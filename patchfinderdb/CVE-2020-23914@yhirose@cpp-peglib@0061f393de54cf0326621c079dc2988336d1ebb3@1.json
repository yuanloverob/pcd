{
  "cve_id": "CVE-2020-23914",
  "cve_desc": "An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service.",
  "repo": "yhirose/cpp-peglib",
  "patch_hash": "0061f393de54cf0326621c079dc2988336d1ebb3",
  "patch_info": {
    "commit_hash": "0061f393de54cf0326621c079dc2988336d1ebb3",
    "repo": "yhirose/cpp-peglib",
    "commit_url": "https://github.com/yhirose/cpp-peglib/commit/0061f393de54cf0326621c079dc2988336d1ebb3",
    "files": [
      "peglib.h",
      "test/test1.cc"
    ],
    "message": "Fix #121",
    "before_after_code_files": [
      "peglib.h||peglib.h",
      "test/test1.cc||test/test1.cc"
    ]
  },
  "patch_diff": {
    "peglib.h||peglib.h": [
      "File: peglib.h -> peglib.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1239:                       public std::enable_shared_from_this<LiteralString> {",
      "1240: public:",
      "1241:   LiteralString(std::string &&s, bool ignore_case)",
      "1245:   LiteralString(const std::string &s, bool ignore_case)",
      "1249:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
      "1250:                     any &dt) const override;",
      "",
      "[Removed Lines]",
      "1242:       : lit_(s), ignore_case_(ignore_case),",
      "1243:         is_word_(false) {}",
      "1246:       : lit_(s), ignore_case_(ignore_case),",
      "1247:         is_word_(false) {}",
      "",
      "[Added Lines]",
      "1242:       : lit_(s), ignore_case_(ignore_case), is_word_(false) {}",
      "1245:       : lit_(s), ignore_case_(ignore_case), is_word_(false) {}",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3438:       }",
      "3439:     }",
      "3442:     for (auto &x : grammar) {",
      "3443:       auto &rule = x.second;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3440:     {",
      "3441:       auto &rule = grammar[data.start];",
      "3442:       if (rule.ignoreSemanticValue) {",
      "3443:         if (log) {",
      "3444:           auto line = line_info(s, rule.s_);",
      "3445:           log(line.first, line.second,",
      "3446:               \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");",
      "3447:         }",
      "3448:         ret = false;",
      "3449:       }",
      "3450:     }",
      "3452:     if (!ret) { return nullptr; }",
      "",
      "---------------"
    ],
    "test/test1.cc||test/test1.cc": [
      "File: test/test1.cc -> test/test1.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "34:     REQUIRE(ret == false);",
      "35: }",
      "37: TEST_CASE(\"Backslash escape sequence test\", \"[general]\")",
      "38: {",
      "39:     parser parser(R\"(",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "37: TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")",
      "38: {",
      "39:     parser parser(R\"(",
      "40:         ~ROOT <- _",
      "41:         _ <- ' '",
      "42:     )\");",
      "44:     bool ret = parser;",
      "45:     REQUIRE(ret == false);",
      "46: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a248d8689e4fcfb2795bed0ef539b07d6768646d",
      "candidate_info": {
        "commit_hash": "a248d8689e4fcfb2795bed0ef539b07d6768646d",
        "repo": "yhirose/cpp-peglib",
        "commit_url": "https://github.com/yhirose/cpp-peglib/commit/a248d8689e4fcfb2795bed0ef539b07d6768646d",
        "files": [
          "peglib.h",
          "test/test2.cc"
        ],
        "message": "Added unreferenced rules check",
        "before_after_code_files": [
          "peglib.h||peglib.h",
          "test/test2.cc||test/test2.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "peglib.h||peglib.h"
          ],
          "candidate": [
            "peglib.h||peglib.h"
          ]
        }
      },
      "candidate_diff": {
        "peglib.h||peglib.h": [
          "File: peglib.h -> peglib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include <sstream>",
          "28: #include <string>",
          "29: #include <unordered_map>",
          "30: #include <vector>",
          "32: #if !defined(__cplusplus) || __cplusplus < 201703L",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include <unordered_set>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "656:   }",
          "658:   void add(const char *token, bool is_literal) {",
          "661:     }",
          "662:     expected_tokens.push_back(std::make_pair(token, is_literal));",
          "663:   }",
          "",
          "[Removed Lines]",
          "659:     for (const auto &x : expected_tokens) {",
          "660:       if (x.first == token && x.second == is_literal) { return; }",
          "",
          "[Added Lines]",
          "660:     for (const auto &[t, l] : expected_tokens) {",
          "661:       if (t == token && l == is_literal) { return; }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "938:     assert(capture_scope_stack.size() >= 2);",
          "939:     auto curr = &capture_scope_stack[capture_scope_stack_size - 1];",
          "940:     auto prev = curr - 1;",
          "943:     }",
          "944:   }",
          "",
          "[Removed Lines]",
          "941:     for (const auto &kv : *curr) {",
          "942:       (*prev)[kv.first] = kv.second;",
          "",
          "[Added Lines]",
          "942:     for (const auto &[k, v] : *curr) {",
          "943:       (*prev)[k] = v;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2001: private:",
          "2002:   void set_error() {",
          "2003:     is_empty = true;",
          "2006:   }",
          "2007:   std::list<std::pair<const char *, std::string>> &refs_;",
          "2008: };",
          "",
          "[Removed Lines]",
          "2004:     error_s = refs_.back().first;",
          "2005:     error_name = refs_.back().second;",
          "",
          "[Added Lines]",
          "2005:     tie(error_s, error_name) = refs_.back();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2090:   std::unordered_map<std::string, const char *> error_s;",
          "2091:   std::unordered_map<std::string, std::string> error_message;",
          "2093: private:",
          "2094:   const Grammar &grammar_;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2092:   std::unordered_set<std::string> referenced;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2943:     error_s[ope.name_] = ope.s_;",
          "2944:     error_message[ope.name_] = \"'\" + ope.name_ + \"' is not defined.\";",
          "2945:   } else {",
          "2946:     const auto &rule = grammar_.at(ope.name_);",
          "2947:     if (rule.is_macro) {",
          "2948:       if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2947:     if (!referenced.count(ope.name_)) { referenced.insert(ope.name_); }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3598:     }",
          "3603:       auto ignore = false;",
          "3604:       if (!name.empty() && name[0] == '~') {",
          "3605:         ignore = true;",
          "",
          "[Removed Lines]",
          "3601:     for (const auto &x : rules) {",
          "3602:       auto name = x.first;",
          "",
          "[Added Lines]",
          "3603:     for (auto [user_name, user_rule] : rules) {",
          "3604:       auto name = user_name;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3607:       }",
          "3608:       if (!name.empty()) {",
          "3609:         auto &rule = grammar[name];",
          "3611:         rule.name = name;",
          "3612:         rule.ignoreSemanticValue = ignore;",
          "3613:       }",
          "",
          "[Removed Lines]",
          "3610:         rule <= x.second;",
          "",
          "[Added Lines]",
          "3612:         rule <= user_rule;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3617:     auto ret = data.duplicates.empty();",
          "3620:       if (log) {",
          "3623:         auto line = line_info(s, ptr);",
          "3624:         log(line.first, line.second, \"'\" + name + \"' is already defined.\");",
          "3625:       }",
          "3626:     }",
          "3629:     {",
          "3632:         if (log) {",
          "3634:           log(line.first, line.second,",
          "3636:         }",
          "3637:         ret = false;",
          "3638:       }",
          "",
          "[Removed Lines]",
          "3619:     for (const auto &x : data.duplicates) {",
          "3621:         const auto &name = x.first;",
          "3622:         auto ptr = x.second;",
          "3630:       auto &rule = grammar[data.start];",
          "3631:       if (rule.ignoreSemanticValue) {",
          "3633:           auto line = line_info(s, rule.s_);",
          "3635:               \"Ignore operator cannot be applied to '\" + rule.name + \"'.\");",
          "",
          "[Added Lines]",
          "3621:     for (const auto &[name, ptr] : data.duplicates) {",
          "3629:     auto &start_rule = grammar[data.start];",
          "3633:       if (start_rule.ignoreSemanticValue) {",
          "3635:           auto line = line_info(s, start_rule.s_);",
          "3637:               \"Ignore operator cannot be applied to '\" + start_rule.name +",
          "3638:                   \"'.\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3641:     if (!ret) { return nullptr; }",
          "3647:       ReferenceChecker vis(grammar, rule.params);",
          "3648:       rule.accept(vis);",
          "3652:         if (log) {",
          "3653:           auto line = line_info(s, ptr);",
          "3654:           log(line.first, line.second, vis.error_message[name]);",
          "",
          "[Removed Lines]",
          "3644:     for (auto &x : grammar) {",
          "3645:       auto &rule = x.second;",
          "3649:       for (const auto &y : vis.error_s) {",
          "3650:         const auto &name = y.first;",
          "3651:         const auto ptr = y.second;",
          "",
          "[Added Lines]",
          "3647:     auto referenced = std::unordered_set<std::string>{",
          "3648:         WHITESPACE_DEFINITION_NAME,",
          "3649:         WORD_DEFINITION_NAME,",
          "3650:         RECOVER_DEFINITION_NAME,",
          "3651:         start_rule.name,",
          "3652:     };",
          "3654:     for (auto &[_, rule] : grammar) {",
          "3657:       referenced.insert(vis.referenced.begin(), vis.referenced.end());",
          "3658:       for (const auto &[name, ptr] : vis.error_s) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3657:       }",
          "3658:     }",
          "3660:     if (!ret) { return nullptr; }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3667:     for (auto &[name, rule] : grammar) {",
          "3668:       if (!referenced.count(name)) {",
          "3669:         if (log) {",
          "3670:           auto line = line_info(s, rule.s_);",
          "3671:           auto msg = \"'\" + name + \"' is not referenced.\";",
          "3672:           log(line.first, line.second, msg);",
          "3673:         }",
          "3674:         ret = false;",
          "3675:       }",
          "3676:     }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3670:     ret = true;",
          "3676:       DetectLeftRecursion vis(name);",
          "3677:       rule.accept(vis);",
          "3678:       if (vis.error_s) {",
          "",
          "[Removed Lines]",
          "3672:     for (auto &x : grammar) {",
          "3673:       const auto &name = x.first;",
          "3674:       auto &rule = x.second;",
          "",
          "[Added Lines]",
          "3690:     for (auto &[name, rule] : grammar) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3687:     if (!ret) { return nullptr; }",
          "3693:     for (auto &[name, rule] : grammar) {",
          "3694:       DetectInfiniteLoop vis(rule.s_, name);",
          "",
          "[Removed Lines]",
          "3690:     auto &start_rule = grammar[data.start];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "3721:     }",
          "3727:       auto &rule = grammar[name];",
          "3729:       if (instruction.type == \"precedence\") {",
          "",
          "[Removed Lines]",
          "3724:     for (const auto &item : data.instructions) {",
          "3725:       const auto &name = item.first;",
          "3726:       const auto &instruction = item.second;",
          "",
          "[Added Lines]",
          "3736:     for (const auto &[name, instruction] : data.instructions) {",
          "",
          "---------------"
        ],
        "test/test2.cc||test/test2.cc": [
          "File: test/test2.cc -> test/test2.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "1036:         A    <- B(C)",
          "1037:         B(D) <- D",
          "1038:         C    <- 'c'",
          "1040:  )\");",
          "1042:   REQUIRE(parser.parse(\"c\"));",
          "1043: }",
          "1045: TEST_CASE(\"Nested macro call\", \"[macro]\") {",
          "1046:   parser parser(R\"(",
          "1047:         A    <- B(T)",
          "",
          "[Removed Lines]",
          "1039:         D    <- 'd'",
          "",
          "[Added Lines]",
          "1044: TEST_CASE(\"Unreferenced rule\", \"[macro]\") {",
          "1045:   parser parser(R\"(",
          "1046:         A    <- B(C)",
          "1047:         B(D) <- D",
          "1048:         C    <- 'c'",
          "1049:         D    <- 'd'",
          "1050:  )\");",
          "1052:   bool ret = parser;",
          "1053:   REQUIRE(ret == false);",
          "1054: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b0c4aa1441239c84e0377f3112750e4c47731d46",
      "candidate_info": {
        "commit_hash": "b0c4aa1441239c84e0377f3112750e4c47731d46",
        "repo": "yhirose/cpp-peglib",
        "commit_url": "https://github.com/yhirose/cpp-peglib/commit/b0c4aa1441239c84e0377f3112750e4c47731d46",
        "files": [
          ".clang-format",
          "peglib.h"
        ],
        "message": "Apply clang-format",
        "before_after_code_files": [
          "peglib.h||peglib.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "peglib.h||peglib.h"
          ],
          "candidate": [
            "peglib.h||peglib.h"
          ]
        }
      },
      "candidate_diff": {
        "peglib.h||peglib.h": [
          "File: peglib.h -> peglib.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #endif // PEGLIB_USE_STD_ANY",
          "19: #include <algorithm>",
          "21: #include <cassert>",
          "22: #include <cstring>",
          "23: #include <functional>",
          "24: #include <initializer_list>",
          "",
          "[Removed Lines]",
          "20: #include <cctype>",
          "",
          "[Added Lines]",
          "21: #include <cctype>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56: template <typename T, typename... Args>",
          "59: }",
          "60: #else",
          "63: public:",
          "83:     }",
          "94:     }",
          "110: private:",
          "130: };",
          "143: }",
          "159: }",
          "165: #endif",
          "196: private:",
          "203: };",
          "205: template <typename EF>",
          "208: }",
          "",
          "[Removed Lines]",
          "57: auto any_cast( Args&&... args ) -> decltype(std::any_cast<T>(std::forward<Args>( args )... )) {",
          "58:   return std::any_cast<T>( std::forward<Args>( args )... );",
          "61: class any",
          "62: {",
          "64:     any() = default;",
          "66:     any(const any& rhs) : content_(rhs.clone()) {}",
          "68:     any(any&& rhs) : content_(rhs.content_) {",
          "69:         rhs.content_ = nullptr;",
          "70:     }",
          "72:     template <typename T>",
          "73:     any(const T& value) : content_(new holder<T>(value)) {}",
          "75:     any& operator=(const any& rhs) {",
          "76:         if (this != &rhs) {",
          "77:             if (content_) {",
          "78:                 delete content_;",
          "79:             }",
          "80:             content_ = rhs.clone();",
          "81:         }",
          "82:         return *this;",
          "85:     any& operator=(any&& rhs) {",
          "86:         if (this != &rhs) {",
          "87:             if (content_) {",
          "88:                 delete content_;",
          "89:             }",
          "90:             content_ = rhs.content_;",
          "91:             rhs.content_ = nullptr;",
          "92:         }",
          "93:         return *this;",
          "96:     ~any() {",
          "97:         delete content_;",
          "98:     }",
          "100:     bool has_value() const {",
          "101:         return content_ != nullptr;",
          "102:     }",
          "104:     template <typename T>",
          "105:     friend T& any_cast(any& val);",
          "107:     template <typename T>",
          "108:     friend const T& any_cast(const any& val);",
          "111:     struct placeholder {",
          "112:         virtual ~placeholder() {}",
          "113:         virtual placeholder* clone() const = 0;",
          "114:     };",
          "116:     template <typename T>",
          "117:     struct holder : placeholder {",
          "118:         holder(const T& value) : value_(value) {}",
          "119:         placeholder* clone() const override {",
          "120:             return new holder(value_);",
          "121:         }",
          "122:         T value_;",
          "123:     };",
          "125:     placeholder* clone() const {",
          "126:         return content_ ? content_->clone() : nullptr;",
          "127:     }",
          "129:     placeholder* content_ = nullptr;",
          "132: template <typename T>",
          "133: T& any_cast(any& val) {",
          "134:     if (!val.content_) {",
          "135:         throw std::bad_cast();",
          "136:     }",
          "137:     auto p = dynamic_cast<any::holder<T>*>(val.content_);",
          "138:     assert(p);",
          "139:     if (!p) {",
          "140:         throw std::bad_cast();",
          "141:     }",
          "142:     return p->value_;",
          "145: template <>",
          "146: any& any_cast<any>(any& val) {",
          "147:     return val;",
          "148: }",
          "150: template <typename T>",
          "151: const T& any_cast(const any& val) {",
          "152:     assert(val.content_);",
          "153:     auto p = dynamic_cast<any::holder<T>*>(val.content_);",
          "154:     assert(p);",
          "155:     if (!p) {",
          "156:         throw std::bad_cast();",
          "157:     }",
          "158:     return p->value_;",
          "161: template <>",
          "162: const any& any_cast<any>(const any& val) {",
          "163:     return val;",
          "164: }",
          "173: template <typename EF>",
          "174: struct scope_exit",
          "175: {",
          "176:     explicit scope_exit(EF&& f)",
          "177:         : exit_function(std::move(f))",
          "178:         , execute_on_destruction{true} {}",
          "180:     scope_exit(scope_exit&& rhs)",
          "181:         : exit_function(std::move(rhs.exit_function))",
          "182:         , execute_on_destruction{rhs.execute_on_destruction} {",
          "183:             rhs.release();",
          "184:     }",
          "186:     ~scope_exit() {",
          "187:         if (execute_on_destruction) {",
          "188:             this->exit_function();",
          "189:         }",
          "190:     }",
          "192:     void release() {",
          "193:         this->execute_on_destruction = false;",
          "194:     }",
          "197:     scope_exit(const scope_exit&) = delete;",
          "198:     void operator=(const scope_exit&) = delete;",
          "199:     scope_exit& operator=(scope_exit&&) = delete;",
          "201:     EF   exit_function;",
          "202:     bool execute_on_destruction;",
          "206: auto make_scope_exit(EF&& exit_function) -> scope_exit<EF> {",
          "207:     return scope_exit<typename std::remove_reference<EF>::type>(std::forward<EF>(exit_function));",
          "",
          "[Added Lines]",
          "57: auto any_cast(Args &&... args)",
          "58:     -> decltype(std::any_cast<T>(std::forward<Args>(args)...)) {",
          "59:   return std::any_cast<T>(std::forward<Args>(args)...);",
          "62: class any {",
          "64:   any() = default;",
          "66:   any(const any &rhs) : content_(rhs.clone()) {}",
          "68:   any(any &&rhs) : content_(rhs.content_) { rhs.content_ = nullptr; }",
          "70:   template <typename T> any(const T &value) : content_(new holder<T>(value)) {}",
          "72:   any &operator=(const any &rhs) {",
          "73:     if (this != &rhs) {",
          "74:       if (content_) { delete content_; }",
          "75:       content_ = rhs.clone();",
          "77:     return *this;",
          "78:   }",
          "80:   any &operator=(any &&rhs) {",
          "81:     if (this != &rhs) {",
          "82:       if (content_) { delete content_; }",
          "83:       content_ = rhs.content_;",
          "84:       rhs.content_ = nullptr;",
          "86:     return *this;",
          "87:   }",
          "89:   ~any() { delete content_; }",
          "91:   bool has_value() const { return content_ != nullptr; }",
          "93:   template <typename T> friend T &any_cast(any &val);",
          "95:   template <typename T> friend const T &any_cast(const any &val);",
          "98:   struct placeholder {",
          "99:     virtual ~placeholder() {}",
          "100:     virtual placeholder *clone() const = 0;",
          "101:   };",
          "103:   template <typename T> struct holder : placeholder {",
          "104:     holder(const T &value) : value_(value) {}",
          "105:     placeholder *clone() const override { return new holder(value_); }",
          "106:     T value_;",
          "107:   };",
          "109:   placeholder *clone() const { return content_ ? content_->clone() : nullptr; }",
          "111:   placeholder *content_ = nullptr;",
          "114: template <typename T> T &any_cast(any &val) {",
          "115:   if (!val.content_) { throw std::bad_cast(); }",
          "116:   auto p = dynamic_cast<any::holder<T> *>(val.content_);",
          "117:   assert(p);",
          "118:   if (!p) { throw std::bad_cast(); }",
          "119:   return p->value_;",
          "122: template <> any &any_cast<any>(any &val) { return val; }",
          "124: template <typename T> const T &any_cast(const any &val) {",
          "125:   assert(val.content_);",
          "126:   auto p = dynamic_cast<any::holder<T> *>(val.content_);",
          "127:   assert(p);",
          "128:   if (!p) { throw std::bad_cast(); }",
          "129:   return p->value_;",
          "132: template <> const any &any_cast<any>(const any &val) { return val; }",
          "142: template <typename EF> struct scope_exit {",
          "143:   explicit scope_exit(EF &&f)",
          "144:       : exit_function(std::move(f)), execute_on_destruction{true} {}",
          "146:   scope_exit(scope_exit &&rhs)",
          "147:       : exit_function(std::move(rhs.exit_function)),",
          "148:         execute_on_destruction{rhs.execute_on_destruction} {",
          "149:     rhs.release();",
          "150:   }",
          "152:   ~scope_exit() {",
          "153:     if (execute_on_destruction) { this->exit_function(); }",
          "154:   }",
          "156:   void release() { this->execute_on_destruction = false; }",
          "159:   scope_exit(const scope_exit &) = delete;",
          "160:   void operator=(const scope_exit &) = delete;",
          "161:   scope_exit &operator=(scope_exit &&) = delete;",
          "163:   EF exit_function;",
          "164:   bool execute_on_destruction;",
          "168: auto make_scope_exit(EF &&exit_function) -> scope_exit<EF> {",
          "169:   return scope_exit<typename std::remove_reference<EF>::type>(",
          "170:       std::forward<EF>(exit_function));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "304: inline size_t decode_codepoint(const char *s8, size_t l, char32_t &out) {",
          "305:   size_t bytes;",
          "309:   return 0;",
          "310: }",
          "",
          "[Removed Lines]",
          "306:   if (decode_codepoint(s8, l, bytes, out)) {",
          "307:     return bytes;",
          "308:   }",
          "",
          "[Added Lines]",
          "269:   if (decode_codepoint(s8, l, bytes, out)) { return bytes; }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "347: }",
          "355: }",
          "365: }",
          "375: }",
          "416:     }",
          "418: }",
          "",
          "[Removed Lines]",
          "335: inline bool is_hex(char c, int& v) {",
          "336:     if ('0' <= c && c <= '9') {",
          "337:         v = c - '0';",
          "338:         return true;",
          "339:     } else if ('a' <= c && c <= 'f') {",
          "340:         v = c - 'a' + 10;",
          "341:         return true;",
          "342:     } else if ('A' <= c && c <= 'F') {",
          "343:         v = c - 'A' + 10;",
          "344:         return true;",
          "345:     }",
          "346:     return false;",
          "349: inline bool is_digit(char c, int& v) {",
          "350:     if ('0' <= c && c <= '9') {",
          "351:         v = c - '0';",
          "352:         return true;",
          "353:     }",
          "354:     return false;",
          "357: inline std::pair<int, size_t> parse_hex_number(const char* s, size_t n, size_t i) {",
          "358:     int ret = 0;",
          "359:     int val;",
          "360:     while (i < n && is_hex(s[i], val)) {",
          "361:         ret = static_cast<int>(ret * 16 + val);",
          "362:         i++;",
          "363:     }",
          "364:     return std::make_pair(ret, i);",
          "367: inline std::pair<int, size_t> parse_octal_number(const char* s, size_t n, size_t i) {",
          "368:     int ret = 0;",
          "369:     int val;",
          "370:     while (i < n && is_digit(s[i], val)) {",
          "371:         ret = static_cast<int>(ret * 8 + val);",
          "372:         i++;",
          "373:     }",
          "374:     return std::make_pair(ret, i);",
          "377: inline std::string resolve_escape_sequence(const char* s, size_t n) {",
          "378:     std::string r;",
          "379:     r.reserve(n);",
          "381:     size_t i = 0;",
          "382:     while (i < n) {",
          "383:         auto ch = s[i];",
          "384:         if (ch == '\\\\') {",
          "385:             i++;",
          "386:             if (i == n) {",
          "387:                 throw std::runtime_error(\"Invalid escape sequence...\");",
          "388:             }",
          "389:             switch (s[i]) {",
          "390:                 case 'n':  r += '\\n'; i++; break;",
          "391:                 case 'r':  r += '\\r'; i++; break;",
          "392:                 case 't':  r += '\\t'; i++; break;",
          "393:                 case '\\'': r += '\\''; i++; break;",
          "394:                 case '\"':  r += '\"';  i++; break;",
          "395:                 case '[':  r += '[';  i++; break;",
          "396:                 case ']':  r += ']';  i++; break;",
          "397:                 case '\\\\': r += '\\\\'; i++; break;",
          "398:                 case 'x':",
          "399:                 case 'u': {",
          "400:                     char32_t cp;",
          "401:                     std::tie(cp, i) = parse_hex_number(s, n, i + 1);",
          "402:                     r += encode_codepoint(cp);",
          "403:                     break;",
          "404:                 }",
          "405:                 default: {",
          "406:                     char32_t cp;",
          "407:                     std::tie(cp, i) = parse_octal_number(s, n, i);",
          "408:                     r += encode_codepoint(cp);",
          "409:                     break;",
          "410:                 }",
          "411:             }",
          "412:         } else {",
          "413:             r += ch;",
          "414:             i++;",
          "415:         }",
          "417:     return r;",
          "",
          "[Added Lines]",
          "296: inline bool is_hex(char c, int &v) {",
          "297:   if ('0' <= c && c <= '9') {",
          "298:     v = c - '0';",
          "299:     return true;",
          "300:   } else if ('a' <= c && c <= 'f') {",
          "301:     v = c - 'a' + 10;",
          "302:     return true;",
          "303:   } else if ('A' <= c && c <= 'F') {",
          "304:     v = c - 'A' + 10;",
          "305:     return true;",
          "306:   }",
          "307:   return false;",
          "310: inline bool is_digit(char c, int &v) {",
          "311:   if ('0' <= c && c <= '9') {",
          "312:     v = c - '0';",
          "313:     return true;",
          "314:   }",
          "315:   return false;",
          "318: inline std::pair<int, size_t> parse_hex_number(const char *s, size_t n,",
          "319:                                                size_t i) {",
          "320:   int ret = 0;",
          "321:   int val;",
          "322:   while (i < n && is_hex(s[i], val)) {",
          "323:     ret = static_cast<int>(ret * 16 + val);",
          "324:     i++;",
          "325:   }",
          "326:   return std::make_pair(ret, i);",
          "329: inline std::pair<int, size_t> parse_octal_number(const char *s, size_t n,",
          "330:                                                  size_t i) {",
          "331:   int ret = 0;",
          "332:   int val;",
          "333:   while (i < n && is_digit(s[i], val)) {",
          "334:     ret = static_cast<int>(ret * 8 + val);",
          "335:     i++;",
          "336:   }",
          "337:   return std::make_pair(ret, i);",
          "340: inline std::string resolve_escape_sequence(const char *s, size_t n) {",
          "341:   std::string r;",
          "342:   r.reserve(n);",
          "344:   size_t i = 0;",
          "345:   while (i < n) {",
          "346:     auto ch = s[i];",
          "347:     if (ch == '\\\\') {",
          "348:       i++;",
          "349:       if (i == n) { throw std::runtime_error(\"Invalid escape sequence...\"); }",
          "350:       switch (s[i]) {",
          "351:       case 'n':",
          "352:         r += '\\n';",
          "353:         i++;",
          "354:         break;",
          "355:       case 'r':",
          "356:         r += '\\r';",
          "357:         i++;",
          "358:         break;",
          "359:       case 't':",
          "360:         r += '\\t';",
          "361:         i++;",
          "362:         break;",
          "363:       case '\\'':",
          "364:         r += '\\'';",
          "365:         i++;",
          "366:         break;",
          "367:       case '\"':",
          "368:         r += '\"';",
          "369:         i++;",
          "370:         break;",
          "371:       case '[':",
          "372:         r += '[';",
          "373:         i++;",
          "374:         break;",
          "375:       case ']':",
          "376:         r += ']';",
          "377:         i++;",
          "378:         break;",
          "379:       case '\\\\':",
          "380:         r += '\\\\';",
          "381:         i++;",
          "382:         break;",
          "383:       case 'x':",
          "384:       case 'u': {",
          "385:         char32_t cp;",
          "386:         std::tie(cp, i) = parse_hex_number(s, n, i + 1);",
          "387:         r += encode_codepoint(cp);",
          "388:         break;",
          "389:       }",
          "390:       default: {",
          "391:         char32_t cp;",
          "392:         std::tie(cp, i) = parse_octal_number(s, n, i);",
          "393:         r += encode_codepoint(cp);",
          "394:         break;",
          "395:       }",
          "396:       }",
          "397:     } else {",
          "398:       r += ch;",
          "399:       i++;",
          "401:   }",
          "402:   return r;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "438:     }",
          "443: }",
          "450: }",
          "452: namespace udl {",
          "456: }",
          "544: private:",
          "563:     }",
          "573:     }",
          "574: };",
          "608: public:",
          "644: private:",
          "748: };",
          "754: struct parse_error {",
          "758: private:",
          "760: };",
          "",
          "[Removed Lines]",
          "427: inline std::pair<size_t, size_t> line_info(const char* start, const char* cur) {",
          "428:     auto p = start;",
          "429:     auto col_ptr = p;",
          "430:     auto no = 1;",
          "432:     while (p < cur) {",
          "433:         if (*p == '\\n') {",
          "434:             no++;",
          "435:             col_ptr = p + 1;",
          "436:         }",
          "437:         p++;",
          "440:     auto col = p - col_ptr + 1;",
          "442:     return std::make_pair(no, col);",
          "448: inline constexpr unsigned int str2tag(const char* str, unsigned int h = 0) {",
          "449:     return (*str == '\\0') ? h : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));",
          "454: inline constexpr unsigned int operator \"\" _(const char* s, size_t) {",
          "455:     return str2tag(s);",
          "458: }",
          "463: struct SemanticValues : protected std::vector<any>",
          "464: {",
          "466:     const char* path = nullptr;",
          "467:     const char* ss = nullptr;",
          "468:     const std::vector<size_t>* source_line_index = nullptr;",
          "471:     const char* c_str() const { return s_; }",
          "472:     size_t      length() const { return n_; }",
          "474:     std::string str() const {",
          "475:         return std::string(s_, n_);",
          "476:     }",
          "479:     const std::string& name() const { return name_; }",
          "481:     std::vector<unsigned int> tags;",
          "484:     std::pair<size_t, size_t> line_info() const {",
          "485:         const auto& idx = *source_line_index;",
          "487:         auto cur = static_cast<size_t>(std::distance(ss, s_));",
          "488:         auto it = std::lower_bound(idx.begin(), idx.end(), cur,",
          "489:             [](size_t element, size_t value) { return element < value; }",
          "490:         );",
          "492:         auto id = static_cast<size_t>(std::distance(idx.begin(), it));",
          "493:         auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);",
          "494:         return std::make_pair(id + 1, off + 1);",
          "495:     }",
          "498:     size_t choice_count() const { return choice_count_; }",
          "501:     size_t choice() const { return choice_; }",
          "504:     std::vector<std::pair<const char*, size_t>> tokens;",
          "506:     std::string token(size_t id = 0) const {",
          "507:         if (!tokens.empty()) {",
          "508:             assert(id < tokens.size());",
          "509:             const auto& tok = tokens[id];",
          "510:             return std::string(tok.first, tok.second);",
          "511:         }",
          "512:         return std::string(s_, n_);",
          "513:     }",
          "516:     template <typename T>",
          "517:     auto transform(size_t beg = 0, size_t end = static_cast<size_t>(-1)) const -> vector<T> {",
          "518:         return this->transform(beg, end, [](const any& v) { return any_cast<T>(v); });",
          "519:     }",
          "521:     using std::vector<any>::iterator;",
          "522:     using std::vector<any>::const_iterator;",
          "523:     using std::vector<any>::size;",
          "524:     using std::vector<any>::empty;",
          "525:     using std::vector<any>::assign;",
          "526:     using std::vector<any>::begin;",
          "527:     using std::vector<any>::end;",
          "528:     using std::vector<any>::rbegin;",
          "529:     using std::vector<any>::rend;",
          "530:     using std::vector<any>::operator[];",
          "531:     using std::vector<any>::at;",
          "532:     using std::vector<any>::resize;",
          "533:     using std::vector<any>::front;",
          "534:     using std::vector<any>::back;",
          "535:     using std::vector<any>::push_back;",
          "536:     using std::vector<any>::pop_back;",
          "537:     using std::vector<any>::insert;",
          "538:     using std::vector<any>::erase;",
          "539:     using std::vector<any>::clear;",
          "540:     using std::vector<any>::swap;",
          "541:     using std::vector<any>::emplace;",
          "542:     using std::vector<any>::emplace_back;",
          "545:     friend class Context;",
          "546:     friend class Sequence;",
          "547:     friend class PrioritizedChoice;",
          "548:     friend class Holder;",
          "550:     const char* s_ = nullptr;",
          "551:     size_t      n_ = 0;",
          "552:     size_t      choice_count_ = 0;",
          "553:     size_t      choice_ = 0;",
          "554:     std::string name_;",
          "556:     template <typename F>",
          "557:     auto transform(F f) const -> vector<typename std::remove_const<decltype(f(any()))>::type> {",
          "558:         vector<typename std::remove_const<decltype(f(any()))>::type> r;",
          "559:         for (const auto& v: *this) {",
          "560:             r.emplace_back(f(v));",
          "561:         }",
          "562:         return r;",
          "565:     template <typename F>",
          "566:     auto transform(size_t beg, size_t end, F f) const -> vector<typename std::remove_const<decltype(f(any()))>::type> {",
          "567:         vector<typename std::remove_const<decltype(f(any()))>::type> r;",
          "568:         end = (std::min)(end, size());",
          "569:         for (size_t i = beg; i < end; i++) {",
          "570:             r.emplace_back(f((*this)[i]));",
          "571:         }",
          "572:         return r;",
          "579: template <",
          "580:     typename R, typename F,",
          "581:     typename std::enable_if<std::is_void<R>::value, std::nullptr_t>::type = nullptr,",
          "582:     typename... Args>",
          "583: any call(F fn, Args&&... args) {",
          "584:     fn(std::forward<Args>(args)...);",
          "585:     return any();",
          "586: }",
          "588: template <",
          "589:     typename R, typename F,",
          "590:     typename std::enable_if<std::is_same<typename std::remove_cv<R>::type, any>::value, std::nullptr_t>::type = nullptr,",
          "591:     typename... Args>",
          "592: any call(F fn, Args&&... args) {",
          "593:     return fn(std::forward<Args>(args)...);",
          "594: }",
          "596: template <",
          "597:     typename R, typename F,",
          "598:     typename std::enable_if<",
          "599:         !std::is_void<R>::value &&",
          "600:         !std::is_same<typename std::remove_cv<R>::type, any>::value, std::nullptr_t>::type = nullptr,",
          "601:     typename... Args>",
          "602: any call(F fn, Args&&... args) {",
          "603:     return any(fn(std::forward<Args>(args)...));",
          "604: }",
          "606: class Action",
          "607: {",
          "609:     Action() = default;",
          "610:     Action(const Action& rhs) = default;",
          "612:     template <typename F, typename std::enable_if<!std::is_pointer<F>::value && !std::is_same<F, std::nullptr_t>::value, std::nullptr_t>::type = nullptr>",
          "613:     Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}",
          "615:     template <typename F, typename std::enable_if<std::is_pointer<F>::value, std::nullptr_t>::type = nullptr>",
          "616:     Action(F fn) : fn_(make_adaptor(fn, fn)) {}",
          "618:     template <typename F, typename std::enable_if<std::is_same<F, std::nullptr_t>::value, std::nullptr_t>::type = nullptr>",
          "619:     Action(F /*fn*/) {}",
          "621:     template <typename F, typename std::enable_if<!std::is_pointer<F>::value && !std::is_same<F, std::nullptr_t>::value, std::nullptr_t>::type = nullptr>",
          "622:     void operator=(F fn) {",
          "623:         fn_ = make_adaptor(fn, &F::operator());",
          "624:     }",
          "626:     template <typename F, typename std::enable_if<std::is_pointer<F>::value, std::nullptr_t>::type = nullptr>",
          "627:     void operator=(F fn) {",
          "628:         fn_ = make_adaptor(fn, fn);",
          "629:     }",
          "631:     template <typename F, typename std::enable_if<std::is_same<F, std::nullptr_t>::value, std::nullptr_t>::type = nullptr>",
          "632:     void operator=(F /*fn*/) {}",
          "634:     Action& operator=(const Action& rhs) = default;",
          "636:     operator bool() const {",
          "637:         return bool(fn_);",
          "638:     }",
          "640:     any operator()(SemanticValues& sv, any& dt) const {",
          "641:         return fn_(sv, dt);",
          "642:     }",
          "645:     template <typename R>",
          "646:     struct TypeAdaptor_sv {",
          "647:         TypeAdaptor_sv(std::function<R (SemanticValues& sv)> fn)",
          "648:             : fn_(fn) {}",
          "649:         any operator()(SemanticValues& sv, any& /*dt*/) {",
          "650:             return call<R>(fn_, sv);",
          "651:         }",
          "652:         std::function<R (SemanticValues& sv)> fn_;",
          "653:     };",
          "655:     template <typename R>",
          "656:     struct TypeAdaptor_csv {",
          "657:         TypeAdaptor_csv(std::function<R (const SemanticValues& sv)> fn)",
          "658:             : fn_(fn) {}",
          "659:         any operator()(SemanticValues& sv, any& /*dt*/) {",
          "660:             return call<R>(fn_, sv);",
          "661:         }",
          "662:         std::function<R (const SemanticValues& sv)> fn_;",
          "663:     };",
          "665:     template <typename R>",
          "666:     struct TypeAdaptor_sv_dt {",
          "667:         TypeAdaptor_sv_dt(std::function<R (SemanticValues& sv, any& dt)> fn)",
          "668:             : fn_(fn) {}",
          "669:         any operator()(SemanticValues& sv, any& dt) {",
          "670:             return call<R>(fn_, sv, dt);",
          "671:         }",
          "672:         std::function<R (SemanticValues& sv, any& dt)> fn_;",
          "673:     };",
          "675:     template <typename R>",
          "676:     struct TypeAdaptor_csv_dt {",
          "677:         TypeAdaptor_csv_dt(std::function<R (const SemanticValues& sv, any& dt)> fn)",
          "678:             : fn_(fn) {}",
          "679:         any operator()(SemanticValues& sv, any& dt) {",
          "680:             return call<R>(fn_, sv, dt);",
          "681:         }",
          "682:         std::function<R (const SemanticValues& sv, any& dt)> fn_;",
          "683:     };",
          "685:     typedef std::function<any (SemanticValues& sv, any& dt)> Fty;",
          "687:     template<typename F, typename R>",
          "688:     Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues& sv) const) {",
          "689:         return TypeAdaptor_sv<R>(fn);",
          "690:     }",
          "692:     template<typename F, typename R>",
          "693:     Fty make_adaptor(F fn, R (F::* /*mf*/)(const SemanticValues& sv) const) {",
          "694:         return TypeAdaptor_csv<R>(fn);",
          "695:     }",
          "697:     template<typename F, typename R>",
          "698:     Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues& sv)) {",
          "699:         return TypeAdaptor_sv<R>(fn);",
          "700:     }",
          "702:     template<typename F, typename R>",
          "703:     Fty make_adaptor(F fn, R (F::* /*mf*/)(const SemanticValues& sv)) {",
          "704:         return TypeAdaptor_csv<R>(fn);",
          "705:     }",
          "707:     template<typename F, typename R>",
          "708:     Fty make_adaptor(F fn, R (* /*mf*/)(SemanticValues& sv)) {",
          "709:         return TypeAdaptor_sv<R>(fn);",
          "710:     }",
          "712:     template<typename F, typename R>",
          "713:     Fty make_adaptor(F fn, R (* /*mf*/)(const SemanticValues& sv)) {",
          "714:         return TypeAdaptor_csv<R>(fn);",
          "715:     }",
          "717:     template<typename F, typename R>",
          "718:     Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues& sv, any& dt) const) {",
          "719:         return TypeAdaptor_sv_dt<R>(fn);",
          "720:     }",
          "722:     template<typename F, typename R>",
          "723:     Fty make_adaptor(F fn, R (F::* /*mf*/)(const SemanticValues& sv, any& dt) const) {",
          "724:         return TypeAdaptor_csv_dt<R>(fn);",
          "725:     }",
          "727:     template<typename F, typename R>",
          "728:     Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues& sv, any& dt)) {",
          "729:         return TypeAdaptor_sv_dt<R>(fn);",
          "730:     }",
          "732:     template<typename F, typename R>",
          "733:     Fty make_adaptor(F fn, R (F::* /*mf*/)(const SemanticValues& sv, any& dt)) {",
          "734:         return TypeAdaptor_csv_dt<R>(fn);",
          "735:     }",
          "737:     template<typename F, typename R>",
          "738:     Fty make_adaptor(F fn, R(* /*mf*/)(SemanticValues& sv, any& dt)) {",
          "739:         return TypeAdaptor_sv_dt<R>(fn);",
          "740:     }",
          "742:     template<typename F, typename R>",
          "743:     Fty make_adaptor(F fn, R(* /*mf*/)(const SemanticValues& sv, any& dt)) {",
          "744:         return TypeAdaptor_csv_dt<R>(fn);",
          "745:     }",
          "747:     Fty fn_;",
          "755:     parse_error() = default;",
          "756:     parse_error(const char* s) : s_(s) {}",
          "757:     const char* what() const { return s_.empty() ? nullptr : s_.c_str(); }",
          "759:     std::string s_;",
          "765: inline bool success(size_t len) {",
          "766:     return len != static_cast<size_t>(-1);",
          "767: }",
          "769: inline bool fail(size_t len) {",
          "770:     return len == static_cast<size_t>(-1);",
          "771: }",
          "",
          "[Added Lines]",
          "412: inline std::pair<size_t, size_t> line_info(const char *start, const char *cur) {",
          "413:   auto p = start;",
          "414:   auto col_ptr = p;",
          "415:   auto no = 1;",
          "417:   while (p < cur) {",
          "418:     if (*p == '\\n') {",
          "419:       no++;",
          "420:       col_ptr = p + 1;",
          "422:     p++;",
          "423:   }",
          "425:   auto col = p - col_ptr + 1;",
          "427:   return std::make_pair(no, col);",
          "433: inline constexpr unsigned int str2tag(const char *str, unsigned int h = 0) {",
          "434:   return (*str == '\\0')",
          "435:              ? h",
          "436:              : str2tag(str + 1, (h * 33) ^ static_cast<unsigned char>(*str));",
          "441: inline constexpr unsigned int operator\"\" _(const char *s, size_t) {",
          "442:   return str2tag(s);",
          "445: } // namespace udl",
          "450: struct SemanticValues : protected std::vector<any> {",
          "452:   const char *path = nullptr;",
          "453:   const char *ss = nullptr;",
          "454:   const std::vector<size_t> *source_line_index = nullptr;",
          "457:   const char *c_str() const { return s_; }",
          "458:   size_t length() const { return n_; }",
          "460:   std::string str() const { return std::string(s_, n_); }",
          "463:   const std::string &name() const { return name_; }",
          "465:   std::vector<unsigned int> tags;",
          "468:   std::pair<size_t, size_t> line_info() const {",
          "469:     const auto &idx = *source_line_index;",
          "471:     auto cur = static_cast<size_t>(std::distance(ss, s_));",
          "472:     auto it = std::lower_bound(",
          "473:         idx.begin(), idx.end(), cur,",
          "474:         [](size_t element, size_t value) { return element < value; });",
          "476:     auto id = static_cast<size_t>(std::distance(idx.begin(), it));",
          "477:     auto off = cur - (id == 0 ? 0 : idx[id - 1] + 1);",
          "478:     return std::make_pair(id + 1, off + 1);",
          "479:   }",
          "482:   size_t choice_count() const { return choice_count_; }",
          "485:   size_t choice() const { return choice_; }",
          "488:   std::vector<std::pair<const char *, size_t>> tokens;",
          "490:   std::string token(size_t id = 0) const {",
          "491:     if (!tokens.empty()) {",
          "492:       assert(id < tokens.size());",
          "493:       const auto &tok = tokens[id];",
          "494:       return std::string(tok.first, tok.second);",
          "495:     }",
          "496:     return std::string(s_, n_);",
          "497:   }",
          "500:   template <typename T>",
          "501:   auto transform(size_t beg = 0, size_t end = static_cast<size_t>(-1)) const",
          "502:       -> vector<T> {",
          "503:     return this->transform(beg, end,",
          "504:                            [](const any &v) { return any_cast<T>(v); });",
          "505:   }",
          "507:   using std::vector<any>::iterator;",
          "508:   using std::vector<any>::const_iterator;",
          "509:   using std::vector<any>::size;",
          "510:   using std::vector<any>::empty;",
          "511:   using std::vector<any>::assign;",
          "512:   using std::vector<any>::begin;",
          "513:   using std::vector<any>::end;",
          "514:   using std::vector<any>::rbegin;",
          "515:   using std::vector<any>::rend;",
          "516:   using std::vector<any>::operator[];",
          "517:   using std::vector<any>::at;",
          "518:   using std::vector<any>::resize;",
          "519:   using std::vector<any>::front;",
          "520:   using std::vector<any>::back;",
          "521:   using std::vector<any>::push_back;",
          "522:   using std::vector<any>::pop_back;",
          "523:   using std::vector<any>::insert;",
          "524:   using std::vector<any>::erase;",
          "525:   using std::vector<any>::clear;",
          "526:   using std::vector<any>::swap;",
          "527:   using std::vector<any>::emplace;",
          "528:   using std::vector<any>::emplace_back;",
          "531:   friend class Context;",
          "532:   friend class Sequence;",
          "533:   friend class PrioritizedChoice;",
          "534:   friend class Holder;",
          "536:   const char *s_ = nullptr;",
          "537:   size_t n_ = 0;",
          "538:   size_t choice_count_ = 0;",
          "539:   size_t choice_ = 0;",
          "540:   std::string name_;",
          "542:   template <typename F>",
          "543:   auto transform(F f) const",
          "544:       -> vector<typename std::remove_const<decltype(f(any()))>::type> {",
          "545:     vector<typename std::remove_const<decltype(f(any()))>::type> r;",
          "546:     for (const auto &v : *this) {",
          "547:       r.emplace_back(f(v));",
          "549:     return r;",
          "550:   }",
          "552:   template <typename F>",
          "553:   auto transform(size_t beg, size_t end, F f) const",
          "554:       -> vector<typename std::remove_const<decltype(f(any()))>::type> {",
          "555:     vector<typename std::remove_const<decltype(f(any()))>::type> r;",
          "556:     end = (std::min)(end, size());",
          "557:     for (size_t i = beg; i < end; i++) {",
          "558:       r.emplace_back(f((*this)[i]));",
          "560:     return r;",
          "561:   }",
          "567: template <typename R, typename F,",
          "568:           typename std::enable_if<std::is_void<R>::value,",
          "569:                                   std::nullptr_t>::type = nullptr,",
          "570:           typename... Args>",
          "571: any call(F fn, Args &&... args) {",
          "572:   fn(std::forward<Args>(args)...);",
          "573:   return any();",
          "574: }",
          "576: template <typename R, typename F,",
          "577:           typename std::enable_if<",
          "578:               std::is_same<typename std::remove_cv<R>::type, any>::value,",
          "579:               std::nullptr_t>::type = nullptr,",
          "580:           typename... Args>",
          "581: any call(F fn, Args &&... args) {",
          "582:   return fn(std::forward<Args>(args)...);",
          "583: }",
          "585: template <typename R, typename F,",
          "586:           typename std::enable_if<",
          "587:               !std::is_void<R>::value &&",
          "588:                   !std::is_same<typename std::remove_cv<R>::type, any>::value,",
          "589:               std::nullptr_t>::type = nullptr,",
          "590:           typename... Args>",
          "591: any call(F fn, Args &&... args) {",
          "592:   return any(fn(std::forward<Args>(args)...));",
          "593: }",
          "595: class Action {",
          "597:   Action() = default;",
          "598:   Action(const Action &rhs) = default;",
          "600:   template <typename F,",
          "601:             typename std::enable_if<!std::is_pointer<F>::value &&",
          "602:                                         !std::is_same<F, std::nullptr_t>::value,",
          "603:                                     std::nullptr_t>::type = nullptr>",
          "604:   Action(F fn) : fn_(make_adaptor(fn, &F::operator())) {}",
          "606:   template <typename F, typename std::enable_if<std::is_pointer<F>::value,",
          "607:                                                 std::nullptr_t>::type = nullptr>",
          "608:   Action(F fn) : fn_(make_adaptor(fn, fn)) {}",
          "610:   template <typename F,",
          "611:             typename std::enable_if<std::is_same<F, std::nullptr_t>::value,",
          "612:                                     std::nullptr_t>::type = nullptr>",
          "613:   Action(F /*fn*/) {}",
          "615:   template <typename F,",
          "616:             typename std::enable_if<!std::is_pointer<F>::value &&",
          "617:                                         !std::is_same<F, std::nullptr_t>::value,",
          "618:                                     std::nullptr_t>::type = nullptr>",
          "619:   void operator=(F fn) {",
          "620:     fn_ = make_adaptor(fn, &F::operator());",
          "621:   }",
          "623:   template <typename F, typename std::enable_if<std::is_pointer<F>::value,",
          "624:                                                 std::nullptr_t>::type = nullptr>",
          "625:   void operator=(F fn) {",
          "626:     fn_ = make_adaptor(fn, fn);",
          "627:   }",
          "629:   template <typename F,",
          "630:             typename std::enable_if<std::is_same<F, std::nullptr_t>::value,",
          "631:                                     std::nullptr_t>::type = nullptr>",
          "632:   void operator=(F /*fn*/) {}",
          "634:   Action &operator=(const Action &rhs) = default;",
          "636:   operator bool() const { return bool(fn_); }",
          "638:   any operator()(SemanticValues &sv, any &dt) const { return fn_(sv, dt); }",
          "641:   template <typename R> struct TypeAdaptor_sv {",
          "642:     TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {}",
          "643:     any operator()(SemanticValues &sv, any & /*dt*/) {",
          "644:       return call<R>(fn_, sv);",
          "645:     }",
          "646:     std::function<R(SemanticValues &sv)> fn_;",
          "647:   };",
          "649:   template <typename R> struct TypeAdaptor_csv {",
          "650:     TypeAdaptor_csv(std::function<R(const SemanticValues &sv)> fn) : fn_(fn) {}",
          "651:     any operator()(SemanticValues &sv, any & /*dt*/) {",
          "652:       return call<R>(fn_, sv);",
          "653:     }",
          "654:     std::function<R(const SemanticValues &sv)> fn_;",
          "655:   };",
          "657:   template <typename R> struct TypeAdaptor_sv_dt {",
          "658:     TypeAdaptor_sv_dt(std::function<R(SemanticValues &sv, any &dt)> fn)",
          "659:         : fn_(fn) {}",
          "660:     any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }",
          "661:     std::function<R(SemanticValues &sv, any &dt)> fn_;",
          "662:   };",
          "664:   template <typename R> struct TypeAdaptor_csv_dt {",
          "665:     TypeAdaptor_csv_dt(std::function<R(const SemanticValues &sv, any &dt)> fn)",
          "666:         : fn_(fn) {}",
          "667:     any operator()(SemanticValues &sv, any &dt) { return call<R>(fn_, sv, dt); }",
          "668:     std::function<R(const SemanticValues &sv, any &dt)> fn_;",
          "669:   };",
          "671:   typedef std::function<any(SemanticValues &sv, any &dt)> Fty;",
          "673:   template <typename F, typename R>",
          "674:   Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues &sv) const) {",
          "675:     return TypeAdaptor_sv<R>(fn);",
          "676:   }",
          "678:   template <typename F, typename R>",
          "679:   Fty make_adaptor(F fn, R (F::* /*mf*/)(const SemanticValues &sv) const) {",
          "680:     return TypeAdaptor_csv<R>(fn);",
          "681:   }",
          "683:   template <typename F, typename R>",
          "684:   Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues &sv)) {",
          "685:     return TypeAdaptor_sv<R>(fn);",
          "686:   }",
          "688:   template <typename F, typename R>",
          "689:   Fty make_adaptor(F fn, R (F::* /*mf*/)(const SemanticValues &sv)) {",
          "690:     return TypeAdaptor_csv<R>(fn);",
          "691:   }",
          "693:   template <typename F, typename R>",
          "694:   Fty make_adaptor(F fn, R (*/*mf*/)(SemanticValues &sv)) {",
          "695:     return TypeAdaptor_sv<R>(fn);",
          "696:   }",
          "698:   template <typename F, typename R>",
          "699:   Fty make_adaptor(F fn, R (*/*mf*/)(const SemanticValues &sv)) {",
          "700:     return TypeAdaptor_csv<R>(fn);",
          "701:   }",
          "703:   template <typename F, typename R>",
          "704:   Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues &sv, any &dt) const) {",
          "705:     return TypeAdaptor_sv_dt<R>(fn);",
          "706:   }",
          "708:   template <typename F, typename R>",
          "709:   Fty make_adaptor(F fn,",
          "710:                    R (F::* /*mf*/)(const SemanticValues &sv, any &dt) const) {",
          "711:     return TypeAdaptor_csv_dt<R>(fn);",
          "712:   }",
          "714:   template <typename F, typename R>",
          "715:   Fty make_adaptor(F fn, R (F::* /*mf*/)(SemanticValues &sv, any &dt)) {",
          "716:     return TypeAdaptor_sv_dt<R>(fn);",
          "717:   }",
          "719:   template <typename F, typename R>",
          "720:   Fty make_adaptor(F fn, R (F::* /*mf*/)(const SemanticValues &sv, any &dt)) {",
          "721:     return TypeAdaptor_csv_dt<R>(fn);",
          "722:   }",
          "724:   template <typename F, typename R>",
          "725:   Fty make_adaptor(F fn, R (*/*mf*/)(SemanticValues &sv, any &dt)) {",
          "726:     return TypeAdaptor_sv_dt<R>(fn);",
          "727:   }",
          "729:   template <typename F, typename R>",
          "730:   Fty make_adaptor(F fn, R (*/*mf*/)(const SemanticValues &sv, any &dt)) {",
          "731:     return TypeAdaptor_csv_dt<R>(fn);",
          "732:   }",
          "734:   Fty fn_;",
          "743:   parse_error() = default;",
          "744:   parse_error(const char *s) : s_(s) {}",
          "745:   const char *what() const { return s_.empty() ? nullptr : s_.c_str(); }",
          "748:   std::string s_;",
          "754: inline bool success(size_t len) { return len != static_cast<size_t>(-1); }",
          "756: inline bool fail(size_t len) { return len == static_cast<size_t>(-1); }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "777: class Ope;",
          "778: class Definition;",
          "786: public:",
          "927:     }",
          "942:     }",
          "946:     }",
          "955:     }",
          "959:     }",
          "967: };",
          "974: public:",
          "981: };",
          "985: public:",
          "1003:         if (!chldsv.empty()) {",
          "1007:         }",
          "1008:         if (!chldsv.tags.empty()) {",
          "1012:         }",
          "1013:         sv.s_ = chldsv.c_str();",
          "1014:         sv.n_ = chldsv.length();",
          "1015:         if (!chldsv.tokens.empty()) {",
          "1019:         }",
          "1074:     }",
          "1081: };",
          "1085: public:",
          "1116:     }",
          "1121: };",
          "1125: public:",
          "1170:     }",
          "1175: };",
          "1179: public:",
          "1206:     }",
          "1211: };",
          "1215: public:",
          "1232:     }",
          "1237: };",
          "1241: public:",
          "1261:     }",
          "1266: };",
          "1271: public:",
          "1287: };",
          "1292: public:",
          "1309:     }",
          "1313:     }",
          "1335:         if (negated_) {",
          "1337:         } else {",
          "1340:         }",
          "1341:     }",
          "1347: };",
          "1352: public:",
          "1361:     }",
          "1366: };",
          "1371: public:",
          "1379:     }",
          "1382: };",
          "1386: public:",
          "1403: };",
          "1407: public:",
          "1426: };",
          "1430: public:",
          "1438: };",
          "1442: public:",
          "1457: };",
          "1463: public:",
          "1471: };",
          "1475: public:",
          "1488: };",
          "1492: public:",
          "1509: };",
          "1511: typedef std::unordered_map<std::string, Definition> Grammar;",
          "1516: public:",
          "1547: };",
          "1551: public:",
          "1567: };",
          "1571: public:",
          "1579: };",
          "1587: }",
          "1592: }",
          "1596: }",
          "1600: }",
          "1604: }",
          "1608: }",
          "1612: }",
          "1616: }",
          "1620: }",
          "1624: }",
          "1628: }",
          "1632: }",
          "1636: }",
          "1638: inline std::shared_ptr<Ope> chr(char dt) {",
          "1640: }",
          "1648: }",
          "1652: }",
          "1656: }",
          "1660: }",
          "1664: }",
          "1668: }",
          "1672: }",
          "1676: }",
          "1705: };",
          "1713: };",
          "1744: };",
          "1752:     }",
          "1757:     }",
          "1773: };",
          "1784:     }",
          "1796: private:",
          "1798: };",
          "1811:     }",
          "1831:     }",
          "1833: private:",
          "1836: };",
          "1838: struct DetectLeftRecursion : public Ope::Visitor {",
          "1851:     }",
          "1860:     }",
          "1883: private:",
          "1887: };",
          "1915:     }",
          "1934: private:",
          "1941: };",
          "1954:     }",
          "1960:     }",
          "1969:     }",
          "1978:     }",
          "1995: private:",
          "1997: };",
          "1999: struct ReferenceChecker : public Ope::Visitor {",
          "2009:     }",
          "2014:     }",
          "2032: private:",
          "2035: };",
          "2037: struct LinkReferences : public Ope::Visitor {",
          "2047:     }",
          "2052:     }",
          "2067: private:",
          "2070: };",
          "2072: struct FindReference : public Ope::Visitor {",
          "2085:     }",
          "2114: private:",
          "2117: };",
          "2131: private:",
          "2133: };",
          "2146: public:",
          "2210:     }",
          "2226:     }",
          "2280: private:",
          "2325: };",
          "2340:     }",
          "2353:     }",
          "2373:     }",
          "2376: }",
          "2381: }",
          "2386: }",
          "2395: }",
          "2407: }",
          "2411: }",
          "2428:     }",
          "2430: }",
          "2486:     });",
          "2488:     if (success(len)) {",
          "2499:         }",
          "2500:     }",
          "2503: }",
          "2513: }",
          "2520: }",
          "2546:     } else {",
          "2551: }",
          "2553: inline std::shared_ptr<Ope> Reference::get_core_operator() const {",
          "2601: }",
          "2609:     }",
          "2610: }",
          "2620:     }",
          "2621: }",
          "2634:     }",
          "2636: }",
          "2653: }",
          "2670: }",
          "2679:         error_s[ope.name_] = ope.s_;",
          "2692:     }",
          "2693: }",
          "2705:     }",
          "2716: }",
          "2725:     }",
          "2727: }",
          "",
          "[Removed Lines]",
          "780: typedef std::function<void (const char* name, const char* s, size_t n, const SemanticValues& sv, const Context& c, const any& dt)> TracerEnter;",
          "782: typedef std::function<void (const char* name, const char* s, size_t n, const SemanticValues& sv, const Context& c, const any& dt, size_t)> TracerLeave;",
          "784: class Context",
          "785: {",
          "787:     const char*                                  path;",
          "788:     const char*                                  s;",
          "789:     const size_t                                 l;",
          "790:     std::vector<size_t>                          source_line_index;",
          "792:     const char*                                  error_pos = nullptr;",
          "793:     const char*                                  message_pos = nullptr;",
          "794:     std::string                                  message; // TODO: should be `int`.",
          "796:     std::vector<std::shared_ptr<SemanticValues>> value_stack;",
          "797:     size_t                                       value_stack_size = 0;",
          "798:     std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;",
          "800:     bool                                         in_token = false;",
          "802:     std::shared_ptr<Ope>                         whitespaceOpe;",
          "803:     bool                                         in_whitespace = false;",
          "805:     std::shared_ptr<Ope>                         wordOpe;",
          "807:     std::vector<std::map<std::string, std::string>> capture_scope_stack;",
          "808:     size_t                                       capture_scope_stack_size = 0;",
          "810:     const size_t                                 def_count;",
          "811:     const bool                                   enablePackratParsing;",
          "812:     std::vector<bool>                            cache_registered;",
          "813:     std::vector<bool>                            cache_success;",
          "815:     std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;",
          "817:     TracerEnter tracer_enter;",
          "818:     TracerLeave tracer_leave;",
          "820:     Context(",
          "821:         const char*          a_path,",
          "822:         const char*          a_s,",
          "823:         size_t               a_l,",
          "824:         size_t               a_def_count,",
          "825:         std::shared_ptr<Ope> a_whitespaceOpe,",
          "826:         std::shared_ptr<Ope> a_wordOpe,",
          "827:         bool                 a_enablePackratParsing,",
          "828:         TracerEnter          a_tracer_enter,",
          "829:         TracerLeave          a_tracer_leave)",
          "830:         : path(a_path)",
          "831:         , s(a_s)",
          "832:         , l(a_l)",
          "833:         , whitespaceOpe(a_whitespaceOpe)",
          "834:         , wordOpe(a_wordOpe)",
          "835:         , def_count(a_def_count)",
          "836:         , enablePackratParsing(a_enablePackratParsing)",
          "837:         , cache_registered(enablePackratParsing ? def_count * (l + 1) : 0)",
          "838:         , cache_success(enablePackratParsing ? def_count * (l + 1) : 0)",
          "839:         , tracer_enter(a_tracer_enter)",
          "840:         , tracer_leave(a_tracer_leave) {",
          "842:         for (size_t pos = 0; pos < l; pos++) {",
          "843:             if (s[pos] == '\\n') {",
          "844:                 source_line_index.push_back(pos);",
          "845:             }",
          "846:         }",
          "847:         source_line_index.push_back(l);",
          "849:         args_stack.resize(1);",
          "851:         push_capture_scope();",
          "852:     }",
          "854:     ~Context() {",
          "855:         assert(!value_stack_size);",
          "856:     }",
          "858:     Context(const Context&) = delete;",
          "859:     Context(Context&&) = delete;",
          "860:     Context operator=(const Context&) = delete;",
          "862:     template <typename T>",
          "863:     void packrat(const char* a_s, size_t def_id, size_t& len, any& val, T fn) {",
          "864:         if (!enablePackratParsing) {",
          "865:             fn(val);",
          "866:             return;",
          "867:         }",
          "869:         auto col = a_s - s;",
          "870:         auto idx = def_count * static_cast<size_t>(col) + def_id;",
          "872:         if (cache_registered[idx]) {",
          "873:             if (cache_success[idx]) {",
          "874:                 auto key = std::make_pair(col, def_id);",
          "875:                 std::tie(len, val) = cache_values[key];",
          "876:                 return;",
          "877:             } else {",
          "878:                 len = static_cast<size_t>(-1);",
          "879:                 return;",
          "880:             }",
          "881:         } else {",
          "882:             fn(val);",
          "883:             cache_registered[idx] = true;",
          "884:             cache_success[idx] = success(len);",
          "885:             if (success(len)) {",
          "886:                 auto key = std::make_pair(col, def_id);",
          "887:                 cache_values[key] = std::make_pair(len, val);",
          "888:             }",
          "889:             return;",
          "890:         }",
          "891:     }",
          "893:     SemanticValues& push() {",
          "894:         assert(value_stack_size <= value_stack.size());",
          "895:         if (value_stack_size == value_stack.size()) {",
          "896:             value_stack.emplace_back(std::make_shared<SemanticValues>());",
          "897:         } else {",
          "898:             auto& sv = *value_stack[value_stack_size];",
          "899:             if (!sv.empty()) {",
          "900:                 sv.clear();",
          "901:                 sv.tags.clear();",
          "902:             }",
          "903:             sv.s_ = nullptr;",
          "904:             sv.n_ = 0;",
          "905:             sv.choice_count_ = 0;",
          "906:             sv.choice_ = 0;",
          "907:             sv.tokens.clear();",
          "908:         }",
          "910:         auto& sv = *value_stack[value_stack_size++];",
          "911:         sv.path = path;",
          "912:         sv.ss = s;",
          "913:         sv.source_line_index = &source_line_index;",
          "914:         return sv;",
          "915:     }",
          "917:     void pop() {",
          "918:         value_stack_size--;",
          "919:     }",
          "921:     void push_args(std::vector<std::shared_ptr<Ope>>&& args) {",
          "922:         args_stack.emplace_back(args);",
          "923:     }",
          "925:     void pop_args() {",
          "926:         args_stack.pop_back();",
          "929:     const std::vector<std::shared_ptr<Ope>>& top_args() const {",
          "930:         return args_stack[args_stack.size() - 1];",
          "931:     }",
          "933:     void push_capture_scope() {",
          "934:         assert(capture_scope_stack_size <= capture_scope_stack.size());",
          "935:         if (capture_scope_stack_size == capture_scope_stack.size()) {",
          "936:             capture_scope_stack.emplace_back(std::map<std::string, std::string>());",
          "937:         } else {",
          "938:             auto& cs = capture_scope_stack[capture_scope_stack_size];",
          "939:             cs.clear();",
          "940:         }",
          "941:         capture_scope_stack_size++;",
          "944:     void pop_capture_scope() {",
          "945:         capture_scope_stack_size--;",
          "948:     void shift_capture_values() {",
          "949:         assert(capture_scope_stack.size() >= 2);",
          "950:         auto curr = &capture_scope_stack[capture_scope_stack_size - 1];",
          "951:         auto prev = curr - 1;",
          "952:         for (const auto& kv: *curr) {",
          "953:             (*prev)[kv.first] = kv.second;",
          "954:         }",
          "957:     void set_error_pos(const char* a_s) {",
          "958:         if (error_pos < a_s) error_pos = a_s;",
          "961:     void trace_enter(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt) const;",
          "962:     void trace_leave(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt, size_t len) const;",
          "963:     bool is_traceable(const Ope& ope) const;",
          "965:     mutable size_t next_trace_id = 0;",
          "966:     mutable std::list<size_t> trace_ids;",
          "972: class Ope",
          "973: {",
          "975:     struct Visitor;",
          "977:     virtual ~Ope() {}",
          "978:     size_t parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const;",
          "979:     virtual size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const = 0;",
          "980:     virtual void accept(Visitor& v) = 0;",
          "983: class Sequence : public Ope",
          "984: {",
          "986:     template <typename... Args>",
          "987:     Sequence(const Args& ...args) : opes_{ static_cast<std::shared_ptr<Ope>>(args)... } {}",
          "988:     Sequence(const std::vector<std::shared_ptr<Ope>>& opes) : opes_(opes) {}",
          "989:     Sequence(std::vector<std::shared_ptr<Ope>>&& opes) : opes_(opes) {}",
          "991:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "992:         auto& chldsv = c.push();",
          "993:         auto pop_se = make_scope_exit([&]() { c.pop(); });",
          "994:         size_t i = 0;",
          "995:         for (const auto& ope : opes_) {",
          "996:             const auto& rule = *ope;",
          "997:             auto len = rule.parse(s + i, n - i, chldsv, c, dt);",
          "998:             if (fail(len)) {",
          "999:                 return static_cast<size_t>(-1);",
          "1000:             }",
          "1001:             i += len;",
          "1002:         }",
          "1004:             for (size_t i = 0; i < chldsv.size(); i++) {",
          "1005:                 sv.emplace_back(std::move(chldsv[i]));",
          "1006:             }",
          "1009:             for (size_t i = 0; i < chldsv.tags.size(); i++) {",
          "1010:                 sv.tags.emplace_back(std::move(chldsv.tags[i]));",
          "1011:             }",
          "1016:             for (size_t i = 0; i < chldsv.tokens.size(); i++) {",
          "1017:                 sv.tokens.emplace_back(std::move(chldsv.tokens[i]));",
          "1018:             }",
          "1020:         return i;",
          "1021:     }",
          "1023:     void accept(Visitor& v) override;",
          "1025:     std::vector<std::shared_ptr<Ope>> opes_;",
          "1026: };",
          "1028: class PrioritizedChoice : public Ope",
          "1029: {",
          "1030: public:",
          "1031:     template <typename... Args>",
          "1032:     PrioritizedChoice(const Args& ...args) : opes_{ static_cast<std::shared_ptr<Ope>>(args)... } {}",
          "1033:     PrioritizedChoice(const std::vector<std::shared_ptr<Ope>>& opes) : opes_(opes) {}",
          "1034:     PrioritizedChoice(std::vector<std::shared_ptr<Ope>>&& opes) : opes_(opes) {}",
          "1036:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1037:         size_t id = 0;",
          "1038:         for (const auto& ope : opes_) {",
          "1039:             auto& chldsv = c.push();",
          "1040:             c.push_capture_scope();",
          "1041:             auto se = make_scope_exit([&]() {",
          "1042:                 c.pop();",
          "1043:                 c.pop_capture_scope();",
          "1044:             });",
          "1045:             const auto& rule = *ope;",
          "1046:             auto len = rule.parse(s, n, chldsv, c, dt);",
          "1047:             if (success(len)) {",
          "1048:                 if (!chldsv.empty()) {",
          "1049:                     for (size_t i = 0; i < chldsv.size(); i++) {",
          "1050:                         sv.emplace_back(std::move(chldsv[i]));",
          "1051:                     }",
          "1052:                 }",
          "1053:                 if (!chldsv.tags.empty()) {",
          "1054:                     for (size_t i = 0; i < chldsv.tags.size(); i++) {",
          "1055:                         sv.tags.emplace_back(std::move(chldsv.tags[i]));",
          "1056:                     }",
          "1057:                 }",
          "1058:                 sv.s_ = chldsv.c_str();",
          "1059:                 sv.n_ = chldsv.length();",
          "1060:                 sv.choice_count_ = opes_.size();",
          "1061:                 sv.choice_ = id;",
          "1062:                 if (!chldsv.tokens.empty()) {",
          "1063:                     for (size_t i = 0; i < chldsv.tokens.size(); i++) {",
          "1064:                         sv.tokens.emplace_back(std::move(chldsv.tokens[i]));",
          "1065:                     }",
          "1066:                 }",
          "1068:                 c.shift_capture_values();",
          "1069:                 return len;",
          "1070:             }",
          "1071:             id++;",
          "1072:         }",
          "1073:         return static_cast<size_t>(-1);",
          "1076:     void accept(Visitor& v) override;",
          "1078:     size_t size() const { return opes_.size();  }",
          "1080:     std::vector<std::shared_ptr<Ope>> opes_;",
          "1083: class ZeroOrMore : public Ope",
          "1084: {",
          "1086:     ZeroOrMore(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1088:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1089:         auto save_error_pos = c.error_pos;",
          "1090:         size_t i = 0;",
          "1091:         while (n - i > 0) {",
          "1092:             c.push_capture_scope();",
          "1093:             auto se = make_scope_exit([&]() {",
          "1094:                 c.pop_capture_scope();",
          "1095:             });",
          "1096:             auto save_sv_size = sv.size();",
          "1097:             auto save_tok_size = sv.tokens.size();",
          "1098:             const auto& rule = *ope_;",
          "1099:             auto len = rule.parse(s + i, n - i, sv, c, dt);",
          "1100:             if (success(len)) {",
          "1101:                 c.shift_capture_values();",
          "1102:             } else {",
          "1103:                 if (sv.size() != save_sv_size) {",
          "1104:                     sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1105:                     sv.tags.erase(sv.tags.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1106:                 }",
          "1107:                 if (sv.tokens.size() != save_tok_size) {",
          "1108:                     sv.tokens.erase(sv.tokens.begin() + static_cast<std::ptrdiff_t>(save_tok_size));",
          "1109:                 }",
          "1110:                 c.error_pos = save_error_pos;",
          "1111:                 break;",
          "1112:             }",
          "1113:             i += len;",
          "1114:         }",
          "1115:         return i;",
          "1118:     void accept(Visitor& v) override;",
          "1120:     std::shared_ptr<Ope> ope_;",
          "1123: class OneOrMore : public Ope",
          "1124: {",
          "1126:     OneOrMore(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1128:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1129:         size_t len = 0;",
          "1130:         {",
          "1131:             c.push_capture_scope();",
          "1132:             auto se = make_scope_exit([&]() {",
          "1133:                 c.pop_capture_scope();",
          "1134:             });",
          "1135:             const auto& rule = *ope_;",
          "1136:             len = rule.parse(s, n, sv, c, dt);",
          "1137:             if (success(len)) {",
          "1138:                 c.shift_capture_values();",
          "1139:             } else {",
          "1140:                 return static_cast<size_t>(-1);",
          "1141:             }",
          "1142:         }",
          "1143:         auto save_error_pos = c.error_pos;",
          "1144:         auto i = len;",
          "1145:         while (n - i > 0) {",
          "1146:             c.push_capture_scope();",
          "1147:             auto se = make_scope_exit([&]() {",
          "1148:                 c.pop_capture_scope();",
          "1149:             });",
          "1150:             auto save_sv_size = sv.size();",
          "1151:             auto save_tok_size = sv.tokens.size();",
          "1152:             const auto& rule = *ope_;",
          "1153:             len = rule.parse(s + i, n - i, sv, c, dt);",
          "1154:             if (success(len)) {",
          "1155:                 c.shift_capture_values();",
          "1156:             } else {",
          "1157:                 if (sv.size() != save_sv_size) {",
          "1158:                     sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1159:                     sv.tags.erase(sv.tags.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1160:                 }",
          "1161:                 if (sv.tokens.size() != save_tok_size) {",
          "1162:                     sv.tokens.erase(sv.tokens.begin() + static_cast<std::ptrdiff_t>(save_tok_size));",
          "1163:                 }",
          "1164:                 c.error_pos = save_error_pos;",
          "1165:                 break;",
          "1166:             }",
          "1167:             i += len;",
          "1168:         }",
          "1169:         return i;",
          "1172:     void accept(Visitor& v) override;",
          "1174:     std::shared_ptr<Ope> ope_;",
          "1177: class Option : public Ope",
          "1178: {",
          "1180:     Option(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1182:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1183:         auto save_error_pos = c.error_pos;",
          "1184:         auto save_sv_size = sv.size();",
          "1185:         auto save_tok_size = sv.tokens.size();",
          "1186:         c.push_capture_scope();",
          "1187:         auto se = make_scope_exit([&]() {",
          "1188:             c.pop_capture_scope();",
          "1189:         });",
          "1190:         const auto& rule = *ope_;",
          "1191:         auto len = rule.parse(s, n, sv, c, dt);",
          "1192:         if (success(len)) {",
          "1193:             c.shift_capture_values();",
          "1194:             return len;",
          "1195:         } else {",
          "1196:             if (sv.size() != save_sv_size) {",
          "1197:                 sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1198:                 sv.tags.erase(sv.tags.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1199:             }",
          "1200:             if (sv.tokens.size() != save_tok_size) {",
          "1201:                 sv.tokens.erase(sv.tokens.begin() + static_cast<std::ptrdiff_t>(save_tok_size));",
          "1202:             }",
          "1203:             c.error_pos = save_error_pos;",
          "1204:             return 0;",
          "1205:         }",
          "1208:     void accept(Visitor& v) override;",
          "1210:     std::shared_ptr<Ope> ope_;",
          "1213: class AndPredicate : public Ope",
          "1214: {",
          "1216:     AndPredicate(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1218:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1219:         auto& chldsv = c.push();",
          "1220:         c.push_capture_scope();",
          "1221:         auto se = make_scope_exit([&]() {",
          "1222:             c.pop();",
          "1223:             c.pop_capture_scope();",
          "1224:         });",
          "1225:         const auto& rule = *ope_;",
          "1226:         auto len = rule.parse(s, n, chldsv, c, dt);",
          "1227:         if (success(len)) {",
          "1228:             return 0;",
          "1229:         } else {",
          "1230:             return static_cast<size_t>(-1);",
          "1231:         }",
          "1234:     void accept(Visitor& v) override;",
          "1236:     std::shared_ptr<Ope> ope_;",
          "1239: class NotPredicate : public Ope",
          "1240: {",
          "1242:     NotPredicate(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1244:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1245:         auto save_error_pos = c.error_pos;",
          "1246:         auto& chldsv = c.push();",
          "1247:         c.push_capture_scope();",
          "1248:         auto se = make_scope_exit([&]() {",
          "1249:             c.pop();",
          "1250:             c.pop_capture_scope();",
          "1251:         });",
          "1252:         const auto& rule = *ope_;",
          "1253:         auto len = rule.parse(s, n, chldsv, c, dt);",
          "1254:         if (success(len)) {",
          "1255:             c.set_error_pos(s);",
          "1256:             return static_cast<size_t>(-1);",
          "1257:         } else {",
          "1258:             c.error_pos = save_error_pos;",
          "1259:             return 0;",
          "1260:         }",
          "1263:     void accept(Visitor& v) override;",
          "1265:     std::shared_ptr<Ope> ope_;",
          "1268: class LiteralString : public Ope",
          "1269:     , public std::enable_shared_from_this<LiteralString>",
          "1270: {",
          "1272:     LiteralString(const std::string& s, bool ignore_case)",
          "1273:         : lit_(s)",
          "1274:         , ignore_case_(ignore_case)",
          "1275:         , init_is_word_(false)",
          "1276:         , is_word_(false)",
          "1277:         {}",
          "1279:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "1281:     void accept(Visitor& v) override;",
          "1283:     std::string lit_;",
          "1284:     bool ignore_case_;",
          "1285:     mutable bool init_is_word_;",
          "1286:     mutable bool is_word_;",
          "1289: class CharacterClass : public Ope",
          "1290:     , public std::enable_shared_from_this<CharacterClass>",
          "1291: {",
          "1293:     CharacterClass(const std::string& s, bool negated): negated_(negated) {",
          "1294:         auto chars = decode(s.c_str(), s.length());",
          "1295:         auto i = 0u;",
          "1296:         while (i < chars.size()) {",
          "1297:             if (i + 2 < chars.size() && chars[i + 1] == '-') {",
          "1298:                 auto cp1 = chars[i];",
          "1299:                 auto cp2 = chars[i + 2];",
          "1300:                 ranges_.emplace_back(std::make_pair(cp1, cp2));",
          "1301:                 i += 3;",
          "1302:             } else {",
          "1303:                 auto cp = chars[i];",
          "1304:                 ranges_.emplace_back(std::make_pair(cp, cp));",
          "1305:                 i += 1;",
          "1306:             }",
          "1307:         }",
          "1308:         assert(!ranges_.empty());",
          "1311:     CharacterClass(const std::vector<std::pair<char32_t, char32_t>>& ranges, bool negated) : ranges_(ranges), negated_(negated) {",
          "1312:         assert(!ranges_.empty());",
          "1315:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1316:         if (n < 1) {",
          "1317:             c.set_error_pos(s);",
          "1318:             return static_cast<size_t>(-1);",
          "1319:         }",
          "1321:         char32_t cp = 0;",
          "1322:         auto len = decode_codepoint(s, n, cp);",
          "1324:         for (const auto& range: ranges_) {",
          "1325:             if (range.first <= cp && cp <= range.second) {",
          "1326:                 if (negated_) {",
          "1327:                     c.set_error_pos(s);",
          "1328:                     return static_cast<size_t>(-1);",
          "1329:                 } else {",
          "1330:                     return len;",
          "1331:                 }",
          "1332:             }",
          "1333:         }",
          "1336:             return len;",
          "1338:             c.set_error_pos(s);",
          "1339:             return static_cast<size_t>(-1);",
          "1343:     void accept(Visitor& v) override;",
          "1345:     std::vector<std::pair<char32_t, char32_t>> ranges_;",
          "1346:     bool negated_;",
          "1349: class Character : public Ope",
          "1350:     , public std::enable_shared_from_this<Character>",
          "1351: {",
          "1353:     Character(char ch) : ch_(ch) {}",
          "1355:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1356:         if (n < 1 || s[0] != ch_) {",
          "1357:             c.set_error_pos(s);",
          "1358:             return static_cast<size_t>(-1);",
          "1359:         }",
          "1360:         return 1;",
          "1363:     void accept(Visitor& v) override;",
          "1365:     char ch_;",
          "1368: class AnyCharacter : public Ope",
          "1369:     , public std::enable_shared_from_this<AnyCharacter>",
          "1370: {",
          "1372:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1373:         auto len = codepoint_length(s, n);",
          "1374:         if (len < 1) {",
          "1375:             c.set_error_pos(s);",
          "1376:             return static_cast<size_t>(-1);",
          "1377:         }",
          "1378:         return len;",
          "1381:     void accept(Visitor& v) override;",
          "1384: class CaptureScope : public Ope",
          "1385: {",
          "1387:     CaptureScope(const std::shared_ptr<Ope>& ope)",
          "1388:         : ope_(ope) {}",
          "1390:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1391:         c.push_capture_scope();",
          "1392:         auto se = make_scope_exit([&]() {",
          "1393:             c.pop_capture_scope();",
          "1394:         });",
          "1395:         const auto& rule = *ope_;",
          "1396:         auto len = rule.parse(s, n, sv, c, dt);",
          "1397:         return len;",
          "1398:     }",
          "1400:     void accept(Visitor& v) override;",
          "1402:     std::shared_ptr<Ope> ope_;",
          "1405: class Capture : public Ope",
          "1406: {",
          "1408:     typedef std::function<void (const char* s, size_t n, Context& c)> MatchAction;",
          "1410:     Capture(const std::shared_ptr<Ope>& ope, MatchAction ma)",
          "1411:         : ope_(ope), match_action_(ma) {}",
          "1413:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1414:         const auto& rule = *ope_;",
          "1415:         auto len = rule.parse(s, n, sv, c, dt);",
          "1416:         if (success(len) && match_action_) {",
          "1417:             match_action_(s, len, c);",
          "1418:         }",
          "1419:         return len;",
          "1420:     }",
          "1422:     void accept(Visitor& v) override;",
          "1424:     std::shared_ptr<Ope> ope_;",
          "1425:     MatchAction          match_action_;",
          "1428: class TokenBoundary : public Ope",
          "1429: {",
          "1431:     TokenBoundary(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1433:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "1435:     void accept(Visitor& v) override;",
          "1437:     std::shared_ptr<Ope> ope_;",
          "1440: class Ignore : public Ope",
          "1441: {",
          "1443:     Ignore(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1445:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1446:         const auto& rule = *ope_;",
          "1447:         auto& chldsv = c.push();",
          "1448:         auto se = make_scope_exit([&]() {",
          "1449:             c.pop();",
          "1450:         });",
          "1451:         return rule.parse(s, n, chldsv, c, dt);",
          "1452:     }",
          "1454:     void accept(Visitor& v) override;",
          "1456:     std::shared_ptr<Ope> ope_;",
          "1459: typedef std::function<size_t (const char* s, size_t n, SemanticValues& sv, any& dt)> Parser;",
          "1461: class User : public Ope",
          "1462: {",
          "1464:     User(Parser fn) : fn_(fn) {}",
          "1465:      size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1466:         assert(fn_);",
          "1467:         return fn_(s, n, sv, dt);",
          "1468:     }",
          "1469:      void accept(Visitor& v) override;",
          "1470:      std::function<size_t (const char* s, size_t n, SemanticValues& sv, any& dt)> fn_;",
          "1473: class WeakHolder : public Ope",
          "1474: {",
          "1476:     WeakHolder(const std::shared_ptr<Ope>& ope) : weak_(ope) {}",
          "1478:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1479:         auto ope = weak_.lock();",
          "1480:         assert(ope);",
          "1481:         const auto& rule = *ope;",
          "1482:         return rule.parse(s, n, sv, c, dt);",
          "1483:     }",
          "1485:     void accept(Visitor& v) override;",
          "1487:     std::weak_ptr<Ope> weak_;",
          "1490: class Holder : public Ope",
          "1491: {",
          "1493:     Holder(Definition* outer)",
          "1494:        : outer_(outer) {}",
          "1496:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "1498:     void accept(Visitor& v) override;",
          "1500:     any reduce(SemanticValues& sv, any& dt) const;",
          "1502:     const char* trace_name() const;",
          "1504:     std::shared_ptr<Ope> ope_;",
          "1505:     Definition*          outer_;",
          "1506:     mutable std::string  trace_name_;",
          "1508:     friend class Definition;",
          "1513: class Reference : public Ope",
          "1514:     , public std::enable_shared_from_this<Reference>",
          "1515: {",
          "1517:     Reference(",
          "1518:         const Grammar& grammar,",
          "1519:         const std::string& name,",
          "1520:         const char* s,",
          "1521:         bool is_macro,",
          "1522:         const std::vector<std::shared_ptr<Ope>>& args)",
          "1523:         : grammar_(grammar)",
          "1524:         , name_(name)",
          "1525:         , s_(s)",
          "1526:         , is_macro_(is_macro)",
          "1527:         , args_(args)",
          "1528:         , rule_(nullptr)",
          "1529:         , iarg_(0)",
          "1530:         {}",
          "1532:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "1534:     void accept(Visitor& v) override;",
          "1536:     std::shared_ptr<Ope> get_core_operator() const;",
          "1538:     const Grammar&    grammar_;",
          "1539:     const std::string name_;",
          "1540:     const char*       s_;",
          "1542:     const bool is_macro_;",
          "1543:     const std::vector<std::shared_ptr<Ope>> args_;",
          "1545:     Definition* rule_;",
          "1546:     size_t iarg_;",
          "1549: class Whitespace : public Ope",
          "1550: {",
          "1552:     Whitespace(const std::shared_ptr<Ope>& ope) : ope_(ope) {}",
          "1554:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override {",
          "1555:         if (c.in_whitespace) {",
          "1556:             return 0;",
          "1557:         }",
          "1558:         c.in_whitespace = true;",
          "1559:         auto se = make_scope_exit([&]() { c.in_whitespace = false; });",
          "1560:         const auto& rule = *ope_;",
          "1561:         return rule.parse(s, n, sv, c, dt);",
          "1562:     }",
          "1564:     void accept(Visitor& v) override;",
          "1566:     std::shared_ptr<Ope> ope_;",
          "1569: class BackReference : public Ope",
          "1570: {",
          "1572:     BackReference(const std::string& name) : name_(name) {}",
          "1574:     size_t parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const override;",
          "1576:     void accept(Visitor& v) override;",
          "1578:     std::string name_;",
          "1584: template <typename... Args>",
          "1585: std::shared_ptr<Ope> seq(Args&& ...args) {",
          "1586:     return std::make_shared<Sequence>(static_cast<std::shared_ptr<Ope>>(args)...);",
          "1589: template <typename... Args>",
          "1590: std::shared_ptr<Ope> cho(Args&& ...args) {",
          "1591:     return std::make_shared<PrioritizedChoice>(static_cast<std::shared_ptr<Ope>>(args)...);",
          "1594: inline std::shared_ptr<Ope> zom(const std::shared_ptr<Ope>& ope) {",
          "1595:     return std::make_shared<ZeroOrMore>(ope);",
          "1598: inline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope>& ope) {",
          "1599:     return std::make_shared<OneOrMore>(ope);",
          "1602: inline std::shared_ptr<Ope> opt(const std::shared_ptr<Ope>& ope) {",
          "1603:     return std::make_shared<Option>(ope);",
          "1606: inline std::shared_ptr<Ope> apd(const std::shared_ptr<Ope>& ope) {",
          "1607:     return std::make_shared<AndPredicate>(ope);",
          "1610: inline std::shared_ptr<Ope> npd(const std::shared_ptr<Ope>& ope) {",
          "1611:     return std::make_shared<NotPredicate>(ope);",
          "1614: inline std::shared_ptr<Ope> lit(const std::string& s) {",
          "1615:     return std::make_shared<LiteralString>(s, false);",
          "1618: inline std::shared_ptr<Ope> liti(const std::string& s) {",
          "1619:     return std::make_shared<LiteralString>(s, true);",
          "1622: inline std::shared_ptr<Ope> cls(const std::string& s) {",
          "1623:     return std::make_shared<CharacterClass>(s, false);",
          "1626: inline std::shared_ptr<Ope> cls(const std::vector<std::pair<char32_t, char32_t>>& ranges) {",
          "1627:     return std::make_shared<CharacterClass>(ranges, false);",
          "1630: inline std::shared_ptr<Ope> ncls(const std::string& s) {",
          "1631:     return std::make_shared<CharacterClass>(s, true);",
          "1634: inline std::shared_ptr<Ope> ncls(const std::vector<std::pair<char32_t, char32_t>>& ranges) {",
          "1635:     return std::make_shared<CharacterClass>(ranges, true);",
          "1639:     return std::make_shared<Character>(dt);",
          "1642: inline std::shared_ptr<Ope> dot() {",
          "1643:     return std::make_shared<AnyCharacter>();",
          "1644: }",
          "1646: inline std::shared_ptr<Ope> csc(const std::shared_ptr<Ope>& ope) {",
          "1647:     return std::make_shared<CaptureScope>(ope);",
          "1650: inline std::shared_ptr<Ope> cap(const std::shared_ptr<Ope>& ope, Capture::MatchAction ma) {",
          "1651:     return std::make_shared<Capture>(ope, ma);",
          "1654: inline std::shared_ptr<Ope> tok(const std::shared_ptr<Ope>& ope) {",
          "1655:     return std::make_shared<TokenBoundary>(ope);",
          "1658: inline std::shared_ptr<Ope> ign(const std::shared_ptr<Ope>& ope) {",
          "1659:     return std::make_shared<Ignore>(ope);",
          "1662: inline std::shared_ptr<Ope> usr(std::function<size_t (const char* s, size_t n, SemanticValues& sv, any& dt)> fn) {",
          "1663:     return std::make_shared<User>(fn);",
          "1666: inline std::shared_ptr<Ope> ref(const Grammar& grammar, const std::string& name, const char* s, bool is_macro, const std::vector<std::shared_ptr<Ope>>& args) {",
          "1667:     return std::make_shared<Reference>(grammar, name, s, is_macro, args);",
          "1670: inline std::shared_ptr<Ope> wsp(const std::shared_ptr<Ope>& ope) {",
          "1671:     return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));",
          "1674: inline std::shared_ptr<Ope> bkr(const std::string& name) {",
          "1675:     return std::make_shared<BackReference>(name);",
          "1681: struct Ope::Visitor",
          "1682: {",
          "1683:     virtual ~Visitor() {}",
          "1684:     virtual void visit(Sequence& /*ope*/) {}",
          "1685:     virtual void visit(PrioritizedChoice& /*ope*/) {}",
          "1686:     virtual void visit(ZeroOrMore& /*ope*/) {}",
          "1687:     virtual void visit(OneOrMore& /*ope*/) {}",
          "1688:     virtual void visit(Option& /*ope*/) {}",
          "1689:     virtual void visit(AndPredicate& /*ope*/) {}",
          "1690:     virtual void visit(NotPredicate& /*ope*/) {}",
          "1691:     virtual void visit(LiteralString& /*ope*/) {}",
          "1692:     virtual void visit(CharacterClass& /*ope*/) {}",
          "1693:     virtual void visit(Character& /*ope*/) {}",
          "1694:     virtual void visit(AnyCharacter& /*ope*/) {}",
          "1695:     virtual void visit(CaptureScope& /*ope*/) {}",
          "1696:     virtual void visit(Capture& /*ope*/) {}",
          "1697:     virtual void visit(TokenBoundary& /*ope*/) {}",
          "1698:     virtual void visit(Ignore& /*ope*/) {}",
          "1699:     virtual void visit(User& /*ope*/) {}",
          "1700:     virtual void visit(WeakHolder& /*ope*/) {}",
          "1701:     virtual void visit(Holder& /*ope*/) {}",
          "1702:     virtual void visit(Reference& /*ope*/) {}",
          "1703:     virtual void visit(Whitespace& /*ope*/) {}",
          "1704:     virtual void visit(BackReference& /*ope*/) {}",
          "1707: struct IsReference : public Ope::Visitor",
          "1708: {",
          "1709:     void visit(Reference& ope) override {",
          "1710:         is_reference = true;",
          "1711:     }",
          "1712:     bool is_reference = false;",
          "1715: struct TraceOpeName : public Ope::Visitor",
          "1716: {",
          "1717:     void visit(Sequence& ope) override { name = \"Sequence\"; }",
          "1718:     void visit(PrioritizedChoice& ope) override { name = \"PrioritizedChoice\"; }",
          "1719:     void visit(ZeroOrMore& ope) override { name = \"ZeroOrMore\"; }",
          "1720:     void visit(OneOrMore& ope) override { name = \"OneOrMore\"; }",
          "1721:     void visit(Option& ope) override { name = \"Option\"; }",
          "1722:     void visit(AndPredicate& ope) override { name = \"AndPredicate\"; }",
          "1723:     void visit(NotPredicate& ope) override { name = \"NotPredicate\"; }",
          "1724:     void visit(LiteralString& ope) override { name = \"LiteralString\"; }",
          "1725:     void visit(CharacterClass& ope) override { name = \"CharacterClass\"; }",
          "1726:     void visit(Character& ope) override { name = \"Character\"; }",
          "1727:     void visit(AnyCharacter& ope) override { name = \"AnyCharacter\"; }",
          "1728:     void visit(CaptureScope& ope) override { name = \"CaptureScope\"; }",
          "1729:     void visit(Capture& ope) override { name = \"Capture\"; }",
          "1730:     void visit(TokenBoundary& ope) override { name = \"TokenBoundary\"; }",
          "1731:     void visit(Ignore& ope) override { name = \"Ignore\"; }",
          "1732:     void visit(User& ope) override { name = \"User\"; }",
          "1733:     void visit(WeakHolder& ope) override { name = \"WeakHolder\"; }",
          "1734:     void visit(Holder& ope) override {",
          "1735:         name = ope.trace_name();",
          "1736:     }",
          "1737:     void visit(Reference& ope) override {",
          "1738:         name = \"Reference\";",
          "1739:     }",
          "1740:     void visit(Whitespace& ope) override { name = \"Whitespace\"; }",
          "1741:     void visit(BackReference& ope) override { name = \"BackReference\"; }",
          "1743:     const char* name = nullptr;",
          "1746: struct AssignIDToDefinition : public Ope::Visitor",
          "1747: {",
          "1748:     void visit(Sequence& ope) override {",
          "1749:         for (auto op: ope.opes_) {",
          "1750:             op->accept(*this);",
          "1751:         }",
          "1753:     void visit(PrioritizedChoice& ope) override {",
          "1754:         for (auto op: ope.opes_) {",
          "1755:             op->accept(*this);",
          "1756:         }",
          "1758:     void visit(ZeroOrMore& ope) override { ope.ope_->accept(*this); }",
          "1759:     void visit(OneOrMore& ope) override { ope.ope_->accept(*this); }",
          "1760:     void visit(Option& ope) override { ope.ope_->accept(*this); }",
          "1761:     void visit(AndPredicate& ope) override { ope.ope_->accept(*this); }",
          "1762:     void visit(NotPredicate& ope) override { ope.ope_->accept(*this); }",
          "1763:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); }",
          "1764:     void visit(Capture& ope) override { ope.ope_->accept(*this); }",
          "1765:     void visit(TokenBoundary& ope) override { ope.ope_->accept(*this); }",
          "1766:     void visit(Ignore& ope) override { ope.ope_->accept(*this); }",
          "1767:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "1768:     void visit(Holder& ope) override;",
          "1769:     void visit(Reference& ope) override;",
          "1770:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); }",
          "1772:     std::unordered_map<void*, size_t> ids;",
          "1775: struct IsLiteralToken : public Ope::Visitor",
          "1776: {",
          "1777:     void visit(PrioritizedChoice& ope) override {",
          "1778:         for (auto op: ope.opes_) {",
          "1779:             if (!IsLiteralToken::check(*op)) {",
          "1780:                 return;",
          "1781:             }",
          "1782:         }",
          "1783:         result_ = true;",
          "1786:     void visit(LiteralString& /*ope*/) override {",
          "1787:         result_ = true;",
          "1788:     }",
          "1790:     static bool check(Ope& ope) {",
          "1791:         IsLiteralToken vis;",
          "1792:         ope.accept(vis);",
          "1793:         return vis.result_;",
          "1794:     }",
          "1797:     bool result_ = false;",
          "1800: struct TokenChecker : public Ope::Visitor",
          "1801: {",
          "1802:     void visit(Sequence& ope) override {",
          "1803:         for (auto op: ope.opes_) {",
          "1804:             op->accept(*this);",
          "1805:         }",
          "1806:     }",
          "1807:     void visit(PrioritizedChoice& ope) override {",
          "1808:         for (auto op: ope.opes_) {",
          "1809:             op->accept(*this);",
          "1810:         }",
          "1812:     void visit(ZeroOrMore& ope) override { ope.ope_->accept(*this); }",
          "1813:     void visit(OneOrMore& ope) override { ope.ope_->accept(*this); }",
          "1814:     void visit(Option& ope) override { ope.ope_->accept(*this); }",
          "1815:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); }",
          "1816:     void visit(Capture& ope) override { ope.ope_->accept(*this); }",
          "1817:     void visit(TokenBoundary& /*ope*/) override { has_token_boundary_ = true; }",
          "1818:     void visit(Ignore& ope) override { ope.ope_->accept(*this); }",
          "1819:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "1820:     void visit(Reference& ope) override;",
          "1821:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); }",
          "1823:     static bool is_token(Ope& ope) {",
          "1824:         if (IsLiteralToken::check(ope)) {",
          "1825:             return true;",
          "1826:         }",
          "1828:         TokenChecker vis;",
          "1829:         ope.accept(vis);",
          "1830:         return vis.has_token_boundary_ || !vis.has_rule_;",
          "1834:     bool has_token_boundary_ = false;",
          "1835:     bool has_rule_ = false;",
          "1839:     DetectLeftRecursion(const std::string& name) : name_(name) {}",
          "1841:     void visit(Sequence& ope) override {",
          "1842:         for (auto op: ope.opes_) {",
          "1843:             op->accept(*this);",
          "1844:             if (done_) {",
          "1845:                 break;",
          "1846:             } else if (error_s) {",
          "1847:                 done_ = true;",
          "1848:                 break;",
          "1849:             }",
          "1850:         }",
          "1852:     void visit(PrioritizedChoice& ope) override {",
          "1853:         for (auto op: ope.opes_) {",
          "1854:             op->accept(*this);",
          "1855:             if (error_s) {",
          "1856:                 done_ = true;",
          "1857:                 break;",
          "1858:             }",
          "1859:         }",
          "1861:     void visit(ZeroOrMore& ope) override { ope.ope_->accept(*this); done_ = false; }",
          "1862:     void visit(OneOrMore& ope) override { ope.ope_->accept(*this); done_ = true; }",
          "1863:     void visit(Option& ope) override { ope.ope_->accept(*this); done_ = false; }",
          "1864:     void visit(AndPredicate& ope) override { ope.ope_->accept(*this); done_ = false; }",
          "1865:     void visit(NotPredicate& ope) override { ope.ope_->accept(*this); done_ = false; }",
          "1866:     void visit(LiteralString& ope) override { done_ = !ope.lit_.empty(); }",
          "1867:     void visit(CharacterClass& /*ope*/) override { done_ = true; }",
          "1868:     void visit(Character& /*ope*/) override { done_ = true; }",
          "1869:     void visit(AnyCharacter& /*ope*/) override { done_ = true; }",
          "1870:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); }",
          "1871:     void visit(Capture& ope) override { ope.ope_->accept(*this); }",
          "1872:     void visit(TokenBoundary& ope) override { ope.ope_->accept(*this); }",
          "1873:     void visit(Ignore& ope) override { ope.ope_->accept(*this); }",
          "1874:     void visit(User& /*ope*/) override { done_ = true; }",
          "1875:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "1876:     void visit(Holder& ope) override { ope.ope_->accept(*this); }",
          "1877:     void visit(Reference& ope) override;",
          "1878:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); }",
          "1879:     void visit(BackReference& /*ope*/) override { done_ = true; }",
          "1881:     const char* error_s = nullptr;",
          "1884:     std::string           name_;",
          "1885:     std::set<std::string> refs_;",
          "1886:     bool                  done_ = false;",
          "1889: struct HasEmptyElement : public Ope::Visitor",
          "1890: {",
          "1891:     HasEmptyElement(std::list<std::pair<const char*, std::string>>& refs): refs_(refs) {}",
          "1893:     void visit(Sequence& ope) override {",
          "1894:         bool save_is_empty = false;",
          "1895:         const char* save_error_s = nullptr;",
          "1896:         std::string save_error_name;",
          "1897:         for (auto op: ope.opes_) {",
          "1898:             op->accept(*this);",
          "1899:             if (!is_empty) { return; }",
          "1900:             save_is_empty = is_empty;",
          "1901:             save_error_s = error_s;",
          "1902:             save_error_name = error_name;",
          "1903:             is_empty = false;",
          "1904:             error_name.clear();",
          "1905:         }",
          "1906:         is_empty = save_is_empty;",
          "1907:         error_s = save_error_s;",
          "1908:         error_name = save_error_name;",
          "1909:     }",
          "1910:     void visit(PrioritizedChoice& ope) override {",
          "1911:         for (auto op: ope.opes_) {",
          "1912:             op->accept(*this);",
          "1913:             if (is_empty) { return; }",
          "1914:         }",
          "1916:     void visit(ZeroOrMore& /*ope*/) override { set_error(); }",
          "1917:     void visit(OneOrMore& ope) override { ope.ope_->accept(*this); }",
          "1918:     void visit(Option& /*ope*/) override { set_error(); }",
          "1919:     void visit(AndPredicate& /*ope*/) override { set_error(); }",
          "1920:     void visit(NotPredicate& /*ope*/) override { set_error(); }",
          "1921:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); }",
          "1922:     void visit(Capture& ope) override { ope.ope_->accept(*this); }",
          "1923:     void visit(TokenBoundary& ope) override { ope.ope_->accept(*this); }",
          "1924:     void visit(Ignore& ope) override { ope.ope_->accept(*this); }",
          "1925:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "1926:     void visit(Holder& ope) override { ope.ope_->accept(*this); }",
          "1927:     void visit(Reference& ope) override;",
          "1928:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); }",
          "1930:     bool is_empty = false;",
          "1931:     const char* error_s = nullptr;",
          "1932:     std::string error_name;",
          "1935:     void set_error() {",
          "1936:         is_empty = true;",
          "1937:         error_s = refs_.back().first;",
          "1938:         error_name = refs_.back().second;",
          "1939:     }",
          "1940:     std::list<std::pair<const char*, std::string>>& refs_;",
          "1943: struct DetectInfiniteLoop : public Ope::Visitor",
          "1944: {",
          "1945:     DetectInfiniteLoop(const char* s, const std::string& name) {",
          "1946:         refs_.emplace_back(s, name);",
          "1947:     }",
          "1949:     void visit(Sequence& ope) override {",
          "1950:         for (auto op: ope.opes_) {",
          "1951:             op->accept(*this);",
          "1952:             if (has_error) { return; }",
          "1953:         }",
          "1955:     void visit(PrioritizedChoice& ope) override {",
          "1956:         for (auto op: ope.opes_) {",
          "1957:             op->accept(*this);",
          "1958:             if (has_error) { return; }",
          "1959:         }",
          "1961:     void visit(ZeroOrMore& ope) override {",
          "1962:         HasEmptyElement vis(refs_);",
          "1963:         ope.ope_->accept(vis);",
          "1964:         if (vis.is_empty) {",
          "1965:             has_error = true;",
          "1966:             error_s = vis.error_s;",
          "1967:             error_name = vis.error_name;",
          "1968:         }",
          "1970:     void visit(OneOrMore& ope) override {",
          "1971:         HasEmptyElement vis(refs_);",
          "1972:         ope.ope_->accept(vis);",
          "1973:         if (vis.is_empty) {",
          "1974:             has_error = true;",
          "1975:             error_s = vis.error_s;",
          "1976:             error_name = vis.error_name;",
          "1977:         }",
          "1979:     void visit(Option& ope) override { ope.ope_->accept(*this); }",
          "1980:     void visit(AndPredicate& ope) override { ope.ope_->accept(*this); }",
          "1981:     void visit(NotPredicate& ope) override { ope.ope_->accept(*this); }",
          "1982:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); }",
          "1983:     void visit(Capture& ope) override { ope.ope_->accept(*this); }",
          "1984:     void visit(TokenBoundary& ope) override { ope.ope_->accept(*this); }",
          "1985:     void visit(Ignore& ope) override { ope.ope_->accept(*this); }",
          "1986:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "1987:     void visit(Holder& ope) override { ope.ope_->accept(*this); }",
          "1988:     void visit(Reference& ope) override;",
          "1989:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); }",
          "1991:     bool has_error = false;",
          "1992:     const char* error_s = nullptr;",
          "1993:     std::string error_name;",
          "1996:     std::list<std::pair<const char*, std::string>> refs_;",
          "2000:     ReferenceChecker(",
          "2001:         const Grammar& grammar,",
          "2002:         const std::vector<std::string>& params)",
          "2003:         : grammar_(grammar), params_(params) {}",
          "2005:     void visit(Sequence& ope) override {",
          "2006:         for (auto op: ope.opes_) {",
          "2007:             op->accept(*this);",
          "2008:         }",
          "2010:     void visit(PrioritizedChoice& ope) override {",
          "2011:         for (auto op: ope.opes_) {",
          "2012:             op->accept(*this);",
          "2013:         }",
          "2015:     void visit(ZeroOrMore& ope) override { ope.ope_->accept(*this); }",
          "2016:     void visit(OneOrMore& ope) override { ope.ope_->accept(*this); }",
          "2017:     void visit(Option& ope) override { ope.ope_->accept(*this); }",
          "2018:     void visit(AndPredicate& ope) override { ope.ope_->accept(*this); }",
          "2019:     void visit(NotPredicate& ope) override { ope.ope_->accept(*this); }",
          "2020:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); }",
          "2021:     void visit(Capture& ope) override { ope.ope_->accept(*this); }",
          "2022:     void visit(TokenBoundary& ope) override { ope.ope_->accept(*this); }",
          "2023:     void visit(Ignore& ope) override { ope.ope_->accept(*this); }",
          "2024:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "2025:     void visit(Holder& ope) override { ope.ope_->accept(*this); }",
          "2026:     void visit(Reference& ope) override;",
          "2027:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); }",
          "2029:     std::unordered_map<std::string, const char*> error_s;",
          "2030:     std::unordered_map<std::string, std::string> error_message;",
          "2033:     const Grammar& grammar_;",
          "2034:     const std::vector<std::string>& params_;",
          "2038:     LinkReferences(",
          "2039:         Grammar& grammar,",
          "2040:         const std::vector<std::string>& params)",
          "2041:         : grammar_(grammar), params_(params) {}",
          "2043:     void visit(Sequence& ope) override {",
          "2044:         for (auto op: ope.opes_) {",
          "2045:             op->accept(*this);",
          "2046:         }",
          "2048:     void visit(PrioritizedChoice& ope) override {",
          "2049:         for (auto op: ope.opes_) {",
          "2050:             op->accept(*this);",
          "2051:         }",
          "2053:     void visit(ZeroOrMore& ope) override { ope.ope_->accept(*this); }",
          "2054:     void visit(OneOrMore& ope) override { ope.ope_->accept(*this); }",
          "2055:     void visit(Option& ope) override { ope.ope_->accept(*this); }",
          "2056:     void visit(AndPredicate& ope) override { ope.ope_->accept(*this); }",
          "2057:     void visit(NotPredicate& ope) override { ope.ope_->accept(*this); }",
          "2058:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); }",
          "2059:     void visit(Capture& ope) override { ope.ope_->accept(*this); }",
          "2060:     void visit(TokenBoundary& ope) override { ope.ope_->accept(*this); }",
          "2061:     void visit(Ignore& ope) override { ope.ope_->accept(*this); }",
          "2062:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "2063:     void visit(Holder& ope) override { ope.ope_->accept(*this); }",
          "2064:     void visit(Reference& ope) override;",
          "2065:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); }",
          "2068:     Grammar& grammar_;",
          "2069:     const std::vector<std::string>& params_;",
          "2073:     FindReference(",
          "2074:         const std::vector<std::shared_ptr<Ope>>& args,",
          "2075:         const std::vector<std::string>& params)",
          "2076:         : args_(args), params_(params) {}",
          "2078:     void visit(Sequence& ope) override {",
          "2079:         std::vector<std::shared_ptr<Ope>> opes;",
          "2080:         for (auto o: ope.opes_) {",
          "2081:             o->accept(*this);",
          "2082:             opes.push_back(found_ope);",
          "2083:         }",
          "2084:         found_ope = std::make_shared<Sequence>(opes);",
          "2086:     void visit(PrioritizedChoice& ope) override {",
          "2087:         std::vector<std::shared_ptr<Ope>> opes;",
          "2088:         for (auto o: ope.opes_) {",
          "2089:             o->accept(*this);",
          "2090:             opes.push_back(found_ope);",
          "2091:         }",
          "2092:         found_ope = std::make_shared<PrioritizedChoice>(opes);",
          "2093:     }",
          "2094:     void visit(ZeroOrMore& ope) override { ope.ope_->accept(*this); found_ope = zom(found_ope); }",
          "2095:     void visit(OneOrMore& ope) override { ope.ope_->accept(*this); found_ope = oom(found_ope); }",
          "2096:     void visit(Option& ope) override { ope.ope_->accept(*this); found_ope = opt(found_ope); }",
          "2097:     void visit(AndPredicate& ope) override { ope.ope_->accept(*this); found_ope = apd(found_ope); }",
          "2098:     void visit(NotPredicate& ope) override { ope.ope_->accept(*this); found_ope = npd(found_ope); }",
          "2099:     void visit(LiteralString& ope) override { found_ope = ope.shared_from_this(); }",
          "2100:     void visit(CharacterClass& ope) override { found_ope = ope.shared_from_this(); }",
          "2101:     void visit(Character& ope) override { found_ope = ope.shared_from_this(); }",
          "2102:     void visit(AnyCharacter& ope) override { found_ope = ope.shared_from_this(); }",
          "2103:     void visit(CaptureScope& ope) override { ope.ope_->accept(*this); found_ope = csc(found_ope); }",
          "2104:     void visit(Capture& ope) override { ope.ope_->accept(*this); found_ope = cap(found_ope, ope.match_action_); }",
          "2105:     void visit(TokenBoundary& ope) override { ope.ope_->accept(*this); found_ope = tok(found_ope); }",
          "2106:     void visit(Ignore& ope) override { ope.ope_->accept(*this); found_ope = ign(found_ope); }",
          "2107:     void visit(WeakHolder& ope) override { ope.weak_.lock()->accept(*this); }",
          "2108:     void visit(Holder& ope) override { ope.ope_->accept(*this); }",
          "2109:     void visit(Reference& ope) override;",
          "2110:     void visit(Whitespace& ope) override { ope.ope_->accept(*this); found_ope = wsp(found_ope); }",
          "2112:     std::shared_ptr<Ope> found_ope;",
          "2115:     const std::vector<std::shared_ptr<Ope>>& args_;",
          "2116:     const std::vector<std::string>& params_;",
          "2119: struct IsPrioritizedChoice : public Ope::Visitor",
          "2120: {",
          "2121:     void visit(PrioritizedChoice& /*ope*/) override {",
          "2122:         result_ = true;",
          "2123:     }",
          "2125:     static bool check(Ope& ope) {",
          "2126:         IsPrioritizedChoice vis;",
          "2127:         ope.accept(vis);",
          "2128:         return vis.result_;",
          "2129:     }",
          "2132:     bool result_ = false;",
          "2138: static const char* WHITESPACE_DEFINITION_NAME = \"%whitespace\";",
          "2139: static const char* WORD_DEFINITION_NAME = \"%word\";",
          "2144: class Definition",
          "2145: {",
          "2147:     struct Result {",
          "2148:         bool              ret;",
          "2149:         size_t            len;",
          "2150:         const char*       error_pos;",
          "2151:         const char*       message_pos;",
          "2152:         const std::string message;",
          "2153:     };",
          "2155:     Definition()",
          "2156:         : holder_(std::make_shared<Holder>(this)) {}",
          "2158:     Definition(const Definition& rhs)",
          "2159:         : name(rhs.name)",
          "2160:         , holder_(rhs.holder_)",
          "2161:     {",
          "2162:         holder_->outer_ = this;",
          "2163:     }",
          "2165:     Definition(const std::shared_ptr<Ope>& ope)",
          "2166:         : holder_(std::make_shared<Holder>(this))",
          "2167:     {",
          "2169:     }",
          "2171:     operator std::shared_ptr<Ope>() {",
          "2172:         return std::make_shared<WeakHolder>(holder_);",
          "2173:     }",
          "2175:     Definition& operator<=(const std::shared_ptr<Ope>& ope) {",
          "2176:         holder_->ope_ = ope;",
          "2177:         return *this;",
          "2178:     }",
          "2180:     Result parse(const char* s, size_t n, const char* path = nullptr) const {",
          "2181:         SemanticValues sv;",
          "2182:         any dt;",
          "2183:         return parse_core(s, n, sv, dt, path);",
          "2184:     }",
          "2186:     Result parse(const char* s, const char* path = nullptr) const {",
          "2187:         auto n = strlen(s);",
          "2188:         return parse(s, n, path);",
          "2189:     }",
          "2191:     Result parse(const char* s, size_t n, any& dt, const char* path = nullptr) const {",
          "2192:         SemanticValues sv;",
          "2193:         return parse_core(s, n, sv, dt, path);",
          "2194:     }",
          "2196:     Result parse(const char* s, any& dt, const char* path = nullptr) const {",
          "2197:         auto n = strlen(s);",
          "2198:         return parse(s, n, dt, path);",
          "2199:     }",
          "2201:     template <typename T>",
          "2202:     Result parse_and_get_value(const char* s, size_t n, T& val, const char* path = nullptr) const {",
          "2203:         SemanticValues sv;",
          "2204:         any dt;",
          "2205:         auto r = parse_core(s, n, sv, dt, path);",
          "2206:         if (r.ret && !sv.empty() && sv.front().has_value()) {",
          "2207:             val = any_cast<T>(sv[0]);",
          "2208:         }",
          "2209:         return r;",
          "2212:     template <typename T>",
          "2213:     Result parse_and_get_value(const char* s, T& val, const char* path = nullptr) const {",
          "2214:         auto n = strlen(s);",
          "2215:         return parse_and_get_value(s, n, val, path);",
          "2216:     }",
          "2218:     template <typename T>",
          "2219:     Result parse_and_get_value(const char* s, size_t n, any& dt, T& val, const char* path = nullptr) const {",
          "2220:         SemanticValues sv;",
          "2221:         auto r = parse_core(s, n, sv, dt, path);",
          "2222:         if (r.ret && !sv.empty() && sv.front().has_value()) {",
          "2223:             val = any_cast<T>(sv[0]);",
          "2224:         }",
          "2225:         return r;",
          "2228:     template <typename T>",
          "2229:     Result parse_and_get_value(const char* s, any& dt, T& val, const char* path = nullptr) const {",
          "2230:         auto n = strlen(s);",
          "2231:         return parse_and_get_value(s, n, dt, val, path);",
          "2232:     }",
          "2234:     Action operator=(Action a) {",
          "2235:         action = a;",
          "2236:         return a;",
          "2237:     }",
          "2239:     template <typename T>",
          "2240:     Definition& operator,(T fn) {",
          "2241:         operator=(fn);",
          "2242:         return *this;",
          "2243:     }",
          "2245:     Definition& operator~() {",
          "2246:         ignoreSemanticValue = true;",
          "2247:         return *this;",
          "2248:     }",
          "2250:     void accept(Ope::Visitor& v) {",
          "2251:         holder_->accept(v);",
          "2252:     }",
          "2254:     std::shared_ptr<Ope> get_core_operator() const {",
          "2255:         return holder_->ope_;",
          "2256:     }",
          "2258:     bool is_token() const {",
          "2259:         std::call_once(is_token_init_, [this]() {",
          "2260:             is_token_ = TokenChecker::is_token(*get_core_operator());",
          "2261:         });",
          "2262:         return is_token_;",
          "2263:     }",
          "2265:     std::string                                                                          name;",
          "2266:     size_t                                                                               id = 0;",
          "2267:     Action                                                                               action;",
          "2268:     std::function<void (const char* s, size_t n, any& dt)>                               enter;",
          "2269:     std::function<void (const char* s, size_t n, size_t matchlen, any& value, any& dt)>  leave;",
          "2270:     std::function<std::string ()>                                                        error_message;",
          "2271:     bool                                                                                 ignoreSemanticValue = false;",
          "2272:     std::shared_ptr<Ope>                                                                 whitespaceOpe;",
          "2273:     std::shared_ptr<Ope>                                                                 wordOpe;",
          "2274:     bool                                                                                 enablePackratParsing = false;",
          "2275:     bool                                                                                 is_macro = false;",
          "2276:     std::vector<std::string>                                                             params;",
          "2277:     TracerEnter                                                                          tracer_enter;",
          "2278:     TracerLeave                                                                          tracer_leave;",
          "2281:     friend class Reference;",
          "2283:     Definition& operator=(const Definition& rhs);",
          "2284:     Definition& operator=(Definition&& rhs);",
          "2286:     void initialize_definition_ids() const {",
          "2287:         std::call_once(definition_ids_init_, [&]() {",
          "2288:             AssignIDToDefinition vis;",
          "2289:             holder_->accept(vis);",
          "2290:             if (whitespaceOpe) {",
          "2291:                 whitespaceOpe->accept(vis);",
          "2292:             }",
          "2293:             if (wordOpe) {",
          "2294:                 wordOpe->accept(vis);",
          "2295:             }",
          "2296:             definition_ids_.swap(vis.ids);",
          "2297:         });",
          "2298:     }",
          "2300:     Result parse_core(const char* s, size_t n, SemanticValues& sv, any& dt, const char* path) const {",
          "2301:         initialize_definition_ids();",
          "2303:         std::shared_ptr<Ope> ope = holder_;",
          "2304:         if (whitespaceOpe) {",
          "2305:             ope = std::make_shared<Sequence>(whitespaceOpe, ope);",
          "2306:         }",
          "2308:         Context cxt(",
          "2309:             path, s, n,",
          "2310:             definition_ids_.size(),",
          "2311:             whitespaceOpe, wordOpe,",
          "2312:             enablePackratParsing,",
          "2313:             tracer_enter, tracer_leave);",
          "2315:         auto len = ope->parse(s, n, sv, cxt, dt);",
          "2316:         return Result{ success(len), len, cxt.error_pos, cxt.message_pos, cxt.message };",
          "2317:     }",
          "2319:     std::shared_ptr<Holder> holder_;",
          "2320:     mutable std::once_flag  is_token_init_;",
          "2321:     mutable bool            is_token_ = false;",
          "2322:     mutable std::once_flag  assign_id_to_definition_init_;",
          "2323:     mutable std::once_flag  definition_ids_init_;",
          "2324:     mutable std::unordered_map<void*, size_t> definition_ids_;",
          "2331: inline size_t parse_literal(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt,",
          "2332:         const std::string& lit, bool& init_is_word, bool& is_word, bool ignore_case)",
          "2333: {",
          "2334:     size_t i = 0;",
          "2335:     for (; i < lit.size(); i++) {",
          "2336:         if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i])) : (s[i] != lit[i]))) {",
          "2337:             c.set_error_pos(s);",
          "2338:             return static_cast<size_t>(-1);",
          "2339:         }",
          "2343:     static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr, nullptr);",
          "2344:     static SemanticValues dummy_sv;",
          "2345:     static any dummy_dt;",
          "2347:     if (!init_is_word) { // TODO: Protect with mutex",
          "2348:         if (c.wordOpe) {",
          "2349:             auto len = c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);",
          "2350:             is_word = success(len);",
          "2351:         }",
          "2352:         init_is_word = true;",
          "2355:     if (is_word) {",
          "2356:         auto ope = std::make_shared<NotPredicate>(c.wordOpe);",
          "2357:         auto len = ope->parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);",
          "2358:         if (fail(len)) {",
          "2359:             return static_cast<size_t>(-1);",
          "2360:         }",
          "2361:         i += len;",
          "2362:     }",
          "2365:     if (!c.in_token) {",
          "2366:         if (c.whitespaceOpe) {",
          "2367:             auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);",
          "2368:             if (fail(len)) {",
          "2369:                 return static_cast<size_t>(-1);",
          "2370:             }",
          "2371:             i += len;",
          "2372:         }",
          "2375:     return i;",
          "2378: inline void Context::trace_enter(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt) const {",
          "2379:     trace_ids.push_back(next_trace_id++);",
          "2380:     tracer_enter(name, a_s, n, sv, *this, dt);",
          "2383: inline void Context::trace_leave(const char* name, const char* a_s, size_t n, SemanticValues& sv, any& dt, size_t len) const {",
          "2384:     tracer_leave(name, a_s, n, sv, *this, dt, len);",
          "2385:     trace_ids.pop_back();",
          "2388: inline bool Context::is_traceable(const Ope& ope) const {",
          "2389:     if (tracer_enter && tracer_leave) {",
          "2390:         IsReference vis;",
          "2391:         const_cast<Ope&>(ope).accept(vis);",
          "2392:         return !vis.is_reference;",
          "2393:     }",
          "2394:     return false;",
          "2397: inline size_t Ope::parse(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2398:     if (c.is_traceable(*this)) {",
          "2399:         TraceOpeName vis;",
          "2400:         const_cast<Ope&>(*this).accept(vis);",
          "2401:         c.trace_enter(vis.name, s, n, sv, dt);",
          "2402:         auto len = parse_core(s, n, sv, c, dt);",
          "2403:         c.trace_leave(vis.name, s, n, sv, dt, len);",
          "2404:         return len;",
          "2405:     }",
          "2406:     return parse_core(s, n, sv, c, dt);",
          "2409: inline size_t LiteralString::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2410:     return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_, ignore_case_);",
          "2413: inline size_t TokenBoundary::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2414:     c.in_token = true;",
          "2415:     auto se = make_scope_exit([&]() { c.in_token = false; });",
          "2416:     const auto& rule = *ope_;",
          "2417:     auto len = rule.parse(s, n, sv, c, dt);",
          "2418:     if (success(len)) {",
          "2419:         sv.tokens.push_back(std::make_pair(s, len));",
          "2421:         if (c.whitespaceOpe) {",
          "2422:             auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);",
          "2423:             if (fail(l)) {",
          "2424:                 return static_cast<size_t>(-1);",
          "2425:             }",
          "2426:             len += l;",
          "2427:         }",
          "2429:     return len;",
          "2432: inline size_t Holder::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2433:     if (!ope_) {",
          "2434:         throw std::logic_error(\"Uninitialized definition ope was used...\");",
          "2435:     }",
          "2439:     if (outer_->is_macro) {",
          "2440:         return ope_->parse(s, n, sv, c, dt);",
          "2441:     }",
          "2443:     size_t len;",
          "2444:     any    val;",
          "2446:     c.packrat(s, outer_->id, len, val, [&](any& a_val) {",
          "2447:         if (outer_->enter) {",
          "2448:             outer_->enter(s, n, dt);",
          "2449:         }",
          "2451:         auto se2 = make_scope_exit([&]() {",
          "2452:             c.pop();",
          "2454:             if (outer_->leave) {",
          "2455:                 outer_->leave(s, n, len, a_val, dt);",
          "2456:             }",
          "2457:         });",
          "2459:         auto& chldsv = c.push();",
          "2461:         len = ope_->parse(s, n, chldsv, c, dt);",
          "2464:         if (success(len)) {",
          "2465:             chldsv.s_ = s;",
          "2466:             chldsv.n_ = len;",
          "2467:             chldsv.name_ = outer_->name;",
          "2469:             if (!IsPrioritizedChoice::check(*ope_)) {",
          "2470:                 chldsv.choice_count_ = 0;",
          "2471:                 chldsv.choice_ = 0;",
          "2472:             }",
          "2474:             try {",
          "2475:                 a_val = reduce(chldsv, dt);",
          "2476:             } catch (const parse_error& e) {",
          "2477:                 if (e.what()) {",
          "2478:                     if (c.message_pos < s) {",
          "2479:                         c.message_pos = s;",
          "2480:                         c.message = e.what();",
          "2481:                     }",
          "2482:                 }",
          "2483:                 len = static_cast<size_t>(-1);",
          "2484:             }",
          "2485:         }",
          "2489:         if (!outer_->ignoreSemanticValue) {",
          "2490:             sv.emplace_back(val);",
          "2491:             sv.tags.emplace_back(str2tag(outer_->name.c_str()));",
          "2492:         }",
          "2493:     } else {",
          "2494:         if (outer_->error_message) {",
          "2495:             if (c.message_pos < s) {",
          "2496:                 c.message_pos = s;",
          "2497:                 c.message = outer_->error_message();",
          "2498:             }",
          "2502:     return len;",
          "2505: inline any Holder::reduce(SemanticValues& sv, any& dt) const {",
          "2506:     if (outer_->action) {",
          "2507:         return outer_->action(sv, dt);",
          "2508:     } else if (sv.empty()) {",
          "2509:         return any();",
          "2510:     } else {",
          "2511:         return std::move(sv.front());",
          "2512:     }",
          "2515: inline const char* Holder::trace_name() const {",
          "2516:     if (trace_name_.empty()) {",
          "2517:         trace_name_ = \"[\" + outer_->name + \"]\";",
          "2518:     }",
          "2519:     return trace_name_.c_str();",
          "2522: inline size_t Reference::parse_core(",
          "2523:     const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2524:     if (rule_) {",
          "2526:         if (rule_->is_macro) {",
          "2528:             FindReference vis(c.top_args(), rule_->params);",
          "2531:             std::vector<std::shared_ptr<Ope>> args;",
          "2532:             for (auto arg: args_) {",
          "2533:                 arg->accept(vis);",
          "2534:                 args.push_back(vis.found_ope);",
          "2535:             }",
          "2537:             c.push_args(std::move(args));",
          "2538:             auto se = make_scope_exit([&]() { c.pop_args(); });",
          "2539:             auto ope = get_core_operator();",
          "2540:             return ope->parse(s, n, sv, c, dt);",
          "2541:         } else {",
          "2543:             auto ope = get_core_operator();",
          "2544:             return ope->parse(s, n, sv, c, dt);",
          "2545:         }",
          "2548:         const auto& args = c.top_args();",
          "2549:         return args[iarg_]->parse(s, n, sv, c, dt);",
          "2550:     }",
          "2554:     return rule_->holder_;",
          "2555: }",
          "2557: inline size_t BackReference::parse_core(const char* s, size_t n, SemanticValues& sv, Context& c, any& dt) const {",
          "2558:     for (int i = c.capture_scope_stack_size - 1; i >= 0; i--) {",
          "2559:         const auto& cs = c.capture_scope_stack[i];",
          "2560:         if (cs.find(name_) != cs.end()) {",
          "2561:             const auto& lit = cs.at(name_);",
          "2562:             auto init_is_word = false;",
          "2563:             auto is_word = false;",
          "2564:             return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);",
          "2565:         }",
          "2566:     }",
          "2567:     throw std::runtime_error(\"Invalid back reference...\");",
          "2568: }",
          "2570: inline void Sequence::accept(Visitor& v) { v.visit(*this); }",
          "2571: inline void PrioritizedChoice::accept(Visitor& v) { v.visit(*this); }",
          "2572: inline void ZeroOrMore::accept(Visitor& v) { v.visit(*this); }",
          "2573: inline void OneOrMore::accept(Visitor& v) { v.visit(*this); }",
          "2574: inline void Option::accept(Visitor& v) { v.visit(*this); }",
          "2575: inline void AndPredicate::accept(Visitor& v) { v.visit(*this); }",
          "2576: inline void NotPredicate::accept(Visitor& v) { v.visit(*this); }",
          "2577: inline void LiteralString::accept(Visitor& v) { v.visit(*this); }",
          "2578: inline void CharacterClass::accept(Visitor& v) { v.visit(*this); }",
          "2579: inline void Character::accept(Visitor& v) { v.visit(*this); }",
          "2580: inline void AnyCharacter::accept(Visitor& v) { v.visit(*this); }",
          "2581: inline void CaptureScope::accept(Visitor& v) { v.visit(*this); }",
          "2582: inline void Capture::accept(Visitor& v) { v.visit(*this); }",
          "2583: inline void TokenBoundary::accept(Visitor& v) { v.visit(*this); }",
          "2584: inline void Ignore::accept(Visitor& v) { v.visit(*this); }",
          "2585: inline void User::accept(Visitor& v) { v.visit(*this); }",
          "2586: inline void WeakHolder::accept(Visitor& v) { v.visit(*this); }",
          "2587: inline void Holder::accept(Visitor& v) { v.visit(*this); }",
          "2588: inline void Reference::accept(Visitor& v) { v.visit(*this); }",
          "2589: inline void Whitespace::accept(Visitor& v) { v.visit(*this); }",
          "2590: inline void BackReference::accept(Visitor& v) { v.visit(*this); }",
          "2592: inline void AssignIDToDefinition::visit(Holder& ope) {",
          "2593:     auto p = static_cast<void*>(ope.outer_);",
          "2594:     if (ids.count(p)) {",
          "2595:         return;",
          "2596:     }",
          "2597:     auto id = ids.size();",
          "2598:     ids[p] = id;",
          "2599:     ope.outer_->id = id;",
          "2600:     ope.ope_->accept(*this);",
          "2603: inline void AssignIDToDefinition::visit(Reference& ope) {",
          "2604:     if (ope.rule_) {",
          "2605:         for (auto arg: ope.args_) {",
          "2606:             arg->accept(*this);",
          "2607:         }",
          "2608:         ope.rule_->accept(*this);",
          "2612: inline void TokenChecker::visit(Reference& ope) {",
          "2613:     if (ope.is_macro_) {",
          "2614:         ope.rule_->accept(*this);",
          "2615:         for (auto arg: ope.args_) {",
          "2616:             arg->accept(*this);",
          "2617:         }",
          "2618:     } else {",
          "2619:         has_rule_ = true;",
          "2623: inline void DetectLeftRecursion::visit(Reference& ope) {",
          "2624:     if (ope.name_ == name_) {",
          "2625:         error_s = ope.s_;",
          "2626:     } else if (!refs_.count(ope.name_)) {",
          "2627:         refs_.insert(ope.name_);",
          "2628:         if (ope.rule_) {",
          "2629:             ope.rule_->accept(*this);",
          "2630:             if (done_ == false) {",
          "2631:                 return;",
          "2632:             }",
          "2633:         }",
          "2635:     done_ = true;",
          "2638: inline void HasEmptyElement::visit(Reference& ope) {",
          "2639:     auto it = std::find_if(refs_.begin(), refs_.end(),",
          "2640:         [&](const std::pair<const char*, std::string>& ref) {",
          "2641:             return ope.name_ == ref.second;",
          "2642:         }",
          "2643:     );",
          "2644:     if (it != refs_.end()) {",
          "2645:         return;",
          "2646:     }",
          "2648:     if (ope.rule_) {",
          "2649:         refs_.emplace_back(ope.s_, ope.name_);",
          "2650:         ope.rule_->accept(*this);",
          "2651:         refs_.pop_back();",
          "2652:     }",
          "2655: inline void DetectInfiniteLoop::visit(Reference& ope) {",
          "2656:     auto it = std::find_if(refs_.begin(), refs_.end(),",
          "2657:         [&](const std::pair<const char*, std::string>& ref) {",
          "2658:             return ope.name_ == ref.second;",
          "2659:         }",
          "2660:     );",
          "2661:     if (it != refs_.end()) {",
          "2662:         return;",
          "2663:     }",
          "2665:     if (ope.rule_) {",
          "2666:         refs_.emplace_back(ope.s_, ope.name_);",
          "2667:         ope.rule_->accept(*this);",
          "2668:         refs_.pop_back();",
          "2669:     }",
          "2672: inline void ReferenceChecker::visit(Reference& ope) {",
          "2673:     auto it = std::find(params_.begin(), params_.end(), ope.name_);",
          "2674:     if (it != params_.end()) {",
          "2675:         return;",
          "2676:     }",
          "2678:     if (!grammar_.count(ope.name_)) {",
          "2680:         error_message[ope.name_] = \"'\" + ope.name_ + \"' is not defined.\";",
          "2681:     } else {",
          "2682:         const auto& rule = grammar_.at(ope.name_);",
          "2683:         if (rule.is_macro) {",
          "2684:             if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {",
          "2685:                 error_s[ope.name_] = ope.s_;",
          "2686:                 error_message[ope.name_] = \"incorrect number of arguments.\";",
          "2687:             }",
          "2688:         } else if (ope.is_macro_) {",
          "2689:             error_s[ope.name_] = ope.s_;",
          "2690:             error_message[ope.name_] = \"'\" + ope.name_ + \"' is not macro.\";",
          "2691:         }",
          "2695: inline void LinkReferences::visit(Reference& ope) {",
          "2697:     auto found_param = false;",
          "2698:     for (size_t i = 0; i < params_.size(); i++) {",
          "2699:         const auto& param = params_[i];",
          "2700:         if (param == ope.name_) {",
          "2701:             ope.iarg_ = i;",
          "2702:             found_param = true;",
          "2703:             break;",
          "2704:         }",
          "2708:     if (!found_param && grammar_.count(ope.name_)) {",
          "2709:         auto& rule = grammar_.at(ope.name_);",
          "2710:         ope.rule_ = &rule;",
          "2711:     }",
          "2713:     for (auto arg: ope.args_) {",
          "2714:         arg->accept(*this);",
          "2715:     }",
          "2718: inline void FindReference::visit(Reference& ope) {",
          "2719:     for (size_t i = 0; i < args_.size(); i++) {",
          "2720:         const auto& name = params_[i];",
          "2721:         if (name == ope.name_) {",
          "2722:             found_ope = args_[i];",
          "2723:             return;",
          "2724:         }",
          "2726:     found_ope = ope.shared_from_this();",
          "",
          "[Added Lines]",
          "765: typedef std::function<void(const char *name, const char *s, size_t n,",
          "766:                            const SemanticValues &sv, const Context &c,",
          "767:                            const any &dt)>",
          "768:     TracerEnter;",
          "770: typedef std::function<void(const char *name, const char *s, size_t n,",
          "771:                            const SemanticValues &sv, const Context &c,",
          "772:                            const any &dt, size_t)>",
          "773:     TracerLeave;",
          "775: class Context {",
          "777:   const char *path;",
          "778:   const char *s;",
          "779:   const size_t l;",
          "780:   std::vector<size_t> source_line_index;",
          "782:   const char *error_pos = nullptr;",
          "783:   const char *message_pos = nullptr;",
          "784:   std::string message; // TODO: should be `int`.",
          "786:   std::vector<std::shared_ptr<SemanticValues>> value_stack;",
          "787:   size_t value_stack_size = 0;",
          "788:   std::vector<std::vector<std::shared_ptr<Ope>>> args_stack;",
          "790:   bool in_token = false;",
          "792:   std::shared_ptr<Ope> whitespaceOpe;",
          "793:   bool in_whitespace = false;",
          "795:   std::shared_ptr<Ope> wordOpe;",
          "797:   std::vector<std::map<std::string, std::string>> capture_scope_stack;",
          "798:   size_t capture_scope_stack_size = 0;",
          "800:   const size_t def_count;",
          "801:   const bool enablePackratParsing;",
          "802:   std::vector<bool> cache_registered;",
          "803:   std::vector<bool> cache_success;",
          "805:   std::map<std::pair<size_t, size_t>, std::tuple<size_t, any>> cache_values;",
          "807:   TracerEnter tracer_enter;",
          "808:   TracerLeave tracer_leave;",
          "810:   Context(const char *a_path, const char *a_s, size_t a_l, size_t a_def_count,",
          "811:           std::shared_ptr<Ope> a_whitespaceOpe, std::shared_ptr<Ope> a_wordOpe,",
          "812:           bool a_enablePackratParsing, TracerEnter a_tracer_enter,",
          "813:           TracerLeave a_tracer_leave)",
          "814:       : path(a_path), s(a_s), l(a_l), whitespaceOpe(a_whitespaceOpe),",
          "815:         wordOpe(a_wordOpe), def_count(a_def_count),",
          "816:         enablePackratParsing(a_enablePackratParsing),",
          "817:         cache_registered(enablePackratParsing ? def_count * (l + 1) : 0),",
          "818:         cache_success(enablePackratParsing ? def_count * (l + 1) : 0),",
          "819:         tracer_enter(a_tracer_enter), tracer_leave(a_tracer_leave) {",
          "821:     for (size_t pos = 0; pos < l; pos++) {",
          "822:       if (s[pos] == '\\n') { source_line_index.push_back(pos); }",
          "824:     source_line_index.push_back(l);",
          "826:     args_stack.resize(1);",
          "828:     push_capture_scope();",
          "829:   }",
          "831:   ~Context() { assert(!value_stack_size); }",
          "833:   Context(const Context &) = delete;",
          "834:   Context(Context &&) = delete;",
          "835:   Context operator=(const Context &) = delete;",
          "837:   template <typename T>",
          "838:   void packrat(const char *a_s, size_t def_id, size_t &len, any &val, T fn) {",
          "839:     if (!enablePackratParsing) {",
          "840:       fn(val);",
          "841:       return;",
          "844:     auto col = a_s - s;",
          "845:     auto idx = def_count * static_cast<size_t>(col) + def_id;",
          "847:     if (cache_registered[idx]) {",
          "848:       if (cache_success[idx]) {",
          "849:         auto key = std::make_pair(col, def_id);",
          "850:         std::tie(len, val) = cache_values[key];",
          "851:         return;",
          "852:       } else {",
          "853:         len = static_cast<size_t>(-1);",
          "854:         return;",
          "855:       }",
          "856:     } else {",
          "857:       fn(val);",
          "858:       cache_registered[idx] = true;",
          "859:       cache_success[idx] = success(len);",
          "860:       if (success(len)) {",
          "861:         auto key = std::make_pair(col, def_id);",
          "862:         cache_values[key] = std::make_pair(len, val);",
          "863:       }",
          "864:       return;",
          "866:   }",
          "868:   SemanticValues &push() {",
          "869:     assert(value_stack_size <= value_stack.size());",
          "870:     if (value_stack_size == value_stack.size()) {",
          "871:       value_stack.emplace_back(std::make_shared<SemanticValues>());",
          "872:     } else {",
          "873:       auto &sv = *value_stack[value_stack_size];",
          "874:       if (!sv.empty()) {",
          "875:         sv.clear();",
          "876:         sv.tags.clear();",
          "877:       }",
          "878:       sv.s_ = nullptr;",
          "879:       sv.n_ = 0;",
          "880:       sv.choice_count_ = 0;",
          "881:       sv.choice_ = 0;",
          "882:       sv.tokens.clear();",
          "883:     }",
          "885:     auto &sv = *value_stack[value_stack_size++];",
          "886:     sv.path = path;",
          "887:     sv.ss = s;",
          "888:     sv.source_line_index = &source_line_index;",
          "889:     return sv;",
          "890:   }",
          "892:   void pop() { value_stack_size--; }",
          "894:   void push_args(std::vector<std::shared_ptr<Ope>> &&args) {",
          "895:     args_stack.emplace_back(args);",
          "896:   }",
          "898:   void pop_args() { args_stack.pop_back(); }",
          "900:   const std::vector<std::shared_ptr<Ope>> &top_args() const {",
          "901:     return args_stack[args_stack.size() - 1];",
          "902:   }",
          "904:   void push_capture_scope() {",
          "905:     assert(capture_scope_stack_size <= capture_scope_stack.size());",
          "906:     if (capture_scope_stack_size == capture_scope_stack.size()) {",
          "907:       capture_scope_stack.emplace_back(std::map<std::string, std::string>());",
          "908:     } else {",
          "909:       auto &cs = capture_scope_stack[capture_scope_stack_size];",
          "910:       cs.clear();",
          "912:     capture_scope_stack_size++;",
          "913:   }",
          "915:   void pop_capture_scope() { capture_scope_stack_size--; }",
          "917:   void shift_capture_values() {",
          "918:     assert(capture_scope_stack.size() >= 2);",
          "919:     auto curr = &capture_scope_stack[capture_scope_stack_size - 1];",
          "920:     auto prev = curr - 1;",
          "921:     for (const auto &kv : *curr) {",
          "922:       (*prev)[kv.first] = kv.second;",
          "924:   }",
          "926:   void set_error_pos(const char *a_s) {",
          "927:     if (error_pos < a_s) error_pos = a_s;",
          "928:   }",
          "930:   void trace_enter(const char *name, const char *a_s, size_t n,",
          "931:                    SemanticValues &sv, any &dt) const;",
          "932:   void trace_leave(const char *name, const char *a_s, size_t n,",
          "933:                    SemanticValues &sv, any &dt, size_t len) const;",
          "934:   bool is_traceable(const Ope &ope) const;",
          "936:   mutable size_t next_trace_id = 0;",
          "937:   mutable std::list<size_t> trace_ids;",
          "943: class Ope {",
          "945:   struct Visitor;",
          "947:   virtual ~Ope() {}",
          "948:   size_t parse(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "949:                any &dt) const;",
          "950:   virtual size_t parse_core(const char *s, size_t n, SemanticValues &sv,",
          "951:                             Context &c, any &dt) const = 0;",
          "952:   virtual void accept(Visitor &v) = 0;",
          "953: };",
          "955: class Sequence : public Ope {",
          "956: public:",
          "957:   template <typename... Args>",
          "958:   Sequence(const Args &... args)",
          "959:       : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}",
          "960:   Sequence(const std::vector<std::shared_ptr<Ope>> &opes) : opes_(opes) {}",
          "961:   Sequence(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}",
          "963:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "964:                     any &dt) const override {",
          "965:     auto &chldsv = c.push();",
          "966:     auto pop_se = make_scope_exit([&]() { c.pop(); });",
          "967:     size_t i = 0;",
          "968:     for (const auto &ope : opes_) {",
          "969:       const auto &rule = *ope;",
          "970:       auto len = rule.parse(s + i, n - i, chldsv, c, dt);",
          "971:       if (fail(len)) { return static_cast<size_t>(-1); }",
          "972:       i += len;",
          "973:     }",
          "974:     if (!chldsv.empty()) {",
          "975:       for (size_t i = 0; i < chldsv.size(); i++) {",
          "976:         sv.emplace_back(std::move(chldsv[i]));",
          "977:       }",
          "978:     }",
          "979:     if (!chldsv.tags.empty()) {",
          "980:       for (size_t i = 0; i < chldsv.tags.size(); i++) {",
          "981:         sv.tags.emplace_back(std::move(chldsv.tags[i]));",
          "982:       }",
          "983:     }",
          "984:     sv.s_ = chldsv.c_str();",
          "985:     sv.n_ = chldsv.length();",
          "986:     if (!chldsv.tokens.empty()) {",
          "987:       for (size_t i = 0; i < chldsv.tokens.size(); i++) {",
          "988:         sv.tokens.emplace_back(std::move(chldsv.tokens[i]));",
          "989:       }",
          "990:     }",
          "991:     return i;",
          "992:   }",
          "994:   void accept(Visitor &v) override;",
          "996:   std::vector<std::shared_ptr<Ope>> opes_;",
          "999: class PrioritizedChoice : public Ope {",
          "1001:   template <typename... Args>",
          "1002:   PrioritizedChoice(const Args &... args)",
          "1003:       : opes_{static_cast<std::shared_ptr<Ope>>(args)...} {}",
          "1004:   PrioritizedChoice(const std::vector<std::shared_ptr<Ope>> &opes)",
          "1005:       : opes_(opes) {}",
          "1006:   PrioritizedChoice(std::vector<std::shared_ptr<Ope>> &&opes) : opes_(opes) {}",
          "1008:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1009:                     any &dt) const override {",
          "1010:     size_t id = 0;",
          "1011:     for (const auto &ope : opes_) {",
          "1012:       auto &chldsv = c.push();",
          "1013:       c.push_capture_scope();",
          "1014:       auto se = make_scope_exit([&]() {",
          "1015:         c.pop();",
          "1016:         c.pop_capture_scope();",
          "1017:       });",
          "1018:       const auto &rule = *ope;",
          "1019:       auto len = rule.parse(s, n, chldsv, c, dt);",
          "1020:       if (success(len)) {",
          "1022:           for (size_t i = 0; i < chldsv.size(); i++) {",
          "1023:             sv.emplace_back(std::move(chldsv[i]));",
          "1024:           }",
          "1027:           for (size_t i = 0; i < chldsv.tags.size(); i++) {",
          "1028:             sv.tags.emplace_back(std::move(chldsv.tags[i]));",
          "1029:           }",
          "1033:         sv.choice_count_ = opes_.size();",
          "1034:         sv.choice_ = id;",
          "1036:           for (size_t i = 0; i < chldsv.tokens.size(); i++) {",
          "1037:             sv.tokens.emplace_back(std::move(chldsv.tokens[i]));",
          "1038:           }",
          "1041:         c.shift_capture_values();",
          "1042:         return len;",
          "1043:       }",
          "1044:       id++;",
          "1046:     return static_cast<size_t>(-1);",
          "1047:   }",
          "1049:   void accept(Visitor &v) override;",
          "1051:   size_t size() const { return opes_.size(); }",
          "1053:   std::vector<std::shared_ptr<Ope>> opes_;",
          "1056: class ZeroOrMore : public Ope {",
          "1058:   ZeroOrMore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1060:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1061:                     any &dt) const override {",
          "1062:     auto save_error_pos = c.error_pos;",
          "1063:     size_t i = 0;",
          "1064:     while (n - i > 0) {",
          "1065:       c.push_capture_scope();",
          "1066:       auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1067:       auto save_sv_size = sv.size();",
          "1068:       auto save_tok_size = sv.tokens.size();",
          "1069:       const auto &rule = *ope_;",
          "1070:       auto len = rule.parse(s + i, n - i, sv, c, dt);",
          "1071:       if (success(len)) {",
          "1072:         c.shift_capture_values();",
          "1073:       } else {",
          "1074:         if (sv.size() != save_sv_size) {",
          "1075:           sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1076:           sv.tags.erase(sv.tags.begin() +",
          "1077:                         static_cast<std::ptrdiff_t>(save_sv_size));",
          "1078:         }",
          "1079:         if (sv.tokens.size() != save_tok_size) {",
          "1080:           sv.tokens.erase(sv.tokens.begin() +",
          "1081:                           static_cast<std::ptrdiff_t>(save_tok_size));",
          "1082:         }",
          "1083:         c.error_pos = save_error_pos;",
          "1084:         break;",
          "1085:       }",
          "1086:       i += len;",
          "1088:     return i;",
          "1089:   }",
          "1091:   void accept(Visitor &v) override;",
          "1093:   std::shared_ptr<Ope> ope_;",
          "1096: class OneOrMore : public Ope {",
          "1098:   OneOrMore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1100:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1101:                     any &dt) const override {",
          "1102:     size_t len = 0;",
          "1103:     {",
          "1104:       c.push_capture_scope();",
          "1105:       auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1106:       const auto &rule = *ope_;",
          "1107:       len = rule.parse(s, n, sv, c, dt);",
          "1108:       if (success(len)) {",
          "1109:         c.shift_capture_values();",
          "1110:       } else {",
          "1111:         return static_cast<size_t>(-1);",
          "1112:       }",
          "1114:     auto save_error_pos = c.error_pos;",
          "1115:     auto i = len;",
          "1116:     while (n - i > 0) {",
          "1117:       c.push_capture_scope();",
          "1118:       auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1119:       auto save_sv_size = sv.size();",
          "1120:       auto save_tok_size = sv.tokens.size();",
          "1121:       const auto &rule = *ope_;",
          "1122:       len = rule.parse(s + i, n - i, sv, c, dt);",
          "1123:       if (success(len)) {",
          "1124:         c.shift_capture_values();",
          "1125:       } else {",
          "1126:         if (sv.size() != save_sv_size) {",
          "1127:           sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1128:           sv.tags.erase(sv.tags.begin() +",
          "1129:                         static_cast<std::ptrdiff_t>(save_sv_size));",
          "1130:         }",
          "1131:         if (sv.tokens.size() != save_tok_size) {",
          "1132:           sv.tokens.erase(sv.tokens.begin() +",
          "1133:                           static_cast<std::ptrdiff_t>(save_tok_size));",
          "1134:         }",
          "1135:         c.error_pos = save_error_pos;",
          "1136:         break;",
          "1137:       }",
          "1138:       i += len;",
          "1139:     }",
          "1140:     return i;",
          "1141:   }",
          "1143:   void accept(Visitor &v) override;",
          "1145:   std::shared_ptr<Ope> ope_;",
          "1148: class Option : public Ope {",
          "1150:   Option(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1152:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1153:                     any &dt) const override {",
          "1154:     auto save_error_pos = c.error_pos;",
          "1155:     auto save_sv_size = sv.size();",
          "1156:     auto save_tok_size = sv.tokens.size();",
          "1157:     c.push_capture_scope();",
          "1158:     auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1159:     const auto &rule = *ope_;",
          "1160:     auto len = rule.parse(s, n, sv, c, dt);",
          "1161:     if (success(len)) {",
          "1162:       c.shift_capture_values();",
          "1163:       return len;",
          "1164:     } else {",
          "1165:       if (sv.size() != save_sv_size) {",
          "1166:         sv.erase(sv.begin() + static_cast<std::ptrdiff_t>(save_sv_size));",
          "1167:         sv.tags.erase(sv.tags.begin() +",
          "1168:                       static_cast<std::ptrdiff_t>(save_sv_size));",
          "1169:       }",
          "1170:       if (sv.tokens.size() != save_tok_size) {",
          "1171:         sv.tokens.erase(sv.tokens.begin() +",
          "1172:                         static_cast<std::ptrdiff_t>(save_tok_size));",
          "1173:       }",
          "1174:       c.error_pos = save_error_pos;",
          "1175:       return 0;",
          "1177:   }",
          "1179:   void accept(Visitor &v) override;",
          "1181:   std::shared_ptr<Ope> ope_;",
          "1184: class AndPredicate : public Ope {",
          "1186:   AndPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1188:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1189:                     any &dt) const override {",
          "1190:     auto &chldsv = c.push();",
          "1191:     c.push_capture_scope();",
          "1192:     auto se = make_scope_exit([&]() {",
          "1193:       c.pop();",
          "1194:       c.pop_capture_scope();",
          "1195:     });",
          "1196:     const auto &rule = *ope_;",
          "1197:     auto len = rule.parse(s, n, chldsv, c, dt);",
          "1198:     if (success(len)) {",
          "1199:       return 0;",
          "1200:     } else {",
          "1201:       return static_cast<size_t>(-1);",
          "1203:   }",
          "1205:   void accept(Visitor &v) override;",
          "1207:   std::shared_ptr<Ope> ope_;",
          "1210: class NotPredicate : public Ope {",
          "1212:   NotPredicate(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1214:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1215:                     any &dt) const override {",
          "1216:     auto save_error_pos = c.error_pos;",
          "1217:     auto &chldsv = c.push();",
          "1218:     c.push_capture_scope();",
          "1219:     auto se = make_scope_exit([&]() {",
          "1220:       c.pop();",
          "1221:       c.pop_capture_scope();",
          "1222:     });",
          "1223:     const auto &rule = *ope_;",
          "1224:     auto len = rule.parse(s, n, chldsv, c, dt);",
          "1225:     if (success(len)) {",
          "1226:       c.set_error_pos(s);",
          "1227:       return static_cast<size_t>(-1);",
          "1228:     } else {",
          "1229:       c.error_pos = save_error_pos;",
          "1230:       return 0;",
          "1232:   }",
          "1234:   void accept(Visitor &v) override;",
          "1236:   std::shared_ptr<Ope> ope_;",
          "1239: class LiteralString : public Ope,",
          "1240:                       public std::enable_shared_from_this<LiteralString> {",
          "1242:   LiteralString(const std::string &s, bool ignore_case)",
          "1243:       : lit_(s), ignore_case_(ignore_case), init_is_word_(false),",
          "1244:         is_word_(false) {}",
          "1246:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1247:                     any &dt) const override;",
          "1249:   void accept(Visitor &v) override;",
          "1251:   std::string lit_;",
          "1252:   bool ignore_case_;",
          "1253:   mutable bool init_is_word_;",
          "1254:   mutable bool is_word_;",
          "1257: class CharacterClass : public Ope,",
          "1258:                        public std::enable_shared_from_this<CharacterClass> {",
          "1260:   CharacterClass(const std::string &s, bool negated) : negated_(negated) {",
          "1261:     auto chars = decode(s.c_str(), s.length());",
          "1262:     auto i = 0u;",
          "1263:     while (i < chars.size()) {",
          "1264:       if (i + 2 < chars.size() && chars[i + 1] == '-') {",
          "1265:         auto cp1 = chars[i];",
          "1266:         auto cp2 = chars[i + 2];",
          "1267:         ranges_.emplace_back(std::make_pair(cp1, cp2));",
          "1268:         i += 3;",
          "1269:       } else {",
          "1270:         auto cp = chars[i];",
          "1271:         ranges_.emplace_back(std::make_pair(cp, cp));",
          "1272:         i += 1;",
          "1273:       }",
          "1275:     assert(!ranges_.empty());",
          "1276:   }",
          "1278:   CharacterClass(const std::vector<std::pair<char32_t, char32_t>> &ranges,",
          "1279:                  bool negated)",
          "1280:       : ranges_(ranges), negated_(negated) {",
          "1281:     assert(!ranges_.empty());",
          "1282:   }",
          "1284:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1285:                     any &dt) const override {",
          "1286:     if (n < 1) {",
          "1287:       c.set_error_pos(s);",
          "1288:       return static_cast<size_t>(-1);",
          "1291:     char32_t cp = 0;",
          "1292:     auto len = decode_codepoint(s, n, cp);",
          "1294:     for (const auto &range : ranges_) {",
          "1295:       if (range.first <= cp && cp <= range.second) {",
          "1297:           c.set_error_pos(s);",
          "1298:           return static_cast<size_t>(-1);",
          "1300:           return len;",
          "1302:       }",
          "1305:     if (negated_) {",
          "1306:       return len;",
          "1307:     } else {",
          "1308:       c.set_error_pos(s);",
          "1309:       return static_cast<size_t>(-1);",
          "1310:     }",
          "1311:   }",
          "1313:   void accept(Visitor &v) override;",
          "1315:   std::vector<std::pair<char32_t, char32_t>> ranges_;",
          "1316:   bool negated_;",
          "1319: class Character : public Ope, public std::enable_shared_from_this<Character> {",
          "1321:   Character(char ch) : ch_(ch) {}",
          "1323:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1324:                     any &dt) const override {",
          "1325:     if (n < 1 || s[0] != ch_) {",
          "1326:       c.set_error_pos(s);",
          "1327:       return static_cast<size_t>(-1);",
          "1329:     return 1;",
          "1330:   }",
          "1332:   void accept(Visitor &v) override;",
          "1334:   char ch_;",
          "1337: class AnyCharacter : public Ope,",
          "1338:                      public std::enable_shared_from_this<AnyCharacter> {",
          "1340:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1341:                     any &dt) const override {",
          "1342:     auto len = codepoint_length(s, n);",
          "1343:     if (len < 1) {",
          "1344:       c.set_error_pos(s);",
          "1345:       return static_cast<size_t>(-1);",
          "1347:     return len;",
          "1348:   }",
          "1350:   void accept(Visitor &v) override;",
          "1353: class CaptureScope : public Ope {",
          "1355:   CaptureScope(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1357:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1358:                     any &dt) const override {",
          "1359:     c.push_capture_scope();",
          "1360:     auto se = make_scope_exit([&]() { c.pop_capture_scope(); });",
          "1361:     const auto &rule = *ope_;",
          "1362:     auto len = rule.parse(s, n, sv, c, dt);",
          "1363:     return len;",
          "1364:   }",
          "1366:   void accept(Visitor &v) override;",
          "1368:   std::shared_ptr<Ope> ope_;",
          "1371: class Capture : public Ope {",
          "1373:   typedef std::function<void(const char *s, size_t n, Context &c)> MatchAction;",
          "1375:   Capture(const std::shared_ptr<Ope> &ope, MatchAction ma)",
          "1376:       : ope_(ope), match_action_(ma) {}",
          "1378:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1379:                     any &dt) const override {",
          "1380:     const auto &rule = *ope_;",
          "1381:     auto len = rule.parse(s, n, sv, c, dt);",
          "1382:     if (success(len) && match_action_) { match_action_(s, len, c); }",
          "1383:     return len;",
          "1384:   }",
          "1386:   void accept(Visitor &v) override;",
          "1388:   std::shared_ptr<Ope> ope_;",
          "1389:   MatchAction match_action_;",
          "1392: class TokenBoundary : public Ope {",
          "1394:   TokenBoundary(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1396:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1397:                     any &dt) const override;",
          "1399:   void accept(Visitor &v) override;",
          "1401:   std::shared_ptr<Ope> ope_;",
          "1404: class Ignore : public Ope {",
          "1406:   Ignore(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1408:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1409:                     any &dt) const override {",
          "1410:     const auto &rule = *ope_;",
          "1411:     auto &chldsv = c.push();",
          "1412:     auto se = make_scope_exit([&]() { c.pop(); });",
          "1413:     return rule.parse(s, n, chldsv, c, dt);",
          "1414:   }",
          "1416:   void accept(Visitor &v) override;",
          "1418:   std::shared_ptr<Ope> ope_;",
          "1421: typedef std::function<size_t(const char *s, size_t n, SemanticValues &sv,",
          "1422:                              any &dt)>",
          "1423:     Parser;",
          "1425: class User : public Ope {",
          "1427:   User(Parser fn) : fn_(fn) {}",
          "1428:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1429:                     any &dt) const override {",
          "1430:     assert(fn_);",
          "1431:     return fn_(s, n, sv, dt);",
          "1432:   }",
          "1433:   void accept(Visitor &v) override;",
          "1434:   std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>",
          "1435:       fn_;",
          "1438: class WeakHolder : public Ope {",
          "1440:   WeakHolder(const std::shared_ptr<Ope> &ope) : weak_(ope) {}",
          "1442:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1443:                     any &dt) const override {",
          "1444:     auto ope = weak_.lock();",
          "1445:     assert(ope);",
          "1446:     const auto &rule = *ope;",
          "1447:     return rule.parse(s, n, sv, c, dt);",
          "1448:   }",
          "1450:   void accept(Visitor &v) override;",
          "1452:   std::weak_ptr<Ope> weak_;",
          "1455: class Holder : public Ope {",
          "1457:   Holder(Definition *outer) : outer_(outer) {}",
          "1459:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1460:                     any &dt) const override;",
          "1462:   void accept(Visitor &v) override;",
          "1464:   any reduce(SemanticValues &sv, any &dt) const;",
          "1466:   const char *trace_name() const;",
          "1468:   std::shared_ptr<Ope> ope_;",
          "1469:   Definition *outer_;",
          "1470:   mutable std::string trace_name_;",
          "1472:   friend class Definition;",
          "1477: class Reference : public Ope, public std::enable_shared_from_this<Reference> {",
          "1479:   Reference(const Grammar &grammar, const std::string &name, const char *s,",
          "1480:             bool is_macro, const std::vector<std::shared_ptr<Ope>> &args)",
          "1481:       : grammar_(grammar), name_(name), s_(s), is_macro_(is_macro), args_(args),",
          "1482:         rule_(nullptr), iarg_(0) {}",
          "1484:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1485:                     any &dt) const override;",
          "1487:   void accept(Visitor &v) override;",
          "1489:   std::shared_ptr<Ope> get_core_operator() const;",
          "1491:   const Grammar &grammar_;",
          "1492:   const std::string name_;",
          "1493:   const char *s_;",
          "1495:   const bool is_macro_;",
          "1496:   const std::vector<std::shared_ptr<Ope>> args_;",
          "1498:   Definition *rule_;",
          "1499:   size_t iarg_;",
          "1502: class Whitespace : public Ope {",
          "1504:   Whitespace(const std::shared_ptr<Ope> &ope) : ope_(ope) {}",
          "1506:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1507:                     any &dt) const override {",
          "1508:     if (c.in_whitespace) { return 0; }",
          "1509:     c.in_whitespace = true;",
          "1510:     auto se = make_scope_exit([&]() { c.in_whitespace = false; });",
          "1511:     const auto &rule = *ope_;",
          "1512:     return rule.parse(s, n, sv, c, dt);",
          "1513:   }",
          "1515:   void accept(Visitor &v) override;",
          "1517:   std::shared_ptr<Ope> ope_;",
          "1520: class BackReference : public Ope {",
          "1522:   BackReference(const std::string &name) : name_(name) {}",
          "1524:   size_t parse_core(const char *s, size_t n, SemanticValues &sv, Context &c,",
          "1525:                     any &dt) const override;",
          "1527:   void accept(Visitor &v) override;",
          "1529:   std::string name_;",
          "1535: template <typename... Args> std::shared_ptr<Ope> seq(Args &&... args) {",
          "1536:   return std::make_shared<Sequence>(static_cast<std::shared_ptr<Ope>>(args)...);",
          "1539: template <typename... Args> std::shared_ptr<Ope> cho(Args &&... args) {",
          "1540:   return std::make_shared<PrioritizedChoice>(",
          "1541:       static_cast<std::shared_ptr<Ope>>(args)...);",
          "1544: inline std::shared_ptr<Ope> zom(const std::shared_ptr<Ope> &ope) {",
          "1545:   return std::make_shared<ZeroOrMore>(ope);",
          "1548: inline std::shared_ptr<Ope> oom(const std::shared_ptr<Ope> &ope) {",
          "1549:   return std::make_shared<OneOrMore>(ope);",
          "1552: inline std::shared_ptr<Ope> opt(const std::shared_ptr<Ope> &ope) {",
          "1553:   return std::make_shared<Option>(ope);",
          "1556: inline std::shared_ptr<Ope> apd(const std::shared_ptr<Ope> &ope) {",
          "1557:   return std::make_shared<AndPredicate>(ope);",
          "1560: inline std::shared_ptr<Ope> npd(const std::shared_ptr<Ope> &ope) {",
          "1561:   return std::make_shared<NotPredicate>(ope);",
          "1564: inline std::shared_ptr<Ope> lit(const std::string &s) {",
          "1565:   return std::make_shared<LiteralString>(s, false);",
          "1568: inline std::shared_ptr<Ope> liti(const std::string &s) {",
          "1569:   return std::make_shared<LiteralString>(s, true);",
          "1572: inline std::shared_ptr<Ope> cls(const std::string &s) {",
          "1573:   return std::make_shared<CharacterClass>(s, false);",
          "1576: inline std::shared_ptr<Ope>",
          "1577: cls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {",
          "1578:   return std::make_shared<CharacterClass>(ranges, false);",
          "1581: inline std::shared_ptr<Ope> ncls(const std::string &s) {",
          "1582:   return std::make_shared<CharacterClass>(s, true);",
          "1585: inline std::shared_ptr<Ope>",
          "1586: ncls(const std::vector<std::pair<char32_t, char32_t>> &ranges) {",
          "1587:   return std::make_shared<CharacterClass>(ranges, true);",
          "1591:   return std::make_shared<Character>(dt);",
          "1594: inline std::shared_ptr<Ope> dot() { return std::make_shared<AnyCharacter>(); }",
          "1596: inline std::shared_ptr<Ope> csc(const std::shared_ptr<Ope> &ope) {",
          "1597:   return std::make_shared<CaptureScope>(ope);",
          "1600: inline std::shared_ptr<Ope> cap(const std::shared_ptr<Ope> &ope,",
          "1601:                                 Capture::MatchAction ma) {",
          "1602:   return std::make_shared<Capture>(ope, ma);",
          "1605: inline std::shared_ptr<Ope> tok(const std::shared_ptr<Ope> &ope) {",
          "1606:   return std::make_shared<TokenBoundary>(ope);",
          "1609: inline std::shared_ptr<Ope> ign(const std::shared_ptr<Ope> &ope) {",
          "1610:   return std::make_shared<Ignore>(ope);",
          "1613: inline std::shared_ptr<Ope>",
          "1614: usr(std::function<size_t(const char *s, size_t n, SemanticValues &sv, any &dt)>",
          "1615:         fn) {",
          "1616:   return std::make_shared<User>(fn);",
          "1619: inline std::shared_ptr<Ope> ref(const Grammar &grammar, const std::string &name,",
          "1620:                                 const char *s, bool is_macro,",
          "1621:                                 const std::vector<std::shared_ptr<Ope>> &args) {",
          "1622:   return std::make_shared<Reference>(grammar, name, s, is_macro, args);",
          "1625: inline std::shared_ptr<Ope> wsp(const std::shared_ptr<Ope> &ope) {",
          "1626:   return std::make_shared<Whitespace>(std::make_shared<Ignore>(ope));",
          "1629: inline std::shared_ptr<Ope> bkr(const std::string &name) {",
          "1630:   return std::make_shared<BackReference>(name);",
          "1636: struct Ope::Visitor {",
          "1637:   virtual ~Visitor() {}",
          "1638:   virtual void visit(Sequence & /*ope*/) {}",
          "1639:   virtual void visit(PrioritizedChoice & /*ope*/) {}",
          "1640:   virtual void visit(ZeroOrMore & /*ope*/) {}",
          "1641:   virtual void visit(OneOrMore & /*ope*/) {}",
          "1642:   virtual void visit(Option & /*ope*/) {}",
          "1643:   virtual void visit(AndPredicate & /*ope*/) {}",
          "1644:   virtual void visit(NotPredicate & /*ope*/) {}",
          "1645:   virtual void visit(LiteralString & /*ope*/) {}",
          "1646:   virtual void visit(CharacterClass & /*ope*/) {}",
          "1647:   virtual void visit(Character & /*ope*/) {}",
          "1648:   virtual void visit(AnyCharacter & /*ope*/) {}",
          "1649:   virtual void visit(CaptureScope & /*ope*/) {}",
          "1650:   virtual void visit(Capture & /*ope*/) {}",
          "1651:   virtual void visit(TokenBoundary & /*ope*/) {}",
          "1652:   virtual void visit(Ignore & /*ope*/) {}",
          "1653:   virtual void visit(User & /*ope*/) {}",
          "1654:   virtual void visit(WeakHolder & /*ope*/) {}",
          "1655:   virtual void visit(Holder & /*ope*/) {}",
          "1656:   virtual void visit(Reference & /*ope*/) {}",
          "1657:   virtual void visit(Whitespace & /*ope*/) {}",
          "1658:   virtual void visit(BackReference & /*ope*/) {}",
          "1661: struct IsReference : public Ope::Visitor {",
          "1662:   void visit(Reference &ope) override { is_reference = true; }",
          "1663:   bool is_reference = false;",
          "1666: struct TraceOpeName : public Ope::Visitor {",
          "1667:   void visit(Sequence &ope) override { name = \"Sequence\"; }",
          "1668:   void visit(PrioritizedChoice &ope) override { name = \"PrioritizedChoice\"; }",
          "1669:   void visit(ZeroOrMore &ope) override { name = \"ZeroOrMore\"; }",
          "1670:   void visit(OneOrMore &ope) override { name = \"OneOrMore\"; }",
          "1671:   void visit(Option &ope) override { name = \"Option\"; }",
          "1672:   void visit(AndPredicate &ope) override { name = \"AndPredicate\"; }",
          "1673:   void visit(NotPredicate &ope) override { name = \"NotPredicate\"; }",
          "1674:   void visit(LiteralString &ope) override { name = \"LiteralString\"; }",
          "1675:   void visit(CharacterClass &ope) override { name = \"CharacterClass\"; }",
          "1676:   void visit(Character &ope) override { name = \"Character\"; }",
          "1677:   void visit(AnyCharacter &ope) override { name = \"AnyCharacter\"; }",
          "1678:   void visit(CaptureScope &ope) override { name = \"CaptureScope\"; }",
          "1679:   void visit(Capture &ope) override { name = \"Capture\"; }",
          "1680:   void visit(TokenBoundary &ope) override { name = \"TokenBoundary\"; }",
          "1681:   void visit(Ignore &ope) override { name = \"Ignore\"; }",
          "1682:   void visit(User &ope) override { name = \"User\"; }",
          "1683:   void visit(WeakHolder &ope) override { name = \"WeakHolder\"; }",
          "1684:   void visit(Holder &ope) override { name = ope.trace_name(); }",
          "1685:   void visit(Reference &ope) override { name = \"Reference\"; }",
          "1686:   void visit(Whitespace &ope) override { name = \"Whitespace\"; }",
          "1687:   void visit(BackReference &ope) override { name = \"BackReference\"; }",
          "1689:   const char *name = nullptr;",
          "1692: struct AssignIDToDefinition : public Ope::Visitor {",
          "1693:   void visit(Sequence &ope) override {",
          "1694:     for (auto op : ope.opes_) {",
          "1695:       op->accept(*this);",
          "1697:   }",
          "1698:   void visit(PrioritizedChoice &ope) override {",
          "1699:     for (auto op : ope.opes_) {",
          "1700:       op->accept(*this);",
          "1702:   }",
          "1703:   void visit(ZeroOrMore &ope) override { ope.ope_->accept(*this); }",
          "1704:   void visit(OneOrMore &ope) override { ope.ope_->accept(*this); }",
          "1705:   void visit(Option &ope) override { ope.ope_->accept(*this); }",
          "1706:   void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }",
          "1707:   void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }",
          "1708:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1709:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1710:   void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }",
          "1711:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1712:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "1713:   void visit(Holder &ope) override;",
          "1714:   void visit(Reference &ope) override;",
          "1715:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "1717:   std::unordered_map<void *, size_t> ids;",
          "1720: struct IsLiteralToken : public Ope::Visitor {",
          "1721:   void visit(PrioritizedChoice &ope) override {",
          "1722:     for (auto op : ope.opes_) {",
          "1723:       if (!IsLiteralToken::check(*op)) { return; }",
          "1725:     result_ = true;",
          "1726:   }",
          "1728:   void visit(LiteralString & /*ope*/) override { result_ = true; }",
          "1730:   static bool check(Ope &ope) {",
          "1731:     IsLiteralToken vis;",
          "1732:     ope.accept(vis);",
          "1733:     return vis.result_;",
          "1734:   }",
          "1737:   bool result_ = false;",
          "1740: struct TokenChecker : public Ope::Visitor {",
          "1741:   void visit(Sequence &ope) override {",
          "1742:     for (auto op : ope.opes_) {",
          "1743:       op->accept(*this);",
          "1745:   }",
          "1746:   void visit(PrioritizedChoice &ope) override {",
          "1747:     for (auto op : ope.opes_) {",
          "1748:       op->accept(*this);",
          "1750:   }",
          "1751:   void visit(ZeroOrMore &ope) override { ope.ope_->accept(*this); }",
          "1752:   void visit(OneOrMore &ope) override { ope.ope_->accept(*this); }",
          "1753:   void visit(Option &ope) override { ope.ope_->accept(*this); }",
          "1754:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1755:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1756:   void visit(TokenBoundary & /*ope*/) override { has_token_boundary_ = true; }",
          "1757:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1758:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "1759:   void visit(Reference &ope) override;",
          "1760:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "1762:   static bool is_token(Ope &ope) {",
          "1763:     if (IsLiteralToken::check(ope)) { return true; }",
          "1765:     TokenChecker vis;",
          "1766:     ope.accept(vis);",
          "1767:     return vis.has_token_boundary_ || !vis.has_rule_;",
          "1768:   }",
          "1771:   bool has_token_boundary_ = false;",
          "1772:   bool has_rule_ = false;",
          "1776:   DetectLeftRecursion(const std::string &name) : name_(name) {}",
          "1778:   void visit(Sequence &ope) override {",
          "1779:     for (auto op : ope.opes_) {",
          "1780:       op->accept(*this);",
          "1781:       if (done_) {",
          "1782:         break;",
          "1783:       } else if (error_s) {",
          "1784:         done_ = true;",
          "1785:         break;",
          "1786:       }",
          "1788:   }",
          "1789:   void visit(PrioritizedChoice &ope) override {",
          "1790:     for (auto op : ope.opes_) {",
          "1791:       op->accept(*this);",
          "1792:       if (error_s) {",
          "1793:         done_ = true;",
          "1794:         break;",
          "1795:       }",
          "1797:   }",
          "1798:   void visit(ZeroOrMore &ope) override {",
          "1799:     ope.ope_->accept(*this);",
          "1800:     done_ = false;",
          "1801:   }",
          "1802:   void visit(OneOrMore &ope) override {",
          "1803:     ope.ope_->accept(*this);",
          "1804:     done_ = true;",
          "1805:   }",
          "1806:   void visit(Option &ope) override {",
          "1807:     ope.ope_->accept(*this);",
          "1808:     done_ = false;",
          "1809:   }",
          "1810:   void visit(AndPredicate &ope) override {",
          "1811:     ope.ope_->accept(*this);",
          "1812:     done_ = false;",
          "1813:   }",
          "1814:   void visit(NotPredicate &ope) override {",
          "1815:     ope.ope_->accept(*this);",
          "1816:     done_ = false;",
          "1817:   }",
          "1818:   void visit(LiteralString &ope) override { done_ = !ope.lit_.empty(); }",
          "1819:   void visit(CharacterClass & /*ope*/) override { done_ = true; }",
          "1820:   void visit(Character & /*ope*/) override { done_ = true; }",
          "1821:   void visit(AnyCharacter & /*ope*/) override { done_ = true; }",
          "1822:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1823:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1824:   void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }",
          "1825:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1826:   void visit(User & /*ope*/) override { done_ = true; }",
          "1827:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "1828:   void visit(Holder &ope) override { ope.ope_->accept(*this); }",
          "1829:   void visit(Reference &ope) override;",
          "1830:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "1831:   void visit(BackReference & /*ope*/) override { done_ = true; }",
          "1833:   const char *error_s = nullptr;",
          "1836:   std::string name_;",
          "1837:   std::set<std::string> refs_;",
          "1838:   bool done_ = false;",
          "1841: struct HasEmptyElement : public Ope::Visitor {",
          "1842:   HasEmptyElement(std::list<std::pair<const char *, std::string>> &refs)",
          "1843:       : refs_(refs) {}",
          "1845:   void visit(Sequence &ope) override {",
          "1846:     bool save_is_empty = false;",
          "1847:     const char *save_error_s = nullptr;",
          "1848:     std::string save_error_name;",
          "1849:     for (auto op : ope.opes_) {",
          "1850:       op->accept(*this);",
          "1851:       if (!is_empty) { return; }",
          "1852:       save_is_empty = is_empty;",
          "1853:       save_error_s = error_s;",
          "1854:       save_error_name = error_name;",
          "1855:       is_empty = false;",
          "1856:       error_name.clear();",
          "1857:     }",
          "1858:     is_empty = save_is_empty;",
          "1859:     error_s = save_error_s;",
          "1860:     error_name = save_error_name;",
          "1861:   }",
          "1862:   void visit(PrioritizedChoice &ope) override {",
          "1863:     for (auto op : ope.opes_) {",
          "1864:       op->accept(*this);",
          "1865:       if (is_empty) { return; }",
          "1867:   }",
          "1868:   void visit(ZeroOrMore & /*ope*/) override { set_error(); }",
          "1869:   void visit(OneOrMore &ope) override { ope.ope_->accept(*this); }",
          "1870:   void visit(Option & /*ope*/) override { set_error(); }",
          "1871:   void visit(AndPredicate & /*ope*/) override { set_error(); }",
          "1872:   void visit(NotPredicate & /*ope*/) override { set_error(); }",
          "1873:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1874:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1875:   void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }",
          "1876:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1877:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "1878:   void visit(Holder &ope) override { ope.ope_->accept(*this); }",
          "1879:   void visit(Reference &ope) override;",
          "1880:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "1882:   bool is_empty = false;",
          "1883:   const char *error_s = nullptr;",
          "1884:   std::string error_name;",
          "1887:   void set_error() {",
          "1888:     is_empty = true;",
          "1889:     error_s = refs_.back().first;",
          "1890:     error_name = refs_.back().second;",
          "1891:   }",
          "1892:   std::list<std::pair<const char *, std::string>> &refs_;",
          "1895: struct DetectInfiniteLoop : public Ope::Visitor {",
          "1896:   DetectInfiniteLoop(const char *s, const std::string &name) {",
          "1897:     refs_.emplace_back(s, name);",
          "1898:   }",
          "1900:   void visit(Sequence &ope) override {",
          "1901:     for (auto op : ope.opes_) {",
          "1902:       op->accept(*this);",
          "1903:       if (has_error) { return; }",
          "1905:   }",
          "1906:   void visit(PrioritizedChoice &ope) override {",
          "1907:     for (auto op : ope.opes_) {",
          "1908:       op->accept(*this);",
          "1909:       if (has_error) { return; }",
          "1911:   }",
          "1912:   void visit(ZeroOrMore &ope) override {",
          "1913:     HasEmptyElement vis(refs_);",
          "1914:     ope.ope_->accept(vis);",
          "1915:     if (vis.is_empty) {",
          "1916:       has_error = true;",
          "1917:       error_s = vis.error_s;",
          "1918:       error_name = vis.error_name;",
          "1920:   }",
          "1921:   void visit(OneOrMore &ope) override {",
          "1922:     HasEmptyElement vis(refs_);",
          "1923:     ope.ope_->accept(vis);",
          "1924:     if (vis.is_empty) {",
          "1925:       has_error = true;",
          "1926:       error_s = vis.error_s;",
          "1927:       error_name = vis.error_name;",
          "1929:   }",
          "1930:   void visit(Option &ope) override { ope.ope_->accept(*this); }",
          "1931:   void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }",
          "1932:   void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }",
          "1933:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1934:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1935:   void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }",
          "1936:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1937:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "1938:   void visit(Holder &ope) override { ope.ope_->accept(*this); }",
          "1939:   void visit(Reference &ope) override;",
          "1940:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "1942:   bool has_error = false;",
          "1943:   const char *error_s = nullptr;",
          "1944:   std::string error_name;",
          "1947:   std::list<std::pair<const char *, std::string>> refs_;",
          "1951:   ReferenceChecker(const Grammar &grammar,",
          "1952:                    const std::vector<std::string> &params)",
          "1953:       : grammar_(grammar), params_(params) {}",
          "1955:   void visit(Sequence &ope) override {",
          "1956:     for (auto op : ope.opes_) {",
          "1957:       op->accept(*this);",
          "1959:   }",
          "1960:   void visit(PrioritizedChoice &ope) override {",
          "1961:     for (auto op : ope.opes_) {",
          "1962:       op->accept(*this);",
          "1964:   }",
          "1965:   void visit(ZeroOrMore &ope) override { ope.ope_->accept(*this); }",
          "1966:   void visit(OneOrMore &ope) override { ope.ope_->accept(*this); }",
          "1967:   void visit(Option &ope) override { ope.ope_->accept(*this); }",
          "1968:   void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }",
          "1969:   void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }",
          "1970:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "1971:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "1972:   void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }",
          "1973:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "1974:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "1975:   void visit(Holder &ope) override { ope.ope_->accept(*this); }",
          "1976:   void visit(Reference &ope) override;",
          "1977:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "1979:   std::unordered_map<std::string, const char *> error_s;",
          "1980:   std::unordered_map<std::string, std::string> error_message;",
          "1983:   const Grammar &grammar_;",
          "1984:   const std::vector<std::string> &params_;",
          "1988:   LinkReferences(Grammar &grammar, const std::vector<std::string> &params)",
          "1989:       : grammar_(grammar), params_(params) {}",
          "1991:   void visit(Sequence &ope) override {",
          "1992:     for (auto op : ope.opes_) {",
          "1993:       op->accept(*this);",
          "1995:   }",
          "1996:   void visit(PrioritizedChoice &ope) override {",
          "1997:     for (auto op : ope.opes_) {",
          "1998:       op->accept(*this);",
          "2000:   }",
          "2001:   void visit(ZeroOrMore &ope) override { ope.ope_->accept(*this); }",
          "2002:   void visit(OneOrMore &ope) override { ope.ope_->accept(*this); }",
          "2003:   void visit(Option &ope) override { ope.ope_->accept(*this); }",
          "2004:   void visit(AndPredicate &ope) override { ope.ope_->accept(*this); }",
          "2005:   void visit(NotPredicate &ope) override { ope.ope_->accept(*this); }",
          "2006:   void visit(CaptureScope &ope) override { ope.ope_->accept(*this); }",
          "2007:   void visit(Capture &ope) override { ope.ope_->accept(*this); }",
          "2008:   void visit(TokenBoundary &ope) override { ope.ope_->accept(*this); }",
          "2009:   void visit(Ignore &ope) override { ope.ope_->accept(*this); }",
          "2010:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "2011:   void visit(Holder &ope) override { ope.ope_->accept(*this); }",
          "2012:   void visit(Reference &ope) override;",
          "2013:   void visit(Whitespace &ope) override { ope.ope_->accept(*this); }",
          "2016:   Grammar &grammar_;",
          "2017:   const std::vector<std::string> &params_;",
          "2021:   FindReference(const std::vector<std::shared_ptr<Ope>> &args,",
          "2022:                 const std::vector<std::string> &params)",
          "2023:       : args_(args), params_(params) {}",
          "2025:   void visit(Sequence &ope) override {",
          "2026:     std::vector<std::shared_ptr<Ope>> opes;",
          "2027:     for (auto o : ope.opes_) {",
          "2028:       o->accept(*this);",
          "2029:       opes.push_back(found_ope);",
          "2031:     found_ope = std::make_shared<Sequence>(opes);",
          "2032:   }",
          "2033:   void visit(PrioritizedChoice &ope) override {",
          "2034:     std::vector<std::shared_ptr<Ope>> opes;",
          "2035:     for (auto o : ope.opes_) {",
          "2036:       o->accept(*this);",
          "2037:       opes.push_back(found_ope);",
          "2038:     }",
          "2039:     found_ope = std::make_shared<PrioritizedChoice>(opes);",
          "2040:   }",
          "2041:   void visit(ZeroOrMore &ope) override {",
          "2042:     ope.ope_->accept(*this);",
          "2043:     found_ope = zom(found_ope);",
          "2044:   }",
          "2045:   void visit(OneOrMore &ope) override {",
          "2046:     ope.ope_->accept(*this);",
          "2047:     found_ope = oom(found_ope);",
          "2048:   }",
          "2049:   void visit(Option &ope) override {",
          "2050:     ope.ope_->accept(*this);",
          "2051:     found_ope = opt(found_ope);",
          "2052:   }",
          "2053:   void visit(AndPredicate &ope) override {",
          "2054:     ope.ope_->accept(*this);",
          "2055:     found_ope = apd(found_ope);",
          "2056:   }",
          "2057:   void visit(NotPredicate &ope) override {",
          "2058:     ope.ope_->accept(*this);",
          "2059:     found_ope = npd(found_ope);",
          "2060:   }",
          "2061:   void visit(LiteralString &ope) override {",
          "2062:     found_ope = ope.shared_from_this();",
          "2063:   }",
          "2064:   void visit(CharacterClass &ope) override {",
          "2065:     found_ope = ope.shared_from_this();",
          "2066:   }",
          "2067:   void visit(Character &ope) override { found_ope = ope.shared_from_this(); }",
          "2068:   void visit(AnyCharacter &ope) override { found_ope = ope.shared_from_this(); }",
          "2069:   void visit(CaptureScope &ope) override {",
          "2070:     ope.ope_->accept(*this);",
          "2071:     found_ope = csc(found_ope);",
          "2072:   }",
          "2073:   void visit(Capture &ope) override {",
          "2074:     ope.ope_->accept(*this);",
          "2075:     found_ope = cap(found_ope, ope.match_action_);",
          "2076:   }",
          "2077:   void visit(TokenBoundary &ope) override {",
          "2078:     ope.ope_->accept(*this);",
          "2079:     found_ope = tok(found_ope);",
          "2080:   }",
          "2081:   void visit(Ignore &ope) override {",
          "2082:     ope.ope_->accept(*this);",
          "2083:     found_ope = ign(found_ope);",
          "2084:   }",
          "2085:   void visit(WeakHolder &ope) override { ope.weak_.lock()->accept(*this); }",
          "2086:   void visit(Holder &ope) override { ope.ope_->accept(*this); }",
          "2087:   void visit(Reference &ope) override;",
          "2088:   void visit(Whitespace &ope) override {",
          "2089:     ope.ope_->accept(*this);",
          "2090:     found_ope = wsp(found_ope);",
          "2091:   }",
          "2093:   std::shared_ptr<Ope> found_ope;",
          "2096:   const std::vector<std::shared_ptr<Ope>> &args_;",
          "2097:   const std::vector<std::string> &params_;",
          "2100: struct IsPrioritizedChoice : public Ope::Visitor {",
          "2101:   void visit(PrioritizedChoice & /*ope*/) override { result_ = true; }",
          "2103:   static bool check(Ope &ope) {",
          "2104:     IsPrioritizedChoice vis;",
          "2105:     ope.accept(vis);",
          "2106:     return vis.result_;",
          "2107:   }",
          "2110:   bool result_ = false;",
          "2116: static const char *WHITESPACE_DEFINITION_NAME = \"%whitespace\";",
          "2117: static const char *WORD_DEFINITION_NAME = \"%word\";",
          "2122: class Definition {",
          "2124:   struct Result {",
          "2125:     bool ret;",
          "2126:     size_t len;",
          "2127:     const char *error_pos;",
          "2128:     const char *message_pos;",
          "2129:     const std::string message;",
          "2130:   };",
          "2132:   Definition() : holder_(std::make_shared<Holder>(this)) {}",
          "2134:   Definition(const Definition &rhs) : name(rhs.name), holder_(rhs.holder_) {",
          "2135:     holder_->outer_ = this;",
          "2136:   }",
          "2138:   Definition(const std::shared_ptr<Ope> &ope)",
          "2139:       : holder_(std::make_shared<Holder>(this)) {",
          "2141:   }",
          "2143:   operator std::shared_ptr<Ope>() {",
          "2144:     return std::make_shared<WeakHolder>(holder_);",
          "2145:   }",
          "2147:   Definition &operator<=(const std::shared_ptr<Ope> &ope) {",
          "2148:     holder_->ope_ = ope;",
          "2149:     return *this;",
          "2150:   }",
          "2152:   Result parse(const char *s, size_t n, const char *path = nullptr) const {",
          "2153:     SemanticValues sv;",
          "2154:     any dt;",
          "2155:     return parse_core(s, n, sv, dt, path);",
          "2156:   }",
          "2158:   Result parse(const char *s, const char *path = nullptr) const {",
          "2159:     auto n = strlen(s);",
          "2160:     return parse(s, n, path);",
          "2161:   }",
          "2163:   Result parse(const char *s, size_t n, any &dt,",
          "2164:                const char *path = nullptr) const {",
          "2165:     SemanticValues sv;",
          "2166:     return parse_core(s, n, sv, dt, path);",
          "2167:   }",
          "2169:   Result parse(const char *s, any &dt, const char *path = nullptr) const {",
          "2170:     auto n = strlen(s);",
          "2171:     return parse(s, n, dt, path);",
          "2172:   }",
          "2174:   template <typename T>",
          "2175:   Result parse_and_get_value(const char *s, size_t n, T &val,",
          "2176:                              const char *path = nullptr) const {",
          "2177:     SemanticValues sv;",
          "2178:     any dt;",
          "2179:     auto r = parse_core(s, n, sv, dt, path);",
          "2180:     if (r.ret && !sv.empty() && sv.front().has_value()) {",
          "2181:       val = any_cast<T>(sv[0]);",
          "2183:     return r;",
          "2184:   }",
          "2186:   template <typename T>",
          "2187:   Result parse_and_get_value(const char *s, T &val,",
          "2188:                              const char *path = nullptr) const {",
          "2189:     auto n = strlen(s);",
          "2190:     return parse_and_get_value(s, n, val, path);",
          "2191:   }",
          "2193:   template <typename T>",
          "2194:   Result parse_and_get_value(const char *s, size_t n, any &dt, T &val,",
          "2195:                              const char *path = nullptr) const {",
          "2196:     SemanticValues sv;",
          "2197:     auto r = parse_core(s, n, sv, dt, path);",
          "2198:     if (r.ret && !sv.empty() && sv.front().has_value()) {",
          "2199:       val = any_cast<T>(sv[0]);",
          "2201:     return r;",
          "2202:   }",
          "2204:   template <typename T>",
          "2205:   Result parse_and_get_value(const char *s, any &dt, T &val,",
          "2206:                              const char *path = nullptr) const {",
          "2207:     auto n = strlen(s);",
          "2208:     return parse_and_get_value(s, n, dt, val, path);",
          "2209:   }",
          "2211:   Action operator=(Action a) {",
          "2212:     action = a;",
          "2213:     return a;",
          "2214:   }",
          "2216:   template <typename T> Definition &operator,(T fn) {",
          "2217:     operator=(fn);",
          "2218:     return *this;",
          "2219:   }",
          "2221:   Definition &operator~() {",
          "2222:     ignoreSemanticValue = true;",
          "2223:     return *this;",
          "2224:   }",
          "2226:   void accept(Ope::Visitor &v) { holder_->accept(v); }",
          "2228:   std::shared_ptr<Ope> get_core_operator() const { return holder_->ope_; }",
          "2230:   bool is_token() const {",
          "2231:     std::call_once(is_token_init_, [this]() {",
          "2232:       is_token_ = TokenChecker::is_token(*get_core_operator());",
          "2233:     });",
          "2234:     return is_token_;",
          "2235:   }",
          "2237:   std::string name;",
          "2238:   size_t id = 0;",
          "2239:   Action action;",
          "2240:   std::function<void(const char *s, size_t n, any &dt)> enter;",
          "2241:   std::function<void(const char *s, size_t n, size_t matchlen, any &value,",
          "2242:                      any &dt)>",
          "2243:       leave;",
          "2244:   std::function<std::string()> error_message;",
          "2245:   bool ignoreSemanticValue = false;",
          "2246:   std::shared_ptr<Ope> whitespaceOpe;",
          "2247:   std::shared_ptr<Ope> wordOpe;",
          "2248:   bool enablePackratParsing = false;",
          "2249:   bool is_macro = false;",
          "2250:   std::vector<std::string> params;",
          "2251:   TracerEnter tracer_enter;",
          "2252:   TracerLeave tracer_leave;",
          "2255:   friend class Reference;",
          "2257:   Definition &operator=(const Definition &rhs);",
          "2258:   Definition &operator=(Definition &&rhs);",
          "2260:   void initialize_definition_ids() const {",
          "2261:     std::call_once(definition_ids_init_, [&]() {",
          "2262:       AssignIDToDefinition vis;",
          "2263:       holder_->accept(vis);",
          "2264:       if (whitespaceOpe) { whitespaceOpe->accept(vis); }",
          "2265:       if (wordOpe) { wordOpe->accept(vis); }",
          "2266:       definition_ids_.swap(vis.ids);",
          "2267:     });",
          "2268:   }",
          "2270:   Result parse_core(const char *s, size_t n, SemanticValues &sv, any &dt,",
          "2271:                     const char *path) const {",
          "2272:     initialize_definition_ids();",
          "2274:     std::shared_ptr<Ope> ope = holder_;",
          "2275:     if (whitespaceOpe) { ope = std::make_shared<Sequence>(whitespaceOpe, ope); }",
          "2277:     Context cxt(path, s, n, definition_ids_.size(), whitespaceOpe, wordOpe,",
          "2278:                 enablePackratParsing, tracer_enter, tracer_leave);",
          "2280:     auto len = ope->parse(s, n, sv, cxt, dt);",
          "2281:     return Result{success(len), len, cxt.error_pos, cxt.message_pos,",
          "2282:                   cxt.message};",
          "2283:   }",
          "2285:   std::shared_ptr<Holder> holder_;",
          "2286:   mutable std::once_flag is_token_init_;",
          "2287:   mutable bool is_token_ = false;",
          "2288:   mutable std::once_flag assign_id_to_definition_init_;",
          "2289:   mutable std::once_flag definition_ids_init_;",
          "2290:   mutable std::unordered_map<void *, size_t> definition_ids_;",
          "2297: inline size_t parse_literal(const char *s, size_t n, SemanticValues &sv,",
          "2298:                             Context &c, any &dt, const std::string &lit,",
          "2299:                             bool &init_is_word, bool &is_word,",
          "2300:                             bool ignore_case) {",
          "2301:   size_t i = 0;",
          "2302:   for (; i < lit.size(); i++) {",
          "2303:     if (i >= n || (ignore_case ? (std::tolower(s[i]) != std::tolower(lit[i]))",
          "2304:                                : (s[i] != lit[i]))) {",
          "2305:       c.set_error_pos(s);",
          "2306:       return static_cast<size_t>(-1);",
          "2308:   }",
          "2311:   static Context dummy_c(nullptr, c.s, c.l, 0, nullptr, nullptr, false, nullptr,",
          "2312:                          nullptr);",
          "2313:   static SemanticValues dummy_sv;",
          "2314:   static any dummy_dt;",
          "2316:   if (!init_is_word) { // TODO: Protect with mutex",
          "2317:     if (c.wordOpe) {",
          "2318:       auto len =",
          "2319:           c.wordOpe->parse(lit.data(), lit.size(), dummy_sv, dummy_c, dummy_dt);",
          "2320:       is_word = success(len);",
          "2322:     init_is_word = true;",
          "2323:   }",
          "2325:   if (is_word) {",
          "2326:     auto ope = std::make_shared<NotPredicate>(c.wordOpe);",
          "2327:     auto len = ope->parse(s + i, n - i, dummy_sv, dummy_c, dummy_dt);",
          "2328:     if (fail(len)) { return static_cast<size_t>(-1); }",
          "2329:     i += len;",
          "2330:   }",
          "2333:   if (!c.in_token) {",
          "2334:     if (c.whitespaceOpe) {",
          "2335:       auto len = c.whitespaceOpe->parse(s + i, n - i, sv, c, dt);",
          "2336:       if (fail(len)) { return static_cast<size_t>(-1); }",
          "2337:       i += len;",
          "2339:   }",
          "2341:   return i;",
          "2344: inline void Context::trace_enter(const char *name, const char *a_s, size_t n,",
          "2345:                                  SemanticValues &sv, any &dt) const {",
          "2346:   trace_ids.push_back(next_trace_id++);",
          "2347:   tracer_enter(name, a_s, n, sv, *this, dt);",
          "2350: inline void Context::trace_leave(const char *name, const char *a_s, size_t n,",
          "2351:                                  SemanticValues &sv, any &dt,",
          "2352:                                  size_t len) const {",
          "2353:   tracer_leave(name, a_s, n, sv, *this, dt, len);",
          "2354:   trace_ids.pop_back();",
          "2357: inline bool Context::is_traceable(const Ope &ope) const {",
          "2358:   if (tracer_enter && tracer_leave) {",
          "2359:     IsReference vis;",
          "2360:     const_cast<Ope &>(ope).accept(vis);",
          "2361:     return !vis.is_reference;",
          "2362:   }",
          "2363:   return false;",
          "2366: inline size_t Ope::parse(const char *s, size_t n, SemanticValues &sv,",
          "2367:                          Context &c, any &dt) const {",
          "2368:   if (c.is_traceable(*this)) {",
          "2369:     TraceOpeName vis;",
          "2370:     const_cast<Ope &>(*this).accept(vis);",
          "2371:     c.trace_enter(vis.name, s, n, sv, dt);",
          "2372:     auto len = parse_core(s, n, sv, c, dt);",
          "2373:     c.trace_leave(vis.name, s, n, sv, dt, len);",
          "2374:     return len;",
          "2375:   }",
          "2376:   return parse_core(s, n, sv, c, dt);",
          "2379: inline size_t LiteralString::parse_core(const char *s, size_t n,",
          "2380:                                         SemanticValues &sv, Context &c,",
          "2381:                                         any &dt) const {",
          "2382:   return parse_literal(s, n, sv, c, dt, lit_, init_is_word_, is_word_,",
          "2383:                        ignore_case_);",
          "2386: inline size_t TokenBoundary::parse_core(const char *s, size_t n,",
          "2387:                                         SemanticValues &sv, Context &c,",
          "2388:                                         any &dt) const {",
          "2389:   c.in_token = true;",
          "2390:   auto se = make_scope_exit([&]() { c.in_token = false; });",
          "2391:   const auto &rule = *ope_;",
          "2392:   auto len = rule.parse(s, n, sv, c, dt);",
          "2393:   if (success(len)) {",
          "2394:     sv.tokens.push_back(std::make_pair(s, len));",
          "2396:     if (c.whitespaceOpe) {",
          "2397:       auto l = c.whitespaceOpe->parse(s + len, n - len, sv, c, dt);",
          "2398:       if (fail(l)) { return static_cast<size_t>(-1); }",
          "2399:       len += l;",
          "2401:   }",
          "2402:   return len;",
          "2405: inline size_t Holder::parse_core(const char *s, size_t n, SemanticValues &sv,",
          "2406:                                  Context &c, any &dt) const {",
          "2407:   if (!ope_) {",
          "2408:     throw std::logic_error(\"Uninitialized definition ope was used...\");",
          "2409:   }",
          "2413:   if (outer_->is_macro) { return ope_->parse(s, n, sv, c, dt); }",
          "2415:   size_t len;",
          "2416:   any val;",
          "2418:   c.packrat(s, outer_->id, len, val, [&](any &a_val) {",
          "2419:     if (outer_->enter) { outer_->enter(s, n, dt); }",
          "2421:     auto se2 = make_scope_exit([&]() {",
          "2422:       c.pop();",
          "2424:       if (outer_->leave) { outer_->leave(s, n, len, a_val, dt); }",
          "2427:     auto &chldsv = c.push();",
          "2429:     len = ope_->parse(s, n, chldsv, c, dt);",
          "2433:       chldsv.s_ = s;",
          "2434:       chldsv.n_ = len;",
          "2435:       chldsv.name_ = outer_->name;",
          "2437:       if (!IsPrioritizedChoice::check(*ope_)) {",
          "2438:         chldsv.choice_count_ = 0;",
          "2439:         chldsv.choice_ = 0;",
          "2440:       }",
          "2442:       try {",
          "2443:         a_val = reduce(chldsv, dt);",
          "2444:       } catch (const parse_error &e) {",
          "2445:         if (e.what()) {",
          "2446:           if (c.message_pos < s) {",
          "2447:             c.message_pos = s;",
          "2448:             c.message = e.what();",
          "2449:           }",
          "2451:         len = static_cast<size_t>(-1);",
          "2452:       }",
          "2454:   });",
          "2456:   if (success(len)) {",
          "2457:     if (!outer_->ignoreSemanticValue) {",
          "2458:       sv.emplace_back(val);",
          "2459:       sv.tags.emplace_back(str2tag(outer_->name.c_str()));",
          "2460:     }",
          "2461:   } else {",
          "2462:     if (outer_->error_message) {",
          "2463:       if (c.message_pos < s) {",
          "2464:         c.message_pos = s;",
          "2465:         c.message = outer_->error_message();",
          "2466:       }",
          "2467:     }",
          "2468:   }",
          "2470:   return len;",
          "2473: inline any Holder::reduce(SemanticValues &sv, any &dt) const {",
          "2474:   if (outer_->action) {",
          "2475:     return outer_->action(sv, dt);",
          "2476:   } else if (sv.empty()) {",
          "2477:     return any();",
          "2478:   } else {",
          "2479:     return std::move(sv.front());",
          "2480:   }",
          "2483: inline const char *Holder::trace_name() const {",
          "2484:   if (trace_name_.empty()) { trace_name_ = \"[\" + outer_->name + \"]\"; }",
          "2485:   return trace_name_.c_str();",
          "2488: inline size_t Reference::parse_core(const char *s, size_t n, SemanticValues &sv,",
          "2489:                                     Context &c, any &dt) const {",
          "2490:   if (rule_) {",
          "2492:     if (rule_->is_macro) {",
          "2494:       FindReference vis(c.top_args(), rule_->params);",
          "2497:       std::vector<std::shared_ptr<Ope>> args;",
          "2498:       for (auto arg : args_) {",
          "2499:         arg->accept(vis);",
          "2500:         args.push_back(vis.found_ope);",
          "2501:       }",
          "2503:       c.push_args(std::move(args));",
          "2504:       auto se = make_scope_exit([&]() { c.pop_args(); });",
          "2505:       auto ope = get_core_operator();",
          "2506:       return ope->parse(s, n, sv, c, dt);",
          "2509:       auto ope = get_core_operator();",
          "2510:       return ope->parse(s, n, sv, c, dt);",
          "2511:     }",
          "2512:   } else {",
          "2514:     const auto &args = c.top_args();",
          "2515:     return args[iarg_]->parse(s, n, sv, c, dt);",
          "2516:   }",
          "2520:   return rule_->holder_;",
          "2523: inline size_t BackReference::parse_core(const char *s, size_t n,",
          "2524:                                         SemanticValues &sv, Context &c,",
          "2525:                                         any &dt) const {",
          "2526:   for (int i = c.capture_scope_stack_size - 1; i >= 0; i--) {",
          "2527:     const auto &cs = c.capture_scope_stack[i];",
          "2528:     if (cs.find(name_) != cs.end()) {",
          "2529:       const auto &lit = cs.at(name_);",
          "2530:       auto init_is_word = false;",
          "2531:       auto is_word = false;",
          "2532:       return parse_literal(s, n, sv, c, dt, lit, init_is_word, is_word, false);",
          "2534:   }",
          "2535:   throw std::runtime_error(\"Invalid back reference...\");",
          "2536: }",
          "2538: inline void Sequence::accept(Visitor &v) { v.visit(*this); }",
          "2539: inline void PrioritizedChoice::accept(Visitor &v) { v.visit(*this); }",
          "2540: inline void ZeroOrMore::accept(Visitor &v) { v.visit(*this); }",
          "2541: inline void OneOrMore::accept(Visitor &v) { v.visit(*this); }",
          "2542: inline void Option::accept(Visitor &v) { v.visit(*this); }",
          "2543: inline void AndPredicate::accept(Visitor &v) { v.visit(*this); }",
          "2544: inline void NotPredicate::accept(Visitor &v) { v.visit(*this); }",
          "2545: inline void LiteralString::accept(Visitor &v) { v.visit(*this); }",
          "2546: inline void CharacterClass::accept(Visitor &v) { v.visit(*this); }",
          "2547: inline void Character::accept(Visitor &v) { v.visit(*this); }",
          "2548: inline void AnyCharacter::accept(Visitor &v) { v.visit(*this); }",
          "2549: inline void CaptureScope::accept(Visitor &v) { v.visit(*this); }",
          "2550: inline void Capture::accept(Visitor &v) { v.visit(*this); }",
          "2551: inline void TokenBoundary::accept(Visitor &v) { v.visit(*this); }",
          "2552: inline void Ignore::accept(Visitor &v) { v.visit(*this); }",
          "2553: inline void User::accept(Visitor &v) { v.visit(*this); }",
          "2554: inline void WeakHolder::accept(Visitor &v) { v.visit(*this); }",
          "2555: inline void Holder::accept(Visitor &v) { v.visit(*this); }",
          "2556: inline void Reference::accept(Visitor &v) { v.visit(*this); }",
          "2557: inline void Whitespace::accept(Visitor &v) { v.visit(*this); }",
          "2558: inline void BackReference::accept(Visitor &v) { v.visit(*this); }",
          "2560: inline void AssignIDToDefinition::visit(Holder &ope) {",
          "2561:   auto p = static_cast<void *>(ope.outer_);",
          "2562:   if (ids.count(p)) { return; }",
          "2563:   auto id = ids.size();",
          "2564:   ids[p] = id;",
          "2565:   ope.outer_->id = id;",
          "2566:   ope.ope_->accept(*this);",
          "2567: }",
          "2569: inline void AssignIDToDefinition::visit(Reference &ope) {",
          "2570:   if (ope.rule_) {",
          "2571:     for (auto arg : ope.args_) {",
          "2572:       arg->accept(*this);",
          "2573:     }",
          "2574:     ope.rule_->accept(*this);",
          "2575:   }",
          "2578: inline void TokenChecker::visit(Reference &ope) {",
          "2579:   if (ope.is_macro_) {",
          "2580:     ope.rule_->accept(*this);",
          "2581:     for (auto arg : ope.args_) {",
          "2582:       arg->accept(*this);",
          "2584:   } else {",
          "2585:     has_rule_ = true;",
          "2586:   }",
          "2589: inline void DetectLeftRecursion::visit(Reference &ope) {",
          "2590:   if (ope.name_ == name_) {",
          "2591:     error_s = ope.s_;",
          "2592:   } else if (!refs_.count(ope.name_)) {",
          "2593:     refs_.insert(ope.name_);",
          "2594:     if (ope.rule_) {",
          "2595:       ope.rule_->accept(*this);",
          "2596:       if (done_ == false) { return; }",
          "2598:   }",
          "2599:   done_ = true;",
          "2602: inline void HasEmptyElement::visit(Reference &ope) {",
          "2603:   auto it = std::find_if(refs_.begin(), refs_.end(),",
          "2604:                          [&](const std::pair<const char *, std::string> &ref) {",
          "2605:                            return ope.name_ == ref.second;",
          "2606:                          });",
          "2607:   if (it != refs_.end()) { return; }",
          "2609:   if (ope.rule_) {",
          "2610:     refs_.emplace_back(ope.s_, ope.name_);",
          "2611:     ope.rule_->accept(*this);",
          "2612:     refs_.pop_back();",
          "2613:   }",
          "2616: inline void DetectInfiniteLoop::visit(Reference &ope) {",
          "2617:   auto it = std::find_if(refs_.begin(), refs_.end(),",
          "2618:                          [&](const std::pair<const char *, std::string> &ref) {",
          "2619:                            return ope.name_ == ref.second;",
          "2620:                          });",
          "2621:   if (it != refs_.end()) { return; }",
          "2623:   if (ope.rule_) {",
          "2624:     refs_.emplace_back(ope.s_, ope.name_);",
          "2625:     ope.rule_->accept(*this);",
          "2626:     refs_.pop_back();",
          "2627:   }",
          "2630: inline void ReferenceChecker::visit(Reference &ope) {",
          "2631:   auto it = std::find(params_.begin(), params_.end(), ope.name_);",
          "2632:   if (it != params_.end()) { return; }",
          "2634:   if (!grammar_.count(ope.name_)) {",
          "2635:     error_s[ope.name_] = ope.s_;",
          "2636:     error_message[ope.name_] = \"'\" + ope.name_ + \"' is not defined.\";",
          "2637:   } else {",
          "2638:     const auto &rule = grammar_.at(ope.name_);",
          "2639:     if (rule.is_macro) {",
          "2640:       if (!ope.is_macro_ || ope.args_.size() != rule.params.size()) {",
          "2642:         error_message[ope.name_] = \"incorrect number of arguments.\";",
          "2643:       }",
          "2644:     } else if (ope.is_macro_) {",
          "2645:       error_s[ope.name_] = ope.s_;",
          "2646:       error_message[ope.name_] = \"'\" + ope.name_ + \"' is not macro.\";",
          "2648:   }",
          "2651: inline void LinkReferences::visit(Reference &ope) {",
          "2653:   auto found_param = false;",
          "2654:   for (size_t i = 0; i < params_.size(); i++) {",
          "2655:     const auto &param = params_[i];",
          "2656:     if (param == ope.name_) {",
          "2657:       ope.iarg_ = i;",
          "2658:       found_param = true;",
          "2659:       break;",
          "2661:   }",
          "2664:   if (!found_param && grammar_.count(ope.name_)) {",
          "2665:     auto &rule = grammar_.at(ope.name_);",
          "2666:     ope.rule_ = &rule;",
          "2667:   }",
          "2669:   for (auto arg : ope.args_) {",
          "2670:     arg->accept(*this);",
          "2671:   }",
          "2674: inline void FindReference::visit(Reference &ope) {",
          "2675:   for (size_t i = 0; i < args_.size(); i++) {",
          "2676:     const auto &name = params_[i];",
          "2677:     if (name == ope.name_) {",
          "2678:       found_ope = args_[i];",
          "2679:       return;",
          "2681:   }",
          "2682:   found_ope = ope.shared_from_this();",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2733: typedef std::unordered_map<std::string, std::shared_ptr<Ope>> Rules;",
          "2738: public:",
          "2764: private:",
          "2773:     }",
          "2782:     };",
          "2867:         }",
          "3116:         }",
          "3174:         }",
          "3207:         }",
          "3212:         }",
          "3218:     }",
          "3221: };",
          "3314: };",
          "3316: template <typename T>",
          "3345: }",
          "3347: template <typename T>",
          "3355: }",
          "3384:     }",
          "3386: private:",
          "3389: };",
          "3391: struct EmptyType {};",
          "",
          "[Removed Lines]",
          "2734: typedef std::function<void (size_t, size_t, const std::string&)> Log;",
          "2736: class ParserGenerator",
          "2737: {",
          "2739:     static std::shared_ptr<Grammar> parse(",
          "2740:         const char*  s,",
          "2741:         size_t       n,",
          "2742:         const Rules& rules,",
          "2743:         std::string& start,",
          "2744:         Log          log)",
          "2745:     {",
          "2746:         return get_instance().perform_core(s, n, rules, start, log);",
          "2747:     }",
          "2749:      static std::shared_ptr<Grammar> parse(",
          "2750:         const char*  s,",
          "2751:         size_t       n,",
          "2752:         std::string& start,",
          "2753:         Log          log)",
          "2754:     {",
          "2755:         Rules dummy;",
          "2756:         return parse(s, n, dummy, start, log);",
          "2757:     }",
          "2760:     static Grammar& grammar() {",
          "2761:         return get_instance().g;",
          "2762:     }",
          "2765:     static ParserGenerator& get_instance() {",
          "2766:         static ParserGenerator instance;",
          "2767:         return instance;",
          "2768:     }",
          "2770:     ParserGenerator() {",
          "2771:         make_grammar();",
          "2772:         setup_actions();",
          "2775:     struct Data {",
          "2776:         std::shared_ptr<Grammar>                         grammar;",
          "2777:         std::string                                      start;",
          "2778:         const char*                                      start_pos = nullptr;",
          "2779:         std::vector<std::pair<std::string, const char*>> duplicates;",
          "2781:         Data(): grammar(std::make_shared<Grammar>()) {}",
          "2784:     void make_grammar() {",
          "2786:         g[\"Grammar\"]    <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);",
          "2787:         g[\"Definition\"] <= cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Parameters\"], g[\"LEFTARROW\"], g[\"Expression\"]),",
          "2788:                                seq(g[\"Ignore\"], g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"]));",
          "2790:         g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));",
          "2791:         g[\"Sequence\"]   <= zom(g[\"Prefix\"]);",
          "2792:         g[\"Prefix\"]     <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);",
          "2793:         g[\"Suffix\"]     <= seq(g[\"Primary\"], opt(cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"])));",
          "2794:         g[\"Primary\"]    <= cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Arguments\"], npd(g[\"LEFTARROW\"])),",
          "2795:                                seq(g[\"Ignore\"], g[\"Identifier\"], npd(seq(opt(g[\"Parameters\"]), g[\"LEFTARROW\"]))),",
          "2796:                                seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),",
          "2797:                                seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),",
          "2798:                                seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),",
          "2799:                                seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]),",
          "2800:                                g[\"BackRef\"], g[\"LiteralI\"], g[\"Literal\"], g[\"NegatedClass\"], g[\"Class\"], g[\"DOT\"]);",
          "2802:         g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);",
          "2803:         g[\"IdentCont\"]  <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));",
          "2805:         const static std::vector<std::pair<char32_t, char32_t>> range = {{ 0x0080, 0xFFFF }};",
          "2806:         g[\"IdentStart\"] <= cho(cls(\"a-zA-Z_%\"), cls(range));",
          "2808:         g[\"IdentRest\"]  <= cho(g[\"IdentStart\"], cls(\"0-9\"));",
          "2810:         g[\"LiteralI\"]   <= cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"), g[\"Spacing\"]),",
          "2811:                                seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"), g[\"Spacing\"]));",
          "2813:         g[\"Literal\"]    <= cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), cls(\"'\"), g[\"Spacing\"]),",
          "2814:                                seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), cls(\"\\\"\"), g[\"Spacing\"]));",
          "2817:         g[\"Class\"]      <= seq(chr('['), npd(chr('^')), tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'), g[\"Spacing\"]);",
          "2818:         g[\"NegatedClass\"] <= seq(lit(\"[^\"), tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'), g[\"Spacing\"]);",
          "2820:         g[\"Range\"]      <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);",
          "2821:         g[\"Char\"]       <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\^\")),",
          "2822:                                seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),",
          "2823:                                seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),",
          "2824:                                seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),",
          "2825:                                seq(lit(\"\\\\u\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\")),",
          "2826:                                seq(npd(chr('\\\\')), dot()));",
          "2828:         g[\"LEFTARROW\"]  <= seq(cho(lit(\"<-\"), lit(u8\"\u2190\")), g[\"Spacing\"]);",
          "2829:         ~g[\"SLASH\"]     <= seq(chr('/'), g[\"Spacing\"]);",
          "2830:         g[\"AND\"]        <= seq(chr('&'), g[\"Spacing\"]);",
          "2831:         g[\"NOT\"]        <= seq(chr('!'), g[\"Spacing\"]);",
          "2832:         g[\"QUESTION\"]   <= seq(chr('?'), g[\"Spacing\"]);",
          "2833:         g[\"STAR\"]       <= seq(chr('*'), g[\"Spacing\"]);",
          "2834:         g[\"PLUS\"]       <= seq(chr('+'), g[\"Spacing\"]);",
          "2835:         ~g[\"OPEN\"]      <= seq(chr('('), g[\"Spacing\"]);",
          "2836:         ~g[\"CLOSE\"]     <= seq(chr(')'), g[\"Spacing\"]);",
          "2837:         g[\"DOT\"]        <= seq(chr('.'), g[\"Spacing\"]);",
          "2839:         ~g[\"Spacing\"]   <= zom(cho(g[\"Space\"], g[\"Comment\"]));",
          "2840:         g[\"Comment\"]    <= seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);",
          "2841:         g[\"Space\"]      <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);",
          "2842:         g[\"EndOfLine\"]  <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));",
          "2843:         g[\"EndOfFile\"]  <= npd(dot());",
          "2845:         ~g[\"BeginTok\"]  <= seq(chr('<'), g[\"Spacing\"]);",
          "2846:         ~g[\"EndTok\"]    <= seq(chr('>'), g[\"Spacing\"]);",
          "2848:         ~g[\"BeginCapScope\"] <= seq(chr('$'), chr('('), g[\"Spacing\"]);",
          "2849:         ~g[\"EndCapScope\"]   <= seq(chr(')'), g[\"Spacing\"]);",
          "2851:         g[\"BeginCap\"]   <= seq(chr('$'), tok(g[\"IdentCont\"]), chr('<'), g[\"Spacing\"]);",
          "2852:         ~g[\"EndCap\"]    <= seq(chr('>'), g[\"Spacing\"]);",
          "2854:         g[\"BackRef\"]    <= seq(chr('$'), tok(g[\"IdentCont\"]), g[\"Spacing\"]);",
          "2856:         g[\"IGNORE\"]     <= chr('~');",
          "2858:         g[\"Ignore\"]     <= opt(g[\"IGNORE\"]);",
          "2859:         g[\"Parameters\"] <= seq(g[\"OPEN\"], g[\"Identifier\"], zom(seq(g[\"COMMA\"], g[\"Identifier\"])), g[\"CLOSE\"]);",
          "2860:         g[\"Arguments\"]  <= seq(g[\"OPEN\"], g[\"Expression\"], zom(seq(g[\"COMMA\"], g[\"Expression\"])), g[\"CLOSE\"]);",
          "2861:         ~g[\"COMMA\"]     <= seq(chr(','), g[\"Spacing\"]);",
          "2865:         for (auto& x: g) {",
          "2866:             x.second.name = x.first;",
          "2868:     }",
          "2870:     void setup_actions() {",
          "2871:         g[\"Definition\"] = [&](const SemanticValues& sv, any& dt) {",
          "2872:             auto is_macro = sv.choice() == 0;",
          "2873:             auto ignore = any_cast<bool>(sv[0]);",
          "2874:             auto name = any_cast<std::string>(sv[ 1 ]);",
          "2876:             std::vector<std::string> params;",
          "2877:             std::shared_ptr<Ope> ope;",
          "2878:             if (is_macro) {",
          "2879:                 params = any_cast<std::vector<std::string>>(sv[2]);",
          "2880:                 ope = any_cast<std::shared_ptr<Ope>>(sv[4]);",
          "2881:             } else {",
          "2882:                 ope = any_cast<std::shared_ptr<Ope>>(sv[3]);",
          "2883:             }",
          "2885:             Data& data = *any_cast<Data*>(dt);",
          "2887:             auto& grammar = *data.grammar;",
          "2888:             if (!grammar.count(name)) {",
          "2889:                 auto& rule = grammar[name];",
          "2890:                 rule <= ope;",
          "2891:                 rule.name = name;",
          "2892:                 rule.ignoreSemanticValue = ignore;",
          "2893:                 rule.is_macro = is_macro;",
          "2894:                 rule.params = params;",
          "2896:                 if (data.start.empty()) {",
          "2897:                     data.start = name;",
          "2898:                     data.start_pos = sv.c_str();",
          "2899:                 }",
          "2900:             } else {",
          "2901:                 data.duplicates.emplace_back(name, sv.c_str());",
          "2902:             }",
          "2903:         };",
          "2905:         g[\"Expression\"] = [&](const SemanticValues& sv) {",
          "2906:             if (sv.size() == 1) {",
          "2907:                 return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2908:             } else {",
          "2909:                 std::vector<std::shared_ptr<Ope>> opes;",
          "2910:                 for (auto i = 0u; i < sv.size(); i++) {",
          "2911:                     opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));",
          "2912:                 }",
          "2913:                 const std::shared_ptr<Ope> ope = std::make_shared<PrioritizedChoice>(opes);",
          "2914:                 return ope;",
          "2915:             }",
          "2916:         };",
          "2918:         g[\"Sequence\"] = [&](const SemanticValues& sv) {",
          "2919:             if (sv.size() == 1) {",
          "2920:                 return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2921:             } else {",
          "2922:                 std::vector<std::shared_ptr<Ope>> opes;",
          "2923:                 for (const auto& x: sv) {",
          "2924:                     opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));",
          "2925:                 }",
          "2926:                 const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);",
          "2927:                 return ope;",
          "2928:             }",
          "2929:         };",
          "2931:         g[\"Prefix\"] = [&](const SemanticValues& sv) {",
          "2932:             std::shared_ptr<Ope> ope;",
          "2933:             if (sv.size() == 1) {",
          "2934:                 ope = any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2935:             } else {",
          "2936:                 assert(sv.size() == 2);",
          "2937:                 auto tok = any_cast<char>(sv[0]);",
          "2938:                 ope = any_cast<std::shared_ptr<Ope>>(sv[1]);",
          "2939:                 if (tok == '&') {",
          "2940:                     ope = apd(ope);",
          "2941:                 } else { // '!'",
          "2942:                     ope = npd(ope);",
          "2943:                 }",
          "2944:             }",
          "2945:             return ope;",
          "2946:         };",
          "2948:         g[\"Suffix\"] = [&](const SemanticValues& sv) {",
          "2949:             auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2950:             if (sv.size() == 1) {",
          "2951:                 return ope;",
          "2952:             } else {",
          "2953:                 assert(sv.size() == 2);",
          "2954:                 auto tok = any_cast<char>(sv[1]);",
          "2955:                 if (tok == '?') {",
          "2956:                     return opt(ope);",
          "2957:                 } else if (tok == '*') {",
          "2958:                     return zom(ope);",
          "2959:                 } else { // '+'",
          "2960:                     return oom(ope);",
          "2961:                 }",
          "2962:             }",
          "2963:         };",
          "2965:         g[\"Primary\"] = [&](const SemanticValues& sv, any& dt) -> std::shared_ptr<Ope> {",
          "2966:             Data& data = *any_cast<Data*>(dt);",
          "2968:             switch (sv.choice()) {",
          "2969:                 case 0:   // Macro Reference",
          "2970:                 case 1: { // Reference",
          "2971:                     auto is_macro = sv.choice() == 0;",
          "2972:                     auto ignore = any_cast<bool>(sv[0]);",
          "2973:                     const auto& ident = any_cast<std::string>(sv[1]);",
          "2975:                     std::vector<std::shared_ptr<Ope>> args;",
          "2976:                     if (is_macro) {",
          "2977:                         args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);",
          "2978:                     }",
          "2980:                     if (ignore) {",
          "2981:                         return ign(ref(*data.grammar, ident, sv.c_str(), is_macro, args));",
          "2982:                     } else {",
          "2983:                         return ref(*data.grammar, ident, sv.c_str(), is_macro, args);",
          "2984:                     }",
          "2985:                 }",
          "2986:                 case 2: { // (Expression)",
          "2987:                     return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2988:                 }",
          "2989:                 case 3: { // TokenBoundary",
          "2990:                     return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));",
          "2991:                 }",
          "2992:                 case 4: { // CaptureScope",
          "2993:                     return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));",
          "2994:                 }",
          "2995:                 case 5: { // Capture",
          "2996:                     const auto& name = any_cast<std::string>(sv[0]);",
          "2997:                     auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);",
          "2998:                     return cap(ope, [name](const char* a_s, size_t a_n, Context& c) {",
          "2999:                         auto& cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];",
          "3000:                         cs[name] = std::string(a_s, a_n);",
          "3001:                     });",
          "3002:                 }",
          "3003:                 default: {",
          "3004:                     return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "3005:                 }",
          "3006:             }",
          "3007:         };",
          "3009:         g[\"IdentCont\"] = [](const SemanticValues& sv) {",
          "3010:             return std::string(sv.c_str(), sv.length());",
          "3011:         };",
          "3013:         g[\"LiteralI\"] = [](const SemanticValues& sv) {",
          "3014:             const auto& tok = sv.tokens.front();",
          "3015:             return liti(resolve_escape_sequence(tok.first, tok.second));",
          "3016:         };",
          "3017:         g[\"Literal\"] = [](const SemanticValues& sv) {",
          "3018:             const auto& tok = sv.tokens.front();",
          "3019:             return lit(resolve_escape_sequence(tok.first, tok.second));",
          "3020:         };",
          "3022:         g[\"Class\"] = [](const SemanticValues& sv) {",
          "3023:             auto ranges = sv.transform<std::pair<char32_t, char32_t>>();",
          "3024:             return cls(ranges);",
          "3025:         };",
          "3026:         g[\"NegatedClass\"] = [](const SemanticValues& sv) {",
          "3027:             auto ranges = sv.transform<std::pair<char32_t, char32_t>>();",
          "3028:             return ncls(ranges);",
          "3029:         };",
          "3030:         g[\"Range\"] = [](const SemanticValues& sv) {",
          "3031:             switch (sv.choice()) {",
          "3032:                 case 0: {",
          "3033:                     auto s1 = any_cast<std::string>(sv[0]);",
          "3034:                     auto s2 = any_cast<std::string>(sv[1]);",
          "3035:                     auto cp1 = decode_codepoint(s1.c_str(), s1.length());",
          "3036:                     auto cp2 = decode_codepoint(s2.c_str(), s2.length());",
          "3037:                     return std::make_pair(cp1, cp2);",
          "3038:                 }",
          "3039:                 case 1: {",
          "3040:                     auto s = any_cast<std::string>(sv[0]);",
          "3041:                     auto cp = decode_codepoint(s.c_str(), s.length());",
          "3042:                     return std::make_pair(cp, cp);",
          "3043:                 }",
          "3044:             }",
          "3045:             return std::make_pair<char32_t, char32_t>(0, 0);",
          "3046:         };",
          "3047:         g[\"Char\"] = [](const SemanticValues& sv) {",
          "3048:             return resolve_escape_sequence(sv.c_str(), sv.length());",
          "3049:         };",
          "3051:         g[\"AND\"]      = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "3052:         g[\"NOT\"]      = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "3053:         g[\"QUESTION\"] = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "3054:         g[\"STAR\"]     = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "3055:         g[\"PLUS\"]     = [](const SemanticValues& sv) { return *sv.c_str(); };",
          "3057:         g[\"DOT\"] = [](const SemanticValues& /*sv*/) { return dot(); };",
          "3059:         g[\"BeginCap\"] = [](const SemanticValues& sv) { return sv.token(); };",
          "3061:         g[\"BackRef\"] = [&](const SemanticValues& sv) {",
          "3062:             return bkr(sv.token());",
          "3063:         };",
          "3065:         g[\"Ignore\"] = [](const SemanticValues& sv) { return sv.size() > 0; };",
          "3067:         g[\"Parameters\"] = [](const SemanticValues& sv) {",
          "3068:             return sv.transform<std::string>();",
          "3069:         };",
          "3071:         g[\"Arguments\"] = [](const SemanticValues& sv) {",
          "3072:             return sv.transform<std::shared_ptr<Ope>>();",
          "3073:         };",
          "3074:     }",
          "3076:     std::shared_ptr<Grammar> perform_core(",
          "3077:         const char*  s,",
          "3078:         size_t       n,",
          "3079:         const Rules& rules,",
          "3080:         std::string& start,",
          "3081:         Log          log)",
          "3082:     {",
          "3083:         Data data;",
          "3084:         any dt = &data;",
          "3085:         auto r = g[\"Grammar\"].parse(s, n, dt);",
          "3087:         if (!r.ret) {",
          "3088:             if (log) {",
          "3089:                 if (r.message_pos) {",
          "3090:                     auto line = line_info(s, r.message_pos);",
          "3091:                     log(line.first, line.second, r.message);",
          "3092:                 } else {",
          "3093:                     auto line = line_info(s, r.error_pos);",
          "3094:                     log(line.first, line.second, \"syntax error\");",
          "3095:                 }",
          "3096:             }",
          "3097:             return nullptr;",
          "3098:         }",
          "3100:         auto& grammar = *data.grammar;",
          "3103:         for (const auto& x: rules) {",
          "3104:             auto name = x.first;",
          "3105:             bool ignore = false;",
          "3106:             if (!name.empty() && name[0] == '~') {",
          "3107:                 ignore = true;",
          "3108:                 name.erase(0, 1);",
          "3109:             }",
          "3110:             if (!name.empty()) {",
          "3111:                 auto& rule = grammar[name];",
          "3112:                 rule <= x.second;",
          "3113:                 rule.name = name;",
          "3114:                 rule.ignoreSemanticValue = ignore;",
          "3115:             }",
          "3119:         bool ret = data.duplicates.empty();",
          "3121:         for (const auto& x: data.duplicates) {",
          "3122:             if (log) {",
          "3123:                 const auto& name = x.first;",
          "3124:                 auto ptr = x.second;",
          "3125:                 auto line = line_info(s, ptr);",
          "3126:                 log(line.first, line.second, \"'\" + name + \"' is already defined.\");",
          "3127:             }",
          "3128:         }",
          "3131:         for (auto& x: grammar) {",
          "3132:             auto& rule = x.second;",
          "3134:             ReferenceChecker vis(*data.grammar, rule.params);",
          "3135:             rule.accept(vis);",
          "3136:             for (const auto& y: vis.error_s) {",
          "3137:                 const auto& name = y.first;",
          "3138:                 const auto ptr = y.second;",
          "3139:                 if (log) {",
          "3140:                     auto line = line_info(s, ptr);",
          "3141:                     log(line.first, line.second, vis.error_message[name]);",
          "3142:                 }",
          "3143:                 ret = false;",
          "3144:             }",
          "3145:         }",
          "3147:         if (!ret) {",
          "3148:             return nullptr;",
          "3149:         }",
          "3152:         for (auto& x: grammar) {",
          "3153:             auto& rule = x.second;",
          "3154:             LinkReferences vis(*data.grammar, rule.params);",
          "3155:             rule.accept(vis);",
          "3156:         }",
          "3159:         ret = true;",
          "3161:         for (auto& x: grammar) {",
          "3162:             const auto& name = x.first;",
          "3163:             auto& rule = x.second;",
          "3165:             DetectLeftRecursion vis(name);",
          "3166:             rule.accept(vis);",
          "3167:             if (vis.error_s) {",
          "3168:                 if (log) {",
          "3169:                     auto line = line_info(s, vis.error_s);",
          "3170:                     log(line.first, line.second, \"'\" + name + \"' is left recursive.\");",
          "3171:                 }",
          "3172:                 ret = false;;",
          "3173:             }",
          "3176:         if (!ret) {",
          "3177:             return nullptr;",
          "3178:         }",
          "3181:         auto& start_rule = (*data.grammar)[data.start];",
          "3184:         {",
          "3185:             DetectInfiniteLoop vis(data.start_pos, data.start);",
          "3186:             start_rule.accept(vis);",
          "3187:             if (vis.has_error) {",
          "3188:                 if (log) {",
          "3189:                     auto line = line_info(s, vis.error_s);",
          "3190:                     log(line.first, line.second, \"infinite loop is detected in '\" + vis.error_name + \"'.\");",
          "3191:                 }",
          "3192:                 return nullptr;",
          "3193:             }",
          "3194:         }",
          "3197:         if (grammar.count(WHITESPACE_DEFINITION_NAME)) {",
          "3198:             for (auto& x: grammar) {",
          "3199:                 auto& rule = x.second;",
          "3200:                 auto ope = rule.get_core_operator();",
          "3201:                 if (IsLiteralToken::check(*ope)) {",
          "3202:                     rule <= tok(ope);",
          "3203:                 }",
          "3204:             }",
          "3206:             start_rule.whitespaceOpe = wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());",
          "3210:         if (grammar.count(WORD_DEFINITION_NAME)) {",
          "3211:             start_rule.wordOpe = (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();",
          "3215:         start = data.start;",
          "3217:         return data.grammar;",
          "3220:     Grammar g;",
          "3227: template <typename Annotation>",
          "3228: struct AstBase : public Annotation",
          "3229: {",
          "3230:     AstBase(const char* a_path, size_t a_line, size_t a_column,",
          "3231:             const char* a_name, size_t a_position, size_t a_length,",
          "3232:             size_t a_choice_count, size_t a_choice,",
          "3233:             const std::vector<std::shared_ptr<AstBase>>& a_nodes)",
          "3234:         : path(a_path ? a_path : \"\")",
          "3235:         , line(a_line)",
          "3236:         , column(a_column)",
          "3237:         , name(a_name)",
          "3238:         , position(a_position)",
          "3239:         , length(a_length)",
          "3240:         , choice_count(a_choice_count)",
          "3241:         , choice(a_choice)",
          "3242:         , original_name(a_name)",
          "3243:         , original_choice_count(a_choice_count)",
          "3244:         , original_choice(a_choice)",
          "3245:         , tag(str2tag(a_name))",
          "3246:         , original_tag(tag)",
          "3247:         , is_token(false)",
          "3248:         , nodes(a_nodes)",
          "3249:     {}",
          "3251:     AstBase(const char* a_path, size_t a_line, size_t a_column,",
          "3252:             const char* a_name, size_t a_position, size_t a_length,",
          "3253:             size_t a_choice_count, size_t a_choice,",
          "3254:             const std::string& a_token)",
          "3255:         : path(a_path ? a_path : \"\")",
          "3256:         , line(a_line)",
          "3257:         , column(a_column)",
          "3258:         , name(a_name)",
          "3259:         , position(a_position)",
          "3260:         , length(a_length)",
          "3261:         , choice_count(a_choice_count)",
          "3262:         , choice(a_choice)",
          "3263:         , original_name(a_name)",
          "3264:         , original_choice_count(a_choice_count)",
          "3265:         , original_choice(a_choice)",
          "3266:         , tag(str2tag(a_name))",
          "3267:         , original_tag(tag)",
          "3268:         , is_token(true)",
          "3269:         , token(a_token)",
          "3270:     {}",
          "3272:     AstBase(const AstBase& ast, const char* a_original_name,",
          "3273:             size_t a_position, size_t a_length,",
          "3274:             size_t a_original_choice_count, size_t a_original_choise)",
          "3275:         : path(ast.path)",
          "3276:         , line(ast.line)",
          "3277:         , column(ast.column)",
          "3278:         , name(ast.name)",
          "3279:         , position(a_position)",
          "3280:         , length(a_length)",
          "3281:         , choice_count(ast.choice_count)",
          "3282:         , choice(ast.choice)",
          "3283:         , original_name(a_original_name)",
          "3284:         , original_choice_count(a_original_choice_count)",
          "3285:         , original_choice(a_original_choise)",
          "3286:         , tag(ast.tag)",
          "3287:         , original_tag(str2tag(a_original_name))",
          "3288:         , is_token(ast.is_token)",
          "3289:         , token(ast.token)",
          "3290:         , nodes(ast.nodes)",
          "3291:         , parent(ast.parent)",
          "3292:     {}",
          "3294:     const std::string                 path;",
          "3295:     const size_t                      line = 1;",
          "3296:     const size_t                      column = 1;",
          "3298:     const std::string                 name;",
          "3299:     size_t                            position;",
          "3300:     size_t                            length;",
          "3301:     const size_t                      choice_count;",
          "3302:     const size_t                      choice;",
          "3303:     const std::string                 original_name;",
          "3304:     const size_t                      original_choice_count;",
          "3305:     const size_t                      original_choice;",
          "3306:     const unsigned int                tag;",
          "3307:     const unsigned int                original_tag;",
          "3309:     const bool                        is_token;",
          "3310:     const std::string                 token;",
          "3312:     std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;",
          "3313:     std::weak_ptr<AstBase<Annotation>>                parent;",
          "3317: void ast_to_s_core(",
          "3318:     const std::shared_ptr<T>& ptr,",
          "3319:     std::string& s,",
          "3320:     int level,",
          "3321:     std::function<std::string (const T& ast, int level)> fn) {",
          "3323:     const auto& ast = *ptr;",
          "3324:     for (auto i = 0; i < level; i++) {",
          "3325:         s += \"  \";",
          "3326:     }",
          "3327:     auto name = ast.original_name;",
          "3328:     if (ast.original_choice_count > 0) {",
          "3329:         name += \"/\" + std::to_string(ast.original_choice);",
          "3330:     }",
          "3331:     if (ast.name != ast.original_name) {",
          "3332:         name += \"[\" + ast.name + \"]\";",
          "3333:     }",
          "3334:     if (ast.is_token) {",
          "3335:         s += \"- \" + name + \" (\" + ast.token + \")\\n\";",
          "3336:     } else {",
          "3337:         s += \"+ \" + name + \"\\n\";",
          "3338:     }",
          "3339:     if (fn) {",
          "3340:       s += fn(ast, level + 1);",
          "3341:     }",
          "3342:     for (auto node : ast.nodes) {",
          "3343:         ast_to_s_core(node, s, level + 1, fn);",
          "3344:     }",
          "3348: std::string ast_to_s(",
          "3349:     const std::shared_ptr<T>& ptr,",
          "3350:     std::function<std::string (const T& ast, int level)> fn = nullptr) {",
          "3352:     std::string s;",
          "3353:     ast_to_s_core(ptr, s, 0, fn);",
          "3354:     return s;",
          "3357: struct AstOptimizer",
          "3358: {",
          "3359:     AstOptimizer(bool optimize_nodes, const std::vector<std::string>& filters = {})",
          "3360:         : optimize_nodes_(optimize_nodes)",
          "3361:         , filters_(filters) {}",
          "3363:     template <typename T>",
          "3364:     std::shared_ptr<T> optimize(std::shared_ptr<T> original, std::shared_ptr<T> parent = nullptr) {",
          "3366:         auto found = std::find(filters_.begin(), filters_.end(), original->name) != filters_.end();",
          "3367:         bool opt = optimize_nodes_ ? !found : found;",
          "3369:         if (opt && original->nodes.size() == 1) {",
          "3370:             auto child = optimize(original->nodes[0], parent);",
          "3371:             return std::make_shared<T>(",
          "3373:                 original->position, original->length, original->choice);",
          "3374:         }",
          "3376:         auto ast = std::make_shared<T>(*original);",
          "3377:         ast->parent = parent;",
          "3378:         ast->nodes.clear();",
          "3379:         for (auto node : original->nodes) {",
          "3380:             auto child = optimize(node, ast);",
          "3381:             ast->nodes.push_back(child);",
          "3382:         }",
          "3383:         return ast;",
          "3387:     const bool                     optimize_nodes_;",
          "3388:     const std::vector<std::string> filters_;",
          "",
          "[Added Lines]",
          "2690: typedef std::function<void(size_t, size_t, const std::string &)> Log;",
          "2692: class ParserGenerator {",
          "2694:   static std::shared_ptr<Grammar> parse(const char *s, size_t n,",
          "2695:                                         const Rules &rules, std::string &start,",
          "2696:                                         Log log) {",
          "2697:     return get_instance().perform_core(s, n, rules, start, log);",
          "2698:   }",
          "2700:   static std::shared_ptr<Grammar> parse(const char *s, size_t n,",
          "2701:                                         std::string &start, Log log) {",
          "2702:     Rules dummy;",
          "2703:     return parse(s, n, dummy, start, log);",
          "2704:   }",
          "2707:   static Grammar &grammar() { return get_instance().g; }",
          "2710:   static ParserGenerator &get_instance() {",
          "2711:     static ParserGenerator instance;",
          "2712:     return instance;",
          "2713:   }",
          "2715:   ParserGenerator() {",
          "2716:     make_grammar();",
          "2717:     setup_actions();",
          "2718:   }",
          "2720:   struct Data {",
          "2721:     std::shared_ptr<Grammar> grammar;",
          "2722:     std::string start;",
          "2723:     const char *start_pos = nullptr;",
          "2724:     std::vector<std::pair<std::string, const char *>> duplicates;",
          "2726:     Data() : grammar(std::make_shared<Grammar>()) {}",
          "2727:   };",
          "2729:   void make_grammar() {",
          "2731:     g[\"Grammar\"] <= seq(g[\"Spacing\"], oom(g[\"Definition\"]), g[\"EndOfFile\"]);",
          "2732:     g[\"Definition\"] <=",
          "2733:         cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Parameters\"], g[\"LEFTARROW\"],",
          "2734:                 g[\"Expression\"]),",
          "2735:             seq(g[\"Ignore\"], g[\"Identifier\"], g[\"LEFTARROW\"], g[\"Expression\"]));",
          "2737:     g[\"Expression\"] <= seq(g[\"Sequence\"], zom(seq(g[\"SLASH\"], g[\"Sequence\"])));",
          "2738:     g[\"Sequence\"] <= zom(g[\"Prefix\"]);",
          "2739:     g[\"Prefix\"] <= seq(opt(cho(g[\"AND\"], g[\"NOT\"])), g[\"Suffix\"]);",
          "2740:     g[\"Suffix\"] <=",
          "2741:         seq(g[\"Primary\"], opt(cho(g[\"QUESTION\"], g[\"STAR\"], g[\"PLUS\"])));",
          "2742:     g[\"Primary\"] <=",
          "2743:         cho(seq(g[\"Ignore\"], g[\"IdentCont\"], g[\"Arguments\"],",
          "2744:                 npd(g[\"LEFTARROW\"])),",
          "2745:             seq(g[\"Ignore\"], g[\"Identifier\"],",
          "2746:                 npd(seq(opt(g[\"Parameters\"]), g[\"LEFTARROW\"]))),",
          "2747:             seq(g[\"OPEN\"], g[\"Expression\"], g[\"CLOSE\"]),",
          "2748:             seq(g[\"BeginTok\"], g[\"Expression\"], g[\"EndTok\"]),",
          "2749:             seq(g[\"BeginCapScope\"], g[\"Expression\"], g[\"EndCapScope\"]),",
          "2750:             seq(g[\"BeginCap\"], g[\"Expression\"], g[\"EndCap\"]), g[\"BackRef\"],",
          "2751:             g[\"LiteralI\"], g[\"Literal\"], g[\"NegatedClass\"], g[\"Class\"],",
          "2752:             g[\"DOT\"]);",
          "2754:     g[\"Identifier\"] <= seq(g[\"IdentCont\"], g[\"Spacing\"]);",
          "2755:     g[\"IdentCont\"] <= seq(g[\"IdentStart\"], zom(g[\"IdentRest\"]));",
          "2757:     const static std::vector<std::pair<char32_t, char32_t>> range = {",
          "2758:         {0x0080, 0xFFFF}};",
          "2759:     g[\"IdentStart\"] <= cho(cls(\"a-zA-Z_%\"), cls(range));",
          "2761:     g[\"IdentRest\"] <= cho(g[\"IdentStart\"], cls(\"0-9\"));",
          "2763:     g[\"LiteralI\"] <=",
          "2764:         cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))), lit(\"'i\"),",
          "2765:                 g[\"Spacing\"]),",
          "2766:             seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))), lit(\"\\\"i\"),",
          "2767:                 g[\"Spacing\"]));",
          "2769:     g[\"Literal\"] <= cho(seq(cls(\"'\"), tok(zom(seq(npd(cls(\"'\")), g[\"Char\"]))),",
          "2770:                             cls(\"'\"), g[\"Spacing\"]),",
          "2771:                         seq(cls(\"\\\"\"), tok(zom(seq(npd(cls(\"\\\"\")), g[\"Char\"]))),",
          "2772:                             cls(\"\\\"\"), g[\"Spacing\"]));",
          "2775:     g[\"Class\"] <= seq(chr('['), npd(chr('^')),",
          "2776:                       tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),",
          "2777:                       g[\"Spacing\"]);",
          "2778:     g[\"NegatedClass\"] <= seq(lit(\"[^\"),",
          "2779:                              tok(oom(seq(npd(chr(']')), g[\"Range\"]))), chr(']'),",
          "2780:                              g[\"Spacing\"]);",
          "2782:     g[\"Range\"] <= cho(seq(g[\"Char\"], chr('-'), g[\"Char\"]), g[\"Char\"]);",
          "2783:     g[\"Char\"] <= cho(seq(chr('\\\\'), cls(\"nrt'\\\"[]\\\\^\")),",
          "2784:                      seq(chr('\\\\'), cls(\"0-3\"), cls(\"0-7\"), cls(\"0-7\")),",
          "2785:                      seq(chr('\\\\'), cls(\"0-7\"), opt(cls(\"0-7\"))),",
          "2786:                      seq(lit(\"\\\\x\"), cls(\"0-9a-fA-F\"), opt(cls(\"0-9a-fA-F\"))),",
          "2787:                      seq(lit(\"\\\\u\"), cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\"),",
          "2788:                          cls(\"0-9a-fA-F\"), cls(\"0-9a-fA-F\")),",
          "2789:                      seq(npd(chr('\\\\')), dot()));",
          "2791:     g[\"LEFTARROW\"] <= seq(cho(lit(\"<-\"), lit(u8\"\u2190\")), g[\"Spacing\"]);",
          "2792:     ~g[\"SLASH\"] <= seq(chr('/'), g[\"Spacing\"]);",
          "2793:     g[\"AND\"] <= seq(chr('&'), g[\"Spacing\"]);",
          "2794:     g[\"NOT\"] <= seq(chr('!'), g[\"Spacing\"]);",
          "2795:     g[\"QUESTION\"] <= seq(chr('?'), g[\"Spacing\"]);",
          "2796:     g[\"STAR\"] <= seq(chr('*'), g[\"Spacing\"]);",
          "2797:     g[\"PLUS\"] <= seq(chr('+'), g[\"Spacing\"]);",
          "2798:     ~g[\"OPEN\"] <= seq(chr('('), g[\"Spacing\"]);",
          "2799:     ~g[\"CLOSE\"] <= seq(chr(')'), g[\"Spacing\"]);",
          "2800:     g[\"DOT\"] <= seq(chr('.'), g[\"Spacing\"]);",
          "2802:     ~g[\"Spacing\"] <= zom(cho(g[\"Space\"], g[\"Comment\"]));",
          "2803:     g[\"Comment\"] <=",
          "2804:         seq(chr('#'), zom(seq(npd(g[\"EndOfLine\"]), dot())), g[\"EndOfLine\"]);",
          "2805:     g[\"Space\"] <= cho(chr(' '), chr('\\t'), g[\"EndOfLine\"]);",
          "2806:     g[\"EndOfLine\"] <= cho(lit(\"\\r\\n\"), chr('\\n'), chr('\\r'));",
          "2807:     g[\"EndOfFile\"] <= npd(dot());",
          "2809:     ~g[\"BeginTok\"] <= seq(chr('<'), g[\"Spacing\"]);",
          "2810:     ~g[\"EndTok\"] <= seq(chr('>'), g[\"Spacing\"]);",
          "2812:     ~g[\"BeginCapScope\"] <= seq(chr('$'), chr('('), g[\"Spacing\"]);",
          "2813:     ~g[\"EndCapScope\"] <= seq(chr(')'), g[\"Spacing\"]);",
          "2815:     g[\"BeginCap\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), chr('<'), g[\"Spacing\"]);",
          "2816:     ~g[\"EndCap\"] <= seq(chr('>'), g[\"Spacing\"]);",
          "2818:     g[\"BackRef\"] <= seq(chr('$'), tok(g[\"IdentCont\"]), g[\"Spacing\"]);",
          "2820:     g[\"IGNORE\"] <= chr('~');",
          "2822:     g[\"Ignore\"] <= opt(g[\"IGNORE\"]);",
          "2823:     g[\"Parameters\"] <= seq(g[\"OPEN\"], g[\"Identifier\"],",
          "2824:                            zom(seq(g[\"COMMA\"], g[\"Identifier\"])), g[\"CLOSE\"]);",
          "2825:     g[\"Arguments\"] <= seq(g[\"OPEN\"], g[\"Expression\"],",
          "2826:                           zom(seq(g[\"COMMA\"], g[\"Expression\"])), g[\"CLOSE\"]);",
          "2827:     ~g[\"COMMA\"] <= seq(chr(','), g[\"Spacing\"]);",
          "2830:     for (auto &x : g) {",
          "2831:       x.second.name = x.first;",
          "2833:   }",
          "2835:   void setup_actions() {",
          "2836:     g[\"Definition\"] = [&](const SemanticValues &sv, any &dt) {",
          "2837:       auto is_macro = sv.choice() == 0;",
          "2838:       auto ignore = any_cast<bool>(sv[0]);",
          "2839:       auto name = any_cast<std::string>(sv[1]);",
          "2841:       std::vector<std::string> params;",
          "2842:       std::shared_ptr<Ope> ope;",
          "2843:       if (is_macro) {",
          "2844:         params = any_cast<std::vector<std::string>>(sv[2]);",
          "2845:         ope = any_cast<std::shared_ptr<Ope>>(sv[4]);",
          "2846:       } else {",
          "2847:         ope = any_cast<std::shared_ptr<Ope>>(sv[3]);",
          "2848:       }",
          "2850:       Data &data = *any_cast<Data *>(dt);",
          "2852:       auto &grammar = *data.grammar;",
          "2853:       if (!grammar.count(name)) {",
          "2854:         auto &rule = grammar[name];",
          "2855:         rule <= ope;",
          "2856:         rule.name = name;",
          "2857:         rule.ignoreSemanticValue = ignore;",
          "2858:         rule.is_macro = is_macro;",
          "2859:         rule.params = params;",
          "2861:         if (data.start.empty()) {",
          "2862:           data.start = name;",
          "2863:           data.start_pos = sv.c_str();",
          "2864:         }",
          "2865:       } else {",
          "2866:         data.duplicates.emplace_back(name, sv.c_str());",
          "2867:       }",
          "2870:     g[\"Expression\"] = [&](const SemanticValues &sv) {",
          "2871:       if (sv.size() == 1) {",
          "2872:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2873:       } else {",
          "2874:         std::vector<std::shared_ptr<Ope>> opes;",
          "2875:         for (auto i = 0u; i < sv.size(); i++) {",
          "2876:           opes.emplace_back(any_cast<std::shared_ptr<Ope>>(sv[i]));",
          "2878:         const std::shared_ptr<Ope> ope =",
          "2879:             std::make_shared<PrioritizedChoice>(opes);",
          "2880:         return ope;",
          "2881:       }",
          "2882:     };",
          "2884:     g[\"Sequence\"] = [&](const SemanticValues &sv) {",
          "2885:       if (sv.size() == 1) {",
          "2886:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2887:       } else {",
          "2888:         std::vector<std::shared_ptr<Ope>> opes;",
          "2889:         for (const auto &x : sv) {",
          "2890:           opes.emplace_back(any_cast<std::shared_ptr<Ope>>(x));",
          "2891:         }",
          "2892:         const std::shared_ptr<Ope> ope = std::make_shared<Sequence>(opes);",
          "2893:         return ope;",
          "2894:       }",
          "2895:     };",
          "2897:     g[\"Prefix\"] = [&](const SemanticValues &sv) {",
          "2898:       std::shared_ptr<Ope> ope;",
          "2899:       if (sv.size() == 1) {",
          "2900:         ope = any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2901:       } else {",
          "2902:         assert(sv.size() == 2);",
          "2903:         auto tok = any_cast<char>(sv[0]);",
          "2904:         ope = any_cast<std::shared_ptr<Ope>>(sv[1]);",
          "2905:         if (tok == '&') {",
          "2906:           ope = apd(ope);",
          "2907:         } else { // '!'",
          "2908:           ope = npd(ope);",
          "2909:         }",
          "2910:       }",
          "2911:       return ope;",
          "2912:     };",
          "2914:     g[\"Suffix\"] = [&](const SemanticValues &sv) {",
          "2915:       auto ope = any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2916:       if (sv.size() == 1) {",
          "2917:         return ope;",
          "2918:       } else {",
          "2919:         assert(sv.size() == 2);",
          "2920:         auto tok = any_cast<char>(sv[1]);",
          "2921:         if (tok == '?') {",
          "2922:           return opt(ope);",
          "2923:         } else if (tok == '*') {",
          "2924:           return zom(ope);",
          "2925:         } else { // '+'",
          "2926:           return oom(ope);",
          "2927:         }",
          "2928:       }",
          "2929:     };",
          "2931:     g[\"Primary\"] = [&](const SemanticValues &sv,",
          "2932:                        any &dt) -> std::shared_ptr<Ope> {",
          "2933:       Data &data = *any_cast<Data *>(dt);",
          "2935:       switch (sv.choice()) {",
          "2936:       case 0:   // Macro Reference",
          "2937:       case 1: { // Reference",
          "2938:         auto is_macro = sv.choice() == 0;",
          "2939:         auto ignore = any_cast<bool>(sv[0]);",
          "2940:         const auto &ident = any_cast<std::string>(sv[1]);",
          "2942:         std::vector<std::shared_ptr<Ope>> args;",
          "2943:         if (is_macro) {",
          "2944:           args = any_cast<std::vector<std::shared_ptr<Ope>>>(sv[2]);",
          "2945:         }",
          "2947:         if (ignore) {",
          "2948:           return ign(ref(*data.grammar, ident, sv.c_str(), is_macro, args));",
          "2949:         } else {",
          "2950:           return ref(*data.grammar, ident, sv.c_str(), is_macro, args);",
          "2951:         }",
          "2952:       }",
          "2953:       case 2: { // (Expression)",
          "2954:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2955:       }",
          "2956:       case 3: { // TokenBoundary",
          "2957:         return tok(any_cast<std::shared_ptr<Ope>>(sv[0]));",
          "2958:       }",
          "2959:       case 4: { // CaptureScope",
          "2960:         return csc(any_cast<std::shared_ptr<Ope>>(sv[0]));",
          "2961:       }",
          "2962:       case 5: { // Capture",
          "2963:         const auto &name = any_cast<std::string>(sv[0]);",
          "2964:         auto ope = any_cast<std::shared_ptr<Ope>>(sv[1]);",
          "2965:         return cap(ope, [name](const char *a_s, size_t a_n, Context &c) {",
          "2966:           auto &cs = c.capture_scope_stack[c.capture_scope_stack_size - 1];",
          "2967:           cs[name] = std::string(a_s, a_n);",
          "2968:         });",
          "2969:       }",
          "2970:       default: {",
          "2971:         return any_cast<std::shared_ptr<Ope>>(sv[0]);",
          "2972:       }",
          "2973:       }",
          "2974:     };",
          "2976:     g[\"IdentCont\"] = [](const SemanticValues &sv) {",
          "2977:       return std::string(sv.c_str(), sv.length());",
          "2978:     };",
          "2980:     g[\"LiteralI\"] = [](const SemanticValues &sv) {",
          "2981:       const auto &tok = sv.tokens.front();",
          "2982:       return liti(resolve_escape_sequence(tok.first, tok.second));",
          "2983:     };",
          "2984:     g[\"Literal\"] = [](const SemanticValues &sv) {",
          "2985:       const auto &tok = sv.tokens.front();",
          "2986:       return lit(resolve_escape_sequence(tok.first, tok.second));",
          "2987:     };",
          "2989:     g[\"Class\"] = [](const SemanticValues &sv) {",
          "2990:       auto ranges = sv.transform<std::pair<char32_t, char32_t>>();",
          "2991:       return cls(ranges);",
          "2992:     };",
          "2993:     g[\"NegatedClass\"] = [](const SemanticValues &sv) {",
          "2994:       auto ranges = sv.transform<std::pair<char32_t, char32_t>>();",
          "2995:       return ncls(ranges);",
          "2996:     };",
          "2997:     g[\"Range\"] = [](const SemanticValues &sv) {",
          "2998:       switch (sv.choice()) {",
          "2999:       case 0: {",
          "3000:         auto s1 = any_cast<std::string>(sv[0]);",
          "3001:         auto s2 = any_cast<std::string>(sv[1]);",
          "3002:         auto cp1 = decode_codepoint(s1.c_str(), s1.length());",
          "3003:         auto cp2 = decode_codepoint(s2.c_str(), s2.length());",
          "3004:         return std::make_pair(cp1, cp2);",
          "3005:       }",
          "3006:       case 1: {",
          "3007:         auto s = any_cast<std::string>(sv[0]);",
          "3008:         auto cp = decode_codepoint(s.c_str(), s.length());",
          "3009:         return std::make_pair(cp, cp);",
          "3010:       }",
          "3011:       }",
          "3012:       return std::make_pair<char32_t, char32_t>(0, 0);",
          "3013:     };",
          "3014:     g[\"Char\"] = [](const SemanticValues &sv) {",
          "3015:       return resolve_escape_sequence(sv.c_str(), sv.length());",
          "3016:     };",
          "3018:     g[\"AND\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3019:     g[\"NOT\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3020:     g[\"QUESTION\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3021:     g[\"STAR\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3022:     g[\"PLUS\"] = [](const SemanticValues &sv) { return *sv.c_str(); };",
          "3024:     g[\"DOT\"] = [](const SemanticValues & /*sv*/) { return dot(); };",
          "3026:     g[\"BeginCap\"] = [](const SemanticValues &sv) { return sv.token(); };",
          "3028:     g[\"BackRef\"] = [&](const SemanticValues &sv) { return bkr(sv.token()); };",
          "3030:     g[\"Ignore\"] = [](const SemanticValues &sv) { return sv.size() > 0; };",
          "3032:     g[\"Parameters\"] = [](const SemanticValues &sv) {",
          "3033:       return sv.transform<std::string>();",
          "3034:     };",
          "3036:     g[\"Arguments\"] = [](const SemanticValues &sv) {",
          "3037:       return sv.transform<std::shared_ptr<Ope>>();",
          "3038:     };",
          "3039:   }",
          "3041:   std::shared_ptr<Grammar> perform_core(const char *s, size_t n,",
          "3042:                                         const Rules &rules, std::string &start,",
          "3043:                                         Log log) {",
          "3044:     Data data;",
          "3045:     any dt = &data;",
          "3046:     auto r = g[\"Grammar\"].parse(s, n, dt);",
          "3048:     if (!r.ret) {",
          "3049:       if (log) {",
          "3050:         if (r.message_pos) {",
          "3051:           auto line = line_info(s, r.message_pos);",
          "3052:           log(line.first, line.second, r.message);",
          "3053:         } else {",
          "3054:           auto line = line_info(s, r.error_pos);",
          "3055:           log(line.first, line.second, \"syntax error\");",
          "3057:       }",
          "3058:       return nullptr;",
          "3059:     }",
          "3061:     auto &grammar = *data.grammar;",
          "3064:     for (const auto &x : rules) {",
          "3065:       auto name = x.first;",
          "3066:       bool ignore = false;",
          "3067:       if (!name.empty() && name[0] == '~') {",
          "3068:         ignore = true;",
          "3069:         name.erase(0, 1);",
          "3070:       }",
          "3071:       if (!name.empty()) {",
          "3072:         auto &rule = grammar[name];",
          "3073:         rule <= x.second;",
          "3074:         rule.name = name;",
          "3075:         rule.ignoreSemanticValue = ignore;",
          "3076:       }",
          "3077:     }",
          "3080:     bool ret = data.duplicates.empty();",
          "3082:     for (const auto &x : data.duplicates) {",
          "3083:       if (log) {",
          "3084:         const auto &name = x.first;",
          "3085:         auto ptr = x.second;",
          "3086:         auto line = line_info(s, ptr);",
          "3087:         log(line.first, line.second, \"'\" + name + \"' is already defined.\");",
          "3088:       }",
          "3089:     }",
          "3092:     for (auto &x : grammar) {",
          "3093:       auto &rule = x.second;",
          "3095:       ReferenceChecker vis(*data.grammar, rule.params);",
          "3096:       rule.accept(vis);",
          "3097:       for (const auto &y : vis.error_s) {",
          "3098:         const auto &name = y.first;",
          "3099:         const auto ptr = y.second;",
          "3100:         if (log) {",
          "3101:           auto line = line_info(s, ptr);",
          "3102:           log(line.first, line.second, vis.error_message[name]);",
          "3104:         ret = false;",
          "3105:       }",
          "3106:     }",
          "3108:     if (!ret) { return nullptr; }",
          "3111:     for (auto &x : grammar) {",
          "3112:       auto &rule = x.second;",
          "3113:       LinkReferences vis(*data.grammar, rule.params);",
          "3114:       rule.accept(vis);",
          "3115:     }",
          "3118:     ret = true;",
          "3120:     for (auto &x : grammar) {",
          "3121:       const auto &name = x.first;",
          "3122:       auto &rule = x.second;",
          "3124:       DetectLeftRecursion vis(name);",
          "3125:       rule.accept(vis);",
          "3126:       if (vis.error_s) {",
          "3127:         if (log) {",
          "3128:           auto line = line_info(s, vis.error_s);",
          "3129:           log(line.first, line.second, \"'\" + name + \"' is left recursive.\");",
          "3131:         ret = false;",
          "3132:         ;",
          "3133:       }",
          "3134:     }",
          "3136:     if (!ret) { return nullptr; }",
          "3139:     auto &start_rule = (*data.grammar)[data.start];",
          "3142:     {",
          "3143:       DetectInfiniteLoop vis(data.start_pos, data.start);",
          "3144:       start_rule.accept(vis);",
          "3145:       if (vis.has_error) {",
          "3146:         if (log) {",
          "3147:           auto line = line_info(s, vis.error_s);",
          "3148:           log(line.first, line.second,",
          "3149:               \"infinite loop is detected in '\" + vis.error_name + \"'.\");",
          "3151:         return nullptr;",
          "3152:       }",
          "3153:     }",
          "3156:     if (grammar.count(WHITESPACE_DEFINITION_NAME)) {",
          "3157:       for (auto &x : grammar) {",
          "3158:         auto &rule = x.second;",
          "3159:         auto ope = rule.get_core_operator();",
          "3160:         if (IsLiteralToken::check(*ope)) { rule <= tok(ope); }",
          "3161:       }",
          "3163:       start_rule.whitespaceOpe =",
          "3164:           wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator());",
          "3165:     }",
          "3168:     if (grammar.count(WORD_DEFINITION_NAME)) {",
          "3169:       start_rule.wordOpe =",
          "3170:           (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator();",
          "3174:     start = data.start;",
          "3176:     return data.grammar;",
          "3177:   }",
          "3179:   Grammar g;",
          "3186: template <typename Annotation> struct AstBase : public Annotation {",
          "3187:   AstBase(const char *a_path, size_t a_line, size_t a_column,",
          "3188:           const char *a_name, size_t a_position, size_t a_length,",
          "3189:           size_t a_choice_count, size_t a_choice,",
          "3190:           const std::vector<std::shared_ptr<AstBase>> &a_nodes)",
          "3191:       : path(a_path ? a_path : \"\"), line(a_line), column(a_column),",
          "3192:         name(a_name), position(a_position), length(a_length),",
          "3193:         choice_count(a_choice_count), choice(a_choice), original_name(a_name),",
          "3194:         original_choice_count(a_choice_count), original_choice(a_choice),",
          "3195:         tag(str2tag(a_name)), original_tag(tag), is_token(false),",
          "3196:         nodes(a_nodes) {}",
          "3198:   AstBase(const char *a_path, size_t a_line, size_t a_column,",
          "3199:           const char *a_name, size_t a_position, size_t a_length,",
          "3200:           size_t a_choice_count, size_t a_choice, const std::string &a_token)",
          "3201:       : path(a_path ? a_path : \"\"), line(a_line), column(a_column),",
          "3202:         name(a_name), position(a_position), length(a_length),",
          "3203:         choice_count(a_choice_count), choice(a_choice), original_name(a_name),",
          "3204:         original_choice_count(a_choice_count), original_choice(a_choice),",
          "3205:         tag(str2tag(a_name)), original_tag(tag), is_token(true),",
          "3206:         token(a_token) {}",
          "3208:   AstBase(const AstBase &ast, const char *a_original_name, size_t a_position,",
          "3209:           size_t a_length, size_t a_original_choice_count,",
          "3210:           size_t a_original_choise)",
          "3211:       : path(ast.path), line(ast.line), column(ast.column), name(ast.name),",
          "3212:         position(a_position), length(a_length), choice_count(ast.choice_count),",
          "3213:         choice(ast.choice), original_name(a_original_name),",
          "3214:         original_choice_count(a_original_choice_count),",
          "3215:         original_choice(a_original_choise), tag(ast.tag),",
          "3216:         original_tag(str2tag(a_original_name)), is_token(ast.is_token),",
          "3217:         token(ast.token), nodes(ast.nodes), parent(ast.parent) {}",
          "3219:   const std::string path;",
          "3220:   const size_t line = 1;",
          "3221:   const size_t column = 1;",
          "3223:   const std::string name;",
          "3224:   size_t position;",
          "3225:   size_t length;",
          "3226:   const size_t choice_count;",
          "3227:   const size_t choice;",
          "3228:   const std::string original_name;",
          "3229:   const size_t original_choice_count;",
          "3230:   const size_t original_choice;",
          "3231:   const unsigned int tag;",
          "3232:   const unsigned int original_tag;",
          "3234:   const bool is_token;",
          "3235:   const std::string token;",
          "3237:   std::vector<std::shared_ptr<AstBase<Annotation>>> nodes;",
          "3238:   std::weak_ptr<AstBase<Annotation>> parent;",
          "3242: void ast_to_s_core(const std::shared_ptr<T> &ptr, std::string &s, int level,",
          "3243:                    std::function<std::string(const T &ast, int level)> fn) {",
          "3245:   const auto &ast = *ptr;",
          "3246:   for (auto i = 0; i < level; i++) {",
          "3247:     s += \"  \";",
          "3248:   }",
          "3249:   auto name = ast.original_name;",
          "3250:   if (ast.original_choice_count > 0) {",
          "3251:     name += \"/\" + std::to_string(ast.original_choice);",
          "3252:   }",
          "3253:   if (ast.name != ast.original_name) { name += \"[\" + ast.name + \"]\"; }",
          "3254:   if (ast.is_token) {",
          "3255:     s += \"- \" + name + \" (\" + ast.token + \")\\n\";",
          "3256:   } else {",
          "3257:     s += \"+ \" + name + \"\\n\";",
          "3258:   }",
          "3259:   if (fn) { s += fn(ast, level + 1); }",
          "3260:   for (auto node : ast.nodes) {",
          "3261:     ast_to_s_core(node, s, level + 1, fn);",
          "3262:   }",
          "3266: std::string",
          "3267: ast_to_s(const std::shared_ptr<T> &ptr,",
          "3268:          std::function<std::string(const T &ast, int level)> fn = nullptr) {",
          "3270:   std::string s;",
          "3271:   ast_to_s_core(ptr, s, 0, fn);",
          "3272:   return s;",
          "3275: struct AstOptimizer {",
          "3276:   AstOptimizer(bool optimize_nodes,",
          "3277:                const std::vector<std::string> &filters = {})",
          "3278:       : optimize_nodes_(optimize_nodes), filters_(filters) {}",
          "3280:   template <typename T>",
          "3281:   std::shared_ptr<T> optimize(std::shared_ptr<T> original,",
          "3282:                               std::shared_ptr<T> parent = nullptr) {",
          "3284:     auto found = std::find(filters_.begin(), filters_.end(), original->name) !=",
          "3285:                  filters_.end();",
          "3286:     bool opt = optimize_nodes_ ? !found : found;",
          "3288:     if (opt && original->nodes.size() == 1) {",
          "3289:       auto child = optimize(original->nodes[0], parent);",
          "3290:       return std::make_shared<T>(*child, original->name.c_str(),",
          "3291:                                  original->choice_count, original->position,",
          "3292:                                  original->length, original->choice);",
          "3293:     }",
          "3295:     auto ast = std::make_shared<T>(*original);",
          "3296:     ast->parent = parent;",
          "3297:     ast->nodes.clear();",
          "3298:     for (auto node : original->nodes) {",
          "3299:       auto child = optimize(node, ast);",
          "3300:       ast->nodes.push_back(child);",
          "3302:     return ast;",
          "3303:   }",
          "3306:   const bool optimize_nodes_;",
          "3307:   const std::vector<std::string> filters_;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3400: public:",
          "3447:     }",
          "3462:     }",
          "3478:     }",
          "3495:     }",
          "3518:     }",
          "3525:     }",
          "3557:     }",
          "3565:     }",
          "3569: private:",
          "3584:         }",
          "3585:     }",
          "3589: };",
          "3591: } // namespace peg",
          "",
          "[Removed Lines]",
          "3398: class parser",
          "3399: {",
          "3401:     parser() = default;",
          "3403:     parser(const char* s, size_t n, const Rules& rules) {",
          "3404:         load_grammar(s, n, rules);",
          "3405:     }",
          "3407:     parser(const char* s, const Rules& rules)",
          "3408:         : parser(s, strlen(s), rules) {}",
          "3410:     parser(const char* s, size_t n)",
          "3411:         : parser(s, n, Rules()) {}",
          "3413:     parser(const char* s)",
          "3414:         : parser(s, strlen(s), Rules()) {}",
          "3416:     operator bool() {",
          "3417:         return grammar_ != nullptr;",
          "3418:     }",
          "3420:     bool load_grammar(const char* s, size_t n, const Rules& rules) {",
          "3421:         grammar_ = ParserGenerator::parse(s, n, rules, start_, log);",
          "3422:         return grammar_ != nullptr;",
          "3423:     }",
          "3425:     bool load_grammar(const char* s, size_t n) {",
          "3426:         return load_grammar(s, n, Rules());",
          "3427:     }",
          "3429:     bool load_grammar(const char* s, const Rules& rules) {",
          "3430:         auto n = strlen(s);",
          "3431:         return load_grammar(s, n, rules);",
          "3432:     }",
          "3434:     bool load_grammar(const char* s) {",
          "3435:         auto n = strlen(s);",
          "3436:         return load_grammar(s, n);",
          "3437:     }",
          "3439:     bool parse_n(const char* s, size_t n, const char* path = nullptr) const {",
          "3440:         if (grammar_ != nullptr) {",
          "3441:             const auto& rule = (*grammar_)[start_];",
          "3442:             auto r = rule.parse(s, n, path);",
          "3443:             output_log(s, n, r);",
          "3444:             return r.ret && r.len == n;",
          "3445:         }",
          "3446:         return false;",
          "3449:     bool parse(const char* s, const char* path = nullptr) const {",
          "3450:         auto n = strlen(s);",
          "3451:         return parse_n(s, n, path);",
          "3452:     }",
          "3454:     bool parse_n(const char* s, size_t n, any& dt, const char* path = nullptr) const {",
          "3455:         if (grammar_ != nullptr) {",
          "3456:             const auto& rule = (*grammar_)[start_];",
          "3457:             auto r = rule.parse(s, n, dt, path);",
          "3458:             output_log(s, n, r);",
          "3459:             return r.ret && r.len == n;",
          "3460:         }",
          "3461:         return false;",
          "3464:     bool parse(const char* s, any& dt, const char* path = nullptr) const {",
          "3465:         auto n = strlen(s);",
          "3466:         return parse_n(s, n, dt, path);",
          "3467:     }",
          "3469:     template <typename T>",
          "3470:     bool parse_n(const char* s, size_t n, T& val, const char* path = nullptr) const {",
          "3471:         if (grammar_ != nullptr) {",
          "3472:             const auto& rule = (*grammar_)[start_];",
          "3473:             auto r = rule.parse_and_get_value(s, n, val, path);",
          "3474:             output_log(s, n, r);",
          "3475:             return r.ret && r.len == n;",
          "3476:         }",
          "3477:         return false;",
          "3480:     template <typename T>",
          "3481:     bool parse(const char* s, T& val, const char* path = nullptr) const {",
          "3482:         auto n = strlen(s);",
          "3483:         return parse_n(s, n, val, path);",
          "3484:     }",
          "3486:     template <typename T>",
          "3487:     bool parse_n(const char* s, size_t n, any& dt, T& val, const char* path = nullptr) const {",
          "3488:         if (grammar_ != nullptr) {",
          "3489:             const auto& rule = (*grammar_)[start_];",
          "3490:             auto r = rule.parse_and_get_value(s, n, dt, val, path);",
          "3491:             output_log(s, n, r);",
          "3492:             return r.ret && r.len == n;",
          "3493:         }",
          "3494:         return false;",
          "3497:     template <typename T>",
          "3498:     bool parse(const char* s, any& dt, T& val, const char* /*path*/ = nullptr) const {",
          "3499:         auto n = strlen(s);",
          "3500:         return parse_n(s, n, dt, val);",
          "3501:     }",
          "3503:     Definition& operator[](const char* s) {",
          "3504:         return (*grammar_)[s];",
          "3505:     }",
          "3507:     const Definition& operator[](const char* s) const {",
          "3508:         return (*grammar_)[s];",
          "3509:     }",
          "3511:     std::vector<std::string> get_rule_names(){",
          "3512:         std::vector<std::string> rules;",
          "3513:         rules.reserve(grammar_->size());",
          "3514:         for (auto const& r : *grammar_) {",
          "3515:             rules.emplace_back(r.first);",
          "3516:         }",
          "3517:         return rules;",
          "3520:     void enable_packrat_parsing() {",
          "3521:         if (grammar_ != nullptr) {",
          "3522:             auto& rule = (*grammar_)[start_];",
          "3523:             rule.enablePackratParsing = true;",
          "3524:         }",
          "3527:     template <typename T = Ast>",
          "3528:     parser& enable_ast() {",
          "3529:         for (auto& x: *grammar_) {",
          "3530:             const auto& name = x.first;",
          "3531:             auto& rule = x.second;",
          "3533:             if (!rule.action) {",
          "3534:                 rule.action = [&](const SemanticValues& sv) {",
          "3535:                     auto line = sv.line_info();",
          "3537:                     if (rule.is_token()) {",
          "3538:                         return std::make_shared<T>(",
          "3539:                             sv.path, line.first, line.second,",
          "3540:                             name.c_str(), std::distance(sv.ss, sv.c_str()), sv.length(), sv.choice_count(), sv.choice(),",
          "3541:                             sv.token());",
          "3542:                     }",
          "3544:                     auto ast = std::make_shared<T>(",
          "3545:                         sv.path, line.first, line.second,",
          "3546:                         name.c_str(), std::distance(sv.ss, sv.c_str()), sv.length(), sv.choice_count(), sv.choice(),",
          "3547:                         sv.transform<std::shared_ptr<T>>());",
          "3549:                     for (auto node: ast->nodes) {",
          "3550:                         node->parent = ast;",
          "3551:                     }",
          "3552:                     return ast;",
          "3553:                 };",
          "3554:             }",
          "3555:         }",
          "3556:         return *this;",
          "3559:     void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {",
          "3560:         if (grammar_ != nullptr) {",
          "3561:             auto& rule = (*grammar_)[start_];",
          "3562:             rule.tracer_enter = tracer_enter;",
          "3563:             rule.tracer_leave = tracer_leave;",
          "3564:         }",
          "3567:     Log log;",
          "3570:     void output_log(const char* s, size_t n, const Definition::Result& r) const {",
          "3571:         if (log) {",
          "3572:             if (!r.ret) {",
          "3573:                 if (r.message_pos) {",
          "3574:                     auto line = line_info(s, r.message_pos);",
          "3575:                     log(line.first, line.second, r.message);",
          "3576:                 } else {",
          "3577:                     auto line = line_info(s, r.error_pos);",
          "3578:                     log(line.first, line.second, \"syntax error\");",
          "3579:                 }",
          "3580:             } else if (r.len != n) {",
          "3581:                 auto line = line_info(s, s + r.len);",
          "3582:                 log(line.first, line.second, \"syntax error\");",
          "3583:             }",
          "3587:     std::shared_ptr<Grammar> grammar_;",
          "3588:     std::string              start_;",
          "",
          "[Added Lines]",
          "3317: class parser {",
          "3319:   parser() = default;",
          "3321:   parser(const char *s, size_t n, const Rules &rules) {",
          "3322:     load_grammar(s, n, rules);",
          "3323:   }",
          "3325:   parser(const char *s, const Rules &rules) : parser(s, strlen(s), rules) {}",
          "3327:   parser(const char *s, size_t n) : parser(s, n, Rules()) {}",
          "3329:   parser(const char *s) : parser(s, strlen(s), Rules()) {}",
          "3331:   operator bool() { return grammar_ != nullptr; }",
          "3333:   bool load_grammar(const char *s, size_t n, const Rules &rules) {",
          "3334:     grammar_ = ParserGenerator::parse(s, n, rules, start_, log);",
          "3335:     return grammar_ != nullptr;",
          "3336:   }",
          "3338:   bool load_grammar(const char *s, size_t n) {",
          "3339:     return load_grammar(s, n, Rules());",
          "3340:   }",
          "3342:   bool load_grammar(const char *s, const Rules &rules) {",
          "3343:     auto n = strlen(s);",
          "3344:     return load_grammar(s, n, rules);",
          "3345:   }",
          "3347:   bool load_grammar(const char *s) {",
          "3348:     auto n = strlen(s);",
          "3349:     return load_grammar(s, n);",
          "3350:   }",
          "3352:   bool parse_n(const char *s, size_t n, const char *path = nullptr) const {",
          "3353:     if (grammar_ != nullptr) {",
          "3354:       const auto &rule = (*grammar_)[start_];",
          "3355:       auto r = rule.parse(s, n, path);",
          "3356:       output_log(s, n, r);",
          "3357:       return r.ret && r.len == n;",
          "3359:     return false;",
          "3360:   }",
          "3362:   bool parse(const char *s, const char *path = nullptr) const {",
          "3363:     auto n = strlen(s);",
          "3364:     return parse_n(s, n, path);",
          "3365:   }",
          "3367:   bool parse_n(const char *s, size_t n, any &dt,",
          "3368:                const char *path = nullptr) const {",
          "3369:     if (grammar_ != nullptr) {",
          "3370:       const auto &rule = (*grammar_)[start_];",
          "3371:       auto r = rule.parse(s, n, dt, path);",
          "3372:       output_log(s, n, r);",
          "3373:       return r.ret && r.len == n;",
          "3375:     return false;",
          "3376:   }",
          "3378:   bool parse(const char *s, any &dt, const char *path = nullptr) const {",
          "3379:     auto n = strlen(s);",
          "3380:     return parse_n(s, n, dt, path);",
          "3381:   }",
          "3383:   template <typename T>",
          "3384:   bool parse_n(const char *s, size_t n, T &val,",
          "3385:                const char *path = nullptr) const {",
          "3386:     if (grammar_ != nullptr) {",
          "3387:       const auto &rule = (*grammar_)[start_];",
          "3388:       auto r = rule.parse_and_get_value(s, n, val, path);",
          "3389:       output_log(s, n, r);",
          "3390:       return r.ret && r.len == n;",
          "3392:     return false;",
          "3393:   }",
          "3395:   template <typename T>",
          "3396:   bool parse(const char *s, T &val, const char *path = nullptr) const {",
          "3397:     auto n = strlen(s);",
          "3398:     return parse_n(s, n, val, path);",
          "3399:   }",
          "3401:   template <typename T>",
          "3402:   bool parse_n(const char *s, size_t n, any &dt, T &val,",
          "3403:                const char *path = nullptr) const {",
          "3404:     if (grammar_ != nullptr) {",
          "3405:       const auto &rule = (*grammar_)[start_];",
          "3406:       auto r = rule.parse_and_get_value(s, n, dt, val, path);",
          "3407:       output_log(s, n, r);",
          "3408:       return r.ret && r.len == n;",
          "3410:     return false;",
          "3411:   }",
          "3413:   template <typename T>",
          "3414:   bool parse(const char *s, any &dt, T &val,",
          "3415:              const char * /*path*/ = nullptr) const {",
          "3416:     auto n = strlen(s);",
          "3417:     return parse_n(s, n, dt, val);",
          "3418:   }",
          "3420:   Definition &operator[](const char *s) { return (*grammar_)[s]; }",
          "3422:   const Definition &operator[](const char *s) const { return (*grammar_)[s]; }",
          "3424:   std::vector<std::string> get_rule_names() {",
          "3425:     std::vector<std::string> rules;",
          "3426:     rules.reserve(grammar_->size());",
          "3427:     for (auto const &r : *grammar_) {",
          "3428:       rules.emplace_back(r.first);",
          "3430:     return rules;",
          "3431:   }",
          "3433:   void enable_packrat_parsing() {",
          "3434:     if (grammar_ != nullptr) {",
          "3435:       auto &rule = (*grammar_)[start_];",
          "3436:       rule.enablePackratParsing = true;",
          "3438:   }",
          "3440:   template <typename T = Ast> parser &enable_ast() {",
          "3441:     for (auto &x : *grammar_) {",
          "3442:       const auto &name = x.first;",
          "3443:       auto &rule = x.second;",
          "3445:       if (!rule.action) {",
          "3446:         rule.action = [&](const SemanticValues &sv) {",
          "3447:           auto line = sv.line_info();",
          "3449:           if (rule.is_token()) {",
          "3450:             return std::make_shared<T>(",
          "3451:                 sv.path, line.first, line.second, name.c_str(),",
          "3452:                 std::distance(sv.ss, sv.c_str()), sv.length(),",
          "3453:                 sv.choice_count(), sv.choice(), sv.token());",
          "3454:           }",
          "3456:           auto ast = std::make_shared<T>(",
          "3457:               sv.path, line.first, line.second, name.c_str(),",
          "3458:               std::distance(sv.ss, sv.c_str()), sv.length(), sv.choice_count(),",
          "3459:               sv.choice(), sv.transform<std::shared_ptr<T>>());",
          "3461:           for (auto node : ast->nodes) {",
          "3462:             node->parent = ast;",
          "3463:           }",
          "3464:           return ast;",
          "3465:         };",
          "3466:       }",
          "3468:     return *this;",
          "3469:   }",
          "3471:   void enable_trace(TracerEnter tracer_enter, TracerLeave tracer_leave) {",
          "3472:     if (grammar_ != nullptr) {",
          "3473:       auto &rule = (*grammar_)[start_];",
          "3474:       rule.tracer_enter = tracer_enter;",
          "3475:       rule.tracer_leave = tracer_leave;",
          "3477:   }",
          "3479:   Log log;",
          "3482:   void output_log(const char *s, size_t n, const Definition::Result &r) const {",
          "3483:     if (log) {",
          "3484:       if (!r.ret) {",
          "3485:         if (r.message_pos) {",
          "3486:           auto line = line_info(s, r.message_pos);",
          "3487:           log(line.first, line.second, r.message);",
          "3488:         } else {",
          "3489:           auto line = line_info(s, r.error_pos);",
          "3490:           log(line.first, line.second, \"syntax error\");",
          "3492:       } else if (r.len != n) {",
          "3493:         auto line = line_info(s, s + r.len);",
          "3494:         log(line.first, line.second, \"syntax error\");",
          "3495:       }",
          "3497:   }",
          "3499:   std::shared_ptr<Grammar> grammar_;",
          "3500:   std::string start_;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-1010065",
  "cve_desc": "The Sleuth Kit 4.6.0 and earlier is affected by: Integer Overflow. The impact is: Opening crafted disk image triggers crash in tsk/fs/hfs_dent.c:237. The component is: Overflow in fls tool used on HFS image. Bug is in tsk/fs/hfs.c file in function hfs_cat_traverse() in lines: 952, 1062. The attack vector is: Victim must open a crafted HFS filesystem image.",
  "repo": "sleuthkit/sleuthkit",
  "patch_hash": "114cd3d0aac8bd1aeaf4b33840feb0163d342d5b",
  "patch_info": {
    "commit_hash": "114cd3d0aac8bd1aeaf4b33840feb0163d342d5b",
    "repo": "sleuthkit/sleuthkit",
    "commit_url": "https://github.com/sleuthkit/sleuthkit/commit/114cd3d0aac8bd1aeaf4b33840feb0163d342d5b",
    "files": [
      "tsk/fs/hfs.c"
    ],
    "message": "hfs: fix keylen check in hfs_cat_traverse()\n\nIf key->key_len is 65535, calculating \"uint16_t keylen' would\ncause an overflow:\n\n   uint16_t keylen;\n   ...\n   keylen = 2 + tsk_getu16(hfs->fs_info.endian, key->key_len)\n\nso the code bypasses the sanity check \"if (keylen > nodesize)\"\nwhich results in crash later:\n\n    ./toolfs/fstools/fls -b 512 -f hfs <image>\n    =================================================================\n    ==16==ERROR: AddressSanitizer: SEGV on unknown address 0x6210000256a4 (pc 0x00000054812b bp 0x7ffca548a8f0 sp 0x7ffca548a480 T0)\n    ==16==The signal is caused by a READ memory access.\n        #0 0x54812a in hfs_dir_open_meta_cb /fuzzing/sleuthkit/tsk/fs/hfs_dent.c:237:20\n        #1 0x51a96c in hfs_cat_traverse /fuzzing/sleuthkit/tsk/fs/hfs.c:1082:21\n        #2 0x547785 in hfs_dir_open_meta /fuzzing/sleuthkit/tsk/fs/hfs_dent.c:480:9\n        #3 0x50f57d in tsk_fs_dir_open_meta /fuzzing/sleuthkit/tsk/fs/fs_dir.c:290:14\n        #4 0x54af17 in tsk_fs_path2inum /fuzzing/sleuthkit/tsk/fs/ifind_lib.c:237:23\n        #5 0x522266 in hfs_open /fuzzing/sleuthkit/tsk/fs/hfs.c:6579:9\n        #6 0x508e89 in main /fuzzing/sleuthkit/tools/fstools/fls.cpp:267:19\n        #7 0x7f9daf67c2b0 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x202b0)\n        #8 0x41d679 in _start (/fuzzing/sleuthkit/tools/fstools/fls+0x41d679)\n\nMake 'keylen' int type to prevent the overflow and fix that.\nNow, I get proper error message instead of crash:\n    ./toolfs/fstools/fls -b 512 -f hfs <image>\n    General file system error (hfs_cat_traverse: length of key 3 in leaf node 1 too large (65537 vs 4096))",
    "before_after_code_files": [
      "tsk/fs/hfs.c||tsk/fs/hfs.c"
    ]
  },
  "patch_diff": {
    "tsk/fs/hfs.c||tsk/fs/hfs.c": [
      "File: tsk/fs/hfs.c -> tsk/fs/hfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "937:                 size_t rec_off;",
      "938:                 hfs_btree_key_cat *key;",
      "939:                 uint8_t retval;",
      "943:                 rec_off =",
      "",
      "[Removed Lines]",
      "940:                 uint16_t keylen;",
      "",
      "[Added Lines]",
      "940:                 int keylen;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1042:                 size_t rec_off;",
      "1043:                 hfs_btree_key_cat *key;",
      "1044:                 uint8_t retval;",
      "1048:                 rec_off =",
      "",
      "[Removed Lines]",
      "1045:                 uint16_t keylen;",
      "",
      "[Added Lines]",
      "1045:                 int keylen;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3cf17f6da6cc53e86a8e6245c95b79907835b177",
      "candidate_info": {
        "commit_hash": "3cf17f6da6cc53e86a8e6245c95b79907835b177",
        "repo": "sleuthkit/sleuthkit",
        "commit_url": "https://github.com/sleuthkit/sleuthkit/commit/3cf17f6da6cc53e86a8e6245c95b79907835b177",
        "files": [
          "tsk/fs/apfs.cpp",
          "tsk/fs/apfs_fs.cpp",
          "tsk/fs/apfs_fs.h"
        ],
        "message": "Use MSVC style structure packing (issue #1)",
        "before_after_code_files": [
          "tsk/fs/apfs.cpp||tsk/fs/apfs.cpp",
          "tsk/fs/apfs_fs.cpp||tsk/fs/apfs_fs.cpp",
          "tsk/fs/apfs_fs.h||tsk/fs/apfs_fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tsk/fs/apfs.cpp||tsk/fs/apfs.cpp": [
          "File: tsk/fs/apfs.cpp -> tsk/fs/apfs.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "570:     uint64_t type : 4;",
          "571:   };",
          "591:   std::for_each(snap_tree.begin(), snap_tree.end(), [&](const auto& entry) {",
          "592:     const auto key = entry.key.template as<key_type>();",
          "",
          "[Removed Lines]",
          "573:   using value_type = struct __attribute__((packed)) {",
          "574:     uint64_t extentref_tree_oid;   // 0x00",
          "575:     uint64_t sblock_oid;           // 0x08",
          "576:     uint64_t create_time;          // 0x10",
          "577:     uint64_t changed_time;         // 0x18",
          "578:     uint64_t private_id;           // 0x20",
          "579:     uint32_t extentref_tree_type;  // 0x28",
          "580:     union {                        // 0x2C",
          "581:       uint32_t flags;",
          "582:       struct {",
          "583:         uint32_t pending_dataless : 1;",
          "584:         uint32_t : 31;",
          "585:       };",
          "586:     };",
          "587:     uint16_t name_length;  // 0x30",
          "588:     char name[0];          // 0x32 (name_length bytes)",
          "589:   };",
          "",
          "[Added Lines]",
          "573:   using value_type = apfs_snap_metadata;",
          "",
          "---------------"
        ],
        "tsk/fs/apfs_fs.cpp||tsk/fs/apfs_fs.cpp": [
          "File: tsk/fs/apfs_fs.cpp -> tsk/fs/apfs_fs.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "132:       const auto value = e.value.template as<apfs_xattr>();",
          "134:       if (value->flags & APFS_XATTR_FLAG_INLINE) {",
          "136:           char data[0];",
          "137:         };",
          "139:         const auto ix = e.value.template as<ixattr>();",
          "140:         _inline_xattrs.emplace_back(inline_xattr{{k->name, k->name_len - 1U},",
          "",
          "[Removed Lines]",
          "135:         struct __attribute__((packed)) ixattr : apfs_xattr {",
          "",
          "[Added Lines]",
          "135: #pragma pack(push, 1)",
          "136:         struct ixattr : apfs_xattr {",
          "139: #pragma pack(pop)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "142:         break;",
          "143:       }",
          "148:         uint64_t xattr_obj_id;",
          "149:         apfs_dstream dstream;",
          "150:       };",
          "151:       static_assert(sizeof(nrattr) == 0x34, \"misaligned structure\");",
          "153:       const auto nrx = e.value.template as<nrattr>();",
          "",
          "[Removed Lines]",
          "147:       struct __attribute__((packed)) nrattr : apfs_xattr {",
          "",
          "[Added Lines]",
          "148: #pragma pack(push, 1)",
          "149:       struct nrattr : apfs_xattr {",
          "153: #pragma pack(pop)",
          "",
          "---------------"
        ],
        "tsk/fs/apfs_fs.h||tsk/fs/apfs_fs.h": [
          "File: tsk/fs/apfs_fs.h -> tsk/fs/apfs_fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #define static_assert(x, y)  // static assertions are not valid in C",
          "11: #endif",
          "13: typedef struct TSK_FS_INFO TSK_FS_INFO;",
          "14: typedef struct TSK_FS_FILE TSK_FS_FILE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: #pragma pack(push, 1)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "70: #define APFS_XATTR_NAME_SECURITY \"com.apple.system.Security\"",
          "71: #define APFS_XATTR_NAME_SYMLINK \"com.apple.fs.symlink\"",
          "74:   uint64_t extentref_tree_oid;   // 0x00",
          "75:   uint64_t sblock_oid;           // 0x08",
          "76:   uint64_t create_time;          // 0x10",
          "",
          "[Removed Lines]",
          "73: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "77: typedef struct {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89: } apfs_snap_metadata;",
          "90: static_assert(sizeof(apfs_snap_metadata) == 0x32, \"improperly aligned struct\");",
          "93:   uint64_t len : 60;       // 0x00 (bottom 60 bits)",
          "94:   uint64_t kind : 4;       // (top 4 bits)",
          "95:   uint64_t owning_obj_id;  // 0x08",
          "",
          "[Removed Lines]",
          "92: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "96: typedef struct {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "97: } apfs_phys_extent;",
          "98: static_assert(sizeof(apfs_phys_extent) == 0x14, \"improperly aligned struct\");",
          "101:   uint64_t parent_id;      // 0x00",
          "102:   uint64_t private_id;     // 0x08",
          "103:   uint64_t create_time;    // 0x10",
          "",
          "[Removed Lines]",
          "100: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "104: typedef struct {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "144: } apfs_inode;",
          "145: static_assert(sizeof(apfs_inode) == 0x5C, \"improperly aligned struct\");",
          "148:   union {  // 0x00",
          "149:     uint16_t flags;",
          "150:     struct {",
          "",
          "[Removed Lines]",
          "147: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "151: typedef struct {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "158: } apfs_xattr;",
          "159: static_assert(sizeof(apfs_xattr) == 0x04, \"improperly aligned struct\");",
          "162:   uint64_t parent;       // 0x00",
          "163:   uint16_t name_length;  // 0x08",
          "164:   char name[0];          // 0x0C (name_length bytes)",
          "165: } apfs_sibling_link;",
          "166: static_assert(sizeof(apfs_sibling_link) == 0x0A, \"improperly aligned struct\");",
          "169:   uint32_t refcnt;  // 0x00",
          "170: } apfs_dstream_id;",
          "171: static_assert(sizeof(apfs_dstream_id) == 0x04, \"improperly aligned struct\");",
          "174:   uint32_t refcount;  // 0x00",
          "175:   struct {",
          "176:     uint16_t major_version;     // 0x04",
          "",
          "[Removed Lines]",
          "161: typedef struct __attribute__((packed)) {",
          "168: typedef struct __attribute__((packed)) {",
          "173: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "165: typedef struct {",
          "172: typedef struct {",
          "177: typedef struct {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "185: } apfs_crypto_state;",
          "186: static_assert(sizeof(apfs_crypto_state) == 0x18, \"improperly aligned struct\");",
          "189:   uint64_t len : 56;   // 0x00 (bottom 56 bits)",
          "190:   uint64_t flags : 8;  // (top 8 bits)",
          "191:   uint64_t phys;       // 0x08",
          "",
          "[Removed Lines]",
          "188: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "192: typedef struct {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "193: } apfs_file_extent;",
          "194: static_assert(sizeof(apfs_file_extent) == 0x18, \"improperly aligned struct\");",
          "197:   uint64_t file_id;     // 0x00",
          "198:   uint64_t date_added;  // 0x08",
          "199:   uint16_t type : 4;    // 0x10",
          "",
          "[Removed Lines]",
          "196: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "200: typedef struct {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "201: } apfs_dir_record;",
          "202: static_assert(sizeof(apfs_dir_record) == 0x12, \"improperly aligned struct\");",
          "205:   uint64_t num_children;  // 0x00",
          "206:   uint64_t total_size;    // 0x08",
          "207:   uint64_t chained_key;   // 0x10",
          "",
          "[Removed Lines]",
          "204: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "208: typedef struct {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "209: } apfs_dir_stats;",
          "210: static_assert(sizeof(apfs_dir_stats) == 0x20, \"improperly aligned struct\");",
          "213:   uint64_t snap_xid;  // 0x00",
          "214: } apfs_snap_name;",
          "215: static_assert(sizeof(apfs_snap_name) == 0x08, \"improperly aligned struct\");",
          "218:   uint64_t orig_file_id;  // 0x00",
          "219: } apfs_sibling_map;",
          "220: static_assert(sizeof(apfs_sibling_map) == 0x08, \"improperly aligned struct\");",
          "",
          "[Removed Lines]",
          "212: typedef struct __attribute__((packed)) {",
          "217: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "216: typedef struct {",
          "221: typedef struct {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "234:   APFS_XFIELD_TYPE_DEVICE = 0x0E,",
          "235: } APFS_XFIELD_TYPE;",
          "238:   uint8_t type;  // 0x00",
          "239:   union {        // 0x01",
          "240:     uint8_t flags;",
          "",
          "[Removed Lines]",
          "237: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "241: typedef struct {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "252: } apfs_xfield_entry;",
          "253: static_assert(sizeof(apfs_xfield_entry) == 0x04, \"improperly aligned struct\");",
          "256:   uint16_t num_exts;",
          "257:   uint16_t used_data;",
          "258:   apfs_xfield_entry entries[0];",
          "259: } apfs_xfield;",
          "260: static_assert(sizeof(apfs_xfield) == 0x04, \"improperly aligned struct\");",
          "263:   uint64_t size;",
          "264:   uint64_t alloced_size;",
          "265:   uint64_t default_crypto_id;",
          "",
          "[Removed Lines]",
          "255: typedef struct __attribute__((packed)) {",
          "262: typedef struct __attribute__((packed)) {",
          "",
          "[Added Lines]",
          "259: typedef struct {",
          "266: typedef struct {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "268: } apfs_dstream;",
          "269: static_assert(sizeof(apfs_dstream) == 0x28, \"improperly aligned struct\");",
          "273: typedef struct {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "276: #pragma pack(pop)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bdc3e8f2111612c6aa2c2c04a19f3df844626b9a",
      "candidate_info": {
        "commit_hash": "bdc3e8f2111612c6aa2c2c04a19f3df844626b9a",
        "repo": "sleuthkit/sleuthkit",
        "commit_url": "https://github.com/sleuthkit/sleuthkit/commit/bdc3e8f2111612c6aa2c2c04a19f3df844626b9a",
        "files": [
          "configure.ac"
        ],
        "message": "No longer a need for no-ms-bitfields flag for mingw (issue #1)",
        "before_after_code_files": [
          "configure.ac||configure.ac"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "94: case \"$host\" in",
          "97:   dnl Adding the native /usr/local is wrong for cross-compiling",
          "98:   ;;",
          "",
          "[Removed Lines]",
          "96:   CPPFLAGS=\"$CPPFLAGS -mno-ms-bitfields\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8c1048d9e6e19d5e9e46eedb815009cd19c99095",
      "candidate_info": {
        "commit_hash": "8c1048d9e6e19d5e9e46eedb815009cd19c99095",
        "repo": "sleuthkit/sleuthkit",
        "commit_url": "https://github.com/sleuthkit/sleuthkit/commit/8c1048d9e6e19d5e9e46eedb815009cd19c99095",
        "files": [
          "tsk/pool/apfs_compat.cpp"
        ],
        "message": "Fixed crash for zero volume containers.  (Fixes: #3)",
        "before_after_code_files": [
          "tsk/pool/apfs_compat.cpp||tsk/pool/apfs_compat.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tsk/pool/apfs_compat.cpp||tsk/pool/apfs_compat.cpp": [
          "File: tsk/pool/apfs_compat.cpp -> tsk/pool/apfs_compat.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: }",
          "23: void APFSPoolCompat::init_volumes() {",
          "25:     _info.vol_list = new TSK_POOL_VOLUME_INFO[_info.num_vols]();",
          "27:     int i = 0;",
          "",
          "[Removed Lines]",
          "24:   if (_info.num_blocks != 0) {",
          "",
          "[Added Lines]",
          "24:   if (_info.num_vols != 0) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "075b09af870ba3437c4f775c45f2416a6601d3e5",
      "candidate_info": {
        "commit_hash": "075b09af870ba3437c4f775c45f2416a6601d3e5",
        "repo": "sleuthkit/sleuthkit",
        "commit_url": "https://github.com/sleuthkit/sleuthkit/commit/075b09af870ba3437c4f775c45f2416a6601d3e5",
        "files": [
          "tsk/fs/apfs.cpp",
          "tsk/fs/apfs_compat.cpp",
          "tsk/fs/apfs_fs.cpp",
          "tsk/fs/apfs_fs.h",
          "tsk/fs/apfs_fs.hpp",
          "tsk/fs/tsk_apfs.h",
          "tsk/fs/tsk_apfs.hpp",
          "tsk/pool/apfs_pool.cpp"
        ],
        "message": "Bitfields aren't portable across compilers, so switch to bitmasks and shifts (issue #1)",
        "before_after_code_files": [
          "tsk/fs/apfs.cpp||tsk/fs/apfs.cpp",
          "tsk/fs/apfs_compat.cpp||tsk/fs/apfs_compat.cpp",
          "tsk/fs/apfs_fs.cpp||tsk/fs/apfs_fs.cpp",
          "tsk/fs/apfs_fs.h||tsk/fs/apfs_fs.h",
          "tsk/fs/apfs_fs.hpp||tsk/fs/apfs_fs.hpp",
          "tsk/fs/tsk_apfs.h||tsk/fs/tsk_apfs.h",
          "tsk/fs/tsk_apfs.hpp||tsk/fs/tsk_apfs.hpp",
          "tsk/pool/apfs_pool.cpp||tsk/pool/apfs_pool.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tsk/fs/apfs.cpp||tsk/fs/apfs.cpp": [
          "File: tsk/fs/apfs.cpp -> tsk/fs/apfs.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "190:     throw std::runtime_error(\"APFSSuperblock: invalid magic\");",
          "191:   }",
          "194:     throw std::runtime_error(",
          "196:   }",
          "198:   if (block_size() != APFS_BLOCK_SIZE) {",
          "",
          "[Removed Lines]",
          "193:   if (sb()->supports_fusion) {",
          "195:         \"multi-tier superblocks are not currently supported\");",
          "",
          "[Added Lines]",
          "193:   if (bit_is_set(sb()->incompatible_features, APFS_NXSB_INCOMPAT_VERSION1)) {",
          "195:         \"APFSSuperblock: Pre-release versions of APFS are not supported\");",
          "196:   }",
          "198:   if (bit_is_set(sb()->incompatible_features, APFS_NXSB_INCOMPAT_FUSION)) {",
          "199:     if (tsk_verbose) {",
          "200:       tsk_fprintf(stderr,",
          "201:                   \"WARNING: APFS fusion drives may not be fully supported\\n\");",
          "202:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "463:     if (tsk_verbose) {",
          "464:       tsk_fprintf(stderr,",
          "465:                   \"apfs: UNK16 is set in VEK.  Decryption will likely fail.\\n\");",
          "",
          "[Removed Lines]",
          "462:   if (_crypto.unk16) {",
          "",
          "[Added Lines]",
          "469:   if (_crypto.unk16()) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "470:   for (const auto& wk : _crypto.wrapped_keks) {",
          "478:       if (tsk_verbose) {",
          "479:         tsk_fprintf(",
          "480:             stderr,",
          "",
          "[Removed Lines]",
          "473:     const auto kek_len = (wk.cs) ? 0x10 : 0x20;",
          "477:     if (wk.hw_crypt) {",
          "",
          "[Added Lines]",
          "480:     const auto kek_len = (wk.cs()) ? 0x10 : 0x20;",
          "484:     if (wk.hw_crypt()) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "508:     const auto vek_len = (_crypto.cs) ? 0x10 : 0x20;",
          "",
          "[Added Lines]",
          "515:     const auto vek_len = (_crypto.cs()) ? 0x10 : 0x20;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "521:     _crypto.password = password;",
          "522:     std::memcpy(_crypto.vek, vek.get(), vek_len);",
          "527:       std::memcpy(_crypto.vek + 0x10, _crypto.vek_uuid,",
          "",
          "[Removed Lines]",
          "524:     if (_crypto.cs) {",
          "",
          "[Added Lines]",
          "531:     if (_crypto.cs()) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "566:                                         nullptr};",
          "568:   using key_type = struct {",
          "571:   };",
          "573:   using value_type = apfs_snap_metadata;",
          "",
          "[Removed Lines]",
          "569:     uint64_t snap_xid : 60;",
          "570:     uint64_t type : 4;",
          "",
          "[Added Lines]",
          "576:     uint64_t xid_and_type;",
          "578:     constexpr uint64_t snap_xid() const noexcept {",
          "579:       return bitfield_value(xid_and_type, 60, 0);",
          "580:     }",
          "582:     constexpr uint64_t type() const noexcept {",
          "583:       return bitfield_value(xid_and_type, 4, 60);",
          "584:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "576:     const auto key = entry.key.template as<key_type>();",
          "577:     const auto value = entry.value.template as<value_type>();",
          "580:       return;",
          "581:     }",
          "583:     v.emplace_back(snapshot_t{",
          "584:         .name = {value->name, value->name_length - 1U},",
          "585:         .timestamp = value->create_time,",
          "587:         .dataless = (value->extentref_tree_oid == 0),",
          "588:     });",
          "589:   });",
          "",
          "[Removed Lines]",
          "579:     if (key->type != APFS_JOBJTYPE_SNAP_METADATA) {",
          "586:         .snap_xid = key->snap_xid,",
          "",
          "[Added Lines]",
          "593:     if (key->type() != APFS_JOBJTYPE_SNAP_METADATA) {",
          "600:         .snap_xid = key->snap_xid(),",
          "",
          "---------------"
        ],
        "tsk/fs/apfs_compat.cpp||tsk/fs/apfs_compat.cpp": [
          "File: tsk/fs/apfs_compat.cpp -> tsk/fs/apfs_compat.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "497:       return TSK_ERR;",
          "498:     }",
          "500:     strncpy(fs_name->name, child.name.c_str(), fs_name->name_size);",
          "501:     fs_name->meta_addr = child.rec.file_id;",
          "503:     fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;",
          "504:     fs_name->date_added = child.rec.date_added;",
          "",
          "[Removed Lines]",
          "502:     fs_name->type = to_name_type(APFS_ITEM_TYPE(child.rec.type));",
          "",
          "[Added Lines]",
          "500:     const auto type =",
          "501:         bitfield_value(child.rec.type_and_flags, APFS_DIR_RECORD_TYPE_BITS,",
          "502:                        APFS_DIR_RECORD_TYPE_SHIFT);",
          "506:     fs_name->type = to_name_type(APFS_ITEM_TYPE(type));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "558:   const auto inode_meta = inode_ptr->inode();",
          "560:   fs_file->meta->flags = TSK_FS_META_FLAG_ALLOC;",
          "561:   fs_file->meta->addr = addr;",
          "564:   fs_file->meta->nlink = inode_meta.nlink;",
          "565:   fs_file->meta->size = inode_ptr->size();",
          "566:   fs_file->meta->uid = inode_meta.owner;",
          "",
          "[Removed Lines]",
          "562:   fs_file->meta->type = to_meta_type(APFS_ITEM_TYPE(inode_meta.type));",
          "563:   fs_file->meta->mode = TSK_FS_META_MODE_ENUM(inode_meta.mode);",
          "",
          "[Added Lines]",
          "564:   const auto mode = bitfield_value(inode_meta.mode_and_type,",
          "565:                                    APFS_INODE_MODE_BITS, APFS_INODE_MODE_SHIFT);",
          "566:   const auto type = bitfield_value(inode_meta.mode_and_type,",
          "567:                                    APFS_INODE_TYPE_BITS, APFS_INODE_TYPE_SHIFT);",
          "571:   fs_file->meta->type = to_meta_type(APFS_ITEM_TYPE(type));",
          "572:   fs_file->meta->mode = TSK_FS_META_MODE_ENUM(mode);",
          "",
          "---------------"
        ],
        "tsk/fs/apfs_fs.cpp||tsk/fs/apfs_fs.cpp": [
          "File: tsk/fs/apfs_fs.cpp -> tsk/fs/apfs_fs.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: void APFSJObject::add_entry(const jit::value_type& e) {",
          "49:   const auto key = e.key.template as<key_type>();",
          "53:     case APFS_JOBJTYPE_INODE: {",
          "54:       const auto value = e.value.template as<apfs_inode>();",
          "55:       _inode = *value;",
          "61:       if ((size_t)e.value.count() > sizeof(apfs_inode)) {",
          "",
          "[Removed Lines]",
          "51:   switch (key->type) {",
          "58:       _is_clone = (_inode.private_id != key->oid);",
          "",
          "[Added Lines]",
          "51:   switch (key->type()) {",
          "58:       _is_clone = (_inode.private_id != key->oid());",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115:       const auto k = e.key.template as<file_extent_key>();",
          "116:       const auto value = e.value.template as<apfs_file_extent>();",
          "121:       break;",
          "122:     }",
          "",
          "[Removed Lines]",
          "118:       _extents.emplace_back(",
          "119:           extent{k->offset, value->phys, value->len, value->crypto});",
          "",
          "[Added Lines]",
          "117:       const auto len =",
          "118:           bitfield_value(value->len_and_flags, APFS_FILE_EXTENT_LEN_BITS,",
          "119:                          APFS_FILE_EXTENT_LEN_SHIFT);",
          "121:       _extents.emplace_back(extent{k->offset, value->phys, len, value->crypto});",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "194:   auto end = std::find_if(",
          "195:       _next,",
          "197:         const auto key = it.key.template as<APFSJObject::key_type>();",
          "199:       });",
          "201:   _jobj = {_next, end};",
          "",
          "[Removed Lines]",
          "196:       _tree->_jobj_root.end(), [oid = key->oid](const auto& it) noexcept {",
          "198:         return key->oid > oid;",
          "",
          "[Added Lines]",
          "198:       _tree->_jobj_root.end(), [oid = key->oid()](const auto& it) noexcept {",
          "200:         return key->oid() > oid;",
          "",
          "---------------"
        ],
        "tsk/fs/apfs_fs.h||tsk/fs/apfs_fs.h": [
          "File: tsk/fs/apfs_fs.h -> tsk/fs/apfs_fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "74: #define APFS_XATTR_NAME_SECURITY \"com.apple.system.Security\"",
          "75: #define APFS_XATTR_NAME_SYMLINK \"com.apple.fs.symlink\"",
          "77: typedef struct {",
          "78:   uint64_t extentref_tree_oid;   // 0x00",
          "79:   uint64_t sblock_oid;           // 0x08",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78: #define APFS_SNAP_METADATA_PENDING_DATALESS 0x00000001",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81:   uint64_t changed_time;         // 0x18",
          "82:   uint64_t private_id;           // 0x20",
          "83:   uint32_t extentref_tree_type;  // 0x28",
          "93: } apfs_snap_metadata;",
          "94: static_assert(sizeof(apfs_snap_metadata) == 0x32, \"improperly aligned struct\");",
          "96: typedef struct {",
          "99:   uint64_t owning_obj_id;  // 0x08",
          "100:   uint32_t refcnt;         // 0x10",
          "101: } apfs_phys_extent;",
          "102: static_assert(sizeof(apfs_phys_extent) == 0x14, \"improperly aligned struct\");",
          "104: typedef struct {",
          "105:   uint64_t parent_id;      // 0x00",
          "106:   uint64_t private_id;     // 0x08",
          "",
          "[Removed Lines]",
          "84:   union {                        // 0x2C",
          "85:     uint32_t flags;",
          "86:     struct {",
          "87:       uint32_t pending_dataless : 1;",
          "88:       uint32_t : 31;",
          "89:     };",
          "90:   };",
          "91:   uint16_t name_length;  // 0x30",
          "92:   char name[0];          // 0x32 (name_length bytes)",
          "97:   uint64_t len : 60;       // 0x00 (bottom 60 bits)",
          "98:   uint64_t kind : 4;       // (top 4 bits)",
          "",
          "[Added Lines]",
          "87:   uint32_t flags;                // 0x2C",
          "88:   uint16_t name_length;          // 0x30",
          "89:   char name[0];                  // 0x32 (name_length bytes)",
          "94: #define APFS_PHYS_EXTENT_LEN_BITS 60",
          "95: #define APFS_PHYS_EXTENT_LEN_SHIFT 0",
          "96: #define APFS_PHYS_EXTENT_KIND_BITS 4",
          "97: #define APFS_PHYS_EXTENT_KIND_SHIFT 60",
          "100:   uint64_t len_and_kind;   // 0x00",
          "107: #define APFS_INODE_IS_APFS_PRIVATE = 0x00000001",
          "108: #define APFS_INODE_MAINTAIN_DIR_STATS = 0x00000002",
          "109: #define APFS_INODE_DIR_STATS_ORIGIN = 0x00000004",
          "110: #define APFS_INODE_PROT_CLASS_EXPLICIT = 0x00000008",
          "111: #define APFS_INODE_WAS_CLONED = 0x00000010",
          "112: #define APFS_INODE_FLAG_UNUSED = 0x00000020",
          "113: #define APFS_INODE_HAS_SECURITY_EA = 0x00000040",
          "114: #define APFS_INODE_BEING_TRUNCATED = 0x00000080",
          "115: #define APFS_INODE_HAS_FINDER_INFO = 0x00000100",
          "116: #define APFS_INODE_IS_SPARSE = 0x00000200",
          "117: #define APFS_INODE_WAS_EVER_CLONED = 0x00000400",
          "118: #define APFS_INODE_ACTIVE_FILE_TRIMMED = 0x00000800",
          "119: #define APFS_INODE_PINNED_TO_MAIN = 0x00001000",
          "120: #define APFS_INODE_PINNED_TO_TIER2 = 0x00002000",
          "121: #define APFS_INODE_HAS_RSRC_FORK = 0x00004000",
          "122: #define APFS_INODE_NO_RSRC_FORK = 0x00008000",
          "123: #define APFS_INODE_ALLOCATION_SPILLEDOVER = 0x00010000",
          "126: #define APFS_INODE_MODE_BITS 12",
          "127: #define APFS_INODE_MODE_SHIFT 0",
          "128: #define APFS_INODE_TYPE_BITS 4",
          "129: #define APFS_INODE_TYPE_SHIFT 12",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "108:   uint64_t modified_time;  // 0x18",
          "109:   uint64_t changed_time;   // 0x20",
          "110:   uint64_t accessed_time;  // 0x28",
          "135:     int32_t nlink;",
          "136:     int32_t nchildren;",
          "137:   };",
          "",
          "[Removed Lines]",
          "111:   union {                  // 0x30",
          "112:     uint64_t flags;",
          "113:     struct {",
          "114:       uint64_t is_apfs_private : 1;",
          "115:       uint64_t maintain_dir_stats : 1;",
          "116:       uint64_t dir_stats_origin : 1;",
          "117:       uint64_t prot_class_explicit : 1;",
          "118:       uint64_t was_cloned : 1;",
          "119:       uint64_t : 1;",
          "120:       uint64_t has_security_ea : 1;",
          "121:       uint64_t being_truncated : 1;",
          "122:       uint64_t has_finder_info : 1;",
          "123:       uint64_t is_sparse : 1;",
          "124:       uint64_t was_ever_cloned : 1;",
          "125:       uint64_t active_file_trimmed : 1;",
          "126:       uint64_t pinned_to_main : 1;",
          "127:       uint64_t pinned_to_tier2 : 1;",
          "128:       uint64_t has_rsrc_fork : 1;",
          "129:       uint64_t no_rsrc_fork : 1;",
          "130:       uint64_t allocation_spilled_over : 1;",
          "131:       uint64_t : 47;",
          "132:     };",
          "133:   };",
          "134:   union {  // 0x38",
          "",
          "[Added Lines]",
          "138:   uint64_t flags;          // 0x30",
          "139:   union {                  // 0x38",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "140:   uint32_t bsdflags;                  // 0x44",
          "141:   uint32_t owner;                     // 0x48",
          "142:   uint32_t group;                     // 0x4C",
          "148: } apfs_inode;",
          "149: static_assert(sizeof(apfs_inode) == 0x5C, \"improperly aligned struct\");",
          "151: typedef struct {",
          "160:   uint16_t xdata_len;  // 0x02",
          "161:   uint8_t xdata[0];    // 0x04",
          "162: } apfs_xattr;",
          "",
          "[Removed Lines]",
          "143:   uint32_t mode : 12;                 // 0x50",
          "144:   uint32_t type : 4;",
          "145:   uint32_t : 16;  // Padding",
          "146:   uint64_t : 64;  // 0x54",
          "147:   uint8_t xfields[0];",
          "152:   union {  // 0x00",
          "153:     uint16_t flags;",
          "154:     struct {",
          "155:       uint16_t data_stream : 1;",
          "156:       uint16_t embedded : 1;",
          "157:       uint16_t fs_owned : 1;",
          "158:     };",
          "159:   };",
          "",
          "[Added Lines]",
          "148:   uint16_t mode_and_type;             // 0x50",
          "149:   uint16_t padding52;                 // 0x52",
          "150:   uint64_t padding54;                 // 0x54",
          "151:   uint8_t xfields[0];                 // 0x5C",
          "156: #define APFS_XATTR_DATA_STREAM = 0x0001",
          "157: #define APFS_XATTR_DATA_EMBEDDED = 0x0002",
          "158: #define APFS_XATTR_FILE_SYSTEM_OWNED = 0x0004",
          "159: #define APFS_XATTR_RESERVED_8 = 0x0008",
          "162:   uint16_t flags;      // 0x00",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "189: } apfs_crypto_state;",
          "190: static_assert(sizeof(apfs_crypto_state) == 0x18, \"improperly aligned struct\");",
          "192: typedef struct {",
          "197: } apfs_file_extent;",
          "198: static_assert(sizeof(apfs_file_extent) == 0x18, \"improperly aligned struct\");",
          "200: typedef struct {",
          "205: } apfs_dir_record;",
          "206: static_assert(sizeof(apfs_dir_record) == 0x12, \"improperly aligned struct\");",
          "",
          "[Removed Lines]",
          "193:   uint64_t len : 56;   // 0x00 (bottom 56 bits)",
          "194:   uint64_t flags : 8;  // (top 8 bits)",
          "195:   uint64_t phys;       // 0x08",
          "196:   uint64_t crypto;     // 0x10",
          "201:   uint64_t file_id;     // 0x00",
          "202:   uint64_t date_added;  // 0x08",
          "203:   uint16_t type : 4;    // 0x10",
          "204:   uint16_t flags : 12;",
          "",
          "[Added Lines]",
          "196: #define APFS_FILE_EXTENT_LEN_BITS 56",
          "197: #define APFS_FILE_EXTENT_LEN_SHIFT 0",
          "198: #define APFS_FILE_EXTENT_FLAGS_BITS 8",
          "199: #define APFS_FILE_EXTENT_FLAGS_SHIFT 56",
          "202:   uint64_t len_and_flags;  // 0x00",
          "203:   uint64_t phys;           // 0x08",
          "204:   uint64_t crypto;         // 0x10",
          "209: #define APFS_DIR_RECORD_TYPE_BITS 4",
          "210: #define APFS_DIR_RECORD_TYPE_SHIFT 0",
          "211: #define APFS_DIR_RECORD_FLAGS_BITS 12",
          "212: #define APFS_DIR_RECORD_FLAGS_SHIFT 4",
          "215:   uint64_t file_id;         // 0x00",
          "216:   uint64_t date_added;      // 0x08",
          "217:   uint16_t type_and_flags;  // 0x10",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "238:   APFS_XFIELD_TYPE_DEVICE = 0x0E,",
          "239: } APFS_XFIELD_TYPE;",
          "241: typedef struct {",
          "256: } apfs_xfield_entry;",
          "257: static_assert(sizeof(apfs_xfield_entry) == 0x04, \"improperly aligned struct\");",
          "",
          "[Removed Lines]",
          "242:   uint8_t type;  // 0x00",
          "243:   union {        // 0x01",
          "244:     uint8_t flags;",
          "245:     struct {",
          "246:       uint8_t data_dependant : 1;",
          "247:       uint8_t do_not_copy : 1;",
          "248:       uint8_t : 1;",
          "249:       uint8_t children_inherit : 1;",
          "250:       uint8_t user_field : 1;",
          "251:       uint8_t system_field : 1;",
          "252:       uint8_t : 2;",
          "253:     };",
          "254:   };",
          "255:   uint16_t len;  // 0x02",
          "",
          "[Added Lines]",
          "255: #define APFS_XFIELD_ENTRY_DATA_DEPENDENT 0x01",
          "256: #define APFS_XFIELD_ENTRY_DO_NOT_COPY 0x02",
          "257: #define APFS_XFIELD_ENTRY_RESERVED_4 0x04",
          "258: #define APFS_XFIELD_ENTRY_CHILDREN_INHERIT 0x08",
          "259: #define APFS_XFIELD_ENTRY_USER_FIELD 0x10",
          "260: #define APFS_XFIELD_ENTRY_SYSTEM_FIELD 0x20",
          "261: #define APFS_XFIELD_ENTRY_RESERVED_40 0x40",
          "262: #define APFS_XFIELD_ENTRY_RESERVED_80 0x80",
          "265:   uint8_t type;   // 0x00",
          "266:   uint8_t flags;  // 0x01",
          "267:   uint16_t len;   // 0x02",
          "",
          "---------------"
        ],
        "tsk/fs/apfs_fs.hpp||tsk/fs/apfs_fs.hpp": [
          "File: tsk/fs/apfs_fs.hpp -> tsk/fs/apfs_fs.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:  public:",
          "47:   using key_type = struct {",
          "50:   };",
          "52:   APFSJObject() = default;",
          "",
          "[Removed Lines]",
          "48:     uint64_t oid : 60;",
          "49:     uint64_t type : 4;",
          "",
          "[Added Lines]",
          "48:     uint64_t oid_and_type;",
          "50:     constexpr uint64_t oid() const noexcept {",
          "51:       return bitfield_value(oid_and_type, 60, 0);",
          "52:     }",
          "54:     constexpr uint64_t type() const noexcept {",
          "55:       return bitfield_value(oid_and_type, 4, 60);",
          "56:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112:         oid, [](const auto &key, const auto &b) noexcept->int64_t {",
          "113:           const auto akey = key.template as<APFSJObject::key_type>();",
          "116:         });",
          "117:   }",
          "",
          "[Removed Lines]",
          "115:           return akey->oid - b;",
          "",
          "[Added Lines]",
          "122:           return akey->oid() - b;",
          "",
          "---------------"
        ],
        "tsk/fs/tsk_apfs.h||tsk/fs/tsk_apfs.h": [
          "File: tsk/fs/tsk_apfs.h -> tsk/fs/tsk_apfs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #define APFS_MAX_HIST 8",
          "25: #define APFS_VOLNAME_LEN 256",
          "27: typedef struct {",
          "28:   uint64_t cksum;  // 0x00",
          "29:   uint64_t oid;    // 0x08",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #define APFS_OBJ_HEADER_VIRTUAL 0x0000",
          "29: #define APFS_OBJ_HEADER_EPHEMERAL 0x8000",
          "30: #define APFS_OBJ_HEADER_PHYSICAL 0x4000",
          "31: #define APFS_OBJ_HEADER_NOHEADER 0x2000",
          "32: #define APFS_OBJ_HEADER_ENCRYPTED 0x1000",
          "33: #define APFS_OBJ_HEADER_NONPERSISTENT 0x0800",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31:   union {          // 0x18",
          "32:     struct {",
          "33:       uint16_t type;",
          "46:     };",
          "47:     uint32_t type_and_flags;",
          "48:   };",
          "",
          "[Removed Lines]",
          "36:       uint16_t : 11;",
          "39:       uint16_t nonpersistent : 1;",
          "42:       uint16_t encrypted : 1;",
          "43:       uint16_t no_header : 1;",
          "44:       uint16_t physical : 1;",
          "45:       uint16_t ephemeral : 1;",
          "",
          "[Added Lines]",
          "42:       uint16_t flags;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "99: } apfs_prange;",
          "100: static_assert(sizeof(apfs_prange) == 0x10, \"improperly aligned struct\");",
          "102: typedef struct {",
          "157:   uint64_t efi_jumpstart;                           // 0x4F8",
          "158:   uint8_t fusion_uuid[16];                          // 0x500",
          "159:   apfs_prange keylocker;                            // 0x510",
          "",
          "[Removed Lines]",
          "103:   apfs_obj_header obj_hdr;  // 0x00",
          "104:   uint32_t magic;           // 0x20 (NXSB)",
          "105:   uint32_t block_size;      // 0x24",
          "106:   uint64_t block_count;     // 0x28",
          "107:   union {                   // 0x30",
          "108:     uint64_t features;",
          "109:     struct {",
          "110:       uint64_t supports_defrag : 1;",
          "111:       uint64_t supports_lcfd : 1;",
          "112:       uint64_t : 62;",
          "113:     };",
          "114:   };",
          "115:   uint64_t readonly_compatible_features;  // 0x38",
          "116:   union {                                 // 0x40",
          "117:     uint64_t incompatible_features;",
          "118:     struct {",
          "119:       uint64_t apfs_version1 : 1;",
          "120:       uint64_t apfs_version2 : 1;",
          "121:       uint64_t : 14;",
          "122:       uint64_t supports_fusion : 1;",
          "123:       uint64_t : 47;",
          "124:     };",
          "125:   };",
          "126:   uint8_t uuid[16];                            // 0x48",
          "127:   uint64_t next_oid;                           // 0x58",
          "128:   uint64_t next_xid;                           // 0x60",
          "129:   uint32_t chkpt_desc_block_count;             // 0x68",
          "130:   uint32_t chkpt_data_block_count;             // 0x6C",
          "131:   uint64_t chkpt_desc_base_addr;               // 0x70",
          "132:   uint64_t chkpt_data_base_addr;               // 0x78",
          "133:   uint32_t chkpt_desc_next_block;              // 0x80",
          "134:   uint32_t chkpt_data_next_block;              // 0x84",
          "135:   uint32_t chkpt_desc_index;                   // 0x88",
          "136:   uint32_t chkpt_desc_len;                     // 0x8C",
          "137:   uint32_t chkpt_data_index;                   // 0x90",
          "138:   uint32_t chkpt_data_len;                     // 0x94",
          "139:   uint64_t spaceman_oid;                       // 0x98",
          "140:   uint64_t omap_oid;                           // 0xA0",
          "141:   uint64_t reaper_oid;                         // 0xA8",
          "142:   uint32_t test_type;                          // 0xB0",
          "143:   uint32_t max_fs_count;                       // 0xB4",
          "144:   uint64_t fs_oids[APFS_NX_MAX_FILE_SYSTEMS];  // 0xB8",
          "145:   uint64_t counters[APFS_NX_NUM_COUNTERS];     // 0x3D8",
          "146:   apfs_prange blocked_out_prange;              // 0x4D8",
          "147:   uint64_t evict_mapping_tree_oid;             // 0x4E8",
          "148:   union {                                      // 0x4F0",
          "149:     uint64_t flags;",
          "150:     struct {",
          "151:       uint64_t reserved1 : 1;",
          "152:       uint64_t reserved2 : 1;",
          "153:       uint64_t crypto_sw : 1;",
          "154:       uint64_t : 61;",
          "155:     };",
          "156:   };",
          "",
          "[Added Lines]",
          "100: #define APFS_NXSB_FEATURES_DEFRAG 0x0000000000000001ULL",
          "101: #define APFS_NXSB_FEATURES_LCFD 0x0000000000000002ULL",
          "104: #define APFS_NXSB_INCOMPAT_VERSION1 0x0000000000000001ULL",
          "105: #define APFS_NXSB_INCOMPAT_VERSION2 0x0000000000000002ULL",
          "106: #define APFS_NXSB_INCOMPAT_FUSION 0x0000000000000100ULL",
          "109: #define APFS_NXSB_FLAGS_RESERVED_1 0x00000001LL",
          "110: #define APFS_NXSB_FLAGS_RESERVED_2 0x00000002LL",
          "111: #define APFS_NXSB_FLAGS_CRYPTO_SW 0x00000004LL",
          "114:   apfs_obj_header obj_hdr;                          // 0x00",
          "115:   uint32_t magic;                                   // 0x20 (NXSB)",
          "116:   uint32_t block_size;                              // 0x24",
          "117:   uint64_t block_count;                             // 0x28",
          "118:   uint64_t features;                                // 0x30",
          "119:   uint64_t readonly_compatible_features;            // 0x38",
          "120:   uint64_t incompatible_features;                   // 0x40",
          "121:   uint8_t uuid[16];                                 // 0x48",
          "122:   uint64_t next_oid;                                // 0x58",
          "123:   uint64_t next_xid;                                // 0x60",
          "124:   uint32_t chkpt_desc_block_count;                  // 0x68",
          "125:   uint32_t chkpt_data_block_count;                  // 0x6C",
          "126:   uint64_t chkpt_desc_base_addr;                    // 0x70",
          "127:   uint64_t chkpt_data_base_addr;                    // 0x78",
          "128:   uint32_t chkpt_desc_next_block;                   // 0x80",
          "129:   uint32_t chkpt_data_next_block;                   // 0x84",
          "130:   uint32_t chkpt_desc_index;                        // 0x88",
          "131:   uint32_t chkpt_desc_len;                          // 0x8C",
          "132:   uint32_t chkpt_data_index;                        // 0x90",
          "133:   uint32_t chkpt_data_len;                          // 0x94",
          "134:   uint64_t spaceman_oid;                            // 0x98",
          "135:   uint64_t omap_oid;                                // 0xA0",
          "136:   uint64_t reaper_oid;                              // 0xA8",
          "137:   uint32_t test_type;                               // 0xB0",
          "138:   uint32_t max_fs_count;                            // 0xB4",
          "139:   uint64_t fs_oids[APFS_NX_MAX_FILE_SYSTEMS];       // 0xB8",
          "140:   uint64_t counters[APFS_NX_NUM_COUNTERS];          // 0x3D8",
          "141:   apfs_prange blocked_out_prange;                   // 0x4D8",
          "142:   uint64_t evict_mapping_tree_oid;                  // 0x4E8",
          "143:   uint64_t flags;                                   // 0x4F0",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "165: } apfs_nx_superblock;",
          "166: static_assert(sizeof(apfs_nx_superblock) == 0x560, \"improperly aligned struct\");",
          "168: typedef struct {",
          "186:   uint32_t snapshot_tree_type;  // 0x2C",
          "187:   uint64_t tree_oid;            // 0x30",
          "188:   uint64_t snapshot_tree_oid;   // 0x38",
          "",
          "[Removed Lines]",
          "169:   apfs_obj_header obj_hdr;  // 0x00",
          "170:   union {                   // 0x20",
          "171:     uint32_t flags;",
          "172:     struct {",
          "173:       uint32_t manually_managed : 1;",
          "174:       uint32_t encrypting : 1;",
          "175:       uint32_t decrypting : 1;",
          "176:       uint32_t keyrolling : 1;",
          "177:       uint32_t crypto_generation : 1;",
          "178:       uint32_t : 27;",
          "179:     };",
          "180:   };",
          "181:   uint32_t snapshot_count;  // 0x24",
          "182:   uint16_t tree_type;       // 0x28",
          "183:   uint16_t : 14;            // 0x2A",
          "184:   uint16_t physical : 1;",
          "185:   uint16_t ephemeral : 1;",
          "",
          "[Added Lines]",
          "156: #define APFS_OMAP_MANUALLY_MANAGED 0x00000001",
          "157: #define APFS_OMAP_ENCRYPTING 0x00000002",
          "158: #define APFS_OMAP_DECRYPTING 0x00000004",
          "159: #define APFS_OMAP_KEYROLLING 0x00000008",
          "160: #define APFS_OMAP_CRYPTO_GENERATION 0x00000010",
          "163: #define APFS_OMAP_EPHEMERAL 0x8000",
          "164: #define APFS_OMAP_PHYSICAL 0x4000",
          "167:   apfs_obj_header obj_hdr;      // 0x00",
          "168:   uint32_t flags;               // 0x20",
          "169:   uint32_t snapshot_count;      // 0x24",
          "170:   uint16_t tree_type;           // 0x28",
          "171:   uint16_t type_flags;          // 0x2A",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "198:   APFS_OMAP_TREE_TYPE_MTREE = 0x0004,",
          "199: } APFS_OMAP_TREE_TYPE_ENUM;",
          "201: typedef struct {",
          "212:   uint16_t level;               // 0x22",
          "213:   uint32_t key_count;           // 0x24",
          "214:   uint16_t table_space_offset;  // 0x28",
          "",
          "[Removed Lines]",
          "202:   apfs_obj_header obj_hdr;  // 0x00",
          "203:   union {                   // 0x20",
          "204:     uint16_t flags;",
          "205:     struct {",
          "206:       uint16_t root : 1;",
          "207:       uint16_t leaf : 1;",
          "208:       uint16_t fixed_kv_size : 1;",
          "209:       uint16_t : 13;",
          "210:     };",
          "211:   };",
          "",
          "[Added Lines]",
          "188: #define APFS_BTNODE_ROOT 0x0001",
          "189: #define APFS_BTNODE_LEAF 0x0002",
          "190: #define APFS_BTNODE_FIXED_KV_SIZE 0x0004",
          "191: #define APFS_BTNODE_CHECK_KOFF_INVAL 0x8000",
          "194:   apfs_obj_header obj_hdr;      // 0x00",
          "195:   uint16_t flags;               // 0x20",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "237: static_assert(sizeof(apfs_btentry_variable) == 0x08,",
          "238:               \"improperly aligned struct\");",
          "240: typedef struct {",
          "253:   uint64_t readonly_compatible_features;  // 0x30",
          "268:   struct {",
          "269:     uint16_t major_version;     // 0x60",
          "270:     uint16_t minor_version;     // 0x62",
          "",
          "[Removed Lines]",
          "241:   apfs_obj_header obj_hdr;  // 0x00",
          "242:   uint32_t magic;           // 0x20",
          "243:   uint32_t fs_index;        // 0x24",
          "244:   union {                   // 0x28",
          "245:     uint64_t features;",
          "246:     struct {",
          "247:       uint64_t supports_defrag_prerelease : 1;",
          "248:       uint64_t supports_hardlink_map_records : 1;",
          "249:       uint64_t supports_defrag : 1;",
          "250:       uint64_t : 61;",
          "251:     };",
          "252:   };",
          "254:   union {                                 // 0x38",
          "255:     uint64_t incompatible_features;",
          "256:     struct {",
          "257:       uint64_t case_insensitive : 1;",
          "258:       uint64_t dataless_snaps : 1;",
          "259:       uint64_t enc_rolled : 1;",
          "260:       uint64_t normalization_insensitive : 1;",
          "261:       uint64_t : 60;",
          "262:     };",
          "263:   };",
          "264:   uint64_t unmount_time;    // 0x40",
          "265:   uint64_t reserve_blocks;  // 0x48",
          "266:   uint64_t quota_blocks;    // 0x50",
          "267:   uint64_t alloc_blocks;    // 0x58",
          "",
          "[Added Lines]",
          "225: #define APFS_SB_FEATURES_DEFRAG_PRERELEASE 0x00000001LL",
          "226: #define APFS_SB_FEATURES_HARDLINK_MAP_RECORDS 0x00000002LL",
          "227: #define APFS_SB_FEATURES_DEFRAG 0x00000004LL",
          "230: #define APFS_SB_INCOMPAT_CASE_INSENSITIVE 0x00000001LL",
          "231: #define APFS_SB_INCOMPAT_DATALESS_SNAPS 0x00000002LL",
          "232: #define APFS_SB_INCOMPAT_ENC_ROLLED 0x00000004LL",
          "233: #define APFS_SB_INCOMPAT_NORMALIZATION_INSENSITIVE 0x00000008LL",
          "236: #define APFS_SB_UNENCRYPTED 0x00000001LL",
          "237: #define APFS_SB_EFFACEABLE 0x00000002LL",
          "238: #define APFS_SB_RESERVED_4 0x00000004LL",
          "239: #define APFS_SB_ONEKEY 0x00000008LL",
          "240: #define APFS_SB_SPILLEDOVER 0x00000010LL",
          "241: #define APFS_SB_RUN_SPILLOVER_CLEANER 0x00000020LL",
          "244:   apfs_obj_header obj_hdr;                // 0x00",
          "245:   uint32_t magic;                         // 0x20",
          "246:   uint32_t fs_index;                      // 0x24",
          "247:   uint64_t features;                      // 0x28",
          "249:   uint64_t incompatible_features;         // 0x38",
          "250:   uint64_t unmount_time;                  // 0x40",
          "251:   uint64_t reserve_blocks;                // 0x48",
          "252:   uint64_t quota_blocks;                  // 0x50",
          "253:   uint64_t alloc_blocks;                  // 0x58",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "274:     uint16_t key_revision;      // 0x70",
          "275:     uint16_t unused;            // 0x72",
          "276:   } meta_crypto;",
          "308:   char formatted_by[APFS_MODIFIED_NAMELEN];  // 0x110",
          "309:   uint64_t created_timestamp;                // 0x130",
          "310:   uint64_t last_xid;                         // 0x138",
          "",
          "[Removed Lines]",
          "277:   uint32_t root_tree_type;        // 0x74",
          "278:   uint32_t extentref_tree_type;   // 0x78",
          "279:   uint32_t snap_meta_tree_type;   // 0x7C",
          "280:   uint64_t omap_oid;              // 0x80",
          "281:   uint64_t root_tree_oid;         // 0x88",
          "282:   uint64_t extentref_tree_oid;    // 0x90",
          "283:   uint64_t snap_meta_tree_oid;    // 0x98",
          "284:   uint64_t revert_to_xid;         // 0xA0",
          "285:   uint64_t revert_to_sblock_oid;  // 0xA8",
          "286:   uint64_t next_inum;             // 0xB0",
          "287:   uint64_t num_files;             // 0xB8",
          "288:   uint64_t num_directories;       // 0xC0",
          "289:   uint64_t num_symlinks;          // 0xC8",
          "290:   uint64_t num_other_fsobjects;   // 0xD0",
          "291:   uint64_t num_snapshots;         // 0xD8",
          "292:   uint64_t total_blocks_alloced;  // 0xE0",
          "293:   uint64_t total_blocks_freed;    // 0xE8",
          "294:   uint8_t uuid[16];               // 0xF0",
          "295:   uint64_t last_mod_time;         // 0x100",
          "296:   union {                         // 0x108",
          "297:     uint64_t flags;",
          "298:     struct {",
          "299:       uint64_t unencrypted : 1;",
          "300:       uint64_t effacable : 1;",
          "301:       uint64_t : 1;",
          "302:       uint64_t onekey : 1;",
          "303:       uint64_t spilled_over : 1;",
          "304:       uint64_t run_spollover_cleaner : 1;",
          "305:       uint64_t : 58;",
          "306:     };",
          "307:   };",
          "",
          "[Added Lines]",
          "263:   uint32_t root_tree_type;                   // 0x74",
          "264:   uint32_t extentref_tree_type;              // 0x78",
          "265:   uint32_t snap_meta_tree_type;              // 0x7C",
          "266:   uint64_t omap_oid;                         // 0x80",
          "267:   uint64_t root_tree_oid;                    // 0x88",
          "268:   uint64_t extentref_tree_oid;               // 0x90",
          "269:   uint64_t snap_meta_tree_oid;               // 0x98",
          "270:   uint64_t revert_to_xid;                    // 0xA0",
          "271:   uint64_t revert_to_sblock_oid;             // 0xA8",
          "272:   uint64_t next_inum;                        // 0xB0",
          "273:   uint64_t num_files;                        // 0xB8",
          "274:   uint64_t num_directories;                  // 0xC0",
          "275:   uint64_t num_symlinks;                     // 0xC8",
          "276:   uint64_t num_other_fsobjects;              // 0xD0",
          "277:   uint64_t num_snapshots;                    // 0xD8",
          "278:   uint64_t total_blocks_alloced;             // 0xE0",
          "279:   uint64_t total_blocks_freed;               // 0xE8",
          "280:   uint8_t uuid[16];                          // 0xF0",
          "281:   uint64_t last_mod_time;                    // 0x100",
          "282:   uint64_t flags;                            // 0x108",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "344:   APFS_SFQ_COUNT = 3",
          "345: } APFS_SFQ;",
          "347: typedef struct {",
          "348:   apfs_obj_header obj_hdr;  // 0x00",
          "357:   struct {",
          "358:     uint16_t type;     // 0x00",
          "359:     uint16_t flags;    // 0x02",
          "",
          "[Removed Lines]",
          "349:   union {                   // 0x20",
          "350:     uint32_t flags;",
          "351:     struct {",
          "352:       uint32_t last : 1;",
          "353:       uint32_t : 31;",
          "354:     };",
          "355:   };",
          "356:   uint32_t count;  // 0x24",
          "",
          "[Added Lines]",
          "323: #define APFS_CHECKPOINT_MAP_LAST 0x00000001",
          "327:   uint32_t flags;           // 0x20",
          "328:   uint32_t count;           // 0x24",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "392: static_assert(sizeof(apfs_spaceman_free_queue) == 0x28,",
          "393:               \"improperly aligned struct\");",
          "395: typedef struct {",
          "409:   uint32_t ip_tx_multiplier;                    // 0x94",
          "410:   uint32_t ip_block_count;                      // 0x98",
          "411:   uint32_t ip_bm_block_count;                   // 0x9C",
          "",
          "[Removed Lines]",
          "396:   apfs_obj_header obj_hdr;                   // 0x00",
          "397:   uint32_t block_size;                       // 0x20",
          "398:   uint32_t blocks_per_chunk;                 // 0x24",
          "399:   uint32_t chunks_per_cib;                   // 0x28",
          "400:   uint32_t cib_per_cab;                      // 0x2C",
          "401:   apfs_spaceman_device devs[APFS_SD_COUNT];  // 0x30",
          "402:   union {                                    // 0x90",
          "403:     uint32_t flags;",
          "404:     struct {",
          "405:       uint32_t versioned : 1;",
          "406:       uint32_t : 31;",
          "407:     };",
          "408:   };",
          "",
          "[Added Lines]",
          "368: #define APFS_SM_FLAG_VERSIONED 0x00000001",
          "371:   apfs_obj_header obj_hdr;                      // 0x00",
          "372:   uint32_t block_size;                          // 0x20",
          "373:   uint32_t blocks_per_chunk;                    // 0x24",
          "374:   uint32_t chunks_per_cib;                      // 0x28",
          "375:   uint32_t cib_per_cab;                         // 0x2C",
          "376:   apfs_spaceman_device devs[APFS_SD_COUNT];     // 0x30",
          "377:   uint32_t flags;                               // 0x90",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "448: } apfs_spaceman_cib;",
          "449: static_assert(sizeof(apfs_spaceman_cib) == 0x28, \"improperly aligned struct\");",
          "451: typedef struct {",
          "452:   apfs_obj_header obj_header;  // 0x00",
          "453:   uint64_t next_reap_id;       // 0x20",
          "454:   uint64_t compleated_id;      // 0x28",
          "455:   uint64_t head;               // 0x30",
          "456:   uint64_t tail;               // 0x38",
          "465:   uint32_t rlcount;            // 0x44",
          "466:   uint32_t type;               // 0x48",
          "467:   uint32_t size;               // 0x4C",
          "",
          "[Removed Lines]",
          "457:   union {                      // 0x40",
          "458:     uint32_t flags;            // 0x40",
          "459:     struct {",
          "460:       uint32_t bhm_flag : 1;  // always set",
          "461:       uint32_t being_reaped : 1;",
          "462:       uint32_t : 30;",
          "463:     };",
          "464:   };",
          "",
          "[Added Lines]",
          "421: #define APFS_NR_BHM_FLAG 0x00000001",
          "422: #define APFS_NR_CONTINUE 0x00000002",
          "430:   uint32_t flags;              // 0x40",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "537: } apfs_omap_key;",
          "538: static_assert(sizeof(apfs_omap_key) == 0x10, \"improperly aligned struct\");",
          "540: typedef struct {",
          "552:   uint32_t size;   // 0x04",
          "553:   uint64_t paddr;  // 0x08",
          "554: } apfs_omap_value;",
          "",
          "[Removed Lines]",
          "541:   union {  // 0x00",
          "542:     uint32_t flags;",
          "543:     struct {",
          "544:       uint32_t deleted : 1;",
          "545:       uint32_t saved : 1;",
          "546:       uint32_t encrypted : 1;",
          "547:       uint32_t noheader : 1;",
          "548:       uint32_t crypto_gen : 1;",
          "549:       uint32_t : 27;",
          "550:     };",
          "551:   };",
          "",
          "[Added Lines]",
          "507: #define APFS_OMAP_VAL_DELETED 0x00000001",
          "508: #define APFS_OMAP_VAL_SAVED 0x00000002",
          "509: #define APFS_OMAP_VAL_ENCRYPTED 0x00000004",
          "510: #define APFS_OMAP_VAL_NOHEADER 0x00000008",
          "511: #define APFS_OMAP_VAL_CRYPTO_GENERATION 0x00000010",
          "514:   uint32_t flags;  // 0x00",
          "",
          "---------------"
        ],
        "tsk/fs/tsk_apfs.hpp||tsk/fs/tsk_apfs.hpp": [
          "File: tsk/fs/tsk_apfs.hpp -> tsk/fs/tsk_apfs.hpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: #include \"../auto/guid.h\"",
          "23: class APFSPool;",
          "25: class APFSObject : public APFSBlock {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "24: template <typename T,",
          "25:           typename = std::enable_if_t<std::numeric_limits<T>::is_integer>>",
          "26: constexpr bool bit_is_set(T bitfield, int bit) noexcept {",
          "27:   return ((bitfield & bit) != 0);",
          "28: }",
          "31: template <typename T,",
          "32:           typename = std::enable_if_t<std::numeric_limits<T>::is_integer>>",
          "33: constexpr T bitfield_value(T bitfield, int bits, int shift) noexcept {",
          "34:   return (bitfield >> shift) & ((1 << bits) - 1);",
          "35: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "427:     };",
          "428:   }",
          "436:   inline uint16_t level() const noexcept { return bn()->level; }",
          "",
          "[Removed Lines]",
          "430:   inline bool is_root() const noexcept { return bn()->root; }",
          "432:   inline bool is_leaf() const noexcept { return bn()->leaf; }",
          "434:   inline bool has_fixed_kv_size() const noexcept { return bn()->fixed_kv_size; }",
          "",
          "[Added Lines]",
          "444:   inline bool is_root() const noexcept {",
          "445:     return bit_is_set(bn()->flags, APFS_BTNODE_ROOT);",
          "446:   }",
          "448:   inline bool is_leaf() const noexcept {",
          "449:     return bit_is_set(bn()->flags, APFS_BTNODE_LEAF);",
          "450:   }",
          "452:   inline bool has_fixed_kv_size() const noexcept {",
          "453:     return bit_is_set(bn()->flags, APFS_BTNODE_FIXED_KV_SIZE);",
          "454:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "901:     Guid uuid;",
          "902:     uint8_t data[0x28];",
          "903:     uint64_t iterations;",
          "914:     uint8_t salt[0x10];",
          "915:     wrapped_kek(Guid &&uuid, const std::unique_ptr<uint8_t[]> &);",
          "916:   };",
          "918:   using crypto_info_t = struct {",
          "",
          "[Removed Lines]",
          "904:     union {",
          "905:       struct {",
          "906:         uint64_t : 56;",
          "907:         uint64_t hw_crypt : 1;  // If this bit is set, some sort of hardware",
          "909:         uint64_t cs : 1;        // If this bit is set the KEK is 0x10 bytes",
          "911:       };",
          "912:       uint64_t flags;",
          "913:     };",
          "",
          "[Added Lines]",
          "924:     uint64_t flags;",
          "928:     constexpr bool hw_crypt() const noexcept {",
          "930:       return bit_is_set(flags, 57);",
          "931:     }",
          "933:     constexpr bool cs() const noexcept {",
          "935:       return bit_is_set(flags, 58);",
          "936:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "920:     std::string password_hint{};",
          "921:     std::string password{};",
          "922:     std::vector<wrapped_kek> wrapped_keks{};",
          "936:     uint8_t wrapped_vek[0x28]{};",
          "937:     uint8_t vek_uuid[0x10]{};",
          "938:     uint8_t vek[0x20]{};",
          "939:     bool unlocked{};",
          "940:   };",
          "942:  protected:",
          "",
          "[Removed Lines]",
          "923:     union {",
          "924:       struct {",
          "925:         uint64_t : 16;",
          "926:         uint64_t unk16 : 8;  // If this byte is not zero (1) then some other",
          "928:         uint64_t : 32;",
          "929:         uint64_t hw_crypt : 1;  // If this bit is set, some sort of hardware",
          "931:         uint64_t cs : 1;        // If this bit is set the VEK is 0x10 bytes",
          "933:       };",
          "934:       uint64_t vek_flags{};",
          "935:     };",
          "",
          "[Added Lines]",
          "944:     uint64_t vek_flags{};",
          "950:     constexpr uint64_t unk16() const noexcept {",
          "952:       return bitfield_value(vek_flags, 8, 16);",
          "953:     }",
          "955:     constexpr bool hw_crypt() const noexcept {",
          "957:       return bit_is_set(vek_flags, 56);",
          "958:     }",
          "960:     constexpr bool cs() const noexcept {",
          "962:       return bit_is_set(vek_flags, 57);",
          "963:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1012:   inline uint64_t last_inum() const noexcept { return fs()->next_inum - 1; }",
          "1016:   inline bool case_sensitive() const noexcept {",
          "1018:   }",
          "1020:   inline uint64_t created() const noexcept { return fs()->created_timestamp; }",
          "",
          "[Removed Lines]",
          "1014:   inline bool encrypted() const noexcept { return (fs()->unencrypted == 0); }",
          "1017:     return (fs()->case_insensitive == 0);",
          "",
          "[Added Lines]",
          "1038:   inline bool encrypted() const noexcept {",
          "1039:     return !bit_is_set(fs()->flags, APFS_SB_UNENCRYPTED);",
          "1040:   }",
          "1043:     return !bit_is_set(fs()->incompatible_features,",
          "1044:                        APFS_SB_INCOMPAT_CASE_INSENSITIVE);",
          "",
          "---------------"
        ],
        "tsk/pool/apfs_pool.cpp||tsk/pool/apfs_pool.cpp": [
          "File: tsk/pool/apfs_pool.cpp -> tsk/pool/apfs_pool.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "54:   _vol_blocks = nxsb->volume_blocks();",
          "55:   _num_vols = _vol_blocks.size();",
          "57: }",
          "59: std::unique_ptr<APFSSuperblock> APFSPool::nx(bool validate) const {",
          "",
          "[Removed Lines]",
          "56:   _hw_crypto = (nxsb->sb()->crypto_sw == 0);",
          "",
          "[Added Lines]",
          "56:   _hw_crypto = !bit_is_set(nxsb->sb()->flags, APFS_NXSB_FLAGS_CRYPTO_SW);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "af88bc32e63284c3929d5451b47dd472a65e57d0",
      "candidate_info": {
        "commit_hash": "af88bc32e63284c3929d5451b47dd472a65e57d0",
        "repo": "sleuthkit/sleuthkit",
        "commit_url": "https://github.com/sleuthkit/sleuthkit/commit/af88bc32e63284c3929d5451b47dd472a65e57d0",
        "files": [
          "bindings/java/src/org/sleuthkit/datamodel/CommunicationsManager.java",
          "bindings/java/src/org/sleuthkit/datamodel/RelationshipTypeFilter.java",
          "bindings/java/test/org/sleuthkit/datamodel/CommunicationsManagerTest.java"
        ],
        "message": "878: Add getRelationshipsCount() API for milestone #3",
        "before_after_code_files": [
          "bindings/javsrc/org/sleuthkit/datamodel/CommunicationsManager.java||bindings/java/src/org/sleuthkit/datamodel/CommunicationsManager.java",
          "bindings/javsrc/org/sleuthkit/datamodel/RelationshipTypeFilter.java||bindings/java/src/org/sleuthkit/datamodel/RelationshipTypeFilter.java",
          "bindings/javtest/org/sleuthkit/datamodel/CommunicationsManagerTest.java||bindings/java/test/org/sleuthkit/datamodel/CommunicationsManagerTest.java"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "bindings/javsrc/org/sleuthkit/datamodel/CommunicationsManager.java||bindings/java/src/org/sleuthkit/datamodel/CommunicationsManager.java": [
          "File: bindings/javsrc/org/sleuthkit/datamodel/CommunicationsManager.java -> bindings/java/src/org/sleuthkit/datamodel/CommunicationsManager.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1348:  public List<BlackboardArtifact> getRelationships(List<Account> accountsList, CommunicationsFilter filter) throws TskCoreException {",
          "1350:   List<Long> account_ids = new ArrayList<Long> ();",
          "1351:   for (Account acct: accountsList) {",
          "1352:    account_ids.add(acct.getAccountId());",
          "1353:   }",
          "1354:   String account_ids_list = buildCSVString(account_ids);",
          "1356:   CaseDbConnection connection = db.getConnection();",
          "1357:   db.acquireSharedLock();",
          "1358:   Statement s = null;",
          "1359:   ResultSet rs = null;",
          "1361:   try {",
          "1362:    s = connection.createStatement();",
          "1363:    String queryStr =",
          "1364:      \"SELECT artifacts.artifact_id AS artifact_id,\"",
          "1365:      + \" artifacts.obj_id AS obj_id,\"",
          "1366:      + \" artifacts.artifact_obj_id AS artifact_obj_id,\"",
          "1367:      + \" artifacts.data_source_obj_id AS data_source_obj_id, \"",
          "1368:      + \" artifacts.artifact_type_id AS artifact_type_id, \"",
          "1369:      + \" artifacts.review_status_id AS review_status_id  \"",
          "1370:      + \" FROM blackboard_artifacts as artifacts\"",
          "1371:      + \" JOIN relationships AS relationships\"",
          "1372:      + \"  ON artifacts.artifact_id = relationships.communication_artifact_id\"",
          "1373:      + \" WHERE artifacts.artifact_type_id IN ( \" + RELATIONSHIP_ARTIFACT_TYPE_IDS_CSV_STR + \" )\"",
          "1374:      + \" AND ( relationships.account1_id IN ( \" + account_ids_list + \" ) \" + \" OR  relationships.account2_id IN ( \" + account_ids_list + \" )\" + \" )\";",
          "1377:    Set<String> applicableFilters = new HashSet<String>();",
          "1378:    applicableFilters.add(DeviceFilter.class.getName());",
          "1379:    applicableFilters.add(RelationshipTypeFilter.class.getName());",
          "1382:    String filterSQL = getCommunicationsFilterSQL(filter, applicableFilters);",
          "1383:    if (!filterSQL.isEmpty()) {",
          "1384:     queryStr += \" AND \" + filterSQL;",
          "1385:    }",
          "1387:    System.out.println(\"RAMAN FilterSQL = \" + filterSQL);",
          "1388:    System.out.println(\"RAMAN QueryStr = \" + queryStr);",
          "1390:    rs = connection.executeQuery(s, queryStr); //NON-NLS",
          "1391:    ArrayList<BlackboardArtifact> artifacts = new ArrayList<BlackboardArtifact>();",
          "1393:    while (rs.next()) {",
          "1394:     BlackboardArtifact.Type bbartType = db.getArtifactType(rs.getInt(\"artifact_type_id\"));",
          "1395:     artifacts.add(new BlackboardArtifact(db, rs.getLong(\"artifact_id\"), rs.getLong(\"obj_id\"), rs.getLong(\"artifact_obj_id\"), rs.getLong(\"data_source_obj_id\"),",
          "1396:       bbartType.getTypeID(), bbartType.getTypeName(), bbartType.getDisplayName(),",
          "1397:       BlackboardArtifact.ReviewStatus.withID(rs.getInt(\"review_status_id\"))));",
          "1398:    }",
          "1400:    return artifacts;",
          "1401:   } catch (SQLException ex) {",
          "1402:    throw new TskCoreException(\"Error getting relationships for account. \" + ex.getMessage(), ex);",
          "1403:   } finally {",
          "1404:    closeResultSet(rs);",
          "1405:    closeStatement(s);",
          "1406:    connection.close();",
          "1407:    db.releaseSharedLock();",
          "1408:   }",
          "1409:  }",
          "",
          "---------------"
        ],
        "bindings/javsrc/org/sleuthkit/datamodel/RelationshipTypeFilter.java||bindings/java/src/org/sleuthkit/datamodel/RelationshipTypeFilter.java": [
          "File: bindings/javsrc/org/sleuthkit/datamodel/RelationshipTypeFilter.java -> bindings/java/src/org/sleuthkit/datamodel/RelationshipTypeFilter.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: package org.sleuthkit.datamodel;",
          "21: import java.util.ArrayList;",
          "22: import java.util.HashSet;",
          "23: import java.util.List;",
          "24: import java.util.Set;",
          "30: public class RelationshipTypeFilter implements SubFilter {",
          "32:  private final Set<BlackboardArtifact.ARTIFACT_TYPE> relationshipTypes;",
          "34:  public RelationshipTypeFilter(Set<BlackboardArtifact.ARTIFACT_TYPE> relationshipTypes) {",
          "35:   this.relationshipTypes = relationshipTypes;",
          "36:  }",
          "43:  Set<BlackboardArtifact.ARTIFACT_TYPE> getRelationshipTypes() {",
          "44:   return new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(relationshipTypes);",
          "45:  }",
          "52:  @Override",
          "53:  public String getDescription() {",
          "54:   return \"Filters relationships by relationship type.\";",
          "55:  }",
          "64:  @Override",
          "65:  public String getSQL(CommunicationsManager commsManager) {",
          "66:   if (relationshipTypes.isEmpty()) {",
          "67:    return \"\";",
          "68:   }",
          "70:   String sql = \"\";",
          "71:   List<Integer> type_ids = new ArrayList<Integer>();",
          "72:   for (BlackboardArtifact.ARTIFACT_TYPE artType : relationshipTypes) {",
          "73:    type_ids.add(artType.getTypeID());",
          "74:   }",
          "76:   String artifact_type_ids_list = CommunicationsManager.buildCSVString(type_ids);",
          "77:   if (!artifact_type_ids_list.isEmpty()) {",
          "78:    sql = \" artifacts.artifact_type_id IN ( \" + artifact_type_ids_list + \" )\";",
          "79:   }",
          "81:   return sql;",
          "82:  }",
          "84: }",
          "",
          "---------------"
        ],
        "bindings/javtest/org/sleuthkit/datamodel/CommunicationsManagerTest.java||bindings/java/test/org/sleuthkit/datamodel/CommunicationsManagerTest.java": [
          "File: bindings/javtest/org/sleuthkit/datamodel/CommunicationsManagerTest.java -> bindings/java/test/org/sleuthkit/datamodel/CommunicationsManagerTest.java",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "686:  @Test",
          "687:  public void relationshipsWithFilterTests() throws TskCoreException {",
          "689:   System.out.println(\"CommsMgr API - Relationship counts test\");",
          "692:   {",
          "693:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "694:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_A)",
          "695:           ));",
          "697:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, null);",
          "698:    assertEquals(4, relationsShips.size());",
          "699:   }",
          "702:   {",
          "703:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "704:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_B)",
          "705:           ));",
          "707:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, null);",
          "708:    assertEquals(3, relationsShips.size());",
          "709:   }",
          "712:   {",
          "713:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "714:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_A),",
          "715:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_C)",
          "716:           ));",
          "718:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, null);",
          "719:    assertEquals(5, relationsShips.size());",
          "720:   }",
          "723:   {",
          "724:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "725:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_A),",
          "726:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_C)",
          "727:           ));",
          "729:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, null);",
          "730:    assertEquals(5, relationsShips.size());",
          "731:   }",
          "734:   {",
          "735:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "736:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_A),",
          "737:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_B),",
          "738:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_C)",
          "739:           ));",
          "741:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, null);",
          "742:    assertEquals(5, relationsShips.size());",
          "743:   }",
          "746:   {",
          "747:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "748:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_A),",
          "749:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_B),",
          "750:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_C)",
          "751:           ));",
          "753:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "754:      new HashSet<String>(Arrays.asList(DS2_DEVICEID)),",
          "755:      null);",
          "757:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "758:    assertEquals(0, relationsShips.size());",
          "759:   }",
          "762:   {",
          "763:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "764:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1)",
          "765:           ));",
          "767:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, null);",
          "768:    assertEquals(1, relationsShips.size());",
          "769:   }",
          "772:   {",
          "773:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "774:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1)",
          "775:           ));",
          "777:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "778:      null,",
          "779:      null,",
          "780:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG)));",
          "782:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "783:    assertEquals(1, relationsShips.size());",
          "784:   }",
          "787:   {",
          "788:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "789:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1)",
          "790:           ));",
          "792:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "793:      null,",
          "794:      null,",
          "795:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT)));",
          "797:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "798:    assertEquals(0, relationsShips.size());",
          "799:   }",
          "802:   {",
          "803:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "804:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1)",
          "805:           ));",
          "807:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "808:      null,",
          "809:      null,",
          "810:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE)));",
          "812:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "813:    assertEquals(0, relationsShips.size());",
          "814:   }",
          "817:   {",
          "818:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "819:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2)",
          "820:           ));",
          "822:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "823:      null,",
          "824:      null,",
          "825:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG)));",
          "827:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "828:    assertEquals(3, relationsShips.size());",
          "829:   }",
          "832:   {",
          "833:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "834:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2)",
          "835:           ));",
          "837:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "838:      null,",
          "839:      null,",
          "840:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT)));",
          "842:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "843:    assertEquals(2, relationsShips.size());",
          "844:   }",
          "847:   {",
          "848:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "849:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2)",
          "850:           ));",
          "852:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "853:      null,",
          "854:      null,",
          "855:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT, BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG )));",
          "857:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "858:    assertEquals(5, relationsShips.size());",
          "859:   }",
          "862:   {",
          "863:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "864:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1),",
          "865:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2)",
          "866:           ));",
          "868:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "869:      null,",
          "870:      null,",
          "871:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE, BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG )));",
          "873:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "874:    assertEquals(8, relationsShips.size());",
          "875:   }",
          "878:   {",
          "879:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "880:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2),",
          "881:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_3),",
          "882:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_4),",
          "883:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_5)",
          "884:           ));",
          "885:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "886:      new HashSet<String>(Arrays.asList(DS1_DEVICEID)),",
          "887:      null,",
          "888:      null);",
          "890:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "891:    assertEquals(8, relationsShips.size());",
          "892:   }",
          "895:   {",
          "896:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "897:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2),",
          "898:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_3),",
          "899:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_4),",
          "900:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_5)",
          "901:           ));",
          "902:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "903:      new HashSet<String>(Arrays.asList(DS1_DEVICEID)),",
          "904:      null,",
          "905:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE)));",
          "907:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "908:    assertEquals(3, relationsShips.size());",
          "909:   }",
          "912:   {",
          "913:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "914:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1),",
          "915:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2),",
          "916:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_3),",
          "917:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_4),",
          "918:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_5)",
          "919:           ));",
          "920:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "921:      new HashSet<String>(Arrays.asList(DS2_DEVICEID)),",
          "922:      null,",
          "923:      null);",
          "925:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "926:    assertEquals(9, relationsShips.size());",
          "927:   }",
          "930:   {",
          "931:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "932:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1),",
          "933:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2),",
          "934:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_3),",
          "935:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_4),",
          "936:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_5)",
          "937:           ));",
          "938:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "939:      new HashSet<String>(Arrays.asList(DS2_DEVICEID)),",
          "940:      null,",
          "941:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_CALLLOG, BlackboardArtifact.ARTIFACT_TYPE.TSK_MESSAGE)));",
          "943:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "944:    assertEquals(6, relationsShips.size());",
          "945:   }",
          "948:   {",
          "949:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "950:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1),",
          "951:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2),",
          "952:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_3),",
          "953:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_4),",
          "954:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_5)",
          "955:           ));",
          "956:    CommunicationsFilter commsFilter = buildCommsFilter(",
          "957:      new HashSet<String>(Arrays.asList(DS2_DEVICEID)),",
          "958:      null,",
          "959:      new HashSet<BlackboardArtifact.ARTIFACT_TYPE>(Arrays.asList(BlackboardArtifact.ARTIFACT_TYPE.TSK_CONTACT)));",
          "961:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, commsFilter);",
          "962:    assertEquals(3, relationsShips.size());",
          "963:   }",
          "966:   {",
          "967:    List<Account> accountList = new ArrayList<Account>(Arrays.asList(",
          "968:           commsMgr.getAccount(Account.Type.EMAIL, EMAIL_A),",
          "969:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_1),",
          "970:           commsMgr.getAccount(Account.Type.PHONE, PHONENUM_2)",
          "971:           ));",
          "973:    List<BlackboardArtifact> relationsShips = commsMgr.getRelationships(accountList, null);",
          "974:    assertEquals(14, relationsShips.size());",
          "975:   }",
          "977:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "988:   return buildCommsFilter(deviceSet, accountTypeSet, null);",
          "989:  }",
          "991:  private static CommunicationsFilter buildCommsFilter(Set<String> deviceSet, Set<Account.Type> accountTypeSet, Set<BlackboardArtifact.ARTIFACT_TYPE> relationshipTypeSet) {",
          "993:   if ((null == deviceSet) && (null == accountTypeSet) && (null == relationshipTypeSet) ) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1004:   if (null != relationshipTypeSet) {",
          "1005:    commsFilter.addAndFilter(new RelationshipTypeFilter(relationshipTypeSet));",
          "1006:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-6410",
  "cve_desc": "The __udf_read_inode function in fs/udf/inode.c in the Linux kernel through 3.16.3 does not restrict the amount of ICB indirection, which allows physically proximate attackers to cause a denial of service (infinite loop or stack consumption) via a UDF filesystem with a crafted inode.",
  "repo": "torvalds/linux",
  "patch_hash": "c03aa9f6e1f938618e6db2e23afef0574efeeb65",
  "patch_info": {
    "commit_hash": "c03aa9f6e1f938618e6db2e23afef0574efeeb65",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c03aa9f6e1f938618e6db2e23afef0574efeeb65",
    "files": [
      "fs/udf/inode.c"
    ],
    "message": "udf: Avoid infinite loop when processing indirect ICBs\n\nWe did not implement any bound on number of indirect ICBs we follow when\nloading inode. Thus corrupted medium could cause kernel to go into an\ninfinite loop, possibly causing a stack overflow.\n\nFix the possible stack overflow by removing recursion from\n__udf_read_inode() and limit number of indirect ICBs we follow to avoid\ninfinite loops.\n\nSigned-off-by: Jan Kara <jack@suse.cz>",
    "before_after_code_files": [
      "fs/udf/inode.c||fs/udf/inode.c"
    ]
  },
  "patch_diff": {
    "fs/udf/inode.c||fs/udf/inode.c": [
      "File: fs/udf/inode.c -> fs/udf/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1270:  return 0;",
      "1271: }",
      "1273: static void __udf_read_inode(struct inode *inode)",
      "1274: {",
      "1275:  struct buffer_head *bh = NULL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1278: #define UDF_MAX_ICB_NESTING 1024",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1279:  struct udf_inode_info *iinfo = UDF_I(inode);",
      "1280:  struct udf_sb_info *sbi = UDF_SB(inode->i_sb);",
      "1281:  unsigned int link_count;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1289:  unsigned int indirections = 0;",
      "1291: reread:",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1317:   ibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,",
      "1318:      &ident);",
      "1319:   if (ident == TAG_IDENT_IE && ibh) {",
      "1321:    struct kernel_lb_addr loc;",
      "1322:    struct indirectEntry *ie;",
      "1324:    ie = (struct indirectEntry *)ibh->b_data;",
      "1325:    loc = lelb_to_cpu(ie->indirectICB.extLocation);",
      "1339:      return;",
      "1340:     }",
      "1342:    }",
      "1343:   }",
      "1344:   brelse(ibh);",
      "",
      "[Removed Lines]",
      "1320:    struct buffer_head *nbh = NULL;",
      "1327:    if (ie->indirectICB.extLength &&",
      "1328:     (nbh = udf_read_ptagged(inode->i_sb, &loc, 0,",
      "1329:        &ident))) {",
      "1330:     if (ident == TAG_IDENT_FE ||",
      "1331:      ident == TAG_IDENT_EFE) {",
      "1332:      memcpy(&iinfo->i_location,",
      "1333:       &loc,",
      "1334:       sizeof(struct kernel_lb_addr));",
      "1335:      brelse(bh);",
      "1336:      brelse(ibh);",
      "1337:      brelse(nbh);",
      "1338:      __udf_read_inode(inode);",
      "1341:     brelse(nbh);",
      "",
      "[Added Lines]",
      "1335:    if (ie->indirectICB.extLength) {",
      "1336:     brelse(bh);",
      "1337:     brelse(ibh);",
      "1338:     memcpy(&iinfo->i_location, &loc,",
      "1339:            sizeof(struct kernel_lb_addr));",
      "1340:     if (++indirections > UDF_MAX_ICB_NESTING) {",
      "1341:      udf_err(inode->i_sb,",
      "1342:       \"too many ICBs in ICB hierarchy\"",
      "1343:       \" (max %d supported)\\n\",",
      "1344:       UDF_MAX_ICB_NESTING);",
      "1345:      make_bad_inode(inode);",
      "1348:     goto reread;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6d3d5e860a114ae606b1af2ba7f64cb19fbeb414",
      "candidate_info": {
        "commit_hash": "6d3d5e860a114ae606b1af2ba7f64cb19fbeb414",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6d3d5e860a114ae606b1af2ba7f64cb19fbeb414",
        "files": [
          "fs/udf/inode.c",
          "fs/udf/namei.c",
          "fs/udf/super.c",
          "fs/udf/udfdecl.h"
        ],
        "message": "udf: Make udf_read_inode() and udf_iget() return error\n\nCurrently __udf_read_inode() wasn't returning anything and we found out\nwhether we succeeded reading inode by checking whether inode is bad or\nnot. udf_iget() returned NULL on failure and inode pointer otherwise.\nMake these two functions properly propagate errors up the call stack and\nuse the return value in callers.\n\nSigned-off-by: Jan Kara <jack@suse.cz>",
        "before_after_code_files": [
          "fs/udf/inode.c||fs/udf/inode.c",
          "fs/udf/namei.c||fs/udf/namei.c",
          "fs/udf/super.c||fs/udf/super.c",
          "fs/udf/udfdecl.h||fs/udf/udfdecl.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/udf/inode.c||fs/udf/inode.c"
          ],
          "candidate": [
            "fs/udf/inode.c||fs/udf/inode.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/udf/inode.c||fs/udf/inode.c": [
          "File: fs/udf/inode.c -> fs/udf/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1278: #define UDF_MAX_ICB_NESTING 1024",
          "1281: {",
          "1282:  struct buffer_head *bh = NULL;",
          "1283:  struct fileEntry *fe;",
          "",
          "[Removed Lines]",
          "1280: static void __udf_read_inode(struct inode *inode)",
          "",
          "[Added Lines]",
          "1280: static int udf_read_inode(struct inode *inode)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1285:  uint16_t ident;",
          "1286:  struct udf_inode_info *iinfo = UDF_I(inode);",
          "1287:  struct udf_sb_info *sbi = UDF_SB(inode->i_sb);",
          "1288:  unsigned int link_count;",
          "1289:  unsigned int indirections = 0;",
          "1291: reread:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1288:  struct kernel_lb_addr *iloc = &iinfo->i_location;",
          "1291:  int ret = -EIO;",
          "1294:  if (iloc->logicalBlockNum >=",
          "1295:      sbi->s_partmaps[iloc->partitionReferenceNum].s_partition_len) {",
          "1296:   udf_debug(\"block=%d, partition=%d out of range\\n\",",
          "1297:      iloc->logicalBlockNum, iloc->partitionReferenceNum);",
          "1298:   return -EIO;",
          "1299:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1305:  if (!bh) {",
          "1306:   udf_err(inode->i_sb, \"(ino %ld) failed !bh\\n\", inode->i_ino);",
          "1309:  }",
          "1311:  if (ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE &&",
          "1312:      ident != TAG_IDENT_USE) {",
          "1313:   udf_err(inode->i_sb, \"(ino %ld) failed ident=%d\\n\",",
          "1314:    inode->i_ino, ident);",
          "1318:  }",
          "1320:  fe = (struct fileEntry *)bh->b_data;",
          "",
          "[Removed Lines]",
          "1304:  bh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 0, &ident);",
          "1307:   make_bad_inode(inode);",
          "1308:   return;",
          "1315:   brelse(bh);",
          "1316:   make_bad_inode(inode);",
          "1317:   return;",
          "",
          "[Added Lines]",
          "1313:  bh = udf_read_ptagged(inode->i_sb, iloc, 0, &ident);",
          "1316:   return -EIO;",
          "1323:   goto out;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1323:  if (fe->icbTag.strategyType == cpu_to_le16(4096)) {",
          "1324:   struct buffer_head *ibh;",
          "1328:   if (ident == TAG_IDENT_IE && ibh) {",
          "1329:    struct kernel_lb_addr loc;",
          "1330:    struct indirectEntry *ie;",
          "",
          "[Removed Lines]",
          "1326:   ibh = udf_read_ptagged(inode->i_sb, &iinfo->i_location, 1,",
          "1327:      &ident);",
          "",
          "[Added Lines]",
          "1332:   ibh = udf_read_ptagged(inode->i_sb, iloc, 1, &ident);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1333:    loc = lelb_to_cpu(ie->indirectICB.extLocation);",
          "1335:    if (ie->indirectICB.extLength) {",
          "1337:     brelse(ibh);",
          "1338:     memcpy(&iinfo->i_location, &loc,",
          "1339:            sizeof(struct kernel_lb_addr));",
          "",
          "[Removed Lines]",
          "1336:     brelse(bh);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1342:       \"too many ICBs in ICB hierarchy\"",
          "1343:       \" (max %d supported)\\n\",",
          "1344:       UDF_MAX_ICB_NESTING);",
          "1347:     }",
          "1348:     goto reread;",
          "1349:    }",
          "1350:   }",
          "",
          "[Removed Lines]",
          "1345:      make_bad_inode(inode);",
          "1346:      return;",
          "",
          "[Added Lines]",
          "1349:      goto out;",
          "1351:     brelse(bh);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1352:  } else if (fe->icbTag.strategyType != cpu_to_le16(4)) {",
          "1353:   udf_err(inode->i_sb, \"unsupported strategy type: %d\\n\",",
          "1354:    le16_to_cpu(fe->icbTag.strategyType));",
          "1358:  }",
          "1359:  if (fe->icbTag.strategyType == cpu_to_le16(4))",
          "1360:   iinfo->i_strat4096 = 0;",
          "",
          "[Removed Lines]",
          "1355:   brelse(bh);",
          "1356:   make_bad_inode(inode);",
          "1357:   return;",
          "",
          "[Added Lines]",
          "1359:   goto out;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1372:  if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {",
          "1373:   iinfo->i_efe = 1;",
          "1374:   iinfo->i_use = 0;",
          "1380:   memcpy(iinfo->i_ext.i_data,",
          "1381:          bh->b_data + sizeof(struct extendedFileEntry),",
          "1382:          inode->i_sb->s_blocksize -",
          "",
          "[Removed Lines]",
          "1375:   if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -",
          "1376:      sizeof(struct extendedFileEntry))) {",
          "1377:    make_bad_inode(inode);",
          "1378:    return;",
          "1379:   }",
          "",
          "[Added Lines]",
          "1377:   ret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -",
          "1378:      sizeof(struct extendedFileEntry));",
          "1379:   if (ret)",
          "1380:    goto out;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1384:  } else if (fe->descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {",
          "1385:   iinfo->i_efe = 0;",
          "1386:   iinfo->i_use = 0;",
          "1392:   memcpy(iinfo->i_ext.i_data,",
          "1393:          bh->b_data + sizeof(struct fileEntry),",
          "1394:          inode->i_sb->s_blocksize - sizeof(struct fileEntry));",
          "",
          "[Removed Lines]",
          "1387:   if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -",
          "1388:       sizeof(struct fileEntry))) {",
          "1389:    make_bad_inode(inode);",
          "1390:    return;",
          "1391:   }",
          "",
          "[Added Lines]",
          "1388:   ret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -",
          "1389:       sizeof(struct fileEntry));",
          "1390:   if (ret)",
          "1391:    goto out;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1398:   iinfo->i_lenAlloc = le32_to_cpu(",
          "1399:     ((struct unallocSpaceEntry *)bh->b_data)->",
          "1400:      lengthAllocDescs);",
          "1406:   memcpy(iinfo->i_ext.i_data,",
          "1407:          bh->b_data + sizeof(struct unallocSpaceEntry),",
          "1408:          inode->i_sb->s_blocksize -",
          "1409:      sizeof(struct unallocSpaceEntry));",
          "1411:  }",
          "1413:  read_lock(&sbi->s_cred_lock);",
          "1414:  i_uid_write(inode, le32_to_cpu(fe->uid));",
          "1415:  if (!uid_valid(inode->i_uid) ||",
          "",
          "[Removed Lines]",
          "1401:   if (udf_alloc_i_data(inode, inode->i_sb->s_blocksize -",
          "1402:      sizeof(struct unallocSpaceEntry))) {",
          "1403:    make_bad_inode(inode);",
          "1404:    return;",
          "1405:   }",
          "1410:   return;",
          "",
          "[Added Lines]",
          "1401:   ret = udf_alloc_i_data(inode, inode->i_sb->s_blocksize -",
          "1402:      sizeof(struct unallocSpaceEntry));",
          "1403:   if (ret)",
          "1404:    goto out;",
          "1409:   return 0;",
          "1412:  ret = -EIO;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1531:  default:",
          "1532:   udf_err(inode->i_sb, \"(ino %ld) failed unknown file type=%d\\n\",",
          "1533:    inode->i_ino, fe->icbTag.fileType);",
          "1536:  }",
          "1537:  if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {",
          "1538:   struct deviceSpec *dsea =",
          "",
          "[Removed Lines]",
          "1534:   make_bad_inode(inode);",
          "1535:   return;",
          "",
          "[Added Lines]",
          "1534:   goto out;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1543:           le32_to_cpu(dsea->minorDeviceIdent)));",
          "1545:   } else",
          "1547:  }",
          "1548:  brelse(bh);",
          "1549: }",
          "1551: static int udf_alloc_i_data(struct inode *inode, size_t size)",
          "",
          "[Removed Lines]",
          "1546:    make_bad_inode(inode);",
          "",
          "[Added Lines]",
          "1545:    goto out;",
          "1547:  ret = 0;",
          "1548: out:",
          "1550:  return ret;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1825: {",
          "1826:  unsigned long block = udf_get_lb_pblock(sb, ino, 0);",
          "1827:  struct inode *inode = iget_locked(sb, block);",
          "1829:  if (!inode)",
          "1847:  }",
          "1849:  return inode;",
          "1854: }",
          "1856: int udf_add_aext(struct inode *inode, struct extent_position *epos,",
          "",
          "[Removed Lines]",
          "1830:   return NULL;",
          "1832:  if (inode->i_state & I_NEW) {",
          "1833:   memcpy(&UDF_I(inode)->i_location, ino, sizeof(struct kernel_lb_addr));",
          "1834:   __udf_read_inode(inode);",
          "1835:   unlock_new_inode(inode);",
          "1836:  }",
          "1838:  if (is_bad_inode(inode))",
          "1839:   goto out_iput;",
          "1841:  if (ino->logicalBlockNum >= UDF_SB(sb)->",
          "1842:    s_partmaps[ino->partitionReferenceNum].s_partition_len) {",
          "1843:   udf_debug(\"block=%d, partition=%d out of range\\n\",",
          "1844:      ino->logicalBlockNum, ino->partitionReferenceNum);",
          "1845:   make_bad_inode(inode);",
          "1846:   goto out_iput;",
          "1851:  out_iput:",
          "1852:  iput(inode);",
          "1853:  return NULL;",
          "",
          "[Added Lines]",
          "1830:  int err;",
          "1833:   return ERR_PTR(-ENOMEM);",
          "1835:  if (!(inode->i_state & I_NEW))",
          "1836:   return inode;",
          "1838:  memcpy(&UDF_I(inode)->i_location, ino, sizeof(struct kernel_lb_addr));",
          "1839:  err = udf_read_inode(inode);",
          "1840:  if (err < 0) {",
          "1841:   iget_failed(inode);",
          "1842:   return ERR_PTR(err);",
          "1844:  unlock_new_inode(inode);",
          "",
          "---------------"
        ],
        "fs/udf/namei.c||fs/udf/namei.c": [
          "File: fs/udf/namei.c -> fs/udf/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "270:       NULL, 0),",
          "271:   };",
          "272:   inode = udf_iget(dir->i_sb, lb);",
          "276:  } else",
          "",
          "[Removed Lines]",
          "273:   if (!inode) {",
          "274:    return ERR_PTR(-EACCES);",
          "275:   }",
          "",
          "[Added Lines]",
          "273:   if (IS_ERR(inode))",
          "274:    return inode;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "286:   loc = lelb_to_cpu(cfi.icb.extLocation);",
          "287:   inode = udf_iget(dir->i_sb, &loc);",
          "291:  }",
          "293:  return d_splice_alias(inode, dentry);",
          "",
          "[Removed Lines]",
          "288:   if (!inode) {",
          "289:    return ERR_PTR(-EACCES);",
          "290:   }",
          "",
          "[Added Lines]",
          "287:   if (IS_ERR(inode))",
          "288:    return ERR_CAST(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1222:  struct udf_fileident_bh fibh;",
          "1224:  if (!udf_find_entry(child->d_inode, &dotdot, &fibh, &cfi))",
          "1227:  if (fibh.sbh != fibh.ebh)",
          "1228:   brelse(fibh.ebh);",
          "",
          "[Removed Lines]",
          "1225:   goto out_unlock;",
          "",
          "[Added Lines]",
          "1223:   return ERR_PTR(-EACCES);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1231:  tloc = lelb_to_cpu(cfi.icb.extLocation);",
          "1232:  inode = udf_iget(child->d_inode->i_sb, &tloc);",
          "1236:  return d_obtain_alias(inode);",
          "1239: }",
          "",
          "[Removed Lines]",
          "1233:  if (!inode)",
          "1234:   goto out_unlock;",
          "1237: out_unlock:",
          "1238:  return ERR_PTR(-EACCES);",
          "",
          "[Added Lines]",
          "1231:  if (IS_ERR(inode))",
          "1232:   return ERR_CAST(inode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1252:  loc.partitionReferenceNum = partref;",
          "1253:  inode = udf_iget(sb, &loc);",
          "1258:  if (generation && inode->i_generation != generation) {",
          "1259:   iput(inode);",
          "",
          "[Removed Lines]",
          "1255:  if (inode == NULL)",
          "1256:   return ERR_PTR(-ENOMEM);",
          "",
          "[Added Lines]",
          "1251:  if (IS_ERR(inode))",
          "1252:   return ERR_CAST(inode);",
          "",
          "---------------"
        ],
        "fs/udf/super.c||fs/udf/super.c": [
          "File: fs/udf/super.c -> fs/udf/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "962:  metadata_fe = udf_iget(sb, &addr);",
          "965:   udf_warn(sb, \"metadata inode efe not found\\n\");",
          "967:   udf_warn(sb, \"metadata inode efe does not have short allocation descriptors!\\n\");",
          "968:   iput(metadata_fe);",
          "970:  }",
          "972:  return metadata_fe;",
          "",
          "[Removed Lines]",
          "964:  if (metadata_fe == NULL)",
          "966:  else if (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {",
          "969:   metadata_fe = NULL;",
          "",
          "[Added Lines]",
          "964:  if (IS_ERR(metadata_fe)) {",
          "966:   return metadata_fe;",
          "967:  }",
          "968:  if (UDF_I(metadata_fe)->i_alloc_type != ICBTAG_FLAG_AD_SHORT) {",
          "971:   return ERR_PTR(-EIO);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "978:  struct udf_part_map *map;",
          "979:  struct udf_meta_data *mdata;",
          "980:  struct kernel_lb_addr addr;",
          "982:  map = &sbi->s_partmaps[partition];",
          "983:  mdata = &map->s_type_specific.s_metadata;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "983:  struct inode *fe;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "986:  udf_debug(\"Metadata file location: block = %d part = %d\\n\",",
          "987:     mdata->s_meta_file_loc, map->s_partition_num);",
          "994:   udf_debug(\"Mirror metadata file location: block = %d part = %d\\n\",",
          "995:      mdata->s_mirror_file_loc, map->s_partition_num);",
          "1001:    udf_err(sb, \"Both metadata and mirror metadata inode efe can not found\\n\");",
          "1003:   }",
          "",
          "[Removed Lines]",
          "989:  mdata->s_metadata_fe = udf_find_metadata_inode_efe(sb,",
          "990:   mdata->s_meta_file_loc, map->s_partition_num);",
          "992:  if (mdata->s_metadata_fe == NULL) {",
          "997:   mdata->s_mirror_fe = udf_find_metadata_inode_efe(sb,",
          "998:    mdata->s_mirror_file_loc, map->s_partition_num);",
          "1000:   if (mdata->s_mirror_fe == NULL) {",
          "1002:    return -EIO;",
          "1004:  }",
          "",
          "[Added Lines]",
          "992:  fe = udf_find_metadata_inode_efe(sb, mdata->s_meta_file_loc,",
          "993:       map->s_partition_num);",
          "994:  if (IS_ERR(fe)) {",
          "999:   fe = udf_find_metadata_inode_efe(sb, mdata->s_mirror_file_loc,",
          "1000:        map->s_partition_num);",
          "1002:   if (IS_ERR(fe)) {",
          "1004:    return PTR_ERR(fe);",
          "1006:   mdata->s_mirror_fe = fe;",
          "1007:  } else",
          "1008:   mdata->s_metadata_fe = fe;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1015:   udf_debug(\"Bitmap file location: block = %d part = %d\\n\",",
          "1016:      addr.logicalBlockNum, addr.partitionReferenceNum);",
          "1020:    if (sb->s_flags & MS_RDONLY)",
          "1021:     udf_warn(sb, \"bitmap inode efe not found but it's ok since the disc is mounted read-only\\n\");",
          "1022:    else {",
          "1023:     udf_err(sb, \"bitmap inode efe not found and attempted read-write mount\\n\");",
          "1025:    }",
          "1027:  }",
          "1029:  udf_debug(\"udf_load_metadata_files Ok\\n\");",
          "",
          "[Removed Lines]",
          "1018:   mdata->s_bitmap_fe = udf_iget(sb, &addr);",
          "1019:   if (mdata->s_bitmap_fe == NULL) {",
          "1024:     return -EIO;",
          "1026:   }",
          "",
          "[Added Lines]",
          "1023:   fe = udf_iget(sb, &addr);",
          "1024:   if (IS_ERR(fe)) {",
          "1029:     return PTR_ERR(fe);",
          "1031:   } else",
          "1032:    mdata->s_bitmap_fe = fe;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1111:     phd->unallocSpaceTable.extPosition),",
          "1112:    .partitionReferenceNum = p_index,",
          "1113:   };",
          "1117:    udf_debug(\"cannot load unallocSpaceTable (part %d)\\n\",",
          "1118:       p_index);",
          "1120:   }",
          "1121:   map->s_partition_flags |= UDF_PART_FLAG_UNALLOC_TABLE;",
          "1122:   udf_debug(\"unallocSpaceTable (part %d) @ %ld\\n\",",
          "1123:      p_index, map->s_uspace.s_table->i_ino);",
          "",
          "[Removed Lines]",
          "1115:   map->s_uspace.s_table = udf_iget(sb, &loc);",
          "1116:   if (!map->s_uspace.s_table) {",
          "1119:    return -EIO;",
          "",
          "[Added Lines]",
          "1120:   struct inode *inode;",
          "1122:   inode = udf_iget(sb, &loc);",
          "1123:   if (IS_ERR(inode)) {",
          "1126:    return PTR_ERR(inode);",
          "1128:   map->s_uspace.s_table = inode;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1144:     phd->freedSpaceTable.extPosition),",
          "1145:    .partitionReferenceNum = p_index,",
          "1146:   };",
          "1150:    udf_debug(\"cannot load freedSpaceTable (part %d)\\n\",",
          "1151:       p_index);",
          "1153:   }",
          "1155:   map->s_partition_flags |= UDF_PART_FLAG_FREED_TABLE;",
          "1156:   udf_debug(\"freedSpaceTable (part %d) @ %ld\\n\",",
          "1157:      p_index, map->s_fspace.s_table->i_ino);",
          "",
          "[Removed Lines]",
          "1148:   map->s_fspace.s_table = udf_iget(sb, &loc);",
          "1149:   if (!map->s_fspace.s_table) {",
          "1152:    return -EIO;",
          "",
          "[Added Lines]",
          "1155:   struct inode *inode;",
          "1157:   inode = udf_iget(sb, &loc);",
          "1158:   if (IS_ERR(inode)) {",
          "1161:    return PTR_ERR(inode);",
          "1163:   map->s_fspace.s_table = inode;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1178:  struct udf_part_map *map = &sbi->s_partmaps[p_index];",
          "1179:  sector_t vat_block;",
          "1180:  struct kernel_lb_addr ino;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1190:  struct inode *inode;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1186:  ino.partitionReferenceNum = type1_index;",
          "1187:  for (vat_block = start_block;",
          "1188:       vat_block >= map->s_partition_root &&",
          "1191:   ino.logicalBlockNum = vat_block - map->s_partition_root;",
          "1193:  }",
          "1194: }",
          "",
          "[Removed Lines]",
          "1189:       vat_block >= start_block - 3 &&",
          "1190:       !sbi->s_vat_inode; vat_block--) {",
          "1192:   sbi->s_vat_inode = udf_iget(sb, &ino);",
          "",
          "[Added Lines]",
          "1199:       vat_block >= start_block - 3; vat_block--) {",
          "1201:   inode = udf_iget(sb, &ino);",
          "1202:   if (!IS_ERR(inode)) {",
          "1203:    sbi->s_vat_inode = inode;",
          "1204:    break;",
          "1205:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2207:  inode = udf_iget(sb, &rootdir);",
          "2209:   udf_err(sb, \"Error in udf_iget, block=%d, partition=%d\\n\",",
          "2210:          rootdir.logicalBlockNum, rootdir.partitionReferenceNum);",
          "2212:   goto error_out;",
          "2213:  }",
          "",
          "[Removed Lines]",
          "2208:  if (!inode) {",
          "2211:   ret = -EIO;",
          "",
          "[Added Lines]",
          "2221:  if (IS_ERR(inode)) {",
          "2224:   ret = PTR_ERR(inode);",
          "",
          "---------------"
        ],
        "fs/udf/udfdecl.h||fs/udf/udfdecl.h": [
          "File: fs/udf/udfdecl.h -> fs/udf/udfdecl.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "143: extern struct buffer_head *udf_expand_dir_adinicb(struct inode *, int *, int *);",
          "144: extern struct buffer_head *udf_bread(struct inode *, int, int, int *);",
          "145: extern int udf_setsize(struct inode *, loff_t);",
          "147: extern void udf_evict_inode(struct inode *);",
          "148: extern int udf_write_inode(struct inode *, struct writeback_control *wbc);",
          "149: extern long udf_block_map(struct inode *, sector_t);",
          "",
          "[Removed Lines]",
          "146: extern void udf_read_inode(struct inode *);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-32166",
  "cve_desc": "In ovs versions v0.90.0 through v2.5.0 are vulnerable to heap buffer over-read in flow.c. An unsafe comparison of \u201cminimasks\u201d function could lead access to an unmapped region of memory. This vulnerability is capable of crashing the software, memory modification, and possible remote execution.",
  "repo": "cloudbase/ovs",
  "patch_hash": "2ed6505555cdcb46f9b1f0329d1491b75290fc73",
  "patch_info": {
    "commit_hash": "2ed6505555cdcb46f9b1f0329d1491b75290fc73",
    "repo": "cloudbase/ovs",
    "commit_url": "https://github.com/cloudbase/ovs/commit/2ed6505555cdcb46f9b1f0329d1491b75290fc73",
    "files": [
      "lib/flow.c"
    ],
    "message": "flow: Avoid unsafe comparison of minimasks.\n\nThe following, run inside the OVS sandbox, caused OVS to abort when\nAddress Sanitizer was used:\n\n    ovs-vsctl add-br br-int\n    ovs-ofctl add-flow br-int \"table=0,cookie=0x1234,priority=10000,icmp,actions=drop\"\n    ovs-ofctl --strict del-flows br-int \"table=0,cookie=0x1234/-1,priority=10000\"\n\nSample report from Address Sanitizer:\n\n==3029==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000043260 at pc 0x7f6b09c2459b bp 0x7ffcb67e7540 sp 0x7ffcb67e6cf0\nREAD of size 40 at 0x603000043260 thread T0\n    #0 0x7f6b09c2459a  (/lib/x86_64-linux-gnu/libasan.so.5+0xb859a)\n    #1 0x565110a748a5 in minimask_equal ../lib/flow.c:3510\n    #2 0x565110a9ea41 in minimatch_equal ../lib/match.c:1821\n    #3 0x56511091e864 in collect_rules_strict ../ofproto/ofproto.c:4516\n    #4 0x56511093d526 in delete_flow_start_strict ../ofproto/ofproto.c:5959\n    #5 0x56511093d526 in ofproto_flow_mod_start ../ofproto/ofproto.c:7949\n    #6 0x56511093d77b in handle_flow_mod__ ../ofproto/ofproto.c:6122\n    #7 0x56511093db71 in handle_flow_mod ../ofproto/ofproto.c:6099\n    #8 0x5651109407f6 in handle_single_part_openflow ../ofproto/ofproto.c:8406\n    #9 0x5651109407f6 in handle_openflow ../ofproto/ofproto.c:8587\n    #10 0x5651109e40da in ofconn_run ../ofproto/connmgr.c:1318\n    #11 0x5651109e40da in connmgr_run ../ofproto/connmgr.c:355\n    #12 0x56511092b129 in ofproto_run ../ofproto/ofproto.c:1826\n    #13 0x5651108f23cd in bridge_run__ ../vswitchd/bridge.c:2965\n    #14 0x565110904887 in bridge_run ../vswitchd/bridge.c:3023\n    #15 0x5651108e659c in main ../vswitchd/ovs-vswitchd.c:127\n    #16 0x7f6b093b709a in __libc_start_main ../csu/libc-start.c:308\n    #17 0x5651108e9009 in _start (/home/blp/nicira/ovs/_build/vswitchd/ovs-vswitchd+0x11d009)\n\nThis fixes the problem, which although largely theoretical could crop up\nwith odd implementations of memcmp(), perhaps ones optimized in various\n\"clever\" ways.  All in all, it seems best to avoid the theoretical problem.\n\nAcked-by: Dumitru Ceara <dceara@redhat.com>\nSigned-off-by: Ben Pfaff <blp@ovn.org>",
    "before_after_code_files": [
      "lib/flow.c||lib/flow.c"
    ]
  },
  "patch_diff": {
    "lib/flow.c||lib/flow.c": [
      "File: lib/flow.c -> lib/flow.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3511: {",
      "3512:     return !memcmp(a, b, sizeof *a",
      "3513:                    + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));",
      "",
      "[Removed Lines]",
      "3509: bool",
      "3510: minimask_equal(const struct minimask *a, const struct minimask *b)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "902c5ffd3360b05ad344f7f4f5ee0301ae331a53",
      "candidate_info": {
        "commit_hash": "902c5ffd3360b05ad344f7f4f5ee0301ae331a53",
        "repo": "cloudbase/ovs",
        "commit_url": "https://github.com/cloudbase/ovs/commit/902c5ffd3360b05ad344f7f4f5ee0301ae331a53",
        "files": [
          "datapath/linux/compat/include/net/dst_metadata.h",
          "datapath/linux/compat/ip_tunnel.c"
        ],
        "message": "compat: iptunnel: NULL pointer deref for ip_md_tunnel_xmit\n\nUpstream commit:\n    commit f4b3ec4e6aa1a2ca437905a519ae08e8cf6af754\n    Author: Alan Maguire <alan.maguire@oracle.com>\n    Date:   Wed Mar 6 10:25:42 2019 +0000\n\n    iptunnel: NULL pointer deref for ip_md_tunnel_xmit\n\n    Naresh Kamboju noted the following oops during execution of selftest\n    tools/testing/selftests/bpf/test_tunnel.sh on x86_64:\n\n    [  274.120445] BUG: unable to handle kernel NULL pointer dereference\n    at 0000000000000000\n    [  274.128285] #PF error: [INSTR]\n    [  274.131351] PGD 8000000414a0e067 P4D 8000000414a0e067 PUD 3b6334067 PMD 0\n    [  274.138241] Oops: 0010 [#1] SMP PTI\n    [  274.141734] CPU: 1 PID: 11464 Comm: ping Not tainted\n    5.0.0-rc4-next-20190129 #1\n    [  274.149046] Hardware name: Supermicro SYS-5019S-ML/X11SSH-F, BIOS\n    2.0b 07/27/2017\n    [  274.156526] RIP: 0010:          (null)\n    [  274.160280] Code: Bad RIP value.\n    [  274.163509] RSP: 0018:ffffbc9681f83540 EFLAGS: 00010286\n    [  274.168726] RAX: 0000000000000000 RBX: ffffdc967fa80a18 RCX: 0000000000000000\n    [  274.175851] RDX: ffff9db2ee08b540 RSI: 000000000000000e RDI: ffffdc967fa809a0\n    [  274.182974] RBP: ffffbc9681f83580 R08: ffff9db2c4d62690 R09: 000000000000000c\n    [  274.190098] R10: 0000000000000000 R11: ffff9db2ee08b540 R12: ffff9db31ce7c000\n    [  274.197222] R13: 0000000000000001 R14: 000000000000000c R15: ffff9db3179cf400\n    [  274.204346] FS:  00007ff4ae7c5740(0000) GS:ffff9db31fa80000(0000)\n    knlGS:0000000000000000\n    [  274.212424] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    [  274.218162] CR2: ffffffffffffffd6 CR3: 00000004574da004 CR4: 00000000003606e0\n    [  274.225292] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    [  274.232416] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n    [  274.239541] Call Trace:\n    [  274.241988]  ? tnl_update_pmtu+0x296/0x3b0\n    [  274.246085]  ip_md_tunnel_xmit+0x1bc/0x520\n    [  274.250176]  gre_fb_xmit+0x330/0x390\n    [  274.253754]  gre_tap_xmit+0x128/0x180\n    [  274.257414]  dev_hard_start_xmit+0xb7/0x300\n    [  274.261598]  sch_direct_xmit+0xf6/0x290\n    [  274.265430]  __qdisc_run+0x15d/0x5e0\n    [  274.269007]  __dev_queue_xmit+0x2c5/0xc00\n    [  274.273011]  ? dev_queue_xmit+0x10/0x20\n    [  274.276842]  ? eth_header+0x2b/0xc0\n    [  274.280326]  dev_queue_xmit+0x10/0x20\n    [  274.283984]  ? dev_queue_xmit+0x10/0x20\n    [  274.287813]  arp_xmit+0x1a/0xf0\n    [  274.290952]  arp_send_dst.part.19+0x46/0x60\n    [  274.295138]  arp_solicit+0x177/0x6b0\n    [  274.298708]  ? mod_timer+0x18e/0x440\n    [  274.302281]  neigh_probe+0x57/0x70\n    [  274.305684]  __neigh_event_send+0x197/0x2d0\n    [  274.309862]  neigh_resolve_output+0x18c/0x210\n    [  274.314212]  ip_finish_output2+0x257/0x690\n    [  274.318304]  ip_finish_output+0x219/0x340\n    [  274.322314]  ? ip_finish_output+0x219/0x340\n    [  274.326493]  ip_output+0x76/0x240\n    [  274.329805]  ? ip_fragment.constprop.53+0x80/0x80\n    [  274.334510]  ip_local_out+0x3f/0x70\n    [  274.337992]  ip_send_skb+0x19/0x40\n    [  274.341391]  ip_push_pending_frames+0x33/0x40\n    [  274.345740]  raw_sendmsg+0xc15/0x11d0\n    [  274.349403]  ? __might_fault+0x85/0x90\n    [  274.353151]  ? _copy_from_user+0x6b/0xa0\n    [  274.357070]  ? rw_copy_check_uvector+0x54/0x130\n    [  274.361604]  inet_sendmsg+0x42/0x1c0\n    [  274.365179]  ? inet_sendmsg+0x42/0x1c0\n    [  274.368937]  sock_sendmsg+0x3e/0x50\n    [  274.372460]  ___sys_sendmsg+0x26f/0x2d0\n    [  274.376293]  ? lock_acquire+0x95/0x190\n    [  274.380043]  ? __handle_mm_fault+0x7ce/0xb70\n    [  274.384307]  ? lock_acquire+0x95/0x190\n    [  274.388053]  ? __audit_syscall_entry+0xdd/0x130\n    [  274.392586]  ? ktime_get_coarse_real_ts64+0x64/0xc0\n    [  274.397461]  ? __audit_syscall_entry+0xdd/0x130\n    [  274.401989]  ? trace_hardirqs_on+0x4c/0x100\n    [  274.406173]  __sys_sendmsg+0x63/0xa0\n    [  274.409744]  ? __sys_sendmsg+0x63/0xa0\n    [  274.413488]  __x64_sys_sendmsg+0x1f/0x30\n    [  274.417405]  do_syscall_64+0x55/0x190\n    [  274.421064]  entry_SYSCALL_64_after_hwframe+0x49/0xbe\n    [  274.426113] RIP: 0033:0x7ff4ae0e6e87\n    [  274.429686] Code: 64 89 02 48 c7 c0 ff ff ff ff eb b9 0f 1f 80 00\n    00 00 00 8b 05 ca d9 2b 00 48 63 d2 48 63 ff 85 c0 75 10 b8 2e 00 00\n    00 0f 05 <48> 3d 00 f0 ff ff 77 51 c3 53 48 89 f3 48 83 ec 10 48 89 7c\n    24 08\n    [  274.448422] RSP: 002b:00007ffcd9b76db8 EFLAGS: 00000246 ORIG_RAX:\n    000000000000002e\n    [  274.455978] RAX: ffffffffffffffda RBX: 0000000000000040 RCX: 00007ff4ae0e6e87\n    [  274.463104] RDX: 0000000000000000 RSI: 00000000006092e0 RDI: 0000000000000003\n    [  274.470228] RBP: 0000000000000000 R08: 00007ffcd9bc40a0 R09: 00007ffcd9bc4080\n    [  274.477349] R10: 000000000000060a R11: 0000000000000246 R12: 0000000000000003\n    [  274.484475] R13: 0000000000000016 R14: 00007ffcd9b77fa0 R15: 00007ffcd9b78da4\n    [  274.491602] Modules linked in: cls_bpf sch_ingress iptable_filter\n    ip_tables algif_hash af_alg x86_pkg_temp_thermal fuse [last unloaded:\n    test_bpf]\n    [  274.504634] CR2: 0000000000000000\n    [  274.507976] ---[ end trace 196d18386545eae1 ]---\n    [  274.512588] RIP: 0010:          (null)\n    [  274.516334] Code: Bad RIP value.\n    [  274.519557] RSP: 0018:ffffbc9681f83540 EFLAGS: 00010286\n    [  274.524775] RAX: 0000000000000000 RBX: ffffdc967fa80a18 RCX: 0000000000000000\n    [  274.531921] RDX: ffff9db2ee08b540 RSI: 000000000000000e RDI: ffffdc967fa809a0\n    [  274.539082] RBP: ffffbc9681f83580 R08: ffff9db2c4d62690 R09: 000000000000000c\n    [  274.546205] R10: 0000000000000000 R11: ffff9db2ee08b540 R12: ffff9db31ce7c000\n    [  274.553329] R13: 0000000000000001 R14: 000000000000000c R15: ffff9db3179cf400\n    [  274.560456] FS:  00007ff4ae7c5740(0000) GS:ffff9db31fa80000(0000)\n    knlGS:0000000000000000\n    [  274.568541] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n    [  274.574277] CR2: ffffffffffffffd6 CR3: 00000004574da004 CR4: 00000000003606e0\n    [  274.581403] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n    [  274.588535] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n    [  274.595658] Kernel panic - not syncing: Fatal exception in interrupt\n    [  274.602046] Kernel Offset: 0x14400000 from 0xffffffff81000000\n    (relocation range: 0xffffffff80000000-0xffffffffbfffffff)\n    [  274.612827] ---[ end Kernel panic - not syncing: Fatal exception in\n    interrupt ]---\n    [  274.620387] ------------[ cut here ]------------\n\n    I'm also seeing the same failure on x86_64, and it reproduces\n    consistently.\n\n    >From poking around it looks like the skb's dst entry is being used\n    to calculate the mtu in:\n\n    mtu = skb_dst(skb) ? dst_mtu(skb_dst(skb)) : dev->mtu;\n\n    ...but because that dst_entry  has an \"ops\" value set to md_dst_ops,\n    the various ops (including mtu) are not set:\n\n    crash> struct sk_buff._skb_refdst ffff928f87447700 -x\n          _skb_refdst = 0xffffcd6fbf5ea590\n    crash> struct dst_entry.ops 0xffffcd6fbf5ea590\n      ops = 0xffffffffa0193800\n    crash> struct dst_ops.mtu 0xffffffffa0193800\n      mtu = 0x0\n    crash>\n\n    I confirmed that the dst entry also has dst->input set to\n    dst_md_discard, so it looks like it's an entry that's been\n    initialized via __metadata_dst_init alright.\n\n    I think the fix here is to use skb_valid_dst(skb) - it checks\n    for  DST_METADATA also, and with that fix in place, the\n    problem - which was previously 100% reproducible - disappears.\n\n    The below patch resolves the panic and all bpf tunnel tests pass\n    without incident.\n\n    Fixes: c8b34e680a09 (\"ip_tunnel: Add tnl_update_pmtu in ip_md_tunnel_xmit\")\n    Reported-by: Naresh Kamboju <naresh.kamboju@linaro.org>\n    Signed-off-by: Alan Maguire <alan.maguire@oracle.com>\n    Acked-by: Alexei Starovoitov <ast@kernel.org>\n    Tested-by: Anders Roxell <anders.roxell@linaro.org>\n    Reported-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\n    Tested-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\n    Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\n    Signed-off-by: David S. Miller <davem@davemloft.net>\n\nFixed up for backward compatibility to our own compat layer ip_tunnel.c\nmodule.\n\nCc: Alan Maguire <alan.maguire@oracle.com>\nReviewed-by: Yifeng Sun <pkusunyifeng@gmail.com>\nSigned-off-by: Greg Rose <gvrose8192@gmail.com>\nSigned-off-by: Ben Pfaff <blp@ovn.org>",
        "before_after_code_files": [
          "datapath/linux/compat/include/net/dst_metadata.h||datapath/linux/compat/include/net/dst_metadata.h",
          "datapath/linux/compat/ip_tunnel.c||datapath/linux/compat/ip_tunnel.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "datapath/linux/compat/include/net/dst_metadata.h||datapath/linux/compat/include/net/dst_metadata.h": [
          "File: datapath/linux/compat/include/net/dst_metadata.h -> datapath/linux/compat/include/net/dst_metadata.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "127: }",
          "128: #define metadata_dst_alloc rpl_metadata_dst_alloc",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "130: #ifndef DST_METADATA",
          "131: #define DST_METADATA  0x0200",
          "132: #endif",
          "134: static inline bool rpl_skb_valid_dst(const struct sk_buff *skb)",
          "135: {",
          "136:  struct dst_entry *dst = skb_dst(skb);",
          "138:  return dst && !(dst->flags & DST_METADATA);",
          "139: }",
          "140: #define skb_valid_dst rpl_skb_valid_dst",
          "",
          "---------------"
        ],
        "datapath/linux/compat/ip_tunnel.c||datapath/linux/compat/ip_tunnel.c": [
          "File: datapath/linux/compat/ip_tunnel.c -> datapath/linux/compat/ip_tunnel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "51: #include <net/net_namespace.h>",
          "52: #include <net/netns/generic.h>",
          "53: #include <net/rtnetlink.h>",
          "55: #if IS_ENABLED(CONFIG_IPV6)",
          "56: #include <net/ipv6.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #include <net/dst_metadata.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "263:   mtu = dst_mtu(&rt->dst) - dev->hard_header_len",
          "264:      - sizeof(struct iphdr) - tunnel->hlen;",
          "265:  else",
          "269:   skb_dst(skb)->ops->update_pmtu(skb_dst(skb), NULL, skb, mtu);",
          "271:  if (skb->protocol == htons(ETH_P_IP)) {",
          "",
          "[Removed Lines]",
          "266:   mtu = skb_dst(skb) ? dst_mtu(skb_dst(skb)) : dev->mtu;",
          "268:  if (skb_dst(skb))",
          "",
          "[Added Lines]",
          "267:   mtu = skb_valid_dst(skb) ? dst_mtu(skb_dst(skb)) : dev->mtu;",
          "269:  if (skb_valid_dst(skb))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "279:  }",
          "280: #if IS_ENABLED(CONFIG_IPV6)",
          "281:  else if (skb->protocol == htons(ETH_P_IPV6)) {",
          "284:   if (rt6 && mtu < dst_mtu(skb_dst(skb)) &&",
          "285:       mtu >= IPV6_MIN_MTU) {",
          "",
          "[Removed Lines]",
          "282:   struct rt6_info *rt6 = (struct rt6_info *)skb_dst(skb);",
          "",
          "[Added Lines]",
          "283:   struct rt6_info *rt6;",
          "285:   rt6 = skb_valid_dst(skb) ? (struct rt6_info *)skb_dst(skb) :",
          "286:         NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9560a18bffb9fe04f006087dbcf742defb489754",
      "candidate_info": {
        "commit_hash": "9560a18bffb9fe04f006087dbcf742defb489754",
        "repo": "cloudbase/ovs",
        "commit_url": "https://github.com/cloudbase/ovs/commit/9560a18bffb9fe04f006087dbcf742defb489754",
        "files": [
          "lib/conntrack.c"
        ],
        "message": "conntrack: Reset ct_state when entering a new zone.\n\nWhen a new conntrack zone is entered, the ct_state field is zeroed in\norder to avoid using state information from different zones.\n\nOne such scenario is when a packet is double NATed. Assuming two zones\nand 3 flows performing the following actions in order on the packet:\n1. ct(zone=5,nat), recirc\n2. ct(zone=1), recirc\n3. ct(zone=1,nat)\n\nIf at step #1 the packet matches an existing NAT entry, it will get\ntranslated and pkt->md.ct_state is set to CS_DST_NAT or CS_SRC_NAT.\nAt step #2 the new tuple might match an existing connection and\npkt->md.ct_zone is set to 1.\nIf at step #3 the packet matches an existing NAT entry in zone 1,\nhandle_nat() will be called to perform the translation but it will\nreturn early because the packet's zone matches the conntrack zone and\nthe ct_state field still contains CS_DST_NAT or CS_SRC_NAT from the\ntranslations in zone 5.\n\nIn order to reliably detect when a packet enters a new conntrack zone\nwe also need to make sure that the pkt->md.ct_zone is properly\ninitialized if pkt->md.ct_state is non-zero. This already happens for\nmost cases. The only exception is when matched conntrack connection is\nof type CT_CONN_TYPE_UN_NAT and the master connection is missing. To\ncover this path we now call write_ct_md() in that case too. Remove\nsetting the CS_TRACKED flag as in this case as it will be done by the\nnew call to write_ct_md().\n\nCC: Darrell Ball <dlu998@gmail.com>\nFixes: 286de2729955 (\"dpdk: Userspace Datapath: Introduce NAT Support.\")\nAcked-by: Ilya Maximets <i.maximets@ovn.org>\nAcked-by: Aaron Conole <aconole@redhat.com>\nSigned-off-by: Dumitru Ceara <dceara@redhat.com>\nSigned-off-by: Ilya Maximets <i.maximets@ovn.org>",
        "before_after_code_files": [
          "lib/conntrack.c||lib/conntrack.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/conntrack.c||lib/conntrack.c": [
          "File: lib/conntrack.c -> lib/conntrack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1096:             const struct ovs_key_ct_labels *setlabel,",
          "1097:             const struct nat_action_info_t *nat_action_info,",
          "1098:             ovs_be16 tp_src, ovs_be16 tp_dst, const char *helper)",
          "1099: {",
          "1100:     bool create_new_conn = false;",
          "1101:     conn_key_lookup(ct, &ctx->key, ctx->hash, now, &ctx->conn, &ctx->reply);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1101:     if (pkt->md.ct_state && pkt->md.ct_zone != zone) {",
          "1102:         pkt->md.ct_state = 0;",
          "1103:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1119:             uint32_t hash = conn_key_hash(&conn->rev_key, ct->hash_basis);",
          "1120:             conn_key_lookup(ct, &ctx->key, hash, now, &conn, &ctx->reply);",
          "1123:                 pkt->md.ct_state |= CS_TRACKED | CS_INVALID;",
          "1124:                 char *log_msg = xasprintf(\"Missing master conn %p\", rev_conn);",
          "1125:                 ct_print_conn_info(rev_conn, log_msg, VLL_INFO, true, true);",
          "",
          "[Removed Lines]",
          "1122:             if (!conn) {",
          "",
          "[Added Lines]",
          "1127:             if (!conn) {",
          "1128:                 pkt->md.ct_state |= CS_INVALID;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "69c51582ff786a68fc325c1c50624715482bc460",
      "candidate_info": {
        "commit_hash": "69c51582ff786a68fc325c1c50624715482bc460",
        "repo": "cloudbase/ovs",
        "commit_url": "https://github.com/cloudbase/ovs/commit/69c51582ff786a68fc325c1c50624715482bc460",
        "files": [
          "lib/dpif-netlink.c"
        ],
        "message": "dpif-netlink: don't allocate per thread netlink sockets\n\nWhen using the kernel datapath, OVS allocates a pool of sockets to handle\nnetlink events. The number of sockets is: ports * n-handler-threads, where\nn-handler-threads is user configurable and defaults to 3/4*number of cores.\n\nThis because vswitchd starts n-handler-threads threads, each one with a\nnetlink socket for every port of the switch. Every thread then, starts\nlistening on events on its set of sockets with epoll().\n\nOn setup with lot of CPUs and ports, the number of sockets easily hits\nthe process file descriptor limit, and ovs-vswitchd will exit with -EMFILE.\n\nChange the number of allocated sockets to just one per port by moving\nthe socket array from a per handler structure to a per datapath one,\nand let all the handlers share the same sockets by using EPOLLEXCLUSIVE\nepoll flag which avoids duplicate events, on systems that support it.\n\nThe patch was tested on a 56 core machine running Linux 4.18 and latest\nOpen vSwitch. A bridge was created with 2000+ ports, some of them being\nveth interfaces with the peer outside the bridge. The latency of the upcall\nis measured by setting a single 'action=controller,local' OpenFlow rule to\nforce all the packets going to the slow path and then to the local port.\nA tool[1] injects some packets to the veth outside the bridge, and measures\nthe delay until the packet is captured on the local port. The rx timestamp\nis get from the socket ancillary data in the attribute SO_TIMESTAMPNS, to\navoid having the scheduler delay in the measured time.\n\nThe first test measures the average latency for an upcall generated from\na single port. To measure it 100k packets, one every msec, are sent to a\nsingle port and the latencies are measured.\n\nThe second test is meant to check latency fairness among ports, namely if\nlatency is equal between ports or if some ports have lower priority.\nThe previous test is repeated for every port, the average of the average\nlatencies and the standard deviation between averages is measured.\n\nThe third test serves to measure responsiveness under load. Heavy traffic\nis sent through all ports, latency and packet loss is measured\non a single idle port.\n\nThe fourth test is all about fairness. Heavy traffic is injected in all\nports but one, latency and packet loss is measured on the single idle port.\n\nThis is the test setup:\n\n  # nproc\n  56\n  # ovs-vsctl show |grep -c Port\n  2223\n  # ovs-ofctl dump-flows ovs_upc_br\n   cookie=0x0, duration=4.827s, table=0, n_packets=0, n_bytes=0, actions=CONTROLLER:65535,LOCAL\n  # uname -a\n  Linux fc28 4.18.7-200.fc28.x86_64 #1 SMP Mon Sep 10 15:44:45 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nAnd these are the results of the tests:\n\n                                          Stock OVS                 Patched\n  netlink sockets\n  in use by vswitchd\n  lsof -p $(pidof ovs-vswitchd) \\\n      |grep -c GENERIC                        91187                    2227\n\n  Test 1\n  one port latency\n  min/avg/max/mdev (us)           2.7/6.6/238.7/1.8       1.6/6.8/160.6/1.7\n\n  Test 2\n  all port\n  avg latency/mdev (us)                   6.51/0.97               6.86/0.17\n\n  Test 3\n  single port latency\n  under load\n  avg/mdev (us)                             7.5/5.9                 3.8/4.8\n  packet loss                                  95 %                    62 %\n\n  Test 4\n  idle port latency\n  under load\n  min/avg/max/mdev (us)           0.8/1.5/210.5/0.9       1.0/2.1/344.5/1.2\n  packet loss                                  94 %                     4 %\n\nCPU and RAM usage seems not to be affected, the resource usage of vswitchd\nidle with 2000+ ports is unchanged:\n\n  # ps u $(pidof ovs-vswitchd)\n  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\n  openvsw+  5430 54.3  0.3 4263964 510968 pts/1  RLl+ 16:20   0:50 ovs-vswitchd\n\nAdditionally, to check if vswitchd is thread safe with this patch, the\nfollowing test was run for circa 48 hours: on a 56 core machine, a\nbridge with kernel datapath is filled with 2200 dummy interfaces and 22\nveth, then 22 traffic generators are run in parallel piping traffic into\nthe veths peers outside the bridge.\nTo generate as many upcalls as possible, all packets were forced to the\nslowpath with an openflow rule like 'action=controller,local' and packet\nsize was set to 64 byte. Also, to avoid overflowing the FDB early and\nslowing down the upcall processing, generated mac addresses were restricted\nto a small interval. vswitchd ran without problems for 48+ hours,\nobviously with all the handler threads with almost 99% CPU usage.\n\n[1] https://github.com/teknoraver/network-tools/blob/master/weed.c\n\nSigned-off-by: Matteo Croce <mcroce@redhat.com>\nSigned-off-by: Ben Pfaff <blp@ovn.org>\nAcked-by: Flavio Leitner <fbl@sysclose.org>",
        "before_after_code_files": [
          "lib/dpif-netlink.c||lib/dpif-netlink.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/dpif-netlink.c||lib/dpif-netlink.c": [
          "File: lib/dpif-netlink.c -> lib/dpif-netlink.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78: #define FLOW_DUMP_MAX_BATCH 50",
          "79: #define OPERATE_MAX_OPS 50",
          "81: struct dpif_netlink_dp {",
          "83:     uint8_t cmd;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "81: #ifndef EPOLLEXCLUSIVE",
          "82: #define EPOLLEXCLUSIVE (1u << 28)",
          "83: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "331:     return 0;",
          "332: }",
          "371: #ifdef _WIN32",
          "372: static void",
          "373: vport_delete_sock_pool(struct dpif_handler *handler)",
          "",
          "[Removed Lines]",
          "336: static void",
          "337: vport_del_socksp__(struct nl_sock **socksp, uint32_t n_socks)",
          "338: {",
          "339:     size_t i;",
          "341:     for (i = 0; i < n_socks; i++) {",
          "342:         nl_sock_destroy(socksp[i]);",
          "343:     }",
          "345:     free(socksp);",
          "346: }",
          "350: static struct nl_sock **",
          "351: vport_create_socksp__(uint32_t n_socks, int *error)",
          "352: {",
          "353:     struct nl_sock **socksp = xzalloc(n_socks * sizeof *socksp);",
          "354:     size_t i;",
          "356:     for (i = 0; i < n_socks; i++) {",
          "358:         if (*error) {",
          "359:             goto error;",
          "360:         }",
          "361:     }",
          "363:     return socksp;",
          "365: error:",
          "366:     vport_del_socksp__(socksp, n_socks);",
          "368:     return NULL;",
          "369: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "422:     vport_delete_sock_pool(handler);",
          "423:     return error;",
          "424: }",
          "515: static bool",
          "518: {",
          "526:         return false;",
          "527:     }",
          "528:     ovs_assert(!WINDOWS || dpif->n_handlers <= 1);",
          "538:     return true;",
          "539: }",
          "541: static int",
          "544: {",
          "545:     struct epoll_event event;",
          "546:     uint32_t port_idx = odp_to_u32(port_no);",
          "548:     int error;",
          "550:     if (dpif->handlers == NULL) {",
          "",
          "[Removed Lines]",
          "428: static struct nl_sock **",
          "429: vport_create_socksp_windows(struct dpif_netlink *dpif, int *error)",
          "430:     OVS_REQ_WRLOCK(dpif->upcall_lock)",
          "431: {",
          "432:     uint32_t n_socks = dpif->n_handlers;",
          "433:     struct nl_sock **socksp;",
          "434:     size_t i;",
          "436:     ovs_assert(n_socks <= 1);",
          "437:     socksp = xzalloc(n_socks * sizeof *socksp);",
          "441:     for (i = 0; i < n_socks; i++) {",
          "442:         struct dpif_handler *handler = &dpif->handlers[i];",
          "443:         struct dpif_windows_vport_sock *sock_pool = handler->vport_sock_pool;",
          "444:         size_t index = handler->last_used_pool_idx;",
          "447:         if (sock_pool == NULL) {",
          "448:             free(socksp);",
          "450:             return NULL;",
          "451:         }",
          "453:         ovs_assert(index < VPORT_SOCK_POOL_SIZE);",
          "454:         socksp[i] = sock_pool[index].nl_sock;",
          "455:         socksp[i] = sock_pool[index].nl_sock;",
          "456:         ovs_assert(socksp[i]);",
          "457:         index = (index == VPORT_SOCK_POOL_SIZE - 1) ? 0 : index + 1;",
          "458:         handler->last_used_pool_idx = index;",
          "459:     }",
          "461:     return socksp;",
          "462: }",
          "464: static void",
          "465: vport_del_socksp_windows(struct dpif_netlink *dpif, struct nl_sock **socksp)",
          "466: {",
          "467:     free(socksp);",
          "468: }",
          "471: static struct nl_sock **",
          "472: vport_create_socksp(struct dpif_netlink *dpif, int *error)",
          "473: {",
          "474: #ifdef _WIN32",
          "475:     return vport_create_socksp_windows(dpif, error);",
          "476: #else",
          "477:     return vport_create_socksp__(dpif->n_handlers, error);",
          "478: #endif",
          "479: }",
          "481: static void",
          "482: vport_del_socksp(struct dpif_netlink *dpif, struct nl_sock **socksp)",
          "483: {",
          "484: #ifdef _WIN32",
          "485:     vport_del_socksp_windows(dpif, socksp);",
          "486: #else",
          "487:     vport_del_socksp__(socksp, dpif->n_handlers);",
          "488: #endif",
          "489: }",
          "494: static uint32_t *",
          "495: vport_socksp_to_pids(struct nl_sock **socksp, uint32_t n_socks)",
          "496: {",
          "497:     uint32_t *pids;",
          "499:     if (!socksp) {",
          "500:         pids = xzalloc(sizeof *pids);",
          "501:     } else {",
          "502:         size_t i;",
          "504:         pids = xzalloc(n_socks * sizeof *pids);",
          "505:         for (i = 0; i < n_socks; i++) {",
          "506:             pids[i] = nl_sock_pid(socksp[i]);",
          "507:         }",
          "508:     }",
          "510:     return pids;",
          "511: }",
          "516: vport_get_pids(struct dpif_netlink *dpif, uint32_t port_idx,",
          "517:                uint32_t **upcall_pids)",
          "519:     uint32_t *pids;",
          "520:     size_t i;",
          "525:     if (!dpif->handlers[0].channels[port_idx].sock) {",
          "530:     pids = xzalloc(dpif->n_handlers * sizeof *pids);",
          "532:     for (i = 0; i < dpif->n_handlers; i++) {",
          "533:         pids[i] = nl_sock_pid(dpif->handlers[i].channels[port_idx].sock);",
          "534:     }",
          "542: vport_add_channels(struct dpif_netlink *dpif, odp_port_t port_no,",
          "543:                    struct nl_sock **socksp)",
          "547:     size_t i, j;",
          "",
          "[Added Lines]",
          "397: vport_get_pid(struct dpif_netlink *dpif, uint32_t port_idx,",
          "398:               uint32_t *upcall_pid)",
          "403:     if (!dpif->channels[port_idx].sock) {",
          "414: vport_add_channel(struct dpif_netlink *dpif, odp_port_t port_no,",
          "415:                   struct nl_sock *socksp)",
          "419:     size_t i;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "563:             return EFBIG;",
          "564:         }",
          "576:             handler->epoll_events = xrealloc(handler->epoll_events,",
          "577:                 new_size * sizeof *handler->epoll_events);",
          "",
          "[Removed Lines]",
          "566:         for (i = 0; i < dpif->n_handlers; i++) {",
          "567:             struct dpif_handler *handler = &dpif->handlers[i];",
          "569:             handler->channels = xrealloc(handler->channels,",
          "570:                                          new_size * sizeof *handler->channels);",
          "572:             for (j = dpif->uc_array_size; j < new_size; j++) {",
          "573:                 handler->channels[j].sock = NULL;",
          "574:             }",
          "",
          "[Added Lines]",
          "438:         dpif->channels = xrealloc(dpif->channels,",
          "439:                                   new_size * sizeof *dpif->channels);",
          "441:         for (i = dpif->uc_array_size; i < new_size; i++) {",
          "442:             dpif->channels[i].sock = NULL;",
          "443:         }",
          "445:         for (i = 0; i < dpif->n_handlers; i++) {",
          "446:             struct dpif_handler *handler = &dpif->handlers[i];",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "581:     }",
          "583:     memset(&event, 0, sizeof event);",
          "585:     event.data.u32 = port_idx;",
          "587:     for (i = 0; i < dpif->n_handlers; i++) {",
          "588:         struct dpif_handler *handler = &dpif->handlers[i];",
          "590: #ifndef _WIN32",
          "592:                       &event) < 0) {",
          "593:             error = errno;",
          "594:             goto error;",
          "595:         }",
          "596: #endif",
          "599:     }",
          "601:     return 0;",
          "603: error:",
          "605: #ifndef _WIN32",
          "610:     }",
          "612:     return error;",
          "613: }",
          "",
          "[Removed Lines]",
          "584:     event.events = EPOLLIN;",
          "591:         if (epoll_ctl(handler->epoll_fd, EPOLL_CTL_ADD, nl_sock_fd(socksp[i]),",
          "597:         dpif->handlers[i].channels[port_idx].sock = socksp[i];",
          "598:         dpif->handlers[i].channels[port_idx].last_poll = LLONG_MIN;",
          "604:     for (j = 0; j < i; j++) {",
          "606:         epoll_ctl(dpif->handlers[j].epoll_fd, EPOLL_CTL_DEL,",
          "607:                   nl_sock_fd(socksp[j]), NULL);",
          "608: #endif",
          "609:         dpif->handlers[j].channels[port_idx].sock = NULL;",
          "",
          "[Added Lines]",
          "456:     event.events = EPOLLIN | EPOLLEXCLUSIVE;",
          "463:         if (epoll_ctl(handler->epoll_fd, EPOLL_CTL_ADD, nl_sock_fd(socksp),",
          "470:     dpif->channels[port_idx].sock = socksp;",
          "471:     dpif->channels[port_idx].last_poll = LLONG_MIN;",
          "477:     while (i--) {",
          "478:         epoll_ctl(dpif->handlers[i].epoll_fd, EPOLL_CTL_DEL,",
          "479:                   nl_sock_fd(socksp), NULL);",
          "481: #endif",
          "482:     dpif->channels[port_idx].sock = NULL;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "618:     uint32_t port_idx = odp_to_u32(port_no);",
          "619:     size_t i;",
          "629:         return;",
          "630:     }",
          "",
          "[Removed Lines]",
          "621:     if (!dpif->handlers || port_idx >= dpif->uc_array_size) {",
          "622:         return;",
          "623:     }",
          "628:     if (!dpif->handlers[0].channels[port_idx].sock) {",
          "",
          "[Added Lines]",
          "493:     if (!dpif->handlers || port_idx >= dpif->uc_array_size",
          "494:         || !dpif->channels[port_idx].sock) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "633:         struct dpif_handler *handler = &dpif->handlers[i];",
          "634: #ifndef _WIN32",
          "635:         epoll_ctl(handler->epoll_fd, EPOLL_CTL_DEL,",
          "638: #endif",
          "640:         handler->event_offset = handler->n_events = 0;",
          "641:     }",
          "642: }",
          "644: static void",
          "",
          "[Removed Lines]",
          "636:                   nl_sock_fd(handler->channels[port_idx].sock), NULL);",
          "637:         nl_sock_destroy(handler->channels[port_idx].sock);",
          "639:         handler->channels[port_idx].sock = NULL;",
          "",
          "[Added Lines]",
          "502:                   nl_sock_fd(dpif->channels[port_idx].sock), NULL);",
          "506: #ifndef _WIN32",
          "507:     nl_sock_destroy(dpif->channels[port_idx].sock);",
          "508: #endif",
          "509:     dpif->channels[port_idx].sock = NULL;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "655:         struct dpif_netlink_vport vport_request;",
          "656:         uint32_t upcall_pids = 0;",
          "662:             continue;",
          "663:         }",
          "",
          "[Removed Lines]",
          "661:         if (!dpif->handlers[0].channels[i].sock) {",
          "",
          "[Added Lines]",
          "526:         if (!dpif->channels[i].sock) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "680:         dpif_netlink_handler_uninit(handler);",
          "681:         free(handler->epoll_events);",
          "683:     }",
          "685:     free(dpif->handlers);",
          "686:     dpif->handlers = NULL;",
          "687:     dpif->n_handlers = 0;",
          "688:     dpif->uc_array_size = 0;",
          "689: }",
          "",
          "[Removed Lines]",
          "682:         free(handler->channels);",
          "",
          "[Added Lines]",
          "548:     free(dpif->channels);",
          "551:     dpif->channels = NULL;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "846: {",
          "847:     struct dpif_netlink_vport request, reply;",
          "848:     struct ofpbuf *buf;",
          "851:     int error = 0;",
          "853:     if (dpif->handlers) {",
          "856:             return error;",
          "857:         }",
          "858:     }",
          "",
          "[Removed Lines]",
          "849:     struct nl_sock **socksp = NULL;",
          "850:     uint32_t *upcall_pids;",
          "854:         socksp = vport_create_socksp(dpif, &error);",
          "855:         if (!socksp) {",
          "",
          "[Added Lines]",
          "714:     struct nl_sock *socksp = NULL;",
          "715:     uint32_t upcall_pids;",
          "719:         if (nl_sock_create(NETLINK_GENERIC, &socksp)) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "864:     request.name = name;",
          "866:     request.port_no = *port_nop;",
          "871:     if (options) {",
          "872:         request.options = options->data;",
          "",
          "[Removed Lines]",
          "867:     upcall_pids = vport_socksp_to_pids(socksp, dpif->n_handlers);",
          "868:     request.n_upcall_pids = socksp ? dpif->n_handlers : 1;",
          "869:     request.upcall_pids = upcall_pids;",
          "",
          "[Added Lines]",
          "731:     upcall_pids = nl_sock_pid(socksp);",
          "732:     request.n_upcall_pids = 1;",
          "733:     request.upcall_pids = &upcall_pids;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "882:                       dpif_name(&dpif->dpif), *port_nop);",
          "883:         }",
          "886:         goto exit;",
          "887:     }",
          "904:     }",
          "907: exit:",
          "908:     ofpbuf_delete(buf);",
          "911:     return error;",
          "912: }",
          "",
          "[Removed Lines]",
          "885:         vport_del_socksp(dpif, socksp);",
          "889:     if (socksp) {",
          "890:         error = vport_add_channels(dpif, *port_nop, socksp);",
          "891:         if (error) {",
          "892:             VLOG_INFO(\"%s: could not add channel for port %s\",",
          "893:                       dpif_name(&dpif->dpif), name);",
          "896:             dpif_netlink_vport_init(&request);",
          "897:             request.cmd = OVS_VPORT_CMD_DEL;",
          "898:             request.dp_ifindex = dpif->dp_ifindex;",
          "899:             request.port_no = *port_nop;",
          "900:             dpif_netlink_vport_transact(&request, NULL, NULL);",
          "901:             vport_del_socksp(dpif, socksp);",
          "902:             goto exit;",
          "903:         }",
          "905:     free(socksp);",
          "909:     free(upcall_pids);",
          "",
          "[Added Lines]",
          "749:         nl_sock_destroy(socksp);",
          "753:     error = vport_add_channel(dpif, *port_nop, socksp);",
          "754:     if (error) {",
          "755:         VLOG_INFO(\"%s: could not add channel for port %s\",",
          "756:                     dpif_name(&dpif->dpif), name);",
          "759:         dpif_netlink_vport_init(&request);",
          "760:         request.cmd = OVS_VPORT_CMD_DEL;",
          "761:         request.dp_ifindex = dpif->dp_ifindex;",
          "762:         request.port_no = *port_nop;",
          "763:         dpif_netlink_vport_transact(&request, NULL, NULL);",
          "764:         nl_sock_destroy(socksp);",
          "765:         goto exit;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1132: static uint32_t",
          "1133: dpif_netlink_port_get_pid__(const struct dpif_netlink *dpif,",
          "1135:     OVS_REQ_RDLOCK(dpif->upcall_lock)",
          "1136: {",
          "1137:     uint32_t port_idx = odp_to_u32(port_no);",
          "",
          "[Removed Lines]",
          "1134:                             odp_port_t port_no, uint32_t hash)",
          "",
          "[Added Lines]",
          "994:                             odp_port_t port_no, uint32_t hash OVS_UNUSED)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1143:         uint32_t idx = port_idx >= dpif->uc_array_size ? 0 : port_idx;",
          "1152:         }",
          "1153:     }",
          "",
          "[Removed Lines]",
          "1144:         struct dpif_handler *h = &dpif->handlers[hash % dpif->n_handlers];",
          "1150:         if (h->channels[idx].sock) {",
          "1151:             pid = nl_sock_pid(h->channels[idx].sock);",
          "",
          "[Added Lines]",
          "1009:         if (dpif->channels[idx].sock) {",
          "1010:             pid = nl_sock_pid(dpif->channels[idx].sock);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2369:     dpif_netlink_port_dump_start__(dpif, &dump);",
          "2370:     while (!dpif_netlink_port_dump_next__(dpif, &dump, &vport, &buf)) {",
          "2371:         uint32_t port_no = odp_to_u32(vport.port_no);",
          "2373:         int error;",
          "2375:         if (port_no >= dpif->uc_array_size",
          "2380:                 goto error;",
          "2381:             }",
          "2384:             if (error) {",
          "2385:                 VLOG_INFO(\"%s: could not add channels for port %s\",",
          "2386:                           dpif_name(&dpif->dpif), vport.name);",
          "2388:                 retval = error;",
          "2389:                 goto error;",
          "2390:             }",
          "2393:         }",
          "2396:         if (vport.upcall_pids[0] == 0",
          "2400:             struct dpif_netlink_vport vport_request;",
          "2402:             dpif_netlink_vport_init(&vport_request);",
          "2403:             vport_request.cmd = OVS_VPORT_CMD_SET;",
          "2404:             vport_request.dp_ifindex = dpif->dp_ifindex;",
          "2405:             vport_request.port_no = vport.port_no;",
          "2408:             error = dpif_netlink_vport_transact(&vport_request, NULL, NULL);",
          "2409:             if (error) {",
          "2410:                 VLOG_WARN_RL(&error_rl,",
          "",
          "[Removed Lines]",
          "2372:         uint32_t *upcall_pids = NULL;",
          "2376:             || !vport_get_pids(dpif, port_no, &upcall_pids)) {",
          "2377:             struct nl_sock **socksp = vport_create_socksp(dpif, &error);",
          "2379:             if (!socksp) {",
          "2383:             error = vport_add_channels(dpif, vport.port_no, socksp);",
          "2387:                 vport_del_socksp(dpif, socksp);",
          "2391:             upcall_pids = vport_socksp_to_pids(socksp, dpif->n_handlers);",
          "2392:             free(socksp);",
          "2397:             || vport.n_upcall_pids != dpif->n_handlers",
          "2398:             || memcmp(upcall_pids, vport.upcall_pids, n_handlers * sizeof",
          "2406:             vport_request.n_upcall_pids = dpif->n_handlers;",
          "2407:             vport_request.upcall_pids = upcall_pids;",
          "",
          "[Added Lines]",
          "2231:         uint32_t upcall_pid;",
          "2235:             || !vport_get_pid(dpif, port_no, &upcall_pid)) {",
          "2236:             struct nl_sock *socksp;",
          "2238:             if (nl_sock_create(NETLINK_GENERIC, &socksp)) {",
          "2242:             error = vport_add_channel(dpif, vport.port_no, socksp);",
          "2246:                 nl_sock_destroy(socksp);",
          "2250:             upcall_pid = nl_sock_pid(socksp);",
          "2255:             || vport.n_upcall_pids != 1",
          "2256:             || upcall_pid != vport.upcall_pids[0]) {",
          "2263:             vport_request.n_upcall_pids = 1;",
          "2264:             vport_request.upcall_pids = &upcall_pid;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2425:         if (port_no < keep_channels_nbits) {",
          "2426:             bitmap_set1(keep_channels, port_no);",
          "2427:         }",
          "2429:         continue;",
          "2431:     error:",
          "2433:         vport_del_channels(dpif, vport.port_no);",
          "2434:     }",
          "2435:     nl_dump_done(&dump);",
          "",
          "[Removed Lines]",
          "2428:         free(upcall_pids);",
          "2432:         free(upcall_pids);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2689:     while (handler->event_offset < handler->n_events) {",
          "2690:         int idx = handler->epoll_events[handler->event_offset].data.u32;",
          "2693:         handler->event_offset++;",
          "",
          "[Removed Lines]",
          "2691:         struct dpif_channel *ch = &dpif->handlers[handler_id].channels[idx];",
          "",
          "[Added Lines]",
          "2546:         struct dpif_channel *ch = &dpif->channels[idx];",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2790:     OVS_REQ_WRLOCK(dpif->upcall_lock)",
          "2791: {",
          "2792:     if (dpif->handlers) {",
          "2795:         for (i = 0; i < dpif->uc_array_size; i++ ) {",
          "2803:         }",
          "2804:     }",
          "2805: }",
          "",
          "[Removed Lines]",
          "2793:         size_t i, j;",
          "2796:             if (!dpif->handlers[0].channels[i].sock) {",
          "2797:                 continue;",
          "2798:             }",
          "2800:             for (j = 0; j < dpif->n_handlers; j++) {",
          "2801:                 nl_sock_drain(dpif->handlers[j].channels[i].sock);",
          "2802:             }",
          "",
          "[Added Lines]",
          "2648:         size_t i;",
          "2650:         if (!dpif->channels[0].sock) {",
          "2651:             return;",
          "2652:         }",
          "2655:             nl_sock_drain(dpif->channels[i].sock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fd33092caae0afad774cbfe16e825908fde994c6",
      "candidate_info": {
        "commit_hash": "fd33092caae0afad774cbfe16e825908fde994c6",
        "repo": "cloudbase/ovs",
        "commit_url": "https://github.com/cloudbase/ovs/commit/fd33092caae0afad774cbfe16e825908fde994c6",
        "files": [
          "lib/conntrack.c"
        ],
        "message": "conntrack: Reset ct_state when entering a new zone.\n\nWhen a new conntrack zone is entered, the ct_state field is zeroed in\norder to avoid using state information from different zones.\n\nOne such scenario is when a packet is double NATed. Assuming two zones\nand 3 flows performing the following actions in order on the packet:\n1. ct(zone=5,nat), recirc\n2. ct(zone=1), recirc\n3. ct(zone=1,nat)\n\nIf at step #1 the packet matches an existing NAT entry, it will get\ntranslated and pkt->md.ct_state is set to CS_DST_NAT or CS_SRC_NAT.\nAt step #2 the new tuple might match an existing connection and\npkt->md.ct_zone is set to 1.\nIf at step #3 the packet matches an existing NAT entry in zone 1,\nhandle_nat() will be called to perform the translation but it will\nreturn early because the packet's zone matches the conntrack zone and\nthe ct_state field still contains CS_DST_NAT or CS_SRC_NAT from the\ntranslations in zone 5.\n\nIn order to reliably detect when a packet enters a new conntrack zone\nwe also need to make sure that the pkt->md.ct_zone is properly\ninitialized if pkt->md.ct_state is non-zero. This already happens for\nmost cases. The only exception is when matched conntrack connection is\nof type CT_CONN_TYPE_UN_NAT and the master connection is missing. To\ncover this path we now call write_ct_md() in that case too. Remove\nsetting the CS_TRACKED flag as in this case as it will be done by the\nnew call to write_ct_md().\n\nCC: Darrell Ball <dlu998@gmail.com>\nFixes: 286de2729955 (\"dpdk: Userspace Datapath: Introduce NAT Support.\")\nAcked-by: Ilya Maximets <i.maximets@ovn.org>\nAcked-by: Aaron Conole <aconole@redhat.com>\nSigned-off-by: Dumitru Ceara <dceara@redhat.com>\nSigned-off-by: Ilya Maximets <i.maximets@ovn.org>",
        "before_after_code_files": [
          "lib/conntrack.c||lib/conntrack.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/conntrack.c||lib/conntrack.c": [
          "File: lib/conntrack.c -> lib/conntrack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1096:             const struct ovs_key_ct_labels *setlabel,",
          "1097:             const struct nat_action_info_t *nat_action_info,",
          "1098:             ovs_be16 tp_src, ovs_be16 tp_dst, const char *helper)",
          "1099: {",
          "1100:     bool create_new_conn = false;",
          "1101:     conn_key_lookup(ct, &ctx->key, ctx->hash, now, &ctx->conn, &ctx->reply);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1101:     if (pkt->md.ct_state && pkt->md.ct_zone != zone) {",
          "1102:         pkt->md.ct_state = 0;",
          "1103:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1119:             uint32_t hash = conn_key_hash(&conn->rev_key, ct->hash_basis);",
          "1120:             conn_key_lookup(ct, &ctx->key, hash, now, &conn, &ctx->reply);",
          "1123:                 pkt->md.ct_state |= CS_TRACKED | CS_INVALID;",
          "1124:                 char *log_msg = xasprintf(\"Missing master conn %p\", rev_conn);",
          "1125:                 ct_print_conn_info(rev_conn, log_msg, VLL_INFO, true, true);",
          "",
          "[Removed Lines]",
          "1122:             if (!conn) {",
          "",
          "[Added Lines]",
          "1127:             if (!conn) {",
          "1128:                 pkt->md.ct_state |= CS_INVALID;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d5d0c94551b619c865acfc3e6ba39089e9b7b2a1",
      "candidate_info": {
        "commit_hash": "d5d0c94551b619c865acfc3e6ba39089e9b7b2a1",
        "repo": "cloudbase/ovs",
        "commit_url": "https://github.com/cloudbase/ovs/commit/d5d0c94551b619c865acfc3e6ba39089e9b7b2a1",
        "files": [
          "lib/stream-ssl.c"
        ],
        "message": "stream-ssl: Fix crash on NULL private key and valid certificate.\n\nRunning ovsdb-server with empty private-key and non-empty certificate\n(or otherwise) causes crash:\n\n # ovsdb-tool create ./etc/openvswitch/conf.db ./vswitch.ovsschema\n # ovsdb-server --remote=punix:./db.sock \\\n                --remote=db:Open_vSwitch,Open_vSwitch,manager_options \\\n                --private-key=db:Open_vSwitch,SSL,private_key \\\n                --certificate=db:Open_vSwitch,SSL,certificate \\\n                --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert\n\n # ovs-vsctl --no-wait init\n # ovs-vsctl --no-wait set-ssl pkey.key cert.cert ca.cert\n # ovs-vsctl --no-wait set SSL . private_key='\"\"'\n # ovs-vsctl --no-wait set SSL . certificate='cert.new'\n\n ==25513==ERROR: AddressSanitizer: SEGV on unknown address 0x000000000000\n ==25513==The signal is caused by a READ memory access.\n ==25513==Hint: address points to the zero page.\n    #0 0x7ff7582aa0a9 in __GI___strlen_sse2\n    #1 0x7ff759bdde81  (/lib64/libasan.so.5+0xace81)\n    #2 0x7ff759479932  (/lib64/libcrypto.so.1.1+0xb3932)\n    #3 0x7ff759473c5a in BIO_ctrl (/lib64/libcrypto.so.1.1+0xadc5a)\n    #4 0x7ff7598decc1 in SSL_CTX_use_certificate_file (/lib64/libssl.so.1.1+0x40cc1)\n    #5 0x4dbaa7 in stream_ssl_set_certificate_file__ lib/stream-ssl.c:1170\n    #6 0x4dca2e in stream_ssl_set_key_and_cert lib/stream-ssl.c:1216\n    #7 0x4146b2 in reconfigure_ssl ovsdb/ovsdb-server.c:1254\n    #8 0x409c83 in main ovsdb/ovsdb-server.c:368\n    #9 0x7ff758233812 in __libc_start_main\n    #10 0x40f6bd in _start (ovsdb-server+0x40f6bd)\n\n AddressSanitizer can not provide additional info.\n SUMMARY: AddressSanitizer: SEGV (/lib64/libc.so.6+0x9a0a9) in __GI___strlen_sse2\n ==25513==ABORTING\n\nAnother way to reproduce is to use non-initialized DB entry for\nprivate-key and a file for certificate in ovsdb-server cmdline.\n\nThe root cause is that stream_ssl_set_key_and_cert() triggers\nconfiguration for both key and cert if any of them is valid, keeping\nit possible for one of them to be NULL.\n\nFixes: 6f1e91b1d7c0 (\"stream-ssl: Make changing keys and certificate at runtime reliable.\")\nSigned-off-by: Ilya Maximets <i.maximets@samsung.com>\nAcked-by: Ben Pfaff <blp@ovn.org>",
        "before_after_code_files": [
          "lib/stream-ssl.c||lib/stream-ssl.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/stream-ssl.c||lib/stream-ssl.c": [
          "File: lib/stream-ssl.c -> lib/stream-ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1210: void",
          "1211: stream_ssl_set_key_and_cert(const char *private_key_file,",
          "1212:                             const char *certificate_file)",
          "1214:     if (update_ssl_config(&private_key, private_key_file)",
          "1215:         || update_ssl_config(&certificate, certificate_file)) {",
          "1216:         stream_ssl_set_certificate_file__(certificate_file);",
          "",
          "[Removed Lines]",
          "1213: {",
          "",
          "[Added Lines]",
          "1213: {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
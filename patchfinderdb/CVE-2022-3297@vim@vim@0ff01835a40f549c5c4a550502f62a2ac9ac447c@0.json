{
  "cve_id": "CVE-2022-3297",
  "cve_desc": "Use After Free in GitHub repository vim/vim prior to 9.0.0579.",
  "repo": "vim/vim",
  "patch_hash": "0ff01835a40f549c5c4a550502f62a2ac9ac447c",
  "patch_info": {
    "commit_hash": "0ff01835a40f549c5c4a550502f62a2ac9ac447c",
    "repo": "vim/vim",
    "commit_url": "https://github.com/vim/vim/commit/0ff01835a40f549c5c4a550502f62a2ac9ac447c",
    "files": [
      "src/insexpand.c",
      "src/move.c",
      "src/testdir/test_ins_complete.vim",
      "src/version.c"
    ],
    "message": "patch 9.0.0579: using freed memory when 'tagfunc' wipes out buffer\n\nProblem:    Using freed memory when 'tagfunc' wipes out buffer that holds\n            'complete'.\nSolution:   Make a copy of the option.  Make sure cursor position is valid.",
    "before_after_code_files": [
      "src/insexpand.c||src/insexpand.c",
      "src/move.c||src/move.c",
      "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim",
      "src/version.c||src/version.c"
    ]
  },
  "patch_diff": {
    "src/insexpand.c||src/insexpand.c": [
      "File: src/insexpand.c -> src/insexpand.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2491:     if (flag == 'w')  // just windows",
      "2492:     {",
      "2494:      wp = curwin;",
      "2495:  while ((wp = (wp->w_next != NULL ? wp->w_next : firstwin)) != curwin",
      "2496:   && wp->w_buffer->b_scanned)",
      "",
      "[Removed Lines]",
      "2493:  if (buf == curbuf || wp == NULL)  // first call for this flag/expansion",
      "",
      "[Added Lines]",
      "2493:  if (buf == curbuf || !win_valid(wp))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3189: typedef struct",
      "3190: {",
      "3192:     buf_T *ins_buf;  // buffer being scanned",
      "3194:     pos_T prev_match_pos;  // previous match position",
      "3195:     int  set_match_pos;  // save first_match_pos/last_match_pos",
      "3196:     pos_T first_match_pos; // first match position",
      "",
      "[Removed Lines]",
      "3191:     char_u *e_cpt;   // current entry in 'complete'",
      "3193:     pos_T *cur_match_pos;   // current match position",
      "",
      "[Added Lines]",
      "3192:     char_u *e_cpt_copy;  // copy of 'complete'",
      "3193:     char_u *e_cpt;   // current entry in \"e_cpt_copy\"",
      "3195:     pos_T *cur_match_pos;  // current match position",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3257:  st->set_match_pos = TRUE;",
      "3258:     }",
      "3259:     else if (vim_strchr((char_u *)\"buwU\", *st->e_cpt) != NULL",
      "3261:     {",
      "3263:  if (st->ins_buf->b_ml.ml_mfp != NULL)   // loaded buffer",
      "",
      "[Removed Lines]",
      "3260:      && (st->ins_buf = ins_compl_next_buf(st->ins_buf, *st->e_cpt)) != curbuf)",
      "",
      "[Added Lines]",
      "3262:      && (st->ins_buf = ins_compl_next_buf(",
      "3263:         st->ins_buf, *st->e_cpt)) != curbuf)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3756:     static int",
      "3757: ins_compl_get_exp(pos_T *ini)",
      "3758: {",
      "3760:     int  i;",
      "3761:     int  found_new_match;",
      "3762:     int  type = ctrl_x_mode;",
      "3764:     if (!compl_started)",
      "3765:     {",
      "3768:  st.found_all = FALSE;",
      "3769:  st.ins_buf = curbuf;",
      "3772:  st.last_match_pos = st.first_match_pos = *ini;",
      "3773:     }",
      "3774:     else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))",
      "",
      "[Removed Lines]",
      "3759:     static ins_compl_next_state_T st;",
      "3766:  FOR_ALL_BUFFERS(st.ins_buf)",
      "3767:      st.ins_buf->b_scanned = 0;",
      "3770:  st.e_cpt = (compl_cont_status & CONT_LOCAL)",
      "3771:          ? (char_u *)\".\" : curbuf->b_p_cpt;",
      "",
      "[Added Lines]",
      "3762:     static ins_compl_next_state_T   st;",
      "3763:     static int       st_cleared = FALSE;",
      "3770:  buf_T *buf;",
      "3772:  FOR_ALL_BUFFERS(buf)",
      "3773:      buf->b_scanned = 0;",
      "3774:  if (!st_cleared)",
      "3775:  {",
      "3776:      CLEAR_FIELD(st);",
      "3777:      st_cleared = TRUE;",
      "3778:  }",
      "3781:  vim_free(st.e_cpt_copy);",
      "3783:  st.e_cpt_copy = vim_strsave((compl_cont_status & CONT_LOCAL)",
      "3784:          ? (char_u *)\".\" : curbuf->b_p_cpt);",
      "3785:  st.e_cpt = st.e_cpt_copy == NULL ? (char_u *)\"\" : st.e_cpt_copy;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4112:     int     todo = count;",
      "4113:     int     advance;",
      "4114:     int     started = compl_started;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4129:     buf_T   *orig_curbuf = curbuf;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "4144:        &num_matches) == -1)",
      "4145:  return -1;",
      "4148:     if (compl_no_insert && !started)",
      "4149:     {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4162:     if (curbuf != orig_curbuf)",
      "4163:     {",
      "4166:  return -1;",
      "4167:     }",
      "",
      "---------------"
    ],
    "src/move.c||src/move.c": [
      "File: src/move.c -> src/move.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "683:     void",
      "684: validate_cursor(void)",
      "685: {",
      "686:     check_cursor_moved(curwin);",
      "687:     if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))",
      "688:  curs_columns(TRUE);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "686:     check_cursor();",
      "",
      "---------------"
    ],
    "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim": [
      "File: src/testdir/test_ins_complete.vim -> src/testdir/test_ins_complete.vim",
      "--- Hunk 1 ---",
      "[Context before]",
      "548:   call writefile(lines, 'Xpreviewscript')",
      "549:   let buf = RunVimInTerminal('-S Xpreviewscript', #{rows: 12})",
      "551:   call term_sendkeys(buf, \"Gi\\<C-X>\\<C-O>\")",
      "553:   call term_sendkeys(buf, \"\\<C-N>\")",
      "554:   call VerifyScreenDump(buf, 'Test_pum_with_preview_win', {})",
      "",
      "[Removed Lines]",
      "550:   call TermWait(buf, 50)",
      "552:   call TermWait(buf, 100)",
      "",
      "[Added Lines]",
      "551:   call TermWait(buf, 200)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2173:   bwipe!",
      "2174: endfunc",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2175: func s:Tagfunc(t,f,o)",
      "2176:   bwipe!",
      "2177:   return []",
      "2178: endfunc",
      "2180: \" This was using freed memory, since 'complete' was in a wiped out buffer.",
      "2181: \" Also using a window that was closed.",
      "2182: func Test_tagfunc_wipes_out_buffer()",
      "2183:   new",
      "2184:   set complete=.,t,w,b,u,i",
      "2185:   se tagfunc=s:Tagfunc",
      "2186:   sil norm i\u000e",
      "2188:   bwipe!",
      "2189: endfunc",
      "",
      "---------------"
    ],
    "src/version.c||src/version.c": [
      "File: src/version.c -> src/version.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "700: static int included_patches[] =",
      "703:     578,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "703:     579,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "edc6f103907a004b9e2265e232dc8be8bc594601",
      "candidate_info": {
        "commit_hash": "edc6f103907a004b9e2265e232dc8be8bc594601",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/edc6f103907a004b9e2265e232dc8be8bc594601",
        "files": [
          "src/insexpand.c",
          "src/testdir/test_ins_complete.vim",
          "src/version.c"
        ],
        "message": "patch 8.2.3937: Insert mode completion function is too long\n\nProblem:    Insert mode completion function is too long.\nSolution:   Refactor into multiple functions. (Yegappan Lakshmanan,\n            closes #9423)",
        "before_after_code_files": [
          "src/insexpand.c||src/insexpand.c",
          "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/insexpand.c||src/insexpand.c",
            "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/insexpand.c||src/insexpand.c",
            "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/insexpand.c||src/insexpand.c": [
          "File: src/insexpand.c -> src/insexpand.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2900: #endif",
          "2901: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2906: enum",
          "2907: {",
          "2908:     INS_COMPL_CPT_OK = 1,",
          "2909:     INS_COMPL_CPT_CONT,",
          "2910:     INS_COMPL_CPT_END",
          "2911: };",
          "2933:     static int",
          "2934: process_next_cpt_value(",
          "2935:  char_u  **e_cpt_arg,",
          "2936:  int  *compl_type_arg,",
          "2937:  int  *found_all_arg,",
          "2938:  buf_T  **buf_arg,",
          "2939:  pos_T  *start_match_pos,",
          "2940:  pos_T  *first_match_pos,",
          "2941:  pos_T  *last_match_pos,",
          "2942:  int  *set_match_pos,",
          "2943:  char_u  **dict_arg,",
          "2944:  int  *dict_flag)",
          "2945: {",
          "2946:     char_u  *e_cpt = *e_cpt_arg;",
          "2947:     int     compl_type = -1;",
          "2948:     int     status = INS_COMPL_CPT_OK;",
          "2949:     buf_T   *buf = *buf_arg;",
          "2950:     int     found_all = FALSE;",
          "2951:     char_u  *dict = NULL;",
          "2952:     int     dict_f = 0;",
          "2954:     while (*e_cpt == ',' || *e_cpt == ' ')",
          "2955:  e_cpt++;",
          "2957:     if (*e_cpt == '.' && !curbuf->b_scanned)",
          "2958:     {",
          "2959:  buf = curbuf;",
          "2963:  if (ctrl_x_mode == CTRL_X_NORMAL && dec(first_match_pos) < 0)",
          "2964:  {",
          "2968:      first_match_pos->lnum = buf->b_ml.ml_line_count;",
          "2969:      first_match_pos->col =",
          "2970:   (colnr_T)STRLEN(ml_get(first_match_pos->lnum));",
          "2971:  }",
          "2973:  compl_type = 0;",
          "2978:     }",
          "2979:     else if (vim_strchr((char_u *)\"buwU\", *e_cpt) != NULL",
          "2980:      && (buf = ins_compl_next_buf(buf, *e_cpt)) != curbuf)",
          "2981:     {",
          "2983:  if (buf->b_ml.ml_mfp != NULL)   // loaded buffer",
          "2984:  {",
          "2985:      compl_started = TRUE;",
          "2986:      first_match_pos->col = last_match_pos->col = 0;",
          "2987:      first_match_pos->lnum = buf->b_ml.ml_line_count + 1;",
          "2988:      last_match_pos->lnum = 0;",
          "2989:      compl_type = 0;",
          "2990:  }",
          "2991:  else // unloaded buffer, scan like dictionary",
          "2992:  {",
          "2993:      found_all = TRUE;",
          "2994:      if (buf->b_fname == NULL)",
          "2995:      {",
          "2996:   status = INS_COMPL_CPT_CONT;",
          "2997:   goto done;",
          "2998:      }",
          "2999:      compl_type = CTRL_X_DICTIONARY;",
          "3000:      dict = buf->b_fname;",
          "3001:      dict_f = DICT_EXACT;",
          "3002:  }",
          "3003:  msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3004:  vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),",
          "3005:   buf->b_fname == NULL",
          "3006:       ? buf_spname(buf)",
          "3007:       : buf->b_sfname == NULL",
          "3008:    ? buf->b_fname",
          "3009:    : buf->b_sfname);",
          "3010:  (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "3011:     }",
          "3012:     else if (*e_cpt == NUL)",
          "3013:  status = INS_COMPL_CPT_END;",
          "3014:     else",
          "3015:     {",
          "3016:  if (ctrl_x_mode_line_or_eval())",
          "3017:      compl_type = -1;",
          "3018:  else if (*e_cpt == 'k' || *e_cpt == 's')",
          "3019:  {",
          "3020:      if (*e_cpt == 'k')",
          "3021:   compl_type = CTRL_X_DICTIONARY;",
          "3022:      else",
          "3023:   compl_type = CTRL_X_THESAURUS;",
          "3024:      if (*++e_cpt != ',' && *e_cpt != NUL)",
          "3025:      {",
          "3026:   dict = e_cpt;",
          "3027:   dict_f = DICT_FIRST;",
          "3028:      }",
          "3029:  }",
          "3030: #ifdef FEAT_FIND_ID",
          "3031:  else if (*e_cpt == 'i')",
          "3032:      compl_type = CTRL_X_PATH_PATTERNS;",
          "3033:  else if (*e_cpt == 'd')",
          "3034:      compl_type = CTRL_X_PATH_DEFINES;",
          "3035: #endif",
          "3036:  else if (*e_cpt == ']' || *e_cpt == 't')",
          "3037:  {",
          "3038:      msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3039:      compl_type = CTRL_X_TAGS;",
          "3040:      vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning tags.\"));",
          "3041:      (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "3042:  }",
          "3043:  else",
          "3044:      compl_type = -1;",
          "3047:  (void)copy_option_part(&e_cpt, IObuff, IOSIZE, \",\");",
          "3049:  found_all = TRUE;",
          "3050:  if (compl_type == -1)",
          "3051:      status = INS_COMPL_CPT_CONT;",
          "3052:     }",
          "3054: done:",
          "3061:     return status;",
          "3062: }",
          "3064: #ifdef FEAT_FIND_ID",
          "3069:     static void",
          "3070: get_next_include_file_completion(int compl_type)",
          "3071: {",
          "3072:     find_pattern_in_path(compl_pattern, compl_direction,",
          "3073:      (int)STRLEN(compl_pattern), FALSE, FALSE,",
          "3074:      (compl_type == CTRL_X_PATH_DEFINES",
          "3075:       && !(compl_cont_status & CONT_SOL))",
          "3076:      ? FIND_DEFINE : FIND_ANY, 1L, ACTION_EXPAND,",
          "3077:      (linenr_T)1, (linenr_T)MAXLNUM);",
          "3078: }",
          "3079: #endif",
          "3085:     static void",
          "3086: get_next_dict_tsr_completion(int compl_type, char_u **dict, int dict_f)",
          "3087: {",
          "3088: #ifdef FEAT_COMPL_FUNC",
          "3089:     if (thesaurus_func_complete(compl_type))",
          "3090:  expand_by_function(compl_type, compl_pattern);",
          "3091:     else",
          "3092: #endif",
          "3093:  ins_compl_dictionaries(",
          "3095:   : (compl_type == CTRL_X_THESAURUS",
          "3096:       ? (*curbuf->b_p_tsr == NUL ? p_tsr : curbuf->b_p_tsr)",
          "3097:       : (*curbuf->b_p_dict == NUL ? p_dict : curbuf->b_p_dict)),",
          "3098:   compl_pattern,",
          "3100:   compl_type == CTRL_X_THESAURUS);",
          "3102: }",
          "3107:     static void",
          "3108: get_next_tag_completion(void)",
          "3109: {",
          "3110:     int  save_p_ic;",
          "3111:     char_u **matches;",
          "3112:     int  num_matches;",
          "3115:     save_p_ic = p_ic;",
          "3116:     p_ic = ignorecase(compl_pattern);",
          "3120:     g_tag_at_cursor = TRUE;",
          "3121:     if (find_tags(compl_pattern, &num_matches, &matches,",
          "3122:   TAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP",
          "3123:   | (ctrl_x_mode != CTRL_X_NORMAL ? TAG_VERBOSE : 0),",
          "3124:   TAG_MANY, curbuf->b_ffname) == OK && num_matches > 0)",
          "3125:  ins_compl_add_matches(num_matches, matches, p_ic);",
          "3126:     g_tag_at_cursor = FALSE;",
          "3127:     p_ic = save_p_ic;",
          "3128: }",
          "3133:     static void",
          "3134: get_next_filename_completion(void)",
          "3135: {",
          "3136:     char_u **matches;",
          "3137:     int  num_matches;",
          "3139:     if (expand_wildcards(1, &compl_pattern, &num_matches, &matches,",
          "3140:   EW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) != OK)",
          "3141:  return;",
          "3144:     tilde_replace(compl_pattern, num_matches, matches);",
          "3145: #ifdef BACKSLASH_IN_FILENAME",
          "3146:     if (curbuf->b_p_csl[0] != NUL)",
          "3147:     {",
          "3148:  int     i;",
          "3150:  for (i = 0; i < num_matches; ++i)",
          "3151:  {",
          "3152:      char_u *ptr = matches[i];",
          "3154:      while (*ptr != NUL)",
          "3155:      {",
          "3156:   if (curbuf->b_p_csl[0] == 's' && *ptr == '\\\\')",
          "3158:   else if (curbuf->b_p_csl[0] == 'b' && *ptr == '/')",
          "3160:   ptr += (*mb_ptr2len)(ptr);",
          "3161:      }",
          "3162:  }",
          "3163:     }",
          "3164: #endif",
          "3165:     ins_compl_add_matches(num_matches, matches, p_fic || p_wic);",
          "3166: }",
          "3171:     static void",
          "3172: get_next_cmdline_completion()",
          "3173: {",
          "3174:     char_u **matches;",
          "3175:     int  num_matches;",
          "3177:     if (expand_cmdline(&compl_xp, compl_pattern,",
          "3178:   (int)STRLEN(compl_pattern),",
          "3179:   &num_matches, &matches) == EXPAND_OK)",
          "3180:  ins_compl_add_matches(num_matches, matches, FALSE);",
          "3181: }",
          "3186:     static void",
          "3187: get_next_spell_completion(linenr_T lnum UNUSED)",
          "3188: {",
          "3189: #ifdef FEAT_SPELL",
          "3190:     char_u **matches;",
          "3191:     int  num_matches;",
          "3193:     num_matches = expand_spelling(lnum, compl_pattern, &matches);",
          "3194:     if (num_matches > 0)",
          "3195:  ins_compl_add_matches(num_matches, matches, p_ic);",
          "3196: #endif",
          "3197: }",
          "3207:     static int",
          "3208: get_next_default_completion(",
          "3209:  buf_T *ins_buf,  // buffer being scanned",
          "3210:  pos_T *start_pos,  // search start position",
          "3211:  pos_T *cur_match_pos,  // current match position",
          "3212:  pos_T *prev_match_pos, // previous match position",
          "3213:  int *save_match_pos, // set first_match_pos/last_match_pos",
          "3214:  pos_T *first_match_pos, // first match position",
          "3215:  pos_T *last_match_pos, // last match position",
          "3216:  int scan_curbuf)  // scan current buffer for completion",
          "3217: {",
          "3218:     int  found_new_match = FAIL;",
          "3219:     int  save_p_scs;",
          "3220:     int  save_p_ws;",
          "3221:     int  looped_around = FALSE;",
          "3222:     char_u *ptr;",
          "3223:     int  len;",
          "3226:     save_p_scs = p_scs;",
          "3227:     if (ins_buf->b_p_inf)",
          "3228:  p_scs = FALSE;",
          "3234:     save_p_ws = p_ws;",
          "3235:     if (ins_buf != curbuf)",
          "3236:  p_ws = FALSE;",
          "3237:     else if (scan_curbuf)",
          "3238:  p_ws = TRUE;",
          "3239:     looped_around = FALSE;",
          "3240:     for (;;)",
          "3241:     {",
          "3242:  int cont_s_ipos = FALSE;",
          "3244:  ++msg_silent;  // Don't want messages for wrapscan.",
          "3248:  if (ctrl_x_mode_line_or_eval()",
          "3249:   || (compl_cont_status & CONT_SOL))",
          "3250:      found_new_match = search_for_exact_line(ins_buf, cur_match_pos,",
          "3251:       compl_direction, compl_pattern);",
          "3252:  else",
          "3253:      found_new_match = searchit(NULL, ins_buf, cur_match_pos, NULL,",
          "3254:       compl_direction,",
          "3255:       compl_pattern, 1L, SEARCH_KEEP + SEARCH_NFMSG,",
          "3256:       RE_LAST, NULL);",
          "3257:  --msg_silent;",
          "3258:  if (!compl_started || *save_match_pos)",
          "3259:  {",
          "3261:      compl_started = TRUE;",
          "3265:  }",
          "3266:  else if (first_match_pos->lnum == last_match_pos->lnum",
          "3267:   && first_match_pos->col == last_match_pos->col)",
          "3268:  {",
          "3269:      found_new_match = FAIL;",
          "3270:  }",
          "3271:  else if ((compl_direction == FORWARD)",
          "3272:   && (prev_match_pos->lnum > cur_match_pos->lnum",
          "3273:       || (prev_match_pos->lnum == cur_match_pos->lnum",
          "3274:    && prev_match_pos->col >= cur_match_pos->col)))",
          "3275:  {",
          "3276:      if (looped_around)",
          "3277:   found_new_match = FAIL;",
          "3278:      else",
          "3279:   looped_around = TRUE;",
          "3280:  }",
          "3281:  else if ((compl_direction != FORWARD)",
          "3282:   && (prev_match_pos->lnum < cur_match_pos->lnum",
          "3283:       || (prev_match_pos->lnum == cur_match_pos->lnum",
          "3284:    && prev_match_pos->col <= cur_match_pos->col)))",
          "3285:  {",
          "3286:      if (looped_around)",
          "3287:   found_new_match = FAIL;",
          "3288:      else",
          "3289:   looped_around = TRUE;",
          "3290:  }",
          "3292:  if (found_new_match == FAIL)",
          "3293:      break;",
          "3296:  if ((compl_cont_status & CONT_ADDING) && ins_buf == curbuf",
          "3297:   && start_pos->lnum == cur_match_pos->lnum",
          "3298:   && start_pos->col  == cur_match_pos->col)",
          "3299:      continue;",
          "3300:  ptr = ml_get_buf(ins_buf, cur_match_pos->lnum, FALSE) +",
          "3301:        cur_match_pos->col;",
          "3302:  if (ctrl_x_mode_line_or_eval())",
          "3303:  {",
          "3304:      if (compl_cont_status & CONT_ADDING)",
          "3305:      {",
          "3306:   if (cur_match_pos->lnum >= ins_buf->b_ml.ml_line_count)",
          "3307:       continue;",
          "3308:   ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);",
          "3309:   if (!p_paste)",
          "3310:       ptr = skipwhite(ptr);",
          "3311:      }",
          "3312:      len = (int)STRLEN(ptr);",
          "3313:  }",
          "3314:  else",
          "3315:  {",
          "3316:      char_u *tmp_ptr = ptr;",
          "3318:      if (compl_cont_status & CONT_ADDING)",
          "3319:      {",
          "3320:   tmp_ptr += compl_length;",
          "3322:   if (vim_iswordp(tmp_ptr))",
          "3323:       continue;",
          "3325:   tmp_ptr = find_word_start(tmp_ptr);",
          "3326:      }",
          "3328:      tmp_ptr = find_word_end(tmp_ptr);",
          "3329:      len = (int)(tmp_ptr - ptr);",
          "3331:      if ((compl_cont_status & CONT_ADDING) && len == compl_length)",
          "3332:      {",
          "3333:   if (cur_match_pos->lnum < ins_buf->b_ml.ml_line_count)",
          "3334:   {",
          "3340:       STRNCPY(IObuff, ptr, len);",
          "3341:       ptr = ml_get_buf(ins_buf, cur_match_pos->lnum + 1, FALSE);",
          "3342:       tmp_ptr = ptr = skipwhite(ptr);",
          "3344:       tmp_ptr = find_word_start(tmp_ptr);",
          "3346:       tmp_ptr = find_word_end(tmp_ptr);",
          "3347:       if (tmp_ptr > ptr)",
          "3348:       {",
          "3349:    if (*ptr != ')' && IObuff[len - 1] != TAB)",
          "3350:    {",
          "3351:        if (IObuff[len - 1] != ' ')",
          "3352:     IObuff[len++] = ' ';",
          "3354:        if (p_js",
          "3355:         && (IObuff[len - 2] == '.'",
          "3356:      || (vim_strchr(p_cpo, CPO_JOINSP)",
          "3357:          == NULL",
          "3358:          && (IObuff[len - 2] == '?'",
          "3359:       || IObuff[len - 2] == '!'))))",
          "3360:     IObuff[len++] = ' ';",
          "3361:    }",
          "3363:    if (tmp_ptr - ptr >= IOSIZE - len)",
          "3364:        tmp_ptr = ptr + IOSIZE - len - 1;",
          "3365:    STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);",
          "3366:    len += (int)(tmp_ptr - ptr);",
          "3367:    cont_s_ipos = TRUE;",
          "3368:       }",
          "3369:       IObuff[len] = NUL;",
          "3370:       ptr = IObuff;",
          "3371:   }",
          "3372:   if (len == compl_length)",
          "3373:       continue;",
          "3374:      }",
          "3375:  }",
          "3376:  if (ins_compl_add_infercase(ptr, len, p_ic,",
          "3377:       ins_buf == curbuf ? NULL : ins_buf->b_sfname,",
          "3378:       0, cont_s_ipos) != NOTDONE)",
          "3379:  {",
          "3380:      found_new_match = OK;",
          "3381:      break;",
          "3382:  }",
          "3383:     }",
          "3384:     p_scs = save_p_scs;",
          "3385:     p_ws = save_p_ws;",
          "3387:     return found_new_match;",
          "3388: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2920:     static buf_T *ins_buf = NULL; // buffer being scanned",
          "2922:     pos_T *pos;",
          "2927:     int  i;",
          "2930:     int  found_new_match;",
          "2931:     int  type = ctrl_x_mode;",
          "2933:     char_u *dict = NULL;",
          "2934:     int  dict_f = 0;",
          "2935:     int  set_match_pos;",
          "2936:     pos_T prev_pos = {0, 0, 0};",
          "2939:     if (!compl_started)",
          "2940:     {",
          "",
          "[Removed Lines]",
          "2923:     char_u **matches;",
          "2924:     int  save_p_scs;",
          "2925:     int  save_p_ws;",
          "2926:     int  save_p_ic;",
          "2928:     int  num_matches;",
          "2929:     int  len;",
          "2932:     char_u *ptr;",
          "2937:     int  looped_around = FALSE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2965:       || ctrl_x_mode_line_or_eval())",
          "2966:      && (!compl_started || found_all))",
          "2967:  {",
          "3024:   break;",
          "3064:  }",
          "",
          "[Removed Lines]",
          "2968:      found_all = FALSE;",
          "2969:      while (*e_cpt == ',' || *e_cpt == ' ')",
          "2970:   e_cpt++;",
          "2971:      if (*e_cpt == '.' && !curbuf->b_scanned)",
          "2972:      {",
          "2973:   ins_buf = curbuf;",
          "2974:   first_match_pos = *ini;",
          "2977:   if (ctrl_x_mode == CTRL_X_NORMAL && dec(&first_match_pos) < 0)",
          "2978:   {",
          "2982:       first_match_pos.lnum = ins_buf->b_ml.ml_line_count;",
          "2983:       first_match_pos.col =",
          "2984:      (colnr_T)STRLEN(ml_get(first_match_pos.lnum));",
          "2985:   }",
          "2986:   last_match_pos = first_match_pos;",
          "2987:   type = 0;",
          "2991:   set_match_pos = TRUE;",
          "2992:      }",
          "2993:      else if (vim_strchr((char_u *)\"buwU\", *e_cpt) != NULL",
          "2994:    && (ins_buf = ins_compl_next_buf(ins_buf, *e_cpt)) != curbuf)",
          "2995:      {",
          "2997:   if (ins_buf->b_ml.ml_mfp != NULL)   // loaded buffer",
          "2998:   {",
          "2999:       compl_started = TRUE;",
          "3000:       first_match_pos.col = last_match_pos.col = 0;",
          "3001:       first_match_pos.lnum = ins_buf->b_ml.ml_line_count + 1;",
          "3002:       last_match_pos.lnum = 0;",
          "3003:       type = 0;",
          "3004:   }",
          "3005:   else // unloaded buffer, scan like dictionary",
          "3006:   {",
          "3007:       found_all = TRUE;",
          "3008:       if (ins_buf->b_fname == NULL)",
          "3009:    continue;",
          "3010:       type = CTRL_X_DICTIONARY;",
          "3011:       dict = ins_buf->b_fname;",
          "3012:       dict_f = DICT_EXACT;",
          "3013:   }",
          "3014:   msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3015:   vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),",
          "3016:    ins_buf->b_fname == NULL",
          "3017:        ? buf_spname(ins_buf)",
          "3018:        : ins_buf->b_sfname == NULL",
          "3019:     ? ins_buf->b_fname",
          "3020:     : ins_buf->b_sfname);",
          "3021:   (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "3022:      }",
          "3023:      else if (*e_cpt == NUL)",
          "3025:      else",
          "3026:      {",
          "3027:   if (ctrl_x_mode_line_or_eval())",
          "3028:       type = -1;",
          "3029:   else if (*e_cpt == 'k' || *e_cpt == 's')",
          "3030:   {",
          "3031:       if (*e_cpt == 'k')",
          "3032:    type = CTRL_X_DICTIONARY;",
          "3033:       else",
          "3034:    type = CTRL_X_THESAURUS;",
          "3035:       if (*++e_cpt != ',' && *e_cpt != NUL)",
          "3036:       {",
          "3037:    dict = e_cpt;",
          "3038:    dict_f = DICT_FIRST;",
          "3039:       }",
          "3040:   }",
          "3041: #ifdef FEAT_FIND_ID",
          "3042:   else if (*e_cpt == 'i')",
          "3043:       type = CTRL_X_PATH_PATTERNS;",
          "3044:   else if (*e_cpt == 'd')",
          "3045:       type = CTRL_X_PATH_DEFINES;",
          "3046: #endif",
          "3047:   else if (*e_cpt == ']' || *e_cpt == 't')",
          "3048:   {",
          "3049:       msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3050:       type = CTRL_X_TAGS;",
          "3051:       vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning tags.\"));",
          "3052:       (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "3053:   }",
          "3054:   else",
          "3055:       type = -1;",
          "3058:   (void)copy_option_part(&e_cpt, IObuff, IOSIZE, \",\");",
          "3060:   found_all = TRUE;",
          "3061:   if (type == -1)",
          "3062:       continue;",
          "3063:      }",
          "",
          "[Added Lines]",
          "3447:      int status = process_next_cpt_value(&e_cpt, &type, &found_all,",
          "3448:       &ins_buf, ini, &first_match_pos, &last_match_pos,",
          "3449:       &set_match_pos, &dict, &dict_f);",
          "3451:      if (status == INS_COMPL_CPT_END)",
          "3453:      if (status == INS_COMPL_CPT_CONT)",
          "3454:   continue;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3075: #ifdef FEAT_FIND_ID",
          "3076:  case CTRL_X_PATH_PATTERNS:",
          "3077:  case CTRL_X_PATH_DEFINES:",
          "3084:      break;",
          "3085: #endif",
          "3087:  case CTRL_X_DICTIONARY:",
          "3088:  case CTRL_X_THESAURUS:",
          "3107:      break;",
          "3109:  case CTRL_X_TAGS:",
          "3124:      break;",
          "3126:  case CTRL_X_FILES:",
          "3155:      break;",
          "3157:  case CTRL_X_CMDLINE:",
          "3158:  case CTRL_X_CMDLINE_CTRL_X:",
          "3163:      break;",
          "3165: #ifdef FEAT_COMPL_FUNC",
          "",
          "[Removed Lines]",
          "3078:      find_pattern_in_path(compl_pattern, compl_direction,",
          "3079:      (int)STRLEN(compl_pattern), FALSE, FALSE,",
          "3080:      (type == CTRL_X_PATH_DEFINES",
          "3081:       && !(compl_cont_status & CONT_SOL))",
          "3082:      ? FIND_DEFINE : FIND_ANY, 1L, ACTION_EXPAND,",
          "3083:      (linenr_T)1, (linenr_T)MAXLNUM);",
          "3089: #ifdef FEAT_COMPL_FUNC",
          "3090:      if (thesaurus_func_complete(type))",
          "3091:   expand_by_function(type, compl_pattern);",
          "3092:      else",
          "3093: #endif",
          "3094:   ins_compl_dictionaries(",
          "3095:       dict != NULL ? dict",
          "3096:     : (type == CTRL_X_THESAURUS",
          "3097:         ? (*curbuf->b_p_tsr == NUL",
          "3098:      ? p_tsr",
          "3099:      : curbuf->b_p_tsr)",
          "3100:         : (*curbuf->b_p_dict == NUL",
          "3101:      ? p_dict",
          "3102:      : curbuf->b_p_dict)),",
          "3103:        compl_pattern,",
          "3104:      dict != NULL ? dict_f",
          "3105:             : 0, type == CTRL_X_THESAURUS);",
          "3106:      dict = NULL;",
          "3111:      save_p_ic = p_ic;",
          "3112:      p_ic = ignorecase(compl_pattern);",
          "3116:      g_tag_at_cursor = TRUE;",
          "3117:      if (find_tags(compl_pattern, &num_matches, &matches,",
          "3118:       TAG_REGEXP | TAG_NAMES | TAG_NOIC | TAG_INS_COMP",
          "3119:       | (ctrl_x_mode != CTRL_X_NORMAL ? TAG_VERBOSE : 0),",
          "3120:       TAG_MANY, curbuf->b_ffname) == OK && num_matches > 0)",
          "3121:   ins_compl_add_matches(num_matches, matches, p_ic);",
          "3122:      g_tag_at_cursor = FALSE;",
          "3123:      p_ic = save_p_ic;",
          "3127:      if (expand_wildcards(1, &compl_pattern, &num_matches, &matches,",
          "3128:       EW_FILE|EW_DIR|EW_ADDSLASH|EW_SILENT) == OK)",
          "3129:      {",
          "3132:   tilde_replace(compl_pattern, num_matches, matches);",
          "3133: #ifdef BACKSLASH_IN_FILENAME",
          "3134:   if (curbuf->b_p_csl[0] != NUL)",
          "3135:   {",
          "3136:       int     i;",
          "3138:       for (i = 0; i < num_matches; ++i)",
          "3139:       {",
          "3140:    char_u *ptr = matches[i];",
          "3142:    while (*ptr != NUL)",
          "3143:    {",
          "3144:        if (curbuf->b_p_csl[0] == 's' && *ptr == '\\\\')",
          "3146:        else if (curbuf->b_p_csl[0] == 'b' && *ptr == '/')",
          "3148:        ptr += (*mb_ptr2len)(ptr);",
          "3149:    }",
          "3150:       }",
          "3151:   }",
          "3152: #endif",
          "3153:   ins_compl_add_matches(num_matches, matches, p_fic || p_wic);",
          "3154:      }",
          "3159:      if (expand_cmdline(&compl_xp, compl_pattern,",
          "3160:    (int)STRLEN(compl_pattern),",
          "3161:       &num_matches, &matches) == EXPAND_OK)",
          "3162:   ins_compl_add_matches(num_matches, matches, FALSE);",
          "",
          "[Added Lines]",
          "3469:      get_next_include_file_completion(type);",
          "3475:      get_next_dict_tsr_completion(type, &dict, dict_f);",
          "3479:      get_next_tag_completion();",
          "3483:      get_next_filename_completion();",
          "3488:      get_next_cmdline_completion();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3170: #endif",
          "3172:  case CTRL_X_SPELL:",
          "3179:      break;",
          "3181:  default: // normal ^P/^N and ^X^L",
          "3347:  }",
          "",
          "[Removed Lines]",
          "3173: #ifdef FEAT_SPELL",
          "3174:      num_matches = expand_spelling(first_match_pos.lnum,",
          "3175:            compl_pattern, &matches);",
          "3176:      if (num_matches > 0)",
          "3177:   ins_compl_add_matches(num_matches, matches, p_ic);",
          "3178: #endif",
          "3183:      save_p_scs = p_scs;",
          "3184:      if (ins_buf->b_p_inf)",
          "3185:   p_scs = FALSE;",
          "3191:      save_p_ws = p_ws;",
          "3192:      if (ins_buf != curbuf)",
          "3193:   p_ws = FALSE;",
          "3194:      else if (*e_cpt == '.')",
          "3195:   p_ws = TRUE;",
          "3196:      looped_around = FALSE;",
          "3197:      for (;;)",
          "3198:      {",
          "3199:   int cont_s_ipos = FALSE;",
          "3201:   ++msg_silent;  // Don't want messages for wrapscan.",
          "3205:   if (ctrl_x_mode_line_or_eval()",
          "3206:    || (compl_cont_status & CONT_SOL))",
          "3207:       found_new_match = search_for_exact_line(ins_buf, pos,",
          "3208:            compl_direction, compl_pattern);",
          "3209:   else",
          "3210:       found_new_match = searchit(NULL, ins_buf, pos, NULL,",
          "3211:              compl_direction,",
          "3212:      compl_pattern, 1L, SEARCH_KEEP + SEARCH_NFMSG,",
          "3213:         RE_LAST, NULL);",
          "3214:   --msg_silent;",
          "3215:   if (!compl_started || set_match_pos)",
          "3216:   {",
          "3218:       compl_started = TRUE;",
          "3219:       first_match_pos = *pos;",
          "3220:       last_match_pos = *pos;",
          "3221:       set_match_pos = FALSE;",
          "3222:   }",
          "3223:   else if (first_match_pos.lnum == last_match_pos.lnum",
          "3224:                                 && first_match_pos.col == last_match_pos.col)",
          "3225:   {",
          "3226:       found_new_match = FAIL;",
          "3227:   }",
          "3228:   else if ((compl_direction == FORWARD)",
          "3229:    && (prev_pos.lnum > pos->lnum",
          "3230:        || (prev_pos.lnum == pos->lnum",
          "3231:     && prev_pos.col >= pos->col)))",
          "3232:   {",
          "3233:       if (looped_around)",
          "3234:    found_new_match = FAIL;",
          "3235:       else",
          "3236:    looped_around = TRUE;",
          "3237:   }",
          "3238:   else if ((compl_direction != FORWARD)",
          "3239:    && (prev_pos.lnum < pos->lnum",
          "3240:        || (prev_pos.lnum == pos->lnum",
          "3241:     && prev_pos.col <= pos->col)))",
          "3242:   {",
          "3243:       if (looped_around)",
          "3244:    found_new_match = FAIL;",
          "3245:       else",
          "3246:    looped_around = TRUE;",
          "3247:   }",
          "3248:   prev_pos = *pos;",
          "3249:   if (found_new_match == FAIL)",
          "3250:   {",
          "3251:       if (ins_buf == curbuf)",
          "3252:    found_all = TRUE;",
          "3253:       break;",
          "3254:   }",
          "3257:   if ( (compl_cont_status & CONT_ADDING) && ins_buf == curbuf",
          "3258:    && ini->lnum == pos->lnum",
          "3259:    && ini->col  == pos->col)",
          "3260:       continue;",
          "3261:   ptr = ml_get_buf(ins_buf, pos->lnum, FALSE) + pos->col;",
          "3262:   if (ctrl_x_mode_line_or_eval())",
          "3263:   {",
          "3264:       if (compl_cont_status & CONT_ADDING)",
          "3265:       {",
          "3266:    if (pos->lnum >= ins_buf->b_ml.ml_line_count)",
          "3267:        continue;",
          "3268:    ptr = ml_get_buf(ins_buf, pos->lnum + 1, FALSE);",
          "3269:    if (!p_paste)",
          "3270:        ptr = skipwhite(ptr);",
          "3271:       }",
          "3272:       len = (int)STRLEN(ptr);",
          "3273:   }",
          "3274:   else",
          "3275:   {",
          "3276:       char_u *tmp_ptr = ptr;",
          "3278:       if (compl_cont_status & CONT_ADDING)",
          "3279:       {",
          "3280:    tmp_ptr += compl_length;",
          "3282:    if (vim_iswordp(tmp_ptr))",
          "3283:        continue;",
          "3285:    tmp_ptr = find_word_start(tmp_ptr);",
          "3286:       }",
          "3288:       tmp_ptr = find_word_end(tmp_ptr);",
          "3289:       len = (int)(tmp_ptr - ptr);",
          "3291:       if ((compl_cont_status & CONT_ADDING)",
          "3292:              && len == compl_length)",
          "3293:       {",
          "3294:    if (pos->lnum < ins_buf->b_ml.ml_line_count)",
          "3295:    {",
          "3301:        STRNCPY(IObuff, ptr, len);",
          "3302:        ptr = ml_get_buf(ins_buf, pos->lnum + 1, FALSE);",
          "3303:        tmp_ptr = ptr = skipwhite(ptr);",
          "3305:        tmp_ptr = find_word_start(tmp_ptr);",
          "3307:        tmp_ptr = find_word_end(tmp_ptr);",
          "3308:        if (tmp_ptr > ptr)",
          "3309:        {",
          "3310:     if (*ptr != ')' && IObuff[len - 1] != TAB)",
          "3311:     {",
          "3312:         if (IObuff[len - 1] != ' ')",
          "3313:      IObuff[len++] = ' ';",
          "3315:         if (p_js",
          "3316:      && (IObuff[len - 2] == '.'",
          "3317:          || (vim_strchr(p_cpo, CPO_JOINSP)",
          "3318:                == NULL",
          "3319:       && (IObuff[len - 2] == '?'",
          "3320:        || IObuff[len - 2] == '!'))))",
          "3321:      IObuff[len++] = ' ';",
          "3322:     }",
          "3324:     if (tmp_ptr - ptr >= IOSIZE - len)",
          "3325:         tmp_ptr = ptr + IOSIZE - len - 1;",
          "3326:     STRNCPY(IObuff + len, ptr, tmp_ptr - ptr);",
          "3327:     len += (int)(tmp_ptr - ptr);",
          "3328:     cont_s_ipos = TRUE;",
          "3329:        }",
          "3330:        IObuff[len] = NUL;",
          "3331:        ptr = IObuff;",
          "3332:    }",
          "3333:    if (len == compl_length)",
          "3334:        continue;",
          "3335:       }",
          "3336:   }",
          "3337:   if (ins_compl_add_infercase(ptr, len, p_ic,",
          "3338:      ins_buf == curbuf ? NULL : ins_buf->b_sfname,",
          "3339:         0, cont_s_ipos) != NOTDONE)",
          "3340:   {",
          "3341:       found_new_match = OK;",
          "3342:       break;",
          "3343:   }",
          "3344:      }",
          "3345:      p_scs = save_p_scs;",
          "3346:      p_ws = save_p_ws;",
          "",
          "[Added Lines]",
          "3499:      get_next_spell_completion(first_match_pos.lnum);",
          "3503:      found_new_match = get_next_default_completion(ins_buf, ini, pos,",
          "3504:       &prev_pos, &set_match_pos, &first_match_pos,",
          "3505:       &last_match_pos, (*e_cpt == '.'));",
          "3506:      if (found_new_match == FAIL && ins_buf == curbuf)",
          "3507:   found_all = TRUE;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3845:     static int",
          "3846: get_normal_compl_info(char_u *line, int startcol, colnr_T curs_col)",
          "3847: {",
          "3850:     {",
          "3851:  if (!(compl_cont_status & CONT_ADDING))",
          "3852:  {",
          "",
          "[Removed Lines]",
          "3848:     if ((compl_cont_status & CONT_SOL)",
          "3849:      || ctrl_x_mode == CTRL_X_PATH_DEFINES)",
          "",
          "[Added Lines]",
          "4009:     if ((compl_cont_status & CONT_SOL) || ctrl_x_mode == CTRL_X_PATH_DEFINES)",
          "",
          "---------------"
        ],
        "src/testdir/test_ins_complete.vim||src/testdir/test_ins_complete.vim": [
          "File: src/testdir/test_ins_complete.vim -> src/testdir/test_ins_complete.vim",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:   exe \"normal o\\<C-X>\\<C-P>\\<C-P>\\<C-X>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-N>\"",
          "48:   call assert_equal('run1 run2', getline('.'))",
          "51:   \" i-add-expands and switches to local",
          "52:   exe \"normal OM\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-N>\\<C-X>\\<C-X>\\<C-X>\\<C-P>\"",
          "53:   call assert_equal(\"Makefile\\tto\\trun3\", getline('.'))",
          "",
          "[Removed Lines]",
          "50:   set cpt=.,w,i",
          "",
          "[Added Lines]",
          "50:   set cpt=.,\\ ,w,i",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "748:   close!",
          "749: endfunc",
          "751: \" Test for using CTRL-L to add one character when completing matching",
          "752: func Test_complete_add_onechar()",
          "753:   new",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "751: \" Test for completing words with a '.' at the end of a word.",
          "752: func Test_complete_joinspaces()",
          "753:   new",
          "754:   call setline(1, ['one two.', 'three. four'])",
          "755:   set joinspaces",
          "756:   exe \"normal Goon\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\\<C-X>\\<C-P>\"",
          "757:   call assert_equal(\"one two.  three. four\", getline(3))",
          "758:   set joinspaces&",
          "759:   bw!",
          "760: endfunc",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "768:   close!",
          "769: endfunc",
          "771: \" Test insert completion with 'cindent' (adjust the indent)",
          "772: func Test_complete_with_cindent()",
          "773:   new",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "782: \" Test for using CTRL-X CTRL-L to complete whole lines lines",
          "783: func Test_complete_wholeline()",
          "784:   new",
          "785:   \" complete one-line",
          "786:   call setline(1, ['a1', 'a2'])",
          "787:   exe \"normal ggoa\\<C-X>\\<C-L>\"",
          "788:   call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))",
          "789:   \" go to the next match (wrapping around the buffer)",
          "790:   exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\"",
          "791:   call assert_equal(['a1', 'a', 'a2'], getline(1, '$'))",
          "792:   \" go to the next match",
          "793:   exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\\<C-N>\"",
          "794:   call assert_equal(['a1', 'a2', 'a2'], getline(1, '$'))",
          "795:   exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-N>\\<C-N>\\<C-N>\"",
          "796:   call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))",
          "797:   \" repeat the test using CTRL-L",
          "798:   \" go to the next match (wrapping around the buffer)",
          "799:   exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\"",
          "800:   call assert_equal(['a1', 'a2', 'a2'], getline(1, '$'))",
          "801:   \" go to the next match",
          "802:   exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\\<C-L>\"",
          "803:   call assert_equal(['a1', 'a', 'a2'], getline(1, '$'))",
          "804:   exe \"normal 2GCa\\<C-X>\\<C-L>\\<C-L>\\<C-L>\\<C-L>\"",
          "805:   call assert_equal(['a1', 'a1', 'a2'], getline(1, '$'))",
          "806:   %d",
          "807:   \" use CTRL-X CTRL-L to add one more line",
          "808:   call setline(1, ['a1', 'b1'])",
          "809:   setlocal complete=.",
          "810:   exe \"normal ggOa\\<C-X>\\<C-L>\\<C-X>\\<C-L>\\<C-X>\\<C-L>\"",
          "811:   call assert_equal(['a1', 'b1', '', 'a1', 'b1'], getline(1, '$'))",
          "812:   bw!",
          "813: endfunc",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3936,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3937,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d4566c14e71c55dcef05fb34ea94eba835831527",
      "candidate_info": {
        "commit_hash": "d4566c14e71c55dcef05fb34ea94eba835831527",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/d4566c14e71c55dcef05fb34ea94eba835831527",
        "files": [
          "src/move.c",
          "src/version.c"
        ],
        "message": "patch 9.0.0581: adding a character for incsearch fails at end of line\n\nProblem:    Adding a character for incsearch fails at end of line.\nSolution:   Only check cursor line number.",
        "before_after_code_files": [
          "src/move.c||src/move.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/move.c||src/move.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/move.c||src/move.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/move.c||src/move.c": [
          "File: src/move.c -> src/move.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "683:     void",
          "684: validate_cursor(void)",
          "685: {",
          "687:     check_cursor_moved(curwin);",
          "688:     if ((curwin->w_valid & (VALID_WCOL|VALID_WROW)) != (VALID_WCOL|VALID_WROW))",
          "689:  curs_columns(TRUE);",
          "",
          "[Removed Lines]",
          "686:     check_cursor();",
          "",
          "[Added Lines]",
          "686:     check_cursor_lnum();",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "700: static int included_patches[] =",
          "703:     580,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "703:     581,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6ad84ab3e48d9490e4139df04f2c55b136f5501d",
      "candidate_info": {
        "commit_hash": "6ad84ab3e48d9490e4139df04f2c55b136f5501d",
        "repo": "vim/vim",
        "commit_url": "https://github.com/vim/vim/commit/6ad84ab3e48d9490e4139df04f2c55b136f5501d",
        "files": [
          "src/insexpand.c",
          "src/version.c"
        ],
        "message": "patch 8.2.3953: insert completion code is too complicated\n\nProblem:    Insert completion code is too complicated.\nSolution:   More refactoring.  Move function arguments into a struct.\n            (Yegappan Lakshmanan, closes #9437)",
        "before_after_code_files": [
          "src/insexpand.c||src/insexpand.c",
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/insexpand.c||src/insexpand.c",
            "src/version.c||src/version.c"
          ],
          "candidate": [
            "src/insexpand.c||src/insexpand.c",
            "src/version.c||src/version.c"
          ]
        }
      },
      "candidate_diff": {
        "src/insexpand.c||src/insexpand.c": [
          "File: src/insexpand.c -> src/insexpand.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "391:     return FALSE;",
          "392: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "398:     static int",
          "399: ins_compl_at_original_text(compl_T *match)",
          "400: {",
          "401:     return match->cp_flags & CP_ORIGINAL_TEXT;",
          "402: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "425:     return vim_iswordc(c);",
          "426: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "441:     static char_u *",
          "442: ins_compl_infercase_gettext(",
          "443:  char_u *str,",
          "444:  int actual_len,",
          "445:  int actual_compl_length,",
          "446:  int min_len)",
          "447: {",
          "448:     int  *wca;   // Wide character array.",
          "449:     char_u *p;",
          "450:     int  i, c;",
          "451:     int  has_lower = FALSE;",
          "452:     int  was_letter = FALSE;",
          "454:     IObuff[0] = NUL;",
          "457:     wca = ALLOC_MULT(int, actual_len);",
          "458:     if (wca == NULL)",
          "459:  return IObuff;",
          "461:     p = str;",
          "462:     for (i = 0; i < actual_len; ++i)",
          "463:  if (has_mbyte)",
          "464:      wca[i] = mb_ptr2char_adv(&p);",
          "465:  else",
          "466:      wca[i] = *(p++);",
          "469:     p = compl_orig_text;",
          "470:     for (i = 0; i < min_len; ++i)",
          "471:     {",
          "472:  if (has_mbyte)",
          "473:      c = mb_ptr2char_adv(&p);",
          "474:  else",
          "475:      c = *(p++);",
          "476:  if (MB_ISLOWER(c))",
          "477:  {",
          "478:      has_lower = TRUE;",
          "479:      if (MB_ISUPPER(wca[i]))",
          "480:      {",
          "482:   for (i = actual_compl_length; i < actual_len; ++i)",
          "483:       wca[i] = MB_TOLOWER(wca[i]);",
          "484:   break;",
          "485:      }",
          "486:  }",
          "487:     }",
          "491:     if (!has_lower)",
          "492:     {",
          "493:  p = compl_orig_text;",
          "494:  for (i = 0; i < min_len; ++i)",
          "495:  {",
          "496:      if (has_mbyte)",
          "497:   c = mb_ptr2char_adv(&p);",
          "498:      else",
          "499:   c = *(p++);",
          "500:      if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))",
          "501:      {",
          "503:   for (i = actual_compl_length; i < actual_len; ++i)",
          "504:       wca[i] = MB_TOUPPER(wca[i]);",
          "505:   break;",
          "506:      }",
          "507:      was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);",
          "508:  }",
          "509:     }",
          "512:     p = compl_orig_text;",
          "513:     for (i = 0; i < min_len; ++i)",
          "514:     {",
          "515:  if (has_mbyte)",
          "516:      c = mb_ptr2char_adv(&p);",
          "517:  else",
          "518:      c = *(p++);",
          "519:  if (MB_ISLOWER(c))",
          "520:      wca[i] = MB_TOLOWER(wca[i]);",
          "521:  else if (MB_ISUPPER(c))",
          "522:      wca[i] = MB_TOUPPER(wca[i]);",
          "523:     }",
          "529:     p = IObuff;",
          "530:     i = 0;",
          "531:     while (i < actual_len && (p - IObuff + 6) < IOSIZE)",
          "532:  if (has_mbyte)",
          "533:      p += (*mb_char2bytes)(wca[i++], p);",
          "534:  else",
          "538:     vim_free(wca);",
          "540:     return IObuff;",
          "541: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "442: {",
          "443:     char_u *str = str_arg;",
          "444:     char_u *p;",
          "446:     int  actual_len;  // Take multi-byte characters",
          "447:     int  actual_compl_length; // into account.",
          "448:     int  min_len;",
          "452:     int  flags = 0;",
          "454:     if (p_ic && curbuf->b_p_inf && len > 0)",
          "",
          "[Removed Lines]",
          "445:     int  i, c;",
          "449:     int  *wca;   // Wide character array.",
          "450:     int  has_lower = FALSE;",
          "451:     int  was_letter = FALSE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "488:  min_len = actual_len < actual_compl_length",
          "489:         ? actual_len : actual_compl_length;",
          "576:     }",
          "577:     if (cont_s_ipos)",
          "578:  flags |= CP_CONT_S_IPOS;",
          "",
          "[Removed Lines]",
          "492:  wca = ALLOC_MULT(int, actual_len);",
          "493:  if (wca != NULL)",
          "494:  {",
          "495:      p = str;",
          "496:      for (i = 0; i < actual_len; ++i)",
          "497:   if (has_mbyte)",
          "498:       wca[i] = mb_ptr2char_adv(&p);",
          "499:   else",
          "500:       wca[i] = *(p++);",
          "503:      p = compl_orig_text;",
          "504:      for (i = 0; i < min_len; ++i)",
          "505:      {",
          "506:   if (has_mbyte)",
          "507:       c = mb_ptr2char_adv(&p);",
          "508:   else",
          "509:       c = *(p++);",
          "510:   if (MB_ISLOWER(c))",
          "511:   {",
          "512:       has_lower = TRUE;",
          "513:       if (MB_ISUPPER(wca[i]))",
          "514:       {",
          "516:    for (i = actual_compl_length; i < actual_len; ++i)",
          "517:        wca[i] = MB_TOLOWER(wca[i]);",
          "518:    break;",
          "519:       }",
          "520:   }",
          "521:      }",
          "525:      if (!has_lower)",
          "526:      {",
          "527:   p = compl_orig_text;",
          "528:   for (i = 0; i < min_len; ++i)",
          "529:   {",
          "530:       if (has_mbyte)",
          "531:    c = mb_ptr2char_adv(&p);",
          "532:       else",
          "533:    c = *(p++);",
          "534:       if (was_letter && MB_ISUPPER(c) && MB_ISLOWER(wca[i]))",
          "535:       {",
          "537:    for (i = actual_compl_length; i < actual_len; ++i)",
          "538:        wca[i] = MB_TOUPPER(wca[i]);",
          "539:    break;",
          "540:       }",
          "541:       was_letter = MB_ISLOWER(c) || MB_ISUPPER(c);",
          "542:   }",
          "543:      }",
          "546:      p = compl_orig_text;",
          "547:      for (i = 0; i < min_len; ++i)",
          "548:      {",
          "549:   if (has_mbyte)",
          "550:       c = mb_ptr2char_adv(&p);",
          "551:   else",
          "552:       c = *(p++);",
          "553:   if (MB_ISLOWER(c))",
          "554:       wca[i] = MB_TOLOWER(wca[i]);",
          "555:   else if (MB_ISUPPER(c))",
          "556:       wca[i] = MB_TOUPPER(wca[i]);",
          "557:      }",
          "563:      p = IObuff;",
          "564:      i = 0;",
          "565:      while (i < actual_len && (p - IObuff + 6) < IOSIZE)",
          "566:   if (has_mbyte)",
          "567:       p += (*mb_char2bytes)(wca[i++], p);",
          "568:   else",
          "572:      vim_free(wca);",
          "573:  }",
          "575:  str = IObuff;",
          "",
          "[Added Lines]",
          "602:  str = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,",
          "603:         min_len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "618:  match = compl_first_match;",
          "619:  do",
          "620:  {",
          "622:       && STRNCMP(match->cp_str, str, len) == 0",
          "623:       && match->cp_str[len] == NUL)",
          "624:   return NOTDONE;",
          "",
          "[Removed Lines]",
          "621:      if (    !(match->cp_flags & CP_ORIGINAL_TEXT)",
          "",
          "[Added Lines]",
          "649:      if (!ins_compl_at_original_text(match)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "730:     {",
          "732:  compl_leader = vim_strsave(match->cp_str);",
          "736:      ins_compl_delete();",
          "746:     }",
          "748:     {",
          "753:  {",
          "777:  }",
          "780:  {",
          "792:  }",
          "795:     }",
          "796: }",
          "",
          "[Removed Lines]",
          "733:  if (compl_leader != NULL)",
          "734:  {",
          "735:      had_match = (curwin->w_cursor.col > compl_col);",
          "737:      ins_bytes(compl_leader + ins_compl_len());",
          "738:      ins_redraw(FALSE);",
          "742:      if (!had_match)",
          "743:   ins_compl_delete();",
          "744:      compl_used_match = FALSE;",
          "745:  }",
          "747:     else",
          "750:  p = compl_leader;",
          "751:  s = match->cp_str;",
          "752:  while (*p != NUL)",
          "754:      if (has_mbyte)",
          "755:      {",
          "756:   c1 = mb_ptr2char(p);",
          "757:   c2 = mb_ptr2char(s);",
          "758:      }",
          "759:      else",
          "760:      {",
          "761:   c1 = *p;",
          "762:   c2 = *s;",
          "763:      }",
          "764:      if ((match->cp_flags & CP_ICASE)",
          "765:         ? (MB_TOLOWER(c1) != MB_TOLOWER(c2)) : (c1 != c2))",
          "766:   break;",
          "767:      if (has_mbyte)",
          "768:      {",
          "769:   MB_PTR_ADV(p);",
          "770:   MB_PTR_ADV(s);",
          "771:      }",
          "772:      else",
          "773:      {",
          "774:   ++p;",
          "775:   ++s;",
          "776:      }",
          "779:  if (*p != NUL)",
          "783:      had_match = (curwin->w_cursor.col > compl_col);",
          "784:      ins_compl_delete();",
          "785:      ins_bytes(compl_leader + ins_compl_len());",
          "786:      ins_redraw(FALSE);",
          "790:      if (!had_match)",
          "791:   ins_compl_delete();",
          "794:  compl_used_match = FALSE;",
          "",
          "[Added Lines]",
          "761:  if (compl_leader == NULL)",
          "762:      return;",
          "764:  had_match = (curwin->w_cursor.col > compl_col);",
          "765:  ins_compl_delete();",
          "766:  ins_bytes(compl_leader + ins_compl_len());",
          "767:  ins_redraw(FALSE);",
          "771:  if (!had_match)",
          "773:  compl_used_match = FALSE;",
          "775:  return;",
          "779:     p = compl_leader;",
          "780:     s = match->cp_str;",
          "781:     while (*p != NUL)",
          "783:  if (has_mbyte)",
          "785:      c1 = mb_ptr2char(p);",
          "786:      c2 = mb_ptr2char(s);",
          "788:  else",
          "790:      c1 = *p;",
          "791:      c2 = *s;",
          "792:  }",
          "793:  if ((match->cp_flags & CP_ICASE)",
          "794:   ? (MB_TOLOWER(c1) != MB_TOLOWER(c2)) : (c1 != c2))",
          "795:      break;",
          "796:  if (has_mbyte)",
          "797:  {",
          "798:      MB_PTR_ADV(p);",
          "799:      MB_PTR_ADV(s);",
          "801:  else",
          "802:  {",
          "803:      ++p;",
          "804:      ++s;",
          "805:  }",
          "806:     }",
          "808:     if (*p != NUL)",
          "809:     {",
          "812:  had_match = (curwin->w_cursor.col > compl_col);",
          "813:  ins_compl_delete();",
          "814:  ins_bytes(compl_leader + ins_compl_len());",
          "815:  ins_redraw(FALSE);",
          "819:  if (!had_match)",
          "820:      ins_compl_delete();",
          "823:     compl_used_match = FALSE;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "827:     compl_T *match;",
          "828:     int     count = 0;",
          "831:     {",
          "842:     }",
          "843:     return count;",
          "844: }",
          "",
          "[Removed Lines]",
          "830:     if (compl_first_match != NULL)",
          "833:  match = compl_first_match;",
          "835:  while (match->cp_next != NULL && match->cp_next != compl_first_match)",
          "836:  {",
          "837:      match = match->cp_next;",
          "838:      ++count;",
          "839:  }",
          "840:  match->cp_next = compl_first_match;",
          "841:  compl_first_match->cp_prev = match;",
          "",
          "[Added Lines]",
          "858:     if (compl_first_match == NULL)",
          "859:  return 0;",
          "862:     match = compl_first_match;",
          "864:     while (match->cp_next != NULL && match->cp_next != compl_first_match)",
          "866:  match = match->cp_next;",
          "867:  ++count;",
          "869:     match->cp_next = compl_first_match;",
          "870:     compl_first_match->cp_prev = match;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "892: {",
          "893:     int  h;",
          "903: }",
          "",
          "[Removed Lines]",
          "895:     if (compl_match_array != NULL)",
          "896:     {",
          "897:  h = curwin->w_cline_height;",
          "899:  pum_call_update_screen();",
          "900:  if (h != curwin->w_cline_height)",
          "901:      ins_compl_del_pum();",
          "902:     }",
          "",
          "[Added Lines]",
          "924:     if (compl_match_array == NULL)",
          "925:  return;",
          "927:     h = curwin->w_cline_height;",
          "929:     pum_call_update_screen();",
          "930:     if (h != curwin->w_cline_height)",
          "931:  ins_compl_del_pum();",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "908:     static void",
          "909: ins_compl_del_pum(void)",
          "910: {",
          "916: }",
          "",
          "[Removed Lines]",
          "911:     if (compl_match_array != NULL)",
          "912:     {",
          "913:  pum_undisplay();",
          "914:  VIM_CLEAR(compl_match_array);",
          "915:     }",
          "",
          "[Added Lines]",
          "940:     if (compl_match_array == NULL)",
          "941:  return;",
          "943:     pum_undisplay();",
          "944:     VIM_CLEAR(compl_match_array);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "952:     do",
          "953:     {",
          "954:  if (compl == NULL",
          "956:      break;",
          "957:  compl = compl->cp_next;",
          "958:     } while (compl != compl_first_match);",
          "",
          "[Removed Lines]",
          "955:         || ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0 && ++i == 2))",
          "",
          "[Added Lines]",
          "984:         || (!ins_compl_at_original_text(compl) && ++i == 2))",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "972: {",
          "973:     dict_T *dict = dict_alloc_lock(VAR_FIXED);",
          "987:     return dict;",
          "988: }",
          "",
          "[Removed Lines]",
          "975:     if (dict != NULL)",
          "976:     {",
          "977:  dict_add_string(dict, \"word\", match->cp_str);",
          "978:  dict_add_string(dict, \"abbr\", match->cp_text[CPT_ABBR]);",
          "979:  dict_add_string(dict, \"menu\", match->cp_text[CPT_MENU]);",
          "980:  dict_add_string(dict, \"kind\", match->cp_text[CPT_KIND]);",
          "981:  dict_add_string(dict, \"info\", match->cp_text[CPT_INFO]);",
          "982:  if (match->cp_user_data.v_type == VAR_UNKNOWN)",
          "983:      dict_add_string(dict, \"user_data\", (char_u *)\"\");",
          "984:  else",
          "985:      dict_add_tv(dict, \"user_data\", &match->cp_user_data);",
          "986:     }",
          "",
          "[Added Lines]",
          "1004:     if (dict == NULL)",
          "1005:  return NULL;",
          "1007:     dict_add_string(dict, \"word\", match->cp_str);",
          "1008:     dict_add_string(dict, \"abbr\", match->cp_text[CPT_ABBR]);",
          "1009:     dict_add_string(dict, \"menu\", match->cp_text[CPT_MENU]);",
          "1010:     dict_add_string(dict, \"kind\", match->cp_text[CPT_KIND]);",
          "1011:     dict_add_string(dict, \"info\", match->cp_text[CPT_INFO]);",
          "1012:     if (match->cp_user_data.v_type == VAR_UNKNOWN)",
          "1013:  dict_add_string(dict, \"user_data\", (char_u *)\"\");",
          "1014:     else",
          "1015:  dict_add_tv(dict, \"user_data\", &match->cp_user_data);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1020: #endif",
          "1028: {",
          "1029:     compl_T     *compl;",
          "1030:     compl_T     *shown_compl = NULL;",
          "",
          "[Removed Lines]",
          "1026:     void",
          "1027: ins_compl_show_pum(void)",
          "",
          "[Added Lines]",
          "1057:     static int",
          "1058: ins_compl_build_pum(void)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1032:     int  shown_match_ok = FALSE;",
          "1033:     int  i;",
          "1034:     int  cur = -1;",
          "1036:     int  lead_len = 0;",
          "1049:     if (compl_match_array == NULL)",
          "1050:     {",
          "1057:  {",
          "1068:  {",
          "1072:   shown_match_ok = TRUE;",
          "1077:      {",
          "1137:     else",
          "1138:     {",
          "",
          "[Removed Lines]",
          "1035:     colnr_T col;",
          "1038:     if (!pum_wanted() || !pum_enough_matches())",
          "1039:  return;",
          "1041: #if defined(FEAT_EVAL)",
          "1043:     do_cmdline_cmd((char_u *)\"if exists('g:loaded_matchparen')|:3match none|endif\");",
          "1044: #endif",
          "1047:     pum_call_update_screen();",
          "1052:  compl_match_arraysize = 0;",
          "1053:  compl = compl_first_match;",
          "1054:  if (compl_leader != NULL)",
          "1055:      lead_len = (int)STRLEN(compl_leader);",
          "1056:  do",
          "1058:      if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0",
          "1059:       && (compl_leader == NULL",
          "1060:    || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1061:   ++compl_match_arraysize;",
          "1062:      compl = compl->cp_next;",
          "1063:  } while (compl != NULL && compl != compl_first_match);",
          "1064:  if (compl_match_arraysize == 0)",
          "1065:      return;",
          "1066:  compl_match_array = ALLOC_CLEAR_MULT(pumitem_T, compl_match_arraysize);",
          "1067:  if (compl_match_array != NULL)",
          "1071:      if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT)",
          "1074:      i = 0;",
          "1075:      compl = compl_first_match;",
          "1076:      do",
          "1078:   if ((compl->cp_flags & CP_ORIGINAL_TEXT) == 0",
          "1079:    && (compl_leader == NULL",
          "1080:        || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1081:   {",
          "1082:       if (!shown_match_ok)",
          "1083:       {",
          "1084:    if (compl == compl_shown_match || did_find_shown_match)",
          "1085:    {",
          "1088:        compl_shown_match = compl;",
          "1089:        did_find_shown_match = TRUE;",
          "1090:        shown_match_ok = TRUE;",
          "1091:    }",
          "1092:    else",
          "1095:        shown_compl = compl;",
          "1096:    cur = i;",
          "1097:       }",
          "1099:       if (compl->cp_text[CPT_ABBR] != NULL)",
          "1100:    compl_match_array[i].pum_text =",
          "1101:            compl->cp_text[CPT_ABBR];",
          "1102:       else",
          "1103:    compl_match_array[i].pum_text = compl->cp_str;",
          "1104:       compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];",
          "1105:       compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];",
          "1106:       if (compl->cp_text[CPT_MENU] != NULL)",
          "1107:    compl_match_array[i++].pum_extra =",
          "1108:            compl->cp_text[CPT_MENU];",
          "1109:       else",
          "1110:    compl_match_array[i++].pum_extra = compl->cp_fname;",
          "1111:   }",
          "1113:   if (compl == compl_shown_match)",
          "1114:   {",
          "1115:       did_find_shown_match = TRUE;",
          "1119:       if (compl->cp_flags & CP_ORIGINAL_TEXT)",
          "1120:    shown_match_ok = TRUE;",
          "1122:       if (!shown_match_ok && shown_compl != NULL)",
          "1123:       {",
          "1126:    compl_shown_match = shown_compl;",
          "1127:    shown_match_ok = TRUE;",
          "1128:       }",
          "1129:   }",
          "1130:   compl = compl->cp_next;",
          "1131:      } while (compl != NULL && compl != compl_first_match);",
          "1133:      if (!shown_match_ok)    // no displayed match at all",
          "1134:   cur = -1;",
          "1135:  }",
          "1136:     }",
          "",
          "[Added Lines]",
          "1069:     compl_match_arraysize = 0;",
          "1070:     compl = compl_first_match;",
          "1071:     if (compl_leader != NULL)",
          "1072:  lead_len = (int)STRLEN(compl_leader);",
          "1074:     do",
          "1075:     {",
          "1076:  if (!ins_compl_at_original_text(compl)",
          "1077:   && (compl_leader == NULL",
          "1078:       || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1079:      ++compl_match_arraysize;",
          "1080:  compl = compl->cp_next;",
          "1081:     } while (compl != NULL && compl != compl_first_match);",
          "1083:     if (compl_match_arraysize == 0)",
          "1084:  return -1;",
          "1086:     compl_match_array = ALLOC_CLEAR_MULT(pumitem_T, compl_match_arraysize);",
          "1088:  return -1;",
          "1092:     if (ins_compl_at_original_text(compl_shown_match))",
          "1093:  shown_match_ok = TRUE;",
          "1095:     i = 0;",
          "1096:     compl = compl_first_match;",
          "1097:     do",
          "1099:  if (!ins_compl_at_original_text(compl)",
          "1100:   && (compl_leader == NULL",
          "1101:       || ins_compl_equal(compl, compl_leader, lead_len)))",
          "1103:      if (!shown_match_ok)",
          "1104:      {",
          "1105:   if (compl == compl_shown_match || did_find_shown_match)",
          "1106:   {",
          "1109:       compl_shown_match = compl;",
          "1110:       did_find_shown_match = TRUE;",
          "1111:       shown_match_ok = TRUE;",
          "1112:   }",
          "1113:   else",
          "1116:       shown_compl = compl;",
          "1117:   cur = i;",
          "1118:      }",
          "1120:      if (compl->cp_text[CPT_ABBR] != NULL)",
          "1121:   compl_match_array[i].pum_text =",
          "1122:       compl->cp_text[CPT_ABBR];",
          "1123:      else",
          "1124:   compl_match_array[i].pum_text = compl->cp_str;",
          "1125:      compl_match_array[i].pum_kind = compl->cp_text[CPT_KIND];",
          "1126:      compl_match_array[i].pum_info = compl->cp_text[CPT_INFO];",
          "1127:      if (compl->cp_text[CPT_MENU] != NULL)",
          "1128:   compl_match_array[i++].pum_extra =",
          "1129:       compl->cp_text[CPT_MENU];",
          "1130:      else",
          "1131:   compl_match_array[i++].pum_extra = compl->cp_fname;",
          "1132:  }",
          "1134:  if (compl == compl_shown_match)",
          "1136:      did_find_shown_match = TRUE;",
          "1140:      if (ins_compl_at_original_text(compl))",
          "1143:      if (!shown_match_ok && shown_compl != NULL)",
          "1147:   compl_shown_match = shown_compl;",
          "1148:   shown_match_ok = TRUE;",
          "1149:      }",
          "1150:  }",
          "1151:  compl = compl->cp_next;",
          "1152:     } while (compl != NULL && compl != compl_first_match);",
          "1154:     if (!shown_match_ok)    // no displayed match at all",
          "1155:  cur = -1;",
          "1157:     return cur;",
          "1158: }",
          "1164:     void",
          "1165: ins_compl_show_pum(void)",
          "1166: {",
          "1167:     int  i;",
          "1168:     int  cur = -1;",
          "1169:     colnr_T col;",
          "1171:     if (!pum_wanted() || !pum_enough_matches())",
          "1172:  return;",
          "1174: #if defined(FEAT_EVAL)",
          "1176:     do_cmdline_cmd((char_u *)\"if exists('g:loaded_matchparen')|:3match none|endif\");",
          "1177: #endif",
          "1180:     pum_call_update_screen();",
          "1182:     if (compl_match_array == NULL)",
          "1184:  cur = ins_compl_build_pum();",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1147:      }",
          "1148:     }",
          "1163: #ifdef FEAT_EVAL",
          "1166: #endif",
          "1168: }",
          "1170: #define DICT_FIRST (1) // use just first element in \"dict\"",
          "",
          "[Removed Lines]",
          "1150:     if (compl_match_array != NULL)",
          "1151:     {",
          "1154:  dollar_vcol = -1;",
          "1158:  col = curwin->w_cursor.col;",
          "1159:  curwin->w_cursor.col = compl_col;",
          "1160:  pum_display(compl_match_array, compl_match_arraysize, cur);",
          "1161:  curwin->w_cursor.col = col;",
          "1164:  if (has_completechanged())",
          "1165:      trigger_complete_changed_event(cur);",
          "1167:     }",
          "",
          "[Added Lines]",
          "1198:     if (compl_match_array == NULL)",
          "1199:  return;",
          "1203:     dollar_vcol = -1;",
          "1207:     col = curwin->w_cursor.col;",
          "1208:     curwin->w_cursor.col = compl_col;",
          "1209:     pum_display(compl_match_array, compl_match_arraysize, cur);",
          "1210:     curwin->w_cursor.col = col;",
          "1213:     if (has_completechanged())",
          "1214:  trigger_complete_changed_event(cur);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1324:      (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "1325:  }",
          "1328:  {",
          "1333:      {",
          "1336:   {",
          "1346:       {",
          "1382:       }",
          "1392:   }",
          "1395:      }",
          "1397:  }",
          "1398:     }",
          "1399: }",
          "",
          "[Removed Lines]",
          "1327:  if (fp != NULL)",
          "1331:      while (!got_int && !compl_interrupted",
          "1332:          && !vim_fgets(buf, LSIZE, fp))",
          "1334:   ptr = buf;",
          "1335:   while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf)))",
          "1337:       ptr = regmatch->startp[0];",
          "1338:       if (ctrl_x_mode_line_or_eval())",
          "1339:    ptr = find_line_end(ptr);",
          "1340:       else",
          "1341:    ptr = find_word_end(ptr);",
          "1342:       add_r = ins_compl_add_infercase(regmatch->startp[0],",
          "1343:        (int)(ptr - regmatch->startp[0]),",
          "1344:         p_ic, files[i], *dir, FALSE);",
          "1345:       if (thesaurus)",
          "1347:    char_u *wstart;",
          "1350:    ptr = buf;",
          "1351:    while (!got_int)",
          "1352:    {",
          "1355:        ptr = find_word_start(ptr);",
          "1356:        if (*ptr == NUL || *ptr == NL)",
          "1357:     break;",
          "1358:        wstart = ptr;",
          "1361:        if (has_mbyte)",
          "1365:     while (*ptr != NUL)",
          "1366:     {",
          "1367:         int l = (*mb_ptr2len)(ptr);",
          "1369:         if (l < 2 && !vim_iswordc(*ptr))",
          "1370:      break;",
          "1371:         ptr += l;",
          "1372:     }",
          "1373:        else",
          "1374:     ptr = find_word_end(ptr);",
          "1377:        if (wstart != regmatch->startp[0])",
          "1378:     add_r = ins_compl_add_infercase(wstart,",
          "1379:      (int)(ptr - wstart),",
          "1380:      p_ic, files[i], *dir, FALSE);",
          "1381:    }",
          "1383:       if (add_r == OK)",
          "1386:       else if (add_r == FAIL)",
          "1387:    break;",
          "1390:       if (*ptr == '\\n' || got_int)",
          "1391:    break;",
          "1393:   line_breakcheck();",
          "1394:   ins_compl_check_keys(50, FALSE);",
          "1396:      fclose(fp);",
          "",
          "[Added Lines]",
          "1375:  if (fp == NULL)",
          "1376:      continue;",
          "1380:  while (!got_int && !compl_interrupted && !vim_fgets(buf, LSIZE, fp))",
          "1382:      ptr = buf;",
          "1383:      while (vim_regexec(regmatch, buf, (colnr_T)(ptr - buf)))",
          "1385:   ptr = regmatch->startp[0];",
          "1386:   if (ctrl_x_mode_line_or_eval())",
          "1387:       ptr = find_line_end(ptr);",
          "1388:   else",
          "1389:       ptr = find_word_end(ptr);",
          "1390:   add_r = ins_compl_add_infercase(regmatch->startp[0],",
          "1391:    (int)(ptr - regmatch->startp[0]),",
          "1392:    p_ic, files[i], *dir, FALSE);",
          "1393:   if (thesaurus)",
          "1395:       char_u *wstart;",
          "1398:       ptr = buf;",
          "1399:       while (!got_int)",
          "1403:    ptr = find_word_start(ptr);",
          "1404:    if (*ptr == NUL || *ptr == NL)",
          "1405:        break;",
          "1406:    wstart = ptr;",
          "1409:    if (has_mbyte)",
          "1413:        while (*ptr != NUL)",
          "1414:        {",
          "1415:     int l = (*mb_ptr2len)(ptr);",
          "1417:     if (l < 2 && !vim_iswordc(*ptr))",
          "1418:         break;",
          "1419:     ptr += l;",
          "1420:        }",
          "1421:    else",
          "1422:        ptr = find_word_end(ptr);",
          "1425:    if (wstart != regmatch->startp[0])",
          "1426:        add_r = ins_compl_add_infercase(wstart,",
          "1427:         (int)(ptr - wstart),",
          "1428:         p_ic, files[i], *dir, FALSE);",
          "1431:   if (add_r == OK)",
          "1434:   else if (add_r == FAIL)",
          "1435:       break;",
          "1438:   if (*ptr == '\\n' || got_int)",
          "1439:       break;",
          "1441:      line_breakcheck();",
          "1442:      ins_compl_check_keys(50, FALSE);",
          "1444:  fclose(fp);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1757:     char_u *p;",
          "1763:     {",
          "1764:  p = vim_strsave(str);",
          "1765:  if (p != NULL)",
          "",
          "[Removed Lines]",
          "1762:     if (compl_first_match->cp_flags & CP_ORIGINAL_TEXT) // safety check",
          "",
          "[Added Lines]",
          "1809:     if (ins_compl_at_original_text(compl_first_match)) // safety check",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1769:  }",
          "1770:     }",
          "1771:     else if (compl_first_match->cp_prev != NULL",
          "1773:     {",
          "1774:        p = vim_strsave(str);",
          "1775:        if (p != NULL)",
          "",
          "[Removed Lines]",
          "1772:      && (compl_first_match->cp_prev->cp_flags & CP_ORIGINAL_TEXT))",
          "",
          "[Added Lines]",
          "1819:      && ins_compl_at_original_text(compl_first_match->cp_prev))",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1797:     {",
          "1801:  {",
          "1805:      {",
          "1813:      }",
          "1816:  }",
          "1818:      return;",
          "1819:     }",
          "1820:     p += len;",
          "",
          "[Removed Lines]",
          "1800:  if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT)",
          "1802:      p = NULL;",
          "1803:      for (cp = compl_shown_match->cp_next; cp != NULL",
          "1804:      && cp != compl_first_match; cp = cp->cp_next)",
          "1806:   if (compl_leader == NULL",
          "1807:    || ins_compl_equal(cp, compl_leader,",
          "1808:          (int)STRLEN(compl_leader)))",
          "1809:   {",
          "1810:       p = cp->cp_str;",
          "1811:       break;",
          "1812:   }",
          "1814:      if (p == NULL || (int)STRLEN(p) <= len)",
          "1815:   return;",
          "1817:  else",
          "",
          "[Added Lines]",
          "1847:  if (!ins_compl_at_original_text(compl_shown_match))",
          "1848:      return;",
          "1850:  p = NULL;",
          "1851:  for (cp = compl_shown_match->cp_next; cp != NULL",
          "1852:   && cp != compl_first_match; cp = cp->cp_next)",
          "1854:      if (compl_leader == NULL",
          "1855:       || ins_compl_equal(cp, compl_leader,",
          "1856:    (int)STRLEN(compl_leader)))",
          "1858:   p = cp->cp_str;",
          "1859:   break;",
          "1862:  if (p == NULL || (int)STRLEN(p) <= len)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2860:      match = compl_first_match;",
          "2861:      do",
          "2862:      {",
          "2864:   {",
          "2865:       di = dict_alloc();",
          "2866:       if (di == NULL)",
          "",
          "[Removed Lines]",
          "2863:   if (!(match->cp_flags & CP_ORIGINAL_TEXT))",
          "",
          "[Added Lines]",
          "2908:   if (!ins_compl_at_original_text(match))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2949: };",
          "2971:     static int",
          "2972: process_next_cpt_value(",
          "2974:  int  *compl_type_arg,",
          "2983: {",
          "2985:     int     compl_type = -1;",
          "2986:     int     status = INS_COMPL_CPT_OK;",
          "2996:     {",
          "3002:  {",
          "3009:  }",
          "3011:  compl_type = 0;",
          "3016:     }",
          "3019:     {",
          "3022:  {",
          "3023:      compl_started = TRUE;",
          "3027:      compl_type = 0;",
          "3028:  }",
          "3029:  else // unloaded buffer, scan like dictionary",
          "3030:  {",
          "3033:      {",
          "3034:   status = INS_COMPL_CPT_CONT;",
          "3035:   goto done;",
          "3036:      }",
          "3037:      compl_type = CTRL_X_DICTIONARY;",
          "3040:  }",
          "3041:  msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3042:  vim_snprintf((char *)IObuff, IOSIZE, _(\"Scanning: %s\"),",
          "3048:  (void)msg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));",
          "3049:     }",
          "3051:  status = INS_COMPL_CPT_END;",
          "3052:     else",
          "3053:     {",
          "3054:  if (ctrl_x_mode_line_or_eval())",
          "3055:      compl_type = -1;",
          "3057:  {",
          "3059:   compl_type = CTRL_X_DICTIONARY;",
          "3060:      else",
          "3061:   compl_type = CTRL_X_THESAURUS;",
          "3063:      {",
          "3066:      }",
          "3067:  }",
          "3068: #ifdef FEAT_FIND_ID",
          "3070:      compl_type = CTRL_X_PATH_PATTERNS;",
          "3072:      compl_type = CTRL_X_PATH_DEFINES;",
          "3073: #endif",
          "3075:  {",
          "3076:      msg_hist_off = TRUE; // reset in msg_trunc_attr()",
          "3077:      compl_type = CTRL_X_TAGS;",
          "",
          "[Removed Lines]",
          "2973:  char_u  **e_cpt_arg,",
          "2975:  int  *found_all_arg,",
          "2976:  buf_T  **buf_arg,",
          "2977:  pos_T  *start_match_pos,",
          "2978:  pos_T  *first_match_pos,",
          "2979:  pos_T  *last_match_pos,",
          "2980:  int  *set_match_pos,",
          "2981:  char_u  **dict_arg,",
          "2982:  int  *dict_flag)",
          "2984:     char_u  *e_cpt = *e_cpt_arg;",
          "2987:     buf_T   *buf = *buf_arg;",
          "2988:     int     found_all = FALSE;",
          "2989:     char_u  *dict = NULL;",
          "2990:     int     dict_f = 0;",
          "2992:     while (*e_cpt == ',' || *e_cpt == ' ')",
          "2993:  e_cpt++;",
          "2995:     if (*e_cpt == '.' && !curbuf->b_scanned)",
          "2997:  buf = curbuf;",
          "3001:  if (ctrl_x_mode == CTRL_X_NORMAL && dec(first_match_pos) < 0)",
          "3006:      first_match_pos->lnum = buf->b_ml.ml_line_count;",
          "3007:      first_match_pos->col =",
          "3008:   (colnr_T)STRLEN(ml_get(first_match_pos->lnum));",
          "3017:     else if (vim_strchr((char_u *)\"buwU\", *e_cpt) != NULL",
          "3018:      && (buf = ins_compl_next_buf(buf, *e_cpt)) != curbuf)",
          "3021:  if (buf->b_ml.ml_mfp != NULL)   // loaded buffer",
          "3024:      first_match_pos->col = last_match_pos->col = 0;",
          "3025:      first_match_pos->lnum = buf->b_ml.ml_line_count + 1;",
          "3026:      last_match_pos->lnum = 0;",
          "3031:      found_all = TRUE;",
          "3032:      if (buf->b_fname == NULL)",
          "3038:      dict = buf->b_fname;",
          "3039:      dict_f = DICT_EXACT;",
          "3043:   buf->b_fname == NULL",
          "3044:       ? buf_spname(buf)",
          "3045:       : buf->b_sfname == NULL",
          "3046:    ? buf->b_fname",
          "3047:    : buf->b_sfname);",
          "3050:     else if (*e_cpt == NUL)",
          "3056:  else if (*e_cpt == 'k' || *e_cpt == 's')",
          "3058:      if (*e_cpt == 'k')",
          "3062:      if (*++e_cpt != ',' && *e_cpt != NUL)",
          "3064:   dict = e_cpt;",
          "3065:   dict_f = DICT_FIRST;",
          "3069:  else if (*e_cpt == 'i')",
          "3071:  else if (*e_cpt == 'd')",
          "3074:  else if (*e_cpt == ']' || *e_cpt == 't')",
          "",
          "[Added Lines]",
          "3000: typedef struct",
          "3001: {",
          "3002:     char_u *e_cpt;   // current entry in 'complete'",
          "3003:     buf_T *ins_buf;  // buffer being scanned",
          "3004:     pos_T *cur_match_pos;   // current match position",
          "3005:     pos_T prev_match_pos;  // previous match position",
          "3006:     int  set_match_pos;  // save first_match_pos/last_match_pos",
          "3007:     pos_T first_match_pos; // first match position",
          "3008:     pos_T last_match_pos;  // last match position",
          "3009:     int  found_all;  // found all matches of a certain type.",
          "3010:     char_u *dict;   // dictionary file to search",
          "3011:     int  dict_f;   // \"dict\" is an exact file name or not",
          "3012: } ins_compl_next_state_T;",
          "3036:  ins_compl_next_state_T *st,",
          "3038:  pos_T  *start_match_pos)",
          "3043:     st->found_all = FALSE;",
          "3045:     while (*st->e_cpt == ',' || *st->e_cpt == ' ')",
          "3046:  st->e_cpt++;",
          "3048:     if (*st->e_cpt == '.' && !curbuf->b_scanned)",
          "3050:  st->ins_buf = curbuf;",
          "3051:  st->first_match_pos = *start_match_pos;",
          "3054:  if (ctrl_x_mode == CTRL_X_NORMAL && dec(&st->first_match_pos) < 0)",
          "3059:      st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count;",
          "3060:      st->first_match_pos.col =",
          "3061:   (colnr_T)STRLEN(ml_get(st->first_match_pos.lnum));",
          "3063:  st->last_match_pos = st->first_match_pos;",
          "3068:  st->set_match_pos = TRUE;",
          "3070:     else if (vim_strchr((char_u *)\"buwU\", *st->e_cpt) != NULL",
          "3071:      && (st->ins_buf = ins_compl_next_buf(st->ins_buf, *st->e_cpt)) != curbuf)",
          "3074:  if (st->ins_buf->b_ml.ml_mfp != NULL)   // loaded buffer",
          "3077:      st->first_match_pos.col = st->last_match_pos.col = 0;",
          "3078:      st->first_match_pos.lnum = st->ins_buf->b_ml.ml_line_count + 1;",
          "3079:      st->last_match_pos.lnum = 0;",
          "3084:      st->found_all = TRUE;",
          "3085:      if (st->ins_buf->b_fname == NULL)",
          "3091:      st->dict = st->ins_buf->b_fname;",
          "3092:      st->dict_f = DICT_EXACT;",
          "3096:   st->ins_buf->b_fname == NULL",
          "3097:       ? buf_spname(st->ins_buf)",
          "3098:       : st->ins_buf->b_sfname == NULL",
          "3099:    ? st->ins_buf->b_fname",
          "3100:    : st->ins_buf->b_sfname);",
          "3103:     else if (*st->e_cpt == NUL)",
          "3109:  else if (*st->e_cpt == 'k' || *st->e_cpt == 's')",
          "3111:      if (*st->e_cpt == 'k')",
          "3115:      if (*++st->e_cpt != ',' && *st->e_cpt != NUL)",
          "3117:   st->dict = st->e_cpt;",
          "3118:   st->dict_f = DICT_FIRST;",
          "3122:  else if (*st->e_cpt == 'i')",
          "3124:  else if (*st->e_cpt == 'd')",
          "3127:  else if (*st->e_cpt == ']' || *st->e_cpt == 't')",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "3082:      compl_type = -1;",
          "3088:  if (compl_type == -1)",
          "3089:      status = INS_COMPL_CPT_CONT;",
          "3090:     }",
          "3092: done:",
          "3099:     return status;",
          "3100: }",
          "",
          "[Removed Lines]",
          "3085:  (void)copy_option_part(&e_cpt, IObuff, IOSIZE, \",\");",
          "3087:  found_all = TRUE;",
          "",
          "[Added Lines]",
          "3138:  (void)copy_option_part(&st->e_cpt, IObuff, IOSIZE, \",\");",
          "3140:  st->found_all = TRUE;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3123:     static void",
          "3125: {",
          "3126: #ifdef FEAT_COMPL_FUNC",
          "3127:     if (thesaurus_func_complete(compl_type))",
          "",
          "[Removed Lines]",
          "3124: get_next_dict_tsr_completion(int compl_type, char_u **dict, int dict_f)",
          "",
          "[Added Lines]",
          "3172: get_next_dict_tsr_completion(int compl_type, char_u *dict, int dict_f)",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3129:     else",
          "3130: #endif",
          "3131:  ins_compl_dictionaries(",
          "3133:   : (compl_type == CTRL_X_THESAURUS",
          "3134:       ? (*curbuf->b_p_tsr == NUL ? p_tsr : curbuf->b_p_tsr)",
          "3135:       : (*curbuf->b_p_dict == NUL ? p_dict : curbuf->b_p_dict)),",
          "3136:   compl_pattern,",
          "3138:   compl_type == CTRL_X_THESAURUS);",
          "3140: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3180:   dict != NULL ? dict",
          "3185:   dict != NULL ? dict_f : 0,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3343:     static int",
          "3353: {",
          "3354:     int  found_new_match = FAIL;",
          "3355:     int  save_p_scs;",
          "",
          "[Removed Lines]",
          "3344: get_next_default_completion(",
          "3345:  buf_T *ins_buf,  // buffer being scanned",
          "3346:  pos_T *start_pos,  // search start position",
          "3347:  pos_T *cur_match_pos,  // current match position",
          "3348:  pos_T *prev_match_pos, // previous match position",
          "3349:  int *save_match_pos, // set first_match_pos/last_match_pos",
          "3350:  pos_T *first_match_pos, // first match position",
          "3351:  pos_T *last_match_pos, // last match position",
          "3352:  int scan_curbuf)  // scan current buffer for completion",
          "",
          "[Added Lines]",
          "3392: get_next_default_completion(ins_compl_next_state_T *st, pos_T *start_pos)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3362:     save_p_scs = p_scs;",
          "3364:  p_scs = FALSE;",
          "",
          "[Removed Lines]",
          "3363:     if (ins_buf->b_p_inf)",
          "",
          "[Added Lines]",
          "3403:     if (st->ins_buf->b_p_inf)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3370:     save_p_ws = p_ws;",
          "3372:  p_ws = FALSE;",
          "3374:  p_ws = TRUE;",
          "3375:     looped_around = FALSE;",
          "3376:     for (;;)",
          "",
          "[Removed Lines]",
          "3371:     if (ins_buf != curbuf)",
          "3373:     else if (scan_curbuf)",
          "",
          "[Added Lines]",
          "3411:     if (st->ins_buf != curbuf)",
          "3413:     else if (*st->e_cpt == '.')",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3384:  if (ctrl_x_mode_line_or_eval()",
          "3385:   || (compl_cont_status & CONT_SOL))",
          "3388:  else",
          "3393:  --msg_silent;",
          "3395:  {",
          "3397:      compl_started = TRUE;",
          "3401:  }",
          "3404:  {",
          "3405:      found_new_match = FAIL;",
          "3406:  }",
          "3407:  else if ((compl_direction == FORWARD)",
          "3411:  {",
          "3412:      if (looped_around)",
          "3413:   found_new_match = FAIL;",
          "",
          "[Removed Lines]",
          "3386:      found_new_match = search_for_exact_line(ins_buf, cur_match_pos,",
          "3387:       compl_direction, compl_pattern);",
          "3389:      found_new_match = searchit(NULL, ins_buf, cur_match_pos, NULL,",
          "3390:       compl_direction,",
          "3391:       compl_pattern, 1L, SEARCH_KEEP + SEARCH_NFMSG,",
          "3392:       RE_LAST, NULL);",
          "3394:  if (!compl_started || *save_match_pos)",
          "3402:  else if (first_match_pos->lnum == last_match_pos->lnum",
          "3403:   && first_match_pos->col == last_match_pos->col)",
          "3408:   && (prev_match_pos->lnum > cur_match_pos->lnum",
          "3409:       || (prev_match_pos->lnum == cur_match_pos->lnum",
          "3410:    && prev_match_pos->col >= cur_match_pos->col)))",
          "",
          "[Added Lines]",
          "3426:      found_new_match = search_for_exact_line(st->ins_buf,",
          "3427:        st->cur_match_pos, compl_direction, compl_pattern);",
          "3429:      found_new_match = searchit(NULL, st->ins_buf, st->cur_match_pos,",
          "3430:     NULL, compl_direction, compl_pattern, 1L,",
          "3431:     SEARCH_KEEP + SEARCH_NFMSG, RE_LAST, NULL);",
          "3433:  if (!compl_started || st->set_match_pos)",
          "3437:      st->first_match_pos = *st->cur_match_pos;",
          "3438:      st->last_match_pos = *st->cur_match_pos;",
          "3439:      st->set_match_pos = FALSE;",
          "3441:  else if (st->first_match_pos.lnum == st->last_match_pos.lnum",
          "3442:   && st->first_match_pos.col == st->last_match_pos.col)",
          "3447:   && (st->prev_match_pos.lnum > st->cur_match_pos->lnum",
          "3448:       || (st->prev_match_pos.lnum == st->cur_match_pos->lnum",
          "3449:    && st->prev_match_pos.col >= st->cur_match_pos->col)))",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3415:   looped_around = TRUE;",
          "3416:  }",
          "3417:  else if ((compl_direction != FORWARD)",
          "3421:  {",
          "3422:      if (looped_around)",
          "3423:   found_new_match = FAIL;",
          "3424:      else",
          "3425:   looped_around = TRUE;",
          "3426:  }",
          "3428:  if (found_new_match == FAIL)",
          "3429:      break;",
          "3435:      continue;",
          "3439:  if (ptr == NULL)",
          "3440:      continue;",
          "3442:  if (ins_compl_add_infercase(ptr, len, p_ic,",
          "3444:       0, cont_s_ipos) != NOTDONE)",
          "3445:  {",
          "3446:      found_new_match = OK;",
          "",
          "[Removed Lines]",
          "3418:   && (prev_match_pos->lnum < cur_match_pos->lnum",
          "3419:       || (prev_match_pos->lnum == cur_match_pos->lnum",
          "3420:    && prev_match_pos->col <= cur_match_pos->col)))",
          "3432:  if ((compl_cont_status & CONT_ADDING) && ins_buf == curbuf",
          "3433:   && start_pos->lnum == cur_match_pos->lnum",
          "3434:   && start_pos->col  == cur_match_pos->col)",
          "3437:  ptr = ins_comp_get_next_word_or_line(ins_buf, cur_match_pos, &len,",
          "3438:        &cont_s_ipos);",
          "3443:       ins_buf == curbuf ? NULL : ins_buf->b_sfname,",
          "",
          "[Added Lines]",
          "3457:   && (st->prev_match_pos.lnum < st->cur_match_pos->lnum",
          "3458:       || (st->prev_match_pos.lnum == st->cur_match_pos->lnum",
          "3459:    && st->prev_match_pos.col <= st->cur_match_pos->col)))",
          "3466:  st->prev_match_pos = *st->cur_match_pos;",
          "3471:  if ((compl_cont_status & CONT_ADDING) && st->ins_buf == curbuf",
          "3472:   && start_pos->lnum == st->cur_match_pos->lnum",
          "3473:   && start_pos->col  == st->cur_match_pos->col)",
          "3476:  ptr = ins_comp_get_next_word_or_line(st->ins_buf, st->cur_match_pos,",
          "3477:        &len, &cont_s_ipos);",
          "3482:       st->ins_buf == curbuf ? NULL : st->ins_buf->b_sfname,",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3453:     return found_new_match;",
          "3454: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3499:     static int",
          "3500: get_next_completion_match(int type, ins_compl_next_state_T *st, pos_T *ini)",
          "3501: {",
          "3502:     int found_new_match = FALSE;",
          "3504:     switch (type)",
          "3505:     {",
          "3506:  case -1:",
          "3507:      break;",
          "3508: #ifdef FEAT_FIND_ID",
          "3509:  case CTRL_X_PATH_PATTERNS:",
          "3510:  case CTRL_X_PATH_DEFINES:",
          "3511:      get_next_include_file_completion(type);",
          "3512:      break;",
          "3513: #endif",
          "3515:  case CTRL_X_DICTIONARY:",
          "3516:  case CTRL_X_THESAURUS:",
          "3517:      get_next_dict_tsr_completion(type, st->dict, st->dict_f);",
          "3518:      st->dict = NULL;",
          "3519:      break;",
          "3521:  case CTRL_X_TAGS:",
          "3522:      get_next_tag_completion();",
          "3523:      break;",
          "3525:  case CTRL_X_FILES:",
          "3526:      get_next_filename_completion();",
          "3527:      break;",
          "3529:  case CTRL_X_CMDLINE:",
          "3530:  case CTRL_X_CMDLINE_CTRL_X:",
          "3531:      get_next_cmdline_completion();",
          "3532:      break;",
          "3534: #ifdef FEAT_COMPL_FUNC",
          "3535:  case CTRL_X_FUNCTION:",
          "3536:  case CTRL_X_OMNI:",
          "3537:      expand_by_function(type, compl_pattern);",
          "3538:      break;",
          "3539: #endif",
          "3541:  case CTRL_X_SPELL:",
          "3542:      get_next_spell_completion(st->first_match_pos.lnum);",
          "3543:      break;",
          "3545:  default: // normal ^P/^N and ^X^L",
          "3546:      found_new_match = get_next_default_completion(st, ini);",
          "3547:      if (found_new_match == FAIL && st->ins_buf == curbuf)",
          "3548:   st->found_all = TRUE;",
          "3549:     }",
          "3553:     if (type != 0 && compl_curr_match != compl_old_match)",
          "3554:  found_new_match = OK;",
          "3556:     return found_new_match;",
          "3557: }",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3465:     static int",
          "3466: ins_compl_get_exp(pos_T *ini)",
          "3467: {",
          "3476:     int  i;",
          "3477:     int  found_new_match;",
          "3478:     int  type = ctrl_x_mode;",
          "3484:     if (!compl_started)",
          "3485:     {",
          "3491:          ? (char_u *)\".\" : curbuf->b_p_cpt;",
          "3493:     }",
          "3497:     compl_old_match = compl_curr_match; // remember the last current match",
          "3501:     for (;;)",
          "3502:     {",
          "3503:  found_new_match = FAIL;",
          "3509:  if ((ctrl_x_mode == CTRL_X_NORMAL",
          "3510:       || ctrl_x_mode_line_or_eval())",
          "3512:  {",
          "3517:      if (status == INS_COMPL_CPT_END)",
          "3518:   break;",
          "",
          "[Removed Lines]",
          "3468:     static pos_T first_match_pos;",
          "3469:     static pos_T last_match_pos;",
          "3470:     static char_u *e_cpt = (char_u *)\"\"; // curr. entry in 'complete'",
          "3471:     static int  found_all = FALSE; // Found all matches of a",
          "3473:     static buf_T *ins_buf = NULL; // buffer being scanned",
          "3475:     pos_T *pos;",
          "3479:     char_u *dict = NULL;",
          "3480:     int  dict_f = 0;",
          "3481:     int  set_match_pos;",
          "3482:     pos_T prev_pos = {0, 0, 0};",
          "3486:  FOR_ALL_BUFFERS(ins_buf)",
          "3487:      ins_buf->b_scanned = 0;",
          "3488:  found_all = FALSE;",
          "3489:  ins_buf = curbuf;",
          "3490:  e_cpt = (compl_cont_status & CONT_LOCAL)",
          "3492:  last_match_pos = first_match_pos = *ini;",
          "3494:     else if (ins_buf != curbuf && !buf_valid(ins_buf))",
          "3495:  ins_buf = curbuf;  // In case the buffer was wiped out.",
          "3498:     pos = (compl_direction == FORWARD) ? &last_match_pos : &first_match_pos;",
          "3504:  set_match_pos = FALSE;",
          "3511:      && (!compl_started || found_all))",
          "3513:      int status = process_next_cpt_value(&e_cpt, &type, &found_all,",
          "3514:       &ins_buf, ini, &first_match_pos, &last_match_pos,",
          "3515:       &set_match_pos, &dict, &dict_f);",
          "",
          "[Added Lines]",
          "3571:     static ins_compl_next_state_T st;",
          "3578:  FOR_ALL_BUFFERS(st.ins_buf)",
          "3579:      st.ins_buf->b_scanned = 0;",
          "3580:  st.found_all = FALSE;",
          "3581:  st.ins_buf = curbuf;",
          "3582:  st.e_cpt = (compl_cont_status & CONT_LOCAL)",
          "3584:  st.last_match_pos = st.first_match_pos = *ini;",
          "3586:     else if (st.ins_buf != curbuf && !buf_valid(st.ins_buf))",
          "3587:  st.ins_buf = curbuf;  // In case the buffer was wiped out.",
          "3590:     st.cur_match_pos = (compl_direction == FORWARD)",
          "3591:     ? &st.last_match_pos : &st.first_match_pos;",
          "3597:  st.set_match_pos = FALSE;",
          "3604:      && (!compl_started || st.found_all))",
          "3606:      int status = process_next_cpt_value(&st, &type, ini);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3525:  if (compl_pattern == NULL)",
          "3526:      break;",
          "",
          "[Removed Lines]",
          "3528:  switch (type)",
          "3529:  {",
          "3530:  case -1:",
          "3531:      break;",
          "3532: #ifdef FEAT_FIND_ID",
          "3533:  case CTRL_X_PATH_PATTERNS:",
          "3534:  case CTRL_X_PATH_DEFINES:",
          "3535:      get_next_include_file_completion(type);",
          "3536:      break;",
          "3537: #endif",
          "3539:  case CTRL_X_DICTIONARY:",
          "3540:  case CTRL_X_THESAURUS:",
          "3541:      get_next_dict_tsr_completion(type, &dict, dict_f);",
          "3542:      break;",
          "3544:  case CTRL_X_TAGS:",
          "3545:      get_next_tag_completion();",
          "3546:      break;",
          "3548:  case CTRL_X_FILES:",
          "3549:      get_next_filename_completion();",
          "3550:      break;",
          "3552:  case CTRL_X_CMDLINE:",
          "3553:  case CTRL_X_CMDLINE_CTRL_X:",
          "3554:      get_next_cmdline_completion();",
          "3555:      break;",
          "3557: #ifdef FEAT_COMPL_FUNC",
          "3558:  case CTRL_X_FUNCTION:",
          "3559:  case CTRL_X_OMNI:",
          "3560:      expand_by_function(type, compl_pattern);",
          "3561:      break;",
          "3562: #endif",
          "3564:  case CTRL_X_SPELL:",
          "3565:      get_next_spell_completion(first_match_pos.lnum);",
          "3566:      break;",
          "3568:  default: // normal ^P/^N and ^X^L",
          "3569:      found_new_match = get_next_default_completion(ins_buf, ini, pos,",
          "3570:       &prev_pos, &set_match_pos, &first_match_pos,",
          "3571:       &last_match_pos, (*e_cpt == '.'));",
          "3572:      if (found_new_match == FAIL && ins_buf == curbuf)",
          "3573:   found_all = TRUE;",
          "3574:  }",
          "3578:  if (type != 0 && compl_curr_match != compl_old_match)",
          "3579:      found_new_match = OK;",
          "",
          "[Added Lines]",
          "3620:  found_new_match = get_next_completion_match(type, &st, ini);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3599:  {",
          "3601:      if (type == 0 || type == CTRL_X_PATH_PATTERNS)",
          "3604:      compl_started = FALSE;",
          "3605:  }",
          "",
          "[Removed Lines]",
          "3602:   ins_buf->b_scanned = TRUE;",
          "",
          "[Added Lines]",
          "3643:   st.ins_buf->b_scanned = TRUE;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3607:     compl_started = TRUE;",
          "3609:     if ((ctrl_x_mode == CTRL_X_NORMAL || ctrl_x_mode_line_or_eval())",
          "3611:  found_new_match = FAIL;",
          "3613:     i = -1;  // total of matches, unknown",
          "",
          "[Removed Lines]",
          "3610:      && *e_cpt == NUL)  // Got to end of 'complete'",
          "",
          "[Added Lines]",
          "3651:      && *st.e_cpt == NUL)  // Got to end of 'complete'",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3700:     if (compl_len < (int)STRLEN(compl_shown_match->cp_str))",
          "3701:  ins_bytes(compl_shown_match->cp_str + compl_len);",
          "3703:  compl_used_match = FALSE;",
          "3704:     else",
          "3705:  compl_used_match = TRUE;",
          "",
          "[Removed Lines]",
          "3702:     if (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT)",
          "",
          "[Added Lines]",
          "3743:     if (ins_compl_at_original_text(compl_shown_match))",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3832:      }",
          "3833:      found_end = FALSE;",
          "3834:  }",
          "3836:   && compl_leader != NULL",
          "3837:   && !ins_compl_equal(compl_shown_match,",
          "3838:       compl_leader, (int)STRLEN(compl_leader)))",
          "",
          "[Removed Lines]",
          "3835:  if ((compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0",
          "",
          "[Added Lines]",
          "3876:  if (!ins_compl_at_original_text(compl_shown_match)",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3891:  return -1;",
          "3893:     if (compl_leader != NULL",
          "3896:  ins_compl_update_shown_match();",
          "",
          "[Removed Lines]",
          "3894:         && (compl_shown_match->cp_flags & CP_ORIGINAL_TEXT) == 0)",
          "",
          "[Added Lines]",
          "3935:         && !ins_compl_at_original_text(compl_shown_match))",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "4662:     if (edit_submode_extra == NULL)",
          "4663:     {",
          "4665:  {",
          "4666:      edit_submode_extra = (char_u *)_(\"Back at original\");",
          "4667:      edit_submode_highl = HLF_W;",
          "",
          "[Removed Lines]",
          "4664:  if (compl_curr_match->cp_flags & CP_ORIGINAL_TEXT)",
          "",
          "[Added Lines]",
          "4705:  if (ins_compl_at_original_text(compl_curr_match))",
          "",
          "---------------"
        ],
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "750: static int included_patches[] =",
          "753:     3952,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "753:     3953,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
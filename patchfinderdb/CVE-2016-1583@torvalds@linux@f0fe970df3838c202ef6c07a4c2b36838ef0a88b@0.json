{
  "cve_id": "CVE-2016-1583",
  "cve_desc": "The ecryptfs_privileged_open function in fs/ecryptfs/kthread.c in the Linux kernel before 4.6.3 allows local users to gain privileges or cause a denial of service (stack memory consumption) via vectors involving crafted mmap calls for /proc pathnames, leading to recursive pagefault handling.",
  "repo": "torvalds/linux",
  "patch_hash": "f0fe970df3838c202ef6c07a4c2b36838ef0a88b",
  "patch_info": {
    "commit_hash": "f0fe970df3838c202ef6c07a4c2b36838ef0a88b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f0fe970df3838c202ef6c07a4c2b36838ef0a88b",
    "files": [
      "fs/ecryptfs/file.c"
    ],
    "message": "ecryptfs: don't allow mmap when the lower fs doesn't support it\n\nThere are legitimate reasons to disallow mmap on certain files, notably\nin sysfs or procfs.  We shouldn't emulate mmap support on file systems\nthat don't offer support natively.\n\nCVE-2016-1583\n\nSigned-off-by: Jeff Mahoney <jeffm@suse.com>\nCc: stable@vger.kernel.org\n[tyhicks: clean up f_op check by using ecryptfs_file_to_lower()]\nSigned-off-by: Tyler Hicks <tyhicks@canonical.com>",
    "before_after_code_files": [
      "fs/ecryptfs/file.c||fs/ecryptfs/file.c"
    ]
  },
  "patch_diff": {
    "fs/ecryptfs/file.c||fs/ecryptfs/file.c": [
      "File: fs/ecryptfs/file.c -> fs/ecryptfs/file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "169:  return rc;",
      "170: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "172: static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)",
      "173: {",
      "174:  struct file *lower_file = ecryptfs_file_to_lower(file);",
      "180:  if (!lower_file->f_op->mmap)",
      "181:   return -ENODEV;",
      "182:  return generic_file_mmap(file, vma);",
      "183: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "403: #ifdef CONFIG_COMPAT",
      "404:  .compat_ioctl = ecryptfs_compat_ioctl,",
      "405: #endif",
      "407:  .open = ecryptfs_open,",
      "408:  .flush = ecryptfs_flush,",
      "409:  .release = ecryptfs_release,",
      "",
      "[Removed Lines]",
      "406:  .mmap = generic_file_mmap,",
      "",
      "[Added Lines]",
      "419:  .mmap = ecryptfs_mmap,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6a480a7842545ec520a91730209ec0bae41694c1",
      "candidate_info": {
        "commit_hash": "6a480a7842545ec520a91730209ec0bae41694c1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6a480a7842545ec520a91730209ec0bae41694c1",
        "files": [
          "fs/ecryptfs/file.c"
        ],
        "message": "ecryptfs: fix handling of directory opening\n\nFirst of all, trying to open them r/w is idiocy; it's guaranteed to fail.\nMoreover, assigning ->f_pos and assuming that everything will work is\nblatantly broken - try that with e.g. tmpfs as underlying layer and watch\nthe fireworks.  There may be a non-trivial amount of state associated with\ncurrent IO position, well beyond the numeric offset.  Using the single\nstruct file associated with underlying inode is really not a good idea;\nwe ought to open one for each ecryptfs directory struct file.\n\nAdditionally, file_operations both for directories and non-directories are\nfull of pointless methods; non-directories should *not* have ->iterate(),\ndirectories should not have ->flush(), ->fasync() and ->splice_read().\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/ecryptfs/file.c||fs/ecryptfs/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ecryptfs/file.c||fs/ecryptfs/file.c"
          ],
          "candidate": [
            "fs/ecryptfs/file.c||fs/ecryptfs/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ecryptfs/file.c||fs/ecryptfs/file.c": [
          "File: fs/ecryptfs/file.c -> fs/ecryptfs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:   .sb = inode->i_sb,",
          "113:  };",
          "114:  lower_file = ecryptfs_file_to_lower(file);",
          "116:  rc = iterate_dir(lower_file, &buf.ctx);",
          "117:  ctx->pos = buf.ctx.pos;",
          "118:  if (rc < 0)",
          "",
          "[Removed Lines]",
          "115:  lower_file->f_pos = ctx->pos;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:  }",
          "224:  ecryptfs_set_file_lower(",
          "225:   file, ecryptfs_inode_to_private(inode)->lower_file);",
          "234:  rc = read_or_initialize_metadata(ecryptfs_dentry);",
          "235:  if (rc)",
          "236:   goto out_put;",
          "",
          "[Removed Lines]",
          "226:  if (d_is_dir(ecryptfs_dentry)) {",
          "227:   ecryptfs_printk(KERN_DEBUG, \"This is a directory\\n\");",
          "228:   mutex_lock(&crypt_stat->cs_mutex);",
          "229:   crypt_stat->flags &= ~(ECRYPTFS_ENCRYPTED);",
          "230:   mutex_unlock(&crypt_stat->cs_mutex);",
          "231:   rc = 0;",
          "232:   goto out;",
          "233:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "247:  return rc;",
          "248: }",
          "250: static int ecryptfs_flush(struct file *file, fl_owner_t td)",
          "251: {",
          "252:  struct file *lower_file = ecryptfs_file_to_lower(file);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "250: static int ecryptfs_dir_open(struct inode *inode, struct file *file)",
          "251: {",
          "252:  struct dentry *ecryptfs_dentry = file->f_path.dentry;",
          "255:  struct ecryptfs_file_info *file_info;",
          "256:  struct file *lower_file;",
          "259:  file_info = kmem_cache_zalloc(ecryptfs_file_info_cache, GFP_KERNEL);",
          "260:  ecryptfs_set_file_private(file, file_info);",
          "261:  if (unlikely(!file_info)) {",
          "262:   ecryptfs_printk(KERN_ERR,",
          "263:     \"Error attempting to allocate memory\\n\");",
          "264:   return -ENOMEM;",
          "265:  }",
          "266:  lower_file = dentry_open(ecryptfs_dentry_to_lower_path(ecryptfs_dentry),",
          "267:      file->f_flags, current_cred());",
          "268:  if (IS_ERR(lower_file)) {",
          "269:   printk(KERN_ERR \"%s: Error attempting to initialize \"",
          "270:    \"the lower file for the dentry with name \"",
          "271:    \"[%pd]; rc = [%ld]\\n\", __func__,",
          "272:    ecryptfs_dentry, PTR_ERR(lower_file));",
          "273:   kmem_cache_free(ecryptfs_file_info_cache, file_info);",
          "274:   return PTR_ERR(lower_file);",
          "275:  }",
          "276:  ecryptfs_set_file_lower(file, lower_file);",
          "277:  return 0;",
          "278: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "267:  return 0;",
          "268: }",
          "270: static int",
          "271: ecryptfs_fsync(struct file *file, loff_t start, loff_t end, int datasync)",
          "272: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "300: static int ecryptfs_dir_release(struct inode *inode, struct file *file)",
          "301: {",
          "302:  fput(ecryptfs_file_to_lower(file));",
          "303:  kmem_cache_free(ecryptfs_file_info_cache,",
          "304:    ecryptfs_file_to_private(file));",
          "305:  return 0;",
          "306: }",
          "308: static loff_t ecryptfs_dir_llseek(struct file *file, loff_t offset, int whence)",
          "309: {",
          "310:  return vfs_llseek(ecryptfs_file_to_lower(file), offset, whence);",
          "311: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "346: #ifdef CONFIG_COMPAT",
          "347:  .compat_ioctl = ecryptfs_compat_ioctl,",
          "348: #endif",
          "352:  .fsync = ecryptfs_fsync,",
          "356: };",
          "358: const struct file_operations ecryptfs_main_fops = {",
          "359:  .llseek = generic_file_llseek,",
          "360:  .read_iter = ecryptfs_read_update_atime,",
          "361:  .write_iter = generic_file_write_iter,",
          "363:  .unlocked_ioctl = ecryptfs_unlocked_ioctl,",
          "364: #ifdef CONFIG_COMPAT",
          "365:  .compat_ioctl = ecryptfs_compat_ioctl,",
          "",
          "[Removed Lines]",
          "349:  .open = ecryptfs_open,",
          "350:  .flush = ecryptfs_flush,",
          "351:  .release = ecryptfs_release,",
          "353:  .fasync = ecryptfs_fasync,",
          "354:  .splice_read = generic_file_splice_read,",
          "355:  .llseek = default_llseek,",
          "362:  .iterate = ecryptfs_readdir,",
          "",
          "[Added Lines]",
          "392:  .open = ecryptfs_dir_open,",
          "393:  .release = ecryptfs_dir_release,",
          "395:  .llseek = ecryptfs_dir_llseek,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-1335",
  "cve_desc": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
  "repo": "lxc/lxc",
  "patch_hash": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
  "patch_info": {
    "commit_hash": "592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "repo": "lxc/lxc",
    "commit_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
    "files": [
      "doc/lxc.container.conf.sgml.in",
      "src/lxc/cgfs.c",
      "src/lxc/cgmanager.c",
      "src/lxc/conf.c",
      "src/lxc/utils.c",
      "src/lxc/utils.h",
      "src/tests/Makefile.am",
      "src/tests/lxc-test-symlink"
    ],
    "message": "CVE-2015-1335: Protect container mounts against symlinks\n\nWhen a container starts up, lxc sets up the container's inital fstree\nby doing a bunch of mounting, guided by the container configuration\nfile.  The container config is owned by the admin or user on the host,\nso we do not try to guard against bad entries.  However, since the\nmount target is in the container, it's possible that the container admin\ncould divert the mount with symbolic links.  This could bypass proper\ncontainer startup (i.e. confinement of a root-owned container by the\nrestrictive apparmor policy, by diverting the required write to\n/proc/self/attr/current), or bypass the (path-based) apparmor policy\nby diverting, say, /proc to /mnt in the container.\n\nTo prevent this,\n\n1. do not allow mounts to paths containing symbolic links\n\n2. do not allow bind mounts from relative paths containing symbolic\nlinks.\n\nDetails:\n\nDefine safe_mount which ensures that the container has not inserted any\nsymbolic links into any mount targets for mounts to be done during\ncontainer setup.\n\nThe host's mount path may contain symbolic links.  As it is under the\ncontrol of the administrator, that's ok.  So safe_mount begins the check\nfor symbolic links after the rootfs->mount, by opening that directory.\n\nIt opens each directory along the path using openat() relative to the\nparent directory using O_NOFOLLOW.  When the target is reached, it\nmounts onto /proc/self/fd/<targetfd>.\n\nUse safe_mount() in mount_entry(), when mounting container proc,\nand when needed.  In particular, safe_mount() need not be used in\nany case where:\n\n1. the mount is done in the container's namespace\n2. the mount is for the container's rootfs\n3. the mount is relative to a tmpfs or proc/sysfs which we have\n   just safe_mount()ed ourselves\n\nSince we were using proc/net as a temporary placeholder for /proc/sys/net\nduring container startup, and proc/net is a symbolic link, use proc/tty\ninstead.\n\nUpdate the lxc.container.conf manpage with details about the new\nrestrictions.\n\nFinally, add a testcase to test some symbolic link possibilities.\n\nReported-by: Roman Fiedler\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>\nAcked-by: St\u00e9phane Graber <stgraber@ubuntu.com>",
    "before_after_code_files": [
      "src/lxc/cgfs.c||src/lxc/cgfs.c",
      "src/lxc/cgmanager.c||src/lxc/cgmanager.c",
      "src/lxc/conf.c||src/lxc/conf.c",
      "src/lxc/utils.c||src/lxc/utils.c",
      "src/lxc/utils.h||src/lxc/utils.h",
      "src/tests/Makefile.am||src/tests/Makefile.am"
    ]
  },
  "patch_diff": {
    "src/lxc/cgfs.c||src/lxc/cgfs.c": [
      "File: src/lxc/cgfs.c -> src/lxc/cgfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1363:  if (!path)",
      "1364:   return false;",
      "1365:  snprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);",
      "1367:  if (r < 0) {",
      "1368:   SYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");",
      "1369:   return false;",
      "",
      "[Removed Lines]",
      "1366:  r = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");",
      "",
      "[Added Lines]",
      "1366:  r = safe_mount(\"cgroup_root\", path, \"tmpfs\",",
      "1367:    MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,",
      "1368:    \"size=10240k,mode=755\",",
      "1369:    root);",
      "",
      "---------------"
    ],
    "src/lxc/cgmanager.c||src/lxc/cgmanager.c": [
      "File: src/lxc/cgmanager.c -> src/lxc/cgmanager.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1477:  }",
      "1481:   SYSERROR(\"Failed to mount tmpfs at %s\", cgpath);",
      "1482:   return false;",
      "1483:  }",
      "",
      "[Removed Lines]",
      "1480:  if (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {",
      "",
      "[Added Lines]",
      "1480:  if (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1488:   return false;",
      "1489:  }",
      "1492:   SYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);",
      "1493:   return false;",
      "1494:  }",
      "",
      "[Removed Lines]",
      "1491:  if (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1491:  if (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {",
      "",
      "---------------"
    ],
    "src/lxc/conf.c||src/lxc/conf.c": [
      "File: src/lxc/conf.c -> src/lxc/conf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "771:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
      "773:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },",
      "774:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
      "776:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },",
      "777:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
      "778:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
      "",
      "[Removed Lines]",
      "772:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },",
      "775:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
      "",
      "[Added Lines]",
      "773:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },",
      "776:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "815:    }",
      "816:    mflags = add_required_remount_flags(source, destination,",
      "817:      default_mounts[i].flags);",
      "819:    saved_errno = errno;",
      "820:    if (r < 0 && errno == ENOENT) {",
      "821:     INFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);",
      "",
      "[Removed Lines]",
      "818:    r = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);",
      "",
      "[Added Lines]",
      "819:    r = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1167:   return 0;",
      "1168:  }",
      "1171:   SYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);",
      "1172:   return false;",
      "1173:  }",
      "",
      "[Removed Lines]",
      "1170:  if (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {",
      "",
      "[Added Lines]",
      "1171:  if (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",",
      "1172:     rootfs->path ? rootfs->mount : NULL)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1252:     return -1;",
      "1253:    }",
      "1254:    fclose(pathfile);",
      "1256:     SYSERROR(\"Failed bind mounting device %s from host into container\",",
      "1257:      d->name);",
      "1258:     return -1;",
      "",
      "[Removed Lines]",
      "1255:    if (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {",
      "",
      "[Added Lines]",
      "1257:    if (safe_mount(hostpath, path, 0, MS_BIND, NULL,",
      "1258:       rootfs->path ? rootfs->mount : NULL) != 0) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1505:   return -1;",
      "1506:  }",
      "1509:   ERROR(\"failed to mount '%s' on '%s'\", console->name, path);",
      "1510:   return -1;",
      "1511:  }",
      "",
      "[Removed Lines]",
      "1508:  if (mount(console->name, path, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1511:  if (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1560:   return 0;",
      "1561:  }",
      "1564:   ERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);",
      "1565:   return -1;",
      "1566:  }",
      "",
      "[Removed Lines]",
      "1563:  if (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {",
      "",
      "[Added Lines]",
      "1566:  if (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1711: static int mount_entry(const char *fsname, const char *target,",
      "1712:          const char *fstype, unsigned long mountflags,",
      "1714: {",
      "1715: #ifdef HAVE_STATVFS",
      "1716:  struct statvfs sb;",
      "1717: #endif",
      "1720:   if (optional) {",
      "1721:    INFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,",
      "1722:         target, strerror(errno));",
      "",
      "[Removed Lines]",
      "1713:          const char *data, int optional)",
      "1719:  if (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {",
      "",
      "[Added Lines]",
      "1716:          const char *data, int optional, const char *rootfs)",
      "1722:  if (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1763: #endif",
      "1765:   if (mount(fsname, target, fstype,",
      "1767:    if (optional) {",
      "1768:     INFO(\"failed to mount '%s' on '%s' (optional): %s\",",
      "1769:       fsname, target, strerror(errno));",
      "",
      "[Removed Lines]",
      "1766:      mountflags | MS_REMOUNT, data)) {",
      "",
      "[Added Lines]",
      "1769:      mountflags | MS_REMOUNT, data) < 0) {",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1843: }",
      "1845: static inline int mount_entry_on_generic(struct mntent *mntent,",
      "1847: {",
      "1848:  unsigned long mntflags;",
      "1849:  char *mntdata;",
      "",
      "[Removed Lines]",
      "1846:                  const char* path)",
      "",
      "[Added Lines]",
      "1849:                  const char* path, const char *rootfs)",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "1863:  }",
      "1865:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,",
      "1868:  free(mntdata);",
      "",
      "[Removed Lines]",
      "1866:      mntflags, mntdata, optional);",
      "",
      "[Added Lines]",
      "1869:      mntflags, mntdata, optional, rootfs);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1873: static inline int mount_entry_on_systemfs(struct mntent *mntent)",
      "1874: {",
      "1876: }",
      "1878: static int mount_entry_on_absolute_rootfs(struct mntent *mntent,",
      "",
      "[Removed Lines]",
      "1875:   return mount_entry_on_generic(mntent, mntent->mnt_dir);",
      "",
      "[Added Lines]",
      "1878:   return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1919:   return -1;",
      "1920:  }",
      "1923: }",
      "1925: static int mount_entry_on_relative_rootfs(struct mntent *mntent,",
      "",
      "[Removed Lines]",
      "1922:  return mount_entry_on_generic(mntent, path);",
      "",
      "[Added Lines]",
      "1925:  return mount_entry_on_generic(mntent, path, rootfs->mount);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1935:   return -1;",
      "1936:  }",
      "1939: }",
      "1941: static int mount_file_entries(const struct lxc_rootfs *rootfs, FILE *file,",
      "",
      "[Removed Lines]",
      "1938:  return mount_entry_on_generic(mntent, path);",
      "",
      "[Added Lines]",
      "1941:  return mount_entry_on_generic(mntent, path, rootfs);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3602:   fclose(pathfile);",
      "3603:  }",
      "3606:  if (ret < 0)",
      "3607:   SYSERROR(\"Failed to bind lxc.init.static into container\");",
      "3608:  INFO(\"lxc.init.static bound into container at %s\", path);",
      "",
      "[Removed Lines]",
      "3605:  ret = mount(path, destpath, \"none\", MS_BIND, NULL);",
      "",
      "[Added Lines]",
      "3608:  ret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);",
      "",
      "---------------"
    ],
    "src/lxc/utils.c||src/lxc/utils.c": [
      "File: src/lxc/utils.c -> src/lxc/utils.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1404:  return ret;",
      "1405: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1414: static char *get_nextpath(char *path, int *offsetp, int fulllen)",
      "1415: {",
      "1416:  int offset = *offsetp;",
      "1418:  if (offset >= fulllen)",
      "1419:   return NULL;",
      "1421:  while (path[offset] != '\\0' && offset < fulllen)",
      "1422:   offset++;",
      "1423:  while (path[offset] == '\\0' && offset < fulllen)",
      "1424:   offset++;",
      "1427:  return (offset < fulllen) ? &path[offset] : NULL;",
      "1428: }",
      "1434: static bool is_subdir(const char *subdir, const char *dir, size_t len)",
      "1435: {",
      "1436:  size_t subdirlen = strlen(subdir);",
      "1438:  if (subdirlen < len)",
      "1439:   return false;",
      "1440:  if (strncmp(subdir, dir, len) != 0)",
      "1441:   return false;",
      "1442:  if (dir[len-1] == '/')",
      "1443:   return true;",
      "1444:  if (subdir[len] == '/' || subdirlen == len)",
      "1445:   return true;",
      "1446:  return false;",
      "1447: }",
      "1453: static int check_symlink(int fd)",
      "1454: {",
      "1455:  struct stat sb;",
      "1456:  int ret = fstat(fd, &sb);",
      "1457:  if (ret < 0)",
      "1458:   return -ENOENT;",
      "1459:  if (S_ISLNK(sb.st_mode))",
      "1460:   return -ELOOP;",
      "1461:  return 0;",
      "1462: }",
      "1470: static int open_if_safe(int dirfd, const char *nextpath)",
      "1471: {",
      "1472:  int newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);",
      "1473:  if (newfd >= 0) // was not a symlink, all good",
      "1474:   return newfd;",
      "1476:  if (errno == ELOOP)",
      "1477:   return newfd;",
      "1479:  if (errno == EPERM || errno == EACCES) {",
      "1482:   newfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);",
      "1483:   if (newfd >= 0) {",
      "1488:    int ret = check_symlink(newfd);",
      "1489:    if (ret < 0) {",
      "1490:     close(newfd);",
      "1491:     newfd = ret;",
      "1492:    }",
      "1493:   }",
      "1494:  }",
      "1496:  return newfd;",
      "1497: }",
      "1512: static int open_without_symlink(const char *target, const char *prefix_skip)",
      "1513: {",
      "1514:  int curlen = 0, dirfd, fulllen, i;",
      "1515:  char *dup = NULL;",
      "1517:  fulllen = strlen(target);",
      "1520:  if (prefix_skip) {",
      "1521:   curlen = strlen(prefix_skip);",
      "1522:   if (!is_subdir(target, prefix_skip, curlen)) {",
      "1523:    ERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",",
      "1524:     target, prefix_skip);",
      "1525:    return -EINVAL;",
      "1526:   }",
      "1532:   if (curlen)",
      "1533:    curlen--;",
      "1534:  } else {",
      "1535:   prefix_skip = \"/\";",
      "1536:   curlen = 0;",
      "1537:  }",
      "1540:  if ((dup = strdup(target)) == NULL) {",
      "1541:   SYSERROR(\"Out of memory checking for symbolic link\");",
      "1542:   return -ENOMEM;",
      "1543:  }",
      "1544:  for (i = 0; i < fulllen; i++) {",
      "1545:   if (dup[i] == '/')",
      "1546:    dup[i] = '\\0';",
      "1547:  }",
      "1549:  dirfd = open(prefix_skip, O_RDONLY);",
      "1550:  if (dirfd < 0)",
      "1551:   goto out;",
      "1552:  while (1) {",
      "1553:   int newfd, saved_errno;",
      "1554:   char *nextpath;",
      "1556:   if ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)",
      "1557:    goto out;",
      "1558:   newfd = open_if_safe(dirfd, nextpath);",
      "1559:   saved_errno = errno;",
      "1560:   close(dirfd);",
      "1561:   dirfd = newfd;",
      "1562:   if (newfd < 0) {",
      "1563:    errno = saved_errno;",
      "1564:    if (errno == ELOOP)",
      "1565:     SYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);",
      "1566:    else",
      "1567:     SYSERROR(\"Error examining %s in %s\", nextpath, target);",
      "1568:    goto out;",
      "1569:   }",
      "1570:  }",
      "1572: out:",
      "1573:  free(dup);",
      "1574:  return dirfd;",
      "1575: }",
      "1585: int safe_mount(const char *src, const char *dest, const char *fstype,",
      "1586:   unsigned long flags, const void *data, const char *rootfs)",
      "1587: {",
      "1588:  int srcfd = -1, destfd, ret, saved_errno;",
      "1589:  char srcbuf[50], destbuf[50]; // only needs enough for /proc/self/fd/<fd>",
      "1590:  const char *mntsrc = src;",
      "1592:  if (!rootfs)",
      "1593:   rootfs = \"\";",
      "1596:  if (flags & MS_BIND && src && src[0] != '/') {",
      "1597:   INFO(\"this is a relative bind mount\");",
      "1598:   srcfd = open_without_symlink(src, NULL);",
      "1599:   if (srcfd < 0)",
      "1600:    return srcfd;",
      "1601:   ret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);",
      "1602:   if (ret < 0 || ret > 50) {",
      "1603:    close(srcfd);",
      "1604:    ERROR(\"Out of memory\");",
      "1605:    return -EINVAL;",
      "1606:   }",
      "1607:   mntsrc = srcbuf;",
      "1608:  }",
      "1610:  destfd = open_without_symlink(dest, rootfs);",
      "1611:  if (destfd < 0) {",
      "1612:   if (srcfd != -1)",
      "1613:    close(srcfd);",
      "1614:   return destfd;",
      "1615:  }",
      "1617:  ret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);",
      "1618:  if (ret < 0 || ret > 50) {",
      "1619:   if (srcfd != -1)",
      "1620:    close(srcfd);",
      "1621:   close(destfd);",
      "1622:   ERROR(\"Out of memory\");",
      "1623:   return -EINVAL;",
      "1624:  }",
      "1626:  ret = mount(mntsrc, destbuf, fstype, flags, data);",
      "1627:  saved_errno = errno;",
      "1628:  if (srcfd != -1)",
      "1629:   close(srcfd);",
      "1630:  close(destfd);",
      "1631:  if (ret < 0) {",
      "1632:   errno = saved_errno;",
      "1633:   SYSERROR(\"Failed to mount %s onto %s\", src, dest);",
      "1634:   return ret;",
      "1635:  }",
      "1637:  return 0;",
      "1638: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1446:  return 0;",
      "1448: domount:",
      "1450:   return -1;",
      "1451:  INFO(\"Mounted /proc in container for security transition\");",
      "1452:  return 1;",
      "",
      "[Removed Lines]",
      "1449:  if (mount(\"proc\", path, \"proc\", 0, NULL))",
      "",
      "[Added Lines]",
      "1682:  if (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)",
      "",
      "---------------"
    ],
    "src/lxc/utils.h||src/lxc/utils.h": [
      "File: src/lxc/utils.h -> src/lxc/utils.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "279: int is_dir(const char *path);",
      "280: char *get_template_path(const char *t);",
      "281: int setproctitle(char *title);",
      "282: int mount_proc_if_needed(const char *rootfs);",
      "283: int null_stdfds(void);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "282: int safe_mount(const char *src, const char *dest, const char *fstype,",
      "283:   unsigned long flags, const void *data, const char *rootfs);",
      "",
      "---------------"
    ],
    "src/tests/Makefile.am||src/tests/Makefile.am": [
      "File: src/tests/Makefile.am -> src/tests/Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "55:  lxc-test-apparmor-mount \\",
      "56:  lxc-test-checkpoint-restore \\",
      "57:  lxc-test-snapdeps \\",
      "58:  lxc-test-ubuntu \\",
      "59:  lxc-test-unpriv \\",
      "60:  lxc-test-usernic",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "58:  lxc-test-symlink \\",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "82:  lxc-test-cloneconfig \\",
      "83:  lxc-test-createconfig \\",
      "84:  lxc-test-snapdeps \\",
      "85:  lxc-test-ubuntu \\",
      "86:  lxc-test-unpriv \\",
      "87:  may_control.c \\",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "86:  lxc-test-symlink \\",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "88e078ba865b675f9a0dc61caa0732d7052593f8",
      "candidate_info": {
        "commit_hash": "88e078ba865b675f9a0dc61caa0732d7052593f8",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/88e078ba865b675f9a0dc61caa0732d7052593f8",
        "files": [
          "src/lxc/utils.c"
        ],
        "message": "open_without_symlink: Don't SYSERROR on something else than ELOOP\n\nThe open_without_symlink routine has been specifically created to prevent\nmounts with synlinks as source or destination. Keep SYSERROR'ing in that\nparticular scenario, but leave error handling to calling functions for the\nother ones - e.g. optional bind mount when the source dir doesn't exist\nthrows a nasty error.\n\nSigned-off-by: Bogdan Purcareata <bogdan.purcareata@nxp.com>",
        "before_after_code_files": [
          "src/lxc/utils.c||src/lxc/utils.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/utils.c||src/lxc/utils.c"
          ],
          "candidate": [
            "src/lxc/utils.c||src/lxc/utils.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/utils.c||src/lxc/utils.c": [
          "File: src/lxc/utils.c -> src/lxc/utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1621:    errno = saved_errno;",
          "1622:    if (errno == ELOOP)",
          "1623:     SYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);",
          "1626:    goto out;",
          "1627:   }",
          "1628:  }",
          "",
          "[Removed Lines]",
          "1624:    else",
          "1625:     SYSERROR(\"Error examining %s in %s\", nextpath, target);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1668:  destfd = open_without_symlink(dest, rootfs);",
          "1669:  if (destfd < 0) {",
          "1671:    close(srcfd);",
          "1672:   return destfd;",
          "1673:  }",
          "",
          "[Removed Lines]",
          "1670:   if (srcfd != -1)",
          "",
          "[Added Lines]",
          "1668:   if (srcfd != -1) {",
          "1669:    saved_errno = errno;",
          "1671:    errno = saved_errno;",
          "1672:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e46cc0dca6662b66bb9bd9f0b340bf6c86c13df",
      "candidate_info": {
        "commit_hash": "6e46cc0dca6662b66bb9bd9f0b340bf6c86c13df",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/6e46cc0dca6662b66bb9bd9f0b340bf6c86c13df",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "Make overlayfs mounts work directly\n\nWhen users wanted to mount overlay directories with lxc.mount.entry they had to\ncreate upperdirs and workdirs beforehand in order to mount them. To create it\nfor them we add the functions mount_entry_create_overlay_dirs() and\nmount_entry_create_aufs_dirs() which do this for them. User can now simply\nspecify e.g.:\n\n        lxc.mount.entry = /lower merged overlay lowerdir=/lower,upper=/upper,workdir=/workdir,create=dir\n\nand /upper and /workdir will be created for them. /upper and /workdir need to\nbe absolute paths to directories which are created under the containerdir (e.g.\nunder $lxcpath/CONTAINERNAME/). Relative mountpoints, mountpoints outside the\ncontainerdir, and mountpoints within the container's rootfs are ignored. (The\nlatter *might* change in the future should it be considered safe/useful.)\n\nSpecifying\n\n        lxc.mount.entry = /lower merged overlay lowerdir=/lower:/lower2,create=dir\n\nwill lead to a read-only overlay mount in accordance with the\nkernel-documentation.\n\nSpecifying\n\n        lxc.mount.entry = /lower merged overlay lowerdir=/lower,create=dir\n\nwill fail when no upperdir and workdir options are given.\n\nSigned-off-by: Christian Brauner <christianvanbrauner@gmail.com>\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1815:  }",
          "1816: }",
          "1818: static int mount_entry_create_dir_file(const struct mntent *mntent,",
          "1820: {",
          "1821:  char *pathdirname = NULL;",
          "1822:  int ret = 0;",
          "1823:  FILE *pathfile = NULL;",
          "1825:  if (hasmntopt(mntent, \"create=dir\")) {",
          "1826:   if (mkdir_p(path, 0755) < 0) {",
          "1827:    WARN(\"Failed to create mount target '%s'\", path);",
          "",
          "[Removed Lines]",
          "1819:            const char* path)",
          "",
          "[Added Lines]",
          "1818: static int mount_entry_create_overlay_dirs(const struct mntent *mntent,",
          "1819:         const struct lxc_rootfs *rootfs)",
          "1820: {",
          "1821:  char *del = NULL;",
          "1822:  char *lxcpath = NULL;",
          "1823:  char *upperdir = NULL;",
          "1824:  char *workdir = NULL;",
          "1825:  char **opts = NULL;",
          "1826:  size_t arrlen = 0;",
          "1827:  size_t dirlen = 0;",
          "1828:  size_t i;",
          "1829:  size_t len = 0;",
          "1830:  size_t rootfslen = 0;",
          "1832:  if (!rootfs->path)",
          "1833:   return -1;",
          "1835:  opts = lxc_string_split(mntent->mnt_opts, ',');",
          "1836:  if (opts)",
          "1837:   arrlen = lxc_array_len((void **)opts);",
          "1838:  else",
          "1839:   return -1;",
          "1841:  for (i = 0; i < arrlen; i++) {",
          "1842:   if (strstr(opts[i], \"upperdir=\") && (strlen(opts[i]) > (len = strlen(\"upperdir=\"))))",
          "1843:    upperdir = opts[i] + len;",
          "1844:   else if (strstr(opts[i], \"workdir=\") && (strlen(opts[i]) > (len = strlen(\"workdir=\"))))",
          "1845:    workdir = opts[i] + len;",
          "1846:  }",
          "1848:  lxcpath = strdup(rootfs->path);",
          "1849:  if (!lxcpath) {",
          "1850:   lxc_free_array((void **)opts, free);",
          "1851:   return -1;",
          "1852:  }",
          "1854:  del = strstr(lxcpath, \"/rootfs\");",
          "1855:  if (!del) {",
          "1856:   free(lxcpath);",
          "1857:   lxc_free_array((void **)opts, free);",
          "1858:   return -1;",
          "1859:  }",
          "1862:  dirlen = strlen(lxcpath);",
          "1863:  rootfslen = strlen(rootfs->path);",
          "1867:  if (upperdir)",
          "1868:   if ((strncmp(upperdir, lxcpath, dirlen) == 0) && (strncmp(upperdir, rootfs->path, rootfslen) != 0))",
          "1869:    if (mkdir_p(upperdir, 0755) < 0) {",
          "1870:     WARN(\"Failed to create upperdir\");",
          "1871:    }",
          "1874:  if (workdir)",
          "1875:   if ((strncmp(workdir, lxcpath, dirlen) == 0) && (strncmp(workdir, rootfs->path, rootfslen) != 0))",
          "1876:    if (mkdir_p(workdir, 0755) < 0) {",
          "1877:     WARN(\"Failed to create workdir\");",
          "1878:    }",
          "1880:  free(lxcpath);",
          "1881:  lxc_free_array((void **)opts, free);",
          "1882:  return 0;",
          "1883: }",
          "1885: static int mount_entry_create_aufs_dirs(const struct mntent *mntent,",
          "1886:      const struct lxc_rootfs *rootfs)",
          "1887: {",
          "1888:  char *del = NULL;",
          "1889:  char *lxcpath = NULL;",
          "1890:  char *scratch = NULL;",
          "1891:  char *tmp = NULL;",
          "1892:  char *upperdir = NULL;",
          "1893:  char **opts = NULL;",
          "1894:  size_t arrlen = 0;",
          "1895:  size_t i;",
          "1896:  size_t len = 0;",
          "1898:  if (!rootfs->path)",
          "1899:   return -1;",
          "1901:  opts = lxc_string_split(mntent->mnt_opts, ',');",
          "1902:  if (opts)",
          "1903:   arrlen = lxc_array_len((void **)opts);",
          "1904:  else",
          "1905:   return -1;",
          "1907:  for (i = 0; i < arrlen; i++) {",
          "1908:   if (strstr(opts[i], \"br=\") && (strlen(opts[i]) > (len = strlen(\"br=\"))))",
          "1909:    tmp = opts[i] + len;",
          "1910:  }",
          "1911:  if (!tmp) {",
          "1912:   lxc_free_array((void **)opts, free);",
          "1913:   return -1;",
          "1914:  }",
          "1916:  upperdir = strtok_r(tmp, \":=\", &scratch);",
          "1917:  if (!upperdir) {",
          "1918:   lxc_free_array((void **)opts, free);",
          "1919:   return -1;",
          "1920:  }",
          "1922:  lxcpath = strdup(rootfs->path);",
          "1923:  if (!lxcpath) {",
          "1924:   lxc_free_array((void **)opts, free);",
          "1925:   return -1;",
          "1926:  }",
          "1928:  del = strstr(lxcpath, \"/rootfs\");",
          "1929:  if (!del) {",
          "1930:   free(lxcpath);",
          "1931:   lxc_free_array((void **)opts, free);",
          "1932:   return -1;",
          "1933:  }",
          "1938:  if ((strncmp(upperdir, lxcpath, strlen(lxcpath)) == 0) && (strncmp(upperdir, rootfs->path, strlen(rootfs->path)) != 0))",
          "1939:   if (mkdir_p(upperdir, 0755) < 0) {",
          "1940:    WARN(\"Failed to create upperdir\");",
          "1941:   }",
          "1943:  free(lxcpath);",
          "1944:  lxc_free_array((void **)opts, free);",
          "1945:  return 0;",
          "1946: }",
          "1949:            const char* path, const struct lxc_rootfs *rootfs)",
          "1955:  if (strncmp(mntent->mnt_type, \"overlay\", 7) == 0) {",
          "1956:   if (mount_entry_create_overlay_dirs(mntent, rootfs) < 0)",
          "1957:    return -1;",
          "1958:  } else if (strncmp(mntent->mnt_type, \"aufs\", 4) == 0) {",
          "1959:   if (mount_entry_create_aufs_dirs(mntent, rootfs) < 0)",
          "1960:    return -1;",
          "1961:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1839:   if (!pathfile) {",
          "1840:    WARN(\"Failed to create mount target '%s'\", path);",
          "1841:    ret = -1;",
          "1844:    fclose(pathfile);",
          "1845:  }",
          "1846:  free(pathdirname);",
          "1847:  return ret;",
          "1848: }",
          "1850: static inline int mount_entry_on_generic(struct mntent *mntent,",
          "1852: {",
          "1853:  unsigned long mntflags;",
          "1854:  char *mntdata;",
          "1855:  int ret;",
          "1856:  bool optional = hasmntopt(mntent, \"optional\") != NULL;",
          "1860:  if (ret < 0)",
          "1861:   return optional ? 0 : -1;",
          "",
          "[Removed Lines]",
          "1842:   }",
          "1843:   else",
          "1851:                  const char* path, const char *rootfs)",
          "1858:  ret = mount_entry_create_dir_file(mntent, path);",
          "",
          "[Added Lines]",
          "1980:   } else {",
          "1982:   }",
          "1989:                  const char* path, const struct lxc_rootfs *rootfs)",
          "1996:  ret = mount_entry_create_dir_file(mntent, path, rootfs);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1867:   return -1;",
          "1868:  }",
          "1873:  free(mntdata);",
          "1875:  return ret;",
          "1876: }",
          "",
          "[Removed Lines]",
          "1870:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,",
          "1871:      mntflags, mntdata, optional, rootfs);",
          "",
          "[Added Lines]",
          "2008:  ret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type, mntflags,",
          "2009:      mntdata, optional,",
          "2010:      rootfs->path ? rootfs->mount : NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1924:   return -1;",
          "1925:  }",
          "1928: }",
          "1930: static int mount_entry_on_relative_rootfs(struct mntent *mntent,",
          "1932: {",
          "1933:  char path[MAXPATHLEN];",
          "1934:  int ret;",
          "1938:  if (ret >= sizeof(path)) {",
          "1939:   ERROR(\"path name too long\");",
          "1940:   return -1;",
          "",
          "[Removed Lines]",
          "1927:  return mount_entry_on_generic(mntent, path, rootfs->mount);",
          "1931:        const char *rootfs)",
          "1937:  ret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);",
          "",
          "[Added Lines]",
          "2065:  return mount_entry_on_generic(mntent, path, rootfs);",
          "2069:        const struct lxc_rootfs *rootfs)",
          "2075:  ret = snprintf(path, sizeof(path), \"%s/%s\", rootfs->mount, mntent->mnt_dir);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1962:   if (mntent.mnt_dir[0] != '/') {",
          "1963:    if (mount_entry_on_relative_rootfs(&mntent,",
          "1965:     goto out;",
          "1966:    continue;",
          "1967:   }",
          "",
          "[Removed Lines]",
          "1964:           rootfs->mount))",
          "",
          "[Added Lines]",
          "2102:           rootfs))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "24ab0d34048f80c1419843fa007cac581855749d",
      "candidate_info": {
        "commit_hash": "24ab0d34048f80c1419843fa007cac581855749d",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/24ab0d34048f80c1419843fa007cac581855749d",
        "files": [
          "src/lxc/conf.c"
        ],
        "message": "proc:mixed make /proc/sys/net writable\n\nSigned-off-by: St\u00e9phane Graber <stgraber@ubuntu.com>\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "754:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
          "755:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },",
          "756:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
          "757:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },",
          "758:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },",
          "759:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "755:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },",
          "758:   { LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f267d6668e3a95cb2247accb169cf1bc7f8ffcab",
      "candidate_info": {
        "commit_hash": "f267d6668e3a95cb2247accb169cf1bc7f8ffcab",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/f267d6668e3a95cb2247accb169cf1bc7f8ffcab",
        "files": [
          "src/lxc/conf.c",
          "src/lxc/utils.c"
        ],
        "message": "mount_proc_if_needed: only safe mount when rootfs is defined\n\nThe safe_mount function was introduced in order to address CVE-2015-1335,\none of the vulnerabilities being a mount with a symlink for the\ndestination path. In scenarios such as lxc-execute with no rootfs, the\ndestination path is the host /proc, which is previously mounted by the\nhost, and is unmounted and mounted again in a new set of namespaces,\ntherefore eliminating the need to check for it being a symlink.\n\nMount the rootfs normally if the rootfs is NULL, keep the safe mount\nonly for scenarios where a different rootfs is defined.\n\nSigned-off-by: Bogdan Purcareata <bogdan.purcareata@nxp.com>\nAcked-by: Serge E. Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c",
          "src/lxc/utils.c||src/lxc/utils.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c",
            "src/lxc/utils.c||src/lxc/utils.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c",
            "src/lxc/utils.c||src/lxc/utils.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c"
        ],
        "src/lxc/utils.c||src/lxc/utils.c": [
          "File: src/lxc/utils.c -> src/lxc/utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1737:  return 0;",
          "1739: domount:",
          "1741:   return -1;",
          "1742:  INFO(\"Mounted /proc in container for security transition\");",
          "1743:  return 1;",
          "1744: }",
          "",
          "[Removed Lines]",
          "1740:  if (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)",
          "",
          "[Added Lines]",
          "1743:   ret = mount(\"proc\", path, \"proc\", 0, NULL);",
          "1744:  else",
          "1745:   ret = safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs);",
          "1747:  if (ret < 0)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c35d29097cce58de0eb568486f8c8082a2b0d4d0",
      "candidate_info": {
        "commit_hash": "c35d29097cce58de0eb568486f8c8082a2b0d4d0",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/c35d29097cce58de0eb568486f8c8082a2b0d4d0",
        "files": [
          "doc/ja/lxc.container.conf.sgml.in",
          "doc/ko/lxc.container.conf.sgml.in",
          "doc/lxc.container.conf.sgml.in",
          "src/lxc/conf.c"
        ],
        "message": "increase /dev size to 500k ( issue #781)\n\nSigned-off-by: Min Wang <mingewang@gmail.com>",
        "before_after_code_files": [
          "src/lxc/conf.c||src/lxc/conf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ],
          "candidate": [
            "src/lxc/conf.c||src/lxc/conf.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1080:   return 0;",
          "1081:  }",
          "1084:     rootfs->path ? rootfs->mount : NULL)) {",
          "1085:   SYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);",
          "1086:   return false;",
          "",
          "[Removed Lines]",
          "1083:  if (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",",
          "",
          "[Added Lines]",
          "1083:  if (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=500000,mode=755\",",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-11463",
  "cve_desc": "A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo. NOTE: this only affects users who downloaded the development code from GitHub. Users of the product's official releases are unaffected.",
  "repo": "libarchive/libarchive",
  "patch_hash": "ba641f73f3d758d9032b3f0e5597a9c6e593a505",
  "patch_info": {
    "commit_hash": "ba641f73f3d758d9032b3f0e5597a9c6e593a505",
    "repo": "libarchive/libarchive",
    "commit_url": "https://github.com/libarchive/libarchive/commit/ba641f73f3d758d9032b3f0e5597a9c6e593a505",
    "files": [
      "libarchive/archive_read_support_format_zip.c"
    ],
    "message": "Fix typo in preprocessor macro in archive_read_format_zip_cleanup()\n\nFrees lzma_stream on cleanup()\n\nFixes #1165",
    "before_after_code_files": [
      "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c"
    ]
  },
  "patch_diff": {
    "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c": [
      "File: libarchive/archive_read_support_format_zip.c -> libarchive/archive_read_support_format_zip.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2751:   inflateEnd(&zip->stream);",
      "2752: #endif",
      "2755:     if (zip->zipx_lzma_valid) {",
      "2756:   lzma_end(&zip->zipx_lzma_stream);",
      "2757:  }",
      "",
      "[Removed Lines]",
      "2754: #if HAVA_LZMA_H && HAVE_LIBLZMA",
      "",
      "[Added Lines]",
      "2754: #if HAVE_LZMA_H && HAVE_LIBLZMA",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "786e734872d80a7676a486a6f1d45ee29710628f",
      "candidate_info": {
        "commit_hash": "786e734872d80a7676a486a6f1d45ee29710628f",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/786e734872d80a7676a486a6f1d45ee29710628f",
        "files": [
          "libarchive/archive_read_support_format_zip.c"
        ],
        "message": "ZIP reader: improve checks for existence of liblzma\n\nFor every HAVE_LZMA_H check, include also a check for HAVE_LIBLZMA.\n\nThis was done in order to fix build issues in case where the 'lzma.h'\nfile does exist, but the SO library file doesn't exist.",
        "before_after_code_files": [
          "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c"
          ],
          "candidate": [
            "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c": [
          "File: libarchive/archive_read_support_format_zip.c -> libarchive/archive_read_support_format_zip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "180:  char   stream_valid;",
          "181: #endif",
          "184:  lzma_stream  zipx_lzma_stream;",
          "185:  char            zipx_lzma_valid;",
          "186: #endif",
          "",
          "[Removed Lines]",
          "183: #ifdef HAVE_LZMA_H",
          "",
          "[Added Lines]",
          "183: #if HAVE_LZMA_H && HAVE_LIBLZMA",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1385:     return (ARCHIVE_OK);",
          "1386: }",
          "1389: static int",
          "1390: zipx_xz_init(struct archive_read *a, struct zip *zip)",
          "1391: {",
          "",
          "[Removed Lines]",
          "1388: #ifdef HAVE_LZMA_H",
          "",
          "[Added Lines]",
          "1388: #if HAVE_LZMA_H && HAVE_LIBLZMA",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2643:   r = zip_read_data_zipx_bzip2(a, buff, size, offset);",
          "2644:   break;",
          "2645: #endif",
          "2648:   r = zip_read_data_zipx_lzma_alone(a, buff, size, offset);",
          "2649:   break;",
          "",
          "[Removed Lines]",
          "2646: #ifdef HAVE_LZMA_H",
          "",
          "[Added Lines]",
          "2646: #if HAVE_LZMA_H && HAVE_LIBLZMA",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2729:   inflateEnd(&zip->stream);",
          "2730: #endif",
          "2733:     if (zip->zipx_lzma_valid) {",
          "2734:   lzma_end(&zip->zipx_lzma_stream);",
          "2735:  }",
          "",
          "[Removed Lines]",
          "2732: #ifdef HAVA_LZMA_H",
          "",
          "[Added Lines]",
          "2732: #if HAVA_LZMA_H && HAVE_LIBLZMA",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "121035c83e18b70d3128e9ac966109ebedb7e516",
      "candidate_info": {
        "commit_hash": "121035c83e18b70d3128e9ac966109ebedb7e516",
        "repo": "libarchive/libarchive",
        "commit_url": "https://github.com/libarchive/libarchive/commit/121035c83e18b70d3128e9ac966109ebedb7e516",
        "files": [
          "libarchive/CMakeLists.txt",
          "libarchive/archive_ppmd8.c",
          "libarchive/archive_ppmd8_private.h",
          "libarchive/archive_read_support_format_zip.c",
          "libarchive/test/test_read_format_zip.c",
          "libarchive/test/test_read_format_zip_bzip2.zipx.uu",
          "libarchive/test/test_read_format_zip_bzip2_multi.zipx.uu",
          "libarchive/test/test_read_format_zip_lzma.zipx.uu",
          "libarchive/test/test_read_format_zip_lzma_multi.zipx.uu",
          "libarchive/test/test_read_format_zip_ppmd8.zipx.uu",
          "libarchive/test/test_read_format_zip_ppmd8_multi.zipx.uu",
          "libarchive/test/test_read_format_zip_xz_multi.zipx.uu"
        ],
        "message": "ZIP reader: added support for XZ, LZMA, PPMD8 and BZIP2 decompression\n\nThis commit adds some support for extraction of '.zipx' files. Those\nfiles are standard ZIP files that can contain files compressed with\ndifferent set of algorithms that standard '.zip' files use.\n\nSupport is still missing for Deflate64, JPEG and WavPack algorithms.",
        "before_after_code_files": [
          "libarchive/archive_ppmd8.c||libarchive/archive_ppmd8.c",
          "libarchive/archive_ppmd8_private.h||libarchive/archive_ppmd8_private.h",
          "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c",
          "libarchive/test/test_read_format_zip.c||libarchive/test/test_read_format_zip.c",
          "libarchive/test/test_read_format_zip_bzip2.zipx.uu||libarchive/test/test_read_format_zip_bzip2.zipx.uu",
          "libarchive/test/test_read_format_zip_bzip2_multi.zipx.uu||libarchive/test/test_read_format_zip_bzip2_multi.zipx.uu",
          "libarchive/test/test_read_format_zip_lzma.zipx.uu||libarchive/test/test_read_format_zip_lzma.zipx.uu",
          "libarchive/test/test_read_format_zip_lzma_multi.zipx.uu||libarchive/test/test_read_format_zip_lzma_multi.zipx.uu",
          "libarchive/test/test_read_format_zip_ppmd8.zipx.uu||libarchive/test/test_read_format_zip_ppmd8.zipx.uu",
          "libarchive/test/test_read_format_zip_ppmd8_multi.zipx.uu||libarchive/test/test_read_format_zip_ppmd8_multi.zipx.uu",
          "libarchive/test/test_read_format_zip_xz_multi.zipx.uu||libarchive/test/test_read_format_zip_xz_multi.zipx.uu"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c"
          ],
          "candidate": [
            "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c"
          ]
        }
      },
      "candidate_diff": {
        "libarchive/archive_ppmd8.c||libarchive/archive_ppmd8.c": [
          "File: libarchive/archive_ppmd8.c -> libarchive/archive_ppmd8.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: 2016-05-21 : Igor Pavlov : Public domain",
          "5: #include \"archive_platform.h\"",
          "7: #include <string.h>",
          "9: #include \"archive_ppmd8_private.h\"",
          "11: const Byte PPMD8_kExpEscape[16] = { 25, 14, 9, 7, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2 };",
          "12: static const UInt16 kInitBinEsc[] = { 0x3CDD, 0x1F3F, 0x59BF, 0x48F3, 0x64A1, 0x5ABC, 0x6632, 0x6051};",
          "14: #define MAX_FREQ 124",
          "15: #define UNIT_SIZE 12",
          "17: #define U2B(nu) ((UInt32)(nu) * UNIT_SIZE)",
          "18: #define U2I(nu) (p->Units2Indx[(nu) - 1])",
          "19: #define I2U(indx) (p->Indx2Units[indx])",
          "21: #ifdef PPMD_32BIT",
          "22:   #define REF(ptr) (ptr)",
          "23: #else",
          "24:   #define REF(ptr) ((UInt32)((Byte *)(ptr) - (p)->Base))",
          "25: #endif",
          "27: #define STATS_REF(ptr) ((CPpmd_State_Ref)REF(ptr))",
          "29: #define CTX(ref) ((CPpmd8_Context *)Ppmd8_GetContext(p, ref))",
          "30: #define STATS(ctx) Ppmd8_GetStats(p, ctx)",
          "31: #define ONE_STATE(ctx) Ppmd8Context_OneState(ctx)",
          "32: #define SUFFIX(ctx) CTX((ctx)->Suffix)",
          "34: #define kTop (1 << 24)",
          "35: #define kBot (1 << 15)",
          "37: typedef CPpmd8_Context * CTX_PTR;",
          "39: struct CPpmd8_Node_;",
          "41: typedef",
          "42:   #ifdef PPMD_32BIT",
          "43:     struct CPpmd8_Node_ *",
          "44:   #else",
          "45:     UInt32",
          "46:   #endif",
          "47:   CPpmd8_Node_Ref;",
          "49: typedef struct CPpmd8_Node_",
          "50: {",
          "51:   UInt32 Stamp;",
          "52:   CPpmd8_Node_Ref Next;",
          "53:   UInt32 NU;",
          "54: } CPpmd8_Node;",
          "56: #ifdef PPMD_32BIT",
          "57:   #define NODE(ptr) (ptr)",
          "58: #else",
          "59:   #define NODE(offs) ((CPpmd8_Node *)(p->Base + (offs)))",
          "60: #endif",
          "62: #define EMPTY_NODE 0xFFFFFFFF",
          "64: void Ppmd8_Construct(CPpmd8 *p)",
          "65: {",
          "66:   unsigned i, k, m;",
          "68:   p->Base = 0;",
          "70:   for (i = 0, k = 0; i < PPMD_NUM_INDEXES; i++)",
          "71:   {",
          "72:     unsigned step = (i >= 12 ? 4 : (i >> 2) + 1);",
          "73:     do { p->Units2Indx[k++] = (Byte)i; } while (--step);",
          "74:     p->Indx2Units[i] = (Byte)k;",
          "75:   }",
          "77:   p->NS2BSIndx[0] = (0 << 1);",
          "78:   p->NS2BSIndx[1] = (1 << 1);",
          "79:   memset(p->NS2BSIndx + 2, (2 << 1), 9);",
          "80:   memset(p->NS2BSIndx + 11, (3 << 1), 256 - 11);",
          "82:   for (i = 0; i < 5; i++)",
          "83:     p->NS2Indx[i] = (Byte)i;",
          "84:   for (m = i, k = 1; i < 260; i++)",
          "85:   {",
          "86:     p->NS2Indx[i] = (Byte)m;",
          "87:     if (--k == 0)",
          "88:       k = (++m) - 4;",
          "89:   }",
          "90: }",
          "92: void Ppmd8_Free(CPpmd8 *p)",
          "93: {",
          "94:   free(p->Base);",
          "95:   p->Size = 0;",
          "96:   p->Base = 0;",
          "97: }",
          "99: Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size)",
          "100: {",
          "101:   if (p->Base == 0 || p->Size != size)",
          "102:   {",
          "103:     Ppmd8_Free(p);",
          "104:     p->AlignOffset =",
          "105:       #ifdef PPMD_32BIT",
          "106:         (4 - size) & 3;",
          "107:       #else",
          "108:         4 - (size & 3);",
          "109:       #endif",
          "110:     if ((p->Base = (Byte *)malloc(p->AlignOffset + size)) == 0)",
          "111:       return False;",
          "112:     p->Size = size;",
          "113:   }",
          "114:   return True;",
          "115: }",
          "117: static void InsertNode(CPpmd8 *p, void *node, unsigned indx)",
          "118: {",
          "119:   ((CPpmd8_Node *)node)->Stamp = EMPTY_NODE;",
          "120:   ((CPpmd8_Node *)node)->Next = (CPpmd8_Node_Ref)p->FreeList[indx];",
          "121:   ((CPpmd8_Node *)node)->NU = I2U(indx);",
          "122:   p->FreeList[indx] = REF(node);",
          "123:   p->Stamps[indx]++;",
          "124: }",
          "126: static void *RemoveNode(CPpmd8 *p, unsigned indx)",
          "127: {",
          "128:   CPpmd8_Node *node = NODE((CPpmd8_Node_Ref)p->FreeList[indx]);",
          "129:   p->FreeList[indx] = node->Next;",
          "130:   p->Stamps[indx]--;",
          "131:   return node;",
          "132: }",
          "134: static void SplitBlock(CPpmd8 *p, void *ptr, unsigned oldIndx, unsigned newIndx)",
          "135: {",
          "136:   unsigned i, nu = I2U(oldIndx) - I2U(newIndx);",
          "137:   ptr = (Byte *)ptr + U2B(I2U(newIndx));",
          "138:   if (I2U(i = U2I(nu)) != nu)",
          "139:   {",
          "140:     unsigned k = I2U(--i);",
          "141:     InsertNode(p, ((Byte *)ptr) + U2B(k), nu - k - 1);",
          "142:   }",
          "143:   InsertNode(p, ptr, i);",
          "144: }",
          "146: static void GlueFreeBlocks(CPpmd8 *p)",
          "147: {",
          "148:   CPpmd8_Node_Ref head = 0;",
          "149:   CPpmd8_Node_Ref *prev = &head;",
          "150:   unsigned i;",
          "152:   p->GlueCount = 1 << 13;",
          "153:   memset(p->Stamps, 0, sizeof(p->Stamps));",
          "157:   if (p->LoUnit != p->HiUnit)",
          "158:     ((CPpmd8_Node *)p->LoUnit)->Stamp = 0;",
          "161:   for (i = 0; i < PPMD_NUM_INDEXES; i++)",
          "162:   {",
          "163:     CPpmd8_Node_Ref next = (CPpmd8_Node_Ref)p->FreeList[i];",
          "164:     p->FreeList[i] = 0;",
          "165:     while (next != 0)",
          "166:     {",
          "167:       CPpmd8_Node *node = NODE(next);",
          "168:       if (node->NU != 0)",
          "169:       {",
          "170:         CPpmd8_Node *node2;",
          "172:         prev = &(node->Next);",
          "173:         while ((node2 = node + node->NU)->Stamp == EMPTY_NODE)",
          "174:         {",
          "175:           node->NU += node2->NU;",
          "176:           node2->NU = 0;",
          "177:         }",
          "178:       }",
          "179:       next = node->Next;",
          "180:     }",
          "181:   }",
          "185:   while (head != 0)",
          "186:   {",
          "187:     CPpmd8_Node *node = NODE(head);",
          "188:     unsigned nu;",
          "189:     head = node->Next;",
          "190:     nu = node->NU;",
          "191:     if (nu == 0)",
          "192:       continue;",
          "193:     for (; nu > 128; nu -= 128, node += 128)",
          "194:       InsertNode(p, node, PPMD_NUM_INDEXES - 1);",
          "195:     if (I2U(i = U2I(nu)) != nu)",
          "196:     {",
          "197:       unsigned k = I2U(--i);",
          "198:       InsertNode(p, node + k, nu - k - 1);",
          "199:     }",
          "200:     InsertNode(p, node, i);",
          "201:   }",
          "202: }",
          "204: static void *AllocUnitsRare(CPpmd8 *p, unsigned indx)",
          "205: {",
          "206:   unsigned i;",
          "207:   void *retVal;",
          "208:   if (p->GlueCount == 0)",
          "209:   {",
          "210:     GlueFreeBlocks(p);",
          "211:     if (p->FreeList[indx] != 0)",
          "212:       return RemoveNode(p, indx);",
          "213:   }",
          "214:   i = indx;",
          "215:   do",
          "216:   {",
          "217:     if (++i == PPMD_NUM_INDEXES)",
          "218:     {",
          "219:       UInt32 numBytes = U2B(I2U(indx));",
          "220:       p->GlueCount--;",
          "221:       return ((UInt32)(p->UnitsStart - p->Text) > numBytes) ? (p->UnitsStart -= numBytes) : (NULL);",
          "222:     }",
          "223:   }",
          "224:   while (p->FreeList[i] == 0);",
          "225:   retVal = RemoveNode(p, i);",
          "226:   SplitBlock(p, retVal, i, indx);",
          "227:   return retVal;",
          "228: }",
          "230: static void *AllocUnits(CPpmd8 *p, unsigned indx)",
          "231: {",
          "232:   UInt32 numBytes;",
          "233:   if (p->FreeList[indx] != 0)",
          "234:     return RemoveNode(p, indx);",
          "235:   numBytes = U2B(I2U(indx));",
          "236:   if (numBytes <= (UInt32)(p->HiUnit - p->LoUnit))",
          "237:   {",
          "238:     void *retVal = p->LoUnit;",
          "239:     p->LoUnit += numBytes;",
          "240:     return retVal;",
          "241:   }",
          "242:   return AllocUnitsRare(p, indx);",
          "243: }",
          "245: #define MyMem12Cpy(dest, src, num) \\",
          "246:   { UInt32 *d = (UInt32 *)dest; const UInt32 *z = (const UInt32 *)src; UInt32 n = num; \\",
          "247:     do { d[0] = z[0]; d[1] = z[1]; d[2] = z[2]; z += 3; d += 3; } while (--n); }",
          "249: static void *ShrinkUnits(CPpmd8 *p, void *oldPtr, unsigned oldNU, unsigned newNU)",
          "250: {",
          "251:   unsigned i0 = U2I(oldNU);",
          "252:   unsigned i1 = U2I(newNU);",
          "253:   if (i0 == i1)",
          "254:     return oldPtr;",
          "255:   if (p->FreeList[i1] != 0)",
          "256:   {",
          "257:     void *ptr = RemoveNode(p, i1);",
          "258:     MyMem12Cpy(ptr, oldPtr, newNU);",
          "259:     InsertNode(p, oldPtr, i0);",
          "260:     return ptr;",
          "261:   }",
          "262:   SplitBlock(p, oldPtr, i0, i1);",
          "263:   return oldPtr;",
          "264: }",
          "266: static void FreeUnits(CPpmd8 *p, void *ptr, unsigned nu)",
          "267: {",
          "268:   InsertNode(p, ptr, U2I(nu));",
          "269: }",
          "271: static void SpecialFreeUnit(CPpmd8 *p, void *ptr)",
          "272: {",
          "273:   if ((Byte *)ptr != p->UnitsStart)",
          "274:     InsertNode(p, ptr, 0);",
          "275:   else",
          "276:   {",
          "277:     #ifdef PPMD8_FREEZE_SUPPORT",
          "279:     #endif",
          "280:     p->UnitsStart += UNIT_SIZE;",
          "281:   }",
          "282: }",
          "284: static void *MoveUnitsUp(CPpmd8 *p, void *oldPtr, unsigned nu)",
          "285: {",
          "286:   unsigned indx = U2I(nu);",
          "287:   void *ptr;",
          "288:   if ((Byte *)oldPtr > p->UnitsStart + 16 * 1024 || REF(oldPtr) > p->FreeList[indx])",
          "289:     return oldPtr;",
          "290:   ptr = RemoveNode(p, indx);",
          "291:   MyMem12Cpy(ptr, oldPtr, nu);",
          "292:   if ((Byte*)oldPtr != p->UnitsStart)",
          "293:     InsertNode(p, oldPtr, indx);",
          "294:   else",
          "295:     p->UnitsStart += U2B(I2U(indx));",
          "296:   return ptr;",
          "297: }",
          "299: static void ExpandTextArea(CPpmd8 *p)",
          "300: {",
          "301:   UInt32 count[PPMD_NUM_INDEXES];",
          "302:   unsigned i;",
          "303:   memset(count, 0, sizeof(count));",
          "304:   if (p->LoUnit != p->HiUnit)",
          "305:     ((CPpmd8_Node *)p->LoUnit)->Stamp = 0;",
          "307:   {",
          "308:     CPpmd8_Node *node = (CPpmd8_Node *)p->UnitsStart;",
          "309:     for (; node->Stamp == EMPTY_NODE; node += node->NU)",
          "310:     {",
          "311:       node->Stamp = 0;",
          "312:       count[U2I(node->NU)]++;",
          "313:     }",
          "314:     p->UnitsStart = (Byte *)node;",
          "315:   }",
          "317:   for (i = 0; i < PPMD_NUM_INDEXES; i++)",
          "318:   {",
          "319:     CPpmd8_Node_Ref *next = (CPpmd8_Node_Ref *)&p->FreeList[i];",
          "320:     while (count[i] != 0)",
          "321:     {",
          "322:       CPpmd8_Node *node = NODE(*next);",
          "323:       while (node->Stamp == 0)",
          "324:       {",
          "326:         node = NODE(*next);",
          "327:         p->Stamps[i]--;",
          "328:         if (--count[i] == 0)",
          "329:           break;",
          "330:       }",
          "331:       next = &node->Next;",
          "332:     }",
          "333:   }",
          "334: }",
          "336: #define SUCCESSOR(p) ((CPpmd_Void_Ref)((p)->SuccessorLow | ((UInt32)(p)->SuccessorHigh << 16)))",
          "338: static void SetSuccessor(CPpmd_State *p, CPpmd_Void_Ref v)",
          "339: {",
          "340:   (p)->SuccessorLow = (UInt16)((UInt32)(v) & 0xFFFF);",
          "341:   (p)->SuccessorHigh = (UInt16)(((UInt32)(v) >> 16) & 0xFFFF);",
          "342: }",
          "344: #define RESET_TEXT(offs) { p->Text = p->Base + p->AlignOffset + (offs); }",
          "346: static void RestartModel(CPpmd8 *p)",
          "347: {",
          "348:   unsigned i, k, m, r;",
          "350:   memset(p->FreeList, 0, sizeof(p->FreeList));",
          "351:   memset(p->Stamps, 0, sizeof(p->Stamps));",
          "352:   RESET_TEXT(0);",
          "353:   p->HiUnit = p->Text + p->Size;",
          "354:   p->LoUnit = p->UnitsStart = p->HiUnit - p->Size / 8 / UNIT_SIZE * 7 * UNIT_SIZE;",
          "355:   p->GlueCount = 0;",
          "357:   p->OrderFall = p->MaxOrder;",
          "358:   p->RunLength = p->InitRL = -(Int32)((p->MaxOrder < 12) ? p->MaxOrder : 12) - 1;",
          "359:   p->PrevSuccess = 0;",
          "362:   p->MinContext->Suffix = 0;",
          "363:   p->MinContext->NumStats = 255;",
          "364:   p->MinContext->Flags = 0;",
          "365:   p->MinContext->SummFreq = 256 + 1;",
          "367:   p->LoUnit += U2B(256 / 2);",
          "368:   p->MinContext->Stats = REF(p->FoundState);",
          "369:   for (i = 0; i < 256; i++)",
          "370:   {",
          "371:     CPpmd_State *s = &p->FoundState[i];",
          "372:     s->Symbol = (Byte)i;",
          "373:     s->Freq = 1;",
          "374:     SetSuccessor(s, 0);",
          "375:   }",
          "377:   for (i = m = 0; m < 25; m++)",
          "378:   {",
          "379:     while (p->NS2Indx[i] == m)",
          "380:       i++;",
          "381:     for (k = 0; k < 8; k++)",
          "382:     {",
          "383:       UInt16 val = (UInt16)(PPMD_BIN_SCALE - kInitBinEsc[k] / (i + 1));",
          "384:       UInt16 *dest = p->BinSumm[m] + k;",
          "385:       for (r = 0; r < 64; r += 8)",
          "386:         dest[r] = val;",
          "387:     }",
          "388:   }",
          "390:   for (i = m = 0; m < 24; m++)",
          "391:   {",
          "392:     while (p->NS2Indx[i + 3] == m + 3)",
          "393:       i++;",
          "394:     for (k = 0; k < 32; k++)",
          "395:     {",
          "396:       CPpmd_See *s = &p->See[m][k];",
          "397:       s->Summ = (UInt16)((2 * i + 5) << (s->Shift = PPMD_PERIOD_BITS - 4));",
          "398:       s->Count = 7;",
          "399:     }",
          "400:   }",
          "401: }",
          "403: void Ppmd8_Init(CPpmd8 *p, unsigned maxOrder, unsigned restoreMethod)",
          "404: {",
          "405:   p->MaxOrder = maxOrder;",
          "406:   p->RestoreMethod = restoreMethod;",
          "407:   RestartModel(p);",
          "408:   p->DummySee.Shift = PPMD_PERIOD_BITS;",
          "411: }",
          "413: static void Refresh(CPpmd8 *p, CTX_PTR ctx, unsigned oldNU, unsigned scale)",
          "414: {",
          "415:   unsigned i = ctx->NumStats, escFreq, sumFreq, flags;",
          "416:   CPpmd_State *s = (CPpmd_State *)ShrinkUnits(p, STATS(ctx), oldNU, (i + 2) >> 1);",
          "417:   ctx->Stats = REF(s);",
          "418:   #ifdef PPMD8_FREEZE_SUPPORT",
          "420:   scale |= (ctx->SummFreq >= ((UInt32)1 << 15));",
          "421:   #endif",
          "422:   flags = (ctx->Flags & (0x10 + 0x04 * scale)) + 0x08 * (s->Symbol >= 0x40);",
          "423:   escFreq = ctx->SummFreq - s->Freq;",
          "424:   sumFreq = (s->Freq = (Byte)((s->Freq + scale) >> scale));",
          "425:   do",
          "426:   {",
          "427:     escFreq -= (++s)->Freq;",
          "428:     sumFreq += (s->Freq = (Byte)((s->Freq + scale) >> scale));",
          "429:     flags |= 0x08 * (s->Symbol >= 0x40);",
          "430:   }",
          "431:   while (--i);",
          "432:   ctx->SummFreq = (UInt16)(sumFreq + ((escFreq + scale) >> scale));",
          "433:   ctx->Flags = (Byte)flags;",
          "434: }",
          "436: static void SwapStates(CPpmd_State *t1, CPpmd_State *t2)",
          "437: {",
          "438:   CPpmd_State tmp = *t1;",
          "441: }",
          "443: static CPpmd_Void_Ref CutOff(CPpmd8 *p, CTX_PTR ctx, unsigned order)",
          "444: {",
          "445:   int i;",
          "446:   unsigned tmp;",
          "447:   CPpmd_State *s;",
          "449:   if (!ctx->NumStats)",
          "450:   {",
          "451:     s = ONE_STATE(ctx);",
          "452:     if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) >= p->UnitsStart)",
          "453:     {",
          "454:       if (order < p->MaxOrder)",
          "455:         SetSuccessor(s, CutOff(p, CTX(SUCCESSOR(s)), order + 1));",
          "456:       else",
          "457:         SetSuccessor(s, 0);",
          "459:         return REF(ctx);",
          "460:     }",
          "461:     SpecialFreeUnit(p, ctx);",
          "462:     return 0;",
          "463:   }",
          "465:   ctx->Stats = STATS_REF(MoveUnitsUp(p, STATS(ctx), tmp = ((unsigned)ctx->NumStats + 2) >> 1));",
          "467:   for (s = STATS(ctx) + (i = ctx->NumStats); s >= STATS(ctx); s--)",
          "468:     if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) < p->UnitsStart)",
          "469:     {",
          "470:       CPpmd_State *s2 = STATS(ctx) + (i--);",
          "471:       SetSuccessor(s, 0);",
          "472:       SwapStates(s, s2);",
          "473:     }",
          "474:     else if (order < p->MaxOrder)",
          "475:       SetSuccessor(s, CutOff(p, CTX(SUCCESSOR(s)), order + 1));",
          "476:     else",
          "477:       SetSuccessor(s, 0);",
          "479:   if (i != ctx->NumStats && order)",
          "480:   {",
          "481:     ctx->NumStats = (Byte)i;",
          "482:     s = STATS(ctx);",
          "483:     if (i < 0)",
          "484:     {",
          "485:       FreeUnits(p, s, tmp);",
          "486:       SpecialFreeUnit(p, ctx);",
          "487:       return 0;",
          "488:     }",
          "489:     if (i == 0)",
          "490:     {",
          "491:       ctx->Flags = (Byte)((ctx->Flags & 0x10) + 0x08 * (s->Symbol >= 0x40));",
          "493:       FreeUnits(p, s, tmp);",
          "495:       ONE_STATE(ctx)->Freq = (Byte)(((unsigned)ONE_STATE(ctx)->Freq + 11) >> 3);",
          "496:     }",
          "497:     else",
          "498:       Refresh(p, ctx, tmp, ctx->SummFreq > 16 * i);",
          "499:   }",
          "500:   return REF(ctx);",
          "501: }",
          "503: #ifdef PPMD8_FREEZE_SUPPORT",
          "504: static CPpmd_Void_Ref RemoveBinContexts(CPpmd8 *p, CTX_PTR ctx, unsigned order)",
          "505: {",
          "506:   CPpmd_State *s;",
          "507:   if (!ctx->NumStats)",
          "508:   {",
          "509:     s = ONE_STATE(ctx);",
          "510:     if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) >= p->UnitsStart && order < p->MaxOrder)",
          "511:       SetSuccessor(s, RemoveBinContexts(p, CTX(SUCCESSOR(s)), order + 1));",
          "512:     else",
          "513:       SetSuccessor(s, 0);",
          "516:     if (!SUCCESSOR(s) && (!SUFFIX(ctx)->NumStats || SUFFIX(ctx)->Flags == 0xFF))",
          "517:     {",
          "518:       FreeUnits(p, ctx, 1);",
          "519:       return 0;",
          "520:     }",
          "521:     else",
          "522:       return REF(ctx);",
          "523:   }",
          "525:   for (s = STATS(ctx) + ctx->NumStats; s >= STATS(ctx); s--)",
          "526:     if ((Byte *)Ppmd8_GetPtr(p, SUCCESSOR(s)) >= p->UnitsStart && order < p->MaxOrder)",
          "527:       SetSuccessor(s, RemoveBinContexts(p, CTX(SUCCESSOR(s)), order + 1));",
          "528:     else",
          "529:       SetSuccessor(s, 0);",
          "531:   return REF(ctx);",
          "532: }",
          "533: #endif",
          "535: static UInt32 GetUsedMemory(const CPpmd8 *p)",
          "536: {",
          "537:   UInt32 v = 0;",
          "538:   unsigned i;",
          "539:   for (i = 0; i < PPMD_NUM_INDEXES; i++)",
          "540:     v += p->Stamps[i] * I2U(i);",
          "541:   return p->Size - (UInt32)(p->HiUnit - p->LoUnit) - (UInt32)(p->UnitsStart - p->Text) - U2B(v);",
          "542: }",
          "544: #ifdef PPMD8_FREEZE_SUPPORT",
          "545:   #define RESTORE_MODEL(c1, fSuccessor) RestoreModel(p, c1, fSuccessor)",
          "546: #else",
          "547:   #define RESTORE_MODEL(c1, fSuccessor) RestoreModel(p, c1)",
          "548: #endif",
          "550: static void RestoreModel(CPpmd8 *p, CTX_PTR c1",
          "551:     #ifdef PPMD8_FREEZE_SUPPORT",
          "552:     , CTX_PTR fSuccessor",
          "553:     #endif",
          "554:     )",
          "555: {",
          "556:   CTX_PTR c;",
          "557:   CPpmd_State *s;",
          "558:   RESET_TEXT(0);",
          "559:   for (c = p->MaxContext; c != c1; c = SUFFIX(c))",
          "560:     if (--(c->NumStats) == 0)",
          "561:     {",
          "562:       s = STATS(c);",
          "563:       c->Flags = (Byte)((c->Flags & 0x10) + 0x08 * (s->Symbol >= 0x40));",
          "565:       SpecialFreeUnit(p, s);",
          "566:       ONE_STATE(c)->Freq = (Byte)(((unsigned)ONE_STATE(c)->Freq + 11) >> 3);",
          "567:     }",
          "568:     else",
          "569:       Refresh(p, c, (c->NumStats+3) >> 1, 0);",
          "571:   for (; c != p->MinContext; c = SUFFIX(c))",
          "572:     if (!c->NumStats)",
          "573:       ONE_STATE(c)->Freq = (Byte)(ONE_STATE(c)->Freq - (ONE_STATE(c)->Freq >> 1));",
          "574:     else if ((c->SummFreq += 4) > 128 + 4 * c->NumStats)",
          "575:       Refresh(p, c, (c->NumStats + 2) >> 1, 1);",
          "577:   #ifdef PPMD8_FREEZE_SUPPORT",
          "578:   if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)",
          "579:   {",
          "580:     p->MaxContext = fSuccessor;",
          "581:     p->GlueCount += !(p->Stamps[1] & 1);",
          "582:   }",
          "583:   else if (p->RestoreMethod == PPMD8_RESTORE_METHOD_FREEZE)",
          "584:   {",
          "585:     while (p->MaxContext->Suffix)",
          "586:       p->MaxContext = SUFFIX(p->MaxContext);",
          "587:     RemoveBinContexts(p, p->MaxContext, 0);",
          "588:     p->RestoreMethod++;",
          "589:     p->GlueCount = 0;",
          "590:     p->OrderFall = p->MaxOrder;",
          "591:   }",
          "592:   else",
          "593:   #endif",
          "594:   if (p->RestoreMethod == PPMD8_RESTORE_METHOD_RESTART || GetUsedMemory(p) < (p->Size >> 1))",
          "595:     RestartModel(p);",
          "596:   else",
          "597:   {",
          "598:     while (p->MaxContext->Suffix)",
          "599:       p->MaxContext = SUFFIX(p->MaxContext);",
          "600:     do",
          "601:     {",
          "602:       CutOff(p, p->MaxContext, 0);",
          "603:       ExpandTextArea(p);",
          "604:     }",
          "605:     while (GetUsedMemory(p) > 3 * (p->Size >> 2));",
          "606:     p->GlueCount = 0;",
          "607:     p->OrderFall = p->MaxOrder;",
          "608:   }",
          "609: }",
          "611: static CTX_PTR CreateSuccessors(CPpmd8 *p, Bool skip, CPpmd_State *s1, CTX_PTR c)",
          "612: {",
          "613:   CPpmd_State upState;",
          "614:   Byte flags;",
          "615:   CPpmd_Byte_Ref upBranch = (CPpmd_Byte_Ref)SUCCESSOR(p->FoundState);",
          "617:   CPpmd_State *ps[PPMD8_MAX_ORDER + 1];",
          "618:   unsigned numPs = 0;",
          "620:   if (!skip)",
          "621:     ps[numPs++] = p->FoundState;",
          "623:   while (c->Suffix)",
          "624:   {",
          "625:     CPpmd_Void_Ref successor;",
          "626:     CPpmd_State *s;",
          "627:     c = SUFFIX(c);",
          "628:     if (s1)",
          "629:     {",
          "630:       s = s1;",
          "631:       s1 = NULL;",
          "632:     }",
          "633:     else if (c->NumStats != 0)",
          "634:     {",
          "635:       for (s = STATS(c); s->Symbol != p->FoundState->Symbol; s++);",
          "636:       if (s->Freq < MAX_FREQ - 9)",
          "637:       {",
          "638:         s->Freq++;",
          "639:         c->SummFreq++;",
          "640:       }",
          "641:     }",
          "642:     else",
          "643:     {",
          "644:       s = ONE_STATE(c);",
          "645:       s->Freq = (Byte)(s->Freq + (!SUFFIX(c)->NumStats & (s->Freq < 24)));",
          "646:     }",
          "647:     successor = SUCCESSOR(s);",
          "648:     if (successor != upBranch)",
          "649:     {",
          "650:       c = CTX(successor);",
          "651:       if (numPs == 0)",
          "652:         return c;",
          "653:       break;",
          "654:     }",
          "655:     ps[numPs++] = s;",
          "656:   }",
          "658:   upState.Symbol = *(const Byte *)Ppmd8_GetPtr(p, upBranch);",
          "659:   SetSuccessor(&upState, upBranch + 1);",
          "660:   flags = (Byte)(0x10 * (p->FoundState->Symbol >= 0x40) + 0x08 * (upState.Symbol >= 0x40));",
          "662:   if (c->NumStats == 0)",
          "663:     upState.Freq = ONE_STATE(c)->Freq;",
          "664:   else",
          "665:   {",
          "666:     UInt32 cf, s0;",
          "667:     CPpmd_State *s;",
          "668:     for (s = STATS(c); s->Symbol != upState.Symbol; s++);",
          "669:     cf = s->Freq - 1;",
          "670:     s0 = c->SummFreq - c->NumStats - cf;",
          "671:     upState.Freq = (Byte)(1 + ((2 * cf <= s0) ? (5 * cf > s0) : ((cf + 2 * s0 - 3) / s0)));",
          "672:   }",
          "674:   do",
          "675:   {",
          "678:     if (p->HiUnit != p->LoUnit)",
          "679:       c1 = (CTX_PTR)(p->HiUnit -= UNIT_SIZE);",
          "680:     else if (p->FreeList[0] != 0)",
          "681:       c1 = (CTX_PTR)RemoveNode(p, 0);",
          "682:     else",
          "683:     {",
          "684:       c1 = (CTX_PTR)AllocUnitsRare(p, 0);",
          "685:       if (!c1)",
          "686:         return NULL;",
          "687:     }",
          "688:     c1->NumStats = 0;",
          "689:     c1->Flags = flags;",
          "691:     c1->Suffix = REF(c);",
          "692:     SetSuccessor(ps[--numPs], REF(c1));",
          "693:     c = c1;",
          "694:   }",
          "695:   while (numPs != 0);",
          "697:   return c;",
          "698: }",
          "700: static CTX_PTR ReduceOrder(CPpmd8 *p, CPpmd_State *s1, CTX_PTR c)",
          "701: {",
          "702:   CPpmd_State *s = NULL;",
          "703:   CTX_PTR c1 = c;",
          "704:   CPpmd_Void_Ref upBranch = REF(p->Text);",
          "706:   #ifdef PPMD8_FREEZE_SUPPORT",
          "708:   CPpmd_State *ps[PPMD8_MAX_ORDER + 1];",
          "709:   unsigned numPs = 0;",
          "710:   ps[numPs++] = p->FoundState;",
          "711:   #endif",
          "713:   SetSuccessor(p->FoundState, upBranch);",
          "714:   p->OrderFall++;",
          "716:   for (;;)",
          "717:   {",
          "718:     if (s1)",
          "719:     {",
          "720:       c = SUFFIX(c);",
          "721:       s = s1;",
          "722:       s1 = NULL;",
          "723:     }",
          "724:     else",
          "725:     {",
          "726:       if (!c->Suffix)",
          "727:       {",
          "728:         #ifdef PPMD8_FREEZE_SUPPORT",
          "729:         if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)",
          "730:         {",
          "731:           do { SetSuccessor(ps[--numPs], REF(c)); } while (numPs);",
          "732:           RESET_TEXT(1);",
          "733:           p->OrderFall = 1;",
          "734:         }",
          "735:         #endif",
          "736:         return c;",
          "737:       }",
          "738:       c = SUFFIX(c);",
          "739:       if (c->NumStats)",
          "740:       {",
          "741:         if ((s = STATS(c))->Symbol != p->FoundState->Symbol)",
          "742:           do { s++; } while (s->Symbol != p->FoundState->Symbol);",
          "743:         if (s->Freq < MAX_FREQ - 9)",
          "744:         {",
          "745:           s->Freq += 2;",
          "746:           c->SummFreq += 2;",
          "747:         }",
          "748:       }",
          "749:       else",
          "750:       {",
          "751:         s = ONE_STATE(c);",
          "752:         s->Freq = (Byte)(s->Freq + (s->Freq < 32));",
          "753:       }",
          "754:     }",
          "755:     if (SUCCESSOR(s))",
          "756:       break;",
          "757:     #ifdef PPMD8_FREEZE_SUPPORT",
          "758:     ps[numPs++] = s;",
          "759:     #endif",
          "760:     SetSuccessor(s, upBranch);",
          "761:     p->OrderFall++;",
          "762:   }",
          "764:   #ifdef PPMD8_FREEZE_SUPPORT",
          "765:   if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)",
          "766:   {",
          "767:     c = CTX(SUCCESSOR(s));",
          "768:     do { SetSuccessor(ps[--numPs], REF(c)); } while (numPs);",
          "769:     RESET_TEXT(1);",
          "770:     p->OrderFall = 1;",
          "771:     return c;",
          "772:   }",
          "773:   else",
          "774:   #endif",
          "775:   if (SUCCESSOR(s) <= upBranch)",
          "776:   {",
          "777:     CTX_PTR successor;",
          "778:     CPpmd_State *s2 = p->FoundState;",
          "779:     p->FoundState = s;",
          "781:     successor = CreateSuccessors(p, False, NULL, c);",
          "782:     if (successor == NULL)",
          "783:       SetSuccessor(s, 0);",
          "784:     else",
          "785:       SetSuccessor(s, REF(successor));",
          "786:     p->FoundState = s2;",
          "787:   }",
          "789:   if (p->OrderFall == 1 && c1 == p->MaxContext)",
          "790:   {",
          "791:     SetSuccessor(p->FoundState, SUCCESSOR(s));",
          "792:     p->Text--;",
          "793:   }",
          "794:   if (SUCCESSOR(s) == 0)",
          "795:     return NULL;",
          "796:   return CTX(SUCCESSOR(s));",
          "797: }",
          "799: static void UpdateModel(CPpmd8 *p)",
          "800: {",
          "801:   CPpmd_Void_Ref successor, fSuccessor = SUCCESSOR(p->FoundState);",
          "802:   CTX_PTR c;",
          "803:   unsigned s0, ns, fFreq = p->FoundState->Freq;",
          "804:   Byte flag, fSymbol = p->FoundState->Symbol;",
          "805:   CPpmd_State *s = NULL;",
          "807:   if (p->FoundState->Freq < MAX_FREQ / 4 && p->MinContext->Suffix != 0)",
          "808:   {",
          "809:     c = SUFFIX(p->MinContext);",
          "811:     if (c->NumStats == 0)",
          "812:     {",
          "813:       s = ONE_STATE(c);",
          "814:       if (s->Freq < 32)",
          "815:         s->Freq++;",
          "816:     }",
          "817:     else",
          "818:     {",
          "819:       s = STATS(c);",
          "820:       if (s->Symbol != p->FoundState->Symbol)",
          "821:       {",
          "822:         do { s++; } while (s->Symbol != p->FoundState->Symbol);",
          "823:         if (s[0].Freq >= s[-1].Freq)",
          "824:         {",
          "825:           SwapStates(&s[0], &s[-1]);",
          "826:           s--;",
          "827:         }",
          "828:       }",
          "829:       if (s->Freq < MAX_FREQ - 9)",
          "830:       {",
          "831:         s->Freq += 2;",
          "832:         c->SummFreq += 2;",
          "833:       }",
          "834:     }",
          "835:   }",
          "837:   c = p->MaxContext;",
          "838:   if (p->OrderFall == 0 && fSuccessor)",
          "839:   {",
          "840:     CTX_PTR cs = CreateSuccessors(p, True, s, p->MinContext);",
          "841:     if (cs == 0)",
          "842:     {",
          "843:       SetSuccessor(p->FoundState, 0);",
          "844:       RESTORE_MODEL(c, CTX(fSuccessor));",
          "845:     }",
          "846:     else",
          "847:     {",
          "848:       SetSuccessor(p->FoundState, REF(cs));",
          "849:       p->MaxContext = cs;",
          "850:     }",
          "851:     return;",
          "852:   }",
          "855:   successor = REF(p->Text);",
          "856:   if (p->Text >= p->UnitsStart)",
          "857:   {",
          "859:     return;",
          "860:   }",
          "862:   if (!fSuccessor)",
          "863:   {",
          "864:     CTX_PTR cs = ReduceOrder(p, s, p->MinContext);",
          "865:     if (cs == NULL)",
          "866:     {",
          "867:       RESTORE_MODEL(c, 0);",
          "868:       return;",
          "869:     }",
          "870:     fSuccessor = REF(cs);",
          "871:   }",
          "872:   else if ((Byte *)Ppmd8_GetPtr(p, fSuccessor) < p->UnitsStart)",
          "873:   {",
          "874:     CTX_PTR cs = CreateSuccessors(p, False, s, p->MinContext);",
          "875:     if (cs == NULL)",
          "876:     {",
          "877:       RESTORE_MODEL(c, 0);",
          "878:       return;",
          "879:     }",
          "880:     fSuccessor = REF(cs);",
          "881:   }",
          "883:   if (--p->OrderFall == 0)",
          "884:   {",
          "885:     successor = fSuccessor;",
          "886:     p->Text -= (p->MaxContext != p->MinContext);",
          "887:   }",
          "888:   #ifdef PPMD8_FREEZE_SUPPORT",
          "889:   else if (p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE)",
          "890:   {",
          "891:     successor = fSuccessor;",
          "892:     RESET_TEXT(0);",
          "893:     p->OrderFall = 0;",
          "894:   }",
          "895:   #endif",
          "897:   s0 = p->MinContext->SummFreq - (ns = p->MinContext->NumStats) - fFreq;",
          "898:   flag = (Byte)(0x08 * (fSymbol >= 0x40));",
          "900:   for (; c != p->MinContext; c = SUFFIX(c))",
          "901:   {",
          "902:     unsigned ns1;",
          "903:     UInt32 cf, sf;",
          "904:     if ((ns1 = c->NumStats) != 0)",
          "905:     {",
          "906:       if ((ns1 & 1) != 0)",
          "907:       {",
          "909:         unsigned oldNU = (ns1 + 1) >> 1;",
          "910:         unsigned i = U2I(oldNU);",
          "911:         if (i != U2I(oldNU + 1))",
          "912:         {",
          "913:           void *ptr = AllocUnits(p, i + 1);",
          "914:           void *oldPtr;",
          "915:           if (!ptr)",
          "916:           {",
          "917:             RESTORE_MODEL(c, CTX(fSuccessor));",
          "918:             return;",
          "919:           }",
          "920:           oldPtr = STATS(c);",
          "921:           MyMem12Cpy(ptr, oldPtr, oldNU);",
          "922:           InsertNode(p, oldPtr, i);",
          "923:           c->Stats = STATS_REF(ptr);",
          "924:         }",
          "925:       }",
          "926:       c->SummFreq = (UInt16)(c->SummFreq + (3 * ns1 + 1 < ns));",
          "927:     }",
          "928:     else",
          "929:     {",
          "930:       CPpmd_State *s2 = (CPpmd_State*)AllocUnits(p, 0);",
          "931:       if (!s2)",
          "932:       {",
          "933:         RESTORE_MODEL(c, CTX(fSuccessor));",
          "934:         return;",
          "935:       }",
          "937:       c->Stats = REF(s2);",
          "938:       if (s2->Freq < MAX_FREQ / 4 - 1)",
          "939:         s2->Freq <<= 1;",
          "940:       else",
          "941:         s2->Freq = MAX_FREQ - 4;",
          "942:       c->SummFreq = (UInt16)(s2->Freq + p->InitEsc + (ns > 2));",
          "943:     }",
          "944:     cf = 2 * fFreq * (c->SummFreq + 6);",
          "945:     sf = (UInt32)s0 + c->SummFreq;",
          "946:     if (cf < 6 * sf)",
          "947:     {",
          "948:       cf = 1 + (cf > sf) + (cf >= 4 * sf);",
          "949:       c->SummFreq += 4;",
          "950:     }",
          "951:     else",
          "952:     {",
          "953:       cf = 4 + (cf > 9 * sf) + (cf > 12 * sf) + (cf > 15 * sf);",
          "954:       c->SummFreq = (UInt16)(c->SummFreq + cf);",
          "955:     }",
          "956:     {",
          "957:       CPpmd_State *s2 = STATS(c) + ns1 + 1;",
          "958:       SetSuccessor(s2, successor);",
          "959:       s2->Symbol = fSymbol;",
          "960:       s2->Freq = (Byte)cf;",
          "961:       c->Flags |= flag;",
          "962:       c->NumStats = (Byte)(ns1 + 1);",
          "963:     }",
          "964:   }",
          "965:   p->MaxContext = p->MinContext = CTX(fSuccessor);",
          "966: }",
          "968: static void Rescale(CPpmd8 *p)",
          "969: {",
          "970:   unsigned i, adder, sumFreq, escFreq;",
          "971:   CPpmd_State *stats = STATS(p->MinContext);",
          "972:   CPpmd_State *s = p->FoundState;",
          "973:   {",
          "974:     CPpmd_State tmp = *s;",
          "975:     for (; s != stats; s--)",
          "976:       s[0] = s[-1];",
          "978:   }",
          "979:   escFreq = p->MinContext->SummFreq - s->Freq;",
          "980:   s->Freq += 4;",
          "981:   adder = (p->OrderFall != 0",
          "982:       #ifdef PPMD8_FREEZE_SUPPORT",
          "983:       || p->RestoreMethod > PPMD8_RESTORE_METHOD_FREEZE",
          "984:       #endif",
          "985:       );",
          "986:   s->Freq = (Byte)((s->Freq + adder) >> 1);",
          "987:   sumFreq = s->Freq;",
          "989:   i = p->MinContext->NumStats;",
          "990:   do",
          "991:   {",
          "992:     escFreq -= (++s)->Freq;",
          "993:     s->Freq = (Byte)((s->Freq + adder) >> 1);",
          "994:     sumFreq += s->Freq;",
          "995:     if (s[0].Freq > s[-1].Freq)",
          "996:     {",
          "997:       CPpmd_State *s1 = s;",
          "998:       CPpmd_State tmp = *s1;",
          "999:       do",
          "1000:         s1[0] = s1[-1];",
          "1001:       while (--s1 != stats && tmp.Freq > s1[-1].Freq);",
          "1003:     }",
          "1004:   }",
          "1005:   while (--i);",
          "1007:   if (s->Freq == 0)",
          "1008:   {",
          "1009:     unsigned numStats = p->MinContext->NumStats;",
          "1010:     unsigned n0, n1;",
          "1011:     do { i++; } while ((--s)->Freq == 0);",
          "1012:     escFreq += i;",
          "1013:     p->MinContext->NumStats = (Byte)(p->MinContext->NumStats - i);",
          "1014:     if (p->MinContext->NumStats == 0)",
          "1015:     {",
          "1016:       CPpmd_State tmp = *stats;",
          "1017:       tmp.Freq = (Byte)((2 * tmp.Freq + escFreq - 1) / escFreq);",
          "1018:       if (tmp.Freq > MAX_FREQ / 3)",
          "1019:         tmp.Freq = MAX_FREQ / 3;",
          "1020:       InsertNode(p, stats, U2I((numStats + 2) >> 1));",
          "1021:       p->MinContext->Flags = (Byte)((p->MinContext->Flags & 0x10) + 0x08 * (tmp.Symbol >= 0x40));",
          "1023:       return;",
          "1024:     }",
          "1025:     n0 = (numStats + 2) >> 1;",
          "1026:     n1 = (p->MinContext->NumStats + 2) >> 1;",
          "1027:     if (n0 != n1)",
          "1028:       p->MinContext->Stats = STATS_REF(ShrinkUnits(p, stats, n0, n1));",
          "1029:     p->MinContext->Flags &= ~0x08;",
          "1030:     p->MinContext->Flags |= 0x08 * ((s = STATS(p->MinContext))->Symbol >= 0x40);",
          "1031:     i = p->MinContext->NumStats;",
          "1032:     do { p->MinContext->Flags |= 0x08*((++s)->Symbol >= 0x40); } while (--i);",
          "1033:   }",
          "1034:   p->MinContext->SummFreq = (UInt16)(sumFreq + escFreq - (escFreq >> 1));",
          "1035:   p->MinContext->Flags |= 0x4;",
          "1036:   p->FoundState = STATS(p->MinContext);",
          "1037: }",
          "1039: CPpmd_See *Ppmd8_MakeEscFreq(CPpmd8 *p, unsigned numMasked1, UInt32 *escFreq)",
          "1040: {",
          "1041:   CPpmd_See *see;",
          "1042:   if (p->MinContext->NumStats != 0xFF)",
          "1043:   {",
          "1044:     see = p->See[(unsigned)p->NS2Indx[(unsigned)p->MinContext->NumStats + 2] - 3] +",
          "1045:         (p->MinContext->SummFreq > 11 * ((unsigned)p->MinContext->NumStats + 1)) +",
          "1046:         2 * (unsigned)(2 * (unsigned)p->MinContext->NumStats <",
          "1047:         ((unsigned)SUFFIX(p->MinContext)->NumStats + numMasked1)) +",
          "1048:         p->MinContext->Flags;",
          "1049:     {",
          "1050:       unsigned r = (see->Summ >> see->Shift);",
          "1051:       see->Summ = (UInt16)(see->Summ - r);",
          "1053:     }",
          "1054:   }",
          "1055:   else",
          "1056:   {",
          "1057:     see = &p->DummySee;",
          "1059:   }",
          "1060:   return see;",
          "1061: }",
          "1063: static void NextContext(CPpmd8 *p)",
          "1064: {",
          "1065:   CTX_PTR c = CTX(SUCCESSOR(p->FoundState));",
          "1066:   if (p->OrderFall == 0 && (Byte *)c >= p->UnitsStart)",
          "1067:     p->MinContext = p->MaxContext = c;",
          "1068:   else",
          "1069:   {",
          "1070:     UpdateModel(p);",
          "1071:     p->MinContext = p->MaxContext;",
          "1072:   }",
          "1073: }",
          "1075: void Ppmd8_Update1(CPpmd8 *p)",
          "1076: {",
          "1077:   CPpmd_State *s = p->FoundState;",
          "1078:   s->Freq += 4;",
          "1079:   p->MinContext->SummFreq += 4;",
          "1080:   if (s[0].Freq > s[-1].Freq)",
          "1081:   {",
          "1082:     SwapStates(&s[0], &s[-1]);",
          "1083:     p->FoundState = --s;",
          "1084:     if (s->Freq > MAX_FREQ)",
          "1085:       Rescale(p);",
          "1086:   }",
          "1087:   NextContext(p);",
          "1088: }",
          "1090: void Ppmd8_Update1_0(CPpmd8 *p)",
          "1091: {",
          "1092:   p->PrevSuccess = (2 * p->FoundState->Freq >= p->MinContext->SummFreq);",
          "1093:   p->RunLength += p->PrevSuccess;",
          "1094:   p->MinContext->SummFreq += 4;",
          "1095:   if ((p->FoundState->Freq += 4) > MAX_FREQ)",
          "1096:     Rescale(p);",
          "1097:   NextContext(p);",
          "1098: }",
          "1100: void Ppmd8_UpdateBin(CPpmd8 *p)",
          "1101: {",
          "1102:   p->FoundState->Freq = (Byte)(p->FoundState->Freq + (p->FoundState->Freq < 196));",
          "1103:   p->PrevSuccess = 1;",
          "1104:   p->RunLength++;",
          "1105:   NextContext(p);",
          "1106: }",
          "1108: void Ppmd8_Update2(CPpmd8 *p)",
          "1109: {",
          "1110:   p->MinContext->SummFreq += 4;",
          "1111:   if ((p->FoundState->Freq += 4) > MAX_FREQ)",
          "1112:     Rescale(p);",
          "1113:   p->RunLength = p->InitRL;",
          "1114:   UpdateModel(p);",
          "1115:   p->MinContext = p->MaxContext;",
          "1116: }",
          "1119: 2010-04-16 : Igor Pavlov : Public domain",
          "1120: This code is based on:",
          "1121:   PPMd var.I (2002): Dmitry Shkarin : Public domain",
          "1124: Bool Ppmd8_RangeDec_Init(CPpmd8 *p)",
          "1125: {",
          "1126:   unsigned i;",
          "1127:   p->Low = 0;",
          "1128:   p->Range = 0xFFFFFFFF;",
          "1129:   p->Code = 0;",
          "1130:   for (i = 0; i < 4; i++)",
          "1131:     p->Code = (p->Code << 8) | p->Stream.In->Read(p->Stream.In);",
          "1132:   return (p->Code < 0xFFFFFFFF);",
          "1133: }",
          "1135: static UInt32 RangeDec_GetThreshold(CPpmd8 *p, UInt32 total)",
          "1136: {",
          "1137:   return p->Code / (p->Range /= total);",
          "1138: }",
          "1140: static void RangeDec_Decode(CPpmd8 *p, UInt32 start, UInt32 size)",
          "1141: {",
          "1142:   start *= p->Range;",
          "1143:   p->Low += start;",
          "1144:   p->Code -= start;",
          "1145:   p->Range *= size;",
          "1147:   while ((p->Low ^ (p->Low + p->Range)) < kTop ||",
          "1148:       (p->Range < kBot && ((p->Range = (0 - p->Low) & (kBot - 1)), 1)))",
          "1149:   {",
          "1150:     p->Code = (p->Code << 8) | p->Stream.In->Read(p->Stream.In);",
          "1151:     p->Range <<= 8;",
          "1152:     p->Low <<= 8;",
          "1153:   }",
          "1154: }",
          "1156: #define MASK(sym) ((signed char *)charMask)[sym]",
          "1158: int Ppmd8_DecodeSymbol(CPpmd8 *p)",
          "1159: {",
          "1160:   size_t charMask[256 / sizeof(size_t)];",
          "1161:   if (p->MinContext->NumStats != 0)",
          "1162:   {",
          "1163:     CPpmd_State *s = Ppmd8_GetStats(p, p->MinContext);",
          "1164:     unsigned i;",
          "1165:     UInt32 count, hiCnt;",
          "1166:     if ((count = RangeDec_GetThreshold(p, p->MinContext->SummFreq)) < (hiCnt = s->Freq))",
          "1167:     {",
          "1168:       Byte symbol;",
          "1169:       RangeDec_Decode(p, 0, s->Freq);",
          "1170:       p->FoundState = s;",
          "1171:       symbol = s->Symbol;",
          "1172:       Ppmd8_Update1_0(p);",
          "1173:       return symbol;",
          "1174:     }",
          "1175:     p->PrevSuccess = 0;",
          "1176:     i = p->MinContext->NumStats;",
          "1177:     do",
          "1178:     {",
          "1179:       if ((hiCnt += (++s)->Freq) > count)",
          "1180:       {",
          "1181:         Byte symbol;",
          "1182:         RangeDec_Decode(p, hiCnt - s->Freq, s->Freq);",
          "1183:         p->FoundState = s;",
          "1184:         symbol = s->Symbol;",
          "1185:         Ppmd8_Update1(p);",
          "1186:         return symbol;",
          "1187:       }",
          "1188:     }",
          "1189:     while (--i);",
          "1190:     if (count >= p->MinContext->SummFreq)",
          "1191:       return -2;",
          "1192:     RangeDec_Decode(p, hiCnt, p->MinContext->SummFreq - hiCnt);",
          "1193:     PPMD_SetAllBitsIn256Bytes(charMask);",
          "1194:     MASK(s->Symbol) = 0;",
          "1195:     i = p->MinContext->NumStats;",
          "1196:     do { MASK((--s)->Symbol) = 0; } while (--i);",
          "1197:   }",
          "1198:   else",
          "1199:   {",
          "1200:     UInt16 *prob = Ppmd8_GetBinSumm(p);",
          "1201:     if (((p->Code / (p->Range >>= 14)) < *prob))",
          "1202:     {",
          "1203:       Byte symbol;",
          "1204:       RangeDec_Decode(p, 0, *prob);",
          "1206:       symbol = (p->FoundState = Ppmd8Context_OneState(p->MinContext))->Symbol;",
          "1207:       Ppmd8_UpdateBin(p);",
          "1208:       return symbol;",
          "1209:     }",
          "1210:     RangeDec_Decode(p, *prob, (1 << 14) - *prob);",
          "1212:     p->InitEsc = PPMD8_kExpEscape[*prob >> 10];",
          "1213:     PPMD_SetAllBitsIn256Bytes(charMask);",
          "1214:     MASK(Ppmd8Context_OneState(p->MinContext)->Symbol) = 0;",
          "1215:     p->PrevSuccess = 0;",
          "1216:   }",
          "1217:   for (;;)",
          "1218:   {",
          "1219:     CPpmd_State *ps[256], *s;",
          "1220:     UInt32 freqSum, count, hiCnt;",
          "1221:     CPpmd_See *see;",
          "1222:     unsigned i, num, numMasked = p->MinContext->NumStats;",
          "1223:     do",
          "1224:     {",
          "1225:       p->OrderFall++;",
          "1226:       if (!p->MinContext->Suffix)",
          "1227:         return -1;",
          "1228:       p->MinContext = Ppmd8_GetContext(p, p->MinContext->Suffix);",
          "1229:     }",
          "1230:     while (p->MinContext->NumStats == numMasked);",
          "1231:     hiCnt = 0;",
          "1232:     s = Ppmd8_GetStats(p, p->MinContext);",
          "1233:     i = 0;",
          "1234:     num = p->MinContext->NumStats - numMasked;",
          "1235:     do",
          "1236:     {",
          "1237:       int k = (int)(MASK(s->Symbol));",
          "1238:       hiCnt += (s->Freq & k);",
          "1239:       ps[i] = s++;",
          "1240:       i -= k;",
          "1241:     }",
          "1242:     while (i != num);",
          "1244:     see = Ppmd8_MakeEscFreq(p, numMasked, &freqSum);",
          "1245:     freqSum += hiCnt;",
          "1246:     count = RangeDec_GetThreshold(p, freqSum);",
          "1248:     if (count < hiCnt)",
          "1249:     {",
          "1250:       Byte symbol;",
          "1251:       CPpmd_State **pps = ps;",
          "1252:       for (hiCnt = 0; (hiCnt += (*pps)->Freq) <= count; pps++);",
          "1253:       s = *pps;",
          "1254:       RangeDec_Decode(p, hiCnt - s->Freq, s->Freq);",
          "1255:       Ppmd_See_Update(see);",
          "1256:       p->FoundState = s;",
          "1257:       symbol = s->Symbol;",
          "1258:       Ppmd8_Update2(p);",
          "1259:       return symbol;",
          "1260:     }",
          "1261:     if (count >= freqSum)",
          "1262:       return -2;",
          "1263:     RangeDec_Decode(p, hiCnt, freqSum - hiCnt);",
          "1264:     see->Summ = (UInt16)(see->Summ + freqSum);",
          "1265:     do { MASK(ps[--i]->Symbol) = 0; } while (i != 0);",
          "1266:   }",
          "1267: }",
          "1270:   NS2Indx",
          "1271:   GlewCount, and Glue method",
          "1272:   BinSum",
          "1273:   See / EscFreq",
          "1274:   CreateSuccessors updates more suffix contexts",
          "1275:   UpdateModel consts.",
          "1276:   PrevSuccess Update",
          "1279: const IPpmd8 __archive_ppmd8_functions =",
          "1280: {",
          "1281:   &Ppmd8_Construct,",
          "1282:   &Ppmd8_Alloc,",
          "1283:   &Ppmd8_Free,",
          "1284:   &Ppmd8_Init,",
          "1285:   &Ppmd8_RangeDec_Init,",
          "1286:   &Ppmd8_DecodeSymbol,",
          "1287: };",
          "",
          "---------------"
        ],
        "libarchive/archive_ppmd8_private.h||libarchive/archive_ppmd8_private.h": [
          "File: libarchive/archive_ppmd8_private.h -> libarchive/archive_ppmd8_private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: 2011-01-27 : Igor Pavlov : Public domain",
          "3: This code is based on:",
          "4:   PPMd var.I (2002): Dmitry Shkarin : Public domain",
          "7: #ifndef __PPMD8_H",
          "8: #define __PPMD8_H",
          "10: #include \"archive_ppmd_private.h\"",
          "12: #define PPMD8_MIN_ORDER 2",
          "13: #define PPMD8_MAX_ORDER 16",
          "15: struct CPpmd8_Context_;",
          "17: typedef",
          "18:   #ifdef PPMD_32BIT",
          "19:     struct CPpmd8_Context_ *",
          "20:   #else",
          "21:     UInt32",
          "22:   #endif",
          "23:   CPpmd8_Context_Ref;",
          "25: #pragma pack(push, 1)",
          "27: typedef struct CPpmd8_Context_",
          "28: {",
          "29:   Byte NumStats;",
          "30:   Byte Flags;",
          "31:   UInt16 SummFreq;",
          "32:   CPpmd_State_Ref Stats;",
          "33:   CPpmd8_Context_Ref Suffix;",
          "34: } CPpmd8_Context;",
          "36: #pragma pack(pop)",
          "38: #define Ppmd8Context_OneState(p) ((CPpmd_State *)&(p)->SummFreq)",
          "41:    code is not compatible with original code for some files compressed",
          "44: enum",
          "45: {",
          "46:   PPMD8_RESTORE_METHOD_RESTART,",
          "47:   PPMD8_RESTORE_METHOD_CUT_OFF",
          "48:   #ifdef PPMD8_FREEZE_SUPPORT",
          "49:   , PPMD8_RESTORE_METHOD_FREEZE",
          "50:   #endif",
          "51: };",
          "53: typedef struct",
          "54: {",
          "55:   CPpmd8_Context *MinContext, *MaxContext;",
          "56:   CPpmd_State *FoundState;",
          "57:   unsigned OrderFall, InitEsc, PrevSuccess, MaxOrder;",
          "60:   UInt32 Size;",
          "61:   UInt32 GlueCount;",
          "62:   Byte *Base, *LoUnit, *HiUnit, *Text, *UnitsStart;",
          "63:   UInt32 AlignOffset;",
          "64:   unsigned RestoreMethod;",
          "67:   UInt32 Range;",
          "68:   UInt32 Code;",
          "69:   UInt32 Low;",
          "70:   union",
          "71:   {",
          "72:     IByteIn *In;",
          "73:     IByteOut *Out;",
          "74:   } Stream;",
          "76:   Byte Indx2Units[PPMD_NUM_INDEXES];",
          "77:   Byte Units2Indx[128];",
          "78:   CPpmd_Void_Ref FreeList[PPMD_NUM_INDEXES];",
          "79:   UInt32 Stamps[PPMD_NUM_INDEXES];",
          "81:   Byte NS2BSIndx[256], NS2Indx[260];",
          "82:   CPpmd_See DummySee, See[24][32];",
          "83:   UInt16 BinSumm[25][64];",
          "84: } CPpmd8;",
          "86: void Ppmd8_Construct(CPpmd8 *p);",
          "87: Bool Ppmd8_Alloc(CPpmd8 *p, UInt32 size);",
          "88: void Ppmd8_Free(CPpmd8 *p);",
          "89: void Ppmd8_Init(CPpmd8 *p, unsigned maxOrder, unsigned restoreMethod);",
          "90: #define Ppmd8_WasAllocated(p) ((p)->Base != NULL)",
          "95: extern const Byte PPMD8_kExpEscape[16];",
          "97: #ifdef PPMD_32BIT",
          "98:   #define Ppmd8_GetPtr(p, ptr) (ptr)",
          "99:   #define Ppmd8_GetContext(p, ptr) (ptr)",
          "100:   #define Ppmd8_GetStats(p, ctx) ((ctx)->Stats)",
          "101: #else",
          "102:   #define Ppmd8_GetPtr(p, offs) ((void *)((p)->Base + (offs)))",
          "103:   #define Ppmd8_GetContext(p, offs) ((CPpmd8_Context *)Ppmd8_GetPtr((p), (offs)))",
          "104:   #define Ppmd8_GetStats(p, ctx) ((CPpmd_State *)Ppmd8_GetPtr((p), ((ctx)->Stats)))",
          "105: #endif",
          "107: void Ppmd8_Update1(CPpmd8 *p);",
          "108: void Ppmd8_Update1_0(CPpmd8 *p);",
          "109: void Ppmd8_Update2(CPpmd8 *p);",
          "110: void Ppmd8_UpdateBin(CPpmd8 *p);",
          "112: #define Ppmd8_GetBinSumm(p) \\",
          "113:     &p->BinSumm[p->NS2Indx[Ppmd8Context_OneState(p->MinContext)->Freq - 1]][ \\",
          "114:     p->NS2BSIndx[Ppmd8_GetContext(p, p->MinContext->Suffix)->NumStats] + \\",
          "115:     p->PrevSuccess + p->MinContext->Flags + ((p->RunLength >> 26) & 0x20)]",
          "117: CPpmd_See *Ppmd8_MakeEscFreq(CPpmd8 *p, unsigned numMasked, UInt32 *scale);",
          "122: Bool Ppmd8_RangeDec_Init(CPpmd8 *p);",
          "123: #define Ppmd8_RangeDec_IsFinishedOK(p) ((p)->Code == 0)",
          "128: #define Ppmd8_RangeEnc_Init(p) { (p)->Low = 0; (p)->Range = 0xFFFFFFFF; }",
          "129: void Ppmd8_RangeEnc_FlushData(CPpmd8 *p);",
          "132: typedef struct",
          "133: {",
          "135:   void (*Ppmd8_Construct)(CPpmd8 *p);",
          "136:   Bool (*Ppmd8_Alloc)(CPpmd8 *p, UInt32 size);",
          "137:   void (*Ppmd8_Free)(CPpmd8 *p);",
          "138:   void (*Ppmd8_Init)(CPpmd8 *p, unsigned max_order, unsigned restore_method);",
          "139:   #define Ppmd7_WasAllocated(p) ((p)->Base != NULL)",
          "142:   int (*Ppmd8_RangeDec_Init)(CPpmd8 *p);",
          "143:   int (*Ppmd8_DecodeSymbol)(CPpmd8 *p);",
          "144: } IPpmd8;",
          "146: extern const IPpmd8 __archive_ppmd8_functions;",
          "148: #endif",
          "",
          "---------------"
        ],
        "libarchive/archive_read_support_format_zip.c||libarchive/archive_read_support_format_zip.c": [
          "File: libarchive/archive_read_support_format_zip.c -> libarchive/archive_read_support_format_zip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: #ifdef HAVE_ZLIB_H",
          "53: #include <zlib.h>",
          "54: #endif",
          "56: #include \"archive.h\"",
          "57: #include \"archive_digest_private.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "55: #ifdef HAVE_BZLIB_H",
          "56: #include <bzlib.h>",
          "57: #endif",
          "58: #ifdef HAVE_LZMA_H",
          "59: #include <lzma.h>",
          "60: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: #include \"archive_private.h\"",
          "64: #include \"archive_rb.h\"",
          "65: #include \"archive_read_private.h\"",
          "67: #ifndef HAVE_ZLIB_H",
          "68: #include \"archive_crc32.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: #include \"archive_ppmd8_private.h\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "165:  char   decompress_init;",
          "166:  char   end_of_entry;",
          "169:  unsigned char   *uncompressed_buffer;",
          "170:  size_t    uncompressed_buffer_size;",
          "171:  z_stream  stream;",
          "172:  char   stream_valid;",
          "173: #endif",
          "175:  struct archive_string_conv *sconv;",
          "176:  struct archive_string_conv *sconv_default;",
          "177:  struct archive_string_conv *sconv_utf8;",
          "",
          "[Removed Lines]",
          "168: #ifdef HAVE_ZLIB_H",
          "",
          "[Added Lines]",
          "178: #ifdef HAVE_ZLIB_H",
          "183: #ifdef HAVE_LZMA_H",
          "184:  lzma_stream  zipx_lzma_stream;",
          "185:  char            zipx_lzma_valid;",
          "186: #endif",
          "188: #ifdef HAVE_BZLIB_H",
          "189:  bz_stream  bzstream;",
          "190:  char            bzstream_valid;",
          "191: #endif",
          "193:  IByteIn   zipx_ppmd_stream;",
          "194:  ssize_t   zipx_ppmd_read_compressed;",
          "195:  CPpmd8   ppmd8;",
          "196:  char   ppmd8_valid;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "223: #define zipmin(a,b) ((a) < (b) ? (a) : (b))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "252: static Byte",
          "253: ppmd_read(void* p) {",
          "255:  struct archive_read *a = ((IByteIn*)p)->a;",
          "256:  struct zip *zip = (struct zip*) a->format->data;",
          "259:  const uint8_t* data = __archive_read_ahead(a, 1, NULL);",
          "260:  __archive_read_consume(a, 1);",
          "263:  ++zip->zipx_ppmd_read_compressed;",
          "266:  return data[0];",
          "267: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1296:  return (ARCHIVE_OK);",
          "1297: }",
          "1299: #ifdef HAVE_ZLIB_H",
          "1300: static int",
          "1301: zip_deflate_init(struct archive_read *a, struct zip *zip)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1345: static int",
          "1346: consume_optional_marker(struct archive_read *a, struct zip *zip)",
          "1347: {",
          "1348:  if (zip->end_of_entry && (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {",
          "1349:   const char *p;",
          "1351:   if (NULL == (p = __archive_read_ahead(a, 24, NULL))) {",
          "1352:    archive_set_error(&a->archive,",
          "1353:        ARCHIVE_ERRNO_FILE_FORMAT,",
          "1354:        \"Truncated ZIP end-of-file record\");",
          "1355:    return (ARCHIVE_FATAL);",
          "1356:   }",
          "1358:   if (p[0] == 'P' && p[1] == 'K' &&",
          "1359:       p[2] == '\\007' && p[3] == '\\010') {",
          "1360:    p += 4;",
          "1361:    zip->unconsumed = 4;",
          "1362:   }",
          "1363:   if (zip->entry->flags & LA_USED_ZIP64) {",
          "1364:    uint64_t compressed, uncompressed;",
          "1365:    zip->entry->crc32 = archive_le32dec(p);",
          "1366:    compressed = archive_le64dec(p + 4);",
          "1367:    uncompressed = archive_le64dec(p + 12);",
          "1368:    if (compressed > INT64_MAX || uncompressed > INT64_MAX) {",
          "1369:     archive_set_error(&a->archive,",
          "1370:         ARCHIVE_ERRNO_FILE_FORMAT,",
          "1371:         \"Overflow of 64-bit file sizes\");",
          "1372:     return ARCHIVE_FAILED;",
          "1373:    }",
          "1374:    zip->entry->compressed_size = compressed;",
          "1375:    zip->entry->uncompressed_size = uncompressed;",
          "1376:    zip->unconsumed += 20;",
          "1377:   } else {",
          "1378:    zip->entry->crc32 = archive_le32dec(p);",
          "1379:    zip->entry->compressed_size = archive_le32dec(p + 4);",
          "1380:    zip->entry->uncompressed_size = archive_le32dec(p + 8);",
          "1381:    zip->unconsumed += 12;",
          "1382:   }",
          "1383:  }",
          "1385:     return (ARCHIVE_OK);",
          "1386: }",
          "1388: #ifdef HAVE_LZMA_H",
          "1389: static int",
          "1390: zipx_xz_init(struct archive_read *a, struct zip *zip)",
          "1391: {",
          "1392:  lzma_ret r;",
          "1394:  if(zip->zipx_lzma_valid) {",
          "1395:   lzma_end(&zip->zipx_lzma_stream);",
          "1396:   zip->zipx_lzma_valid = 0;",
          "1397:  }",
          "1399:  memset(&zip->zipx_lzma_stream, 0, sizeof(zip->zipx_lzma_stream));",
          "1400:  r = lzma_stream_decoder(&zip->zipx_lzma_stream, UINT64_MAX, 0);",
          "1401:  if (r != LZMA_OK) {",
          "1402:   archive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,",
          "1403:       \"xz initialization failed(%d)\",",
          "1404:       r);",
          "1406:   return (ARCHIVE_FAILED);",
          "1407:  }",
          "1409:  zip->zipx_lzma_valid = 1;",
          "1411:  if(zip->uncompressed_buffer)",
          "1412:   free(zip->uncompressed_buffer);",
          "1414:  zip->uncompressed_buffer_size = 256 * 1024;",
          "1415:  zip->uncompressed_buffer =",
          "1416:      (uint8_t*) malloc(zip->uncompressed_buffer_size);",
          "1417:  if (zip->uncompressed_buffer == NULL) {",
          "1418:   archive_set_error(&a->archive, ENOMEM,",
          "1419:       \"No memory for xz decompression\");",
          "1420:       return (ARCHIVE_FATAL);",
          "1421:  }",
          "1423:  zip->decompress_init = 1;",
          "1424:  return (ARCHIVE_OK);",
          "1425: }",
          "1427: static int",
          "1428: zipx_lzma_alone_init(struct archive_read *a, struct zip *zip)",
          "1429: {",
          "1430:  lzma_ret r;",
          "1431:  const uint8_t* p;",
          "1433: #pragma pack(push)",
          "1434: #pragma pack(1)",
          "1435:  struct _alone_header {",
          "1436:      uint8_t bytes[5];",
          "1437:      uint64_t uncompressed_size;",
          "1438:  } alone_header;",
          "1439: #pragma pack(pop)",
          "1448:  memset(&zip->zipx_lzma_stream, 0, sizeof(zip->zipx_lzma_stream));",
          "1449:  r = lzma_alone_decoder(&zip->zipx_lzma_stream, UINT64_MAX);",
          "1450:  if (r != LZMA_OK) {",
          "1451:   archive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,",
          "1452:       \"lzma initialization failed(%d)\", r);",
          "1454:   return (ARCHIVE_FAILED);",
          "1455:  }",
          "1459:  zip->zipx_lzma_valid = 1;",
          "1499:  if((p = __archive_read_ahead(a, 9, NULL)) == NULL) {",
          "1500:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1501:       \"Truncated lzma data\");",
          "1502:   return (ARCHIVE_FATAL);",
          "1503:  }",
          "1505:  if(p[2] != 0x05 || p[3] != 0x00) {",
          "1506:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1507:       \"Invalid lzma data\");",
          "1508:   return (ARCHIVE_FATAL);",
          "1509:  }",
          "1513:  memcpy(&alone_header.bytes[0], p + 4, 5);",
          "1517:  alone_header.uncompressed_size = UINT64_MAX;",
          "1519:  if(!zip->uncompressed_buffer) {",
          "1520:   zip->uncompressed_buffer_size = 256 * 1024;",
          "1521:   zip->uncompressed_buffer =",
          "1522:    (uint8_t*) malloc(zip->uncompressed_buffer_size);",
          "1524:   if (zip->uncompressed_buffer == NULL) {",
          "1525:    archive_set_error(&a->archive, ENOMEM,",
          "1526:        \"No memory for lzma decompression\");",
          "1527:    return (ARCHIVE_FATAL);",
          "1528:   }",
          "1529:  }",
          "1531:  zip->zipx_lzma_stream.next_in = (void*) &alone_header;",
          "1532:  zip->zipx_lzma_stream.avail_in = sizeof(alone_header);",
          "1533:  zip->zipx_lzma_stream.total_in = 0;",
          "1534:  zip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;",
          "1535:  zip->zipx_lzma_stream.avail_out = zip->uncompressed_buffer_size;",
          "1536:  zip->zipx_lzma_stream.total_out = 0;",
          "1540:  r = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);",
          "1541:  if (r != LZMA_OK) {",
          "1542:   archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,",
          "1543:       \"lzma stream initialization error\");",
          "1544:   return ARCHIVE_FATAL;",
          "1545:  }",
          "1548:  __archive_read_consume(a, 9);",
          "1549:  zip->entry_bytes_remaining -= 9;",
          "1550:  zip->entry_compressed_bytes_read += 9;",
          "1552:  zip->decompress_init = 1;",
          "1553:  return (ARCHIVE_OK);",
          "1554: }",
          "1556: static int",
          "1557: zip_read_data_zipx_xz(struct archive_read *a, const void **buff,",
          "1558:  size_t *size, int64_t *offset)",
          "1559: {",
          "1560:  struct zip* zip = (struct zip *)(a->format->data);",
          "1561:  int ret;",
          "1562:  lzma_ret lz_ret;",
          "1563:  const void* compressed_buf;",
          "1564:  ssize_t bytes_avail, in_bytes, to_consume = 0;",
          "1569:  if (!zip->decompress_init) {",
          "1570:   ret = zipx_xz_init(a, zip);",
          "1571:   if (ret != ARCHIVE_OK)",
          "1572:    return (ret);",
          "1573:  }",
          "1575:  compressed_buf = __archive_read_ahead(a, 1, &bytes_avail);",
          "1576:  if (bytes_avail < 0) {",
          "1577:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1578:       \"Truncated xz file body\");",
          "1579:   return (ARCHIVE_FATAL);",
          "1580:  }",
          "1582:  in_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);",
          "1583:  zip->zipx_lzma_stream.next_in = compressed_buf;",
          "1584:  zip->zipx_lzma_stream.avail_in = in_bytes;",
          "1585:  zip->zipx_lzma_stream.total_in = 0;",
          "1586:  zip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;",
          "1587:  zip->zipx_lzma_stream.avail_out = zip->uncompressed_buffer_size;",
          "1588:  zip->zipx_lzma_stream.total_out = 0;",
          "1591:  lz_ret = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);",
          "1592:  switch(lz_ret) {",
          "1593:   case LZMA_DATA_ERROR:",
          "1594:    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
          "1595:        \"xz data error (error %d)\", (int) lz_ret);",
          "1596:    return (ARCHIVE_FATAL);",
          "1598:   case LZMA_NO_CHECK:",
          "1599:   case LZMA_OK:",
          "1600:    break;",
          "1602:   default:",
          "1603:    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
          "1604:        \"xz unknown error %d\", (int) lz_ret);",
          "1605:    return (ARCHIVE_FATAL);",
          "1607:   case LZMA_STREAM_END:",
          "1608:    lzma_end(&zip->zipx_lzma_stream);",
          "1609:    zip->zipx_lzma_valid = 0;",
          "1611:    if((int64_t) zip->zipx_lzma_stream.total_in !=",
          "1612:        zip->entry_bytes_remaining)",
          "1613:    {",
          "1614:     archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
          "1615:         \"xz premature end of stream\");",
          "1616:     return (ARCHIVE_FATAL);",
          "1617:    }",
          "1619:    zip->end_of_entry = 1;",
          "1620:    break;",
          "1621:  }",
          "1623:  to_consume = zip->zipx_lzma_stream.total_in;",
          "1625:  __archive_read_consume(a, to_consume);",
          "1626:  zip->entry_bytes_remaining -= to_consume;",
          "1627:  zip->entry_compressed_bytes_read += to_consume;",
          "1628:  zip->entry_uncompressed_bytes_read += zip->zipx_lzma_stream.total_out;",
          "1633:  ret = consume_optional_marker(a, zip);",
          "1634:  if (ret != ARCHIVE_OK)",
          "1635:   return (ret);",
          "1637:  return (ARCHIVE_OK);",
          "1638: }",
          "1640: static int",
          "1641: zip_read_data_zipx_lzma_alone(struct archive_read *a, const void **buff,",
          "1642:     size_t *size, int64_t *offset)",
          "1643: {",
          "1644:  struct zip* zip = (struct zip *)(a->format->data);",
          "1645:  int ret;",
          "1646:  lzma_ret lz_ret;",
          "1647:  const void* compressed_buf;",
          "1648:  ssize_t bytes_avail, in_bytes, to_consume;",
          "1653:  if (!zip->decompress_init) {",
          "1654:   ret = zipx_lzma_alone_init(a, zip);",
          "1655:   if (ret != ARCHIVE_OK)",
          "1656:    return (ret);",
          "1657:  }",
          "1666:  compressed_buf = __archive_read_ahead(a, 1, &bytes_avail);",
          "1667:  if (bytes_avail < 0) {",
          "1668:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1669:       \"Truncated lzma file body\");",
          "1670:   return (ARCHIVE_FATAL);",
          "1671:  }",
          "1674:  in_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);",
          "1676:  zip->zipx_lzma_stream.next_in = compressed_buf;",
          "1677:  zip->zipx_lzma_stream.avail_in = in_bytes;",
          "1678:  zip->zipx_lzma_stream.total_in = 0;",
          "1679:  zip->zipx_lzma_stream.next_out = zip->uncompressed_buffer;",
          "1680:  zip->zipx_lzma_stream.avail_out =",
          "1683:   zipmin((int64_t) zip->uncompressed_buffer_size,",
          "1684:       zip->entry->uncompressed_size -",
          "1685:       zip->entry_uncompressed_bytes_read);",
          "1686:  zip->zipx_lzma_stream.total_out = 0;",
          "1689:  lz_ret = lzma_code(&zip->zipx_lzma_stream, LZMA_RUN);",
          "1690:  switch(lz_ret) {",
          "1691:   case LZMA_DATA_ERROR:",
          "1692:    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
          "1693:        \"lzma data error (error %d)\", (int) lz_ret);",
          "1694:    return (ARCHIVE_FATAL);",
          "1696:   case LZMA_OK:",
          "1697:    break;",
          "1699:   default:",
          "1700:    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
          "1701:        \"lzma unknown error %d\", (int) lz_ret);",
          "1702:    return (ARCHIVE_FATAL);",
          "1703:  }",
          "1705:  to_consume = zip->zipx_lzma_stream.total_in;",
          "1708:  __archive_read_consume(a, to_consume);",
          "1709:  zip->entry_bytes_remaining -= to_consume;",
          "1710:  zip->entry_compressed_bytes_read += to_consume;",
          "1711:  zip->entry_uncompressed_bytes_read += zip->zipx_lzma_stream.total_out;",
          "1713:  if(zip->entry_bytes_remaining == 0) {",
          "1714:   zip->end_of_entry = 1;",
          "1715:  }",
          "1722:  ret = consume_optional_marker(a, zip);",
          "1723:  if (ret != ARCHIVE_OK)",
          "1724:   return (ret);",
          "1727:  if(zip->end_of_entry) {",
          "1728:   lzma_end(&zip->zipx_lzma_stream);",
          "1729:   zip->zipx_lzma_valid = 0;",
          "1730:  }",
          "1733:  return (ARCHIVE_OK);",
          "1734: }",
          "1737: static int",
          "1738: zipx_ppmd8_init(struct archive_read *a, struct zip *zip)",
          "1739: {",
          "1740:  const void* p;",
          "1741:  uint32_t val;",
          "1742:  uint32_t order;",
          "1743:  uint32_t mem;",
          "1744:  uint32_t restore_method;",
          "1747:  if(zip->ppmd8_valid) {",
          "1748:   __archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);",
          "1749:   zip->ppmd8_valid = 0;",
          "1750:  }",
          "1753:  __archive_ppmd8_functions.Ppmd8_Construct(&zip->ppmd8);",
          "1758:  zip->ppmd8.Stream.In = &zip->zipx_ppmd_stream;",
          "1759:  zip->zipx_ppmd_stream.a = a;",
          "1760:  zip->zipx_ppmd_stream.Read = &ppmd_read;",
          "1763:  zip->zipx_ppmd_read_compressed = 0;",
          "1766:  p = __archive_read_ahead(a, 2, NULL);",
          "1767:  if(!p) {",
          "1768:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1769:       \"Truncated file data in PPMd8 stream\");",
          "1770:   return (ARCHIVE_FATAL);",
          "1771:  }",
          "1772:  __archive_read_consume(a, 2);",
          "1775:  val = archive_le16dec(p);",
          "1776:  order = (val & 15) + 1;",
          "1777:  mem = ((val >> 4) & 0xff) + 1;",
          "1778:  restore_method = (val >> 12);",
          "1780:  if(order < 2 || restore_method > 2) {",
          "1781:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1782:       \"Invalid parameter set in PPMd8 stream (order=%d, \"",
          "1783:       \"restore=%d)\", order, restore_method);",
          "1784:   return (ARCHIVE_FAILED);",
          "1785:  }",
          "1788:  if(!__archive_ppmd8_functions.Ppmd8_Alloc(&zip->ppmd8, mem << 20)) {",
          "1789:   archive_set_error(&a->archive, ENOMEM,",
          "1790:       \"Unable to allocate memory for PPMd8 stream: %d bytes\",",
          "1791:       mem << 20);",
          "1792:   return (ARCHIVE_FATAL);",
          "1793:  }",
          "1797:  zip->ppmd8_valid = 1;",
          "1800:  if(!__archive_ppmd8_functions.Ppmd8_RangeDec_Init(&zip->ppmd8)) {",
          "1801:   archive_set_error(&a->archive, ARCHIVE_ERRNO_PROGRAMMER,",
          "1802:       \"PPMd8 stream range decoder initialization error\");",
          "1803:   return (ARCHIVE_FATAL);",
          "1804:  }",
          "1806:  __archive_ppmd8_functions.Ppmd8_Init(&zip->ppmd8, order, restore_method);",
          "1809:  if(zip->uncompressed_buffer)",
          "1810:   free(zip->uncompressed_buffer);",
          "1812:  zip->uncompressed_buffer_size = 256 * 1024;",
          "1813:  zip->uncompressed_buffer =",
          "1814:      (uint8_t*) malloc(zip->uncompressed_buffer_size);",
          "1816:  if(zip->uncompressed_buffer == NULL) {",
          "1817:   archive_set_error(&a->archive, ENOMEM,",
          "1818:       \"No memory for PPMd8 decompression\");",
          "1819:   return ARCHIVE_FATAL;",
          "1820:  }",
          "1823:  zip->decompress_init = 1;",
          "1829:  zip->entry_compressed_bytes_read += 2 + zip->zipx_ppmd_read_compressed;",
          "1831:  return ARCHIVE_OK;",
          "1832: }",
          "1834: static int",
          "1835: zip_read_data_zipx_ppmd(struct archive_read *a, const void **buff,",
          "1836:     size_t *size, int64_t *offset)",
          "1837: {",
          "1838:  struct zip* zip = (struct zip *)(a->format->data);",
          "1839:  int ret;",
          "1840:  size_t consumed_bytes = 0;",
          "1841:  ssize_t bytes_avail = 0;",
          "1847:  if(!zip->decompress_init) {",
          "1848:   ret = zipx_ppmd8_init(a, zip);",
          "1849:   if(ret != ARCHIVE_OK)",
          "1850:    return ret;",
          "1851:  }",
          "1855:  (void) __archive_read_ahead(a, 1, &bytes_avail);",
          "1856:  if(bytes_avail < 0) {",
          "1857:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1858:       \"Truncated PPMd8 file body\");",
          "1859:   return (ARCHIVE_FATAL);",
          "1860:  }",
          "1864:  zip->zipx_ppmd_read_compressed = 0;",
          "1867:  do {",
          "1868:   int sym = __archive_ppmd8_functions.Ppmd8_DecodeSymbol(&zip->ppmd8);",
          "1869:   if(sym < 0) {",
          "1870:    zip->end_of_entry = 1;",
          "1871:    break;",
          "1872:   }",
          "1874:   zip->uncompressed_buffer[consumed_bytes] = (uint8_t) sym;",
          "1875:   ++consumed_bytes;",
          "1876:  } while(consumed_bytes < zip->uncompressed_buffer_size);",
          "1883:  zip->entry_bytes_remaining -= zip->zipx_ppmd_read_compressed;",
          "1884:  zip->entry_compressed_bytes_read += zip->zipx_ppmd_read_compressed;",
          "1885:  zip->entry_uncompressed_bytes_read += consumed_bytes;",
          "1888:  if(zip->end_of_entry) {",
          "1889:   __archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);",
          "1890:   zip->ppmd8_valid = 0;",
          "1891:  }",
          "1894:  ret = consume_optional_marker(a, zip);",
          "1895:  if (ret != ARCHIVE_OK)",
          "1896:   return ret;",
          "1898:  return ARCHIVE_OK;",
          "1899: }",
          "1901: #ifdef HAVE_BZLIB_H",
          "1902: static int",
          "1903: zipx_bzip2_init(struct archive_read *a, struct zip *zip)",
          "1904: {",
          "1905:  int r;",
          "1909:  if(zip->bzstream_valid) {",
          "1910:   BZ2_bzDecompressEnd(&zip->bzstream);",
          "1911:   zip->bzstream_valid = 0;",
          "1912:  }",
          "1915:  memset(&zip->bzstream, 0, sizeof(bz_stream));",
          "1916:  r = BZ2_bzDecompressInit(&zip->bzstream, 0, 1);",
          "1917:  if(r != BZ_OK) {",
          "1918:   archive_set_error(&(a->archive), ARCHIVE_ERRNO_MISC,",
          "1919:       \"bzip2 initialization failed(%d)\",",
          "1920:       r);",
          "1922:   return ARCHIVE_FAILED;",
          "1923:  }",
          "1926:  zip->bzstream_valid = 1;",
          "1929:  if(zip->uncompressed_buffer)",
          "1930:   free(zip->uncompressed_buffer);",
          "1932:  zip->uncompressed_buffer_size = 256 * 1024;",
          "1933:  zip->uncompressed_buffer =",
          "1934:      (uint8_t*) malloc(zip->uncompressed_buffer_size);",
          "1935:  if (zip->uncompressed_buffer == NULL) {",
          "1936:   archive_set_error(&a->archive, ENOMEM,",
          "1937:       \"No memory for bzip2 decompression\");",
          "1938:       return ARCHIVE_FATAL;",
          "1939:  }",
          "1942:  zip->decompress_init = 1;",
          "1943:  return ARCHIVE_OK;",
          "1944: }",
          "1946: static int",
          "1947: zip_read_data_zipx_bzip2(struct archive_read *a, const void **buff,",
          "1948:     size_t *size, int64_t *offset)",
          "1949: {",
          "1950:  struct zip *zip = (struct zip *)(a->format->data);",
          "1951:  ssize_t bytes_avail = 0, in_bytes, to_consume;",
          "1952:  const void *compressed_buff;",
          "1953:  int r;",
          "1954:  uint64_t total_out;",
          "1959:  if(!zip->decompress_init) {",
          "1960:   r = zipx_bzip2_init(a, zip);",
          "1961:   if(r != ARCHIVE_OK)",
          "1962:    return r;",
          "1963:  }",
          "1966:  compressed_buff = __archive_read_ahead(a, 1, &bytes_avail);",
          "1967:  if(bytes_avail < 0) {",
          "1968:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1969:       \"Truncated bzip2 file body\");",
          "1970:   return (ARCHIVE_FATAL);",
          "1971:  }",
          "1973:  in_bytes = zipmin(zip->entry_bytes_remaining, bytes_avail);",
          "1976:  zip->bzstream.next_in = (char*)(uintptr_t) compressed_buff;",
          "1977:  zip->bzstream.avail_in = in_bytes;",
          "1978:  zip->bzstream.total_in_hi32 = 0;",
          "1979:  zip->bzstream.total_in_lo32 = 0;",
          "1980:  zip->bzstream.next_out = (char*) zip->uncompressed_buffer;",
          "1981:  zip->bzstream.avail_out = zip->uncompressed_buffer_size;",
          "1982:  zip->bzstream.total_out_hi32 = 0;",
          "1983:  zip->bzstream.total_out_lo32 = 0;",
          "1986:  r = BZ2_bzDecompress(&zip->bzstream);",
          "1987:  switch(r) {",
          "1988:   case BZ_STREAM_END:",
          "1991:    switch(BZ2_bzDecompressEnd(&zip->bzstream)) {",
          "1992:     case BZ_OK:",
          "1993:      break;",
          "1994:     default:",
          "1995:      archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
          "1996:          \"Failed to clean up bzip2 decompressor\");",
          "1997:      return ARCHIVE_FATAL;",
          "1998:    }",
          "2000:    zip->end_of_entry = 1;",
          "2001:    break;",
          "2002:   case BZ_OK:",
          "2005:    break;",
          "2006:   default:",
          "2007:    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,",
          "2008:        \"bzip2 decompression failed\");",
          "2009:    return ARCHIVE_FATAL;",
          "2010:  }",
          "2013:  to_consume = zip->bzstream.total_in_lo32;",
          "2014:  __archive_read_consume(a, to_consume);",
          "2016:  total_out = ((uint64_t) zip->bzstream.total_out_hi32 << 32) +",
          "2017:      zip->bzstream.total_out_lo32;",
          "2019:  zip->entry_bytes_remaining -= to_consume;",
          "2020:  zip->entry_compressed_bytes_read += to_consume;",
          "2021:  zip->entry_uncompressed_bytes_read += total_out;",
          "2028:  r = consume_optional_marker(a, zip);",
          "2029:  if(r != ARCHIVE_OK)",
          "2030:   return r;",
          "2032:  return ARCHIVE_OK;",
          "2033: }",
          "2035: #endif",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1470:    return (r);",
          "1471:  }",
          "1510:  return (ARCHIVE_OK);",
          "1511: }",
          "",
          "[Removed Lines]",
          "1473:  if (zip->end_of_entry && (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {",
          "1474:   const char *p;",
          "1476:   if (NULL == (p = __archive_read_ahead(a, 24, NULL))) {",
          "1477:    archive_set_error(&a->archive,",
          "1478:        ARCHIVE_ERRNO_FILE_FORMAT,",
          "1479:        \"Truncated ZIP end-of-file record\");",
          "1480:    return (ARCHIVE_FATAL);",
          "1481:   }",
          "1483:   if (p[0] == 'P' && p[1] == 'K' &&",
          "1484:       p[2] == '\\007' && p[3] == '\\010') {",
          "1485:    p += 4;",
          "1486:    zip->unconsumed = 4;",
          "1487:   }",
          "1488:   if (zip->entry->flags & LA_USED_ZIP64) {",
          "1489:    uint64_t compressed, uncompressed;",
          "1490:    zip->entry->crc32 = archive_le32dec(p);",
          "1491:    compressed = archive_le64dec(p + 4);",
          "1492:    uncompressed = archive_le64dec(p + 12);",
          "1493:    if (compressed > INT64_MAX || uncompressed > INT64_MAX) {",
          "1494:     archive_set_error(&a->archive,",
          "1495:         ARCHIVE_ERRNO_FILE_FORMAT,",
          "1496:         \"Overflow of 64-bit file sizes\");",
          "1497:     return ARCHIVE_FAILED;",
          "1498:    }",
          "1499:    zip->entry->compressed_size = compressed;",
          "1500:    zip->entry->uncompressed_size = uncompressed;",
          "1501:    zip->unconsumed += 20;",
          "1502:   } else {",
          "1503:    zip->entry->crc32 = archive_le32dec(p);",
          "1504:    zip->entry->compressed_size = archive_le32dec(p + 4);",
          "1505:    zip->entry->uncompressed_size = archive_le32dec(p + 8);",
          "1506:    zip->unconsumed += 12;",
          "1507:   }",
          "1508:  }",
          "",
          "[Added Lines]",
          "2211:  r = consume_optional_marker(a, zip);",
          "2212:  if (r != ARCHIVE_OK)",
          "2213:   return (r);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1934:   r =  zip_read_data_none(a, buff, size, offset);",
          "1935:   break;",
          "1936: #ifdef HAVE_ZLIB_H",
          "1938:   r =  zip_read_data_deflate(a, buff, size, offset);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2641: #ifdef HAVE_BZLIB_H",
          "2643:   r = zip_read_data_zipx_bzip2(a, buff, size, offset);",
          "2644:   break;",
          "2645: #endif",
          "2646: #ifdef HAVE_LZMA_H",
          "2648:   r = zip_read_data_zipx_lzma_alone(a, buff, size, offset);",
          "2649:   break;",
          "2651:   r = zip_read_data_zipx_xz(a, buff, size, offset);",
          "2652:   break;",
          "2653: #endif",
          "2656:   r = zip_read_data_zipx_ppmd(a, buff, size, offset);",
          "2657:   break;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1943:   archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
          "1948:   return (ARCHIVE_FAILED);",
          "",
          "[Removed Lines]",
          "1944:       \"Unsupported ZIP compression method (%s)\",",
          "1945:       compression_name(zip->entry->compression));",
          "",
          "[Added Lines]",
          "2667:       \"Unsupported ZIP compression method (%d: %s)\",",
          "2668:       zip->entry->compression, compression_name(zip->entry->compression));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2000:  struct zip_entry *zip_entry, *next_zip_entry;",
          "2002:  zip = (struct zip *)(a->format->data);",
          "2003: #ifdef HAVE_ZLIB_H",
          "2004:  if (zip->stream_valid)",
          "2005:   inflateEnd(&zip->stream);",
          "2007: #endif",
          "2008:  if (zip->zip_entries) {",
          "2009:   zip_entry = zip->zip_entries;",
          "2010:   while (zip_entry != NULL) {",
          "",
          "[Removed Lines]",
          "2006:  free(zip->uncompressed_buffer);",
          "",
          "[Added Lines]",
          "2732: #ifdef HAVA_LZMA_H",
          "2733:     if (zip->zipx_lzma_valid) {",
          "2734:   lzma_end(&zip->zipx_lzma_stream);",
          "2735:  }",
          "2736: #endif",
          "2738: #ifdef HAVE_BZLIB_H",
          "2739:  if (zip->bzstream_valid) {",
          "2740:   BZ2_bzDecompressEnd(&zip->bzstream);",
          "2741:  }",
          "2742: #endif",
          "2744:  if (zip->uncompressed_buffer)",
          "2745:   free(zip->uncompressed_buffer);",
          "2747:  if (zip->ppmd8_valid)",
          "2748:   __archive_ppmd8_functions.Ppmd8_Free(&zip->ppmd8);",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip.c||libarchive/test/test_read_format_zip.c": [
          "File: libarchive/test/test_read_format_zip.c -> libarchive/test/test_read_format_zip.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include \"test.h\"",
          "27: __FBSDID(\"$FreeBSD: head/lib/libarchive/test/test_read_format_zip.c 189482 2009-03-07 03:30:35Z kientzle $\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #define __LIBARCHIVE_BUILD",
          "30: #include <archive_crc32.h>",
          "32: static",
          "33: int extract_one(struct archive* a, struct archive_entry* ae, uint32_t crc)",
          "34: {",
          "35:     la_ssize_t fsize, bytes_read;",
          "36:     uint8_t* buf;",
          "37:     int ret = 1;",
          "38:     uint32_t computed_crc;",
          "40:     fsize = archive_entry_size(ae);",
          "41:     buf = malloc(fsize);",
          "42:     if(buf == NULL)",
          "43:         return 1;",
          "45:     bytes_read = archive_read_data(a, buf, fsize);",
          "46:     if(bytes_read != fsize) {",
          "47:         assertEqualInt(bytes_read, fsize);",
          "48:         goto fn_exit;",
          "49:     }",
          "51:     computed_crc = crc32(0, buf, fsize);",
          "52:     assertEqualInt(computed_crc, crc);",
          "53:     ret = 0;",
          "55: fn_exit:",
          "56:     free(buf);",
          "57:     return ret;",
          "58: }",
          "60: static",
          "61: int extract_one_using_blocks(struct archive* a, int block_size, uint32_t crc)",
          "62: {",
          "63:  uint8_t* buf;",
          "64:  int ret = 1;",
          "65:  uint32_t computed_crc = 0;",
          "66:  la_ssize_t bytes_read;",
          "68:  buf = malloc(block_size);",
          "69:  if(buf == NULL)",
          "70:   return 1;",
          "72:  while(1) {",
          "73:   bytes_read = archive_read_data(a, buf, block_size);",
          "74:   if(bytes_read == ARCHIVE_RETRY)",
          "75:    continue;",
          "76:   else if(bytes_read == 0)",
          "77:    break;",
          "78:   else if(bytes_read < 0) {",
          "81:    assertA(0);",
          "82:    ret = 1;",
          "83:    goto fn_exit;",
          "84:   } else {",
          "86:   }",
          "88:   computed_crc = crc32(computed_crc, buf, bytes_read);",
          "89:  }",
          "91:  assertEqualInt(computed_crc, crc);",
          "92:  ret = 0;",
          "94: fn_exit:",
          "95:  free(buf);",
          "96:  return ret;",
          "97: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "312:  test_extract_length_at_end();",
          "313:  test_symlink();",
          "314: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "386: DEFINE_TEST(test_read_format_zip_ppmd_one_file)",
          "387: {",
          "388:  const char *refname = \"test_read_format_zip_ppmd8.zipx\";",
          "389:  struct archive *a;",
          "390:  struct archive_entry *ae;",
          "392:  extract_reference_file(refname);",
          "394:  assert((a = archive_read_new()) != NULL);",
          "395:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "396:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "397:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "398:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "399:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "400:  assertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));",
          "401:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "402:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "403:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "404: }",
          "406: DEFINE_TEST(test_read_format_zip_ppmd_one_file_blockread)",
          "407: {",
          "408:  const char *refname = \"test_read_format_zip_ppmd8.zipx\";",
          "409:  struct archive *a;",
          "410:  struct archive_entry *ae;",
          "412:  extract_reference_file(refname);",
          "414:  assert((a = archive_read_new()) != NULL);",
          "415:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "416:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "417:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "418:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "419:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "420:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 13, 0xBA8E3BAA));",
          "421:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "422:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "423:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "424: }",
          "426: DEFINE_TEST(test_read_format_zip_ppmd_multi)",
          "427: {",
          "428:  const char *refname = \"test_read_format_zip_ppmd8_multi.zipx\";",
          "429:  struct archive *a;",
          "430:  struct archive_entry *ae;",
          "432:  extract_reference_file(refname);",
          "434:  assert((a = archive_read_new()) != NULL);",
          "435:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "436:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "438:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "439:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "440:  assertEqualString(\"smartd.conf\", archive_entry_pathname(ae));",
          "441:  assertEqualIntA(a, 0, extract_one(a, ae, 0x8DD7379E));",
          "443:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "444:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "445:  assertEqualString(\"ts.conf\", archive_entry_pathname(ae));",
          "446:  assertEqualIntA(a, 0, extract_one(a, ae, 0x7AE59B31));",
          "448:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "449:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "450:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "451:  assertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));",
          "453:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "454:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "455:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "456: }",
          "458: DEFINE_TEST(test_read_format_zip_ppmd_multi_blockread)",
          "459: {",
          "460:  const char *refname = \"test_read_format_zip_ppmd8_multi.zipx\";",
          "461:  struct archive *a;",
          "462:  struct archive_entry *ae;",
          "464:  extract_reference_file(refname);",
          "466:  assert((a = archive_read_new()) != NULL);",
          "467:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "468:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "470:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "471:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "472:  assertEqualString(\"smartd.conf\", archive_entry_pathname(ae));",
          "473:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 12, 0x8DD7379E));",
          "475:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "476:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "477:  assertEqualString(\"ts.conf\", archive_entry_pathname(ae));",
          "478:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 13, 0x7AE59B31));",
          "480:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "481:  assertEqualString(\"ZIP 6.3 (ppmd-1)\", archive_format_name(a));",
          "482:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "483:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 14, 0xBA8E3BAA));",
          "485:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "486:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "487:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "488: }",
          "490: DEFINE_TEST(test_read_format_zip_lzma_one_file)",
          "491: {",
          "492:  const char *refname = \"test_read_format_zip_lzma.zipx\";",
          "493:  struct archive *a;",
          "494:  struct archive_entry *ae;",
          "496:  extract_reference_file(refname);",
          "498:  assert((a = archive_read_new()) != NULL);",
          "499:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "500:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "501:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "502:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "503:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "504:  assertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));",
          "505:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "506:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "507:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "508: }",
          "510: DEFINE_TEST(test_read_format_zip_lzma_one_file_blockread)",
          "511: {",
          "512:  const char *refname = \"test_read_format_zip_lzma.zipx\";",
          "513:  struct archive *a;",
          "514:  struct archive_entry *ae;",
          "516:  extract_reference_file(refname);",
          "518:  assert((a = archive_read_new()) != NULL);",
          "519:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "520:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "521:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "522:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "523:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "524:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 13, 0xBA8E3BAA));",
          "525:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "526:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "527:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "528: }",
          "530: DEFINE_TEST(test_read_format_zip_lzma_multi)",
          "531: {",
          "532:  const char *refname = \"test_read_format_zip_lzma_multi.zipx\";",
          "533:  struct archive *a;",
          "534:  struct archive_entry *ae;",
          "536:  extract_reference_file(refname);",
          "538:  assert((a = archive_read_new()) != NULL);",
          "539:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "540:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "542:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "543:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "544:  assertEqualString(\"smartd.conf\", archive_entry_pathname(ae));",
          "545:  assertEqualIntA(a, 0, extract_one(a, ae, 0x8DD7379E));",
          "547:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "548:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "549:  assertEqualString(\"ts.conf\", archive_entry_pathname(ae));",
          "550:  assertEqualIntA(a, 0, extract_one(a, ae, 0x7AE59B31));",
          "552:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "553:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "554:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "555:  assertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));",
          "557:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "558:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "559:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "560: }",
          "562: DEFINE_TEST(test_read_format_zip_lzma_multi_blockread)",
          "563: {",
          "564:  const char *refname = \"test_read_format_zip_lzma_multi.zipx\";",
          "565:  struct archive *a;",
          "566:  struct archive_entry *ae;",
          "568:  extract_reference_file(refname);",
          "570:  assert((a = archive_read_new()) != NULL);",
          "571:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "572:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "574:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "575:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "576:  assertEqualString(\"smartd.conf\", archive_entry_pathname(ae));",
          "577:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 12, 0x8DD7379E));",
          "579:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "580:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "581:  assertEqualString(\"ts.conf\", archive_entry_pathname(ae));",
          "582:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 13, 0x7AE59B31));",
          "584:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "585:  assertEqualString(\"ZIP 6.3 (lzma)\", archive_format_name(a));",
          "586:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "587:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 14, 0xBA8E3BAA));",
          "589:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "590:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "591:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "592: }",
          "595: DEFINE_TEST(test_read_format_zip_bzip2_one_file)",
          "596: {",
          "597:  const char *refname = \"test_read_format_zip_bzip2.zipx\";",
          "598:  struct archive *a;",
          "599:  struct archive_entry *ae;",
          "601:  extract_reference_file(refname);",
          "603:  assert((a = archive_read_new()) != NULL);",
          "604:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "605:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "606:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "607:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "608:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "609:  assertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));",
          "610:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "611:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "612:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "613: }",
          "615: DEFINE_TEST(test_read_format_zip_bzip2_one_file_blockread)",
          "616: {",
          "617:  const char *refname = \"test_read_format_zip_bzip2.zipx\";",
          "618:  struct archive *a;",
          "619:  struct archive_entry *ae;",
          "621:  extract_reference_file(refname);",
          "623:  assert((a = archive_read_new()) != NULL);",
          "624:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "625:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "626:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "627:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "628:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "629:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 13, 0xBA8E3BAA));",
          "630:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "631:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "632:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "633: }",
          "635: DEFINE_TEST(test_read_format_zip_bzip2_multi)",
          "636: {",
          "637:  const char *refname = \"test_read_format_zip_bzip2_multi.zipx\";",
          "638:  struct archive *a;",
          "639:  struct archive_entry *ae;",
          "641:  extract_reference_file(refname);",
          "643:  assert((a = archive_read_new()) != NULL);",
          "644:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "645:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "647:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "648:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "649:  assertEqualString(\"smartd.conf\", archive_entry_pathname(ae));",
          "650:  assertEqualIntA(a, 0, extract_one(a, ae, 0x8DD7379E));",
          "652:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "653:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "654:  assertEqualString(\"ts.conf\", archive_entry_pathname(ae));",
          "655:  assertEqualIntA(a, 0, extract_one(a, ae, 0x7AE59B31));",
          "657:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "658:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "659:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "660:  assertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));",
          "662:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "663:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "664:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "665: }",
          "667: DEFINE_TEST(test_read_format_zip_bzip2_multi_blockread)",
          "668: {",
          "669:  const char *refname = \"test_read_format_zip_bzip2_multi.zipx\";",
          "670:  struct archive *a;",
          "671:  struct archive_entry *ae;",
          "673:  extract_reference_file(refname);",
          "675:  assert((a = archive_read_new()) != NULL);",
          "676:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "677:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "679:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "680:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "681:  assertEqualString(\"smartd.conf\", archive_entry_pathname(ae));",
          "682:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 12, 0x8DD7379E));",
          "684:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "685:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "686:  assertEqualString(\"ts.conf\", archive_entry_pathname(ae));",
          "687:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 13, 0x7AE59B31));",
          "689:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "690:  assertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));",
          "691:  assertEqualString(\"vimrc\", archive_entry_pathname(ae));",
          "692:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 14, 0xBA8E3BAA));",
          "694:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "695:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "696:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "697: }",
          "699: DEFINE_TEST(test_read_format_zip_xz_multi)",
          "700: {",
          "701:  const char *refname = \"test_read_format_zip_xz_multi.zipx\";",
          "702:  struct archive *a;",
          "703:  struct archive_entry *ae;",
          "705:  extract_reference_file(refname);",
          "707:  assert((a = archive_read_new()) != NULL);",
          "708:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "709:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "711:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "712:  assertEqualString(\"ZIP 2.0 (xz)\", archive_format_name(a));",
          "713:  assertEqualString(\"bash.bashrc\", archive_entry_pathname(ae));",
          "714:  assertEqualIntA(a, 0, extract_one(a, ae, 0xF751B8C9));",
          "716:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "717:  assertEqualString(\"ZIP 2.0 (xz)\", archive_format_name(a));",
          "718:  assertEqualString(\"pacman.conf\", archive_entry_pathname(ae));",
          "719:  assertEqualIntA(a, 0, extract_one(a, ae, 0xB20B7F88));",
          "721:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "722:  assertEqualString(\"ZIP 2.0 (xz)\", archive_format_name(a));",
          "723:  assertEqualString(\"profile\", archive_entry_pathname(ae));",
          "724:  assertEqualIntA(a, 0, extract_one(a, ae, 0x2329F054));",
          "726:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "727:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "728:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "729: }",
          "731: DEFINE_TEST(test_read_format_zip_xz_multi_blockread)",
          "732: {",
          "733:  const char *refname = \"test_read_format_zip_xz_multi.zipx\";",
          "734:  struct archive *a;",
          "735:  struct archive_entry *ae;",
          "737:  extract_reference_file(refname);",
          "739:  assert((a = archive_read_new()) != NULL);",
          "740:  assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));",
          "741:  assertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));",
          "743:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "744:  assertEqualString(\"ZIP 2.0 (xz)\", archive_format_name(a));",
          "745:  assertEqualString(\"bash.bashrc\", archive_entry_pathname(ae));",
          "746:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 12, 0xF751B8C9));",
          "748:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "749:  assertEqualString(\"ZIP 2.0 (xz)\", archive_format_name(a));",
          "750:  assertEqualString(\"pacman.conf\", archive_entry_pathname(ae));",
          "751:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 13, 0xB20B7F88));",
          "753:  assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));",
          "754:  assertEqualString(\"ZIP 2.0 (xz)\", archive_format_name(a));",
          "755:  assertEqualString(\"profile\", archive_entry_pathname(ae));",
          "756:  assertEqualIntA(a, 0, extract_one_using_blocks(a, 14, 0x2329F054));",
          "758:  assertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));",
          "759:  assertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));",
          "760:  assertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));",
          "761: }",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip_bzip2.zipx.uu||libarchive/test/test_read_format_zip_bzip2.zipx.uu": [
          "File: libarchive/test/test_read_format_zip_bzip2.zipx.uu -> libarchive/test/test_read_format_zip_bzip2.zipx.uu",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: begin 644 bzip2.zipx",
          "2: M4$L#!\"X#```,`#TQD4VJ.XZZ-`(``)`#```%````=FEM<F-\"6F@Y,4%9)E-9",
          "3: MYPC!D@``3%^``!!TY^!2(B.7`+__W^%``C$[0!AJ>E,ID:&U-'E`T&C1IIIZ",
          "4: M@8&J>$9\":`IZ@``'J:/2&#```````!@`2FB$T:31D9\"F@8FC0`\\H^:+Y;81F",
          "5: M6OH?UN<?%+%N:%31B%P(0RVO1<SQJ<1.]SV*&^IH14$2>^\\U&IFQOP9(.Z29",
          "6: MPY<T(I:;+;+%&$B@2M1Y72W?=(*2WDS,\\HT0@,EKOQMPK@2EG,=`4I\\L2`([",
          "7: M5,]S''3%_7<)2\">-_:/D\\-$@RAM/2I>(FNV$2K!!&6I\"Q+LXG0-YLG/4-JQE",
          "8: M=%^\\,6JL1H*\"\"1!1W]<O1I!W61YH<W#N(;L:?>4\\/.E))/*(3J)$L1_D*SPD",
          "9: MAZY)I5-#7@)=-5H06@2PP-)YSB5D!.3J63\\EJ*\\X%RMDE]>>,6XG5O@<^@:T",
          "10: MT671Y,.:/=ICJ(=@\\88>!>M^W)$;,QY(*`F*%Q2YZ^%TF$V^/85:V;L\\W53/",
          "11: M?9[-IX&M.O38C\\;C@Q';$E9[,C'?<#304$$9O&4U<2\"$^;O(<O4$WDF@5\")3",
          "12: M:<V%Q;W\"+5#B4$L8:VN_J<@<6I7.ME\"(6?\"\"\"#O+0A5/?<$^+\"0D5-NSRK//",
          "13: M\"%<_?]^4-QYYJ,(+(C;@Y3')J>0X:)KR2UT?=.E*K!>,09(4\\>BYUO&*8;D4",
          "14: MY=51BK5L/;$+WB\"S8Z-?)M+GT/]^;,7$S'N0)))KF]$Z(GL[.L=F*G#!4NC)",
          "15: M4)I$P%W)%.%\"0YPC!DA02P$\"/P,N`P``#``],9%-JCN.NC0\"``\"0`P``!0`D",
          "16: M`````````\"\"`I($`````=FEM<F,*`\"````````$`&```EU'!QI74`8#\"I,S&",
          "17: AE=0!`)=1P<:5U`%02P4&``````$``0!7````5P(`````",
          "18: `",
          "19: end",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip_bzip2_multi.zipx.uu||libarchive/test/test_read_format_zip_bzip2_multi.zipx.uu": [
          "File: libarchive/test/test_read_format_zip_bzip2_multi.zipx.uu -> libarchive/test/test_read_format_zip_bzip2_multi.zipx.uu",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: begin 644 test_read_format_zip_bzip2_multi.zipx",
          "2: M4$L#!\"X#```,`)$XD4V>-]>-Q`H``\"L:```+````<VUA<G1D+F-O;F9\"6F@Y",
          "3: M,4%9)E-9)%%XJ@`\"I5^`4!!,Y__W?^??]+_O__1@\"^U]9V%K:9UFZ$O2A7K'",
          "4: M77-*UK(BDFF*DG<-30(`:9(V@@-2?JFGB)Z(TVIH9J>H'J-##(C0U&1)Y*>F",
          "5: MF4:'E-&0:!H``-``)30B!0]3TFDVD])ZF(::`!Z@`T9#30,)\"0@FBGD*9-IZ",
          "6: MIZGE,F@9``-``&0'`````#````````)$00FC1,(TE/T:,HTVJ?J3/5-#,4]3",
          "7: MU#TADVAYI!A\\^>RT<GE6YYS5N0CDH-W\\T^/EI(<6MF;^`>Q(BD3$3I$[^,/;",
          "8: MLS`?JD6R.G5Z9H!*U7PV]92S^P:OR\\HL0A0_3>$BI8)(/R)[BOOLC2%8YJD(",
          "9: MA.HIB.`H&#CG`1Q7XZ?+[_/^7_[H%_86(A9>\\@A,<LAFVO+>_,XZ=,XL5W'7",
          "10: MHP4M+H9TD.>'-*H@_0+C17D%)P0)RW]IX%[$\"C`LP1H=G0_&E!1\":MS%AMXQ",
          "11: M.;)R8XI%.5\\07+<T%D;E`.H3-$BPXHC9O9][@4+5@?#H]U\\C:>:U'.MSO0WA",
          "12: M_'JHZ5GH`I2IS+,0&673'.$+E#O<4'!QIOJ(=A]MS$!DF&L:[UWD`N@'J&ON",
          "13: MK\"9F:A.4,3W/HWR,FFXKDW<H8/K$-R-J7+-EF/I^Y'\"+NG5CCEZ+0:?KD<+3",
          "14: M`\"I<U;86QQF!%.4@B\\T!6@0*$:O*&.M*[F3XHCB!PDNC=;?B?(XH83B<VJ3,",
          "15: M@\\!-,#RI8$6_#3WTX6'H[6MHG!,&=ACHLI1OX975N=BR)Q(P3\"R]T*(N@FVS",
          "16: MEY4+OL3<O1,KCHTPOX=VJF:N9O,42K4RCC=]+6O5$9[3/FKPO@0(HFMMCG(M",
          "17: MS(TAPC;*E<FMNE0SN-MRQGSE<D$G2%7;F3AT+J@5+!!70<<\",M>_PF?19FN:",
          "18: M8JZ13*&(2TCX35$\",$])GPS2BLBY&_H+ZVL;>UD^#7W[$P11S-:X+;I&4P_2",
          "19: MY2FF=^Q>)*S'RAW&B*<0LART09,I)(!+E@9\";HI&D+G>(HXB:0(%/23%!+S@",
          "20: M:NR/5*I%\\9CK3:PVI<JJC%D=$J4%/&554*(4_,7#440X'\":4,8L63JN=>^LQ",
          "21: MG?A&-RQT6VZ[1QPG2Y9UVU<7W0N_@W]>`:ZV*-IMC1AC'\"5PL)0>9PPF\\/OD",
          "22: MXXHMUZ\\<Z25(;=^+RI'$VR3AK-]]ZYZ5:F:A:K!+N/1,2[.%G;@BE(-[@.1`",
          "23: M22/B@`/?%#.CZ)`,.^U9$,*\\\\.[JTU#1MZ7P>%[^LVOK%3L]),1F)*MOQ5)H",
          "24: MBOICX8!01L:?$[E<$R]4`!$&F!\"N^Z]2A2JH&\\;#/\"R\\MG<`!XM)L2.#%FT@",
          "25: MI$\"[T#%/63SY#K=LX#RSQ*%:^J%L1'HN2F*:.2LQ2X?\"^Y^<9@U@PV(.4E%C",
          "26: MNS^(@N\"/+X8L:9,0T^E]7FZXBP#;&@K7#\\.W[MOUG8-`-,<'O._DJ$2@7*?N",
          "27: M#ZO8W/#Q7.=4KXGTY)7:1_NJ7-3FF\\<6*$<^N]+-!C)W4+U60F$@>:,&%)NE",
          "28: M6U9J0*F\"F4!.R,Y`.G*\"*P_*(P>-<7WV6=I7*E]98+HG\":L0P4Y,?%RY^X[*",
          "29: MDSY./:P;H^X)PU&L=#\"2/IS$=1]X>MB:/!;68(&.EX`-X^\"ZW_F;B,/8(F45",
          "30: M`_?U2XOBQ%&$HQ1YCTEC[_A42U:75Z>4-MI3.*/X>72/`C\"+5Z>0B4C49O3A",
          "31: M'N8'1IOJC95M$\"-@1RC6(E\"P.0[ZZ:;J?E0+#0?LP-6OA,=$^`?$]R<D,R:6",
          "32: M&AO6\\BZF>)HW%K-',>W@ZBCI&CX:1\\Q,YOY&7QLLV_J,<-^S+:AAO&'.A;*V",
          "33: M3AQROQ<,BPB$?,M'!#1QR@/4P#T<S7`8\"66LBP\\H218.SMGB,,\\1%E*\\/0*#",
          "34: MQ_'#_%KC&V`62ZV)_`]OL^PI[Y+3Y'D:D>M5\"<!K'\\`NAZ/[F;AK;1&O\\DA=",
          "35: M0]#/L9O[-T_:F38NS8'QH!;O!*9%KW46U%$P7^K@8H&S*H\\KD-/C1E92^52F",
          "36: M)F1C$@7G-V(O%9#LFI%D%E!$P!\\'1B(0-?))-42@&?](DR&2ZE`T8XW\\%:FB",
          "37: MF*Z1QI590R+_@5,W2:2C-`LE@8*Q&:H8NM`['><*D.$6U5>6NB0:@2#RD1AD",
          "38: M(26E6M&U7;I&M?><,-FD48N@:,:2[U9AD#8DO`F8G`NH2VG:1>/.?`E4V(J^",
          "39: M#5)1$;.G/E?/U7S,RZJL\\[5*#)Y+2^&5-1.L.G9B!:4)5`06C6IFT)6E9!%+",
          "40: M2NC400RE=1Y`*MU7P;V<R<\"<-'X?;X97UARL<KW%NB7,<_XCW;#Y=&J42S?<",
          "41: MCYV65#`1E'MK>=>_94Q:13C>/8$;NI99OUE6QCKTH&-VKEJ+?SICS8UQ>&55",
          "42: MS!AN47T#J*?QEQ6,M2+`@9;Z#.*GM;18!J.<)J@Q;$1#.I*.KS4[,-,#$>-\\",
          "43: M)PO&\"I/*D7`.K'08;Q%TA8:$`G^HT8=;C3N5_4;IF)[F0N$3TDH*Q0-P<[42",
          "44: M,33G53,R)8(253>'`I(/(`C4Y$P=<ZI3<Q9F-%6NDX[@@<-.#$:\"ZHK=Y\"2W",
          "45: ML':Y1S;)()A8F:NQI,Z6<4EA=#ZP7K\"X9XEI=Y1^>LZC+Z#,LC!<`8.=$0&&",
          "46: MHL)>D\\@AT(1A;6.-(URT`6J-@0P%Y020G3VP:QRCZPM[@QB;&[&]I'1L3HG6",
          "47: MHMV_<`9H[#0AJH/K\\46RSPQC,;0Z:L!U8.MI-<Z53:%EM8O;@;NC/2H=';XV",
          "48: M-Z@X,TK*TU++@]A*YJ;NAQ6:N!AY.&J8HED08VR&!22SM(6OK:A%ET7;U&!4",
          "49: MVK6\\B1<8S:RZ$2&P0S%>>!:8E!XF+SMT&6HO@%[!H\\1%0L[N;T&#(0;8].D%",
          "50: M:TK%I(F/ON*[L1CE)4QE?&7UU65^]]5\"5--B;I#AF:-,&WEQ%G1QM<7=I+I-",
          "51: M#%HED2A!O:62V29]+QED;,>@Q1/-)PPU+A@W!SW0+W/DU,0V*IU>![3,1S&>",
          "52: MJH>)MQ]&0><M19/ROSLZEN3#B_9J<R3UR(K`N`N21DVKG\"X%,+[7TX+(=*P1",
          "53: MNJH*&-M^.1NI8I=_4LF'\\I+3TCS]0COXP9&VQ[OL=S+9D5III],[VS7W')'H",
          "54: MV^<R#4%Y)U(&T?;3\\\\!'6[>D=NTHM!=_;/K:@AM+BTH-:,C49$_(R)IC&^1Y",
          "55: M[EI=1!L8O8:A+.F,:91'!%LGX.Y*[9W'8Q>2DN<Q$3J253N=[B+$M5`,`ZAP",
          "56: MX#7D2G.9Q9&85E=C::&FQI#=#:77?K,:7Y2%%\"\"A5E:3S95'D*ZI%['/%R@N",
          "57: MPC:9L35R#[8BW=,#-3+S!A7!WNSP.\"]&D&T:/,C4#0L]K,!G8G9),'9JIE\".",
          "58: MT&JZK3L\";)&ZF\\:#Z+0V:/`NPWLAN#;)1&)7&:):CTRMF6MYRNVWEM,W\"3=O",
          "59: M9OBR&5B:>$BIBQ<M:6NS/6M-<.;%:!:CM-Q:7P+F[9<^U)ITR0:D$:JK$S%:",
          "60: M9V8;[^0=S9:\"MAG>(Y()FJNVR\"%T-;E6?@6^'&XMHR)AAWR$C9972+M#HSN-",
          "61: M);+!>$HVAW9>(FP:U,1BUS180R6S:<$UD99O<NY=G[''Z\\C9AG)U+.%99@9C",
          "62: M;.=-Q(V\\S5@<WPQZ(`71O7+I2%C0S36*BC[[+MW<$P5LFC!]\"[=Y5+L:1H65",
          "63: MAB'!(B:A*;VK2KG,`:&Z<:9\\L7<@'RG1`XHDFZ*SB=DQ(`&LRTFHZ?^+N2*<",
          "64: M*$@2*+Q5`%!+`P0N`P``#`\"(.)%-,9OE>L@!``!4`P``!P```'1S+F-O;F9\"",
          "65: M6F@Y,4%9)E-9[2!3B0``35^``!1(A>=\")0$\"`+__W^!``=V;:TML-3U*>D]I",
          "66: M3`F]4]-(T9`T:&@T8I`F(U'ZIZ@!H`>IZ&`````P``\"4T4R9-3U`$T]$`,0:",
          "67: M9KMEA9T)[OUF#<]_H_:R!%VW(Z5<8GI,92Q$\\@_99'.V;0!9M_JQW(Q83@(>",
          "68: MU(&RK]97O.4,(?<D&2+:<8T+C,9*N8XBL0!($BWA2>9Q\\O->C6^K@,2&/*Q^",
          "69: MQ&&;:95MR[%C&6KSOTJXV':CWZ0#H?FO+]L:K$L-@\\J??66K\"[C''`Q(05A5",
          "70: MAA`H<]68]Z8WD3,92%/*1-[+TH^&FHBX0;F(=TXT`&\\A85\\I0\".^@K=W'6BV",
          "71: M6W7I=FG(:-GP/>J!T.)K9&E&`70E\\*O7<@B\"XC8N],ESUC>J<#0$&LF`$Q\"I",
          "72: MPFSXM(AMXP]!B.B$A)+*A@FQI7N,888C3<<1)$V8APW#69B,^)R&)J6R?!9U",
          "73: MVQ?F1G9TTEH&P\"PV\"U$F)!()!JGQ4/1670D)VLF!P-;I.\\BHY\"F((+!C$AZJ",
          "74: MZ4L(AR$T$'4N]0NK3DSCOKGQ@9(O?$J:V8>5Q'*QHI5Q[SIJ>$D/XNY(IPH2",
          "75: M':0*<2!02P,$+@,```P`/3&13:H[CKHT`@``D`,```4```!V:6UR8T)::#DQ",
          "76: M05DF4UGG\",&2``!,7X``$'3GX%(B(Y<`O__?X4`\",3M`&&IZ4RF1H;4T>4#0",
          "77: M:-&FFGJ!@:IX1D)H\"GJ```>IH](8,```````&`!*:(31I-&1D*:!B:-`#RCY",
          "78: MHOEMA&9:^A_6YQ\\4L6YH5-&(7`A#+:]%S/&IQ$[W/8H;ZFA%01)[[S4:F;&_",
          "79: M!D@[I)G#ES0BEILMLL482*!*U'E=+=]T@I+>3,SRC1\"`R6N_&W\"N!*6<QT!2",
          "80: MGRQ(`CM4SW,<=,7]=PE()XW]H^3PT2#*&T]*EXB:[81*L$$9:D+$NSB=`WFR",
          "81: M<]0VK&5T7[PQ:JQ&@H()$%'?UR]&D'=9'FAS<.XANQI]Y3P\\Z4DD\\HA.HD2Q",
          "82: M'^0K/\"2'KDFE4T->`ETU6A!:!+#`TGG.)60$Y.I9/R6HKS@7*V27UYXQ;B=6",
          "83: M^!SZ!K319='DPYH]VF.HAV#QAAX%ZW[<D1LS'D@H\"8H7%+GKX7283;X]A5K9",
          "84: MNSS=5,]]GLVG@:TZ]-B/QN.#$=L25GLR,=]P--!001F\\935Q((3YN\\AR]03>",
          "85: M2:!4(E-IS87%O<(M4.)02QAK:[^IR!Q:E<ZV4(A9\\(((.\\M\"%4]]P3XL)\"14",
          "86: MV[/*L\\\\(5S]_WY0W'GFHP@LB-N#E,<FIY#AHFO)+71]TZ4JL%XQ!DA3QZ+G6",
          "87: M\\8IAN13EU5&*M6P]L0O>(+-CHU\\FTN?0_WYLQ<3,>Y`DDFN;T3HB>SLZQV8J",
          "88: M<,%2Z,E0FD3`7<D4X4)#G\",&2%!+`0(_`RX#```,`)$XD4V>-]>-Q`H``\"L:",
          "89: M```+`\"0`````````((\"D@0````!S;6%R=&0N8V]N9@H`(````````0`8`(#N",
          "90: M7F'.E=0!`,YV<<Z5U`&`[EYASI74`5!+`0(_`RX#```,`(@XD4TQF^5ZR`$`",
          "91: M`%0#```'`\"0`````````((\"D@>T*``!T<RYC;VYF\"@`@```````!`!@``/`\\",
          "92: M5\\Z5U`$`SG9QSI74`0#P/%?.E=0!4$L!`C\\#+@,```P`/3&13:H[CKHT`@``",
          "93: MD`,```4`)``````````@@*2!V@P``'9I;7)C\"@`@```````!`!@``)=1P<:5",
          "94: HU`&`0`0-QY74`0`TN_O&E=0!4$L%!@`````#``,`#0$``#$/````````",
          "95: `",
          "96: end",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip_lzma.zipx.uu||libarchive/test/test_read_format_zip_lzma.zipx.uu": [
          "File: libarchive/test/test_read_format_zip_lzma.zipx.uu -> libarchive/test/test_read_format_zip_lzma.zipx.uu",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: begin 644 lzma.zipx",
          "2: M4$L#!#\\#```.`#TQD4VJ.XZZ.0(``)`#```%````=FEM<F,0`@4`70`0````",
          "3: M$0@$J,)\\D;(#4L%<^$P5TO^CM0KI0HWG08B&_].4<,CJ\")TW/L>)82Q1PWAL",
          "4: M+U`,N0L_$]^&650C/X$D6#4QFD$\\A/\"_![4!O/5O/!KH`WCQ*4?T2*]4P#/D",
          "5: M0'9I?EZG=N69Z0V;H0I=C<!C<J6O^834W097PY1$%=-++.YUA'!>P*$?\".I\\",
          "6: MGMG/80.A'^W>R4J'S/CZ%P`8`>F=R>R&R$2T@EM#X)\"OQH1?A7,`:4IU9WV!",
          "7: M#2W*DXT',;.4YIN4A:-X)O=IREL201ZSOC=YSAU[C4-::/YV8\\)%\"L17+>VC",
          "8: M%/'B]ZCQN$2(Q*9*\\KJZ`Y131`]5C&G';@1S-QES_RZF!2OX45@58+??ES%(",
          "9: MUJ<(\\`11M$NO)HK#/MK-9RT\"15.2I:IZN8<TJR>VTM1_?$G\\L#BH67]$S%[4",
          "10: M%C-$\\Q<+./&HV](4,7)OL-@C^M0F\"2O!0N$OHOW54H87^QLBQVH*D%A<#SI%",
          "11: M/#+-5U(W';:KC)RE>0Y^5YI!RECQNR\"R4.UW9IR!@:B!UB8?_D5$FT8YCJHJ",
          "12: M2[2\"-&-_D2BJ6#XK[6G=%K\"%;'^-+0]FHCY4ER#`^<I-M<!\"D:-0H@);U\"P\"",
          "13: MPYX+4#8!&$7\\M.+%%MZ:KQ2GX0<]$\"P7F^HT)J5JM<$VO9/D[#7KZ\\'FITL/",
          "14: MYIF\"=GO+-L?F[8QS4KC7+=A)1`\")V<.8DX629Q;;Y4XA\\M-%O&MWC)^)`NO<",
          "15: M.J6(5V2UY9\"I(C*QKA[Z#)-#XU!+`0(_`S\\#```.`#TQD4VJ.XZZ.0(``)`#",
          "16: M```%`\"0`````````((\"D@0````!V:6UR8PH`(````````0`8``\"74<'&E=0!",
          "17: F`)=1P<:5U`$`EU'!QI74`5!+!08``````0`!`%<```!<`@``````",
          "18: `",
          "19: end",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip_lzma_multi.zipx.uu||libarchive/test/test_read_format_zip_lzma_multi.zipx.uu": [
          "File: libarchive/test/test_read_format_zip_lzma_multi.zipx.uu -> libarchive/test/test_read_format_zip_lzma_multi.zipx.uu",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: begin 644 test_read_format_zip_lzma_multi.zipx",
          "2: M4$L#!#\\#```.`)$XD4V>-]>-A`H``\"L:```+````<VUA<G1D+F-O;F80`@4`",
          "3: M70`@````$8@&YWH`1\\\"K>?C+)VT(T,`U9;I1/'N)!6C.3M-O9LO]H<^=OZF\\",
          "4: MXD\\QEZIMP!JM4)W+(F]%N;U#&+F]WZ%S9>>]&^75:X)0Q-5>)IRT/%INC887",
          "5: ML0UF,PS8J@3;WGH95EW4\\KBH,6ZK9,'![3$-(WL/C<S3&K[A1C?*`W/KQ4&Q",
          "6: M`/BGQ$#SJ^?;Z_7,NJ_(<YJKYEW5LH4:QPH.Z]G1VW_M3E2QS5S'\\6S@-/7M",
          "7: M9+&F/N+H[TX:GRGI</0(-B-?I7II0M#&)*LQO[%N?0,S48\\!,6C%\"FGSL(59",
          "8: MPVH.\\D`%['MI;`8-TPQ<'NX'K:\"0+`MQCQ)B*FT/.17CT@8%^,I/-[K?`GGD",
          "9: M\\2YAO1K`&COVK><[0.6%L9@]0;]_>&[A'#Q^##`6+*PM@YT+]E[B9<QN2EY>",
          "10: M;QK38:)CO+S]4X2KF'=)BVO-GM+_#]PB0'*J89+$Q11IG\\\\+84M](58^RW.E",
          "11: MGM3S6RH]#73P.KV0V,2=,/A!;G>2Y4R!!.4(0U+D<.'5V*%./ZZYD\")=W4*4",
          "12: M\\SL\"IUJLN])WM`-&4L&!9&U_-1%%SPU0N4*.^L5&33\"A5MZ;@8F+I^D7JB'K",
          "13: ME&,P>\"UI]NT;ZX`<E]/3;Z;:;KU;K(9,W7@41O,3:LQJH%H%RXZ.<A,Y\\=Q;",
          "14: M`]D>UU->]V$?<H!@ZNFP0M6BYMPO95IJLC48\"DOTCXD/#?VW%LVZD2SSZ7FN",
          "15: M'KLU!HVB+H7FJ)Z@GPA7L\"R'[&^62*7E6S:TJ[XYM+U?YR1K21?P]5TN],0/",
          "16: MV05M[H@C9&OY+CA3(2G0HZD@0M2`\"O;9&ORU2_2D#8T`3=,>KZV(DX&-6L>?",
          "17: ME,(J<;DNA6/2.<9$>?-P]_!S8L3/2P@[C'H$FOA$WUOB>;X$)E7;K+7#X9M(",
          "18: MM+H^AK#CML0LX<B:.L9A!G3PTXL5UK?O<K5?S00^\"%V;EC>TO#P#I)J_5\"@O",
          "19: MMGH9+OXD^P7AG@<%QGH<>FIWE]/>L)6Q2Q\\CC=[?TCG262\"1EO)'_W_C_K4<",
          "20: M8.7YNR\"3\\9WTQ\"0-!>^,M>WT.Y0A&3AK.4/YN5EW]\"&HQ1=8Q-NHQABVH7$%",
          "21: M24Q:J/<8%F1EI)-!HND&FP_;]E,JI$*AGE&]Y#FJ5R6<(UM;;>U?KU@OQ,M_",
          "22: MI/+:;0^0'8JA\"==H5/;]Y10P&PS,1_M+D1I>`%>_Y\\&F[_R/##784#0AQ1!O",
          "23: M'8>IBY?;&;(VAOI$+Z[VMI>]WC!['W$&Z5/D+\"6[\"[[.<DH&[&K^*\"`/UB[Z",
          "24: M2Q?D`J)9WKDL?`4\\\\V0;#,28BU'V+#=0IGN6YS1Y9,V,<-2!(-L@Z20XL8I:",
          "25: M5#\"QC1CFF*\"!].U\\TX1;$IL?#Y<\\`1C*%*`XW?^@>[P!/?9C/;CD66^J/OC)",
          "26: MO0JXP'Y6]PGW8N@X(#-XXWMP\"A%E$A8L+X>QIC[0P,UT0A!IYQ/#+>E60KX/",
          "27: M2JC'F-Z@_,-/$7+F5F$1\\#^\"CTSY;H2EAE,/8>F$^'5H!M2@D?2O@+NJ2&-O",
          "28: M6IV-[<6F-JG0(,W-YJ%PJ<7T.F\")'/+F_`F6B-<MX=E68$!XW'W(RG>HG436",
          "29: MJM-VK0?>9*R?K#]OHC90!]BCG'^D&%!JZ2T_&[RWV?0Z?T:#_\\B`?:MRC$D5",
          "30: M1Z.)!/;3/=GT*T;DC/XLR;7S%VEP+U-M)-*V,1?M<377S9-`J]S4[OI4SR>V",
          "31: M_?_H2WWH>\\@*$V@`LZO?-<BM\\X$'4(L'MF_HV4RT1V'^V>'Z[4_4\"T2R@=%!",
          "32: M!\\1]:4M((1B=ATAJ)23HE7>]=,7I#SK5'2OUZLX0LX*_67!+6S:*0UL)^GS6",
          "33: MM;$2!(-TY%4ME1>*'M)S'[0JP^&J%<A'CQ?7FI>\"-&A[C1YE;1:X_4Y&K9*2",
          "34: M'14NC*]O(JXNLX#M_(LDE6$G<0,+V/;44]-*^S%7G*.\\$W&>2=9,EYB)/@XK",
          "35: MX+E4?>NIP=*X]Z>3T,V?!\"5:/M@<Y?5&/FI$@I@$N)0*3];_\\;[7)(:*+#2,",
          "36: M$JTT&;V1H(;O<>X-H%DZEV,*9WIK;T_C18UC5$%^Z5PY8;USNB?S]`D-K2V2",
          "37: M-C#0-45C'YFF>#*$9JZ!$>%0;=VQ@LGY\"J<.C.10\"1'</GIK=$9`=+K0L,5<",
          "38: M/])*:+OWS(:V1=R\"?*)9&DJ;KZ/0ZI0L8,^</;B?N`=1UB<\"P1!T-'$3:D-%",
          "39: M8\\K1LH+E![6M]42AXTZ]FR@_6W0Y*@?[L(<\\D-<C[(//PKW-#\"'].EG9-=!9",
          "40: M'B9)\"486TDIB/J5RT`,JO'_SX1LJI@H^47%.'QJ/KU`P5K<C!A3],-2995TS",
          "41: M-5B#!(:B;,]CXTQ_ER3(3>JL^B(VXPNK^]Q97E\\`HX0MG2)F=>38R,IFGK\\R",
          "42: MVH!.V3_)_D,II8A=SL;X1!2D9E67=.$P+_D6&'X^1;4%:`ERV>!,''7<#=NE",
          "43: MP')[\\,A89G35\\;ZN:IIY5DDSB$(8D$[G>7-L!(+(-7=LQ0Q3=S`L-)R9YT;S",
          "44: M;%ZYVD%6)M=I]*QS>!3='\"SB'E/4>J#EQ.&]0*U<?2AYA#J0V*IJ#AC@C./2",
          "45: M542_X#'@J3M.%(D.\\<Q/^[S\\^[K8P\\I@1(RM[%G$O='.Q#'@6.:]E-P6$<9`",
          "46: M6A_HT;>0H/Y1%DM].)E/UFD0?Q)B;_;;)-K_]6Z<)D_>^[=?49%4D4B@REC`",
          "47: M,_KU,KX-N,44CL/:*^D>7X(;6_1&C;<;&`K3+4NY[=4%K2K:U\"Q%T9)',7,\"",
          "48: M+PC``PBBDVNY9V-LN'V')B4@4;OH(\\/M%UBX$S.\"4_!;&=9W\\L`!2O\\!ANM5",
          "49: M8<J4RY>+\"\"#5J&/M[2;M?47WN=0[4C*$<!KL:]JI#:F(GID#\"X3/_+OW4^9$",
          "50: MH(D!M_S%*9ME+?QP:[JJ)<;$_/.0R`B9\\^)8##D)RWG\"SP>7D#QB&`!*@5_0",
          "51: M9(5SZ7,Q\"N?0W!\\0WGQF,0JKH[G-(<6^PMJZV&VHQIT?VKJ^7^!EW?)`EC`$",
          "52: M0%,=?X0ME@T_&5UXJIJ9)5(<[=W]M#Y.$.96:_T8WM/H+\"T_Q;QZN\"`5DC&'",
          "53: M.+(^\")0XO=#&#@KVL2R9+.#F)P02=`6PT[21&>T*Q3Y2WVL><:PHB)R?*'+3",
          "54: M+,OK(7PNXHXMVFT<GB/X]4Z(@V!G@I*W2+?/E8B$.YQWJ::$&5/A\"L1:8E%K",
          "55: MB=/,3Y3G]Y=64JWA\"@J:$P16J+IAUZFU7R^QK;H&;^D;!``-$E-)!6#@YQ#\"",
          "56: M[4,OT;*U7IE$\\KI[&:W.&KS7ZEO@1/GQZ\\3O-'FX<<!+Z2>\"!)??8!H^I,&V",
          "57: M8BOE(Z/VYY(5WLSG$.+8$;.A>]+PVB`WV,9M@YL='Q_<%2STU?_IG.I17G^L",
          "58: M>#-=')K6T<!)<XY!]\\5&A$\"^\\9^X:W^2@`!L:56ZV^TU.)Y$<1%OM2BUNZ./",
          "59: M&YD1MAR0^RP*&R%@\"21'W-^R\\=D,\\1JM63J<>?C[^&,7Z)0!B[2-)2:&?*5,",
          "60: M,;&-HI_/O(/V\"4-:_E>0Z)=C=1/9HQJO$R:(&H@4RP\"3%T[BOBZ`3_2>)K49",
          "61: M\\ZL-26)MQ\\%(>T0S5A4>EUCU[),JI\"_/9<5)*6X\\97`N:8YSR0%)@*#_'9'?",
          "62: M/E=RFK\"L&(#RS$S_0[?/!DW.`\\FH$M\\#\"JSQ@*&C*W\\`4$L#!#\\#```.`(@X",
          "63: MD4TQF^5ZO0$``%0#```'````=',N8V]N9A`\"!0!=`\"`````1B`2H,L'S88)4",
          "64: M*WW.8!PX^&C9J^P?<4.RSJ^WF7L-W#+OB4@(A-83?&.PVF@$.:VM<4\\8K(_6",
          "65: M`CRI/@MR:,)C8$&U*MZ&#04KA\\W'KCI%E2GDYYE/SB'*\\S@5]NO,ZBF!;HY@",
          "66: M3Q=F\"]@P02:6^LC>JT$T7BB(.:*G`I.?%/53CC#4I0N_ARFXFG`DZSI*$)UM",
          "67: M1^X:IZ^^)T*5E,C6L<,L%=ASF-1:0CP6*FX_;?<K)^Q*:<'E!WV3Y^)QW7=\"",
          "68: M/.)?WNY-<(\"[VKFR$BQ*_6D4][NEB\\IZ<[_,,`1C%(([BG)4G[]C,^8$W5:S",
          "69: M!X8MX+YUOE1,?OV<7IV(TJY<0RPDRI%4`^%8]HL^H?>R;<M-IR(=C:[/JFI\\",
          "70: M@1WIP=G)@F5A::X3B@1A;CYD=PUCB*'VM^R:X2:XWH8&\"Y\"ZB-A`SBC*D4SN",
          "71: M3DAH,0A!PJ\\ZHL?#PB)4OI\"FOD^Y$@I+T0N$05U+3K3,)DW%,#3SCA:7=D#^",
          "72: M&^`PD\\!WF#VEY5I;2G@*ZN8XPLL!)AC#&5GR&:MW:!`3\"^JARM%?H&>#]C:/",
          "73: M)C@@M]\\FLU4*%H^>8VW4@@%D0U!02P,$/P,```X`/3&13:H[CKHY`@``D`,`",
          "74: M``4```!V:6UR8Q`\"!0!=`\"`````1\"`2HPGR1L@-2P5SX3!72_Z.U\"NE\"C>=!",
          "75: MB(;_TY1PR.H(G3<^QXEA+%'#>&PO4`RY\"S\\3WX995\",_@218-3&:03R$\\+\\'",
          "76: MM0&\\]6\\\\&N@#>/$I1_1(KU3`,^1`=FE^7J=VY9GI#9NA\"EV-P&-RI:_YA-3=",
          "77: M!E?#E$05TTLL[G6$<%[`H1\\(ZGR>V<]A`Z$?[=[)2H?,^/H7`!@!Z9W)[(;(",
          "78: M1+2\"6T/@D*_&A%^%<P!I2G5G?8$-+<J3C0<QLY3FFY2%HW@F]VG*6Q)!'K.^",
          "79: M-WG.'7N-0UIH_G9CPD4*Q%<M[:,4\\>+WJ/&X1(C$IDKRNKH#E%-$#U6,:<=N",
          "80: M!',W&7/_+J8%*_A16!5@M]^7,4C6IPCP!%&T2Z\\FBL,^VLUG+0)%4Y*EJGJY",
          "81: MAS2K)[;2U']\\2?RP.*A9?T3,7M06,T3S%PLX\\:C;TA0Q<F^PV\"/ZU\"8)*\\%\"",
          "82: MX2^B_=52AA?[&R+':@J06%P/.D4\\,LU74C<=MJN,G*5Y#GY7FD'*6/&[(+)0",
          "83: M[7=FG(&!J('6)A_^142;1CF.JBI+M((T8W^1**I8/BOM:=T6L(5L?XTM#V:B",
          "84: M/E27(,#YRDVUP$*1HU\"B`EO4+`+#G@M0-@$81?RTXL46WIJO%*?A!ST0+!>;",
          "85: MZC0FI6JUP3:]D^3L->OKP>:G2P_FF8)V>\\LVQ^;MC'-2N-<MV$E$`(G9PYB3",
          "86: MA9)G%MOE3B'RTT6\\:W>,GXD\"Z]PZI8A79+7ED*DB,K&N'OH,DT/C4$L!`C\\#",
          "87: M/P,```X`D3B139XWUXV$\"@``*QH```L`)``````````@@*2!`````'-M87)T",
          "88: M9\"YC;VYF\"@`@```````!`!@`@.Y>8<Z5U`&`[EYASI74`8#N7F'.E=0!4$L!",
          "89: M`C\\#/P,```X`B#B133&;Y7J]`0``5`,```<`)``````````@@*2!K0H``'1S",
          "90: M+F-O;F8*`\"````````$`&```\\#Q7SI74`0#P/%?.E=0!`/`\\5\\Z5U`%02P$\"",
          "91: M/P,_`P``#@`],9%-JCN.NCD\"``\"0`P``!0`D`````````\"\"`I(&/#```=FEM",
          "92: M<F,*`\"````````$`&```EU'!QI74`8!`!`W'E=0!`#2[^\\:5U`%02P4&````",
          "93: /``,``P`-`0``ZPX`````",
          "94: `",
          "95: end",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip_ppmd8.zipx.uu||libarchive/test/test_read_format_zip_ppmd8.zipx.uu": [
          "File: libarchive/test/test_read_format_zip_ppmd8.zipx.uu -> libarchive/test/test_read_format_zip_ppmd8.zipx.uu",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: begin 644 ppmd8.zipx",
          "2: M4$L#!#\\#``!B`#TQD4VJ.XZZV`$``)`#```%````=FEM<F,'`\"']JO\"&\\1[R",
          "3: M;;G)@`(8>EJ>3<8@F_*<(\\B>K]4_(WC8#)`_QSG+`7`B&_11VIJ)@#(<W.9L",
          "4: M>K)_I8R^=`VUO2_S,1C=1CAU>-*`]CC+&6Q;EE'#CG-W=^[,F,+UR-TE(9,G",
          "5: M1_&$NYD`,5WY5QX7@%5XX-*7+7&#W'1#XF+\"?6*U!H=B063.]NTA`1+&\\J(K",
          "6: M&U]D<Z8#:-^E0@IRO9J$W&\\^A>E8$ZYUU'UT\\$!88I,6+(M/\"=_+3@V5H+24",
          "7: MBA0>^0?[W07K\"B%SQ&OA-R)S9W>DH,<4##E@?5YF:%K<JGI_YMJ^QT4/IK3'",
          "8: MME]>$?5U@W[IVG+2#8FC4'GT3-$L%_N,B$^)UY1GAD=.Z(HI#3[T\"979&<`+",
          "9: M`S]9G+PI';5\"==`18UE,>N\"?>\"_C\"MSHX<[!&8$+A6U_7][TK*6.^\\-O-UK!",
          "10: M`)>[*.D1:1H!I,?PEIPW,NQ5CCX2NCY+%UH\"T5X!O$&=6+X#\"()33:]FPF:F",
          "11: ME-O)\\652#KD$^ZFBJ7K`55]R/A\"OA\"T7\\R6K%B(2&6*/H0>*-:@<P:\\X15#O",
          "12: M7`.(BCE?O\\0!1%K[A;:`MWNF3\\/K9SJ28+D-Z2I92^$J-BWY6\";ANPDO&M><",
          "13: MJ2V9^KJSL+P4A&$`4$L!`C\\#/P,``&(`/3&13:H[CKK8`0``D`,```4`)```",
          "14: M```````@@*2!`````'9I;7)C\"@`@```````!`!@``)=1P<:5U`&`PJ3,QI74",
          "15: ?`0\"74<'&E=0!4$L%!@`````!``$`5P```/L!````````",
          "16: `",
          "17: end",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip_ppmd8_multi.zipx.uu||libarchive/test/test_read_format_zip_ppmd8_multi.zipx.uu": [
          "File: libarchive/test/test_read_format_zip_ppmd8_multi.zipx.uu -> libarchive/test/test_read_format_zip_ppmd8_multi.zipx.uu",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: begin 644 test_read_format_zip_ppmd8_multi.zipx",
          "2: M4$L#!#\\#``!B`)$XD4V>-]>-.0D``\"L:```+````<VUA<G1D+F-O;F8'`\"+\\",
          "3: MO.+63+[=I+F0!)GF1VJ,J;4U\"`+-]H\\Q#[5$#:5W]29`:.D\\EI:7BM#X2\\84",
          "4: MDE)J.5>X%[[99#N5_N2Y@T-?\"T%*8O@,-K>QSOR>-).,0-Q:=7)+:*Z&:B9'",
          "5: M-YXDKOWK\"T?\"(.;F$3'A>TW+.W#W%Y0`:_5XI+35&4_L<0>95Q!XP,\\T=VCM",
          "6: MZB%S4G,4ED*-4T#5Y'BUCMS!0Z)0*50U=EQWM_F]2)<8#VF(432?^.!'O`I/",
          "7: MLP!A8AN1>8;MQ:S?/4-$K07X@[\"K?T]0<=84:OJ]Y$.D)3MNMK`U.(ORV3M&",
          "8: MV`2EDVHT&D'F-=\\,_\"^;UGWW!=,KJI4^NZAF72$S=N.*PW!#ZJ?KQ0;$7E!]",
          "9: MFC,:ST/]Y(,:K3SK7,%&A_%1`($9H@/\\G.RN$J7BA?C\\P\"[U&[8MITK*`U5E",
          "10: MVH'&CJ8?%1+H-H0=B*8]_(F;;/P`371(@?QN2T<4C52L;%S-XV),E4-V05&I",
          "11: MA.V?U+HM63;JH=1]LJ_E\"@JM?QH\\6#NQ7I\\I*%-!)LWB?U):O^--2R=1C):^",
          "12: M^@GFC0GETH%>LXD8_D*J'KS5[/M5+89M;6@3?]I.`M=;(S7*1?(?.9G!`S26",
          "13: M([JDK/(RCM%WYC`>G*L7:NJ!5TS[7<CU3:8J00'UVNP^80ML:5-$)@YGVB]V",
          "14: MRCR-N\\+'6U?T;,];2KLQJK05&CW>MI^E[4/\\RU9$&1XJ5#V;<'F^AX^R@P7<",
          "15: M/2?UB;-2+I11]^X;,J\\:,'^R=&8\"@[EI0$J:\":*LQ-F(IOSXC?1W>/;?4$P*",
          "16: M;=V\"OEY@<N7-M&<4#[>S\\%3'&F-^K0FME.]%1DTO*OP8.:M('3W)\\S\"1.@8#",
          "17: M6Y1&@L+#!YVL]8.,[UP/\\HMAR1\"O!M/2?DY-8[N'P[T&2J7-V5%=XWMRQ,EM",
          "18: M7TL^99!FXY0+B1^7K36\"#!85\"WXE,WFEU=B!+GX2$D<)MW>&A,8A9RPL]CR(",
          "19: M!=1JX99-:5D;PM@S4(>?<OGI*B\\\"Y0\\$Z?+-^5A2D>BKTFAQ>\"%9\\Q^Y\\6T\\",
          "20: MTS\"*[M.TW7AE:#\\(:M_JLJ#*-9-O,UW\\T:PVW8G01OR!B59P=[:XNH0<C21F",
          "21: M^#W^ZH9HB=LH)[+R]HC:HC(7GUO2YL]P^!VT?*^WF0VT2:4W-@W[3&)7]3B=",
          "22: M(S`169(MJ\"A4\\AUA:?Z22\".6\">Y=OC9`KJ_%.>^)RW-,G^%%(U9HC957G/\\@",
          "23: MW1\\J*,JLX*CF*,-!'^O*E7=V#S8_#G`9YQ)#%,AJ8\"-4B,OR8RW4@L)8F$JB",
          "24: M.3QD;;M_L<:*T3B>8\\OECY@*'6?[2VYXB3B!`<:65*HB/.^@;]\\`IE<HRA&2",
          "25: MY[*2&*\\%-#I).D+(^GQEE#E-F`8`X0#[ADT>)<D?R$&7^?/$\"/0,Q_%FSX==",
          "26: M\"9!Q9!-0>HTIG=_X:*3A'#M\\P0L*]^ZFWC\\UL`O;WL@#?\"!(_]OZ4=B<\\QL/",
          "27: MWD%/TL5<Q77`U;^:R@9J2]QL&U3HQ7B4]3:>[P\\,^_3G\\]WD-Q`?XU]K5LFW",
          "28: MI6J$G\\=W(Q+2_U&THGA'_6)`\"WK=X74-OD_B%WJU+JH/A\"K#JQ@)A<`>A6[H",
          "29: MC2A>S7]ZV/H?/1KV&OR8B]IS\\>Y:\\5;B-:+E^V`:5_O[+(!,6LW0&[5(F4UH",
          "30: MKM;R]_V\\?PI6I+\"7M1H%E':WL<1#J\"O<P+?ZX&A,*\";+5(?J&-:@61*&H;B.",
          "31: M9B4X%W]`K]$KZPB]0A*A;G\\=7?CYO>`>]S*UKS02ME,S7]X66@[B`_#?H$^)",
          "32: MT&07IY[)18RK+`@#?UXT=8B=XC$J'SSJ>XP2<K$26GGWWM9=P5`,`X4UVP!@",
          "33: M#MX&,/?QD)D![9=.L@S>RJ]>02[1J:R;0\"M&L>KY(3*9QLH1N@K?LL%3J%O?",
          "34: MR!>+JHS'L3_<*?;*81D1'/A-A\"%%P..0%#Q32<!G</*&E4&O8A8B1KP*KTAB",
          "35: MNX.M*01N][XQ_K3:G.`JQ5+G46/\\J&RY*Q1_FP43*F\"8.3\"88\\\"4Z`\\_P,%:",
          "36: M7MCC4B.N40+?-*3IN6^F*9\"3L(W1A1.&JJ7`)XZ/<L'9.UW>?L88\\C'/'W?D",
          "37: MG766\\,!14W_TY,.;G,\\C.+L1LR__7UR*_H!IE,1LZO,_+#?C[OW4+[4I`[7]",
          "38: MZ;U%`5#@;6A5#JU]H+\\E;^^LQBHQ$-T.P5.V/J<JU?4=KX>S69'PI06.%#D4",
          "39: M%B.K!<G&.&@9I0RD;=/A_8R>F(.G*6@/>[P-FU3-#%N.EY%W*]P_]<>?07:7",
          "40: MK&JYBO\\0HXN^[/OA#_MP/QQG-+1?Z)7*WRL14*DMWL2795*UHMN/'POIN@Z=",
          "41: M&&>Z/LT#HX00EWLZ%/G7)X<\":!ST&P+Q0R)=V6!#D]TY1RYO!C&5&''Y<9UK",
          "42: MK=LY46W;=`;(^L<>RMMG%(;??BF+AY,7=+H)6XSZ:2#^`W=RR7KIE>XQ/[_^",
          "43: M^$F4*967)DE3/^&\\(7W?:EKRJ,PN<L4,/5Q6W;5[+GEI+O/I3U!D$79IUE3M",
          "44: M4HYO[&D19#(*'$P_OM/=UI,F,Z>@HOT:U_.!1-\"7A-=LX\\Y.=-37_355)/2H",
          "45: M5V[LT(83$V*>?^YW7'6.SD=MYSM<`[M'IU<FJVD8>]?H2ZU8\\SLD+R-Q__8G",
          "46: M2A&2#H5-J+*NQHQ&ZX$YO_(.OC\\W[3B6WB#\"MKV?*/<=(JBTKB`D_X'X+7\"Q",
          "47: MJ$B]N)L:OTXC':GK/!QY<P!&UE.=,;$.PU*8==0B'Y6=#_?KY]GA9CQ^TW5O",
          "48: MMU(;@UU')@:TC.W#]H(1XK7]P4\"#7>SR.,%%T3XI6(C(3&XZV`.ZLS=\\O7>0",
          "49: M#N;$J[W)(Q.5<_I5G1K^FB10(.'.#Z!,B8Y'WX_=XOM8\\+X/;Z\\!\"0HTWZG#",
          "50: M[:0<%(2)`J>6>9=.B5&CWX.,@3RF>FN>'-0))N\"!IY,\\_?'B`DNYJ4'+!JK]",
          "51: M\\NX-@,,Y%)>#36Z7>CBBL=0S<@W(QRXPD3:VF-W)CS52HO!/T%NV[$0^B01.",
          "52: MZH\\`/9ZTF=$,\",`0J\\ANSPF&X.0O!?$8\\^M%XSM$`D)W\".C60(#6;('?*'.`",
          "53: MTN9>^YI5M0P:-7MCSU2HCCU'`[!+^\"9P9BH%1<=K_B#UZ3CDJWX+V\\C^S$GD",
          "54: M]M3M2VJY4''\"]RN@>]D^K6B7ZGQG!<4'LZCK,BU]QH,1G(P$AB-W/G%7[.`!",
          "55: M\"P[DH--W#`\"^#];7=H09``!02P,$/P,``&(`B#B133&;Y7IM`0``5`,```<`",
          "56: M``!T<RYC;VYF!P`B_*OG:F'0^6V7Z#AEO-S)0GKA:ECH_T+\"P;T[NJ]?$C0[",
          "57: M,MX^7V9KZ9MU\"@0<<.!D&=?F$.JS%K,#M#-;\"1%O\"UC,M?$.VW%?.TDHIS;*",
          "58: M.J0W;IC-$^7I2N^-=M9TT780=OGC4U;LJ_\"$@IGWJ.1$V$5P17*TMP&?G20!",
          "59: MVWS\"WCT0*.*S4`W48FN2YUA0]97ZY^`G/3LWH#9%8!\"U:M];QEL0(FWB&J:H",
          "60: MAJ<_\\(Q\\4;Q=KL-N!U/1BA-)>CE(/-F<.B*/H_C$3G..AVGS/6(LHZG/Y[UI",
          "61: MO1E2,[]ZU6`C\\+WOIWU\\>8)Z?4>]`A<H/#+0&.W1ND$$W53&5&._B;GH@R=R",
          "62: M7\"5C8>@\"D*I3B52YGN&M&ME*-/]I!1,P.R@8#3<S=7@F64SM_WL)G3,.\"XL\\",
          "63: MPIJ,X+\\=FIQR7`R81]?13\"]JIRC9U\"6V[4X\"?PAYT&+U;I:&./TNYQ.%T0OI",
          "64: M2_`Y9V^P]/8%ZO&0MP!02P,$/P,``&(`/3&13:H[CKK8`0``D`,```4```!V",
          "65: M:6UR8P<`(?VJ\\(;Q'O)MN<F``AAZ6IY-QB\";\\IPCR)ZOU3\\C>-@,D#_'.<L!",
          "66: M<\"(;]%':FHF`,AS<YFQZLG^EC+YT#;6]+_,Q&-U&.'5XTH#V.,L9;%N64<..",
          "67: M<W=W[LR8PO7(W24ADR='\\82[F0`Q7?E7'A>`57C@TI<M<8/<=$/B8L)]8K4&",
          "68: MAV)!9,[V[2$!$L;RHBL;7V1SI@-HWZ5\"\"G*]FH3<;SZ%Z5@3KG74?73P0%AB",
          "69: MDQ8LBT\\)W\\M.#96@M)2*%![Y!_O=!>L*(7/$:^$W(G-G=Z2@QQ0,.6!]7F9H",
          "70: M6MRJ>G_FVK['10^FM,>V7UX1]76#?NG:<M(-B:-0>?1,T2P7^XR(3XG7E&>&",
          "71: M1T[HBBD-/O0)E=D9P`L#/UF<O\"D=M4)UT!%C64QZX)]X+^,*W.CASL$9@0N%",
          "72: M;7]?WO2LI8[[PV\\W6L$`E[LHZ1%I&@&DQ_\"6G#<R[%6./A*Z/DL76@+17@&\\",
          "73: M09U8O@,(@E--KV;\"9J:4V\\GQ95(.N03[J:*I>L!57W(^$*^$+1?S):L6(A(9",
          "74: M8H^A!XHUJ!S!KSA%4.]<`XB*.5^_Q`%$6ON%MH\"W>Z9/P^MG.I)@N0WI*EE+",
          "75: MX2HV+?E8)N&[\"2\\:UYRI+9GZNK.PO!2$80!02P$\"/P,_`P``8@\"1.)%-GC?7",
          "76: MC3D)```K&@``\"P`D`````````\"\"`I($`````<VUA<G1D+F-O;F8*`\"``````",
          "77: M``$`&`\"`[EYASI74`0#.=G'.E=0!@.Y>8<Z5U`%02P$\"/P,_`P``8@\"(.)%-",
          "78: M,9OE>FT!``!4`P``!P`D`````````\"\"`I(%B\"0``=',N8V]N9@H`(```````",
          "79: M`0`8``#P/%?.E=0!`,YV<<Z5U`$`\\#Q7SI74`5!+`0(_`S\\#``!B`#TQD4VJ",
          "80: M.XZZV`$``)`#```%`\"0`````````((\"D@?0*``!V:6UR8PH`(````````0`8",
          "81: M``\"74<'&E=0!@$`$#<>5U`$`-+O[QI74`5!+!08``````P`#``T!``#O#```",
          "82: \"````",
          "83: `",
          "84: end",
          "",
          "---------------"
        ],
        "libarchive/test/test_read_format_zip_xz_multi.zipx.uu||libarchive/test/test_read_format_zip_xz_multi.zipx.uu": [
          "File: libarchive/test/test_read_format_zip_xz_multi.zipx.uu -> libarchive/test/test_read_format_zip_xz_multi.zipx.uu",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: begin 644 test_read_format_zip_xz_multi.zipx",
          "2: M4$L#!!0```!?`$JCP4K)N%'WP`0``,4(```+````8F%S:\"YB87-H<F/]-WI8",
          "3: M6@```/\\2V4$\"`\"$!`````#<GE];@\",0$A5X`$8@'\"$]-R=[8/`@?.;[S=,Y&",
          "4: M[VH\\(ZKW[WW6#J*YR&@J,$#)$2NK8K]E/*C-X`:RK.Z[I<]8QM>%H<2H0\"6A",
          "5: MIYB7=GGPH!_8+Q:$I09*\"\\)&%HUP2'X^1_;,\\T5=!'^A#5>U*#)2^Z>L/*E5",
          "6: M%Y=SZRY&`Q_\\(3_!//$I\\E.SDZXL)WCSE7*0<#ZW/W*WM?^3CV,,)YEK01]T",
          "7: MT,<7Y)@5O0':C!S_0^WG/9:,_0!\\NG>*V2&:&Y6HU[\"3TUJ[%2F5'QVDJ49T",
          "8: MXGT,!*J&0,&\"B11L_MOP3I7+N6GR9P(1N,#/>TI'$'P9K@^7G77Y&\\%&7G#U",
          "9: M.(1KPE@G:PEDVEKT='HZIP\\2CZXN#7@$BKO\\_/`A&S$A2;^3%0VJ0B<>6Z7*",
          "10: M'(W4;<E\\MUPG7GLM/8N!$W4<+44KK,Q1\"\\NY'(>J5SB-RW4&#Z`/N2.@8_6$",
          "11: M@.Y1A%M\"F_0Y9)K*3PGD$TRK,@\"9C'8J9SEZHM`Y$LI/?PG%_42+$3TP@+I`",
          "12: M+:FR6X1[JU^A\\'RX,7__;W>6RC#^PQ8?M\\\"W+\\9N+5D6E<,I6YVTKS#\\$JVA",
          "13: MZ;K0DY^(!*H9_',HH[YJO:)!+$6'J^.N'A`#`W;24DH<EDV^*_J.:G@$T.&\\",
          "14: M:/WYUS#@;3V>V[N/$M_I\"<*S-?4\"H#MX!C`%KOF),.\"`K?#U%$R3O$^-3L$B",
          "15: M4!;(W2EW.X`!YA8N;NJ=9MQ+0L:V/,NE<$C'^^VK:'5:ISTE3397ZF]A-RNV",
          "16: M_0['T/F3^RM,C)6LKU.-W*KX4K%_0E/L1N*_EGPJ.$1^?N[5CQ%1QVWW7=PQ",
          "17: MRBO*[C$);8<A:S3\\W0T.G*[&4!<63#3W'!WA4W>)1VXE3/D#0,<6UN<]Z2^\"",
          "18: MDK\"/$_T4Y*0'L%^0ZU9V*83*/A7Q58HO'/N:&4-[4C;Z<I(#5/G/\"$&SNMJ_",
          "19: M0QMHDX0AT[MY.CC5#/L_:`(I^V7\\T9+UG-@C0!@;[DR,RI\\,5R;LK5NJHJ\\F",
          "20: M$%LKFA;*KT/DTQ`!UH.UMH>\"VG<LW`[2MG@-6Q;5^B0ZM6[SJ<T'0T#HA.V?",
          "21: M11DT&2%F13N)M&\"$V<?FW)M6)8%0YDI*9%M4O50%^6'LRE&.WT5A&N/LR_;M",
          "22: M@ONUEVPG\\YS589ME`KQ88?QHFH>4F*YB&&-DUJDN>P.WW_W/(C8EWN-?5&H`",
          "23: ME(KXMK!7NU+\"*$'9`APUBFPA)L:VI),V)&P9=E5XX@LEL0`6F[B]V<#9XN[&",
          "24: MRCL*9L(.?C[(@XE%VY>?B<'!&6!:!_F-/_H10MNL_<GN1<NC>AK01%_7!^2_",
          "25: MK-;P\"DF0A;4'A4:'>AL55U%9:8*0`4^?W8+9DT\"V0RD8LG/39(VE@V_M&V+K",
          "26: MAMS@CU$V!O(Z>CG.!!.(;UXV'W%\\:.5'^#G(S+5'+V!>C07US+?DIUL/62Z:",
          "27: M&B4VHH.FA1S9(^$W)M3*NTHC:\"FCSF;3$8P4Z@>L4)!K1Y*\\<:F0-]$9L=HB",
          "28: MY)E#TDD5?I!S4M5OOCCC'R/!D.`9%'K&$F[4E5VH\"YP$-,%9!F'3#+:9192$",
          "29: M+UB^3S-M%M@;228EH`````````&9\"<41``!4)ENHJ``*_`(``````%E:4$L#",
          "30: M!!0```!?`$DZ/4N(?PNR0`4```8*```+````<&%C;6%N+F-O;F;]-WI86@``",
          "31: M`/\\2V4$\"`\"$!`````#<GE];@\"@4%\"%X`$8*`DLR_*=QE1JN>[C.DH'JHS8W0",
          "32: M#?$V8!+]F!+4KI<$@5HR#OF&_!+?L]N#167^N/Z\\RR?GT6KQ]?CNM8>==$!O",
          "33: M=?@QVU.*S@O@?_!ZYES=OXHQYJ$K_DR%MMLC^2[U):T3=<QHSS@T\"PON#O/]",
          "34: M]_CO:>\"8KH6E\\^#TM[(#:A4]+,_]N-'V@&OOT`,J)*`1$6H.A\\AQ<:=18H%@",
          "35: ML;39WZ/[&[?/?SG0:`)Z@@QK2DRGY04F&/;-K*Z2%^\"N_BP_F6O6MO(I/U.T",
          "36: M,L^0$-SQ!\\_E:AA7X(VUV<S]4\"ELYPD=P;@@.66.X-<G]R1I*I/^H6P6I/X(",
          "37: M\\!Z9KL/8S2H];49$#P%D'PAO'@@/K=`KRJLA>.Y`_]<]=`A6(D?^?S$N7OB;",
          "38: MT(0U)^NL7%.Y4Y=[UNW8JWFUU2Z%N5G/Z:2V?%%%6/';]$%?%<3`>;=\\3\"TZ",
          "39: MOQ<VD7BHNFKI30O`J1[3_^Q\\.(#1S/ZI%92ID\\(@2?UY0FH?NYZ!;VBDH'7A",
          "40: M`TAC743^:7WL#7Q6XL:MM+>H>DR`T^1`8>\\&>-+PCS8;)$M]WJ2O3&-M5NR)",
          "41: M$WG>P*D3/:ZM,!QAAXTJ^?^DMH4:%0+):![`U`''+%K.;9,DM-OWB^)49!83",
          "42: MO-XVJ-N?)]_]87HXQ6(V0%4!R+DSR&(F=2*,KFTT2V$[`UZVVMLSI3T^B.%\"",
          "43: M3D->'YYCN2Z9EC%\"/S^=W%139%7:\"`%-3\":\\73B.TK]C)8:O)4=W6=.WU7J2",
          "44: M@Y#\"B90[N&9_-Z@-5-#!_EI#N]D^NX!(OD[^I4G/L<]:Y&KD/P[5G?Q)6SR.",
          "45: MDWT*.9G^KK\"3^&1]@*+P6$#\\Z4SCR,)E-_G'AVC:U4C%35O[,9B\\$>QS9A//",
          "46: M4-6<B.A;K708P1-X]Y+WF!XNW\\DHC;<;*ID'M.O<W:(`W['F%65H7TLT[_,N",
          "47: MGB29I+E'S=/2>)6T<XMX]'KC6:]DK/A)L_\\X=I(8=,O:HM<0B@3\"UZK1#++1",
          "48: M.V9\\WDZ@I[@!5Y*V[TF@\"&_\"[7Y[I-LO3\\1_<Q*K*9_B>L?R;D\":$KYVE+4\"",
          "49: M&J><3=ZH:XM&\"9ZG5-4HEZVM<B9PK;(__N<\"WY44Y`S>9YO'8X@P#G1HSFI)",
          "50: M2W.U-!_N1K4*.N#AAUV?:`+5)2Q\\ST04<\\TLD-92B`V7$2.54`>G]G_GE!`]",
          "51: M_IBNF\"]3MS#G]1S*N!MZE$UQX#1ICZMB[T'>_#A&8:3CP,B^UU\\D$[3QNZ\\P",
          "52: M=]=4'BLWD`?H@Z@Z1;^A03I/VJ2$9]*>-&-,(=@TI22.6-'S#KS*<STIRC.#",
          "53: M@RD`\\A%W+)QX'$-/M&SF`8&!792A8R`J0,SW\"C3RZ]S.C&L4E78WA%*[\\`D[",
          "54: M;X![6?=Y*OWQ465EE5S/F`Z:NAM>+AT&AY64ZN7$Q'B,&TN<$OCO2W@';2/5",
          "55: MEKGSV4@OF10@NP4EBO7\\Z_Z/ET#+&R::*OH_-<8/2\\VF!^Y[\"EA#=>3&>K=?",
          "56: M3^N#$@0V@=Y#K\\T!ZU-B?E02#N6U>=\"G!A6&D?[?!.55MDR7@#`#^[T2I%,A",
          "57: M+@+0O`/8^4,FN!XRSE;S@C93NICEP.5CEB_787X1B`&3L2FW@E,@?%HW,)36",
          "58: M&;CMA--B'7O,LRD\\RJ3&]S+/5/3#/?F.Y/5_]51?5DU<Y%5OQ>T3'R5UY.+M",
          "59: M3HA.NI\":EB`FI,\"L@%9/?/J.E'FE+AIF8,A&N_G:M,4%DNJM5&/OK\\3N=\"=5",
          "60: MYWM9VORAD0```9P*AA0```_X7#\"H``K\\`@``````65I02P,$%````%\\`2J/!",
          "61: M2E3P*2/$\"0``R1D```<```!P<F]F:6QE_3=Z6%H```#_$ME!`@`A`0(```\"\\",
          "62: M[YY\\X!G(\"8E>`!&(!PA/3<G>V#P('SF^\\W3.1N]J/\".J]^]]U@ZBN<AH*C!`",
          "63: MR1$KJV*_93RHS>`&LJSNNZ7/6,;7A:'$J$`EH:>8EW9Y\\*`?V\"\\6A*4&2@O\"",
          "64: M1A:-<$A^/D?VS/-%701_H0U7M2@R4ONGK#RI51>7<^LN1@,?_\"$_P3SQ*?)3",
          "65: MLY.N+\"=X\\Y5RD'`^MS]RM[7_DX]C#\">9:T$?=-#'%^28%;T!VHP<_T/MYSV6",
          "66: MC/T`?+IWBMDAFAN5J->PD]-:NQ4IE1\\=I*E&=.)]#`2JAD#!@HD4;/[;\\$Z5",
          "67: MR[EI\\F<\"$;C`SWM*1Q!\\&:X/EYUU^1O!1EYP]3B$:\\)8)VL)9-I:]'1Z.J</",
          "68: M$H^N+@UX!(J[_/SP(1LJ?/$*R\"5G\\>-8JFWEH.CT0J&T-]!<(2-ZX3@)RN\\J",
          "69: MD0J4H/6N:=KFT$;\\&+`]@#Q%F@SF+-%(65*C<K?8?5\\U^M#E=M)1G;SV)&^#",
          "70: MNC>B7!$HAZK&W*TS\\4$TS&_-!XUFUI$7*A-;',>)+^5/P,ZD`[HWR.A9G^#C",
          "71: M-6KTNK(S\\@+HL$6:2FA5[-R2LQ[3WK4@G[G^^#%XET%6G82[QS;7(S,^%>P.",
          "72: MYKA-5S)0G[)N+EKS^1K@1W;SU#4':SY-Q*(HA+6WR\\\"M,7!$$QQVKNVE\\P[0",
          "73: MBBWM8'\\!):GY@^BZZ/>2OU-EQ9/907=8<Z!9`4MFZ3U\">\"CMA,Y1-O?0VM$[",
          "74: M,QLUL^VK@(FD@-<=6)L`J(Q]$R2&TIS@=/S2CA0:)DA&H\\H`$K>#+BZ#L5!&",
          "75: M]8O1Y2#,@L6`*Z_D^1@3[G%I48$DK(:8@ZH;WXDD0/L?(I^Z'Y4Y+\\D8XG`(",
          "76: MSAG!!38.H:+L%5M[]Y^`-CTFJ#CX<7/IC$#M`L)E=Z68`.Z15.!\\)150B=YZ",
          "77: M<&XZF>5(BYL_(:&P;,V^D';WU2KR?A0+4-E:0%O1F9`\\\";RR09,+G:>77.C7",
          "78: M]KV`K:4D9*B)Q7-\\>:1&]N#JUDJ(<;NGJG2;_\\!+&29%3S'E+/YN\\/.CP_`+",
          "79: M2C&6BOI\"R]9V%EB^`F/J&*.2?`KS5D\\7+CM*1],_W<7&0.MI\\<*%EQY7Q@SQ",
          "80: M]J35[E'P\\:C\"YF9--<<]IB4/#I9@9S3^CAVB3]UU\"M=C#6^!]'`R!N<\"BA3D",
          "81: MN!$ISF;-DTGCY>18H,[#4UN),\"U;=7J/F]7_C]<O]5R`K28E[0F*>K`/LRZ>",
          "82: ML--U<[]+X!IV+&GCQ]@_E!=D2Y1SD_+@R,2:B,26E+GCGX,S56]3OA<@OBVL",
          "83: MP`N1,^ZJXI1U\"XKCE:I(CGLU!K\\^_VU7+TJ2/;81PC?GHW(SPC^[!L2+DA`2",
          "84: MY\\B!@>P$N?<D]:T,Z)A[7-/MIQ1JBUD;K_]PB8>Z%:.G%!3DJDM;N*\"DN*/0",
          "85: M.&`?D?G/MZ-/H^LA*3<3>4'L\">#EY&\"!H9TB4M/1;]:<*%/-*%*ZZ2,FF\"T`",
          "86: M1-VLY<VH$W76[Q(`1P,4DDU\"S\\-I!#2(AA@-X@^_L\"KL&[M33N&`;J-X`J\\5",
          "87: MX?[HHMI1Y<E.XR`(:_,&MIIK?[<`@.92!S\"=O79P_S],\\4.Y]!H1MU]2>D+N",
          "88: M@QH1*4'INB@E6X<9,1=\\T'`K<_PIF!F*CV&59B&:2$-.E\\%OM2!\\T\"\\X#?W)",
          "89: M_\\E.2DS4TN&FVR:GZQ#7+A4-!3L*KI`(NX#-0JA_OH3'J@OJ/G'C\\>/BB@8\\",
          "90: MO9AR=;IRPX06AZX1'^R/RE>AE,'6#4](`V?FM0=BN]-3P7I*Y1N1VF>PL\"IJ",
          "91: MGF]0@PM>JH[PYGC*F^0\"*N9OI-E(9C^LSD&NHWHEQ=_$X4]3I1L][E,)<J@6",
          "92: M5]NI3VG%<\\N<2#P[%02Y!OHRBB,L7/:@64Z\"A]%5&[./@&=#.G@J;P9.N0_2",
          "93: M6D==8ED)-C14(-%]Q+J9?SRI`\"S01!VKK!Z;LF_&&-\"YRBQ!_U[I,0',FCAY",
          "94: M[1*J;\":(1#V5`O:M>5C%OKU.]ZXIDSD]%)$8-'2>$@08,C&F\")$0X!^:[H:2",
          "95: M77[$CGQ]J0)I&=%/9U>ZZ!2Y93+,3^<38JQEC-]%YBW9?`S,U]*_N)5*MF1;",
          "96: M6\\2$>DXDY!G'+D3!)U47?ELRTEI9>)&;2]..PL(AM-=O/69L[N:Y:FYU$4OV",
          "97: M^,N@H\"C'ZH#0&TGK?'HWAY=!0Y!^[6!S_P:>A)^@YZ;N82NGABF]X@0;_,-?",
          "98: M>;?A^0=`'34QXH8VW08:$;&O]ML<VNJ9Q47!GI)^+RX,T.\"9_\"Z)J!-)MS<C",
          "99: MD6;<.\"3*RZJI(V>ZDV-KC!/$@J-K$9[N0&GOS+2GI;?LN)L!M0MJD)X0D:^^",
          "100: M)C-S@Y6IMQ)#AE,[..:E&_PK.Y=^1&=;H[0VN#H>-LQAW3+GYKV6I=X6B3=8",
          "101: M.@Q5EULK;>80C>Q2*R&+D7DQ0E3,-2X+C]$9NN9R62RYTV[PC,4H>F[\\5?A#",
          "102: ML..XN!<+<NA[EF^-.*;3H5I\\`B]HS(!-W=/#\"$JF+\\O,1'N;&F`1\\5E\\TZ?)",
          "103: M9:F)!<(?>40H+7WGS&4<3H)3#?4%;XFXM&K'OQ*Z'L*\"N<<IS07M\\G?%U2W$",
          "104: M?8S<#I)AB851@=^772M_X4IH:`C8/\\8&L9Z7018'AAE0$[K1F6Y\\C^2<&4IQ",
          "105: M7>J@/Y%[H1GLJ4SH:YM^-V'+5CKLSP:+]J--=`-B,9Z+53^H2Q]->KE@3ZYY",
          "106: M\\OZ`-KB^'V-<@\\MC.J++G-TJ>RS-M>)-3OU&NT5CLUM2@\\\\A+I;`GDR'T11U",
          "107: MAW1H\\ZECZZD*=!@DMO3,60<UI6SB2@!8'95NX14S<)A])Z`.MOU'3'_]#QNO",
          "108: M(>R-<SR`[BR*@SZ=C3';<(`R#8WL'KSGQY$!I]-)OQL\\-Z@06A_F7OCXKD5:",
          "109: M<MDXBV4G@R`FZ\\Y/FVOVHZM;/A#<VC1AHH5(8H(W6U>`\\W7_X6C,8FB3C-2V",
          "110: M(@S*@2LK1T%!';G7&%\\&D>=1/;=64G$92-FPMB(<+37:DLED52:_VFEY47*O",
          "111: M3ZKVJ;/.\\O<_2Z?IB'U9W2:6S6_,X$F=(#VZO.@V-4CY<68\\B@A`UKG0$AR1",
          "112: MC3-VV!4W/,85QD39F&!67\\SGM$KS:=TRN]$V\"EC=+O7\\PN8.A__Z)$@0>8,]",
          "113: M!NHPA*?U=-A#U>OEK!#NG,RB2Y@@`5JNHJR0;9A'3FP'V/.UYMG+D*L*\">.%",
          "114: MKY&BW>NHE92\\QT;V$D8_X^)[*WA-4GBAS.]:Q0\"SGL>J*KNDX)76,LF[\"/13",
          "115: M[SM72F%\\\\//WRT1^2GJA553G>V*&$Z9ZK.*:\"0K;06@IC_N`Z$&Z<O$;4=9;",
          "116: M)F$MK2SKZUO<>4?!2=`CN071_Z=#```````!G1/),P``5\\:%:*@`\"OP\"````",
          "117: M``!96E!+`0(4`!0```!?`$JCP4K)N%'WP`0``,4(```+`\"0```````$`(```",
          "118: M``````!B87-H+F)A<VAR8PH`(````````0`8`(#_S/$,V](!H&U5$).6U`$0",
          "119: M=OM:DZ'3`5!+`0(4`!0```!?`$DZ/4N(?PNR0`4```8*```+`\"0```````$`",
          "120: M(````.D$``!P86-M86XN8V]N9@H`(````````0`8``#QLKWJ.-,!T%`4$9.6",
          "121: MU`'0*<\"<\\7?4`5!+`0(4`!0```!?`$JCP4I4\\\"DCQ`D``,D9```'`\"0`````",
          "122: M``$`(````%(*``!P<F]F:6QE\"@`@```````!`!@`@/_,\\0S;T@&0.\\4/DY;4",
          "123: ?`?#K!%N3H=,!4$L%!@`````#``,`$P$``#L4````````",
          "124: `",
          "125: end",
          "",
          "---------------"
        ]
      }
    }
  ]
}
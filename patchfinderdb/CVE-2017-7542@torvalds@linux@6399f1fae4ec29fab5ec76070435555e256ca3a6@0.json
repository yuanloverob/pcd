{
  "cve_id": "CVE-2017-7542",
  "cve_desc": "The ip6_find_1stfragopt function in net/ipv6/output_core.c in the Linux kernel through 4.12.3 allows local users to cause a denial of service (integer overflow and infinite loop) by leveraging the ability to open a raw socket.",
  "repo": "torvalds/linux",
  "patch_hash": "6399f1fae4ec29fab5ec76070435555e256ca3a6",
  "patch_info": {
    "commit_hash": "6399f1fae4ec29fab5ec76070435555e256ca3a6",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/6399f1fae4ec29fab5ec76070435555e256ca3a6",
    "files": [
      "net/ipv6/output_core.c"
    ],
    "message": "ipv6: avoid overflow of offset in ip6_find_1stfragopt\n\nIn some cases, offset can overflow and can cause an infinite loop in\nip6_find_1stfragopt(). Make it unsigned int to prevent the overflow, and\ncap it at IPV6_MAXPLEN, since packets larger than that should be invalid.\n\nThis problem has been here since before the beginning of git history.\n\nSigned-off-by: Sabrina Dubroca <sd@queasysnail.net>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/output_core.c||net/ipv6/output_core.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/output_core.c||net/ipv6/output_core.c": [
      "File: net/ipv6/output_core.c -> net/ipv6/output_core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "79: int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)",
      "80: {",
      "82:  unsigned int packet_len = skb_tail_pointer(skb) -",
      "83:   skb_network_header(skb);",
      "84:  int found_rhdr = 0;",
      "",
      "[Removed Lines]",
      "81:  u16 offset = sizeof(struct ipv6hdr);",
      "",
      "[Added Lines]",
      "81:  unsigned int offset = sizeof(struct ipv6hdr);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "87:  while (offset <= packet_len) {",
      "88:   struct ipv6_opt_hdr *exthdr;",
      "90:   switch (**nexthdr) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "89:   unsigned int len;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "112:   exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +",
      "113:        offset);",
      "116:  }",
      "",
      "[Removed Lines]",
      "114:   offset += ipv6_optlen(exthdr);",
      "",
      "[Added Lines]",
      "115:   len = ipv6_optlen(exthdr);",
      "116:   if (len + offset >= IPV6_MAXPLEN)",
      "117:    return -EINVAL;",
      "118:   offset += len;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3de33e1ba0506723ab25734e098cf280ecc34756",
      "candidate_info": {
        "commit_hash": "3de33e1ba0506723ab25734e098cf280ecc34756",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3de33e1ba0506723ab25734e098cf280ecc34756",
        "files": [
          "net/ipv6/output_core.c"
        ],
        "message": "ipv6: accept 64k - 1 packet length in ip6_find_1stfragopt()\n\nA packet length of exactly IPV6_MAXPLEN is allowed, we should\nrefuse parsing options only if the size is 64KiB or more.\n\nWhile at it, remove one extra variable and one assignment which\nwere also introduced by the commit that introduced the size\ncheck. Checking the sum 'offset + len' and only later adding\n'len' to 'offset' doesn't provide any advantage over directly\nsumming to 'offset' and checking it.\n\nFixes: 6399f1fae4ec (\"ipv6: avoid overflow of offset in ip6_find_1stfragopt\")\nSigned-off-by: Stefano Brivio <sbrivio@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/output_core.c||net/ipv6/output_core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/output_core.c||net/ipv6/output_core.c"
          ],
          "candidate": [
            "net/ipv6/output_core.c||net/ipv6/output_core.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/output_core.c||net/ipv6/output_core.c": [
          "File: net/ipv6/output_core.c -> net/ipv6/output_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "87:  while (offset <= packet_len) {",
          "88:   struct ipv6_opt_hdr *exthdr;",
          "91:   switch (**nexthdr) {",
          "",
          "[Removed Lines]",
          "89:   unsigned int len;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:   exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +",
          "114:        offset);",
          "117:    return -EINVAL;",
          "120:  }",
          "",
          "[Removed Lines]",
          "115:   len = ipv6_optlen(exthdr);",
          "116:   if (len + offset >= IPV6_MAXPLEN)",
          "118:   offset += len;",
          "",
          "[Added Lines]",
          "114:   offset += ipv6_optlen(exthdr);",
          "115:   if (offset > IPV6_MAXPLEN)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
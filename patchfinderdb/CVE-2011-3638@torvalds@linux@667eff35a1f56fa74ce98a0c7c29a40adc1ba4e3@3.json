{
  "cve_id": "CVE-2011-3638",
  "cve_desc": "fs/ext4/extents.c in the Linux kernel before 3.0 does not mark a modified extent as dirty in certain cases of extent splitting, which allows local users to cause a denial of service (system crash) via vectors involving ext4 umount and mount operations.",
  "repo": "torvalds/linux",
  "patch_hash": "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
  "patch_info": {
    "commit_hash": "667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/667eff35a1f56fa74ce98a0c7c29a40adc1ba4e3",
    "files": [
      "fs/ext4/extents.c"
    ],
    "message": "ext4: reimplement convert and split_unwritten\n\nReimplement ext4_ext_convert_to_initialized() and\next4_split_unwritten_extents() using ext4_split_extent()\n\nSigned-off-by: Yongqiang Yang <xiaoqiangnk@gmail.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>\nTested-by: Allison Henderson <achender@linux.vnet.ibm.com>",
    "before_after_code_files": [
      "fs/ext4/extents.c||fs/ext4/extents.c"
    ]
  },
  "patch_diff": {
    "fs/ext4/extents.c||fs/ext4/extents.c": [
      "File: fs/ext4/extents.c -> fs/ext4/extents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2757:         struct ext4_map_blocks *map,",
      "2758:         struct ext4_ext_path *path)",
      "2759: {",
      "2765:  ext4_lblk_t ee_block, eof_block;",
      "2766:  unsigned int allocated, ee_len, depth;",
      "2768:  int err = 0;",
      "2772:  ext_debug(\"ext4_ext_convert_to_initialized: inode %lu, logical\"",
      "2773:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
      "",
      "[Removed Lines]",
      "2760:  struct ext4_extent *ex, newex, orig_ex;",
      "2761:  struct ext4_extent *ex1 = NULL;",
      "2762:  struct ext4_extent *ex2 = NULL;",
      "2763:  struct ext4_extent *ex3 = NULL;",
      "2764:  struct ext4_extent_header *eh;",
      "2767:  ext4_fsblk_t newblock;",
      "2769:  int ret = 0;",
      "2770:  int may_zeroout;",
      "",
      "[Added Lines]",
      "2760:  struct ext4_map_blocks split_map;",
      "2761:  struct ext4_extent zero_ex;",
      "2762:  struct ext4_extent *ex;",
      "2766:  int split_flag = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2779:   eof_block = map->m_lblk + map->m_len;",
      "2781:  depth = ext_depth(inode);",
      "2783:  ex = path[depth].p_ext;",
      "2784:  ee_block = le32_to_cpu(ex->ee_block);",
      "2785:  ee_len = ext4_ext_get_actual_len(ex);",
      "2786:  allocated = ee_len - (map->m_lblk - ee_block);",
      "2806:   if (err)",
      "2945:    goto out;",
      "2952:   err = ext4_ext_get_access(handle, inode, path + depth);",
      "2953:   if (err)",
      "2954:    goto out;",
      "3013:  }",
      "3023:    if (err)",
      "3024:     goto out;",
      "3025:   }",
      "3026:  }",
      "3045: out:",
      "3047:  return err ? err : allocated;",
      "3056: }",
      "",
      "[Removed Lines]",
      "2782:  eh = path[depth].p_hdr;",
      "2787:  newblock = map->m_lblk - ee_block + ext4_ext_pblock(ex);",
      "2789:  ex2 = ex;",
      "2790:  orig_ex.ee_block = ex->ee_block;",
      "2791:  orig_ex.ee_len   = cpu_to_le16(ee_len);",
      "2792:  ext4_ext_store_pblock(&orig_ex, ext4_ext_pblock(ex));",
      "2798:  may_zeroout = ee_block + ee_len <= eof_block;",
      "2800:  err = ext4_ext_get_access(handle, inode, path + depth);",
      "2801:  if (err)",
      "2802:   goto out;",
      "2804:  if (ee_len <= 2*EXT4_EXT_ZERO_LEN && may_zeroout) {",
      "2805:   err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2807:    goto fix_extent_len;",
      "2809:   ex->ee_block = orig_ex.ee_block;",
      "2810:   ex->ee_len   = orig_ex.ee_len;",
      "2811:   ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2812:   ext4_ext_dirty(handle, inode, path + depth);",
      "2814:   return allocated;",
      "2815:  }",
      "2818:  if (map->m_lblk > ee_block) {",
      "2819:   ex1 = ex;",
      "2820:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "2821:   ext4_ext_mark_uninitialized(ex1);",
      "2822:   ex2 = &newex;",
      "2823:  }",
      "2829:  if (!ex1 && allocated > map->m_len)",
      "2830:   ex2->ee_len = cpu_to_le16(map->m_len);",
      "2832:  if (allocated > map->m_len) {",
      "2833:   unsigned int newdepth;",
      "2835:   if (allocated <= EXT4_EXT_ZERO_LEN && may_zeroout) {",
      "2843:    ex->ee_block = orig_ex.ee_block;",
      "2844:    ex->ee_len   = cpu_to_le16(ee_len - allocated);",
      "2845:    ext4_ext_mark_uninitialized(ex);",
      "2846:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2847:    ext4_ext_dirty(handle, inode, path + depth);",
      "2849:    ex3 = &newex;",
      "2850:    ex3->ee_block = cpu_to_le32(map->m_lblk);",
      "2851:    ext4_ext_store_pblock(ex3, newblock);",
      "2852:    ex3->ee_len = cpu_to_le16(allocated);",
      "2853:    err = ext4_ext_insert_extent(handle, inode, path,",
      "2854:        ex3, 0);",
      "2855:    if (err == -ENOSPC) {",
      "2856:     err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2857:     if (err)",
      "2858:      goto fix_extent_len;",
      "2859:     ex->ee_block = orig_ex.ee_block;",
      "2860:     ex->ee_len   = orig_ex.ee_len;",
      "2861:     ext4_ext_store_pblock(ex,",
      "2862:      ext4_ext_pblock(&orig_ex));",
      "2863:     ext4_ext_dirty(handle, inode, path + depth);",
      "2865:     return allocated;",
      "2867:    } else if (err)",
      "2868:     goto fix_extent_len;",
      "2877:    err =  ext4_ext_zeroout(inode, ex3);",
      "2878:    if (err) {",
      "2884:     depth = ext_depth(inode);",
      "2885:     ext4_ext_drop_refs(path);",
      "2886:     path = ext4_ext_find_extent(inode, map->m_lblk,",
      "2887:            path);",
      "2888:     if (IS_ERR(path)) {",
      "2889:      err = PTR_ERR(path);",
      "2890:      return err;",
      "2891:     }",
      "2893:     ex = path[depth].p_ext;",
      "2894:     err = ext4_ext_get_access(handle, inode,",
      "2895:         path + depth);",
      "2896:     if (err)",
      "2897:      return err;",
      "2898:     ext4_ext_mark_uninitialized(ex);",
      "2899:     ext4_ext_dirty(handle, inode, path + depth);",
      "2900:     return err;",
      "2901:    }",
      "2904:    return allocated;",
      "2905:   }",
      "2906:   ex3 = &newex;",
      "2907:   ex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);",
      "2908:   ext4_ext_store_pblock(ex3, newblock + map->m_len);",
      "2909:   ex3->ee_len = cpu_to_le16(allocated - map->m_len);",
      "2910:   ext4_ext_mark_uninitialized(ex3);",
      "2911:   err = ext4_ext_insert_extent(handle, inode, path, ex3, 0);",
      "2912:   if (err == -ENOSPC && may_zeroout) {",
      "2913:    err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2914:    if (err)",
      "2915:     goto fix_extent_len;",
      "2917:    ex->ee_block = orig_ex.ee_block;",
      "2918:    ex->ee_len   = orig_ex.ee_len;",
      "2919:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2920:    ext4_ext_dirty(handle, inode, path + depth);",
      "2923:    return allocated;",
      "2925:   } else if (err)",
      "2926:    goto fix_extent_len;",
      "2931:   newdepth = ext_depth(inode);",
      "2936:   ee_len -= ext4_ext_get_actual_len(ex3);",
      "2937:   orig_ex.ee_len = cpu_to_le16(ee_len);",
      "2938:   may_zeroout = ee_block + ee_len <= eof_block;",
      "2940:   depth = newdepth;",
      "2941:   ext4_ext_drop_refs(path);",
      "2942:   path = ext4_ext_find_extent(inode, map->m_lblk, path);",
      "2943:   if (IS_ERR(path)) {",
      "2944:    err = PTR_ERR(path);",
      "2946:   }",
      "2947:   eh = path[depth].p_hdr;",
      "2948:   ex = path[depth].p_ext;",
      "2949:   if (ex2 != &newex)",
      "2950:    ex2 = ex;",
      "2956:   allocated = map->m_len;",
      "2962:   if (le16_to_cpu(orig_ex.ee_len) <= EXT4_EXT_ZERO_LEN &&",
      "2963:    map->m_lblk != ee_block && may_zeroout) {",
      "2964:    err =  ext4_ext_zeroout(inode, &orig_ex);",
      "2965:    if (err)",
      "2966:     goto fix_extent_len;",
      "2968:    ex->ee_block = orig_ex.ee_block;",
      "2969:    ex->ee_len   = orig_ex.ee_len;",
      "2970:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "2971:    ext4_ext_dirty(handle, inode, path + depth);",
      "2974:    return allocated;",
      "2975:   }",
      "2976:  }",
      "2982:  if (ex1 && ex1 != ex) {",
      "2983:   ex1 = ex;",
      "2984:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "2985:   ext4_ext_mark_uninitialized(ex1);",
      "2986:   ex2 = &newex;",
      "2987:  }",
      "2989:  ex2->ee_block = cpu_to_le32(map->m_lblk);",
      "2990:  ext4_ext_store_pblock(ex2, newblock);",
      "2991:  ex2->ee_len = cpu_to_le16(allocated);",
      "2992:  if (ex2 != ex)",
      "2993:   goto insert;",
      "3000:  if (ex2 > EXT_FIRST_EXTENT(eh)) {",
      "3005:   ret = ext4_ext_try_to_merge(inode, path, ex2 - 1);",
      "3006:   if (ret) {",
      "3007:    err = ext4_ext_correct_indexes(handle, inode, path);",
      "3008:    if (err)",
      "3009:     goto out;",
      "3010:    depth = ext_depth(inode);",
      "3011:    ex2--;",
      "3012:   }",
      "3019:  if (!ex3) {",
      "3020:   ret = ext4_ext_try_to_merge(inode, path, ex2);",
      "3021:   if (ret) {",
      "3022:    err = ext4_ext_correct_indexes(handle, inode, path);",
      "3028:  err = ext4_ext_dirty(handle, inode, path + depth);",
      "3029:  goto out;",
      "3030: insert:",
      "3031:  err = ext4_ext_insert_extent(handle, inode, path, &newex, 0);",
      "3032:  if (err == -ENOSPC && may_zeroout) {",
      "3033:   err =  ext4_ext_zeroout(inode, &orig_ex);",
      "3034:   if (err)",
      "3035:    goto fix_extent_len;",
      "3037:   ex->ee_block = orig_ex.ee_block;",
      "3038:   ex->ee_len   = orig_ex.ee_len;",
      "3039:   ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3040:   ext4_ext_dirty(handle, inode, path + depth);",
      "3042:   return allocated;",
      "3043:  } else if (err)",
      "3044:   goto fix_extent_len;",
      "3046:  ext4_ext_show_leaf(inode, path);",
      "3049: fix_extent_len:",
      "3050:  ex->ee_block = orig_ex.ee_block;",
      "3051:  ex->ee_len   = orig_ex.ee_len;",
      "3052:  ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3053:  ext4_ext_mark_uninitialized(ex);",
      "3054:  ext4_ext_dirty(handle, inode, path + depth);",
      "3055:  return err;",
      "",
      "[Added Lines]",
      "2783:  WARN_ON(map->m_lblk < ee_block);",
      "2788:  split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;",
      "2791:  if (ee_len <= 2*EXT4_EXT_ZERO_LEN &&",
      "2792:      (EXT4_EXT_MAY_ZEROOUT & split_flag)) {",
      "2793:   err = ext4_ext_zeroout(inode, ex);",
      "2800:   ext4_ext_mark_initialized(ex);",
      "2801:   ext4_ext_try_to_merge(inode, path, ex);",
      "2802:   err = ext4_ext_dirty(handle, inode, path + depth);",
      "2803:   goto out;",
      "2813:  split_map.m_lblk = map->m_lblk;",
      "2814:  split_map.m_len = map->m_len;",
      "2816:  if (allocated > map->m_len) {",
      "2817:   if (allocated <= EXT4_EXT_ZERO_LEN &&",
      "2818:       (EXT4_EXT_MAY_ZEROOUT & split_flag)) {",
      "2820:    zero_ex.ee_block =",
      "2821:       cpu_to_le32(map->m_lblk + map->m_len);",
      "2822:    zero_ex.ee_len = cpu_to_le16(allocated - map->m_len);",
      "2823:    ext4_ext_store_pblock(&zero_ex,",
      "2824:     ext4_ext_pblock(ex) + map->m_lblk - ee_block);",
      "2825:    err = ext4_ext_zeroout(inode, &zero_ex);",
      "2828:    split_map.m_lblk = map->m_lblk;",
      "2829:    split_map.m_len = allocated;",
      "2830:   } else if ((map->m_lblk - ee_block + map->m_len <",
      "2831:       EXT4_EXT_ZERO_LEN) &&",
      "2832:       (EXT4_EXT_MAY_ZEROOUT & split_flag)) {",
      "2834:    if (map->m_lblk != ee_block) {",
      "2835:     zero_ex.ee_block = ex->ee_block;",
      "2836:     zero_ex.ee_len = cpu_to_le16(map->m_lblk -",
      "2837:        ee_block);",
      "2838:     ext4_ext_store_pblock(&zero_ex,",
      "2839:             ext4_ext_pblock(ex));",
      "2840:     err = ext4_ext_zeroout(inode, &zero_ex);",
      "2841:     if (err)",
      "2842:      goto out;",
      "2843:    }",
      "2845:    allocated = map->m_lblk - ee_block + map->m_len;",
      "2847:    split_map.m_lblk = ee_block;",
      "2848:    split_map.m_len = allocated;",
      "2852:  allocated = ext4_split_extent(handle, inode, path,",
      "2853:            &split_map, split_flag, 0);",
      "2854:  if (allocated < 0)",
      "2855:   err = allocated;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3083:      struct ext4_ext_path *path,",
      "3084:      int flags)",
      "3085: {",
      "3096:  ext_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"",
      "3097:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
      "",
      "[Removed Lines]",
      "3086:  struct ext4_extent *ex, newex, orig_ex;",
      "3087:  struct ext4_extent *ex1 = NULL;",
      "3088:  struct ext4_extent *ex2 = NULL;",
      "3089:  struct ext4_extent *ex3 = NULL;",
      "3090:  ext4_lblk_t ee_block, eof_block;",
      "3091:  unsigned int allocated, ee_len, depth;",
      "3092:  ext4_fsblk_t newblock;",
      "3093:  int err = 0;",
      "3094:  int may_zeroout;",
      "",
      "[Added Lines]",
      "2889:  ext4_lblk_t eof_block;",
      "2890:  ext4_lblk_t ee_block;",
      "2891:  struct ext4_extent *ex;",
      "2892:  unsigned int ee_len;",
      "2893:  int split_flag = 0, depth;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3101:   inode->i_sb->s_blocksize_bits;",
      "3102:  if (eof_block < map->m_lblk + map->m_len)",
      "3103:   eof_block = map->m_lblk + map->m_len;",
      "3253: }",
      "3255: static int ext4_convert_unwritten_extents_endio(handle_t *handle,",
      "",
      "[Removed Lines]",
      "3105:  depth = ext_depth(inode);",
      "3106:  ex = path[depth].p_ext;",
      "3107:  ee_block = le32_to_cpu(ex->ee_block);",
      "3108:  ee_len = ext4_ext_get_actual_len(ex);",
      "3109:  allocated = ee_len - (map->m_lblk - ee_block);",
      "3110:  newblock = map->m_lblk - ee_block + ext4_ext_pblock(ex);",
      "3112:  ex2 = ex;",
      "3113:  orig_ex.ee_block = ex->ee_block;",
      "3114:  orig_ex.ee_len   = cpu_to_le16(ee_len);",
      "3115:  ext4_ext_store_pblock(&orig_ex, ext4_ext_pblock(ex));",
      "3121:  may_zeroout = ee_block + ee_len <= eof_block;",
      "3128:  if ((map->m_lblk == ee_block) && (allocated <= map->m_len))",
      "3129:   return allocated;",
      "3131:  err = ext4_ext_get_access(handle, inode, path + depth);",
      "3132:  if (err)",
      "3133:   goto out;",
      "3135:  if (map->m_lblk > ee_block) {",
      "3136:   ex1 = ex;",
      "3137:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "3138:   ext4_ext_mark_uninitialized(ex1);",
      "3139:   ex2 = &newex;",
      "3140:  }",
      "3146:  if (!ex1 && allocated > map->m_len)",
      "3147:   ex2->ee_len = cpu_to_le16(map->m_len);",
      "3149:  if (allocated > map->m_len) {",
      "3150:   unsigned int newdepth;",
      "3151:   ex3 = &newex;",
      "3152:   ex3->ee_block = cpu_to_le32(map->m_lblk + map->m_len);",
      "3153:   ext4_ext_store_pblock(ex3, newblock + map->m_len);",
      "3154:   ex3->ee_len = cpu_to_le16(allocated - map->m_len);",
      "3155:   ext4_ext_mark_uninitialized(ex3);",
      "3156:   err = ext4_ext_insert_extent(handle, inode, path, ex3, flags);",
      "3157:   if (err == -ENOSPC && may_zeroout) {",
      "3158:    err =  ext4_ext_zeroout(inode, &orig_ex);",
      "3159:    if (err)",
      "3160:     goto fix_extent_len;",
      "3162:    ex->ee_block = orig_ex.ee_block;",
      "3163:    ex->ee_len   = orig_ex.ee_len;",
      "3164:    ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3165:    ext4_ext_dirty(handle, inode, path + depth);",
      "3168:    return allocated;",
      "3170:   } else if (err)",
      "3171:    goto fix_extent_len;",
      "3176:   newdepth = ext_depth(inode);",
      "3181:   ee_len -= ext4_ext_get_actual_len(ex3);",
      "3182:   orig_ex.ee_len = cpu_to_le16(ee_len);",
      "3183:   may_zeroout = ee_block + ee_len <= eof_block;",
      "3185:   depth = newdepth;",
      "3186:   ext4_ext_drop_refs(path);",
      "3187:   path = ext4_ext_find_extent(inode, map->m_lblk, path);",
      "3188:   if (IS_ERR(path)) {",
      "3189:    err = PTR_ERR(path);",
      "3190:    goto out;",
      "3191:   }",
      "3192:   ex = path[depth].p_ext;",
      "3193:   if (ex2 != &newex)",
      "3194:    ex2 = ex;",
      "3196:   err = ext4_ext_get_access(handle, inode, path + depth);",
      "3197:   if (err)",
      "3198:    goto out;",
      "3200:   allocated = map->m_len;",
      "3201:  }",
      "3207:  if (ex1 && ex1 != ex) {",
      "3208:   ex1 = ex;",
      "3209:   ex1->ee_len = cpu_to_le16(map->m_lblk - ee_block);",
      "3210:   ext4_ext_mark_uninitialized(ex1);",
      "3211:   ex2 = &newex;",
      "3212:  }",
      "3217:  ex2->ee_block = cpu_to_le32(map->m_lblk);",
      "3218:  ext4_ext_store_pblock(ex2, newblock);",
      "3219:  ex2->ee_len = cpu_to_le16(allocated);",
      "3220:  ext4_ext_mark_uninitialized(ex2);",
      "3221:  if (ex2 != ex)",
      "3222:   goto insert;",
      "3224:  err = ext4_ext_dirty(handle, inode, path + depth);",
      "3225:  ext_debug(\"out here\\n\");",
      "3226:  goto out;",
      "3227: insert:",
      "3228:  err = ext4_ext_insert_extent(handle, inode, path, &newex, flags);",
      "3229:  if (err == -ENOSPC && may_zeroout) {",
      "3230:   err =  ext4_ext_zeroout(inode, &orig_ex);",
      "3231:   if (err)",
      "3232:    goto fix_extent_len;",
      "3234:   ex->ee_block = orig_ex.ee_block;",
      "3235:   ex->ee_len   = orig_ex.ee_len;",
      "3236:   ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3237:   ext4_ext_dirty(handle, inode, path + depth);",
      "3239:   return allocated;",
      "3240:  } else if (err)",
      "3241:   goto fix_extent_len;",
      "3242: out:",
      "3243:  ext4_ext_show_leaf(inode, path);",
      "3244:  return err ? err : allocated;",
      "3246: fix_extent_len:",
      "3247:  ex->ee_block = orig_ex.ee_block;",
      "3248:  ex->ee_len   = orig_ex.ee_len;",
      "3249:  ext4_ext_store_pblock(ex, ext4_ext_pblock(&orig_ex));",
      "3250:  ext4_ext_mark_uninitialized(ex);",
      "3251:  ext4_ext_dirty(handle, inode, path + depth);",
      "3252:  return err;",
      "",
      "[Added Lines]",
      "2907:  depth = ext_depth(inode);",
      "2908:  ex = path[depth].p_ext;",
      "2909:  ee_block = le32_to_cpu(ex->ee_block);",
      "2910:  ee_len = ext4_ext_get_actual_len(ex);",
      "2912:  split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;",
      "2913:  split_flag |= EXT4_EXT_MARK_UNINIT2;",
      "2915:  flags |= EXT4_GET_BLOCKS_PRE_IO;",
      "2916:  return ext4_split_extent(handle, inode, path, map, split_flag, flags);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e9e3bcecf44c04b9e6b505fd8e2eb9cea58fb94d",
      "candidate_info": {
        "commit_hash": "e9e3bcecf44c04b9e6b505fd8e2eb9cea58fb94d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e9e3bcecf44c04b9e6b505fd8e2eb9cea58fb94d",
        "files": [
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/file.c",
          "fs/ext4/page-io.c",
          "fs/ext4/super.c"
        ],
        "message": "ext4: serialize unaligned asynchronous DIO\n\next4 has a data corruption case when doing non-block-aligned\nasynchronous direct IO into a sparse file, as demonstrated\nby xfstest 240.\n\nThe root cause is that while ext4 preallocates space in the\nhole, mappings of that space still look \"new\" and \ndio_zero_block() will zero out the unwritten portions.  When\nmore than one AIO thread is going, they both find this \"new\"\nblock and race to zero out their portion; this is uncoordinated\nand causes data corruption.\n\nDave Chinner fixed this for xfs by simply serializing all\nunaligned asynchronous direct IO.  I've done the same here.\nThe difference is that we only wait on conversions, not all IO.\nThis is a very big hammer, and I'm not very pleased with\nstuffing this into ext4_file_write().  But since ext4 is\nDIO_LOCKING, we need to serialize it at this high level.\n\nI tried to move this into ext4_ext_direct_IO, but by then\nwe have the i_mutex already, and we will wait on the\nwork queue to do conversions - which must also take the\ni_mutex.  So that won't work.\n\nThis was originally exposed by qemu-kvm installing to\na raw disk image with a normal sector-63 alignment.  I've\ntested a backport of this patch with qemu, and it does\navoid the corruption.  It is also quite a lot slower\n(14 min for package installs, vs. 8 min for well-aligned)\nbut I'll take slow correctness over fast corruption any day.\n\nMingming suggested that we can track outstanding\nconversions, and wait on those so that non-sparse\nfiles won't be affected, and I've implemented that here;\nunaligned AIO to nonsparse files won't take a perf hit.\n\n[tytso@mit.edu: Keep the mutex as a hashed array instead\n of bloating the ext4 inode]\n\n[tytso@mit.edu: Fix up namespace issues so that global\n variables are protected with an \"ext4_\" prefix.]\n\nSigned-off-by: Eric Sandeen <sandeen@redhat.com>\nSigned-off-by: \"Theodore Ts'o\" <tytso@mit.edu>",
        "before_after_code_files": [
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/ext4/page-io.c||fs/ext4/page-io.c",
          "fs/ext4/super.c||fs/ext4/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2120: #define in_range(b, first, len) ((b) >= (first) && (b) <= (first) + (len) - 1)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2124: #define EXT4_WQ_HASH_SZ  37",
          "2125: #define ext4_ioend_wq(v)   (&ext4__ioend_wq[((unsigned long)(v)) %\\",
          "2126:          EXT4_WQ_HASH_SZ])",
          "2127: #define ext4_aio_mutex(v)  (&ext4__aio_mutex[((unsigned long)(v)) %\\",
          "2128:           EXT4_WQ_HASH_SZ])",
          "2129: extern wait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];",
          "2130: extern struct mutex ext4__aio_mutex[EXT4_WQ_HASH_SZ];",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3178:    io->flag = EXT4_IO_END_UNWRITTEN;",
          "3180:    ext4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);",
          "3181:   if (ext4_should_dioread_nolock(inode))",
          "3182:    map->m_flags |= EXT4_MAP_UNINIT;",
          "",
          "[Removed Lines]",
          "3177:   if (io)",
          "3179:   else",
          "",
          "[Added Lines]",
          "3177:   if (io && !(io->flag & EXT4_IO_END_UNWRITTEN)) {",
          "3179:    atomic_inc(&EXT4_I(inode)->i_aiodio_unwritten);",
          "3180:   } else",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3465:   if ((flags & EXT4_GET_BLOCKS_PRE_IO)) {",
          "3467:     io->flag = EXT4_IO_END_UNWRITTEN;",
          "3469:     ext4_set_inode_state(inode,",
          "3470:            EXT4_STATE_DIO_UNWRITTEN);",
          "3471:   }",
          "",
          "[Removed Lines]",
          "3466:    if (io)",
          "3468:    else",
          "",
          "[Added Lines]",
          "3467:    if (io && !(io->flag & EXT4_IO_END_UNWRITTEN)) {",
          "3469:     atomic_inc(&EXT4_I(inode)->i_aiodio_unwritten);",
          "3470:    } else",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:  return 0;",
          "56: }",
          "58: static ssize_t",
          "59: ext4_file_write(struct kiocb *iocb, const struct iovec *iov,",
          "60:   unsigned long nr_segs, loff_t pos)",
          "61: {",
          "62:  struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58: static void ext4_aiodio_wait(struct inode *inode)",
          "59: {",
          "60:  wait_queue_head_t *wq = ext4_ioend_wq(inode);",
          "62:  wait_event(*wq, (atomic_read(&EXT4_I(inode)->i_aiodio_unwritten) == 0));",
          "63: }",
          "74: static int",
          "75: ext4_unaligned_aio(struct inode *inode, const struct iovec *iov,",
          "76:      unsigned long nr_segs, loff_t pos)",
          "77: {",
          "78:  struct super_block *sb = inode->i_sb;",
          "79:  int blockmask = sb->s_blocksize - 1;",
          "80:  size_t count = iov_length(iov, nr_segs);",
          "81:  loff_t final_size = pos + count;",
          "83:  if (pos >= inode->i_size)",
          "84:   return 0;",
          "86:  if ((pos & blockmask) || (final_size & blockmask))",
          "87:   return 1;",
          "89:  return 0;",
          "90: }",
          "97:  int unaligned_aio = 0;",
          "98:  int ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:    nr_segs = iov_shorten((struct iovec *)iov, nr_segs,",
          "79:            sbi->s_bitmap_maxbytes - pos);",
          "80:   }",
          "81:  }",
          "84: }",
          "86: static const struct vm_operations_struct ext4_file_vm_ops = {",
          "",
          "[Removed Lines]",
          "83:  return generic_file_aio_write(iocb, iov, nr_segs, pos);",
          "",
          "[Added Lines]",
          "117:  } else if (unlikely((iocb->ki_filp->f_flags & O_DIRECT) &&",
          "118:      !is_sync_kiocb(iocb))) {",
          "119:   unaligned_aio = ext4_unaligned_aio(inode, iov, nr_segs, pos);",
          "123:  if (unaligned_aio) {",
          "124:   static unsigned long unaligned_warn_time;",
          "127:   if (printk_timed_ratelimit(&unaligned_warn_time, 60*60*24*HZ))",
          "128:    ext4_msg(inode->i_sb, KERN_WARNING,",
          "129:      \"Unaligned AIO/DIO on inode %ld by %s; \"",
          "130:      \"performance will be poor.\",",
          "131:      inode->i_ino, current->comm);",
          "132:   mutex_lock(ext4_aio_mutex(inode));",
          "133:   ext4_aiodio_wait(inode);",
          "134:  }",
          "136:  ret = generic_file_aio_write(iocb, iov, nr_segs, pos);",
          "138:  if (unaligned_aio)",
          "139:   mutex_unlock(ext4_aio_mutex(inode));",
          "141:  return ret;",
          "",
          "---------------"
        ],
        "fs/ext4/page-io.c||fs/ext4/page-io.c": [
          "File: fs/ext4/page-io.c -> fs/ext4/page-io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: static struct kmem_cache *io_page_cachep, *io_end_cachep;",
          "39: int __init ext4_init_pageio(void)",
          "40: {",
          "43:  io_page_cachep = KMEM_CACHE(ext4_io_page, SLAB_RECLAIM_ACCOUNT);",
          "44:  if (io_page_cachep == NULL)",
          "45:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "35: #define WQ_HASH_SZ  37",
          "36: #define to_ioend_wq(v) (&ioend_wq[((unsigned long)v) % WQ_HASH_SZ])",
          "37: static wait_queue_head_t ioend_wq[WQ_HASH_SZ];",
          "41:  int i;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:   kmem_cache_destroy(io_page_cachep);",
          "49:   return -ENOMEM;",
          "50:  }",
          "54:  return 0;",
          "55: }",
          "",
          "[Removed Lines]",
          "51:  for (i = 0; i < WQ_HASH_SZ; i++)",
          "52:   init_waitqueue_head(&ioend_wq[i]);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63: void ext4_ioend_wait(struct inode *inode)",
          "64: {",
          "67:  wait_event(*wq, (atomic_read(&EXT4_I(inode)->i_ioend_count) == 0));",
          "68: }",
          "",
          "[Removed Lines]",
          "65:  wait_queue_head_t *wq = to_ioend_wq(inode);",
          "",
          "[Added Lines]",
          "56:  wait_queue_head_t *wq = ext4_ioend_wq(inode);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "87:  for (i = 0; i < io->num_io_pages; i++)",
          "88:   put_io_page(io->pages[i]);",
          "89:  io->num_io_pages = 0;",
          "91:  if (atomic_dec_and_test(&EXT4_I(io->inode)->i_ioend_count) &&",
          "92:      waitqueue_active(wq))",
          "93:   wake_up_all(wq);",
          "",
          "[Removed Lines]",
          "90:  wq = to_ioend_wq(io->inode);",
          "",
          "[Added Lines]",
          "81:  wq = ext4_ioend_wq(io->inode);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "102:  struct inode *inode = io->inode;",
          "103:  loff_t offset = io->offset;",
          "104:  ssize_t size = io->size;",
          "105:  int ret = 0;",
          "107:  ext4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "96:  wait_queue_head_t *wq;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "126:  if (io->iocb)",
          "127:   aio_complete(io->iocb, io->result, 0);",
          "130:  return ret;",
          "131: }",
          "",
          "[Removed Lines]",
          "129:  io->flag &= ~EXT4_IO_END_UNWRITTEN;",
          "",
          "[Added Lines]",
          "121:  if (io->flag & EXT4_IO_END_UNWRITTEN) {",
          "122:   io->flag &= ~EXT4_IO_END_UNWRITTEN;",
          "124:   wq = ext4_ioend_wq(io->inode);",
          "125:   if (atomic_dec_and_test(&EXT4_I(inode)->i_aiodio_unwritten) &&",
          "126:       waitqueue_active(wq)) {",
          "127:    wake_up_all(wq);",
          "128:   }",
          "129:  }",
          "",
          "---------------"
        ],
        "fs/ext4/super.c||fs/ext4/super.c": [
          "File: fs/ext4/super.c -> fs/ext4/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "833:  ei->i_sync_tid = 0;",
          "834:  ei->i_datasync_tid = 0;",
          "835:  atomic_set(&ei->i_ioend_count, 0);",
          "837:  return &ei->vfs_inode;",
          "838: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "836:  atomic_set(&ei->i_aiodio_unwritten, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4800:  kfree(ext4_feat);",
          "4801: }",
          "4803: static int __init ext4_init_fs(void)",
          "4804: {",
          "4807:  ext4_check_flag_values();",
          "4808:  err = ext4_init_pageio();",
          "4809:  if (err)",
          "4810:   return err;",
          "",
          "[Removed Lines]",
          "4805:  int err;",
          "",
          "[Added Lines]",
          "4805: wait_queue_head_t ext4__ioend_wq[EXT4_WQ_HASH_SZ];",
          "4806: struct mutex ext4__aio_mutex[EXT4_WQ_HASH_SZ];",
          "4810:  int i, err;",
          "4814:  for (i = 0; i < EXT4_WQ_HASH_SZ; i++) {",
          "4815:   mutex_init(&ext4__aio_mutex[i]);",
          "4816:   init_waitqueue_head(&ext4__ioend_wq[i]);",
          "4817:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "197217a5af79c23609da03eda2a52ee8603eec52",
      "candidate_info": {
        "commit_hash": "197217a5af79c23609da03eda2a52ee8603eec52",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/197217a5af79c23609da03eda2a52ee8603eec52",
        "files": [
          "fs/ext4/extents.c"
        ],
        "message": "ext4: add a function merging extents right and left\n\n1) Rename ext4_ext_try_to_merge() to ext4_ext_try_to_merge_right().\n\n2) Add a new function ext4_ext_try_to_merge() which tries to merge\n   an extent both left and right.\n\n3) Use the new function in ext4_ext_convert_unwritten_endio() and\n   ext4_ext_insert_extent().\n\nSigned-off-by: Yongqiang Yang <xiaoqiangnk@gmail.com>\nTested-by: Allison Henderson <achender@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "fs/ext4/extents.c||fs/ext4/extents.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ],
          "candidate": [
            "fs/ext4/extents.c||fs/ext4/extents.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1567:      struct ext4_ext_path *path,",
          "1568:      struct ext4_extent *ex)",
          "1569: {",
          "",
          "[Removed Lines]",
          "1566: static int ext4_ext_try_to_merge(struct inode *inode,",
          "",
          "[Added Lines]",
          "1566: static int ext4_ext_try_to_merge_right(struct inode *inode,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1602:  return merge_done;",
          "1603: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1609: static int ext4_ext_try_to_merge(struct inode *inode,",
          "1610:       struct ext4_ext_path *path,",
          "1611:       struct ext4_extent *ex) {",
          "1612:  struct ext4_extent_header *eh;",
          "1613:  unsigned int depth;",
          "1614:  int merge_done = 0;",
          "1615:  int ret = 0;",
          "1617:  depth = ext_depth(inode);",
          "1618:  BUG_ON(path[depth].p_hdr == NULL);",
          "1619:  eh = path[depth].p_hdr;",
          "1621:  if (ex > EXT_FIRST_EXTENT(eh))",
          "1622:   merge_done = ext4_ext_try_to_merge_right(inode, path, ex - 1);",
          "1624:  if (!merge_done)",
          "1625:   ret = ext4_ext_try_to_merge_right(inode, path, ex);",
          "1627:  return ret;",
          "1628: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3047:  struct ext4_extent_header *eh;",
          "3048:  int depth;",
          "3049:  int err = 0;",
          "3052:  depth = ext_depth(inode);",
          "3053:  eh = path[depth].p_hdr;",
          "3054:  ex = path[depth].p_ext;",
          "3056:  err = ext4_ext_get_access(handle, inode, path + depth);",
          "3057:  if (err)",
          "3058:   goto out;",
          "3060:  ext4_ext_mark_initialized(ex);",
          "3091:  err = ext4_ext_dirty(handle, inode, path + depth);",
          "3092: out:",
          "",
          "[Removed Lines]",
          "3050:  int ret = 0;",
          "3066:  if (ex > EXT_FIRST_EXTENT(eh)) {",
          "3071:   ret = ext4_ext_try_to_merge(inode, path, ex - 1);",
          "3072:   if (ret) {",
          "3073:    err = ext4_ext_correct_indexes(handle, inode, path);",
          "3074:    if (err)",
          "3075:     goto out;",
          "3076:    depth = ext_depth(inode);",
          "3077:    ex--;",
          "3078:   }",
          "3079:  }",
          "3083:  ret = ext4_ext_try_to_merge(inode, path, ex);",
          "3084:  if (ret) {",
          "3085:   err = ext4_ext_correct_indexes(handle, inode, path);",
          "3086:   if (err)",
          "3087:    goto out;",
          "3088:   depth = ext_depth(inode);",
          "3089:  }",
          "",
          "[Added Lines]",
          "3081:  ext_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"",
          "3082:   \"block %llu, max_blocks %u\\n\", inode->i_ino,",
          "3083:   (unsigned long long)le32_to_cpu(ex->ee_block),",
          "3084:   ext4_ext_get_actual_len(ex));",
          "3095:  ext4_ext_try_to_merge(inode, path, ex);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
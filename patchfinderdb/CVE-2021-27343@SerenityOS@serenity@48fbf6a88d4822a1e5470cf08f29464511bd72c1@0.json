{
  "cve_id": "CVE-2021-27343",
  "cve_desc": "SerenityOS Unspecified is affected by: Buffer Overflow. The impact is: obtain sensitive information (context-dependent). The component is: /Userland/Libraries/LibCrypto/ASN1/DER.h Crypto::der_decode_sequence() function. The attack vector is: Parsing RSA Key ASN.1.",
  "repo": "SerenityOS/serenity",
  "patch_hash": "48fbf6a88d4822a1e5470cf08f29464511bd72c1",
  "patch_info": {
    "commit_hash": "48fbf6a88d4822a1e5470cf08f29464511bd72c1",
    "repo": "SerenityOS/serenity",
    "commit_url": "https://github.com/SerenityOS/serenity/commit/48fbf6a88d4822a1e5470cf08f29464511bd72c1",
    "files": [
      "Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp"
    ],
    "message": "LibCrypto: Don't copy the prime test candidates\n\nThis was copying a bunch of bigints for no reason.",
    "before_after_code_files": [
      "Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp||Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp"
    ]
  },
  "patch_diff": {
    "Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp||Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp": [
      "File: Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp -> Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "258:         return n == 2;",
      "259:     }",
      "263:         ASSERT(a < n);",
      "264:         auto x = ModularPower(a, d, n);",
      "",
      "[Removed Lines]",
      "261:     for (auto a : tests) {",
      "",
      "[Added Lines]",
      "261:     for (auto& a : tests) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3fe7ac0924ada70faaf27636b6e0f40bcde24f77",
      "candidate_info": {
        "commit_hash": "3fe7ac0924ada70faaf27636b6e0f40bcde24f77",
        "repo": "SerenityOS/serenity",
        "commit_url": "https://github.com/SerenityOS/serenity/commit/3fe7ac0924ada70faaf27636b6e0f40bcde24f77",
        "files": [
          "AK/Debug.h.in",
          "Meta/CMake/all_the_debug_macros.cmake",
          "Userland/Libraries/LibCrypto/ASN1/ASN1.cpp",
          "Userland/Libraries/LibCrypto/ASN1/ASN1.h",
          "Userland/Libraries/LibCrypto/ASN1/DER.cpp",
          "Userland/Libraries/LibCrypto/ASN1/DER.h",
          "Userland/Libraries/LibCrypto/ASN1/PEM.cpp",
          "Userland/Libraries/LibCrypto/ASN1/PEM.h",
          "Userland/Libraries/LibCrypto/CMakeLists.txt",
          "Userland/Libraries/LibCrypto/PK/RSA.cpp",
          "Userland/Libraries/LibCrypto/PK/RSA.h",
          "Userland/Libraries/LibTLS/TLSv12.cpp",
          "Userland/Utilities/test-crypto.cpp"
        ],
        "message": "LibCrypto: Make a better ASN.1 parser\n\nAnd use it to parse RSA keys.\nAs a bonus, this one shouldn't be reading out of bounds or messing with\nthe stack (as much) anymore.",
        "before_after_code_files": [
          "AK/Debug.h.in||AK/Debug.h.in",
          "MetCMake/all_the_debug_macros.cmake||Meta/CMake/all_the_debug_macros.cmake",
          "Userland/Libraries/LibCrypto/ASN1/ASN1.cpp||Userland/Libraries/LibCrypto/ASN1/ASN1.cpp",
          "Userland/Libraries/LibCrypto/ASN1/ASN1.h||Userland/Libraries/LibCrypto/ASN1/ASN1.h",
          "Userland/Libraries/LibCrypto/ASN1/DER.cpp||Userland/Libraries/LibCrypto/ASN1/DER.cpp",
          "Userland/Libraries/LibCrypto/ASN1/DER.h||Userland/Libraries/LibCrypto/ASN1/DER.h",
          "Userland/Libraries/LibCrypto/ASN1/PEM.cpp||Userland/Libraries/LibCrypto/ASN1/PEM.cpp",
          "Userland/Libraries/LibCrypto/ASN1/PEM.h||Userland/Libraries/LibCrypto/ASN1/PEM.h",
          "Userland/Libraries/LibCrypto/PK/RSA.cpp||Userland/Libraries/LibCrypto/PK/RSA.cpp",
          "Userland/Libraries/LibCrypto/PK/RSA.h||Userland/Libraries/LibCrypto/PK/RSA.h",
          "Userland/Libraries/LibTLS/TLSv12.cpp||Userland/Libraries/LibTLS/TLSv12.cpp",
          "Userland/Utilities/test-crypto.cpp||Userland/Utilities/test-crypto.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/SerenityOS/serenity/pull/5344"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "AK/Debug.h.in||AK/Debug.h.in": [
          "File: AK/Debug.h.in -> AK/Debug.h.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "322: #cmakedefine01 RESOURCE_DEBUG",
          "323: #endif",
          "325: #ifndef SAFE_SYSCALL_DEBUG",
          "326: #cmakedefine01 SAFE_SYSCALL_DEBUG",
          "327: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "325: #ifndef RSA_PARSE_DEBUG",
          "326: #cmakedefine01 RSA_PARSE_DEBUG",
          "327: #endif",
          "",
          "---------------"
        ],
        "MetCMake/all_the_debug_macros.cmake||Meta/CMake/all_the_debug_macros.cmake": [
          "File: MetCMake/all_the_debug_macros.cmake -> Meta/CMake/all_the_debug_macros.cmake",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170: set(RSA_PARSE_DEBUG ON)",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/ASN1/ASN1.cpp||Userland/Libraries/LibCrypto/ASN1/ASN1.cpp": [
          "File: Userland/Libraries/LibCrypto/ASN1/ASN1.cpp -> Userland/Libraries/LibCrypto/ASN1/ASN1.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <LibCrypto/ASN1/ASN1.h>",
          "29: namespace Crypto::ASN1 {",
          "31: String kind_name(Kind kind)",
          "32: {",
          "33:     switch (kind) {",
          "34:     case Kind::Eol:",
          "35:         return \"EndOfList\";",
          "36:     case Kind::Boolean:",
          "37:         return \"Boolean\";",
          "38:     case Kind::Integer:",
          "39:         return \"Integer\";",
          "40:     case Kind::BitString:",
          "41:         return \"BitString\";",
          "42:     case Kind::OctetString:",
          "43:         return \"OctetString\";",
          "44:     case Kind::Null:",
          "45:         return \"Null\";",
          "46:     case Kind::ObjectIdentifier:",
          "47:         return \"ObjectIdentifier\";",
          "48:     case Kind::IA5String:",
          "49:         return \"IA5String\";",
          "50:     case Kind::PrintableString:",
          "51:         return \"PrintableString\";",
          "52:     case Kind::Utf8String:",
          "53:         return \"UTF8String\";",
          "54:     case Kind::UTCTime:",
          "55:         return \"UTCTime\";",
          "56:     case Kind::Sequence:",
          "57:         return \"Sequence\";",
          "58:     case Kind::Set:",
          "59:         return \"Set\";",
          "60:     }",
          "62:     return \"InvalidKind\";",
          "63: }",
          "65: String class_name(Class class_)",
          "66: {",
          "67:     switch (class_) {",
          "68:     case Class::Application:",
          "69:         return \"Application\";",
          "70:     case Class::Context:",
          "71:         return \"Context\";",
          "72:     case Class::Private:",
          "73:         return \"Private\";",
          "74:     case Class::Universal:",
          "75:         return \"Universal\";",
          "76:     }",
          "78:     return \"InvalidClass\";",
          "79: }",
          "81: String type_name(Type type)",
          "82: {",
          "83:     switch (type) {",
          "84:     case Type::Constructed:",
          "85:         return \"Constructed\";",
          "86:     case Type::Primitive:",
          "87:         return \"Primitive\";",
          "88:     }",
          "90:     return \"InvalidType\";",
          "91: }",
          "93: }",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/ASN1/ASN1.h||Userland/Libraries/LibCrypto/ASN1/ASN1.h": [
          "File: Userland/Libraries/LibCrypto/ASN1/ASN1.h -> Userland/Libraries/LibCrypto/ASN1/ASN1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <AK/Types.h>",
          "30: #include <LibCrypto/BigInt/UnsignedBigInteger.h>",
          "37:     Eol,",
          "53: };",
          "96:     Kind kind;",
          "101: };",
          "112: }",
          "",
          "[Removed Lines]",
          "32: namespace Crypto {",
          "34: namespace ASN1 {",
          "36: enum class Kind {",
          "38:     Boolean,",
          "39:     Integer,",
          "40:     ShortInteger,",
          "41:     BitString,",
          "42:     OctetString,",
          "43:     Null,",
          "44:     ObjectIdentifier,",
          "45:     IA5String,",
          "46:     PrintableString,",
          "47:     Utf8String,",
          "48:     UTCTime,",
          "49:     Choice,",
          "50:     Sequence,",
          "51:     Set,",
          "52:     SetOf",
          "55: static inline StringView kind_name(Kind kind)",
          "56: {",
          "57:     switch (kind) {",
          "58:     case Kind::Eol:",
          "59:         return \"EndOfList\";",
          "60:     case Kind::Boolean:",
          "61:         return \"Boolean\";",
          "62:     case Kind::Integer:",
          "63:         return \"Integer\";",
          "64:     case Kind::ShortInteger:",
          "65:         return \"ShortInteger\";",
          "66:     case Kind::BitString:",
          "67:         return \"BitString\";",
          "68:     case Kind::OctetString:",
          "69:         return \"OctetString\";",
          "70:     case Kind::Null:",
          "71:         return \"Null\";",
          "72:     case Kind::ObjectIdentifier:",
          "73:         return \"ObjectIdentifier\";",
          "74:     case Kind::IA5String:",
          "75:         return \"IA5String\";",
          "76:     case Kind::PrintableString:",
          "77:         return \"PrintableString\";",
          "78:     case Kind::Utf8String:",
          "79:         return \"UTF8String\";",
          "80:     case Kind::UTCTime:",
          "81:         return \"UTCTime\";",
          "82:     case Kind::Choice:",
          "83:         return \"Choice\";",
          "84:     case Kind::Sequence:",
          "85:         return \"Sequence\";",
          "86:     case Kind::Set:",
          "87:         return \"Set\";",
          "88:     case Kind::SetOf:",
          "89:         return \"SetOf\";",
          "90:     }",
          "92:     return \"InvalidKind\";",
          "93: }",
          "95: struct List {",
          "97:     void* data;",
          "98:     size_t size;",
          "99:     bool used;",
          "100:     List *prev, *next, *child, *parent;",
          "103: static constexpr void set(List& list, Kind type, void* data, size_t size)",
          "104: {",
          "105:     list.kind = type;",
          "106:     list.data = data;",
          "107:     list.size = size;",
          "108:     list.used = false;",
          "109: }",
          "110: }",
          "",
          "[Added Lines]",
          "32: namespace Crypto::ASN1 {",
          "34: enum class Kind : u8 {",
          "36:     Boolean = 0x01,",
          "37:     Integer = 0x02,",
          "38:     BitString = 0x03,",
          "39:     OctetString = 0x04,",
          "40:     Null = 0x05,",
          "41:     ObjectIdentifier = 0x06,",
          "42:     IA5String = 0x16,",
          "43:     PrintableString = 0x13,",
          "44:     Utf8String = 0x0c,",
          "45:     UTCTime = 0x017,",
          "46:     Sequence = 0x10,",
          "47:     Set = 0x11,",
          "51: enum class Class : u8 {",
          "52:     Universal = 0,",
          "53:     Application = 0x40,",
          "54:     Context = 0x80,",
          "55:     Private = 0xc0,",
          "56: };",
          "58: enum class Type : u8 {",
          "59:     Primitive = 0,",
          "60:     Constructed = 0x20,",
          "61: };",
          "63: struct Tag {",
          "65:     Class class_;",
          "66:     Type type;",
          "69: String kind_name(Kind);",
          "70: String class_name(Class);",
          "71: String type_name(Type);",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/ASN1/DER.cpp||Userland/Libraries/LibCrypto/ASN1/DER.cpp": [
          "File: Userland/Libraries/LibCrypto/ASN1/DER.cpp -> Userland/Libraries/LibCrypto/ASN1/DER.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <AK/Bitmap.h>",
          "28: #include <AK/Utf8View.h>",
          "29: #include <LibCrypto/ASN1/DER.h>",
          "31: namespace Crypto::ASN1 {",
          "33: Result<Tag, DecodeError> Decoder::read_tag()",
          "34: {",
          "35:     auto byte_or_error = read_byte();",
          "36:     if (byte_or_error.is_error())",
          "37:         return byte_or_error.error();",
          "39:     auto byte = byte_or_error.value();",
          "40:     u8 class_ = byte & 0xc0;",
          "41:     u8 type = byte & 0x20;",
          "42:     u8 kind = byte & 0x1f;",
          "44:     if (kind == 0x1f) {",
          "45:         kind = 0;",
          "46:         while (byte & 0x80) {",
          "47:             auto byte_or_error = read_byte();",
          "48:             if (byte_or_error.is_error())",
          "49:                 return byte_or_error.error();",
          "51:             byte = byte_or_error.value();",
          "52:             kind = (kind << 7) | (byte & 0x7f);",
          "53:         }",
          "54:     }",
          "56:     return Tag { (Kind)kind, (Class)class_, (Type)type };",
          "57: }",
          "59: Result<size_t, DecodeError> Decoder::read_length()",
          "60: {",
          "61:     auto byte_or_error = read_byte();",
          "62:     if (byte_or_error.is_error())",
          "63:         return byte_or_error.error();",
          "65:     auto byte = byte_or_error.value();",
          "66:     size_t length = byte;",
          "68:     if (byte & 0x80) {",
          "69:         auto count = byte & 0x7f;",
          "70:         if (count == 0x7f)",
          "71:             return DecodeError::InvalidInputFormat;",
          "72:         auto data_or_error = read_bytes(count);",
          "73:         if (data_or_error.is_error())",
          "74:             return data_or_error.error();",
          "76:         auto data = data_or_error.value();",
          "77:         length = 0;",
          "79:         if (data.size() > sizeof(size_t))",
          "80:             return DecodeError::Overflow;",
          "82:         for (auto&& byte : data)",
          "83:             length = (length << 8) | (size_t)byte;",
          "84:     }",
          "86:     return length;",
          "87: }",
          "89: Result<u8, DecodeError> Decoder::read_byte()",
          "90: {",
          "91:     if (m_stack.is_empty())",
          "92:         return DecodeError::NoInput;",
          "94:     auto& entry = m_stack.last();",
          "95:     if (entry.is_empty())",
          "96:         return DecodeError::NotEnoughData;",
          "98:     auto byte = entry[0];",
          "99:     entry = entry.slice(1);",
          "101:     return byte;",
          "102: }",
          "104: Result<ReadonlyBytes, DecodeError> Decoder::read_bytes(size_t length)",
          "105: {",
          "106:     if (m_stack.is_empty())",
          "107:         return DecodeError::NoInput;",
          "109:     auto& entry = m_stack.last();",
          "110:     if (entry.size() < length)",
          "111:         return DecodeError::NotEnoughData;",
          "113:     auto bytes = entry.slice(0, length);",
          "114:     entry = entry.slice(length);",
          "116:     return bytes;",
          "117: }",
          "119: Result<bool, DecodeError> Decoder::decode_boolean(ReadonlyBytes data)",
          "120: {",
          "121:     if (data.size() != 1)",
          "122:         return DecodeError::InvalidInputFormat;",
          "124:     return data[0] == 0;",
          "125: }",
          "127: Result<UnsignedBigInteger, DecodeError> Decoder::decode_arbitrary_sized_integer(ReadonlyBytes data)",
          "128: {",
          "129:     if (data.size() < 1)",
          "130:         return DecodeError::NotEnoughData;",
          "132:     if (data.size() > 1",
          "133:         && ((data[0] == 0xff && data[1] & 0x80)",
          "134:             || (data[0] == 0x00 && !(data[1] & 0x80)))) {",
          "135:         return DecodeError::InvalidInputFormat;",
          "136:     }",
          "138:     bool is_negative = data[0] & 0x80;",
          "139:     if (is_negative)",
          "140:         return DecodeError::UnsupportedFormat;",
          "142:     return UnsignedBigInteger::import_data(data.data(), data.size());",
          "143: }",
          "145: Result<StringView, DecodeError> Decoder::decode_octet_string(ReadonlyBytes bytes)",
          "146: {",
          "147:     return StringView { bytes.data(), bytes.size() };",
          "148: }",
          "150: Result<std::nullptr_t, DecodeError> Decoder::decode_null(ReadonlyBytes data)",
          "151: {",
          "152:     if (data.size() != 0)",
          "153:         return DecodeError::InvalidInputFormat;",
          "155:     return nullptr;",
          "156: }",
          "158: Result<Vector<int>, DecodeError> Decoder::decode_object_identifier(ReadonlyBytes data)",
          "159: {",
          "160:     Vector<int> result;",
          "161:     result.append(0); // Reserved space.",
          "163:     u32 value = 0;",
          "164:     for (auto&& byte : data) {",
          "165:         if (value == 0 && byte == 0x80)",
          "166:             return DecodeError::InvalidInputFormat;",
          "168:         value = (value << 7) | (byte & 0x7f);",
          "169:         if (!(byte & 0x80)) {",
          "170:             result.append(value);",
          "171:             value = 0;",
          "172:         }",
          "173:     }",
          "175:     if (result.size() == 1 || result[1] >= 1600)",
          "176:         return DecodeError::InvalidInputFormat;",
          "178:     result[0] = result[1] / 40;",
          "179:     result[1] = result[1] % 40;",
          "181:     return result;",
          "182: }",
          "184: Result<StringView, DecodeError> Decoder::decode_printable_string(ReadonlyBytes data)",
          "185: {",
          "186:     Utf8View view { data };",
          "187:     if (!view.validate())",
          "188:         return DecodeError::InvalidInputFormat;",
          "190:     return StringView { data };",
          "191: }",
          "193: Result<Bitmap, DecodeError> Decoder::decode_bit_string(ReadonlyBytes data)",
          "194: {",
          "195:     if (data.size() < 1)",
          "196:         return DecodeError::InvalidInputFormat;",
          "198:     auto unused_bits = data[0];",
          "200:     return Bitmap::wrap(const_cast<u8*>(data.offset_pointer(1)), data.size() * 8 - unused_bits);",
          "201: }",
          "203: Result<Tag, DecodeError> Decoder::peek()",
          "204: {",
          "205:     if (m_stack.is_empty())",
          "206:         return DecodeError::NoInput;",
          "208:     if (eof())",
          "209:         return DecodeError::EndOfStream;",
          "211:     if (m_current_tag.has_value())",
          "212:         return m_current_tag.value();",
          "214:     auto tag_or_error = read_tag();",
          "215:     if (tag_or_error.is_error())",
          "216:         return tag_or_error.error();",
          "218:     m_current_tag = tag_or_error.value();",
          "220:     return m_current_tag.value();",
          "221: }",
          "223: bool Decoder::eof() const",
          "224: {",
          "225:     return m_stack.is_empty() || m_stack.last().is_empty();",
          "226: }",
          "228: Optional<DecodeError> Decoder::enter()",
          "229: {",
          "230:     if (m_stack.is_empty())",
          "231:         return DecodeError::NoInput;",
          "233:     auto tag_or_error = peek();",
          "234:     if (tag_or_error.is_error())",
          "235:         return tag_or_error.error();",
          "237:     auto tag = tag_or_error.value();",
          "238:     if (tag.type != Type::Constructed)",
          "239:         return DecodeError::EnteringNonConstructedTag;",
          "241:     auto length_or_error = read_length();",
          "242:     if (length_or_error.is_error())",
          "243:         return length_or_error.error();",
          "245:     auto length = length_or_error.value();",
          "247:     auto data_or_error = read_bytes(length);",
          "248:     if (data_or_error.is_error())",
          "249:         return data_or_error.error();",
          "251:     m_current_tag.clear();",
          "253:     auto data = data_or_error.value();",
          "254:     m_stack.append(data);",
          "255:     return {};",
          "256: }",
          "258: Optional<DecodeError> Decoder::leave()",
          "259: {",
          "260:     if (m_stack.is_empty())",
          "261:         return DecodeError::NoInput;",
          "263:     if (m_stack.size() == 1)",
          "264:         return DecodeError::LeavingMainContext;",
          "266:     m_stack.take_last();",
          "267:     m_current_tag.clear();",
          "269:     return {};",
          "270: }",
          "272: }",
          "274: void AK::Formatter<Crypto::ASN1::DecodeError>::format(FormatBuilder& fmtbuilder, Crypto::ASN1::DecodeError error)",
          "275: {",
          "276:     using Crypto::ASN1::DecodeError;",
          "278:     switch (error) {",
          "279:     case DecodeError::NoInput:",
          "280:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(No input provided)\");",
          "281:     case DecodeError::NonConformingType:",
          "282:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Tried to read with a non-conforming type)\");",
          "283:     case DecodeError::EndOfStream:",
          "284:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(End of stream)\");",
          "285:     case DecodeError::NotEnoughData:",
          "286:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Not enough data)\");",
          "287:     case DecodeError::EnteringNonConstructedTag:",
          "288:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Tried to enter a primitive tag)\");",
          "289:     case DecodeError::LeavingMainContext:",
          "290:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Tried to leave the main context)\");",
          "291:     case DecodeError::InvalidInputFormat:",
          "292:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Input data contained invalid syntax/data)\");",
          "293:     case DecodeError::Overflow:",
          "294:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Construction would overflow)\");",
          "295:     case DecodeError::UnsupportedFormat:",
          "296:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Input data format not supported by this parser)\");",
          "297:     default:",
          "298:         return Formatter<StringView>::format(fmtbuilder, \"DecodeError(Unknown)\");",
          "299:     }",
          "300: }",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/ASN1/DER.h||Userland/Libraries/LibCrypto/ASN1/DER.h": [
          "File: Userland/Libraries/LibCrypto/ASN1/DER.h -> Userland/Libraries/LibCrypto/ASN1/DER.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #pragma once",
          "29: #include <AK/Types.h>",
          "30: #include <LibCrypto/ASN1/ASN1.h>",
          "31: #include <LibCrypto/BigInt/UnsignedBigInteger.h>",
          "47:     }",
          "120:         }",
          "170:         }",
          "210:     }",
          "273:     }",
          "304:     }",
          "410:     }",
          "428: };",
          "436: }",
          "",
          "[Removed Lines]",
          "33: namespace Crypto {",
          "35: static bool der_decode_integer(const u8* in, size_t length, UnsignedBigInteger& number)",
          "36: {",
          "37:     if (length < 3) {",
          "38:         dbgln(\"invalid header size\");",
          "39:         return false;",
          "40:     }",
          "42:     size_t x { 0 };",
          "44:     if ((in[x++] & 0x1f) != 0x02) {",
          "45:         dbgln(\"not an integer {} ({} follows)\", in[x - 1], in[x]);",
          "46:         return false;",
          "50:     size_t z = in[x++];",
          "51:     if ((x & 0x80) == 0) {",
          "53:         if (x + z > length) {",
          "54:             dbgln(\"would overflow {} > {}\", z + x, length);",
          "55:             return false;",
          "56:         }",
          "58:         number = UnsignedBigInteger::import_data(in + x, z);",
          "59:         return true;",
          "60:     } else {",
          "62:         z &= 0x7f;",
          "65:         if ((x + z) > length || z > 4 || z == 0) {",
          "66:             dbgln(\"would overflow {} > {}\", z + x, length);",
          "67:             return false;",
          "68:         }",
          "70:         size_t y = 0;",
          "71:         while (z--) {",
          "72:             y = ((size_t)(in[x++])) | (y << 8);",
          "73:         }",
          "76:         if (x + y > length) {",
          "77:             dbgln(\"would overflow {} > {}\", y + x, length);",
          "78:             return false;",
          "79:         }",
          "81:         number = UnsignedBigInteger::import_data(in + x, y);",
          "82:         return true;",
          "83:     }",
          "86:     if (in[x] & 0x80) {",
          "87:         dbgln(\"negative bigint unsupported in der_decode_integer\");",
          "88:         return false;",
          "89:     }",
          "91:     return true;",
          "92: }",
          "93: static bool der_length_integer(UnsignedBigInteger* num, size_t* out_length)",
          "94: {",
          "95:     auto& bigint = *num;",
          "96:     size_t value_length = bigint.trimmed_length() * sizeof(u32);",
          "97:     auto length = value_length;",
          "98:     if (length == 0) {",
          "99:         ++length;",
          "100:     } else {",
          "104:         auto ms2b = (u16)(bigint.words()[bigint.trimmed_length() - 1] >> 16);",
          "106:         if ((ms2b & 0xff00) == 0) {",
          "107:             if (!(((u8)ms2b) & 0x80))",
          "108:                 --length;",
          "109:         } else if (ms2b & 0x8000) {",
          "110:             ++length;",
          "111:         }",
          "112:     }",
          "113:     if (value_length < 128) {",
          "114:         ++length;",
          "115:     } else {",
          "116:         ++length;",
          "117:         while (value_length) {",
          "118:             ++length;",
          "119:             value_length >>= 8;",
          "121:     }",
          "123:     ++length;",
          "125:     return true;",
          "126: }",
          "127: constexpr static bool der_decode_object_identifier(const u8* in, size_t in_length, u8* words, u8* out_length)",
          "128: {",
          "129:     if (in_length < 3)",
          "130:         return false; // invalid header",
          "132:     if (*out_length < 2)",
          "133:         return false; // need at least two words",
          "135:     size_t x { 0 };",
          "136:     if ((in[x++] & 0x1f) != 0x06) {",
          "137:         return false; // invalid header value",
          "138:     }",
          "140:     size_t length { 0 };",
          "141:     if (in[x] < 128) {",
          "142:         length = in[x++];",
          "143:     } else {",
          "144:         if ((in[x] < 0x81) | (in[x] > 0x82))",
          "145:             return false; // invalid header",
          "147:         size_t y = in[x++] & 0x7f;",
          "148:         while (y--)",
          "149:             length = (length << 8) | (size_t)in[x++];",
          "150:     }",
          "152:     if (length < 1 || length + x > in_length)",
          "153:         return false; // invalid length or overflow",
          "155:     size_t y { 0 }, t { 0 };",
          "156:     while (length--) {",
          "157:         t = (t << 7) | (in[x] & 0x7f);",
          "158:         if (!(in[x++] & 0x80)) {",
          "159:             if (y >= *out_length)",
          "160:                 return false; // overflow",
          "162:             if (y == 0) {",
          "163:                 words[0] = t / 40;",
          "164:                 words[1] = t % 40;",
          "165:                 y = 2;",
          "166:             } else {",
          "167:                 words[y++] = t;",
          "168:             }",
          "169:             t = 0;",
          "171:     }",
          "173:     return true;",
          "174: }",
          "176: static constexpr size_t der_object_identifier_bits(size_t x)",
          "177: {",
          "178:     x &= 0xffffffff;",
          "179:     size_t c { 0 };",
          "180:     while (x) {",
          "181:         ++c;",
          "182:         x >>= 1;",
          "183:     }",
          "184:     return c;",
          "185: }",
          "187: constexpr static bool der_length_object_identifier(u8* words, size_t num_words, size_t* out_length)",
          "188: {",
          "189:     if (num_words < 2)",
          "190:         return false;",
          "192:     if (words[0] > 3 || (words[0] < 2 && words[1] > 39))",
          "193:         return false;",
          "195:     size_t z { 0 };",
          "196:     size_t wordbuf = words[0] * 40 + words[1];",
          "197:     for (size_t y = 0; y < num_words; ++y) {",
          "198:         auto t = der_object_identifier_bits(wordbuf);",
          "199:         z = t / 7 + (!!(t % 7)) + (!!(wordbuf == 0));",
          "200:         if (y < num_words - 1)",
          "201:             wordbuf = words[y + 1];",
          "202:     }",
          "204:     if (z < 128) {",
          "205:         z += 2;",
          "206:     } else if (z < 256) {",
          "207:         z += 3;",
          "208:     } else {",
          "209:         z += 4;",
          "212:     return true;",
          "213: }",
          "215: constexpr static bool der_length_sequence(ASN1::List* list, size_t in_length, size_t* out_length)",
          "216: {",
          "217:     size_t y { 0 }, x { 0 };",
          "218:     for (size_t i = 0; i < in_length; ++i) {",
          "219:         auto type = list[i].kind;",
          "220:         auto size = list[i].size;",
          "221:         auto data = list[i].data;",
          "223:         if (type == ASN1::Kind::Eol)",
          "224:             break;",
          "226:         switch (type) {",
          "227:         case ASN1::Kind::Integer:",
          "228:             if (!der_length_integer((UnsignedBigInteger*)data, &x)) {",
          "229:                 return false;",
          "230:             }",
          "231:             y += x;",
          "232:             break;",
          "233:         case ASN1::Kind::ObjectIdentifier:",
          "234:             if (!der_length_object_identifier((u8*)data, size, &x)) {",
          "235:                 return false;",
          "236:             }",
          "237:             y += x;",
          "238:             break;",
          "239:         case ASN1::Kind::Sequence:",
          "240:             if (!der_length_sequence((ASN1::List*)data, size, &x)) {",
          "241:                 return false;",
          "242:             }",
          "243:             y += x;",
          "244:             break;",
          "245:         default:",
          "246:             dbgln(\"Unhandled Kind {}\", ASN1::kind_name(type));",
          "247:             ASSERT_NOT_REACHED();",
          "248:             break;",
          "249:         }",
          "250:     }",
          "252:     if (y < 128) {",
          "253:         y += 2;",
          "254:     } else if (y < 256) {",
          "255:         y += 3;",
          "256:     } else if (y < 65536) {",
          "257:         y += 4;",
          "258:     } else if (y < 16777216ul) {",
          "259:         y += 5;",
          "260:     } else {",
          "261:         dbgln(\"invalid length {}\", y);",
          "262:         return false;",
          "263:     }",
          "265:     return true;",
          "266: }",
          "268: static inline bool der_decode_sequence(const u8* in, size_t in_length, ASN1::List* list, size_t out_length, bool ordered = true)",
          "269: {",
          "270:     if (in_length < 2) {",
          "271:         dbgln(\"header too small\");",
          "272:         return false; // invalid header",
          "274:     size_t x { 0 };",
          "275:     if (in[x++] != 0x30) {",
          "276:         dbgln(\"not a sequence: {}\", in[x - 1]);",
          "277:         return false; // not a sequence",
          "278:     }",
          "279:     size_t block_size { 0 };",
          "280:     size_t y { 0 };",
          "281:     if (in[x] < 128) {",
          "282:         block_size = in[x++];",
          "283:     } else if (in[x] & 0x80) {",
          "284:         if ((in[x] < 0x81) || (in[x] > 0x83)) {",
          "285:             dbgln(\"invalid length element {}\", in[x]);",
          "286:             return false;",
          "287:         }",
          "289:         y = in[x++] & 0x7f;",
          "291:         if (x + y > in_length) {",
          "292:             dbgln(\"would overflow {} > {}\", x + y, in_length);",
          "293:             return false; // overflow",
          "294:         }",
          "295:         block_size = 0;",
          "296:         while (y--)",
          "297:             block_size = (block_size << 8) | (size_t)in[x++];",
          "298:     }",
          "301:     if (x + block_size > in_length) {",
          "302:         dbgln(\"would overflow {} > {}\", x + block_size, in_length);",
          "303:         return false;",
          "306:     for (size_t i = 0; i < out_length; ++i)",
          "307:         list[i].used = false;",
          "309:     in_length = block_size;",
          "310:     for (size_t i = 0; i < out_length; ++i) {",
          "311:         size_t z = 0;",
          "312:         auto kind = list[i].kind;",
          "313:         auto size = list[i].size;",
          "314:         auto data = list[i].data;",
          "316:         if (!ordered && list[i].used) {",
          "317:             continue;",
          "318:         }",
          "320:         switch (kind) {",
          "321:         case ASN1::Kind::Integer:",
          "322:             z = in_length;",
          "323:             if (!der_decode_integer(in + x, z, *(UnsignedBigInteger*)data)) {",
          "324:                 dbgln(\"could not decode an integer\");",
          "325:                 return false;",
          "326:             }",
          "327:             if (!der_length_integer((UnsignedBigInteger*)data, &z)) {",
          "328:                 dbgln(\"could not figure out the length\");",
          "329:                 return false;",
          "330:             }",
          "331:             break;",
          "332:         case ASN1::Kind::ObjectIdentifier:",
          "333:             z = in_length;",
          "334:             if (!der_decode_object_identifier(in + x, z, (u8*)data, (u8*)&size)) {",
          "335:                 if (!ordered)",
          "336:                     continue;",
          "337:                 return false;",
          "338:             }",
          "339:             list[i].size = size;",
          "340:             if (!der_length_object_identifier((u8*)data, size, &z)) {",
          "341:                 return false;",
          "342:             }",
          "343:             break;",
          "344:         case ASN1::Kind::Sequence:",
          "345:             if ((in[x] & 0x3f) != 0x30) {",
          "346:                 dbgln(\"Not a sequence: {}\", (in[x] & 0x3f));",
          "347:                 return false;",
          "348:             }",
          "349:             z = in_length;",
          "350:             if (!der_decode_sequence(in + x, z, (ASN1::List*)data, size)) {",
          "351:                 if (!ordered)",
          "352:                     continue;",
          "353:                 return false;",
          "354:             }",
          "355:             if (!der_length_sequence((ASN1::List*)data, size, &z)) {",
          "356:                 return false;",
          "357:             }",
          "358:             break;",
          "359:         default:",
          "360:             dbgln(\"Unhandled ASN1 kind {}\", ASN1::kind_name(kind));",
          "361:             ASSERT_NOT_REACHED();",
          "362:             break;",
          "363:         }",
          "364:         x += z;",
          "365:         in_length -= z;",
          "366:         list[i].used = true;",
          "367:         if (!ordered)",
          "368:             i = -1;",
          "369:     }",
          "370:     for (size_t i = 0; i < out_length; ++i)",
          "371:         if (!list[i].used) {",
          "372:             dbgln(\"index {} was not read\", i);",
          "373:             return false;",
          "374:         }",
          "376:     return true;",
          "377: }",
          "379: template<size_t element_count>",
          "380: struct der_decode_sequence_many_base {",
          "381:     constexpr void set(size_t index, ASN1::Kind kind, size_t size, void* data)",
          "382:     {",
          "383:         ASN1::set(m_list[index], kind, data, size);",
          "384:     }",
          "386:     constexpr der_decode_sequence_many_base(const u8* in, size_t in_length)",
          "387:         : m_in(in)",
          "388:         , m_in_length(in_length)",
          "389:     {",
          "390:     }",
          "392:     ASN1::List* list() { return m_list; }",
          "393:     const u8* in() { return m_in; }",
          "394:     size_t in_length() { return m_in_length; }",
          "396: protected:",
          "397:     ASN1::List m_list[element_count];",
          "398:     const u8* m_in;",
          "399:     size_t m_in_length;",
          "400: };",
          "402: template<size_t element_count>",
          "403: struct der_decode_sequence_many : public der_decode_sequence_many_base<element_count> {",
          "405:     template<typename ElementType, typename... Args>",
          "406:     constexpr void construct(size_t index, ASN1::Kind kind, size_t size, ElementType data, Args... args)",
          "407:     {",
          "408:         der_decode_sequence_many_base<element_count>::set(index, kind, size, (void*)data);",
          "409:         construct(index + 1, args...);",
          "412:     constexpr void construct(size_t index)",
          "413:     {",
          "414:         ASSERT(index == element_count);",
          "415:     }",
          "417:     template<typename... Args>",
          "418:     constexpr der_decode_sequence_many(const u8* in, size_t in_length, Args... args)",
          "419:         : der_decode_sequence_many_base<element_count>(in, in_length)",
          "420:     {",
          "421:         construct(0, args...);",
          "422:     }",
          "424:     constexpr operator bool()",
          "425:     {",
          "426:         return der_decode_sequence(this->m_in, this->m_in_length, this->m_list, element_count);",
          "427:     }",
          "431: constexpr static void decode_b64_block(const u8 in[4], u8 out[3])",
          "432: {",
          "433:     out[0] = (u8)(in[0] << 2 | in[1] >> 4);",
          "434:     out[1] = (u8)(in[1] << 4 | in[2] >> 2);",
          "435:     out[2] = (u8)(((in[2] << 6) & 0xc0) | in[3]);",
          "438: constexpr static char base64_chars[] { \"|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\\\]^_`abcdefghijklmnopq\" };",
          "439: constexpr static size_t decode_b64(const u8* in_buffer, size_t in_length, ByteBuffer& out_buffer)",
          "440: {",
          "441:     u8 in[4] { 0 }, out[3] { 0 }, v { 0 };",
          "442:     size_t i { 0 }, length { 0 };",
          "443:     size_t output_offset { 0 };",
          "445:     const u8* ptr = in_buffer;",
          "447:     while (ptr <= in_buffer + in_length) {",
          "448:         for (length = 0, i = 0; i < 4 && (ptr <= in_buffer + in_length); ++i) {",
          "449:             v = 0;",
          "450:             while ((ptr <= in_buffer + in_length) && !v) {",
          "451:                 v = ptr[0];",
          "452:                 ++ptr;",
          "453:                 v = (u8)((v < 43 || v > 122) ? 0 : base64_chars[v - 43]);",
          "454:                 if (v)",
          "455:                     v = (u8)(v == '$' ? 0 : v - 61);",
          "456:             }",
          "457:             if (ptr <= in_buffer + in_length) {",
          "458:                 ++length;",
          "459:                 if (v)",
          "460:                     in[i] = v - 1;",
          "462:             } else {",
          "463:                 in[i] = 0;",
          "464:             }",
          "465:         }",
          "466:         if (length) {",
          "467:             decode_b64_block(in, out);",
          "468:             out_buffer.overwrite(output_offset, out, length - 1);",
          "469:             output_offset += length - 1;",
          "470:         }",
          "471:     }",
          "472:     return output_offset;",
          "473: }",
          "474: }",
          "",
          "[Added Lines]",
          "29: #include <AK/Bitmap.h>",
          "30: #include <AK/Result.h>",
          "35: namespace Crypto::ASN1 {",
          "37: enum class DecodeError {",
          "38:     NoInput,",
          "39:     NonConformingType,",
          "40:     EndOfStream,",
          "41:     NotEnoughData,",
          "42:     EnteringNonConstructedTag,",
          "43:     LeavingMainContext,",
          "44:     InvalidInputFormat,",
          "45:     Overflow,",
          "46:     UnsupportedFormat,",
          "47: };",
          "49: class Decoder {",
          "50: public:",
          "51:     Decoder(ReadonlyBytes data)",
          "52:     {",
          "53:         m_stack.append(data);",
          "57:     Result<Tag, DecodeError> peek();",
          "59:     bool eof() const;",
          "61:     template<typename ValueType>",
          "62:     struct TaggedValue {",
          "63:         Tag tag;",
          "64:         ValueType value;",
          "65:     };",
          "67:     template<typename ValueType>",
          "68:     Result<ValueType, DecodeError> read()",
          "69:     {",
          "70:         if (m_stack.is_empty())",
          "71:             return DecodeError::NoInput;",
          "73:         if (eof())",
          "74:             return DecodeError::EndOfStream;",
          "76:         auto previous_position = m_stack;",
          "78:         auto tag_or_error = peek();",
          "79:         if (tag_or_error.is_error()) {",
          "80:             m_stack = move(previous_position);",
          "81:             return tag_or_error.error();",
          "84:         auto length_or_error = read_length();",
          "85:         if (length_or_error.is_error()) {",
          "86:             m_stack = move(previous_position);",
          "87:             return length_or_error.error();",
          "88:         }",
          "90:         auto tag = tag_or_error.value();",
          "91:         auto length = length_or_error.value();",
          "93:         auto value_or_error = read_value<ValueType>(tag.class_, tag.kind, length);",
          "94:         if (value_or_error.is_error()) {",
          "95:             m_stack = move(previous_position);",
          "96:             return value_or_error.error();",
          "99:         m_current_tag.clear();",
          "101:         return value_or_error.release_value();",
          "104:     Optional<DecodeError> enter();",
          "105:     Optional<DecodeError> leave();",
          "107: private:",
          "108:     template<typename ValueType, typename DecodedType>",
          "109:     Result<ValueType, DecodeError> with_type_check(DecodedType&& value)",
          "110:     {",
          "111:         if constexpr (requires { ValueType { value }; })",
          "112:             return ValueType { value };",
          "114:         return DecodeError::NonConformingType;",
          "117:     template<typename ValueType, typename DecodedType>",
          "118:     Result<ValueType, DecodeError> with_type_check(Result<DecodedType, DecodeError>&& value_or_error)",
          "119:     {",
          "120:         if (value_or_error.is_error())",
          "121:             return value_or_error.error();",
          "123:         auto&& value = value_or_error.value();",
          "124:         if constexpr (requires { ValueType { value }; })",
          "125:             return ValueType { value };",
          "127:         return DecodeError::NonConformingType;",
          "130:     template<typename ValueType>",
          "131:     Result<ValueType, DecodeError> read_value(Class klass, Kind kind, size_t length)",
          "132:     {",
          "133:         auto data_or_error = read_bytes(length);",
          "134:         if (data_or_error.is_error())",
          "135:             return data_or_error.error();",
          "136:         auto data = data_or_error.value();",
          "138:         if (klass != Class::Universal)",
          "139:             return with_type_check<ValueType>(data);",
          "141:         if (kind == Kind::Boolean)",
          "142:             return with_type_check<ValueType>(decode_boolean(data));",
          "144:         if (kind == Kind::Integer)",
          "145:             return with_type_check<ValueType>(decode_arbitrary_sized_integer(data));",
          "147:         if (kind == Kind::OctetString)",
          "148:             return with_type_check<ValueType>(decode_octet_string(data));",
          "150:         if (kind == Kind::Null)",
          "151:             return with_type_check<ValueType>(decode_null(data));",
          "153:         if (kind == Kind::ObjectIdentifier)",
          "154:             return with_type_check<ValueType>(decode_object_identifier(data));",
          "156:         if (kind == Kind::PrintableString || kind == Kind::IA5String || kind == Kind::UTCTime)",
          "157:             return with_type_check<ValueType>(decode_printable_string(data));",
          "159:         if (kind == Kind::Utf8String)",
          "160:             return with_type_check<ValueType>(StringView { data.data(), data.size() });",
          "162:         if (kind == Kind::BitString)",
          "163:             return with_type_check<ValueType>(decode_bit_string(data));",
          "165:         return with_type_check<ValueType>(data);",
          "168:     Result<Tag, DecodeError> read_tag();",
          "169:     Result<size_t, DecodeError> read_length();",
          "170:     Result<u8, DecodeError> read_byte();",
          "171:     Result<ReadonlyBytes, DecodeError> read_bytes(size_t length);",
          "173:     static Result<bool, DecodeError> decode_boolean(ReadonlyBytes);",
          "174:     static Result<UnsignedBigInteger, DecodeError> decode_arbitrary_sized_integer(ReadonlyBytes);",
          "175:     static Result<StringView, DecodeError> decode_octet_string(ReadonlyBytes);",
          "176:     static Result<std::nullptr_t, DecodeError> decode_null(ReadonlyBytes);",
          "177:     static Result<Vector<int>, DecodeError> decode_object_identifier(ReadonlyBytes);",
          "178:     static Result<StringView, DecodeError> decode_printable_string(ReadonlyBytes);",
          "179:     static Result<Bitmap, DecodeError> decode_bit_string(ReadonlyBytes);",
          "181:     Vector<ReadonlyBytes> m_stack;",
          "182:     Optional<Tag> m_current_tag;",
          "187: template<>",
          "188: struct AK::Formatter<Crypto::ASN1::DecodeError> : Formatter<StringView> {",
          "189:     void format(FormatBuilder&, Crypto::ASN1::DecodeError);",
          "190: };",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/ASN1/PEM.cpp||Userland/Libraries/LibCrypto/ASN1/PEM.cpp": [
          "File: Userland/Libraries/LibCrypto/ASN1/PEM.cpp -> Userland/Libraries/LibCrypto/ASN1/PEM.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <AK/Base64.h>",
          "28: #include <AK/GenericLexer.h>",
          "29: #include <LibCrypto/ASN1/PEM.h>",
          "31: namespace Crypto {",
          "33: ByteBuffer decode_pem(ReadonlyBytes data)",
          "34: {",
          "35:     GenericLexer lexer { data };",
          "36:     ByteBuffer decoded;",
          "39:     enum {",
          "40:         PreStartData,",
          "41:         Started,",
          "42:         Ended,",
          "43:     } state { PreStartData };",
          "44:     while (!lexer.is_eof()) {",
          "45:         switch (state) {",
          "46:         case PreStartData:",
          "47:             if (lexer.consume_specific(\"-----BEGIN\"))",
          "48:                 state = Started;",
          "49:             lexer.consume_line();",
          "50:             break;",
          "51:         case Started: {",
          "52:             if (lexer.consume_specific(\"-----END\")) {",
          "53:                 state = Ended;",
          "54:                 lexer.consume_line();",
          "55:                 break;",
          "56:             }",
          "57:             auto b64decoded = decode_base64(lexer.consume_line().trim_whitespace(TrimMode::Right));",
          "58:             decoded.append(b64decoded.data(), b64decoded.size());",
          "59:             break;",
          "60:         }",
          "61:         case Ended:",
          "62:             lexer.consume_all();",
          "63:             break;",
          "64:         default:",
          "65:             ASSERT_NOT_REACHED();",
          "66:         }",
          "67:     }",
          "69:     return decoded;",
          "70: }",
          "72: }",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/ASN1/PEM.h||Userland/Libraries/LibCrypto/ASN1/PEM.h": [
          "File: Userland/Libraries/LibCrypto/ASN1/PEM.h -> Userland/Libraries/LibCrypto/ASN1/PEM.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: namespace Crypto {",
          "75: }",
          "",
          "[Removed Lines]",
          "35: static inline ByteBuffer decode_pem(ReadonlyBytes data_in, size_t cert_index = 0)",
          "36: {",
          "37:     size_t i { 0 };",
          "38:     size_t start_at { 0 };",
          "39:     size_t idx { 0 };",
          "40:     size_t input_length = data_in.size();",
          "41:     auto alloc_len = input_length / 4 * 3;",
          "42:     auto output = ByteBuffer::create_uninitialized(alloc_len);",
          "44:     for (i = 0; i < input_length; i++) {",
          "45:         if ((data_in[i] == '\\n') || (data_in[i] == '\\r'))",
          "46:             continue;",
          "48:         if (data_in[i] != '-') {",
          "50:             while ((i < input_length) && (data_in[i] != '\\n'))",
          "51:                 i++;",
          "52:             continue;",
          "53:         }",
          "55:         if (data_in[i] == '-') {",
          "56:             auto end_idx = i;",
          "58:             while ((i < input_length) && (data_in[i] != '\\n'))",
          "59:                 i++;",
          "60:             if (start_at) {",
          "61:                 if (cert_index > 0) {",
          "62:                     cert_index--;",
          "63:                     start_at = 0;",
          "64:                 } else {",
          "65:                     idx = decode_b64(data_in.offset(start_at), end_idx - start_at, output);",
          "66:                     break;",
          "67:                 }",
          "68:             } else",
          "69:                 start_at = i + 1;",
          "70:         }",
          "71:     }",
          "72:     return output.slice(0, idx);",
          "73: }",
          "",
          "[Added Lines]",
          "35: ByteBuffer decode_pem(ReadonlyBytes);",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/PK/RSA.cpp||Userland/Libraries/LibCrypto/PK/RSA.cpp": [
          "File: Userland/Libraries/LibCrypto/PK/RSA.cpp -> Userland/Libraries/LibCrypto/PK/RSA.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include <AK/Debug.h>",
          "28: #include <AK/Random.h>",
          "29: #include <LibCrypto/ASN1/ASN1.h>",
          "30: #include <LibCrypto/ASN1/DER.h>",
          "31: #include <LibCrypto/ASN1/PEM.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include <AK/ScopeGuard.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34: namespace Crypto {",
          "35: namespace PK {",
          "38: {",
          "40:     KeyPairType keypair;",
          "70:         }",
          "77:             return keypair;",
          "78:         }",
          "82:     }",
          "91:     }",
          "102:             return keypair;",
          "103:         }",
          "111:     }",
          "115: }",
          "117: void RSA::encrypt(ReadonlyBytes in, Bytes& out)",
          "",
          "[Removed Lines]",
          "37: RSA::KeyPairType RSA::parse_rsa_key(ReadonlyBytes in)",
          "42:     u64 t, x, y, z, tmp_oid[16];",
          "43:     u8 tmp_buf[4096] { 0 };",
          "44:     UnsignedBigInteger n, e, d;",
          "45:     ASN1::List pubkey_hash_oid[2], pubkey[2];",
          "47:     ASN1::set(pubkey_hash_oid[0], ASN1::Kind::ObjectIdentifier, tmp_oid, sizeof(tmp_oid) / sizeof(tmp_oid[0]));",
          "48:     ASN1::set(pubkey_hash_oid[1], ASN1::Kind::Null, nullptr, 0);",
          "52:     ASN1::set(pubkey[0], ASN1::Kind::Sequence, &pubkey_hash_oid, 2);",
          "53:     ASN1::set(pubkey[1], ASN1::Kind::Null, nullptr, 0);",
          "55:     dbgln(\"we were offered {} bytes of input\", in.size());",
          "57:     if (der_decode_sequence(in.data(), in.size(), pubkey, 2)) {",
          "59:         t = 0;",
          "60:         y = 0;",
          "61:         z = 0;",
          "62:         x = 0;",
          "63:         for (; x < pubkey[1].size; ++x) {",
          "64:             y = (y << 1) | tmp_buf[x];",
          "65:             if (++z == 8) {",
          "66:                 tmp_buf[t++] = (u8)y;",
          "67:                 y = 0;",
          "68:                 z = 0;",
          "69:             }",
          "72:         if (!der_decode_sequence_many<2>(tmp_buf, t,",
          "73:                 ASN1::Kind::Integer, 1, &n,",
          "74:                 ASN1::Kind::Integer, 1, &e)) {",
          "76:             dbgln(\"bad pubkey: e={} n={}\", e, n);",
          "80:         keypair.public_key.set(n, e);",
          "81:         return keypair;",
          "85:     if (!der_decode_sequence_many<1>(in.data(), in.size(),",
          "86:             ASN1::Kind::Integer, 1, &n)) {",
          "89:         dbgln(\"that's a death star\");",
          "90:         return keypair;",
          "93:     if (n == 0) {",
          "95:         UnsignedBigInteger zero;",
          "96:         if (!der_decode_sequence_many<4>(in.data(), in.size(),",
          "97:                 ASN1::Kind::Integer, 1, &zero,",
          "98:                 ASN1::Kind::Integer, 1, &n,",
          "99:                 ASN1::Kind::Integer, 1, &e,",
          "100:                 ASN1::Kind::Integer, 1, &d)) {",
          "101:             dbgln(\"bad privkey n={} e={} d={}\", n, e, d);",
          "104:         keypair.private_key.set(n, d, e);",
          "105:         return keypair;",
          "106:     }",
          "107:     if (n == 1) {",
          "109:         dbgln(\"Unsupported key type\");",
          "110:         return keypair;",
          "113:     keypair.public_key.set(n, 65537);",
          "114:     return keypair;",
          "",
          "[Added Lines]",
          "38: static constexpr Array<int, 7> pkcs8_rsa_key_oid { 1, 2, 840, 113549, 1, 1, 1 };",
          "40: RSA::KeyPairType RSA::parse_rsa_key(ReadonlyBytes der)",
          "45:     ASN1::Decoder decoder(der);",
          "53:     {",
          "54:         auto result = decoder.peek();",
          "55:         if (result.is_error()) {",
          "57:             dbgln_if(RSA_PARSE_DEBUG, \"RSA key parse failed: {}\", result.error());",
          "58:             return keypair;",
          "60:         auto tag = result.value();",
          "61:         if (tag.kind != ASN1::Kind::Sequence) {",
          "62:             dbgln_if(RSA_PARSE_DEBUG, \"RSA key parse failed: Expected a Sequence but got {}\", ASN1::kind_name(tag.kind));",
          "68:     {",
          "69:         auto error = decoder.enter();",
          "70:         if (error.has_value()) {",
          "72:             dbgln_if(RSA_PARSE_DEBUG, \"RSA key parse failed: {}\", error.value());",
          "73:             return keypair;",
          "74:         }",
          "77:     bool has_read_error = false;",
          "79:     const auto check_if_pkcs8_rsa_key = [&] {",
          "81:         auto tag_result = decoder.peek();",
          "82:         if (tag_result.is_error()) {",
          "84:             dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#8 public key parse failed: {}\", tag_result.error());",
          "85:             return false;",
          "86:         }",
          "88:         auto tag = tag_result.value();",
          "89:         if (tag.kind != ASN1::Kind::Sequence) {",
          "91:             dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#8 public key parse failed: Expected a Sequence but got {}\", ASN1::kind_name(tag.kind));",
          "92:             return false;",
          "93:         }",
          "96:         auto error = decoder.enter();",
          "97:         if (error.has_value()) {",
          "99:             dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#8 public key parse failed: {}\", error.value());",
          "100:             return false;",
          "101:         }",
          "103:         ScopeGuard leave { [&] {",
          "104:             auto error = decoder.leave();",
          "105:             if (error.has_value()) {",
          "106:                 dbgln_if(RSA_PARSE_DEBUG, \"RSA key parse failed: {}\", error.value());",
          "107:                 has_read_error = true;",
          "108:             }",
          "109:         } };",
          "112:         auto oid_result = decoder.read<Vector<int>>();",
          "113:         if (oid_result.is_error()) {",
          "114:             dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#8 public key parse failed: {}\", oid_result.error());",
          "115:             return false;",
          "116:         }",
          "118:         auto oid = oid_result.release_value();",
          "120:         if (oid != pkcs8_rsa_key_oid) {",
          "122:             dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#8 public key parse failed: Not an RSA key\");",
          "123:             return false;",
          "124:         }",
          "126:         return true;",
          "127:     };",
          "129:     auto integer_result = decoder.read<UnsignedBigInteger>();",
          "131:     if (!integer_result.is_error()) {",
          "132:         auto first_integer = integer_result.release_value();",
          "136:         if (check_if_pkcs8_rsa_key()) {",
          "137:             if (has_read_error)",
          "138:                 return keypair;",
          "140:             auto data_result = decoder.read<StringView>();",
          "141:             if (data_result.is_error()) {",
          "142:                 dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#8 private key parse failed: {}\", data_result.error());",
          "143:                 return keypair;",
          "144:             }",
          "145:             return parse_rsa_key(data_result.value().bytes());",
          "146:         }",
          "148:         if (has_read_error)",
          "149:             return keypair;",
          "153:         if (first_integer == 0) {",
          "155:             auto modulus_result = decoder.read<UnsignedBigInteger>();",
          "156:             if (modulus_result.is_error()) {",
          "157:                 dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#1 private key parse failed: {}\", modulus_result.error());",
          "158:                 return keypair;",
          "159:             }",
          "160:             auto modulus = modulus_result.release_value();",
          "162:             auto public_exponent_result = decoder.read<UnsignedBigInteger>();",
          "163:             if (public_exponent_result.is_error()) {",
          "164:                 dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#1 private key parse failed: {}\", public_exponent_result.error());",
          "165:                 return keypair;",
          "166:             }",
          "167:             auto public_exponent = public_exponent_result.release_value();",
          "169:             auto private_exponent_result = decoder.read<UnsignedBigInteger>();",
          "170:             if (private_exponent_result.is_error()) {",
          "171:                 dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#1 private key parse failed: {}\", private_exponent_result.error());",
          "172:                 return keypair;",
          "173:             }",
          "174:             auto private_exponent = private_exponent_result.release_value();",
          "178:             keypair.private_key = { modulus, move(private_exponent), public_exponent };",
          "179:             keypair.public_key = { move(modulus), move(public_exponent) };",
          "181:             return keypair;",
          "182:         } else if (first_integer == 1) {",
          "184:             dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#1 private key parse failed: Multi-prime key not supported\");",
          "185:             return keypair;",
          "186:         } else {",
          "187:             auto&& modulus = move(first_integer);",
          "190:             auto public_exponent_result = decoder.read<UnsignedBigInteger>();",
          "191:             if (public_exponent_result.is_error()) {",
          "193:                 dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#1 public key parse failed: {}\", public_exponent_result.error());",
          "194:                 return keypair;",
          "195:             }",
          "197:             auto public_exponent = public_exponent_result.release_value();",
          "198:             keypair.public_key.set(move(modulus), move(public_exponent));",
          "203:     } else {",
          "205:         if (!check_if_pkcs8_rsa_key())",
          "206:             return keypair;",
          "208:         if (has_read_error)",
          "209:             return keypair;",
          "212:         auto data_result = decoder.read<Bitmap>();",
          "213:         if (data_result.is_error()) {",
          "214:             dbgln_if(RSA_PARSE_DEBUG, \"RSA PKCS#8 public key parse failed: {}\", data_result.error());",
          "215:             return keypair;",
          "216:         }",
          "219:         auto data = data_result.release_value();",
          "221:         auto padded_data = ByteBuffer::create_zeroed(data.size_in_bytes());",
          "222:         padded_data.overwrite(0, data.data(), data.size_in_bytes());",
          "224:         return parse_rsa_key(padded_data.bytes());",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibCrypto/PK/RSA.h||Userland/Libraries/LibCrypto/PK/RSA.h": [
          "File: Userland/Libraries/LibCrypto/PK/RSA.h -> Userland/Libraries/LibCrypto/PK/RSA.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: namespace Crypto {",
          "37: namespace PK {",
          "39: class RSAPublicKey {",
          "40: public:",
          "44:     {",
          "45:     }",
          "",
          "[Removed Lines]",
          "38: template<typename Integer = u64>",
          "41:     RSAPublicKey(const Integer& n, const Integer& e)",
          "42:         : m_modulus(n)",
          "43:         , m_public_exponent(e)",
          "",
          "[Added Lines]",
          "38: template<typename Integer = UnsignedBigInteger>",
          "41:     RSAPublicKey(Integer n, Integer e)",
          "42:         : m_modulus(move(n))",
          "43:         , m_public_exponent(move(e))",
          "44:         , m_length(m_modulus.trimmed_length() * sizeof(u32))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:     size_t length() const { return m_length; }",
          "58:     void set_length(size_t length) { m_length = length; }",
          "61:     {",
          "65:     }",
          "67: private:",
          "",
          "[Removed Lines]",
          "60:     void set(const Integer& n, const Integer& e)",
          "62:         m_modulus = n;",
          "63:         m_public_exponent = e;",
          "64:         m_length = (n.trimmed_length() * sizeof(u32));",
          "",
          "[Added Lines]",
          "61:     void set(Integer n, Integer e)",
          "63:         m_modulus = move(n);",
          "64:         m_public_exponent = move(e);",
          "65:         m_length = (m_modulus.trimmed_length() * sizeof(u32));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "73: template<typename Integer = UnsignedBigInteger>",
          "74: class RSAPrivateKey {",
          "75: public:",
          "80:     {",
          "81:     }",
          "",
          "[Removed Lines]",
          "76:     RSAPrivateKey(const Integer& n, const Integer& d, const Integer& e)",
          "77:         : m_modulus(n)",
          "78:         , m_private_exponent(d)",
          "79:         , m_public_exponent(e)",
          "",
          "[Added Lines]",
          "77:     RSAPrivateKey(Integer n, Integer d, Integer e)",
          "78:         : m_modulus(move(n))",
          "79:         , m_private_exponent(move(d))",
          "80:         , m_public_exponent(move(e))",
          "81:         , m_length(m_modulus.trimmed_length() * sizeof(u32))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "91:     size_t length() const { return m_length; }",
          "92:     void set_length(size_t length) { m_length = length; }",
          "95:     {",
          "100:     }",
          "102: private:",
          "",
          "[Removed Lines]",
          "94:     void set(const Integer& n, const Integer& d, const Integer& e)",
          "96:         m_modulus = n;",
          "97:         m_private_exponent = d;",
          "98:         m_public_exponent = e;",
          "99:         m_length = (n.length() * sizeof(u32));",
          "",
          "[Added Lines]",
          "96:     void set(Integer n, Integer d, Integer e)",
          "98:         m_modulus = move(n);",
          "99:         m_private_exponent = move(d);",
          "100:         m_public_exponent = move(e);",
          "101:         m_length = m_modulus.trimmed_length() * sizeof(u32);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "120: public:",
          "121:     using KeyPairType = RSAKeyPair<PublicKeyType, PrivateKeyType>;",
          "124:     static KeyPairType generate_key_pair(size_t bits = 256)",
          "125:     {",
          "126:         IntegerType e { 65537 }; // :P",
          "",
          "[Removed Lines]",
          "123:     static KeyPairType parse_rsa_key(ReadonlyBytes);",
          "",
          "[Added Lines]",
          "125:     static KeyPairType parse_rsa_key(ReadonlyBytes der);",
          "",
          "---------------"
        ],
        "Userland/Libraries/LibTLS/TLSv12.cpp||Userland/Libraries/LibTLS/TLSv12.cpp": [
          "File: Userland/Libraries/LibTLS/TLSv12.cpp -> Userland/Libraries/LibTLS/TLSv12.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "839:     if (certificate_pem_buffer.is_empty() || rsa_key.is_empty()) {",
          "840:         return true;",
          "841:     }",
          "843:     if (decoded_certificate.is_empty()) {",
          "844:         dbgln(\"Certificate not PEM\");",
          "845:         return false;",
          "",
          "[Removed Lines]",
          "842:     auto decoded_certificate = Crypto::decode_pem(certificate_pem_buffer, 0);",
          "",
          "[Added Lines]",
          "842:     auto decoded_certificate = Crypto::decode_pem(certificate_pem_buffer);",
          "",
          "---------------"
        ],
        "Userland/Utilities/test-crypto.cpp||Userland/Utilities/test-crypto.cpp": [
          "File: Userland/Utilities/test-crypto.cpp -> Userland/Utilities/test-crypto.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "1971: static void rsa_test_der_parse()",
          "1972: {",
          "1975: MIIBOgIBAAJBAJsrIYHxs1YL9tpfodaWs1lJoMdF4kgFisUFSj6nvBhJUlmBh607AlgTaX0E",
          "1976: DGPYycXYGZ2n6rqmms5lpDXBpUcCAwEAAQJAUNpPkmtEHDENxsoQBUXvXDYeXdePSiIBJhpU",
          "1977: joNOYoR5R9z5oX2cpcyykQ58FC2vKKg+x8N6xczG7qO95tw5UQIhAN354CP/FA+uTeJ6KJ+i",
          "",
          "[Removed Lines]",
          "1973:     I_TEST((RSA | ASN1 DER / PEM encoded Key import));",
          "1974:     auto privkey = R\"(-----BEGIN RSA PRIVATE KEY-----",
          "",
          "[Added Lines]",
          "1973:     {",
          "1974:         I_TEST((RSA | ASN1 PKCS1 DER / PEM encoded Key import));",
          "1975:         auto privkey = R\"(-----BEGIN RSA PRIVATE KEY-----",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1980: nrDlBQpuxz7bwSyQO7UCIHrYMnDohgNbwtA5ZpW3H1cKKQQvueWm6sxW9P5sUrZ3",
          "1981: -----END RSA PRIVATE KEY-----)\";",
          "1991:     }",
          "1992: }",
          "",
          "[Removed Lines]",
          "1983:     Crypto::PK::RSA rsa(privkey);",
          "1984:     if (rsa.public_key().public_exponent() == 65537) {",
          "1985:         if (rsa.private_key().private_exponent() == \"4234603516465654167360850580101327813936403862038934287300450163438938741499875303761385527882335478349599685406941909381269804396099893549838642251053393\"_bigint) {",
          "1986:             PASS;",
          "1987:         } else",
          "1988:             FAIL(Invalid private exponent);",
          "1989:     } else {",
          "1990:         FAIL(Invalid public exponent);",
          "",
          "[Added Lines]",
          "1984:         Crypto::PK::RSA rsa(privkey);",
          "1985:         if (rsa.public_key().public_exponent() == 65537) {",
          "1986:             if (rsa.private_key().private_exponent() == \"4234603516465654167360850580101327813936403862038934287300450163438938741499875303761385527882335478349599685406941909381269804396099893549838642251053393\"_bigint) {",
          "1987:                 PASS;",
          "1988:             } else",
          "1989:                 FAIL(Invalid private exponent);",
          "1990:         } else {",
          "1991:             FAIL(Invalid public exponent);",
          "1992:         }",
          "1993:     }",
          "1995:     {",
          "1996:         I_TEST((RSA | ASN1 PKCS8 DER / PEM encoded Key import));",
          "1997:         auto privkey = R\"(-----BEGIN PRIVATE KEY-----",
          "1998: MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQC7ZBYaG9+CcJP7",
          "1999: WVFJRI/uw3hljc7WpzeYs8MN82/g9CG1gnEF3P3ZSBdWVr8gnbh05EsSGHKghIce",
          "2000: CB7DNrM5Ab0ru04CuODdPx56xCj+4MmzTc/aq79ntmOt131NGHgq9yVwfJqnSpyl",
          "2001: OoVw7j/Wg4ciwPDQaeLmD1BsE/W9UsF1km7DWasBpW5br82DpudKgJq2Ixf52+rY",
          "2002: TCkMgyWcetx4MfXll4y5ZVtJXCnHJfkCS64EaCqXmClP4ovOuHH4khJ3rW9j4yuL",
          "2003: e5ck3PSXOrtOTR43HZkCXzseCkbW7qKSmk/9ZreImOzOgu8vvw7ewLAQR9qYVS6X",
          "2004: PXY8IilDAgMBAAECggEBAIV3ld5mt90Z/exqA2Fh+fofMyNxyz5Lv2d9sZHAL5FT",
          "2005: kKbND18TtaIKnMSb6Gl8rKJk76slyo7Vlb8oHXEBBsm1mV0KfVenAlHS4QyjpmdT",
          "2006: B5Yz97VR2nQuDfUFpHNC2GQRv5LMzQIWPFfaxKxYpRNOfvOb5Gks4bTmd2tjFAYR",
          "2007: MCbHgPw1liKA9dYKk4NB0301EY05e4Zz8RjqYHkkmOPD7DnjFbHqcFUjVKK5E3vD",
          "2008: WjxNXUbiSudCCN7WLEOyeHZNd+l6kSAVxZuCAp0G3Da5ndXgIStcy4hYi/fL3XQQ",
          "2009: bNpxjfhsjlD3tdHNr3NNYDAqxcxpsyO1NCpCIW3ZVrECgYEA7l6gTZ3e9AiSNlMd",
          "2010: 2O2vNnbQ6UZfsEfu2y7HmpCuNJkFkAnM/1h72Krejnn31rRuR6uCFn4YgQUN9Eq0",
          "2011: E1PJCtTay2ucZw5rqtkewT9QzXvVD9eiGM+MF89UzSCC+dOW0/odkD+xP2evnPvG",
          "2012: PbXztnuERC1pi0YWLj1YcsfsEX0CgYEAyUA2UtYjnvCcteIy+rURT0aoZ9tDMrG+",
          "2013: Es42EURVv1sduVdUst5R+bXx1aDzpCkcdni3TyxeosvTGAZngI3O8ghh1GV7NPZR",
          "2014: nkiPXjMnhL0Zf+X9gCA6TFANfPuWhMSGijYsCd46diKGDReGYUnmcN9XopeG1h6i",
          "2015: 3JiOuVPAIb8CgYBmIcUtfGb6yHFdNV+kgrJ/84ivaqe1MBz3bKO5ZiQ+BRKNFKXx",
          "2016: AkiOHSgeg8PdCpH1w1aJrJ1zKmdANIHThiKtsWXNot3wig03tq+mvSox4Mz5bLrX",
          "2017: RpYP3ZXIDhYQVMhbKt9f3upi8FoeOQJHjp5Nob6aN5rxQaZfSYmMJHzRQQKBgQCO",
          "2018: ALwUGTtLNBYvlKtKEadkG8RKfAFfbOFkXZLy/hfPDRjdJY0DJTIMk+BPT+F6rPOD",
          "2019: eMxHllQ0ZMPPiP1RTT5/s4BsISsdhMy0dhiLbGbvF4s9nugPly3rmPTbgp6DkjQo",
          "2020: o+7RC7iOkO+rnzTXwxBSBpXMiUTAIx/hrdfPVxQT+wKBgCh7N3OLIOH6EWcW1fif",
          "2021: UoENh8rkt/kzm89G1JLwBhuBIBPXUEZt2dS/xSUempqVqFGONpP87gvqxkMTtgCA",
          "2022: 73KXn/cxHWM2kmXyHA3kQlOYw6WHjpldQAxLE+TRHXO2JUtZ09Mu4rVXX7lmwbTm",
          "2023: l3vmuDEF3/Bo1C1HTg0xRV/l",
          "2024: -----END PRIVATE KEY-----)\";",
          "2026:         Crypto::PK::RSA rsa(privkey);",
          "2027:         if (rsa.public_key().public_exponent() == 65537) {",
          "2028:             if (rsa.private_key().private_exponent() == \"16848664331299797559656678180469464902267415922431923391961407795209879741791261105581093539484181644099608161661780611501562625272630894063592208758992911105496755004417051031019663332258403844985328863382168329621318366311519850803972480500782200178279692319955495383119697563295214236936264406600739633470565823022975212999060908747002623721589308539473108154612454595201561671949550531384574873324370774408913092560971930541734744950937900805812300970883306404011323308000168926094053141613790857814489531436452649384151085451448183385611208320292948291211969430321231180227006521681776197974694030147965578466993\"_bigint) {",
          "2029:                 PASS;",
          "2030:             } else",
          "2031:                 FAIL(Invalid private exponent);",
          "2032:         } else {",
          "2033:             FAIL(Invalid public exponent);",
          "2034:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4d40864b9dc3837c00b1d02b567d6a648e0048f2",
      "candidate_info": {
        "commit_hash": "4d40864b9dc3837c00b1d02b567d6a648e0048f2",
        "repo": "SerenityOS/serenity",
        "commit_url": "https://github.com/SerenityOS/serenity/commit/4d40864b9dc3837c00b1d02b567d6a648e0048f2",
        "files": [
          "AK/Bitmap.h"
        ],
        "message": "AK: Make the Bitmap::size_in_bytes() member function public\n\nIt's annoying to calculate it when it's already a member function.",
        "before_after_code_files": [
          "AK/Bitmap.h||AK/Bitmap.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/SerenityOS/serenity/pull/5344"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "AK/Bitmap.h||AK/Bitmap.h": [
          "File: AK/Bitmap.h -> AK/Bitmap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:     }",
          "84:     size_t size() const { return m_size; }",
          "85:     bool get(size_t index) const",
          "86:     {",
          "87:         ASSERT(index < m_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "85:     size_t size_in_bytes() const { return ceil_div(m_size, static_cast<size_t>(8)); }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "523:     static constexpr u32 max_size = 0xffffffff;",
          "525: private:",
          "528:     u8* m_data { nullptr };",
          "529:     size_t m_size { 0 };",
          "530:     bool m_owned { false };",
          "",
          "[Removed Lines]",
          "526:     size_t size_in_bytes() const { return ceil_div(m_size, static_cast<size_t>(8)); }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
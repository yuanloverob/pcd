{
  "cve_id": "CVE-2019-15146",
  "cve_desc": "GoPro GPMF-parser 1.2.2 has a heap-based buffer over-read (4 bytes) in GPMF_Next in GPMF_parser.c.",
  "repo": "gopro/gpmf-parser",
  "patch_hash": "341f12cd5b97ab419e53853ca00176457c9f1681",
  "patch_info": {
    "commit_hash": "341f12cd5b97ab419e53853ca00176457c9f1681",
    "repo": "gopro/gpmf-parser",
    "commit_url": "https://github.com/gopro/gpmf-parser/commit/341f12cd5b97ab419e53853ca00176457c9f1681",
    "files": [
      "GPMF_parser.c",
      "GPMF_parser.h",
      "demo/GPMF_demo.c",
      "demo/GPMF_mp4reader.c",
      "demo/GPMF_mp4reader.h"
    ],
    "message": "fixed many security issues with the too crude mp4 reader",
    "before_after_code_files": [
      "GPMF_parser.c||GPMF_parser.c",
      "GPMF_parser.h||GPMF_parser.h",
      "demo/GPMF_demo.c||demo/GPMF_demo.c",
      "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
      "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
    ]
  },
  "patch_diff": {
    "GPMF_parser.c||GPMF_parser.c": [
      "File: GPMF_parser.c -> GPMF_parser.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42: {",
      "43:  if (ms)",
      "44:  {",
      "46:   if (nestsize == 0 && ms->nest_level == 0)",
      "47:    nestsize = ms->buffer_size_longs;",
      "",
      "[Removed Lines]",
      "45:   int32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];",
      "",
      "[Added Lines]",
      "45:   uint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];",
      "",
      "---------------"
    ],
    "GPMF_parser.h||GPMF_parser.h": [
      "File: GPMF_parser.h -> GPMF_parser.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "126:  GPMF_KEY_UNITS =   MAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \"RPM\", \"MPH\", \"km/h\", etc)",
      "127:  GPMF_KEY_SCALE =   MAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.",
      "128:  GPMF_KEY_TYPE =    MAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures",
      "130:  GPMF_KEY_TICK =    MAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds.",
      "131:  GPMF_KEY_TOCK =    MAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds.",
      "132:  GPMF_KEY_EMPTY_PAYLOADS = MAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)",
      "",
      "[Removed Lines]",
      "129:  GPMF_KEY_TOTAL_SAMPLES = MAKEID('T','S','M','P'),//TOTL - Total Sample Count including the current payload",
      "",
      "[Added Lines]",
      "129:  GPMF_KEY_TOTAL_SAMPLES = MAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload",
      "130:  GPMF_KEY_TIME_OFFSET =  MAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)",
      "131:  GPMF_KEY_TIMING_OFFSET = MAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO",
      "132:  GPMF_KEY_TIME_STAMP =  MAKEID('S','T','M','P'),//STMP - Time stamp for the first sample.",
      "133:  GPMF_KEY_TIME_STAMPS =  MAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.)",
      "",
      "---------------"
    ],
    "demo/GPMF_demo.c||demo/GPMF_demo.c": [
      "File: demo/GPMF_demo.c -> demo/GPMF_demo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "46:  }",
      "48:  size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);",
      "51:  metadatalength = GetDuration(mp4);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "49:  if (mp4 == 0)",
      "50:  {",
      "51:   printf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);",
      "52:   return -1;",
      "53:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "90:   for (index = 0; index < payloads; index++)",
      "91:   {",
      "92:    uint32_t payloadsize = GetPayloadSize(mp4, index);",
      "94:    payload = GetPayload(mp4, payload, index);",
      "95:    if (payload == NULL)",
      "96:     goto cleanup;",
      "",
      "[Removed Lines]",
      "93:    float in = 0.0, out = 0.0; //times",
      "",
      "[Added Lines]",
      "99:    double in = 0.0, out = 0.0; //times",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "238:   {",
      "239:    if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream",
      "240:    {",
      "241:     uint32_t fourcc = GPMF_Key(ms);",
      "244:    }",
      "245:   }",
      "246: #endif",
      "",
      "[Removed Lines]",
      "242:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);",
      "243:     printf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);",
      "",
      "[Added Lines]",
      "247:     double in = 0.0, out = 0.0;",
      "249:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);",
      "250:     printf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);",
      "",
      "---------------"
    ],
    "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
      "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "26: #include <stdlib.h>",
      "27: #include <stdio.h>",
      "28: #include <string.h>",
      "29: #include <stdint.h>",
      "30: #include \"GPMF_mp4reader.h\"",
      "32: #define PRINT_MP4_STRUCTURE  0",
      "34: #ifdef WIN32",
      "36: #else",
      "38: #endif",
      "",
      "[Removed Lines]",
      "35: #define LONGSEEK  _fseeki64",
      "37: #define LONGSEEK  fseeko",
      "",
      "[Added Lines]",
      "28: #include <sys/types.h>",
      "29: #include <sys/stat.h>",
      "36: #define LONGSEEK _fseeki64",
      "37: #define stat64  _stat64",
      "39: #define LONGSEEK fseeko",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:   if (MP4buffer)",
      "65:   {",
      "69:   }",
      "70:  }",
      "71:  return NULL;",
      "72: }",
      "76: {",
      "82:  {",
      "85:  }",
      "87: }",
      "91: void FreePayload(uint32_t *lastpayload)",
      "92: {",
      "93:  if (lastpayload)",
      "",
      "[Removed Lines]",
      "66:    LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "67:    fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
      "68:    return MP4buffer;",
      "75: void SavePayload(size_t handle, uint32_t *payload, uint32_t index)",
      "77:  mp4object *mp4 = (mp4object *)handle;",
      "78:  if (mp4 == NULL) return;",
      "80:  uint32_t *MP4buffer = NULL;",
      "81:  if (index < mp4->indexcount && mp4->mediafp && payload)",
      "83:   LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "84:   fwrite(payload, 1, mp4->metasizes[index], mp4->mediafp);",
      "86:  return;",
      "",
      "[Added Lines]",
      "67:    if (mp4->filesize > mp4->metaoffsets[index]+mp4->metasizes[index])",
      "68:    {",
      "69:     LONGSEEK(mp4->mediafp, mp4->metaoffsets[index], SEEK_SET);",
      "70:     fread(MP4buffer, 1, mp4->metasizes[index], mp4->mediafp);",
      "71:     mp4->filepos = mp4->metaoffsets[index] + mp4->metasizes[index];",
      "72:     return MP4buffer;",
      "73:    }",
      "80: void LongSeek(mp4object *mp4, int64_t offset)",
      "82:  if (mp4 && offset)",
      "84:   if (mp4->filepos + offset < mp4->filesize)",
      "85:   {",
      "86:    LONGSEEK(mp4->mediafp, offset, SEEK_CUR);",
      "87:    mp4->filepos += offset;",
      "88:   }",
      "89:   else",
      "90:   {",
      "91:    mp4->filepos = mp4->filesize;",
      "92:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "116:  memset(mp4, 0, sizeof(mp4object));",
      "118: #ifdef _WINDOWS",
      "119:  fopen_s(&mp4->mediafp, filename, \"rb\");",
      "120: #else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "124:  struct stat64 mp4stat;",
      "125:  stat64(filename, &mp4stat);",
      "126:  mp4->filesize = mp4stat.st_size;",
      "128:  if (mp4->filesize < 64) return 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "129:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
      "130:   uint64_t lastsize = 0, qtsize;",
      "132:   do",
      "133:   {",
      "134:    len = fread(&qtsize32, 1, 4, mp4->mediafp);",
      "135:    len += fread(&qttag, 1, 4, mp4->mediafp);",
      "137:    {",
      "138:     if (!VALID_FOURCC(qttag))",
      "139:     {",
      "144:     }",
      "146:     qtsize32 = BYTESWAP32(qtsize32);",
      "148:     if (qtsize32 == 1) // 64-bit Atom",
      "149:     {",
      "151:      qtsize = BYTESWAP64(qtsize) - 8;",
      "152:     }",
      "153:     else",
      "",
      "[Removed Lines]",
      "136:    if (len == 8)",
      "140:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
      "142:      NESTSIZE(lastsize - 8);",
      "143:      continue;",
      "150:      fread(&qtsize, 1, 8, mp4->mediafp);",
      "",
      "[Added Lines]",
      "149:    mp4->filepos += len;",
      "150:    if (len == 8 && mp4->filepos < mp4->filesize)",
      "154:      CloseSource((size_t)mp4);",
      "155:      mp4 = NULL;",
      "156:      break;",
      "163:      len = fread(&qtsize, 1, 8, mp4->mediafp);",
      "164:      mp4->filepos += len;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "169:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
      "170:      qttag == MAKEID('f', 't', 'y', 'p') ||",
      "172:     {",
      "175:      NESTSIZE(qtsize);",
      "",
      "[Removed Lines]",
      "171:      qttag == MAKEID('u', 'd', 't', 'a'))",
      "173:      LONGSEEK(mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "185:      qttag == MAKEID('u', 'd', 't', 'a') ||",
      "186:      qttag == MAKEID('f', 'r', 'e', 'e'))",
      "188:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "187:      qttag != MAKEID('d', 'i', 'n', 'f') &&",
      "188:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "189:      qttag != MAKEID('s', 't', 's', 'd') &&",
      "192:      qttag != MAKEID('s', 't', 'b', 'l') &&",
      "193:      qttag != MAKEID('s', 't', 't', 's') &&",
      "194:      qttag != MAKEID('s', 't', 's', 'c') &&",
      "",
      "[Removed Lines]",
      "190:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "191:      qttag != MAKEID('a', 'l', 'i', 's') &&",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "197:      qttag != MAKEID('c', 'o', '6', '4') &&",
      "198:      qttag != MAKEID('h', 'd', 'l', 'r'))",
      "199:     {",
      "202:      NESTSIZE(qtsize);",
      "203:     }",
      "",
      "[Removed Lines]",
      "200:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "213:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "210:       len += fread(&skip, 1, 4, mp4->mediafp);",
      "211:       len += fread(&mp4->clockdemon, 1, 4, mp4->mediafp); mp4->clockdemon = BYTESWAP32(mp4->clockdemon);",
      "212:       len += fread(&mp4->clockcount, 1, 4, mp4->mediafp); mp4->clockcount = BYTESWAP32(mp4->clockcount);",
      "215:       NESTSIZE(qtsize);",
      "216:      }",
      "",
      "[Removed Lines]",
      "213:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
      "",
      "[Added Lines]",
      "227:       mp4->filepos += len;",
      "228:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "233:         mp4->videolength = (float)((double)mp4->trak_clockcount / (double)mp4->trak_clockdemon);",
      "234:        }",
      "235:       }",
      "238:       NESTSIZE(qtsize);",
      "239:      }",
      "",
      "[Removed Lines]",
      "236:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over mvhd",
      "",
      "[Added Lines]",
      "252:       mp4->filepos += len;",
      "253:       LongSeek(mp4, qtsize - 8 - len); // skip over mvhd",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "244:       len += fread(&skip, 1, 4, mp4->mediafp);",
      "245:       len += fread(&temp, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.",
      "248:        type = temp;",
      "252:       NESTSIZE(qtsize);",
      "",
      "[Removed Lines]",
      "247:       if (temp != MAKEID('a', 'l', 'i', 's'))",
      "250:       LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over hldr",
      "",
      "[Added Lines]",
      "264:       if (temp != MAKEID('a', 'l', 'i', 's') && temp != MAKEID('u', 'r', 'l', ' '))",
      "267:       mp4->filepos += len;",
      "268:       LongSeek(mp4, qtsize - 8 - len); // skip over hldr",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "267:          type = 0; // MP4",
      "268:         }",
      "269:        }",
      "271:       }",
      "272:       else",
      "275:       NESTSIZE(qtsize);",
      "276:      }",
      "",
      "[Removed Lines]",
      "270:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsd",
      "273:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "288:        mp4->filepos += len;",
      "289:        LongSeek(mp4, qtsize - 8 - len); // skip over stsd",
      "292:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "286:        {",
      "287:         mp4->metastsc_count = num;",
      "288:         if (mp4->metastsc) free(mp4->metastsc);",
      "291:         {",
      "296:          {",
      "305:         {",
      "309:         }",
      "310:        }",
      "312:       }",
      "313:       else",
      "316:       NESTSIZE(qtsize);",
      "317:      }",
      "",
      "[Removed Lines]",
      "289:         mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
      "290:         if (mp4->metastsc)",
      "292:          uint32_t total_stsc = num;",
      "293:          len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
      "295:          do",
      "297:           num--;",
      "298:           mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
      "299:           mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
      "300:           mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
      "301:          } while (num > 0);",
      "302:         }",
      "304:         if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
      "306:          if (mp4->metastsc) free(mp4->metastsc);",
      "307:          mp4->metastsc = NULL;",
      "308:          mp4->metastsc_count = 0;",
      "311:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsx",
      "314:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "308:         if (num > 0)",
      "310:          mp4->metastsc = (SampleToChunk *)malloc(num * sizeof(SampleToChunk));",
      "311:          if (mp4->metastsc)",
      "313:           len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
      "315:           do",
      "316:           {",
      "317:            num--;",
      "318:            mp4->metastsc[num].chunk_num = BYTESWAP32(mp4->metastsc[num].chunk_num);",
      "319:            mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
      "320:            mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
      "321:           } while (num > 0);",
      "322:          }",
      "323:         }",
      "324:         else",
      "327:          CloseSource((size_t)mp4);",
      "328:          mp4 = NULL;",
      "329:          break;",
      "332:        mp4->filepos += len;",
      "333:        LongSeek(mp4, qtsize - 8 - len); // skip over stsx",
      "336:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "330:        {",
      "331:         mp4->metasize_count = num;",
      "332:         if (mp4->metasizes) free(mp4->metasizes);",
      "335:         {",
      "337:          {",
      "340:           {",
      "349:           {",
      "353:          }",
      "354:         }",
      "355:        }",
      "357:       }",
      "358:       else",
      "361:       NESTSIZE(qtsize);",
      "362:      }",
      "",
      "[Removed Lines]",
      "333:         mp4->metasizes = (uint32_t *)malloc(num * 4);",
      "334:         if (mp4->metasizes)",
      "336:          if (equalsamplesize == 0)",
      "338:           len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
      "339:           do",
      "341:            num--;",
      "342:            mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
      "343:           } while (num > 0);",
      "344:          }",
      "345:          else",
      "346:          {",
      "347:           equalsamplesize = BYTESWAP32(equalsamplesize);",
      "348:           do",
      "350:            num--;",
      "351:            mp4->metasizes[num] = equalsamplesize;",
      "352:           } while (num > 0);",
      "356:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
      "359:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "355:         if(num > 0)",
      "357:          mp4->metasizes = (uint32_t *)malloc(num * 4);",
      "358:          if (mp4->metasizes)",
      "360:           if (equalsamplesize == 0)",
      "362:            len += fread(mp4->metasizes, 1, num * 4, mp4->mediafp);",
      "363:            do",
      "364:            {",
      "365:             num--;",
      "366:             mp4->metasizes[num] = BYTESWAP32(mp4->metasizes[num]);",
      "367:            } while (num > 0);",
      "368:           }",
      "369:           else",
      "371:            equalsamplesize = BYTESWAP32(equalsamplesize);",
      "372:            do",
      "373:            {",
      "374:             num--;",
      "375:             mp4->metasizes[num] = equalsamplesize;",
      "376:            } while (num > 0);",
      "377:           }",
      "380:         else",
      "381:         {",
      "383:          CloseSource((size_t)mp4);",
      "384:          mp4 = NULL;",
      "385:          break;",
      "386:         }",
      "388:        mp4->filepos += len;",
      "389:        LongSeek(mp4, qtsize - 8 - len); // skip over stsz",
      "392:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "369:        num = BYTESWAP32(num);",
      "370:        if (num * 4 <= qtsize - 8 - len)",
      "371:        {",
      "372:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
      "373:         {",
      "375:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "378:          {",
      "382:           {",
      "397:            {",
      "399:             {",
      "411:             {",
      "414:             }",
      "421:            }",
      "428:           }",
      "429:          }",
      "430:         }",
      "431:         else",
      "432:         {",
      "433:          mp4->indexcount = num;",
      "434:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "437:          {",
      "441:           {",
      "445:            {",
      "451:           }",
      "452:          }",
      "453:         }",
      "454:        }",
      "456:       }",
      "457:       else",
      "460:       NESTSIZE(qtsize);",
      "461:      }",
      "",
      "[Removed Lines]",
      "374:          mp4->indexcount = mp4->metasize_count;",
      "376:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "377:          if (mp4->metaoffsets)",
      "379:           uint32_t *metaoffsets32 = NULL;",
      "380:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "381:           if (metaoffsets32)",
      "383:            uint64_t fileoffset = 0;",
      "384:            int stsc_pos = 0;",
      "385:            int stco_pos = 0;",
      "386:            int repeat = 1;",
      "387:            len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "388:            do",
      "389:            {",
      "390:             num--;",
      "391:             metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
      "392:            } while (num > 0);",
      "394:            mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
      "395:            num = 1;",
      "396:            while (num < mp4->metasize_count)",
      "398:             if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)",
      "400:              stco_pos++; stsc_pos++;",
      "401:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "402:              repeat = 1;",
      "403:             }",
      "404:             else if (repeat == mp4->metastsc[stsc_pos].samples)",
      "405:             {",
      "406:              stco_pos++;",
      "407:              fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "408:              repeat = 1;",
      "409:             }",
      "410:             else",
      "412:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "413:              repeat++;",
      "416:             mp4->metaoffsets[num] = fileoffset;",
      "420:             num++;",
      "423:            if (mp4->metastsc) free(mp4->metastsc);",
      "424:            mp4->metastsc = NULL;",
      "425:            mp4->metastsc_count = 0;",
      "427:            free(metaoffsets32);",
      "435:          mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "436:          if (mp4->metaoffsets)",
      "438:           uint32_t *metaoffsets32 = NULL;",
      "439:           metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "440:           if (metaoffsets32)",
      "442:            size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "443:            len += readlen;",
      "444:            do",
      "446:             num--;",
      "447:             mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
      "448:            } while (num > 0);",
      "450:            free(metaoffsets32);",
      "455:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "458:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "405:         uint32_t metastco_count = num;",
      "409:          mp4->indexcount = num;",
      "411:          if(num > 0)",
      "413:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "414:           if (mp4->metaoffsets)",
      "416:            uint32_t *metaoffsets32 = NULL;",
      "417:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "418:            if (metaoffsets32)",
      "420:             uint64_t fileoffset = 0;",
      "421:             int stsc_pos = 0;",
      "422:             int stco_pos = 0;",
      "423:             int repeat = 1;",
      "424:             len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "425:             do",
      "427:              num--;",
      "428:              metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
      "429:             } while (num > 0);",
      "431:             mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
      "432:             num = 1;",
      "433:             while (num < mp4->indexcount)",
      "435:              if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)",
      "436:              {",
      "437:               if ((uint32_t)stco_pos + 1 < metastco_count)",
      "438:               {",
      "439:                stco_pos++;",
      "440:                fileoffset = (uint64_t)metaoffsets32[stco_pos];",
      "441:               }",
      "442:               else",
      "443:               {",
      "444:                fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "445:               }",
      "446:               if ((uint32_t)stsc_pos + 1 < mp4->metastsc_count)",
      "447:                if (mp4->metastsc[stsc_pos + 1].chunk_num == (uint32_t)stco_pos + 1)",
      "448:                 stsc_pos++;",
      "450:               repeat = 1;",
      "451:              }",
      "452:              else",
      "453:              {",
      "454:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "455:               repeat++;",
      "456:              }",
      "458:              mp4->metaoffsets[num] = fileoffset;",
      "462:              num++;",
      "465:             if (mp4->metastsc) free(mp4->metastsc);",
      "466:             mp4->metastsc = NULL;",
      "467:             mp4->metastsc_count = 0;",
      "469:             free(metaoffsets32);",
      "473:          else",
      "474:          {",
      "476:           CloseSource((size_t)mp4);",
      "477:           mp4 = NULL;",
      "478:           break;",
      "479:          }",
      "485:          if (num > 0)",
      "487:           mp4->metaoffsets = (uint64_t *)malloc(num * 8);",
      "488:           if (mp4->metaoffsets)",
      "490:            uint32_t *metaoffsets32 = NULL;",
      "491:            metaoffsets32 = (uint32_t *)malloc(num * 4);",
      "492:            if (metaoffsets32)",
      "494:             size_t readlen = fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
      "495:             len += readlen;",
      "496:             do",
      "497:             {",
      "498:              num--;",
      "499:              mp4->metaoffsets[num] = BYTESWAP32(metaoffsets32[num]);",
      "500:             } while (num > 0);",
      "502:             free(metaoffsets32);",
      "503:            }",
      "506:          else",
      "507:          {",
      "509:           CloseSource((size_t)mp4);",
      "510:           mp4 = NULL;",
      "511:           break;",
      "512:          }",
      "515:        mp4->filepos += len;",
      "516:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "519:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "467:        len = fread(&skip, 1, 4, mp4->mediafp);",
      "468:        len += fread(&num, 1, 4, mp4->mediafp);",
      "469:        num = BYTESWAP32(num);",
      "470:        if (num * 8 <= qtsize - 8 - len)",
      "471:        {",
      "472:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
      "473:         {",
      "474:          mp4->indexcount = mp4->metasize_count;",
      "475:          if (mp4->metaoffsets) free(mp4->metaoffsets);",
      "478:          {",
      "482:           {",
      "488:            {",
      "506:             {",
      "508:             }",
      "515:            }",
      "522:           }",
      "523:          }",
      "524:         }",
      "525:         else",
      "526:         {",
      "",
      "[Removed Lines]",
      "476:          mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "477:          if (mp4->metaoffsets)",
      "479:           uint64_t *metaoffsets64 = NULL;",
      "480:           metaoffsets64 = (uint64_t *)malloc(num * 8);",
      "481:           if (metaoffsets64)",
      "483:            uint64_t fileoffset = 0;",
      "484:            int stsc_pos = 0;",
      "485:            int stco_pos = 0;",
      "486:            len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
      "487:            do",
      "489:             num--;",
      "490:             metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
      "491:            } while (num > 0);",
      "493:            fileoffset = metaoffsets64[0];",
      "494:            mp4->metaoffsets[0] = fileoffset;",
      "497:            num = 1;",
      "498:            while (num < mp4->metasize_count)",
      "499:            {",
      "500:             if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
      "501:             {",
      "502:              stco_pos++;",
      "503:              fileoffset = (uint64_t)metaoffsets64[stco_pos];",
      "504:             }",
      "505:             else",
      "507:              fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "510:             mp4->metaoffsets[num] = fileoffset;",
      "514:             num++;",
      "517:            if (mp4->metastsc) free(mp4->metastsc);",
      "518:            mp4->metastsc = NULL;",
      "519:            mp4->metastsc_count = 0;",
      "521:            free(metaoffsets64);",
      "",
      "[Added Lines]",
      "532:        if(num == 0)",
      "533:        {",
      "535:         CloseSource((size_t)mp4);",
      "536:         mp4 = NULL;",
      "537:         break;",
      "538:        }",
      "546:          if (mp4->metasize_count)",
      "548:           mp4->metaoffsets = (uint64_t *)malloc(mp4->metasize_count * 8);",
      "549:           if (mp4->metaoffsets)",
      "551:            uint64_t *metaoffsets64 = NULL;",
      "552:            metaoffsets64 = (uint64_t *)malloc(num * 8);",
      "553:            if (metaoffsets64)",
      "555:             uint64_t fileoffset = 0;",
      "556:             int stsc_pos = 0;",
      "557:             int stco_pos = 0;",
      "558:             len += fread(metaoffsets64, 1, num * 8, mp4->mediafp);",
      "559:             do",
      "560:             {",
      "561:              num--;",
      "562:              metaoffsets64[num] = BYTESWAP64(metaoffsets64[num]);",
      "563:             } while (num > 0);",
      "565:             fileoffset = metaoffsets64[0];",
      "566:             mp4->metaoffsets[0] = fileoffset;",
      "569:             num = 1;",
      "570:             while (num < mp4->metasize_count)",
      "572:              if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
      "573:              {",
      "574:               stco_pos++;",
      "575:               fileoffset = (uint64_t)metaoffsets64[stco_pos];",
      "576:              }",
      "577:              else",
      "578:              {",
      "579:               fileoffset += (uint64_t)mp4->metasizes[num - 1];",
      "580:              }",
      "582:              mp4->metaoffsets[num] = fileoffset;",
      "586:              num++;",
      "589:             if (mp4->metastsc) free(mp4->metastsc);",
      "590:             mp4->metastsc = NULL;",
      "591:             mp4->metastsc_count = 0;",
      "593:             free(metaoffsets64);",
      "597:          else",
      "598:          {",
      "600:           CloseSource((size_t)mp4);",
      "601:           mp4 = NULL;",
      "602:           break;",
      "603:          }",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "538:          }",
      "539:         }",
      "540:        }",
      "542:       }",
      "543:       else",
      "546:       NESTSIZE(qtsize);",
      "547:      }",
      "",
      "[Removed Lines]",
      "541:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "544:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "621:        mp4->filepos += len;",
      "622:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "625:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "578:         }",
      "579:         mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
      "580:        }",
      "582:       }",
      "583:       else",
      "586:       NESTSIZE(qtsize);",
      "587:      }",
      "",
      "[Removed Lines]",
      "581:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stco",
      "584:        LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "662:        mp4->filepos += len;",
      "663:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
      "666:        LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "595:     break;",
      "596:    }",
      "597:   } while (len > 0);",
      "598:  }",
      "599:  else",
      "600:  {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "681:   if (mp4)",
      "682:   {",
      "683:    if (mp4->metasizes == NULL || mp4->metaoffsets == NULL)",
      "684:    {",
      "685:     CloseSource((size_t)mp4);",
      "686:     mp4 = NULL;",
      "687:    }",
      "688:   }",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "631: }",
      "635: {",
      "636:  mp4object *mp4 = (mp4object *)handle;",
      "644: }",
      "649: size_t OpenMP4SourceUDTA(char *filename)",
      "650: {",
      "",
      "[Removed Lines]",
      "634: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out)",
      "637:  if (mp4 == NULL) return 0;",
      "639:  if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 1;",
      "643:  return 0;",
      "",
      "[Added Lines]",
      "725: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out)",
      "728:  if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
      "730:  if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return GPMF_ERROR_MEMORY;",
      "734:  return GPMF_OK;",
      "738: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)",
      "739: {",
      "740:     mp4object *mp4 = (mp4object *)handle;",
      "741:     if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
      "743:     if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;",
      "749:     return GPMF_OK;",
      "750: }",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "662:  if (mp4->mediafp)",
      "663:  {",
      "665:   int32_t nest = 0;",
      "666:   uint64_t nestsize[MAX_NEST_LEVEL] = { 0 };",
      "667:   uint64_t lastsize = 0, qtsize;",
      "",
      "[Removed Lines]",
      "664:   uint32_t qttag, qtsize32, len;",
      "",
      "[Added Lines]",
      "767:   uint32_t qttag, qtsize32;",
      "768:   size_t len;",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "674:    {",
      "675:     if (!GPMF_VALID_FOURCC(qttag))",
      "676:     {",
      "679:      NESTSIZE(lastsize - 8);",
      "680:      continue;",
      "",
      "[Removed Lines]",
      "677:      LONGSEEK(mp4->mediafp, lastsize - 8 - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "781:      LongSeek(mp4, lastsize - 8 - 8);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "701:     if (qttag == MAKEID('m', 'd', 'a', 't') ||",
      "702:      qttag == MAKEID('f', 't', 'y', 'p'))",
      "703:     {",
      "705:      NESTSIZE(qtsize);",
      "706:      continue;",
      "707:     }",
      "",
      "[Removed Lines]",
      "704:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "808:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "725:     if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms",
      "726:      qttag != MAKEID('u', 'd', 't', 'a'))",
      "727:     {",
      "729:      NESTSIZE(qtsize);",
      "730:      continue;",
      "731:     }",
      "",
      "[Removed Lines]",
      "728:      LONGSEEK(mp4->mediafp, qtsize - 8, SEEK_CUR);",
      "",
      "[Added Lines]",
      "832:      LongSeek(mp4, qtsize - 8);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "740: }",
      "744: {",
      "745:  mp4object *mp4 = (mp4object *)handle;",
      "746:  if (mp4 == NULL) return 0.0;",
      "",
      "[Removed Lines]",
      "743: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)",
      "",
      "[Added Lines]",
      "847: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *firstsampletime, double *lastsampletime)",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "750:  uint32_t testend = mp4->indexcount;",
      "751:  double rate = 0.0;",
      "753:  if (mp4->indexcount < 1)",
      "754:   return 0.0;",
      "766:  if (ret != GPMF_OK)",
      "767:   goto cleanup;",
      "769:  {",
      "770:   uint32_t startsamples = 0;",
      "771:   uint32_t endsamples = 0;",
      "775:   {",
      "777:    teststart++;",
      "778:    payload = GetPayload(handle, payload, teststart); // second last payload",
      "779:    payloadsize = GetPayloadSize(handle, teststart);",
      "780:    ret = GPMF_Init(ms, payload, payloadsize);",
      "781:   }",
      "792:   {",
      "794:    GPMF_stream find_stream;",
      "795:    GPMF_CopyState(ms, &find_stream);",
      "798:    {",
      "802:     payloadsize = GetPayloadSize(handle, testend);",
      "803:     ret = GPMF_Init(ms, payload, payloadsize);",
      "808:     {",
      "811:      {",
      "815:      }",
      "816:     }",
      "819:    }",
      "821:    {",
      "830:     {",
      "839:      {",
      "844:       {",
      "850:         {",
      "867:        {",
      "875:        }",
      "876:       }",
      "877:      }",
      "889:      {",
      "899: #if 0",
      "901:      {",
      "905:      }",
      "917:    }",
      "952:  }",
      "969:  return rate;",
      "970: }",
      "",
      "[Removed Lines]",
      "756:  if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies.",
      "757:  {",
      "758:   teststart++;",
      "759:   testend--;",
      "760:  }",
      "762:  uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload",
      "763:  uint32_t payloadsize = GetPayloadSize(handle, teststart);",
      "764:  int32_t ret = GPMF_Init(ms, payload, payloadsize);",
      "772:   uint32_t missing_samples = 0;",
      "774:   while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "776:    missing_samples = 1;",
      "783:   if (missing_samples)",
      "784:   {",
      "785:    teststart++;   //samples after sensor start are statistically the best",
      "786:    payload = GetPayload(handle, payload, teststart);",
      "787:    payloadsize = GetPayloadSize(handle, teststart);",
      "788:    ret = GPMF_Init(ms, payload, payloadsize);",
      "789:   }",
      "791:   if (ret == GPMF_OK)",
      "793:    uint32_t samples = GPMF_Repeat(ms);",
      "797:    if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "799:     startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;",
      "801:     payload = GetPayload(handle, payload, testend); // second last payload",
      "804:     if (ret != GPMF_OK)",
      "805:      goto cleanup;",
      "807:     if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "809:      GPMF_CopyState(ms, &find_stream);",
      "810:      if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "812:       endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "813:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "814:       goto cleanup;",
      "818:     rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "820:    else // for increased precision, for older GPMF streams sometimes missing the total sample count",
      "822:     uint32_t payloadpos = 0, payloadcount = 0;",
      "823:     double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
      "824:     uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
      "825:     memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
      "827:     samples = 0;",
      "829:     for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)",
      "831:      payload = GetPayload(handle, payload, payloadpos); // second last payload",
      "832:      payloadsize = GetPayloadSize(handle, payloadpos);",
      "833:      ret = GPMF_Init(ms, payload, payloadsize);",
      "835:      if (ret != GPMF_OK)",
      "836:       goto cleanup;",
      "838:      if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "840:       GPMF_stream find_stream2;",
      "841:       GPMF_CopyState(ms, &find_stream2);",
      "843:       if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats",
      "845:        if (repeatarray)",
      "846:        {",
      "847:         float in, out;",
      "849:         do",
      "851:          samples++;",
      "852:         } while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));",
      "854:         repeatarray[payloadpos] = samples;",
      "855:         meanY += (double)samples;",
      "857:         GetPayloadTime(handle, payloadpos, &in, &out);",
      "858:         meanX += out;",
      "859:        }",
      "860:       }",
      "861:       else",
      "862:       {",
      "863:        uint32_t repeat = GPMF_Repeat(ms);",
      "864:        samples += repeat;",
      "866:        if (repeatarray)",
      "868:         float in, out;",
      "870:         repeatarray[payloadpos] = samples;",
      "871:         meanY += (double)samples;",
      "873:         GetPayloadTime(handle, payloadpos, &in, &out);",
      "874:         meanX += out;",
      "878:     }",
      "883:     if (repeatarray)",
      "884:     {",
      "885:      meanY /= (double)payloadcount;",
      "886:      meanX /= (double)payloadcount;",
      "888:      for (payloadpos = teststart; payloadpos < testend; payloadpos++)",
      "890:       float in, out;",
      "891:       GetPayloadTime(handle, payloadpos, &in, &out);",
      "893:       top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);",
      "894:       bot += ((double)out - meanX)*((double)out - meanX);",
      "895:      }",
      "897:      slope = top / bot;",
      "902:       double intercept;",
      "903:       intercept = meanY - slope*meanX;",
      "904:       printf(\"%c%c%c%c start offset = %f (%.3fms)\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);",
      "906: #endif",
      "907:      rate = slope;",
      "908:     }",
      "909:     else",
      "910:     {",
      "911:      rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "912:     }",
      "914:     free(repeatarray);",
      "916:     goto cleanup;",
      "918:   }",
      "919:  }",
      "921: cleanup:",
      "922:  if (payload)",
      "923:  {",
      "924:   FreePayload(payload);",
      "925:   payload = NULL;",
      "926:  }",
      "928:  return rate;",
      "929: }",
      "932: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double rate, uint32_t index, double *in, double *out)",
      "933: {",
      "934:  mp4object *mp4 = (mp4object *)handle;",
      "935:  if (mp4 == NULL) return 0.0;",
      "937:  uint32_t key, insamples;",
      "938:  uint32_t repeat, outsamples;",
      "939:  GPMF_stream find_stream;",
      "941:  if (gs == NULL || mp4->metaoffsets == 0 || mp4->indexcount == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in == NULL || out == NULL) return 0.0;",
      "943:  key = GPMF_Key(gs);",
      "944:  repeat = GPMF_Repeat(gs);",
      "945:  if (rate == 0.0)",
      "946:   rate = GetGPMFSampleRate(handle, key, GPMF_SAMPLE_RATE_FAST);",
      "948:  if (rate == 0.0)",
      "949:  {",
      "951:   return 0.0;",
      "954:  GPMF_CopyState(gs, &find_stream);",
      "955:  if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "956:  {",
      "957:   outsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "958:   insamples = outsamples - repeat;",
      "962:  }",
      "963:  else",
      "964:  {",
      "968:  }",
      "",
      "[Added Lines]",
      "857:  uint32_t *payload;",
      "858:  uint32_t payloadsize;",
      "859:  int32_t ret;",
      "864:  payload = GetPayload(handle, NULL, teststart);",
      "865:  payloadsize = GetPayloadSize(handle, teststart);",
      "866:  ret = GPMF_Init(ms, payload, payloadsize);",
      "872:   uint64_t minimumtimestamp = 0;",
      "873:   uint64_t starttimestamp = 0;",
      "874:   uint64_t endtimestamp = 0;",
      "877:   double intercept = 0.0;",
      "881:   while (teststart < mp4->indexcount && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "889:   if (ret == GPMF_OK && payload)",
      "891:    uint32_t samples = GPMF_PayloadSampleCount(ms);",
      "894:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "895:     startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;",
      "897:    GPMF_CopyState(ms, &find_stream);",
      "898:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))",
      "899:     starttimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));",
      "901:    if (starttimestamp) // is this earliest in the payload, examine the other streams in this early payload.",
      "903:     GPMF_stream any_stream;",
      "904:     GPMF_Init(&any_stream, payload, payloadsize);",
      "906:     minimumtimestamp = starttimestamp;",
      "907:     while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))",
      "908:     {",
      "909:      uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));",
      "910:      if (timestamp < minimumtimestamp)",
      "911:       minimumtimestamp = timestamp;",
      "912:     }",
      "913:    }",
      "915:    testend = mp4->indexcount;",
      "916:    do",
      "917:    {",
      "918:     testend--;// last payload with the fourcc needed",
      "919:     payload = GetPayload(handle, payload, testend);",
      "922:    } while (testend > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
      "924:    GPMF_CopyState(ms, &find_stream);",
      "925:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
      "926:     endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));",
      "927:    else // If there is no TSMP we have to count the samples.",
      "928:    {",
      "929:     uint32_t i;",
      "930:     for (i = teststart; i <= testend; i++)",
      "932:      payload = GetPayload(handle,payload, i); // second last payload",
      "933:      payloadsize = GetPayloadSize(handle, i);",
      "934:      if (GPMF_OK == GPMF_Init(ms, payload, payloadsize))",
      "935:       if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "936:        endsamples += GPMF_PayloadSampleCount(ms);",
      "937:     }",
      "938:    }",
      "940:    if (starttimestamp != 0)",
      "941:    {",
      "942:     uint32_t last_samples = GPMF_PayloadSampleCount(ms);",
      "943:     uint32_t totaltimestamped_samples = endsamples - last_samples - startsamples;",
      "944:     double time_stamp_scale = 1000000000.0; // scan for nanoseconds, microseconds to seconds, all base 10.",
      "946:     GPMF_CopyState(ms, &find_stream);",
      "947:     if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))",
      "948:      endtimestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&find_stream));",
      "950:     if (endtimestamp)",
      "951:     {",
      "952:      double approxrate = 0.0;",
      "953:      if (endsamples > startsamples)",
      "954:       approxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "956:      if (approxrate == 0.0)",
      "957:       approxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "960:      while (time_stamp_scale >= 1)",
      "962:       rate = (double)(totaltimestamped_samples) / ((double)(endtimestamp - starttimestamp) / time_stamp_scale);",
      "963:       if (rate*0.9 < approxrate && approxrate < rate*1.1)",
      "964:        break;",
      "966:       time_stamp_scale *= 0.1;",
      "968:      if (time_stamp_scale < 1.0) rate = 0.0;",
      "969:      intercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;",
      "973:    if (rate == 0.0) //Timestamps didn't help weren't available",
      "975:     if (!(flags & GPMF_SAMPLE_RATE_PRECISE))",
      "976:     {",
      "977:      if (endsamples > startsamples)",
      "978:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "980:      if (rate == 0.0)",
      "981:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "983:      double in, out;",
      "984:      if (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))",
      "985:       intercept = (double)-in * rate;",
      "986:     }",
      "987:     else // for increased precision, for older GPMF streams sometimes missing the total sample count",
      "989:      uint32_t payloadpos = 0, payloadcount = 0;",
      "990:      double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
      "991:      uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
      "992:      memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
      "994:      samples = 0;",
      "996:      for (payloadpos = teststart; payloadpos <= testend; payloadpos++)",
      "998:       payload = GetPayload(handle, payload, payloadpos); // second last payload",
      "999:       payloadsize = GetPayloadSize(handle, payloadpos);",
      "1000:       ret = GPMF_Init(ms, payload, payloadsize);",
      "1002:       if (ret != GPMF_OK)",
      "1003:        goto cleanup;",
      "1005:       if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))",
      "1007:        GPMF_stream find_stream2;",
      "1008:        GPMF_CopyState(ms, &find_stream2);",
      "1010:        payloadcount++;",
      "1012:        if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats",
      "1013:        {",
      "1014:         if (repeatarray)",
      "1016:          double in, out;",
      "1018:          do",
      "1019:          {",
      "1020:           samples++;",
      "1021:          } while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));",
      "1023:          repeatarray[payloadpos] = samples;",
      "1024:          meanY += (double)samples;",
      "1026:          if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1027:           meanX += out;",
      "1028:         }",
      "1029:        }",
      "1030:        else",
      "1032:         uint32_t repeat = GPMF_PayloadSampleCount(ms);",
      "1033:         samples += repeat;",
      "1035:         if (repeatarray)",
      "1036:         {",
      "1037:          double in, out;",
      "1039:          repeatarray[payloadpos] = samples;",
      "1040:          meanY += (double)samples;",
      "1042:          if (GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1043:           meanX += out;",
      "1044:         }",
      "1047:       else",
      "1048:       {",
      "1049:        repeatarray[payloadpos] = 0;",
      "1050:       }",
      "1056:      if (repeatarray)",
      "1058:       meanY /= (double)payloadcount;",
      "1059:       meanX /= (double)payloadcount;",
      "1061:       for (payloadpos = teststart; payloadpos <= testend; payloadpos++)",
      "1062:       {",
      "1063:        double in, out;",
      "1064:        if (repeatarray[payloadpos] && GPMF_OK == GetPayloadTime(handle, payloadpos, &in, &out))",
      "1065:        {",
      "1066:         top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);",
      "1067:         bot += ((double)out - meanX)*((double)out - meanX);",
      "1068:        }",
      "1069:       }",
      "1071:       slope = top / bot;",
      "1072:       rate = slope;",
      "1075:       intercept = meanY - slope * meanX;",
      "1077:       printf(\"%c%c%c%c start offset = %f (%.3fms) rate = %f\\n\", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope, rate);",
      "1078:       printf(\"%c%c%c%c first sample at time %.3fms\\n\", PRINTF_4CC(fourcc), -1000.0 * intercept / slope);",
      "1079: #endif",
      "1080:      }",
      "1081:      else",
      "1083:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
      "1086:      free(repeatarray);",
      "1087:     }",
      "1090:    if (firstsampletime && lastsampletime)",
      "1091:    {",
      "1092:     uint32_t endpayload = mp4->indexcount;",
      "1093:     do",
      "1094:     {",
      "1095:      endpayload--;// last payload with the fourcc needed",
      "1096:      payload = GetPayload(handle, payload, endpayload);",
      "1097:      payloadsize = GetPayloadSize(handle, endpayload);",
      "1098:      ret = GPMF_Init(ms, payload, payloadsize);",
      "1099:     } while (endpayload > 0 && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
      "1101:     if (endpayload > 0 && ret == GPMF_OK)",
      "1102:     {",
      "1103:      uint32_t totalsamples = endsamples - startsamples;",
      "1104:      float timo = 0.0;",
      "1106:      GPMF_CopyState(ms, &find_stream);",
      "1107:      if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TIME_OFFSET, GPMF_CURRENT_LEVEL))",
      "1108:       GPMF_FormattedData(&find_stream, &timo, 4, 0, 1);",
      "1110:      double first, last;",
      "1111:      first = -intercept / rate - timo;",
      "1112:      last = first + (double)totalsamples / rate;",
      "1116:      if (firstsampletime) *firstsampletime = first;",
      "1118:      if (lastsampletime) *lastsampletime = last;",
      "1119:     }",
      "1120:    }",
      "1121:   }",
      "1124: cleanup:",
      "1125:  if (payload)",
      "1126:   FreePayload(payload);",
      "1127:  payload = NULL;",
      "",
      "---------------"
    ],
    "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h": [
      "File: demo/GPMF_mp4reader.h -> demo/GPMF_mp4reader.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "64:  uint32_t meta_clockdemon, meta_clockcount;",
      "65:  double basemetadataduration;",
      "66:  FILE *mediafp;",
      "67: } mp4object;",
      "69: #define MAKEID(a,b,c,d)   (((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "67:  uint64_t filesize;",
      "68:  uint64_t filepos;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "101: float GetDuration(size_t handle);",
      "102: uint32_t GetNumberPayloads(size_t handle);",
      "103: uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);",
      "105: void FreePayload(uint32_t *lastpayload);",
      "106: uint32_t GetPayloadSize(size_t handle, uint32_t index);",
      "109: #define GPMF_SAMPLE_RATE_FAST  0",
      "110: #define GPMF_SAMPLE_RATE_PRECISE 1",
      "115: #ifdef __cplusplus",
      "116: }",
      "",
      "[Removed Lines]",
      "104: void SavePayload(size_t handle, uint32_t *payload, uint32_t index);",
      "107: uint32_t GetPayloadTime(size_t handle, uint32_t index, float *in, float *out); //MP4 timestamps for the payload",
      "112: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags);",
      "113: double GetGPMFSampleRateAndTimes(size_t handle, GPMF_stream *gs, double lastrate, uint32_t index, double *in, double *out); //Jitter corrected sample(s) time, if lastrate is unknown, send 0.0 and it will be computed",
      "",
      "[Added Lines]",
      "108: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload",
      "109: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);",
      "114: double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags, double *in, double *out);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "db2b167c3a11bee912a2815f2c911d41af47f9fa",
      "candidate_info": {
        "commit_hash": "db2b167c3a11bee912a2815f2c911d41af47f9fa",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/db2b167c3a11bee912a2815f2c911d41af47f9fa",
        "files": [
          "demo/GPMF_mp4reader.c"
        ],
        "message": "minor cleanup of stsc buffer",
        "before_after_code_files": [
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "307:        if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
          "308:        {",
          "309:         if (mp4->metastsc) free(mp4->metastsc);",
          "310:         mp4->metastsc_count = 0;",
          "311:        }",
          "312:        LONGSEEK(mp4->mediafp, qtsize - 8 - len, SEEK_CUR); // skip over stsz",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "310:         mp4->metastsc = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "406:           }",
          "408:           if (mp4->metastsc) free(mp4->metastsc);",
          "409:           mp4->metastsc_count = 0;",
          "411:           free(metaoffsets32);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "410:           mp4->metastsc = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "496:           }",
          "498:           if (mp4->metastsc) free(mp4->metastsc);",
          "499:           mp4->metastsc_count = 0;",
          "501:           free(metaoffsets64);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "501:           mp4->metastsc = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8e72cb2e00a5afaad2662851ebb3085b1ceefcad",
      "candidate_info": {
        "commit_hash": "8e72cb2e00a5afaad2662851ebb3085b1ceefcad",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/8e72cb2e00a5afaad2662851ebb3085b1ceefcad",
        "files": [
          "demo/GPMF_mp4reader.c"
        ],
        "message": "Fix for reading stsc and stco",
        "before_after_code_files": [
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "285:        mp4->metastsc = (SampleToChunk *)malloc(num * 12);",
          "286:        if (mp4->metastsc)",
          "287:        {",
          "288:         len += fread(mp4->metastsc, 1, num * sizeof(SampleToChunk), mp4->mediafp);",
          "290:         do",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "288:         uint32_t total_stsc = num;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "294:          mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
          "295:          mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
          "296:         } while (num > 0);",
          "297:        }",
          "299:        if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "300:         mp4->metastsc[0].id = 0;",
          "301:         for (uint32_t i = 1; i < total_stsc; i++)",
          "302:         {",
          "303:          mp4->metastsc[i].id = mp4->metastsc[i-1].id + mp4->metastsc[i-1].samples;",
          "304:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "376:            metaoffsets32[num] = BYTESWAP32(metaoffsets32[num]);",
          "377:           } while (num > 0);",
          "383:           num = 1;",
          "384:           while (num < mp4->metasize_count)",
          "385:           {",
          "387:            {",
          "388:             stco_pos++;",
          "389:             fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "",
          "[Removed Lines]",
          "379:           fileoffset = metaoffsets32[0];",
          "380:           mp4->metaoffsets[0] = fileoffset;",
          "386:            if (num != mp4->metastsc[stsc_pos].chunk_num - 1 && 0 == (num - (mp4->metastsc[stsc_pos].chunk_num - 1)) % mp4->metastsc[stsc_pos].samples)",
          "",
          "[Added Lines]",
          "387:           mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
          "391:            if(num == mp4->metastsc[stco_pos+1].id)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "50d4198a062ef7af70b53a1dbd7cd44adf55aee4",
      "candidate_info": {
        "commit_hash": "50d4198a062ef7af70b53a1dbd7cd44adf55aee4",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/50d4198a062ef7af70b53a1dbd7cd44adf55aee4",
        "files": [
          "demo/GPMF_mp4reader.c"
        ],
        "message": "Fixed stat vs _stat64 issue with non-Windows builds",
        "before_after_code_files": [
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: #ifdef WIN32",
          "36: #define LONGSEEK _fseeki64",
          "38: #else",
          "39: #define LONGSEEK fseeko",
          "40: #endif",
          "",
          "[Removed Lines]",
          "37: #define stat64  _stat64",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:  if (mp4 == NULL) return 0;",
          "122:  memset(mp4, 0, sizeof(mp4object));",
          "126:  mp4->filesize = mp4stat.st_size;",
          "128:  if (mp4->filesize < 64) return 0;",
          "130: #ifdef _WINDOWS",
          "",
          "[Removed Lines]",
          "124:  struct stat64 mp4stat;",
          "125:  stat64(filename, &mp4stat);",
          "",
          "[Added Lines]",
          "122: #ifdef _WINDOWS",
          "123:  struct _stat64 mp4stat;",
          "124:  _stat64(filename, &mp4stat);",
          "125: #else",
          "126:  struct stat mp4stat;",
          "127:  stat(filename, &mp4stat);",
          "128: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dedfdb38dd4d3528298af575fd1e5204982205fd",
      "candidate_info": {
        "commit_hash": "dedfdb38dd4d3528298af575fd1e5204982205fd",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/dedfdb38dd4d3528298af575fd1e5204982205fd",
        "files": [
          "demo/GPMF_mp4reader.c"
        ],
        "message": "Fixed 'stsc' atom handling",
        "before_after_code_files": [
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ],
          "candidate": [
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c"
          ]
        }
      },
      "candidate_diff": {
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "295:          mp4->metastsc[num].samples = BYTESWAP32(mp4->metastsc[num].samples);",
          "296:          mp4->metastsc[num].id = BYTESWAP32(mp4->metastsc[num].id);",
          "297:         } while (num > 0);",
          "305:        }",
          "307:        if (mp4->metastsc_count == 1 && mp4->metastsc[0].samples == 1) // Simplify if the stsc is not reporting any grouped chunks.",
          "",
          "[Removed Lines]",
          "300:         mp4->metastsc[0].id = 0;",
          "301:         for (uint32_t i = 1; i < total_stsc; i++)",
          "302:         {",
          "303:          mp4->metastsc[i].id = mp4->metastsc[i-1].id + mp4->metastsc[i-1].samples;",
          "304:         }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "378:           uint64_t fileoffset = 0;",
          "379:           int stsc_pos = 0;",
          "380:           int stco_pos = 0;",
          "381:           len += fread(metaoffsets32, 1, num * 4, mp4->mediafp);",
          "382:           do",
          "383:           {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "374:           int repeat = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "389:           num = 1;",
          "390:           while (num < mp4->metasize_count)",
          "391:           {",
          "393:            {",
          "394:             stco_pos++;",
          "395:             fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "396:            }",
          "397:            else",
          "398:            {",
          "399:             fileoffset += (uint64_t)mp4->metasizes[num - 1];",
          "400:            }",
          "402:            mp4->metaoffsets[num] = fileoffset;",
          "",
          "[Removed Lines]",
          "392:            if(num == mp4->metastsc[stco_pos+1].id)",
          "",
          "[Added Lines]",
          "386:            if (stsc_pos + 1 < (int)mp4->metastsc_count && num == stsc_pos)",
          "387:            {",
          "388:             stco_pos++; stsc_pos++;",
          "389:             fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "390:             repeat = 1;",
          "391:            }",
          "392:            else if (repeat == mp4->metastsc[stsc_pos].samples)",
          "396:             repeat = 1;",
          "401:             repeat++;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb13056e5ce3ddbefce90dabc36316e2cd592218",
      "candidate_info": {
        "commit_hash": "fb13056e5ce3ddbefce90dabc36316e2cd592218",
        "repo": "gopro/gpmf-parser",
        "commit_url": "https://github.com/gopro/gpmf-parser/commit/fb13056e5ce3ddbefce90dabc36316e2cd592218",
        "files": [
          "GPMF_parser.c",
          "GPMF_parser.h",
          "demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c",
          "demo/GPMF_mp4reader.h",
          "demo/GPMF_print.c",
          "demo/makefile"
        ],
        "message": "master from develop",
        "before_after_code_files": [
          "GPMF_parser.c||GPMF_parser.c",
          "GPMF_parser.h||GPMF_parser.h",
          "demo/GPMF_demo.c||demo/GPMF_demo.c",
          "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
          "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h",
          "demo/GPMF_print.c||demo/GPMF_print.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "GPMF_parser.c||GPMF_parser.c",
            "GPMF_parser.h||GPMF_parser.h",
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
            "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
          ],
          "candidate": [
            "GPMF_parser.c||GPMF_parser.c",
            "GPMF_parser.h||GPMF_parser.h",
            "demo/GPMF_demo.c||demo/GPMF_demo.c",
            "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c",
            "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h"
          ]
        }
      },
      "candidate_diff": {
        "GPMF_parser.c||GPMF_parser.c": [
          "File: GPMF_parser.c -> GPMF_parser.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: #include <stdint.h>",
          "27: #include \"GPMF_parser.h\"",
          "30: #ifdef DBG",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: #include \"GPMF_bitstream.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "191: {",
          "192:  if(ms && buffer && datasize > 0)",
          "193:  {",
          "200:  }",
          "202:  return GPMF_ERROR_MEMORY;",
          "",
          "[Removed Lines]",
          "194:   ms->buffer = buffer;",
          "195:   ms->buffer_size_longs = (datasize+3)>>2;",
          "197:   GPMF_ResetState(ms);",
          "199:   return GPMF_OK;",
          "",
          "[Added Lines]",
          "195:   int pos = 0;",
          "197:   while((pos+1) * 4 < datasize && buffer[pos] == GPMF_KEY_DEVICE)",
          "198:   {",
          "199:    uint32_t size = GPMF_DATA_SIZE(buffer[pos+1]);",
          "200:    pos += 2 + (size >> 2);",
          "201:   }",
          "202:   if (pos * 4 == datasize)",
          "203:   {",
          "204:    ms->buffer = buffer;",
          "205:    ms->buffer_size_longs = (datasize + 3) >> 2;",
          "206:    ms->cbhandle = 0;",
          "208:    GPMF_ResetState(ms);",
          "210:    return GPMF_OK;",
          "211:   }",
          "212:   else",
          "213:   {",
          "214:    return GPMF_ERROR_BAD_STRUCTURE;",
          "215:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "425:   else",
          "426:   {",
          "427:    count = GPMF_Repeat(ms);",
          "428:   }",
          "429:  }",
          "430:  return count;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "444:    if (count == 0) // this can happen with an empty FACE, yet this is still a FACE fouce",
          "445:     count = 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "544: }",
          "548: {",
          "549:  if (ms && ms->pos+1 < ms->buffer_size_longs)",
          "550:  {",
          "552:   return type;",
          "553:  }",
          "555: }",
          "",
          "[Removed Lines]",
          "547: uint32_t GPMF_Type(GPMF_stream *ms)",
          "551:   uint32_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos+1]);",
          "554:  return 0;",
          "",
          "[Added Lines]",
          "565: GPMF_SampleType GPMF_Type(GPMF_stream *ms)",
          "569:   GPMF_SampleType type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos+1]);",
          "570:   if (type == GPMF_TYPE_COMPRESSED && ms->pos+2 < ms->buffer_size_longs)",
          "571:   {",
          "572:    type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 2]);",
          "573:   }",
          "576:  return GPMF_TYPE_ERROR;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "560:  if (ms && ms->pos+1 < ms->buffer_size_longs)",
          "561:  {",
          "562:   uint32_t ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);",
          "567:   return ssize;",
          "568:  }",
          "569:  return 0;",
          "",
          "[Removed Lines]",
          "563:   uint32_t size = (GPMF_DATA_SIZE(ms->buffer[ms->pos + 1]) >> 2);",
          "565:   if (GPMF_OK != IsValidSize(ms, size)) return 0; // as the structure is corrupted. i.e. GPMF_ERROR_BAD_STRUCTURE;",
          "",
          "[Added Lines]",
          "585:   uint32_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "586:   if (type == GPMF_TYPE_COMPRESSED && ms->pos+2 < ms->buffer_size_longs)",
          "587:   {",
          "588:    ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 2]);",
          "589:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "574: {",
          "575:  if (ms && ms->pos+1 < ms->buffer_size_longs)",
          "576:  {",
          "581:   {",
          "582:    int32_t tsize = GPMF_SizeofType(type);",
          "583:    if (tsize > 0)",
          "",
          "[Removed Lines]",
          "577:   uint32_t ssize = GPMF_StructSize(ms);",
          "578:   GPMF_SampleType type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "580:   if (type != GPMF_TYPE_NEST && type != GPMF_TYPE_COMPLEX)",
          "",
          "[Added Lines]",
          "600:   uint32_t ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);",
          "601:   GPMF_SampleType type = (GPMF_SampleType) GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "603:   if (type != GPMF_TYPE_NEST && type != GPMF_TYPE_COMPLEX && type != GPMF_TYPE_COMPRESSED)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "602:      return tmpsize;",
          "603:    }",
          "604:   }",
          "605:  }",
          "606:  return 0;",
          "607: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "627:   if (type == GPMF_TYPE_COMPRESSED && ms->pos+2 < ms->buffer_size_longs)",
          "628:   {",
          "629:    type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 2]);",
          "630:    ssize = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 2]);",
          "631:    int32_t tsize = GPMF_SizeofType(type);",
          "632:    if (tsize > 0)",
          "633:     return ssize / tsize;",
          "634:    else",
          "635:     return 0;",
          "636:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "611: {",
          "612:  if (ms && ms->pos+1 < ms->buffer_size_longs)",
          "613:  {",
          "614:   uint32_t repeat = GPMF_SAMPLES(ms->buffer[ms->pos + 1]);",
          "615:   return repeat;",
          "616:  }",
          "617:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "646:   GPMF_SampleType type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "648:   if(type == GPMF_TYPE_COMPRESSED && ms->pos+2 < ms->buffer_size_longs)",
          "649:   {",
          "650:    repeat = GPMF_SAMPLES(ms->buffer[ms->pos + 2]);",
          "651:   }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "629:  return 0;",
          "630: }",
          "633: uint32_t GPMF_NestLevel(GPMF_stream *ms)",
          "634: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "669: uint32_t GPMF_FormattedDataSize(GPMF_stream *ms)",
          "670: {",
          "671:  if (ms && ms->pos + 1 < ms->buffer_size_longs)",
          "672:  {",
          "673:   GPMF_SampleType type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "674:   uint32_t size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1])*GPMF_SAMPLES(ms->buffer[ms->pos + 1]);",
          "676:   if (type == GPMF_TYPE_COMPRESSED && ms->pos+2 < ms->buffer_size_longs)",
          "677:   {",
          "678:    size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 2])*GPMF_SAMPLES(ms->buffer[ms->pos + 2]);",
          "679:   }",
          "680:   return size;",
          "681:  }",
          "682:  return 0;",
          "683: }",
          "685: uint32_t GPMF_ScaledDataSize(GPMF_stream *ms, GPMF_SampleType type)",
          "686: {",
          "687:  if (ms && ms->pos + 1 < ms->buffer_size_longs)",
          "688:  {",
          "689:   uint32_t elements = GPMF_ElementsInStruct(ms);",
          "690:   uint32_t samples = GPMF_Repeat(ms);",
          "691:   return GPMF_SizeofType(type) * elements * samples;",
          "692:  }",
          "693:  return 0;",
          "694: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "680: {",
          "681:  uint32_t ssize = 0;",
          "684:  {",
          "685:  case GPMF_TYPE_STRING_ASCII:  ssize = 1; break;",
          "686:  case GPMF_TYPE_SIGNED_BYTE:   ssize = 1; break;",
          "",
          "[Removed Lines]",
          "683:  switch ((int)type)",
          "",
          "[Added Lines]",
          "746:  switch (type)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "703:  case GPMF_TYPE_GUID:    ssize = 16; break;",
          "704:  case GPMF_TYPE_UTC_DATE_TIME:  ssize = 16; break;",
          "705:  }",
          "707:  return ssize;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "768:  default: ssize = 0; break;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "813:   if (GPMF_OK != IsValidSize(ms, remaining_sample_size>>2))",
          "814:    return GPMF_ERROR_BAD_STRUCTURE;",
          "816:   if (sample_size * read_samples > buffersize)",
          "817:    return GPMF_ERROR_MEMORY;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "880:   if (type == GPMF_TYPE_COMPRESSED)",
          "881:   {",
          "882:    if (GPMF_OK == GPMF_Decompress(ms, (uint32_t *)output, buffersize))",
          "883:    {",
          "884:     uint32_t compressed_typesize = ms->buffer[ms->pos + 2];",
          "885:     sample_size = GPMF_SAMPLE_SIZE(compressed_typesize);",
          "886:     remaining_sample_size = GPMF_DATA_PACKEDSIZE(compressed_typesize);",
          "887:     type = GPMF_SAMPLE_TYPE(compressed_typesize);",
          "888:     data = output;",
          "889:    }",
          "890:    else",
          "891:     return GPMF_ERROR_MEMORY;",
          "892:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "876:       typesize = 0;",
          "877:      }",
          "878:      else",
          "880:     }",
          "882:     switch (typesize)",
          "",
          "[Removed Lines]",
          "879:       typesize = GPMF_SizeofType(complextype[i]);",
          "",
          "[Added Lines]",
          "957:       typesize = GPMF_SizeofType((GPMF_SampleType) complextype[i]);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "936: #define MACRO_CAST_SCALE_UNSIGNED_TYPE(casttype)  \\",
          "937: {                            \\",
          "938:  casttype *tmp = (casttype *)output;                   \\",
          "940:  {                           \\",
          "948:  default: break;                        \\",
          "949:  }                           \\",
          "950:  output = (uint8_t *)tmp;                     \\",
          "",
          "[Removed Lines]",
          "939:  switch (scaletype)                       \\",
          "941:  case GPMF_TYPE_SIGNED_BYTE:  *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int8_t *)scaledata8); break; \\",
          "942:  case GPMF_TYPE_UNSIGNED_BYTE: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint8_t *)scaledata8); break; \\",
          "943:  case GPMF_TYPE_SIGNED_SHORT: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int16_t *)scaledata8); break; \\",
          "944:  case GPMF_TYPE_UNSIGNED_SHORT: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint16_t *)scaledata8); break; \\",
          "945:  case GPMF_TYPE_SIGNED_LONG:  *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int32_t *)scaledata8); break; \\",
          "946:  case GPMF_TYPE_UNSIGNED_LONG: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint32_t *)scaledata8); break;  \\",
          "947:  case GPMF_TYPE_FLOAT:   *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((float *)scaledata8); break; \\",
          "",
          "[Added Lines]",
          "1017:  switch (scal_type)                       \\",
          "1019:  case GPMF_TYPE_SIGNED_BYTE:  *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int8_t *)scal_data8); break; \\",
          "1020:  case GPMF_TYPE_UNSIGNED_BYTE: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint8_t *)scal_data8); break; \\",
          "1021:  case GPMF_TYPE_SIGNED_SHORT: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int16_t *)scal_data8); break; \\",
          "1022:  case GPMF_TYPE_UNSIGNED_SHORT: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint16_t *)scal_data8); break; \\",
          "1023:  case GPMF_TYPE_SIGNED_LONG:  *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((int32_t *)scal_data8); break; \\",
          "1024:  case GPMF_TYPE_UNSIGNED_LONG: *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((uint32_t *)scal_data8); break;  \\",
          "1025:  case GPMF_TYPE_FLOAT:   *tmp++ = (casttype)(*val < 0 ? 0 : *val) / (casttype)*((float *)scal_data8); break; \\",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "953: #define MACRO_CAST_SCALE_SIGNED_TYPE(casttype)  \\",
          "954: {                           \\",
          "955:  casttype *tmp = (casttype *)output;                  \\",
          "957:  {                          \\",
          "965:  default: break;                       \\",
          "966:  }                          \\",
          "967:  output = (uint8_t *)tmp;                    \\",
          "",
          "[Removed Lines]",
          "956:  switch (scaletype)                      \\",
          "958:  case GPMF_TYPE_SIGNED_BYTE:  *tmp++ = (casttype)*val / (casttype)*((int8_t *)scaledata8); break; \\",
          "959:  case GPMF_TYPE_UNSIGNED_BYTE: *tmp++ = (casttype)*val / (casttype)*((uint8_t *)scaledata8); break; \\",
          "960:  case GPMF_TYPE_SIGNED_SHORT: *tmp++ = (casttype)*val / (casttype)*((int16_t *)scaledata8); break; \\",
          "961:  case GPMF_TYPE_UNSIGNED_SHORT: *tmp++ = (casttype)*val / (casttype)*((uint16_t *)scaledata8); break; \\",
          "962:  case GPMF_TYPE_SIGNED_LONG:  *tmp++ = (casttype)*val / (casttype)*((int32_t *)scaledata8); break; \\",
          "963:  case GPMF_TYPE_UNSIGNED_LONG: *tmp++ = (casttype)*val / (casttype)*((uint32_t *)scaledata8); break;  \\",
          "964:  case GPMF_TYPE_FLOAT:   *tmp++ = (casttype)*val / (casttype)*((float *)scaledata8);  break; \\",
          "",
          "[Added Lines]",
          "1034:  switch (scal_type)                      \\",
          "1036:  case GPMF_TYPE_SIGNED_BYTE:  *tmp++ = (casttype)*val / (casttype)*((int8_t *)scal_data8); break; \\",
          "1037:  case GPMF_TYPE_UNSIGNED_BYTE: *tmp++ = (casttype)*val / (casttype)*((uint8_t *)scal_data8); break; \\",
          "1038:  case GPMF_TYPE_SIGNED_SHORT: *tmp++ = (casttype)*val / (casttype)*((int16_t *)scal_data8); break; \\",
          "1039:  case GPMF_TYPE_UNSIGNED_SHORT: *tmp++ = (casttype)*val / (casttype)*((uint16_t *)scal_data8); break; \\",
          "1040:  case GPMF_TYPE_SIGNED_LONG:  *tmp++ = (casttype)*val / (casttype)*((int32_t *)scal_data8); break; \\",
          "1041:  case GPMF_TYPE_UNSIGNED_LONG: *tmp++ = (casttype)*val / (casttype)*((uint32_t *)scal_data8); break;  \\",
          "1042:  case GPMF_TYPE_FLOAT:   *tmp++ = (casttype)*val / (casttype)*((float *)scal_data8);  break; \\",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "991:  data = (uint8_t *)datatemp;       \\",
          "992: }",
          "994: GPMF_ERR GPMF_ScaledData(GPMF_stream *ms, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples, GPMF_SampleType outputType)",
          "995: {",
          "996:  if (ms && buffer)",
          "997:  {",
          "998:   uint8_t *data = (uint8_t *)&ms->buffer[ms->pos + 2];",
          "999:   uint8_t *output = (uint8_t *)buffer;",
          "1000:   uint32_t sample_size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 1]);",
          "1001:   uint32_t output_sample_size = GPMF_SizeofType(outputType);",
          "1002:   uint32_t remaining_sample_size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 1]);",
          "1004:   char complextype[64] = \"L\";",
          "1005:   uint32_t inputtypesize = 0;",
          "1006:   uint32_t inputtypeelements = 0;",
          "1013:   uint32_t elements = 1;",
          "1017:   if (type == GPMF_TYPE_NEST)",
          "1018:    return GPMF_ERROR_MEMORY;",
          "1030:   {",
          "1032:    GPMF_stream find_stream;",
          "1033:    GPMF_CopyState(ms, &find_stream);",
          "1035:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_RECURSE_LEVELS))",
          "1036:    {",
          "1037:     char *data1 = (char *)GPMF_RawData(&find_stream);",
          "",
          "[Removed Lines]",
          "1003:   uint8_t type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "1007:   uint8_t scaletype = 0;",
          "1008:   uint8_t scalecount = 0;",
          "1009:   uint32_t scaletypesize = 0;",
          "1010:   uint32_t *scaledata = NULL;",
          "1011:   uint32_t tmpbuffer[64];",
          "1012:   uint32_t tmpbuffersize = sizeof(tmpbuffer);",
          "1015:   type = GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "1020:   if (GPMF_OK != IsValidSize(ms, remaining_sample_size >> 2))",
          "1021:    return GPMF_ERROR_BAD_STRUCTURE;",
          "1023:   remaining_sample_size -= sample_offset * sample_size; // skip samples",
          "1024:   data += sample_offset * sample_size;",
          "1026:   if (remaining_sample_size < sample_size * read_samples)",
          "1027:    return GPMF_ERROR_MEMORY;",
          "1029:   if (type == GPMF_TYPE_COMPLEX)",
          "",
          "[Added Lines]",
          "1072: #define MACRO_NOSWAP_CAST_SCALE(inputcast) \\",
          "1073: {              \\",
          "1074:  inputcast *val;          \\",
          "1075:  inputcast temp,  *datatemp = (inputcast *)data;  \\",
          "1076:  temp = *(inputcast *)data;       \\",
          "1077:  val = (inputcast *)&temp;       \\",
          "1078:  MACRO_CAST_SCALE         \\",
          "1079:  datatemp++;           \\",
          "1080:  data = (uint8_t *)datatemp;       \\",
          "1081: }",
          "1084: #define MACRO_IS_MATRIX_CALIBRATION(inputcast)    \\",
          "1085: {               \\",
          "1086:  uint32_t m;            \\",
          "1087:  inputcast *md = (inputcast *)mtrx_data;     \\",
          "1088:  inputcast one = (inputcast)1;       \\",
          "1089:  inputcast negone = (inputcast)-1;      \\",
          "1090:  mtrx_calibration = 0;         \\",
          "1091:  for (m = 0; m < elements*elements; m++, md++)         \\",
          "1092:  {              \\",
          "1093:   if (*md != one && *md != negone && *md != 0)  \\",
          "1094:    mtrx_calibration = 1;       \\",
          "1095:  }              \\",
          "1096: }",
          "1099: #define MACRO_APPLY_CALIBRATION(matrixcast, outputcast)                  \\",
          "1100: {                               \\",
          "1101:  uint32_t x,y;                           \\",
          "1102:  outputcast tmpbuf[8];                         \\",
          "1103:  outputcast *tmp = (outputcast *)output;                     \\",
          "1104:  tmp -= elements;                          \\",
          "1105:  matrixcast *mtrx = (matrixcast *)mtrx_data;                    \\",
          "1106:  for (y = 0; y < elements; y++) tmpbuf[y] = 0;                   \\",
          "1107:  for (y = 0; y < elements; y++) for (x = 0; x < elements; x++)  tmpbuf[y] += tmp[x] * (outputcast)mtrx[y*elements + x]; \\",
          "1108:  for (y = 0; y < elements; y++) tmp[y] = tmpbuf[y];                  \\",
          "1109: }",
          "1112: #define MACRO_APPLY_MATRIX_CALIBRATION(matrixcast)            \\",
          "1113: {                        \\",
          "1114:  switch (outputType) {                  \\",
          "1115:   case GPMF_TYPE_SIGNED_BYTE:  MACRO_APPLY_CALIBRATION(matrixcast, int8_t)  break; \\",
          "1116:   case GPMF_TYPE_UNSIGNED_BYTE: MACRO_APPLY_CALIBRATION(matrixcast, uint8_t) break; \\",
          "1117:   case GPMF_TYPE_SIGNED_SHORT:  MACRO_APPLY_CALIBRATION(matrixcast, int16_t) break; \\",
          "1118:   case GPMF_TYPE_UNSIGNED_SHORT: MACRO_APPLY_CALIBRATION(matrixcast, uint16_t) break; \\",
          "1119:   case GPMF_TYPE_SIGNED_LONG:  MACRO_APPLY_CALIBRATION(matrixcast, int32_t) break; \\",
          "1120:   case GPMF_TYPE_UNSIGNED_LONG: MACRO_APPLY_CALIBRATION(matrixcast, uint32_t) break; \\",
          "1121:   case GPMF_TYPE_FLOAT:   MACRO_APPLY_CALIBRATION(matrixcast, float)  break; \\",
          "1122:   case GPMF_TYPE_DOUBLE:   MACRO_APPLY_CALIBRATION(matrixcast, double)  break; \\",
          "1123:   default: break;                   \\",
          "1124:  }                       \\",
          "1125: }",
          "1127: #define MACRO_SET_MATRIX(matrixcast, orin, orio, pos) \\",
          "1128: {              \\",
          "1129:  matrixcast *mtrx = (matrixcast *)mtrx_data;   \\",
          "1130:  if (orin == orio)         \\",
          "1131:   mtrx[pos] = (matrixcast)1;      \\",
          "1132:  else if ((orin - 'a') == (orio - 'A'))    \\",
          "1133:   mtrx[pos] = (matrixcast)-1;      \\",
          "1134:  else if ((orin - 'A') == (orio - 'a'))    \\",
          "1135:   mtrx[pos] = (matrixcast)-1;      \\",
          "1136:  else            \\",
          "1137:   mtrx[pos] = 0;         \\",
          "1138: }",
          "1146:   GPMF_ERR ret = GPMF_OK;",
          "1152:   GPMF_SampleType type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "1157:   uint8_t scal_type = 0;",
          "1158:   uint8_t scal_count = 0;",
          "1159:   uint32_t scal_typesize = 0;",
          "1160:   uint32_t *scal_data = NULL;",
          "1161:   uint32_t scal_buffer[64];",
          "1162:   uint32_t scal_buffersize = sizeof(scal_buffer);",
          "1164:   uint8_t mtrx_type = 0;",
          "1165:   uint8_t mtrx_count = 0;",
          "1166:   uint32_t mtrx_typesize = 0;",
          "1167:   uint32_t mtrx_sample_size = 0;",
          "1168:   uint32_t *mtrx_data = NULL;",
          "1169:   uint32_t mtrx_buffer[64];",
          "1170:   uint32_t mtrx_buffersize = sizeof(mtrx_buffer);",
          "1171:   uint32_t mtrx_calibration = 0;",
          "1173:   char *orin_data = NULL;",
          "1174:   uint32_t orin_len = 0;",
          "1175:   char *orio_data = NULL;",
          "1176:   uint32_t orio_len = 0;",
          "1178:   uint32_t *uncompressedSamples = NULL;",
          "1180:   uint32_t noswap = 0;",
          "1182:   type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 1]);",
          "1187:   if (type == GPMF_TYPE_COMPRESSED)",
          "1188:   {",
          "1189:    int neededunc = GPMF_FormattedDataSize(ms);",
          "1190:    int samples = GPMF_Repeat(ms);",
          "1192:    remaining_sample_size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 2]);",
          "1194:    uncompressedSamples = (uint32_t *)malloc(neededunc + 12);",
          "1195:    if (uncompressedSamples)",
          "1196:    {",
          "1197:     if (GPMF_OK == GPMF_FormattedData(ms, uncompressedSamples, neededunc, 0, samples))",
          "1198:     {",
          "1199:      read_samples = samples;",
          "1200:      elements = GPMF_ElementsInStruct(ms);",
          "1201:      type = GPMF_Type(ms);",
          "1202:      complextype[0] = (char)type;",
          "1203:      inputtypesize = GPMF_SizeofType((GPMF_SampleType)type);",
          "1204:      if (inputtypesize == 0)",
          "1205:      {",
          "1206:       ret = GPMF_ERROR_MEMORY;",
          "1207:       goto cleanup;",
          "1208:      }",
          "1209:      inputtypeelements = 1;",
          "1210:      noswap = 1; // data is formatted to LittleEndian",
          "1212:      data = (uint8_t *)uncompressedSamples;",
          "1214:      remaining_sample_size -= sample_offset * sample_size; // skip samples",
          "1215:      data += sample_offset * sample_size;",
          "1217:      if (remaining_sample_size < sample_size * read_samples)",
          "1218:       return GPMF_ERROR_MEMORY;",
          "1220:     }",
          "1221:    }",
          "1222:   }",
          "1223:   else if (type == GPMF_TYPE_COMPLEX)",
          "1229:    remaining_sample_size -= sample_offset * sample_size; // skip samples",
          "1230:    data += sample_offset * sample_size;",
          "1232:    if (remaining_sample_size < sample_size * read_samples)",
          "1233:     return GPMF_ERROR_MEMORY;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1052:   }",
          "1053:   else",
          "1054:   {",
          "1055:    complextype[0] = type;",
          "1057:    if (inputtypesize == 0)",
          "1058:     return GPMF_ERROR_MEMORY;",
          "1059:    inputtypeelements = 1;",
          "",
          "[Removed Lines]",
          "1056:    inputtypesize = GPMF_SizeofType(type);",
          "",
          "[Added Lines]",
          "1256:    remaining_sample_size -= sample_offset * sample_size; // skip samples",
          "1257:    data += sample_offset * sample_size;",
          "1259:    if (remaining_sample_size < sample_size * read_samples)",
          "1260:     return GPMF_ERROR_MEMORY;",
          "1263:    inputtypesize = GPMF_SizeofType((GPMF_SampleType) type);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1081:    if (GPMF_OK == GPMF_FindPrev(&fs, GPMF_KEY_SCALE, GPMF_CURRENT_LEVEL))",
          "1082:    {",
          "1087:     {",
          "1088:     case GPMF_TYPE_SIGNED_BYTE:",
          "1089:     case GPMF_TYPE_UNSIGNED_BYTE:",
          "",
          "[Removed Lines]",
          "1083:     scaledata = (uint32_t *)GPMF_RawData(&fs);",
          "1084:     scaletype = GPMF_SAMPLE_TYPE(fs.buffer[fs.pos + 1]);",
          "1086:     switch (scaletype)",
          "",
          "[Added Lines]",
          "1290:     scal_data = (uint32_t *)GPMF_RawData(&fs);",
          "1291:     scal_type = GPMF_SAMPLE_TYPE(fs.buffer[fs.pos + 1]);",
          "1293:     switch (scal_type)",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1092:     case GPMF_TYPE_SIGNED_LONG:",
          "1093:     case GPMF_TYPE_UNSIGNED_LONG:",
          "1094:     case GPMF_TYPE_FLOAT:",
          "1105:      break;",
          "1106:     default:",
          "1107:      return GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "",
          "[Removed Lines]",
          "1095:      scalecount = GPMF_SAMPLES(fs.buffer[fs.pos + 1]);",
          "1096:      scaletypesize = GPMF_SizeofType(scaletype);",
          "1098:      if (scalecount > 1)",
          "1099:       if (scalecount != elements)",
          "1100:        return GPMF_ERROR_SCALE_COUNT;",
          "1102:      GPMF_FormattedData(&fs, tmpbuffer, tmpbuffersize, 0, scalecount);",
          "1104:      scaledata = (uint32_t *)tmpbuffer;",
          "",
          "[Added Lines]",
          "1302:      scal_count = GPMF_SAMPLES(fs.buffer[fs.pos + 1]);",
          "1303:      scal_typesize = GPMF_SizeofType((GPMF_SampleType)scal_type);",
          "1305:      if (scal_count > 1)",
          "1306:      {",
          "1307:       if (scal_count != elements)",
          "1308:       {",
          "1309:        ret = GPMF_ERROR_SCALE_COUNT;",
          "1310:        goto cleanup;",
          "1311:       }",
          "1312:      }",
          "1314:      GPMF_FormattedData(&fs, scal_buffer, scal_buffersize, 0, scal_count);",
          "1316:      scal_data = (uint32_t *)scal_buffer;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1110:    }",
          "1111:    else",
          "1112:    {",
          "1117:    }",
          "1118:   }",
          "1120:   while (read_samples--)",
          "1121:   {",
          "1122:    uint32_t i;",
          "1125:    for (i = 0; i < elements; i++)",
          "1126:    {",
          "1128:     {",
          "1141:     }",
          "1144:    }",
          "1145:   }",
          "1146:   break;",
          "1148:   default:",
          "1150:    break;",
          "1151:   }",
          "1153:   return GPMF_OK;",
          "1154:  }",
          "1156:  return GPMF_ERROR_MEMORY;",
          "1157: }",
          "",
          "[Removed Lines]",
          "1113:     scaletype = 'L';",
          "1114:     scalecount = 1;",
          "1115:     tmpbuffer[0] = 1; // set the scale to 1 is no scale was provided",
          "1116:     scaledata = (uint32_t *)tmpbuffer;",
          "1123:    uint8_t *scaledata8 = (uint8_t *)scaledata;",
          "1127:     switch (complextype[i % inputtypeelements])",
          "1129:     case GPMF_TYPE_FLOAT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, float, uint32_t) break;",
          "1130:     case GPMF_TYPE_SIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, int8_t, uint8_t) break;",
          "1131:     case GPMF_TYPE_UNSIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, uint8_t, uint8_t) break;",
          "1132:     case GPMF_TYPE_SIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, int16_t, uint16_t) break;",
          "1133:     case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, uint16_t, uint16_t) break;",
          "1134:     case GPMF_TYPE_SIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, int32_t, uint32_t) break;",
          "1135:     case GPMF_TYPE_UNSIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, uint32_t, uint32_t) break;",
          "1136:     case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;",
          "1137:     case GPMF_TYPE_UNSIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;",
          "1138:     default:",
          "1139:      return GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "1140:      break;",
          "1142:     if (scalecount > 1)",
          "1143:      scaledata8 += scaletypesize;",
          "1149:    return GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "",
          "[Added Lines]",
          "1325:     scal_type = 'L';",
          "1326:     scal_count = 1;",
          "1327:     scal_buffer[0] = 1; // set the scale to 1 is no scale was provided",
          "1328:     scal_data = (uint32_t *)scal_buffer;",
          "1329:    }",
          "1331:    GPMF_CopyState(ms, &fs);",
          "1332:    if (GPMF_OK == GPMF_FindPrev(&fs, GPMF_KEY_MATRIX, GPMF_CURRENT_LEVEL))",
          "1333:    {",
          "1334:     uint32_t mtrx_found_size = 0;",
          "1335:     uint32_t matrix_size = elements * elements;",
          "1336:     mtrx_data = (uint32_t *)GPMF_RawData(&fs);",
          "1337:     mtrx_type = GPMF_SAMPLE_TYPE(fs.buffer[fs.pos + 1]);",
          "1339:     switch (mtrx_type)",
          "1340:     {",
          "1341:     case GPMF_TYPE_SIGNED_BYTE:",
          "1342:     case GPMF_TYPE_UNSIGNED_BYTE:",
          "1343:     case GPMF_TYPE_SIGNED_SHORT:",
          "1344:     case GPMF_TYPE_UNSIGNED_SHORT:",
          "1345:     case GPMF_TYPE_SIGNED_LONG:",
          "1346:     case GPMF_TYPE_UNSIGNED_LONG:",
          "1347:     case GPMF_TYPE_FLOAT:",
          "1348:     case GPMF_TYPE_DOUBLE:",
          "1349:      mtrx_count = GPMF_SAMPLES(fs.buffer[fs.pos + 1]);",
          "1350:      mtrx_sample_size = GPMF_SAMPLE_SIZE(fs.buffer[fs.pos + 1]);",
          "1351:      mtrx_typesize = GPMF_SizeofType((GPMF_SampleType)mtrx_type);",
          "1352:      mtrx_found_size = mtrx_count * mtrx_sample_size / mtrx_typesize;",
          "1353:      if (mtrx_found_size != matrix_size)  // e.g XYZ is a 3x3 matrix, RGBA is a 4x4 matrix",
          "1354:      {",
          "1355:       ret = GPMF_ERROR_SCALE_COUNT;",
          "1356:       goto cleanup;",
          "1357:      }",
          "1359:      GPMF_FormattedData(&fs, mtrx_buffer, mtrx_buffersize, 0, mtrx_count);",
          "1360:      mtrx_data = (uint32_t *)mtrx_buffer;",
          "1361:      break;",
          "1362:     default:",
          "1363:      return GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "1364:      break;",
          "1365:     }",
          "1367:     switch (mtrx_type)",
          "1368:     {",
          "1369:     case GPMF_TYPE_SIGNED_BYTE:  MACRO_IS_MATRIX_CALIBRATION(int8_t) break;",
          "1370:     case GPMF_TYPE_UNSIGNED_BYTE:  MACRO_IS_MATRIX_CALIBRATION(uint8_t) break;",
          "1371:     case GPMF_TYPE_SIGNED_SHORT:  MACRO_IS_MATRIX_CALIBRATION(int16_t) break;",
          "1372:     case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_IS_MATRIX_CALIBRATION(uint16_t) break;",
          "1373:     case GPMF_TYPE_SIGNED_LONG:  MACRO_IS_MATRIX_CALIBRATION(int32_t) break;",
          "1374:     case GPMF_TYPE_UNSIGNED_LONG:  MACRO_IS_MATRIX_CALIBRATION(uint32_t) break;",
          "1375:     case GPMF_TYPE_FLOAT: MACRO_IS_MATRIX_CALIBRATION(float); break;",
          "1376:     case GPMF_TYPE_DOUBLE: MACRO_IS_MATRIX_CALIBRATION(double); break;",
          "1377:     }",
          "1378:    }",
          "1380:    if (!mtrx_calibration)",
          "1381:    {",
          "1382:     GPMF_CopyState(ms, &fs);",
          "1383:     if (GPMF_OK == GPMF_FindPrev(&fs, GPMF_KEY_ORIENTATION_IN, GPMF_CURRENT_LEVEL))",
          "1384:     {",
          "1385:      orin_data = (char *)GPMF_RawData(&fs);",
          "1386:      orin_len = GPMF_DATA_PACKEDSIZE(fs.buffer[fs.pos + 1]);",
          "1387:     }",
          "1388:     GPMF_CopyState(ms, &fs);",
          "1389:     if (GPMF_OK == GPMF_FindPrev(&fs, GPMF_KEY_ORIENTATION_OUT, GPMF_CURRENT_LEVEL))",
          "1390:     {",
          "1391:      orio_data = (char *)GPMF_RawData(&fs);",
          "1392:      orio_len = GPMF_DATA_PACKEDSIZE(fs.buffer[fs.pos + 1]);",
          "1393:     }",
          "1394:     if (orio_len == orin_len && orin_len > 1 && orio_len == elements)",
          "1395:     {",
          "1396:      uint32_t x, y, pos = 0;",
          "1397:      mtrx_type = outputType;",
          "1399:      for (y = 0; y < elements; y++)",
          "1400:      {",
          "1401:       for (x = 0; x < elements; x++)",
          "1402:       {",
          "1403:        switch (mtrx_type)",
          "1404:        {",
          "1405:        case GPMF_TYPE_FLOAT:   MACRO_SET_MATRIX(float,       orio_data[y], orin_data[x], pos);  break;",
          "1406:        case GPMF_TYPE_DOUBLE:   MACRO_SET_MATRIX(double,      orio_data[y], orin_data[x], pos);  break;",
          "1407:        case GPMF_TYPE_SIGNED_BYTE:  MACRO_SET_MATRIX(int8_t,      orio_data[y], orin_data[x], pos);   break;",
          "1408:        case GPMF_TYPE_UNSIGNED_BYTE: MACRO_SET_MATRIX(uint8_t,     orio_data[y], orin_data[x], pos);  break;",
          "1409:        case GPMF_TYPE_SIGNED_SHORT: MACRO_SET_MATRIX(int16_t,     orio_data[y], orin_data[x], pos);  break;",
          "1410:        case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_SET_MATRIX(uint16_t,    orio_data[y], orin_data[x], pos);  break;",
          "1411:        case GPMF_TYPE_SIGNED_LONG:  MACRO_SET_MATRIX(int32_t,     orio_data[y], orin_data[x], pos);  break;",
          "1412:        case GPMF_TYPE_UNSIGNED_LONG: MACRO_SET_MATRIX(uint32_t,    orio_data[y], orin_data[x], pos);  break;",
          "1413:        case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_SET_MATRIX(int64_t,   orio_data[y], orin_data[x], pos);  break;",
          "1414:        case GPMF_TYPE_UNSIGNED_64BIT_INT: MACRO_SET_MATRIX(uint64_t, orio_data[y], orin_data[x], pos);  break;",
          "1415:        default:",
          "1416:         ret = GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "1417:         goto cleanup;",
          "1418:         break;",
          "1419:        }",
          "1421:        pos++;",
          "1422:       }",
          "1423:      }",
          "1425:      mtrx_calibration = 1;",
          "1426:     }",
          "1434:    uint8_t *scal_data8 = (uint8_t *)scal_data;",
          "1438:     if (noswap)",
          "1440:      switch (complextype[i % inputtypeelements])",
          "1441:      {",
          "1442:      case GPMF_TYPE_FLOAT:  MACRO_NOSWAP_CAST_SCALE(float) break;",
          "1443:      case GPMF_TYPE_SIGNED_BYTE:  MACRO_NOSWAP_CAST_SCALE(int8_t) break;",
          "1444:      case GPMF_TYPE_UNSIGNED_BYTE:  MACRO_NOSWAP_CAST_SCALE(uint8_t) break;",
          "1445:      case GPMF_TYPE_SIGNED_SHORT:  MACRO_NOSWAP_CAST_SCALE(int16_t) break;",
          "1446:      case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_NOSWAP_CAST_SCALE(uint16_t) break;",
          "1447:      case GPMF_TYPE_SIGNED_LONG:  MACRO_NOSWAP_CAST_SCALE(int32_t) break;",
          "1448:      case GPMF_TYPE_UNSIGNED_LONG:  MACRO_NOSWAP_CAST_SCALE(uint32_t) break;",
          "1449:      case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_NOSWAP_CAST_SCALE(int64_t) break;",
          "1450:      case GPMF_TYPE_UNSIGNED_64BIT_INT:  MACRO_NOSWAP_CAST_SCALE(uint64_t) break;",
          "1451:      default:",
          "1452:       ret = GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "1453:       goto cleanup;",
          "1454:       break;",
          "1455:      }",
          "1456:     }",
          "1457:     else",
          "1458:     {",
          "1459:      switch (complextype[i % inputtypeelements])",
          "1460:      {",
          "1461:      case GPMF_TYPE_FLOAT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, float, uint32_t) break;",
          "1462:      case GPMF_TYPE_SIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, int8_t, uint8_t) break;",
          "1463:      case GPMF_TYPE_UNSIGNED_BYTE:  MACRO_BSWAP_CAST_SCALE(NOSWAP8, uint8_t, uint8_t) break;",
          "1464:      case GPMF_TYPE_SIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, int16_t, uint16_t) break;",
          "1465:      case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP16, uint16_t, uint16_t) break;",
          "1466:      case GPMF_TYPE_SIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, int32_t, uint32_t) break;",
          "1467:      case GPMF_TYPE_UNSIGNED_LONG:  MACRO_BSWAP_CAST_SCALE(BYTESWAP32, uint32_t, uint32_t) break;",
          "1468:      case GPMF_TYPE_SIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, int64_t, uint64_t) break;",
          "1469:      case GPMF_TYPE_UNSIGNED_64BIT_INT:  MACRO_BSWAP_CAST_SCALE(BYTESWAP64, uint64_t, uint64_t) break;",
          "1470:      default:",
          "1471:       ret = GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "1472:       goto cleanup;",
          "1473:       break;",
          "1474:      }",
          "1475:     }",
          "1476:     if (scal_count > 1)",
          "1477:      scal_data8 += scal_typesize;",
          "1478:    }",
          "1481:    if (inputtypeelements == 1)",
          "1482:    {",
          "1483:     if (mtrx_calibration)",
          "1484:     {",
          "1485:      switch (mtrx_type)",
          "1486:      {",
          "1487:      case GPMF_TYPE_SIGNED_BYTE:  MACRO_APPLY_MATRIX_CALIBRATION(int8_t) break;",
          "1488:      case GPMF_TYPE_UNSIGNED_BYTE:  MACRO_APPLY_MATRIX_CALIBRATION(uint8_t) break;",
          "1489:      case GPMF_TYPE_SIGNED_SHORT:  MACRO_APPLY_MATRIX_CALIBRATION(int16_t) break;",
          "1490:      case GPMF_TYPE_UNSIGNED_SHORT:  MACRO_APPLY_MATRIX_CALIBRATION(uint16_t) break;",
          "1491:      case GPMF_TYPE_SIGNED_LONG:  MACRO_APPLY_MATRIX_CALIBRATION(int32_t) break;",
          "1492:      case GPMF_TYPE_UNSIGNED_LONG:  MACRO_APPLY_MATRIX_CALIBRATION(uint32_t) break;",
          "1493:      case GPMF_TYPE_FLOAT: MACRO_APPLY_MATRIX_CALIBRATION(float); break;",
          "1494:      case GPMF_TYPE_DOUBLE: MACRO_APPLY_MATRIX_CALIBRATION(double); break;",
          "1495:      default: break;",
          "1496:      }",
          "1503:    ret = GPMF_ERROR_TYPE_NOT_SUPPORTED;",
          "1504:    goto cleanup;",
          "1508: cleanup:",
          "1509:   if(uncompressedSamples)",
          "1510:    free(uncompressedSamples);",
          "1512:   return ret;",
          "1513:  }",
          "1515:  return GPMF_ERROR_MEMORY;",
          "1516: }",
          "1520: GPMF_ERR GPMF_DecompressedSize(GPMF_stream *ms, uint32_t *neededsize)",
          "1521: {",
          "1522:  if (ms && neededsize)",
          "1523:  {",
          "1525:   return GPMF_OK;",
          "1526:  }",
          "1528:  return GPMF_ERROR_MEMORY;",
          "1529: }",
          "1532: GPMF_ERR GPMF_Decompress(GPMF_stream *ms, uint32_t *localbuf, uint32_t localbuf_size)",
          "1533: {",
          "1534:  if (ms && localbuf && localbuf_size)",
          "1535:  {",
          "1536:   if (ms->cbhandle == 0)",
          "1537:    if (GPMF_OK != GPMF_AllocCodebook(&ms->cbhandle))",
          "1538:     return GPMF_ERROR_MEMORY;",
          "1540:   memset(localbuf, 0, localbuf_size);",
          "1543:   GPMF_SampleType type = (GPMF_SampleType)GPMF_SAMPLE_TYPE(ms->buffer[ms->pos + 2]);// The first 32-bit of data, is the uncomresseded type-size-repeat",
          "1544:   uint8_t *start = (uint8_t *)&ms->buffer[ms->pos + 3];",
          "1545:   uint16_t quant;",
          "1546:   size_t sOffset = 0;",
          "1547:   uint16_t *compressed_data;",
          "1548:   uint32_t sample_size = GPMF_SAMPLE_SIZE(ms->buffer[ms->pos + 2]);",
          "1549:   uint32_t sizeoftype = GPMF_SizeofType(type);",
          "1550:   uint32_t chn = 0, channels = sample_size / sizeoftype;",
          "1552:   uint32_t uncompressed_size = GPMF_DATA_PACKEDSIZE(ms->buffer[ms->pos + 2]);",
          "1553:   uint32_t maxsamples = uncompressed_size / sample_size;",
          "1554:   int signed_type = 1;",
          "1556:   memset(localbuf, 0, localbuf_size);",
          "1558:   GPMF_codebook *cb = (GPMF_codebook *)ms->cbhandle;",
          "1560:   if (sizeoftype == 4) // LONGs are handled at two channels of SHORTs",
          "1561:   {",
          "1562:    sizeoftype = 2;",
          "1563:    channels *= 2;",
          "1565:    if (type == 'l')",
          "1566:     type = GPMF_TYPE_SIGNED_SHORT;",
          "1567:    else",
          "1568:     type = GPMF_TYPE_UNSIGNED_SHORT;",
          "1569:   }",
          "1572:   if (type == GPMF_TYPE_SIGNED_SHORT || type == GPMF_TYPE_SIGNED_BYTE)",
          "1573:    signed_type = -1; //signed",
          "1576:   uint16_t *buf_u16 = (uint16_t *)localbuf;",
          "1577:   int16_t *buf_s16 = (int16_t *)localbuf;",
          "1578:   uint8_t *buf_u8 = (uint8_t *)localbuf;",
          "1579:   int8_t *buf_s8 = (int8_t *)localbuf;",
          "1580:   int last;",
          "1581:   int pos, end = 0;",
          "1583:   memcpy(&buf_u8[0], start, sample_size);",
          "1585:   sOffset += sample_size;",
          "1587:   for (chn = 0; chn<channels; chn++)",
          "1588:   {",
          "1589:    pos = 1;",
          "1591:    switch (sizeoftype*signed_type)",
          "1592:    {",
          "1593:    default:",
          "1594:    case -2: last = BYTESWAP16(buf_s16[chn]); quant = *((uint16_t *)&start[sOffset]); quant = BYTESWAP16(quant); sOffset += 2; break;",
          "1595:    case -1: last = buf_s8[chn]; quant = *((uint8_t *)&start[sOffset]); sOffset++; break;",
          "1596:    case 1: last = buf_u8[chn]; quant = *((uint8_t *)&start[sOffset]); sOffset++; break;",
          "1597:    case 2: last = BYTESWAP16(buf_u16[chn]); quant = *((uint16_t *)&start[sOffset]); quant = BYTESWAP16(quant); sOffset += 2;  break;",
          "1598:    }",
          "1600:    sOffset = ((sOffset + 1) & ~1); //16-bit aligned compressed data",
          "1601:    compressed_data = (uint16_t *)&start[sOffset];",
          "1603:    uint16_t currWord = BYTESWAP16(*compressed_data); compressed_data++;",
          "1604:    uint16_t nextWord = BYTESWAP16(*compressed_data); compressed_data++;",
          "1605:    int currBits = 16;",
          "1606:    int nextBits = 16;",
          "1608:    do",
          "1609:    {",
          "1610:     switch (cb[currWord].command)",
          "1611:     {",
          "1612:     case 0:  // store zeros and/or a value",
          "1613:      {",
          "1614:       int usedbits = cb[currWord].bits_used;",
          "1615:       int zeros = cb[currWord].offset;",
          "1616:       int delta = (int)cb[currWord].value * quant;",
          "1618:       last += delta * cb[currWord].bytes_stored;",
          "1620:       if (pos + zeros >= (int)maxsamples)",
          "1621:       {",
          "1622:        end = 1;",
          "1623:        return GPMF_ERROR_MEMORY;",
          "1624:       }",
          "1625:       switch (sizeoftype*signed_type)",
          "1626:       {",
          "1627:       default:",
          "1628:       case -2:",
          "1629:        while (zeros) { buf_s16[channels*pos++ + chn] = BYTESWAP16(last); zeros--; }",
          "1630:        buf_s16[channels*pos + chn] = BYTESWAP16(last);",
          "1631:        break;",
          "1632:       case -1:",
          "1633:        while (zeros) { buf_s8[channels*pos++ + chn] = (int8_t)last; zeros--; }",
          "1634:        buf_s8[channels*pos + chn] = (int8_t)last;",
          "1635:        break;",
          "1636:       case 1:",
          "1637:        while (zeros) { buf_u8[channels*pos++ + chn] = (uint8_t)last; zeros--; }",
          "1638:        buf_u8[channels*pos + chn] = (uint8_t)last;",
          "1639:        break;",
          "1640:       case 2:",
          "1641:        while (zeros) { buf_u16[channels*pos++ + chn] = BYTESWAP16(last); zeros--; }",
          "1642:        buf_u16[channels*pos + chn] = BYTESWAP16(last);",
          "1643:        break;",
          "1644:       }",
          "1646:       pos += cb[currWord].bytes_stored;",
          "1647:       currWord <<= usedbits;",
          "1648:       currBits -= usedbits;",
          "1649:      }",
          "1650:      break;",
          "1652:     case 1: //channel END code detected, store the remaining zero deltas",
          "1653:      {",
          "1654:       int zeros = ((int)uncompressed_size/(channels*sizeoftype) - pos);",
          "1655:       switch (sizeoftype*signed_type)",
          "1656:       {",
          "1657:       default:",
          "1658:       case -2:",
          "1659:        while (zeros) { buf_s16[channels*pos++ + chn] = BYTESWAP16(last); zeros--; }",
          "1660:        break;",
          "1661:       case -1:",
          "1662:        while (zeros) { buf_s8[channels*pos++ + chn] = (int8_t)last; zeros--; }",
          "1663:        break;",
          "1664:       case 1:",
          "1665:        while (zeros) { buf_u8[channels*pos++ + chn] = (uint8_t)last; zeros--; }",
          "1666:        break;",
          "1667:       case 2:",
          "1668:        while (zeros) { buf_u16[channels*pos++ + chn] = BYTESWAP16(last); zeros--; }",
          "1669:        break;",
          "1670:       }",
          "1671:      }",
          "1672:      end = 1;",
          "1673:      break;",
          "1675:     case 2: //ESC code, next byte or short contains the delta.",
          "1676:      {",
          "1677:       int usedbits = cb[currWord].bits_used;",
          "1678:       int delta;",
          "1679:       currWord <<= usedbits;",
          "1680:       currBits -= usedbits;",
          "1683:       while (currBits < 16)",
          "1684:       {",
          "1685:        int needed = 16 - currBits;",
          "1686:        currWord |= nextWord >> currBits;",
          "1687:        if (nextBits >= needed) currBits = 16; else currBits += nextBits;",
          "1688:        nextWord <<= needed;",
          "1689:        nextBits -= needed;",
          "1690:        if (nextBits <= 0)",
          "1691:        {",
          "1692:         nextWord = BYTESWAP16(*compressed_data);",
          "1693:         compressed_data++;",
          "1694:         nextBits = 16;",
          "1695:        }",
          "1696:       }",
          "1698:       switch (sizeoftype*signed_type)",
          "1699:       {",
          "1700:       default:",
          "1701:       case -2:",
          "1702:        delta = (int16_t)(currWord);",
          "1703:        delta *= quant;",
          "1704:        last += delta;",
          "1705:        buf_s16[channels*pos++ + chn] = BYTESWAP16(last);",
          "1706:        break;",
          "1707:       case -1:",
          "1708:        delta = (int8_t)(currWord >> 8);",
          "1709:        delta *= quant;",
          "1710:        last += delta;",
          "1711:        buf_s8[channels*pos++ + chn] = (int8_t)last;",
          "1712:        break;",
          "1713:       case 1:",
          "1714:        delta = (int8_t)(currWord >> 8);",
          "1715:        delta *= quant;",
          "1716:        last += delta;",
          "1717:        buf_u8[channels*pos++ + chn] = (uint8_t)last;",
          "1718:        break;",
          "1719:       case 2:",
          "1720:        delta = (int16_t)(currWord);",
          "1721:        delta *= quant;",
          "1722:        last += delta;",
          "1723:        buf_u16[channels*pos++ + chn] = BYTESWAP16(last);",
          "1724:        break;",
          "1725:       }",
          "1726:       currWord <<= 8 * sizeoftype;",
          "1727:       currBits -= 8 * sizeoftype;",
          "1728:      }",
          "1729:      break;",
          "1731:     default: //Invalid codeword read",
          "1732:      end = 1;",
          "1733:      return GPMF_ERROR_MEMORY;",
          "1734:      break;",
          "1735:     }",
          "1738:     while (currBits < 16)",
          "1739:     {",
          "1740:      int needed = 16 - currBits;",
          "1741:      currWord |= nextWord >> currBits;",
          "1742:      if (nextBits >= needed) currBits = 16; else currBits += nextBits;",
          "1743:      nextWord <<= needed;",
          "1744:      nextBits -= needed;",
          "1745:      if (nextBits <= 0)",
          "1746:      {",
          "1747:       nextWord = BYTESWAP16(*compressed_data);",
          "1748:       compressed_data++;",
          "1749:       nextBits = 16;",
          "1750:      }",
          "1751:     }",
          "1752:    } while (!end);",
          "1754:    if (nextBits == 16) compressed_data--;",
          "1755:    sOffset = (size_t)compressed_data - (size_t)start;",
          "1756:    end = 0;",
          "1757:   }",
          "1759:   return GPMF_OK;",
          "1760:  }",
          "1762:  return GPMF_ERROR_MEMORY;",
          "1763: }",
          "1766: GPMF_ERR GPMF_AllocCodebook(size_t *cbhandle)",
          "1767: {",
          "1769:  if (*cbhandle)",
          "1770:  {",
          "1771:   int i,v,z;",
          "1772:   GPMF_codebook *cb = (GPMF_codebook *)*cbhandle;",
          "1774:   for (i = 0; i <= 0xffff; i++)",
          "1775:   {",
          "1776:    uint16_t code = (uint16_t)i;",
          "1777:    uint16_t mask = 0x8000;",
          "1778:    int zeros = 0, used = 0;",
          "1780:    cb->command = 0;",
          "1783:    if (code == enccontrolcodestable.entries[HUFF_ESC_CODE_ENTRY].bits)",
          "1784:    {",
          "1785:     cb->command = 2;",
          "1786:     cb->bytes_stored = 1;",
          "1787:     cb->bits_used = 16;",
          "1788:     cb->offset = 0;",
          "1789:     cb++;",
          "1790:     continue;",
          "1791:    }",
          "1792:    if (code == enccontrolcodestable.entries[HUFF_END_CODE_ENTRY].bits)",
          "1793:    {",
          "1794:     cb->command = 1;",
          "1795:     cb->bytes_stored = 0;",
          "1796:     cb->bits_used = 16;",
          "1797:     cb->offset = 0;",
          "1798:     cb++;",
          "1799:     continue;",
          "1800:    }",
          "1802:    for (z = enczerorunstable.length-1; z >= 0; z--)",
          "1803:    {",
          "1804:     if (16 - used >= enczerorunstable.entries[z].size)",
          "1805:     {",
          "1806:      if ((code >> (16 - enczerorunstable.entries[z].size)) == enczerorunstable.entries[z].bits)",
          "1807:      {",
          "1808:       zeros += enczerorunstable.entries[z].count;",
          "1809:       used  += enczerorunstable.entries[z].size;",
          "1810:       mask >>= enczerorunstable.entries[z].size;",
          "1811:       break;",
          "1812:      }",
          "1813:     }",
          "1814:     else break;",
          "1815:    }",
          "1818:    while (!(code & mask) && mask)",
          "1819:    {",
          "1820:     zeros++;",
          "1821:     used++;",
          "1822:     mask >>= 1;",
          "1823:    }",
          "1826:    code <<= used;",
          "1828:    cb->bytes_stored = 0;",
          "1829:    for (v=enchuftable.length-1; v>0; v--)",
          "1830:    {",
          "1831:     if (16-used >= enchuftable.entries[v].size+1) // codeword + sign bit",
          "1832:     {",
          "1833:      if ((code >> (16 - enchuftable.entries[v].size)) == enchuftable.entries[v].bits)",
          "1834:      {",
          "1835:       int sign = 1-(((code >> (16 - (enchuftable.entries[v].size + 1))) & 1)<<1); // last bit is the sign.",
          "1836:       cb->value = enchuftable.entries[v].value * (int16_t)sign;",
          "1837:       used += enchuftable.entries[v].size+1;",
          "1838:       cb->bytes_stored = 1;",
          "1839:       break;",
          "1840:      }",
          "1841:     }",
          "1842:    }",
          "1844:    if (used == 0)",
          "1845:    {",
          "1846:     used = 16;",
          "1847:     cb->command = -1; // ERROR invalid code",
          "1848:    }",
          "1849:    cb->bits_used = (uint8_t)used;",
          "1850:    cb->offset = (uint8_t)zeros;",
          "1851:    cb++;",
          "1852:   }",
          "1860: GPMF_ERR GPMF_FreeCodebook(size_t cbhandle)",
          "1861: {",
          "1862:  GPMF_codebook *cb = (GPMF_codebook *)cbhandle;",
          "1864:  if (cb)",
          "1865:  {",
          "1866:   free(cb);",
          "1868:   return GPMF_OK;",
          "1869:  }",
          "1870:  return GPMF_ERROR_MEMORY;",
          "1871: }",
          "",
          "---------------"
        ],
        "GPMF_parser.h||GPMF_parser.h": [
          "File: GPMF_parser.h -> GPMF_parser.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #ifndef _GPMF_PARSER_H",
          "23: #define _GPMF_PARSER_H",
          "25: #ifdef __cplusplus",
          "26: extern \"C\" {",
          "27: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include <stdint.h>",
          "26: #include <stddef.h>",
          "27: #include \"GPMF_common.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "40:  uint32_t device_count;",
          "41:  uint32_t device_id;",
          "42:  char device_name[32];",
          "43: } GPMF_stream;",
          "59: typedef enum GPMF_LEVELS",
          "60: {",
          "",
          "[Removed Lines]",
          "45: typedef enum GPMF_ERROR",
          "46: {",
          "47:  GPMF_OK = 0,",
          "48:  GPMF_ERROR_MEMORY,",
          "49:  GPMF_ERROR_BAD_STRUCTURE,",
          "50:  GPMF_ERROR_BUFFER_END,",
          "51:  GPMF_ERROR_FIND,",
          "52:  GPMF_ERROR_LAST,",
          "53:  GPMF_ERROR_TYPE_NOT_SUPPORTED,",
          "54:  GPMF_ERROR_SCALE_NOT_SUPPORTED,",
          "55:  GPMF_ERROR_SCALE_COUNT,",
          "56:  GPMF_ERROR_RESERVED",
          "57: } GPMF_ERROR;",
          "",
          "[Added Lines]",
          "47:  size_t cbhandle; // compression handler",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "62:  GPMF_RECURSE_LEVELS",
          "63: } GPMF_LEVELS;",
          "145: GPMF_ERR GPMF_Init(GPMF_stream *gs, uint32_t *buffer, int datasize);       //Initialize a GPMF_stream for parsing a particular buffer.",
          "",
          "[Removed Lines]",
          "65: #define GPMF_ERR uint32_t",
          "67: typedef enum",
          "68: {",
          "69:  GPMF_TYPE_STRING_ASCII = 'c', //single byte 'c' style character string",
          "70:  GPMF_TYPE_SIGNED_BYTE = 'b',//single byte signed number",
          "71:  GPMF_TYPE_UNSIGNED_BYTE = 'B', //single byte unsigned number",
          "72:  GPMF_TYPE_SIGNED_SHORT = 's',//16-bit integer",
          "73:  GPMF_TYPE_UNSIGNED_SHORT = 'S',//16-bit integer",
          "74:  GPMF_TYPE_FLOAT = 'f', //32-bit single precision float (IEEE 754)",
          "75:  GPMF_TYPE_FOURCC = 'F', //32-bit four character tag",
          "76:  GPMF_TYPE_SIGNED_LONG = 'l',//32-bit integer",
          "77:  GPMF_TYPE_UNSIGNED_LONG = 'L', //32-bit integer",
          "78:  GPMF_TYPE_Q15_16_FIXED_POINT = 'q', // Q number Q15.16 - 16-bit signed integer (A) with 16-bit fixed point (B) for A.B value (range -32768.0 to 32767.99998).",
          "79:  GPMF_TYPE_Q31_32_FIXED_POINT = 'Q', // Q number Q31.32 - 32-bit signed integer (A) with 32-bit fixed point (B) for A.B value.",
          "80:  GPMF_TYPE_SIGNED_64BIT_INT = 'j', //64 bit signed long",
          "81:  GPMF_TYPE_UNSIGNED_64BIT_INT = 'J', //64 bit unsigned long",
          "82:  GPMF_TYPE_DOUBLE = 'd', //64 bit double precision float (IEEE 754)",
          "83:  GPMF_TYPE_UTC_DATE_TIME = 'U', //128-bit ASCII Date + UTC Time format yymmddhhmmss.sss - 16 bytes ASCII (years 20xx covered)",
          "84:  GPMF_TYPE_GUID = 'G', //128-bit ID (like UUID)",
          "86:  GPMF_TYPE_COMPLEX = '?', //for sample with complex data structures, base size in bytes.  Data is either opaque, or the stream has a TYPE structure field for the sample.",
          "88:  GPMF_TYPE_NEST = 0, // used to nest more GPMF formatted metadata",
          "90: } GPMF_SampleType;",
          "94: #define MAKEID(a,b,c,d)   (((d&0xff)<<24)|((c&0xff)<<16)|((b&0xff)<<8)|(a&0xff))",
          "95: #define STR2FOURCC(s)   ((s[0]<<0)|(s[1]<<8)|(s[2]<<16)|(s[3]<<24))",
          "97: #define BYTESWAP64(a)   (((a&0xff)<<56)|((a&0xff00)<<40)|((a&0xff0000)<<24)|((a&0xff000000)<<8) | ((a>>56)&0xff)|((a>>40)&0xff00)|((a>>24)&0xff0000)|((a>>8)&0xff000000) )",
          "98: #define BYTESWAP32(a)   (((a&0xff)<<24)|((a&0xff00)<<8)|((a>>8)&0xff00)|((a>>24)&0xff))",
          "99: #define BYTESWAP16(a)   ((((a)>>8)&0xff)|(((a)<<8)&0xff00))",
          "100: #define NOSWAP8(a)    (a)",
          "102: #define GPMF_SAMPLES(a)   (((a>>24) & 0xff)|(((a>>16)&0xff)<<8))",
          "103: #define GPMF_SAMPLE_SIZE(a)  (((a)>>8)&0xff)",
          "104: #define GPMF_SAMPLE_TYPE(a)  (a&0xff)",
          "105: #define GPMF_MAKE_TYPE_SIZE_COUNT(t,s,c)  ((t)&0xff)|(((s)&0xff)<<8)|(((c)&0xff)<<24)|(((c)&0xff00)<<8)",
          "106: #define GPMF_DATA_SIZE(a)  ((GPMF_SAMPLE_SIZE(a)*GPMF_SAMPLES(a)+3)&~0x3)",
          "107: #define GPMF_DATA_PACKEDSIZE(a) ((GPMF_SAMPLE_SIZE(a)*GPMF_SAMPLES(a)))",
          "108: #define GPMF_VALID_FOURCC(a) (((((a>>24)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>24)&0xff)>='A'&&((a>>24)&0xff)<='Z') || (((a>>24)&0xff)>='0'&&((a>>24)&0xff)<='9') || (((a>>24)&0xff)==' ') ) && \\",
          "109:         ( (((a>>16)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>16)&0xff)>='A'&&((a>>16)&0xff)<='Z') || (((a>>16)&0xff)>='0'&&((a>>16)&0xff)<='9') || (((a>>16)&0xff)==' ') ) && \\",
          "110:         ( (((a>>8)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>8)&0xff)>='A'&&((a>>8)&0xff)<='Z') || (((a>>8)&0xff)>='0'&&((a>>8)&0xff)<='9') || (((a>>8)&0xff)==' ') ) && \\",
          "111:         ( (((a>>0)&0xff)>='a'&&((a>>24)&0xff)<='z') || (((a>>0)&0xff)>='A'&&((a>>0)&0xff)<='Z') || (((a>>0)&0xff)>='0'&&((a>>0)&0xff)<='9') || (((a>>0)&0xff)==' ') ))",
          "112: #define GPMF_KEY_TYPE(a)  (a&0xff)",
          "114: #define PRINTF_4CC(k)   ((k) >> 0) & 0xff, ((k) >> 8) & 0xff, ((k) >> 16) & 0xff, ((k) >> 24) & 0xff",
          "117: typedef enum GPMFKey // TAG in all caps are GoPro preserved (are defined by GoPro, but can be used by others.)",
          "118: {",
          "120:  GPMF_KEY_DEVICE =   MAKEID('D','E','V','C'),//DEVC - nested device data to speed the parsing of multiple devices in post",
          "121:  GPMF_KEY_DEVICE_ID =  MAKEID('D','V','I','D'),//DVID - unique id per stream for a metadata source (in camera or external input) (single 4 byte int)",
          "122:  GPMF_KEY_DEVICE_NAME =  MAKEID('D','V','N','M'),//DVNM - human readable device type/name (char string)",
          "123:  GPMF_KEY_STREAM =   MAKEID('S','T','R','M'),//STRM - nested channel/stream of telemetry data",
          "124:  GPMF_KEY_STREAM_NAME =  MAKEID('S','T','N','M'),//STNM - human readable telemetry/metadata stream type/name (char string)",
          "125:  GPMF_KEY_SI_UNITS =   MAKEID('S','I','U','N'),//SIUN - Display string for metadata units where inputs are in SI units \"uT\",\"rad/s\",\"km/s\",\"m/s\",\"mm/s\" etc.",
          "126:  GPMF_KEY_UNITS =   MAKEID('U','N','I','T'),//UNIT - Freedform display string for metadata units (char sting like \"RPM\", \"MPH\", \"km/h\", etc)",
          "127:  GPMF_KEY_SCALE =   MAKEID('S','C','A','L'),//SCAL - divisor for input data to scale to the correct units.",
          "128:  GPMF_KEY_TYPE =    MAKEID('T','Y','P','E'),//TYPE - Type define for complex data structures",
          "129:  GPMF_KEY_TOTAL_SAMPLES = MAKEID('T','S','M','P'),//TSMP - Total Sample Count including the current payload",
          "130:  GPMF_KEY_TIME_OFFSET =  MAKEID('T','I','M','O'),//TIMO - Time offset of the metadata stream that follows (single 4 byte float)",
          "131:  GPMF_KEY_TIMING_OFFSET = MAKEID('T','I','M','O'),//TIMO - duplicated, as older code might use the other version of TIMO",
          "132:  GPMF_KEY_TIME_STAMP =  MAKEID('S','T','M','P'),//STMP - Time stamp for the first sample.",
          "133:  GPMF_KEY_TIME_STAMPS =  MAKEID('S','T','P','S'),//STPS - Stream of all the timestamps delivered (Generally don't use this. This would be if your sensor has no peroidic times, yet precision is required, or for debugging.)",
          "134:  GPMF_KEY_TICK =    MAKEID('T','I','C','K'),//TICK - Used for slow data. Beginning of data timing in milliseconds.",
          "135:  GPMF_KEY_TOCK =    MAKEID('T','O','C','K'),//TOCK - Used for slow data. End of data timing in milliseconds.",
          "136:  GPMF_KEY_EMPTY_PAYLOADS = MAKEID('E','M','P','T'),//EMPT - Payloads that are empty since the device start (e.g. BLE disconnect.)",
          "137:  GPMF_KEY_REMARK =   MAKEID('R','M','R','K'),//RMRK - addcing comments to the bitstream (debugging)",
          "139:  GPMF_KEY_END = 0//(null)",
          "140: } GPMFKey;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "157: uint32_t GPMF_Key(GPMF_stream *gs);                //return the current Key (FourCC)",
          "159: uint32_t GPMF_StructSize(GPMF_stream *gs);              //return the current sample structure size",
          "160: uint32_t GPMF_Repeat(GPMF_stream *gs);               //return the current repeat or the number of samples of this structure",
          "161: uint32_t GPMF_PayloadSampleCount(GPMF_stream *gs);              //return the current number of samples of this structure, supporting multisample entries.",
          "",
          "[Removed Lines]",
          "158: uint32_t GPMF_Type(GPMF_stream *gs);               //return the current Type (GPMF_Type)",
          "",
          "[Added Lines]",
          "74: GPMF_SampleType GPMF_Type(GPMF_stream *gs);              //return the current Type (GPMF_Type)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "175: GPMF_ERR GPMF_Reserved(uint32_t key);               // Test for a reverse GPMF Key, returns GPMF_OK is not reversed.",
          "178: GPMF_ERR GPMF_FormattedData(GPMF_stream *gs, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples);  // extract 'n' samples into local endian memory format.",
          "179: GPMF_ERR GPMF_ScaledData(GPMF_stream *gs, void *buffer, uint32_t buffersize, uint32_t sample_offset, uint32_t read_samples, GPMF_SampleType type); // extract 'n' samples into local endian memory format          // return a point the KLV data.",
          "186: #ifdef __cplusplus",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94: uint32_t GPMF_FormattedDataSize(GPMF_stream *gs);            //return the decompressed data size for the current GPMF KLV",
          "95: uint32_t GPMF_ScaledDataSize(GPMF_stream *gs, GPMF_SampleType type);            //return the decompressed data size for the current GPMF KLV",
          "101: typedef struct GPMF_codebook",
          "102: {",
          "103:  int16_t value;   //value to store",
          "104:  uint8_t offset;   //0 to 128+ bytes to skip before store (leading zeros)",
          "105:  uint8_t bits_used;  //1 to 16,32 (if escape code > 16 then read from bit-steam),",
          "106:  int8_t bytes_stored; //bytes stored in value: 0, 1 or 2",
          "107:  int8_t command;  //0 - OKAY,  -1 valid code, 1 - end",
          "108: } GPMF_codebook;",
          "111: GPMF_ERR GPMF_AllocCodebook(size_t *cbhandle);",
          "112: GPMF_ERR GPMF_FreeCodebook(size_t cbhandle);",
          "113: GPMF_ERR GPMF_DecompressedSize(GPMF_stream *gs, uint32_t *neededsize);",
          "114: GPMF_ERR GPMF_Decompress(GPMF_stream *gs, uint32_t *localbuf, uint32_t localbuf_size);",
          "",
          "---------------"
        ],
        "demo/GPMF_demo.c||demo/GPMF_demo.c": [
          "File: demo/GPMF_demo.c -> demo/GPMF_demo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "35:  int32_t ret = GPMF_OK;",
          "36:  GPMF_stream metadata_stream, *ms = &metadata_stream;",
          "37:  double metadatalength;",
          "38:  uint32_t *payload = NULL; //buffer to store GPMF samples from the MP4.",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38:  double start_offset = 0.0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "44:   printf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);",
          "45:   return -1;",
          "46:  }",
          "48:  size_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);",
          "50:  size_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta",
          "51: #endif",
          "52:  if (mp4 == 0)",
          "53:  {",
          "55:   return -1;",
          "56:  }",
          "",
          "[Removed Lines]",
          "47: #if 1",
          "49: #else",
          "54:   printf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);",
          "",
          "[Added Lines]",
          "49: #if 1 // Search for GPMF Track",
          "51: #else // look for a global GPMF payload in the moov header, within 'udta'",
          "56:   printf(\"error: %s is an invalid MP4/MOV or it has no GPMF data\\n\", argv[1]);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:   uint32_t index, payloads = GetNumberPayloads(mp4);",
          "66: #if 1",
          "67:   if (payloads == 1) // Printf the contents of the single payload",
          "68:   {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:   uint32_t fr_num, fr_dem;",
          "69:   uint32_t frames = GetVideoFrameRateAndCount(mp4, &fr_num, &fr_dem);",
          "70:   if (frames)",
          "71:   {",
          "72:    printf(\"video framerate is %.2f with %d frames\\n\", (float)fr_num/(float)fr_dem, frames);",
          "73:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "114: #if 1  // Find all the available Streams and the data carrying FourCC",
          "115:    if (index == 0) // show first payload",
          "116:    {",
          "117:     ret = GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS);",
          "118:     while (GPMF_OK == ret)",
          "119:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125:     GPMF_stream find;",
          "126:     GPMF_CopyState(ms, &find);",
          "128:     if (GPMF_OK == GPMF_FindNext(&find, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))",
          "129:     {",
          "130:      double payload_in = 0.0, payload_out;",
          "131:      double start = 0.0, end;",
          "133:      GetPayloadTime(mp4, 0, &payload_in, &payload_out);",
          "135:      if (GPMF_OK == GPMF_FindNext(&find, STR2FOURCC(\"SHUT\"), GPMF_RECURSE_LEVELS))",
          "136:      {",
          "138:       if (GPMF_OK == GPMF_FindPrev(&find, GPMF_KEY_TIME_STAMP, GPMF_CURRENT_LEVEL))",
          "139:       {",
          "140:        double rate = GetGPMFSampleRate(mp4, STR2FOURCC(\"SHUT\"), GPMF_SAMPLE_RATE_PRECISE, &start, &end);// GPMF_SAMPLE_RATE_FAST);",
          "141:        start_offset = start - payload_in;",
          "142:       }",
          "143:      }",
          "144:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "184: #if 1  // Find GPS values and return scaled doubles.",
          "185:    if (index == 0) // show first payload",
          "186:    {",
          "189:     {",
          "190:      uint32_t key = GPMF_Key(ms);",
          "191:      uint32_t samples = GPMF_Repeat(ms);",
          "192:      uint32_t elements = GPMF_ElementsInStruct(ms);",
          "193:      uint32_t buffersize = samples * elements * sizeof(double);",
          "194:      GPMF_stream find_stream;",
          "196:      char units[10][6] = { \"\" };",
          "197:      uint32_t unit_samples = 1;",
          "",
          "[Removed Lines]",
          "187:     if (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPS5\"), GPMF_RECURSE_LEVELS) || //GoPro Hero5/6/7 GPS",
          "188:      GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"GPRI\"), GPMF_RECURSE_LEVELS))   //GoPro Karma GPS",
          "195:      double *ptr, *tmpbuffer = malloc(buffersize);",
          "",
          "[Added Lines]",
          "219:     if (GPMF_OK == GPMF_FindNext(ms, STR2FOURCC(\"ACCL\"), GPMF_RECURSE_LEVELS)) //GoPro Hero5/6/7 Accelerometer",
          "226:      double *ptr, *tmpbuffer = (double *)malloc(buffersize);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "246:   {",
          "247:    if (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream",
          "248:    {",
          "250:     uint32_t fourcc = GPMF_Key(ms);",
          "253:    }",
          "254:   }",
          "255: #endif",
          "",
          "[Removed Lines]",
          "249:     double in = 0.0, out = 0.0;",
          "251:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);",
          "252:     printf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);",
          "",
          "[Added Lines]",
          "280:     double start, end;",
          "282:     double rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &start, &end);// GPMF_SAMPLE_RATE_FAST);",
          "284:     start -= start_offset;",
          "285:     end -= start_offset;",
          "286:     printf(\"%c%c%c%c sampling rate = %fHz (time %f to %f)\\\",\\n\", PRINTF_4CC(fourcc), rate, start, end);",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.c||demo/GPMF_mp4reader.c": [
          "File: demo/GPMF_mp4reader.c -> demo/GPMF_mp4reader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <sys/stat.h>",
          "31: #include \"GPMF_mp4reader.h\"",
          "33: #define PRINT_MP4_STRUCTURE  0",
          "35: #ifdef _WINDOWS",
          "36: #define LONGSEEK _fseeki64",
          "37: #else",
          "38: #define LONGSEEK fseeko",
          "39: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #include \"../GPMF_common.h\"",
          "38: #define LONGTELL _ftelli64",
          "41: #define LONGTELL ftell",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "109:  if (mp4 == NULL) return 0;",
          "111:  if (mp4->metasizes && mp4->metasize_count > index)",
          "114:  return 0;",
          "115: }",
          "",
          "[Removed Lines]",
          "112:   return mp4->metasizes[index];",
          "",
          "[Added Lines]",
          "114:   return mp4->metasizes[index] & ~0x3;  //All GPMF payloads are 32-bit aligned and sized",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "163:      break;",
          "164:     }",
          "167:     {",
          "168:      CloseSource((size_t)mp4);",
          "169:      mp4 = NULL;",
          "",
          "[Removed Lines]",
          "166:     if (!VALID_FOURCC(qttag))",
          "",
          "[Added Lines]",
          "169:     if (!GPMF_VALID_FOURCC(qttag))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "213:      continue;",
          "214:     }",
          "216:     if (qttag != MAKEID('m', 'o', 'o', 'v') && //skip over all but these atoms",
          "217:      qttag != MAKEID('m', 'v', 'h', 'd') &&",
          "218:      qttag != MAKEID('t', 'r', 'a', 'k') &&",
          "",
          "[Removed Lines]",
          "215: #else",
          "",
          "[Added Lines]",
          "218: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "229:      qttag != MAKEID('s', 't', 's', 'z') &&",
          "230:      qttag != MAKEID('s', 't', 'c', 'o') &&",
          "231:      qttag != MAKEID('c', 'o', '6', '4') &&",
          "233:     {",
          "234:      LongSeek(mp4, qtsize - 8);",
          "236:      NESTSIZE(qtsize);",
          "237:     }",
          "238:     else",
          "240:      if (qttag == MAKEID('m', 'v', 'h', 'd')) //mvhd  movie header",
          "241:      {",
          "242:       len = fread(&skip, 1, 4, mp4->mediafp);",
          "",
          "[Removed Lines]",
          "232:      qttag != MAKEID('h', 'd', 'l', 'r'))",
          "239: #endif",
          "",
          "[Added Lines]",
          "235:      qttag != MAKEID('h', 'd', 'l', 'r') &&",
          "236:      qttag != MAKEID('e', 'd', 't', 's'))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "251:       NESTSIZE(qtsize);",
          "252:      }",
          "253:      else if (qttag == MAKEID('m', 'd', 'h', 'd')) //mdhd  media header",
          "254:      {",
          "255:       media_header md;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "256:      else if (qttag == MAKEID('t', 'r', 'a', 'k')) //trak header",
          "257:      {",
          "259:       if (mp4->trak_num+1 < MAX_TRACKS)",
          "260:        mp4->trak_num++;",
          "262:       NESTSIZE(qtsize);",
          "263:      }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "291:       NESTSIZE(qtsize);",
          "293:      }",
          "294:      else if (qttag == MAKEID('s', 't', 's', 'd')) //read the sample decription to determine the type of metadata",
          "295:      {",
          "296:       if (type == traktype) //like meta",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "305:      else if (qttag == MAKEID('e', 'd', 't', 's')) //edit list",
          "306:      {",
          "307:       uint32_t elst,temp,num,i;",
          "308:       len = fread(&skip, 1, 4, mp4->mediafp);",
          "309:       len += fread(&elst, 1, 4, mp4->mediafp);",
          "310:       if (elst == MAKEID('e', 'l', 's', 't'))",
          "311:       {",
          "312:        len += fread(&temp, 1, 4, mp4->mediafp);",
          "313:        if (temp == 0)",
          "314:        {",
          "315:         len += fread(&num, 1, 4, mp4->mediafp);",
          "316:         num = BYTESWAP32(num);",
          "317:         if (num <= ((qtsize - 8 - len) / 12))",
          "318:         {",
          "319:          int32_t segment_duration; //integer that specifies the duration of this edit segment in units of the movie\ufffds time scale.",
          "320:          int32_t segment_mediaTime; //integer containing the starting time within the media of this edit segment(in media timescale units).If this field is set to \ufffd1, it is an empty edit.The last edit in a track should never be an empty edit.Any difference between the movie\ufffds duration and the track\ufffds duration is expressed as an implicit empty edit.",
          "321:          int32_t segment_mediaRate; //point number that specifies the relative rate at which to play the media corresponding to this edit segment.This rate value cannot be 0 or negative.",
          "322:          for (i = 0; i < num; i++)",
          "323:          {",
          "324:           len += fread(&segment_duration, 1, 4, mp4->mediafp);",
          "325:           len += fread(&segment_mediaTime, 1, 4, mp4->mediafp);",
          "326:           len += fread(&segment_mediaRate, 1, 4, mp4->mediafp);",
          "328:           segment_duration = BYTESWAP32(segment_duration);  // in MP4 clock base",
          "329:           segment_mediaTime = BYTESWAP32(segment_mediaTime); // in trak clock base",
          "330:           segment_mediaRate = BYTESWAP32(segment_mediaRate); // Fixed-point 65536 = 1.0X",
          "332:           if (segment_mediaTime == -1) // the segment_duration for blanked time",
          "333:            mp4->trak_edit_list_offsets[mp4->trak_num] += segment_duration;  //samples are delay, data starts after presentation time zero.",
          "334:           else if (i == 0) // If the first editlst starts after zero, the track is offset by this time (time before presentation time zero.)",
          "335:            mp4->trak_edit_list_offsets[mp4->trak_num] -= (int32_t)((double)segment_mediaTime/(double)mp4->trak_clockdemon*(double)mp4->clockdemon); //convert to MP4 clock base.",
          "336:          }",
          "337:          if (type == traktype) // GPMF metadata",
          "338:          {",
          "339:           mp4->metadataoffset_clockcount = mp4->trak_edit_list_offsets[mp4->trak_num]; //leave in MP4 clock base",
          "340:          }",
          "341:         }",
          "342:        }",
          "343:       }",
          "344:       mp4->filepos += len;",
          "345:       LongSeek(mp4, qtsize - 8 - len); // skip over edts",
          "347:       NESTSIZE(qtsize);",
          "348:      }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "301:        len += fread(&subtype, 1, 4, mp4->mediafp);  // type will be 'meta' for the correct trak.",
          "302:        if (len == 16)",
          "303:        {",
          "305:         {",
          "306:          type = 0; // MP4",
          "307:         }",
          "",
          "[Removed Lines]",
          "304:         if (subtype != traksubtype) // MP4 metadata",
          "",
          "[Added Lines]",
          "359:         if (subtype != traksubtype) // not MP4 metadata",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "373:        len += fread(&num, 1, 4, mp4->mediafp);",
          "375:        num = BYTESWAP32(num);",
          "377:        {",
          "378:         mp4->metasize_count = num;",
          "379:         if (mp4->metasizes)",
          "",
          "[Removed Lines]",
          "376:        if (num <= ((qtsize - 8 - len)/sizeof(uint32_t)))",
          "",
          "[Added Lines]",
          "432:        if ((num <= ((qtsize - 8 - len)/sizeof(uint32_t))) || (equalsamplesize != 0 && qtsize == 20))",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "431:        num = BYTESWAP32(num);",
          "432:        if (num <= ((qtsize - 8 - len)/sizeof(uint32_t)))",
          "433:        {",
          "436:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "437:         {",
          "439:          if (mp4->metaoffsets)",
          "440:          {",
          "441:           free(mp4->metaoffsets);",
          "",
          "[Removed Lines]",
          "434:         uint32_t metastco_count = num;",
          "438:          mp4->indexcount = num;",
          "",
          "[Added Lines]",
          "490:         mp4->metastco_count = num;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "464:             mp4->metaoffsets[0] = fileoffset = metaoffsets32[stco_pos];",
          "465:             num = 1;",
          "467:             {",
          "468:              if ((uint32_t)repeat == mp4->metastsc[stsc_pos].samples)",
          "469:              {",
          "471:               {",
          "472:                stco_pos++;",
          "473:                fileoffset = (uint64_t)metaoffsets32[stco_pos];",
          "",
          "[Removed Lines]",
          "466:             while (num < mp4->indexcount)",
          "470:               if ((uint32_t)stco_pos + 1 < metastco_count)",
          "",
          "[Added Lines]",
          "521:             while (num < mp4->metastco_count)",
          "525:               if ((uint32_t)stco_pos + 1 < mp4->metastco_count)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "513:         }",
          "514:         else",
          "515:         {",
          "517:          if (mp4->metaoffsets)",
          "518:          {",
          "519:           free(mp4->metaoffsets);",
          "",
          "[Removed Lines]",
          "516:          mp4->indexcount = num;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "577:        if (num <= ((qtsize - 8 - len)/sizeof(uint64_t)))",
          "578:        {",
          "579:         if (mp4->metastsc_count > 0 && num != mp4->metasize_count)",
          "580:         {",
          "582:          if (mp4->metaoffsets)",
          "583:          {",
          "584:           free(mp4->metaoffsets);",
          "",
          "[Removed Lines]",
          "581:          mp4->indexcount = mp4->metasize_count;",
          "",
          "[Added Lines]",
          "633:         mp4->metastco_count = num;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "645:         }",
          "646:         else",
          "647:         {",
          "649:          if (mp4->metaoffsets)",
          "650:          {",
          "651:           free(mp4->metaoffsets);",
          "",
          "[Removed Lines]",
          "648:          mp4->indexcount = num;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "673:      }",
          "674:      else if (qttag == MAKEID('s', 't', 't', 's')) // time to samples",
          "675:      {",
          "676:       if (type == traktype) // meta",
          "677:       {",
          "678:        uint32_t totaldur = 0, samples = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "730:       if (type == MAKEID('v', 'i', 'd', 'e')) // video trak to get frame rate",
          "731:       {",
          "732:        uint32_t totaldur = 0, samples = 0;",
          "733:        int32_t entries = 0;",
          "734:        len = fread(&skip, 1, 4, mp4->mediafp);",
          "735:        len += fread(&num, 1, 4, mp4->mediafp);",
          "736:        num = BYTESWAP32(num);",
          "737:        if (num <= ((qtsize - 8 - len) / 8))",
          "738:        {",
          "739:         entries = num;",
          "741:         while (entries > 0)",
          "742:         {",
          "743:          int32_t samplecount;",
          "744:          int32_t duration;",
          "745:          len += fread(&samplecount, 1, 4, mp4->mediafp);",
          "746:          samplecount = BYTESWAP32(samplecount);",
          "747:          len += fread(&duration, 1, 4, mp4->mediafp);",
          "748:          duration = BYTESWAP32(duration);",
          "750:          samples += samplecount;",
          "751:          entries--;",
          "753:          if (mp4->video_framerate_numerator == 0)",
          "754:          {",
          "755:           mp4->video_framerate_numerator = mp4->trak_clockdemon;",
          "756:           mp4->video_framerate_denominator = duration;",
          "757:          }",
          "758:         }",
          "759:         mp4->video_frames = samples;",
          "760:        }",
          "761:        mp4->filepos += len;",
          "762:        LongSeek(mp4, qtsize - 8 - len); // skip over stco",
          "763:       }",
          "764:       else",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "702:          totaldur += duration;",
          "703:          mp4->metadatalength += (double)((double)samplecount * (double)duration / (double)mp4->meta_clockdemon);",
          "705:           mp4->basemetadataduration = mp4->metadatalength * (double)mp4->meta_clockdemon / (double)samples;",
          "706:         }",
          "707:        }",
          "",
          "[Removed Lines]",
          "704:          if (samplecount > 1 || num == 1)",
          "",
          "[Added Lines]",
          "793:          if (samplecount > 1 || entries == 1)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "731:     CloseSource((size_t)mp4);",
          "732:     mp4 = NULL;",
          "733:    }",
          "734:   }",
          "735:  }",
          "736:  else",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "825:    if (mp4 != NULL)",
          "826:    {",
          "827:     mp4->indexcount = mp4->metasize_count;",
          "828:     if (mp4->metastco_count < mp4->indexcount)",
          "829:      mp4->indexcount = mp4->metastco_count;",
          "830:    }",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "754:  return (float)mp4->metadatalength;",
          "755: }",
          "758: void CloseSource(size_t handle)",
          "759: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "854: uint32_t GetVideoFrameRateAndCount(size_t handle, uint32_t *numer, uint32_t *demon)",
          "855: {",
          "856:  mp4object *mp4 = (mp4object *)handle;",
          "857:  if (mp4 == NULL) return 0;",
          "859:  if (numer != NULL && demon != NULL && mp4->video_frames > 0)",
          "860:  {",
          "863:   return mp4->video_frames;",
          "864:  }",
          "865:  return 0;",
          "866: }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "800:  return GPMF_OK;",
          "801: }",
          "805: {",
          "806:     mp4object *mp4 = (mp4object *)handle;",
          "807:     if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
          "809:     if (mp4->metaoffsets == 0 || mp4->basemetadataduration == 0 || mp4->meta_clockdemon == 0 || in_numerator == NULL || out_numerator == NULL) return GPMF_ERROR_MEMORY;",
          "815:     return GPMF_OK;",
          "816: }",
          "818: size_t OpenMP4SourceUDTA(char *filename)",
          "819: {",
          "820:  mp4object *mp4 = (mp4object *)malloc(sizeof(mp4object));",
          "",
          "[Removed Lines]",
          "804: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator)",
          "",
          "[Added Lines]",
          "911:  if (*out > (double)mp4->metadatalength)",
          "921: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, int32_t *in_numerator, int32_t *out_numerator, uint32_t *denominator)",
          "931:  if (*out_numerator > (int32_t)((double)mp4->metadatalength*(double)mp4->meta_clockdemon))",
          "944: uint32_t GetEditListOffset(size_t handle, double *offset)",
          "945: {",
          "946:  mp4object *mp4 = (mp4object *)handle;",
          "947:  if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
          "949:  if (mp4->clockdemon == 0) return GPMF_ERROR_MEMORY;",
          "953:  return GPMF_OK;",
          "954: }",
          "956: uint32_t GetEditListOffsetRationalTime(size_t handle, int32_t *offset_numerator, uint32_t *denominator)",
          "957: {",
          "958:  mp4object *mp4 = (mp4object *)handle;",
          "959:  if (mp4 == NULL) return GPMF_ERROR_MEMORY;",
          "961:  if (mp4->clockdemon == 0) return GPMF_ERROR_MEMORY;",
          "966:  return GPMF_OK;",
          "967: }",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "899:      mp4->metaoffsets = (uint64_t *)malloc(mp4->indexcount * 8 + 8);  memset(mp4->metaoffsets, 0, mp4->indexcount * 8 + 8);",
          "901:      mp4->metasizes[0] = (int)qtsize - 8;",
          "903:      mp4->metasize_count = 1;",
          "905:      return (size_t)mp4;  // not an MP4, RAW GPMF which has not inherent timing, assigning a during of 1second.",
          "",
          "[Removed Lines]",
          "902:      mp4->metaoffsets[0] = ftell(mp4->mediafp);",
          "",
          "[Added Lines]",
          "1055:      mp4->metaoffsets[0] = LONGTELL(mp4->mediafp);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "947:   goto cleanup;",
          "949:  {",
          "951:   uint64_t starttimestamp = 0;",
          "952:   uint64_t endtimestamp = 0;",
          "953:   uint32_t startsamples = 0;",
          "",
          "[Removed Lines]",
          "950:   uint64_t minimumtimestamp = 0;",
          "",
          "[Added Lines]",
          "1103:   uint64_t basetimestamp = 0;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "967:   if (ret == GPMF_OK && payload)",
          "968:   {",
          "969:    uint32_t samples = GPMF_PayloadSampleCount(ms);",
          "970:    GPMF_stream find_stream;",
          "971:    GPMF_CopyState(ms, &find_stream);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1122:    double startin, startout, endin, endout;",
          "1123:    int usedTimeStamps = 0;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "981:     GPMF_stream any_stream;",
          "982:     if (GPMF_OK == GPMF_Init(&any_stream, payload, payloadsize))",
          "983:     {",
          "985:      while (GPMF_OK == GPMF_FindNext(&any_stream, GPMF_KEY_TIME_STAMP, GPMF_RECURSE_LEVELS))",
          "986:      {",
          "987:       uint64_t timestamp = BYTESWAP64(*(uint64_t *)GPMF_RawData(&any_stream));",
          "990:      }",
          "991:     }",
          "992:    }",
          "994:    testend = mp4->indexcount;",
          "995:    do",
          "",
          "[Removed Lines]",
          "984:      minimumtimestamp = starttimestamp;",
          "988:       if (timestamp < minimumtimestamp)",
          "989:        minimumtimestamp = timestamp;",
          "",
          "[Added Lines]",
          "1140:      basetimestamp = starttimestamp;",
          "1144:       if (timestamp < basetimestamp)",
          "1145:        basetimestamp = timestamp;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "998:     payload = GetPayload(handle, payload, testend);",
          "999:     payloadsize = GetPayloadSize(handle, testend);",
          "1000:     ret = GPMF_Init(ms, payload, payloadsize);",
          "1003:    GPMF_CopyState(ms, &find_stream);",
          "1004:    if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))",
          "",
          "[Removed Lines]",
          "1001:    } while (testend > 0 && ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
          "",
          "[Added Lines]",
          "1161:    } while (testend > 0 && ret == GPMF_OK &&  GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS));",
          "1163:    GetPayloadTime(handle, teststart, &startin, &startout);",
          "1164:    GetPayloadTime(handle, testend, &endin, &endout);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1030:     {",
          "1031:      double approxrate = 0.0;",
          "1032:      if (endsamples > startsamples)",
          "1035:      if (approxrate == 0.0)",
          "1039:      while (time_stamp_scale >= 1)",
          "",
          "[Removed Lines]",
          "1033:       approxrate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "1036:       approxrate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "",
          "[Added Lines]",
          "1196:       approxrate = (double)(endsamples - startsamples) / (endout - startin);",
          "1199:       approxrate = (double)(samples) / (endout - startin);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1045:       time_stamp_scale *= 0.1;",
          "1046:      }",
          "1047:      if (time_stamp_scale < 1.0) rate = 0.0;",
          "1049:     }",
          "1050:    }",
          "",
          "[Removed Lines]",
          "1048:      intercept = (((double)minimumtimestamp - (double)starttimestamp) / time_stamp_scale) * rate;",
          "",
          "[Added Lines]",
          "1211:      intercept = (((double)basetimestamp - (double)starttimestamp) / time_stamp_scale) * rate;",
          "1212:      usedTimeStamps = 1;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1054:     if (!(flags & GPMF_SAMPLE_RATE_PRECISE))",
          "1055:     {",
          "1056:      if (endsamples > startsamples)",
          "1059:      if (rate == 0.0)",
          "1065:     }",
          "1066:     else // for increased precision, for older GPMF streams sometimes missing the total sample count",
          "1067:     {",
          "1068:      uint32_t payloadpos = 0, payloadcount = 0;",
          "1069:      double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;",
          "1071:      memset(repeatarray, 0, mp4->indexcount * 4 + 4);",
          "1073:      samples = 0;",
          "",
          "[Removed Lines]",
          "1057:       rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "1060:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "1062:      double in, out;",
          "1063:      if (GPMF_OK == GetPayloadTime(handle, teststart, &in, &out))",
          "1064:       intercept = (double)-in * rate;",
          "1070:      uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);",
          "",
          "[Added Lines]",
          "1221:       rate = (double)(endsamples - startsamples) / (endout - startin);",
          "1224:       rate = (double)(samples) / (endout - startin);",
          "1226:      intercept = (double)-startin * rate;",
          "1232:      uint32_t *repeatarray = (uint32_t *)malloc(mp4->indexcount * 4 + 4);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1159:      }",
          "1160:      else",
          "1161:      {",
          "1163:      }",
          "1165:      free(repeatarray);",
          "",
          "[Removed Lines]",
          "1162:       rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);",
          "",
          "[Added Lines]",
          "1324:       rate = (double)(samples) / (endout - startin);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1190:      first = -intercept / rate - timo;",
          "1191:      last = first + (double)totalsamples / rate;",
          "1195:      if (firstsampletime) *firstsampletime = first;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1356:      if (usedTimeStamps)  // clips with STMP have the Edit List already applied via GetPayloadTime()",
          "1357:      {",
          "1358:       first += (double)mp4->metadataoffset_clockcount / (double)mp4->clockdemon;",
          "1359:       last += (double)mp4->metadataoffset_clockcount / (double)mp4->clockdemon;",
          "1360:      }",
          "",
          "---------------"
        ],
        "demo/GPMF_mp4reader.h||demo/GPMF_mp4reader.h": [
          "File: demo/GPMF_mp4reader.h -> demo/GPMF_mp4reader.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  uint32_t id;",
          "49: } SampleToChunk;",
          "52: typedef struct mp4object",
          "53: {",
          "54:  uint32_t *metasizes;",
          "55:  uint32_t metasize_count;",
          "56:  uint64_t *metaoffsets;",
          "57:  SampleToChunk *metastsc;",
          "58:  uint32_t metastsc_count;",
          "59:  uint32_t indexcount;",
          "60:  double videolength;",
          "61:  double metadatalength;",
          "62:  uint32_t clockdemon, clockcount;",
          "63:  uint32_t trak_clockdemon, trak_clockcount;",
          "64:  uint32_t meta_clockdemon, meta_clockcount;",
          "65:  double basemetadataduration;",
          "66:  FILE *mediafp;",
          "67:  uint64_t filesize;",
          "68:  uint64_t filepos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "51: #define MAX_TRACKS 16",
          "57:  uint32_t metastco_count;",
          "63:  int32_t metadataoffset_clockcount;",
          "67:  uint32_t video_framerate_numerator;",
          "68:  uint32_t video_framerate_denominator;",
          "69:  uint32_t video_frames;",
          "71:  int32_t trak_edit_list_offsets[MAX_TRACKS];",
          "72:  uint32_t trak_num;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101: size_t OpenMP4SourceUDTA(char *filename);",
          "102: void CloseSource(size_t handle);",
          "103: float GetDuration(size_t handle);",
          "104: uint32_t GetNumberPayloads(size_t handle);",
          "105: uint32_t *GetPayload(size_t handle, uint32_t *lastpayload, uint32_t index);",
          "106: void FreePayload(uint32_t *lastpayload);",
          "107: uint32_t GetPayloadSize(size_t handle, uint32_t index);",
          "108: uint32_t GetPayloadTime(size_t handle, uint32_t index, double *in, double *out); //MP4 timestamps for the payload",
          "111: #define GPMF_SAMPLE_RATE_FAST  0",
          "112: #define GPMF_SAMPLE_RATE_PRECISE 1",
          "",
          "[Removed Lines]",
          "109: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, uint32_t *in_numerator, uint32_t *out_numerator, uint32_t *denominator);",
          "",
          "[Added Lines]",
          "111: uint32_t GetVideoFrameRateAndCount(size_t handle, uint32_t *numer, uint32_t *demon);",
          "117: uint32_t GetPayloadRationalTime(size_t handle, uint32_t index, int32_t *in_numerator, int32_t *out_numerator, uint32_t *denominator);",
          "118: uint32_t GetEditListOffset(size_t handle, double *offset);",
          "119: uint32_t GetEditListOffsetRationalTime(size_t handle, int32_t *offset_numerator, uint32_t *denominator);",
          "",
          "---------------"
        ],
        "demo/GPMF_print.c||demo/GPMF_print.c": [
          "File: demo/GPMF_print.c -> demo/GPMF_print.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "353:     while (arraysize--)",
          "354:     {",
          "356:      J++;",
          "357:     }",
          "358:     if (repeat) DBG_MSG(\" \");",
          "",
          "[Removed Lines]",
          "355:      DBG_MSG(\"%lld,\", BYTESWAP64(*J));",
          "",
          "[Added Lines]",
          "355:      DBG_MSG(\"%lld,\", (long long int)BYTESWAP64(*J));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "371:     while (arraysize--)",
          "372:     {",
          "374:      J++;",
          "375:     }",
          "376:     if (repeat) DBG_MSG(\" \");",
          "",
          "[Removed Lines]",
          "373:      DBG_MSG(\"%llu,\", BYTESWAP64(*J));",
          "",
          "[Added Lines]",
          "373:      DBG_MSG(\"%llu,\", (long long unsigned int)BYTESWAP64(*J));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "423:     GPMF_CopyState(ms, &find_stream);",
          "424:     if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TYPE, GPMF_CURRENT_LEVEL))",
          "425:     {",
          "427:      uint32_t typelen = GPMF_RawDataSize(&find_stream);",
          "428:      int struct_size_of_type;",
          "",
          "[Removed Lines]",
          "426:      char *srctype = GPMF_RawData(&find_stream);",
          "",
          "[Added Lines]",
          "426:      char *srctype = (char *)GPMF_RawData(&find_stream);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "459:         }",
          "460:         for (i = 0; i < elements; i++)",
          "461:         {",
          "463:          printfData(typearray[i], elementsize, 1, bdata);",
          "464:          bdata += elementsize;",
          "465:         }",
          "",
          "[Removed Lines]",
          "462:          int elementsize = GPMF_SizeofType(typearray[i]);",
          "",
          "[Added Lines]",
          "462:          int elementsize = (int)GPMF_SizeofType((GPMF_SampleType)typearray[i]);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
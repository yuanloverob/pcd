{
  "cve_id": "CVE-2015-8959",
  "cve_desc": "coders/dds.c in ImageMagick before 6.9.0-4 Beta allows remote attackers to cause a denial of service (CPU consumption) via a crafted DDS file.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "cc2a4d2ba5371d25c58763e4db2dbc1f4691c0f7",
  "patch_info": {
    "commit_hash": "cc2a4d2ba5371d25c58763e4db2dbc1f4691c0f7",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/cc2a4d2ba5371d25c58763e4db2dbc1f4691c0f7",
    "files": [
      "coders/dds.c"
    ],
    "message": "http://www.imagemagick.org/discourse-server/viewtopic.php?f=3&t=26861",
    "before_after_code_files": [
      "coders/dds.c||coders/dds.c"
    ]
  },
  "patch_diff": {
    "coders/dds.c||coders/dds.c": [
      "File: coders/dds.c -> coders/dds.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2385:         Mipmapcount includes the main image, so start from one",
      "2389:         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;",
      "2390:         (void) SeekBlob(image, offset, SEEK_CUR);",
      "",
      "[Removed Lines]",
      "2387:       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
      "2388:       {",
      "",
      "[Added Lines]",
      "2387:       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
      "2388:       {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2432:         Mipmapcount includes the main image, so start from one",
      "2436:         offset = (MagickOffsetType) w * h * pixel_size;",
      "2437:         (void) SeekBlob(image, offset, SEEK_CUR);",
      "",
      "[Removed Lines]",
      "2434:       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
      "2435:       {",
      "",
      "[Added Lines]",
      "2434:       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
      "2435:       {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d9f5dd8646eb95c35f0d2698289215ab7940786e",
      "candidate_info": {
        "commit_hash": "d9f5dd8646eb95c35f0d2698289215ab7940786e",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/d9f5dd8646eb95c35f0d2698289215ab7940786e",
        "files": [
          "coders/dds.c"
        ],
        "message": "Newlines...",
        "before_after_code_files": [
          "coders/dds.c||coders/dds.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/dds.c||coders/dds.c"
          ],
          "candidate": [
            "coders/dds.c||coders/dds.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/dds.c||coders/dds.c": [
          "File: coders/dds.c -> coders/dds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2181:   ssize_t",
          "2182:     x, y;",
          "2185:     color;",
          "2187:   if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(",
          "2199:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2200:     {",
          "2202:       if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2203:         {",
          "2204:            color=ReadBlobShort(image);",
          "2205:            SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "",
          "[Removed Lines]",
          "2: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "3: %                                                                             %",
          "4: %                                                                             %",
          "5: %                                                                             %",
          "6: %                            DDDD   DDDD   SSSSS                              %",
          "7: %                            D   D  D   D  SS                                 %",
          "8: %                            D   D  D   D   SSS                               %",
          "9: %                            D   D  D   D     SS                              %",
          "10: %                            DDDD   DDDD   SSSSS                              %",
          "11: %                                                                             %",
          "12: %                                                                             %",
          "13: %           Read/Write Microsoft Direct Draw Surface Image Format             %",
          "14: %                                                                             %",
          "15: %                              Software Design                                %",
          "16: %                             Bianca van Schaik                               %",
          "17: %                                March 2008                                   %",
          "18: %                               Dirk Lemstra                                  %",
          "19: %                              September 2013                                 %",
          "20: %                                                                             %",
          "21: %                                                                             %",
          "22: %  Copyright 1999-2014 ImageMagick Studio LLC, a non-profit organization      %",
          "23: %  dedicated to making software imaging solutions freely available.           %",
          "24: %                                                                             %",
          "25: %  You may not use this file except in compliance with the License.  You may  %",
          "26: %  obtain a copy of the License at                                            %",
          "27: %                                                                             %",
          "28: %    http://www.imagemagick.org/script/license.php                            %",
          "29: %                                                                             %",
          "30: %  Unless required by applicable law or agreed to in writing, software        %",
          "31: %  distributed under the License is distributed on an \"AS IS\" BASIS,          %",
          "32: %  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %",
          "33: %  See the License for the specific language governing permissions and        %",
          "34: %  limitations under the License.                                             %",
          "35: %                                                                             %",
          "36: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "37: %",
          "38: %",
          "43:   Include declarations.",
          "45: #include \"MagickCore/studio.h\"",
          "46: #include \"MagickCore/blob.h\"",
          "47: #include \"MagickCore/blob-private.h\"",
          "48: #include \"MagickCore/cache.h\"",
          "49: #include \"MagickCore/colorspace.h\"",
          "50: #include \"MagickCore/exception.h\"",
          "51: #include \"MagickCore/exception-private.h\"",
          "52: #include \"MagickCore/image.h\"",
          "53: #include \"MagickCore/image-private.h\"",
          "54: #include \"MagickCore/list.h\"",
          "55: #include \"MagickCore/log.h\"",
          "56: #include \"MagickCore/magick.h\"",
          "57: #include \"MagickCore/memory_.h\"",
          "58: #include \"MagickCore/monitor.h\"",
          "59: #include \"MagickCore/monitor-private.h\"",
          "60: #include \"MagickCore/profile.h\"",
          "61: #include \"MagickCore/quantum-private.h\"",
          "62: #include \"MagickCore/static.h\"",
          "63: #include \"MagickCore/string_.h\"",
          "64: #include \"MagickCore/module.h\"",
          "65: #include \"MagickCore/transform.h\"",
          "66: #include \"MagickCore/studio.h\"",
          "67: #include \"MagickCore/blob.h\"",
          "68: #include \"MagickCore/blob-private.h\"",
          "69: #include \"MagickCore/colorspace.h\"",
          "70: #include \"MagickCore/colorspace-private.h\"",
          "71: #include \"MagickCore/exception.h\"",
          "72: #include \"MagickCore/exception-private.h\"",
          "73: #include \"MagickCore/compress.h\"",
          "74: #include \"MagickCore/image.h\"",
          "75: #include \"MagickCore/image-private.h\"",
          "76: #include \"MagickCore/list.h\"",
          "77: #include \"MagickCore/magick.h\"",
          "78: #include \"MagickCore/memory_.h\"",
          "79: #include \"MagickCore/monitor.h\"",
          "80: #include \"MagickCore/monitor-private.h\"",
          "81: #include \"MagickCore/option.h\"",
          "82: #include \"MagickCore/pixel-accessor.h\"",
          "83: #include \"MagickCore/quantum.h\"",
          "84: #include \"MagickCore/static.h\"",
          "85: #include \"MagickCore/string_.h\"",
          "86: #include \"MagickCore/string-private.h\"",
          "90:   Definitions",
          "92: #define DDSD_CAPS         0x00000001",
          "93: #define DDSD_HEIGHT       0x00000002",
          "94: #define DDSD_WIDTH        0x00000004",
          "95: #define DDSD_PITCH        0x00000008",
          "96: #define DDSD_PIXELFORMAT  0x00001000",
          "97: #define DDSD_MIPMAPCOUNT  0x00020000",
          "98: #define DDSD_LINEARSIZE   0x00080000",
          "99: #define DDSD_DEPTH        0x00800000",
          "101: #define DDPF_ALPHAPIXELS  0x00000001",
          "102: #define DDPF_FOURCC       0x00000004",
          "103: #define DDPF_RGB          0x00000040",
          "105: #define FOURCC_DXT1       0x31545844",
          "106: #define FOURCC_DXT3       0x33545844",
          "107: #define FOURCC_DXT5       0x35545844",
          "109: #define DDSCAPS_COMPLEX   0x00000008",
          "110: #define DDSCAPS_TEXTURE   0x00001000",
          "111: #define DDSCAPS_MIPMAP    0x00400000",
          "113: #define DDSCAPS2_CUBEMAP  0x00000200",
          "114: #define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400",
          "115: #define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800",
          "116: #define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000",
          "117: #define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000",
          "118: #define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000",
          "119: #define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000",
          "120: #define DDSCAPS2_VOLUME   0x00200000",
          "122: #ifndef SIZE_MAX",
          "123: #define SIZE_MAX ((size_t) -1)",
          "124: #endif",
          "127:   Structure declarations.",
          "129: typedef struct _DDSPixelFormat",
          "130: {",
          "131:   size_t",
          "132:     flags,",
          "133:     fourcc,",
          "134:     rgb_bitcount,",
          "135:     r_bitmask,",
          "136:     g_bitmask,",
          "137:     b_bitmask,",
          "138:     alpha_bitmask;",
          "139: } DDSPixelFormat;",
          "141: typedef struct _DDSInfo",
          "142: {",
          "143:   size_t",
          "144:     flags,",
          "145:     height,",
          "146:     width,",
          "147:     pitchOrLinearSize,",
          "148:     depth,",
          "149:     mipmapcount,",
          "150:     ddscaps1,",
          "151:     ddscaps2;",
          "153:   DDSPixelFormat",
          "154:     pixelformat;",
          "155: } DDSInfo;",
          "157: typedef struct _DDSColors",
          "158: {",
          "159:   unsigned char",
          "160:     r[4],",
          "161:     g[4],",
          "162:     b[4],",
          "163:     a[4];",
          "164: } DDSColors;",
          "166: typedef struct _DDSVector4",
          "167: {",
          "168:   float",
          "169:     x,",
          "170:     y,",
          "171:     z,",
          "172:     w;",
          "173: } DDSVector4;",
          "175: typedef struct _DDSVector3",
          "176: {",
          "177:   float",
          "178:     x,",
          "179:     y,",
          "180:     z;",
          "181: } DDSVector3;",
          "183: typedef struct _DDSSourceBlock",
          "184: {",
          "185:   unsigned char",
          "186:     start,",
          "187:     end,",
          "188:     error;",
          "189: } DDSSourceBlock;",
          "191: typedef struct _DDSSingleColourLookup",
          "192: {",
          "193:   DDSSourceBlock sources[2];",
          "194: } DDSSingleColourLookup;",
          "196: typedef MagickBooleanType",
          "197:   DDSDecoder(Image *, DDSInfo *, ExceptionInfo *);",
          "199: static const DDSSingleColourLookup DDSLookup_5_4[] =",
          "200: {",
          "201:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "202:   { { { 0, 0, 1 }, { 0, 1, 1 } } },",
          "203:   { { { 0, 0, 2 }, { 0, 1, 0 } } },",
          "204:   { { { 0, 0, 3 }, { 0, 1, 1 } } },",
          "205:   { { { 0, 0, 4 }, { 0, 2, 1 } } },",
          "206:   { { { 1, 0, 3 }, { 0, 2, 0 } } },",
          "207:   { { { 1, 0, 2 }, { 0, 2, 1 } } },",
          "208:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "209:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "210:   { { { 1, 0, 1 }, { 1, 2, 1 } } },",
          "211:   { { { 1, 0, 2 }, { 1, 2, 0 } } },",
          "212:   { { { 1, 0, 3 }, { 0, 4, 0 } } },",
          "213:   { { { 1, 0, 4 }, { 0, 5, 1 } } },",
          "214:   { { { 2, 0, 3 }, { 0, 5, 0 } } },",
          "215:   { { { 2, 0, 2 }, { 0, 5, 1 } } },",
          "216:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "217:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "218:   { { { 2, 0, 1 }, { 2, 3, 1 } } },",
          "219:   { { { 2, 0, 2 }, { 2, 3, 0 } } },",
          "220:   { { { 2, 0, 3 }, { 0, 7, 0 } } },",
          "221:   { { { 2, 0, 4 }, { 1, 6, 1 } } },",
          "222:   { { { 3, 0, 3 }, { 1, 6, 0 } } },",
          "223:   { { { 3, 0, 2 }, { 0, 8, 0 } } },",
          "224:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "225:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "226:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "227:   { { { 3, 0, 2 }, { 0, 10, 1 } } },",
          "228:   { { { 3, 0, 3 }, { 0, 10, 0 } } },",
          "229:   { { { 3, 0, 4 }, { 2, 7, 1 } } },",
          "230:   { { { 4, 0, 4 }, { 2, 7, 0 } } },",
          "231:   { { { 4, 0, 3 }, { 0, 11, 0 } } },",
          "232:   { { { 4, 0, 2 }, { 1, 10, 1 } } },",
          "233:   { { { 4, 0, 1 }, { 1, 10, 0 } } },",
          "234:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "235:   { { { 4, 0, 1 }, { 0, 13, 1 } } },",
          "236:   { { { 4, 0, 2 }, { 0, 13, 0 } } },",
          "237:   { { { 4, 0, 3 }, { 0, 13, 1 } } },",
          "238:   { { { 4, 0, 4 }, { 0, 14, 1 } } },",
          "239:   { { { 5, 0, 3 }, { 0, 14, 0 } } },",
          "240:   { { { 5, 0, 2 }, { 2, 11, 1 } } },",
          "241:   { { { 5, 0, 1 }, { 2, 11, 0 } } },",
          "242:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "243:   { { { 5, 0, 1 }, { 1, 14, 1 } } },",
          "244:   { { { 5, 0, 2 }, { 1, 14, 0 } } },",
          "245:   { { { 5, 0, 3 }, { 0, 16, 0 } } },",
          "246:   { { { 5, 0, 4 }, { 0, 17, 1 } } },",
          "247:   { { { 6, 0, 3 }, { 0, 17, 0 } } },",
          "248:   { { { 6, 0, 2 }, { 0, 17, 1 } } },",
          "249:   { { { 6, 0, 1 }, { 0, 18, 1 } } },",
          "250:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "251:   { { { 6, 0, 1 }, { 2, 15, 1 } } },",
          "252:   { { { 6, 0, 2 }, { 2, 15, 0 } } },",
          "253:   { { { 6, 0, 3 }, { 0, 19, 0 } } },",
          "254:   { { { 6, 0, 4 }, { 1, 18, 1 } } },",
          "255:   { { { 7, 0, 3 }, { 1, 18, 0 } } },",
          "256:   { { { 7, 0, 2 }, { 0, 20, 0 } } },",
          "257:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "258:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "259:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "260:   { { { 7, 0, 2 }, { 0, 22, 1 } } },",
          "261:   { { { 7, 0, 3 }, { 0, 22, 0 } } },",
          "262:   { { { 7, 0, 4 }, { 2, 19, 1 } } },",
          "263:   { { { 8, 0, 4 }, { 2, 19, 0 } } },",
          "264:   { { { 8, 0, 3 }, { 0, 23, 0 } } },",
          "265:   { { { 8, 0, 2 }, { 1, 22, 1 } } },",
          "266:   { { { 8, 0, 1 }, { 1, 22, 0 } } },",
          "267:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "268:   { { { 8, 0, 1 }, { 0, 25, 1 } } },",
          "269:   { { { 8, 0, 2 }, { 0, 25, 0 } } },",
          "270:   { { { 8, 0, 3 }, { 0, 25, 1 } } },",
          "271:   { { { 8, 0, 4 }, { 0, 26, 1 } } },",
          "272:   { { { 9, 0, 3 }, { 0, 26, 0 } } },",
          "273:   { { { 9, 0, 2 }, { 2, 23, 1 } } },",
          "274:   { { { 9, 0, 1 }, { 2, 23, 0 } } },",
          "275:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "276:   { { { 9, 0, 1 }, { 1, 26, 1 } } },",
          "277:   { { { 9, 0, 2 }, { 1, 26, 0 } } },",
          "278:   { { { 9, 0, 3 }, { 0, 28, 0 } } },",
          "279:   { { { 9, 0, 4 }, { 0, 29, 1 } } },",
          "280:   { { { 10, 0, 3 }, { 0, 29, 0 } } },",
          "281:   { { { 10, 0, 2 }, { 0, 29, 1 } } },",
          "282:   { { { 10, 0, 1 }, { 0, 30, 1 } } },",
          "283:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "284:   { { { 10, 0, 1 }, { 2, 27, 1 } } },",
          "285:   { { { 10, 0, 2 }, { 2, 27, 0 } } },",
          "286:   { { { 10, 0, 3 }, { 0, 31, 0 } } },",
          "287:   { { { 10, 0, 4 }, { 1, 30, 1 } } },",
          "288:   { { { 11, 0, 3 }, { 1, 30, 0 } } },",
          "289:   { { { 11, 0, 2 }, { 4, 24, 0 } } },",
          "290:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "291:   { { { 11, 0, 0 }, { 1, 31, 0 } } },",
          "292:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "293:   { { { 11, 0, 2 }, { 2, 30, 1 } } },",
          "294:   { { { 11, 0, 3 }, { 2, 30, 0 } } },",
          "295:   { { { 11, 0, 4 }, { 2, 31, 1 } } },",
          "296:   { { { 12, 0, 4 }, { 2, 31, 0 } } },",
          "297:   { { { 12, 0, 3 }, { 4, 27, 0 } } },",
          "298:   { { { 12, 0, 2 }, { 3, 30, 1 } } },",
          "299:   { { { 12, 0, 1 }, { 3, 30, 0 } } },",
          "300:   { { { 12, 0, 0 }, { 4, 28, 0 } } },",
          "301:   { { { 12, 0, 1 }, { 3, 31, 1 } } },",
          "302:   { { { 12, 0, 2 }, { 3, 31, 0 } } },",
          "303:   { { { 12, 0, 3 }, { 3, 31, 1 } } },",
          "304:   { { { 12, 0, 4 }, { 4, 30, 1 } } },",
          "305:   { { { 13, 0, 3 }, { 4, 30, 0 } } },",
          "306:   { { { 13, 0, 2 }, { 6, 27, 1 } } },",
          "307:   { { { 13, 0, 1 }, { 6, 27, 0 } } },",
          "308:   { { { 13, 0, 0 }, { 4, 31, 0 } } },",
          "309:   { { { 13, 0, 1 }, { 5, 30, 1 } } },",
          "310:   { { { 13, 0, 2 }, { 5, 30, 0 } } },",
          "311:   { { { 13, 0, 3 }, { 8, 24, 0 } } },",
          "312:   { { { 13, 0, 4 }, { 5, 31, 1 } } },",
          "313:   { { { 14, 0, 3 }, { 5, 31, 0 } } },",
          "314:   { { { 14, 0, 2 }, { 5, 31, 1 } } },",
          "315:   { { { 14, 0, 1 }, { 6, 30, 1 } } },",
          "316:   { { { 14, 0, 0 }, { 6, 30, 0 } } },",
          "317:   { { { 14, 0, 1 }, { 6, 31, 1 } } },",
          "318:   { { { 14, 0, 2 }, { 6, 31, 0 } } },",
          "319:   { { { 14, 0, 3 }, { 8, 27, 0 } } },",
          "320:   { { { 14, 0, 4 }, { 7, 30, 1 } } },",
          "321:   { { { 15, 0, 3 }, { 7, 30, 0 } } },",
          "322:   { { { 15, 0, 2 }, { 8, 28, 0 } } },",
          "323:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "324:   { { { 15, 0, 0 }, { 7, 31, 0 } } },",
          "325:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "326:   { { { 15, 0, 2 }, { 8, 30, 1 } } },",
          "327:   { { { 15, 0, 3 }, { 8, 30, 0 } } },",
          "328:   { { { 15, 0, 4 }, { 10, 27, 1 } } },",
          "329:   { { { 16, 0, 4 }, { 10, 27, 0 } } },",
          "330:   { { { 16, 0, 3 }, { 8, 31, 0 } } },",
          "331:   { { { 16, 0, 2 }, { 9, 30, 1 } } },",
          "332:   { { { 16, 0, 1 }, { 9, 30, 0 } } },",
          "333:   { { { 16, 0, 0 }, { 12, 24, 0 } } },",
          "334:   { { { 16, 0, 1 }, { 9, 31, 1 } } },",
          "335:   { { { 16, 0, 2 }, { 9, 31, 0 } } },",
          "336:   { { { 16, 0, 3 }, { 9, 31, 1 } } },",
          "337:   { { { 16, 0, 4 }, { 10, 30, 1 } } },",
          "338:   { { { 17, 0, 3 }, { 10, 30, 0 } } },",
          "339:   { { { 17, 0, 2 }, { 10, 31, 1 } } },",
          "340:   { { { 17, 0, 1 }, { 10, 31, 0 } } },",
          "341:   { { { 17, 0, 0 }, { 12, 27, 0 } } },",
          "342:   { { { 17, 0, 1 }, { 11, 30, 1 } } },",
          "343:   { { { 17, 0, 2 }, { 11, 30, 0 } } },",
          "344:   { { { 17, 0, 3 }, { 12, 28, 0 } } },",
          "345:   { { { 17, 0, 4 }, { 11, 31, 1 } } },",
          "346:   { { { 18, 0, 3 }, { 11, 31, 0 } } },",
          "347:   { { { 18, 0, 2 }, { 11, 31, 1 } } },",
          "348:   { { { 18, 0, 1 }, { 12, 30, 1 } } },",
          "349:   { { { 18, 0, 0 }, { 12, 30, 0 } } },",
          "350:   { { { 18, 0, 1 }, { 14, 27, 1 } } },",
          "351:   { { { 18, 0, 2 }, { 14, 27, 0 } } },",
          "352:   { { { 18, 0, 3 }, { 12, 31, 0 } } },",
          "353:   { { { 18, 0, 4 }, { 13, 30, 1 } } },",
          "354:   { { { 19, 0, 3 }, { 13, 30, 0 } } },",
          "355:   { { { 19, 0, 2 }, { 16, 24, 0 } } },",
          "356:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "357:   { { { 19, 0, 0 }, { 13, 31, 0 } } },",
          "358:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "359:   { { { 19, 0, 2 }, { 14, 30, 1 } } },",
          "360:   { { { 19, 0, 3 }, { 14, 30, 0 } } },",
          "361:   { { { 19, 0, 4 }, { 14, 31, 1 } } },",
          "362:   { { { 20, 0, 4 }, { 14, 31, 0 } } },",
          "363:   { { { 20, 0, 3 }, { 16, 27, 0 } } },",
          "364:   { { { 20, 0, 2 }, { 15, 30, 1 } } },",
          "365:   { { { 20, 0, 1 }, { 15, 30, 0 } } },",
          "366:   { { { 20, 0, 0 }, { 16, 28, 0 } } },",
          "367:   { { { 20, 0, 1 }, { 15, 31, 1 } } },",
          "368:   { { { 20, 0, 2 }, { 15, 31, 0 } } },",
          "369:   { { { 20, 0, 3 }, { 15, 31, 1 } } },",
          "370:   { { { 20, 0, 4 }, { 16, 30, 1 } } },",
          "371:   { { { 21, 0, 3 }, { 16, 30, 0 } } },",
          "372:   { { { 21, 0, 2 }, { 18, 27, 1 } } },",
          "373:   { { { 21, 0, 1 }, { 18, 27, 0 } } },",
          "374:   { { { 21, 0, 0 }, { 16, 31, 0 } } },",
          "375:   { { { 21, 0, 1 }, { 17, 30, 1 } } },",
          "376:   { { { 21, 0, 2 }, { 17, 30, 0 } } },",
          "377:   { { { 21, 0, 3 }, { 20, 24, 0 } } },",
          "378:   { { { 21, 0, 4 }, { 17, 31, 1 } } },",
          "379:   { { { 22, 0, 3 }, { 17, 31, 0 } } },",
          "380:   { { { 22, 0, 2 }, { 17, 31, 1 } } },",
          "381:   { { { 22, 0, 1 }, { 18, 30, 1 } } },",
          "382:   { { { 22, 0, 0 }, { 18, 30, 0 } } },",
          "383:   { { { 22, 0, 1 }, { 18, 31, 1 } } },",
          "384:   { { { 22, 0, 2 }, { 18, 31, 0 } } },",
          "385:   { { { 22, 0, 3 }, { 20, 27, 0 } } },",
          "386:   { { { 22, 0, 4 }, { 19, 30, 1 } } },",
          "387:   { { { 23, 0, 3 }, { 19, 30, 0 } } },",
          "388:   { { { 23, 0, 2 }, { 20, 28, 0 } } },",
          "389:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "390:   { { { 23, 0, 0 }, { 19, 31, 0 } } },",
          "391:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "392:   { { { 23, 0, 2 }, { 20, 30, 1 } } },",
          "393:   { { { 23, 0, 3 }, { 20, 30, 0 } } },",
          "394:   { { { 23, 0, 4 }, { 22, 27, 1 } } },",
          "395:   { { { 24, 0, 4 }, { 22, 27, 0 } } },",
          "396:   { { { 24, 0, 3 }, { 20, 31, 0 } } },",
          "397:   { { { 24, 0, 2 }, { 21, 30, 1 } } },",
          "398:   { { { 24, 0, 1 }, { 21, 30, 0 } } },",
          "399:   { { { 24, 0, 0 }, { 24, 24, 0 } } },",
          "400:   { { { 24, 0, 1 }, { 21, 31, 1 } } },",
          "401:   { { { 24, 0, 2 }, { 21, 31, 0 } } },",
          "402:   { { { 24, 0, 3 }, { 21, 31, 1 } } },",
          "403:   { { { 24, 0, 4 }, { 22, 30, 1 } } },",
          "404:   { { { 25, 0, 3 }, { 22, 30, 0 } } },",
          "405:   { { { 25, 0, 2 }, { 22, 31, 1 } } },",
          "406:   { { { 25, 0, 1 }, { 22, 31, 0 } } },",
          "407:   { { { 25, 0, 0 }, { 24, 27, 0 } } },",
          "408:   { { { 25, 0, 1 }, { 23, 30, 1 } } },",
          "409:   { { { 25, 0, 2 }, { 23, 30, 0 } } },",
          "410:   { { { 25, 0, 3 }, { 24, 28, 0 } } },",
          "411:   { { { 25, 0, 4 }, { 23, 31, 1 } } },",
          "412:   { { { 26, 0, 3 }, { 23, 31, 0 } } },",
          "413:   { { { 26, 0, 2 }, { 23, 31, 1 } } },",
          "414:   { { { 26, 0, 1 }, { 24, 30, 1 } } },",
          "415:   { { { 26, 0, 0 }, { 24, 30, 0 } } },",
          "416:   { { { 26, 0, 1 }, { 26, 27, 1 } } },",
          "417:   { { { 26, 0, 2 }, { 26, 27, 0 } } },",
          "418:   { { { 26, 0, 3 }, { 24, 31, 0 } } },",
          "419:   { { { 26, 0, 4 }, { 25, 30, 1 } } },",
          "420:   { { { 27, 0, 3 }, { 25, 30, 0 } } },",
          "421:   { { { 27, 0, 2 }, { 28, 24, 0 } } },",
          "422:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "423:   { { { 27, 0, 0 }, { 25, 31, 0 } } },",
          "424:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "425:   { { { 27, 0, 2 }, { 26, 30, 1 } } },",
          "426:   { { { 27, 0, 3 }, { 26, 30, 0 } } },",
          "427:   { { { 27, 0, 4 }, { 26, 31, 1 } } },",
          "428:   { { { 28, 0, 4 }, { 26, 31, 0 } } },",
          "429:   { { { 28, 0, 3 }, { 28, 27, 0 } } },",
          "430:   { { { 28, 0, 2 }, { 27, 30, 1 } } },",
          "431:   { { { 28, 0, 1 }, { 27, 30, 0 } } },",
          "432:   { { { 28, 0, 0 }, { 28, 28, 0 } } },",
          "433:   { { { 28, 0, 1 }, { 27, 31, 1 } } },",
          "434:   { { { 28, 0, 2 }, { 27, 31, 0 } } },",
          "435:   { { { 28, 0, 3 }, { 27, 31, 1 } } },",
          "436:   { { { 28, 0, 4 }, { 28, 30, 1 } } },",
          "437:   { { { 29, 0, 3 }, { 28, 30, 0 } } },",
          "438:   { { { 29, 0, 2 }, { 30, 27, 1 } } },",
          "439:   { { { 29, 0, 1 }, { 30, 27, 0 } } },",
          "440:   { { { 29, 0, 0 }, { 28, 31, 0 } } },",
          "441:   { { { 29, 0, 1 }, { 29, 30, 1 } } },",
          "442:   { { { 29, 0, 2 }, { 29, 30, 0 } } },",
          "443:   { { { 29, 0, 3 }, { 29, 30, 1 } } },",
          "444:   { { { 29, 0, 4 }, { 29, 31, 1 } } },",
          "445:   { { { 30, 0, 3 }, { 29, 31, 0 } } },",
          "446:   { { { 30, 0, 2 }, { 29, 31, 1 } } },",
          "447:   { { { 30, 0, 1 }, { 30, 30, 1 } } },",
          "448:   { { { 30, 0, 0 }, { 30, 30, 0 } } },",
          "449:   { { { 30, 0, 1 }, { 30, 31, 1 } } },",
          "450:   { { { 30, 0, 2 }, { 30, 31, 0 } } },",
          "451:   { { { 30, 0, 3 }, { 30, 31, 1 } } },",
          "452:   { { { 30, 0, 4 }, { 31, 30, 1 } } },",
          "453:   { { { 31, 0, 3 }, { 31, 30, 0 } } },",
          "454:   { { { 31, 0, 2 }, { 31, 30, 1 } } },",
          "455:   { { { 31, 0, 1 }, { 31, 31, 1 } } },",
          "456:   { { { 31, 0, 0 }, { 31, 31, 0 } } }",
          "457: };",
          "459: static const DDSSingleColourLookup DDSLookup_6_4[] =",
          "460: {",
          "461:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "462:   { { { 0, 0, 1 }, { 0, 1, 0 } } },",
          "463:   { { { 0, 0, 2 }, { 0, 2, 0 } } },",
          "464:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "465:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "466:   { { { 1, 0, 1 }, { 0, 4, 0 } } },",
          "467:   { { { 1, 0, 2 }, { 0, 5, 0 } } },",
          "468:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "469:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "470:   { { { 2, 0, 1 }, { 0, 7, 0 } } },",
          "471:   { { { 2, 0, 2 }, { 0, 8, 0 } } },",
          "472:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "473:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "474:   { { { 3, 0, 1 }, { 0, 10, 0 } } },",
          "475:   { { { 3, 0, 2 }, { 0, 11, 0 } } },",
          "476:   { { { 4, 0, 1 }, { 0, 12, 1 } } },",
          "477:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "478:   { { { 4, 0, 1 }, { 0, 13, 0 } } },",
          "479:   { { { 4, 0, 2 }, { 0, 14, 0 } } },",
          "480:   { { { 5, 0, 1 }, { 0, 15, 1 } } },",
          "481:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "482:   { { { 5, 0, 1 }, { 0, 16, 0 } } },",
          "483:   { { { 5, 0, 2 }, { 1, 15, 0 } } },",
          "484:   { { { 6, 0, 1 }, { 0, 17, 0 } } },",
          "485:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "486:   { { { 6, 0, 1 }, { 0, 19, 0 } } },",
          "487:   { { { 6, 0, 2 }, { 3, 14, 0 } } },",
          "488:   { { { 7, 0, 1 }, { 0, 20, 0 } } },",
          "489:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "490:   { { { 7, 0, 1 }, { 0, 22, 0 } } },",
          "491:   { { { 7, 0, 2 }, { 4, 15, 0 } } },",
          "492:   { { { 8, 0, 1 }, { 0, 23, 0 } } },",
          "493:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "494:   { { { 8, 0, 1 }, { 0, 25, 0 } } },",
          "495:   { { { 8, 0, 2 }, { 6, 14, 0 } } },",
          "496:   { { { 9, 0, 1 }, { 0, 26, 0 } } },",
          "497:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "498:   { { { 9, 0, 1 }, { 0, 28, 0 } } },",
          "499:   { { { 9, 0, 2 }, { 7, 15, 0 } } },",
          "500:   { { { 10, 0, 1 }, { 0, 29, 0 } } },",
          "501:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "502:   { { { 10, 0, 1 }, { 0, 31, 0 } } },",
          "503:   { { { 10, 0, 2 }, { 9, 14, 0 } } },",
          "504:   { { { 11, 0, 1 }, { 0, 32, 0 } } },",
          "505:   { { { 11, 0, 0 }, { 0, 33, 0 } } },",
          "506:   { { { 11, 0, 1 }, { 2, 30, 0 } } },",
          "507:   { { { 11, 0, 2 }, { 0, 34, 0 } } },",
          "508:   { { { 12, 0, 1 }, { 0, 35, 0 } } },",
          "509:   { { { 12, 0, 0 }, { 0, 36, 0 } } },",
          "510:   { { { 12, 0, 1 }, { 3, 31, 0 } } },",
          "511:   { { { 12, 0, 2 }, { 0, 37, 0 } } },",
          "512:   { { { 13, 0, 1 }, { 0, 38, 0 } } },",
          "513:   { { { 13, 0, 0 }, { 0, 39, 0 } } },",
          "514:   { { { 13, 0, 1 }, { 5, 30, 0 } } },",
          "515:   { { { 13, 0, 2 }, { 0, 40, 0 } } },",
          "516:   { { { 14, 0, 1 }, { 0, 41, 0 } } },",
          "517:   { { { 14, 0, 0 }, { 0, 42, 0 } } },",
          "518:   { { { 14, 0, 1 }, { 6, 31, 0 } } },",
          "519:   { { { 14, 0, 2 }, { 0, 43, 0 } } },",
          "520:   { { { 15, 0, 1 }, { 0, 44, 0 } } },",
          "521:   { { { 15, 0, 0 }, { 0, 45, 0 } } },",
          "522:   { { { 15, 0, 1 }, { 8, 30, 0 } } },",
          "523:   { { { 15, 0, 2 }, { 0, 46, 0 } } },",
          "524:   { { { 16, 0, 2 }, { 0, 47, 0 } } },",
          "525:   { { { 16, 0, 1 }, { 1, 46, 0 } } },",
          "526:   { { { 16, 0, 0 }, { 0, 48, 0 } } },",
          "527:   { { { 16, 0, 1 }, { 0, 49, 0 } } },",
          "528:   { { { 16, 0, 2 }, { 0, 50, 0 } } },",
          "529:   { { { 17, 0, 1 }, { 2, 47, 0 } } },",
          "530:   { { { 17, 0, 0 }, { 0, 51, 0 } } },",
          "531:   { { { 17, 0, 1 }, { 0, 52, 0 } } },",
          "532:   { { { 17, 0, 2 }, { 0, 53, 0 } } },",
          "533:   { { { 18, 0, 1 }, { 4, 46, 0 } } },",
          "534:   { { { 18, 0, 0 }, { 0, 54, 0 } } },",
          "535:   { { { 18, 0, 1 }, { 0, 55, 0 } } },",
          "536:   { { { 18, 0, 2 }, { 0, 56, 0 } } },",
          "537:   { { { 19, 0, 1 }, { 5, 47, 0 } } },",
          "538:   { { { 19, 0, 0 }, { 0, 57, 0 } } },",
          "539:   { { { 19, 0, 1 }, { 0, 58, 0 } } },",
          "540:   { { { 19, 0, 2 }, { 0, 59, 0 } } },",
          "541:   { { { 20, 0, 1 }, { 7, 46, 0 } } },",
          "542:   { { { 20, 0, 0 }, { 0, 60, 0 } } },",
          "543:   { { { 20, 0, 1 }, { 0, 61, 0 } } },",
          "544:   { { { 20, 0, 2 }, { 0, 62, 0 } } },",
          "545:   { { { 21, 0, 1 }, { 8, 47, 0 } } },",
          "546:   { { { 21, 0, 0 }, { 0, 63, 0 } } },",
          "547:   { { { 21, 0, 1 }, { 1, 62, 0 } } },",
          "548:   { { { 21, 0, 2 }, { 1, 63, 0 } } },",
          "549:   { { { 22, 0, 1 }, { 10, 46, 0 } } },",
          "550:   { { { 22, 0, 0 }, { 2, 62, 0 } } },",
          "551:   { { { 22, 0, 1 }, { 2, 63, 0 } } },",
          "552:   { { { 22, 0, 2 }, { 3, 62, 0 } } },",
          "553:   { { { 23, 0, 1 }, { 11, 47, 0 } } },",
          "554:   { { { 23, 0, 0 }, { 3, 63, 0 } } },",
          "555:   { { { 23, 0, 1 }, { 4, 62, 0 } } },",
          "556:   { { { 23, 0, 2 }, { 4, 63, 0 } } },",
          "557:   { { { 24, 0, 1 }, { 13, 46, 0 } } },",
          "558:   { { { 24, 0, 0 }, { 5, 62, 0 } } },",
          "559:   { { { 24, 0, 1 }, { 5, 63, 0 } } },",
          "560:   { { { 24, 0, 2 }, { 6, 62, 0 } } },",
          "561:   { { { 25, 0, 1 }, { 14, 47, 0 } } },",
          "562:   { { { 25, 0, 0 }, { 6, 63, 0 } } },",
          "563:   { { { 25, 0, 1 }, { 7, 62, 0 } } },",
          "564:   { { { 25, 0, 2 }, { 7, 63, 0 } } },",
          "565:   { { { 26, 0, 1 }, { 16, 45, 0 } } },",
          "566:   { { { 26, 0, 0 }, { 8, 62, 0 } } },",
          "567:   { { { 26, 0, 1 }, { 8, 63, 0 } } },",
          "568:   { { { 26, 0, 2 }, { 9, 62, 0 } } },",
          "569:   { { { 27, 0, 1 }, { 16, 48, 0 } } },",
          "570:   { { { 27, 0, 0 }, { 9, 63, 0 } } },",
          "571:   { { { 27, 0, 1 }, { 10, 62, 0 } } },",
          "572:   { { { 27, 0, 2 }, { 10, 63, 0 } } },",
          "573:   { { { 28, 0, 1 }, { 16, 51, 0 } } },",
          "574:   { { { 28, 0, 0 }, { 11, 62, 0 } } },",
          "575:   { { { 28, 0, 1 }, { 11, 63, 0 } } },",
          "576:   { { { 28, 0, 2 }, { 12, 62, 0 } } },",
          "577:   { { { 29, 0, 1 }, { 16, 54, 0 } } },",
          "578:   { { { 29, 0, 0 }, { 12, 63, 0 } } },",
          "579:   { { { 29, 0, 1 }, { 13, 62, 0 } } },",
          "580:   { { { 29, 0, 2 }, { 13, 63, 0 } } },",
          "581:   { { { 30, 0, 1 }, { 16, 57, 0 } } },",
          "582:   { { { 30, 0, 0 }, { 14, 62, 0 } } },",
          "583:   { { { 30, 0, 1 }, { 14, 63, 0 } } },",
          "584:   { { { 30, 0, 2 }, { 15, 62, 0 } } },",
          "585:   { { { 31, 0, 1 }, { 16, 60, 0 } } },",
          "586:   { { { 31, 0, 0 }, { 15, 63, 0 } } },",
          "587:   { { { 31, 0, 1 }, { 24, 46, 0 } } },",
          "588:   { { { 31, 0, 2 }, { 16, 62, 0 } } },",
          "589:   { { { 32, 0, 2 }, { 16, 63, 0 } } },",
          "590:   { { { 32, 0, 1 }, { 17, 62, 0 } } },",
          "591:   { { { 32, 0, 0 }, { 25, 47, 0 } } },",
          "592:   { { { 32, 0, 1 }, { 17, 63, 0 } } },",
          "593:   { { { 32, 0, 2 }, { 18, 62, 0 } } },",
          "594:   { { { 33, 0, 1 }, { 18, 63, 0 } } },",
          "595:   { { { 33, 0, 0 }, { 27, 46, 0 } } },",
          "596:   { { { 33, 0, 1 }, { 19, 62, 0 } } },",
          "597:   { { { 33, 0, 2 }, { 19, 63, 0 } } },",
          "598:   { { { 34, 0, 1 }, { 20, 62, 0 } } },",
          "599:   { { { 34, 0, 0 }, { 28, 47, 0 } } },",
          "600:   { { { 34, 0, 1 }, { 20, 63, 0 } } },",
          "601:   { { { 34, 0, 2 }, { 21, 62, 0 } } },",
          "602:   { { { 35, 0, 1 }, { 21, 63, 0 } } },",
          "603:   { { { 35, 0, 0 }, { 30, 46, 0 } } },",
          "604:   { { { 35, 0, 1 }, { 22, 62, 0 } } },",
          "605:   { { { 35, 0, 2 }, { 22, 63, 0 } } },",
          "606:   { { { 36, 0, 1 }, { 23, 62, 0 } } },",
          "607:   { { { 36, 0, 0 }, { 31, 47, 0 } } },",
          "608:   { { { 36, 0, 1 }, { 23, 63, 0 } } },",
          "609:   { { { 36, 0, 2 }, { 24, 62, 0 } } },",
          "610:   { { { 37, 0, 1 }, { 24, 63, 0 } } },",
          "611:   { { { 37, 0, 0 }, { 32, 47, 0 } } },",
          "612:   { { { 37, 0, 1 }, { 25, 62, 0 } } },",
          "613:   { { { 37, 0, 2 }, { 25, 63, 0 } } },",
          "614:   { { { 38, 0, 1 }, { 26, 62, 0 } } },",
          "615:   { { { 38, 0, 0 }, { 32, 50, 0 } } },",
          "616:   { { { 38, 0, 1 }, { 26, 63, 0 } } },",
          "617:   { { { 38, 0, 2 }, { 27, 62, 0 } } },",
          "618:   { { { 39, 0, 1 }, { 27, 63, 0 } } },",
          "619:   { { { 39, 0, 0 }, { 32, 53, 0 } } },",
          "620:   { { { 39, 0, 1 }, { 28, 62, 0 } } },",
          "621:   { { { 39, 0, 2 }, { 28, 63, 0 } } },",
          "622:   { { { 40, 0, 1 }, { 29, 62, 0 } } },",
          "623:   { { { 40, 0, 0 }, { 32, 56, 0 } } },",
          "624:   { { { 40, 0, 1 }, { 29, 63, 0 } } },",
          "625:   { { { 40, 0, 2 }, { 30, 62, 0 } } },",
          "626:   { { { 41, 0, 1 }, { 30, 63, 0 } } },",
          "627:   { { { 41, 0, 0 }, { 32, 59, 0 } } },",
          "628:   { { { 41, 0, 1 }, { 31, 62, 0 } } },",
          "629:   { { { 41, 0, 2 }, { 31, 63, 0 } } },",
          "630:   { { { 42, 0, 1 }, { 32, 61, 0 } } },",
          "631:   { { { 42, 0, 0 }, { 32, 62, 0 } } },",
          "632:   { { { 42, 0, 1 }, { 32, 63, 0 } } },",
          "633:   { { { 42, 0, 2 }, { 41, 46, 0 } } },",
          "634:   { { { 43, 0, 1 }, { 33, 62, 0 } } },",
          "635:   { { { 43, 0, 0 }, { 33, 63, 0 } } },",
          "636:   { { { 43, 0, 1 }, { 34, 62, 0 } } },",
          "637:   { { { 43, 0, 2 }, { 42, 47, 0 } } },",
          "638:   { { { 44, 0, 1 }, { 34, 63, 0 } } },",
          "639:   { { { 44, 0, 0 }, { 35, 62, 0 } } },",
          "640:   { { { 44, 0, 1 }, { 35, 63, 0 } } },",
          "641:   { { { 44, 0, 2 }, { 44, 46, 0 } } },",
          "642:   { { { 45, 0, 1 }, { 36, 62, 0 } } },",
          "643:   { { { 45, 0, 0 }, { 36, 63, 0 } } },",
          "644:   { { { 45, 0, 1 }, { 37, 62, 0 } } },",
          "645:   { { { 45, 0, 2 }, { 45, 47, 0 } } },",
          "646:   { { { 46, 0, 1 }, { 37, 63, 0 } } },",
          "647:   { { { 46, 0, 0 }, { 38, 62, 0 } } },",
          "648:   { { { 46, 0, 1 }, { 38, 63, 0 } } },",
          "649:   { { { 46, 0, 2 }, { 47, 46, 0 } } },",
          "650:   { { { 47, 0, 1 }, { 39, 62, 0 } } },",
          "651:   { { { 47, 0, 0 }, { 39, 63, 0 } } },",
          "652:   { { { 47, 0, 1 }, { 40, 62, 0 } } },",
          "653:   { { { 47, 0, 2 }, { 48, 46, 0 } } },",
          "654:   { { { 48, 0, 2 }, { 40, 63, 0 } } },",
          "655:   { { { 48, 0, 1 }, { 41, 62, 0 } } },",
          "656:   { { { 48, 0, 0 }, { 41, 63, 0 } } },",
          "657:   { { { 48, 0, 1 }, { 48, 49, 0 } } },",
          "658:   { { { 48, 0, 2 }, { 42, 62, 0 } } },",
          "659:   { { { 49, 0, 1 }, { 42, 63, 0 } } },",
          "660:   { { { 49, 0, 0 }, { 43, 62, 0 } } },",
          "661:   { { { 49, 0, 1 }, { 48, 52, 0 } } },",
          "662:   { { { 49, 0, 2 }, { 43, 63, 0 } } },",
          "663:   { { { 50, 0, 1 }, { 44, 62, 0 } } },",
          "664:   { { { 50, 0, 0 }, { 44, 63, 0 } } },",
          "665:   { { { 50, 0, 1 }, { 48, 55, 0 } } },",
          "666:   { { { 50, 0, 2 }, { 45, 62, 0 } } },",
          "667:   { { { 51, 0, 1 }, { 45, 63, 0 } } },",
          "668:   { { { 51, 0, 0 }, { 46, 62, 0 } } },",
          "669:   { { { 51, 0, 1 }, { 48, 58, 0 } } },",
          "670:   { { { 51, 0, 2 }, { 46, 63, 0 } } },",
          "671:   { { { 52, 0, 1 }, { 47, 62, 0 } } },",
          "672:   { { { 52, 0, 0 }, { 47, 63, 0 } } },",
          "673:   { { { 52, 0, 1 }, { 48, 61, 0 } } },",
          "674:   { { { 52, 0, 2 }, { 48, 62, 0 } } },",
          "675:   { { { 53, 0, 1 }, { 56, 47, 0 } } },",
          "676:   { { { 53, 0, 0 }, { 48, 63, 0 } } },",
          "677:   { { { 53, 0, 1 }, { 49, 62, 0 } } },",
          "678:   { { { 53, 0, 2 }, { 49, 63, 0 } } },",
          "679:   { { { 54, 0, 1 }, { 58, 46, 0 } } },",
          "680:   { { { 54, 0, 0 }, { 50, 62, 0 } } },",
          "681:   { { { 54, 0, 1 }, { 50, 63, 0 } } },",
          "682:   { { { 54, 0, 2 }, { 51, 62, 0 } } },",
          "683:   { { { 55, 0, 1 }, { 59, 47, 0 } } },",
          "684:   { { { 55, 0, 0 }, { 51, 63, 0 } } },",
          "685:   { { { 55, 0, 1 }, { 52, 62, 0 } } },",
          "686:   { { { 55, 0, 2 }, { 52, 63, 0 } } },",
          "687:   { { { 56, 0, 1 }, { 61, 46, 0 } } },",
          "688:   { { { 56, 0, 0 }, { 53, 62, 0 } } },",
          "689:   { { { 56, 0, 1 }, { 53, 63, 0 } } },",
          "690:   { { { 56, 0, 2 }, { 54, 62, 0 } } },",
          "691:   { { { 57, 0, 1 }, { 62, 47, 0 } } },",
          "692:   { { { 57, 0, 0 }, { 54, 63, 0 } } },",
          "693:   { { { 57, 0, 1 }, { 55, 62, 0 } } },",
          "694:   { { { 57, 0, 2 }, { 55, 63, 0 } } },",
          "695:   { { { 58, 0, 1 }, { 56, 62, 1 } } },",
          "696:   { { { 58, 0, 0 }, { 56, 62, 0 } } },",
          "697:   { { { 58, 0, 1 }, { 56, 63, 0 } } },",
          "698:   { { { 58, 0, 2 }, { 57, 62, 0 } } },",
          "699:   { { { 59, 0, 1 }, { 57, 63, 1 } } },",
          "700:   { { { 59, 0, 0 }, { 57, 63, 0 } } },",
          "701:   { { { 59, 0, 1 }, { 58, 62, 0 } } },",
          "702:   { { { 59, 0, 2 }, { 58, 63, 0 } } },",
          "703:   { { { 60, 0, 1 }, { 59, 62, 1 } } },",
          "704:   { { { 60, 0, 0 }, { 59, 62, 0 } } },",
          "705:   { { { 60, 0, 1 }, { 59, 63, 0 } } },",
          "706:   { { { 60, 0, 2 }, { 60, 62, 0 } } },",
          "707:   { { { 61, 0, 1 }, { 60, 63, 1 } } },",
          "708:   { { { 61, 0, 0 }, { 60, 63, 0 } } },",
          "709:   { { { 61, 0, 1 }, { 61, 62, 0 } } },",
          "710:   { { { 61, 0, 2 }, { 61, 63, 0 } } },",
          "711:   { { { 62, 0, 1 }, { 62, 62, 1 } } },",
          "712:   { { { 62, 0, 0 }, { 62, 62, 0 } } },",
          "713:   { { { 62, 0, 1 }, { 62, 63, 0 } } },",
          "714:   { { { 62, 0, 2 }, { 63, 62, 0 } } },",
          "715:   { { { 63, 0, 1 }, { 63, 63, 1 } } },",
          "716:   { { { 63, 0, 0 }, { 63, 63, 0 } } }",
          "717: };",
          "719: static const DDSSingleColourLookup*",
          "720:   DDS_LOOKUP[] =",
          "721: {",
          "722:   DDSLookup_5_4,",
          "723:   DDSLookup_6_4,",
          "724:   DDSLookup_5_4",
          "725: };",
          "728:   Macros",
          "730: #define C565_r(x) (((x) & 0xF800) >> 11)",
          "731: #define C565_g(x) (((x) & 0x07E0) >> 5)",
          "732: #define C565_b(x)  ((x) & 0x001F)",
          "734: #define C565_red(x)   ( (C565_r(x) << 3 | C565_r(x) >> 2))",
          "735: #define C565_green(x) ( (C565_g(x) << 2 | C565_g(x) >> 4))",
          "736: #define C565_blue(x)  ( (C565_b(x) << 3 | C565_b(x) >> 2))",
          "738: #define DIV2(x)  ((x) > 1 ? ((x) >> 1) : 1)",
          "740: #define FixRange(min, max, steps) \\",
          "741: if (min > max) \\",
          "742:   min = max; \\",
          "743: if (max - min < steps) \\",
          "744:   max = Min(min + steps, 255); \\",
          "745: if (max - min < steps) \\",
          "746:   min = Max(min - steps, 0)",
          "748: #define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)",
          "750: #define VectorInit(vector, value) vector.x = vector.y = vector.z = vector.w \\",
          "751:   = value",
          "752: #define VectorInit3(vector, value) vector.x = vector.y = vector.z = value",
          "754: #define IsBitMask(mask, r, g, b, a) (mask.r_bitmask == r && mask.g_bitmask == \\",
          "755:   g && mask.b_bitmask == b && mask.alpha_bitmask == a)",
          "758:   Forward declarations",
          "760: static MagickBooleanType",
          "761:   ConstructOrdering(const size_t, const DDSVector4 *, const DDSVector3,",
          "762:   DDSVector4 *, DDSVector4 *, unsigned char *, size_t);",
          "764: static MagickBooleanType",
          "765:   ReadDDSInfo(Image *, DDSInfo *);",
          "767: static void",
          "768:   CalculateColors(unsigned short, unsigned short,",
          "769:     DDSColors *, MagickBooleanType);",
          "771: static MagickBooleanType",
          "772:   ReadDXT1(Image *, DDSInfo *, ExceptionInfo *);",
          "774: static MagickBooleanType",
          "775:   ReadDXT3(Image *, DDSInfo *, ExceptionInfo *);",
          "777: static MagickBooleanType",
          "778:   ReadDXT5(Image *, DDSInfo *, ExceptionInfo *);",
          "780: static MagickBooleanType",
          "781:   ReadUncompressedRGB(Image *, DDSInfo *, ExceptionInfo *);",
          "783: static MagickBooleanType",
          "784:   ReadUncompressedRGBA(Image *, DDSInfo *, ExceptionInfo *);",
          "786: static void",
          "787:   RemapIndices(const ssize_t *, const unsigned char *, unsigned char *);",
          "789: static void",
          "790:   SkipDXTMipmaps(Image *, DDSInfo *, int);",
          "792: static void",
          "793:   SkipRGBMipmaps(Image *, DDSInfo *, int);",
          "795: static",
          "796:   MagickBooleanType WriteDDSImage(const ImageInfo *, Image *, ExceptionInfo *);",
          "798: static void",
          "799:   WriteDDSInfo(Image *, const size_t, const size_t, const size_t);",
          "801: static void",
          "802:   WriteFourCC(Image *, const size_t, const MagickBooleanType,",
          "803:     const MagickBooleanType, ExceptionInfo *);",
          "805: static void",
          "806:   WriteImageData(Image *, const size_t, const size_t, const MagickBooleanType,",
          "807:   const MagickBooleanType, ExceptionInfo *);",
          "809: static void",
          "810:   WriteIndices(Image *, const DDSVector3, const DDSVector3, unsigned char *);",
          "812: static MagickBooleanType",
          "813:   WriteMipmaps(Image *, const size_t, const size_t, const size_t,",
          "814:     const MagickBooleanType, const MagickBooleanType, ExceptionInfo *);",
          "816: static void",
          "817:   WriteSingleColorFit(Image *, const DDSVector4 *, const ssize_t *);",
          "819: static void",
          "820:   WriteUncompressed(Image *, ExceptionInfo *);",
          "822: static inline size_t Max(size_t one, size_t two)",
          "823: {",
          "824:   if (one > two)",
          "825:     return one;",
          "826:   return two;",
          "827: }",
          "829: static inline float MaxF(float one, float two)",
          "830: {",
          "831:   if (one > two)",
          "832:     return one;",
          "833:   return two;",
          "834: }",
          "836: static inline size_t Min(size_t one, size_t two)",
          "837: {",
          "838:   if (one < two)",
          "839:     return one;",
          "840:   return two;",
          "841: }",
          "843: static inline float MinF(float one, float two)",
          "844: {",
          "845:   if (one < two)",
          "846:     return one;",
          "847:   return two;",
          "848: }",
          "850: static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,",
          "851:   DDSVector4 *destination)",
          "852: {",
          "853:   destination->x = left.x + right.x;",
          "854:   destination->y = left.y + right.y;",
          "855:   destination->z = left.z + right.z;",
          "856:   destination->w = left.w + right.w;",
          "857: }",
          "859: static inline void VectorClamp(DDSVector4 *value)",
          "860: {",
          "861:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "862:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "863:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "864:   value->w = MinF(1.0f,MaxF(0.0f,value->w));",
          "865: }",
          "867: static inline void VectorClamp3(DDSVector3 *value)",
          "868: {",
          "869:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "870:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "871:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "872: }",
          "874: static inline void VectorCopy43(const DDSVector4 source,",
          "875:   DDSVector3 *destination)",
          "876: {",
          "877:   destination->x = source.x;",
          "878:   destination->y = source.y;",
          "879:   destination->z = source.z;",
          "880: }",
          "882: static inline void VectorCopy44(const DDSVector4 source,",
          "883:   DDSVector4 *destination)",
          "884: {",
          "885:   destination->x = source.x;",
          "886:   destination->y = source.y;",
          "887:   destination->z = source.z;",
          "888:   destination->w = source.w;",
          "889: }",
          "891: static inline void VectorNegativeMultiplySubtract(const DDSVector4 a,",
          "892:   const DDSVector4 b, const DDSVector4 c, DDSVector4 *destination)",
          "893: {",
          "894:   destination->x = c.x - (a.x * b.x);",
          "895:   destination->y = c.y - (a.y * b.y);",
          "896:   destination->z = c.z - (a.z * b.z);",
          "897:   destination->w = c.w - (a.w * b.w);",
          "898: }",
          "900: static inline void VectorMultiply(const DDSVector4 left,",
          "901:   const DDSVector4 right, DDSVector4 *destination)",
          "902: {",
          "903:   destination->x = left.x * right.x;",
          "904:   destination->y = left.y * right.y;",
          "905:   destination->z = left.z * right.z;",
          "906:   destination->w = left.w * right.w;",
          "907: }",
          "909: static inline void VectorMultiply3(const DDSVector3 left,",
          "910:   const DDSVector3 right, DDSVector3 *destination)",
          "911: {",
          "912:   destination->x = left.x * right.x;",
          "913:   destination->y = left.y * right.y;",
          "914:   destination->z = left.z * right.z;",
          "915: }",
          "917: static inline void VectorMultiplyAdd(const DDSVector4 a, const DDSVector4 b,",
          "918:   const DDSVector4 c, DDSVector4 *destination)",
          "919: {",
          "920:   destination->x = (a.x * b.x) + c.x;",
          "921:   destination->y = (a.y * b.y) + c.y;",
          "922:   destination->z = (a.z * b.z) + c.z;",
          "923:   destination->w = (a.w * b.w) + c.w;",
          "924: }",
          "926: static inline void VectorMultiplyAdd3(const DDSVector3 a, const DDSVector3 b,",
          "927:   const DDSVector3 c, DDSVector3 *destination)",
          "928: {",
          "929:   destination->x = (a.x * b.x) + c.x;",
          "930:   destination->y = (a.y * b.y) + c.y;",
          "931:   destination->z = (a.z * b.z) + c.z;",
          "932: }",
          "934: static inline void VectorReciprocal(const DDSVector4 value,",
          "935:   DDSVector4 *destination)",
          "936: {",
          "937:   destination->x = 1.0f / value.x;",
          "938:   destination->y = 1.0f / value.y;",
          "939:   destination->z = 1.0f / value.z;",
          "940:   destination->w = 1.0f / value.w;",
          "941: }",
          "943: static inline void VectorSubtract(const DDSVector4 left,",
          "944:   const DDSVector4 right, DDSVector4 *destination)",
          "945: {",
          "946:   destination->x = left.x - right.x;",
          "947:   destination->y = left.y - right.y;",
          "948:   destination->z = left.z - right.z;",
          "949:   destination->w = left.w - right.w;",
          "950: }",
          "952: static inline void VectorSubtract3(const DDSVector3 left,",
          "953:   const DDSVector3 right, DDSVector3 *destination)",
          "954: {",
          "955:   destination->x = left.x - right.x;",
          "956:   destination->y = left.y - right.y;",
          "957:   destination->z = left.z - right.z;",
          "958: }",
          "960: static inline void VectorTruncate(DDSVector4 *value)",
          "961: {",
          "962:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "963:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "964:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "965:   value->w = value->w > 0.0f ? floor(value->w) : ceil(value->w);",
          "966: }",
          "968: static inline void VectorTruncate3(DDSVector3 *value)",
          "969: {",
          "970:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "971:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "972:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "973: }",
          "975: static void CalculateColors(unsigned short c0, unsigned short c1,",
          "976:   DDSColors *c, MagickBooleanType ignoreAlpha)",
          "977: {",
          "978:   c->a[0] = c->a[1] = c->a[2] = c->a[3] = 0;",
          "980:   c->r[0] = (unsigned char) C565_red(c0);",
          "981:   c->g[0] = (unsigned char) C565_green(c0);",
          "982:   c->b[0] = (unsigned char) C565_blue(c0);",
          "984:   c->r[1] = (unsigned char) C565_red(c1);",
          "985:   c->g[1] = (unsigned char) C565_green(c1);",
          "986:   c->b[1] = (unsigned char) C565_blue(c1);",
          "988:   if (ignoreAlpha != MagickFalse || c0 > c1)",
          "989:     {",
          "990:       c->r[2] = (unsigned char) ((2 * c->r[0] + c->r[1]) / 3);",
          "991:       c->g[2] = (unsigned char) ((2 * c->g[0] + c->g[1]) / 3);",
          "992:       c->b[2] = (unsigned char) ((2 * c->b[0] + c->b[1]) / 3);",
          "994:       c->r[3] = (unsigned char) ((c->r[0] + 2 * c->r[1]) / 3);",
          "995:       c->g[3] = (unsigned char) ((c->g[0] + 2 * c->g[1]) / 3);",
          "996:       c->b[3] = (unsigned char) ((c->b[0] + 2 * c->b[1]) / 3);",
          "997:     }",
          "998:   else",
          "999:     {",
          "1000:       c->r[2] = (unsigned char) ((c->r[0] + c->r[1]) / 2);",
          "1001:       c->g[2] = (unsigned char) ((c->g[0] + c->g[1]) / 2);",
          "1002:       c->b[2] = (unsigned char) ((c->b[0] + c->b[1]) / 2);",
          "1004:       c->r[3] = c->g[3] = c->b[3] = 0;",
          "1005:       c->a[3] = 255;",
          "1006:     }",
          "1007: }",
          "1009: static size_t CompressAlpha(const size_t min, const size_t max,",
          "1010:   const size_t steps, const ssize_t *alphas, unsigned char* indices)",
          "1011: {",
          "1012:   unsigned char",
          "1013:     codes[8];",
          "1015:   register ssize_t",
          "1016:     i;",
          "1018:   size_t",
          "1019:     error,",
          "1020:     index,",
          "1021:     j,",
          "1022:     least,",
          "1023:     value;",
          "1025:   codes[0] = (unsigned char) min;",
          "1026:   codes[1] = (unsigned char) max;",
          "1027:   codes[6] = 0;",
          "1028:   codes[7] = 255;",
          "1030:   for (i=1; i <  (ssize_t) steps; i++)",
          "1031:     codes[i+1] = (unsigned char) (((steps-i)*min + i*max) / steps);",
          "1033:   error = 0;",
          "1034:   for (i=0; i<16; i++)",
          "1035:   {",
          "1036:     if (alphas[i] == -1)",
          "1037:       {",
          "1038:         indices[i] = 0;",
          "1039:         continue;",
          "1040:       }",
          "1042:     value = alphas[i];",
          "1043:     least = SIZE_MAX;",
          "1044:     index = 0;",
          "1045:     for (j=0; j<8; j++)",
          "1046:     {",
          "1047:       size_t",
          "1048:         dist;",
          "1050:       dist = value - (size_t)codes[j];",
          "1051:       dist *= dist;",
          "1053:       if (dist < least)",
          "1054:         {",
          "1055:           least = dist;",
          "1056:           index = j;",
          "1057:         }",
          "1058:     }",
          "1060:     indices[i] = (unsigned char)index;",
          "1061:     error += least;",
          "1062:   }",
          "1064:   return error;",
          "1065: }",
          "1067: static void CompressClusterFit(const size_t count,",
          "1068:   const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,",
          "1069:   const DDSVector4 metric, DDSVector3 *start, DDSVector3* end,",
          "1070:   unsigned char *indices)",
          "1071: {",
          "1072:   DDSVector3",
          "1073:     axis;",
          "1075:   DDSVector4",
          "1076:     grid,",
          "1077:     gridrcp,",
          "1078:     half,",
          "1079:     onethird_onethird2,",
          "1080:     part0,",
          "1081:     part1,",
          "1082:     part2,",
          "1083:     part3,",
          "1084:     pointsWeights[16],",
          "1085:     two,",
          "1086:     twonineths,",
          "1087:     twothirds_twothirds2,",
          "1088:     xSumwSum;",
          "1090:   float",
          "1091:     bestError = 1e+37f;",
          "1093:   size_t",
          "1094:     bestIteration = 0,",
          "1095:     besti = 0,",
          "1096:     bestj = 0,",
          "1097:     bestk = 0,",
          "1098:     iterationIndex,",
          "1099:     i,",
          "1100:     j,",
          "1101:     k,",
          "1102:     kmin;",
          "1104:   unsigned char",
          "1106:     order[128],",
          "1107:     unordered[16];",
          "1109:   VectorInit(half,0.5f);",
          "1110:   VectorInit(two,2.0f);",
          "1112:   VectorInit(onethird_onethird2,1.0f/3.0f);",
          "1113:   onethird_onethird2.w = 1.0f/9.0f;",
          "1114:   VectorInit(twothirds_twothirds2,2.0f/3.0f);",
          "1115:   twothirds_twothirds2.w = 4.0f/9.0f;",
          "1116:   VectorInit(twonineths,2.0f/9.0f);",
          "1118:   grid.x = 31.0f;",
          "1119:   grid.y = 63.0f;",
          "1120:   grid.z = 31.0f;",
          "1121:   grid.w = 0.0f;",
          "1123:   gridrcp.x = 1.0f/31.0f;",
          "1124:   gridrcp.y = 1.0f/63.0f;",
          "1125:   gridrcp.z = 1.0f/31.0f;",
          "1126:   gridrcp.w = 0.0f;",
          "1128:   xSumwSum.x = 0.0f;",
          "1129:   xSumwSum.y = 0.0f;",
          "1130:   xSumwSum.z = 0.0f;",
          "1131:   xSumwSum.w = 0.0f;",
          "1133:   ConstructOrdering(count,points,principle,pointsWeights,&xSumwSum,order,0);",
          "1135:   for (iterationIndex = 0;;)",
          "1136:   {",
          "1137:     VectorInit(part0,0.0f);",
          "1138:     for (i=0; i < count; i++)",
          "1139:     {",
          "1140:       VectorInit(part1,0.0f);",
          "1141:       for (j=i;;)",
          "1142:       {",
          "1143:         if (j == 0)",
          "1144:           {",
          "1145:             VectorCopy44(pointsWeights[0],&part2);",
          "1146:             kmin = 1;",
          "1147:           }",
          "1148:           else",
          "1149:           {",
          "1150:             VectorInit(part2,0.0f);",
          "1151:             kmin = j;",
          "1152:           }",
          "1154:         for (k=kmin;;)",
          "1155:         {",
          "1156:           DDSVector4",
          "1157:             a,",
          "1158:             alpha2_sum,",
          "1159:             alphax_sum,",
          "1160:             alphabeta_sum,",
          "1161:             b,",
          "1162:             beta2_sum,",
          "1163:             betax_sum,",
          "1164:             e1,",
          "1165:             e2,",
          "1166:             factor;",
          "1168:           float",
          "1169:             error;",
          "1171:           VectorSubtract(xSumwSum,part2,&part3);",
          "1172:           VectorSubtract(part3,part1,&part3);",
          "1173:           VectorSubtract(part3,part0,&part3);",
          "1175:           VectorMultiplyAdd(part1,twothirds_twothirds2,part0,&alphax_sum);",
          "1176:           VectorMultiplyAdd(part2,onethird_onethird2,alphax_sum,&alphax_sum);",
          "1177:           VectorInit(alpha2_sum,alphax_sum.w);",
          "1179:           VectorMultiplyAdd(part2,twothirds_twothirds2,part3,&betax_sum);",
          "1180:           VectorMultiplyAdd(part1,onethird_onethird2,betax_sum,&betax_sum);",
          "1181:           VectorInit(beta2_sum,betax_sum.w);",
          "1183:           VectorAdd(part1,part2,&alphabeta_sum);",
          "1184:           VectorInit(alphabeta_sum,alphabeta_sum.w);",
          "1185:           VectorMultiply(twonineths,alphabeta_sum,&alphabeta_sum);",
          "1187:           VectorMultiply(alpha2_sum,beta2_sum,&factor);",
          "1188:           VectorNegativeMultiplySubtract(alphabeta_sum,alphabeta_sum,factor,",
          "1189:             &factor);",
          "1190:           VectorReciprocal(factor,&factor);",
          "1192:           VectorMultiply(alphax_sum,beta2_sum,&a);",
          "1193:           VectorNegativeMultiplySubtract(betax_sum,alphabeta_sum,a,&a);",
          "1194:           VectorMultiply(a,factor,&a);",
          "1196:           VectorMultiply(betax_sum,alpha2_sum,&b);",
          "1197:           VectorNegativeMultiplySubtract(alphax_sum,alphabeta_sum,b,&b);",
          "1198:           VectorMultiply(b,factor,&b);",
          "1200:           VectorClamp(&a);",
          "1201:           VectorMultiplyAdd(grid,a,half,&a);",
          "1202:           VectorTruncate(&a);",
          "1203:           VectorMultiply(a,gridrcp,&a);",
          "1205:           VectorClamp(&b);",
          "1206:           VectorMultiplyAdd(grid,b,half,&b);",
          "1207:           VectorTruncate(&b);",
          "1208:           VectorMultiply(b,gridrcp,&b);",
          "1210:           VectorMultiply(b,b,&e1);",
          "1211:           VectorMultiply(e1,beta2_sum,&e1);",
          "1212:           VectorMultiply(a,a,&e2);",
          "1213:           VectorMultiplyAdd(e2,alpha2_sum,e1,&e1);",
          "1215:           VectorMultiply(a,b,&e2);",
          "1216:           VectorMultiply(e2,alphabeta_sum,&e2);",
          "1217:           VectorNegativeMultiplySubtract(a,alphax_sum,e2,&e2);",
          "1218:           VectorNegativeMultiplySubtract(b,betax_sum,e2,&e2);",
          "1219:           VectorMultiplyAdd(two,e2,e1,&e2);",
          "1220:           VectorMultiply(e2,metric,&e2);",
          "1222:           error = e2.x + e2.y + e2.z;",
          "1224:           if (error < bestError)",
          "1225:           {",
          "1226:             VectorCopy43(a,start);",
          "1227:             VectorCopy43(b,end);",
          "1228:             bestError = error;",
          "1229:             besti = i;",
          "1230:             bestj = j;",
          "1231:             bestk = k;",
          "1232:             bestIteration = iterationIndex;",
          "1233:           }",
          "1235:           if (k == count)",
          "1236:             break;",
          "1238:           VectorAdd(pointsWeights[k],part2,&part2);",
          "1239:           k++;",
          "1240:         }",
          "1242:         if (j == count)",
          "1243:           break;",
          "1245:         VectorAdd(pointsWeights[j],part1,&part1);",
          "1246:         j++;",
          "1247:       }",
          "1249:       VectorAdd(pointsWeights[i],part0,&part0);",
          "1250:     }",
          "1252:     if (bestIteration != iterationIndex)",
          "1253:       break;",
          "1255:     iterationIndex++;",
          "1256:     if (iterationIndex == 8)",
          "1257:       break;",
          "1259:     VectorSubtract3(*end,*start,&axis);",
          "1260:     if (ConstructOrdering(count,points,axis,pointsWeights,&xSumwSum,order,",
          "1261:       iterationIndex) == MagickFalse)",
          "1262:       break;",
          "1263:   }",
          "1265:   o = order + (16*bestIteration);",
          "1267:   for (i=0; i < besti; i++)",
          "1268:     unordered[o[i]] = 0;",
          "1269:   for (i=besti; i < bestj; i++)",
          "1270:     unordered[o[i]] = 2;",
          "1271:   for (i=bestj; i < bestk; i++)",
          "1272:     unordered[o[i]] = 3;",
          "1273:   for (i=bestk; i < count; i++)",
          "1274:     unordered[o[i]] = 1;",
          "1276:   RemapIndices(map,unordered,indices);",
          "1277: }",
          "1279: static void CompressRangeFit(const size_t count,",
          "1280:   const DDSVector4* points, const ssize_t *map, const DDSVector3 principle,",
          "1281:   const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,",
          "1282:   unsigned char *indices)",
          "1283: {",
          "1284:   float",
          "1285:     d,",
          "1286:     bestDist,",
          "1287:     max,",
          "1288:     min,",
          "1289:     val;",
          "1291:   DDSVector3",
          "1292:     codes[4],",
          "1293:     grid,",
          "1294:     gridrcp,",
          "1295:     half,",
          "1296:     dist;",
          "1298:   register ssize_t",
          "1299:     i;",
          "1301:   size_t",
          "1302:     bestj,",
          "1303:     j;",
          "1305:   unsigned char",
          "1306:     closest[16];",
          "1308:   VectorInit3(half,0.5f);",
          "1310:   grid.x = 31.0f;",
          "1311:   grid.y = 63.0f;",
          "1312:   grid.z = 31.0f;",
          "1314:   gridrcp.x = 1.0f/31.0f;",
          "1315:   gridrcp.y = 1.0f/63.0f;",
          "1316:   gridrcp.z = 1.0f/31.0f;",
          "1318:   if (count > 0)",
          "1319:     {",
          "1320:       VectorCopy43(points[0],start);",
          "1321:       VectorCopy43(points[0],end);",
          "1323:       min = max = Dot(points[0],principle);",
          "1324:       for (i=1; i < (ssize_t) count; i++)",
          "1325:       {",
          "1326:         val = Dot(points[i],principle);",
          "1327:         if (val < min)",
          "1328:         {",
          "1329:           VectorCopy43(points[i],start);",
          "1330:           min = val;",
          "1331:         }",
          "1332:         else if (val > max)",
          "1333:         {",
          "1334:           VectorCopy43(points[i],end);",
          "1335:           max = val;",
          "1336:         }",
          "1337:       }",
          "1338:     }",
          "1340:   VectorClamp3(start);",
          "1341:   VectorMultiplyAdd3(grid,*start,half,start);",
          "1342:   VectorTruncate3(start);",
          "1343:   VectorMultiply3(*start,gridrcp,start);",
          "1345:   VectorClamp3(end);",
          "1346:   VectorMultiplyAdd3(grid,*end,half,end);",
          "1347:   VectorTruncate3(end);",
          "1348:   VectorMultiply3(*end,gridrcp,end);",
          "1350:   codes[0] = *start;",
          "1351:   codes[1] = *end;",
          "1352:   codes[2].x = (start->x * (2.0f/3.0f)) + (end->x * (1.0f/3.0f));",
          "1353:   codes[2].y = (start->y * (2.0f/3.0f)) + (end->y * (1.0f/3.0f));",
          "1354:   codes[2].z = (start->z * (2.0f/3.0f)) + (end->z * (1.0f/3.0f));",
          "1355:   codes[3].x = (start->x * (1.0f/3.0f)) + (end->x * (2.0f/3.0f));",
          "1356:   codes[3].y = (start->y * (1.0f/3.0f)) + (end->y * (2.0f/3.0f));",
          "1357:   codes[3].z = (start->z * (1.0f/3.0f)) + (end->z * (2.0f/3.0f));",
          "1359:   for (i=0; i < (ssize_t) count; i++)",
          "1360:   {",
          "1361:     bestDist = 1e+37f;",
          "1362:     bestj = 0;",
          "1363:     for (j=0; j < 4; j++)",
          "1364:     {",
          "1365:       dist.x = (points[i].x - codes[j].x) * metric.x;",
          "1366:       dist.y = (points[i].y - codes[j].y) * metric.y;",
          "1367:       dist.z = (points[i].z - codes[j].z) * metric.z;",
          "1369:       d = Dot(dist,dist);",
          "1370:       if (d < bestDist)",
          "1371:         {",
          "1372:           bestDist = d;",
          "1373:           bestj = j;",
          "1374:         }",
          "1375:     }",
          "1377:     closest[i] = (unsigned char) bestj;",
          "1378:   }",
          "1380:   RemapIndices(map, closest, indices);",
          "1381: }",
          "1383: static void ComputeEndPoints(const DDSSingleColourLookup *lookup[],",
          "1384:   const unsigned char *color, DDSVector3 *start, DDSVector3 *end,",
          "1385:   unsigned char *index)",
          "1386: {",
          "1387:   register ssize_t",
          "1388:     i;",
          "1390:   size_t",
          "1391:     c,",
          "1392:     maxError = SIZE_MAX;",
          "1394:   for (i=0; i < 2; i++)",
          "1395:   {",
          "1396:     const DDSSourceBlock*",
          "1397:       sources[3];",
          "1399:       size_t",
          "1400:         error = 0;",
          "1402:     for (c=0; c < 3; c++)",
          "1403:     {",
          "1404:       sources[c] = &lookup[c][color[c]].sources[i];",
          "1405:       error += ((size_t) sources[c]->error) * ((size_t) sources[c]->error);",
          "1406:     }",
          "1408:     if (error > maxError)",
          "1409:       continue;",
          "1411:     start->x = (float) sources[0]->start / 31.0f;",
          "1412:     start->y = (float) sources[1]->start / 63.0f;",
          "1413:     start->z = (float) sources[2]->start / 31.0f;",
          "1415:     end->x = (float) sources[0]->end / 31.0f;",
          "1416:     end->y = (float) sources[1]->end / 63.0f;",
          "1417:     end->z = (float) sources[2]->end / 31.0f;",
          "1420:     maxError = error;",
          "1421:   }",
          "1422: }",
          "1424: static void ComputePrincipleComponent(const float *covariance,",
          "1425:   DDSVector3 *principle)",
          "1426: {",
          "1427:   DDSVector4",
          "1428:     row0,",
          "1429:     row1,",
          "1430:     row2,",
          "1431:     v;",
          "1433:   register ssize_t",
          "1434:     i;",
          "1436:   row0.x = covariance[0];",
          "1437:   row0.y = covariance[1];",
          "1438:   row0.z = covariance[2];",
          "1439:   row0.w = 0.0f;",
          "1441:   row1.x = covariance[1];",
          "1442:   row1.y = covariance[3];",
          "1443:   row1.z = covariance[4];",
          "1444:   row1.w = 0.0f;",
          "1446:   row2.x = covariance[2];",
          "1447:   row2.y = covariance[4];",
          "1448:   row2.z = covariance[5];",
          "1449:   row2.w = 0.0f;",
          "1451:   VectorInit(v,1.0f);",
          "1453:   for (i=0; i < 8; i++)",
          "1454:   {",
          "1455:     DDSVector4",
          "1456:       w;",
          "1458:     float",
          "1459:       a;",
          "1461:     w.x = row0.x * v.x;",
          "1462:     w.y = row0.y * v.x;",
          "1463:     w.z = row0.z * v.x;",
          "1464:     w.w = row0.w * v.x;",
          "1466:     w.x = (row1.x * v.y) + w.x;",
          "1467:     w.y = (row1.y * v.y) + w.y;",
          "1468:     w.z = (row1.z * v.y) + w.z;",
          "1469:     w.w = (row1.w * v.y) + w.w;",
          "1471:     w.x = (row2.x * v.z) + w.x;",
          "1472:     w.y = (row2.y * v.z) + w.y;",
          "1473:     w.z = (row2.z * v.z) + w.z;",
          "1474:     w.w = (row2.w * v.z) + w.w;",
          "1476:     a = 1.0f / MaxF(w.x,MaxF(w.y,w.z));",
          "1478:     v.x = w.x * a;",
          "1479:     v.y = w.y * a;",
          "1480:     v.z = w.z * a;",
          "1481:     v.w = w.w * a;",
          "1482:   }",
          "1484:   VectorCopy43(v,principle);",
          "1485: }",
          "1487: static void ComputeWeightedCovariance(const size_t count,",
          "1488:   const DDSVector4 *points, float *covariance)",
          "1489: {",
          "1490:   DDSVector3",
          "1491:     centroid;",
          "1493:   float",
          "1494:     total;",
          "1496:   size_t",
          "1497:     i;",
          "1499:   total = 0.0f;",
          "1500:   VectorInit3(centroid,0.0f);",
          "1502:   for (i=0; i < count; i++)",
          "1503:   {",
          "1504:     total += points[i].w;",
          "1505:     centroid.x += (points[i].x * points[i].w);",
          "1506:     centroid.y += (points[i].y * points[i].w);",
          "1507:     centroid.z += (points[i].z * points[i].w);",
          "1508:   }",
          "1510:   if( total > 1.192092896e-07F)",
          "1511:     {",
          "1512:       centroid.x /= total;",
          "1513:       centroid.y /= total;",
          "1514:       centroid.z /= total;",
          "1515:     }",
          "1517:   for (i=0; i < 6; i++)",
          "1518:     covariance[i] = 0.0f;",
          "1520:   for (i = 0; i < count; i++)",
          "1521:   {",
          "1522:     DDSVector3",
          "1523:       a,",
          "1524:       b;",
          "1526:     a.x = points[i].x - centroid.x;",
          "1527:     a.y = points[i].y - centroid.y;",
          "1528:     a.z = points[i].z - centroid.z;",
          "1530:     b.x = points[i].w * a.x;",
          "1531:     b.y = points[i].w * a.y;",
          "1532:     b.z = points[i].w * a.z;",
          "1534:     covariance[0] += a.x*b.x;",
          "1535:     covariance[1] += a.x*b.y;",
          "1536:     covariance[2] += a.x*b.z;",
          "1537:     covariance[3] += a.y*b.y;",
          "1538:     covariance[4] += a.y*b.z;",
          "1539:     covariance[5] += a.z*b.z;",
          "1540:   }",
          "1541: }",
          "1543: static MagickBooleanType ConstructOrdering(const size_t count,",
          "1544:   const DDSVector4 *points, const DDSVector3 axis, DDSVector4 *pointsWeights,",
          "1545:   DDSVector4 *xSumwSum, unsigned char *order, size_t iteration)",
          "1546: {",
          "1547:   float",
          "1548:      dps[16],",
          "1549:      f;",
          "1551:   register ssize_t",
          "1552:     i;",
          "1554:   size_t",
          "1555:     j;",
          "1557:   unsigned char",
          "1558:     c,",
          "1562:   o = order + (16*iteration);",
          "1564:   for (i=0; i < (ssize_t) count; i++)",
          "1565:   {",
          "1566:     dps[i] = Dot(points[i],axis);",
          "1567:     o[i] = (unsigned char)i;",
          "1568:   }",
          "1570:   for (i=0; i < (ssize_t) count; i++)",
          "1571:   {",
          "1572:     for (j=i; j > 0 && dps[j] < dps[j - 1]; j--)",
          "1573:     {",
          "1574:       f = dps[j];",
          "1575:       dps[j] = dps[j - 1];",
          "1576:       dps[j - 1] = f;",
          "1578:       c = o[j];",
          "1579:       o[j] = o[j - 1];",
          "1580:       o[j - 1] = c;",
          "1581:     }",
          "1582:   }",
          "1584:   for (i=0; i < (ssize_t) iteration; i++)",
          "1585:   {",
          "1586:     MagickBooleanType",
          "1587:       same;",
          "1589:     p = order + (16*i);",
          "1590:     same = MagickTrue;",
          "1592:     for (j=0; j < count; j++)",
          "1593:     {",
          "1594:       if (o[j] != p[j])",
          "1595:         {",
          "1596:           same = MagickFalse;",
          "1597:           break;",
          "1598:         }",
          "1599:     }",
          "1601:     if (same != MagickFalse)",
          "1602:       return MagickFalse;",
          "1603:   }",
          "1605:   xSumwSum->x = 0;",
          "1606:   xSumwSum->y = 0;",
          "1607:   xSumwSum->z = 0;",
          "1608:   xSumwSum->w = 0;",
          "1610:   for (i=0; i < (ssize_t) count; i++)",
          "1611:   {",
          "1612:     DDSVector4",
          "1613:       v;",
          "1615:     j = (size_t) o[i];",
          "1617:     v.x = points[j].w * points[j].x;",
          "1618:     v.y = points[j].w * points[j].y;",
          "1619:     v.z = points[j].w * points[j].z;",
          "1620:     v.w = points[j].w * 1.0f;",
          "1622:     VectorCopy44(v,&pointsWeights[i]);",
          "1623:     VectorAdd(*xSumwSum,v,xSumwSum);",
          "1624:   }",
          "1626:   return MagickTrue;",
          "1627: }",
          "1630: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1631: %                                                                             %",
          "1632: %                                                                             %",
          "1633: %                                                                             %",
          "1634: %   I s D D S                                                                 %",
          "1635: %                                                                             %",
          "1636: %                                                                             %",
          "1637: %                                                                             %",
          "1638: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1639: %",
          "1640: %  IsDDS() returns MagickTrue if the image format type, identified by the",
          "1641: %  magick string, is DDS.",
          "1642: %",
          "1643: %  The format of the IsDDS method is:",
          "1644: %",
          "1645: %      MagickBooleanType IsDDS(const unsigned char *magick,const size_t length)",
          "1646: %",
          "1647: %  A description of each parameter follows:",
          "1648: %",
          "1649: %    o magick: compare image format pattern against these bytes.",
          "1650: %",
          "1651: %    o length: Specifies the length of the magick string.",
          "1652: %",
          "1654: static MagickBooleanType IsDDS(const unsigned char *magick, const size_t length)",
          "1655: {",
          "1656:   if (length < 4)",
          "1657:     return(MagickFalse);",
          "1658:   if (LocaleNCompare((char *) magick,\"DDS \", 4) == 0)",
          "1659:     return(MagickTrue);",
          "1660:   return(MagickFalse);",
          "1661: }",
          "1663: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1664: %                                                                             %",
          "1665: %                                                                             %",
          "1666: %                                                                             %",
          "1667: %   R e a d D D S I m a g e                                                   %",
          "1668: %                                                                             %",
          "1669: %                                                                             %",
          "1670: %                                                                             %",
          "1671: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1672: %",
          "1673: %  ReadDDSImage() reads a DirectDraw Surface image file and returns it.  It",
          "1674: %  allocates the memory necessary for the new Image structure and returns a",
          "1675: %  pointer to the new image.",
          "1676: %",
          "1677: %  The format of the ReadDDSImage method is:",
          "1678: %",
          "1679: %      Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1680: %",
          "1681: %  A description of each parameter follows:",
          "1682: %",
          "1683: %    o image_info: The image info.",
          "1684: %",
          "1685: %    o exception: return any errors or warnings in this structure.",
          "1686: %",
          "1689: static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1690: {",
          "1691:   Image",
          "1694:   MagickBooleanType",
          "1695:     status,",
          "1696:     cubemap = MagickFalse,",
          "1697:     volume = MagickFalse;",
          "1699:   CompressionType",
          "1700:     compression;",
          "1702:   DDSInfo",
          "1703:     dds_info;",
          "1705:   DDSDecoder",
          "1708:   PixelTrait",
          "1709:     alpha_trait;",
          "1711:   size_t",
          "1712:     n,",
          "1713:     num_images;",
          "1716:     Open image file.",
          "1718:   assert(image_info != (const ImageInfo *) NULL);",
          "1719:   assert(image_info->signature == MagickSignature);",
          "1720:   if (image_info->debug != MagickFalse)",
          "1721:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",",
          "1722:       image_info->filename);",
          "1723:   assert(exception != (ExceptionInfo *) NULL);",
          "1724:   assert(exception->signature == MagickSignature);",
          "1725:   image=AcquireImage(image_info,exception);",
          "1726:   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);",
          "1727:   if (status == MagickFalse)",
          "1728:     {",
          "1729:       image=DestroyImageList(image);",
          "1730:       return((Image *) NULL);",
          "1731:     }",
          "1734:     Initialize image structure.",
          "1736:   if (ReadDDSInfo(image, &dds_info) != MagickTrue) {",
          "1737:     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "1738:   }",
          "1740:   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)",
          "1741:     cubemap = MagickTrue;",
          "1743:   if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)",
          "1744:     volume = MagickTrue;",
          "1746:   (void) SeekBlob(image, 128, SEEK_SET);",
          "1749:     Determine pixel format",
          "1751:   if (dds_info.pixelformat.flags & DDPF_RGB)",
          "1752:     {",
          "1753:       compression = NoCompression;",
          "1754:       if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)",
          "1755:         {",
          "1756:           alpha_trait = BlendPixelTrait;",
          "1757:           decoder = ReadUncompressedRGBA;",
          "1758:         }",
          "1759:       else",
          "1760:         {",
          "1761:           alpha_trait = UndefinedPixelTrait;",
          "1762:           decoder = ReadUncompressedRGB;",
          "1763:         }",
          "1764:     }",
          "1765:   else if (dds_info.pixelformat.flags & DDPF_FOURCC)",
          "1766:     {",
          "1767:       switch (dds_info.pixelformat.fourcc)",
          "1768:       {",
          "1769:         case FOURCC_DXT1:",
          "1770:         {",
          "1771:           alpha_trait = UndefinedPixelTrait;",
          "1772:           compression = DXT1Compression;",
          "1773:           decoder = ReadDXT1;",
          "1774:           break;",
          "1775:         }",
          "1777:         case FOURCC_DXT3:",
          "1778:         {",
          "1779:           alpha_trait = BlendPixelTrait;",
          "1780:           compression = DXT3Compression;",
          "1781:           decoder = ReadDXT3;",
          "1782:           break;",
          "1783:         }",
          "1785:         case FOURCC_DXT5:",
          "1786:         {",
          "1787:           alpha_trait = BlendPixelTrait;",
          "1788:           compression = DXT5Compression;",
          "1789:           decoder = ReadDXT5;",
          "1790:           break;",
          "1791:         }",
          "1793:         default:",
          "1794:         {",
          "1796:           ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1797:         }",
          "1798:       }",
          "1799:     }",
          "1800:   else",
          "1801:     {",
          "1803:       ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1804:     }",
          "1806:   num_images = 1;",
          "1807:   if (cubemap)",
          "1808:     {",
          "1810:         Determine number of faces defined in the cubemap",
          "1812:       num_images = 0;",
          "1813:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;",
          "1814:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;",
          "1815:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;",
          "1816:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;",
          "1817:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;",
          "1818:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;",
          "1819:     }",
          "1821:   if (volume)",
          "1822:     num_images = dds_info.depth;",
          "1824:   for (n = 0; n < num_images; n++)",
          "1825:   {",
          "1826:     if (n != 0)",
          "1827:       {",
          "1829:         AcquireNextImage(image_info,image,exception);",
          "1830:         if (GetNextImageInList(image) == (Image *) NULL)",
          "1831:           return(DestroyImageList(image));",
          "1832:         image=SyncNextImageInList(image);",
          "1833:       }",
          "1835:     image->alpha_trait=alpha_trait;",
          "1836:     image->compression = compression;",
          "1837:     image->columns = dds_info.width;",
          "1838:     image->rows = dds_info.height;",
          "1839:     image->storage_class = DirectClass;",
          "1840:     image->endian = LSBEndian;",
          "1841:     image->depth = 8;",
          "1842:     if (image_info->ping != MagickFalse)",
          "1843:       {",
          "1844:         (void) CloseBlob(image);",
          "1845:         return(GetFirstImageInList(image));",
          "1846:       }",
          "1848:     if ((decoder)(image, &dds_info, exception) != MagickTrue)",
          "1849:       {",
          "1850:         (void) CloseBlob(image);",
          "1851:         return(GetFirstImageInList(image));",
          "1852:       }",
          "1853:   }",
          "1855:   if (EOFBlob(image) != MagickFalse)",
          "1856:     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "1857:       image->filename);",
          "1859:   (void) CloseBlob(image);",
          "1860:   return(GetFirstImageInList(image));",
          "1861: }",
          "1863: static MagickBooleanType ReadDDSInfo(Image *image, DDSInfo *dds_info)",
          "1864: {",
          "1865:   size_t",
          "1866:     hdr_size,",
          "1867:     required;",
          "1870:   (void) SeekBlob(image, 4, SEEK_SET);",
          "1873:   hdr_size = ReadBlobLSBLong(image);",
          "1874:   if (hdr_size != 124)",
          "1875:     return MagickFalse;",
          "1878:   dds_info->flags = ReadBlobLSBLong(image);",
          "1881:   required=(size_t) (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);",
          "1882:   if ((dds_info->flags & required) != required)",
          "1883:     return MagickFalse;",
          "1885:   dds_info->height = ReadBlobLSBLong(image);",
          "1886:   dds_info->width = ReadBlobLSBLong(image);",
          "1887:   dds_info->pitchOrLinearSize = ReadBlobLSBLong(image);",
          "1888:   dds_info->depth = ReadBlobLSBLong(image);",
          "1889:   dds_info->mipmapcount = ReadBlobLSBLong(image);",
          "1894:   hdr_size = ReadBlobLSBLong(image);",
          "1895:   if (hdr_size != 32)",
          "1896:     return MagickFalse;",
          "1898:   dds_info->pixelformat.flags = ReadBlobLSBLong(image);",
          "1899:   dds_info->pixelformat.fourcc = ReadBlobLSBLong(image);",
          "1900:   dds_info->pixelformat.rgb_bitcount = ReadBlobLSBLong(image);",
          "1901:   dds_info->pixelformat.r_bitmask = ReadBlobLSBLong(image);",
          "1902:   dds_info->pixelformat.g_bitmask = ReadBlobLSBLong(image);",
          "1903:   dds_info->pixelformat.b_bitmask = ReadBlobLSBLong(image);",
          "1904:   dds_info->pixelformat.alpha_bitmask = ReadBlobLSBLong(image);",
          "1906:   dds_info->ddscaps1 = ReadBlobLSBLong(image);",
          "1907:   dds_info->ddscaps2 = ReadBlobLSBLong(image);",
          "1910:   return MagickTrue;",
          "1911: }",
          "1913: static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,",
          "1914:   ExceptionInfo *exception)",
          "1915: {",
          "1916:   DDSColors",
          "1917:     colors;",
          "1919:   register Quantum",
          "1922:   register ssize_t",
          "1923:     i,",
          "1924:     x;",
          "1926:   size_t",
          "1927:     bits;",
          "1929:   ssize_t",
          "1930:     j,",
          "1931:     y;",
          "1933:   unsigned char",
          "1934:     code;",
          "1936:   unsigned short",
          "1937:     c0,",
          "1938:     c1;",
          "1940:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "1941:   {",
          "1942:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "1943:     {",
          "1945:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "1946:         Min(4, dds_info->height - y),exception);",
          "1948:       if (q == (Quantum *) NULL)",
          "1949:         return MagickFalse;",
          "1952:       c0 = ReadBlobLSBShort(image);",
          "1953:       c1 = ReadBlobLSBShort(image);",
          "1954:       bits = ReadBlobLSBLong(image);",
          "1956:       CalculateColors(c0, c1, &colors, MagickFalse);",
          "1959:       for (j = 0; j < 4; j++)",
          "1960:       {",
          "1961:         for (i = 0; i < 4; i++)",
          "1962:         {",
          "1963:           if ((x + i) < (ssize_t) dds_info->width &&",
          "1964:               (y + j) < (ssize_t) dds_info->height)",
          "1965:             {",
          "1966:               code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);",
          "1967:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "1968:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "1969:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "1970:               SetPixelAlpha(image,ScaleCharToQuantum(colors.a[code]),q);",
          "1971:               if (colors.a[code] && (image->alpha_trait != BlendPixelTrait))",
          "1973:               q+=GetPixelChannels(image);",
          "1974:             }",
          "1975:         }",
          "1976:       }",
          "1978:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "1979:         return MagickFalse;",
          "1980:     }",
          "1981:   }",
          "1983:   SkipDXTMipmaps(image, dds_info, 8);",
          "1985:   return MagickTrue;",
          "1986: }",
          "1988: static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,",
          "1989:   ExceptionInfo *exception)",
          "1990: {",
          "1991:   DDSColors",
          "1992:     colors;",
          "1994:   register Quantum",
          "1997:   register ssize_t",
          "1998:     i,",
          "1999:     x;",
          "2001:   unsigned char",
          "2002:     alpha;",
          "2004:   size_t",
          "2005:     a0,",
          "2006:     a1,",
          "2007:     bits,",
          "2008:     code;",
          "2010:   ssize_t",
          "2011:     j,",
          "2012:     y;",
          "2014:   unsigned short",
          "2015:     c0,",
          "2016:     c1;",
          "2018:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2019:   {",
          "2020:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2021:     {",
          "2023:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2024:                          Min(4, dds_info->height - y),exception);",
          "2026:       if (q == (Quantum *) NULL)",
          "2027:         return MagickFalse;",
          "2030:       a0 = ReadBlobLSBLong(image);",
          "2031:       a1 = ReadBlobLSBLong(image);",
          "2034:       c0 = ReadBlobLSBShort(image);",
          "2035:       c1 = ReadBlobLSBShort(image);",
          "2036:       bits = ReadBlobLSBLong(image);",
          "2038:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2041:       for (j = 0; j < 4; j++)",
          "2042:       {",
          "2043:         for (i = 0; i < 4; i++)",
          "2044:         {",
          "2045:           if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)",
          "2046:             {",
          "2047:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2048:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2049:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2050:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2052:                 Extract alpha value: multiply 0..15 by 17 to get range 0..255",
          "2054:               if (j < 2)",
          "2055:                 alpha = 17U * (unsigned char) ((a0 >> (4*(4*j+i))) & 0xf);",
          "2056:               else",
          "2057:                 alpha = 17U * (unsigned char) ((a1 >> (4*(4*(j-2)+i))) & 0xf);",
          "2058:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2059:               q+=GetPixelChannels(image);",
          "2060:             }",
          "2061:         }",
          "2062:       }",
          "2064:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2065:         return MagickFalse;",
          "2066:     }",
          "2067:   }",
          "2069:   SkipDXTMipmaps(image, dds_info, 16);",
          "2071:   return MagickTrue;",
          "2072: }",
          "2074: static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,",
          "2075:   ExceptionInfo *exception)",
          "2076: {",
          "2077:   DDSColors",
          "2078:     colors;",
          "2080:   MagickSizeType",
          "2081:     alpha_bits;",
          "2083:   register Quantum",
          "2086:   register ssize_t",
          "2087:     i,",
          "2088:     x;",
          "2090:   unsigned char",
          "2091:     a0,",
          "2092:     a1;",
          "2094:   size_t",
          "2095:     alpha,",
          "2096:     bits,",
          "2097:     code,",
          "2098:     alpha_code;",
          "2100:   ssize_t",
          "2101:     j,",
          "2102:     y;",
          "2104:   unsigned short",
          "2105:     c0,",
          "2106:     c1;",
          "2108:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2109:   {",
          "2110:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2111:     {",
          "2113:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2114:                          Min(4, dds_info->height - y),exception);",
          "2116:       if (q == (Quantum *) NULL)",
          "2117:         return MagickFalse;",
          "2120:       a0 = (unsigned char) ReadBlobByte(image);",
          "2121:       a1 = (unsigned char) ReadBlobByte(image);",
          "2123:       alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);",
          "2124:       alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);",
          "2127:       c0 = ReadBlobLSBShort(image);",
          "2128:       c1 = ReadBlobLSBShort(image);",
          "2129:       bits = ReadBlobLSBLong(image);",
          "2131:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2134:       for (j = 0; j < 4; j++)",
          "2135:       {",
          "2136:         for (i = 0; i < 4; i++)",
          "2137:         {",
          "2138:           if ((x + i) < (ssize_t) dds_info->width &&",
          "2139:               (y + j) < (ssize_t) dds_info->height)",
          "2140:             {",
          "2141:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2142:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2143:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2144:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2146:               alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;",
          "2147:               if (alpha_code == 0)",
          "2148:                 alpha = a0;",
          "2149:               else if (alpha_code == 1)",
          "2150:                 alpha = a1;",
          "2151:               else if (a0 > a1)",
          "2152:                 alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;",
          "2153:               else if (alpha_code == 6)",
          "2154:                 alpha = 0;",
          "2155:               else if (alpha_code == 7)",
          "2156:                 alpha = 255;",
          "2157:               else",
          "2158:                 alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);",
          "2159:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2160:               q+=GetPixelChannels(image);",
          "2161:             }",
          "2162:         }",
          "2163:       }",
          "2165:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2166:         return MagickFalse;",
          "2167:     }",
          "2168:   }",
          "2170:   SkipDXTMipmaps(image, dds_info, 16);",
          "2172:   return MagickTrue;",
          "2173: }",
          "2175: static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,",
          "2176:   ExceptionInfo *exception)",
          "2177: {",
          "2178:   register Quantum",
          "2184:   unsigned short",
          "2188:     dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))",
          "2189:     ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2190:       image->filename);",
          "2192:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2193:   {",
          "2194:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2196:     if (q == (Quantum *) NULL)",
          "2197:       return MagickFalse;",
          "",
          "[Added Lines]",
          "4: %                                                                             %",
          "5: %                                                                             %",
          "6: %                            DDDD   DDDD   SSSSS                              %",
          "7: %                            D   D  D   D  SS                                 %",
          "8: %                            D   D  D   D   SSS                               %",
          "9: %                            D   D  D   D     SS                              %",
          "10: %                            DDDD   DDDD   SSSSS                              %",
          "11: %                                                                             %",
          "12: %                                                                             %",
          "13: %           Read/Write Microsoft Direct Draw Surface Image Format             %",
          "14: %                                                                             %",
          "15: %                              Software Design                                %",
          "16: %                             Bianca van Schaik                               %",
          "17: %                                March 2008                                   %",
          "18: %                               Dirk Lemstra                                  %",
          "19: %                              September 2013                                 %",
          "20: %                                                                             %",
          "21: %                                                                             %",
          "22: %  Copyright 1999-2014 ImageMagick Studio LLC, a non-profit organization      %",
          "23: %  dedicated to making software imaging solutions freely available.           %",
          "24: %                                                                             %",
          "25: %  You may not use this file except in compliance with the License.  You may  %",
          "26: %  obtain a copy of the License at                                            %",
          "27: %                                                                             %",
          "28: %    http://www.imagemagick.org/script/license.php                            %",
          "29: %                                                                             %",
          "30: %  Unless required by applicable law or agreed to in writing, software        %",
          "31: %  distributed under the License is distributed on an \"AS IS\" BASIS,          %",
          "32: %  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %",
          "33: %  See the License for the specific language governing permissions and        %",
          "34: %  limitations under the License.                                             %",
          "35: %                                                                             %",
          "36: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "37: %",
          "38: %",
          "43:   Include declarations.",
          "45: #include \"MagickCore/studio.h\"",
          "46: #include \"MagickCore/blob.h\"",
          "47: #include \"MagickCore/blob-private.h\"",
          "48: #include \"MagickCore/cache.h\"",
          "49: #include \"MagickCore/colorspace.h\"",
          "50: #include \"MagickCore/exception.h\"",
          "51: #include \"MagickCore/exception-private.h\"",
          "52: #include \"MagickCore/image.h\"",
          "53: #include \"MagickCore/image-private.h\"",
          "54: #include \"MagickCore/list.h\"",
          "55: #include \"MagickCore/log.h\"",
          "56: #include \"MagickCore/magick.h\"",
          "57: #include \"MagickCore/memory_.h\"",
          "58: #include \"MagickCore/monitor.h\"",
          "59: #include \"MagickCore/monitor-private.h\"",
          "60: #include \"MagickCore/profile.h\"",
          "61: #include \"MagickCore/quantum-private.h\"",
          "62: #include \"MagickCore/static.h\"",
          "63: #include \"MagickCore/string_.h\"",
          "64: #include \"MagickCore/module.h\"",
          "65: #include \"MagickCore/transform.h\"",
          "66: #include \"MagickCore/studio.h\"",
          "67: #include \"MagickCore/blob.h\"",
          "68: #include \"MagickCore/blob-private.h\"",
          "69: #include \"MagickCore/colorspace.h\"",
          "70: #include \"MagickCore/colorspace-private.h\"",
          "71: #include \"MagickCore/exception.h\"",
          "72: #include \"MagickCore/exception-private.h\"",
          "73: #include \"MagickCore/compress.h\"",
          "74: #include \"MagickCore/image.h\"",
          "75: #include \"MagickCore/image-private.h\"",
          "76: #include \"MagickCore/list.h\"",
          "77: #include \"MagickCore/magick.h\"",
          "78: #include \"MagickCore/memory_.h\"",
          "79: #include \"MagickCore/monitor.h\"",
          "80: #include \"MagickCore/monitor-private.h\"",
          "81: #include \"MagickCore/option.h\"",
          "82: #include \"MagickCore/pixel-accessor.h\"",
          "83: #include \"MagickCore/quantum.h\"",
          "84: #include \"MagickCore/static.h\"",
          "85: #include \"MagickCore/string_.h\"",
          "86: #include \"MagickCore/string-private.h\"",
          "90:   Definitions",
          "92: #define DDSD_CAPS         0x00000001",
          "93: #define DDSD_HEIGHT       0x00000002",
          "94: #define DDSD_WIDTH        0x00000004",
          "95: #define DDSD_PITCH        0x00000008",
          "96: #define DDSD_PIXELFORMAT  0x00001000",
          "97: #define DDSD_MIPMAPCOUNT  0x00020000",
          "98: #define DDSD_LINEARSIZE   0x00080000",
          "99: #define DDSD_DEPTH        0x00800000",
          "101: #define DDPF_ALPHAPIXELS  0x00000001",
          "102: #define DDPF_FOURCC       0x00000004",
          "103: #define DDPF_RGB          0x00000040",
          "105: #define FOURCC_DXT1       0x31545844",
          "106: #define FOURCC_DXT3       0x33545844",
          "107: #define FOURCC_DXT5       0x35545844",
          "109: #define DDSCAPS_COMPLEX   0x00000008",
          "110: #define DDSCAPS_TEXTURE   0x00001000",
          "111: #define DDSCAPS_MIPMAP    0x00400000",
          "113: #define DDSCAPS2_CUBEMAP  0x00000200",
          "114: #define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400",
          "115: #define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800",
          "116: #define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000",
          "117: #define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000",
          "118: #define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000",
          "119: #define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000",
          "120: #define DDSCAPS2_VOLUME   0x00200000",
          "122: #ifndef SIZE_MAX",
          "123: #define SIZE_MAX ((size_t) -1)",
          "124: #endif",
          "127:   Structure declarations.",
          "129: typedef struct _DDSPixelFormat",
          "130: {",
          "131:   size_t",
          "132:     flags,",
          "133:     fourcc,",
          "134:     rgb_bitcount,",
          "135:     r_bitmask,",
          "136:     g_bitmask,",
          "137:     b_bitmask,",
          "138:     alpha_bitmask;",
          "139: } DDSPixelFormat;",
          "141: typedef struct _DDSInfo",
          "142: {",
          "143:   size_t",
          "144:     flags,",
          "145:     height,",
          "146:     width,",
          "147:     pitchOrLinearSize,",
          "148:     depth,",
          "149:     mipmapcount,",
          "150:     ddscaps1,",
          "151:     ddscaps2;",
          "153:   DDSPixelFormat",
          "154:     pixelformat;",
          "155: } DDSInfo;",
          "157: typedef struct _DDSColors",
          "158: {",
          "159:   unsigned char",
          "160:     r[4],",
          "161:     g[4],",
          "162:     b[4],",
          "163:     a[4];",
          "164: } DDSColors;",
          "166: typedef struct _DDSVector4",
          "167: {",
          "168:   float",
          "169:     x,",
          "170:     y,",
          "171:     z,",
          "172:     w;",
          "173: } DDSVector4;",
          "175: typedef struct _DDSVector3",
          "176: {",
          "177:   float",
          "178:     x,",
          "179:     y,",
          "180:     z;",
          "181: } DDSVector3;",
          "183: typedef struct _DDSSourceBlock",
          "184: {",
          "185:   unsigned char",
          "186:     start,",
          "187:     end,",
          "188:     error;",
          "189: } DDSSourceBlock;",
          "191: typedef struct _DDSSingleColourLookup",
          "192: {",
          "193:   DDSSourceBlock sources[2];",
          "194: } DDSSingleColourLookup;",
          "196: typedef MagickBooleanType",
          "197:   DDSDecoder(Image *, DDSInfo *, ExceptionInfo *);",
          "199: static const DDSSingleColourLookup DDSLookup_5_4[] =",
          "200: {",
          "201:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "202:   { { { 0, 0, 1 }, { 0, 1, 1 } } },",
          "203:   { { { 0, 0, 2 }, { 0, 1, 0 } } },",
          "204:   { { { 0, 0, 3 }, { 0, 1, 1 } } },",
          "205:   { { { 0, 0, 4 }, { 0, 2, 1 } } },",
          "206:   { { { 1, 0, 3 }, { 0, 2, 0 } } },",
          "207:   { { { 1, 0, 2 }, { 0, 2, 1 } } },",
          "208:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "209:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "210:   { { { 1, 0, 1 }, { 1, 2, 1 } } },",
          "211:   { { { 1, 0, 2 }, { 1, 2, 0 } } },",
          "212:   { { { 1, 0, 3 }, { 0, 4, 0 } } },",
          "213:   { { { 1, 0, 4 }, { 0, 5, 1 } } },",
          "214:   { { { 2, 0, 3 }, { 0, 5, 0 } } },",
          "215:   { { { 2, 0, 2 }, { 0, 5, 1 } } },",
          "216:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "217:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "218:   { { { 2, 0, 1 }, { 2, 3, 1 } } },",
          "219:   { { { 2, 0, 2 }, { 2, 3, 0 } } },",
          "220:   { { { 2, 0, 3 }, { 0, 7, 0 } } },",
          "221:   { { { 2, 0, 4 }, { 1, 6, 1 } } },",
          "222:   { { { 3, 0, 3 }, { 1, 6, 0 } } },",
          "223:   { { { 3, 0, 2 }, { 0, 8, 0 } } },",
          "224:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "225:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "226:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "227:   { { { 3, 0, 2 }, { 0, 10, 1 } } },",
          "228:   { { { 3, 0, 3 }, { 0, 10, 0 } } },",
          "229:   { { { 3, 0, 4 }, { 2, 7, 1 } } },",
          "230:   { { { 4, 0, 4 }, { 2, 7, 0 } } },",
          "231:   { { { 4, 0, 3 }, { 0, 11, 0 } } },",
          "232:   { { { 4, 0, 2 }, { 1, 10, 1 } } },",
          "233:   { { { 4, 0, 1 }, { 1, 10, 0 } } },",
          "234:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "235:   { { { 4, 0, 1 }, { 0, 13, 1 } } },",
          "236:   { { { 4, 0, 2 }, { 0, 13, 0 } } },",
          "237:   { { { 4, 0, 3 }, { 0, 13, 1 } } },",
          "238:   { { { 4, 0, 4 }, { 0, 14, 1 } } },",
          "239:   { { { 5, 0, 3 }, { 0, 14, 0 } } },",
          "240:   { { { 5, 0, 2 }, { 2, 11, 1 } } },",
          "241:   { { { 5, 0, 1 }, { 2, 11, 0 } } },",
          "242:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "243:   { { { 5, 0, 1 }, { 1, 14, 1 } } },",
          "244:   { { { 5, 0, 2 }, { 1, 14, 0 } } },",
          "245:   { { { 5, 0, 3 }, { 0, 16, 0 } } },",
          "246:   { { { 5, 0, 4 }, { 0, 17, 1 } } },",
          "247:   { { { 6, 0, 3 }, { 0, 17, 0 } } },",
          "248:   { { { 6, 0, 2 }, { 0, 17, 1 } } },",
          "249:   { { { 6, 0, 1 }, { 0, 18, 1 } } },",
          "250:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "251:   { { { 6, 0, 1 }, { 2, 15, 1 } } },",
          "252:   { { { 6, 0, 2 }, { 2, 15, 0 } } },",
          "253:   { { { 6, 0, 3 }, { 0, 19, 0 } } },",
          "254:   { { { 6, 0, 4 }, { 1, 18, 1 } } },",
          "255:   { { { 7, 0, 3 }, { 1, 18, 0 } } },",
          "256:   { { { 7, 0, 2 }, { 0, 20, 0 } } },",
          "257:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "258:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "259:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "260:   { { { 7, 0, 2 }, { 0, 22, 1 } } },",
          "261:   { { { 7, 0, 3 }, { 0, 22, 0 } } },",
          "262:   { { { 7, 0, 4 }, { 2, 19, 1 } } },",
          "263:   { { { 8, 0, 4 }, { 2, 19, 0 } } },",
          "264:   { { { 8, 0, 3 }, { 0, 23, 0 } } },",
          "265:   { { { 8, 0, 2 }, { 1, 22, 1 } } },",
          "266:   { { { 8, 0, 1 }, { 1, 22, 0 } } },",
          "267:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "268:   { { { 8, 0, 1 }, { 0, 25, 1 } } },",
          "269:   { { { 8, 0, 2 }, { 0, 25, 0 } } },",
          "270:   { { { 8, 0, 3 }, { 0, 25, 1 } } },",
          "271:   { { { 8, 0, 4 }, { 0, 26, 1 } } },",
          "272:   { { { 9, 0, 3 }, { 0, 26, 0 } } },",
          "273:   { { { 9, 0, 2 }, { 2, 23, 1 } } },",
          "274:   { { { 9, 0, 1 }, { 2, 23, 0 } } },",
          "275:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "276:   { { { 9, 0, 1 }, { 1, 26, 1 } } },",
          "277:   { { { 9, 0, 2 }, { 1, 26, 0 } } },",
          "278:   { { { 9, 0, 3 }, { 0, 28, 0 } } },",
          "279:   { { { 9, 0, 4 }, { 0, 29, 1 } } },",
          "280:   { { { 10, 0, 3 }, { 0, 29, 0 } } },",
          "281:   { { { 10, 0, 2 }, { 0, 29, 1 } } },",
          "282:   { { { 10, 0, 1 }, { 0, 30, 1 } } },",
          "283:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "284:   { { { 10, 0, 1 }, { 2, 27, 1 } } },",
          "285:   { { { 10, 0, 2 }, { 2, 27, 0 } } },",
          "286:   { { { 10, 0, 3 }, { 0, 31, 0 } } },",
          "287:   { { { 10, 0, 4 }, { 1, 30, 1 } } },",
          "288:   { { { 11, 0, 3 }, { 1, 30, 0 } } },",
          "289:   { { { 11, 0, 2 }, { 4, 24, 0 } } },",
          "290:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "291:   { { { 11, 0, 0 }, { 1, 31, 0 } } },",
          "292:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "293:   { { { 11, 0, 2 }, { 2, 30, 1 } } },",
          "294:   { { { 11, 0, 3 }, { 2, 30, 0 } } },",
          "295:   { { { 11, 0, 4 }, { 2, 31, 1 } } },",
          "296:   { { { 12, 0, 4 }, { 2, 31, 0 } } },",
          "297:   { { { 12, 0, 3 }, { 4, 27, 0 } } },",
          "298:   { { { 12, 0, 2 }, { 3, 30, 1 } } },",
          "299:   { { { 12, 0, 1 }, { 3, 30, 0 } } },",
          "300:   { { { 12, 0, 0 }, { 4, 28, 0 } } },",
          "301:   { { { 12, 0, 1 }, { 3, 31, 1 } } },",
          "302:   { { { 12, 0, 2 }, { 3, 31, 0 } } },",
          "303:   { { { 12, 0, 3 }, { 3, 31, 1 } } },",
          "304:   { { { 12, 0, 4 }, { 4, 30, 1 } } },",
          "305:   { { { 13, 0, 3 }, { 4, 30, 0 } } },",
          "306:   { { { 13, 0, 2 }, { 6, 27, 1 } } },",
          "307:   { { { 13, 0, 1 }, { 6, 27, 0 } } },",
          "308:   { { { 13, 0, 0 }, { 4, 31, 0 } } },",
          "309:   { { { 13, 0, 1 }, { 5, 30, 1 } } },",
          "310:   { { { 13, 0, 2 }, { 5, 30, 0 } } },",
          "311:   { { { 13, 0, 3 }, { 8, 24, 0 } } },",
          "312:   { { { 13, 0, 4 }, { 5, 31, 1 } } },",
          "313:   { { { 14, 0, 3 }, { 5, 31, 0 } } },",
          "314:   { { { 14, 0, 2 }, { 5, 31, 1 } } },",
          "315:   { { { 14, 0, 1 }, { 6, 30, 1 } } },",
          "316:   { { { 14, 0, 0 }, { 6, 30, 0 } } },",
          "317:   { { { 14, 0, 1 }, { 6, 31, 1 } } },",
          "318:   { { { 14, 0, 2 }, { 6, 31, 0 } } },",
          "319:   { { { 14, 0, 3 }, { 8, 27, 0 } } },",
          "320:   { { { 14, 0, 4 }, { 7, 30, 1 } } },",
          "321:   { { { 15, 0, 3 }, { 7, 30, 0 } } },",
          "322:   { { { 15, 0, 2 }, { 8, 28, 0 } } },",
          "323:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "324:   { { { 15, 0, 0 }, { 7, 31, 0 } } },",
          "325:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "326:   { { { 15, 0, 2 }, { 8, 30, 1 } } },",
          "327:   { { { 15, 0, 3 }, { 8, 30, 0 } } },",
          "328:   { { { 15, 0, 4 }, { 10, 27, 1 } } },",
          "329:   { { { 16, 0, 4 }, { 10, 27, 0 } } },",
          "330:   { { { 16, 0, 3 }, { 8, 31, 0 } } },",
          "331:   { { { 16, 0, 2 }, { 9, 30, 1 } } },",
          "332:   { { { 16, 0, 1 }, { 9, 30, 0 } } },",
          "333:   { { { 16, 0, 0 }, { 12, 24, 0 } } },",
          "334:   { { { 16, 0, 1 }, { 9, 31, 1 } } },",
          "335:   { { { 16, 0, 2 }, { 9, 31, 0 } } },",
          "336:   { { { 16, 0, 3 }, { 9, 31, 1 } } },",
          "337:   { { { 16, 0, 4 }, { 10, 30, 1 } } },",
          "338:   { { { 17, 0, 3 }, { 10, 30, 0 } } },",
          "339:   { { { 17, 0, 2 }, { 10, 31, 1 } } },",
          "340:   { { { 17, 0, 1 }, { 10, 31, 0 } } },",
          "341:   { { { 17, 0, 0 }, { 12, 27, 0 } } },",
          "342:   { { { 17, 0, 1 }, { 11, 30, 1 } } },",
          "343:   { { { 17, 0, 2 }, { 11, 30, 0 } } },",
          "344:   { { { 17, 0, 3 }, { 12, 28, 0 } } },",
          "345:   { { { 17, 0, 4 }, { 11, 31, 1 } } },",
          "346:   { { { 18, 0, 3 }, { 11, 31, 0 } } },",
          "347:   { { { 18, 0, 2 }, { 11, 31, 1 } } },",
          "348:   { { { 18, 0, 1 }, { 12, 30, 1 } } },",
          "349:   { { { 18, 0, 0 }, { 12, 30, 0 } } },",
          "350:   { { { 18, 0, 1 }, { 14, 27, 1 } } },",
          "351:   { { { 18, 0, 2 }, { 14, 27, 0 } } },",
          "352:   { { { 18, 0, 3 }, { 12, 31, 0 } } },",
          "353:   { { { 18, 0, 4 }, { 13, 30, 1 } } },",
          "354:   { { { 19, 0, 3 }, { 13, 30, 0 } } },",
          "355:   { { { 19, 0, 2 }, { 16, 24, 0 } } },",
          "356:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "357:   { { { 19, 0, 0 }, { 13, 31, 0 } } },",
          "358:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "359:   { { { 19, 0, 2 }, { 14, 30, 1 } } },",
          "360:   { { { 19, 0, 3 }, { 14, 30, 0 } } },",
          "361:   { { { 19, 0, 4 }, { 14, 31, 1 } } },",
          "362:   { { { 20, 0, 4 }, { 14, 31, 0 } } },",
          "363:   { { { 20, 0, 3 }, { 16, 27, 0 } } },",
          "364:   { { { 20, 0, 2 }, { 15, 30, 1 } } },",
          "365:   { { { 20, 0, 1 }, { 15, 30, 0 } } },",
          "366:   { { { 20, 0, 0 }, { 16, 28, 0 } } },",
          "367:   { { { 20, 0, 1 }, { 15, 31, 1 } } },",
          "368:   { { { 20, 0, 2 }, { 15, 31, 0 } } },",
          "369:   { { { 20, 0, 3 }, { 15, 31, 1 } } },",
          "370:   { { { 20, 0, 4 }, { 16, 30, 1 } } },",
          "371:   { { { 21, 0, 3 }, { 16, 30, 0 } } },",
          "372:   { { { 21, 0, 2 }, { 18, 27, 1 } } },",
          "373:   { { { 21, 0, 1 }, { 18, 27, 0 } } },",
          "374:   { { { 21, 0, 0 }, { 16, 31, 0 } } },",
          "375:   { { { 21, 0, 1 }, { 17, 30, 1 } } },",
          "376:   { { { 21, 0, 2 }, { 17, 30, 0 } } },",
          "377:   { { { 21, 0, 3 }, { 20, 24, 0 } } },",
          "378:   { { { 21, 0, 4 }, { 17, 31, 1 } } },",
          "379:   { { { 22, 0, 3 }, { 17, 31, 0 } } },",
          "380:   { { { 22, 0, 2 }, { 17, 31, 1 } } },",
          "381:   { { { 22, 0, 1 }, { 18, 30, 1 } } },",
          "382:   { { { 22, 0, 0 }, { 18, 30, 0 } } },",
          "383:   { { { 22, 0, 1 }, { 18, 31, 1 } } },",
          "384:   { { { 22, 0, 2 }, { 18, 31, 0 } } },",
          "385:   { { { 22, 0, 3 }, { 20, 27, 0 } } },",
          "386:   { { { 22, 0, 4 }, { 19, 30, 1 } } },",
          "387:   { { { 23, 0, 3 }, { 19, 30, 0 } } },",
          "388:   { { { 23, 0, 2 }, { 20, 28, 0 } } },",
          "389:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "390:   { { { 23, 0, 0 }, { 19, 31, 0 } } },",
          "391:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "392:   { { { 23, 0, 2 }, { 20, 30, 1 } } },",
          "393:   { { { 23, 0, 3 }, { 20, 30, 0 } } },",
          "394:   { { { 23, 0, 4 }, { 22, 27, 1 } } },",
          "395:   { { { 24, 0, 4 }, { 22, 27, 0 } } },",
          "396:   { { { 24, 0, 3 }, { 20, 31, 0 } } },",
          "397:   { { { 24, 0, 2 }, { 21, 30, 1 } } },",
          "398:   { { { 24, 0, 1 }, { 21, 30, 0 } } },",
          "399:   { { { 24, 0, 0 }, { 24, 24, 0 } } },",
          "400:   { { { 24, 0, 1 }, { 21, 31, 1 } } },",
          "401:   { { { 24, 0, 2 }, { 21, 31, 0 } } },",
          "402:   { { { 24, 0, 3 }, { 21, 31, 1 } } },",
          "403:   { { { 24, 0, 4 }, { 22, 30, 1 } } },",
          "404:   { { { 25, 0, 3 }, { 22, 30, 0 } } },",
          "405:   { { { 25, 0, 2 }, { 22, 31, 1 } } },",
          "406:   { { { 25, 0, 1 }, { 22, 31, 0 } } },",
          "407:   { { { 25, 0, 0 }, { 24, 27, 0 } } },",
          "408:   { { { 25, 0, 1 }, { 23, 30, 1 } } },",
          "409:   { { { 25, 0, 2 }, { 23, 30, 0 } } },",
          "410:   { { { 25, 0, 3 }, { 24, 28, 0 } } },",
          "411:   { { { 25, 0, 4 }, { 23, 31, 1 } } },",
          "412:   { { { 26, 0, 3 }, { 23, 31, 0 } } },",
          "413:   { { { 26, 0, 2 }, { 23, 31, 1 } } },",
          "414:   { { { 26, 0, 1 }, { 24, 30, 1 } } },",
          "415:   { { { 26, 0, 0 }, { 24, 30, 0 } } },",
          "416:   { { { 26, 0, 1 }, { 26, 27, 1 } } },",
          "417:   { { { 26, 0, 2 }, { 26, 27, 0 } } },",
          "418:   { { { 26, 0, 3 }, { 24, 31, 0 } } },",
          "419:   { { { 26, 0, 4 }, { 25, 30, 1 } } },",
          "420:   { { { 27, 0, 3 }, { 25, 30, 0 } } },",
          "421:   { { { 27, 0, 2 }, { 28, 24, 0 } } },",
          "422:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "423:   { { { 27, 0, 0 }, { 25, 31, 0 } } },",
          "424:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "425:   { { { 27, 0, 2 }, { 26, 30, 1 } } },",
          "426:   { { { 27, 0, 3 }, { 26, 30, 0 } } },",
          "427:   { { { 27, 0, 4 }, { 26, 31, 1 } } },",
          "428:   { { { 28, 0, 4 }, { 26, 31, 0 } } },",
          "429:   { { { 28, 0, 3 }, { 28, 27, 0 } } },",
          "430:   { { { 28, 0, 2 }, { 27, 30, 1 } } },",
          "431:   { { { 28, 0, 1 }, { 27, 30, 0 } } },",
          "432:   { { { 28, 0, 0 }, { 28, 28, 0 } } },",
          "433:   { { { 28, 0, 1 }, { 27, 31, 1 } } },",
          "434:   { { { 28, 0, 2 }, { 27, 31, 0 } } },",
          "435:   { { { 28, 0, 3 }, { 27, 31, 1 } } },",
          "436:   { { { 28, 0, 4 }, { 28, 30, 1 } } },",
          "437:   { { { 29, 0, 3 }, { 28, 30, 0 } } },",
          "438:   { { { 29, 0, 2 }, { 30, 27, 1 } } },",
          "439:   { { { 29, 0, 1 }, { 30, 27, 0 } } },",
          "440:   { { { 29, 0, 0 }, { 28, 31, 0 } } },",
          "441:   { { { 29, 0, 1 }, { 29, 30, 1 } } },",
          "442:   { { { 29, 0, 2 }, { 29, 30, 0 } } },",
          "443:   { { { 29, 0, 3 }, { 29, 30, 1 } } },",
          "444:   { { { 29, 0, 4 }, { 29, 31, 1 } } },",
          "445:   { { { 30, 0, 3 }, { 29, 31, 0 } } },",
          "446:   { { { 30, 0, 2 }, { 29, 31, 1 } } },",
          "447:   { { { 30, 0, 1 }, { 30, 30, 1 } } },",
          "448:   { { { 30, 0, 0 }, { 30, 30, 0 } } },",
          "449:   { { { 30, 0, 1 }, { 30, 31, 1 } } },",
          "450:   { { { 30, 0, 2 }, { 30, 31, 0 } } },",
          "451:   { { { 30, 0, 3 }, { 30, 31, 1 } } },",
          "452:   { { { 30, 0, 4 }, { 31, 30, 1 } } },",
          "453:   { { { 31, 0, 3 }, { 31, 30, 0 } } },",
          "454:   { { { 31, 0, 2 }, { 31, 30, 1 } } },",
          "455:   { { { 31, 0, 1 }, { 31, 31, 1 } } },",
          "456:   { { { 31, 0, 0 }, { 31, 31, 0 } } }",
          "457: };",
          "459: static const DDSSingleColourLookup DDSLookup_6_4[] =",
          "460: {",
          "461:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "462:   { { { 0, 0, 1 }, { 0, 1, 0 } } },",
          "463:   { { { 0, 0, 2 }, { 0, 2, 0 } } },",
          "464:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "465:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "466:   { { { 1, 0, 1 }, { 0, 4, 0 } } },",
          "467:   { { { 1, 0, 2 }, { 0, 5, 0 } } },",
          "468:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "469:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "470:   { { { 2, 0, 1 }, { 0, 7, 0 } } },",
          "471:   { { { 2, 0, 2 }, { 0, 8, 0 } } },",
          "472:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "473:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "474:   { { { 3, 0, 1 }, { 0, 10, 0 } } },",
          "475:   { { { 3, 0, 2 }, { 0, 11, 0 } } },",
          "476:   { { { 4, 0, 1 }, { 0, 12, 1 } } },",
          "477:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "478:   { { { 4, 0, 1 }, { 0, 13, 0 } } },",
          "479:   { { { 4, 0, 2 }, { 0, 14, 0 } } },",
          "480:   { { { 5, 0, 1 }, { 0, 15, 1 } } },",
          "481:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "482:   { { { 5, 0, 1 }, { 0, 16, 0 } } },",
          "483:   { { { 5, 0, 2 }, { 1, 15, 0 } } },",
          "484:   { { { 6, 0, 1 }, { 0, 17, 0 } } },",
          "485:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "486:   { { { 6, 0, 1 }, { 0, 19, 0 } } },",
          "487:   { { { 6, 0, 2 }, { 3, 14, 0 } } },",
          "488:   { { { 7, 0, 1 }, { 0, 20, 0 } } },",
          "489:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "490:   { { { 7, 0, 1 }, { 0, 22, 0 } } },",
          "491:   { { { 7, 0, 2 }, { 4, 15, 0 } } },",
          "492:   { { { 8, 0, 1 }, { 0, 23, 0 } } },",
          "493:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "494:   { { { 8, 0, 1 }, { 0, 25, 0 } } },",
          "495:   { { { 8, 0, 2 }, { 6, 14, 0 } } },",
          "496:   { { { 9, 0, 1 }, { 0, 26, 0 } } },",
          "497:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "498:   { { { 9, 0, 1 }, { 0, 28, 0 } } },",
          "499:   { { { 9, 0, 2 }, { 7, 15, 0 } } },",
          "500:   { { { 10, 0, 1 }, { 0, 29, 0 } } },",
          "501:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "502:   { { { 10, 0, 1 }, { 0, 31, 0 } } },",
          "503:   { { { 10, 0, 2 }, { 9, 14, 0 } } },",
          "504:   { { { 11, 0, 1 }, { 0, 32, 0 } } },",
          "505:   { { { 11, 0, 0 }, { 0, 33, 0 } } },",
          "506:   { { { 11, 0, 1 }, { 2, 30, 0 } } },",
          "507:   { { { 11, 0, 2 }, { 0, 34, 0 } } },",
          "508:   { { { 12, 0, 1 }, { 0, 35, 0 } } },",
          "509:   { { { 12, 0, 0 }, { 0, 36, 0 } } },",
          "510:   { { { 12, 0, 1 }, { 3, 31, 0 } } },",
          "511:   { { { 12, 0, 2 }, { 0, 37, 0 } } },",
          "512:   { { { 13, 0, 1 }, { 0, 38, 0 } } },",
          "513:   { { { 13, 0, 0 }, { 0, 39, 0 } } },",
          "514:   { { { 13, 0, 1 }, { 5, 30, 0 } } },",
          "515:   { { { 13, 0, 2 }, { 0, 40, 0 } } },",
          "516:   { { { 14, 0, 1 }, { 0, 41, 0 } } },",
          "517:   { { { 14, 0, 0 }, { 0, 42, 0 } } },",
          "518:   { { { 14, 0, 1 }, { 6, 31, 0 } } },",
          "519:   { { { 14, 0, 2 }, { 0, 43, 0 } } },",
          "520:   { { { 15, 0, 1 }, { 0, 44, 0 } } },",
          "521:   { { { 15, 0, 0 }, { 0, 45, 0 } } },",
          "522:   { { { 15, 0, 1 }, { 8, 30, 0 } } },",
          "523:   { { { 15, 0, 2 }, { 0, 46, 0 } } },",
          "524:   { { { 16, 0, 2 }, { 0, 47, 0 } } },",
          "525:   { { { 16, 0, 1 }, { 1, 46, 0 } } },",
          "526:   { { { 16, 0, 0 }, { 0, 48, 0 } } },",
          "527:   { { { 16, 0, 1 }, { 0, 49, 0 } } },",
          "528:   { { { 16, 0, 2 }, { 0, 50, 0 } } },",
          "529:   { { { 17, 0, 1 }, { 2, 47, 0 } } },",
          "530:   { { { 17, 0, 0 }, { 0, 51, 0 } } },",
          "531:   { { { 17, 0, 1 }, { 0, 52, 0 } } },",
          "532:   { { { 17, 0, 2 }, { 0, 53, 0 } } },",
          "533:   { { { 18, 0, 1 }, { 4, 46, 0 } } },",
          "534:   { { { 18, 0, 0 }, { 0, 54, 0 } } },",
          "535:   { { { 18, 0, 1 }, { 0, 55, 0 } } },",
          "536:   { { { 18, 0, 2 }, { 0, 56, 0 } } },",
          "537:   { { { 19, 0, 1 }, { 5, 47, 0 } } },",
          "538:   { { { 19, 0, 0 }, { 0, 57, 0 } } },",
          "539:   { { { 19, 0, 1 }, { 0, 58, 0 } } },",
          "540:   { { { 19, 0, 2 }, { 0, 59, 0 } } },",
          "541:   { { { 20, 0, 1 }, { 7, 46, 0 } } },",
          "542:   { { { 20, 0, 0 }, { 0, 60, 0 } } },",
          "543:   { { { 20, 0, 1 }, { 0, 61, 0 } } },",
          "544:   { { { 20, 0, 2 }, { 0, 62, 0 } } },",
          "545:   { { { 21, 0, 1 }, { 8, 47, 0 } } },",
          "546:   { { { 21, 0, 0 }, { 0, 63, 0 } } },",
          "547:   { { { 21, 0, 1 }, { 1, 62, 0 } } },",
          "548:   { { { 21, 0, 2 }, { 1, 63, 0 } } },",
          "549:   { { { 22, 0, 1 }, { 10, 46, 0 } } },",
          "550:   { { { 22, 0, 0 }, { 2, 62, 0 } } },",
          "551:   { { { 22, 0, 1 }, { 2, 63, 0 } } },",
          "552:   { { { 22, 0, 2 }, { 3, 62, 0 } } },",
          "553:   { { { 23, 0, 1 }, { 11, 47, 0 } } },",
          "554:   { { { 23, 0, 0 }, { 3, 63, 0 } } },",
          "555:   { { { 23, 0, 1 }, { 4, 62, 0 } } },",
          "556:   { { { 23, 0, 2 }, { 4, 63, 0 } } },",
          "557:   { { { 24, 0, 1 }, { 13, 46, 0 } } },",
          "558:   { { { 24, 0, 0 }, { 5, 62, 0 } } },",
          "559:   { { { 24, 0, 1 }, { 5, 63, 0 } } },",
          "560:   { { { 24, 0, 2 }, { 6, 62, 0 } } },",
          "561:   { { { 25, 0, 1 }, { 14, 47, 0 } } },",
          "562:   { { { 25, 0, 0 }, { 6, 63, 0 } } },",
          "563:   { { { 25, 0, 1 }, { 7, 62, 0 } } },",
          "564:   { { { 25, 0, 2 }, { 7, 63, 0 } } },",
          "565:   { { { 26, 0, 1 }, { 16, 45, 0 } } },",
          "566:   { { { 26, 0, 0 }, { 8, 62, 0 } } },",
          "567:   { { { 26, 0, 1 }, { 8, 63, 0 } } },",
          "568:   { { { 26, 0, 2 }, { 9, 62, 0 } } },",
          "569:   { { { 27, 0, 1 }, { 16, 48, 0 } } },",
          "570:   { { { 27, 0, 0 }, { 9, 63, 0 } } },",
          "571:   { { { 27, 0, 1 }, { 10, 62, 0 } } },",
          "572:   { { { 27, 0, 2 }, { 10, 63, 0 } } },",
          "573:   { { { 28, 0, 1 }, { 16, 51, 0 } } },",
          "574:   { { { 28, 0, 0 }, { 11, 62, 0 } } },",
          "575:   { { { 28, 0, 1 }, { 11, 63, 0 } } },",
          "576:   { { { 28, 0, 2 }, { 12, 62, 0 } } },",
          "577:   { { { 29, 0, 1 }, { 16, 54, 0 } } },",
          "578:   { { { 29, 0, 0 }, { 12, 63, 0 } } },",
          "579:   { { { 29, 0, 1 }, { 13, 62, 0 } } },",
          "580:   { { { 29, 0, 2 }, { 13, 63, 0 } } },",
          "581:   { { { 30, 0, 1 }, { 16, 57, 0 } } },",
          "582:   { { { 30, 0, 0 }, { 14, 62, 0 } } },",
          "583:   { { { 30, 0, 1 }, { 14, 63, 0 } } },",
          "584:   { { { 30, 0, 2 }, { 15, 62, 0 } } },",
          "585:   { { { 31, 0, 1 }, { 16, 60, 0 } } },",
          "586:   { { { 31, 0, 0 }, { 15, 63, 0 } } },",
          "587:   { { { 31, 0, 1 }, { 24, 46, 0 } } },",
          "588:   { { { 31, 0, 2 }, { 16, 62, 0 } } },",
          "589:   { { { 32, 0, 2 }, { 16, 63, 0 } } },",
          "590:   { { { 32, 0, 1 }, { 17, 62, 0 } } },",
          "591:   { { { 32, 0, 0 }, { 25, 47, 0 } } },",
          "592:   { { { 32, 0, 1 }, { 17, 63, 0 } } },",
          "593:   { { { 32, 0, 2 }, { 18, 62, 0 } } },",
          "594:   { { { 33, 0, 1 }, { 18, 63, 0 } } },",
          "595:   { { { 33, 0, 0 }, { 27, 46, 0 } } },",
          "596:   { { { 33, 0, 1 }, { 19, 62, 0 } } },",
          "597:   { { { 33, 0, 2 }, { 19, 63, 0 } } },",
          "598:   { { { 34, 0, 1 }, { 20, 62, 0 } } },",
          "599:   { { { 34, 0, 0 }, { 28, 47, 0 } } },",
          "600:   { { { 34, 0, 1 }, { 20, 63, 0 } } },",
          "601:   { { { 34, 0, 2 }, { 21, 62, 0 } } },",
          "602:   { { { 35, 0, 1 }, { 21, 63, 0 } } },",
          "603:   { { { 35, 0, 0 }, { 30, 46, 0 } } },",
          "604:   { { { 35, 0, 1 }, { 22, 62, 0 } } },",
          "605:   { { { 35, 0, 2 }, { 22, 63, 0 } } },",
          "606:   { { { 36, 0, 1 }, { 23, 62, 0 } } },",
          "607:   { { { 36, 0, 0 }, { 31, 47, 0 } } },",
          "608:   { { { 36, 0, 1 }, { 23, 63, 0 } } },",
          "609:   { { { 36, 0, 2 }, { 24, 62, 0 } } },",
          "610:   { { { 37, 0, 1 }, { 24, 63, 0 } } },",
          "611:   { { { 37, 0, 0 }, { 32, 47, 0 } } },",
          "612:   { { { 37, 0, 1 }, { 25, 62, 0 } } },",
          "613:   { { { 37, 0, 2 }, { 25, 63, 0 } } },",
          "614:   { { { 38, 0, 1 }, { 26, 62, 0 } } },",
          "615:   { { { 38, 0, 0 }, { 32, 50, 0 } } },",
          "616:   { { { 38, 0, 1 }, { 26, 63, 0 } } },",
          "617:   { { { 38, 0, 2 }, { 27, 62, 0 } } },",
          "618:   { { { 39, 0, 1 }, { 27, 63, 0 } } },",
          "619:   { { { 39, 0, 0 }, { 32, 53, 0 } } },",
          "620:   { { { 39, 0, 1 }, { 28, 62, 0 } } },",
          "621:   { { { 39, 0, 2 }, { 28, 63, 0 } } },",
          "622:   { { { 40, 0, 1 }, { 29, 62, 0 } } },",
          "623:   { { { 40, 0, 0 }, { 32, 56, 0 } } },",
          "624:   { { { 40, 0, 1 }, { 29, 63, 0 } } },",
          "625:   { { { 40, 0, 2 }, { 30, 62, 0 } } },",
          "626:   { { { 41, 0, 1 }, { 30, 63, 0 } } },",
          "627:   { { { 41, 0, 0 }, { 32, 59, 0 } } },",
          "628:   { { { 41, 0, 1 }, { 31, 62, 0 } } },",
          "629:   { { { 41, 0, 2 }, { 31, 63, 0 } } },",
          "630:   { { { 42, 0, 1 }, { 32, 61, 0 } } },",
          "631:   { { { 42, 0, 0 }, { 32, 62, 0 } } },",
          "632:   { { { 42, 0, 1 }, { 32, 63, 0 } } },",
          "633:   { { { 42, 0, 2 }, { 41, 46, 0 } } },",
          "634:   { { { 43, 0, 1 }, { 33, 62, 0 } } },",
          "635:   { { { 43, 0, 0 }, { 33, 63, 0 } } },",
          "636:   { { { 43, 0, 1 }, { 34, 62, 0 } } },",
          "637:   { { { 43, 0, 2 }, { 42, 47, 0 } } },",
          "638:   { { { 44, 0, 1 }, { 34, 63, 0 } } },",
          "639:   { { { 44, 0, 0 }, { 35, 62, 0 } } },",
          "640:   { { { 44, 0, 1 }, { 35, 63, 0 } } },",
          "641:   { { { 44, 0, 2 }, { 44, 46, 0 } } },",
          "642:   { { { 45, 0, 1 }, { 36, 62, 0 } } },",
          "643:   { { { 45, 0, 0 }, { 36, 63, 0 } } },",
          "644:   { { { 45, 0, 1 }, { 37, 62, 0 } } },",
          "645:   { { { 45, 0, 2 }, { 45, 47, 0 } } },",
          "646:   { { { 46, 0, 1 }, { 37, 63, 0 } } },",
          "647:   { { { 46, 0, 0 }, { 38, 62, 0 } } },",
          "648:   { { { 46, 0, 1 }, { 38, 63, 0 } } },",
          "649:   { { { 46, 0, 2 }, { 47, 46, 0 } } },",
          "650:   { { { 47, 0, 1 }, { 39, 62, 0 } } },",
          "651:   { { { 47, 0, 0 }, { 39, 63, 0 } } },",
          "652:   { { { 47, 0, 1 }, { 40, 62, 0 } } },",
          "653:   { { { 47, 0, 2 }, { 48, 46, 0 } } },",
          "654:   { { { 48, 0, 2 }, { 40, 63, 0 } } },",
          "655:   { { { 48, 0, 1 }, { 41, 62, 0 } } },",
          "656:   { { { 48, 0, 0 }, { 41, 63, 0 } } },",
          "657:   { { { 48, 0, 1 }, { 48, 49, 0 } } },",
          "658:   { { { 48, 0, 2 }, { 42, 62, 0 } } },",
          "659:   { { { 49, 0, 1 }, { 42, 63, 0 } } },",
          "660:   { { { 49, 0, 0 }, { 43, 62, 0 } } },",
          "661:   { { { 49, 0, 1 }, { 48, 52, 0 } } },",
          "662:   { { { 49, 0, 2 }, { 43, 63, 0 } } },",
          "663:   { { { 50, 0, 1 }, { 44, 62, 0 } } },",
          "664:   { { { 50, 0, 0 }, { 44, 63, 0 } } },",
          "665:   { { { 50, 0, 1 }, { 48, 55, 0 } } },",
          "666:   { { { 50, 0, 2 }, { 45, 62, 0 } } },",
          "667:   { { { 51, 0, 1 }, { 45, 63, 0 } } },",
          "668:   { { { 51, 0, 0 }, { 46, 62, 0 } } },",
          "669:   { { { 51, 0, 1 }, { 48, 58, 0 } } },",
          "670:   { { { 51, 0, 2 }, { 46, 63, 0 } } },",
          "671:   { { { 52, 0, 1 }, { 47, 62, 0 } } },",
          "672:   { { { 52, 0, 0 }, { 47, 63, 0 } } },",
          "673:   { { { 52, 0, 1 }, { 48, 61, 0 } } },",
          "674:   { { { 52, 0, 2 }, { 48, 62, 0 } } },",
          "675:   { { { 53, 0, 1 }, { 56, 47, 0 } } },",
          "676:   { { { 53, 0, 0 }, { 48, 63, 0 } } },",
          "677:   { { { 53, 0, 1 }, { 49, 62, 0 } } },",
          "678:   { { { 53, 0, 2 }, { 49, 63, 0 } } },",
          "679:   { { { 54, 0, 1 }, { 58, 46, 0 } } },",
          "680:   { { { 54, 0, 0 }, { 50, 62, 0 } } },",
          "681:   { { { 54, 0, 1 }, { 50, 63, 0 } } },",
          "682:   { { { 54, 0, 2 }, { 51, 62, 0 } } },",
          "683:   { { { 55, 0, 1 }, { 59, 47, 0 } } },",
          "684:   { { { 55, 0, 0 }, { 51, 63, 0 } } },",
          "685:   { { { 55, 0, 1 }, { 52, 62, 0 } } },",
          "686:   { { { 55, 0, 2 }, { 52, 63, 0 } } },",
          "687:   { { { 56, 0, 1 }, { 61, 46, 0 } } },",
          "688:   { { { 56, 0, 0 }, { 53, 62, 0 } } },",
          "689:   { { { 56, 0, 1 }, { 53, 63, 0 } } },",
          "690:   { { { 56, 0, 2 }, { 54, 62, 0 } } },",
          "691:   { { { 57, 0, 1 }, { 62, 47, 0 } } },",
          "692:   { { { 57, 0, 0 }, { 54, 63, 0 } } },",
          "693:   { { { 57, 0, 1 }, { 55, 62, 0 } } },",
          "694:   { { { 57, 0, 2 }, { 55, 63, 0 } } },",
          "695:   { { { 58, 0, 1 }, { 56, 62, 1 } } },",
          "696:   { { { 58, 0, 0 }, { 56, 62, 0 } } },",
          "697:   { { { 58, 0, 1 }, { 56, 63, 0 } } },",
          "698:   { { { 58, 0, 2 }, { 57, 62, 0 } } },",
          "699:   { { { 59, 0, 1 }, { 57, 63, 1 } } },",
          "700:   { { { 59, 0, 0 }, { 57, 63, 0 } } },",
          "701:   { { { 59, 0, 1 }, { 58, 62, 0 } } },",
          "702:   { { { 59, 0, 2 }, { 58, 63, 0 } } },",
          "703:   { { { 60, 0, 1 }, { 59, 62, 1 } } },",
          "704:   { { { 60, 0, 0 }, { 59, 62, 0 } } },",
          "705:   { { { 60, 0, 1 }, { 59, 63, 0 } } },",
          "706:   { { { 60, 0, 2 }, { 60, 62, 0 } } },",
          "707:   { { { 61, 0, 1 }, { 60, 63, 1 } } },",
          "708:   { { { 61, 0, 0 }, { 60, 63, 0 } } },",
          "709:   { { { 61, 0, 1 }, { 61, 62, 0 } } },",
          "710:   { { { 61, 0, 2 }, { 61, 63, 0 } } },",
          "711:   { { { 62, 0, 1 }, { 62, 62, 1 } } },",
          "712:   { { { 62, 0, 0 }, { 62, 62, 0 } } },",
          "713:   { { { 62, 0, 1 }, { 62, 63, 0 } } },",
          "714:   { { { 62, 0, 2 }, { 63, 62, 0 } } },",
          "715:   { { { 63, 0, 1 }, { 63, 63, 1 } } },",
          "716:   { { { 63, 0, 0 }, { 63, 63, 0 } } }",
          "717: };",
          "719: static const DDSSingleColourLookup*",
          "720:   DDS_LOOKUP[] =",
          "721: {",
          "722:   DDSLookup_5_4,",
          "723:   DDSLookup_6_4,",
          "724:   DDSLookup_5_4",
          "725: };",
          "728:   Macros",
          "730: #define C565_r(x) (((x) & 0xF800) >> 11)",
          "731: #define C565_g(x) (((x) & 0x07E0) >> 5)",
          "732: #define C565_b(x)  ((x) & 0x001F)",
          "734: #define C565_red(x)   ( (C565_r(x) << 3 | C565_r(x) >> 2))",
          "735: #define C565_green(x) ( (C565_g(x) << 2 | C565_g(x) >> 4))",
          "736: #define C565_blue(x)  ( (C565_b(x) << 3 | C565_b(x) >> 2))",
          "738: #define DIV2(x)  ((x) > 1 ? ((x) >> 1) : 1)",
          "740: #define FixRange(min, max, steps) \\",
          "741: if (min > max) \\",
          "742:   min = max; \\",
          "743: if (max - min < steps) \\",
          "744:   max = Min(min + steps, 255); \\",
          "745: if (max - min < steps) \\",
          "746:   min = Max(min - steps, 0)",
          "748: #define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)",
          "750: #define VectorInit(vector, value) vector.x = vector.y = vector.z = vector.w \\",
          "751:   = value",
          "752: #define VectorInit3(vector, value) vector.x = vector.y = vector.z = value",
          "754: #define IsBitMask(mask, r, g, b, a) (mask.r_bitmask == r && mask.g_bitmask == \\",
          "755:   g && mask.b_bitmask == b && mask.alpha_bitmask == a)",
          "758:   Forward declarations",
          "760: static MagickBooleanType",
          "761:   ConstructOrdering(const size_t, const DDSVector4 *, const DDSVector3,",
          "762:   DDSVector4 *, DDSVector4 *, unsigned char *, size_t);",
          "764: static MagickBooleanType",
          "765:   ReadDDSInfo(Image *, DDSInfo *);",
          "767: static void",
          "768:   CalculateColors(unsigned short, unsigned short,",
          "769:     DDSColors *, MagickBooleanType);",
          "771: static MagickBooleanType",
          "772:   ReadDXT1(Image *, DDSInfo *, ExceptionInfo *);",
          "774: static MagickBooleanType",
          "775:   ReadDXT3(Image *, DDSInfo *, ExceptionInfo *);",
          "777: static MagickBooleanType",
          "778:   ReadDXT5(Image *, DDSInfo *, ExceptionInfo *);",
          "780: static MagickBooleanType",
          "781:   ReadUncompressedRGB(Image *, DDSInfo *, ExceptionInfo *);",
          "783: static MagickBooleanType",
          "784:   ReadUncompressedRGBA(Image *, DDSInfo *, ExceptionInfo *);",
          "786: static void",
          "787:   RemapIndices(const ssize_t *, const unsigned char *, unsigned char *);",
          "789: static void",
          "790:   SkipDXTMipmaps(Image *, DDSInfo *, int);",
          "792: static void",
          "793:   SkipRGBMipmaps(Image *, DDSInfo *, int);",
          "795: static",
          "796:   MagickBooleanType WriteDDSImage(const ImageInfo *, Image *, ExceptionInfo *);",
          "798: static void",
          "799:   WriteDDSInfo(Image *, const size_t, const size_t, const size_t);",
          "801: static void",
          "802:   WriteFourCC(Image *, const size_t, const MagickBooleanType,",
          "803:     const MagickBooleanType, ExceptionInfo *);",
          "805: static void",
          "806:   WriteImageData(Image *, const size_t, const size_t, const MagickBooleanType,",
          "807:   const MagickBooleanType, ExceptionInfo *);",
          "809: static void",
          "810:   WriteIndices(Image *, const DDSVector3, const DDSVector3, unsigned char *);",
          "812: static MagickBooleanType",
          "813:   WriteMipmaps(Image *, const size_t, const size_t, const size_t,",
          "814:     const MagickBooleanType, const MagickBooleanType, ExceptionInfo *);",
          "816: static void",
          "817:   WriteSingleColorFit(Image *, const DDSVector4 *, const ssize_t *);",
          "819: static void",
          "820:   WriteUncompressed(Image *, ExceptionInfo *);",
          "822: static inline size_t Max(size_t one, size_t two)",
          "823: {",
          "824:   if (one > two)",
          "825:     return one;",
          "826:   return two;",
          "827: }",
          "829: static inline float MaxF(float one, float two)",
          "830: {",
          "831:   if (one > two)",
          "832:     return one;",
          "833:   return two;",
          "834: }",
          "836: static inline size_t Min(size_t one, size_t two)",
          "837: {",
          "838:   if (one < two)",
          "839:     return one;",
          "840:   return two;",
          "841: }",
          "843: static inline float MinF(float one, float two)",
          "844: {",
          "845:   if (one < two)",
          "846:     return one;",
          "847:   return two;",
          "848: }",
          "850: static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,",
          "851:   DDSVector4 *destination)",
          "852: {",
          "853:   destination->x = left.x + right.x;",
          "854:   destination->y = left.y + right.y;",
          "855:   destination->z = left.z + right.z;",
          "856:   destination->w = left.w + right.w;",
          "857: }",
          "859: static inline void VectorClamp(DDSVector4 *value)",
          "860: {",
          "861:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "862:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "863:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "864:   value->w = MinF(1.0f,MaxF(0.0f,value->w));",
          "865: }",
          "867: static inline void VectorClamp3(DDSVector3 *value)",
          "868: {",
          "869:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "870:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "871:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "872: }",
          "874: static inline void VectorCopy43(const DDSVector4 source,",
          "875:   DDSVector3 *destination)",
          "876: {",
          "877:   destination->x = source.x;",
          "878:   destination->y = source.y;",
          "879:   destination->z = source.z;",
          "880: }",
          "882: static inline void VectorCopy44(const DDSVector4 source,",
          "883:   DDSVector4 *destination)",
          "884: {",
          "885:   destination->x = source.x;",
          "886:   destination->y = source.y;",
          "887:   destination->z = source.z;",
          "888:   destination->w = source.w;",
          "889: }",
          "891: static inline void VectorNegativeMultiplySubtract(const DDSVector4 a,",
          "892:   const DDSVector4 b, const DDSVector4 c, DDSVector4 *destination)",
          "893: {",
          "894:   destination->x = c.x - (a.x * b.x);",
          "895:   destination->y = c.y - (a.y * b.y);",
          "896:   destination->z = c.z - (a.z * b.z);",
          "897:   destination->w = c.w - (a.w * b.w);",
          "898: }",
          "900: static inline void VectorMultiply(const DDSVector4 left,",
          "901:   const DDSVector4 right, DDSVector4 *destination)",
          "902: {",
          "903:   destination->x = left.x * right.x;",
          "904:   destination->y = left.y * right.y;",
          "905:   destination->z = left.z * right.z;",
          "906:   destination->w = left.w * right.w;",
          "907: }",
          "909: static inline void VectorMultiply3(const DDSVector3 left,",
          "910:   const DDSVector3 right, DDSVector3 *destination)",
          "911: {",
          "912:   destination->x = left.x * right.x;",
          "913:   destination->y = left.y * right.y;",
          "914:   destination->z = left.z * right.z;",
          "915: }",
          "917: static inline void VectorMultiplyAdd(const DDSVector4 a, const DDSVector4 b,",
          "918:   const DDSVector4 c, DDSVector4 *destination)",
          "919: {",
          "920:   destination->x = (a.x * b.x) + c.x;",
          "921:   destination->y = (a.y * b.y) + c.y;",
          "922:   destination->z = (a.z * b.z) + c.z;",
          "923:   destination->w = (a.w * b.w) + c.w;",
          "924: }",
          "926: static inline void VectorMultiplyAdd3(const DDSVector3 a, const DDSVector3 b,",
          "927:   const DDSVector3 c, DDSVector3 *destination)",
          "928: {",
          "929:   destination->x = (a.x * b.x) + c.x;",
          "930:   destination->y = (a.y * b.y) + c.y;",
          "931:   destination->z = (a.z * b.z) + c.z;",
          "932: }",
          "934: static inline void VectorReciprocal(const DDSVector4 value,",
          "935:   DDSVector4 *destination)",
          "936: {",
          "937:   destination->x = 1.0f / value.x;",
          "938:   destination->y = 1.0f / value.y;",
          "939:   destination->z = 1.0f / value.z;",
          "940:   destination->w = 1.0f / value.w;",
          "941: }",
          "943: static inline void VectorSubtract(const DDSVector4 left,",
          "944:   const DDSVector4 right, DDSVector4 *destination)",
          "945: {",
          "946:   destination->x = left.x - right.x;",
          "947:   destination->y = left.y - right.y;",
          "948:   destination->z = left.z - right.z;",
          "949:   destination->w = left.w - right.w;",
          "950: }",
          "952: static inline void VectorSubtract3(const DDSVector3 left,",
          "953:   const DDSVector3 right, DDSVector3 *destination)",
          "954: {",
          "955:   destination->x = left.x - right.x;",
          "956:   destination->y = left.y - right.y;",
          "957:   destination->z = left.z - right.z;",
          "958: }",
          "960: static inline void VectorTruncate(DDSVector4 *value)",
          "961: {",
          "962:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "963:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "964:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "965:   value->w = value->w > 0.0f ? floor(value->w) : ceil(value->w);",
          "966: }",
          "968: static inline void VectorTruncate3(DDSVector3 *value)",
          "969: {",
          "970:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "971:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "972:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "973: }",
          "975: static void CalculateColors(unsigned short c0, unsigned short c1,",
          "976:   DDSColors *c, MagickBooleanType ignoreAlpha)",
          "977: {",
          "978:   c->a[0] = c->a[1] = c->a[2] = c->a[3] = 0;",
          "980:   c->r[0] = (unsigned char) C565_red(c0);",
          "981:   c->g[0] = (unsigned char) C565_green(c0);",
          "982:   c->b[0] = (unsigned char) C565_blue(c0);",
          "984:   c->r[1] = (unsigned char) C565_red(c1);",
          "985:   c->g[1] = (unsigned char) C565_green(c1);",
          "986:   c->b[1] = (unsigned char) C565_blue(c1);",
          "988:   if (ignoreAlpha != MagickFalse || c0 > c1)",
          "989:     {",
          "990:       c->r[2] = (unsigned char) ((2 * c->r[0] + c->r[1]) / 3);",
          "991:       c->g[2] = (unsigned char) ((2 * c->g[0] + c->g[1]) / 3);",
          "992:       c->b[2] = (unsigned char) ((2 * c->b[0] + c->b[1]) / 3);",
          "994:       c->r[3] = (unsigned char) ((c->r[0] + 2 * c->r[1]) / 3);",
          "995:       c->g[3] = (unsigned char) ((c->g[0] + 2 * c->g[1]) / 3);",
          "996:       c->b[3] = (unsigned char) ((c->b[0] + 2 * c->b[1]) / 3);",
          "997:     }",
          "998:   else",
          "999:     {",
          "1000:       c->r[2] = (unsigned char) ((c->r[0] + c->r[1]) / 2);",
          "1001:       c->g[2] = (unsigned char) ((c->g[0] + c->g[1]) / 2);",
          "1002:       c->b[2] = (unsigned char) ((c->b[0] + c->b[1]) / 2);",
          "1004:       c->r[3] = c->g[3] = c->b[3] = 0;",
          "1005:       c->a[3] = 255;",
          "1006:     }",
          "1007: }",
          "1009: static size_t CompressAlpha(const size_t min, const size_t max,",
          "1010:   const size_t steps, const ssize_t *alphas, unsigned char* indices)",
          "1011: {",
          "1012:   unsigned char",
          "1013:     codes[8];",
          "1015:   register ssize_t",
          "1016:     i;",
          "1018:   size_t",
          "1019:     error,",
          "1020:     index,",
          "1021:     j,",
          "1022:     least,",
          "1023:     value;",
          "1025:   codes[0] = (unsigned char) min;",
          "1026:   codes[1] = (unsigned char) max;",
          "1027:   codes[6] = 0;",
          "1028:   codes[7] = 255;",
          "1030:   for (i=1; i <  (ssize_t) steps; i++)",
          "1031:     codes[i+1] = (unsigned char) (((steps-i)*min + i*max) / steps);",
          "1033:   error = 0;",
          "1034:   for (i=0; i<16; i++)",
          "1035:   {",
          "1036:     if (alphas[i] == -1)",
          "1037:       {",
          "1038:         indices[i] = 0;",
          "1039:         continue;",
          "1040:       }",
          "1042:     value = alphas[i];",
          "1043:     least = SIZE_MAX;",
          "1044:     index = 0;",
          "1045:     for (j=0; j<8; j++)",
          "1046:     {",
          "1047:       size_t",
          "1048:         dist;",
          "1050:       dist = value - (size_t)codes[j];",
          "1051:       dist *= dist;",
          "1053:       if (dist < least)",
          "1054:         {",
          "1055:           least = dist;",
          "1056:           index = j;",
          "1057:         }",
          "1058:     }",
          "1060:     indices[i] = (unsigned char)index;",
          "1061:     error += least;",
          "1062:   }",
          "1064:   return error;",
          "1065: }",
          "1067: static void CompressClusterFit(const size_t count,",
          "1068:   const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,",
          "1069:   const DDSVector4 metric, DDSVector3 *start, DDSVector3* end,",
          "1070:   unsigned char *indices)",
          "1071: {",
          "1072:   DDSVector3",
          "1073:     axis;",
          "1075:   DDSVector4",
          "1076:     grid,",
          "1077:     gridrcp,",
          "1078:     half,",
          "1079:     onethird_onethird2,",
          "1080:     part0,",
          "1081:     part1,",
          "1082:     part2,",
          "1083:     part3,",
          "1084:     pointsWeights[16],",
          "1085:     two,",
          "1086:     twonineths,",
          "1087:     twothirds_twothirds2,",
          "1088:     xSumwSum;",
          "1090:   float",
          "1091:     bestError = 1e+37f;",
          "1093:   size_t",
          "1094:     bestIteration = 0,",
          "1095:     besti = 0,",
          "1096:     bestj = 0,",
          "1097:     bestk = 0,",
          "1098:     iterationIndex,",
          "1099:     i,",
          "1100:     j,",
          "1101:     k,",
          "1102:     kmin;",
          "1104:   unsigned char",
          "1106:     order[128],",
          "1107:     unordered[16];",
          "1109:   VectorInit(half,0.5f);",
          "1110:   VectorInit(two,2.0f);",
          "1112:   VectorInit(onethird_onethird2,1.0f/3.0f);",
          "1113:   onethird_onethird2.w = 1.0f/9.0f;",
          "1114:   VectorInit(twothirds_twothirds2,2.0f/3.0f);",
          "1115:   twothirds_twothirds2.w = 4.0f/9.0f;",
          "1116:   VectorInit(twonineths,2.0f/9.0f);",
          "1118:   grid.x = 31.0f;",
          "1119:   grid.y = 63.0f;",
          "1120:   grid.z = 31.0f;",
          "1121:   grid.w = 0.0f;",
          "1123:   gridrcp.x = 1.0f/31.0f;",
          "1124:   gridrcp.y = 1.0f/63.0f;",
          "1125:   gridrcp.z = 1.0f/31.0f;",
          "1126:   gridrcp.w = 0.0f;",
          "1128:   xSumwSum.x = 0.0f;",
          "1129:   xSumwSum.y = 0.0f;",
          "1130:   xSumwSum.z = 0.0f;",
          "1131:   xSumwSum.w = 0.0f;",
          "1133:   ConstructOrdering(count,points,principle,pointsWeights,&xSumwSum,order,0);",
          "1135:   for (iterationIndex = 0;;)",
          "1136:   {",
          "1137:     VectorInit(part0,0.0f);",
          "1138:     for (i=0; i < count; i++)",
          "1139:     {",
          "1140:       VectorInit(part1,0.0f);",
          "1141:       for (j=i;;)",
          "1142:       {",
          "1143:         if (j == 0)",
          "1144:           {",
          "1145:             VectorCopy44(pointsWeights[0],&part2);",
          "1146:             kmin = 1;",
          "1147:           }",
          "1148:           else",
          "1149:           {",
          "1150:             VectorInit(part2,0.0f);",
          "1151:             kmin = j;",
          "1152:           }",
          "1154:         for (k=kmin;;)",
          "1155:         {",
          "1156:           DDSVector4",
          "1157:             a,",
          "1158:             alpha2_sum,",
          "1159:             alphax_sum,",
          "1160:             alphabeta_sum,",
          "1161:             b,",
          "1162:             beta2_sum,",
          "1163:             betax_sum,",
          "1164:             e1,",
          "1165:             e2,",
          "1166:             factor;",
          "1168:           float",
          "1169:             error;",
          "1171:           VectorSubtract(xSumwSum,part2,&part3);",
          "1172:           VectorSubtract(part3,part1,&part3);",
          "1173:           VectorSubtract(part3,part0,&part3);",
          "1175:           VectorMultiplyAdd(part1,twothirds_twothirds2,part0,&alphax_sum);",
          "1176:           VectorMultiplyAdd(part2,onethird_onethird2,alphax_sum,&alphax_sum);",
          "1177:           VectorInit(alpha2_sum,alphax_sum.w);",
          "1179:           VectorMultiplyAdd(part2,twothirds_twothirds2,part3,&betax_sum);",
          "1180:           VectorMultiplyAdd(part1,onethird_onethird2,betax_sum,&betax_sum);",
          "1181:           VectorInit(beta2_sum,betax_sum.w);",
          "1183:           VectorAdd(part1,part2,&alphabeta_sum);",
          "1184:           VectorInit(alphabeta_sum,alphabeta_sum.w);",
          "1185:           VectorMultiply(twonineths,alphabeta_sum,&alphabeta_sum);",
          "1187:           VectorMultiply(alpha2_sum,beta2_sum,&factor);",
          "1188:           VectorNegativeMultiplySubtract(alphabeta_sum,alphabeta_sum,factor,",
          "1189:             &factor);",
          "1190:           VectorReciprocal(factor,&factor);",
          "1192:           VectorMultiply(alphax_sum,beta2_sum,&a);",
          "1193:           VectorNegativeMultiplySubtract(betax_sum,alphabeta_sum,a,&a);",
          "1194:           VectorMultiply(a,factor,&a);",
          "1196:           VectorMultiply(betax_sum,alpha2_sum,&b);",
          "1197:           VectorNegativeMultiplySubtract(alphax_sum,alphabeta_sum,b,&b);",
          "1198:           VectorMultiply(b,factor,&b);",
          "1200:           VectorClamp(&a);",
          "1201:           VectorMultiplyAdd(grid,a,half,&a);",
          "1202:           VectorTruncate(&a);",
          "1203:           VectorMultiply(a,gridrcp,&a);",
          "1205:           VectorClamp(&b);",
          "1206:           VectorMultiplyAdd(grid,b,half,&b);",
          "1207:           VectorTruncate(&b);",
          "1208:           VectorMultiply(b,gridrcp,&b);",
          "1210:           VectorMultiply(b,b,&e1);",
          "1211:           VectorMultiply(e1,beta2_sum,&e1);",
          "1212:           VectorMultiply(a,a,&e2);",
          "1213:           VectorMultiplyAdd(e2,alpha2_sum,e1,&e1);",
          "1215:           VectorMultiply(a,b,&e2);",
          "1216:           VectorMultiply(e2,alphabeta_sum,&e2);",
          "1217:           VectorNegativeMultiplySubtract(a,alphax_sum,e2,&e2);",
          "1218:           VectorNegativeMultiplySubtract(b,betax_sum,e2,&e2);",
          "1219:           VectorMultiplyAdd(two,e2,e1,&e2);",
          "1220:           VectorMultiply(e2,metric,&e2);",
          "1222:           error = e2.x + e2.y + e2.z;",
          "1224:           if (error < bestError)",
          "1225:           {",
          "1226:             VectorCopy43(a,start);",
          "1227:             VectorCopy43(b,end);",
          "1228:             bestError = error;",
          "1229:             besti = i;",
          "1230:             bestj = j;",
          "1231:             bestk = k;",
          "1232:             bestIteration = iterationIndex;",
          "1233:           }",
          "1235:           if (k == count)",
          "1236:             break;",
          "1238:           VectorAdd(pointsWeights[k],part2,&part2);",
          "1239:           k++;",
          "1240:         }",
          "1242:         if (j == count)",
          "1243:           break;",
          "1245:         VectorAdd(pointsWeights[j],part1,&part1);",
          "1246:         j++;",
          "1247:       }",
          "1249:       VectorAdd(pointsWeights[i],part0,&part0);",
          "1250:     }",
          "1252:     if (bestIteration != iterationIndex)",
          "1253:       break;",
          "1255:     iterationIndex++;",
          "1256:     if (iterationIndex == 8)",
          "1257:       break;",
          "1259:     VectorSubtract3(*end,*start,&axis);",
          "1260:     if (ConstructOrdering(count,points,axis,pointsWeights,&xSumwSum,order,",
          "1261:       iterationIndex) == MagickFalse)",
          "1262:       break;",
          "1263:   }",
          "1265:   o = order + (16*bestIteration);",
          "1267:   for (i=0; i < besti; i++)",
          "1268:     unordered[o[i]] = 0;",
          "1269:   for (i=besti; i < bestj; i++)",
          "1270:     unordered[o[i]] = 2;",
          "1271:   for (i=bestj; i < bestk; i++)",
          "1272:     unordered[o[i]] = 3;",
          "1273:   for (i=bestk; i < count; i++)",
          "1274:     unordered[o[i]] = 1;",
          "1276:   RemapIndices(map,unordered,indices);",
          "1277: }",
          "1279: static void CompressRangeFit(const size_t count,",
          "1280:   const DDSVector4* points, const ssize_t *map, const DDSVector3 principle,",
          "1281:   const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,",
          "1282:   unsigned char *indices)",
          "1283: {",
          "1284:   float",
          "1285:     d,",
          "1286:     bestDist,",
          "1287:     max,",
          "1288:     min,",
          "1289:     val;",
          "1291:   DDSVector3",
          "1292:     codes[4],",
          "1293:     grid,",
          "1294:     gridrcp,",
          "1295:     half,",
          "1296:     dist;",
          "1298:   register ssize_t",
          "1299:     i;",
          "1301:   size_t",
          "1302:     bestj,",
          "1303:     j;",
          "1305:   unsigned char",
          "1306:     closest[16];",
          "1308:   VectorInit3(half,0.5f);",
          "1310:   grid.x = 31.0f;",
          "1311:   grid.y = 63.0f;",
          "1312:   grid.z = 31.0f;",
          "1314:   gridrcp.x = 1.0f/31.0f;",
          "1315:   gridrcp.y = 1.0f/63.0f;",
          "1316:   gridrcp.z = 1.0f/31.0f;",
          "1318:   if (count > 0)",
          "1319:     {",
          "1320:       VectorCopy43(points[0],start);",
          "1321:       VectorCopy43(points[0],end);",
          "1323:       min = max = Dot(points[0],principle);",
          "1324:       for (i=1; i < (ssize_t) count; i++)",
          "1325:       {",
          "1326:         val = Dot(points[i],principle);",
          "1327:         if (val < min)",
          "1328:         {",
          "1329:           VectorCopy43(points[i],start);",
          "1330:           min = val;",
          "1331:         }",
          "1332:         else if (val > max)",
          "1333:         {",
          "1334:           VectorCopy43(points[i],end);",
          "1335:           max = val;",
          "1336:         }",
          "1337:       }",
          "1338:     }",
          "1340:   VectorClamp3(start);",
          "1341:   VectorMultiplyAdd3(grid,*start,half,start);",
          "1342:   VectorTruncate3(start);",
          "1343:   VectorMultiply3(*start,gridrcp,start);",
          "1345:   VectorClamp3(end);",
          "1346:   VectorMultiplyAdd3(grid,*end,half,end);",
          "1347:   VectorTruncate3(end);",
          "1348:   VectorMultiply3(*end,gridrcp,end);",
          "1350:   codes[0] = *start;",
          "1351:   codes[1] = *end;",
          "1352:   codes[2].x = (start->x * (2.0f/3.0f)) + (end->x * (1.0f/3.0f));",
          "1353:   codes[2].y = (start->y * (2.0f/3.0f)) + (end->y * (1.0f/3.0f));",
          "1354:   codes[2].z = (start->z * (2.0f/3.0f)) + (end->z * (1.0f/3.0f));",
          "1355:   codes[3].x = (start->x * (1.0f/3.0f)) + (end->x * (2.0f/3.0f));",
          "1356:   codes[3].y = (start->y * (1.0f/3.0f)) + (end->y * (2.0f/3.0f));",
          "1357:   codes[3].z = (start->z * (1.0f/3.0f)) + (end->z * (2.0f/3.0f));",
          "1359:   for (i=0; i < (ssize_t) count; i++)",
          "1360:   {",
          "1361:     bestDist = 1e+37f;",
          "1362:     bestj = 0;",
          "1363:     for (j=0; j < 4; j++)",
          "1364:     {",
          "1365:       dist.x = (points[i].x - codes[j].x) * metric.x;",
          "1366:       dist.y = (points[i].y - codes[j].y) * metric.y;",
          "1367:       dist.z = (points[i].z - codes[j].z) * metric.z;",
          "1369:       d = Dot(dist,dist);",
          "1370:       if (d < bestDist)",
          "1371:         {",
          "1372:           bestDist = d;",
          "1373:           bestj = j;",
          "1374:         }",
          "1375:     }",
          "1377:     closest[i] = (unsigned char) bestj;",
          "1378:   }",
          "1380:   RemapIndices(map, closest, indices);",
          "1381: }",
          "1383: static void ComputeEndPoints(const DDSSingleColourLookup *lookup[],",
          "1384:   const unsigned char *color, DDSVector3 *start, DDSVector3 *end,",
          "1385:   unsigned char *index)",
          "1386: {",
          "1387:   register ssize_t",
          "1388:     i;",
          "1390:   size_t",
          "1391:     c,",
          "1392:     maxError = SIZE_MAX;",
          "1394:   for (i=0; i < 2; i++)",
          "1395:   {",
          "1396:     const DDSSourceBlock*",
          "1397:       sources[3];",
          "1399:       size_t",
          "1400:         error = 0;",
          "1402:     for (c=0; c < 3; c++)",
          "1403:     {",
          "1404:       sources[c] = &lookup[c][color[c]].sources[i];",
          "1405:       error += ((size_t) sources[c]->error) * ((size_t) sources[c]->error);",
          "1406:     }",
          "1408:     if (error > maxError)",
          "1409:       continue;",
          "1411:     start->x = (float) sources[0]->start / 31.0f;",
          "1412:     start->y = (float) sources[1]->start / 63.0f;",
          "1413:     start->z = (float) sources[2]->start / 31.0f;",
          "1415:     end->x = (float) sources[0]->end / 31.0f;",
          "1416:     end->y = (float) sources[1]->end / 63.0f;",
          "1417:     end->z = (float) sources[2]->end / 31.0f;",
          "1420:     maxError = error;",
          "1421:   }",
          "1422: }",
          "1424: static void ComputePrincipleComponent(const float *covariance,",
          "1425:   DDSVector3 *principle)",
          "1426: {",
          "1427:   DDSVector4",
          "1428:     row0,",
          "1429:     row1,",
          "1430:     row2,",
          "1431:     v;",
          "1433:   register ssize_t",
          "1434:     i;",
          "1436:   row0.x = covariance[0];",
          "1437:   row0.y = covariance[1];",
          "1438:   row0.z = covariance[2];",
          "1439:   row0.w = 0.0f;",
          "1441:   row1.x = covariance[1];",
          "1442:   row1.y = covariance[3];",
          "1443:   row1.z = covariance[4];",
          "1444:   row1.w = 0.0f;",
          "1446:   row2.x = covariance[2];",
          "1447:   row2.y = covariance[4];",
          "1448:   row2.z = covariance[5];",
          "1449:   row2.w = 0.0f;",
          "1451:   VectorInit(v,1.0f);",
          "1453:   for (i=0; i < 8; i++)",
          "1454:   {",
          "1455:     DDSVector4",
          "1456:       w;",
          "1458:     float",
          "1459:       a;",
          "1461:     w.x = row0.x * v.x;",
          "1462:     w.y = row0.y * v.x;",
          "1463:     w.z = row0.z * v.x;",
          "1464:     w.w = row0.w * v.x;",
          "1466:     w.x = (row1.x * v.y) + w.x;",
          "1467:     w.y = (row1.y * v.y) + w.y;",
          "1468:     w.z = (row1.z * v.y) + w.z;",
          "1469:     w.w = (row1.w * v.y) + w.w;",
          "1471:     w.x = (row2.x * v.z) + w.x;",
          "1472:     w.y = (row2.y * v.z) + w.y;",
          "1473:     w.z = (row2.z * v.z) + w.z;",
          "1474:     w.w = (row2.w * v.z) + w.w;",
          "1476:     a = 1.0f / MaxF(w.x,MaxF(w.y,w.z));",
          "1478:     v.x = w.x * a;",
          "1479:     v.y = w.y * a;",
          "1480:     v.z = w.z * a;",
          "1481:     v.w = w.w * a;",
          "1482:   }",
          "1484:   VectorCopy43(v,principle);",
          "1485: }",
          "1487: static void ComputeWeightedCovariance(const size_t count,",
          "1488:   const DDSVector4 *points, float *covariance)",
          "1489: {",
          "1490:   DDSVector3",
          "1491:     centroid;",
          "1493:   float",
          "1494:     total;",
          "1496:   size_t",
          "1497:     i;",
          "1499:   total = 0.0f;",
          "1500:   VectorInit3(centroid,0.0f);",
          "1502:   for (i=0; i < count; i++)",
          "1503:   {",
          "1504:     total += points[i].w;",
          "1505:     centroid.x += (points[i].x * points[i].w);",
          "1506:     centroid.y += (points[i].y * points[i].w);",
          "1507:     centroid.z += (points[i].z * points[i].w);",
          "1508:   }",
          "1510:   if( total > 1.192092896e-07F)",
          "1511:     {",
          "1512:       centroid.x /= total;",
          "1513:       centroid.y /= total;",
          "1514:       centroid.z /= total;",
          "1515:     }",
          "1517:   for (i=0; i < 6; i++)",
          "1518:     covariance[i] = 0.0f;",
          "1520:   for (i = 0; i < count; i++)",
          "1521:   {",
          "1522:     DDSVector3",
          "1523:       a,",
          "1524:       b;",
          "1526:     a.x = points[i].x - centroid.x;",
          "1527:     a.y = points[i].y - centroid.y;",
          "1528:     a.z = points[i].z - centroid.z;",
          "1530:     b.x = points[i].w * a.x;",
          "1531:     b.y = points[i].w * a.y;",
          "1532:     b.z = points[i].w * a.z;",
          "1534:     covariance[0] += a.x*b.x;",
          "1535:     covariance[1] += a.x*b.y;",
          "1536:     covariance[2] += a.x*b.z;",
          "1537:     covariance[3] += a.y*b.y;",
          "1538:     covariance[4] += a.y*b.z;",
          "1539:     covariance[5] += a.z*b.z;",
          "1540:   }",
          "1541: }",
          "1543: static MagickBooleanType ConstructOrdering(const size_t count,",
          "1544:   const DDSVector4 *points, const DDSVector3 axis, DDSVector4 *pointsWeights,",
          "1545:   DDSVector4 *xSumwSum, unsigned char *order, size_t iteration)",
          "1546: {",
          "1547:   float",
          "1548:      dps[16],",
          "1549:      f;",
          "1551:   register ssize_t",
          "1552:     i;",
          "1554:   size_t",
          "1555:     j;",
          "1557:   unsigned char",
          "1558:     c,",
          "1562:   o = order + (16*iteration);",
          "1564:   for (i=0; i < (ssize_t) count; i++)",
          "1565:   {",
          "1566:     dps[i] = Dot(points[i],axis);",
          "1567:     o[i] = (unsigned char)i;",
          "1568:   }",
          "1570:   for (i=0; i < (ssize_t) count; i++)",
          "1571:   {",
          "1572:     for (j=i; j > 0 && dps[j] < dps[j - 1]; j--)",
          "1573:     {",
          "1574:       f = dps[j];",
          "1575:       dps[j] = dps[j - 1];",
          "1576:       dps[j - 1] = f;",
          "1578:       c = o[j];",
          "1579:       o[j] = o[j - 1];",
          "1580:       o[j - 1] = c;",
          "1581:     }",
          "1582:   }",
          "1584:   for (i=0; i < (ssize_t) iteration; i++)",
          "1585:   {",
          "1586:     MagickBooleanType",
          "1587:       same;",
          "1589:     p = order + (16*i);",
          "1590:     same = MagickTrue;",
          "1592:     for (j=0; j < count; j++)",
          "1593:     {",
          "1594:       if (o[j] != p[j])",
          "1595:         {",
          "1596:           same = MagickFalse;",
          "1597:           break;",
          "1598:         }",
          "1599:     }",
          "1601:     if (same != MagickFalse)",
          "1602:       return MagickFalse;",
          "1603:   }",
          "1605:   xSumwSum->x = 0;",
          "1606:   xSumwSum->y = 0;",
          "1607:   xSumwSum->z = 0;",
          "1608:   xSumwSum->w = 0;",
          "1610:   for (i=0; i < (ssize_t) count; i++)",
          "1611:   {",
          "1612:     DDSVector4",
          "1613:       v;",
          "1615:     j = (size_t) o[i];",
          "1617:     v.x = points[j].w * points[j].x;",
          "1618:     v.y = points[j].w * points[j].y;",
          "1619:     v.z = points[j].w * points[j].z;",
          "1620:     v.w = points[j].w * 1.0f;",
          "1622:     VectorCopy44(v,&pointsWeights[i]);",
          "1623:     VectorAdd(*xSumwSum,v,xSumwSum);",
          "1624:   }",
          "1626:   return MagickTrue;",
          "1627: }",
          "1630: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1631: %                                                                             %",
          "1632: %                                                                             %",
          "1633: %                                                                             %",
          "1634: %   I s D D S                                                                 %",
          "1635: %                                                                             %",
          "1636: %                                                                             %",
          "1637: %                                                                             %",
          "1638: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1639: %",
          "1640: %  IsDDS() returns MagickTrue if the image format type, identified by the",
          "1641: %  magick string, is DDS.",
          "1642: %",
          "1643: %  The format of the IsDDS method is:",
          "1644: %",
          "1645: %      MagickBooleanType IsDDS(const unsigned char *magick,const size_t length)",
          "1646: %",
          "1647: %  A description of each parameter follows:",
          "1648: %",
          "1649: %    o magick: compare image format pattern against these bytes.",
          "1650: %",
          "1651: %    o length: Specifies the length of the magick string.",
          "1652: %",
          "1654: static MagickBooleanType IsDDS(const unsigned char *magick, const size_t length)",
          "1655: {",
          "1656:   if (length < 4)",
          "1657:     return(MagickFalse);",
          "1658:   if (LocaleNCompare((char *) magick,\"DDS \", 4) == 0)",
          "1659:     return(MagickTrue);",
          "1660:   return(MagickFalse);",
          "1661: }",
          "1663: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1664: %                                                                             %",
          "1665: %                                                                             %",
          "1666: %                                                                             %",
          "1667: %   R e a d D D S I m a g e                                                   %",
          "1668: %                                                                             %",
          "1669: %                                                                             %",
          "1670: %                                                                             %",
          "1671: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1672: %",
          "1673: %  ReadDDSImage() reads a DirectDraw Surface image file and returns it.  It",
          "1674: %  allocates the memory necessary for the new Image structure and returns a",
          "1675: %  pointer to the new image.",
          "1676: %",
          "1677: %  The format of the ReadDDSImage method is:",
          "1678: %",
          "1679: %      Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1680: %",
          "1681: %  A description of each parameter follows:",
          "1682: %",
          "1683: %    o image_info: The image info.",
          "1684: %",
          "1685: %    o exception: return any errors or warnings in this structure.",
          "1686: %",
          "1689: static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1690: {",
          "1691:   Image",
          "1694:   MagickBooleanType",
          "1695:     status,",
          "1696:     cubemap = MagickFalse,",
          "1697:     volume = MagickFalse;",
          "1699:   CompressionType",
          "1700:     compression;",
          "1702:   DDSInfo",
          "1703:     dds_info;",
          "1705:   DDSDecoder",
          "1708:   PixelTrait",
          "1709:     alpha_trait;",
          "1711:   size_t",
          "1712:     n,",
          "1713:     num_images;",
          "1716:     Open image file.",
          "1718:   assert(image_info != (const ImageInfo *) NULL);",
          "1719:   assert(image_info->signature == MagickSignature);",
          "1720:   if (image_info->debug != MagickFalse)",
          "1721:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",",
          "1722:       image_info->filename);",
          "1723:   assert(exception != (ExceptionInfo *) NULL);",
          "1724:   assert(exception->signature == MagickSignature);",
          "1725:   image=AcquireImage(image_info,exception);",
          "1726:   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);",
          "1727:   if (status == MagickFalse)",
          "1728:     {",
          "1729:       image=DestroyImageList(image);",
          "1730:       return((Image *) NULL);",
          "1731:     }",
          "1734:     Initialize image structure.",
          "1736:   if (ReadDDSInfo(image, &dds_info) != MagickTrue) {",
          "1737:     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "1738:   }",
          "1740:   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)",
          "1741:     cubemap = MagickTrue;",
          "1743:   if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)",
          "1744:     volume = MagickTrue;",
          "1746:   (void) SeekBlob(image, 128, SEEK_SET);",
          "1749:     Determine pixel format",
          "1751:   if (dds_info.pixelformat.flags & DDPF_RGB)",
          "1752:     {",
          "1753:       compression = NoCompression;",
          "1754:       if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)",
          "1755:         {",
          "1756:           alpha_trait = BlendPixelTrait;",
          "1757:           decoder = ReadUncompressedRGBA;",
          "1758:         }",
          "1759:       else",
          "1760:         {",
          "1761:           alpha_trait = UndefinedPixelTrait;",
          "1762:           decoder = ReadUncompressedRGB;",
          "1763:         }",
          "1764:     }",
          "1765:   else if (dds_info.pixelformat.flags & DDPF_FOURCC)",
          "1766:     {",
          "1767:       switch (dds_info.pixelformat.fourcc)",
          "1768:       {",
          "1769:         case FOURCC_DXT1:",
          "1770:         {",
          "1771:           alpha_trait = UndefinedPixelTrait;",
          "1772:           compression = DXT1Compression;",
          "1773:           decoder = ReadDXT1;",
          "1774:           break;",
          "1775:         }",
          "1777:         case FOURCC_DXT3:",
          "1778:         {",
          "1779:           alpha_trait = BlendPixelTrait;",
          "1780:           compression = DXT3Compression;",
          "1781:           decoder = ReadDXT3;",
          "1782:           break;",
          "1783:         }",
          "1785:         case FOURCC_DXT5:",
          "1786:         {",
          "1787:           alpha_trait = BlendPixelTrait;",
          "1788:           compression = DXT5Compression;",
          "1789:           decoder = ReadDXT5;",
          "1790:           break;",
          "1791:         }",
          "1793:         default:",
          "1794:         {",
          "1796:           ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1797:         }",
          "1798:       }",
          "1799:     }",
          "1800:   else",
          "1801:     {",
          "1803:       ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1804:     }",
          "1806:   num_images = 1;",
          "1807:   if (cubemap)",
          "1808:     {",
          "1810:         Determine number of faces defined in the cubemap",
          "1812:       num_images = 0;",
          "1813:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;",
          "1814:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;",
          "1815:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;",
          "1816:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;",
          "1817:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;",
          "1818:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;",
          "1819:     }",
          "1821:   if (volume)",
          "1822:     num_images = dds_info.depth;",
          "1824:   for (n = 0; n < num_images; n++)",
          "1825:   {",
          "1826:     if (n != 0)",
          "1827:       {",
          "1829:         AcquireNextImage(image_info,image,exception);",
          "1830:         if (GetNextImageInList(image) == (Image *) NULL)",
          "1831:           return(DestroyImageList(image));",
          "1832:         image=SyncNextImageInList(image);",
          "1833:       }",
          "1835:     image->alpha_trait=alpha_trait;",
          "1836:     image->compression = compression;",
          "1837:     image->columns = dds_info.width;",
          "1838:     image->rows = dds_info.height;",
          "1839:     image->storage_class = DirectClass;",
          "1840:     image->endian = LSBEndian;",
          "1841:     image->depth = 8;",
          "1842:     if (image_info->ping != MagickFalse)",
          "1843:       {",
          "1844:         (void) CloseBlob(image);",
          "1845:         return(GetFirstImageInList(image));",
          "1846:       }",
          "1848:     if ((decoder)(image, &dds_info, exception) != MagickTrue)",
          "1849:       {",
          "1850:         (void) CloseBlob(image);",
          "1851:         return(GetFirstImageInList(image));",
          "1852:       }",
          "1853:   }",
          "1855:   if (EOFBlob(image) != MagickFalse)",
          "1856:     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "1857:       image->filename);",
          "1859:   (void) CloseBlob(image);",
          "1860:   return(GetFirstImageInList(image));",
          "1861: }",
          "1863: static MagickBooleanType ReadDDSInfo(Image *image, DDSInfo *dds_info)",
          "1864: {",
          "1865:   size_t",
          "1866:     hdr_size,",
          "1867:     required;",
          "1870:   (void) SeekBlob(image, 4, SEEK_SET);",
          "1873:   hdr_size = ReadBlobLSBLong(image);",
          "1874:   if (hdr_size != 124)",
          "1875:     return MagickFalse;",
          "1878:   dds_info->flags = ReadBlobLSBLong(image);",
          "1881:   required=(size_t) (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);",
          "1882:   if ((dds_info->flags & required) != required)",
          "1883:     return MagickFalse;",
          "1885:   dds_info->height = ReadBlobLSBLong(image);",
          "1886:   dds_info->width = ReadBlobLSBLong(image);",
          "1887:   dds_info->pitchOrLinearSize = ReadBlobLSBLong(image);",
          "1888:   dds_info->depth = ReadBlobLSBLong(image);",
          "1889:   dds_info->mipmapcount = ReadBlobLSBLong(image);",
          "1894:   hdr_size = ReadBlobLSBLong(image);",
          "1895:   if (hdr_size != 32)",
          "1896:     return MagickFalse;",
          "1898:   dds_info->pixelformat.flags = ReadBlobLSBLong(image);",
          "1899:   dds_info->pixelformat.fourcc = ReadBlobLSBLong(image);",
          "1900:   dds_info->pixelformat.rgb_bitcount = ReadBlobLSBLong(image);",
          "1901:   dds_info->pixelformat.r_bitmask = ReadBlobLSBLong(image);",
          "1902:   dds_info->pixelformat.g_bitmask = ReadBlobLSBLong(image);",
          "1903:   dds_info->pixelformat.b_bitmask = ReadBlobLSBLong(image);",
          "1904:   dds_info->pixelformat.alpha_bitmask = ReadBlobLSBLong(image);",
          "1906:   dds_info->ddscaps1 = ReadBlobLSBLong(image);",
          "1907:   dds_info->ddscaps2 = ReadBlobLSBLong(image);",
          "1910:   return MagickTrue;",
          "1911: }",
          "1913: static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,",
          "1914:   ExceptionInfo *exception)",
          "1915: {",
          "1916:   DDSColors",
          "1917:     colors;",
          "1919:   register Quantum",
          "1922:   register ssize_t",
          "1923:     i,",
          "1924:     x;",
          "1926:   size_t",
          "1927:     bits;",
          "1929:   ssize_t",
          "1930:     j,",
          "1931:     y;",
          "1933:   unsigned char",
          "1934:     code;",
          "1936:   unsigned short",
          "1937:     c0,",
          "1938:     c1;",
          "1940:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "1941:   {",
          "1942:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "1943:     {",
          "1945:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "1946:         Min(4, dds_info->height - y),exception);",
          "1948:       if (q == (Quantum *) NULL)",
          "1949:         return MagickFalse;",
          "1952:       c0 = ReadBlobLSBShort(image);",
          "1953:       c1 = ReadBlobLSBShort(image);",
          "1954:       bits = ReadBlobLSBLong(image);",
          "1956:       CalculateColors(c0, c1, &colors, MagickFalse);",
          "1959:       for (j = 0; j < 4; j++)",
          "1960:       {",
          "1961:         for (i = 0; i < 4; i++)",
          "1962:         {",
          "1963:           if ((x + i) < (ssize_t) dds_info->width &&",
          "1964:               (y + j) < (ssize_t) dds_info->height)",
          "1965:             {",
          "1966:               code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);",
          "1967:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "1968:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "1969:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "1970:               SetPixelAlpha(image,ScaleCharToQuantum(colors.a[code]),q);",
          "1971:               if (colors.a[code] && (image->alpha_trait != BlendPixelTrait))",
          "1973:               q+=GetPixelChannels(image);",
          "1974:             }",
          "1975:         }",
          "1976:       }",
          "1978:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "1979:         return MagickFalse;",
          "1980:     }",
          "1981:   }",
          "1983:   SkipDXTMipmaps(image, dds_info, 8);",
          "1985:   return MagickTrue;",
          "1986: }",
          "1988: static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,",
          "1989:   ExceptionInfo *exception)",
          "1990: {",
          "1991:   DDSColors",
          "1992:     colors;",
          "1994:   register Quantum",
          "1997:   register ssize_t",
          "1998:     i,",
          "1999:     x;",
          "2001:   unsigned char",
          "2002:     alpha;",
          "2004:   size_t",
          "2005:     a0,",
          "2006:     a1,",
          "2007:     bits,",
          "2008:     code;",
          "2010:   ssize_t",
          "2011:     j,",
          "2012:     y;",
          "2014:   unsigned short",
          "2015:     c0,",
          "2016:     c1;",
          "2018:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2019:   {",
          "2020:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2021:     {",
          "2023:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2024:                          Min(4, dds_info->height - y),exception);",
          "2026:       if (q == (Quantum *) NULL)",
          "2027:         return MagickFalse;",
          "2030:       a0 = ReadBlobLSBLong(image);",
          "2031:       a1 = ReadBlobLSBLong(image);",
          "2034:       c0 = ReadBlobLSBShort(image);",
          "2035:       c1 = ReadBlobLSBShort(image);",
          "2036:       bits = ReadBlobLSBLong(image);",
          "2038:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2041:       for (j = 0; j < 4; j++)",
          "2042:       {",
          "2043:         for (i = 0; i < 4; i++)",
          "2044:         {",
          "2045:           if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)",
          "2046:             {",
          "2047:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2048:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2049:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2050:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2052:                 Extract alpha value: multiply 0..15 by 17 to get range 0..255",
          "2054:               if (j < 2)",
          "2055:                 alpha = 17U * (unsigned char) ((a0 >> (4*(4*j+i))) & 0xf);",
          "2056:               else",
          "2057:                 alpha = 17U * (unsigned char) ((a1 >> (4*(4*(j-2)+i))) & 0xf);",
          "2058:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2059:               q+=GetPixelChannels(image);",
          "2060:             }",
          "2061:         }",
          "2062:       }",
          "2064:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2065:         return MagickFalse;",
          "2066:     }",
          "2067:   }",
          "2069:   SkipDXTMipmaps(image, dds_info, 16);",
          "2071:   return MagickTrue;",
          "2072: }",
          "2074: static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,",
          "2075:   ExceptionInfo *exception)",
          "2076: {",
          "2077:   DDSColors",
          "2078:     colors;",
          "2080:   MagickSizeType",
          "2081:     alpha_bits;",
          "2083:   register Quantum",
          "2086:   register ssize_t",
          "2087:     i,",
          "2088:     x;",
          "2090:   unsigned char",
          "2091:     a0,",
          "2092:     a1;",
          "2094:   size_t",
          "2095:     alpha,",
          "2096:     bits,",
          "2097:     code,",
          "2098:     alpha_code;",
          "2100:   ssize_t",
          "2101:     j,",
          "2102:     y;",
          "2104:   unsigned short",
          "2105:     c0,",
          "2106:     c1;",
          "2108:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2109:   {",
          "2110:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2111:     {",
          "2113:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2114:                          Min(4, dds_info->height - y),exception);",
          "2116:       if (q == (Quantum *) NULL)",
          "2117:         return MagickFalse;",
          "2120:       a0 = (unsigned char) ReadBlobByte(image);",
          "2121:       a1 = (unsigned char) ReadBlobByte(image);",
          "2123:       alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);",
          "2124:       alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);",
          "2127:       c0 = ReadBlobLSBShort(image);",
          "2128:       c1 = ReadBlobLSBShort(image);",
          "2129:       bits = ReadBlobLSBLong(image);",
          "2131:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2134:       for (j = 0; j < 4; j++)",
          "2135:       {",
          "2136:         for (i = 0; i < 4; i++)",
          "2137:         {",
          "2138:           if ((x + i) < (ssize_t) dds_info->width &&",
          "2139:               (y + j) < (ssize_t) dds_info->height)",
          "2140:             {",
          "2141:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2142:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2143:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2144:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2146:               alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;",
          "2147:               if (alpha_code == 0)",
          "2148:                 alpha = a0;",
          "2149:               else if (alpha_code == 1)",
          "2150:                 alpha = a1;",
          "2151:               else if (a0 > a1)",
          "2152:                 alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;",
          "2153:               else if (alpha_code == 6)",
          "2154:                 alpha = 0;",
          "2155:               else if (alpha_code == 7)",
          "2156:                 alpha = 255;",
          "2157:               else",
          "2158:                 alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);",
          "2159:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2160:               q+=GetPixelChannels(image);",
          "2161:             }",
          "2162:         }",
          "2163:       }",
          "2165:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2166:         return MagickFalse;",
          "2167:     }",
          "2168:   }",
          "2170:   SkipDXTMipmaps(image, dds_info, 16);",
          "2172:   return MagickTrue;",
          "2173: }",
          "2175: static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,",
          "2176:   ExceptionInfo *exception)",
          "2177: {",
          "2178:   register Quantum",
          "2184:   unsigned short",
          "2188:     dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))",
          "2189:     ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2190:       image->filename);",
          "2192:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2193:   {",
          "2194:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2196:     if (q == (Quantum *) NULL)",
          "2197:       return MagickFalse;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2208:              ((((unsigned short)(color << 5) >> 10)/63.0)*255)),q);",
          "2209:            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2210:              ((((unsigned short)(color << 11) >> 11)/31.0)*255)),q);",
          "2220:           if (dds_info->pixelformat.rgb_bitcount == 32)",
          "2242:     alphaBits,",
          "2243:     x,",
          "2244:     y;",
          "2247:     color;",
          "2249:   alphaBits=0;",
          "",
          "[Removed Lines]",
          "2211:         }",
          "2212:       else",
          "2213:         {",
          "2214:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2215:             ReadBlobByte(image)),q);",
          "2216:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2217:             ReadBlobByte(image)),q);",
          "2218:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2219:             ReadBlobByte(image)),q);",
          "2221:             (void) ReadBlobByte(image);",
          "2222:         }",
          "2223:       q+=GetPixelChannels(image);",
          "2224:     }",
          "2226:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2227:       return MagickFalse;",
          "2228:   }",
          "2230:   SkipRGBMipmaps(image, dds_info, 3);",
          "2232:   return MagickTrue;",
          "2233: }",
          "2235: static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,",
          "2236:   ExceptionInfo *exception)",
          "2237: {",
          "2238:   register Quantum",
          "2241:   ssize_t",
          "2246:   unsigned short",
          "",
          "[Added Lines]",
          "2211:         }",
          "2212:       else",
          "2213:         {",
          "2214:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2215:             ReadBlobByte(image)),q);",
          "2216:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2217:             ReadBlobByte(image)),q);",
          "2218:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2219:             ReadBlobByte(image)),q);",
          "2221:             (void) ReadBlobByte(image);",
          "2222:         }",
          "2223:       q+=GetPixelChannels(image);",
          "2224:     }",
          "2226:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2227:       return MagickFalse;",
          "2228:   }",
          "2230:   SkipRGBMipmaps(image, dds_info, 3);",
          "2232:   return MagickTrue;",
          "2233: }",
          "2235: static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,",
          "2236:   ExceptionInfo *exception)",
          "2237: {",
          "2238:   register Quantum",
          "2241:   ssize_t",
          "2246:   unsigned short",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2254:       else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))",
          "2255:         alphaBits=4;",
          "2256:       else",
          "2268:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2269:     {",
          "",
          "[Removed Lines]",
          "2257:         ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2258:           image->filename);",
          "2259:     }",
          "2261:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2262:   {",
          "2263:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2265:     if (q == (Quantum *) NULL)",
          "2266:       return MagickFalse;",
          "",
          "[Added Lines]",
          "2257:         ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2258:           image->filename);",
          "2259:     }",
          "2261:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2262:   {",
          "2263:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2265:     if (q == (Quantum *) NULL)",
          "2266:       return MagickFalse;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2291:                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2292:                  ((((unsigned short)(color << 12) >> 12)/15.0)*255)),q);",
          "2293:             }",
          "3096:   }",
          "3097: }",
          "",
          "[Removed Lines]",
          "2294:         }",
          "2295:       else",
          "2296:         {",
          "2297:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2298:             ReadBlobByte(image)),q);",
          "2299:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2300:             ReadBlobByte(image)),q);",
          "2301:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2302:             ReadBlobByte(image)),q);",
          "2303:           SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2304:             ReadBlobByte(image)),q);",
          "2305:         }",
          "2306:       q+=GetPixelChannels(image);",
          "2307:     }",
          "2309:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2310:       return MagickFalse;",
          "2311:   }",
          "2313:   SkipRGBMipmaps(image, dds_info, 4);",
          "2315:   return MagickTrue;",
          "2316: }",
          "2320: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2321: %                                                                             %",
          "2322: %                                                                             %",
          "2323: %                                                                             %",
          "2324: %   R e g i s t e r D D S I m a g e                                           %",
          "2325: %                                                                             %",
          "2326: %                                                                             %",
          "2327: %                                                                             %",
          "2328: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2329: %",
          "2330: %  RegisterDDSImage() adds attributes for the DDS image format to",
          "2331: %  the list of supported formats.  The attributes include the image format",
          "2332: %  tag, a method to read and/or write the format, whether the format",
          "2333: %  supports the saving of more than one frame to the same file or blob,",
          "2334: %  whether the format supports native in-memory I/O, and a brief",
          "2335: %  description of the format.",
          "2336: %",
          "2337: %  The format of the RegisterDDSImage method is:",
          "2338: %",
          "2339: %      RegisterDDSImage(void)",
          "2340: %",
          "2342: ModuleExport size_t RegisterDDSImage(void)",
          "2343: {",
          "2344:   MagickInfo",
          "2347:   entry = SetMagickInfo(\"DDS\");",
          "2348:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2349:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2350:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2351:   entry->seekable_stream=MagickTrue;",
          "2352:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2353:   entry->module = ConstantString(\"DDS\");",
          "2354:   (void) RegisterMagickInfo(entry);",
          "2355:   entry = SetMagickInfo(\"DXT1\");",
          "2356:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2357:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2358:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2359:   entry->seekable_stream=MagickTrue;",
          "2360:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2361:   entry->module = ConstantString(\"DDS\");",
          "2362:   (void) RegisterMagickInfo(entry);",
          "2363:   entry = SetMagickInfo(\"DXT5\");",
          "2364:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2365:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2366:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2367:   entry->seekable_stream=MagickTrue;",
          "2368:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2369:   entry->module = ConstantString(\"DDS\");",
          "2370:   (void) RegisterMagickInfo(entry);",
          "2371:   return(MagickImageCoderSignature);",
          "2372: }",
          "2374: static void RemapIndices(const ssize_t *map, const unsigned char *source,",
          "2375:   unsigned char *target)",
          "2376: {",
          "2377:   register ssize_t",
          "2378:     i;",
          "2380:   for (i = 0; i < 16; i++)",
          "2381:   {",
          "2382:     if (map[i] == -1)",
          "2383:       target[i] = 3;",
          "2384:     else",
          "2385:       target[i] = source[map[i]];",
          "2386:   }",
          "2387: }",
          "2390:   Skip the mipmap images for compressed (DXTn) dds files",
          "2392: static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)",
          "2393: {",
          "2394:   MagickOffsetType",
          "2395:     offset;",
          "2397:   register ssize_t",
          "2398:     i;",
          "2400:   size_t",
          "2401:     h,",
          "2402:     w;",
          "2405:     Only skip mipmaps for textures and cube maps",
          "2407:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2408:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2409:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2410:     {",
          "2411:       w = DIV2(dds_info->width);",
          "2412:       h = DIV2(dds_info->height);",
          "2415:         Mipmapcount includes the main image, so start from one",
          "2417:       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2418:       {",
          "2419:         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;",
          "2420:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2422:         w = DIV2(w);",
          "2423:         h = DIV2(h);",
          "2424:       }",
          "2425:     }",
          "2426: }",
          "2429:   Skip the mipmap images for uncompressed (RGB or RGBA) dds files",
          "2431: static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)",
          "2432: {",
          "2433:   MagickOffsetType",
          "2434:     offset;",
          "2436:   register ssize_t",
          "2437:     i;",
          "2439:   size_t",
          "2440:     h,",
          "2441:     w;",
          "2444:     Only skip mipmaps for textures and cube maps",
          "2446:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2447:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2448:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2449:     {",
          "2450:       w = DIV2(dds_info->width);",
          "2451:       h = DIV2(dds_info->height);",
          "2454:         Mipmapcount includes the main image, so start from one",
          "2456:       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2457:       {",
          "2458:         offset = (MagickOffsetType) w * h * pixel_size;",
          "2459:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2461:         w = DIV2(w);",
          "2462:         h = DIV2(h);",
          "2463:       }",
          "2464:     }",
          "2465: }",
          "2469: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2470: %                                                                             %",
          "2471: %                                                                             %",
          "2472: %                                                                             %",
          "2473: %   U n r e g i s t e r D D S I m a g e                                       %",
          "2474: %                                                                             %",
          "2475: %                                                                             %",
          "2476: %                                                                             %",
          "2477: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2478: %",
          "2479: %  UnregisterDDSImage() removes format registrations made by the",
          "2480: %  DDS module from the list of supported formats.",
          "2481: %",
          "2482: %  The format of the UnregisterDDSImage method is:",
          "2483: %",
          "2484: %      UnregisterDDSImage(void)",
          "2485: %",
          "2487: ModuleExport void UnregisterDDSImage(void)",
          "2488: {",
          "2489:   (void) UnregisterMagickInfo(\"DDS\");",
          "2490:   (void) UnregisterMagickInfo(\"DXT1\");",
          "2491:   (void) UnregisterMagickInfo(\"DXT5\");",
          "2492: }",
          "2494: static void WriteAlphas(Image *image, const ssize_t *alphas, size_t min5,",
          "2495:   size_t max5, size_t min7, size_t max7)",
          "2496: {",
          "2497:   register ssize_t",
          "2498:     i;",
          "2500:   size_t",
          "2501:     err5,",
          "2502:     err7,",
          "2503:     j;",
          "2505:   unsigned char",
          "2506:     indices5[16],",
          "2507:     indices7[16];",
          "2509:   FixRange(min5,max5,5);",
          "2510:   err5 = CompressAlpha(min5,max5,5,alphas,indices5);",
          "2512:   FixRange(min7,max7,7);",
          "2513:   err7 = CompressAlpha(min7,max7,7,alphas,indices7);",
          "2515:   if (err7 < err5)",
          "2516:   {",
          "2517:     for (i=0; i < 16; i++)",
          "2518:     {",
          "2519:       unsigned char",
          "2520:         index;",
          "2522:       index = indices7[i];",
          "2523:       if( index == 0 )",
          "2524:         indices5[i] = 1;",
          "2525:       else if (index == 1)",
          "2526:         indices5[i] = 0;",
          "2527:       else",
          "2528:         indices5[i] = 9 - index;",
          "2529:     }",
          "2531:     min5 = max7;",
          "2532:     max5 = min7;",
          "2533:   }",
          "2535:   (void) WriteBlobByte(image,(unsigned char) min5);",
          "2536:   (void) WriteBlobByte(image,(unsigned char) max5);",
          "2538:   for(i=0; i < 2; i++)",
          "2539:   {",
          "2540:     size_t",
          "2541:       value = 0;",
          "2543:     for (j=0; j < 8; j++)",
          "2544:     {",
          "2545:       size_t index = (size_t) indices5[j + i*8];",
          "2546:       value |= ( index << 3*j );",
          "2547:     }",
          "2549:     for (j=0; j < 3; j++)",
          "2550:     {",
          "2551:       size_t byte = (value >> 8*j) & 0xff;",
          "2552:       (void) WriteBlobByte(image,(unsigned char) byte);",
          "2553:     }",
          "2554:   }",
          "2555: }",
          "2557: static void WriteCompressed(Image *image, const size_t count,",
          "2558:   DDSVector4 *points, const ssize_t *map, const MagickBooleanType clusterFit)",
          "2559: {",
          "2560:   float",
          "2561:     covariance[16];",
          "2563:   DDSVector3",
          "2564:     end,",
          "2565:     principle,",
          "2566:     start;",
          "2568:   DDSVector4",
          "2569:     metric;",
          "2571:   unsigned char",
          "2572:     indices[16];",
          "2574:   VectorInit(metric,1.0f);",
          "2575:   VectorInit3(start,0.0f);",
          "2576:   VectorInit3(end,0.0f);",
          "2578:   ComputeWeightedCovariance(count,points,covariance);",
          "2579:   ComputePrincipleComponent(covariance,&principle);",
          "2581:   if (clusterFit == MagickFalse || count == 0)",
          "2582:     CompressRangeFit(count,points,map,principle,metric,&start,&end,indices);",
          "2583:   else",
          "2584:     CompressClusterFit(count,points,map,principle,metric,&start,&end,indices);",
          "2586:   WriteIndices(image,start,end,indices);",
          "2587: }",
          "2590: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2591: %                                                                             %",
          "2592: %                                                                             %",
          "2593: %                                                                             %",
          "2594: %   W r i t e D D S I m a g e                                                 %",
          "2595: %                                                                             %",
          "2596: %                                                                             %",
          "2597: %                                                                             %",
          "2598: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2599: %",
          "2600: %  WriteDDSImage() writes a DirectDraw Surface image file in the DXT5 format.",
          "2601: %",
          "2602: %  The format of the WriteBMPImage method is:",
          "2603: %",
          "2604: %     MagickBooleanType WriteDDSImage(const ImageInfo *image_info,Image *image)",
          "2605: %",
          "2606: %  A description of each parameter follows.",
          "2607: %",
          "2608: %    o image_info: the image info.",
          "2609: %",
          "2610: %    o image:  The image.",
          "2611: %",
          "2613: static MagickBooleanType WriteDDSImage(const ImageInfo *image_info,",
          "2614:   Image *image, ExceptionInfo *exception)",
          "2615: {",
          "2616:   const char",
          "2619:   size_t",
          "2620:     compression,",
          "2621:     columns,",
          "2622:     maxMipmaps,",
          "2623:     mipmaps,",
          "2624:     pixelFormat,",
          "2625:     rows;",
          "2627:   MagickBooleanType",
          "2628:     clusterFit,",
          "2629:     status,",
          "2630:     weightByAlpha;",
          "2632:   assert(image_info != (const ImageInfo *) NULL);",
          "2633:   assert(image_info->signature == MagickSignature);",
          "2634:   assert(image != (Image *) NULL);",
          "2635:   assert(image->signature == MagickSignature);",
          "2636:   if (image->debug != MagickFalse)",
          "2637:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);",
          "2638:   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);",
          "2639:   if (status == MagickFalse)",
          "2640:     return(status);",
          "2641:   (void) TransformImageColorspace(image,sRGBColorspace,exception);",
          "2642:   pixelFormat=DDPF_FOURCC;",
          "2643:   compression=FOURCC_DXT5;",
          "2645:   if (image->alpha_trait != BlendPixelTrait)",
          "2646:     compression=FOURCC_DXT1;",
          "2648:   if (LocaleCompare(image_info->magick,\"dxt1\") == 0)",
          "2649:     compression=FOURCC_DXT1;",
          "2651:   option=GetImageOption(image_info,\"dds:compression\");",
          "2652:   if (option != (char *) NULL)",
          "2653:     {",
          "2654:        if (LocaleCompare(option,\"dxt1\") == 0)",
          "2655:          compression=FOURCC_DXT1;",
          "2656:        if (LocaleCompare(option,\"none\") == 0)",
          "2657:          pixelFormat=DDPF_RGB;",
          "2658:     }",
          "2660:   clusterFit=MagickFalse;",
          "2661:   weightByAlpha=MagickFalse;",
          "2663:   if (pixelFormat == DDPF_FOURCC)",
          "2664:     {",
          "2665:       option=GetImageOption(image_info,\"dds:cluster-fit\");",
          "2666:       if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2667:         {",
          "2668:           clusterFit=MagickTrue;",
          "2669:           if (compression != FOURCC_DXT1)",
          "2670:             {",
          "2671:               option=GetImageOption(image_info,\"dds:weight-by-alpha\");",
          "2672:               if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2673:                 weightByAlpha=MagickTrue;",
          "2674:             }",
          "2675:         }",
          "2676:     }",
          "2678:   maxMipmaps=SIZE_MAX;",
          "2679:   mipmaps=0;",
          "2680:   if ((image->columns & (image->columns - 1)) == 0 &&",
          "2681:       (image->rows & (image->rows - 1)) == 0)",
          "2682:     {",
          "2683:       option=GetImageOption(image_info,\"dds:mipmaps\");",
          "2684:       if (option != (char *) NULL)",
          "2685:         maxMipmaps=StringToUnsignedLong(option);",
          "2687:       if (maxMipmaps != 0)",
          "2688:         {",
          "2689:           columns=image->columns;",
          "2690:           rows=image->rows;",
          "2691:           while (columns != 1 && rows != 1 && mipmaps != maxMipmaps)",
          "2692:           {",
          "2693:             columns=DIV2(columns);",
          "2694:             rows=DIV2(rows);",
          "2695:             mipmaps++;",
          "2696:           }",
          "2697:         }",
          "2698:     }",
          "2700:   WriteDDSInfo(image,pixelFormat,compression,mipmaps);",
          "2702:   WriteImageData(image,pixelFormat,compression,clusterFit,weightByAlpha,",
          "2703:     exception);",
          "2705:   if (mipmaps > 0 && WriteMipmaps(image,pixelFormat,compression,mipmaps,",
          "2706:         clusterFit,weightByAlpha,exception) == MagickFalse)",
          "2707:     return(MagickFalse);",
          "2709:   (void) CloseBlob(image);",
          "2710:   return(MagickTrue);",
          "2711: }",
          "2713: static void WriteDDSInfo(Image *image, const size_t pixelFormat,",
          "2714:   const size_t compression, const size_t mipmaps)",
          "2715: {",
          "2716:   char",
          "2717:     software[MaxTextExtent];",
          "2719:   register ssize_t",
          "2720:     i;",
          "2722:   unsigned int",
          "2723:     format,",
          "2724:     caps,",
          "2725:     flags;",
          "2727:   flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |",
          "2728:     DDSD_PIXELFORMAT | DDSD_LINEARSIZE);",
          "2729:   caps=(unsigned int) DDSCAPS_TEXTURE;",
          "2730:   format=(unsigned int) pixelFormat;",
          "2732:   if (mipmaps > 0)",
          "2733:     {",
          "2734:       flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;",
          "2735:       caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);",
          "2736:     }",
          "2738:   if (format != DDPF_FOURCC && image->alpha_trait == BlendPixelTrait)",
          "2739:     format=format | DDPF_ALPHAPIXELS;",
          "2741:   (void) WriteBlob(image,4,(unsigned char *) \"DDS \");",
          "2742:   (void) WriteBlobLSBLong(image,124);",
          "2743:   (void) WriteBlobLSBLong(image,flags);",
          "2744:   (void) WriteBlobLSBLong(image,image->rows);",
          "2745:   (void) WriteBlobLSBLong(image,image->columns);",
          "2747:   if (compression == FOURCC_DXT1)",
          "2748:     (void) WriteBlobLSBLong(image,",
          "2749:              (unsigned int) (Max(1,(image->columns+3)/4) * 8));",
          "2750:   else",
          "2751:     (void) WriteBlobLSBLong(image,",
          "2752:              (unsigned int) (Max(1,(image->columns+3)/4) * 16));",
          "2754:   (void) WriteBlobLSBLong(image,0x00);",
          "2755:   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);",
          "2756:   (void) ResetMagickMemory(software,0,sizeof(software));",
          "2757:   (void) strcpy(software,\"IMAGEMAGICK\");",
          "2758:   (void) WriteBlob(image,44,(unsigned char *) software);",
          "2760:   (void) WriteBlobLSBLong(image,32);",
          "2761:   (void) WriteBlobLSBLong(image,format);",
          "2763:   if (pixelFormat == DDPF_FOURCC)",
          "2764:     {",
          "2765:       (void) WriteBlobLSBLong(image,(unsigned int) compression);",
          "2766:       for(i=0;i < 5;i++) // bitcount / masks",
          "2767:         (void) WriteBlobLSBLong(image,0x00);",
          "2768:     }",
          "2769:   else",
          "2770:     {",
          "2771:       (void) WriteBlobLSBLong(image,0x00);",
          "2772:       if (image->alpha_trait == BlendPixelTrait)",
          "2773:         {",
          "2774:           (void) WriteBlobLSBLong(image,32);",
          "2775:           (void) WriteBlobLSBLong(image,0xff0000);",
          "2776:           (void) WriteBlobLSBLong(image,0xff00);",
          "2777:           (void) WriteBlobLSBLong(image,0xff);",
          "2778:           (void) WriteBlobLSBLong(image,0xff000000);",
          "2779:         }",
          "2780:       else",
          "2781:         {",
          "2782:           (void) WriteBlobLSBLong(image,24);",
          "2783:           (void) WriteBlobLSBLong(image,0xff);",
          "2784:           (void) WriteBlobLSBLong(image,0x00);",
          "2785:           (void) WriteBlobLSBLong(image,0x00);",
          "2786:           (void) WriteBlobLSBLong(image,0x00);",
          "2787:         }",
          "2788:     }",
          "2790:   (void) WriteBlobLSBLong(image,caps);",
          "2791:   for(i=0;i < 4;i++) // ddscaps2 + reserved region",
          "2792:     (void) WriteBlobLSBLong(image,0x00);",
          "2793: }",
          "2795: static void WriteFourCC(Image *image, const size_t compression,",
          "2796:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "2797:   ExceptionInfo *exception)",
          "2798: {",
          "2799:   register ssize_t",
          "2800:     x;",
          "2802:   ssize_t",
          "2803:     i,",
          "2804:     y,",
          "2805:     bx,",
          "2806:     by;",
          "2808:   register const Quantum",
          "2811:   for (y=0; y < (ssize_t) image->rows; y+=4)",
          "2812:   {",
          "2813:     for (x=0; x < (ssize_t) image->columns; x+=4)",
          "2814:     {",
          "2815:       MagickBooleanType",
          "2816:         match;",
          "2818:       DDSVector4",
          "2819:         point,",
          "2820:         points[16];",
          "2822:       size_t",
          "2823:         count = 0,",
          "2824:         max5 = 0,",
          "2825:         max7 = 0,",
          "2826:         min5 = 255,",
          "2827:         min7 = 255,",
          "2828:         columns = 4,",
          "2829:         rows = 4;",
          "2831:       ssize_t",
          "2832:         alphas[16],",
          "2833:         map[16];",
          "2835:       unsigned char",
          "2836:         alpha;",
          "2838:       if (x + columns >= image->columns)",
          "2839:         columns = image->columns - x;",
          "2841:       if (y + rows >= image->rows)",
          "2842:         rows = image->rows - y;",
          "2844:       p=GetVirtualPixels(image,x,y,columns,rows,exception);",
          "2845:       if (p == (const Quantum *) NULL)",
          "2846:         break;",
          "2848:       for (i=0; i<16; i++)",
          "2849:       {",
          "2850:         map[i] = -1;",
          "2851:         alphas[i] = -1;",
          "2852:       }",
          "2854:       for (by=0; by <  (ssize_t) rows; by++)",
          "2855:       {",
          "2856:         for (bx=0; bx <  (ssize_t) columns; bx++)",
          "2857:         {",
          "2858:           if (compression == FOURCC_DXT5)",
          "2859:             alpha = ScaleQuantumToChar(GetPixelAlpha(image,p));",
          "2860:           else",
          "2861:             alpha = 255;",
          "2863:           alphas[4*by + bx] = (size_t)alpha;",
          "2865:           point.x = (float)ScaleQuantumToChar(GetPixelRed(image,p)) / 255.0f;",
          "2866:           point.y = (float)ScaleQuantumToChar(GetPixelGreen(image,p)) / 255.0f;",
          "2867:           point.z = (float)ScaleQuantumToChar(GetPixelBlue(image,p)) / 255.0f;",
          "2868:           point.w = weightByAlpha ? (float)(alpha + 1) / 256.0f : 1.0f;",
          "2869:           p+=GetPixelChannels(image);",
          "2871:           match = MagickFalse;",
          "2872:           for (i=0; i <  (ssize_t) count; i++)",
          "2873:           {",
          "2874:             if ((points[i].x == point.x) &&",
          "2875:                 (points[i].y == point.y) &&",
          "2876:                 (points[i].z == point.z) &&",
          "2877:                 (alpha       >= 128 || compression == FOURCC_DXT5))",
          "2878:               {",
          "2879:                 points[i].w += point.w;",
          "2880:                 map[4*by + bx] = i;",
          "2881:                 match = MagickTrue;",
          "2882:                 break;",
          "2883:               }",
          "2884:             }",
          "2886:             if (match != MagickFalse)",
          "2887:               continue;",
          "2889:             points[count].x = point.x;",
          "2890:             points[count].y = point.y;",
          "2891:             points[count].z = point.z;",
          "2892:             points[count].w = point.w;",
          "2893:             map[4*by + bx] = count;",
          "2894:             count++;",
          "2896:             if (compression == FOURCC_DXT5)",
          "2897:               {",
          "2898:                 if (alpha < min7)",
          "2899:                   min7 = alpha;",
          "2900:                 if (alpha > max7)",
          "2901:                   max7 = alpha;",
          "2902:                 if (alpha != 0 && alpha < min5)",
          "2903:                   min5 = alpha;",
          "2904:                 if (alpha != 255 && alpha > max5)",
          "2905:                   max5 = alpha;",
          "2906:               }",
          "2907:           }",
          "2908:         }",
          "2910:       for (i=0; i <  (ssize_t) count; i++)",
          "2911:         points[i].w = sqrt(points[i].w);",
          "2913:       if (compression == FOURCC_DXT5)",
          "2914:         WriteAlphas(image,alphas,min5,max5,min7,max7);",
          "2916:       if (count == 1)",
          "2917:         WriteSingleColorFit(image,points,map);",
          "2918:       else",
          "2919:         WriteCompressed(image,count,points,map,clusterFit);",
          "2920:     }",
          "2921:   }",
          "2922: }",
          "2924: static void WriteImageData(Image *image, const size_t pixelFormat,",
          "2925:   const size_t compression,const MagickBooleanType clusterFit,",
          "2926:   const MagickBooleanType weightByAlpha, ExceptionInfo *exception)",
          "2927: {",
          "2928:   if (pixelFormat == DDPF_FOURCC)",
          "2929:     WriteFourCC(image,compression,clusterFit,weightByAlpha,exception);",
          "2930:   else",
          "2931:     WriteUncompressed(image,exception);",
          "2932: }",
          "2934: static inline size_t ClampToLimit(const float value, const size_t limit)",
          "2935: {",
          "2936:   size_t",
          "2937:     result = (int) (value + 0.5f);",
          "2939:   if (result < 0.0f)",
          "2940:     return(0);",
          "2941:   if (result > limit)",
          "2942:     return(limit);",
          "2943:   return result;",
          "2944: }",
          "2946: static inline size_t ColorTo565(const DDSVector3 point)",
          "2947: {",
          "2948:   size_t r = ClampToLimit(31.0f*point.x,31);",
          "2949:   size_t g = ClampToLimit(63.0f*point.y,63);",
          "2950:   size_t b = ClampToLimit(31.0f*point.z,31);",
          "2952:   return (r << 11) | (g << 5) | b;",
          "2953: }",
          "2955: static void WriteIndices(Image *image, const DDSVector3 start,",
          "2956:   const DDSVector3 end, unsigned char *indices)",
          "2957: {",
          "2958:   register ssize_t",
          "2959:     i;",
          "2961:   size_t",
          "2962:     a,",
          "2963:     b;",
          "2965:   unsigned char",
          "2966:     remapped[16];",
          "2968:   const unsigned char",
          "2971:   a = ColorTo565(start);",
          "2972:   b = ColorTo565(end);",
          "2974:   for (i=0; i<16; i++)",
          "2975:   {",
          "2976:     if( a < b )",
          "2977:       remapped[i] = (indices[i] ^ 0x1) & 0x3;",
          "2978:     else if( a == b )",
          "2979:       remapped[i] = 0;",
          "2980:     else",
          "2981:       remapped[i] = indices[i];",
          "2982:   }",
          "2984:   if( a < b )",
          "2985:     Swap(a,b);",
          "2987:   (void) WriteBlobByte(image,(unsigned char) (a & 0xff));",
          "2988:   (void) WriteBlobByte(image,(unsigned char) (a >> 8));",
          "2989:   (void) WriteBlobByte(image,(unsigned char) (b & 0xff));",
          "2990:   (void) WriteBlobByte(image,(unsigned char) (b >> 8));",
          "2992:   for (i=0; i<4; i++)",
          "2993:   {",
          "2994:      ind = remapped + 4*i;",
          "2995:      (void) WriteBlobByte(image,ind[0] | (ind[1] << 2) | (ind[2] << 4) |",
          "2996:        (ind[3] << 6));",
          "2997:   }",
          "2998: }",
          "3000: static MagickBooleanType WriteMipmaps(Image *image, const size_t pixelFormat,",
          "3001:   const size_t compression, const size_t mipmaps,",
          "3002:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "3003:   ExceptionInfo *exception)",
          "3004: {",
          "3005:   Image*",
          "3006:     resize_image;",
          "3008:   register ssize_t",
          "3009:     i;",
          "3011:   size_t",
          "3012:     columns,",
          "3013:     rows;",
          "3015:   columns = image->columns;",
          "3016:   rows = image->rows;",
          "3018:   for (i=0; i< (ssize_t) mipmaps; i++)",
          "3019:   {",
          "3020:     resize_image = ResizeImage(image,columns/2,rows/2,TriangleFilter,",
          "3021:       exception);",
          "3023:     if (resize_image == (Image *) NULL)",
          "3024:       return(MagickFalse);",
          "3026:     DestroyBlob(resize_image);",
          "3027:     resize_image->blob=ReferenceBlob(image->blob);",
          "3029:     WriteImageData(resize_image,pixelFormat,compression,weightByAlpha,",
          "3030:       clusterFit,exception);",
          "3032:     resize_image=DestroyImage(resize_image);",
          "3034:     columns = DIV2(columns);",
          "3035:     rows = DIV2(rows);",
          "3036:   }",
          "3038:   return(MagickTrue);",
          "3039: }",
          "3041: static void WriteSingleColorFit(Image *image, const DDSVector4 *points,",
          "3042:   const ssize_t *map)",
          "3043: {",
          "3044:   DDSVector3",
          "3045:     start,",
          "3046:     end;",
          "3048:   register ssize_t",
          "3049:     i;",
          "3051:   unsigned char",
          "3052:     color[3],",
          "3053:     index,",
          "3054:     indexes[16],",
          "3055:     indices[16];",
          "3057:   color[0] = (unsigned char) ClampToLimit(255.0f*points->x,255);",
          "3058:   color[1] = (unsigned char) ClampToLimit(255.0f*points->y,255);",
          "3059:   color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);",
          "3061:   index=0;",
          "3062:   ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);",
          "3064:   for (i=0; i< 16; i++)",
          "3065:     indexes[i]=index;",
          "3066:   RemapIndices(map,indexes,indices);",
          "3067:   WriteIndices(image,start,end,indices);",
          "3068: }",
          "3070: static void WriteUncompressed(Image *image, ExceptionInfo *exception)",
          "3071: {",
          "3072:   register const Quantum",
          "3075:   register ssize_t",
          "3076:     x;",
          "3078:   ssize_t",
          "3079:     y;",
          "3081:   for (y=0; y < (ssize_t) image->rows; y++)",
          "3082:   {",
          "3083:     p=GetVirtualPixels(image,0,y,image->columns,1,exception);",
          "3084:     if (p == (const Quantum *) NULL)",
          "3085:       break;",
          "3087:     for (x=0; x < (ssize_t) image->columns; x++)",
          "3088:     {",
          "3089:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(image,p)));",
          "3090:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(image,p)));",
          "3091:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(image,p)));",
          "3092:       if (image->alpha_trait == BlendPixelTrait)",
          "3093:         (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));",
          "3094:       p+=GetPixelChannels(image);",
          "3095:     }",
          "",
          "[Added Lines]",
          "2294:         }",
          "2295:       else",
          "2296:         {",
          "2297:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2298:             ReadBlobByte(image)),q);",
          "2299:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2300:             ReadBlobByte(image)),q);",
          "2301:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2302:             ReadBlobByte(image)),q);",
          "2303:           SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2304:             ReadBlobByte(image)),q);",
          "2305:         }",
          "2306:       q+=GetPixelChannels(image);",
          "2307:     }",
          "2309:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2310:       return MagickFalse;",
          "2311:   }",
          "2313:   SkipRGBMipmaps(image, dds_info, 4);",
          "2315:   return MagickTrue;",
          "2316: }",
          "2320: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2321: %                                                                             %",
          "2322: %                                                                             %",
          "2323: %                                                                             %",
          "2324: %   R e g i s t e r D D S I m a g e                                           %",
          "2325: %                                                                             %",
          "2326: %                                                                             %",
          "2327: %                                                                             %",
          "2328: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2329: %",
          "2330: %  RegisterDDSImage() adds attributes for the DDS image format to",
          "2331: %  the list of supported formats.  The attributes include the image format",
          "2332: %  tag, a method to read and/or write the format, whether the format",
          "2333: %  supports the saving of more than one frame to the same file or blob,",
          "2334: %  whether the format supports native in-memory I/O, and a brief",
          "2335: %  description of the format.",
          "2336: %",
          "2337: %  The format of the RegisterDDSImage method is:",
          "2338: %",
          "2339: %      RegisterDDSImage(void)",
          "2340: %",
          "2342: ModuleExport size_t RegisterDDSImage(void)",
          "2343: {",
          "2344:   MagickInfo",
          "2347:   entry = SetMagickInfo(\"DDS\");",
          "2348:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2349:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2350:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2351:   entry->seekable_stream=MagickTrue;",
          "2352:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2353:   entry->module = ConstantString(\"DDS\");",
          "2354:   (void) RegisterMagickInfo(entry);",
          "2355:   entry = SetMagickInfo(\"DXT1\");",
          "2356:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2357:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2358:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2359:   entry->seekable_stream=MagickTrue;",
          "2360:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2361:   entry->module = ConstantString(\"DDS\");",
          "2362:   (void) RegisterMagickInfo(entry);",
          "2363:   entry = SetMagickInfo(\"DXT5\");",
          "2364:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2365:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2366:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2367:   entry->seekable_stream=MagickTrue;",
          "2368:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2369:   entry->module = ConstantString(\"DDS\");",
          "2370:   (void) RegisterMagickInfo(entry);",
          "2371:   return(MagickImageCoderSignature);",
          "2372: }",
          "2374: static void RemapIndices(const ssize_t *map, const unsigned char *source,",
          "2375:   unsigned char *target)",
          "2376: {",
          "2377:   register ssize_t",
          "2378:     i;",
          "2380:   for (i = 0; i < 16; i++)",
          "2381:   {",
          "2382:     if (map[i] == -1)",
          "2383:       target[i] = 3;",
          "2384:     else",
          "2385:       target[i] = source[map[i]];",
          "2386:   }",
          "2387: }",
          "2390:   Skip the mipmap images for compressed (DXTn) dds files",
          "2392: static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)",
          "2393: {",
          "2394:   MagickOffsetType",
          "2395:     offset;",
          "2397:   register ssize_t",
          "2398:     i;",
          "2400:   size_t",
          "2401:     h,",
          "2402:     w;",
          "2405:     Only skip mipmaps for textures and cube maps",
          "2407:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2408:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2409:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2410:     {",
          "2411:       w = DIV2(dds_info->width);",
          "2412:       h = DIV2(dds_info->height);",
          "2415:         Mipmapcount includes the main image, so start from one",
          "2417:       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2418:       {",
          "2419:         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;",
          "2420:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2422:         w = DIV2(w);",
          "2423:         h = DIV2(h);",
          "2424:       }",
          "2425:     }",
          "2426: }",
          "2429:   Skip the mipmap images for uncompressed (RGB or RGBA) dds files",
          "2431: static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)",
          "2432: {",
          "2433:   MagickOffsetType",
          "2434:     offset;",
          "2436:   register ssize_t",
          "2437:     i;",
          "2439:   size_t",
          "2440:     h,",
          "2441:     w;",
          "2444:     Only skip mipmaps for textures and cube maps",
          "2446:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2447:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2448:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2449:     {",
          "2450:       w = DIV2(dds_info->width);",
          "2451:       h = DIV2(dds_info->height);",
          "2454:         Mipmapcount includes the main image, so start from one",
          "2456:       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2457:       {",
          "2458:         offset = (MagickOffsetType) w * h * pixel_size;",
          "2459:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2461:         w = DIV2(w);",
          "2462:         h = DIV2(h);",
          "2463:       }",
          "2464:     }",
          "2465: }",
          "2469: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2470: %                                                                             %",
          "2471: %                                                                             %",
          "2472: %                                                                             %",
          "2473: %   U n r e g i s t e r D D S I m a g e                                       %",
          "2474: %                                                                             %",
          "2475: %                                                                             %",
          "2476: %                                                                             %",
          "2477: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2478: %",
          "2479: %  UnregisterDDSImage() removes format registrations made by the",
          "2480: %  DDS module from the list of supported formats.",
          "2481: %",
          "2482: %  The format of the UnregisterDDSImage method is:",
          "2483: %",
          "2484: %      UnregisterDDSImage(void)",
          "2485: %",
          "2487: ModuleExport void UnregisterDDSImage(void)",
          "2488: {",
          "2489:   (void) UnregisterMagickInfo(\"DDS\");",
          "2490:   (void) UnregisterMagickInfo(\"DXT1\");",
          "2491:   (void) UnregisterMagickInfo(\"DXT5\");",
          "2492: }",
          "2494: static void WriteAlphas(Image *image, const ssize_t *alphas, size_t min5,",
          "2495:   size_t max5, size_t min7, size_t max7)",
          "2496: {",
          "2497:   register ssize_t",
          "2498:     i;",
          "2500:   size_t",
          "2501:     err5,",
          "2502:     err7,",
          "2503:     j;",
          "2505:   unsigned char",
          "2506:     indices5[16],",
          "2507:     indices7[16];",
          "2509:   FixRange(min5,max5,5);",
          "2510:   err5 = CompressAlpha(min5,max5,5,alphas,indices5);",
          "2512:   FixRange(min7,max7,7);",
          "2513:   err7 = CompressAlpha(min7,max7,7,alphas,indices7);",
          "2515:   if (err7 < err5)",
          "2516:   {",
          "2517:     for (i=0; i < 16; i++)",
          "2518:     {",
          "2519:       unsigned char",
          "2520:         index;",
          "2522:       index = indices7[i];",
          "2523:       if( index == 0 )",
          "2524:         indices5[i] = 1;",
          "2525:       else if (index == 1)",
          "2526:         indices5[i] = 0;",
          "2527:       else",
          "2528:         indices5[i] = 9 - index;",
          "2529:     }",
          "2531:     min5 = max7;",
          "2532:     max5 = min7;",
          "2533:   }",
          "2535:   (void) WriteBlobByte(image,(unsigned char) min5);",
          "2536:   (void) WriteBlobByte(image,(unsigned char) max5);",
          "2538:   for(i=0; i < 2; i++)",
          "2539:   {",
          "2540:     size_t",
          "2541:       value = 0;",
          "2543:     for (j=0; j < 8; j++)",
          "2544:     {",
          "2545:       size_t index = (size_t) indices5[j + i*8];",
          "2546:       value |= ( index << 3*j );",
          "2547:     }",
          "2549:     for (j=0; j < 3; j++)",
          "2550:     {",
          "2551:       size_t byte = (value >> 8*j) & 0xff;",
          "2552:       (void) WriteBlobByte(image,(unsigned char) byte);",
          "2553:     }",
          "2554:   }",
          "2555: }",
          "2557: static void WriteCompressed(Image *image, const size_t count,",
          "2558:   DDSVector4 *points, const ssize_t *map, const MagickBooleanType clusterFit)",
          "2559: {",
          "2560:   float",
          "2561:     covariance[16];",
          "2563:   DDSVector3",
          "2564:     end,",
          "2565:     principle,",
          "2566:     start;",
          "2568:   DDSVector4",
          "2569:     metric;",
          "2571:   unsigned char",
          "2572:     indices[16];",
          "2574:   VectorInit(metric,1.0f);",
          "2575:   VectorInit3(start,0.0f);",
          "2576:   VectorInit3(end,0.0f);",
          "2578:   ComputeWeightedCovariance(count,points,covariance);",
          "2579:   ComputePrincipleComponent(covariance,&principle);",
          "2581:   if (clusterFit == MagickFalse || count == 0)",
          "2582:     CompressRangeFit(count,points,map,principle,metric,&start,&end,indices);",
          "2583:   else",
          "2584:     CompressClusterFit(count,points,map,principle,metric,&start,&end,indices);",
          "2586:   WriteIndices(image,start,end,indices);",
          "2587: }",
          "2590: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2591: %                                                                             %",
          "2592: %                                                                             %",
          "2593: %                                                                             %",
          "2594: %   W r i t e D D S I m a g e                                                 %",
          "2595: %                                                                             %",
          "2596: %                                                                             %",
          "2597: %                                                                             %",
          "2598: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2599: %",
          "2600: %  WriteDDSImage() writes a DirectDraw Surface image file in the DXT5 format.",
          "2601: %",
          "2602: %  The format of the WriteBMPImage method is:",
          "2603: %",
          "2604: %     MagickBooleanType WriteDDSImage(const ImageInfo *image_info,Image *image)",
          "2605: %",
          "2606: %  A description of each parameter follows.",
          "2607: %",
          "2608: %    o image_info: the image info.",
          "2609: %",
          "2610: %    o image:  The image.",
          "2611: %",
          "2613: static MagickBooleanType WriteDDSImage(const ImageInfo *image_info,",
          "2614:   Image *image, ExceptionInfo *exception)",
          "2615: {",
          "2616:   const char",
          "2619:   size_t",
          "2620:     compression,",
          "2621:     columns,",
          "2622:     maxMipmaps,",
          "2623:     mipmaps,",
          "2624:     pixelFormat,",
          "2625:     rows;",
          "2627:   MagickBooleanType",
          "2628:     clusterFit,",
          "2629:     status,",
          "2630:     weightByAlpha;",
          "2632:   assert(image_info != (const ImageInfo *) NULL);",
          "2633:   assert(image_info->signature == MagickSignature);",
          "2634:   assert(image != (Image *) NULL);",
          "2635:   assert(image->signature == MagickSignature);",
          "2636:   if (image->debug != MagickFalse)",
          "2637:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);",
          "2638:   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);",
          "2639:   if (status == MagickFalse)",
          "2640:     return(status);",
          "2641:   (void) TransformImageColorspace(image,sRGBColorspace,exception);",
          "2642:   pixelFormat=DDPF_FOURCC;",
          "2643:   compression=FOURCC_DXT5;",
          "2645:   if (image->alpha_trait != BlendPixelTrait)",
          "2646:     compression=FOURCC_DXT1;",
          "2648:   if (LocaleCompare(image_info->magick,\"dxt1\") == 0)",
          "2649:     compression=FOURCC_DXT1;",
          "2651:   option=GetImageOption(image_info,\"dds:compression\");",
          "2652:   if (option != (char *) NULL)",
          "2653:     {",
          "2654:        if (LocaleCompare(option,\"dxt1\") == 0)",
          "2655:          compression=FOURCC_DXT1;",
          "2656:        if (LocaleCompare(option,\"none\") == 0)",
          "2657:          pixelFormat=DDPF_RGB;",
          "2658:     }",
          "2660:   clusterFit=MagickFalse;",
          "2661:   weightByAlpha=MagickFalse;",
          "2663:   if (pixelFormat == DDPF_FOURCC)",
          "2664:     {",
          "2665:       option=GetImageOption(image_info,\"dds:cluster-fit\");",
          "2666:       if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2667:         {",
          "2668:           clusterFit=MagickTrue;",
          "2669:           if (compression != FOURCC_DXT1)",
          "2670:             {",
          "2671:               option=GetImageOption(image_info,\"dds:weight-by-alpha\");",
          "2672:               if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2673:                 weightByAlpha=MagickTrue;",
          "2674:             }",
          "2675:         }",
          "2676:     }",
          "2678:   maxMipmaps=SIZE_MAX;",
          "2679:   mipmaps=0;",
          "2680:   if ((image->columns & (image->columns - 1)) == 0 &&",
          "2681:       (image->rows & (image->rows - 1)) == 0)",
          "2682:     {",
          "2683:       option=GetImageOption(image_info,\"dds:mipmaps\");",
          "2684:       if (option != (char *) NULL)",
          "2685:         maxMipmaps=StringToUnsignedLong(option);",
          "2687:       if (maxMipmaps != 0)",
          "2688:         {",
          "2689:           columns=image->columns;",
          "2690:           rows=image->rows;",
          "2691:           while (columns != 1 && rows != 1 && mipmaps != maxMipmaps)",
          "2692:           {",
          "2693:             columns=DIV2(columns);",
          "2694:             rows=DIV2(rows);",
          "2695:             mipmaps++;",
          "2696:           }",
          "2697:         }",
          "2698:     }",
          "2700:   WriteDDSInfo(image,pixelFormat,compression,mipmaps);",
          "2702:   WriteImageData(image,pixelFormat,compression,clusterFit,weightByAlpha,",
          "2703:     exception);",
          "2705:   if (mipmaps > 0 && WriteMipmaps(image,pixelFormat,compression,mipmaps,",
          "2706:         clusterFit,weightByAlpha,exception) == MagickFalse)",
          "2707:     return(MagickFalse);",
          "2709:   (void) CloseBlob(image);",
          "2710:   return(MagickTrue);",
          "2711: }",
          "2713: static void WriteDDSInfo(Image *image, const size_t pixelFormat,",
          "2714:   const size_t compression, const size_t mipmaps)",
          "2715: {",
          "2716:   char",
          "2717:     software[MaxTextExtent];",
          "2719:   register ssize_t",
          "2720:     i;",
          "2722:   unsigned int",
          "2723:     format,",
          "2724:     caps,",
          "2725:     flags;",
          "2727:   flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |",
          "2728:     DDSD_PIXELFORMAT | DDSD_LINEARSIZE);",
          "2729:   caps=(unsigned int) DDSCAPS_TEXTURE;",
          "2730:   format=(unsigned int) pixelFormat;",
          "2732:   if (mipmaps > 0)",
          "2733:     {",
          "2734:       flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;",
          "2735:       caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);",
          "2736:     }",
          "2738:   if (format != DDPF_FOURCC && image->alpha_trait == BlendPixelTrait)",
          "2739:     format=format | DDPF_ALPHAPIXELS;",
          "2741:   (void) WriteBlob(image,4,(unsigned char *) \"DDS \");",
          "2742:   (void) WriteBlobLSBLong(image,124);",
          "2743:   (void) WriteBlobLSBLong(image,flags);",
          "2744:   (void) WriteBlobLSBLong(image,image->rows);",
          "2745:   (void) WriteBlobLSBLong(image,image->columns);",
          "2747:   if (compression == FOURCC_DXT1)",
          "2748:     (void) WriteBlobLSBLong(image,",
          "2749:              (unsigned int) (Max(1,(image->columns+3)/4) * 8));",
          "2750:   else",
          "2751:     (void) WriteBlobLSBLong(image,",
          "2752:              (unsigned int) (Max(1,(image->columns+3)/4) * 16));",
          "2754:   (void) WriteBlobLSBLong(image,0x00);",
          "2755:   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);",
          "2756:   (void) ResetMagickMemory(software,0,sizeof(software));",
          "2757:   (void) strcpy(software,\"IMAGEMAGICK\");",
          "2758:   (void) WriteBlob(image,44,(unsigned char *) software);",
          "2760:   (void) WriteBlobLSBLong(image,32);",
          "2761:   (void) WriteBlobLSBLong(image,format);",
          "2763:   if (pixelFormat == DDPF_FOURCC)",
          "2764:     {",
          "2765:       (void) WriteBlobLSBLong(image,(unsigned int) compression);",
          "2766:       for(i=0;i < 5;i++) // bitcount / masks",
          "2767:         (void) WriteBlobLSBLong(image,0x00);",
          "2768:     }",
          "2769:   else",
          "2770:     {",
          "2771:       (void) WriteBlobLSBLong(image,0x00);",
          "2772:       if (image->alpha_trait == BlendPixelTrait)",
          "2773:         {",
          "2774:           (void) WriteBlobLSBLong(image,32);",
          "2775:           (void) WriteBlobLSBLong(image,0xff0000);",
          "2776:           (void) WriteBlobLSBLong(image,0xff00);",
          "2777:           (void) WriteBlobLSBLong(image,0xff);",
          "2778:           (void) WriteBlobLSBLong(image,0xff000000);",
          "2779:         }",
          "2780:       else",
          "2781:         {",
          "2782:           (void) WriteBlobLSBLong(image,24);",
          "2783:           (void) WriteBlobLSBLong(image,0xff);",
          "2784:           (void) WriteBlobLSBLong(image,0x00);",
          "2785:           (void) WriteBlobLSBLong(image,0x00);",
          "2786:           (void) WriteBlobLSBLong(image,0x00);",
          "2787:         }",
          "2788:     }",
          "2790:   (void) WriteBlobLSBLong(image,caps);",
          "2791:   for(i=0;i < 4;i++) // ddscaps2 + reserved region",
          "2792:     (void) WriteBlobLSBLong(image,0x00);",
          "2793: }",
          "2795: static void WriteFourCC(Image *image, const size_t compression,",
          "2796:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "2797:   ExceptionInfo *exception)",
          "2798: {",
          "2799:   register ssize_t",
          "2800:     x;",
          "2802:   ssize_t",
          "2803:     i,",
          "2804:     y,",
          "2805:     bx,",
          "2806:     by;",
          "2808:   register const Quantum",
          "2811:   for (y=0; y < (ssize_t) image->rows; y+=4)",
          "2812:   {",
          "2813:     for (x=0; x < (ssize_t) image->columns; x+=4)",
          "2814:     {",
          "2815:       MagickBooleanType",
          "2816:         match;",
          "2818:       DDSVector4",
          "2819:         point,",
          "2820:         points[16];",
          "2822:       size_t",
          "2823:         count = 0,",
          "2824:         max5 = 0,",
          "2825:         max7 = 0,",
          "2826:         min5 = 255,",
          "2827:         min7 = 255,",
          "2828:         columns = 4,",
          "2829:         rows = 4;",
          "2831:       ssize_t",
          "2832:         alphas[16],",
          "2833:         map[16];",
          "2835:       unsigned char",
          "2836:         alpha;",
          "2838:       if (x + columns >= image->columns)",
          "2839:         columns = image->columns - x;",
          "2841:       if (y + rows >= image->rows)",
          "2842:         rows = image->rows - y;",
          "2844:       p=GetVirtualPixels(image,x,y,columns,rows,exception);",
          "2845:       if (p == (const Quantum *) NULL)",
          "2846:         break;",
          "2848:       for (i=0; i<16; i++)",
          "2849:       {",
          "2850:         map[i] = -1;",
          "2851:         alphas[i] = -1;",
          "2852:       }",
          "2854:       for (by=0; by <  (ssize_t) rows; by++)",
          "2855:       {",
          "2856:         for (bx=0; bx <  (ssize_t) columns; bx++)",
          "2857:         {",
          "2858:           if (compression == FOURCC_DXT5)",
          "2859:             alpha = ScaleQuantumToChar(GetPixelAlpha(image,p));",
          "2860:           else",
          "2861:             alpha = 255;",
          "2863:           alphas[4*by + bx] = (size_t)alpha;",
          "2865:           point.x = (float)ScaleQuantumToChar(GetPixelRed(image,p)) / 255.0f;",
          "2866:           point.y = (float)ScaleQuantumToChar(GetPixelGreen(image,p)) / 255.0f;",
          "2867:           point.z = (float)ScaleQuantumToChar(GetPixelBlue(image,p)) / 255.0f;",
          "2868:           point.w = weightByAlpha ? (float)(alpha + 1) / 256.0f : 1.0f;",
          "2869:           p+=GetPixelChannels(image);",
          "2871:           match = MagickFalse;",
          "2872:           for (i=0; i <  (ssize_t) count; i++)",
          "2873:           {",
          "2874:             if ((points[i].x == point.x) &&",
          "2875:                 (points[i].y == point.y) &&",
          "2876:                 (points[i].z == point.z) &&",
          "2877:                 (alpha       >= 128 || compression == FOURCC_DXT5))",
          "2878:               {",
          "2879:                 points[i].w += point.w;",
          "2880:                 map[4*by + bx] = i;",
          "2881:                 match = MagickTrue;",
          "2882:                 break;",
          "2883:               }",
          "2884:             }",
          "2886:             if (match != MagickFalse)",
          "2887:               continue;",
          "2889:             points[count].x = point.x;",
          "2890:             points[count].y = point.y;",
          "2891:             points[count].z = point.z;",
          "2892:             points[count].w = point.w;",
          "2893:             map[4*by + bx] = count;",
          "2894:             count++;",
          "2896:             if (compression == FOURCC_DXT5)",
          "2897:               {",
          "2898:                 if (alpha < min7)",
          "2899:                   min7 = alpha;",
          "2900:                 if (alpha > max7)",
          "2901:                   max7 = alpha;",
          "2902:                 if (alpha != 0 && alpha < min5)",
          "2903:                   min5 = alpha;",
          "2904:                 if (alpha != 255 && alpha > max5)",
          "2905:                   max5 = alpha;",
          "2908:         }",
          "2910:       for (i=0; i <  (ssize_t) count; i++)",
          "2911:         points[i].w = sqrt(points[i].w);",
          "2913:       if (compression == FOURCC_DXT5)",
          "2914:         WriteAlphas(image,alphas,min5,max5,min7,max7);",
          "2916:       if (count == 1)",
          "2917:         WriteSingleColorFit(image,points,map);",
          "2918:       else",
          "2919:         WriteCompressed(image,count,points,map,clusterFit);",
          "2920:     }",
          "2921:   }",
          "2922: }",
          "2924: static void WriteImageData(Image *image, const size_t pixelFormat,",
          "2925:   const size_t compression,const MagickBooleanType clusterFit,",
          "2926:   const MagickBooleanType weightByAlpha, ExceptionInfo *exception)",
          "2927: {",
          "2928:   if (pixelFormat == DDPF_FOURCC)",
          "2929:     WriteFourCC(image,compression,clusterFit,weightByAlpha,exception);",
          "2930:   else",
          "2931:     WriteUncompressed(image,exception);",
          "2932: }",
          "2934: static inline size_t ClampToLimit(const float value, const size_t limit)",
          "2935: {",
          "2936:   size_t",
          "2937:     result = (int) (value + 0.5f);",
          "2939:   if (result < 0.0f)",
          "2940:     return(0);",
          "2941:   if (result > limit)",
          "2942:     return(limit);",
          "2943:   return result;",
          "2944: }",
          "2946: static inline size_t ColorTo565(const DDSVector3 point)",
          "2947: {",
          "2948:   size_t r = ClampToLimit(31.0f*point.x,31);",
          "2949:   size_t g = ClampToLimit(63.0f*point.y,63);",
          "2950:   size_t b = ClampToLimit(31.0f*point.z,31);",
          "2952:   return (r << 11) | (g << 5) | b;",
          "2953: }",
          "2955: static void WriteIndices(Image *image, const DDSVector3 start,",
          "2956:   const DDSVector3 end, unsigned char *indices)",
          "2957: {",
          "2958:   register ssize_t",
          "2959:     i;",
          "2961:   size_t",
          "2962:     a,",
          "2963:     b;",
          "2965:   unsigned char",
          "2966:     remapped[16];",
          "2968:   const unsigned char",
          "2971:   a = ColorTo565(start);",
          "2972:   b = ColorTo565(end);",
          "2974:   for (i=0; i<16; i++)",
          "2975:   {",
          "2976:     if( a < b )",
          "2977:       remapped[i] = (indices[i] ^ 0x1) & 0x3;",
          "2978:     else if( a == b )",
          "2979:       remapped[i] = 0;",
          "2980:     else",
          "2981:       remapped[i] = indices[i];",
          "2982:   }",
          "2984:   if( a < b )",
          "2985:     Swap(a,b);",
          "2987:   (void) WriteBlobByte(image,(unsigned char) (a & 0xff));",
          "2988:   (void) WriteBlobByte(image,(unsigned char) (a >> 8));",
          "2989:   (void) WriteBlobByte(image,(unsigned char) (b & 0xff));",
          "2990:   (void) WriteBlobByte(image,(unsigned char) (b >> 8));",
          "2992:   for (i=0; i<4; i++)",
          "2993:   {",
          "2994:      ind = remapped + 4*i;",
          "2995:      (void) WriteBlobByte(image,ind[0] | (ind[1] << 2) | (ind[2] << 4) |",
          "2996:        (ind[3] << 6));",
          "2997:   }",
          "2998: }",
          "3000: static MagickBooleanType WriteMipmaps(Image *image, const size_t pixelFormat,",
          "3001:   const size_t compression, const size_t mipmaps,",
          "3002:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "3003:   ExceptionInfo *exception)",
          "3004: {",
          "3005:   Image*",
          "3006:     resize_image;",
          "3008:   register ssize_t",
          "3009:     i;",
          "3011:   size_t",
          "3012:     columns,",
          "3013:     rows;",
          "3015:   columns = image->columns;",
          "3016:   rows = image->rows;",
          "3018:   for (i=0; i< (ssize_t) mipmaps; i++)",
          "3019:   {",
          "3020:     resize_image = ResizeImage(image,columns/2,rows/2,TriangleFilter,",
          "3021:       exception);",
          "3023:     if (resize_image == (Image *) NULL)",
          "3024:       return(MagickFalse);",
          "3026:     DestroyBlob(resize_image);",
          "3027:     resize_image->blob=ReferenceBlob(image->blob);",
          "3029:     WriteImageData(resize_image,pixelFormat,compression,weightByAlpha,",
          "3030:       clusterFit,exception);",
          "3032:     resize_image=DestroyImage(resize_image);",
          "3034:     columns = DIV2(columns);",
          "3035:     rows = DIV2(rows);",
          "3036:   }",
          "3038:   return(MagickTrue);",
          "3039: }",
          "3041: static void WriteSingleColorFit(Image *image, const DDSVector4 *points,",
          "3042:   const ssize_t *map)",
          "3043: {",
          "3044:   DDSVector3",
          "3045:     start,",
          "3046:     end;",
          "3048:   register ssize_t",
          "3049:     i;",
          "3051:   unsigned char",
          "3052:     color[3],",
          "3053:     index,",
          "3054:     indexes[16],",
          "3055:     indices[16];",
          "3057:   color[0] = (unsigned char) ClampToLimit(255.0f*points->x,255);",
          "3058:   color[1] = (unsigned char) ClampToLimit(255.0f*points->y,255);",
          "3059:   color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);",
          "3061:   index=0;",
          "3062:   ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);",
          "3064:   for (i=0; i< 16; i++)",
          "3065:     indexes[i]=index;",
          "3066:   RemapIndices(map,indexes,indices);",
          "3067:   WriteIndices(image,start,end,indices);",
          "3068: }",
          "3070: static void WriteUncompressed(Image *image, ExceptionInfo *exception)",
          "3071: {",
          "3072:   register const Quantum",
          "3075:   register ssize_t",
          "3076:     x;",
          "3078:   ssize_t",
          "3079:     y;",
          "3081:   for (y=0; y < (ssize_t) image->rows; y++)",
          "3082:   {",
          "3083:     p=GetVirtualPixels(image,0,y,image->columns,1,exception);",
          "3084:     if (p == (const Quantum *) NULL)",
          "3085:       break;",
          "3087:     for (x=0; x < (ssize_t) image->columns; x++)",
          "3088:     {",
          "3089:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(image,p)));",
          "3090:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(image,p)));",
          "3091:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(image,p)));",
          "3092:       if (image->alpha_trait == BlendPixelTrait)",
          "3093:         (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));",
          "3094:       p+=GetPixelChannels(image);",
          "3095:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8692172297647753b19567a180d52a6415193e3d",
      "candidate_info": {
        "commit_hash": "8692172297647753b19567a180d52a6415193e3d",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/8692172297647753b19567a180d52a6415193e3d",
        "files": [
          "coders/dds.c"
        ],
        "message": "Newlines...",
        "before_after_code_files": [
          "coders/dds.c||coders/dds.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/dds.c||coders/dds.c"
          ],
          "candidate": [
            "coders/dds.c||coders/dds.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/dds.c||coders/dds.c": [
          "File: coders/dds.c -> coders/dds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "2: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "3: %                                                                             %",
          "4: %                                                                             %",
          "5: %                                                                             %",
          "6: %                            DDDD   DDDD   SSSSS                              %",
          "7: %                            D   D  D   D  SS                                 %",
          "8: %                            D   D  D   D   SSS                               %",
          "9: %                            D   D  D   D     SS                              %",
          "10: %                            DDDD   DDDD   SSSSS                              %",
          "11: %                                                                             %",
          "12: %                                                                             %",
          "13: %           Read/Write Microsoft Direct Draw Surface Image Format             %",
          "14: %                                                                             %",
          "15: %                              Software Design                                %",
          "16: %                             Bianca van Schaik                               %",
          "17: %                                March 2008                                   %",
          "18: %                               Dirk Lemstra                                  %",
          "19: %                              September 2013                                 %",
          "20: %                                                                             %",
          "21: %                                                                             %",
          "22: %  Copyright 1999-2014 ImageMagick Studio LLC, a non-profit organization      %",
          "23: %  dedicated to making software imaging solutions freely available.           %",
          "24: %                                                                             %",
          "25: %  You may not use this file except in compliance with the License.  You may  %",
          "26: %  obtain a copy of the License at                                            %",
          "27: %                                                                             %",
          "28: %    http://www.imagemagick.org/script/license.php                            %",
          "29: %                                                                             %",
          "30: %  Unless required by applicable law or agreed to in writing, software        %",
          "31: %  distributed under the License is distributed on an \"AS IS\" BASIS,          %",
          "32: %  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %",
          "33: %  See the License for the specific language governing permissions and        %",
          "34: %  limitations under the License.                                             %",
          "35: %                                                                             %",
          "36: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "37: %",
          "38: %",
          "43:   Include declarations.",
          "45: #include \"MagickCore/studio.h\"",
          "46: #include \"MagickCore/blob.h\"",
          "47: #include \"MagickCore/blob-private.h\"",
          "48: #include \"MagickCore/cache.h\"",
          "49: #include \"MagickCore/colorspace.h\"",
          "50: #include \"MagickCore/exception.h\"",
          "51: #include \"MagickCore/exception-private.h\"",
          "52: #include \"MagickCore/image.h\"",
          "53: #include \"MagickCore/image-private.h\"",
          "54: #include \"MagickCore/list.h\"",
          "55: #include \"MagickCore/log.h\"",
          "56: #include \"MagickCore/magick.h\"",
          "57: #include \"MagickCore/memory_.h\"",
          "58: #include \"MagickCore/monitor.h\"",
          "59: #include \"MagickCore/monitor-private.h\"",
          "60: #include \"MagickCore/profile.h\"",
          "61: #include \"MagickCore/quantum-private.h\"",
          "62: #include \"MagickCore/static.h\"",
          "63: #include \"MagickCore/string_.h\"",
          "64: #include \"MagickCore/module.h\"",
          "65: #include \"MagickCore/transform.h\"",
          "66: #include \"MagickCore/studio.h\"",
          "67: #include \"MagickCore/blob.h\"",
          "68: #include \"MagickCore/blob-private.h\"",
          "69: #include \"MagickCore/colorspace.h\"",
          "70: #include \"MagickCore/colorspace-private.h\"",
          "71: #include \"MagickCore/exception.h\"",
          "72: #include \"MagickCore/exception-private.h\"",
          "73: #include \"MagickCore/compress.h\"",
          "74: #include \"MagickCore/image.h\"",
          "75: #include \"MagickCore/image-private.h\"",
          "76: #include \"MagickCore/list.h\"",
          "77: #include \"MagickCore/magick.h\"",
          "78: #include \"MagickCore/memory_.h\"",
          "79: #include \"MagickCore/monitor.h\"",
          "80: #include \"MagickCore/monitor-private.h\"",
          "81: #include \"MagickCore/option.h\"",
          "82: #include \"MagickCore/pixel-accessor.h\"",
          "83: #include \"MagickCore/quantum.h\"",
          "84: #include \"MagickCore/static.h\"",
          "85: #include \"MagickCore/string_.h\"",
          "86: #include \"MagickCore/string-private.h\"",
          "90:   Definitions",
          "92: #define DDSD_CAPS         0x00000001",
          "93: #define DDSD_HEIGHT       0x00000002",
          "94: #define DDSD_WIDTH        0x00000004",
          "95: #define DDSD_PITCH        0x00000008",
          "96: #define DDSD_PIXELFORMAT  0x00001000",
          "97: #define DDSD_MIPMAPCOUNT  0x00020000",
          "98: #define DDSD_LINEARSIZE   0x00080000",
          "99: #define DDSD_DEPTH        0x00800000",
          "101: #define DDPF_ALPHAPIXELS  0x00000001",
          "102: #define DDPF_FOURCC       0x00000004",
          "103: #define DDPF_RGB          0x00000040",
          "105: #define FOURCC_DXT1       0x31545844",
          "106: #define FOURCC_DXT3       0x33545844",
          "107: #define FOURCC_DXT5       0x35545844",
          "109: #define DDSCAPS_COMPLEX   0x00000008",
          "110: #define DDSCAPS_TEXTURE   0x00001000",
          "111: #define DDSCAPS_MIPMAP    0x00400000",
          "113: #define DDSCAPS2_CUBEMAP  0x00000200",
          "114: #define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400",
          "115: #define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800",
          "116: #define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000",
          "117: #define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000",
          "118: #define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000",
          "119: #define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000",
          "120: #define DDSCAPS2_VOLUME   0x00200000",
          "122: #ifndef SIZE_MAX",
          "123: #define SIZE_MAX ((size_t) -1)",
          "124: #endif",
          "127:   Structure declarations.",
          "129: typedef struct _DDSPixelFormat",
          "130: {",
          "131:   size_t",
          "132:     flags,",
          "133:     fourcc,",
          "134:     rgb_bitcount,",
          "135:     r_bitmask,",
          "136:     g_bitmask,",
          "137:     b_bitmask,",
          "138:     alpha_bitmask;",
          "139: } DDSPixelFormat;",
          "141: typedef struct _DDSInfo",
          "142: {",
          "143:   size_t",
          "144:     flags,",
          "145:     height,",
          "146:     width,",
          "147:     pitchOrLinearSize,",
          "148:     depth,",
          "149:     mipmapcount,",
          "150:     ddscaps1,",
          "151:     ddscaps2;",
          "153:   DDSPixelFormat",
          "154:     pixelformat;",
          "155: } DDSInfo;",
          "157: typedef struct _DDSColors",
          "158: {",
          "159:   unsigned char",
          "160:     r[4],",
          "161:     g[4],",
          "162:     b[4],",
          "163:     a[4];",
          "164: } DDSColors;",
          "166: typedef struct _DDSVector4",
          "167: {",
          "168:   float",
          "169:     x,",
          "170:     y,",
          "171:     z,",
          "172:     w;",
          "173: } DDSVector4;",
          "175: typedef struct _DDSVector3",
          "176: {",
          "177:   float",
          "178:     x,",
          "179:     y,",
          "180:     z;",
          "181: } DDSVector3;",
          "183: typedef struct _DDSSourceBlock",
          "184: {",
          "185:   unsigned char",
          "186:     start,",
          "187:     end,",
          "188:     error;",
          "189: } DDSSourceBlock;",
          "191: typedef struct _DDSSingleColourLookup",
          "192: {",
          "193:   DDSSourceBlock sources[2];",
          "194: } DDSSingleColourLookup;",
          "196: typedef MagickBooleanType",
          "197:   DDSDecoder(Image *, DDSInfo *, ExceptionInfo *);",
          "199: static const DDSSingleColourLookup DDSLookup_5_4[] =",
          "200: {",
          "201:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "202:   { { { 0, 0, 1 }, { 0, 1, 1 } } },",
          "203:   { { { 0, 0, 2 }, { 0, 1, 0 } } },",
          "204:   { { { 0, 0, 3 }, { 0, 1, 1 } } },",
          "205:   { { { 0, 0, 4 }, { 0, 2, 1 } } },",
          "206:   { { { 1, 0, 3 }, { 0, 2, 0 } } },",
          "207:   { { { 1, 0, 2 }, { 0, 2, 1 } } },",
          "208:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "209:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "210:   { { { 1, 0, 1 }, { 1, 2, 1 } } },",
          "211:   { { { 1, 0, 2 }, { 1, 2, 0 } } },",
          "212:   { { { 1, 0, 3 }, { 0, 4, 0 } } },",
          "213:   { { { 1, 0, 4 }, { 0, 5, 1 } } },",
          "214:   { { { 2, 0, 3 }, { 0, 5, 0 } } },",
          "215:   { { { 2, 0, 2 }, { 0, 5, 1 } } },",
          "216:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "217:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "218:   { { { 2, 0, 1 }, { 2, 3, 1 } } },",
          "219:   { { { 2, 0, 2 }, { 2, 3, 0 } } },",
          "220:   { { { 2, 0, 3 }, { 0, 7, 0 } } },",
          "221:   { { { 2, 0, 4 }, { 1, 6, 1 } } },",
          "222:   { { { 3, 0, 3 }, { 1, 6, 0 } } },",
          "223:   { { { 3, 0, 2 }, { 0, 8, 0 } } },",
          "224:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "225:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "226:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "227:   { { { 3, 0, 2 }, { 0, 10, 1 } } },",
          "228:   { { { 3, 0, 3 }, { 0, 10, 0 } } },",
          "229:   { { { 3, 0, 4 }, { 2, 7, 1 } } },",
          "230:   { { { 4, 0, 4 }, { 2, 7, 0 } } },",
          "231:   { { { 4, 0, 3 }, { 0, 11, 0 } } },",
          "232:   { { { 4, 0, 2 }, { 1, 10, 1 } } },",
          "233:   { { { 4, 0, 1 }, { 1, 10, 0 } } },",
          "234:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "235:   { { { 4, 0, 1 }, { 0, 13, 1 } } },",
          "236:   { { { 4, 0, 2 }, { 0, 13, 0 } } },",
          "237:   { { { 4, 0, 3 }, { 0, 13, 1 } } },",
          "238:   { { { 4, 0, 4 }, { 0, 14, 1 } } },",
          "239:   { { { 5, 0, 3 }, { 0, 14, 0 } } },",
          "240:   { { { 5, 0, 2 }, { 2, 11, 1 } } },",
          "241:   { { { 5, 0, 1 }, { 2, 11, 0 } } },",
          "242:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "243:   { { { 5, 0, 1 }, { 1, 14, 1 } } },",
          "244:   { { { 5, 0, 2 }, { 1, 14, 0 } } },",
          "245:   { { { 5, 0, 3 }, { 0, 16, 0 } } },",
          "246:   { { { 5, 0, 4 }, { 0, 17, 1 } } },",
          "247:   { { { 6, 0, 3 }, { 0, 17, 0 } } },",
          "248:   { { { 6, 0, 2 }, { 0, 17, 1 } } },",
          "249:   { { { 6, 0, 1 }, { 0, 18, 1 } } },",
          "250:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "251:   { { { 6, 0, 1 }, { 2, 15, 1 } } },",
          "252:   { { { 6, 0, 2 }, { 2, 15, 0 } } },",
          "253:   { { { 6, 0, 3 }, { 0, 19, 0 } } },",
          "254:   { { { 6, 0, 4 }, { 1, 18, 1 } } },",
          "255:   { { { 7, 0, 3 }, { 1, 18, 0 } } },",
          "256:   { { { 7, 0, 2 }, { 0, 20, 0 } } },",
          "257:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "258:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "259:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "260:   { { { 7, 0, 2 }, { 0, 22, 1 } } },",
          "261:   { { { 7, 0, 3 }, { 0, 22, 0 } } },",
          "262:   { { { 7, 0, 4 }, { 2, 19, 1 } } },",
          "263:   { { { 8, 0, 4 }, { 2, 19, 0 } } },",
          "264:   { { { 8, 0, 3 }, { 0, 23, 0 } } },",
          "265:   { { { 8, 0, 2 }, { 1, 22, 1 } } },",
          "266:   { { { 8, 0, 1 }, { 1, 22, 0 } } },",
          "267:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "268:   { { { 8, 0, 1 }, { 0, 25, 1 } } },",
          "269:   { { { 8, 0, 2 }, { 0, 25, 0 } } },",
          "270:   { { { 8, 0, 3 }, { 0, 25, 1 } } },",
          "271:   { { { 8, 0, 4 }, { 0, 26, 1 } } },",
          "272:   { { { 9, 0, 3 }, { 0, 26, 0 } } },",
          "273:   { { { 9, 0, 2 }, { 2, 23, 1 } } },",
          "274:   { { { 9, 0, 1 }, { 2, 23, 0 } } },",
          "275:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "276:   { { { 9, 0, 1 }, { 1, 26, 1 } } },",
          "277:   { { { 9, 0, 2 }, { 1, 26, 0 } } },",
          "278:   { { { 9, 0, 3 }, { 0, 28, 0 } } },",
          "279:   { { { 9, 0, 4 }, { 0, 29, 1 } } },",
          "280:   { { { 10, 0, 3 }, { 0, 29, 0 } } },",
          "281:   { { { 10, 0, 2 }, { 0, 29, 1 } } },",
          "282:   { { { 10, 0, 1 }, { 0, 30, 1 } } },",
          "283:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "284:   { { { 10, 0, 1 }, { 2, 27, 1 } } },",
          "285:   { { { 10, 0, 2 }, { 2, 27, 0 } } },",
          "286:   { { { 10, 0, 3 }, { 0, 31, 0 } } },",
          "287:   { { { 10, 0, 4 }, { 1, 30, 1 } } },",
          "288:   { { { 11, 0, 3 }, { 1, 30, 0 } } },",
          "289:   { { { 11, 0, 2 }, { 4, 24, 0 } } },",
          "290:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "291:   { { { 11, 0, 0 }, { 1, 31, 0 } } },",
          "292:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "293:   { { { 11, 0, 2 }, { 2, 30, 1 } } },",
          "294:   { { { 11, 0, 3 }, { 2, 30, 0 } } },",
          "295:   { { { 11, 0, 4 }, { 2, 31, 1 } } },",
          "296:   { { { 12, 0, 4 }, { 2, 31, 0 } } },",
          "297:   { { { 12, 0, 3 }, { 4, 27, 0 } } },",
          "298:   { { { 12, 0, 2 }, { 3, 30, 1 } } },",
          "299:   { { { 12, 0, 1 }, { 3, 30, 0 } } },",
          "300:   { { { 12, 0, 0 }, { 4, 28, 0 } } },",
          "301:   { { { 12, 0, 1 }, { 3, 31, 1 } } },",
          "302:   { { { 12, 0, 2 }, { 3, 31, 0 } } },",
          "303:   { { { 12, 0, 3 }, { 3, 31, 1 } } },",
          "304:   { { { 12, 0, 4 }, { 4, 30, 1 } } },",
          "305:   { { { 13, 0, 3 }, { 4, 30, 0 } } },",
          "306:   { { { 13, 0, 2 }, { 6, 27, 1 } } },",
          "307:   { { { 13, 0, 1 }, { 6, 27, 0 } } },",
          "308:   { { { 13, 0, 0 }, { 4, 31, 0 } } },",
          "309:   { { { 13, 0, 1 }, { 5, 30, 1 } } },",
          "310:   { { { 13, 0, 2 }, { 5, 30, 0 } } },",
          "311:   { { { 13, 0, 3 }, { 8, 24, 0 } } },",
          "312:   { { { 13, 0, 4 }, { 5, 31, 1 } } },",
          "313:   { { { 14, 0, 3 }, { 5, 31, 0 } } },",
          "314:   { { { 14, 0, 2 }, { 5, 31, 1 } } },",
          "315:   { { { 14, 0, 1 }, { 6, 30, 1 } } },",
          "316:   { { { 14, 0, 0 }, { 6, 30, 0 } } },",
          "317:   { { { 14, 0, 1 }, { 6, 31, 1 } } },",
          "318:   { { { 14, 0, 2 }, { 6, 31, 0 } } },",
          "319:   { { { 14, 0, 3 }, { 8, 27, 0 } } },",
          "320:   { { { 14, 0, 4 }, { 7, 30, 1 } } },",
          "321:   { { { 15, 0, 3 }, { 7, 30, 0 } } },",
          "322:   { { { 15, 0, 2 }, { 8, 28, 0 } } },",
          "323:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "324:   { { { 15, 0, 0 }, { 7, 31, 0 } } },",
          "325:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "326:   { { { 15, 0, 2 }, { 8, 30, 1 } } },",
          "327:   { { { 15, 0, 3 }, { 8, 30, 0 } } },",
          "328:   { { { 15, 0, 4 }, { 10, 27, 1 } } },",
          "329:   { { { 16, 0, 4 }, { 10, 27, 0 } } },",
          "330:   { { { 16, 0, 3 }, { 8, 31, 0 } } },",
          "331:   { { { 16, 0, 2 }, { 9, 30, 1 } } },",
          "332:   { { { 16, 0, 1 }, { 9, 30, 0 } } },",
          "333:   { { { 16, 0, 0 }, { 12, 24, 0 } } },",
          "334:   { { { 16, 0, 1 }, { 9, 31, 1 } } },",
          "335:   { { { 16, 0, 2 }, { 9, 31, 0 } } },",
          "336:   { { { 16, 0, 3 }, { 9, 31, 1 } } },",
          "337:   { { { 16, 0, 4 }, { 10, 30, 1 } } },",
          "338:   { { { 17, 0, 3 }, { 10, 30, 0 } } },",
          "339:   { { { 17, 0, 2 }, { 10, 31, 1 } } },",
          "340:   { { { 17, 0, 1 }, { 10, 31, 0 } } },",
          "341:   { { { 17, 0, 0 }, { 12, 27, 0 } } },",
          "342:   { { { 17, 0, 1 }, { 11, 30, 1 } } },",
          "343:   { { { 17, 0, 2 }, { 11, 30, 0 } } },",
          "344:   { { { 17, 0, 3 }, { 12, 28, 0 } } },",
          "345:   { { { 17, 0, 4 }, { 11, 31, 1 } } },",
          "346:   { { { 18, 0, 3 }, { 11, 31, 0 } } },",
          "347:   { { { 18, 0, 2 }, { 11, 31, 1 } } },",
          "348:   { { { 18, 0, 1 }, { 12, 30, 1 } } },",
          "349:   { { { 18, 0, 0 }, { 12, 30, 0 } } },",
          "350:   { { { 18, 0, 1 }, { 14, 27, 1 } } },",
          "351:   { { { 18, 0, 2 }, { 14, 27, 0 } } },",
          "352:   { { { 18, 0, 3 }, { 12, 31, 0 } } },",
          "353:   { { { 18, 0, 4 }, { 13, 30, 1 } } },",
          "354:   { { { 19, 0, 3 }, { 13, 30, 0 } } },",
          "355:   { { { 19, 0, 2 }, { 16, 24, 0 } } },",
          "356:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "357:   { { { 19, 0, 0 }, { 13, 31, 0 } } },",
          "358:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "359:   { { { 19, 0, 2 }, { 14, 30, 1 } } },",
          "360:   { { { 19, 0, 3 }, { 14, 30, 0 } } },",
          "361:   { { { 19, 0, 4 }, { 14, 31, 1 } } },",
          "362:   { { { 20, 0, 4 }, { 14, 31, 0 } } },",
          "363:   { { { 20, 0, 3 }, { 16, 27, 0 } } },",
          "364:   { { { 20, 0, 2 }, { 15, 30, 1 } } },",
          "365:   { { { 20, 0, 1 }, { 15, 30, 0 } } },",
          "366:   { { { 20, 0, 0 }, { 16, 28, 0 } } },",
          "367:   { { { 20, 0, 1 }, { 15, 31, 1 } } },",
          "368:   { { { 20, 0, 2 }, { 15, 31, 0 } } },",
          "369:   { { { 20, 0, 3 }, { 15, 31, 1 } } },",
          "370:   { { { 20, 0, 4 }, { 16, 30, 1 } } },",
          "371:   { { { 21, 0, 3 }, { 16, 30, 0 } } },",
          "372:   { { { 21, 0, 2 }, { 18, 27, 1 } } },",
          "373:   { { { 21, 0, 1 }, { 18, 27, 0 } } },",
          "374:   { { { 21, 0, 0 }, { 16, 31, 0 } } },",
          "375:   { { { 21, 0, 1 }, { 17, 30, 1 } } },",
          "376:   { { { 21, 0, 2 }, { 17, 30, 0 } } },",
          "377:   { { { 21, 0, 3 }, { 20, 24, 0 } } },",
          "378:   { { { 21, 0, 4 }, { 17, 31, 1 } } },",
          "379:   { { { 22, 0, 3 }, { 17, 31, 0 } } },",
          "380:   { { { 22, 0, 2 }, { 17, 31, 1 } } },",
          "381:   { { { 22, 0, 1 }, { 18, 30, 1 } } },",
          "382:   { { { 22, 0, 0 }, { 18, 30, 0 } } },",
          "383:   { { { 22, 0, 1 }, { 18, 31, 1 } } },",
          "384:   { { { 22, 0, 2 }, { 18, 31, 0 } } },",
          "385:   { { { 22, 0, 3 }, { 20, 27, 0 } } },",
          "386:   { { { 22, 0, 4 }, { 19, 30, 1 } } },",
          "387:   { { { 23, 0, 3 }, { 19, 30, 0 } } },",
          "388:   { { { 23, 0, 2 }, { 20, 28, 0 } } },",
          "389:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "390:   { { { 23, 0, 0 }, { 19, 31, 0 } } },",
          "391:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "392:   { { { 23, 0, 2 }, { 20, 30, 1 } } },",
          "393:   { { { 23, 0, 3 }, { 20, 30, 0 } } },",
          "394:   { { { 23, 0, 4 }, { 22, 27, 1 } } },",
          "395:   { { { 24, 0, 4 }, { 22, 27, 0 } } },",
          "396:   { { { 24, 0, 3 }, { 20, 31, 0 } } },",
          "397:   { { { 24, 0, 2 }, { 21, 30, 1 } } },",
          "398:   { { { 24, 0, 1 }, { 21, 30, 0 } } },",
          "399:   { { { 24, 0, 0 }, { 24, 24, 0 } } },",
          "400:   { { { 24, 0, 1 }, { 21, 31, 1 } } },",
          "401:   { { { 24, 0, 2 }, { 21, 31, 0 } } },",
          "402:   { { { 24, 0, 3 }, { 21, 31, 1 } } },",
          "403:   { { { 24, 0, 4 }, { 22, 30, 1 } } },",
          "404:   { { { 25, 0, 3 }, { 22, 30, 0 } } },",
          "405:   { { { 25, 0, 2 }, { 22, 31, 1 } } },",
          "406:   { { { 25, 0, 1 }, { 22, 31, 0 } } },",
          "407:   { { { 25, 0, 0 }, { 24, 27, 0 } } },",
          "408:   { { { 25, 0, 1 }, { 23, 30, 1 } } },",
          "409:   { { { 25, 0, 2 }, { 23, 30, 0 } } },",
          "410:   { { { 25, 0, 3 }, { 24, 28, 0 } } },",
          "411:   { { { 25, 0, 4 }, { 23, 31, 1 } } },",
          "412:   { { { 26, 0, 3 }, { 23, 31, 0 } } },",
          "413:   { { { 26, 0, 2 }, { 23, 31, 1 } } },",
          "414:   { { { 26, 0, 1 }, { 24, 30, 1 } } },",
          "415:   { { { 26, 0, 0 }, { 24, 30, 0 } } },",
          "416:   { { { 26, 0, 1 }, { 26, 27, 1 } } },",
          "417:   { { { 26, 0, 2 }, { 26, 27, 0 } } },",
          "418:   { { { 26, 0, 3 }, { 24, 31, 0 } } },",
          "419:   { { { 26, 0, 4 }, { 25, 30, 1 } } },",
          "420:   { { { 27, 0, 3 }, { 25, 30, 0 } } },",
          "421:   { { { 27, 0, 2 }, { 28, 24, 0 } } },",
          "422:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "423:   { { { 27, 0, 0 }, { 25, 31, 0 } } },",
          "424:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "425:   { { { 27, 0, 2 }, { 26, 30, 1 } } },",
          "426:   { { { 27, 0, 3 }, { 26, 30, 0 } } },",
          "427:   { { { 27, 0, 4 }, { 26, 31, 1 } } },",
          "428:   { { { 28, 0, 4 }, { 26, 31, 0 } } },",
          "429:   { { { 28, 0, 3 }, { 28, 27, 0 } } },",
          "430:   { { { 28, 0, 2 }, { 27, 30, 1 } } },",
          "431:   { { { 28, 0, 1 }, { 27, 30, 0 } } },",
          "432:   { { { 28, 0, 0 }, { 28, 28, 0 } } },",
          "433:   { { { 28, 0, 1 }, { 27, 31, 1 } } },",
          "434:   { { { 28, 0, 2 }, { 27, 31, 0 } } },",
          "435:   { { { 28, 0, 3 }, { 27, 31, 1 } } },",
          "436:   { { { 28, 0, 4 }, { 28, 30, 1 } } },",
          "437:   { { { 29, 0, 3 }, { 28, 30, 0 } } },",
          "438:   { { { 29, 0, 2 }, { 30, 27, 1 } } },",
          "439:   { { { 29, 0, 1 }, { 30, 27, 0 } } },",
          "440:   { { { 29, 0, 0 }, { 28, 31, 0 } } },",
          "441:   { { { 29, 0, 1 }, { 29, 30, 1 } } },",
          "442:   { { { 29, 0, 2 }, { 29, 30, 0 } } },",
          "443:   { { { 29, 0, 3 }, { 29, 30, 1 } } },",
          "444:   { { { 29, 0, 4 }, { 29, 31, 1 } } },",
          "445:   { { { 30, 0, 3 }, { 29, 31, 0 } } },",
          "446:   { { { 30, 0, 2 }, { 29, 31, 1 } } },",
          "447:   { { { 30, 0, 1 }, { 30, 30, 1 } } },",
          "448:   { { { 30, 0, 0 }, { 30, 30, 0 } } },",
          "449:   { { { 30, 0, 1 }, { 30, 31, 1 } } },",
          "450:   { { { 30, 0, 2 }, { 30, 31, 0 } } },",
          "451:   { { { 30, 0, 3 }, { 30, 31, 1 } } },",
          "452:   { { { 30, 0, 4 }, { 31, 30, 1 } } },",
          "453:   { { { 31, 0, 3 }, { 31, 30, 0 } } },",
          "454:   { { { 31, 0, 2 }, { 31, 30, 1 } } },",
          "455:   { { { 31, 0, 1 }, { 31, 31, 1 } } },",
          "456:   { { { 31, 0, 0 }, { 31, 31, 0 } } }",
          "457: };",
          "459: static const DDSSingleColourLookup DDSLookup_6_4[] =",
          "460: {",
          "461:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "462:   { { { 0, 0, 1 }, { 0, 1, 0 } } },",
          "463:   { { { 0, 0, 2 }, { 0, 2, 0 } } },",
          "464:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "465:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "466:   { { { 1, 0, 1 }, { 0, 4, 0 } } },",
          "467:   { { { 1, 0, 2 }, { 0, 5, 0 } } },",
          "468:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "469:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "470:   { { { 2, 0, 1 }, { 0, 7, 0 } } },",
          "471:   { { { 2, 0, 2 }, { 0, 8, 0 } } },",
          "472:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "473:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "474:   { { { 3, 0, 1 }, { 0, 10, 0 } } },",
          "475:   { { { 3, 0, 2 }, { 0, 11, 0 } } },",
          "476:   { { { 4, 0, 1 }, { 0, 12, 1 } } },",
          "477:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "478:   { { { 4, 0, 1 }, { 0, 13, 0 } } },",
          "479:   { { { 4, 0, 2 }, { 0, 14, 0 } } },",
          "480:   { { { 5, 0, 1 }, { 0, 15, 1 } } },",
          "481:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "482:   { { { 5, 0, 1 }, { 0, 16, 0 } } },",
          "483:   { { { 5, 0, 2 }, { 1, 15, 0 } } },",
          "484:   { { { 6, 0, 1 }, { 0, 17, 0 } } },",
          "485:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "486:   { { { 6, 0, 1 }, { 0, 19, 0 } } },",
          "487:   { { { 6, 0, 2 }, { 3, 14, 0 } } },",
          "488:   { { { 7, 0, 1 }, { 0, 20, 0 } } },",
          "489:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "490:   { { { 7, 0, 1 }, { 0, 22, 0 } } },",
          "491:   { { { 7, 0, 2 }, { 4, 15, 0 } } },",
          "492:   { { { 8, 0, 1 }, { 0, 23, 0 } } },",
          "493:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "494:   { { { 8, 0, 1 }, { 0, 25, 0 } } },",
          "495:   { { { 8, 0, 2 }, { 6, 14, 0 } } },",
          "496:   { { { 9, 0, 1 }, { 0, 26, 0 } } },",
          "497:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "498:   { { { 9, 0, 1 }, { 0, 28, 0 } } },",
          "499:   { { { 9, 0, 2 }, { 7, 15, 0 } } },",
          "500:   { { { 10, 0, 1 }, { 0, 29, 0 } } },",
          "501:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "502:   { { { 10, 0, 1 }, { 0, 31, 0 } } },",
          "503:   { { { 10, 0, 2 }, { 9, 14, 0 } } },",
          "504:   { { { 11, 0, 1 }, { 0, 32, 0 } } },",
          "505:   { { { 11, 0, 0 }, { 0, 33, 0 } } },",
          "506:   { { { 11, 0, 1 }, { 2, 30, 0 } } },",
          "507:   { { { 11, 0, 2 }, { 0, 34, 0 } } },",
          "508:   { { { 12, 0, 1 }, { 0, 35, 0 } } },",
          "509:   { { { 12, 0, 0 }, { 0, 36, 0 } } },",
          "510:   { { { 12, 0, 1 }, { 3, 31, 0 } } },",
          "511:   { { { 12, 0, 2 }, { 0, 37, 0 } } },",
          "512:   { { { 13, 0, 1 }, { 0, 38, 0 } } },",
          "513:   { { { 13, 0, 0 }, { 0, 39, 0 } } },",
          "514:   { { { 13, 0, 1 }, { 5, 30, 0 } } },",
          "515:   { { { 13, 0, 2 }, { 0, 40, 0 } } },",
          "516:   { { { 14, 0, 1 }, { 0, 41, 0 } } },",
          "517:   { { { 14, 0, 0 }, { 0, 42, 0 } } },",
          "518:   { { { 14, 0, 1 }, { 6, 31, 0 } } },",
          "519:   { { { 14, 0, 2 }, { 0, 43, 0 } } },",
          "520:   { { { 15, 0, 1 }, { 0, 44, 0 } } },",
          "521:   { { { 15, 0, 0 }, { 0, 45, 0 } } },",
          "522:   { { { 15, 0, 1 }, { 8, 30, 0 } } },",
          "523:   { { { 15, 0, 2 }, { 0, 46, 0 } } },",
          "524:   { { { 16, 0, 2 }, { 0, 47, 0 } } },",
          "525:   { { { 16, 0, 1 }, { 1, 46, 0 } } },",
          "526:   { { { 16, 0, 0 }, { 0, 48, 0 } } },",
          "527:   { { { 16, 0, 1 }, { 0, 49, 0 } } },",
          "528:   { { { 16, 0, 2 }, { 0, 50, 0 } } },",
          "529:   { { { 17, 0, 1 }, { 2, 47, 0 } } },",
          "530:   { { { 17, 0, 0 }, { 0, 51, 0 } } },",
          "531:   { { { 17, 0, 1 }, { 0, 52, 0 } } },",
          "532:   { { { 17, 0, 2 }, { 0, 53, 0 } } },",
          "533:   { { { 18, 0, 1 }, { 4, 46, 0 } } },",
          "534:   { { { 18, 0, 0 }, { 0, 54, 0 } } },",
          "535:   { { { 18, 0, 1 }, { 0, 55, 0 } } },",
          "536:   { { { 18, 0, 2 }, { 0, 56, 0 } } },",
          "537:   { { { 19, 0, 1 }, { 5, 47, 0 } } },",
          "538:   { { { 19, 0, 0 }, { 0, 57, 0 } } },",
          "539:   { { { 19, 0, 1 }, { 0, 58, 0 } } },",
          "540:   { { { 19, 0, 2 }, { 0, 59, 0 } } },",
          "541:   { { { 20, 0, 1 }, { 7, 46, 0 } } },",
          "542:   { { { 20, 0, 0 }, { 0, 60, 0 } } },",
          "543:   { { { 20, 0, 1 }, { 0, 61, 0 } } },",
          "544:   { { { 20, 0, 2 }, { 0, 62, 0 } } },",
          "545:   { { { 21, 0, 1 }, { 8, 47, 0 } } },",
          "546:   { { { 21, 0, 0 }, { 0, 63, 0 } } },",
          "547:   { { { 21, 0, 1 }, { 1, 62, 0 } } },",
          "548:   { { { 21, 0, 2 }, { 1, 63, 0 } } },",
          "549:   { { { 22, 0, 1 }, { 10, 46, 0 } } },",
          "550:   { { { 22, 0, 0 }, { 2, 62, 0 } } },",
          "551:   { { { 22, 0, 1 }, { 2, 63, 0 } } },",
          "552:   { { { 22, 0, 2 }, { 3, 62, 0 } } },",
          "553:   { { { 23, 0, 1 }, { 11, 47, 0 } } },",
          "554:   { { { 23, 0, 0 }, { 3, 63, 0 } } },",
          "555:   { { { 23, 0, 1 }, { 4, 62, 0 } } },",
          "556:   { { { 23, 0, 2 }, { 4, 63, 0 } } },",
          "557:   { { { 24, 0, 1 }, { 13, 46, 0 } } },",
          "558:   { { { 24, 0, 0 }, { 5, 62, 0 } } },",
          "559:   { { { 24, 0, 1 }, { 5, 63, 0 } } },",
          "560:   { { { 24, 0, 2 }, { 6, 62, 0 } } },",
          "561:   { { { 25, 0, 1 }, { 14, 47, 0 } } },",
          "562:   { { { 25, 0, 0 }, { 6, 63, 0 } } },",
          "563:   { { { 25, 0, 1 }, { 7, 62, 0 } } },",
          "564:   { { { 25, 0, 2 }, { 7, 63, 0 } } },",
          "565:   { { { 26, 0, 1 }, { 16, 45, 0 } } },",
          "566:   { { { 26, 0, 0 }, { 8, 62, 0 } } },",
          "567:   { { { 26, 0, 1 }, { 8, 63, 0 } } },",
          "568:   { { { 26, 0, 2 }, { 9, 62, 0 } } },",
          "569:   { { { 27, 0, 1 }, { 16, 48, 0 } } },",
          "570:   { { { 27, 0, 0 }, { 9, 63, 0 } } },",
          "571:   { { { 27, 0, 1 }, { 10, 62, 0 } } },",
          "572:   { { { 27, 0, 2 }, { 10, 63, 0 } } },",
          "573:   { { { 28, 0, 1 }, { 16, 51, 0 } } },",
          "574:   { { { 28, 0, 0 }, { 11, 62, 0 } } },",
          "575:   { { { 28, 0, 1 }, { 11, 63, 0 } } },",
          "576:   { { { 28, 0, 2 }, { 12, 62, 0 } } },",
          "577:   { { { 29, 0, 1 }, { 16, 54, 0 } } },",
          "578:   { { { 29, 0, 0 }, { 12, 63, 0 } } },",
          "579:   { { { 29, 0, 1 }, { 13, 62, 0 } } },",
          "580:   { { { 29, 0, 2 }, { 13, 63, 0 } } },",
          "581:   { { { 30, 0, 1 }, { 16, 57, 0 } } },",
          "582:   { { { 30, 0, 0 }, { 14, 62, 0 } } },",
          "583:   { { { 30, 0, 1 }, { 14, 63, 0 } } },",
          "584:   { { { 30, 0, 2 }, { 15, 62, 0 } } },",
          "585:   { { { 31, 0, 1 }, { 16, 60, 0 } } },",
          "586:   { { { 31, 0, 0 }, { 15, 63, 0 } } },",
          "587:   { { { 31, 0, 1 }, { 24, 46, 0 } } },",
          "588:   { { { 31, 0, 2 }, { 16, 62, 0 } } },",
          "589:   { { { 32, 0, 2 }, { 16, 63, 0 } } },",
          "590:   { { { 32, 0, 1 }, { 17, 62, 0 } } },",
          "591:   { { { 32, 0, 0 }, { 25, 47, 0 } } },",
          "592:   { { { 32, 0, 1 }, { 17, 63, 0 } } },",
          "593:   { { { 32, 0, 2 }, { 18, 62, 0 } } },",
          "594:   { { { 33, 0, 1 }, { 18, 63, 0 } } },",
          "595:   { { { 33, 0, 0 }, { 27, 46, 0 } } },",
          "596:   { { { 33, 0, 1 }, { 19, 62, 0 } } },",
          "597:   { { { 33, 0, 2 }, { 19, 63, 0 } } },",
          "598:   { { { 34, 0, 1 }, { 20, 62, 0 } } },",
          "599:   { { { 34, 0, 0 }, { 28, 47, 0 } } },",
          "600:   { { { 34, 0, 1 }, { 20, 63, 0 } } },",
          "601:   { { { 34, 0, 2 }, { 21, 62, 0 } } },",
          "602:   { { { 35, 0, 1 }, { 21, 63, 0 } } },",
          "603:   { { { 35, 0, 0 }, { 30, 46, 0 } } },",
          "604:   { { { 35, 0, 1 }, { 22, 62, 0 } } },",
          "605:   { { { 35, 0, 2 }, { 22, 63, 0 } } },",
          "606:   { { { 36, 0, 1 }, { 23, 62, 0 } } },",
          "607:   { { { 36, 0, 0 }, { 31, 47, 0 } } },",
          "608:   { { { 36, 0, 1 }, { 23, 63, 0 } } },",
          "609:   { { { 36, 0, 2 }, { 24, 62, 0 } } },",
          "610:   { { { 37, 0, 1 }, { 24, 63, 0 } } },",
          "611:   { { { 37, 0, 0 }, { 32, 47, 0 } } },",
          "612:   { { { 37, 0, 1 }, { 25, 62, 0 } } },",
          "613:   { { { 37, 0, 2 }, { 25, 63, 0 } } },",
          "614:   { { { 38, 0, 1 }, { 26, 62, 0 } } },",
          "615:   { { { 38, 0, 0 }, { 32, 50, 0 } } },",
          "616:   { { { 38, 0, 1 }, { 26, 63, 0 } } },",
          "617:   { { { 38, 0, 2 }, { 27, 62, 0 } } },",
          "618:   { { { 39, 0, 1 }, { 27, 63, 0 } } },",
          "619:   { { { 39, 0, 0 }, { 32, 53, 0 } } },",
          "620:   { { { 39, 0, 1 }, { 28, 62, 0 } } },",
          "621:   { { { 39, 0, 2 }, { 28, 63, 0 } } },",
          "622:   { { { 40, 0, 1 }, { 29, 62, 0 } } },",
          "623:   { { { 40, 0, 0 }, { 32, 56, 0 } } },",
          "624:   { { { 40, 0, 1 }, { 29, 63, 0 } } },",
          "625:   { { { 40, 0, 2 }, { 30, 62, 0 } } },",
          "626:   { { { 41, 0, 1 }, { 30, 63, 0 } } },",
          "627:   { { { 41, 0, 0 }, { 32, 59, 0 } } },",
          "628:   { { { 41, 0, 1 }, { 31, 62, 0 } } },",
          "629:   { { { 41, 0, 2 }, { 31, 63, 0 } } },",
          "630:   { { { 42, 0, 1 }, { 32, 61, 0 } } },",
          "631:   { { { 42, 0, 0 }, { 32, 62, 0 } } },",
          "632:   { { { 42, 0, 1 }, { 32, 63, 0 } } },",
          "633:   { { { 42, 0, 2 }, { 41, 46, 0 } } },",
          "634:   { { { 43, 0, 1 }, { 33, 62, 0 } } },",
          "635:   { { { 43, 0, 0 }, { 33, 63, 0 } } },",
          "636:   { { { 43, 0, 1 }, { 34, 62, 0 } } },",
          "637:   { { { 43, 0, 2 }, { 42, 47, 0 } } },",
          "638:   { { { 44, 0, 1 }, { 34, 63, 0 } } },",
          "639:   { { { 44, 0, 0 }, { 35, 62, 0 } } },",
          "640:   { { { 44, 0, 1 }, { 35, 63, 0 } } },",
          "641:   { { { 44, 0, 2 }, { 44, 46, 0 } } },",
          "642:   { { { 45, 0, 1 }, { 36, 62, 0 } } },",
          "643:   { { { 45, 0, 0 }, { 36, 63, 0 } } },",
          "644:   { { { 45, 0, 1 }, { 37, 62, 0 } } },",
          "645:   { { { 45, 0, 2 }, { 45, 47, 0 } } },",
          "646:   { { { 46, 0, 1 }, { 37, 63, 0 } } },",
          "647:   { { { 46, 0, 0 }, { 38, 62, 0 } } },",
          "648:   { { { 46, 0, 1 }, { 38, 63, 0 } } },",
          "649:   { { { 46, 0, 2 }, { 47, 46, 0 } } },",
          "650:   { { { 47, 0, 1 }, { 39, 62, 0 } } },",
          "651:   { { { 47, 0, 0 }, { 39, 63, 0 } } },",
          "652:   { { { 47, 0, 1 }, { 40, 62, 0 } } },",
          "653:   { { { 47, 0, 2 }, { 48, 46, 0 } } },",
          "654:   { { { 48, 0, 2 }, { 40, 63, 0 } } },",
          "655:   { { { 48, 0, 1 }, { 41, 62, 0 } } },",
          "656:   { { { 48, 0, 0 }, { 41, 63, 0 } } },",
          "657:   { { { 48, 0, 1 }, { 48, 49, 0 } } },",
          "658:   { { { 48, 0, 2 }, { 42, 62, 0 } } },",
          "659:   { { { 49, 0, 1 }, { 42, 63, 0 } } },",
          "660:   { { { 49, 0, 0 }, { 43, 62, 0 } } },",
          "661:   { { { 49, 0, 1 }, { 48, 52, 0 } } },",
          "662:   { { { 49, 0, 2 }, { 43, 63, 0 } } },",
          "663:   { { { 50, 0, 1 }, { 44, 62, 0 } } },",
          "664:   { { { 50, 0, 0 }, { 44, 63, 0 } } },",
          "665:   { { { 50, 0, 1 }, { 48, 55, 0 } } },",
          "666:   { { { 50, 0, 2 }, { 45, 62, 0 } } },",
          "667:   { { { 51, 0, 1 }, { 45, 63, 0 } } },",
          "668:   { { { 51, 0, 0 }, { 46, 62, 0 } } },",
          "669:   { { { 51, 0, 1 }, { 48, 58, 0 } } },",
          "670:   { { { 51, 0, 2 }, { 46, 63, 0 } } },",
          "671:   { { { 52, 0, 1 }, { 47, 62, 0 } } },",
          "672:   { { { 52, 0, 0 }, { 47, 63, 0 } } },",
          "673:   { { { 52, 0, 1 }, { 48, 61, 0 } } },",
          "674:   { { { 52, 0, 2 }, { 48, 62, 0 } } },",
          "675:   { { { 53, 0, 1 }, { 56, 47, 0 } } },",
          "676:   { { { 53, 0, 0 }, { 48, 63, 0 } } },",
          "677:   { { { 53, 0, 1 }, { 49, 62, 0 } } },",
          "678:   { { { 53, 0, 2 }, { 49, 63, 0 } } },",
          "679:   { { { 54, 0, 1 }, { 58, 46, 0 } } },",
          "680:   { { { 54, 0, 0 }, { 50, 62, 0 } } },",
          "681:   { { { 54, 0, 1 }, { 50, 63, 0 } } },",
          "682:   { { { 54, 0, 2 }, { 51, 62, 0 } } },",
          "683:   { { { 55, 0, 1 }, { 59, 47, 0 } } },",
          "684:   { { { 55, 0, 0 }, { 51, 63, 0 } } },",
          "685:   { { { 55, 0, 1 }, { 52, 62, 0 } } },",
          "686:   { { { 55, 0, 2 }, { 52, 63, 0 } } },",
          "687:   { { { 56, 0, 1 }, { 61, 46, 0 } } },",
          "688:   { { { 56, 0, 0 }, { 53, 62, 0 } } },",
          "689:   { { { 56, 0, 1 }, { 53, 63, 0 } } },",
          "690:   { { { 56, 0, 2 }, { 54, 62, 0 } } },",
          "691:   { { { 57, 0, 1 }, { 62, 47, 0 } } },",
          "692:   { { { 57, 0, 0 }, { 54, 63, 0 } } },",
          "693:   { { { 57, 0, 1 }, { 55, 62, 0 } } },",
          "694:   { { { 57, 0, 2 }, { 55, 63, 0 } } },",
          "695:   { { { 58, 0, 1 }, { 56, 62, 1 } } },",
          "696:   { { { 58, 0, 0 }, { 56, 62, 0 } } },",
          "697:   { { { 58, 0, 1 }, { 56, 63, 0 } } },",
          "698:   { { { 58, 0, 2 }, { 57, 62, 0 } } },",
          "699:   { { { 59, 0, 1 }, { 57, 63, 1 } } },",
          "700:   { { { 59, 0, 0 }, { 57, 63, 0 } } },",
          "701:   { { { 59, 0, 1 }, { 58, 62, 0 } } },",
          "702:   { { { 59, 0, 2 }, { 58, 63, 0 } } },",
          "703:   { { { 60, 0, 1 }, { 59, 62, 1 } } },",
          "704:   { { { 60, 0, 0 }, { 59, 62, 0 } } },",
          "705:   { { { 60, 0, 1 }, { 59, 63, 0 } } },",
          "706:   { { { 60, 0, 2 }, { 60, 62, 0 } } },",
          "707:   { { { 61, 0, 1 }, { 60, 63, 1 } } },",
          "708:   { { { 61, 0, 0 }, { 60, 63, 0 } } },",
          "709:   { { { 61, 0, 1 }, { 61, 62, 0 } } },",
          "710:   { { { 61, 0, 2 }, { 61, 63, 0 } } },",
          "711:   { { { 62, 0, 1 }, { 62, 62, 1 } } },",
          "712:   { { { 62, 0, 0 }, { 62, 62, 0 } } },",
          "713:   { { { 62, 0, 1 }, { 62, 63, 0 } } },",
          "714:   { { { 62, 0, 2 }, { 63, 62, 0 } } },",
          "715:   { { { 63, 0, 1 }, { 63, 63, 1 } } },",
          "716:   { { { 63, 0, 0 }, { 63, 63, 0 } } }",
          "717: };",
          "719: static const DDSSingleColourLookup*",
          "720:   DDS_LOOKUP[] =",
          "721: {",
          "722:   DDSLookup_5_4,",
          "723:   DDSLookup_6_4,",
          "724:   DDSLookup_5_4",
          "725: };",
          "728:   Macros",
          "730: #define C565_r(x) (((x) & 0xF800) >> 11)",
          "731: #define C565_g(x) (((x) & 0x07E0) >> 5)",
          "732: #define C565_b(x)  ((x) & 0x001F)",
          "734: #define C565_red(x)   ( (C565_r(x) << 3 | C565_r(x) >> 2))",
          "735: #define C565_green(x) ( (C565_g(x) << 2 | C565_g(x) >> 4))",
          "736: #define C565_blue(x)  ( (C565_b(x) << 3 | C565_b(x) >> 2))",
          "738: #define DIV2(x)  ((x) > 1 ? ((x) >> 1) : 1)",
          "740: #define FixRange(min, max, steps) \\",
          "741: if (min > max) \\",
          "742:   min = max; \\",
          "743: if (max - min < steps) \\",
          "744:   max = Min(min + steps, 255); \\",
          "745: if (max - min < steps) \\",
          "746:   min = Max(min - steps, 0)",
          "748: #define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)",
          "750: #define VectorInit(vector, value) vector.x = vector.y = vector.z = vector.w \\",
          "751:   = value",
          "752: #define VectorInit3(vector, value) vector.x = vector.y = vector.z = value",
          "754: #define IsBitMask(mask, r, g, b, a) (mask.r_bitmask == r && mask.g_bitmask == \\",
          "755:   g && mask.b_bitmask == b && mask.alpha_bitmask == a)",
          "758:   Forward declarations",
          "760: static MagickBooleanType",
          "761:   ConstructOrdering(const size_t, const DDSVector4 *, const DDSVector3,",
          "762:   DDSVector4 *, DDSVector4 *, unsigned char *, size_t);",
          "764: static MagickBooleanType",
          "765:   ReadDDSInfo(Image *, DDSInfo *);",
          "767: static void",
          "768:   CalculateColors(unsigned short, unsigned short,",
          "769:     DDSColors *, MagickBooleanType);",
          "771: static MagickBooleanType",
          "772:   ReadDXT1(Image *, DDSInfo *, ExceptionInfo *);",
          "774: static MagickBooleanType",
          "775:   ReadDXT3(Image *, DDSInfo *, ExceptionInfo *);",
          "777: static MagickBooleanType",
          "778:   ReadDXT5(Image *, DDSInfo *, ExceptionInfo *);",
          "780: static MagickBooleanType",
          "781:   ReadUncompressedRGB(Image *, DDSInfo *, ExceptionInfo *);",
          "783: static MagickBooleanType",
          "784:   ReadUncompressedRGBA(Image *, DDSInfo *, ExceptionInfo *);",
          "786: static void",
          "787:   RemapIndices(const ssize_t *, const unsigned char *, unsigned char *);",
          "789: static void",
          "790:   SkipDXTMipmaps(Image *, DDSInfo *, int);",
          "792: static void",
          "793:   SkipRGBMipmaps(Image *, DDSInfo *, int);",
          "795: static",
          "796:   MagickBooleanType WriteDDSImage(const ImageInfo *, Image *, ExceptionInfo *);",
          "798: static void",
          "799:   WriteDDSInfo(Image *, const size_t, const size_t, const size_t);",
          "801: static void",
          "802:   WriteFourCC(Image *, const size_t, const MagickBooleanType,",
          "803:     const MagickBooleanType, ExceptionInfo *);",
          "805: static void",
          "806:   WriteImageData(Image *, const size_t, const size_t, const MagickBooleanType,",
          "807:   const MagickBooleanType, ExceptionInfo *);",
          "809: static void",
          "810:   WriteIndices(Image *, const DDSVector3, const DDSVector3, unsigned char *);",
          "812: static MagickBooleanType",
          "813:   WriteMipmaps(Image *, const size_t, const size_t, const size_t,",
          "814:     const MagickBooleanType, const MagickBooleanType, ExceptionInfo *);",
          "816: static void",
          "817:   WriteSingleColorFit(Image *, const DDSVector4 *, const ssize_t *);",
          "819: static void",
          "820:   WriteUncompressed(Image *, ExceptionInfo *);",
          "822: static inline size_t Max(size_t one, size_t two)",
          "823: {",
          "824:   if (one > two)",
          "825:     return one;",
          "826:   return two;",
          "827: }",
          "829: static inline float MaxF(float one, float two)",
          "830: {",
          "831:   if (one > two)",
          "832:     return one;",
          "833:   return two;",
          "834: }",
          "836: static inline size_t Min(size_t one, size_t two)",
          "837: {",
          "838:   if (one < two)",
          "839:     return one;",
          "840:   return two;",
          "841: }",
          "843: static inline float MinF(float one, float two)",
          "844: {",
          "845:   if (one < two)",
          "846:     return one;",
          "847:   return two;",
          "848: }",
          "850: static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,",
          "851:   DDSVector4 *destination)",
          "852: {",
          "853:   destination->x = left.x + right.x;",
          "854:   destination->y = left.y + right.y;",
          "855:   destination->z = left.z + right.z;",
          "856:   destination->w = left.w + right.w;",
          "857: }",
          "859: static inline void VectorClamp(DDSVector4 *value)",
          "860: {",
          "861:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "862:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "863:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "864:   value->w = MinF(1.0f,MaxF(0.0f,value->w));",
          "865: }",
          "867: static inline void VectorClamp3(DDSVector3 *value)",
          "868: {",
          "869:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "870:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "871:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "872: }",
          "874: static inline void VectorCopy43(const DDSVector4 source,",
          "875:   DDSVector3 *destination)",
          "876: {",
          "877:   destination->x = source.x;",
          "878:   destination->y = source.y;",
          "879:   destination->z = source.z;",
          "880: }",
          "882: static inline void VectorCopy44(const DDSVector4 source,",
          "883:   DDSVector4 *destination)",
          "884: {",
          "885:   destination->x = source.x;",
          "886:   destination->y = source.y;",
          "887:   destination->z = source.z;",
          "888:   destination->w = source.w;",
          "889: }",
          "891: static inline void VectorNegativeMultiplySubtract(const DDSVector4 a,",
          "892:   const DDSVector4 b, const DDSVector4 c, DDSVector4 *destination)",
          "893: {",
          "894:   destination->x = c.x - (a.x * b.x);",
          "895:   destination->y = c.y - (a.y * b.y);",
          "896:   destination->z = c.z - (a.z * b.z);",
          "897:   destination->w = c.w - (a.w * b.w);",
          "898: }",
          "900: static inline void VectorMultiply(const DDSVector4 left,",
          "901:   const DDSVector4 right, DDSVector4 *destination)",
          "902: {",
          "903:   destination->x = left.x * right.x;",
          "904:   destination->y = left.y * right.y;",
          "905:   destination->z = left.z * right.z;",
          "906:   destination->w = left.w * right.w;",
          "907: }",
          "909: static inline void VectorMultiply3(const DDSVector3 left,",
          "910:   const DDSVector3 right, DDSVector3 *destination)",
          "911: {",
          "912:   destination->x = left.x * right.x;",
          "913:   destination->y = left.y * right.y;",
          "914:   destination->z = left.z * right.z;",
          "915: }",
          "917: static inline void VectorMultiplyAdd(const DDSVector4 a, const DDSVector4 b,",
          "918:   const DDSVector4 c, DDSVector4 *destination)",
          "919: {",
          "920:   destination->x = (a.x * b.x) + c.x;",
          "921:   destination->y = (a.y * b.y) + c.y;",
          "922:   destination->z = (a.z * b.z) + c.z;",
          "923:   destination->w = (a.w * b.w) + c.w;",
          "924: }",
          "926: static inline void VectorMultiplyAdd3(const DDSVector3 a, const DDSVector3 b,",
          "927:   const DDSVector3 c, DDSVector3 *destination)",
          "928: {",
          "929:   destination->x = (a.x * b.x) + c.x;",
          "930:   destination->y = (a.y * b.y) + c.y;",
          "931:   destination->z = (a.z * b.z) + c.z;",
          "932: }",
          "934: static inline void VectorReciprocal(const DDSVector4 value,",
          "935:   DDSVector4 *destination)",
          "936: {",
          "937:   destination->x = 1.0f / value.x;",
          "938:   destination->y = 1.0f / value.y;",
          "939:   destination->z = 1.0f / value.z;",
          "940:   destination->w = 1.0f / value.w;",
          "941: }",
          "943: static inline void VectorSubtract(const DDSVector4 left,",
          "944:   const DDSVector4 right, DDSVector4 *destination)",
          "945: {",
          "946:   destination->x = left.x - right.x;",
          "947:   destination->y = left.y - right.y;",
          "948:   destination->z = left.z - right.z;",
          "949:   destination->w = left.w - right.w;",
          "950: }",
          "952: static inline void VectorSubtract3(const DDSVector3 left,",
          "953:   const DDSVector3 right, DDSVector3 *destination)",
          "954: {",
          "955:   destination->x = left.x - right.x;",
          "956:   destination->y = left.y - right.y;",
          "957:   destination->z = left.z - right.z;",
          "958: }",
          "960: static inline void VectorTruncate(DDSVector4 *value)",
          "961: {",
          "962:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "963:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "964:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "965:   value->w = value->w > 0.0f ? floor(value->w) : ceil(value->w);",
          "966: }",
          "968: static inline void VectorTruncate3(DDSVector3 *value)",
          "969: {",
          "970:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "971:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "972:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "973: }",
          "975: static void CalculateColors(unsigned short c0, unsigned short c1,",
          "976:   DDSColors *c, MagickBooleanType ignoreAlpha)",
          "977: {",
          "978:   c->a[0] = c->a[1] = c->a[2] = c->a[3] = 0;",
          "980:   c->r[0] = (unsigned char) C565_red(c0);",
          "981:   c->g[0] = (unsigned char) C565_green(c0);",
          "982:   c->b[0] = (unsigned char) C565_blue(c0);",
          "984:   c->r[1] = (unsigned char) C565_red(c1);",
          "985:   c->g[1] = (unsigned char) C565_green(c1);",
          "986:   c->b[1] = (unsigned char) C565_blue(c1);",
          "988:   if (ignoreAlpha != MagickFalse || c0 > c1)",
          "989:     {",
          "990:       c->r[2] = (unsigned char) ((2 * c->r[0] + c->r[1]) / 3);",
          "991:       c->g[2] = (unsigned char) ((2 * c->g[0] + c->g[1]) / 3);",
          "992:       c->b[2] = (unsigned char) ((2 * c->b[0] + c->b[1]) / 3);",
          "994:       c->r[3] = (unsigned char) ((c->r[0] + 2 * c->r[1]) / 3);",
          "995:       c->g[3] = (unsigned char) ((c->g[0] + 2 * c->g[1]) / 3);",
          "996:       c->b[3] = (unsigned char) ((c->b[0] + 2 * c->b[1]) / 3);",
          "997:     }",
          "998:   else",
          "999:     {",
          "1000:       c->r[2] = (unsigned char) ((c->r[0] + c->r[1]) / 2);",
          "1001:       c->g[2] = (unsigned char) ((c->g[0] + c->g[1]) / 2);",
          "1002:       c->b[2] = (unsigned char) ((c->b[0] + c->b[1]) / 2);",
          "1004:       c->r[3] = c->g[3] = c->b[3] = 0;",
          "1005:       c->a[3] = 255;",
          "1006:     }",
          "1007: }",
          "1009: static size_t CompressAlpha(const size_t min, const size_t max,",
          "1010:   const size_t steps, const ssize_t *alphas, unsigned char* indices)",
          "1011: {",
          "1012:   unsigned char",
          "1013:     codes[8];",
          "1015:   register ssize_t",
          "1016:     i;",
          "1018:   size_t",
          "1019:     error,",
          "1020:     index,",
          "1021:     j,",
          "1022:     least,",
          "1023:     value;",
          "1025:   codes[0] = (unsigned char) min;",
          "1026:   codes[1] = (unsigned char) max;",
          "1027:   codes[6] = 0;",
          "1028:   codes[7] = 255;",
          "1030:   for (i=1; i <  (ssize_t) steps; i++)",
          "1031:     codes[i+1] = (unsigned char) (((steps-i)*min + i*max) / steps);",
          "1033:   error = 0;",
          "1034:   for (i=0; i<16; i++)",
          "1035:   {",
          "1036:     if (alphas[i] == -1)",
          "1037:       {",
          "1038:         indices[i] = 0;",
          "1039:         continue;",
          "1040:       }",
          "1042:     value = alphas[i];",
          "1043:     least = SIZE_MAX;",
          "1044:     index = 0;",
          "1045:     for (j=0; j<8; j++)",
          "1046:     {",
          "1047:       size_t",
          "1048:         dist;",
          "1050:       dist = value - (size_t)codes[j];",
          "1051:       dist *= dist;",
          "1053:       if (dist < least)",
          "1054:         {",
          "1055:           least = dist;",
          "1056:           index = j;",
          "1057:         }",
          "1058:     }",
          "1060:     indices[i] = (unsigned char)index;",
          "1061:     error += least;",
          "1062:   }",
          "1064:   return error;",
          "1065: }",
          "1067: static void CompressClusterFit(const size_t count,",
          "1068:   const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,",
          "1069:   const DDSVector4 metric, DDSVector3 *start, DDSVector3* end,",
          "1070:   unsigned char *indices)",
          "1071: {",
          "1072:   DDSVector3",
          "1073:     axis;",
          "1075:   DDSVector4",
          "1076:     grid,",
          "1077:     gridrcp,",
          "1078:     half,",
          "1079:     onethird_onethird2,",
          "1080:     part0,",
          "1081:     part1,",
          "1082:     part2,",
          "1083:     part3,",
          "1084:     pointsWeights[16],",
          "1085:     two,",
          "1086:     twonineths,",
          "1087:     twothirds_twothirds2,",
          "1088:     xSumwSum;",
          "1090:   float",
          "1091:     bestError = 1e+37f;",
          "1093:   size_t",
          "1094:     bestIteration = 0,",
          "1095:     besti = 0,",
          "1096:     bestj = 0,",
          "1097:     bestk = 0,",
          "1098:     iterationIndex,",
          "1099:     i,",
          "1100:     j,",
          "1101:     k,",
          "1102:     kmin;",
          "1104:   unsigned char",
          "1106:     order[128],",
          "1107:     unordered[16];",
          "1109:   VectorInit(half,0.5f);",
          "1110:   VectorInit(two,2.0f);",
          "1112:   VectorInit(onethird_onethird2,1.0f/3.0f);",
          "1113:   onethird_onethird2.w = 1.0f/9.0f;",
          "1114:   VectorInit(twothirds_twothirds2,2.0f/3.0f);",
          "1115:   twothirds_twothirds2.w = 4.0f/9.0f;",
          "1116:   VectorInit(twonineths,2.0f/9.0f);",
          "1118:   grid.x = 31.0f;",
          "1119:   grid.y = 63.0f;",
          "1120:   grid.z = 31.0f;",
          "1121:   grid.w = 0.0f;",
          "1123:   gridrcp.x = 1.0f/31.0f;",
          "1124:   gridrcp.y = 1.0f/63.0f;",
          "1125:   gridrcp.z = 1.0f/31.0f;",
          "1126:   gridrcp.w = 0.0f;",
          "1128:   xSumwSum.x = 0.0f;",
          "1129:   xSumwSum.y = 0.0f;",
          "1130:   xSumwSum.z = 0.0f;",
          "1131:   xSumwSum.w = 0.0f;",
          "1133:   ConstructOrdering(count,points,principle,pointsWeights,&xSumwSum,order,0);",
          "1135:   for (iterationIndex = 0;;)",
          "1136:   {",
          "1137:     VectorInit(part0,0.0f);",
          "1138:     for (i=0; i < count; i++)",
          "1139:     {",
          "1140:       VectorInit(part1,0.0f);",
          "1141:       for (j=i;;)",
          "1142:       {",
          "1143:         if (j == 0)",
          "1144:           {",
          "1145:             VectorCopy44(pointsWeights[0],&part2);",
          "1146:             kmin = 1;",
          "1147:           }",
          "1148:           else",
          "1149:           {",
          "1150:             VectorInit(part2,0.0f);",
          "1151:             kmin = j;",
          "1152:           }",
          "1154:         for (k=kmin;;)",
          "1155:         {",
          "1156:           DDSVector4",
          "1157:             a,",
          "1158:             alpha2_sum,",
          "1159:             alphax_sum,",
          "1160:             alphabeta_sum,",
          "1161:             b,",
          "1162:             beta2_sum,",
          "1163:             betax_sum,",
          "1164:             e1,",
          "1165:             e2,",
          "1166:             factor;",
          "1168:           float",
          "1169:             error;",
          "1171:           VectorSubtract(xSumwSum,part2,&part3);",
          "1172:           VectorSubtract(part3,part1,&part3);",
          "1173:           VectorSubtract(part3,part0,&part3);",
          "1175:           VectorMultiplyAdd(part1,twothirds_twothirds2,part0,&alphax_sum);",
          "1176:           VectorMultiplyAdd(part2,onethird_onethird2,alphax_sum,&alphax_sum);",
          "1177:           VectorInit(alpha2_sum,alphax_sum.w);",
          "1179:           VectorMultiplyAdd(part2,twothirds_twothirds2,part3,&betax_sum);",
          "1180:           VectorMultiplyAdd(part1,onethird_onethird2,betax_sum,&betax_sum);",
          "1181:           VectorInit(beta2_sum,betax_sum.w);",
          "1183:           VectorAdd(part1,part2,&alphabeta_sum);",
          "1184:           VectorInit(alphabeta_sum,alphabeta_sum.w);",
          "1185:           VectorMultiply(twonineths,alphabeta_sum,&alphabeta_sum);",
          "1187:           VectorMultiply(alpha2_sum,beta2_sum,&factor);",
          "1188:           VectorNegativeMultiplySubtract(alphabeta_sum,alphabeta_sum,factor,",
          "1189:             &factor);",
          "1190:           VectorReciprocal(factor,&factor);",
          "1192:           VectorMultiply(alphax_sum,beta2_sum,&a);",
          "1193:           VectorNegativeMultiplySubtract(betax_sum,alphabeta_sum,a,&a);",
          "1194:           VectorMultiply(a,factor,&a);",
          "1196:           VectorMultiply(betax_sum,alpha2_sum,&b);",
          "1197:           VectorNegativeMultiplySubtract(alphax_sum,alphabeta_sum,b,&b);",
          "1198:           VectorMultiply(b,factor,&b);",
          "1200:           VectorClamp(&a);",
          "1201:           VectorMultiplyAdd(grid,a,half,&a);",
          "1202:           VectorTruncate(&a);",
          "1203:           VectorMultiply(a,gridrcp,&a);",
          "1205:           VectorClamp(&b);",
          "1206:           VectorMultiplyAdd(grid,b,half,&b);",
          "1207:           VectorTruncate(&b);",
          "1208:           VectorMultiply(b,gridrcp,&b);",
          "1210:           VectorMultiply(b,b,&e1);",
          "1211:           VectorMultiply(e1,beta2_sum,&e1);",
          "1212:           VectorMultiply(a,a,&e2);",
          "1213:           VectorMultiplyAdd(e2,alpha2_sum,e1,&e1);",
          "1215:           VectorMultiply(a,b,&e2);",
          "1216:           VectorMultiply(e2,alphabeta_sum,&e2);",
          "1217:           VectorNegativeMultiplySubtract(a,alphax_sum,e2,&e2);",
          "1218:           VectorNegativeMultiplySubtract(b,betax_sum,e2,&e2);",
          "1219:           VectorMultiplyAdd(two,e2,e1,&e2);",
          "1220:           VectorMultiply(e2,metric,&e2);",
          "1222:           error = e2.x + e2.y + e2.z;",
          "1224:           if (error < bestError)",
          "1225:           {",
          "1226:             VectorCopy43(a,start);",
          "1227:             VectorCopy43(b,end);",
          "1228:             bestError = error;",
          "1229:             besti = i;",
          "1230:             bestj = j;",
          "1231:             bestk = k;",
          "1232:             bestIteration = iterationIndex;",
          "1233:           }",
          "1235:           if (k == count)",
          "1236:             break;",
          "1238:           VectorAdd(pointsWeights[k],part2,&part2);",
          "1239:           k++;",
          "1240:         }",
          "1242:         if (j == count)",
          "1243:           break;",
          "1245:         VectorAdd(pointsWeights[j],part1,&part1);",
          "1246:         j++;",
          "1247:       }",
          "1249:       VectorAdd(pointsWeights[i],part0,&part0);",
          "1250:     }",
          "1252:     if (bestIteration != iterationIndex)",
          "1253:       break;",
          "1255:     iterationIndex++;",
          "1256:     if (iterationIndex == 8)",
          "1257:       break;",
          "1259:     VectorSubtract3(*end,*start,&axis);",
          "1260:     if (ConstructOrdering(count,points,axis,pointsWeights,&xSumwSum,order,",
          "1261:       iterationIndex) == MagickFalse)",
          "1262:       break;",
          "1263:   }",
          "1265:   o = order + (16*bestIteration);",
          "1267:   for (i=0; i < besti; i++)",
          "1268:     unordered[o[i]] = 0;",
          "1269:   for (i=besti; i < bestj; i++)",
          "1270:     unordered[o[i]] = 2;",
          "1271:   for (i=bestj; i < bestk; i++)",
          "1272:     unordered[o[i]] = 3;",
          "1273:   for (i=bestk; i < count; i++)",
          "1274:     unordered[o[i]] = 1;",
          "1276:   RemapIndices(map,unordered,indices);",
          "1277: }",
          "1279: static void CompressRangeFit(const size_t count,",
          "1280:   const DDSVector4* points, const ssize_t *map, const DDSVector3 principle,",
          "1281:   const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,",
          "1282:   unsigned char *indices)",
          "1283: {",
          "1284:   float",
          "1285:     d,",
          "1286:     bestDist,",
          "1287:     max,",
          "1288:     min,",
          "1289:     val;",
          "1291:   DDSVector3",
          "1292:     codes[4],",
          "1293:     grid,",
          "1294:     gridrcp,",
          "1295:     half,",
          "1296:     dist;",
          "1298:   register ssize_t",
          "1299:     i;",
          "1301:   size_t",
          "1302:     bestj,",
          "1303:     j;",
          "1305:   unsigned char",
          "1306:     closest[16];",
          "1308:   VectorInit3(half,0.5f);",
          "1310:   grid.x = 31.0f;",
          "1311:   grid.y = 63.0f;",
          "1312:   grid.z = 31.0f;",
          "1314:   gridrcp.x = 1.0f/31.0f;",
          "1315:   gridrcp.y = 1.0f/63.0f;",
          "1316:   gridrcp.z = 1.0f/31.0f;",
          "1318:   if (count > 0)",
          "1319:     {",
          "1320:       VectorCopy43(points[0],start);",
          "1321:       VectorCopy43(points[0],end);",
          "1323:       min = max = Dot(points[0],principle);",
          "1324:       for (i=1; i < (ssize_t) count; i++)",
          "1325:       {",
          "1326:         val = Dot(points[i],principle);",
          "1327:         if (val < min)",
          "1328:         {",
          "1329:           VectorCopy43(points[i],start);",
          "1330:           min = val;",
          "1331:         }",
          "1332:         else if (val > max)",
          "1333:         {",
          "1334:           VectorCopy43(points[i],end);",
          "1335:           max = val;",
          "1336:         }",
          "1337:       }",
          "1338:     }",
          "1340:   VectorClamp3(start);",
          "1341:   VectorMultiplyAdd3(grid,*start,half,start);",
          "1342:   VectorTruncate3(start);",
          "1343:   VectorMultiply3(*start,gridrcp,start);",
          "1345:   VectorClamp3(end);",
          "1346:   VectorMultiplyAdd3(grid,*end,half,end);",
          "1347:   VectorTruncate3(end);",
          "1348:   VectorMultiply3(*end,gridrcp,end);",
          "1350:   codes[0] = *start;",
          "1351:   codes[1] = *end;",
          "1352:   codes[2].x = (start->x * (2.0f/3.0f)) + (end->x * (1.0f/3.0f));",
          "1353:   codes[2].y = (start->y * (2.0f/3.0f)) + (end->y * (1.0f/3.0f));",
          "1354:   codes[2].z = (start->z * (2.0f/3.0f)) + (end->z * (1.0f/3.0f));",
          "1355:   codes[3].x = (start->x * (1.0f/3.0f)) + (end->x * (2.0f/3.0f));",
          "1356:   codes[3].y = (start->y * (1.0f/3.0f)) + (end->y * (2.0f/3.0f));",
          "1357:   codes[3].z = (start->z * (1.0f/3.0f)) + (end->z * (2.0f/3.0f));",
          "1359:   for (i=0; i < (ssize_t) count; i++)",
          "1360:   {",
          "1361:     bestDist = 1e+37f;",
          "1362:     bestj = 0;",
          "1363:     for (j=0; j < 4; j++)",
          "1364:     {",
          "1365:       dist.x = (points[i].x - codes[j].x) * metric.x;",
          "1366:       dist.y = (points[i].y - codes[j].y) * metric.y;",
          "1367:       dist.z = (points[i].z - codes[j].z) * metric.z;",
          "1369:       d = Dot(dist,dist);",
          "1370:       if (d < bestDist)",
          "1371:         {",
          "1372:           bestDist = d;",
          "1373:           bestj = j;",
          "1374:         }",
          "1375:     }",
          "1377:     closest[i] = (unsigned char) bestj;",
          "1378:   }",
          "1380:   RemapIndices(map, closest, indices);",
          "1381: }",
          "1383: static void ComputeEndPoints(const DDSSingleColourLookup *lookup[],",
          "1384:   const unsigned char *color, DDSVector3 *start, DDSVector3 *end,",
          "1385:   unsigned char *index)",
          "1386: {",
          "1387:   register ssize_t",
          "1388:     i;",
          "1390:   size_t",
          "1391:     c,",
          "1392:     maxError = SIZE_MAX;",
          "1394:   for (i=0; i < 2; i++)",
          "1395:   {",
          "1396:     const DDSSourceBlock*",
          "1397:       sources[3];",
          "1399:       size_t",
          "1400:         error = 0;",
          "1402:     for (c=0; c < 3; c++)",
          "1403:     {",
          "1404:       sources[c] = &lookup[c][color[c]].sources[i];",
          "1405:       error += ((size_t) sources[c]->error) * ((size_t) sources[c]->error);",
          "1406:     }",
          "1408:     if (error > maxError)",
          "1409:       continue;",
          "1411:     start->x = (float) sources[0]->start / 31.0f;",
          "1412:     start->y = (float) sources[1]->start / 63.0f;",
          "1413:     start->z = (float) sources[2]->start / 31.0f;",
          "1415:     end->x = (float) sources[0]->end / 31.0f;",
          "1416:     end->y = (float) sources[1]->end / 63.0f;",
          "1417:     end->z = (float) sources[2]->end / 31.0f;",
          "1420:     maxError = error;",
          "1421:   }",
          "1422: }",
          "1424: static void ComputePrincipleComponent(const float *covariance,",
          "1425:   DDSVector3 *principle)",
          "1426: {",
          "1427:   DDSVector4",
          "1428:     row0,",
          "1429:     row1,",
          "1430:     row2,",
          "1431:     v;",
          "1433:   register ssize_t",
          "1434:     i;",
          "1436:   row0.x = covariance[0];",
          "1437:   row0.y = covariance[1];",
          "1438:   row0.z = covariance[2];",
          "1439:   row0.w = 0.0f;",
          "1441:   row1.x = covariance[1];",
          "1442:   row1.y = covariance[3];",
          "1443:   row1.z = covariance[4];",
          "1444:   row1.w = 0.0f;",
          "1446:   row2.x = covariance[2];",
          "1447:   row2.y = covariance[4];",
          "1448:   row2.z = covariance[5];",
          "1449:   row2.w = 0.0f;",
          "1451:   VectorInit(v,1.0f);",
          "1453:   for (i=0; i < 8; i++)",
          "1454:   {",
          "1455:     DDSVector4",
          "1456:       w;",
          "1458:     float",
          "1459:       a;",
          "1461:     w.x = row0.x * v.x;",
          "1462:     w.y = row0.y * v.x;",
          "1463:     w.z = row0.z * v.x;",
          "1464:     w.w = row0.w * v.x;",
          "1466:     w.x = (row1.x * v.y) + w.x;",
          "1467:     w.y = (row1.y * v.y) + w.y;",
          "1468:     w.z = (row1.z * v.y) + w.z;",
          "1469:     w.w = (row1.w * v.y) + w.w;",
          "1471:     w.x = (row2.x * v.z) + w.x;",
          "1472:     w.y = (row2.y * v.z) + w.y;",
          "1473:     w.z = (row2.z * v.z) + w.z;",
          "1474:     w.w = (row2.w * v.z) + w.w;",
          "1476:     a = 1.0f / MaxF(w.x,MaxF(w.y,w.z));",
          "1478:     v.x = w.x * a;",
          "1479:     v.y = w.y * a;",
          "1480:     v.z = w.z * a;",
          "1481:     v.w = w.w * a;",
          "1482:   }",
          "1484:   VectorCopy43(v,principle);",
          "1485: }",
          "1487: static void ComputeWeightedCovariance(const size_t count,",
          "1488:   const DDSVector4 *points, float *covariance)",
          "1489: {",
          "1490:   DDSVector3",
          "1491:     centroid;",
          "1493:   float",
          "1494:     total;",
          "1496:   size_t",
          "1497:     i;",
          "1499:   total = 0.0f;",
          "1500:   VectorInit3(centroid,0.0f);",
          "1502:   for (i=0; i < count; i++)",
          "1503:   {",
          "1504:     total += points[i].w;",
          "1505:     centroid.x += (points[i].x * points[i].w);",
          "1506:     centroid.y += (points[i].y * points[i].w);",
          "1507:     centroid.z += (points[i].z * points[i].w);",
          "1508:   }",
          "1510:   if( total > 1.192092896e-07F)",
          "1511:     {",
          "1512:       centroid.x /= total;",
          "1513:       centroid.y /= total;",
          "1514:       centroid.z /= total;",
          "1515:     }",
          "1517:   for (i=0; i < 6; i++)",
          "1518:     covariance[i] = 0.0f;",
          "1520:   for (i = 0; i < count; i++)",
          "1521:   {",
          "1522:     DDSVector3",
          "1523:       a,",
          "1524:       b;",
          "1526:     a.x = points[i].x - centroid.x;",
          "1527:     a.y = points[i].y - centroid.y;",
          "1528:     a.z = points[i].z - centroid.z;",
          "1530:     b.x = points[i].w * a.x;",
          "1531:     b.y = points[i].w * a.y;",
          "1532:     b.z = points[i].w * a.z;",
          "1534:     covariance[0] += a.x*b.x;",
          "1535:     covariance[1] += a.x*b.y;",
          "1536:     covariance[2] += a.x*b.z;",
          "1537:     covariance[3] += a.y*b.y;",
          "1538:     covariance[4] += a.y*b.z;",
          "1539:     covariance[5] += a.z*b.z;",
          "1540:   }",
          "1541: }",
          "1543: static MagickBooleanType ConstructOrdering(const size_t count,",
          "1544:   const DDSVector4 *points, const DDSVector3 axis, DDSVector4 *pointsWeights,",
          "1545:   DDSVector4 *xSumwSum, unsigned char *order, size_t iteration)",
          "1546: {",
          "1547:   float",
          "1548:      dps[16],",
          "1549:      f;",
          "1551:   register ssize_t",
          "1552:     i;",
          "1554:   size_t",
          "1555:     j;",
          "1557:   unsigned char",
          "1558:     c,",
          "1562:   o = order + (16*iteration);",
          "1564:   for (i=0; i < (ssize_t) count; i++)",
          "1565:   {",
          "1566:     dps[i] = Dot(points[i],axis);",
          "1567:     o[i] = (unsigned char)i;",
          "1568:   }",
          "1570:   for (i=0; i < (ssize_t) count; i++)",
          "1571:   {",
          "1572:     for (j=i; j > 0 && dps[j] < dps[j - 1]; j--)",
          "1573:     {",
          "1574:       f = dps[j];",
          "1575:       dps[j] = dps[j - 1];",
          "1576:       dps[j - 1] = f;",
          "1578:       c = o[j];",
          "1579:       o[j] = o[j - 1];",
          "1580:       o[j - 1] = c;",
          "1581:     }",
          "1582:   }",
          "1584:   for (i=0; i < (ssize_t) iteration; i++)",
          "1585:   {",
          "1586:     MagickBooleanType",
          "1587:       same;",
          "1589:     p = order + (16*i);",
          "1590:     same = MagickTrue;",
          "1592:     for (j=0; j < count; j++)",
          "1593:     {",
          "1594:       if (o[j] != p[j])",
          "1595:         {",
          "1596:           same = MagickFalse;",
          "1597:           break;",
          "1598:         }",
          "1599:     }",
          "1601:     if (same != MagickFalse)",
          "1602:       return MagickFalse;",
          "1603:   }",
          "1605:   xSumwSum->x = 0;",
          "1606:   xSumwSum->y = 0;",
          "1607:   xSumwSum->z = 0;",
          "1608:   xSumwSum->w = 0;",
          "1610:   for (i=0; i < (ssize_t) count; i++)",
          "1611:   {",
          "1612:     DDSVector4",
          "1613:       v;",
          "1615:     j = (size_t) o[i];",
          "1617:     v.x = points[j].w * points[j].x;",
          "1618:     v.y = points[j].w * points[j].y;",
          "1619:     v.z = points[j].w * points[j].z;",
          "1620:     v.w = points[j].w * 1.0f;",
          "1622:     VectorCopy44(v,&pointsWeights[i]);",
          "1623:     VectorAdd(*xSumwSum,v,xSumwSum);",
          "1624:   }",
          "1626:   return MagickTrue;",
          "1627: }",
          "1630: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1631: %                                                                             %",
          "1632: %                                                                             %",
          "1633: %                                                                             %",
          "1634: %   I s D D S                                                                 %",
          "1635: %                                                                             %",
          "1636: %                                                                             %",
          "1637: %                                                                             %",
          "1638: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1639: %",
          "1640: %  IsDDS() returns MagickTrue if the image format type, identified by the",
          "1641: %  magick string, is DDS.",
          "1642: %",
          "1643: %  The format of the IsDDS method is:",
          "1644: %",
          "1645: %      MagickBooleanType IsDDS(const unsigned char *magick,const size_t length)",
          "1646: %",
          "1647: %  A description of each parameter follows:",
          "1648: %",
          "1649: %    o magick: compare image format pattern against these bytes.",
          "1650: %",
          "1651: %    o length: Specifies the length of the magick string.",
          "1652: %",
          "1654: static MagickBooleanType IsDDS(const unsigned char *magick, const size_t length)",
          "1655: {",
          "1656:   if (length < 4)",
          "1657:     return(MagickFalse);",
          "1658:   if (LocaleNCompare((char *) magick,\"DDS \", 4) == 0)",
          "1659:     return(MagickTrue);",
          "1660:   return(MagickFalse);",
          "1661: }",
          "1663: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1664: %                                                                             %",
          "1665: %                                                                             %",
          "1666: %                                                                             %",
          "1667: %   R e a d D D S I m a g e                                                   %",
          "1668: %                                                                             %",
          "1669: %                                                                             %",
          "1670: %                                                                             %",
          "1671: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1672: %",
          "1673: %  ReadDDSImage() reads a DirectDraw Surface image file and returns it.  It",
          "1674: %  allocates the memory necessary for the new Image structure and returns a",
          "1675: %  pointer to the new image.",
          "1676: %",
          "1677: %  The format of the ReadDDSImage method is:",
          "1678: %",
          "1679: %      Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1680: %",
          "1681: %  A description of each parameter follows:",
          "1682: %",
          "1683: %    o image_info: The image info.",
          "1684: %",
          "1685: %    o exception: return any errors or warnings in this structure.",
          "1686: %",
          "1689: static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1690: {",
          "1691:   Image",
          "1694:   MagickBooleanType",
          "1695:     status,",
          "1696:     cubemap = MagickFalse,",
          "1697:     volume = MagickFalse;",
          "1699:   CompressionType",
          "1700:     compression;",
          "1702:   DDSInfo",
          "1703:     dds_info;",
          "1705:   DDSDecoder",
          "1708:   PixelTrait",
          "1709:     alpha_trait;",
          "1711:   size_t",
          "1712:     n,",
          "1713:     num_images;",
          "1716:     Open image file.",
          "1718:   assert(image_info != (const ImageInfo *) NULL);",
          "1719:   assert(image_info->signature == MagickSignature);",
          "1720:   if (image_info->debug != MagickFalse)",
          "1721:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",",
          "1722:       image_info->filename);",
          "1723:   assert(exception != (ExceptionInfo *) NULL);",
          "1724:   assert(exception->signature == MagickSignature);",
          "1725:   image=AcquireImage(image_info,exception);",
          "1726:   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);",
          "1727:   if (status == MagickFalse)",
          "1728:     {",
          "1729:       image=DestroyImageList(image);",
          "1730:       return((Image *) NULL);",
          "1731:     }",
          "1734:     Initialize image structure.",
          "1736:   if (ReadDDSInfo(image, &dds_info) != MagickTrue) {",
          "1737:     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "1738:   }",
          "1740:   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)",
          "1741:     cubemap = MagickTrue;",
          "1743:   if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)",
          "1744:     volume = MagickTrue;",
          "1746:   (void) SeekBlob(image, 128, SEEK_SET);",
          "1749:     Determine pixel format",
          "1751:   if (dds_info.pixelformat.flags & DDPF_RGB)",
          "1752:     {",
          "1753:       compression = NoCompression;",
          "1754:       if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)",
          "1755:         {",
          "1756:           alpha_trait = BlendPixelTrait;",
          "1757:           decoder = ReadUncompressedRGBA;",
          "1758:         }",
          "1759:       else",
          "1760:         {",
          "1761:           alpha_trait = UndefinedPixelTrait;",
          "1762:           decoder = ReadUncompressedRGB;",
          "1763:         }",
          "1764:     }",
          "1765:   else if (dds_info.pixelformat.flags & DDPF_FOURCC)",
          "1766:     {",
          "1767:       switch (dds_info.pixelformat.fourcc)",
          "1768:       {",
          "1769:         case FOURCC_DXT1:",
          "1770:         {",
          "1771:           alpha_trait = UndefinedPixelTrait;",
          "1772:           compression = DXT1Compression;",
          "1773:           decoder = ReadDXT1;",
          "1774:           break;",
          "1775:         }",
          "1777:         case FOURCC_DXT3:",
          "1778:         {",
          "1779:           alpha_trait = BlendPixelTrait;",
          "1780:           compression = DXT3Compression;",
          "1781:           decoder = ReadDXT3;",
          "1782:           break;",
          "1783:         }",
          "1785:         case FOURCC_DXT5:",
          "1786:         {",
          "1787:           alpha_trait = BlendPixelTrait;",
          "1788:           compression = DXT5Compression;",
          "1789:           decoder = ReadDXT5;",
          "1790:           break;",
          "1791:         }",
          "1793:         default:",
          "1794:         {",
          "1796:           ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1797:         }",
          "1798:       }",
          "1799:     }",
          "1800:   else",
          "1801:     {",
          "1803:       ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1804:     }",
          "1806:   num_images = 1;",
          "1807:   if (cubemap)",
          "1808:     {",
          "1810:         Determine number of faces defined in the cubemap",
          "1812:       num_images = 0;",
          "1813:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;",
          "1814:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;",
          "1815:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;",
          "1816:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;",
          "1817:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;",
          "1818:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;",
          "1819:     }",
          "1821:   if (volume)",
          "1822:     num_images = dds_info.depth;",
          "1824:   for (n = 0; n < num_images; n++)",
          "1825:   {",
          "1826:     if (n != 0)",
          "1827:       {",
          "1829:         AcquireNextImage(image_info,image,exception);",
          "1830:         if (GetNextImageInList(image) == (Image *) NULL)",
          "1831:           return(DestroyImageList(image));",
          "1832:         image=SyncNextImageInList(image);",
          "1833:       }",
          "1835:     image->alpha_trait=alpha_trait;",
          "1836:     image->compression = compression;",
          "1837:     image->columns = dds_info.width;",
          "1838:     image->rows = dds_info.height;",
          "1839:     image->storage_class = DirectClass;",
          "1840:     image->endian = LSBEndian;",
          "1841:     image->depth = 8;",
          "1842:     if (image_info->ping != MagickFalse)",
          "1843:       {",
          "1844:         (void) CloseBlob(image);",
          "1845:         return(GetFirstImageInList(image));",
          "1846:       }",
          "1848:     if ((decoder)(image, &dds_info, exception) != MagickTrue)",
          "1849:       {",
          "1850:         (void) CloseBlob(image);",
          "1851:         return(GetFirstImageInList(image));",
          "1852:       }",
          "1853:   }",
          "1855:   if (EOFBlob(image) != MagickFalse)",
          "1856:     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "1857:       image->filename);",
          "1859:   (void) CloseBlob(image);",
          "1860:   return(GetFirstImageInList(image));",
          "1861: }",
          "1863: static MagickBooleanType ReadDDSInfo(Image *image, DDSInfo *dds_info)",
          "1864: {",
          "1865:   size_t",
          "1866:     hdr_size,",
          "1867:     required;",
          "1870:   (void) SeekBlob(image, 4, SEEK_SET);",
          "1873:   hdr_size = ReadBlobLSBLong(image);",
          "1874:   if (hdr_size != 124)",
          "1875:     return MagickFalse;",
          "1878:   dds_info->flags = ReadBlobLSBLong(image);",
          "1881:   required=(size_t) (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);",
          "1882:   if ((dds_info->flags & required) != required)",
          "1883:     return MagickFalse;",
          "1885:   dds_info->height = ReadBlobLSBLong(image);",
          "1886:   dds_info->width = ReadBlobLSBLong(image);",
          "1887:   dds_info->pitchOrLinearSize = ReadBlobLSBLong(image);",
          "1888:   dds_info->depth = ReadBlobLSBLong(image);",
          "1889:   dds_info->mipmapcount = ReadBlobLSBLong(image);",
          "1894:   hdr_size = ReadBlobLSBLong(image);",
          "1895:   if (hdr_size != 32)",
          "1896:     return MagickFalse;",
          "1898:   dds_info->pixelformat.flags = ReadBlobLSBLong(image);",
          "1899:   dds_info->pixelformat.fourcc = ReadBlobLSBLong(image);",
          "1900:   dds_info->pixelformat.rgb_bitcount = ReadBlobLSBLong(image);",
          "1901:   dds_info->pixelformat.r_bitmask = ReadBlobLSBLong(image);",
          "1902:   dds_info->pixelformat.g_bitmask = ReadBlobLSBLong(image);",
          "1903:   dds_info->pixelformat.b_bitmask = ReadBlobLSBLong(image);",
          "1904:   dds_info->pixelformat.alpha_bitmask = ReadBlobLSBLong(image);",
          "1906:   dds_info->ddscaps1 = ReadBlobLSBLong(image);",
          "1907:   dds_info->ddscaps2 = ReadBlobLSBLong(image);",
          "1910:   return MagickTrue;",
          "1911: }",
          "1913: static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,",
          "1914:   ExceptionInfo *exception)",
          "1915: {",
          "1916:   DDSColors",
          "1917:     colors;",
          "1919:   register Quantum",
          "1922:   register ssize_t",
          "1923:     i,",
          "1924:     x;",
          "1926:   size_t",
          "1927:     bits;",
          "1929:   ssize_t",
          "1930:     j,",
          "1931:     y;",
          "1933:   unsigned char",
          "1934:     code;",
          "1936:   unsigned short",
          "1937:     c0,",
          "1938:     c1;",
          "1940:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "1941:   {",
          "1942:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "1943:     {",
          "1945:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "1946:         Min(4, dds_info->height - y),exception);",
          "1948:       if (q == (Quantum *) NULL)",
          "1949:         return MagickFalse;",
          "1952:       c0 = ReadBlobLSBShort(image);",
          "1953:       c1 = ReadBlobLSBShort(image);",
          "1954:       bits = ReadBlobLSBLong(image);",
          "1956:       CalculateColors(c0, c1, &colors, MagickFalse);",
          "1959:       for (j = 0; j < 4; j++)",
          "1960:       {",
          "1961:         for (i = 0; i < 4; i++)",
          "1962:         {",
          "1963:           if ((x + i) < (ssize_t) dds_info->width &&",
          "1964:               (y + j) < (ssize_t) dds_info->height)",
          "1965:             {",
          "1966:               code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);",
          "1967:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "1968:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "1969:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "1970:               SetPixelAlpha(image,ScaleCharToQuantum(colors.a[code]),q);",
          "1971:               if (colors.a[code] && (image->alpha_trait != BlendPixelTrait))",
          "1973:               q+=GetPixelChannels(image);",
          "1974:             }",
          "1975:         }",
          "1976:       }",
          "1978:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "1979:         return MagickFalse;",
          "1980:     }",
          "1981:   }",
          "1983:   SkipDXTMipmaps(image, dds_info, 8);",
          "1985:   return MagickTrue;",
          "1986: }",
          "1988: static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,",
          "1989:   ExceptionInfo *exception)",
          "1990: {",
          "1991:   DDSColors",
          "1992:     colors;",
          "1994:   register Quantum",
          "1997:   register ssize_t",
          "1998:     i,",
          "1999:     x;",
          "2001:   unsigned char",
          "2002:     alpha;",
          "2004:   size_t",
          "2005:     a0,",
          "2006:     a1,",
          "2007:     bits,",
          "2008:     code;",
          "2010:   ssize_t",
          "2011:     j,",
          "2012:     y;",
          "2014:   unsigned short",
          "2015:     c0,",
          "2016:     c1;",
          "2018:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2019:   {",
          "2020:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2021:     {",
          "2023:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2024:                          Min(4, dds_info->height - y),exception);",
          "2026:       if (q == (Quantum *) NULL)",
          "2027:         return MagickFalse;",
          "2030:       a0 = ReadBlobLSBLong(image);",
          "2031:       a1 = ReadBlobLSBLong(image);",
          "2034:       c0 = ReadBlobLSBShort(image);",
          "2035:       c1 = ReadBlobLSBShort(image);",
          "2036:       bits = ReadBlobLSBLong(image);",
          "2038:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2041:       for (j = 0; j < 4; j++)",
          "2042:       {",
          "2043:         for (i = 0; i < 4; i++)",
          "2044:         {",
          "2045:           if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)",
          "2046:             {",
          "2047:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2048:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2049:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2050:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2052:                 Extract alpha value: multiply 0..15 by 17 to get range 0..255",
          "2054:               if (j < 2)",
          "2055:                 alpha = 17U * (unsigned char) ((a0 >> (4*(4*j+i))) & 0xf);",
          "2056:               else",
          "2057:                 alpha = 17U * (unsigned char) ((a1 >> (4*(4*(j-2)+i))) & 0xf);",
          "2058:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2059:               q+=GetPixelChannels(image);",
          "2060:             }",
          "2061:         }",
          "2062:       }",
          "2064:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2065:         return MagickFalse;",
          "2066:     }",
          "2067:   }",
          "2069:   SkipDXTMipmaps(image, dds_info, 16);",
          "2071:   return MagickTrue;",
          "2072: }",
          "2074: static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,",
          "2075:   ExceptionInfo *exception)",
          "2076: {",
          "2077:   DDSColors",
          "2078:     colors;",
          "2080:   MagickSizeType",
          "2081:     alpha_bits;",
          "2083:   register Quantum",
          "2086:   register ssize_t",
          "2087:     i,",
          "2088:     x;",
          "2090:   unsigned char",
          "2091:     a0,",
          "2092:     a1;",
          "2094:   size_t",
          "2095:     alpha,",
          "2096:     bits,",
          "2097:     code,",
          "2098:     alpha_code;",
          "2100:   ssize_t",
          "2101:     j,",
          "2102:     y;",
          "2104:   unsigned short",
          "2105:     c0,",
          "2106:     c1;",
          "2108:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2109:   {",
          "2110:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2111:     {",
          "2113:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2114:                          Min(4, dds_info->height - y),exception);",
          "2116:       if (q == (Quantum *) NULL)",
          "2117:         return MagickFalse;",
          "2120:       a0 = (unsigned char) ReadBlobByte(image);",
          "2121:       a1 = (unsigned char) ReadBlobByte(image);",
          "2123:       alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);",
          "2124:       alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);",
          "2127:       c0 = ReadBlobLSBShort(image);",
          "2128:       c1 = ReadBlobLSBShort(image);",
          "2129:       bits = ReadBlobLSBLong(image);",
          "2131:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2134:       for (j = 0; j < 4; j++)",
          "2135:       {",
          "2136:         for (i = 0; i < 4; i++)",
          "2137:         {",
          "2138:           if ((x + i) < (ssize_t) dds_info->width &&",
          "2139:               (y + j) < (ssize_t) dds_info->height)",
          "2140:             {",
          "2141:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2142:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2143:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2144:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2146:               alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;",
          "2147:               if (alpha_code == 0)",
          "2148:                 alpha = a0;",
          "2149:               else if (alpha_code == 1)",
          "2150:                 alpha = a1;",
          "2151:               else if (a0 > a1)",
          "2152:                 alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;",
          "2153:               else if (alpha_code == 6)",
          "2154:                 alpha = 0;",
          "2155:               else if (alpha_code == 7)",
          "2156:                 alpha = 255;",
          "2157:               else",
          "2158:                 alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);",
          "2159:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2160:               q+=GetPixelChannels(image);",
          "2161:             }",
          "2162:         }",
          "2163:       }",
          "2165:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2166:         return MagickFalse;",
          "2167:     }",
          "2168:   }",
          "2170:   SkipDXTMipmaps(image, dds_info, 16);",
          "2172:   return MagickTrue;",
          "2173: }",
          "2175: static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,",
          "2176:   ExceptionInfo *exception)",
          "2177: {",
          "2178:   register Quantum",
          "2181:   ssize_t",
          "2182:     x, y;",
          "2184:   unsigned short",
          "2185:     color;",
          "2187:   if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(",
          "2188:     dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))",
          "2189:     ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2190:       image->filename);",
          "2192:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2193:   {",
          "2194:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2196:     if (q == (Quantum *) NULL)",
          "2197:       return MagickFalse;",
          "2199:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2200:     {",
          "2202:       if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2203:         {",
          "2204:            color=ReadBlobShort(image);",
          "2205:            SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2206:              (((color >> 11)/31.0)*255)),q);",
          "2207:            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2208:              ((((unsigned short)(color << 5) >> 10)/63.0)*255)),q);",
          "2209:            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2210:              ((((unsigned short)(color << 11) >> 11)/31.0)*255)),q);",
          "2211:         }",
          "2212:       else",
          "2213:         {",
          "2214:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2215:             ReadBlobByte(image)),q);",
          "2216:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2217:             ReadBlobByte(image)),q);",
          "2218:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2219:             ReadBlobByte(image)),q);",
          "2220:           if (dds_info->pixelformat.rgb_bitcount == 32)",
          "2221:             (void) ReadBlobByte(image);",
          "2222:         }",
          "2223:       q+=GetPixelChannels(image);",
          "2224:     }",
          "2226:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2227:       return MagickFalse;",
          "2228:   }",
          "2230:   SkipRGBMipmaps(image, dds_info, 3);",
          "2232:   return MagickTrue;",
          "2233: }",
          "2235: static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,",
          "2236:   ExceptionInfo *exception)",
          "2237: {",
          "2238:   register Quantum",
          "2241:   ssize_t",
          "2242:     alphaBits,",
          "2243:     x,",
          "2244:     y;",
          "2246:   unsigned short",
          "2247:     color;",
          "2249:   alphaBits=0;",
          "2250:   if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2251:     {",
          "2252:       if (IsBitMask(dds_info->pixelformat,0x7c00,0x03e0,0x001f,0x8000))",
          "2253:         alphaBits=1;",
          "2254:       else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))",
          "2255:         alphaBits=4;",
          "2256:       else",
          "2257:         ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2258:           image->filename);",
          "2259:     }",
          "2261:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2262:   {",
          "2263:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2265:     if (q == (Quantum *) NULL)",
          "2266:       return MagickFalse;",
          "2268:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2269:     {",
          "2270:       if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2271:         {",
          "2272:            color=ReadBlobShort(image);",
          "2273:            if (alphaBits == 1)",
          "2274:              {",
          "2275:                SetPixelAlpha(image,(color & (1 << 15)) ? QuantumRange : 0,q);",
          "2276:                SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2277:                  ((((unsigned short)(color << 1) >> 11)/31.0)*255)),q);",
          "2278:                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2279:                  ((((unsigned short)(color << 6) >> 11)/31.0)*255)),q);",
          "2280:                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2281:                  ((((unsigned short)(color << 11) >> 11)/31.0)*255)),q);",
          "2282:              }",
          "2283:           else",
          "2284:             {",
          "2285:                SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2286:                  (((color >> 12)/15.0)*255)),q);",
          "2287:                SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2288:                  ((((unsigned short)(color << 4) >> 12)/15.0)*255)),q);",
          "2289:                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2290:                  ((((unsigned short)(color << 8) >> 12)/15.0)*255)),q);",
          "2291:                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2292:                  ((((unsigned short)(color << 12) >> 12)/15.0)*255)),q);",
          "2293:             }",
          "2294:         }",
          "2295:       else",
          "2296:         {",
          "2297:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2298:             ReadBlobByte(image)),q);",
          "2299:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2300:             ReadBlobByte(image)),q);",
          "2301:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2302:             ReadBlobByte(image)),q);",
          "2303:           SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2304:             ReadBlobByte(image)),q);",
          "2305:         }",
          "2306:       q+=GetPixelChannels(image);",
          "2307:     }",
          "2309:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2310:       return MagickFalse;",
          "2311:   }",
          "2313:   SkipRGBMipmaps(image, dds_info, 4);",
          "2315:   return MagickTrue;",
          "2316: }",
          "2320: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2321: %                                                                             %",
          "2322: %                                                                             %",
          "2323: %                                                                             %",
          "2324: %   R e g i s t e r D D S I m a g e                                           %",
          "2325: %                                                                             %",
          "2326: %                                                                             %",
          "2327: %                                                                             %",
          "2328: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2329: %",
          "2330: %  RegisterDDSImage() adds attributes for the DDS image format to",
          "2331: %  the list of supported formats.  The attributes include the image format",
          "2332: %  tag, a method to read and/or write the format, whether the format",
          "2333: %  supports the saving of more than one frame to the same file or blob,",
          "2334: %  whether the format supports native in-memory I/O, and a brief",
          "2335: %  description of the format.",
          "2336: %",
          "2337: %  The format of the RegisterDDSImage method is:",
          "2338: %",
          "2339: %      RegisterDDSImage(void)",
          "2340: %",
          "2342: ModuleExport size_t RegisterDDSImage(void)",
          "2343: {",
          "2344:   MagickInfo",
          "2347:   entry = SetMagickInfo(\"DDS\");",
          "2348:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2349:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2350:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2351:   entry->seekable_stream=MagickTrue;",
          "2352:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2353:   entry->module = ConstantString(\"DDS\");",
          "2354:   (void) RegisterMagickInfo(entry);",
          "2355:   entry = SetMagickInfo(\"DXT1\");",
          "2356:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2357:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2358:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2359:   entry->seekable_stream=MagickTrue;",
          "2360:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2361:   entry->module = ConstantString(\"DDS\");",
          "2362:   (void) RegisterMagickInfo(entry);",
          "2363:   entry = SetMagickInfo(\"DXT5\");",
          "2364:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2365:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2366:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2367:   entry->seekable_stream=MagickTrue;",
          "2368:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2369:   entry->module = ConstantString(\"DDS\");",
          "2370:   (void) RegisterMagickInfo(entry);",
          "2371:   return(MagickImageCoderSignature);",
          "2372: }",
          "2374: static void RemapIndices(const ssize_t *map, const unsigned char *source,",
          "2375:   unsigned char *target)",
          "2376: {",
          "2377:   register ssize_t",
          "2378:     i;",
          "2380:   for (i = 0; i < 16; i++)",
          "2381:   {",
          "2382:     if (map[i] == -1)",
          "2383:       target[i] = 3;",
          "2384:     else",
          "2385:       target[i] = source[map[i]];",
          "2386:   }",
          "2387: }",
          "2390:   Skip the mipmap images for compressed (DXTn) dds files",
          "2392: static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)",
          "2393: {",
          "2394:   MagickOffsetType",
          "2395:     offset;",
          "2397:   register ssize_t",
          "2398:     i;",
          "2400:   size_t",
          "2401:     h,",
          "2402:     w;",
          "2405:     Only skip mipmaps for textures and cube maps",
          "2407:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2408:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2409:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2410:     {",
          "2411:       w = DIV2(dds_info->width);",
          "2412:       h = DIV2(dds_info->height);",
          "2415:         Mipmapcount includes the main image, so start from one",
          "2417:       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2418:       {",
          "2419:         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;",
          "2420:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2422:         w = DIV2(w);",
          "2423:         h = DIV2(h);",
          "2424:       }",
          "2425:     }",
          "2426: }",
          "2429:   Skip the mipmap images for uncompressed (RGB or RGBA) dds files",
          "2431: static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)",
          "2432: {",
          "2433:   MagickOffsetType",
          "2434:     offset;",
          "2436:   register ssize_t",
          "2437:     i;",
          "2439:   size_t",
          "2440:     h,",
          "2441:     w;",
          "2444:     Only skip mipmaps for textures and cube maps",
          "2446:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2447:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2448:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2449:     {",
          "2450:       w = DIV2(dds_info->width);",
          "2451:       h = DIV2(dds_info->height);",
          "2454:         Mipmapcount includes the main image, so start from one",
          "2456:       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2457:       {",
          "2458:         offset = (MagickOffsetType) w * h * pixel_size;",
          "2459:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2461:         w = DIV2(w);",
          "2462:         h = DIV2(h);",
          "2463:       }",
          "2464:     }",
          "2465: }",
          "2469: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2470: %                                                                             %",
          "2471: %                                                                             %",
          "2472: %                                                                             %",
          "2473: %   U n r e g i s t e r D D S I m a g e                                       %",
          "2474: %                                                                             %",
          "2475: %                                                                             %",
          "2476: %                                                                             %",
          "2477: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2478: %",
          "2479: %  UnregisterDDSImage() removes format registrations made by the",
          "2480: %  DDS module from the list of supported formats.",
          "2481: %",
          "2482: %  The format of the UnregisterDDSImage method is:",
          "2483: %",
          "2484: %      UnregisterDDSImage(void)",
          "2485: %",
          "2487: ModuleExport void UnregisterDDSImage(void)",
          "2488: {",
          "2489:   (void) UnregisterMagickInfo(\"DDS\");",
          "2490:   (void) UnregisterMagickInfo(\"DXT1\");",
          "2491:   (void) UnregisterMagickInfo(\"DXT5\");",
          "2492: }",
          "2494: static void WriteAlphas(Image *image, const ssize_t *alphas, size_t min5,",
          "2495:   size_t max5, size_t min7, size_t max7)",
          "2496: {",
          "2497:   register ssize_t",
          "2498:     i;",
          "2500:   size_t",
          "2501:     err5,",
          "2502:     err7,",
          "2503:     j;",
          "2505:   unsigned char",
          "2506:     indices5[16],",
          "2507:     indices7[16];",
          "2509:   FixRange(min5,max5,5);",
          "2510:   err5 = CompressAlpha(min5,max5,5,alphas,indices5);",
          "2512:   FixRange(min7,max7,7);",
          "2513:   err7 = CompressAlpha(min7,max7,7,alphas,indices7);",
          "2515:   if (err7 < err5)",
          "2516:   {",
          "2517:     for (i=0; i < 16; i++)",
          "2518:     {",
          "2519:       unsigned char",
          "2520:         index;",
          "2522:       index = indices7[i];",
          "2523:       if( index == 0 )",
          "2524:         indices5[i] = 1;",
          "2525:       else if (index == 1)",
          "2526:         indices5[i] = 0;",
          "2527:       else",
          "2528:         indices5[i] = 9 - index;",
          "2529:     }",
          "2531:     min5 = max7;",
          "2532:     max5 = min7;",
          "2533:   }",
          "2535:   (void) WriteBlobByte(image,(unsigned char) min5);",
          "2536:   (void) WriteBlobByte(image,(unsigned char) max5);",
          "2538:   for(i=0; i < 2; i++)",
          "2539:   {",
          "2540:     size_t",
          "2541:       value = 0;",
          "2543:     for (j=0; j < 8; j++)",
          "2544:     {",
          "2545:       size_t index = (size_t) indices5[j + i*8];",
          "2546:       value |= ( index << 3*j );",
          "2547:     }",
          "2549:     for (j=0; j < 3; j++)",
          "2550:     {",
          "2551:       size_t byte = (value >> 8*j) & 0xff;",
          "2552:       (void) WriteBlobByte(image,(unsigned char) byte);",
          "2553:     }",
          "2554:   }",
          "2555: }",
          "2557: static void WriteCompressed(Image *image, const size_t count,",
          "2558:   DDSVector4 *points, const ssize_t *map, const MagickBooleanType clusterFit)",
          "2559: {",
          "2560:   float",
          "2561:     covariance[16];",
          "2563:   DDSVector3",
          "2564:     end,",
          "2565:     principle,",
          "2566:     start;",
          "2568:   DDSVector4",
          "2569:     metric;",
          "2571:   unsigned char",
          "2572:     indices[16];",
          "2574:   VectorInit(metric,1.0f);",
          "2575:   VectorInit3(start,0.0f);",
          "2576:   VectorInit3(end,0.0f);",
          "2578:   ComputeWeightedCovariance(count,points,covariance);",
          "2579:   ComputePrincipleComponent(covariance,&principle);",
          "2581:   if (clusterFit == MagickFalse || count == 0)",
          "2582:     CompressRangeFit(count,points,map,principle,metric,&start,&end,indices);",
          "2583:   else",
          "2584:     CompressClusterFit(count,points,map,principle,metric,&start,&end,indices);",
          "2586:   WriteIndices(image,start,end,indices);",
          "2587: }",
          "2590: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2591: %                                                                             %",
          "2592: %                                                                             %",
          "2593: %                                                                             %",
          "2594: %   W r i t e D D S I m a g e                                                 %",
          "2595: %                                                                             %",
          "2596: %                                                                             %",
          "2597: %                                                                             %",
          "2598: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2599: %",
          "2600: %  WriteDDSImage() writes a DirectDraw Surface image file in the DXT5 format.",
          "2601: %",
          "2602: %  The format of the WriteBMPImage method is:",
          "2603: %",
          "2604: %     MagickBooleanType WriteDDSImage(const ImageInfo *image_info,Image *image)",
          "2605: %",
          "2606: %  A description of each parameter follows.",
          "2607: %",
          "2608: %    o image_info: the image info.",
          "2609: %",
          "2610: %    o image:  The image.",
          "2611: %",
          "2613: static MagickBooleanType WriteDDSImage(const ImageInfo *image_info,",
          "2614:   Image *image, ExceptionInfo *exception)",
          "2615: {",
          "2616:   const char",
          "2619:   size_t",
          "2620:     compression,",
          "2621:     columns,",
          "2622:     maxMipmaps,",
          "2623:     mipmaps,",
          "2624:     pixelFormat,",
          "2625:     rows;",
          "2627:   MagickBooleanType",
          "2628:     clusterFit,",
          "2629:     status,",
          "2630:     weightByAlpha;",
          "2632:   assert(image_info != (const ImageInfo *) NULL);",
          "2633:   assert(image_info->signature == MagickSignature);",
          "2634:   assert(image != (Image *) NULL);",
          "2635:   assert(image->signature == MagickSignature);",
          "2636:   if (image->debug != MagickFalse)",
          "2637:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);",
          "2638:   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);",
          "2639:   if (status == MagickFalse)",
          "2640:     return(status);",
          "2641:   (void) TransformImageColorspace(image,sRGBColorspace,exception);",
          "2642:   pixelFormat=DDPF_FOURCC;",
          "2643:   compression=FOURCC_DXT5;",
          "2645:   if (image->alpha_trait != BlendPixelTrait)",
          "2646:     compression=FOURCC_DXT1;",
          "2648:   if (LocaleCompare(image_info->magick,\"dxt1\") == 0)",
          "2649:     compression=FOURCC_DXT1;",
          "2651:   option=GetImageOption(image_info,\"dds:compression\");",
          "2652:   if (option != (char *) NULL)",
          "2653:     {",
          "2654:        if (LocaleCompare(option,\"dxt1\") == 0)",
          "2655:          compression=FOURCC_DXT1;",
          "2656:        if (LocaleCompare(option,\"none\") == 0)",
          "2657:          pixelFormat=DDPF_RGB;",
          "2658:     }",
          "2660:   clusterFit=MagickFalse;",
          "2661:   weightByAlpha=MagickFalse;",
          "2663:   if (pixelFormat == DDPF_FOURCC)",
          "2664:     {",
          "2665:       option=GetImageOption(image_info,\"dds:cluster-fit\");",
          "2666:       if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2667:         {",
          "2668:           clusterFit=MagickTrue;",
          "2669:           if (compression != FOURCC_DXT1)",
          "2670:             {",
          "2671:               option=GetImageOption(image_info,\"dds:weight-by-alpha\");",
          "2672:               if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2673:                 weightByAlpha=MagickTrue;",
          "2674:             }",
          "2675:         }",
          "2676:     }",
          "2678:   maxMipmaps=SIZE_MAX;",
          "2679:   mipmaps=0;",
          "2680:   if ((image->columns & (image->columns - 1)) == 0 &&",
          "2681:       (image->rows & (image->rows - 1)) == 0)",
          "2682:     {",
          "2683:       option=GetImageOption(image_info,\"dds:mipmaps\");",
          "2684:       if (option != (char *) NULL)",
          "2685:         maxMipmaps=StringToUnsignedLong(option);",
          "2687:       if (maxMipmaps != 0)",
          "2688:         {",
          "2689:           columns=image->columns;",
          "2690:           rows=image->rows;",
          "2691:           while (columns != 1 && rows != 1 && mipmaps != maxMipmaps)",
          "2692:           {",
          "2693:             columns=DIV2(columns);",
          "2694:             rows=DIV2(rows);",
          "2695:             mipmaps++;",
          "2696:           }",
          "2697:         }",
          "2698:     }",
          "2700:   WriteDDSInfo(image,pixelFormat,compression,mipmaps);",
          "2702:   WriteImageData(image,pixelFormat,compression,clusterFit,weightByAlpha,",
          "2703:     exception);",
          "2705:   if (mipmaps > 0 && WriteMipmaps(image,pixelFormat,compression,mipmaps,",
          "2706:         clusterFit,weightByAlpha,exception) == MagickFalse)",
          "2707:     return(MagickFalse);",
          "2709:   (void) CloseBlob(image);",
          "2710:   return(MagickTrue);",
          "2711: }",
          "2713: static void WriteDDSInfo(Image *image, const size_t pixelFormat,",
          "2714:   const size_t compression, const size_t mipmaps)",
          "2715: {",
          "2716:   char",
          "2717:     software[MaxTextExtent];",
          "2719:   register ssize_t",
          "2720:     i;",
          "2722:   unsigned int",
          "2723:     format,",
          "2724:     caps,",
          "2725:     flags;",
          "2727:   flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |",
          "2728:     DDSD_PIXELFORMAT | DDSD_LINEARSIZE);",
          "2729:   caps=(unsigned int) DDSCAPS_TEXTURE;",
          "2730:   format=(unsigned int) pixelFormat;",
          "2732:   if (mipmaps > 0)",
          "2733:     {",
          "2734:       flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;",
          "2735:       caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);",
          "2736:     }",
          "2738:   if (format != DDPF_FOURCC && image->alpha_trait == BlendPixelTrait)",
          "2739:     format=format | DDPF_ALPHAPIXELS;",
          "2741:   (void) WriteBlob(image,4,(unsigned char *) \"DDS \");",
          "2742:   (void) WriteBlobLSBLong(image,124);",
          "2743:   (void) WriteBlobLSBLong(image,flags);",
          "2744:   (void) WriteBlobLSBLong(image,image->rows);",
          "2745:   (void) WriteBlobLSBLong(image,image->columns);",
          "2747:   if (compression == FOURCC_DXT1)",
          "2748:     (void) WriteBlobLSBLong(image,",
          "2749:              (unsigned int) (Max(1,(image->columns+3)/4) * 8));",
          "2750:   else",
          "2751:     (void) WriteBlobLSBLong(image,",
          "2752:              (unsigned int) (Max(1,(image->columns+3)/4) * 16));",
          "2754:   (void) WriteBlobLSBLong(image,0x00);",
          "2755:   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);",
          "2756:   (void) ResetMagickMemory(software,0,sizeof(software));",
          "2757:   (void) strcpy(software,\"IMAGEMAGICK\");",
          "2758:   (void) WriteBlob(image,44,(unsigned char *) software);",
          "2760:   (void) WriteBlobLSBLong(image,32);",
          "2761:   (void) WriteBlobLSBLong(image,format);",
          "2763:   if (pixelFormat == DDPF_FOURCC)",
          "2764:     {",
          "2765:       (void) WriteBlobLSBLong(image,(unsigned int) compression);",
          "2766:       for(i=0;i < 5;i++) // bitcount / masks",
          "2767:         (void) WriteBlobLSBLong(image,0x00);",
          "2768:     }",
          "2769:   else",
          "2770:     {",
          "2771:       (void) WriteBlobLSBLong(image,0x00);",
          "2772:       if (image->alpha_trait == BlendPixelTrait)",
          "2773:         {",
          "2774:           (void) WriteBlobLSBLong(image,32);",
          "2775:           (void) WriteBlobLSBLong(image,0xff0000);",
          "2776:           (void) WriteBlobLSBLong(image,0xff00);",
          "2777:           (void) WriteBlobLSBLong(image,0xff);",
          "2778:           (void) WriteBlobLSBLong(image,0xff000000);",
          "2779:         }",
          "2780:       else",
          "2781:         {",
          "2782:           (void) WriteBlobLSBLong(image,24);",
          "2783:           (void) WriteBlobLSBLong(image,0xff);",
          "2784:           (void) WriteBlobLSBLong(image,0x00);",
          "2785:           (void) WriteBlobLSBLong(image,0x00);",
          "2786:           (void) WriteBlobLSBLong(image,0x00);",
          "2787:         }",
          "2788:     }",
          "2790:   (void) WriteBlobLSBLong(image,caps);",
          "2791:   for(i=0;i < 4;i++) // ddscaps2 + reserved region",
          "2792:     (void) WriteBlobLSBLong(image,0x00);",
          "2793: }",
          "2795: static void WriteFourCC(Image *image, const size_t compression,",
          "2796:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "2797:   ExceptionInfo *exception)",
          "2798: {",
          "2799:   register ssize_t",
          "2800:     x;",
          "2802:   ssize_t",
          "2803:     i,",
          "2804:     y,",
          "2805:     bx,",
          "2806:     by;",
          "2808:   register const Quantum",
          "2811:   for (y=0; y < (ssize_t) image->rows; y+=4)",
          "2812:   {",
          "2813:     for (x=0; x < (ssize_t) image->columns; x+=4)",
          "2814:     {",
          "2815:       MagickBooleanType",
          "2816:         match;",
          "2818:       DDSVector4",
          "2819:         point,",
          "2820:         points[16];",
          "2822:       size_t",
          "2823:         count = 0,",
          "2824:         max5 = 0,",
          "2825:         max7 = 0,",
          "2826:         min5 = 255,",
          "2827:         min7 = 255,",
          "2828:         columns = 4,",
          "2829:         rows = 4;",
          "2831:       ssize_t",
          "2832:         alphas[16],",
          "2833:         map[16];",
          "2835:       unsigned char",
          "2836:         alpha;",
          "2838:       if (x + columns >= image->columns)",
          "2839:         columns = image->columns - x;",
          "2841:       if (y + rows >= image->rows)",
          "2842:         rows = image->rows - y;",
          "2844:       p=GetVirtualPixels(image,x,y,columns,rows,exception);",
          "2845:       if (p == (const Quantum *) NULL)",
          "2846:         break;",
          "2848:       for (i=0; i<16; i++)",
          "2849:       {",
          "2850:         map[i] = -1;",
          "2851:         alphas[i] = -1;",
          "2852:       }",
          "2854:       for (by=0; by <  (ssize_t) rows; by++)",
          "2855:       {",
          "2856:         for (bx=0; bx <  (ssize_t) columns; bx++)",
          "2857:         {",
          "2858:           if (compression == FOURCC_DXT5)",
          "2859:             alpha = ScaleQuantumToChar(GetPixelAlpha(image,p));",
          "2860:           else",
          "2861:             alpha = 255;",
          "2863:           alphas[4*by + bx] = (size_t)alpha;",
          "2865:           point.x = (float)ScaleQuantumToChar(GetPixelRed(image,p)) / 255.0f;",
          "2866:           point.y = (float)ScaleQuantumToChar(GetPixelGreen(image,p)) / 255.0f;",
          "2867:           point.z = (float)ScaleQuantumToChar(GetPixelBlue(image,p)) / 255.0f;",
          "2868:           point.w = weightByAlpha ? (float)(alpha + 1) / 256.0f : 1.0f;",
          "2869:           p+=GetPixelChannels(image);",
          "2871:           match = MagickFalse;",
          "2872:           for (i=0; i <  (ssize_t) count; i++)",
          "2873:           {",
          "2874:             if ((points[i].x == point.x) &&",
          "2875:                 (points[i].y == point.y) &&",
          "2876:                 (points[i].z == point.z) &&",
          "2877:                 (alpha       >= 128 || compression == FOURCC_DXT5))",
          "2878:               {",
          "2879:                 points[i].w += point.w;",
          "2880:                 map[4*by + bx] = i;",
          "2881:                 match = MagickTrue;",
          "2882:                 break;",
          "2883:               }",
          "2884:             }",
          "2886:             if (match != MagickFalse)",
          "2887:               continue;",
          "2889:             points[count].x = point.x;",
          "2890:             points[count].y = point.y;",
          "2891:             points[count].z = point.z;",
          "2892:             points[count].w = point.w;",
          "2893:             map[4*by + bx] = count;",
          "2894:             count++;",
          "2896:             if (compression == FOURCC_DXT5)",
          "2897:               {",
          "2898:                 if (alpha < min7)",
          "2899:                   min7 = alpha;",
          "2900:                 if (alpha > max7)",
          "2901:                   max7 = alpha;",
          "2902:                 if (alpha != 0 && alpha < min5)",
          "2903:                   min5 = alpha;",
          "2904:                 if (alpha != 255 && alpha > max5)",
          "2905:                   max5 = alpha;",
          "2906:               }",
          "2907:           }",
          "2908:         }",
          "2910:       for (i=0; i <  (ssize_t) count; i++)",
          "2911:         points[i].w = sqrt(points[i].w);",
          "2913:       if (compression == FOURCC_DXT5)",
          "2914:         WriteAlphas(image,alphas,min5,max5,min7,max7);",
          "2916:       if (count == 1)",
          "2917:         WriteSingleColorFit(image,points,map);",
          "2918:       else",
          "2919:         WriteCompressed(image,count,points,map,clusterFit);",
          "2920:     }",
          "2921:   }",
          "2922: }",
          "2924: static void WriteImageData(Image *image, const size_t pixelFormat,",
          "2925:   const size_t compression,const MagickBooleanType clusterFit,",
          "2926:   const MagickBooleanType weightByAlpha, ExceptionInfo *exception)",
          "2927: {",
          "2928:   if (pixelFormat == DDPF_FOURCC)",
          "2929:     WriteFourCC(image,compression,clusterFit,weightByAlpha,exception);",
          "2930:   else",
          "2931:     WriteUncompressed(image,exception);",
          "2932: }",
          "2934: static inline size_t ClampToLimit(const float value, const size_t limit)",
          "2935: {",
          "2936:   size_t",
          "2937:     result = (int) (value + 0.5f);",
          "2939:   if (result < 0.0f)",
          "2940:     return(0);",
          "2941:   if (result > limit)",
          "2942:     return(limit);",
          "2943:   return result;",
          "2944: }",
          "2946: static inline size_t ColorTo565(const DDSVector3 point)",
          "2947: {",
          "2948:   size_t r = ClampToLimit(31.0f*point.x,31);",
          "2949:   size_t g = ClampToLimit(63.0f*point.y,63);",
          "2950:   size_t b = ClampToLimit(31.0f*point.z,31);",
          "2952:   return (r << 11) | (g << 5) | b;",
          "2953: }",
          "2955: static void WriteIndices(Image *image, const DDSVector3 start,",
          "2956:   const DDSVector3 end, unsigned char *indices)",
          "2957: {",
          "2958:   register ssize_t",
          "2959:     i;",
          "2961:   size_t",
          "2962:     a,",
          "2963:     b;",
          "2965:   unsigned char",
          "2966:     remapped[16];",
          "2968:   const unsigned char",
          "2971:   a = ColorTo565(start);",
          "2972:   b = ColorTo565(end);",
          "2974:   for (i=0; i<16; i++)",
          "2975:   {",
          "2976:     if( a < b )",
          "2977:       remapped[i] = (indices[i] ^ 0x1) & 0x3;",
          "2978:     else if( a == b )",
          "2979:       remapped[i] = 0;",
          "2980:     else",
          "2981:       remapped[i] = indices[i];",
          "2982:   }",
          "2984:   if( a < b )",
          "2985:     Swap(a,b);",
          "2987:   (void) WriteBlobByte(image,(unsigned char) (a & 0xff));",
          "2988:   (void) WriteBlobByte(image,(unsigned char) (a >> 8));",
          "2989:   (void) WriteBlobByte(image,(unsigned char) (b & 0xff));",
          "2990:   (void) WriteBlobByte(image,(unsigned char) (b >> 8));",
          "2992:   for (i=0; i<4; i++)",
          "2993:   {",
          "2994:      ind = remapped + 4*i;",
          "2995:      (void) WriteBlobByte(image,ind[0] | (ind[1] << 2) | (ind[2] << 4) |",
          "2996:        (ind[3] << 6));",
          "2997:   }",
          "2998: }",
          "3000: static MagickBooleanType WriteMipmaps(Image *image, const size_t pixelFormat,",
          "3001:   const size_t compression, const size_t mipmaps,",
          "3002:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "3003:   ExceptionInfo *exception)",
          "3004: {",
          "3005:   Image*",
          "3006:     resize_image;",
          "3008:   register ssize_t",
          "3009:     i;",
          "3011:   size_t",
          "3012:     columns,",
          "3013:     rows;",
          "3015:   columns = image->columns;",
          "3016:   rows = image->rows;",
          "3018:   for (i=0; i< (ssize_t) mipmaps; i++)",
          "3019:   {",
          "3020:     resize_image = ResizeImage(image,columns/2,rows/2,TriangleFilter,",
          "3021:       exception);",
          "3023:     if (resize_image == (Image *) NULL)",
          "3024:       return(MagickFalse);",
          "3026:     DestroyBlob(resize_image);",
          "3027:     resize_image->blob=ReferenceBlob(image->blob);",
          "3029:     WriteImageData(resize_image,pixelFormat,compression,weightByAlpha,",
          "3030:       clusterFit,exception);",
          "3032:     resize_image=DestroyImage(resize_image);",
          "3034:     columns = DIV2(columns);",
          "3035:     rows = DIV2(rows);",
          "3036:   }",
          "3038:   return(MagickTrue);",
          "3039: }",
          "3041: static void WriteSingleColorFit(Image *image, const DDSVector4 *points,",
          "3042:   const ssize_t *map)",
          "3043: {",
          "3044:   DDSVector3",
          "3045:     start,",
          "3046:     end;",
          "3048:   register ssize_t",
          "3049:     i;",
          "3051:   unsigned char",
          "3052:     color[3],",
          "3053:     index,",
          "3054:     indexes[16],",
          "3055:     indices[16];",
          "3057:   color[0] = (unsigned char) ClampToLimit(255.0f*points->x,255);",
          "3058:   color[1] = (unsigned char) ClampToLimit(255.0f*points->y,255);",
          "3059:   color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);",
          "3061:   index=0;",
          "3062:   ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);",
          "3064:   for (i=0; i< 16; i++)",
          "3065:     indexes[i]=index;",
          "3066:   RemapIndices(map,indexes,indices);",
          "3067:   WriteIndices(image,start,end,indices);",
          "3068: }",
          "3070: static void WriteUncompressed(Image *image, ExceptionInfo *exception)",
          "3071: {",
          "3072:   register const Quantum",
          "3075:   register ssize_t",
          "3076:     x;",
          "3078:   ssize_t",
          "3079:     y;",
          "3081:   for (y=0; y < (ssize_t) image->rows; y++)",
          "3082:   {",
          "3083:     p=GetVirtualPixels(image,0,y,image->columns,1,exception);",
          "3084:     if (p == (const Quantum *) NULL)",
          "3085:       break;",
          "3087:     for (x=0; x < (ssize_t) image->columns; x++)",
          "3088:     {",
          "3089:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(image,p)));",
          "3090:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(image,p)));",
          "3091:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(image,p)));",
          "3092:       if (image->alpha_trait == BlendPixelTrait)",
          "3093:         (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));",
          "3094:       p+=GetPixelChannels(image);",
          "3095:     }",
          "3096:   }",
          "3097: }",
          "",
          "[Added Lines]",
          "6: %                            DDDD   DDDD   SSSSS                              %",
          "7: %                            D   D  D   D  SS                                 %",
          "8: %                            D   D  D   D   SSS                               %",
          "9: %                            D   D  D   D     SS                              %",
          "10: %                            DDDD   DDDD   SSSSS                              %",
          "11: %                                                                             %",
          "12: %                                                                             %",
          "13: %           Read/Write Microsoft Direct Draw Surface Image Format             %",
          "14: %                                                                             %",
          "15: %                              Software Design                                %",
          "16: %                             Bianca van Schaik                               %",
          "17: %                                March 2008                                   %",
          "18: %                               Dirk Lemstra                                  %",
          "19: %                              September 2013                                 %",
          "20: %                                                                             %",
          "21: %                                                                             %",
          "22: %  Copyright 1999-2014 ImageMagick Studio LLC, a non-profit organization      %",
          "23: %  dedicated to making software imaging solutions freely available.           %",
          "24: %                                                                             %",
          "25: %  You may not use this file except in compliance with the License.  You may  %",
          "26: %  obtain a copy of the License at                                            %",
          "27: %                                                                             %",
          "28: %    http://www.imagemagick.org/script/license.php                            %",
          "29: %                                                                             %",
          "30: %  Unless required by applicable law or agreed to in writing, software        %",
          "31: %  distributed under the License is distributed on an \"AS IS\" BASIS,          %",
          "32: %  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %",
          "33: %  See the License for the specific language governing permissions and        %",
          "34: %  limitations under the License.                                             %",
          "35: %                                                                             %",
          "36: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "37: %",
          "38: %",
          "43:   Include declarations.",
          "45: #include \"MagickCore/studio.h\"",
          "46: #include \"MagickCore/blob.h\"",
          "47: #include \"MagickCore/blob-private.h\"",
          "48: #include \"MagickCore/cache.h\"",
          "49: #include \"MagickCore/colorspace.h\"",
          "50: #include \"MagickCore/exception.h\"",
          "51: #include \"MagickCore/exception-private.h\"",
          "52: #include \"MagickCore/image.h\"",
          "53: #include \"MagickCore/image-private.h\"",
          "54: #include \"MagickCore/list.h\"",
          "55: #include \"MagickCore/log.h\"",
          "56: #include \"MagickCore/magick.h\"",
          "57: #include \"MagickCore/memory_.h\"",
          "58: #include \"MagickCore/monitor.h\"",
          "59: #include \"MagickCore/monitor-private.h\"",
          "60: #include \"MagickCore/profile.h\"",
          "61: #include \"MagickCore/quantum-private.h\"",
          "62: #include \"MagickCore/static.h\"",
          "63: #include \"MagickCore/string_.h\"",
          "64: #include \"MagickCore/module.h\"",
          "65: #include \"MagickCore/transform.h\"",
          "66: #include \"MagickCore/studio.h\"",
          "67: #include \"MagickCore/blob.h\"",
          "68: #include \"MagickCore/blob-private.h\"",
          "69: #include \"MagickCore/colorspace.h\"",
          "70: #include \"MagickCore/colorspace-private.h\"",
          "71: #include \"MagickCore/exception.h\"",
          "72: #include \"MagickCore/exception-private.h\"",
          "73: #include \"MagickCore/compress.h\"",
          "74: #include \"MagickCore/image.h\"",
          "75: #include \"MagickCore/image-private.h\"",
          "76: #include \"MagickCore/list.h\"",
          "77: #include \"MagickCore/magick.h\"",
          "78: #include \"MagickCore/memory_.h\"",
          "79: #include \"MagickCore/monitor.h\"",
          "80: #include \"MagickCore/monitor-private.h\"",
          "81: #include \"MagickCore/option.h\"",
          "82: #include \"MagickCore/pixel-accessor.h\"",
          "83: #include \"MagickCore/quantum.h\"",
          "84: #include \"MagickCore/static.h\"",
          "85: #include \"MagickCore/string_.h\"",
          "86: #include \"MagickCore/string-private.h\"",
          "90:   Definitions",
          "92: #define DDSD_CAPS         0x00000001",
          "93: #define DDSD_HEIGHT       0x00000002",
          "94: #define DDSD_WIDTH        0x00000004",
          "95: #define DDSD_PITCH        0x00000008",
          "96: #define DDSD_PIXELFORMAT  0x00001000",
          "97: #define DDSD_MIPMAPCOUNT  0x00020000",
          "98: #define DDSD_LINEARSIZE   0x00080000",
          "99: #define DDSD_DEPTH        0x00800000",
          "101: #define DDPF_ALPHAPIXELS  0x00000001",
          "102: #define DDPF_FOURCC       0x00000004",
          "103: #define DDPF_RGB          0x00000040",
          "105: #define FOURCC_DXT1       0x31545844",
          "106: #define FOURCC_DXT3       0x33545844",
          "107: #define FOURCC_DXT5       0x35545844",
          "109: #define DDSCAPS_COMPLEX   0x00000008",
          "110: #define DDSCAPS_TEXTURE   0x00001000",
          "111: #define DDSCAPS_MIPMAP    0x00400000",
          "113: #define DDSCAPS2_CUBEMAP  0x00000200",
          "114: #define DDSCAPS2_CUBEMAP_POSITIVEX  0x00000400",
          "115: #define DDSCAPS2_CUBEMAP_NEGATIVEX  0x00000800",
          "116: #define DDSCAPS2_CUBEMAP_POSITIVEY  0x00001000",
          "117: #define DDSCAPS2_CUBEMAP_NEGATIVEY  0x00002000",
          "118: #define DDSCAPS2_CUBEMAP_POSITIVEZ  0x00004000",
          "119: #define DDSCAPS2_CUBEMAP_NEGATIVEZ  0x00008000",
          "120: #define DDSCAPS2_VOLUME   0x00200000",
          "122: #ifndef SIZE_MAX",
          "123: #define SIZE_MAX ((size_t) -1)",
          "124: #endif",
          "127:   Structure declarations.",
          "129: typedef struct _DDSPixelFormat",
          "130: {",
          "131:   size_t",
          "132:     flags,",
          "133:     fourcc,",
          "134:     rgb_bitcount,",
          "135:     r_bitmask,",
          "136:     g_bitmask,",
          "137:     b_bitmask,",
          "138:     alpha_bitmask;",
          "139: } DDSPixelFormat;",
          "141: typedef struct _DDSInfo",
          "142: {",
          "143:   size_t",
          "144:     flags,",
          "145:     height,",
          "146:     width,",
          "147:     pitchOrLinearSize,",
          "148:     depth,",
          "149:     mipmapcount,",
          "150:     ddscaps1,",
          "151:     ddscaps2;",
          "153:   DDSPixelFormat",
          "154:     pixelformat;",
          "155: } DDSInfo;",
          "157: typedef struct _DDSColors",
          "158: {",
          "159:   unsigned char",
          "160:     r[4],",
          "161:     g[4],",
          "162:     b[4],",
          "163:     a[4];",
          "164: } DDSColors;",
          "166: typedef struct _DDSVector4",
          "167: {",
          "168:   float",
          "169:     x,",
          "170:     y,",
          "171:     z,",
          "172:     w;",
          "173: } DDSVector4;",
          "175: typedef struct _DDSVector3",
          "176: {",
          "177:   float",
          "178:     x,",
          "179:     y,",
          "180:     z;",
          "181: } DDSVector3;",
          "183: typedef struct _DDSSourceBlock",
          "184: {",
          "185:   unsigned char",
          "186:     start,",
          "187:     end,",
          "188:     error;",
          "189: } DDSSourceBlock;",
          "191: typedef struct _DDSSingleColourLookup",
          "192: {",
          "193:   DDSSourceBlock sources[2];",
          "194: } DDSSingleColourLookup;",
          "196: typedef MagickBooleanType",
          "197:   DDSDecoder(Image *, DDSInfo *, ExceptionInfo *);",
          "199: static const DDSSingleColourLookup DDSLookup_5_4[] =",
          "200: {",
          "201:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "202:   { { { 0, 0, 1 }, { 0, 1, 1 } } },",
          "203:   { { { 0, 0, 2 }, { 0, 1, 0 } } },",
          "204:   { { { 0, 0, 3 }, { 0, 1, 1 } } },",
          "205:   { { { 0, 0, 4 }, { 0, 2, 1 } } },",
          "206:   { { { 1, 0, 3 }, { 0, 2, 0 } } },",
          "207:   { { { 1, 0, 2 }, { 0, 2, 1 } } },",
          "208:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "209:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "210:   { { { 1, 0, 1 }, { 1, 2, 1 } } },",
          "211:   { { { 1, 0, 2 }, { 1, 2, 0 } } },",
          "212:   { { { 1, 0, 3 }, { 0, 4, 0 } } },",
          "213:   { { { 1, 0, 4 }, { 0, 5, 1 } } },",
          "214:   { { { 2, 0, 3 }, { 0, 5, 0 } } },",
          "215:   { { { 2, 0, 2 }, { 0, 5, 1 } } },",
          "216:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "217:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "218:   { { { 2, 0, 1 }, { 2, 3, 1 } } },",
          "219:   { { { 2, 0, 2 }, { 2, 3, 0 } } },",
          "220:   { { { 2, 0, 3 }, { 0, 7, 0 } } },",
          "221:   { { { 2, 0, 4 }, { 1, 6, 1 } } },",
          "222:   { { { 3, 0, 3 }, { 1, 6, 0 } } },",
          "223:   { { { 3, 0, 2 }, { 0, 8, 0 } } },",
          "224:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "225:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "226:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "227:   { { { 3, 0, 2 }, { 0, 10, 1 } } },",
          "228:   { { { 3, 0, 3 }, { 0, 10, 0 } } },",
          "229:   { { { 3, 0, 4 }, { 2, 7, 1 } } },",
          "230:   { { { 4, 0, 4 }, { 2, 7, 0 } } },",
          "231:   { { { 4, 0, 3 }, { 0, 11, 0 } } },",
          "232:   { { { 4, 0, 2 }, { 1, 10, 1 } } },",
          "233:   { { { 4, 0, 1 }, { 1, 10, 0 } } },",
          "234:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "235:   { { { 4, 0, 1 }, { 0, 13, 1 } } },",
          "236:   { { { 4, 0, 2 }, { 0, 13, 0 } } },",
          "237:   { { { 4, 0, 3 }, { 0, 13, 1 } } },",
          "238:   { { { 4, 0, 4 }, { 0, 14, 1 } } },",
          "239:   { { { 5, 0, 3 }, { 0, 14, 0 } } },",
          "240:   { { { 5, 0, 2 }, { 2, 11, 1 } } },",
          "241:   { { { 5, 0, 1 }, { 2, 11, 0 } } },",
          "242:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "243:   { { { 5, 0, 1 }, { 1, 14, 1 } } },",
          "244:   { { { 5, 0, 2 }, { 1, 14, 0 } } },",
          "245:   { { { 5, 0, 3 }, { 0, 16, 0 } } },",
          "246:   { { { 5, 0, 4 }, { 0, 17, 1 } } },",
          "247:   { { { 6, 0, 3 }, { 0, 17, 0 } } },",
          "248:   { { { 6, 0, 2 }, { 0, 17, 1 } } },",
          "249:   { { { 6, 0, 1 }, { 0, 18, 1 } } },",
          "250:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "251:   { { { 6, 0, 1 }, { 2, 15, 1 } } },",
          "252:   { { { 6, 0, 2 }, { 2, 15, 0 } } },",
          "253:   { { { 6, 0, 3 }, { 0, 19, 0 } } },",
          "254:   { { { 6, 0, 4 }, { 1, 18, 1 } } },",
          "255:   { { { 7, 0, 3 }, { 1, 18, 0 } } },",
          "256:   { { { 7, 0, 2 }, { 0, 20, 0 } } },",
          "257:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "258:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "259:   { { { 7, 0, 1 }, { 0, 21, 1 } } },",
          "260:   { { { 7, 0, 2 }, { 0, 22, 1 } } },",
          "261:   { { { 7, 0, 3 }, { 0, 22, 0 } } },",
          "262:   { { { 7, 0, 4 }, { 2, 19, 1 } } },",
          "263:   { { { 8, 0, 4 }, { 2, 19, 0 } } },",
          "264:   { { { 8, 0, 3 }, { 0, 23, 0 } } },",
          "265:   { { { 8, 0, 2 }, { 1, 22, 1 } } },",
          "266:   { { { 8, 0, 1 }, { 1, 22, 0 } } },",
          "267:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "268:   { { { 8, 0, 1 }, { 0, 25, 1 } } },",
          "269:   { { { 8, 0, 2 }, { 0, 25, 0 } } },",
          "270:   { { { 8, 0, 3 }, { 0, 25, 1 } } },",
          "271:   { { { 8, 0, 4 }, { 0, 26, 1 } } },",
          "272:   { { { 9, 0, 3 }, { 0, 26, 0 } } },",
          "273:   { { { 9, 0, 2 }, { 2, 23, 1 } } },",
          "274:   { { { 9, 0, 1 }, { 2, 23, 0 } } },",
          "275:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "276:   { { { 9, 0, 1 }, { 1, 26, 1 } } },",
          "277:   { { { 9, 0, 2 }, { 1, 26, 0 } } },",
          "278:   { { { 9, 0, 3 }, { 0, 28, 0 } } },",
          "279:   { { { 9, 0, 4 }, { 0, 29, 1 } } },",
          "280:   { { { 10, 0, 3 }, { 0, 29, 0 } } },",
          "281:   { { { 10, 0, 2 }, { 0, 29, 1 } } },",
          "282:   { { { 10, 0, 1 }, { 0, 30, 1 } } },",
          "283:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "284:   { { { 10, 0, 1 }, { 2, 27, 1 } } },",
          "285:   { { { 10, 0, 2 }, { 2, 27, 0 } } },",
          "286:   { { { 10, 0, 3 }, { 0, 31, 0 } } },",
          "287:   { { { 10, 0, 4 }, { 1, 30, 1 } } },",
          "288:   { { { 11, 0, 3 }, { 1, 30, 0 } } },",
          "289:   { { { 11, 0, 2 }, { 4, 24, 0 } } },",
          "290:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "291:   { { { 11, 0, 0 }, { 1, 31, 0 } } },",
          "292:   { { { 11, 0, 1 }, { 1, 31, 1 } } },",
          "293:   { { { 11, 0, 2 }, { 2, 30, 1 } } },",
          "294:   { { { 11, 0, 3 }, { 2, 30, 0 } } },",
          "295:   { { { 11, 0, 4 }, { 2, 31, 1 } } },",
          "296:   { { { 12, 0, 4 }, { 2, 31, 0 } } },",
          "297:   { { { 12, 0, 3 }, { 4, 27, 0 } } },",
          "298:   { { { 12, 0, 2 }, { 3, 30, 1 } } },",
          "299:   { { { 12, 0, 1 }, { 3, 30, 0 } } },",
          "300:   { { { 12, 0, 0 }, { 4, 28, 0 } } },",
          "301:   { { { 12, 0, 1 }, { 3, 31, 1 } } },",
          "302:   { { { 12, 0, 2 }, { 3, 31, 0 } } },",
          "303:   { { { 12, 0, 3 }, { 3, 31, 1 } } },",
          "304:   { { { 12, 0, 4 }, { 4, 30, 1 } } },",
          "305:   { { { 13, 0, 3 }, { 4, 30, 0 } } },",
          "306:   { { { 13, 0, 2 }, { 6, 27, 1 } } },",
          "307:   { { { 13, 0, 1 }, { 6, 27, 0 } } },",
          "308:   { { { 13, 0, 0 }, { 4, 31, 0 } } },",
          "309:   { { { 13, 0, 1 }, { 5, 30, 1 } } },",
          "310:   { { { 13, 0, 2 }, { 5, 30, 0 } } },",
          "311:   { { { 13, 0, 3 }, { 8, 24, 0 } } },",
          "312:   { { { 13, 0, 4 }, { 5, 31, 1 } } },",
          "313:   { { { 14, 0, 3 }, { 5, 31, 0 } } },",
          "314:   { { { 14, 0, 2 }, { 5, 31, 1 } } },",
          "315:   { { { 14, 0, 1 }, { 6, 30, 1 } } },",
          "316:   { { { 14, 0, 0 }, { 6, 30, 0 } } },",
          "317:   { { { 14, 0, 1 }, { 6, 31, 1 } } },",
          "318:   { { { 14, 0, 2 }, { 6, 31, 0 } } },",
          "319:   { { { 14, 0, 3 }, { 8, 27, 0 } } },",
          "320:   { { { 14, 0, 4 }, { 7, 30, 1 } } },",
          "321:   { { { 15, 0, 3 }, { 7, 30, 0 } } },",
          "322:   { { { 15, 0, 2 }, { 8, 28, 0 } } },",
          "323:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "324:   { { { 15, 0, 0 }, { 7, 31, 0 } } },",
          "325:   { { { 15, 0, 1 }, { 7, 31, 1 } } },",
          "326:   { { { 15, 0, 2 }, { 8, 30, 1 } } },",
          "327:   { { { 15, 0, 3 }, { 8, 30, 0 } } },",
          "328:   { { { 15, 0, 4 }, { 10, 27, 1 } } },",
          "329:   { { { 16, 0, 4 }, { 10, 27, 0 } } },",
          "330:   { { { 16, 0, 3 }, { 8, 31, 0 } } },",
          "331:   { { { 16, 0, 2 }, { 9, 30, 1 } } },",
          "332:   { { { 16, 0, 1 }, { 9, 30, 0 } } },",
          "333:   { { { 16, 0, 0 }, { 12, 24, 0 } } },",
          "334:   { { { 16, 0, 1 }, { 9, 31, 1 } } },",
          "335:   { { { 16, 0, 2 }, { 9, 31, 0 } } },",
          "336:   { { { 16, 0, 3 }, { 9, 31, 1 } } },",
          "337:   { { { 16, 0, 4 }, { 10, 30, 1 } } },",
          "338:   { { { 17, 0, 3 }, { 10, 30, 0 } } },",
          "339:   { { { 17, 0, 2 }, { 10, 31, 1 } } },",
          "340:   { { { 17, 0, 1 }, { 10, 31, 0 } } },",
          "341:   { { { 17, 0, 0 }, { 12, 27, 0 } } },",
          "342:   { { { 17, 0, 1 }, { 11, 30, 1 } } },",
          "343:   { { { 17, 0, 2 }, { 11, 30, 0 } } },",
          "344:   { { { 17, 0, 3 }, { 12, 28, 0 } } },",
          "345:   { { { 17, 0, 4 }, { 11, 31, 1 } } },",
          "346:   { { { 18, 0, 3 }, { 11, 31, 0 } } },",
          "347:   { { { 18, 0, 2 }, { 11, 31, 1 } } },",
          "348:   { { { 18, 0, 1 }, { 12, 30, 1 } } },",
          "349:   { { { 18, 0, 0 }, { 12, 30, 0 } } },",
          "350:   { { { 18, 0, 1 }, { 14, 27, 1 } } },",
          "351:   { { { 18, 0, 2 }, { 14, 27, 0 } } },",
          "352:   { { { 18, 0, 3 }, { 12, 31, 0 } } },",
          "353:   { { { 18, 0, 4 }, { 13, 30, 1 } } },",
          "354:   { { { 19, 0, 3 }, { 13, 30, 0 } } },",
          "355:   { { { 19, 0, 2 }, { 16, 24, 0 } } },",
          "356:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "357:   { { { 19, 0, 0 }, { 13, 31, 0 } } },",
          "358:   { { { 19, 0, 1 }, { 13, 31, 1 } } },",
          "359:   { { { 19, 0, 2 }, { 14, 30, 1 } } },",
          "360:   { { { 19, 0, 3 }, { 14, 30, 0 } } },",
          "361:   { { { 19, 0, 4 }, { 14, 31, 1 } } },",
          "362:   { { { 20, 0, 4 }, { 14, 31, 0 } } },",
          "363:   { { { 20, 0, 3 }, { 16, 27, 0 } } },",
          "364:   { { { 20, 0, 2 }, { 15, 30, 1 } } },",
          "365:   { { { 20, 0, 1 }, { 15, 30, 0 } } },",
          "366:   { { { 20, 0, 0 }, { 16, 28, 0 } } },",
          "367:   { { { 20, 0, 1 }, { 15, 31, 1 } } },",
          "368:   { { { 20, 0, 2 }, { 15, 31, 0 } } },",
          "369:   { { { 20, 0, 3 }, { 15, 31, 1 } } },",
          "370:   { { { 20, 0, 4 }, { 16, 30, 1 } } },",
          "371:   { { { 21, 0, 3 }, { 16, 30, 0 } } },",
          "372:   { { { 21, 0, 2 }, { 18, 27, 1 } } },",
          "373:   { { { 21, 0, 1 }, { 18, 27, 0 } } },",
          "374:   { { { 21, 0, 0 }, { 16, 31, 0 } } },",
          "375:   { { { 21, 0, 1 }, { 17, 30, 1 } } },",
          "376:   { { { 21, 0, 2 }, { 17, 30, 0 } } },",
          "377:   { { { 21, 0, 3 }, { 20, 24, 0 } } },",
          "378:   { { { 21, 0, 4 }, { 17, 31, 1 } } },",
          "379:   { { { 22, 0, 3 }, { 17, 31, 0 } } },",
          "380:   { { { 22, 0, 2 }, { 17, 31, 1 } } },",
          "381:   { { { 22, 0, 1 }, { 18, 30, 1 } } },",
          "382:   { { { 22, 0, 0 }, { 18, 30, 0 } } },",
          "383:   { { { 22, 0, 1 }, { 18, 31, 1 } } },",
          "384:   { { { 22, 0, 2 }, { 18, 31, 0 } } },",
          "385:   { { { 22, 0, 3 }, { 20, 27, 0 } } },",
          "386:   { { { 22, 0, 4 }, { 19, 30, 1 } } },",
          "387:   { { { 23, 0, 3 }, { 19, 30, 0 } } },",
          "388:   { { { 23, 0, 2 }, { 20, 28, 0 } } },",
          "389:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "390:   { { { 23, 0, 0 }, { 19, 31, 0 } } },",
          "391:   { { { 23, 0, 1 }, { 19, 31, 1 } } },",
          "392:   { { { 23, 0, 2 }, { 20, 30, 1 } } },",
          "393:   { { { 23, 0, 3 }, { 20, 30, 0 } } },",
          "394:   { { { 23, 0, 4 }, { 22, 27, 1 } } },",
          "395:   { { { 24, 0, 4 }, { 22, 27, 0 } } },",
          "396:   { { { 24, 0, 3 }, { 20, 31, 0 } } },",
          "397:   { { { 24, 0, 2 }, { 21, 30, 1 } } },",
          "398:   { { { 24, 0, 1 }, { 21, 30, 0 } } },",
          "399:   { { { 24, 0, 0 }, { 24, 24, 0 } } },",
          "400:   { { { 24, 0, 1 }, { 21, 31, 1 } } },",
          "401:   { { { 24, 0, 2 }, { 21, 31, 0 } } },",
          "402:   { { { 24, 0, 3 }, { 21, 31, 1 } } },",
          "403:   { { { 24, 0, 4 }, { 22, 30, 1 } } },",
          "404:   { { { 25, 0, 3 }, { 22, 30, 0 } } },",
          "405:   { { { 25, 0, 2 }, { 22, 31, 1 } } },",
          "406:   { { { 25, 0, 1 }, { 22, 31, 0 } } },",
          "407:   { { { 25, 0, 0 }, { 24, 27, 0 } } },",
          "408:   { { { 25, 0, 1 }, { 23, 30, 1 } } },",
          "409:   { { { 25, 0, 2 }, { 23, 30, 0 } } },",
          "410:   { { { 25, 0, 3 }, { 24, 28, 0 } } },",
          "411:   { { { 25, 0, 4 }, { 23, 31, 1 } } },",
          "412:   { { { 26, 0, 3 }, { 23, 31, 0 } } },",
          "413:   { { { 26, 0, 2 }, { 23, 31, 1 } } },",
          "414:   { { { 26, 0, 1 }, { 24, 30, 1 } } },",
          "415:   { { { 26, 0, 0 }, { 24, 30, 0 } } },",
          "416:   { { { 26, 0, 1 }, { 26, 27, 1 } } },",
          "417:   { { { 26, 0, 2 }, { 26, 27, 0 } } },",
          "418:   { { { 26, 0, 3 }, { 24, 31, 0 } } },",
          "419:   { { { 26, 0, 4 }, { 25, 30, 1 } } },",
          "420:   { { { 27, 0, 3 }, { 25, 30, 0 } } },",
          "421:   { { { 27, 0, 2 }, { 28, 24, 0 } } },",
          "422:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "423:   { { { 27, 0, 0 }, { 25, 31, 0 } } },",
          "424:   { { { 27, 0, 1 }, { 25, 31, 1 } } },",
          "425:   { { { 27, 0, 2 }, { 26, 30, 1 } } },",
          "426:   { { { 27, 0, 3 }, { 26, 30, 0 } } },",
          "427:   { { { 27, 0, 4 }, { 26, 31, 1 } } },",
          "428:   { { { 28, 0, 4 }, { 26, 31, 0 } } },",
          "429:   { { { 28, 0, 3 }, { 28, 27, 0 } } },",
          "430:   { { { 28, 0, 2 }, { 27, 30, 1 } } },",
          "431:   { { { 28, 0, 1 }, { 27, 30, 0 } } },",
          "432:   { { { 28, 0, 0 }, { 28, 28, 0 } } },",
          "433:   { { { 28, 0, 1 }, { 27, 31, 1 } } },",
          "434:   { { { 28, 0, 2 }, { 27, 31, 0 } } },",
          "435:   { { { 28, 0, 3 }, { 27, 31, 1 } } },",
          "436:   { { { 28, 0, 4 }, { 28, 30, 1 } } },",
          "437:   { { { 29, 0, 3 }, { 28, 30, 0 } } },",
          "438:   { { { 29, 0, 2 }, { 30, 27, 1 } } },",
          "439:   { { { 29, 0, 1 }, { 30, 27, 0 } } },",
          "440:   { { { 29, 0, 0 }, { 28, 31, 0 } } },",
          "441:   { { { 29, 0, 1 }, { 29, 30, 1 } } },",
          "442:   { { { 29, 0, 2 }, { 29, 30, 0 } } },",
          "443:   { { { 29, 0, 3 }, { 29, 30, 1 } } },",
          "444:   { { { 29, 0, 4 }, { 29, 31, 1 } } },",
          "445:   { { { 30, 0, 3 }, { 29, 31, 0 } } },",
          "446:   { { { 30, 0, 2 }, { 29, 31, 1 } } },",
          "447:   { { { 30, 0, 1 }, { 30, 30, 1 } } },",
          "448:   { { { 30, 0, 0 }, { 30, 30, 0 } } },",
          "449:   { { { 30, 0, 1 }, { 30, 31, 1 } } },",
          "450:   { { { 30, 0, 2 }, { 30, 31, 0 } } },",
          "451:   { { { 30, 0, 3 }, { 30, 31, 1 } } },",
          "452:   { { { 30, 0, 4 }, { 31, 30, 1 } } },",
          "453:   { { { 31, 0, 3 }, { 31, 30, 0 } } },",
          "454:   { { { 31, 0, 2 }, { 31, 30, 1 } } },",
          "455:   { { { 31, 0, 1 }, { 31, 31, 1 } } },",
          "456:   { { { 31, 0, 0 }, { 31, 31, 0 } } }",
          "457: };",
          "459: static const DDSSingleColourLookup DDSLookup_6_4[] =",
          "460: {",
          "461:   { { { 0, 0, 0 }, { 0, 0, 0 } } },",
          "462:   { { { 0, 0, 1 }, { 0, 1, 0 } } },",
          "463:   { { { 0, 0, 2 }, { 0, 2, 0 } } },",
          "464:   { { { 1, 0, 1 }, { 0, 3, 1 } } },",
          "465:   { { { 1, 0, 0 }, { 0, 3, 0 } } },",
          "466:   { { { 1, 0, 1 }, { 0, 4, 0 } } },",
          "467:   { { { 1, 0, 2 }, { 0, 5, 0 } } },",
          "468:   { { { 2, 0, 1 }, { 0, 6, 1 } } },",
          "469:   { { { 2, 0, 0 }, { 0, 6, 0 } } },",
          "470:   { { { 2, 0, 1 }, { 0, 7, 0 } } },",
          "471:   { { { 2, 0, 2 }, { 0, 8, 0 } } },",
          "472:   { { { 3, 0, 1 }, { 0, 9, 1 } } },",
          "473:   { { { 3, 0, 0 }, { 0, 9, 0 } } },",
          "474:   { { { 3, 0, 1 }, { 0, 10, 0 } } },",
          "475:   { { { 3, 0, 2 }, { 0, 11, 0 } } },",
          "476:   { { { 4, 0, 1 }, { 0, 12, 1 } } },",
          "477:   { { { 4, 0, 0 }, { 0, 12, 0 } } },",
          "478:   { { { 4, 0, 1 }, { 0, 13, 0 } } },",
          "479:   { { { 4, 0, 2 }, { 0, 14, 0 } } },",
          "480:   { { { 5, 0, 1 }, { 0, 15, 1 } } },",
          "481:   { { { 5, 0, 0 }, { 0, 15, 0 } } },",
          "482:   { { { 5, 0, 1 }, { 0, 16, 0 } } },",
          "483:   { { { 5, 0, 2 }, { 1, 15, 0 } } },",
          "484:   { { { 6, 0, 1 }, { 0, 17, 0 } } },",
          "485:   { { { 6, 0, 0 }, { 0, 18, 0 } } },",
          "486:   { { { 6, 0, 1 }, { 0, 19, 0 } } },",
          "487:   { { { 6, 0, 2 }, { 3, 14, 0 } } },",
          "488:   { { { 7, 0, 1 }, { 0, 20, 0 } } },",
          "489:   { { { 7, 0, 0 }, { 0, 21, 0 } } },",
          "490:   { { { 7, 0, 1 }, { 0, 22, 0 } } },",
          "491:   { { { 7, 0, 2 }, { 4, 15, 0 } } },",
          "492:   { { { 8, 0, 1 }, { 0, 23, 0 } } },",
          "493:   { { { 8, 0, 0 }, { 0, 24, 0 } } },",
          "494:   { { { 8, 0, 1 }, { 0, 25, 0 } } },",
          "495:   { { { 8, 0, 2 }, { 6, 14, 0 } } },",
          "496:   { { { 9, 0, 1 }, { 0, 26, 0 } } },",
          "497:   { { { 9, 0, 0 }, { 0, 27, 0 } } },",
          "498:   { { { 9, 0, 1 }, { 0, 28, 0 } } },",
          "499:   { { { 9, 0, 2 }, { 7, 15, 0 } } },",
          "500:   { { { 10, 0, 1 }, { 0, 29, 0 } } },",
          "501:   { { { 10, 0, 0 }, { 0, 30, 0 } } },",
          "502:   { { { 10, 0, 1 }, { 0, 31, 0 } } },",
          "503:   { { { 10, 0, 2 }, { 9, 14, 0 } } },",
          "504:   { { { 11, 0, 1 }, { 0, 32, 0 } } },",
          "505:   { { { 11, 0, 0 }, { 0, 33, 0 } } },",
          "506:   { { { 11, 0, 1 }, { 2, 30, 0 } } },",
          "507:   { { { 11, 0, 2 }, { 0, 34, 0 } } },",
          "508:   { { { 12, 0, 1 }, { 0, 35, 0 } } },",
          "509:   { { { 12, 0, 0 }, { 0, 36, 0 } } },",
          "510:   { { { 12, 0, 1 }, { 3, 31, 0 } } },",
          "511:   { { { 12, 0, 2 }, { 0, 37, 0 } } },",
          "512:   { { { 13, 0, 1 }, { 0, 38, 0 } } },",
          "513:   { { { 13, 0, 0 }, { 0, 39, 0 } } },",
          "514:   { { { 13, 0, 1 }, { 5, 30, 0 } } },",
          "515:   { { { 13, 0, 2 }, { 0, 40, 0 } } },",
          "516:   { { { 14, 0, 1 }, { 0, 41, 0 } } },",
          "517:   { { { 14, 0, 0 }, { 0, 42, 0 } } },",
          "518:   { { { 14, 0, 1 }, { 6, 31, 0 } } },",
          "519:   { { { 14, 0, 2 }, { 0, 43, 0 } } },",
          "520:   { { { 15, 0, 1 }, { 0, 44, 0 } } },",
          "521:   { { { 15, 0, 0 }, { 0, 45, 0 } } },",
          "522:   { { { 15, 0, 1 }, { 8, 30, 0 } } },",
          "523:   { { { 15, 0, 2 }, { 0, 46, 0 } } },",
          "524:   { { { 16, 0, 2 }, { 0, 47, 0 } } },",
          "525:   { { { 16, 0, 1 }, { 1, 46, 0 } } },",
          "526:   { { { 16, 0, 0 }, { 0, 48, 0 } } },",
          "527:   { { { 16, 0, 1 }, { 0, 49, 0 } } },",
          "528:   { { { 16, 0, 2 }, { 0, 50, 0 } } },",
          "529:   { { { 17, 0, 1 }, { 2, 47, 0 } } },",
          "530:   { { { 17, 0, 0 }, { 0, 51, 0 } } },",
          "531:   { { { 17, 0, 1 }, { 0, 52, 0 } } },",
          "532:   { { { 17, 0, 2 }, { 0, 53, 0 } } },",
          "533:   { { { 18, 0, 1 }, { 4, 46, 0 } } },",
          "534:   { { { 18, 0, 0 }, { 0, 54, 0 } } },",
          "535:   { { { 18, 0, 1 }, { 0, 55, 0 } } },",
          "536:   { { { 18, 0, 2 }, { 0, 56, 0 } } },",
          "537:   { { { 19, 0, 1 }, { 5, 47, 0 } } },",
          "538:   { { { 19, 0, 0 }, { 0, 57, 0 } } },",
          "539:   { { { 19, 0, 1 }, { 0, 58, 0 } } },",
          "540:   { { { 19, 0, 2 }, { 0, 59, 0 } } },",
          "541:   { { { 20, 0, 1 }, { 7, 46, 0 } } },",
          "542:   { { { 20, 0, 0 }, { 0, 60, 0 } } },",
          "543:   { { { 20, 0, 1 }, { 0, 61, 0 } } },",
          "544:   { { { 20, 0, 2 }, { 0, 62, 0 } } },",
          "545:   { { { 21, 0, 1 }, { 8, 47, 0 } } },",
          "546:   { { { 21, 0, 0 }, { 0, 63, 0 } } },",
          "547:   { { { 21, 0, 1 }, { 1, 62, 0 } } },",
          "548:   { { { 21, 0, 2 }, { 1, 63, 0 } } },",
          "549:   { { { 22, 0, 1 }, { 10, 46, 0 } } },",
          "550:   { { { 22, 0, 0 }, { 2, 62, 0 } } },",
          "551:   { { { 22, 0, 1 }, { 2, 63, 0 } } },",
          "552:   { { { 22, 0, 2 }, { 3, 62, 0 } } },",
          "553:   { { { 23, 0, 1 }, { 11, 47, 0 } } },",
          "554:   { { { 23, 0, 0 }, { 3, 63, 0 } } },",
          "555:   { { { 23, 0, 1 }, { 4, 62, 0 } } },",
          "556:   { { { 23, 0, 2 }, { 4, 63, 0 } } },",
          "557:   { { { 24, 0, 1 }, { 13, 46, 0 } } },",
          "558:   { { { 24, 0, 0 }, { 5, 62, 0 } } },",
          "559:   { { { 24, 0, 1 }, { 5, 63, 0 } } },",
          "560:   { { { 24, 0, 2 }, { 6, 62, 0 } } },",
          "561:   { { { 25, 0, 1 }, { 14, 47, 0 } } },",
          "562:   { { { 25, 0, 0 }, { 6, 63, 0 } } },",
          "563:   { { { 25, 0, 1 }, { 7, 62, 0 } } },",
          "564:   { { { 25, 0, 2 }, { 7, 63, 0 } } },",
          "565:   { { { 26, 0, 1 }, { 16, 45, 0 } } },",
          "566:   { { { 26, 0, 0 }, { 8, 62, 0 } } },",
          "567:   { { { 26, 0, 1 }, { 8, 63, 0 } } },",
          "568:   { { { 26, 0, 2 }, { 9, 62, 0 } } },",
          "569:   { { { 27, 0, 1 }, { 16, 48, 0 } } },",
          "570:   { { { 27, 0, 0 }, { 9, 63, 0 } } },",
          "571:   { { { 27, 0, 1 }, { 10, 62, 0 } } },",
          "572:   { { { 27, 0, 2 }, { 10, 63, 0 } } },",
          "573:   { { { 28, 0, 1 }, { 16, 51, 0 } } },",
          "574:   { { { 28, 0, 0 }, { 11, 62, 0 } } },",
          "575:   { { { 28, 0, 1 }, { 11, 63, 0 } } },",
          "576:   { { { 28, 0, 2 }, { 12, 62, 0 } } },",
          "577:   { { { 29, 0, 1 }, { 16, 54, 0 } } },",
          "578:   { { { 29, 0, 0 }, { 12, 63, 0 } } },",
          "579:   { { { 29, 0, 1 }, { 13, 62, 0 } } },",
          "580:   { { { 29, 0, 2 }, { 13, 63, 0 } } },",
          "581:   { { { 30, 0, 1 }, { 16, 57, 0 } } },",
          "582:   { { { 30, 0, 0 }, { 14, 62, 0 } } },",
          "583:   { { { 30, 0, 1 }, { 14, 63, 0 } } },",
          "584:   { { { 30, 0, 2 }, { 15, 62, 0 } } },",
          "585:   { { { 31, 0, 1 }, { 16, 60, 0 } } },",
          "586:   { { { 31, 0, 0 }, { 15, 63, 0 } } },",
          "587:   { { { 31, 0, 1 }, { 24, 46, 0 } } },",
          "588:   { { { 31, 0, 2 }, { 16, 62, 0 } } },",
          "589:   { { { 32, 0, 2 }, { 16, 63, 0 } } },",
          "590:   { { { 32, 0, 1 }, { 17, 62, 0 } } },",
          "591:   { { { 32, 0, 0 }, { 25, 47, 0 } } },",
          "592:   { { { 32, 0, 1 }, { 17, 63, 0 } } },",
          "593:   { { { 32, 0, 2 }, { 18, 62, 0 } } },",
          "594:   { { { 33, 0, 1 }, { 18, 63, 0 } } },",
          "595:   { { { 33, 0, 0 }, { 27, 46, 0 } } },",
          "596:   { { { 33, 0, 1 }, { 19, 62, 0 } } },",
          "597:   { { { 33, 0, 2 }, { 19, 63, 0 } } },",
          "598:   { { { 34, 0, 1 }, { 20, 62, 0 } } },",
          "599:   { { { 34, 0, 0 }, { 28, 47, 0 } } },",
          "600:   { { { 34, 0, 1 }, { 20, 63, 0 } } },",
          "601:   { { { 34, 0, 2 }, { 21, 62, 0 } } },",
          "602:   { { { 35, 0, 1 }, { 21, 63, 0 } } },",
          "603:   { { { 35, 0, 0 }, { 30, 46, 0 } } },",
          "604:   { { { 35, 0, 1 }, { 22, 62, 0 } } },",
          "605:   { { { 35, 0, 2 }, { 22, 63, 0 } } },",
          "606:   { { { 36, 0, 1 }, { 23, 62, 0 } } },",
          "607:   { { { 36, 0, 0 }, { 31, 47, 0 } } },",
          "608:   { { { 36, 0, 1 }, { 23, 63, 0 } } },",
          "609:   { { { 36, 0, 2 }, { 24, 62, 0 } } },",
          "610:   { { { 37, 0, 1 }, { 24, 63, 0 } } },",
          "611:   { { { 37, 0, 0 }, { 32, 47, 0 } } },",
          "612:   { { { 37, 0, 1 }, { 25, 62, 0 } } },",
          "613:   { { { 37, 0, 2 }, { 25, 63, 0 } } },",
          "614:   { { { 38, 0, 1 }, { 26, 62, 0 } } },",
          "615:   { { { 38, 0, 0 }, { 32, 50, 0 } } },",
          "616:   { { { 38, 0, 1 }, { 26, 63, 0 } } },",
          "617:   { { { 38, 0, 2 }, { 27, 62, 0 } } },",
          "618:   { { { 39, 0, 1 }, { 27, 63, 0 } } },",
          "619:   { { { 39, 0, 0 }, { 32, 53, 0 } } },",
          "620:   { { { 39, 0, 1 }, { 28, 62, 0 } } },",
          "621:   { { { 39, 0, 2 }, { 28, 63, 0 } } },",
          "622:   { { { 40, 0, 1 }, { 29, 62, 0 } } },",
          "623:   { { { 40, 0, 0 }, { 32, 56, 0 } } },",
          "624:   { { { 40, 0, 1 }, { 29, 63, 0 } } },",
          "625:   { { { 40, 0, 2 }, { 30, 62, 0 } } },",
          "626:   { { { 41, 0, 1 }, { 30, 63, 0 } } },",
          "627:   { { { 41, 0, 0 }, { 32, 59, 0 } } },",
          "628:   { { { 41, 0, 1 }, { 31, 62, 0 } } },",
          "629:   { { { 41, 0, 2 }, { 31, 63, 0 } } },",
          "630:   { { { 42, 0, 1 }, { 32, 61, 0 } } },",
          "631:   { { { 42, 0, 0 }, { 32, 62, 0 } } },",
          "632:   { { { 42, 0, 1 }, { 32, 63, 0 } } },",
          "633:   { { { 42, 0, 2 }, { 41, 46, 0 } } },",
          "634:   { { { 43, 0, 1 }, { 33, 62, 0 } } },",
          "635:   { { { 43, 0, 0 }, { 33, 63, 0 } } },",
          "636:   { { { 43, 0, 1 }, { 34, 62, 0 } } },",
          "637:   { { { 43, 0, 2 }, { 42, 47, 0 } } },",
          "638:   { { { 44, 0, 1 }, { 34, 63, 0 } } },",
          "639:   { { { 44, 0, 0 }, { 35, 62, 0 } } },",
          "640:   { { { 44, 0, 1 }, { 35, 63, 0 } } },",
          "641:   { { { 44, 0, 2 }, { 44, 46, 0 } } },",
          "642:   { { { 45, 0, 1 }, { 36, 62, 0 } } },",
          "643:   { { { 45, 0, 0 }, { 36, 63, 0 } } },",
          "644:   { { { 45, 0, 1 }, { 37, 62, 0 } } },",
          "645:   { { { 45, 0, 2 }, { 45, 47, 0 } } },",
          "646:   { { { 46, 0, 1 }, { 37, 63, 0 } } },",
          "647:   { { { 46, 0, 0 }, { 38, 62, 0 } } },",
          "648:   { { { 46, 0, 1 }, { 38, 63, 0 } } },",
          "649:   { { { 46, 0, 2 }, { 47, 46, 0 } } },",
          "650:   { { { 47, 0, 1 }, { 39, 62, 0 } } },",
          "651:   { { { 47, 0, 0 }, { 39, 63, 0 } } },",
          "652:   { { { 47, 0, 1 }, { 40, 62, 0 } } },",
          "653:   { { { 47, 0, 2 }, { 48, 46, 0 } } },",
          "654:   { { { 48, 0, 2 }, { 40, 63, 0 } } },",
          "655:   { { { 48, 0, 1 }, { 41, 62, 0 } } },",
          "656:   { { { 48, 0, 0 }, { 41, 63, 0 } } },",
          "657:   { { { 48, 0, 1 }, { 48, 49, 0 } } },",
          "658:   { { { 48, 0, 2 }, { 42, 62, 0 } } },",
          "659:   { { { 49, 0, 1 }, { 42, 63, 0 } } },",
          "660:   { { { 49, 0, 0 }, { 43, 62, 0 } } },",
          "661:   { { { 49, 0, 1 }, { 48, 52, 0 } } },",
          "662:   { { { 49, 0, 2 }, { 43, 63, 0 } } },",
          "663:   { { { 50, 0, 1 }, { 44, 62, 0 } } },",
          "664:   { { { 50, 0, 0 }, { 44, 63, 0 } } },",
          "665:   { { { 50, 0, 1 }, { 48, 55, 0 } } },",
          "666:   { { { 50, 0, 2 }, { 45, 62, 0 } } },",
          "667:   { { { 51, 0, 1 }, { 45, 63, 0 } } },",
          "668:   { { { 51, 0, 0 }, { 46, 62, 0 } } },",
          "669:   { { { 51, 0, 1 }, { 48, 58, 0 } } },",
          "670:   { { { 51, 0, 2 }, { 46, 63, 0 } } },",
          "671:   { { { 52, 0, 1 }, { 47, 62, 0 } } },",
          "672:   { { { 52, 0, 0 }, { 47, 63, 0 } } },",
          "673:   { { { 52, 0, 1 }, { 48, 61, 0 } } },",
          "674:   { { { 52, 0, 2 }, { 48, 62, 0 } } },",
          "675:   { { { 53, 0, 1 }, { 56, 47, 0 } } },",
          "676:   { { { 53, 0, 0 }, { 48, 63, 0 } } },",
          "677:   { { { 53, 0, 1 }, { 49, 62, 0 } } },",
          "678:   { { { 53, 0, 2 }, { 49, 63, 0 } } },",
          "679:   { { { 54, 0, 1 }, { 58, 46, 0 } } },",
          "680:   { { { 54, 0, 0 }, { 50, 62, 0 } } },",
          "681:   { { { 54, 0, 1 }, { 50, 63, 0 } } },",
          "682:   { { { 54, 0, 2 }, { 51, 62, 0 } } },",
          "683:   { { { 55, 0, 1 }, { 59, 47, 0 } } },",
          "684:   { { { 55, 0, 0 }, { 51, 63, 0 } } },",
          "685:   { { { 55, 0, 1 }, { 52, 62, 0 } } },",
          "686:   { { { 55, 0, 2 }, { 52, 63, 0 } } },",
          "687:   { { { 56, 0, 1 }, { 61, 46, 0 } } },",
          "688:   { { { 56, 0, 0 }, { 53, 62, 0 } } },",
          "689:   { { { 56, 0, 1 }, { 53, 63, 0 } } },",
          "690:   { { { 56, 0, 2 }, { 54, 62, 0 } } },",
          "691:   { { { 57, 0, 1 }, { 62, 47, 0 } } },",
          "692:   { { { 57, 0, 0 }, { 54, 63, 0 } } },",
          "693:   { { { 57, 0, 1 }, { 55, 62, 0 } } },",
          "694:   { { { 57, 0, 2 }, { 55, 63, 0 } } },",
          "695:   { { { 58, 0, 1 }, { 56, 62, 1 } } },",
          "696:   { { { 58, 0, 0 }, { 56, 62, 0 } } },",
          "697:   { { { 58, 0, 1 }, { 56, 63, 0 } } },",
          "698:   { { { 58, 0, 2 }, { 57, 62, 0 } } },",
          "699:   { { { 59, 0, 1 }, { 57, 63, 1 } } },",
          "700:   { { { 59, 0, 0 }, { 57, 63, 0 } } },",
          "701:   { { { 59, 0, 1 }, { 58, 62, 0 } } },",
          "702:   { { { 59, 0, 2 }, { 58, 63, 0 } } },",
          "703:   { { { 60, 0, 1 }, { 59, 62, 1 } } },",
          "704:   { { { 60, 0, 0 }, { 59, 62, 0 } } },",
          "705:   { { { 60, 0, 1 }, { 59, 63, 0 } } },",
          "706:   { { { 60, 0, 2 }, { 60, 62, 0 } } },",
          "707:   { { { 61, 0, 1 }, { 60, 63, 1 } } },",
          "708:   { { { 61, 0, 0 }, { 60, 63, 0 } } },",
          "709:   { { { 61, 0, 1 }, { 61, 62, 0 } } },",
          "710:   { { { 61, 0, 2 }, { 61, 63, 0 } } },",
          "711:   { { { 62, 0, 1 }, { 62, 62, 1 } } },",
          "712:   { { { 62, 0, 0 }, { 62, 62, 0 } } },",
          "713:   { { { 62, 0, 1 }, { 62, 63, 0 } } },",
          "714:   { { { 62, 0, 2 }, { 63, 62, 0 } } },",
          "715:   { { { 63, 0, 1 }, { 63, 63, 1 } } },",
          "716:   { { { 63, 0, 0 }, { 63, 63, 0 } } }",
          "717: };",
          "719: static const DDSSingleColourLookup*",
          "720:   DDS_LOOKUP[] =",
          "721: {",
          "722:   DDSLookup_5_4,",
          "723:   DDSLookup_6_4,",
          "724:   DDSLookup_5_4",
          "725: };",
          "728:   Macros",
          "730: #define C565_r(x) (((x) & 0xF800) >> 11)",
          "731: #define C565_g(x) (((x) & 0x07E0) >> 5)",
          "732: #define C565_b(x)  ((x) & 0x001F)",
          "734: #define C565_red(x)   ( (C565_r(x) << 3 | C565_r(x) >> 2))",
          "735: #define C565_green(x) ( (C565_g(x) << 2 | C565_g(x) >> 4))",
          "736: #define C565_blue(x)  ( (C565_b(x) << 3 | C565_b(x) >> 2))",
          "738: #define DIV2(x)  ((x) > 1 ? ((x) >> 1) : 1)",
          "740: #define FixRange(min, max, steps) \\",
          "741: if (min > max) \\",
          "742:   min = max; \\",
          "743: if (max - min < steps) \\",
          "744:   max = Min(min + steps, 255); \\",
          "745: if (max - min < steps) \\",
          "746:   min = Max(min - steps, 0)",
          "748: #define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)",
          "750: #define VectorInit(vector, value) vector.x = vector.y = vector.z = vector.w \\",
          "751:   = value",
          "752: #define VectorInit3(vector, value) vector.x = vector.y = vector.z = value",
          "754: #define IsBitMask(mask, r, g, b, a) (mask.r_bitmask == r && mask.g_bitmask == \\",
          "755:   g && mask.b_bitmask == b && mask.alpha_bitmask == a)",
          "758:   Forward declarations",
          "760: static MagickBooleanType",
          "761:   ConstructOrdering(const size_t, const DDSVector4 *, const DDSVector3,",
          "762:   DDSVector4 *, DDSVector4 *, unsigned char *, size_t);",
          "764: static MagickBooleanType",
          "765:   ReadDDSInfo(Image *, DDSInfo *);",
          "767: static void",
          "768:   CalculateColors(unsigned short, unsigned short,",
          "769:     DDSColors *, MagickBooleanType);",
          "771: static MagickBooleanType",
          "772:   ReadDXT1(Image *, DDSInfo *, ExceptionInfo *);",
          "774: static MagickBooleanType",
          "775:   ReadDXT3(Image *, DDSInfo *, ExceptionInfo *);",
          "777: static MagickBooleanType",
          "778:   ReadDXT5(Image *, DDSInfo *, ExceptionInfo *);",
          "780: static MagickBooleanType",
          "781:   ReadUncompressedRGB(Image *, DDSInfo *, ExceptionInfo *);",
          "783: static MagickBooleanType",
          "784:   ReadUncompressedRGBA(Image *, DDSInfo *, ExceptionInfo *);",
          "786: static void",
          "787:   RemapIndices(const ssize_t *, const unsigned char *, unsigned char *);",
          "789: static void",
          "790:   SkipDXTMipmaps(Image *, DDSInfo *, int);",
          "792: static void",
          "793:   SkipRGBMipmaps(Image *, DDSInfo *, int);",
          "795: static",
          "796:   MagickBooleanType WriteDDSImage(const ImageInfo *, Image *, ExceptionInfo *);",
          "798: static void",
          "799:   WriteDDSInfo(Image *, const size_t, const size_t, const size_t);",
          "801: static void",
          "802:   WriteFourCC(Image *, const size_t, const MagickBooleanType,",
          "803:     const MagickBooleanType, ExceptionInfo *);",
          "805: static void",
          "806:   WriteImageData(Image *, const size_t, const size_t, const MagickBooleanType,",
          "807:   const MagickBooleanType, ExceptionInfo *);",
          "809: static void",
          "810:   WriteIndices(Image *, const DDSVector3, const DDSVector3, unsigned char *);",
          "812: static MagickBooleanType",
          "813:   WriteMipmaps(Image *, const size_t, const size_t, const size_t,",
          "814:     const MagickBooleanType, const MagickBooleanType, ExceptionInfo *);",
          "816: static void",
          "817:   WriteSingleColorFit(Image *, const DDSVector4 *, const ssize_t *);",
          "819: static void",
          "820:   WriteUncompressed(Image *, ExceptionInfo *);",
          "822: static inline size_t Max(size_t one, size_t two)",
          "823: {",
          "824:   if (one > two)",
          "825:     return one;",
          "826:   return two;",
          "827: }",
          "829: static inline float MaxF(float one, float two)",
          "830: {",
          "831:   if (one > two)",
          "832:     return one;",
          "833:   return two;",
          "834: }",
          "836: static inline size_t Min(size_t one, size_t two)",
          "837: {",
          "838:   if (one < two)",
          "839:     return one;",
          "840:   return two;",
          "841: }",
          "843: static inline float MinF(float one, float two)",
          "844: {",
          "845:   if (one < two)",
          "846:     return one;",
          "847:   return two;",
          "848: }",
          "850: static inline void VectorAdd(const DDSVector4 left, const DDSVector4 right,",
          "851:   DDSVector4 *destination)",
          "852: {",
          "853:   destination->x = left.x + right.x;",
          "854:   destination->y = left.y + right.y;",
          "855:   destination->z = left.z + right.z;",
          "856:   destination->w = left.w + right.w;",
          "857: }",
          "859: static inline void VectorClamp(DDSVector4 *value)",
          "860: {",
          "861:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "862:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "863:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "864:   value->w = MinF(1.0f,MaxF(0.0f,value->w));",
          "865: }",
          "867: static inline void VectorClamp3(DDSVector3 *value)",
          "868: {",
          "869:   value->x = MinF(1.0f,MaxF(0.0f,value->x));",
          "870:   value->y = MinF(1.0f,MaxF(0.0f,value->y));",
          "871:   value->z = MinF(1.0f,MaxF(0.0f,value->z));",
          "872: }",
          "874: static inline void VectorCopy43(const DDSVector4 source,",
          "875:   DDSVector3 *destination)",
          "876: {",
          "877:   destination->x = source.x;",
          "878:   destination->y = source.y;",
          "879:   destination->z = source.z;",
          "880: }",
          "882: static inline void VectorCopy44(const DDSVector4 source,",
          "883:   DDSVector4 *destination)",
          "884: {",
          "885:   destination->x = source.x;",
          "886:   destination->y = source.y;",
          "887:   destination->z = source.z;",
          "888:   destination->w = source.w;",
          "889: }",
          "891: static inline void VectorNegativeMultiplySubtract(const DDSVector4 a,",
          "892:   const DDSVector4 b, const DDSVector4 c, DDSVector4 *destination)",
          "893: {",
          "894:   destination->x = c.x - (a.x * b.x);",
          "895:   destination->y = c.y - (a.y * b.y);",
          "896:   destination->z = c.z - (a.z * b.z);",
          "897:   destination->w = c.w - (a.w * b.w);",
          "898: }",
          "900: static inline void VectorMultiply(const DDSVector4 left,",
          "901:   const DDSVector4 right, DDSVector4 *destination)",
          "902: {",
          "903:   destination->x = left.x * right.x;",
          "904:   destination->y = left.y * right.y;",
          "905:   destination->z = left.z * right.z;",
          "906:   destination->w = left.w * right.w;",
          "907: }",
          "909: static inline void VectorMultiply3(const DDSVector3 left,",
          "910:   const DDSVector3 right, DDSVector3 *destination)",
          "911: {",
          "912:   destination->x = left.x * right.x;",
          "913:   destination->y = left.y * right.y;",
          "914:   destination->z = left.z * right.z;",
          "915: }",
          "917: static inline void VectorMultiplyAdd(const DDSVector4 a, const DDSVector4 b,",
          "918:   const DDSVector4 c, DDSVector4 *destination)",
          "919: {",
          "920:   destination->x = (a.x * b.x) + c.x;",
          "921:   destination->y = (a.y * b.y) + c.y;",
          "922:   destination->z = (a.z * b.z) + c.z;",
          "923:   destination->w = (a.w * b.w) + c.w;",
          "924: }",
          "926: static inline void VectorMultiplyAdd3(const DDSVector3 a, const DDSVector3 b,",
          "927:   const DDSVector3 c, DDSVector3 *destination)",
          "928: {",
          "929:   destination->x = (a.x * b.x) + c.x;",
          "930:   destination->y = (a.y * b.y) + c.y;",
          "931:   destination->z = (a.z * b.z) + c.z;",
          "932: }",
          "934: static inline void VectorReciprocal(const DDSVector4 value,",
          "935:   DDSVector4 *destination)",
          "936: {",
          "937:   destination->x = 1.0f / value.x;",
          "938:   destination->y = 1.0f / value.y;",
          "939:   destination->z = 1.0f / value.z;",
          "940:   destination->w = 1.0f / value.w;",
          "941: }",
          "943: static inline void VectorSubtract(const DDSVector4 left,",
          "944:   const DDSVector4 right, DDSVector4 *destination)",
          "945: {",
          "946:   destination->x = left.x - right.x;",
          "947:   destination->y = left.y - right.y;",
          "948:   destination->z = left.z - right.z;",
          "949:   destination->w = left.w - right.w;",
          "950: }",
          "952: static inline void VectorSubtract3(const DDSVector3 left,",
          "953:   const DDSVector3 right, DDSVector3 *destination)",
          "954: {",
          "955:   destination->x = left.x - right.x;",
          "956:   destination->y = left.y - right.y;",
          "957:   destination->z = left.z - right.z;",
          "958: }",
          "960: static inline void VectorTruncate(DDSVector4 *value)",
          "961: {",
          "962:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "963:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "964:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "965:   value->w = value->w > 0.0f ? floor(value->w) : ceil(value->w);",
          "966: }",
          "968: static inline void VectorTruncate3(DDSVector3 *value)",
          "969: {",
          "970:   value->x = value->x > 0.0f ? floor(value->x) : ceil(value->x);",
          "971:   value->y = value->y > 0.0f ? floor(value->y) : ceil(value->y);",
          "972:   value->z = value->z > 0.0f ? floor(value->z) : ceil(value->z);",
          "973: }",
          "975: static void CalculateColors(unsigned short c0, unsigned short c1,",
          "976:   DDSColors *c, MagickBooleanType ignoreAlpha)",
          "977: {",
          "978:   c->a[0] = c->a[1] = c->a[2] = c->a[3] = 0;",
          "980:   c->r[0] = (unsigned char) C565_red(c0);",
          "981:   c->g[0] = (unsigned char) C565_green(c0);",
          "982:   c->b[0] = (unsigned char) C565_blue(c0);",
          "984:   c->r[1] = (unsigned char) C565_red(c1);",
          "985:   c->g[1] = (unsigned char) C565_green(c1);",
          "986:   c->b[1] = (unsigned char) C565_blue(c1);",
          "988:   if (ignoreAlpha != MagickFalse || c0 > c1)",
          "989:     {",
          "990:       c->r[2] = (unsigned char) ((2 * c->r[0] + c->r[1]) / 3);",
          "991:       c->g[2] = (unsigned char) ((2 * c->g[0] + c->g[1]) / 3);",
          "992:       c->b[2] = (unsigned char) ((2 * c->b[0] + c->b[1]) / 3);",
          "994:       c->r[3] = (unsigned char) ((c->r[0] + 2 * c->r[1]) / 3);",
          "995:       c->g[3] = (unsigned char) ((c->g[0] + 2 * c->g[1]) / 3);",
          "996:       c->b[3] = (unsigned char) ((c->b[0] + 2 * c->b[1]) / 3);",
          "997:     }",
          "998:   else",
          "999:     {",
          "1000:       c->r[2] = (unsigned char) ((c->r[0] + c->r[1]) / 2);",
          "1001:       c->g[2] = (unsigned char) ((c->g[0] + c->g[1]) / 2);",
          "1002:       c->b[2] = (unsigned char) ((c->b[0] + c->b[1]) / 2);",
          "1004:       c->r[3] = c->g[3] = c->b[3] = 0;",
          "1005:       c->a[3] = 255;",
          "1006:     }",
          "1007: }",
          "1009: static size_t CompressAlpha(const size_t min, const size_t max,",
          "1010:   const size_t steps, const ssize_t *alphas, unsigned char* indices)",
          "1011: {",
          "1012:   unsigned char",
          "1013:     codes[8];",
          "1015:   register ssize_t",
          "1016:     i;",
          "1018:   size_t",
          "1019:     error,",
          "1020:     index,",
          "1021:     j,",
          "1022:     least,",
          "1023:     value;",
          "1025:   codes[0] = (unsigned char) min;",
          "1026:   codes[1] = (unsigned char) max;",
          "1027:   codes[6] = 0;",
          "1028:   codes[7] = 255;",
          "1030:   for (i=1; i <  (ssize_t) steps; i++)",
          "1031:     codes[i+1] = (unsigned char) (((steps-i)*min + i*max) / steps);",
          "1033:   error = 0;",
          "1034:   for (i=0; i<16; i++)",
          "1035:   {",
          "1036:     if (alphas[i] == -1)",
          "1037:       {",
          "1038:         indices[i] = 0;",
          "1039:         continue;",
          "1040:       }",
          "1042:     value = alphas[i];",
          "1043:     least = SIZE_MAX;",
          "1044:     index = 0;",
          "1045:     for (j=0; j<8; j++)",
          "1046:     {",
          "1047:       size_t",
          "1048:         dist;",
          "1050:       dist = value - (size_t)codes[j];",
          "1051:       dist *= dist;",
          "1053:       if (dist < least)",
          "1054:         {",
          "1055:           least = dist;",
          "1056:           index = j;",
          "1057:         }",
          "1058:     }",
          "1060:     indices[i] = (unsigned char)index;",
          "1061:     error += least;",
          "1062:   }",
          "1064:   return error;",
          "1065: }",
          "1067: static void CompressClusterFit(const size_t count,",
          "1068:   const DDSVector4 *points, const ssize_t *map, const DDSVector3 principle,",
          "1069:   const DDSVector4 metric, DDSVector3 *start, DDSVector3* end,",
          "1070:   unsigned char *indices)",
          "1071: {",
          "1072:   DDSVector3",
          "1073:     axis;",
          "1075:   DDSVector4",
          "1076:     grid,",
          "1077:     gridrcp,",
          "1078:     half,",
          "1079:     onethird_onethird2,",
          "1080:     part0,",
          "1081:     part1,",
          "1082:     part2,",
          "1083:     part3,",
          "1084:     pointsWeights[16],",
          "1085:     two,",
          "1086:     twonineths,",
          "1087:     twothirds_twothirds2,",
          "1088:     xSumwSum;",
          "1090:   float",
          "1091:     bestError = 1e+37f;",
          "1093:   size_t",
          "1094:     bestIteration = 0,",
          "1095:     besti = 0,",
          "1096:     bestj = 0,",
          "1097:     bestk = 0,",
          "1098:     iterationIndex,",
          "1099:     i,",
          "1100:     j,",
          "1101:     k,",
          "1102:     kmin;",
          "1104:   unsigned char",
          "1106:     order[128],",
          "1107:     unordered[16];",
          "1109:   VectorInit(half,0.5f);",
          "1110:   VectorInit(two,2.0f);",
          "1112:   VectorInit(onethird_onethird2,1.0f/3.0f);",
          "1113:   onethird_onethird2.w = 1.0f/9.0f;",
          "1114:   VectorInit(twothirds_twothirds2,2.0f/3.0f);",
          "1115:   twothirds_twothirds2.w = 4.0f/9.0f;",
          "1116:   VectorInit(twonineths,2.0f/9.0f);",
          "1118:   grid.x = 31.0f;",
          "1119:   grid.y = 63.0f;",
          "1120:   grid.z = 31.0f;",
          "1121:   grid.w = 0.0f;",
          "1123:   gridrcp.x = 1.0f/31.0f;",
          "1124:   gridrcp.y = 1.0f/63.0f;",
          "1125:   gridrcp.z = 1.0f/31.0f;",
          "1126:   gridrcp.w = 0.0f;",
          "1128:   xSumwSum.x = 0.0f;",
          "1129:   xSumwSum.y = 0.0f;",
          "1130:   xSumwSum.z = 0.0f;",
          "1131:   xSumwSum.w = 0.0f;",
          "1133:   ConstructOrdering(count,points,principle,pointsWeights,&xSumwSum,order,0);",
          "1135:   for (iterationIndex = 0;;)",
          "1136:   {",
          "1137:     VectorInit(part0,0.0f);",
          "1138:     for (i=0; i < count; i++)",
          "1139:     {",
          "1140:       VectorInit(part1,0.0f);",
          "1141:       for (j=i;;)",
          "1142:       {",
          "1143:         if (j == 0)",
          "1144:           {",
          "1145:             VectorCopy44(pointsWeights[0],&part2);",
          "1146:             kmin = 1;",
          "1147:           }",
          "1148:           else",
          "1149:           {",
          "1150:             VectorInit(part2,0.0f);",
          "1151:             kmin = j;",
          "1152:           }",
          "1154:         for (k=kmin;;)",
          "1155:         {",
          "1156:           DDSVector4",
          "1157:             a,",
          "1158:             alpha2_sum,",
          "1159:             alphax_sum,",
          "1160:             alphabeta_sum,",
          "1161:             b,",
          "1162:             beta2_sum,",
          "1163:             betax_sum,",
          "1164:             e1,",
          "1165:             e2,",
          "1166:             factor;",
          "1168:           float",
          "1169:             error;",
          "1171:           VectorSubtract(xSumwSum,part2,&part3);",
          "1172:           VectorSubtract(part3,part1,&part3);",
          "1173:           VectorSubtract(part3,part0,&part3);",
          "1175:           VectorMultiplyAdd(part1,twothirds_twothirds2,part0,&alphax_sum);",
          "1176:           VectorMultiplyAdd(part2,onethird_onethird2,alphax_sum,&alphax_sum);",
          "1177:           VectorInit(alpha2_sum,alphax_sum.w);",
          "1179:           VectorMultiplyAdd(part2,twothirds_twothirds2,part3,&betax_sum);",
          "1180:           VectorMultiplyAdd(part1,onethird_onethird2,betax_sum,&betax_sum);",
          "1181:           VectorInit(beta2_sum,betax_sum.w);",
          "1183:           VectorAdd(part1,part2,&alphabeta_sum);",
          "1184:           VectorInit(alphabeta_sum,alphabeta_sum.w);",
          "1185:           VectorMultiply(twonineths,alphabeta_sum,&alphabeta_sum);",
          "1187:           VectorMultiply(alpha2_sum,beta2_sum,&factor);",
          "1188:           VectorNegativeMultiplySubtract(alphabeta_sum,alphabeta_sum,factor,",
          "1189:             &factor);",
          "1190:           VectorReciprocal(factor,&factor);",
          "1192:           VectorMultiply(alphax_sum,beta2_sum,&a);",
          "1193:           VectorNegativeMultiplySubtract(betax_sum,alphabeta_sum,a,&a);",
          "1194:           VectorMultiply(a,factor,&a);",
          "1196:           VectorMultiply(betax_sum,alpha2_sum,&b);",
          "1197:           VectorNegativeMultiplySubtract(alphax_sum,alphabeta_sum,b,&b);",
          "1198:           VectorMultiply(b,factor,&b);",
          "1200:           VectorClamp(&a);",
          "1201:           VectorMultiplyAdd(grid,a,half,&a);",
          "1202:           VectorTruncate(&a);",
          "1203:           VectorMultiply(a,gridrcp,&a);",
          "1205:           VectorClamp(&b);",
          "1206:           VectorMultiplyAdd(grid,b,half,&b);",
          "1207:           VectorTruncate(&b);",
          "1208:           VectorMultiply(b,gridrcp,&b);",
          "1210:           VectorMultiply(b,b,&e1);",
          "1211:           VectorMultiply(e1,beta2_sum,&e1);",
          "1212:           VectorMultiply(a,a,&e2);",
          "1213:           VectorMultiplyAdd(e2,alpha2_sum,e1,&e1);",
          "1215:           VectorMultiply(a,b,&e2);",
          "1216:           VectorMultiply(e2,alphabeta_sum,&e2);",
          "1217:           VectorNegativeMultiplySubtract(a,alphax_sum,e2,&e2);",
          "1218:           VectorNegativeMultiplySubtract(b,betax_sum,e2,&e2);",
          "1219:           VectorMultiplyAdd(two,e2,e1,&e2);",
          "1220:           VectorMultiply(e2,metric,&e2);",
          "1222:           error = e2.x + e2.y + e2.z;",
          "1224:           if (error < bestError)",
          "1225:           {",
          "1226:             VectorCopy43(a,start);",
          "1227:             VectorCopy43(b,end);",
          "1228:             bestError = error;",
          "1229:             besti = i;",
          "1230:             bestj = j;",
          "1231:             bestk = k;",
          "1232:             bestIteration = iterationIndex;",
          "1233:           }",
          "1235:           if (k == count)",
          "1236:             break;",
          "1238:           VectorAdd(pointsWeights[k],part2,&part2);",
          "1239:           k++;",
          "1240:         }",
          "1242:         if (j == count)",
          "1243:           break;",
          "1245:         VectorAdd(pointsWeights[j],part1,&part1);",
          "1246:         j++;",
          "1247:       }",
          "1249:       VectorAdd(pointsWeights[i],part0,&part0);",
          "1250:     }",
          "1252:     if (bestIteration != iterationIndex)",
          "1253:       break;",
          "1255:     iterationIndex++;",
          "1256:     if (iterationIndex == 8)",
          "1257:       break;",
          "1259:     VectorSubtract3(*end,*start,&axis);",
          "1260:     if (ConstructOrdering(count,points,axis,pointsWeights,&xSumwSum,order,",
          "1261:       iterationIndex) == MagickFalse)",
          "1262:       break;",
          "1263:   }",
          "1265:   o = order + (16*bestIteration);",
          "1267:   for (i=0; i < besti; i++)",
          "1268:     unordered[o[i]] = 0;",
          "1269:   for (i=besti; i < bestj; i++)",
          "1270:     unordered[o[i]] = 2;",
          "1271:   for (i=bestj; i < bestk; i++)",
          "1272:     unordered[o[i]] = 3;",
          "1273:   for (i=bestk; i < count; i++)",
          "1274:     unordered[o[i]] = 1;",
          "1276:   RemapIndices(map,unordered,indices);",
          "1277: }",
          "1279: static void CompressRangeFit(const size_t count,",
          "1280:   const DDSVector4* points, const ssize_t *map, const DDSVector3 principle,",
          "1281:   const DDSVector4 metric, DDSVector3 *start, DDSVector3 *end,",
          "1282:   unsigned char *indices)",
          "1283: {",
          "1284:   float",
          "1285:     d,",
          "1286:     bestDist,",
          "1287:     max,",
          "1288:     min,",
          "1289:     val;",
          "1291:   DDSVector3",
          "1292:     codes[4],",
          "1293:     grid,",
          "1294:     gridrcp,",
          "1295:     half,",
          "1296:     dist;",
          "1298:   register ssize_t",
          "1299:     i;",
          "1301:   size_t",
          "1302:     bestj,",
          "1303:     j;",
          "1305:   unsigned char",
          "1306:     closest[16];",
          "1308:   VectorInit3(half,0.5f);",
          "1310:   grid.x = 31.0f;",
          "1311:   grid.y = 63.0f;",
          "1312:   grid.z = 31.0f;",
          "1314:   gridrcp.x = 1.0f/31.0f;",
          "1315:   gridrcp.y = 1.0f/63.0f;",
          "1316:   gridrcp.z = 1.0f/31.0f;",
          "1318:   if (count > 0)",
          "1319:     {",
          "1320:       VectorCopy43(points[0],start);",
          "1321:       VectorCopy43(points[0],end);",
          "1323:       min = max = Dot(points[0],principle);",
          "1324:       for (i=1; i < (ssize_t) count; i++)",
          "1325:       {",
          "1326:         val = Dot(points[i],principle);",
          "1327:         if (val < min)",
          "1328:         {",
          "1329:           VectorCopy43(points[i],start);",
          "1330:           min = val;",
          "1331:         }",
          "1332:         else if (val > max)",
          "1333:         {",
          "1334:           VectorCopy43(points[i],end);",
          "1335:           max = val;",
          "1336:         }",
          "1337:       }",
          "1338:     }",
          "1340:   VectorClamp3(start);",
          "1341:   VectorMultiplyAdd3(grid,*start,half,start);",
          "1342:   VectorTruncate3(start);",
          "1343:   VectorMultiply3(*start,gridrcp,start);",
          "1345:   VectorClamp3(end);",
          "1346:   VectorMultiplyAdd3(grid,*end,half,end);",
          "1347:   VectorTruncate3(end);",
          "1348:   VectorMultiply3(*end,gridrcp,end);",
          "1350:   codes[0] = *start;",
          "1351:   codes[1] = *end;",
          "1352:   codes[2].x = (start->x * (2.0f/3.0f)) + (end->x * (1.0f/3.0f));",
          "1353:   codes[2].y = (start->y * (2.0f/3.0f)) + (end->y * (1.0f/3.0f));",
          "1354:   codes[2].z = (start->z * (2.0f/3.0f)) + (end->z * (1.0f/3.0f));",
          "1355:   codes[3].x = (start->x * (1.0f/3.0f)) + (end->x * (2.0f/3.0f));",
          "1356:   codes[3].y = (start->y * (1.0f/3.0f)) + (end->y * (2.0f/3.0f));",
          "1357:   codes[3].z = (start->z * (1.0f/3.0f)) + (end->z * (2.0f/3.0f));",
          "1359:   for (i=0; i < (ssize_t) count; i++)",
          "1360:   {",
          "1361:     bestDist = 1e+37f;",
          "1362:     bestj = 0;",
          "1363:     for (j=0; j < 4; j++)",
          "1364:     {",
          "1365:       dist.x = (points[i].x - codes[j].x) * metric.x;",
          "1366:       dist.y = (points[i].y - codes[j].y) * metric.y;",
          "1367:       dist.z = (points[i].z - codes[j].z) * metric.z;",
          "1369:       d = Dot(dist,dist);",
          "1370:       if (d < bestDist)",
          "1371:         {",
          "1372:           bestDist = d;",
          "1373:           bestj = j;",
          "1374:         }",
          "1375:     }",
          "1377:     closest[i] = (unsigned char) bestj;",
          "1378:   }",
          "1380:   RemapIndices(map, closest, indices);",
          "1381: }",
          "1383: static void ComputeEndPoints(const DDSSingleColourLookup *lookup[],",
          "1384:   const unsigned char *color, DDSVector3 *start, DDSVector3 *end,",
          "1385:   unsigned char *index)",
          "1386: {",
          "1387:   register ssize_t",
          "1388:     i;",
          "1390:   size_t",
          "1391:     c,",
          "1392:     maxError = SIZE_MAX;",
          "1394:   for (i=0; i < 2; i++)",
          "1395:   {",
          "1396:     const DDSSourceBlock*",
          "1397:       sources[3];",
          "1399:       size_t",
          "1400:         error = 0;",
          "1402:     for (c=0; c < 3; c++)",
          "1403:     {",
          "1404:       sources[c] = &lookup[c][color[c]].sources[i];",
          "1405:       error += ((size_t) sources[c]->error) * ((size_t) sources[c]->error);",
          "1406:     }",
          "1408:     if (error > maxError)",
          "1409:       continue;",
          "1411:     start->x = (float) sources[0]->start / 31.0f;",
          "1412:     start->y = (float) sources[1]->start / 63.0f;",
          "1413:     start->z = (float) sources[2]->start / 31.0f;",
          "1415:     end->x = (float) sources[0]->end / 31.0f;",
          "1416:     end->y = (float) sources[1]->end / 63.0f;",
          "1417:     end->z = (float) sources[2]->end / 31.0f;",
          "1420:     maxError = error;",
          "1421:   }",
          "1422: }",
          "1424: static void ComputePrincipleComponent(const float *covariance,",
          "1425:   DDSVector3 *principle)",
          "1426: {",
          "1427:   DDSVector4",
          "1428:     row0,",
          "1429:     row1,",
          "1430:     row2,",
          "1431:     v;",
          "1433:   register ssize_t",
          "1434:     i;",
          "1436:   row0.x = covariance[0];",
          "1437:   row0.y = covariance[1];",
          "1438:   row0.z = covariance[2];",
          "1439:   row0.w = 0.0f;",
          "1441:   row1.x = covariance[1];",
          "1442:   row1.y = covariance[3];",
          "1443:   row1.z = covariance[4];",
          "1444:   row1.w = 0.0f;",
          "1446:   row2.x = covariance[2];",
          "1447:   row2.y = covariance[4];",
          "1448:   row2.z = covariance[5];",
          "1449:   row2.w = 0.0f;",
          "1451:   VectorInit(v,1.0f);",
          "1453:   for (i=0; i < 8; i++)",
          "1454:   {",
          "1455:     DDSVector4",
          "1456:       w;",
          "1458:     float",
          "1459:       a;",
          "1461:     w.x = row0.x * v.x;",
          "1462:     w.y = row0.y * v.x;",
          "1463:     w.z = row0.z * v.x;",
          "1464:     w.w = row0.w * v.x;",
          "1466:     w.x = (row1.x * v.y) + w.x;",
          "1467:     w.y = (row1.y * v.y) + w.y;",
          "1468:     w.z = (row1.z * v.y) + w.z;",
          "1469:     w.w = (row1.w * v.y) + w.w;",
          "1471:     w.x = (row2.x * v.z) + w.x;",
          "1472:     w.y = (row2.y * v.z) + w.y;",
          "1473:     w.z = (row2.z * v.z) + w.z;",
          "1474:     w.w = (row2.w * v.z) + w.w;",
          "1476:     a = 1.0f / MaxF(w.x,MaxF(w.y,w.z));",
          "1478:     v.x = w.x * a;",
          "1479:     v.y = w.y * a;",
          "1480:     v.z = w.z * a;",
          "1481:     v.w = w.w * a;",
          "1482:   }",
          "1484:   VectorCopy43(v,principle);",
          "1485: }",
          "1487: static void ComputeWeightedCovariance(const size_t count,",
          "1488:   const DDSVector4 *points, float *covariance)",
          "1489: {",
          "1490:   DDSVector3",
          "1491:     centroid;",
          "1493:   float",
          "1494:     total;",
          "1496:   size_t",
          "1497:     i;",
          "1499:   total = 0.0f;",
          "1500:   VectorInit3(centroid,0.0f);",
          "1502:   for (i=0; i < count; i++)",
          "1503:   {",
          "1504:     total += points[i].w;",
          "1505:     centroid.x += (points[i].x * points[i].w);",
          "1506:     centroid.y += (points[i].y * points[i].w);",
          "1507:     centroid.z += (points[i].z * points[i].w);",
          "1508:   }",
          "1510:   if( total > 1.192092896e-07F)",
          "1511:     {",
          "1512:       centroid.x /= total;",
          "1513:       centroid.y /= total;",
          "1514:       centroid.z /= total;",
          "1515:     }",
          "1517:   for (i=0; i < 6; i++)",
          "1518:     covariance[i] = 0.0f;",
          "1520:   for (i = 0; i < count; i++)",
          "1521:   {",
          "1522:     DDSVector3",
          "1523:       a,",
          "1524:       b;",
          "1526:     a.x = points[i].x - centroid.x;",
          "1527:     a.y = points[i].y - centroid.y;",
          "1528:     a.z = points[i].z - centroid.z;",
          "1530:     b.x = points[i].w * a.x;",
          "1531:     b.y = points[i].w * a.y;",
          "1532:     b.z = points[i].w * a.z;",
          "1534:     covariance[0] += a.x*b.x;",
          "1535:     covariance[1] += a.x*b.y;",
          "1536:     covariance[2] += a.x*b.z;",
          "1537:     covariance[3] += a.y*b.y;",
          "1538:     covariance[4] += a.y*b.z;",
          "1539:     covariance[5] += a.z*b.z;",
          "1540:   }",
          "1541: }",
          "1543: static MagickBooleanType ConstructOrdering(const size_t count,",
          "1544:   const DDSVector4 *points, const DDSVector3 axis, DDSVector4 *pointsWeights,",
          "1545:   DDSVector4 *xSumwSum, unsigned char *order, size_t iteration)",
          "1546: {",
          "1547:   float",
          "1548:      dps[16],",
          "1549:      f;",
          "1551:   register ssize_t",
          "1552:     i;",
          "1554:   size_t",
          "1555:     j;",
          "1557:   unsigned char",
          "1558:     c,",
          "1562:   o = order + (16*iteration);",
          "1564:   for (i=0; i < (ssize_t) count; i++)",
          "1565:   {",
          "1566:     dps[i] = Dot(points[i],axis);",
          "1567:     o[i] = (unsigned char)i;",
          "1568:   }",
          "1570:   for (i=0; i < (ssize_t) count; i++)",
          "1571:   {",
          "1572:     for (j=i; j > 0 && dps[j] < dps[j - 1]; j--)",
          "1573:     {",
          "1574:       f = dps[j];",
          "1575:       dps[j] = dps[j - 1];",
          "1576:       dps[j - 1] = f;",
          "1578:       c = o[j];",
          "1579:       o[j] = o[j - 1];",
          "1580:       o[j - 1] = c;",
          "1581:     }",
          "1582:   }",
          "1584:   for (i=0; i < (ssize_t) iteration; i++)",
          "1585:   {",
          "1586:     MagickBooleanType",
          "1587:       same;",
          "1589:     p = order + (16*i);",
          "1590:     same = MagickTrue;",
          "1592:     for (j=0; j < count; j++)",
          "1593:     {",
          "1594:       if (o[j] != p[j])",
          "1595:         {",
          "1596:           same = MagickFalse;",
          "1597:           break;",
          "1598:         }",
          "1599:     }",
          "1601:     if (same != MagickFalse)",
          "1602:       return MagickFalse;",
          "1603:   }",
          "1605:   xSumwSum->x = 0;",
          "1606:   xSumwSum->y = 0;",
          "1607:   xSumwSum->z = 0;",
          "1608:   xSumwSum->w = 0;",
          "1610:   for (i=0; i < (ssize_t) count; i++)",
          "1611:   {",
          "1612:     DDSVector4",
          "1613:       v;",
          "1615:     j = (size_t) o[i];",
          "1617:     v.x = points[j].w * points[j].x;",
          "1618:     v.y = points[j].w * points[j].y;",
          "1619:     v.z = points[j].w * points[j].z;",
          "1620:     v.w = points[j].w * 1.0f;",
          "1622:     VectorCopy44(v,&pointsWeights[i]);",
          "1623:     VectorAdd(*xSumwSum,v,xSumwSum);",
          "1624:   }",
          "1626:   return MagickTrue;",
          "1627: }",
          "1630: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1631: %                                                                             %",
          "1632: %                                                                             %",
          "1633: %                                                                             %",
          "1634: %   I s D D S                                                                 %",
          "1635: %                                                                             %",
          "1636: %                                                                             %",
          "1637: %                                                                             %",
          "1638: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1639: %",
          "1640: %  IsDDS() returns MagickTrue if the image format type, identified by the",
          "1641: %  magick string, is DDS.",
          "1642: %",
          "1643: %  The format of the IsDDS method is:",
          "1644: %",
          "1645: %      MagickBooleanType IsDDS(const unsigned char *magick,const size_t length)",
          "1646: %",
          "1647: %  A description of each parameter follows:",
          "1648: %",
          "1649: %    o magick: compare image format pattern against these bytes.",
          "1650: %",
          "1651: %    o length: Specifies the length of the magick string.",
          "1652: %",
          "1654: static MagickBooleanType IsDDS(const unsigned char *magick, const size_t length)",
          "1655: {",
          "1656:   if (length < 4)",
          "1657:     return(MagickFalse);",
          "1658:   if (LocaleNCompare((char *) magick,\"DDS \", 4) == 0)",
          "1659:     return(MagickTrue);",
          "1660:   return(MagickFalse);",
          "1661: }",
          "1663: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1664: %                                                                             %",
          "1665: %                                                                             %",
          "1666: %                                                                             %",
          "1667: %   R e a d D D S I m a g e                                                   %",
          "1668: %                                                                             %",
          "1669: %                                                                             %",
          "1670: %                                                                             %",
          "1671: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "1672: %",
          "1673: %  ReadDDSImage() reads a DirectDraw Surface image file and returns it.  It",
          "1674: %  allocates the memory necessary for the new Image structure and returns a",
          "1675: %  pointer to the new image.",
          "1676: %",
          "1677: %  The format of the ReadDDSImage method is:",
          "1678: %",
          "1679: %      Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1680: %",
          "1681: %  A description of each parameter follows:",
          "1682: %",
          "1683: %    o image_info: The image info.",
          "1684: %",
          "1685: %    o exception: return any errors or warnings in this structure.",
          "1686: %",
          "1689: static Image *ReadDDSImage(const ImageInfo *image_info,ExceptionInfo *exception)",
          "1690: {",
          "1691:   Image",
          "1694:   MagickBooleanType",
          "1695:     status,",
          "1696:     cubemap = MagickFalse,",
          "1697:     volume = MagickFalse;",
          "1699:   CompressionType",
          "1700:     compression;",
          "1702:   DDSInfo",
          "1703:     dds_info;",
          "1705:   DDSDecoder",
          "1708:   PixelTrait",
          "1709:     alpha_trait;",
          "1711:   size_t",
          "1712:     n,",
          "1713:     num_images;",
          "1716:     Open image file.",
          "1718:   assert(image_info != (const ImageInfo *) NULL);",
          "1719:   assert(image_info->signature == MagickSignature);",
          "1720:   if (image_info->debug != MagickFalse)",
          "1721:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",",
          "1722:       image_info->filename);",
          "1723:   assert(exception != (ExceptionInfo *) NULL);",
          "1724:   assert(exception->signature == MagickSignature);",
          "1725:   image=AcquireImage(image_info,exception);",
          "1726:   status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);",
          "1727:   if (status == MagickFalse)",
          "1728:     {",
          "1729:       image=DestroyImageList(image);",
          "1730:       return((Image *) NULL);",
          "1731:     }",
          "1734:     Initialize image structure.",
          "1736:   if (ReadDDSInfo(image, &dds_info) != MagickTrue) {",
          "1737:     ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");",
          "1738:   }",
          "1740:   if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP)",
          "1741:     cubemap = MagickTrue;",
          "1743:   if (dds_info.ddscaps2 & DDSCAPS2_VOLUME && dds_info.depth > 0)",
          "1744:     volume = MagickTrue;",
          "1746:   (void) SeekBlob(image, 128, SEEK_SET);",
          "1749:     Determine pixel format",
          "1751:   if (dds_info.pixelformat.flags & DDPF_RGB)",
          "1752:     {",
          "1753:       compression = NoCompression;",
          "1754:       if (dds_info.pixelformat.flags & DDPF_ALPHAPIXELS)",
          "1755:         {",
          "1756:           alpha_trait = BlendPixelTrait;",
          "1757:           decoder = ReadUncompressedRGBA;",
          "1758:         }",
          "1759:       else",
          "1760:         {",
          "1761:           alpha_trait = UndefinedPixelTrait;",
          "1762:           decoder = ReadUncompressedRGB;",
          "1763:         }",
          "1764:     }",
          "1765:   else if (dds_info.pixelformat.flags & DDPF_FOURCC)",
          "1766:     {",
          "1767:       switch (dds_info.pixelformat.fourcc)",
          "1768:       {",
          "1769:         case FOURCC_DXT1:",
          "1770:         {",
          "1771:           alpha_trait = UndefinedPixelTrait;",
          "1772:           compression = DXT1Compression;",
          "1773:           decoder = ReadDXT1;",
          "1774:           break;",
          "1775:         }",
          "1777:         case FOURCC_DXT3:",
          "1778:         {",
          "1779:           alpha_trait = BlendPixelTrait;",
          "1780:           compression = DXT3Compression;",
          "1781:           decoder = ReadDXT3;",
          "1782:           break;",
          "1783:         }",
          "1785:         case FOURCC_DXT5:",
          "1786:         {",
          "1787:           alpha_trait = BlendPixelTrait;",
          "1788:           compression = DXT5Compression;",
          "1789:           decoder = ReadDXT5;",
          "1790:           break;",
          "1791:         }",
          "1793:         default:",
          "1794:         {",
          "1796:           ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1797:         }",
          "1798:       }",
          "1799:     }",
          "1800:   else",
          "1801:     {",
          "1803:       ThrowReaderException(CorruptImageError, \"ImageTypeNotSupported\");",
          "1804:     }",
          "1806:   num_images = 1;",
          "1807:   if (cubemap)",
          "1808:     {",
          "1810:         Determine number of faces defined in the cubemap",
          "1812:       num_images = 0;",
          "1813:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) num_images++;",
          "1814:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) num_images++;",
          "1815:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY) num_images++;",
          "1816:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) num_images++;",
          "1817:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) num_images++;",
          "1818:       if (dds_info.ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ) num_images++;",
          "1819:     }",
          "1821:   if (volume)",
          "1822:     num_images = dds_info.depth;",
          "1824:   for (n = 0; n < num_images; n++)",
          "1825:   {",
          "1826:     if (n != 0)",
          "1827:       {",
          "1829:         AcquireNextImage(image_info,image,exception);",
          "1830:         if (GetNextImageInList(image) == (Image *) NULL)",
          "1831:           return(DestroyImageList(image));",
          "1832:         image=SyncNextImageInList(image);",
          "1833:       }",
          "1835:     image->alpha_trait=alpha_trait;",
          "1836:     image->compression = compression;",
          "1837:     image->columns = dds_info.width;",
          "1838:     image->rows = dds_info.height;",
          "1839:     image->storage_class = DirectClass;",
          "1840:     image->endian = LSBEndian;",
          "1841:     image->depth = 8;",
          "1842:     if (image_info->ping != MagickFalse)",
          "1843:       {",
          "1844:         (void) CloseBlob(image);",
          "1845:         return(GetFirstImageInList(image));",
          "1846:       }",
          "1848:     if ((decoder)(image, &dds_info, exception) != MagickTrue)",
          "1849:       {",
          "1850:         (void) CloseBlob(image);",
          "1851:         return(GetFirstImageInList(image));",
          "1852:       }",
          "1853:   }",
          "1855:   if (EOFBlob(image) != MagickFalse)",
          "1856:     ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",",
          "1857:       image->filename);",
          "1859:   (void) CloseBlob(image);",
          "1860:   return(GetFirstImageInList(image));",
          "1861: }",
          "1863: static MagickBooleanType ReadDDSInfo(Image *image, DDSInfo *dds_info)",
          "1864: {",
          "1865:   size_t",
          "1866:     hdr_size,",
          "1867:     required;",
          "1870:   (void) SeekBlob(image, 4, SEEK_SET);",
          "1873:   hdr_size = ReadBlobLSBLong(image);",
          "1874:   if (hdr_size != 124)",
          "1875:     return MagickFalse;",
          "1878:   dds_info->flags = ReadBlobLSBLong(image);",
          "1881:   required=(size_t) (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT);",
          "1882:   if ((dds_info->flags & required) != required)",
          "1883:     return MagickFalse;",
          "1885:   dds_info->height = ReadBlobLSBLong(image);",
          "1886:   dds_info->width = ReadBlobLSBLong(image);",
          "1887:   dds_info->pitchOrLinearSize = ReadBlobLSBLong(image);",
          "1888:   dds_info->depth = ReadBlobLSBLong(image);",
          "1889:   dds_info->mipmapcount = ReadBlobLSBLong(image);",
          "1894:   hdr_size = ReadBlobLSBLong(image);",
          "1895:   if (hdr_size != 32)",
          "1896:     return MagickFalse;",
          "1898:   dds_info->pixelformat.flags = ReadBlobLSBLong(image);",
          "1899:   dds_info->pixelformat.fourcc = ReadBlobLSBLong(image);",
          "1900:   dds_info->pixelformat.rgb_bitcount = ReadBlobLSBLong(image);",
          "1901:   dds_info->pixelformat.r_bitmask = ReadBlobLSBLong(image);",
          "1902:   dds_info->pixelformat.g_bitmask = ReadBlobLSBLong(image);",
          "1903:   dds_info->pixelformat.b_bitmask = ReadBlobLSBLong(image);",
          "1904:   dds_info->pixelformat.alpha_bitmask = ReadBlobLSBLong(image);",
          "1906:   dds_info->ddscaps1 = ReadBlobLSBLong(image);",
          "1907:   dds_info->ddscaps2 = ReadBlobLSBLong(image);",
          "1910:   return MagickTrue;",
          "1911: }",
          "1913: static MagickBooleanType ReadDXT1(Image *image, DDSInfo *dds_info,",
          "1914:   ExceptionInfo *exception)",
          "1915: {",
          "1916:   DDSColors",
          "1917:     colors;",
          "1919:   register Quantum",
          "1922:   register ssize_t",
          "1923:     i,",
          "1924:     x;",
          "1926:   size_t",
          "1927:     bits;",
          "1929:   ssize_t",
          "1930:     j,",
          "1931:     y;",
          "1933:   unsigned char",
          "1934:     code;",
          "1936:   unsigned short",
          "1937:     c0,",
          "1938:     c1;",
          "1940:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "1941:   {",
          "1942:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "1943:     {",
          "1945:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "1946:         Min(4, dds_info->height - y),exception);",
          "1948:       if (q == (Quantum *) NULL)",
          "1949:         return MagickFalse;",
          "1952:       c0 = ReadBlobLSBShort(image);",
          "1953:       c1 = ReadBlobLSBShort(image);",
          "1954:       bits = ReadBlobLSBLong(image);",
          "1956:       CalculateColors(c0, c1, &colors, MagickFalse);",
          "1959:       for (j = 0; j < 4; j++)",
          "1960:       {",
          "1961:         for (i = 0; i < 4; i++)",
          "1962:         {",
          "1963:           if ((x + i) < (ssize_t) dds_info->width &&",
          "1964:               (y + j) < (ssize_t) dds_info->height)",
          "1965:             {",
          "1966:               code = (unsigned char) ((bits >> ((j*4+i)*2)) & 0x3);",
          "1967:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "1968:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "1969:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "1970:               SetPixelAlpha(image,ScaleCharToQuantum(colors.a[code]),q);",
          "1971:               if (colors.a[code] && (image->alpha_trait != BlendPixelTrait))",
          "1973:               q+=GetPixelChannels(image);",
          "1974:             }",
          "1975:         }",
          "1976:       }",
          "1978:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "1979:         return MagickFalse;",
          "1980:     }",
          "1981:   }",
          "1983:   SkipDXTMipmaps(image, dds_info, 8);",
          "1985:   return MagickTrue;",
          "1986: }",
          "1988: static MagickBooleanType ReadDXT3(Image *image, DDSInfo *dds_info,",
          "1989:   ExceptionInfo *exception)",
          "1990: {",
          "1991:   DDSColors",
          "1992:     colors;",
          "1994:   register Quantum",
          "1997:   register ssize_t",
          "1998:     i,",
          "1999:     x;",
          "2001:   unsigned char",
          "2002:     alpha;",
          "2004:   size_t",
          "2005:     a0,",
          "2006:     a1,",
          "2007:     bits,",
          "2008:     code;",
          "2010:   ssize_t",
          "2011:     j,",
          "2012:     y;",
          "2014:   unsigned short",
          "2015:     c0,",
          "2016:     c1;",
          "2018:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2019:   {",
          "2020:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2021:     {",
          "2023:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2024:                          Min(4, dds_info->height - y),exception);",
          "2026:       if (q == (Quantum *) NULL)",
          "2027:         return MagickFalse;",
          "2030:       a0 = ReadBlobLSBLong(image);",
          "2031:       a1 = ReadBlobLSBLong(image);",
          "2034:       c0 = ReadBlobLSBShort(image);",
          "2035:       c1 = ReadBlobLSBShort(image);",
          "2036:       bits = ReadBlobLSBLong(image);",
          "2038:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2041:       for (j = 0; j < 4; j++)",
          "2042:       {",
          "2043:         for (i = 0; i < 4; i++)",
          "2044:         {",
          "2045:           if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)",
          "2046:             {",
          "2047:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2048:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2049:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2050:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2052:                 Extract alpha value: multiply 0..15 by 17 to get range 0..255",
          "2054:               if (j < 2)",
          "2055:                 alpha = 17U * (unsigned char) ((a0 >> (4*(4*j+i))) & 0xf);",
          "2056:               else",
          "2057:                 alpha = 17U * (unsigned char) ((a1 >> (4*(4*(j-2)+i))) & 0xf);",
          "2058:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2059:               q+=GetPixelChannels(image);",
          "2060:             }",
          "2061:         }",
          "2062:       }",
          "2064:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2065:         return MagickFalse;",
          "2066:     }",
          "2067:   }",
          "2069:   SkipDXTMipmaps(image, dds_info, 16);",
          "2071:   return MagickTrue;",
          "2072: }",
          "2074: static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,",
          "2075:   ExceptionInfo *exception)",
          "2076: {",
          "2077:   DDSColors",
          "2078:     colors;",
          "2080:   MagickSizeType",
          "2081:     alpha_bits;",
          "2083:   register Quantum",
          "2086:   register ssize_t",
          "2087:     i,",
          "2088:     x;",
          "2090:   unsigned char",
          "2091:     a0,",
          "2092:     a1;",
          "2094:   size_t",
          "2095:     alpha,",
          "2096:     bits,",
          "2097:     code,",
          "2098:     alpha_code;",
          "2100:   ssize_t",
          "2101:     j,",
          "2102:     y;",
          "2104:   unsigned short",
          "2105:     c0,",
          "2106:     c1;",
          "2108:   for (y = 0; y < (ssize_t) dds_info->height; y += 4)",
          "2109:   {",
          "2110:     for (x = 0; x < (ssize_t) dds_info->width; x += 4)",
          "2111:     {",
          "2113:       q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),",
          "2114:                          Min(4, dds_info->height - y),exception);",
          "2116:       if (q == (Quantum *) NULL)",
          "2117:         return MagickFalse;",
          "2120:       a0 = (unsigned char) ReadBlobByte(image);",
          "2121:       a1 = (unsigned char) ReadBlobByte(image);",
          "2123:       alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);",
          "2124:       alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);",
          "2127:       c0 = ReadBlobLSBShort(image);",
          "2128:       c1 = ReadBlobLSBShort(image);",
          "2129:       bits = ReadBlobLSBLong(image);",
          "2131:       CalculateColors(c0, c1, &colors, MagickTrue);",
          "2134:       for (j = 0; j < 4; j++)",
          "2135:       {",
          "2136:         for (i = 0; i < 4; i++)",
          "2137:         {",
          "2138:           if ((x + i) < (ssize_t) dds_info->width &&",
          "2139:               (y + j) < (ssize_t) dds_info->height)",
          "2140:             {",
          "2141:               code = (bits >> ((4*j+i)*2)) & 0x3;",
          "2142:               SetPixelRed(image,ScaleCharToQuantum(colors.r[code]),q);",
          "2143:               SetPixelGreen(image,ScaleCharToQuantum(colors.g[code]),q);",
          "2144:               SetPixelBlue(image,ScaleCharToQuantum(colors.b[code]),q);",
          "2146:               alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;",
          "2147:               if (alpha_code == 0)",
          "2148:                 alpha = a0;",
          "2149:               else if (alpha_code == 1)",
          "2150:                 alpha = a1;",
          "2151:               else if (a0 > a1)",
          "2152:                 alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;",
          "2153:               else if (alpha_code == 6)",
          "2154:                 alpha = 0;",
          "2155:               else if (alpha_code == 7)",
          "2156:                 alpha = 255;",
          "2157:               else",
          "2158:                 alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);",
          "2159:               SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) alpha),q);",
          "2160:               q+=GetPixelChannels(image);",
          "2161:             }",
          "2162:         }",
          "2163:       }",
          "2165:       if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2166:         return MagickFalse;",
          "2167:     }",
          "2168:   }",
          "2170:   SkipDXTMipmaps(image, dds_info, 16);",
          "2172:   return MagickTrue;",
          "2173: }",
          "2175: static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,",
          "2176:   ExceptionInfo *exception)",
          "2177: {",
          "2178:   register Quantum",
          "2181:   ssize_t",
          "2182:     x, y;",
          "2184:   unsigned short",
          "2185:     color;",
          "2187:   if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(",
          "2188:     dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))",
          "2189:     ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2190:       image->filename);",
          "2192:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2193:   {",
          "2194:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2196:     if (q == (Quantum *) NULL)",
          "2197:       return MagickFalse;",
          "2199:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2200:     {",
          "2202:       if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2203:         {",
          "2204:            color=ReadBlobShort(image);",
          "2205:            SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2206:              (((color >> 11)/31.0)*255)),q);",
          "2207:            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2208:              ((((unsigned short)(color << 5) >> 10)/63.0)*255)),q);",
          "2209:            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2210:              ((((unsigned short)(color << 11) >> 11)/31.0)*255)),q);",
          "2211:         }",
          "2212:       else",
          "2213:         {",
          "2214:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2215:             ReadBlobByte(image)),q);",
          "2216:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2217:             ReadBlobByte(image)),q);",
          "2218:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2219:             ReadBlobByte(image)),q);",
          "2220:           if (dds_info->pixelformat.rgb_bitcount == 32)",
          "2221:             (void) ReadBlobByte(image);",
          "2222:         }",
          "2223:       q+=GetPixelChannels(image);",
          "2224:     }",
          "2226:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2227:       return MagickFalse;",
          "2228:   }",
          "2230:   SkipRGBMipmaps(image, dds_info, 3);",
          "2232:   return MagickTrue;",
          "2233: }",
          "2235: static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,",
          "2236:   ExceptionInfo *exception)",
          "2237: {",
          "2238:   register Quantum",
          "2241:   ssize_t",
          "2242:     alphaBits,",
          "2243:     x,",
          "2244:     y;",
          "2246:   unsigned short",
          "2247:     color;",
          "2249:   alphaBits=0;",
          "2250:   if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2251:     {",
          "2252:       if (IsBitMask(dds_info->pixelformat,0x7c00,0x03e0,0x001f,0x8000))",
          "2253:         alphaBits=1;",
          "2254:       else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))",
          "2255:         alphaBits=4;",
          "2256:       else",
          "2257:         ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2258:           image->filename);",
          "2259:     }",
          "2261:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "2262:   {",
          "2263:     q = QueueAuthenticPixels(image, 0, y, dds_info->width, 1,exception);",
          "2265:     if (q == (Quantum *) NULL)",
          "2266:       return MagickFalse;",
          "2268:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2269:     {",
          "2270:       if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2271:         {",
          "2272:            color=ReadBlobShort(image);",
          "2273:            if (alphaBits == 1)",
          "2274:              {",
          "2275:                SetPixelAlpha(image,(color & (1 << 15)) ? QuantumRange : 0,q);",
          "2276:                SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2277:                  ((((unsigned short)(color << 1) >> 11)/31.0)*255)),q);",
          "2278:                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2279:                  ((((unsigned short)(color << 6) >> 11)/31.0)*255)),q);",
          "2280:                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2281:                  ((((unsigned short)(color << 11) >> 11)/31.0)*255)),q);",
          "2282:              }",
          "2283:           else",
          "2284:             {",
          "2285:                SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2286:                  (((color >> 12)/15.0)*255)),q);",
          "2287:                SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2288:                  ((((unsigned short)(color << 4) >> 12)/15.0)*255)),q);",
          "2289:                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2290:                  ((((unsigned short)(color << 8) >> 12)/15.0)*255)),q);",
          "2291:                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2292:                  ((((unsigned short)(color << 12) >> 12)/15.0)*255)),q);",
          "2293:             }",
          "2294:         }",
          "2295:       else",
          "2296:         {",
          "2297:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2298:             ReadBlobByte(image)),q);",
          "2299:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2300:             ReadBlobByte(image)),q);",
          "2301:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2302:             ReadBlobByte(image)),q);",
          "2303:           SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2304:             ReadBlobByte(image)),q);",
          "2305:         }",
          "2306:       q+=GetPixelChannels(image);",
          "2307:     }",
          "2309:     if (SyncAuthenticPixels(image,exception) == MagickFalse)",
          "2310:       return MagickFalse;",
          "2311:   }",
          "2313:   SkipRGBMipmaps(image, dds_info, 4);",
          "2315:   return MagickTrue;",
          "2316: }",
          "2320: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2321: %                                                                             %",
          "2322: %                                                                             %",
          "2323: %                                                                             %",
          "2324: %   R e g i s t e r D D S I m a g e                                           %",
          "2325: %                                                                             %",
          "2326: %                                                                             %",
          "2327: %                                                                             %",
          "2328: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2329: %",
          "2330: %  RegisterDDSImage() adds attributes for the DDS image format to",
          "2331: %  the list of supported formats.  The attributes include the image format",
          "2332: %  tag, a method to read and/or write the format, whether the format",
          "2333: %  supports the saving of more than one frame to the same file or blob,",
          "2334: %  whether the format supports native in-memory I/O, and a brief",
          "2335: %  description of the format.",
          "2336: %",
          "2337: %  The format of the RegisterDDSImage method is:",
          "2338: %",
          "2339: %      RegisterDDSImage(void)",
          "2340: %",
          "2342: ModuleExport size_t RegisterDDSImage(void)",
          "2343: {",
          "2344:   MagickInfo",
          "2347:   entry = SetMagickInfo(\"DDS\");",
          "2348:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2349:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2350:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2351:   entry->seekable_stream=MagickTrue;",
          "2352:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2353:   entry->module = ConstantString(\"DDS\");",
          "2354:   (void) RegisterMagickInfo(entry);",
          "2355:   entry = SetMagickInfo(\"DXT1\");",
          "2356:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2357:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2358:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2359:   entry->seekable_stream=MagickTrue;",
          "2360:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2361:   entry->module = ConstantString(\"DDS\");",
          "2362:   (void) RegisterMagickInfo(entry);",
          "2363:   entry = SetMagickInfo(\"DXT5\");",
          "2364:   entry->decoder = (DecodeImageHandler *) ReadDDSImage;",
          "2365:   entry->encoder = (EncodeImageHandler *) WriteDDSImage;",
          "2366:   entry->magick = (IsImageFormatHandler *) IsDDS;",
          "2367:   entry->seekable_stream=MagickTrue;",
          "2368:   entry->description = ConstantString(\"Microsoft DirectDraw Surface\");",
          "2369:   entry->module = ConstantString(\"DDS\");",
          "2370:   (void) RegisterMagickInfo(entry);",
          "2371:   return(MagickImageCoderSignature);",
          "2372: }",
          "2374: static void RemapIndices(const ssize_t *map, const unsigned char *source,",
          "2375:   unsigned char *target)",
          "2376: {",
          "2377:   register ssize_t",
          "2378:     i;",
          "2380:   for (i = 0; i < 16; i++)",
          "2381:   {",
          "2382:     if (map[i] == -1)",
          "2383:       target[i] = 3;",
          "2384:     else",
          "2385:       target[i] = source[map[i]];",
          "2386:   }",
          "2387: }",
          "2390:   Skip the mipmap images for compressed (DXTn) dds files",
          "2392: static void SkipDXTMipmaps(Image *image, DDSInfo *dds_info, int texel_size)",
          "2393: {",
          "2394:   MagickOffsetType",
          "2395:     offset;",
          "2397:   register ssize_t",
          "2398:     i;",
          "2400:   size_t",
          "2401:     h,",
          "2402:     w;",
          "2405:     Only skip mipmaps for textures and cube maps",
          "2407:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2408:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2409:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2410:     {",
          "2411:       w = DIV2(dds_info->width);",
          "2412:       h = DIV2(dds_info->height);",
          "2415:         Mipmapcount includes the main image, so start from one",
          "2417:       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2418:       {",
          "2419:         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;",
          "2420:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2422:         w = DIV2(w);",
          "2423:         h = DIV2(h);",
          "2424:       }",
          "2425:     }",
          "2426: }",
          "2429:   Skip the mipmap images for uncompressed (RGB or RGBA) dds files",
          "2431: static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size)",
          "2432: {",
          "2433:   MagickOffsetType",
          "2434:     offset;",
          "2436:   register ssize_t",
          "2437:     i;",
          "2439:   size_t",
          "2440:     h,",
          "2441:     w;",
          "2444:     Only skip mipmaps for textures and cube maps",
          "2446:   if (dds_info->ddscaps1 & DDSCAPS_MIPMAP",
          "2447:       && (dds_info->ddscaps1 & DDSCAPS_TEXTURE",
          "2448:           || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))",
          "2449:     {",
          "2450:       w = DIV2(dds_info->width);",
          "2451:       h = DIV2(dds_info->height);",
          "2454:         Mipmapcount includes the main image, so start from one",
          "2456:       for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)",
          "2457:       {",
          "2458:         offset = (MagickOffsetType) w * h * pixel_size;",
          "2459:         (void) SeekBlob(image, offset, SEEK_CUR);",
          "2461:         w = DIV2(w);",
          "2462:         h = DIV2(h);",
          "2463:       }",
          "2464:     }",
          "2465: }",
          "2469: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2470: %                                                                             %",
          "2471: %                                                                             %",
          "2472: %                                                                             %",
          "2473: %   U n r e g i s t e r D D S I m a g e                                       %",
          "2474: %                                                                             %",
          "2475: %                                                                             %",
          "2476: %                                                                             %",
          "2477: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2478: %",
          "2479: %  UnregisterDDSImage() removes format registrations made by the",
          "2480: %  DDS module from the list of supported formats.",
          "2481: %",
          "2482: %  The format of the UnregisterDDSImage method is:",
          "2483: %",
          "2484: %      UnregisterDDSImage(void)",
          "2485: %",
          "2487: ModuleExport void UnregisterDDSImage(void)",
          "2488: {",
          "2489:   (void) UnregisterMagickInfo(\"DDS\");",
          "2490:   (void) UnregisterMagickInfo(\"DXT1\");",
          "2491:   (void) UnregisterMagickInfo(\"DXT5\");",
          "2492: }",
          "2494: static void WriteAlphas(Image *image, const ssize_t *alphas, size_t min5,",
          "2495:   size_t max5, size_t min7, size_t max7)",
          "2496: {",
          "2497:   register ssize_t",
          "2498:     i;",
          "2500:   size_t",
          "2501:     err5,",
          "2502:     err7,",
          "2503:     j;",
          "2505:   unsigned char",
          "2506:     indices5[16],",
          "2507:     indices7[16];",
          "2509:   FixRange(min5,max5,5);",
          "2510:   err5 = CompressAlpha(min5,max5,5,alphas,indices5);",
          "2512:   FixRange(min7,max7,7);",
          "2513:   err7 = CompressAlpha(min7,max7,7,alphas,indices7);",
          "2515:   if (err7 < err5)",
          "2516:   {",
          "2517:     for (i=0; i < 16; i++)",
          "2518:     {",
          "2519:       unsigned char",
          "2520:         index;",
          "2522:       index = indices7[i];",
          "2523:       if( index == 0 )",
          "2524:         indices5[i] = 1;",
          "2525:       else if (index == 1)",
          "2526:         indices5[i] = 0;",
          "2527:       else",
          "2528:         indices5[i] = 9 - index;",
          "2529:     }",
          "2531:     min5 = max7;",
          "2532:     max5 = min7;",
          "2533:   }",
          "2535:   (void) WriteBlobByte(image,(unsigned char) min5);",
          "2536:   (void) WriteBlobByte(image,(unsigned char) max5);",
          "2538:   for(i=0; i < 2; i++)",
          "2539:   {",
          "2540:     size_t",
          "2541:       value = 0;",
          "2543:     for (j=0; j < 8; j++)",
          "2544:     {",
          "2545:       size_t index = (size_t) indices5[j + i*8];",
          "2546:       value |= ( index << 3*j );",
          "2547:     }",
          "2549:     for (j=0; j < 3; j++)",
          "2550:     {",
          "2551:       size_t byte = (value >> 8*j) & 0xff;",
          "2552:       (void) WriteBlobByte(image,(unsigned char) byte);",
          "2553:     }",
          "2554:   }",
          "2555: }",
          "2557: static void WriteCompressed(Image *image, const size_t count,",
          "2558:   DDSVector4 *points, const ssize_t *map, const MagickBooleanType clusterFit)",
          "2559: {",
          "2560:   float",
          "2561:     covariance[16];",
          "2563:   DDSVector3",
          "2564:     end,",
          "2565:     principle,",
          "2566:     start;",
          "2568:   DDSVector4",
          "2569:     metric;",
          "2571:   unsigned char",
          "2572:     indices[16];",
          "2574:   VectorInit(metric,1.0f);",
          "2575:   VectorInit3(start,0.0f);",
          "2576:   VectorInit3(end,0.0f);",
          "2578:   ComputeWeightedCovariance(count,points,covariance);",
          "2579:   ComputePrincipleComponent(covariance,&principle);",
          "2581:   if (clusterFit == MagickFalse || count == 0)",
          "2582:     CompressRangeFit(count,points,map,principle,metric,&start,&end,indices);",
          "2583:   else",
          "2584:     CompressClusterFit(count,points,map,principle,metric,&start,&end,indices);",
          "2586:   WriteIndices(image,start,end,indices);",
          "2587: }",
          "2590: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2591: %                                                                             %",
          "2592: %                                                                             %",
          "2593: %                                                                             %",
          "2594: %   W r i t e D D S I m a g e                                                 %",
          "2595: %                                                                             %",
          "2596: %                                                                             %",
          "2597: %                                                                             %",
          "2598: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "2599: %",
          "2600: %  WriteDDSImage() writes a DirectDraw Surface image file in the DXT5 format.",
          "2601: %",
          "2602: %  The format of the WriteBMPImage method is:",
          "2603: %",
          "2604: %     MagickBooleanType WriteDDSImage(const ImageInfo *image_info,Image *image)",
          "2605: %",
          "2606: %  A description of each parameter follows.",
          "2607: %",
          "2608: %    o image_info: the image info.",
          "2609: %",
          "2610: %    o image:  The image.",
          "2611: %",
          "2613: static MagickBooleanType WriteDDSImage(const ImageInfo *image_info,",
          "2614:   Image *image, ExceptionInfo *exception)",
          "2615: {",
          "2616:   const char",
          "2619:   size_t",
          "2620:     compression,",
          "2621:     columns,",
          "2622:     maxMipmaps,",
          "2623:     mipmaps,",
          "2624:     pixelFormat,",
          "2625:     rows;",
          "2627:   MagickBooleanType",
          "2628:     clusterFit,",
          "2629:     status,",
          "2630:     weightByAlpha;",
          "2632:   assert(image_info != (const ImageInfo *) NULL);",
          "2633:   assert(image_info->signature == MagickSignature);",
          "2634:   assert(image != (Image *) NULL);",
          "2635:   assert(image->signature == MagickSignature);",
          "2636:   if (image->debug != MagickFalse)",
          "2637:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);",
          "2638:   status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);",
          "2639:   if (status == MagickFalse)",
          "2640:     return(status);",
          "2641:   (void) TransformImageColorspace(image,sRGBColorspace,exception);",
          "2642:   pixelFormat=DDPF_FOURCC;",
          "2643:   compression=FOURCC_DXT5;",
          "2645:   if (image->alpha_trait != BlendPixelTrait)",
          "2646:     compression=FOURCC_DXT1;",
          "2648:   if (LocaleCompare(image_info->magick,\"dxt1\") == 0)",
          "2649:     compression=FOURCC_DXT1;",
          "2651:   option=GetImageOption(image_info,\"dds:compression\");",
          "2652:   if (option != (char *) NULL)",
          "2653:     {",
          "2654:        if (LocaleCompare(option,\"dxt1\") == 0)",
          "2655:          compression=FOURCC_DXT1;",
          "2656:        if (LocaleCompare(option,\"none\") == 0)",
          "2657:          pixelFormat=DDPF_RGB;",
          "2658:     }",
          "2660:   clusterFit=MagickFalse;",
          "2661:   weightByAlpha=MagickFalse;",
          "2663:   if (pixelFormat == DDPF_FOURCC)",
          "2664:     {",
          "2665:       option=GetImageOption(image_info,\"dds:cluster-fit\");",
          "2666:       if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2667:         {",
          "2668:           clusterFit=MagickTrue;",
          "2669:           if (compression != FOURCC_DXT1)",
          "2670:             {",
          "2671:               option=GetImageOption(image_info,\"dds:weight-by-alpha\");",
          "2672:               if (option != (char *) NULL && LocaleCompare(option,\"true\") == 0)",
          "2673:                 weightByAlpha=MagickTrue;",
          "2674:             }",
          "2675:         }",
          "2676:     }",
          "2678:   maxMipmaps=SIZE_MAX;",
          "2679:   mipmaps=0;",
          "2680:   if ((image->columns & (image->columns - 1)) == 0 &&",
          "2681:       (image->rows & (image->rows - 1)) == 0)",
          "2682:     {",
          "2683:       option=GetImageOption(image_info,\"dds:mipmaps\");",
          "2684:       if (option != (char *) NULL)",
          "2685:         maxMipmaps=StringToUnsignedLong(option);",
          "2687:       if (maxMipmaps != 0)",
          "2688:         {",
          "2689:           columns=image->columns;",
          "2690:           rows=image->rows;",
          "2691:           while (columns != 1 && rows != 1 && mipmaps != maxMipmaps)",
          "2692:           {",
          "2693:             columns=DIV2(columns);",
          "2694:             rows=DIV2(rows);",
          "2695:             mipmaps++;",
          "2696:           }",
          "2697:         }",
          "2698:     }",
          "2700:   WriteDDSInfo(image,pixelFormat,compression,mipmaps);",
          "2702:   WriteImageData(image,pixelFormat,compression,clusterFit,weightByAlpha,",
          "2703:     exception);",
          "2705:   if (mipmaps > 0 && WriteMipmaps(image,pixelFormat,compression,mipmaps,",
          "2706:         clusterFit,weightByAlpha,exception) == MagickFalse)",
          "2707:     return(MagickFalse);",
          "2709:   (void) CloseBlob(image);",
          "2710:   return(MagickTrue);",
          "2711: }",
          "2713: static void WriteDDSInfo(Image *image, const size_t pixelFormat,",
          "2714:   const size_t compression, const size_t mipmaps)",
          "2715: {",
          "2716:   char",
          "2717:     software[MaxTextExtent];",
          "2719:   register ssize_t",
          "2720:     i;",
          "2722:   unsigned int",
          "2723:     format,",
          "2724:     caps,",
          "2725:     flags;",
          "2727:   flags=(unsigned int) (DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT |",
          "2728:     DDSD_PIXELFORMAT | DDSD_LINEARSIZE);",
          "2729:   caps=(unsigned int) DDSCAPS_TEXTURE;",
          "2730:   format=(unsigned int) pixelFormat;",
          "2732:   if (mipmaps > 0)",
          "2733:     {",
          "2734:       flags=flags | (unsigned int) DDSD_MIPMAPCOUNT;",
          "2735:       caps=caps | (unsigned int) (DDSCAPS_MIPMAP | DDSCAPS_COMPLEX);",
          "2736:     }",
          "2738:   if (format != DDPF_FOURCC && image->alpha_trait == BlendPixelTrait)",
          "2739:     format=format | DDPF_ALPHAPIXELS;",
          "2741:   (void) WriteBlob(image,4,(unsigned char *) \"DDS \");",
          "2742:   (void) WriteBlobLSBLong(image,124);",
          "2743:   (void) WriteBlobLSBLong(image,flags);",
          "2744:   (void) WriteBlobLSBLong(image,image->rows);",
          "2745:   (void) WriteBlobLSBLong(image,image->columns);",
          "2747:   if (compression == FOURCC_DXT1)",
          "2748:     (void) WriteBlobLSBLong(image,",
          "2749:              (unsigned int) (Max(1,(image->columns+3)/4) * 8));",
          "2750:   else",
          "2751:     (void) WriteBlobLSBLong(image,",
          "2752:              (unsigned int) (Max(1,(image->columns+3)/4) * 16));",
          "2754:   (void) WriteBlobLSBLong(image,0x00);",
          "2755:   (void) WriteBlobLSBLong(image,(unsigned int) mipmaps+1);",
          "2756:   (void) ResetMagickMemory(software,0,sizeof(software));",
          "2757:   (void) strcpy(software,\"IMAGEMAGICK\");",
          "2758:   (void) WriteBlob(image,44,(unsigned char *) software);",
          "2760:   (void) WriteBlobLSBLong(image,32);",
          "2761:   (void) WriteBlobLSBLong(image,format);",
          "2763:   if (pixelFormat == DDPF_FOURCC)",
          "2764:     {",
          "2765:       (void) WriteBlobLSBLong(image,(unsigned int) compression);",
          "2766:       for(i=0;i < 5;i++) // bitcount / masks",
          "2767:         (void) WriteBlobLSBLong(image,0x00);",
          "2768:     }",
          "2769:   else",
          "2770:     {",
          "2771:       (void) WriteBlobLSBLong(image,0x00);",
          "2772:       if (image->alpha_trait == BlendPixelTrait)",
          "2773:         {",
          "2774:           (void) WriteBlobLSBLong(image,32);",
          "2775:           (void) WriteBlobLSBLong(image,0xff0000);",
          "2776:           (void) WriteBlobLSBLong(image,0xff00);",
          "2777:           (void) WriteBlobLSBLong(image,0xff);",
          "2778:           (void) WriteBlobLSBLong(image,0xff000000);",
          "2779:         }",
          "2780:       else",
          "2781:         {",
          "2782:           (void) WriteBlobLSBLong(image,24);",
          "2783:           (void) WriteBlobLSBLong(image,0xff);",
          "2784:           (void) WriteBlobLSBLong(image,0x00);",
          "2785:           (void) WriteBlobLSBLong(image,0x00);",
          "2786:           (void) WriteBlobLSBLong(image,0x00);",
          "2787:         }",
          "2788:     }",
          "2790:   (void) WriteBlobLSBLong(image,caps);",
          "2791:   for(i=0;i < 4;i++) // ddscaps2 + reserved region",
          "2792:     (void) WriteBlobLSBLong(image,0x00);",
          "2793: }",
          "2795: static void WriteFourCC(Image *image, const size_t compression,",
          "2796:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "2797:   ExceptionInfo *exception)",
          "2798: {",
          "2799:   register ssize_t",
          "2800:     x;",
          "2802:   ssize_t",
          "2803:     i,",
          "2804:     y,",
          "2805:     bx,",
          "2806:     by;",
          "2808:   register const Quantum",
          "2811:   for (y=0; y < (ssize_t) image->rows; y+=4)",
          "2812:   {",
          "2813:     for (x=0; x < (ssize_t) image->columns; x+=4)",
          "2814:     {",
          "2815:       MagickBooleanType",
          "2816:         match;",
          "2818:       DDSVector4",
          "2819:         point,",
          "2820:         points[16];",
          "2822:       size_t",
          "2823:         count = 0,",
          "2824:         max5 = 0,",
          "2825:         max7 = 0,",
          "2826:         min5 = 255,",
          "2827:         min7 = 255,",
          "2828:         columns = 4,",
          "2829:         rows = 4;",
          "2831:       ssize_t",
          "2832:         alphas[16],",
          "2833:         map[16];",
          "2835:       unsigned char",
          "2836:         alpha;",
          "2838:       if (x + columns >= image->columns)",
          "2839:         columns = image->columns - x;",
          "2841:       if (y + rows >= image->rows)",
          "2842:         rows = image->rows - y;",
          "2844:       p=GetVirtualPixels(image,x,y,columns,rows,exception);",
          "2845:       if (p == (const Quantum *) NULL)",
          "2846:         break;",
          "2848:       for (i=0; i<16; i++)",
          "2849:       {",
          "2850:         map[i] = -1;",
          "2851:         alphas[i] = -1;",
          "2852:       }",
          "2854:       for (by=0; by <  (ssize_t) rows; by++)",
          "2855:       {",
          "2856:         for (bx=0; bx <  (ssize_t) columns; bx++)",
          "2857:         {",
          "2858:           if (compression == FOURCC_DXT5)",
          "2859:             alpha = ScaleQuantumToChar(GetPixelAlpha(image,p));",
          "2860:           else",
          "2861:             alpha = 255;",
          "2863:           alphas[4*by + bx] = (size_t)alpha;",
          "2865:           point.x = (float)ScaleQuantumToChar(GetPixelRed(image,p)) / 255.0f;",
          "2866:           point.y = (float)ScaleQuantumToChar(GetPixelGreen(image,p)) / 255.0f;",
          "2867:           point.z = (float)ScaleQuantumToChar(GetPixelBlue(image,p)) / 255.0f;",
          "2868:           point.w = weightByAlpha ? (float)(alpha + 1) / 256.0f : 1.0f;",
          "2869:           p+=GetPixelChannels(image);",
          "2871:           match = MagickFalse;",
          "2872:           for (i=0; i <  (ssize_t) count; i++)",
          "2873:           {",
          "2874:             if ((points[i].x == point.x) &&",
          "2875:                 (points[i].y == point.y) &&",
          "2876:                 (points[i].z == point.z) &&",
          "2877:                 (alpha       >= 128 || compression == FOURCC_DXT5))",
          "2878:               {",
          "2879:                 points[i].w += point.w;",
          "2880:                 map[4*by + bx] = i;",
          "2881:                 match = MagickTrue;",
          "2882:                 break;",
          "2883:               }",
          "2884:             }",
          "2886:             if (match != MagickFalse)",
          "2887:               continue;",
          "2889:             points[count].x = point.x;",
          "2890:             points[count].y = point.y;",
          "2891:             points[count].z = point.z;",
          "2892:             points[count].w = point.w;",
          "2893:             map[4*by + bx] = count;",
          "2894:             count++;",
          "2896:             if (compression == FOURCC_DXT5)",
          "2897:               {",
          "2898:                 if (alpha < min7)",
          "2899:                   min7 = alpha;",
          "2900:                 if (alpha > max7)",
          "2901:                   max7 = alpha;",
          "2902:                 if (alpha != 0 && alpha < min5)",
          "2903:                   min5 = alpha;",
          "2904:                 if (alpha != 255 && alpha > max5)",
          "2905:                   max5 = alpha;",
          "2906:               }",
          "2907:           }",
          "2908:         }",
          "2910:       for (i=0; i <  (ssize_t) count; i++)",
          "2911:         points[i].w = sqrt(points[i].w);",
          "2913:       if (compression == FOURCC_DXT5)",
          "2914:         WriteAlphas(image,alphas,min5,max5,min7,max7);",
          "2916:       if (count == 1)",
          "2917:         WriteSingleColorFit(image,points,map);",
          "2918:       else",
          "2919:         WriteCompressed(image,count,points,map,clusterFit);",
          "2920:     }",
          "2921:   }",
          "2922: }",
          "2924: static void WriteImageData(Image *image, const size_t pixelFormat,",
          "2925:   const size_t compression,const MagickBooleanType clusterFit,",
          "2926:   const MagickBooleanType weightByAlpha, ExceptionInfo *exception)",
          "2927: {",
          "2928:   if (pixelFormat == DDPF_FOURCC)",
          "2929:     WriteFourCC(image,compression,clusterFit,weightByAlpha,exception);",
          "2930:   else",
          "2931:     WriteUncompressed(image,exception);",
          "2932: }",
          "2934: static inline size_t ClampToLimit(const float value, const size_t limit)",
          "2935: {",
          "2936:   size_t",
          "2937:     result = (int) (value + 0.5f);",
          "2939:   if (result < 0.0f)",
          "2940:     return(0);",
          "2941:   if (result > limit)",
          "2942:     return(limit);",
          "2943:   return result;",
          "2944: }",
          "2946: static inline size_t ColorTo565(const DDSVector3 point)",
          "2947: {",
          "2948:   size_t r = ClampToLimit(31.0f*point.x,31);",
          "2949:   size_t g = ClampToLimit(63.0f*point.y,63);",
          "2950:   size_t b = ClampToLimit(31.0f*point.z,31);",
          "2952:   return (r << 11) | (g << 5) | b;",
          "2953: }",
          "2955: static void WriteIndices(Image *image, const DDSVector3 start,",
          "2956:   const DDSVector3 end, unsigned char *indices)",
          "2957: {",
          "2958:   register ssize_t",
          "2959:     i;",
          "2961:   size_t",
          "2962:     a,",
          "2963:     b;",
          "2965:   unsigned char",
          "2966:     remapped[16];",
          "2968:   const unsigned char",
          "2971:   a = ColorTo565(start);",
          "2972:   b = ColorTo565(end);",
          "2974:   for (i=0; i<16; i++)",
          "2975:   {",
          "2976:     if( a < b )",
          "2977:       remapped[i] = (indices[i] ^ 0x1) & 0x3;",
          "2978:     else if( a == b )",
          "2979:       remapped[i] = 0;",
          "2980:     else",
          "2981:       remapped[i] = indices[i];",
          "2982:   }",
          "2984:   if( a < b )",
          "2985:     Swap(a,b);",
          "2987:   (void) WriteBlobByte(image,(unsigned char) (a & 0xff));",
          "2988:   (void) WriteBlobByte(image,(unsigned char) (a >> 8));",
          "2989:   (void) WriteBlobByte(image,(unsigned char) (b & 0xff));",
          "2990:   (void) WriteBlobByte(image,(unsigned char) (b >> 8));",
          "2992:   for (i=0; i<4; i++)",
          "2993:   {",
          "2994:      ind = remapped + 4*i;",
          "2995:      (void) WriteBlobByte(image,ind[0] | (ind[1] << 2) | (ind[2] << 4) |",
          "2996:        (ind[3] << 6));",
          "2997:   }",
          "2998: }",
          "3000: static MagickBooleanType WriteMipmaps(Image *image, const size_t pixelFormat,",
          "3001:   const size_t compression, const size_t mipmaps,",
          "3002:   const MagickBooleanType clusterFit, const MagickBooleanType weightByAlpha,",
          "3003:   ExceptionInfo *exception)",
          "3004: {",
          "3005:   Image*",
          "3006:     resize_image;",
          "3008:   register ssize_t",
          "3009:     i;",
          "3011:   size_t",
          "3012:     columns,",
          "3013:     rows;",
          "3015:   columns = image->columns;",
          "3016:   rows = image->rows;",
          "3018:   for (i=0; i< (ssize_t) mipmaps; i++)",
          "3019:   {",
          "3020:     resize_image = ResizeImage(image,columns/2,rows/2,TriangleFilter,",
          "3021:       exception);",
          "3023:     if (resize_image == (Image *) NULL)",
          "3024:       return(MagickFalse);",
          "3026:     DestroyBlob(resize_image);",
          "3027:     resize_image->blob=ReferenceBlob(image->blob);",
          "3029:     WriteImageData(resize_image,pixelFormat,compression,weightByAlpha,",
          "3030:       clusterFit,exception);",
          "3032:     resize_image=DestroyImage(resize_image);",
          "3034:     columns = DIV2(columns);",
          "3035:     rows = DIV2(rows);",
          "3036:   }",
          "3038:   return(MagickTrue);",
          "3039: }",
          "3041: static void WriteSingleColorFit(Image *image, const DDSVector4 *points,",
          "3042:   const ssize_t *map)",
          "3043: {",
          "3044:   DDSVector3",
          "3045:     start,",
          "3046:     end;",
          "3048:   register ssize_t",
          "3049:     i;",
          "3051:   unsigned char",
          "3052:     color[3],",
          "3053:     index,",
          "3054:     indexes[16],",
          "3055:     indices[16];",
          "3057:   color[0] = (unsigned char) ClampToLimit(255.0f*points->x,255);",
          "3058:   color[1] = (unsigned char) ClampToLimit(255.0f*points->y,255);",
          "3059:   color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);",
          "3061:   index=0;",
          "3062:   ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);",
          "3064:   for (i=0; i< 16; i++)",
          "3065:     indexes[i]=index;",
          "3066:   RemapIndices(map,indexes,indices);",
          "3067:   WriteIndices(image,start,end,indices);",
          "3068: }",
          "3070: static void WriteUncompressed(Image *image, ExceptionInfo *exception)",
          "3071: {",
          "3072:   register const Quantum",
          "3075:   register ssize_t",
          "3076:     x;",
          "3078:   ssize_t",
          "3079:     y;",
          "3081:   for (y=0; y < (ssize_t) image->rows; y++)",
          "3082:   {",
          "3083:     p=GetVirtualPixels(image,0,y,image->columns,1,exception);",
          "3084:     if (p == (const Quantum *) NULL)",
          "3085:       break;",
          "3087:     for (x=0; x < (ssize_t) image->columns; x++)",
          "3088:     {",
          "3089:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelBlue(image,p)));",
          "3090:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelGreen(image,p)));",
          "3091:       (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(image,p)));",
          "3092:       if (image->alpha_trait == BlendPixelTrait)",
          "3093:         (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelAlpha(image,p)));",
          "3094:       p+=GetPixelChannels(image);",
          "3095:     }",
          "3096:   }",
          "3097: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9388ef4adb3c897713b738d722c2858d61a512d9",
      "candidate_info": {
        "commit_hash": "9388ef4adb3c897713b738d722c2858d61a512d9",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/9388ef4adb3c897713b738d722c2858d61a512d9",
        "files": [
          "coders/dds.c"
        ],
        "message": "Added support for R5G6B5, RGB5A1 and RGBA4 dds files.",
        "before_after_code_files": [
          "coders/dds.c||coders/dds.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/dds.c||coders/dds.c"
          ],
          "candidate": [
            "coders/dds.c||coders/dds.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/dds.c||coders/dds.c": [
          "File: coders/dds.c -> coders/dds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "748: #define Dot(left, right) (left.x*right.x) + (left.y*right.y) + (left.z*right.z)",
          "750: #define VectorInit(vector, value) vector.x = vector.y = vector.z = vector.w \\",
          "751:   = value",
          "752: #define VectorInit3(vector, value) vector.x = vector.y = vector.z = value",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "752: #define VectorInit3(vector, value) vector.x = vector.y = vector.z = value",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2170: }",
          "2172: static MagickBooleanType ReadUncompressedRGB(Image *image, DDSInfo *dds_info,",
          "2176:     x, y;",
          "2178:   register Quantum",
          "2181:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "",
          "[Removed Lines]",
          "2173:   ExceptionInfo *exception)",
          "2174: {",
          "2175:   ssize_t",
          "",
          "[Added Lines]",
          "2181:   ssize_t",
          "2182:     x, y;",
          "2184:   unsigned short",
          "2185:     color;",
          "2187:   if (dds_info->pixelformat.rgb_bitcount == 16 && !IsBitMask(",
          "2188:     dds_info->pixelformat,0xf800,0x07e0,0x001f,0x0000))",
          "2189:     ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2185:     if (q == (Quantum *) NULL)",
          "2186:       return MagickFalse;",
          "2196:       if (dds_info->pixelformat.rgb_bitcount == 32)",
          "2197:         (void) ReadBlobByte(image);",
          "2198:       q+=GetPixelChannels(image);",
          "",
          "[Removed Lines]",
          "2188:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2189:     {",
          "2190:       SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2191:         ReadBlobByte(image)),q);",
          "2192:       SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2193:         ReadBlobByte(image)),q);",
          "2194:       SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2195:         ReadBlobByte(image)),q);",
          "",
          "[Added Lines]",
          "2200:     {",
          "2202:       if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2203:         {",
          "2204:            color=ReadBlobShort(image);",
          "2205:            SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2206:              (((color >> 11)/31.0)*255)),q);",
          "2207:            SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2208:              ((((unsigned short)(color << 5) >> 10)/63.0)*255)),q);",
          "2209:            SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2210:              ((((unsigned short)(color << 11) >> 11)/31.0)*255)),q);",
          "2211:         }",
          "2212:       else",
          "2213:         {",
          "2214:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2215:             ReadBlobByte(image)),q);",
          "2216:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2217:             ReadBlobByte(image)),q);",
          "2218:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2219:             ReadBlobByte(image)),q);",
          "2220:           if (dds_info->pixelformat.rgb_bitcount == 32)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2208: }",
          "2210: static MagickBooleanType ReadUncompressedRGBA(Image *image, DDSInfo *dds_info,",
          "2214:     x, y;",
          "2216:   register Quantum",
          "2219:   for (y = 0; y < (ssize_t) dds_info->height; y++)",
          "",
          "[Removed Lines]",
          "2211:   ExceptionInfo *exception)",
          "2212: {",
          "2213:   ssize_t",
          "",
          "[Added Lines]",
          "2241:   ssize_t",
          "2242:     alphaBits,",
          "2243:     x,",
          "2244:     y;",
          "2246:   unsigned short",
          "2247:     color;",
          "2249:   alphaBits=0;",
          "2250:   if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2251:     {",
          "2252:       if (IsBitMask(dds_info->pixelformat,0x7c00,0x03e0,0x001f,0x8000))",
          "2253:         alphaBits=1;",
          "2254:       else if (IsBitMask(dds_info->pixelformat,0x0f00,0x00f0,0x000f,0xf000))",
          "2255:         alphaBits=4;",
          "2256:       else",
          "2257:         ThrowBinaryException(CorruptImageError,\"ImageTypeNotSupported\",",
          "2258:           image->filename);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2223:     if (q == (Quantum *) NULL)",
          "2224:       return MagickFalse;",
          "2234:       SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2235:         ReadBlobByte(image)),q);",
          "2236:       q+=GetPixelChannels(image);",
          "",
          "[Removed Lines]",
          "2226:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2227:     {",
          "2228:       SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2229:         ReadBlobByte(image)),q);",
          "2230:       SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2231:         ReadBlobByte(image)),q);",
          "2232:       SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2233:         ReadBlobByte(image)),q);",
          "",
          "[Added Lines]",
          "2268:     for (x = 0; x < (ssize_t) dds_info->width; x++)",
          "2269:     {",
          "2270:       if (dds_info->pixelformat.rgb_bitcount == 16)",
          "2271:         {",
          "2272:            color=ReadBlobShort(image);",
          "2273:            if (alphaBits == 1)",
          "2274:              {",
          "2275:                SetPixelAlpha(image,(color & (1 << 15)) ? QuantumRange : 0,q);",
          "2276:                SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2277:                  ((((unsigned short)(color << 1) >> 11)/31.0)*255)),q);",
          "2278:                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2279:                  ((((unsigned short)(color << 6) >> 11)/31.0)*255)),q);",
          "2280:                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2281:                  ((((unsigned short)(color << 11) >> 11)/31.0)*255)),q);",
          "2282:              }",
          "2283:           else",
          "2284:             {",
          "2285:                SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "2286:                  (((color >> 12)/15.0)*255)),q);",
          "2287:                SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2288:                  ((((unsigned short)(color << 4) >> 12)/15.0)*255)),q);",
          "2289:                SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2290:                  ((((unsigned short)(color << 8) >> 12)/15.0)*255)),q);",
          "2291:                SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2292:                  ((((unsigned short)(color << 12) >> 12)/15.0)*255)),q);",
          "2293:             }",
          "2294:         }",
          "2295:       else",
          "2296:         {",
          "2297:           SetPixelBlue(image,ScaleCharToQuantum((unsigned char)",
          "2298:             ReadBlobByte(image)),q);",
          "2299:           SetPixelGreen(image,ScaleCharToQuantum((unsigned char)",
          "2300:             ReadBlobByte(image)),q);",
          "2301:           SetPixelRed(image,ScaleCharToQuantum((unsigned char)",
          "2302:             ReadBlobByte(image)),q);",
          "2303:           SetPixelAlpha(image,ScaleCharToQuantum((unsigned char)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ee684c5ed18df4cc703e00c783f7ea89fbb500fe",
      "candidate_info": {
        "commit_hash": "ee684c5ed18df4cc703e00c783f7ea89fbb500fe",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/ee684c5ed18df4cc703e00c783f7ea89fbb500fe",
        "files": [
          "coders/dds.c"
        ],
        "message": "Added NULL checks.",
        "before_after_code_files": [
          "coders/dds.c||coders/dds.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/dds.c||coders/dds.c"
          ],
          "candidate": [
            "coders/dds.c||coders/dds.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/dds.c||coders/dds.c": [
          "File: coders/dds.c -> coders/dds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1705:   PixelTrait",
          "1706:     alpha_trait;",
          "1709:     n, num_images;",
          "",
          "[Removed Lines]",
          "1708:   size_t",
          "",
          "[Added Lines]",
          "1708:   size_t",
          "1709:     n,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1822:     if (n != 0)",
          "1823:       {",
          "1829:             return((Image *) NULL);",
          "1830:           }",
          "1831:         image=SyncNextImageInList(image);",
          "",
          "[Removed Lines]",
          "1825:         AcquireNextImage(image_info,image,exception);",
          "1826:         if (GetNextImageInList(image) == (Image *) NULL)",
          "1827:           {",
          "1828:             image = DestroyImageList(image);",
          "",
          "[Added Lines]",
          "1826:         AcquireNextImage(image_info,image,exception);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2770:       if (x + columns >= image->columns)",
          "2771:         columns = image->columns - x;",
          "2773:       if (y + rows >= image->rows)",
          "2774:         rows = image->rows - y;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2771:       if (y + rows >= image->rows)",
          "2772:         rows = image->rows - y;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3008:   ssize_t",
          "3009:     y;",
          "3011:   for (y=0; y < (ssize_t) image->rows; y++)",
          "3012:   {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3011:   for (y=0; y < (ssize_t) image->rows; y++)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "210600bead5f8709a8e64c3f11203d0e954fd47c",
      "candidate_info": {
        "commit_hash": "210600bead5f8709a8e64c3f11203d0e954fd47c",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/210600bead5f8709a8e64c3f11203d0e954fd47c",
        "files": [
          "coders/dds.c"
        ],
        "message": "Fix in single color fit.",
        "before_after_code_files": [
          "coders/dds.c||coders/dds.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "coders/dds.c||coders/dds.c"
          ],
          "candidate": [
            "coders/dds.c||coders/dds.c"
          ]
        }
      },
      "candidate_diff": {
        "coders/dds.c||coders/dds.c": [
          "File: coders/dds.c -> coders/dds.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2968:   return(MagickTrue);",
          "2969: }",
          "2971: static void WriteSingleColorFit(Image *image, const DDSVector4 *points,",
          "2972:   const ssize_t *map)",
          "2973: {",
          "2974:   unsigned char",
          "2979:   DDSVector3",
          "2980:     start,",
          "2981:     end;",
          "2983:   color[0] = (unsigned char) ClampToLimit(255.0f*points->x,255);",
          "2984:   color[1] = (unsigned char) ClampToLimit(255.0f*points->y,255);",
          "2987:   ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);",
          "",
          "[Removed Lines]",
          "2975:     color[3],",
          "2976:     index,",
          "2977:     indices[16];",
          "2985:   color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);",
          "",
          "[Added Lines]",
          "2971: static void WriteSingleColorFit(Image *image, const DDSVector4 *points,",
          "2972:   const ssize_t *map)",
          "2973: {",
          "2974:   DDSVector3",
          "2975:     start,",
          "2976:     end;",
          "2989:   color[2] = (unsigned char) ClampToLimit(255.0f*points->z,255);",
          "2991:   ComputeEndPoints(DDS_LOOKUP,color,&start,&end,&index);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-8066",
  "cve_desc": "drivers/net/can/usb/gs_usb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.2 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",
  "repo": "torvalds/linux",
  "patch_hash": "c919a3069c775c1c876bec55e00b2305d5125caa",
  "patch_info": {
    "commit_hash": "c919a3069c775c1c876bec55e00b2305d5125caa",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c919a3069c775c1c876bec55e00b2305d5125caa",
    "files": [
      "drivers/net/can/usb/gs_usb.c"
    ],
    "message": "can: gs_usb: Don't use stack memory for USB transfers\n\nFixes: 05ca5270005c can: gs_usb: add ethtool set_phys_id callback to locate physical device\n\nThe gs_usb driver is performing USB transfers using buffers allocated on\nthe stack. This causes the driver to not function with vmapped stacks.\nInstead, allocate memory for the transfer buffers.\n\nSigned-off-by: Ethan Zonca <e@ethanzonca.com>\nCc: linux-stable <stable@vger.kernel.org> # >= v4.8\nSigned-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",
    "before_after_code_files": [
      "drivers/net/can/usb/gs_usb.c||drivers/net/can/usgs_usb.c"
    ]
  },
  "patch_diff": {
    "drivers/net/can/usb/gs_usb.c||drivers/net/can/usgs_usb.c": [
      "File: drivers/net/can/usb/gs_usb.c -> drivers/net/can/usgs_usb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "908:  struct gs_usb *dev;",
      "909:  int rc = -ENOMEM;",
      "910:  unsigned int icount, i;",
      "917:  rc = usb_control_msg(interface_to_usbdev(intf),",
      "",
      "[Removed Lines]",
      "911:  struct gs_host_config hconf = {",
      "912:   .byte_order = 0x0000beef,",
      "913:  };",
      "914:  struct gs_device_config dconf;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "920:         USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,",
      "921:         1,",
      "922:         intf->altsetting[0].desc.bInterfaceNumber,",
      "925:         1000);",
      "927:  if (rc < 0) {",
      "928:   dev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",",
      "929:    rc);",
      "930:   return rc;",
      "931:  }",
      "934:  rc = usb_control_msg(interface_to_usbdev(intf),",
      "935:         usb_rcvctrlpipe(interface_to_usbdev(intf), 0),",
      "",
      "[Removed Lines]",
      "923:         &hconf,",
      "924:         sizeof(hconf),",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "937:         USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,",
      "938:         1,",
      "939:         intf->altsetting[0].desc.bInterfaceNumber,",
      "942:         1000);",
      "943:  if (rc < 0) {",
      "944:   dev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",",
      "945:    rc);",
      "946:   return rc;",
      "947:  }",
      "950:  dev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);",
      "952:  if (icount > GS_MAX_INTF) {",
      "953:   dev_err(&intf->dev,",
      "954:    \"Driver cannot handle more that %d CAN interfaces\\n\",",
      "955:    GS_MAX_INTF);",
      "956:   return -EINVAL;",
      "957:  }",
      "959:  dev = kzalloc(sizeof(*dev), GFP_KERNEL);",
      "961:   return -ENOMEM;",
      "962:  init_usb_anchor(&dev->rx_submitted);",
      "964:  atomic_set(&dev->active_channels, 0);",
      "",
      "[Removed Lines]",
      "940:         &dconf,",
      "941:         sizeof(dconf),",
      "949:  icount = dconf.icount + 1;",
      "960:  if (!dev)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "967:  dev->udev = interface_to_usbdev(intf);",
      "969:  for (i = 0; i < icount; i++) {",
      "971:   if (IS_ERR_OR_NULL(dev->canch[i])) {",
      "973:    rc = PTR_ERR(dev->canch[i]);",
      "",
      "[Removed Lines]",
      "970:   dev->canch[i] = gs_make_candev(i, intf, &dconf);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "978:     gs_destroy_candev(dev->canch[i]);",
      "980:    usb_kill_anchored_urbs(&dev->rx_submitted);",
      "981:    kfree(dev);",
      "982:    return rc;",
      "983:   }",
      "984:   dev->canch[i]->parent = dev;",
      "985:  }",
      "987:  return 0;",
      "988: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "05ca5270005c18ec46decacef87992ea968f9fce",
      "candidate_info": {
        "commit_hash": "05ca5270005c18ec46decacef87992ea968f9fce",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/05ca5270005c18ec46decacef87992ea968f9fce",
        "files": [
          "drivers/net/can/usb/gs_usb.c"
        ],
        "message": "can: gs_usb: add ethtool set_phys_id callback to locate physical device\n\nThis patch Implements the ethtool set_phys_id callback to ease the\nlocating of specific physical devices. Currently only supported on\ncandleLight interfaces.\n\nSigned-off-by: Hubert Denkmair <hubert@denkmair.de>\nSigned-off-by: Maximilian Schneider <max@schneidersoft.net>\n[mkl: split codingstyle change sinto separate patch]\nSigned-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",
        "before_after_code_files": [
          "drivers/net/can/usb/gs_usb.c||drivers/net/can/usb/gs_usb.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/net/can/usb/gs_usb.c||drivers/net/can/usgs_usb.c"
          ],
          "candidate": [
            "drivers/net/can/usb/gs_usb.c||drivers/net/can/usb/gs_usb.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/can/usb/gs_usb.c||drivers/net/can/usb/gs_usb.c": [
          "File: drivers/net/can/usb/gs_usb.c -> drivers/net/can/usb/gs_usb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39:  GS_USB_BREQ_MODE,",
          "40:  GS_USB_BREQ_BERR,",
          "41:  GS_USB_BREQ_BT_CONST,",
          "43: };",
          "45: enum gs_can_mode {",
          "",
          "[Removed Lines]",
          "42:  GS_USB_BREQ_DEVICE_CONFIG",
          "",
          "[Added Lines]",
          "42:  GS_USB_BREQ_DEVICE_CONFIG,",
          "43:  GS_USB_BREQ_TIMESTAMP,",
          "44:  GS_USB_BREQ_IDENTIFY,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "58:  GS_CAN_STATE_SLEEPING",
          "59: };",
          "62: struct gs_host_config {",
          "63:  u32 byte_order;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63: enum gs_can_identify_mode {",
          "64:  GS_CAN_IDENTIFY_OFF = 0,",
          "65:  GS_CAN_IDENTIFY_ON",
          "66: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "101:  u32 brp;",
          "102: } __packed;",
          "104: #define GS_CAN_FEATURE_LISTEN_ONLY      BIT(0)",
          "105: #define GS_CAN_FEATURE_LOOP_BACK        BIT(1)",
          "106: #define GS_CAN_FEATURE_TRIPLE_SAMPLE    BIT(2)",
          "107: #define GS_CAN_FEATURE_ONE_SHOT         BIT(3)",
          "109: struct gs_device_bt_const {",
          "110:  u32 feature;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: struct gs_identify_mode {",
          "112:  u32 mode;",
          "113: } __packed;",
          "119: #define GS_CAN_FEATURE_HW_TIMESTAMP     BIT(4)",
          "120: #define GS_CAN_FEATURE_IDENTIFY         BIT(5)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "724:  .ndo_change_mtu = can_change_mtu,",
          "725: };",
          "728: {",
          "729:  struct gs_can *dev;",
          "730:  struct net_device *netdev;",
          "",
          "[Removed Lines]",
          "727: static struct gs_can *gs_make_candev(unsigned int channel, struct usb_interface *intf)",
          "",
          "[Added Lines]",
          "740: static int gs_usb_set_identify(struct net_device *netdev, bool do_identify)",
          "741: {",
          "742:  struct gs_can *dev = netdev_priv(netdev);",
          "743:  struct gs_identify_mode imode;",
          "744:  int rc;",
          "746:  if (do_identify)",
          "747:   imode.mode = GS_CAN_IDENTIFY_ON;",
          "748:  else",
          "749:   imode.mode = GS_CAN_IDENTIFY_OFF;",
          "751:  rc = usb_control_msg(interface_to_usbdev(dev->iface),",
          "752:         usb_sndctrlpipe(interface_to_usbdev(dev->iface),",
          "753:           0),",
          "754:         GS_USB_BREQ_IDENTIFY,",
          "755:         USB_DIR_OUT | USB_TYPE_VENDOR |",
          "756:         USB_RECIP_INTERFACE,",
          "757:         dev->channel,",
          "758:         0,",
          "759:         &imode,",
          "760:         sizeof(imode),",
          "761:         100);",
          "763:  return (rc > 0) ? 0 : rc;",
          "764: }",
          "767: static int gs_usb_set_phys_id(struct net_device *dev,",
          "768:          enum ethtool_phys_id_state state)",
          "769: {",
          "770:  int rc = 0;",
          "772:  switch (state) {",
          "773:  case ETHTOOL_ID_ACTIVE:",
          "774:   rc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_ON);",
          "775:   break;",
          "776:  case ETHTOOL_ID_INACTIVE:",
          "777:   rc = gs_usb_set_identify(dev, GS_CAN_IDENTIFY_OFF);",
          "778:   break;",
          "779:  default:",
          "780:   break;",
          "781:  }",
          "783:  return rc;",
          "784: }",
          "786: static const struct ethtool_ops gs_usb_ethtool_ops = {",
          "787:  .set_phys_id = gs_usb_set_phys_id,",
          "788: };",
          "790: static struct gs_can *gs_make_candev(unsigned int channel,",
          "791:          struct usb_interface *intf,",
          "792:          struct gs_device_config *dconf)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "812:  if (bt_const->feature & GS_CAN_FEATURE_ONE_SHOT)",
          "813:   dev->can.ctrlmode_supported |= CAN_CTRLMODE_ONE_SHOT;",
          "817:  SET_NETDEV_DEV(netdev, &intf->dev);",
          "819:  rc = register_candev(dev->netdev);",
          "820:  if (rc) {",
          "821:   free_candev(dev->netdev);",
          "",
          "[Removed Lines]",
          "815:  kfree(bt_const);",
          "",
          "[Added Lines]",
          "882:  if (dconf->sw_version > 1)",
          "883:   if (bt_const->feature & GS_CAN_FEATURE_IDENTIFY)",
          "884:    netdev->ethtool_ops = &gs_usb_ethtool_ops;",
          "886:  kfree(bt_const);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "833:  free_candev(dev->netdev);",
          "834: }",
          "837: {",
          "838:  struct gs_usb *dev;",
          "839:  int rc = -ENOMEM;",
          "840:  unsigned int icount, i;",
          "851:  rc = usb_control_msg(interface_to_usbdev(intf),",
          "",
          "[Removed Lines]",
          "836: static int gs_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)",
          "841:  struct gs_host_config *hconf;",
          "842:  struct gs_device_config *dconf;",
          "844:  hconf = kmalloc(sizeof(*hconf), GFP_KERNEL);",
          "845:  if (!hconf)",
          "846:   return -ENOMEM;",
          "848:  hconf->byte_order = 0x0000beef;",
          "",
          "[Added Lines]",
          "905: static int gs_usb_probe(struct usb_interface *intf,",
          "906:    const struct usb_device_id *id)",
          "911:  struct gs_host_config hconf = {",
          "912:   .byte_order = 0x0000beef,",
          "913:  };",
          "914:  struct gs_device_config dconf;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "854:         USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,",
          "855:         1,",
          "856:         intf->altsetting[0].desc.bInterfaceNumber,",
          "859:         1000);",
          "863:  if (rc < 0) {",
          "864:   dev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",",
          "865:    rc);",
          "866:   return rc;",
          "867:  }",
          "874:  rc = usb_control_msg(interface_to_usbdev(intf),",
          "875:         usb_rcvctrlpipe(interface_to_usbdev(intf), 0),",
          "",
          "[Removed Lines]",
          "857:         hconf,",
          "858:         sizeof(*hconf),",
          "861:  kfree(hconf);",
          "869:  dconf = kmalloc(sizeof(*dconf), GFP_KERNEL);",
          "870:  if (!dconf)",
          "871:   return -ENOMEM;",
          "",
          "[Added Lines]",
          "923:         &hconf,",
          "924:         sizeof(hconf),",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "877:         USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,",
          "878:         1,",
          "879:         intf->altsetting[0].desc.bInterfaceNumber,",
          "882:         1000);",
          "883:  if (rc < 0) {",
          "884:   dev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",",
          "885:    rc);",
          "889:   return rc;",
          "890:  }",
          "896:  dev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);",
          "898:  if (icount > GS_MAX_INTF) {",
          "",
          "[Removed Lines]",
          "880:         dconf,",
          "881:         sizeof(*dconf),",
          "887:   kfree(dconf);",
          "892:  icount = dconf->icount+1;",
          "894:  kfree(dconf);",
          "",
          "[Added Lines]",
          "940:         &dconf,",
          "941:         sizeof(dconf),",
          "949:  icount = dconf.icount + 1;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "913:  dev->udev = interface_to_usbdev(intf);",
          "915:  for (i = 0; i < icount; i++) {",
          "917:   if (IS_ERR_OR_NULL(dev->canch[i])) {",
          "919:    rc = PTR_ERR(dev->canch[i]);",
          "",
          "[Removed Lines]",
          "916:   dev->canch[i] = gs_make_candev(i, intf);",
          "",
          "[Added Lines]",
          "970:   dev->canch[i] = gs_make_candev(i, intf, &dconf);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-18249",
  "cve_desc": "The add_free_nid function in fs/f2fs/node.c in the Linux kernel before 4.12 does not properly track an allocated nid, which allows local users to cause a denial of service (race condition) or possibly have unspecified other impact via concurrent threads.",
  "repo": "torvalds/linux",
  "patch_hash": "30a61ddf8117c26ac5b295e1233eaa9629a94ca3",
  "patch_info": {
    "commit_hash": "30a61ddf8117c26ac5b295e1233eaa9629a94ca3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/30a61ddf8117c26ac5b295e1233eaa9629a94ca3",
    "files": [
      "fs/f2fs/node.c"
    ],
    "message": "f2fs: fix race condition in between free nid allocator/initializer\n\nIn below concurrent case, allocated nid can be loaded into free nid cache\nand be allocated again.\n\nThread A\t\t\t\tThread B\n- f2fs_create\n - f2fs_new_inode\n  - alloc_nid\n   - __insert_nid_to_list(ALLOC_NID_LIST)\n\t\t\t\t\t- f2fs_balance_fs_bg\n\t\t\t\t\t - build_free_nids\n\t\t\t\t\t  - __build_free_nids\n\t\t\t\t\t   - scan_nat_page\n\t\t\t\t\t    - add_free_nid\n\t\t\t\t\t     - __lookup_nat_cache\n - f2fs_add_link\n  - init_inode_metadata\n   - new_inode_page\n    - new_node_page\n     - set_node_addr\n - alloc_nid_done\n  - __remove_nid_from_list(ALLOC_NID_LIST)\n\t\t\t\t\t     - __insert_nid_to_list(FREE_NID_LIST)\n\nThis patch makes nat cache lookup and free nid list operation being atomical\nto avoid this race condition.\n\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/node.c||fs/f2fs/node.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/node.c||fs/f2fs/node.c": [
      "File: fs/f2fs/node.c -> fs/f2fs/node.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1761: static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)",
      "1762: {",
      "1763:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
      "1765:  struct nat_entry *ne;",
      "1769:  if (unlikely(nid == 0))",
      "1770:   return false;",
      "1780:  i = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);",
      "1781:  i->nid = nid;",
      "1782:  i->state = NID_NEW;",
      "1789:  spin_lock(&nm_i->nid_list_lock);",
      "1790:  err = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);",
      "1791:  spin_unlock(&nm_i->nid_list_lock);",
      "1792:  radix_tree_preload_end();",
      "1794:   kmem_cache_free(free_nid_slab, i);",
      "1798: }",
      "1800: static void remove_free_nid(struct f2fs_sb_info *sbi, nid_t nid)",
      "",
      "[Removed Lines]",
      "1764:  struct free_nid *i;",
      "1766:  int err;",
      "1772:  if (build) {",
      "1774:   ne = __lookup_nat_cache(nm_i, nid);",
      "1775:   if (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||",
      "1776:     nat_get_blkaddr(ne) != NULL_ADDR))",
      "1777:    return false;",
      "1778:  }",
      "1784:  if (radix_tree_preload(GFP_NOFS)) {",
      "1785:   kmem_cache_free(free_nid_slab, i);",
      "1786:   return true;",
      "1787:  }",
      "1793:  if (err) {",
      "1795:   return true;",
      "1796:  }",
      "1797:  return true;",
      "",
      "[Added Lines]",
      "1764:  struct free_nid *i, *e;",
      "1766:  int err = -EINVAL;",
      "1767:  bool ret = false;",
      "1777:  if (radix_tree_preload(GFP_NOFS))",
      "1778:   goto err;",
      "1782:  if (build) {",
      "1804:   ne = __lookup_nat_cache(nm_i, nid);",
      "1805:   if (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||",
      "1806:     nat_get_blkaddr(ne) != NULL_ADDR))",
      "1807:    goto err_out;",
      "1809:   e = __lookup_free_nid_list(nm_i, nid);",
      "1810:   if (e) {",
      "1811:    if (e->state == NID_NEW)",
      "1812:     ret = true;",
      "1813:    goto err_out;",
      "1814:   }",
      "1815:  }",
      "1816:  ret = true;",
      "1818: err_out:",
      "1821: err:",
      "1822:  if (err)",
      "1824:  return ret;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4ac912427c4214d8031d9ad6fbc3bc75e71512df",
      "candidate_info": {
        "commit_hash": "4ac912427c4214d8031d9ad6fbc3bc75e71512df",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4ac912427c4214d8031d9ad6fbc3bc75e71512df",
        "files": [
          "fs/f2fs/debug.c",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/node.c",
          "include/linux/f2fs_fs.h"
        ],
        "message": "f2fs: introduce free nid bitmap\n\nIn scenario of intensively node allocation, free nids will be ran out\nsoon, then it needs to stop to load free nids by traversing NAT blocks,\nin worse case, if NAT blocks does not be cached in memory, it generates\nIOs which slows down our foreground operations.\n\nIn order to speed up node allocation, in this patch we introduce a new\nfree_nid_bitmap array, so there is an bitmap table for each NAT block,\nOnce the NAT block is loaded, related bitmap cache will be switched on,\nand bitmap will be set during traversing nat entries in NAT block, later\nwe can query and update nid usage status in memory completely.\n\nWith such implementation, I expect performance of node allocation can be\nimproved in the long-term after filesystem image is mounted.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/debug.c||fs/f2fs/debug.c",
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/node.c||fs/f2fs/node.c",
          "include/linux/f2fs_fs.h||include/linux/f2fs_fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ],
          "candidate": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/debug.c||fs/f2fs/debug.c": [
          "File: fs/f2fs/debug.c -> fs/f2fs/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:  si->base_mem += sizeof(struct f2fs_nm_info);",
          "195:  si->base_mem += __bitmap_size(sbi, NAT_BITMAP);",
          "196:  si->base_mem += (NM_I(sbi)->nat_bits_blocks << F2FS_BLKSIZE_BITS);",
          "198: get_cache:",
          "199:  si->cache_mem = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "197:  si->base_mem += NM_I(sbi)->nat_blocks * NAT_ENTRY_BITMAP_SIZE;",
          "198:  si->base_mem += NM_I(sbi)->nat_blocks / 8;",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "558:  unsigned char (*free_nid_bitmap)[NAT_ENTRY_BITMAP_SIZE];",
          "559:  unsigned char *nat_block_bitmap;",
          "",
          "---------------"
        ],
        "fs/f2fs/node.c||fs/f2fs/node.c": [
          "File: fs/f2fs/node.c -> fs/f2fs/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1765:   radix_tree_delete(&nm_i->free_nid_root, i->nid);",
          "1766: }",
          "1769: {",
          "1770:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1771:  struct free_nid *i;",
          "",
          "[Removed Lines]",
          "1768: static int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)",
          "",
          "[Added Lines]",
          "1769: static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1776:  if (unlikely(nid == 0))",
          "1779:  if (build) {",
          "1781:   ne = __lookup_nat_cache(nm_i, nid);",
          "1782:   if (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||",
          "1783:     nat_get_blkaddr(ne) != NULL_ADDR))",
          "1785:  }",
          "1787:  i = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);",
          "",
          "[Removed Lines]",
          "1777:   return 0;",
          "1784:    return 0;",
          "",
          "[Added Lines]",
          "1778:   return false;",
          "1785:    return false;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1791:  if (radix_tree_preload(GFP_NOFS)) {",
          "1792:   kmem_cache_free(free_nid_slab, i);",
          "1794:  }",
          "1796:  spin_lock(&nm_i->nid_list_lock);",
          "",
          "[Removed Lines]",
          "1793:   return 0;",
          "",
          "[Added Lines]",
          "1794:   return true;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1799:  radix_tree_preload_end();",
          "1800:  if (err) {",
          "1801:   kmem_cache_free(free_nid_slab, i);",
          "1803:  }",
          "1805: }",
          "1807: static void remove_free_nid(struct f2fs_sb_info *sbi, nid_t nid)",
          "",
          "[Removed Lines]",
          "1802:   return 0;",
          "1804:  return 1;",
          "",
          "[Added Lines]",
          "1803:   return true;",
          "1805:  return true;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1822:   kmem_cache_free(free_nid_slab, i);",
          "1823: }",
          "1825: static void scan_nat_page(struct f2fs_sb_info *sbi,",
          "1826:    struct page *nat_page, nid_t start_nid)",
          "1827: {",
          "1828:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1829:  struct f2fs_nat_block *nat_blk = page_address(nat_page);",
          "1830:  block_t blk_addr;",
          "1831:  int i;",
          "1833:  i = start_nid % NAT_ENTRY_PER_BLOCK;",
          "1835:  for (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {",
          "1837:   if (unlikely(start_nid >= nm_i->max_nid))",
          "1838:    break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1826: void update_free_nid_bitmap(struct f2fs_sb_info *sbi, nid_t nid, bool set)",
          "1827: {",
          "1828:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1829:  unsigned int nat_ofs = NAT_BLOCK_OFFSET(nid);",
          "1830:  unsigned int nid_ofs = nid - START_NID(nid);",
          "1832:  if (!test_bit_le(nat_ofs, nm_i->nat_block_bitmap))",
          "1833:   return;",
          "1835:  if (set)",
          "1836:   set_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);",
          "1837:  else",
          "1838:   clear_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);",
          "1839: }",
          "1847:  unsigned int nat_ofs = NAT_BLOCK_OFFSET(start_nid);",
          "1850:  set_bit_le(nat_ofs, nm_i->nat_block_bitmap);",
          "1855:   bool freed = false;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1840:   blk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);",
          "1841:   f2fs_bug_on(sbi, blk_addr == NEW_ADDR);",
          "1842:   if (blk_addr == NULL_ADDR)",
          "1844:  }",
          "1845: }",
          "1847: static int scan_nat_bits(struct f2fs_sb_info *sbi)",
          "",
          "[Removed Lines]",
          "1843:    add_free_nid(sbi, start_nid, true);",
          "",
          "[Added Lines]",
          "1863:    freed = add_free_nid(sbi, start_nid, true);",
          "1864:   update_free_nid_bitmap(sbi, start_nid, freed);",
          "1865:  }",
          "1866: }",
          "1868: static void scan_free_nid_bits(struct f2fs_sb_info *sbi)",
          "1869: {",
          "1870:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1871:  struct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);",
          "1872:  struct f2fs_journal *journal = curseg->journal;",
          "1873:  unsigned int i, idx;",
          "1874:  unsigned int target = FREE_NID_PAGES * NAT_ENTRY_PER_BLOCK;",
          "1876:  down_read(&nm_i->nat_tree_lock);",
          "1878:  for (i = 0; i < nm_i->nat_blocks; i++) {",
          "1879:   if (!test_bit_le(i, nm_i->nat_block_bitmap))",
          "1880:    continue;",
          "1881:   for (idx = 0; idx < NAT_ENTRY_PER_BLOCK; idx++) {",
          "1882:    nid_t nid;",
          "1884:    if (!test_bit_le(idx, nm_i->free_nid_bitmap[i]))",
          "1885:     continue;",
          "1887:    nid = i * NAT_ENTRY_PER_BLOCK + idx;",
          "1888:    add_free_nid(sbi, nid, true);",
          "1890:    if (nm_i->nid_cnt[FREE_NID_LIST] >= target)",
          "1891:     goto out;",
          "1892:   }",
          "1893:  }",
          "1894: out:",
          "1895:  down_read(&curseg->journal_rwsem);",
          "1896:  for (i = 0; i < nats_in_cursum(journal); i++) {",
          "1897:   block_t addr;",
          "1898:   nid_t nid;",
          "1900:   addr = le32_to_cpu(nat_in_journal(journal, i).block_addr);",
          "1901:   nid = le32_to_cpu(nid_in_journal(journal, i));",
          "1902:   if (addr == NULL_ADDR)",
          "1903:    add_free_nid(sbi, nid, true);",
          "1904:   else",
          "1905:    remove_free_nid(sbi, nid);",
          "1907:  up_read(&curseg->journal_rwsem);",
          "1908:  up_read(&nm_i->nat_tree_lock);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1912:  if (!sync && !available_free_memory(sbi, FREE_NIDS))",
          "1913:   return;",
          "1920:  if (enabled_nat_bits(sbi, NULL)) {",
          "",
          "[Removed Lines]",
          "1916:  if (!mount && !scan_nat_bits(sbi) && nm_i->nid_cnt[FREE_NID_LIST])",
          "1917:   return;",
          "",
          "[Added Lines]",
          "1979:  if (!mount) {",
          "1981:   scan_free_nid_bits(sbi);",
          "1983:   if (nm_i->nid_cnt[FREE_NID_LIST])",
          "1984:    return;",
          "1987:   if (!scan_nat_bits(sbi) && nm_i->nid_cnt[FREE_NID_LIST])",
          "1988:    return;",
          "1989:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2010:   i->state = NID_ALLOC;",
          "2011:   __insert_nid_to_list(sbi, i, ALLOC_NID_LIST, false);",
          "2012:   nm_i->available_nids--;",
          "2013:   spin_unlock(&nm_i->nid_list_lock);",
          "2014:   return true;",
          "2015:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2086:   update_free_nid_bitmap(sbi, *nid, false);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2065:  nm_i->available_nids++;",
          "2067:  spin_unlock(&nm_i->nid_list_lock);",
          "2069:  if (need_free)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2142:  update_free_nid_bitmap(sbi, nid, true);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2392:    add_free_nid(sbi, nid, false);",
          "2393:    spin_lock(&NM_I(sbi)->nid_list_lock);",
          "2394:    NM_I(sbi)->available_nids++;",
          "2395:    spin_unlock(&NM_I(sbi)->nid_list_lock);",
          "2396:   }",
          "2397:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2472:    update_free_nid_bitmap(sbi, nid, true);",
          "2473:    spin_unlock(&NM_I(sbi)->nid_list_lock);",
          "2474:   } else {",
          "2475:    spin_lock(&NM_I(sbi)->nid_list_lock);",
          "2476:    update_free_nid_bitmap(sbi, nid, false);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2558:  return 0;",
          "2559: }",
          "2561: int build_node_manager(struct f2fs_sb_info *sbi)",
          "2562: {",
          "2563:  int err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2643: int init_free_nid_cache(struct f2fs_sb_info *sbi)",
          "2644: {",
          "2645:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "2647:  nm_i->free_nid_bitmap = f2fs_kvzalloc(nm_i->nat_blocks *",
          "2648:      NAT_ENTRY_BITMAP_SIZE, GFP_KERNEL);",
          "2649:  if (!nm_i->free_nid_bitmap)",
          "2650:   return -ENOMEM;",
          "2652:  nm_i->nat_block_bitmap = f2fs_kvzalloc(nm_i->nat_blocks / 8,",
          "2653:         GFP_KERNEL);",
          "2654:  if (!nm_i->nat_block_bitmap)",
          "2655:   return -ENOMEM;",
          "2656:  return 0;",
          "2657: }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2570:  if (err)",
          "2571:   return err;",
          "2573:  build_free_nids(sbi, true, true);",
          "2574:  return 0;",
          "2575: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2671:  err = init_free_nid_cache(sbi);",
          "2672:  if (err)",
          "2673:   return err;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2628:  }",
          "2629:  up_write(&nm_i->nat_tree_lock);",
          "2631:  kfree(nm_i->nat_bitmap);",
          "2632:  kfree(nm_i->nat_bits);",
          "2633: #ifdef CONFIG_F2FS_CHECK_FS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2733:  kvfree(nm_i->nat_block_bitmap);",
          "2734:  kvfree(nm_i->free_nid_bitmap);",
          "",
          "---------------"
        ],
        "include/linux/f2fs_fs.h||include/linux/f2fs_fs.h": [
          "File: include/linux/f2fs_fs.h -> include/linux/f2fs_fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "281: #define NAT_ENTRY_PER_BLOCK (PAGE_SIZE / sizeof(struct f2fs_nat_entry))",
          "283: struct f2fs_nat_entry {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "282: #define NAT_ENTRY_BITMAP_SIZE ((NAT_ENTRY_PER_BLOCK + 7) / 8)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5921aaa185908c07e1e30cbdaee417ddeb27cbf9",
      "candidate_info": {
        "commit_hash": "5921aaa185908c07e1e30cbdaee417ddeb27cbf9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5921aaa185908c07e1e30cbdaee417ddeb27cbf9",
        "files": [
          "fs/f2fs/node.c"
        ],
        "message": "f2fs: fix concurrent problem for updating free bitmap\n\nalloc_nid_failed and scan_nat_page can be called at the same time,\nand we haven't protected add_free_nid and update_free_nid_bitmap\nwith the same nid_list_lock. That could lead to\n\nThread A\t\t\t\tThread B\n- __build_free_nids\n - scan_nat_page\n  - add_free_nid\n\t\t\t\t\t- alloc_nid_failed\n\t\t\t\t\t - update_free_nid_bitmap\n  - update_free_nid_bitmap\n\nscan_nat_page will clear the free bitmap since the nid is PREALLOC_NID,\nbut alloc_nid_failed needs to set the free bitmap. This results in\nfree nid with free bitmap cleared.\nThis patch update the bitmap under the same nid_list_lock in add_free_nid.\nAnd use __GFP_NOFAIL to make sure to update status of free nid correctly.\n\nSigned-off-by: Fan li <fanofcode.li@samsung.com>\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/node.c||fs/f2fs/node.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ],
          "candidate": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/node.c||fs/f2fs/node.c": [
          "File: fs/f2fs/node.c -> fs/f2fs/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1812:  }",
          "1813: }",
          "1817: {",
          "1818:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1819:  struct free_nid *i, *e;",
          "",
          "[Removed Lines]",
          "1816: static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)",
          "",
          "[Added Lines]",
          "1815: static void update_free_nid_bitmap(struct f2fs_sb_info *sbi, nid_t nid,",
          "1816:        bool set, bool build)",
          "1817: {",
          "1818:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1819:  unsigned int nat_ofs = NAT_BLOCK_OFFSET(nid);",
          "1820:  unsigned int nid_ofs = nid - START_NID(nid);",
          "1822:  if (!test_bit_le(nat_ofs, nm_i->nat_block_bitmap))",
          "1823:   return;",
          "1825:  if (set) {",
          "1826:   if (test_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]))",
          "1827:    return;",
          "1828:   __set_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);",
          "1829:   nm_i->free_nid_count[nat_ofs]++;",
          "1830:  } else {",
          "1831:   if (!test_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]))",
          "1832:    return;",
          "1833:   __clear_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);",
          "1834:   if (!build)",
          "1835:    nm_i->free_nid_count[nat_ofs]--;",
          "1836:  }",
          "1837: }",
          "1840: static bool add_free_nid(struct f2fs_sb_info *sbi,",
          "1841:     nid_t nid, bool build, bool update)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1829:  i->nid = nid;",
          "1830:  i->state = FREE_NID;",
          "1835:  spin_lock(&nm_i->nid_list_lock);",
          "",
          "[Removed Lines]",
          "1832:  if (radix_tree_preload(GFP_NOFS))",
          "1833:   goto err;",
          "",
          "[Added Lines]",
          "1857:  radix_tree_preload(GFP_NOFS | __GFP_NOFAIL);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1871:  ret = true;",
          "1872:  err = __insert_free_nid(sbi, i, FREE_NID);",
          "1873: err_out:",
          "1874:  spin_unlock(&nm_i->nid_list_lock);",
          "1875:  radix_tree_preload_end();",
          "1877:  if (err)",
          "1878:   kmem_cache_free(free_nid_slab, i);",
          "1879:  return ret;",
          "",
          "[Removed Lines]",
          "1876: err:",
          "",
          "[Added Lines]",
          "1898:  if (update) {",
          "1899:   update_free_nid_bitmap(sbi, nid, ret, build);",
          "1900:   if (!build)",
          "1901:    nm_i->available_nids++;",
          "1902:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1897:   kmem_cache_free(free_nid_slab, i);",
          "1898: }",
          "1924: static void scan_nat_page(struct f2fs_sb_info *sbi,",
          "1925:    struct page *nat_page, nid_t start_nid)",
          "1926: {",
          "",
          "[Removed Lines]",
          "1900: static void update_free_nid_bitmap(struct f2fs_sb_info *sbi, nid_t nid,",
          "1901:        bool set, bool build)",
          "1902: {",
          "1903:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1904:  unsigned int nat_ofs = NAT_BLOCK_OFFSET(nid);",
          "1905:  unsigned int nid_ofs = nid - START_NID(nid);",
          "1907:  if (!test_bit_le(nat_ofs, nm_i->nat_block_bitmap))",
          "1908:   return;",
          "1910:  if (set) {",
          "1911:   if (test_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]))",
          "1912:    return;",
          "1913:   __set_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);",
          "1914:   nm_i->free_nid_count[nat_ofs]++;",
          "1915:  } else {",
          "1916:   if (!test_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]))",
          "1917:    return;",
          "1918:   __clear_bit_le(nid_ofs, nm_i->free_nid_bitmap[nat_ofs]);",
          "1919:   if (!build)",
          "1920:    nm_i->free_nid_count[nat_ofs]--;",
          "1921:  }",
          "1922: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1935:  i = start_nid % NAT_ENTRY_PER_BLOCK;",
          "1937:  for (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {",
          "1940:   if (unlikely(start_nid >= nm_i->max_nid))",
          "1941:    break;",
          "1943:   blk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);",
          "1944:   f2fs_bug_on(sbi, blk_addr == NEW_ADDR);",
          "1950:  }",
          "1951: }",
          "",
          "[Removed Lines]",
          "1938:   bool freed = false;",
          "1945:   if (blk_addr == NULL_ADDR)",
          "1946:    freed = add_free_nid(sbi, start_nid, true);",
          "1947:   spin_lock(&NM_I(sbi)->nid_list_lock);",
          "1948:   update_free_nid_bitmap(sbi, start_nid, freed, true);",
          "1949:   spin_unlock(&NM_I(sbi)->nid_list_lock);",
          "",
          "[Added Lines]",
          "1948:   if (blk_addr == NULL_ADDR) {",
          "1949:    add_free_nid(sbi, start_nid, true, true);",
          "1950:   } else {",
          "1951:    spin_lock(&NM_I(sbi)->nid_list_lock);",
          "1952:    update_free_nid_bitmap(sbi, start_nid, false, true);",
          "1953:    spin_unlock(&NM_I(sbi)->nid_list_lock);",
          "1954:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1964:   addr = le32_to_cpu(nat_in_journal(journal, i).block_addr);",
          "1965:   nid = le32_to_cpu(nid_in_journal(journal, i));",
          "1966:   if (addr == NULL_ADDR)",
          "1968:   else",
          "1969:    remove_free_nid(sbi, nid);",
          "1970:  }",
          "",
          "[Removed Lines]",
          "1967:    add_free_nid(sbi, nid, true);",
          "",
          "[Added Lines]",
          "1972:    add_free_nid(sbi, nid, true, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1991:     break;",
          "1993:    nid = i * NAT_ENTRY_PER_BLOCK + idx;",
          "1996:    if (nm_i->nid_cnt[FREE_NID] >= MAX_FREE_NIDS)",
          "1997:     goto out;",
          "",
          "[Removed Lines]",
          "1994:    add_free_nid(sbi, nid, true);",
          "",
          "[Added Lines]",
          "1999:    add_free_nid(sbi, nid, true, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2497:   nat_reset_flag(ne);",
          "2498:   __clear_nat_cache_dirty(NM_I(sbi), set, ne);",
          "2499:   if (nat_get_blkaddr(ne) == NULL_ADDR) {",
          "2505:   } else {",
          "2506:    spin_lock(&NM_I(sbi)->nid_list_lock);",
          "2507:    update_free_nid_bitmap(sbi, nid, false, false);",
          "",
          "[Removed Lines]",
          "2500:    add_free_nid(sbi, nid, false);",
          "2501:    spin_lock(&NM_I(sbi)->nid_list_lock);",
          "2502:    NM_I(sbi)->available_nids++;",
          "2503:    update_free_nid_bitmap(sbi, nid, true, false);",
          "2504:    spin_unlock(&NM_I(sbi)->nid_list_lock);",
          "",
          "[Added Lines]",
          "2505:    add_free_nid(sbi, nid, false, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "eb0aa4b80784b8551bd5be577024e067bc83ef94",
      "candidate_info": {
        "commit_hash": "eb0aa4b80784b8551bd5be577024e067bc83ef94",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/eb0aa4b80784b8551bd5be577024e067bc83ef94",
        "files": [
          "fs/f2fs/node.c"
        ],
        "message": "f2fs: clean up free nid list operations\n\nThis patch cleans up to use consistent free nid list ops.\n\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/node.c||fs/f2fs/node.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ],
          "candidate": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/node.c||fs/f2fs/node.c": [
          "File: fs/f2fs/node.c -> fs/f2fs/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1695:  return radix_tree_lookup(&nm_i->free_nid_root, n);",
          "1696: }",
          "1706: {",
          "1707:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1709:  f2fs_bug_on(sbi, list == FREE_NID_LIST ? i->state != NID_NEW :",
          "1710:       i->state != NID_ALLOC);",
          "1711:  nm_i->nid_cnt[list]++;",
          "1712:  list_add_tail(&i->list, &nm_i->nid_list[list]);",
          "1713: }",
          "1715: static void __remove_nid_from_list(struct f2fs_sb_info *sbi,",
          "1717: {",
          "1718:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "",
          "[Removed Lines]",
          "1698: static void __del_from_free_nid_list(struct f2fs_nm_info *nm_i,",
          "1699:       struct free_nid *i)",
          "1700: {",
          "1701:  radix_tree_delete(&nm_i->free_nid_root, i->nid);",
          "1702: }",
          "1704: static void __insert_nid_to_list(struct f2fs_sb_info *sbi,",
          "1705:      struct free_nid *i, enum nid_list list)",
          "1716:      struct free_nid *i, enum nid_list list)",
          "",
          "[Added Lines]",
          "1698: static int __insert_nid_to_list(struct f2fs_sb_info *sbi,",
          "1699:    struct free_nid *i, enum nid_list list, bool new)",
          "1703:  if (new) {",
          "1704:   int err = radix_tree_insert(&nm_i->free_nid_root, i->nid, i);",
          "1705:   if (err)",
          "1706:    return err;",
          "1707:  }",
          "1713:  return 0;",
          "1717:    struct free_nid *i, enum nid_list list, bool reuse)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1721:       i->state != NID_ALLOC);",
          "1722:  nm_i->nid_cnt[list]--;",
          "1723:  list_del(&i->list);",
          "1724: }",
          "1726: static int add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1725:  if (!reuse)",
          "1726:   radix_tree_delete(&nm_i->free_nid_root, i->nid);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1728:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1729:  struct free_nid *i;",
          "1730:  struct nat_entry *ne;",
          "1732:  if (!available_free_memory(sbi, FREE_NIDS))",
          "1733:   return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1734:  int err;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1754:  }",
          "1756:  spin_lock(&nm_i->nid_list_lock);",
          "1760:   kmem_cache_free(free_nid_slab, i);",
          "1761:   return 0;",
          "1762:  }",
          "1766:  return 1;",
          "1767: }",
          "",
          "[Removed Lines]",
          "1757:  if (radix_tree_insert(&nm_i->free_nid_root, i->nid, i)) {",
          "1758:   spin_unlock(&nm_i->nid_list_lock);",
          "1759:   radix_tree_preload_end();",
          "1763:  __insert_nid_to_list(sbi, i, FREE_NID_LIST);",
          "1764:  spin_unlock(&nm_i->nid_list_lock);",
          "1765:  radix_tree_preload_end();",
          "",
          "[Added Lines]",
          "1761:  err = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);",
          "1762:  spin_unlock(&nm_i->nid_list_lock);",
          "1763:  radix_tree_preload_end();",
          "1764:  if (err) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1775:  spin_lock(&nm_i->nid_list_lock);",
          "1776:  i = __lookup_free_nid_list(nm_i, nid);",
          "1777:  if (i && i->state == NID_NEW) {",
          "1780:   need_free = true;",
          "1781:  }",
          "1782:  spin_unlock(&nm_i->nid_list_lock);",
          "",
          "[Removed Lines]",
          "1778:   __remove_nid_from_list(sbi, i, FREE_NID_LIST);",
          "1779:   __del_from_free_nid_list(nm_i, i);",
          "",
          "[Added Lines]",
          "1780:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, false);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1896:      struct free_nid, list);",
          "1900:   i->state = NID_ALLOC;",
          "1902:   spin_unlock(&nm_i->nid_list_lock);",
          "1903:   return true;",
          "1904:  }",
          "",
          "[Removed Lines]",
          "1899:   __remove_nid_from_list(sbi, i, FREE_NID_LIST);",
          "1901:   __insert_nid_to_list(sbi, i, ALLOC_NID_LIST);",
          "",
          "[Added Lines]",
          "1900:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, true);",
          "1902:   __insert_nid_to_list(sbi, i, ALLOC_NID_LIST, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1920:  spin_lock(&nm_i->nid_list_lock);",
          "1921:  i = __lookup_free_nid_list(nm_i, nid);",
          "1922:  f2fs_bug_on(sbi, !i);",
          "1925:  spin_unlock(&nm_i->nid_list_lock);",
          "1927:  kmem_cache_free(free_nid_slab, i);",
          "",
          "[Removed Lines]",
          "1923:  __remove_nid_from_list(sbi, i, ALLOC_NID_LIST);",
          "1924:  __del_from_free_nid_list(nm_i, i);",
          "",
          "[Added Lines]",
          "1924:  __remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1943:  i = __lookup_free_nid_list(nm_i, nid);",
          "1944:  f2fs_bug_on(sbi, !i);",
          "1948:  if (!available_free_memory(sbi, FREE_NIDS)) {",
          "1950:   need_free = true;",
          "1951:  } else {",
          "1952:   i->state = NID_NEW;",
          "1954:  }",
          "1955:  spin_unlock(&nm_i->nid_list_lock);",
          "",
          "[Removed Lines]",
          "1946:  __remove_nid_from_list(sbi, i, ALLOC_NID_LIST);",
          "1949:   __del_from_free_nid_list(nm_i, i);",
          "1953:   __insert_nid_to_list(sbi, i, FREE_NID_LIST);",
          "",
          "[Added Lines]",
          "1947:   __remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);",
          "1950:   __remove_nid_from_list(sbi, i, ALLOC_NID_LIST, true);",
          "1952:   __insert_nid_to_list(sbi, i, FREE_NID_LIST, false);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1977:     nm_i->nid_cnt[FREE_NID_LIST] <= MAX_FREE_NIDS)",
          "1978:    break;",
          "1983:   kmem_cache_free(free_nid_slab, i);",
          "1984:   nr_shrink--;",
          "1985:  }",
          "",
          "[Removed Lines]",
          "1980:   __remove_nid_from_list(sbi, i, FREE_NID_LIST);",
          "1981:   __del_from_free_nid_list(nm_i, i);",
          "",
          "[Added Lines]",
          "1979:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, false);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2366:  spin_lock(&nm_i->nid_list_lock);",
          "2367:  list_for_each_entry_safe(i, next_i, &nm_i->nid_list[FREE_NID_LIST],",
          "2368:          list) {",
          "2371:   spin_unlock(&nm_i->nid_list_lock);",
          "2372:   kmem_cache_free(free_nid_slab, i);",
          "2373:   spin_lock(&nm_i->nid_list_lock);",
          "",
          "[Removed Lines]",
          "2369:   __remove_nid_from_list(sbi, i, FREE_NID_LIST);",
          "2370:   __del_from_free_nid_list(nm_i, i);",
          "",
          "[Added Lines]",
          "2366:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, false);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9a4ffdf55811ff3382cdf44459ec17521bd47e5e",
      "candidate_info": {
        "commit_hash": "9a4ffdf55811ff3382cdf44459ec17521bd47e5e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9a4ffdf55811ff3382cdf44459ec17521bd47e5e",
        "files": [
          "fs/f2fs/debug.c",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/node.c",
          "fs/f2fs/node.h",
          "fs/f2fs/shrinker.c"
        ],
        "message": "f2fs: obsolete ALLOC_NID_LIST list\n\nAs Fan Li reported, there is no user traversing nid_list[ALLOC_NID_LIST]\nwhich is used for tracking preallocated nids. Let's drop it, and only\ntrack preallocated nids in free_nid_root radix-tree.\n\nReported-by: Fan Li <fanofcode.li@samsung.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/debug.c||fs/f2fs/debug.c",
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/node.c||fs/f2fs/node.c",
          "fs/f2fs/node.h||fs/f2fs/node.h",
          "fs/f2fs/shrinker.c||fs/f2fs/shrinker.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ],
          "candidate": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/debug.c||fs/f2fs/debug.c": [
          "File: fs/f2fs/debug.c -> fs/f2fs/debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "98:  si->dirty_nats = NM_I(sbi)->dirty_nat_cnt;",
          "99:  si->sits = MAIN_SEGS(sbi);",
          "100:  si->dirty_sits = SIT_I(sbi)->dirty_sentries;",
          "102:  si->avail_nids = NM_I(sbi)->available_nids;",
          "104:  si->bg_gc = sbi->bg_gc;",
          "105:  si->util_free = (int)(free_user_blocks(sbi) >> sbi->log_blocks_per_seg)",
          "",
          "[Removed Lines]",
          "101:  si->free_nids = NM_I(sbi)->nid_cnt[FREE_NID_LIST];",
          "103:  si->alloc_nids = NM_I(sbi)->nid_cnt[ALLOC_NID_LIST];",
          "",
          "[Added Lines]",
          "101:  si->free_nids = NM_I(sbi)->nid_cnt[FREE_NID];",
          "103:  si->alloc_nids = NM_I(sbi)->nid_cnt[PREALLOC_NID];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "233:  }",
          "238:     sizeof(struct free_nid);",
          "239:  si->cache_mem += NM_I(sbi)->nat_cnt * sizeof(struct nat_entry);",
          "240:  si->cache_mem += NM_I(sbi)->dirty_nat_cnt *",
          "",
          "[Removed Lines]",
          "236:  si->cache_mem += (NM_I(sbi)->nid_cnt[FREE_NID_LIST] +",
          "237:     NM_I(sbi)->nid_cnt[ALLOC_NID_LIST]) *",
          "",
          "[Added Lines]",
          "236:  si->cache_mem += (NM_I(sbi)->nid_cnt[FREE_NID] +",
          "237:     NM_I(sbi)->nid_cnt[PREALLOC_NID]) *",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "666:  }",
          "667: }",
          "673: };",
          "675: struct f2fs_nm_info {",
          "",
          "[Removed Lines]",
          "669: enum nid_list {",
          "670:  FREE_NID_LIST,",
          "671:  ALLOC_NID_LIST,",
          "672:  MAX_NID_LIST,",
          "",
          "[Added Lines]",
          "672: enum nid_state {",
          "675:  MAX_NID_STATE,",
          "",
          "---------------"
        ],
        "fs/f2fs/node.c||fs/f2fs/node.c": [
          "File: fs/f2fs/node.c -> fs/f2fs/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48:  if (type == FREE_NIDS) {",
          "50:     sizeof(struct free_nid)) >> PAGE_SHIFT;",
          "51:   res = mem_size < ((avail_ram * nm_i->ram_thresh / 100) >> 2);",
          "52:  } else if (type == NAT_ENTRIES) {",
          "",
          "[Removed Lines]",
          "49:   mem_size = (nm_i->nid_cnt[FREE_NID_LIST] *",
          "",
          "[Added Lines]",
          "49:   mem_size = (nm_i->nid_cnt[FREE_NID] *",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1757:  return radix_tree_lookup(&nm_i->free_nid_root, n);",
          "1758: }",
          "1762: {",
          "1763:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "",
          "[Removed Lines]",
          "1760: static int __insert_nid_to_list(struct f2fs_sb_info *sbi,",
          "1761:    struct free_nid *i, enum nid_list list, bool new)",
          "",
          "[Added Lines]",
          "1760: static int __insert_free_nid(struct f2fs_sb_info *sbi,",
          "1761:    struct free_nid *i, enum nid_state state, bool new)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1768:    return err;",
          "1769:  }",
          "1775:  return 0;",
          "1776: }",
          "1780: {",
          "1781:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1787:  if (!reuse)",
          "1788:   radix_tree_delete(&nm_i->free_nid_root, i->nid);",
          "1789: }",
          "",
          "[Removed Lines]",
          "1771:  f2fs_bug_on(sbi, list == FREE_NID_LIST ? i->state != NID_NEW :",
          "1772:       i->state != NID_ALLOC);",
          "1773:  nm_i->nid_cnt[list]++;",
          "1774:  list_add_tail(&i->list, &nm_i->nid_list[list]);",
          "1778: static void __remove_nid_from_list(struct f2fs_sb_info *sbi,",
          "1779:    struct free_nid *i, enum nid_list list, bool reuse)",
          "1783:  f2fs_bug_on(sbi, list == FREE_NID_LIST ? i->state != NID_NEW :",
          "1784:       i->state != NID_ALLOC);",
          "1785:  nm_i->nid_cnt[list]--;",
          "1786:  list_del(&i->list);",
          "",
          "[Added Lines]",
          "1771:  f2fs_bug_on(sbi, state != i->state);",
          "1772:  nm_i->nid_cnt[state]++;",
          "1773:  if (state == FREE_NID)",
          "1774:   list_add_tail(&i->list, &nm_i->free_nid_list);",
          "1778: static void __remove_free_nid(struct f2fs_sb_info *sbi,",
          "1779:    struct free_nid *i, enum nid_state state, bool reuse)",
          "1783:  f2fs_bug_on(sbi, state != i->state);",
          "1784:  nm_i->nid_cnt[state]--;",
          "1785:  if (state == FREE_NID)",
          "1786:   list_del(&i->list);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1804:  i = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);",
          "1805:  i->nid = nid;",
          "1808:  if (radix_tree_preload(GFP_NOFS))",
          "1809:   goto err;",
          "",
          "[Removed Lines]",
          "1806:  i->state = NID_NEW;",
          "",
          "[Added Lines]",
          "1806:  i->state = FREE_NID;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1840:   e = __lookup_free_nid_list(nm_i, nid);",
          "1841:   if (e) {",
          "1843:     ret = true;",
          "1844:    goto err_out;",
          "1845:   }",
          "1846:  }",
          "1847:  ret = true;",
          "1849: err_out:",
          "1850:  spin_unlock(&nm_i->nid_list_lock);",
          "1851:  radix_tree_preload_end();",
          "",
          "[Removed Lines]",
          "1842:    if (e->state == NID_NEW)",
          "1848:  err = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);",
          "",
          "[Added Lines]",
          "1842:    if (e->state == FREE_NID)",
          "1848:  err = __insert_free_nid(sbi, i, FREE_NID, true);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1864:  spin_lock(&nm_i->nid_list_lock);",
          "1865:  i = __lookup_free_nid_list(nm_i, nid);",
          "1868:   need_free = true;",
          "1869:  }",
          "1870:  spin_unlock(&nm_i->nid_list_lock);",
          "",
          "[Removed Lines]",
          "1866:  if (i && i->state == NID_NEW) {",
          "1867:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, false);",
          "",
          "[Added Lines]",
          "1866:  if (i && i->state == FREE_NID) {",
          "1867:   __remove_free_nid(sbi, i, FREE_NID, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1949:    nid = i * NAT_ENTRY_PER_BLOCK + idx;",
          "1950:    add_free_nid(sbi, nid, true);",
          "1953:     goto out;",
          "1954:   }",
          "1955:  }",
          "",
          "[Removed Lines]",
          "1952:    if (nm_i->nid_cnt[FREE_NID_LIST] >= MAX_FREE_NIDS)",
          "",
          "[Added Lines]",
          "1952:    if (nm_i->nid_cnt[FREE_NID] >= MAX_FREE_NIDS)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1982:   nid = 0;",
          "1986:   return;",
          "1988:  if (!sync && !available_free_memory(sbi, FREE_NIDS))",
          "",
          "[Removed Lines]",
          "1985:  if (nm_i->nid_cnt[FREE_NID_LIST] >= NAT_ENTRY_PER_BLOCK)",
          "",
          "[Added Lines]",
          "1985:  if (nm_i->nid_cnt[FREE_NID] >= NAT_ENTRY_PER_BLOCK)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1993:   scan_free_nid_bits(sbi);",
          "1996:    return;",
          "1997:  }",
          "",
          "[Removed Lines]",
          "1995:   if (nm_i->nid_cnt[FREE_NID_LIST])",
          "",
          "[Added Lines]",
          "1995:   if (nm_i->nid_cnt[FREE_NID])",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2069:  }",
          "2075:      struct free_nid, list);",
          "2081:   nm_i->available_nids--;",
          "2083:   update_free_nid_bitmap(sbi, *nid, false, false);",
          "",
          "[Removed Lines]",
          "2072:  if (nm_i->nid_cnt[FREE_NID_LIST] && !on_build_free_nids(nm_i)) {",
          "2073:   f2fs_bug_on(sbi, list_empty(&nm_i->nid_list[FREE_NID_LIST]));",
          "2074:   i = list_first_entry(&nm_i->nid_list[FREE_NID_LIST],",
          "2078:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, true);",
          "2079:   i->state = NID_ALLOC;",
          "2080:   __insert_nid_to_list(sbi, i, ALLOC_NID_LIST, false);",
          "",
          "[Added Lines]",
          "2072:  if (nm_i->nid_cnt[FREE_NID] && !on_build_free_nids(nm_i)) {",
          "2073:   f2fs_bug_on(sbi, list_empty(&nm_i->free_nid_list));",
          "2074:   i = list_first_entry(&nm_i->free_nid_list,",
          "2078:   __remove_free_nid(sbi, i, FREE_NID, true);",
          "2079:   i->state = PREALLOC_NID;",
          "2080:   __insert_free_nid(sbi, i, PREALLOC_NID, false);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2103:  spin_lock(&nm_i->nid_list_lock);",
          "2104:  i = __lookup_free_nid_list(nm_i, nid);",
          "2105:  f2fs_bug_on(sbi, !i);",
          "2107:  spin_unlock(&nm_i->nid_list_lock);",
          "2109:  kmem_cache_free(free_nid_slab, i);",
          "",
          "[Removed Lines]",
          "2106:  __remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);",
          "",
          "[Added Lines]",
          "2106:  __remove_free_nid(sbi, i, PREALLOC_NID, false);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2126:  f2fs_bug_on(sbi, !i);",
          "2128:  if (!available_free_memory(sbi, FREE_NIDS)) {",
          "2130:   need_free = true;",
          "2131:  } else {",
          "2135:  }",
          "2137:  nm_i->available_nids++;",
          "",
          "[Removed Lines]",
          "2129:   __remove_nid_from_list(sbi, i, ALLOC_NID_LIST, false);",
          "2132:   __remove_nid_from_list(sbi, i, ALLOC_NID_LIST, true);",
          "2133:   i->state = NID_NEW;",
          "2134:   __insert_nid_to_list(sbi, i, FREE_NID_LIST, false);",
          "",
          "[Added Lines]",
          "2129:   __remove_free_nid(sbi, i, PREALLOC_NID, false);",
          "2132:   __remove_free_nid(sbi, i, PREALLOC_NID, true);",
          "2133:   i->state = FREE_NID;",
          "2134:   __insert_free_nid(sbi, i, FREE_NID, false);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2150:  struct free_nid *i, *next;",
          "2151:  int nr = nr_shrink;",
          "2154:   return 0;",
          "2156:  if (!mutex_trylock(&nm_i->build_lock))",
          "2157:   return 0;",
          "2159:  spin_lock(&nm_i->nid_list_lock);",
          "2162:   if (nr_shrink <= 0 ||",
          "2164:    break;",
          "2167:   kmem_cache_free(free_nid_slab, i);",
          "2168:   nr_shrink--;",
          "2169:  }",
          "",
          "[Removed Lines]",
          "2153:  if (nm_i->nid_cnt[FREE_NID_LIST] <= MAX_FREE_NIDS)",
          "2160:  list_for_each_entry_safe(i, next, &nm_i->nid_list[FREE_NID_LIST],",
          "2161:          list) {",
          "2163:     nm_i->nid_cnt[FREE_NID_LIST] <= MAX_FREE_NIDS)",
          "2166:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, false);",
          "",
          "[Added Lines]",
          "2153:  if (nm_i->nid_cnt[FREE_NID] <= MAX_FREE_NIDS)",
          "2160:  list_for_each_entry_safe(i, next, &nm_i->free_nid_list, list) {",
          "2162:     nm_i->nid_cnt[FREE_NID] <= MAX_FREE_NIDS)",
          "2165:   __remove_free_nid(sbi, i, FREE_NID, false);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2636:  nm_i->available_nids = nm_i->max_nid - sbi->total_valid_node_count -",
          "2637:        F2FS_RESERVED_NODE_NUM;",
          "2640:  nm_i->nat_cnt = 0;",
          "2641:  nm_i->ram_thresh = DEF_RAM_THRESHOLD;",
          "2642:  nm_i->ra_nid_pages = DEF_RA_NID_PAGES;",
          "2643:  nm_i->dirty_nats_ratio = DEF_DIRTY_NAT_RATIO_THRESHOLD;",
          "2645:  INIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);",
          "2648:  INIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);",
          "2649:  INIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);",
          "2650:  INIT_LIST_HEAD(&nm_i->nat_entries);",
          "",
          "[Removed Lines]",
          "2638:  nm_i->nid_cnt[FREE_NID_LIST] = 0;",
          "2639:  nm_i->nid_cnt[ALLOC_NID_LIST] = 0;",
          "2646:  INIT_LIST_HEAD(&nm_i->nid_list[FREE_NID_LIST]);",
          "2647:  INIT_LIST_HEAD(&nm_i->nid_list[ALLOC_NID_LIST]);",
          "",
          "[Added Lines]",
          "2637:  nm_i->nid_cnt[FREE_NID] = 0;",
          "2638:  nm_i->nid_cnt[PREALLOC_NID] = 0;",
          "2645:  INIT_LIST_HEAD(&nm_i->free_nid_list);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2738:  spin_lock(&nm_i->nid_list_lock);",
          "2742:   spin_unlock(&nm_i->nid_list_lock);",
          "2743:   kmem_cache_free(free_nid_slab, i);",
          "2744:   spin_lock(&nm_i->nid_list_lock);",
          "2745:  }",
          "2749:  spin_unlock(&nm_i->nid_list_lock);",
          "",
          "[Removed Lines]",
          "2739:  list_for_each_entry_safe(i, next_i, &nm_i->nid_list[FREE_NID_LIST],",
          "2740:          list) {",
          "2741:   __remove_nid_from_list(sbi, i, FREE_NID_LIST, false);",
          "2746:  f2fs_bug_on(sbi, nm_i->nid_cnt[FREE_NID_LIST]);",
          "2747:  f2fs_bug_on(sbi, nm_i->nid_cnt[ALLOC_NID_LIST]);",
          "2748:  f2fs_bug_on(sbi, !list_empty(&nm_i->nid_list[ALLOC_NID_LIST]));",
          "",
          "[Added Lines]",
          "2737:  list_for_each_entry_safe(i, next_i, &nm_i->free_nid_list, list) {",
          "2738:   __remove_free_nid(sbi, i, FREE_NID, false);",
          "2743:  f2fs_bug_on(sbi, nm_i->nid_cnt[FREE_NID]);",
          "2744:  f2fs_bug_on(sbi, nm_i->nid_cnt[PREALLOC_NID]);",
          "2745:  f2fs_bug_on(sbi, !list_empty(&nm_i->free_nid_list));",
          "",
          "---------------"
        ],
        "fs/f2fs/node.h||fs/f2fs/node.h": [
          "File: fs/f2fs/node.h -> fs/f2fs/node.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "151: };",
          "161: struct free_nid {",
          "165: };",
          "167: static inline void next_free_nid(struct f2fs_sb_info *sbi, nid_t *nid)",
          "",
          "[Removed Lines]",
          "156: enum nid_state {",
          "159: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170:  struct free_nid *fnid;",
          "172:  spin_lock(&nm_i->nid_list_lock);",
          "174:   spin_unlock(&nm_i->nid_list_lock);",
          "175:   return;",
          "176:  }",
          "180:  spin_unlock(&nm_i->nid_list_lock);",
          "181: }",
          "",
          "[Removed Lines]",
          "173:  if (nm_i->nid_cnt[FREE_NID_LIST] <= 0) {",
          "177:  fnid = list_first_entry(&nm_i->nid_list[FREE_NID_LIST],",
          "178:       struct free_nid, list);",
          "",
          "[Added Lines]",
          "165:  if (nm_i->nid_cnt[FREE_NID] <= 0) {",
          "169:  fnid = list_first_entry(&nm_i->free_nid_list, struct free_nid, list);",
          "",
          "---------------"
        ],
        "fs/f2fs/shrinker.c||fs/f2fs/shrinker.c": [
          "File: fs/f2fs/shrinker.c -> fs/f2fs/shrinker.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: static unsigned long __count_free_nids(struct f2fs_sb_info *sbi)",
          "30: {",
          "33:  return count > 0 ? count : 0;",
          "34: }",
          "",
          "[Removed Lines]",
          "31:  long count = NM_I(sbi)->nid_cnt[FREE_NID_LIST] - MAX_FREE_NIDS;",
          "",
          "[Added Lines]",
          "31:  long count = NM_I(sbi)->nid_cnt[FREE_NID] - MAX_FREE_NIDS;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fb58ae22067e0595d974e3d856522c1ed6d2d7bf",
      "candidate_info": {
        "commit_hash": "fb58ae22067e0595d974e3d856522c1ed6d2d7bf",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fb58ae22067e0595d974e3d856522c1ed6d2d7bf",
        "files": [
          "fs/f2fs/node.c"
        ],
        "message": "f2fs: remove an obsolete variable\n\nThis patch removes an obsolete variable used in add_free_nid.\n\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/node.c||fs/f2fs/node.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ],
          "candidate": [
            "fs/f2fs/node.c||fs/f2fs/node.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/node.c||fs/f2fs/node.c": [
          "File: fs/f2fs/node.c -> fs/f2fs/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1690:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "1691:  struct free_nid *i;",
          "1692:  struct nat_entry *ne;",
          "1695:  if (!available_free_memory(sbi, FREE_NIDS))",
          "1696:   return -1;",
          "",
          "[Removed Lines]",
          "1693:  bool allocated = false;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1704:   ne = __lookup_nat_cache(nm_i, nid);",
          "1705:   if (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||",
          "1706:     nat_get_blkaddr(ne) != NULL_ADDR))",
          "1709:    return 0;",
          "1710:  }",
          "",
          "[Removed Lines]",
          "1707:    allocated = true;",
          "1708:   if (allocated)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
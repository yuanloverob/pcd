{
  "cve_id": "CVE-2020-25211",
  "cve_desc": "In the Linux kernel through 5.8.7, local attackers able to inject conntrack netlink configuration could overflow a local buffer, causing crashes or triggering use of incorrect protocol numbers in ctnetlink_parse_tuple_filter in net/netfilter/nf_conntrack_netlink.c, aka CID-1cc5ef91d2ff.",
  "repo": "torvalds/linux",
  "patch_hash": "1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
  "patch_info": {
    "commit_hash": "1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
    "files": [
      "net/netfilter/nf_conntrack_netlink.c"
    ],
    "message": "netfilter: ctnetlink: add a range check for l3/l4 protonum\n\nThe indexes to the nf_nat_l[34]protos arrays come from userspace. So\ncheck the tuple's family, e.g. l3num, when creating the conntrack in\norder to prevent an OOB memory access during setup.  Here is an example\nkernel panic on 4.14.180 when userspace passes in an index greater than\nNFPROTO_NUMPROTO.\n\nInternal error: Oops - BUG: 0 [#1] PREEMPT SMP\nModules linked in:...\nProcess poc (pid: 5614, stack limit = 0x00000000a3933121)\nCPU: 4 PID: 5614 Comm: poc Tainted: G S      W  O    4.14.180-g051355490483\nHardware name: Qualcomm Technologies, Inc. SM8150 V2 PM8150 Google Inc. MSM\ntask: 000000002a3dfffe task.stack: 00000000a3933121\npc : __cfi_check_fail+0x1c/0x24\nlr : __cfi_check_fail+0x1c/0x24\n...\nCall trace:\n__cfi_check_fail+0x1c/0x24\nname_to_dev_t+0x0/0x468\nnfnetlink_parse_nat_setup+0x234/0x258\nctnetlink_parse_nat_setup+0x4c/0x228\nctnetlink_new_conntrack+0x590/0xc40\nnfnetlink_rcv_msg+0x31c/0x4d4\nnetlink_rcv_skb+0x100/0x184\nnfnetlink_rcv+0xf4/0x180\nnetlink_unicast+0x360/0x770\nnetlink_sendmsg+0x5a0/0x6a4\n___sys_sendmsg+0x314/0x46c\nSyS_sendmsg+0xb4/0x108\nel0_svc_naked+0x34/0x38\n\nThis crash is not happening since 5.4+, however, ctnetlink still\nallows for creating entries with unsupported layer 3 protocol number.\n\nFixes: c1d10adb4a521 (\"[NETFILTER]: Add ctnetlink port for nf_conntrack\")\nSigned-off-by: Will McVicker <willmcvicker@google.com>\n[pablo@netfilter.org: rebased original patch on top of nf.git]\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "before_after_code_files": [
      "net/netfilter/nf_conntrack_netlink.c||net/netfilter/nf_conntrack_netlink.c"
    ]
  },
  "patch_diff": {
    "net/netfilter/nf_conntrack_netlink.c||net/netfilter/nf_conntrack_netlink.c": [
      "File: net/netfilter/nf_conntrack_netlink.c -> net/netfilter/nf_conntrack_netlink.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1404:  if (err < 0)",
      "1405:   return err;",
      "1408:  tuple->src.l3num = l3num;",
      "1410:  if (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1407:  if (l3num != NFPROTO_IPV4 && l3num != NFPROTO_IPV6)",
      "1408:   return -EOPNOTSUPP;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "843d926b003ea692468c8cc5bea1f9f58dfa8c75",
      "candidate_info": {
        "commit_hash": "843d926b003ea692468c8cc5bea1f9f58dfa8c75",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/843d926b003ea692468c8cc5bea1f9f58dfa8c75",
        "files": [
          "net/ipv6/ip6_fib.c"
        ],
        "message": "ipv6: avoid lockdep issue in fib6_del()\n\nsyzbot reported twice a lockdep issue in fib6_del() [1]\nwhich I think is caused by net->ipv6.fib6_null_entry\nhaving a NULL fib6_table pointer.\n\nfib6_del() already checks for fib6_null_entry special\ncase, we only need to return earlier.\n\nBug seems to occur very rarely, I have thus chosen\na 'bug origin' that makes backports not too complex.\n\n[1]\nWARNING: suspicious RCU usage\n5.9.0-rc4-syzkaller #0 Not tainted\n-----------------------------\nnet/ipv6/ip6_fib.c:1996 suspicious rcu_dereference_protected() usage!\n\nother info that might help us debug this:\n\nrcu_scheduler_active = 2, debug_locks = 1\n4 locks held by syz-executor.5/8095:\n #0: ffffffff8a7ea708 (rtnl_mutex){+.+.}-{3:3}, at: ppp_release+0x178/0x240 drivers/net/ppp/ppp_generic.c:401\n #1: ffff88804c422dd8 (&net->ipv6.fib6_gc_lock){+.-.}-{2:2}, at: spin_trylock_bh include/linux/spinlock.h:414 [inline]\n #1: ffff88804c422dd8 (&net->ipv6.fib6_gc_lock){+.-.}-{2:2}, at: fib6_run_gc+0x21b/0x2d0 net/ipv6/ip6_fib.c:2312\n #2: ffffffff89bd6a40 (rcu_read_lock){....}-{1:2}, at: __fib6_clean_all+0x0/0x290 net/ipv6/ip6_fib.c:2613\n #3: ffff8880a82e6430 (&tb->tb6_lock){+.-.}-{2:2}, at: spin_lock_bh include/linux/spinlock.h:359 [inline]\n #3: ffff8880a82e6430 (&tb->tb6_lock){+.-.}-{2:2}, at: __fib6_clean_all+0x107/0x290 net/ipv6/ip6_fib.c:2245\n\nstack backtrace:\nCPU: 1 PID: 8095 Comm: syz-executor.5 Not tainted 5.9.0-rc4-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x198/0x1fd lib/dump_stack.c:118\n fib6_del+0x12b4/0x1630 net/ipv6/ip6_fib.c:1996\n fib6_clean_node+0x39b/0x570 net/ipv6/ip6_fib.c:2180\n fib6_walk_continue+0x4aa/0x8e0 net/ipv6/ip6_fib.c:2102\n fib6_walk+0x182/0x370 net/ipv6/ip6_fib.c:2150\n fib6_clean_tree+0xdb/0x120 net/ipv6/ip6_fib.c:2230\n __fib6_clean_all+0x120/0x290 net/ipv6/ip6_fib.c:2246\n fib6_clean_all net/ipv6/ip6_fib.c:2257 [inline]\n fib6_run_gc+0x113/0x2d0 net/ipv6/ip6_fib.c:2320\n ndisc_netdev_event+0x217/0x350 net/ipv6/ndisc.c:1805\n notifier_call_chain+0xb5/0x200 kernel/notifier.c:83\n call_netdevice_notifiers_info+0xb5/0x130 net/core/dev.c:2033\n call_netdevice_notifiers_extack net/core/dev.c:2045 [inline]\n call_netdevice_notifiers net/core/dev.c:2059 [inline]\n dev_close_many+0x30b/0x650 net/core/dev.c:1634\n rollback_registered_many+0x3a8/0x1210 net/core/dev.c:9261\n rollback_registered net/core/dev.c:9329 [inline]\n unregister_netdevice_queue+0x2dd/0x570 net/core/dev.c:10410\n unregister_netdevice include/linux/netdevice.h:2774 [inline]\n ppp_release+0x216/0x240 drivers/net/ppp/ppp_generic.c:403\n __fput+0x285/0x920 fs/file_table.c:281\n task_work_run+0xdd/0x190 kernel/task_work.c:141\n tracehook_notify_resume include/linux/tracehook.h:188 [inline]\n exit_to_user_mode_loop kernel/entry/common.c:163 [inline]\n exit_to_user_mode_prepare+0x1e1/0x200 kernel/entry/common.c:190\n syscall_exit_to_user_mode+0x7e/0x2e0 kernel/entry/common.c:265\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\nFixes: 421842edeaf6 (\"net/ipv6: Add fib6_null_entry\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: David Ahern <dsahern@gmail.com>\nReviewed-by: David Ahern <dsahern@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_fib.c||net/ipv6/ip6_fib.c": [
          "File: net/ipv6/ip6_fib.c -> net/ipv6/ip6_fib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1994: int fib6_del(struct fib6_info *rt, struct nl_info *info)",
          "1995: {",
          "1999:  struct net *net = info->nl_net;",
          "2000:  struct fib6_info __rcu **rtp;",
          "2001:  struct fib6_info __rcu **rtp_next;",
          "2004:   return -ENOENT;",
          "2006:  WARN_ON(!(fn->fn_flags & RTN_RTINFO));",
          "",
          "[Removed Lines]",
          "1996:  struct fib6_node *fn = rcu_dereference_protected(rt->fib6_node,",
          "1997:         lockdep_is_held(&rt->fib6_table->tb6_lock));",
          "1998:  struct fib6_table *table = rt->fib6_table;",
          "2003:  if (!fn || rt == net->ipv6.fib6_null_entry)",
          "",
          "[Added Lines]",
          "1999:  struct fib6_table *table;",
          "2000:  struct fib6_node *fn;",
          "2002:  if (rt == net->ipv6.fib6_null_entry)",
          "2003:   return -ENOENT;",
          "2005:  table = rt->fib6_table;",
          "2006:  fn = rcu_dereference_protected(rt->fib6_node,",
          "2007:            lockdep_is_held(&table->tb6_lock));",
          "2008:  if (!fn)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5fb8642a17aa2ab9077372977d67a72d3899a98d",
      "candidate_info": {
        "commit_hash": "5fb8642a17aa2ab9077372977d67a72d3899a98d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5fb8642a17aa2ab9077372977d67a72d3899a98d",
        "files": [
          "net/smc/smc_close.c"
        ],
        "message": "net/smc: fix sock refcounting in case of termination\n\nWhen an ISM device is removed, all its linkgroups are terminated,\ni.e. all the corresponding connections are killed.\nConnection killing invokes smc_close_active_abort(), which decreases\nthe sock refcount for certain states to simulate passive closing.\nAnd it cancels the close worker and has to give up the sock lock for\nthis timeframe. This opens the door for a passive close worker or a\nsocket close to run in between. In this case smc_close_active_abort() and\npassive close worker resp. smc_release() might do a sock_put for passive\nclosing. This causes:\n\n[ 1323.315943] refcount_t: underflow; use-after-free.\n[ 1323.316055] WARNING: CPU: 3 PID: 54469 at lib/refcount.c:28 refcount_warn_saturate+0xe8/0x130\n[ 1323.316069] Kernel panic - not syncing: panic_on_warn set ...\n[ 1323.316084] CPU: 3 PID: 54469 Comm: uperf Not tainted 5.9.0-20200826.rc2.git0.46328853ed20.300.fc32.s390x+debug #1\n[ 1323.316096] Hardware name: IBM 2964 NC9 702 (z/VM 6.4.0)\n[ 1323.316108] Call Trace:\n[ 1323.316125]  [<00000000c0d4aae8>] show_stack+0x90/0xf8\n[ 1323.316143]  [<00000000c15989b0>] dump_stack+0xa8/0xe8\n[ 1323.316158]  [<00000000c0d8344e>] panic+0x11e/0x288\n[ 1323.316173]  [<00000000c0d83144>] __warn+0xac/0x158\n[ 1323.316187]  [<00000000c1597a7a>] report_bug+0xb2/0x130\n[ 1323.316201]  [<00000000c0d36424>] monitor_event_exception+0x44/0xc0\n[ 1323.316219]  [<00000000c195c716>] pgm_check_handler+0x1da/0x238\n[ 1323.316234]  [<00000000c151844c>] refcount_warn_saturate+0xec/0x130\n[ 1323.316280] ([<00000000c1518448>] refcount_warn_saturate+0xe8/0x130)\n[ 1323.316310]  [<000003ff801f2e2a>] smc_release+0x192/0x1c8 [smc]\n[ 1323.316323]  [<00000000c169f1fa>] __sock_release+0x5a/0xe0\n[ 1323.316334]  [<00000000c169f2ac>] sock_close+0x2c/0x40\n[ 1323.316350]  [<00000000c1086de0>] __fput+0xb8/0x278\n[ 1323.316362]  [<00000000c0db1e0e>] task_work_run+0x76/0xb8\n[ 1323.316393]  [<00000000c0d8ab84>] do_exit+0x26c/0x520\n[ 1323.316408]  [<00000000c0d8af08>] do_group_exit+0x48/0xc0\n[ 1323.316421]  [<00000000c0d8afa8>] __s390x_sys_exit_group+0x28/0x38\n[ 1323.316433]  [<00000000c195c32c>] system_call+0xe0/0x2b4\n[ 1323.316446] 1 lock held by uperf/54469:\n[ 1323.316456]  #0: 0000000044125e60 (&sb->s_type->i_mutex_key#9){+.+.}-{3:3}, at: __sock_release+0x44/0xe0\n\nThe patch rechecks sock state in smc_close_active_abort() after\nsmc_close_cancel_work() to avoid duplicate decrease of sock\nrefcount for the same purpose.\n\nFixes: 611b63a12732 (\"net/smc: cancel tx worker in case of socket aborts\")\nReviewed-by: Karsten Graul <kgraul@linux.ibm.com>\nSigned-off-by: Ursula Braun <ubraun@linux.ibm.com>\nSigned-off-by: Karsten Graul <kgraul@linux.ibm.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/smc/smc_close.c||net/smc/smc_close.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "net/smc/smc_close.c||net/smc/smc_close.c": [
          "File: net/smc/smc_close.c -> net/smc/smc_close.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:  cancel_work_sync(&smc->conn.close_work);",
          "117:  cancel_delayed_work_sync(&smc->conn.tx_work);",
          "118:  lock_sock(sk);",
          "120: }",
          "",
          "[Removed Lines]",
          "119:  sk->sk_state = SMC_CLOSED;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134:  }",
          "135:  switch (sk->sk_state) {",
          "136:  case SMC_ACTIVE:",
          "142:  case SMC_APPCLOSEWAIT1:",
          "143:  case SMC_APPCLOSEWAIT2:",
          "144:   smc_close_cancel_work(smc);",
          "145:   sk->sk_state = SMC_CLOSED;",
          "147:   break;",
          "148:  case SMC_PEERCLOSEWAIT1:",
          "149:  case SMC_PEERCLOSEWAIT2:",
          "150:  case SMC_PEERFINCLOSEWAIT:",
          "151:   sk->sk_state = SMC_PEERABORTWAIT;",
          "152:   smc_close_cancel_work(smc);",
          "153:   sk->sk_state = SMC_CLOSED;",
          "154:   smc_conn_free(&smc->conn);",
          "155:   release_clcsock = true;",
          "",
          "[Removed Lines]",
          "137:   sk->sk_state = SMC_PEERABORTWAIT;",
          "138:   smc_close_cancel_work(smc);",
          "139:   sk->sk_state = SMC_CLOSED;",
          "141:   break;",
          "",
          "[Added Lines]",
          "138:   sk->sk_state = SMC_PEERABORTWAIT;",
          "140:   if (sk->sk_state != SMC_PEERABORTWAIT)",
          "141:    break;",
          "150:   if (sk->sk_state != SMC_PEERABORTWAIT)",
          "151:    break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "159:  case SMC_APPFINCLOSEWAIT:",
          "160:   sk->sk_state = SMC_PEERABORTWAIT;",
          "161:   smc_close_cancel_work(smc);",
          "162:   sk->sk_state = SMC_CLOSED;",
          "163:   smc_conn_free(&smc->conn);",
          "164:   release_clcsock = true;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:   if (sk->sk_state != SMC_PEERABORTWAIT)",
          "162:    break;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ccae0f36d500aef727f98acd8d0601e6b262a513",
      "candidate_info": {
        "commit_hash": "ccae0f36d500aef727f98acd8d0601e6b262a513",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ccae0f36d500aef727f98acd8d0601e6b262a513",
        "files": [
          "arch/x86/mm/numa_emulation.c"
        ],
        "message": "x86, fakenuma: Fix invalid starting node ID\n\nCommit:\n\n  cc9aec03e58f (\"x86/numa_emulation: Introduce uniform split capability\")\n\nuses \"-1\" as the starting node ID, which causes the strange kernel log as\nfollows, when \"numa=fake=32G\" is added to the kernel command line:\n\n    Faking node -1 at [mem 0x0000000000000000-0x0000000893ffffff] (35136MB)\n    Faking node 0 at [mem 0x0000001840000000-0x000000203fffffff] (32768MB)\n    Faking node 1 at [mem 0x0000000894000000-0x000000183fffffff] (64192MB)\n    Faking node 2 at [mem 0x0000002040000000-0x000000283fffffff] (32768MB)\n    Faking node 3 at [mem 0x0000002840000000-0x000000303fffffff] (32768MB)\n\nAnd finally the kernel crashes:\n\n    BUG: Bad page state in process swapper  pfn:00011\n    page:(____ptrval____) refcount:0 mapcount:1 mapping:(____ptrval____) index:0x55cd7e44b270 pfn:0x11\n    failed to read mapping contents, not a valid kernel address?\n    flags: 0x5(locked|uptodate)\n    raw: 0000000000000005 000055cd7e44af30 000055cd7e44af50 0000000100000006\n    raw: 000055cd7e44b270 000055cd7e44b290 0000000000000000 000055cd7e44b510\n    page dumped because: page still charged to cgroup\n    page->mem_cgroup:000055cd7e44b510\n    Modules linked in:\n    CPU: 0 PID: 0 Comm: swapper Not tainted 5.9.0-rc2 #1\n    Hardware name: Intel Corporation S2600WFT/S2600WFT, BIOS SE5C620.86B.02.01.0008.031920191559 03/19/2019\n    Call Trace:\n     dump_stack+0x57/0x80\n     bad_page.cold+0x63/0x94\n     __free_pages_ok+0x33f/0x360\n     memblock_free_all+0x127/0x195\n     mem_init+0x23/0x1f5\n     start_kernel+0x219/0x4f5\n     secondary_startup_64+0xb6/0xc0\n\nFix this bug via using 0 as the starting node ID.  This restores the\noriginal behavior before cc9aec03e58f.\n\n[ mingo: Massaged the changelog. ]\n\nFixes: cc9aec03e58f (\"x86/numa_emulation: Introduce uniform split capability\")\nSigned-off-by: \"Huang, Ying\" <ying.huang@intel.com>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>\nLink: https://lore.kernel.org/r/20200904061047.612950-1-ying.huang@intel.com",
        "before_after_code_files": [
          "arch/x86/mm/numa_emulation.c||arch/x86/mm/numa_emulation.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/mm/numa_emulation.c||arch/x86/mm/numa_emulation.c": [
          "File: arch/x86/mm/numa_emulation.c -> arch/x86/mm/numa_emulation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:            u64 addr, u64 max_addr, u64 size)",
          "322: {",
          "323:  return split_nodes_size_interleave_uniform(ei, pi, addr, max_addr, size,",
          "325: }",
          "327: static int __init setup_emu2phys_nid(int *dfl_phys_nid)",
          "",
          "[Removed Lines]",
          "324:    0, NULL, NUMA_NO_NODE);",
          "",
          "[Added Lines]",
          "324:    0, NULL, 0);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6dbf7bb555981fb5faf7b691e8f6169fc2b2e63b",
      "candidate_info": {
        "commit_hash": "6dbf7bb555981fb5faf7b691e8f6169fc2b2e63b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6dbf7bb555981fb5faf7b691e8f6169fc2b2e63b",
        "files": [
          "fs/buffer.c"
        ],
        "message": "fs: Don't invalidate page buffers in block_write_full_page()\n\nIf block_write_full_page() is called for a page that is beyond current\ninode size, it will truncate page buffers for the page and return 0.\nThis logic has been added in 2.5.62 in commit 81eb69062588 (\"fix ext3\nBUG due to race with truncate\") in history.git tree to fix a problem\nwith ext3 in data=ordered mode. This particular problem doesn't exist\nanymore because ext3 is long gone and ext4 handles ordered data\ndifferently. Also normally buffers are invalidated by truncate code and\nthere's no need to specially handle this in ->writepage() code.\n\nThis invalidation of page buffers in block_write_full_page() is causing\nissues to filesystems (e.g. ext4 or ocfs2) when block device is shrunk\nunder filesystem's hands and metadata buffers get discarded while being\ntracked by the journalling layer. Although it is obviously \"not\nsupported\" it can cause kernel crashes like:\n\n[ 7986.689400] BUG: unable to handle kernel NULL pointer dereference at\n+0000000000000008\n[ 7986.697197] PGD 0 P4D 0\n[ 7986.699724] Oops: 0002 [#1] SMP PTI\n[ 7986.703200] CPU: 4 PID: 203778 Comm: jbd2/dm-3-8 Kdump: loaded Tainted: G\n+O     --------- -  - 4.18.0-147.5.0.5.h126.eulerosv2r9.x86_64 #1\n[ 7986.716438] Hardware name: Huawei RH2288H V3/BC11HGSA0, BIOS 1.57 08/11/2015\n[ 7986.723462] RIP: 0010:jbd2_journal_grab_journal_head+0x1b/0x40 [jbd2]\n...\n[ 7986.810150] Call Trace:\n[ 7986.812595]  __jbd2_journal_insert_checkpoint+0x23/0x70 [jbd2]\n[ 7986.818408]  jbd2_journal_commit_transaction+0x155f/0x1b60 [jbd2]\n[ 7986.836467]  kjournald2+0xbd/0x270 [jbd2]\n\nwhich is not great. The crash happens because bh->b_private is suddently\nNULL although BH_JBD flag is still set (this is because\nblock_invalidatepage() cleared BH_Mapped flag and subsequent bh lookup\nfound buffer without BH_Mapped set, called init_page_buffers() which has\nrewritten bh->b_private). So just remove the invalidation in\nblock_write_full_page().\n\nNote that the buffer cache invalidation when block device changes size\nis already careful to avoid similar problems by using\ninvalidate_mapping_pages() which skips busy buffers so it was only this\nodd block_write_full_page() behavior that could tear down bdev buffers\nunder filesystem's hands.\n\nReported-by: Ye Bin <yebin10@huawei.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nCC: stable@vger.kernel.org\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "fs/buffer.c||fs/buffer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/buffer.c||fs/buffer.c": [
          "File: fs/buffer.c -> fs/buffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2772:  offset = i_size & (PAGE_SIZE-1);",
          "2773:  if (page->index >= end_index+1 || !offset) {",
          "2784:   unlock_page(page);",
          "2786:  }",
          "",
          "[Removed Lines]",
          "2779: #if 0",
          "2781:   if (page->mapping->a_ops->invalidatepage)",
          "2782:    page->mapping->a_ops->invalidatepage(page, offset);",
          "2783: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2976:  offset = i_size & (PAGE_SIZE-1);",
          "2977:  if (page->index >= end_index+1 || !offset) {",
          "2984:   unlock_page(page);",
          "2986:  }",
          "",
          "[Removed Lines]",
          "2983:   do_invalidatepage(page, 0, PAGE_SIZE);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "384d87ef2c954fc58e6c5fd8253e4a1984f5fe02",
      "candidate_info": {
        "commit_hash": "384d87ef2c954fc58e6c5fd8253e4a1984f5fe02",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/384d87ef2c954fc58e6c5fd8253e4a1984f5fe02",
        "files": [
          "block/ioctl.c",
          "fs/block_dev.c",
          "include/linux/blkdev.h"
        ],
        "message": "block: Do not discard buffers under a mounted filesystem\n\nDiscarding blocks and buffers under a mounted filesystem is hardly\nanything admin wants to do. Usually it will confuse the filesystem and\nsometimes the loss of buffer_head state (including b_private field) can\neven cause crashes like:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000008\nPGD 0 P4D 0\nOops: 0002 [#1] SMP PTI\nCPU: 4 PID: 203778 Comm: jbd2/dm-3-8 Kdump: loaded Tainted: G O     --------- -  - 4.18.0-147.5.0.5.h126.eulerosv2r9.x86_64 #1\nHardware name: Huawei RH2288H V3/BC11HGSA0, BIOS 1.57 08/11/2015\nRIP: 0010:jbd2_journal_grab_journal_head+0x1b/0x40 [jbd2]\n...\nCall Trace:\n __jbd2_journal_insert_checkpoint+0x23/0x70 [jbd2]\n jbd2_journal_commit_transaction+0x155f/0x1b60 [jbd2]\n kjournald2+0xbd/0x270 [jbd2]\n\nSo if we don't have block device open with O_EXCL already, claim the\nblock device while we truncate buffer cache. This makes sure any\nexclusive block device user (such as filesystem) cannot operate on the\ndevice while we are discarding buffer cache.\n\nReported-by: Ye Bin <yebin10@huawei.com>\nSigned-off-by: Jan Kara <jack@suse.cz>\nReviewed-by: Christoph Hellwig <hch@lst.de>\n[axboe: fix !CONFIG_BLOCK error in truncate_bdev_range()]\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "block/ioctl.c||block/ioctl.c",
          "fs/block_dev.c||fs/block_dev.c",
          "include/linux/blkdev.h||include/linux/blkdev.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "block/ioctl.c||block/ioctl.c": [
          "File: block/ioctl.c -> block/ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "112:  uint64_t range[2];",
          "113:  uint64_t start, len;",
          "114:  struct request_queue *q = bdev_get_queue(bdev);",
          "118:  if (!(mode & FMODE_WRITE))",
          "119:   return -EBADF;",
          "",
          "[Removed Lines]",
          "115:  struct address_space *mapping = bdev->bd_inode->i_mapping;",
          "",
          "[Added Lines]",
          "115:  int err;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135:  if (start + len > i_size_read(bdev->bd_inode))",
          "136:   return -EINVAL;",
          "138:  return blkdev_issue_discard(bdev, start >> 9, len >> 9,",
          "139:         GFP_KERNEL, flags);",
          "140: }",
          "",
          "[Removed Lines]",
          "137:  truncate_inode_pages_range(mapping, start, start + len - 1);",
          "",
          "[Added Lines]",
          "137:  err = truncate_bdev_range(bdev, mode, start, start + len - 1);",
          "138:  if (err)",
          "139:   return err;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "143:   unsigned long arg)",
          "144: {",
          "145:  uint64_t range[2];",
          "147:  uint64_t start, end, len;",
          "149:  if (!(mode & FMODE_WRITE))",
          "150:   return -EBADF;",
          "",
          "[Removed Lines]",
          "146:  struct address_space *mapping;",
          "",
          "[Added Lines]",
          "150:  int err;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "166:   return -EINVAL;",
          "172:  return blkdev_issue_zeroout(bdev, start >> 9, len >> 9, GFP_KERNEL,",
          "173:    BLKDEV_ZERO_NOUNMAP);",
          "",
          "[Removed Lines]",
          "169:  mapping = bdev->bd_inode->i_mapping;",
          "170:  truncate_inode_pages_range(mapping, start, end);",
          "",
          "[Added Lines]",
          "172:  err = truncate_bdev_range(bdev, mode, start, end);",
          "173:  if (err)",
          "174:   return err;",
          "",
          "---------------"
        ],
        "fs/block_dev.c||fs/block_dev.c": [
          "File: fs/block_dev.c -> fs/block_dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: }",
          "104: EXPORT_SYMBOL(invalidate_bdev);",
          "106: static void set_init_blocksize(struct block_device *bdev)",
          "107: {",
          "108:  bdev->bd_inode->i_blkbits = blksize_bits(bdev_logical_block_size(bdev));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110: int truncate_bdev_range(struct block_device *bdev, fmode_t mode,",
          "111:    loff_t lstart, loff_t lend)",
          "112: {",
          "113:  struct block_device *claimed_bdev = NULL;",
          "114:  int err;",
          "121:  if (!(mode & FMODE_EXCL)) {",
          "122:   claimed_bdev = bdev->bd_contains;",
          "123:   err = bd_prepare_to_claim(bdev, claimed_bdev,",
          "124:        truncate_bdev_range);",
          "125:   if (err)",
          "126:    return err;",
          "127:  }",
          "128:  truncate_inode_pages_range(bdev->bd_inode->i_mapping, lstart, lend);",
          "129:  if (claimed_bdev)",
          "130:   bd_abort_claiming(bdev, claimed_bdev, truncate_bdev_range);",
          "131:  return 0;",
          "132: }",
          "133: EXPORT_SYMBOL(truncate_bdev_range);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1968:         loff_t len)",
          "1969: {",
          "1970:  struct block_device *bdev = I_BDEV(bdev_file_inode(file));",
          "1972:  loff_t end = start + len - 1;",
          "1973:  loff_t isize;",
          "1974:  int error;",
          "",
          "[Removed Lines]",
          "1971:  struct address_space *mapping;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1996:   return -EINVAL;",
          "2002:  switch (mode) {",
          "2003:  case FALLOC_FL_ZERO_RANGE:",
          "",
          "[Removed Lines]",
          "1999:  mapping = bdev->bd_inode->i_mapping;",
          "2000:  truncate_inode_pages_range(mapping, start, end);",
          "",
          "[Added Lines]",
          "2027:  error = truncate_bdev_range(bdev, file->f_mode, start, end);",
          "2028:  if (error)",
          "2029:   return error;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2028:           start >> PAGE_SHIFT,",
          "2029:           end >> PAGE_SHIFT);",
          "2030: }",
          "",
          "[Removed Lines]",
          "2027:  return invalidate_inode_pages2_range(mapping,",
          "",
          "[Added Lines]",
          "2056:  return invalidate_inode_pages2_range(bdev->bd_inode->i_mapping,",
          "",
          "---------------"
        ],
        "include/linux/blkdev.h||include/linux/blkdev.h": [
          "File: include/linux/blkdev.h -> include/linux/blkdev.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1988: #ifdef CONFIG_BLOCK",
          "1989: void invalidate_bdev(struct block_device *bdev);",
          "1990: int sync_blockdev(struct block_device *bdev);",
          "1991: #else",
          "1992: static inline void invalidate_bdev(struct block_device *bdev)",
          "1993: {",
          "1994: }",
          "1995: static inline int sync_blockdev(struct block_device *bdev)",
          "1996: {",
          "1997:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1990: int truncate_bdev_range(struct block_device *bdev, fmode_t mode, loff_t lstart,",
          "1991:    loff_t lend);",
          "1997: static inline int truncate_bdev_range(struct block_device *bdev, fmode_t mode,",
          "1998:           loff_t lstart, loff_t lend)",
          "1999: {",
          "2000:  return 0;",
          "2001: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
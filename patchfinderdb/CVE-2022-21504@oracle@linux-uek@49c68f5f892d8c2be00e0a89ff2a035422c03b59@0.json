{
  "cve_id": "CVE-2022-21504",
  "cve_desc": "The code in UEK6 U3 was missing an appropiate file descriptor count to be missing. This resulted in a use count error that allowed a file descriptor to a socket to be closed and freed while it was still in use by another portion of the kernel. An attack with local access can operate on the socket, and cause a denial of service. CVSS 3.1 Base Score 5.5 (Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H).",
  "repo": "oracle/linux-uek",
  "patch_hash": "49c68f5f892d8c2be00e0a89ff2a035422c03b59",
  "patch_info": {
    "commit_hash": "49c68f5f892d8c2be00e0a89ff2a035422c03b59",
    "repo": "oracle/linux-uek",
    "commit_url": "https://github.com/oracle/linux-uek/commit/49c68f5f892d8c2be00e0a89ff2a035422c03b59",
    "files": [
      "drivers/android/binder.c",
      "fs/file.c"
    ],
    "message": "fs: move filp_close() outside of __close_fd_get_file()\n\nJust one caller of this, and just use filp_close() there manually.\nThis is important to allow async close/removal of the fd.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\n(cherry picked from commit 6e802a4ba056a6f2f51ac9d54eead3ed6f9829a2)\nConflicts:\n    drivers/android/binder.c: no real conflict but code base difference\nOrabug: 33413846\nSigned-off-by: Prasad Singamsetty <prasad.singamsetty@oracle.com>\nReviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>\nSigned-off-by: Brian Maly <brian.maly@oracle.com>",
    "before_after_code_files": [
      "drivers/android/binder.c||drivers/android/binder.c",
      "fs/file.c||fs/file.c"
    ]
  },
  "patch_diff": {
    "drivers/android/binder.c||drivers/android/binder.c": [
      "File: drivers/android/binder.c -> drivers/android/binder.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2236:   return;",
      "2237:  init_task_work(&twcb->twork, binder_do_fd_close);",
      "2238:  __close_fd_get_file(fd, &twcb->file);",
      "2240:   task_work_add(current, &twcb->twork, TWA_RESUME);",
      "2242:   kfree(twcb);",
      "2243: }",
      "2245: static void binder_transaction_buffer_release(struct binder_proc *proc,",
      "",
      "[Removed Lines]",
      "2239:  if (twcb->file)",
      "2241:  else",
      "",
      "[Added Lines]",
      "2239:  if (twcb->file) {",
      "2240:   filp_close(twcb->file, current->files);",
      "2242:  } else {",
      "2244:  }",
      "",
      "---------------"
    ],
    "fs/file.c||fs/file.c": [
      "File: fs/file.c -> fs/file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "670:  spin_unlock(&files->file_lock);",
      "671:  get_file(file);",
      "675: out_unlock:",
      "676:  spin_unlock(&files->file_lock);",
      "",
      "[Removed Lines]",
      "673:  return filp_close(file, files);",
      "",
      "[Added Lines]",
      "675:  return 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6e802a4ba056a6f2f51ac9d54eead3ed6f9829a2",
      "candidate_info": {
        "commit_hash": "6e802a4ba056a6f2f51ac9d54eead3ed6f9829a2",
        "repo": "oracle/linux-uek",
        "commit_url": "https://github.com/oracle/linux-uek/commit/6e802a4ba056a6f2f51ac9d54eead3ed6f9829a2",
        "files": [
          "drivers/android/binder.c",
          "fs/file.c"
        ],
        "message": "fs: move filp_close() outside of __close_fd_get_file()\n\nJust one caller of this, and just use filp_close() there manually.\nThis is important to allow async close/removal of the fd.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "drivers/android/binder.c||drivers/android/binder.c",
          "fs/file.c||fs/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "drivers/android/binder.c||drivers/android/binder.c",
            "fs/file.c||fs/file.c"
          ],
          "candidate": [
            "drivers/android/binder.c||drivers/android/binder.c",
            "fs/file.c||fs/file.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/android/binder.c||drivers/android/binder.c": [
          "File: drivers/android/binder.c -> drivers/android/binder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2249:   return;",
          "2250:  init_task_work(&twcb->twork, binder_do_fd_close);",
          "2251:  __close_fd_get_file(fd, &twcb->file);",
          "2253:   task_work_add(current, &twcb->twork, true);",
          "2255:   kfree(twcb);",
          "2256: }",
          "2258: static void binder_transaction_buffer_release(struct binder_proc *proc,",
          "",
          "[Removed Lines]",
          "2252:  if (twcb->file)",
          "2254:  else",
          "",
          "[Added Lines]",
          "2252:  if (twcb->file) {",
          "2253:   filp_close(twcb->file, current->files);",
          "2255:  } else {",
          "2257:  }",
          "",
          "---------------"
        ],
        "fs/file.c||fs/file.c": [
          "File: fs/file.c -> fs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "662:  spin_unlock(&files->file_lock);",
          "663:  get_file(file);",
          "667: out_unlock:",
          "668:  spin_unlock(&files->file_lock);",
          "",
          "[Removed Lines]",
          "665:  return filp_close(file, files);",
          "",
          "[Added Lines]",
          "667:  return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ca2fad58491ab47394d8ada88160c101d9e8eded",
      "candidate_info": {
        "commit_hash": "ca2fad58491ab47394d8ada88160c101d9e8eded",
        "repo": "oracle/linux-uek",
        "commit_url": "https://github.com/oracle/linux-uek/commit/ca2fad58491ab47394d8ada88160c101d9e8eded",
        "files": [
          "drivers/android/binder.c",
          "fs/file.c"
        ],
        "message": "fs: move filp_close() outside of __close_fd_get_file()\n\nJust one caller of this, and just use filp_close() there manually.\nThis is important to allow async close/removal of the fd.\n\nSigned-off-by: Jens Axboe <axboe@kernel.dk>\n(cherry picked from commit 6e802a4ba056a6f2f51ac9d54eead3ed6f9829a2)\nConflicts:\n    drivers/android/binder.c: no real conflict but code base difference\nOrabug: 33413846\nSigned-off-by: Prasad Singamsetty <prasad.singamsetty@oracle.com>\nReviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>\nSigned-off-by: Brian Maly <brian.maly@oracle.com>",
        "before_after_code_files": [
          "drivers/android/binder.c||drivers/android/binder.c",
          "fs/file.c||fs/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "drivers/android/binder.c||drivers/android/binder.c",
            "fs/file.c||fs/file.c"
          ],
          "candidate": [
            "drivers/android/binder.c||drivers/android/binder.c",
            "fs/file.c||fs/file.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/android/binder.c||drivers/android/binder.c": [
          "File: drivers/android/binder.c -> drivers/android/binder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2236:   return;",
          "2237:  init_task_work(&twcb->twork, binder_do_fd_close);",
          "2238:  __close_fd_get_file(fd, &twcb->file);",
          "2240:   task_work_add(current, &twcb->twork, TWA_RESUME);",
          "2242:   kfree(twcb);",
          "2243: }",
          "2245: static void binder_transaction_buffer_release(struct binder_proc *proc,",
          "",
          "[Removed Lines]",
          "2239:  if (twcb->file)",
          "2241:  else",
          "",
          "[Added Lines]",
          "2239:  if (twcb->file) {",
          "2240:   filp_close(twcb->file, current->files);",
          "2242:  } else {",
          "2244:  }",
          "",
          "---------------"
        ],
        "fs/file.c||fs/file.c": [
          "File: fs/file.c -> fs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "670:  spin_unlock(&files->file_lock);",
          "671:  get_file(file);",
          "675: out_unlock:",
          "676:  spin_unlock(&files->file_lock);",
          "",
          "[Removed Lines]",
          "673:  return filp_close(file, files);",
          "",
          "[Added Lines]",
          "675:  return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8b91a9494391f17c1324c5f3da8142aecda15c2a",
      "candidate_info": {
        "commit_hash": "8b91a9494391f17c1324c5f3da8142aecda15c2a",
        "repo": "oracle/linux-uek",
        "commit_url": "https://github.com/oracle/linux-uek/commit/8b91a9494391f17c1324c5f3da8142aecda15c2a",
        "files": [
          "drivers/acpi/apei/ghes.c",
          "drivers/android/binder.c",
          "fs/exec.c",
          "fs/file.c",
          "fs/file_table.c",
          "fs/io-wq.c",
          "fs/io-wq.h",
          "fs/io_uring.c",
          "fs/namespace.c",
          "include/linux/file.h",
          "include/linux/io_uring.h",
          "include/linux/sched.h",
          "include/linux/socket.h",
          "include/linux/task_work.h",
          "include/trace/events/io_uring.h",
          "include/uapi/linux/io_uring.h",
          "init/init_task.c",
          "kernel/events/uprobes.c",
          "kernel/fork.c",
          "kernel/irq/manage.c",
          "kernel/sched/fair.c",
          "kernel/task_work.c",
          "net/socket.c",
          "security/keys/keyctl.c",
          "security/yama/yama_lsm.c",
          "tools/io_uring/io_uring-bench.c",
          "tools/io_uring/liburing.h"
        ],
        "message": "io_uring: backport 5.10 version of io_uring code base to uek6-u3\n\nThe following files are checked in from 5.10 upstream kernel\n   fs/io-wq.c\n   fs/io-wq.h\n   fs/io_uring.c\n   include/trace/events/io_uring.h\n   include/uapi/linux/io_uring.h\n   tools/io_uring/io_uring-bench.c\n   tools/io_uring/liburing.\n   include/linux/io_uring.h\n\nAdditional changes to the io-uring code from:\n1) Cherry pick changes from upstream commit:\n   \"0f2122045b94 io_uring: don't rely on weak ->files references\"\n   Fixed UEK-KABI check error for the new field 'io_uring' added\n   to struct task_struct.\n\n2) Revert the name change introduced by the upstream commit for io_uring\n   \"f5678e7f2ac3 kernel: better document the use_mm/unuse_mm API contract\".\n\n3) Revert the changes from the following upstream patches for io_uring:\n   f1f6a7dd9b53 mm, tree-wide: rename put_user_page*() to unpin_user_page*()\n   2113b05d039e fs/io_uring: set FOLL_PIN via pin_user_pages()\n\n4) Cherry pick changes from the upstream patch\n   91989c707884 task_work: cleanup notification modes\n   NOTE: Changes in files, arch/x86/kernel/cpu/mce/core\n   and arch/x86/kernel/cpu/restrl/rdtgroup.c are not\n   applicalbe due to code base differences.\n\n5) Revert the changes from upstream commit to io_uring.c file\n   89cd35c58bc2 iov_iter: transparently handle compat iovecs in import_iovec\n\n6) Revert the changes from upstream commit to io_uring.c file\n   0726b01e7045 mm/madvise: pass mm to do_madvise\n\n7) Cherry pick changes from the following upstream patches except the\n   io_uring.c changes which are already covered in 5.10 version:\n   4022e7af86be io_uring: make sure openat/openat2 honor rlimit nofile\n   09952e3e7826 io_uring: make sure accept honor rlimit nofile\n\n8) Apply (*poll_queue_proc)() arg change to io_uring.c file due to the\n   following UEK specific commit:\n   76ce2c9a8229 waitfd: new syscall implementing waitpid() over fds\n\nOrabug: 33042559\n\nSigned-off-by: Prasad Singamsetty <prasad.singamsetty@oracle.com>\nReviewed-by: Alan Adamson <alan.adamson@oracle.com>\nReviewed-by: Himanshu Madhani <himanshu.madhani@oracle.com>",
        "before_after_code_files": [
          "drivers/acpi/apei/ghes.c||drivers/acpi/apei/ghes.c",
          "drivers/android/binder.c||drivers/android/binder.c",
          "fs/exec.c||fs/exec.c",
          "fs/file.c||fs/file.c",
          "fs/file_table.c||fs/file_table.c",
          "fs/io-wq.c||fs/io-wq.c",
          "fs/io-wq.h||fs/io-wq.h",
          "fs/io_uring.c||fs/io_uring.c",
          "fs/namespace.c||fs/namespace.c",
          "include/linux/file.h||include/linux/file.h",
          "include/linux/io_uring.h||include/linux/io_uring.h",
          "include/linux/sched.h||include/linux/sched.h",
          "include/linux/socket.h||include/linux/socket.h",
          "include/linux/task_work.h||include/linux/task_work.h",
          "include/trace/events/io_uring.h||include/trace/events/io_uring.h",
          "include/uapi/linux/io_uring.h||include/uapi/linux/io_uring.h",
          "init/init_task.c||init/init_task.c",
          "kernel/events/uprobes.c||kernel/events/uprobes.c",
          "kernel/fork.c||kernel/fork.c",
          "kernel/irq/manage.c||kernel/irq/manage.c",
          "kernel/sched/fair.c||kernel/sched/fair.c",
          "kernel/task_work.c||kernel/task_work.c",
          "net/socket.c||net/socket.c",
          "security/keys/keyctl.c||security/keys/keyctl.c",
          "security/yamyama_lsm.c||security/yama/yama_lsm.c",
          "tools/io_uring/io_uring-bench.c||tools/io_uring/io_uring-bench.c",
          "tools/io_uring/liburing.h||tools/io_uring/liburing.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/android/binder.c||drivers/android/binder.c",
            "fs/file.c||fs/file.c"
          ],
          "candidate": [
            "drivers/android/binder.c||drivers/android/binder.c",
            "fs/file.c||fs/file.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/acpi/apei/ghes.c||drivers/acpi/apei/ghes.c": [
          "File: drivers/acpi/apei/ghes.c -> drivers/acpi/apei/ghes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "885:    estatus_node->task_work.func = ghes_kick_task_work;",
          "886:    estatus_node->task_work_cpu = smp_processor_id();",
          "887:    ret = task_work_add(current, &estatus_node->task_work,",
          "889:    if (ret)",
          "890:     estatus_node->task_work.func = NULL;",
          "891:   }",
          "",
          "[Removed Lines]",
          "888:          true);",
          "",
          "[Added Lines]",
          "888:          TWA_RESUME);",
          "",
          "---------------"
        ],
        "drivers/android/binder.c||drivers/android/binder.c": [
          "File: drivers/android/binder.c -> drivers/android/binder.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2233:  init_task_work(&twcb->twork, binder_do_fd_close);",
          "2234:  __close_fd_get_file(fd, &twcb->file);",
          "2235:  if (twcb->file)",
          "2237:  else",
          "2238:   kfree(twcb);",
          "2239: }",
          "",
          "[Removed Lines]",
          "2236:   task_work_add(current, &twcb->twork, true);",
          "",
          "[Added Lines]",
          "2236:   task_work_add(current, &twcb->twork, TWA_RESUME);",
          "",
          "---------------"
        ],
        "fs/exec.c||fs/exec.c": [
          "File: fs/exec.c -> fs/exec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: #include <linux/oom.h>",
          "64: #include <linux/compat.h>",
          "65: #include <linux/vmalloc.h>",
          "67: #include <linux/uaccess.h>",
          "68: #include <asm/mmu_context.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: #include <linux/io_uring.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1796:  current->flags &= ~PF_NPROC_EXCEEDED;",
          "1798:  retval = unshare_files(&displaced);",
          "1799:  if (retval)",
          "1800:   goto out_ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1802:  io_uring_task_cancel();",
          "",
          "---------------"
        ],
        "fs/file.c||fs/file.c": [
          "File: fs/file.c -> fs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "542:  return __alloc_fd(current->files, start, rlimit(RLIMIT_NOFILE), flags);",
          "543: }",
          "545: int get_unused_fd_flags(unsigned flags)",
          "546: {",
          "548: }",
          "549: EXPORT_SYMBOL(get_unused_fd_flags);",
          "",
          "[Removed Lines]",
          "547:  return __alloc_fd(current->files, 0, rlimit(RLIMIT_NOFILE), flags);",
          "",
          "[Added Lines]",
          "545: int __get_unused_fd_flags(unsigned flags, unsigned long nofile)",
          "546: {",
          "547:  return __alloc_fd(current->files, 0, nofile, flags);",
          "548: }",
          "552:  return __get_unused_fd_flags(flags, rlimit(RLIMIT_NOFILE));",
          "",
          "---------------"
        ],
        "fs/file_table.c||fs/file_table.c": [
          "File: fs/file_table.c -> fs/file_table.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "339:   if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {",
          "340:    init_task_work(&file->f_u.fu_rcuhead, ____fput);",
          "342:     return;",
          "",
          "[Removed Lines]",
          "341:    if (!task_work_add(task, &file->f_u.fu_rcuhead, true))",
          "",
          "[Added Lines]",
          "341:    if (!task_work_add(task, &file->f_u.fu_rcuhead, TWA_RESUME))",
          "",
          "---------------"
        ],
        "fs/io-wq.c||fs/io-wq.c": [
          "File: fs/io-wq.c -> fs/io-wq.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <linux/errno.h>",
          "11: #include <linux/sched/signal.h>",
          "12: #include <linux/mm.h>",
          "14: #include <linux/sched/mm.h>",
          "15: #include <linux/percpu.h>",
          "16: #include <linux/slab.h>",
          "17: #include <linux/kthread.h>",
          "18: #include <linux/rculist_nulls.h>",
          "20: #include \"io-wq.h\"",
          "22: #define WORKER_IDLE_TIMEOUT (5 * HZ)",
          "",
          "[Removed Lines]",
          "13: #include <linux/mmu_context.h>",
          "",
          "[Added Lines]",
          "18: #include <linux/fs_struct.h>",
          "19: #include <linux/task_work.h>",
          "20: #include <linux/blk-cgroup.h>",
          "21: #include <linux/audit.h>",
          "22: #include <linux/cpu.h>",
          "24: #include \"../kernel/sched/sched.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "57:  struct rcu_head rcu;",
          "58:  struct mm_struct *mm;",
          "60:  struct files_struct *restore_files;",
          "61: };",
          "63: #if BITS_PER_LONG == 64",
          "",
          "[Removed Lines]",
          "59:  const struct cred *creds;",
          "",
          "[Added Lines]",
          "63: #ifdef CONFIG_BLK_CGROUP",
          "64:  struct cgroup_subsys_state *blkcg_css;",
          "65: #endif",
          "66:  const struct cred *cur_creds;",
          "67:  const struct cred *saved_creds;",
          "69:  struct nsproxy *restore_nsproxy;",
          "70:  struct fs_struct *restore_fs;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "66: #define IO_WQ_HASH_ORDER 5",
          "67: #endif",
          "69: struct io_wqe_acct {",
          "70:  unsigned nr_workers;",
          "71:  unsigned max_workers;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "79: #define IO_WQ_NR_HASH_BUCKETS (1u << IO_WQ_HASH_ORDER)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "83: struct io_wqe {",
          "84:  struct {",
          "86:   struct io_wq_work_list work_list;",
          "87:   unsigned long hash_map;",
          "88:   unsigned flags;",
          "",
          "[Removed Lines]",
          "85:   spinlock_t lock;",
          "",
          "[Added Lines]",
          "97:   raw_spinlock_t lock;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "95:  struct list_head all_list;",
          "97:  struct io_wq *wq;",
          "98: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:  struct io_wq_work *hash_tail[IO_WQ_NR_HASH_BUCKETS];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "104:  struct io_wqe **wqes;",
          "105:  unsigned long state;",
          "110:  struct task_struct *manager;",
          "111:  struct user_struct *user;",
          "114:  refcount_t refs;",
          "115:  struct completion done;",
          "116: };",
          "118: static bool io_worker_get(struct io_worker *worker)",
          "119: {",
          "120:  return refcount_inc_not_zero(&worker->ref);",
          "",
          "[Removed Lines]",
          "107:  get_work_fn *get_work;",
          "108:  put_work_fn *put_work;",
          "112:  const struct cred *creds;",
          "113:  struct mm_struct *mm;",
          "",
          "[Added Lines]",
          "120:  free_work_fn *free_work;",
          "121:  io_wq_work_fn *do_work;",
          "128:  struct hlist_node cpuhp_node;",
          "130:  refcount_t use_refs;",
          "133: static enum cpuhp_state io_wq_online;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "135: {",
          "136:  bool dropped_lock = false;",
          "141:  }",
          "143:  if (current->files != worker->restore_files) {",
          "144:   __acquire(&wqe->lock);",
          "146:   dropped_lock = true;",
          "148:   task_lock(current);",
          "149:   current->files = worker->restore_files;",
          "150:   task_unlock(current);",
          "151:  }",
          "",
          "[Removed Lines]",
          "138:  if (worker->creds) {",
          "139:   revert_creds(worker->creds);",
          "140:   worker->creds = NULL;",
          "145:   spin_unlock_irq(&wqe->lock);",
          "",
          "[Added Lines]",
          "155:  if (worker->saved_creds) {",
          "156:   revert_creds(worker->saved_creds);",
          "157:   worker->cur_creds = worker->saved_creds = NULL;",
          "162:   raw_spin_unlock_irq(&wqe->lock);",
          "167:   current->nsproxy = worker->restore_nsproxy;",
          "171:  if (current->fs != worker->restore_fs)",
          "172:   current->fs = worker->restore_fs;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "157:  if (worker->mm) {",
          "158:   if (!dropped_lock) {",
          "159:    __acquire(&wqe->lock);",
          "161:    dropped_lock = true;",
          "162:   }",
          "163:   __set_current_state(TASK_RUNNING);",
          "165:   unuse_mm(worker->mm);",
          "166:   mmput(worker->mm);",
          "167:   worker->mm = NULL;",
          "168:  }",
          "170:  return dropped_lock;",
          "171: }",
          "",
          "[Removed Lines]",
          "160:    spin_unlock_irq(&wqe->lock);",
          "164:   set_fs(KERNEL_DS);",
          "",
          "[Added Lines]",
          "181:    raw_spin_unlock_irq(&wqe->lock);",
          "190: #ifdef CONFIG_BLK_CGROUP",
          "191:  if (worker->blkcg_css) {",
          "192:   kthread_associate_blkcg(NULL);",
          "193:   worker->blkcg_css = NULL;",
          "194:  }",
          "195: #endif",
          "196:  if (current->signal->rlim[RLIMIT_FSIZE].rlim_cur != RLIM_INFINITY)",
          "197:   current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "192: {",
          "193:  struct io_wqe *wqe = worker->wqe;",
          "194:  struct io_wqe_acct *acct = io_wqe_get_acct(wqe, worker);",
          "",
          "[Removed Lines]",
          "195:  unsigned nr_workers;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "212:  worker->flags = 0;",
          "213:  preempt_enable();",
          "216:  hlist_nulls_del_rcu(&worker->nulls_node);",
          "217:  list_del_rcu(&worker->all_list);",
          "218:  if (__io_worker_unuse(wqe, worker)) {",
          "219:   __release(&wqe->lock);",
          "221:  }",
          "222:  acct->nr_workers--;",
          "231:  kfree_rcu(worker, rcu);",
          "232: }",
          "234: static inline bool io_wqe_run_queue(struct io_wqe *wqe)",
          "",
          "[Removed Lines]",
          "215:  spin_lock_irq(&wqe->lock);",
          "220:   spin_lock_irq(&wqe->lock);",
          "223:  nr_workers = wqe->acct[IO_WQ_ACCT_BOUND].nr_workers +",
          "224:    wqe->acct[IO_WQ_ACCT_UNBOUND].nr_workers;",
          "225:  spin_unlock_irq(&wqe->lock);",
          "228:  if (!nr_workers && refcount_dec_and_test(&wqe->wq->refs))",
          "229:   complete(&wqe->wq->done);",
          "",
          "[Added Lines]",
          "242:  raw_spin_lock_irq(&wqe->lock);",
          "247:   raw_spin_lock_irq(&wqe->lock);",
          "250:  raw_spin_unlock_irq(&wqe->lock);",
          "253:  if (refcount_dec_and_test(&wqe->wq->refs))",
          "254:   complete(&wqe->wq->done);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "311:  worker->flags |= (IO_WORKER_F_UP | IO_WORKER_F_RUNNING);",
          "312:  worker->restore_files = current->files;",
          "313:  io_wqe_inc_running(wqe, worker);",
          "314: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "336:  worker->restore_nsproxy = current->nsproxy;",
          "337:  worker->restore_fs = current->fs;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "369:  return __io_worker_unuse(wqe, worker);",
          "370: }",
          "373:  __must_hold(wqe->lock)",
          "374: {",
          "375:  struct io_wq_work_node *node, *prev;",
          "378:  wq_list_for_each(node, prev, &wqe->work_list) {",
          "379:   work = container_of(node, struct io_wq_work, list);",
          "384:    return work;",
          "385:   }",
          "392:    return work;",
          "393:   }",
          "394:  }",
          "",
          "[Removed Lines]",
          "372: static struct io_wq_work *io_get_next_work(struct io_wqe *wqe, unsigned *hash)",
          "376:  struct io_wq_work *work;",
          "382:   if (!(work->flags & IO_WQ_WORK_HASHED)) {",
          "383:    wq_node_del(&wqe->work_list, node, prev);",
          "389:   if (!(wqe->hash_map & BIT_ULL(*hash))) {",
          "390:    wqe->hash_map |= BIT_ULL(*hash);",
          "391:    wq_node_del(&wqe->work_list, node, prev);",
          "",
          "[Added Lines]",
          "397: static inline unsigned int io_get_work_hash(struct io_wq_work *work)",
          "398: {",
          "399:  return work->flags >> IO_WQ_HASH_SHIFT;",
          "400: }",
          "402: static struct io_wq_work *io_get_next_work(struct io_wqe *wqe)",
          "406:  struct io_wq_work *work, *tail;",
          "407:  unsigned int hash;",
          "413:   if (!io_wq_is_hashed(work)) {",
          "414:    wq_list_del(&wqe->work_list, node, prev);",
          "419:   hash = io_get_work_hash(work);",
          "420:   if (!(wqe->hash_map & BIT(hash))) {",
          "421:    wqe->hash_map |= BIT(hash);",
          "423:    tail = wqe->hash_tail[hash];",
          "424:    wqe->hash_tail[hash] = NULL;",
          "425:    wq_list_cut(&wqe->work_list, &tail->list, prev);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "396:  return NULL;",
          "397: }",
          "399: static void io_worker_handle_work(struct io_worker *worker)",
          "400:  __releases(wqe->lock)",
          "401: {",
          "403:  struct io_wqe *wqe = worker->wqe;",
          "404:  struct io_wq *wq = wqe->wq;",
          "406:  do {",
          "",
          "[Removed Lines]",
          "402:  struct io_wq_work *work, *old_work = NULL, *put_work = NULL;",
          "407:   unsigned hash = -1U;",
          "",
          "[Added Lines]",
          "433: static void io_wq_switch_mm(struct io_worker *worker, struct io_wq_work *work)",
          "434: {",
          "435:  if (worker->mm) {",
          "436:   unuse_mm(worker->mm);",
          "437:   mmput(worker->mm);",
          "438:   worker->mm = NULL;",
          "439:  }",
          "441:  if (mmget_not_zero(work->identity->mm)) {",
          "442:   use_mm(work->identity->mm);",
          "443:   worker->mm = work->identity->mm;",
          "444:   return;",
          "445:  }",
          "448:  work->flags |= IO_WQ_WORK_CANCEL;",
          "449: }",
          "451: static inline void io_wq_switch_blkcg(struct io_worker *worker,",
          "452:           struct io_wq_work *work)",
          "453: {",
          "454: #ifdef CONFIG_BLK_CGROUP",
          "455:  if (!(work->flags & IO_WQ_WORK_BLKCG))",
          "456:   return;",
          "457:  if (work->identity->blkcg_css != worker->blkcg_css) {",
          "458:   kthread_associate_blkcg(work->identity->blkcg_css);",
          "459:   worker->blkcg_css = work->identity->blkcg_css;",
          "460:  }",
          "461: #endif",
          "462: }",
          "464: static void io_wq_switch_creds(struct io_worker *worker,",
          "465:           struct io_wq_work *work)",
          "466: {",
          "467:  const struct cred *old_creds = override_creds(work->identity->creds);",
          "469:  worker->cur_creds = work->identity->creds;",
          "470:  if (worker->saved_creds)",
          "472:  else",
          "473:   worker->saved_creds = old_creds;",
          "474: }",
          "476: static void io_impersonate_work(struct io_worker *worker,",
          "477:     struct io_wq_work *work)",
          "478: {",
          "479:  if ((work->flags & IO_WQ_WORK_FILES) &&",
          "480:      current->files != work->identity->files) {",
          "481:   task_lock(current);",
          "482:   current->files = work->identity->files;",
          "483:   current->nsproxy = work->identity->nsproxy;",
          "484:   task_unlock(current);",
          "485:   if (!work->identity->files) {",
          "487:    work->flags |= IO_WQ_WORK_CANCEL;",
          "488:   }",
          "489:  }",
          "490:  if ((work->flags & IO_WQ_WORK_FS) && current->fs != work->identity->fs)",
          "491:   current->fs = work->identity->fs;",
          "492:  if ((work->flags & IO_WQ_WORK_MM) && work->identity->mm != worker->mm)",
          "493:   io_wq_switch_mm(worker, work);",
          "494:  if ((work->flags & IO_WQ_WORK_CREDS) &&",
          "495:      worker->cur_creds != work->identity->creds)",
          "496:   io_wq_switch_creds(worker, work);",
          "497:  if (work->flags & IO_WQ_WORK_FSIZE)",
          "498:   current->signal->rlim[RLIMIT_FSIZE].rlim_cur = work->identity->fsize;",
          "499:  else if (current->signal->rlim[RLIMIT_FSIZE].rlim_cur != RLIM_INFINITY)",
          "500:   current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;",
          "501:  io_wq_switch_blkcg(worker, work);",
          "502: #ifdef CONFIG_AUDIT",
          "503:  current->loginuid = work->identity->loginuid;",
          "504:  current->sessionid = work->identity->sessionid;",
          "505: #endif",
          "506: }",
          "508: static void io_assign_current_work(struct io_worker *worker,",
          "509:        struct io_wq_work *work)",
          "510: {",
          "511:  if (work) {",
          "513:   if (signal_pending(current))",
          "514:    flush_signals(current);",
          "515:   cond_resched();",
          "516:  }",
          "518: #ifdef CONFIG_AUDIT",
          "519:  current->loginuid = KUIDT_INIT(AUDIT_UID_UNSET);",
          "520:  current->sessionid = AUDIT_SID_UNSET;",
          "521: #endif",
          "523:  spin_lock_irq(&worker->lock);",
          "524:  worker->cur_work = work;",
          "525:  spin_unlock_irq(&worker->lock);",
          "526: }",
          "528: static void io_wqe_enqueue(struct io_wqe *wqe, struct io_wq_work *work);",
          "537:   struct io_wq_work *work;",
          "538: get_next:",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "417:   if (work)",
          "418:    __io_worker_busy(wqe, worker, work);",
          "419:   else if (!wq_list_empty(&wqe->work_list))",
          "420:    wqe->flags |= IO_WQE_FLAG_STALLED;",
          "425:   if (!work)",
          "426:    break;",
          "454:     work->flags |= IO_WQ_WORK_CANCEL;",
          "488:    }",
          "494:  } while (1);",
          "495: }",
          "510: static int io_wqe_worker(void *data)",
          "511: {",
          "512:  struct io_worker *worker = data;",
          "513:  struct io_wqe *wqe = worker->wqe;",
          "514:  struct io_wq *wq = wqe->wq;",
          "517:  io_worker_start(wqe, worker);",
          "520:  while (!test_bit(IO_WQ_BIT_EXIT, &wq->state)) {",
          "521:   set_current_state(TASK_INTERRUPTIBLE);",
          "522: loop:",
          "526:   if (io_wqe_run_queue(wqe)) {",
          "527:    __set_current_state(TASK_RUNNING);",
          "528:    io_worker_handle_work(worker);",
          "530:    goto loop;",
          "531:   }",
          "534:   if (__io_worker_idle(wqe, worker)) {",
          "535:    __release(&wqe->lock);",
          "536:    goto loop;",
          "537:   }",
          "539:   if (signal_pending(current))",
          "540:    flush_signals(current);",
          "541:   if (schedule_timeout(WORKER_IDLE_TIMEOUT))",
          "",
          "[Removed Lines]",
          "416:   work = io_get_next_work(wqe, &hash);",
          "422:   spin_unlock_irq(&wqe->lock);",
          "423:   if (put_work && wq->put_work)",
          "424:    wq->put_work(old_work);",
          "427: next:",
          "429:   if (signal_pending(current))",
          "430:    flush_signals(current);",
          "432:   cond_resched();",
          "434:   spin_lock_irq(&worker->lock);",
          "435:   worker->cur_work = work;",
          "436:   spin_unlock_irq(&worker->lock);",
          "438:   if (work->flags & IO_WQ_WORK_CB)",
          "439:    work->func(&work);",
          "441:   if ((work->flags & IO_WQ_WORK_NEEDS_FILES) &&",
          "442:       current->files != work->files) {",
          "443:    task_lock(current);",
          "444:    current->files = work->files;",
          "445:    task_unlock(current);",
          "446:   }",
          "447:   if ((work->flags & IO_WQ_WORK_NEEDS_USER) && !worker->mm &&",
          "448:       wq->mm) {",
          "449:    if (mmget_not_zero(wq->mm)) {",
          "450:     use_mm(wq->mm);",
          "451:     set_fs(USER_DS);",
          "452:     worker->mm = wq->mm;",
          "453:    } else {",
          "455:    }",
          "456:   }",
          "457:   if (!worker->creds)",
          "458:    worker->creds = override_creds(wq->creds);",
          "459:   if (test_bit(IO_WQ_BIT_CANCEL, &wq->state))",
          "460:    work->flags |= IO_WQ_WORK_CANCEL;",
          "461:   if (worker->mm)",
          "462:    work->flags |= IO_WQ_WORK_HAS_MM;",
          "464:   if (wq->get_work && !(work->flags & IO_WQ_WORK_INTERNAL)) {",
          "465:    put_work = work;",
          "466:    wq->get_work(work);",
          "467:   }",
          "469:   old_work = work;",
          "470:   work->func(&work);",
          "472:   spin_lock_irq(&worker->lock);",
          "473:   worker->cur_work = NULL;",
          "474:   spin_unlock_irq(&worker->lock);",
          "476:   spin_lock_irq(&wqe->lock);",
          "478:   if (hash != -1U) {",
          "479:    wqe->hash_map &= ~BIT_ULL(hash);",
          "480:    wqe->flags &= ~IO_WQE_FLAG_STALLED;",
          "481:   }",
          "482:   if (work && work != old_work) {",
          "483:    spin_unlock_irq(&wqe->lock);",
          "485:    if (put_work && wq->put_work) {",
          "486:     wq->put_work(put_work);",
          "487:     put_work = NULL;",
          "491:    hash = -1U;",
          "492:    goto next;",
          "493:   }",
          "497: static inline void io_worker_spin_for_work(struct io_wqe *wqe)",
          "498: {",
          "499:  int i = 0;",
          "501:  while (++i < 1000) {",
          "502:   if (io_wqe_run_queue(wqe))",
          "503:    break;",
          "504:   if (need_resched())",
          "505:    break;",
          "506:   cpu_relax();",
          "507:  }",
          "508: }",
          "515:  bool did_work;",
          "519:  did_work = false;",
          "523:   if (did_work)",
          "524:    io_worker_spin_for_work(wqe);",
          "525:   spin_lock_irq(&wqe->lock);",
          "529:    did_work = true;",
          "532:   did_work = false;",
          "538:   spin_unlock_irq(&wqe->lock);",
          "",
          "[Added Lines]",
          "546:   work = io_get_next_work(wqe);",
          "552:   raw_spin_unlock_irq(&wqe->lock);",
          "555:   io_assign_current_work(worker, work);",
          "558:   do {",
          "559:    struct io_wq_work *old_work, *next_hashed, *linked;",
          "560:    unsigned int hash = io_get_work_hash(work);",
          "562:    next_hashed = wq_next_work(work);",
          "563:    io_impersonate_work(worker, work);",
          "568:    if (test_bit(IO_WQ_BIT_CANCEL, &wq->state))",
          "571:    old_work = work;",
          "572:    linked = wq->do_work(work);",
          "574:    work = next_hashed;",
          "575:    if (!work && linked && !io_wq_is_hashed(linked)) {",
          "576:     work = linked;",
          "577:     linked = NULL;",
          "578:    }",
          "579:    io_assign_current_work(worker, work);",
          "580:    wq->free_work(old_work);",
          "582:    if (linked)",
          "583:     io_wqe_enqueue(wqe, linked);",
          "585:    if (hash != -1U && !next_hashed) {",
          "586:     raw_spin_lock_irq(&wqe->lock);",
          "587:     wqe->hash_map &= ~BIT_ULL(hash);",
          "588:     wqe->flags &= ~IO_WQE_FLAG_STALLED;",
          "590:     if (!work)",
          "591:      goto get_next;",
          "592:     raw_spin_unlock_irq(&wqe->lock);",
          "594:   } while (work);",
          "596:   raw_spin_lock_irq(&wqe->lock);",
          "611:   raw_spin_lock_irq(&wqe->lock);",
          "622:   raw_spin_unlock_irq(&wqe->lock);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "547:  }",
          "549:  if (test_bit(IO_WQ_BIT_EXIT, &wq->state)) {",
          "551:   if (!wq_list_empty(&wqe->work_list))",
          "552:    io_worker_handle_work(worker);",
          "553:   else",
          "555:  }",
          "557:  io_worker_exit(worker);",
          "",
          "[Removed Lines]",
          "550:   spin_lock_irq(&wqe->lock);",
          "554:    spin_unlock_irq(&wqe->lock);",
          "",
          "[Added Lines]",
          "634:   raw_spin_lock_irq(&wqe->lock);",
          "638:    raw_spin_unlock_irq(&wqe->lock);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "592:  worker->flags &= ~IO_WORKER_F_RUNNING;",
          "595:  io_wqe_dec_running(wqe, worker);",
          "597: }",
          "599: static bool create_io_worker(struct io_wq *wq, struct io_wqe *wqe, int index)",
          "600: {",
          "602:  struct io_worker *worker;",
          "604:  worker = kzalloc_node(sizeof(*worker), GFP_KERNEL, wqe->node);",
          "",
          "[Removed Lines]",
          "594:  spin_lock_irq(&wqe->lock);",
          "596:  spin_unlock_irq(&wqe->lock);",
          "601:  struct io_wqe_acct *acct =&wqe->acct[index];",
          "",
          "[Added Lines]",
          "678:  raw_spin_lock_irq(&wqe->lock);",
          "680:  raw_spin_unlock_irq(&wqe->lock);",
          "685:  struct io_wqe_acct *acct = &wqe->acct[index];",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "616:   kfree(worker);",
          "617:   return false;",
          "618:  }",
          "621:  hlist_nulls_add_head_rcu(&worker->nulls_node, &wqe->free_list);",
          "622:  list_add_tail_rcu(&worker->all_list, &wqe->all_list);",
          "623:  worker->flags |= IO_WORKER_F_FREE;",
          "",
          "[Removed Lines]",
          "620:  spin_lock_irq(&wqe->lock);",
          "",
          "[Added Lines]",
          "703:  kthread_bind_mask(worker->task, cpumask_of_node(wqe->node));",
          "705:  raw_spin_lock_irq(&wqe->lock);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "626:  if (!acct->nr_workers && (worker->flags & IO_WORKER_F_BOUND))",
          "627:   worker->flags |= IO_WORKER_F_FIXED;",
          "628:  acct->nr_workers++;",
          "631:  if (index == IO_WQ_ACCT_UNBOUND)",
          "632:   atomic_inc(&wq->user->processes);",
          "634:  wake_up_process(worker->task);",
          "635:  return true;",
          "636: }",
          "",
          "[Removed Lines]",
          "629:  spin_unlock_irq(&wqe->lock);",
          "",
          "[Added Lines]",
          "714:  raw_spin_unlock_irq(&wqe->lock);",
          "719:  refcount_inc(&wq->refs);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "646:  return acct->nr_workers < acct->max_workers;",
          "647: }",
          "652: static int io_wq_manager(void *data)",
          "653: {",
          "654:  struct io_wq *wq = data;",
          "656:  int node;",
          "660:  for_each_node(node) {",
          "664:  }",
          "666:  complete(&wq->done);",
          "668:  while (!kthread_should_stop()) {",
          "669:   for_each_node(node) {",
          "670:    struct io_wqe *wqe = wq->wqes[node];",
          "671:    bool fork_worker[2] = { false, false };",
          "674:    if (io_wqe_need_worker(wqe, IO_WQ_ACCT_BOUND))",
          "675:     fork_worker[IO_WQ_ACCT_BOUND] = true;",
          "676:    if (io_wqe_need_worker(wqe, IO_WQ_ACCT_UNBOUND))",
          "677:     fork_worker[IO_WQ_ACCT_UNBOUND] = true;",
          "679:    if (fork_worker[IO_WQ_ACCT_BOUND])",
          "680:     create_io_worker(wq, wqe, IO_WQ_ACCT_BOUND);",
          "681:    if (fork_worker[IO_WQ_ACCT_UNBOUND])",
          "",
          "[Removed Lines]",
          "655:  int workers_to_create = num_possible_nodes();",
          "659:  refcount_set(&wq->refs, workers_to_create);",
          "661:   if (!create_io_worker(wq, wq->wqes[node], IO_WQ_ACCT_BOUND))",
          "662:    goto err;",
          "663:   workers_to_create--;",
          "673:    spin_lock_irq(&wqe->lock);",
          "678:    spin_unlock_irq(&wqe->lock);",
          "",
          "[Added Lines]",
          "735: static bool io_wqe_worker_send_sig(struct io_worker *worker, void *data)",
          "736: {",
          "737:  send_sig(SIGINT, worker->task, 1);",
          "738:  return false;",
          "739: }",
          "745: static bool io_wq_for_each_worker(struct io_wqe *wqe,",
          "746:       bool (*func)(struct io_worker *, void *),",
          "747:       void *data)",
          "748: {",
          "749:  struct io_worker *worker;",
          "750:  bool ret = false;",
          "752:  list_for_each_entry_rcu(worker, &wqe->all_list, all_list) {",
          "753:   if (io_worker_get(worker)) {",
          "755:    if (worker->task)",
          "756:     ret = func(worker, data);",
          "757:    io_worker_release(worker);",
          "758:    if (ret)",
          "759:     break;",
          "760:   }",
          "761:  }",
          "763:  return ret;",
          "764: }",
          "766: static bool io_wq_worker_wake(struct io_worker *worker, void *data)",
          "767: {",
          "768:  wake_up_process(worker->task);",
          "769:  return false;",
          "770: }",
          "781:  refcount_set(&wq->refs, 1);",
          "783:   if (!node_online(node))",
          "784:    continue;",
          "785:   if (create_io_worker(wq, wq->wqes[node], IO_WQ_ACCT_BOUND))",
          "786:    continue;",
          "787:   set_bit(IO_WQ_BIT_ERROR, &wq->state);",
          "788:   set_bit(IO_WQ_BIT_EXIT, &wq->state);",
          "789:   goto out;",
          "795:   if (current->task_works)",
          "796:    task_work_run();",
          "802:    if (!node_online(node))",
          "803:     continue;",
          "805:    raw_spin_lock_irq(&wqe->lock);",
          "810:    raw_spin_unlock_irq(&wqe->lock);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "685:   schedule_timeout(HZ);",
          "686:  }",
          "693:   complete(&wq->done);",
          "694:  return 0;",
          "695: }",
          "",
          "[Removed Lines]",
          "688:  return 0;",
          "689: err:",
          "690:  set_bit(IO_WQ_BIT_ERROR, &wq->state);",
          "691:  set_bit(IO_WQ_BIT_EXIT, &wq->state);",
          "692:  if (refcount_sub_and_test(workers_to_create, &wq->refs))",
          "",
          "[Added Lines]",
          "820:  if (current->task_works)",
          "821:   task_work_run();",
          "823: out:",
          "824:  if (refcount_dec_and_test(&wq->refs)) {",
          "826:   return 0;",
          "827:  }",
          "829:  if (test_bit(IO_WQ_BIT_ERROR, &wq->state)) {",
          "830:   rcu_read_lock();",
          "831:   for_each_node(node)",
          "832:    io_wq_for_each_worker(wq->wqes[node], io_wq_worker_wake, NULL);",
          "833:   rcu_read_unlock();",
          "834:  }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "717:  return true;",
          "718: }",
          "720: static void io_wqe_enqueue(struct io_wqe *wqe, struct io_wq_work *work)",
          "721: {",
          "722:  struct io_wqe_acct *acct = io_work_get_acct(wqe, work);",
          "723:  unsigned long flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "861: static void io_run_cancel(struct io_wq_work *work, struct io_wqe *wqe)",
          "862: {",
          "863:  struct io_wq *wq = wqe->wq;",
          "865:  do {",
          "866:   struct io_wq_work *old_work = work;",
          "868:   work->flags |= IO_WQ_WORK_CANCEL;",
          "869:   work = wq->do_work(work);",
          "870:   wq->free_work(old_work);",
          "871:  } while (work);",
          "872: }",
          "874: static void io_wqe_insert_work(struct io_wqe *wqe, struct io_wq_work *work)",
          "875: {",
          "876:  unsigned int hash;",
          "877:  struct io_wq_work *tail;",
          "879:  if (!io_wq_is_hashed(work)) {",
          "880: append:",
          "881:   wq_list_add_tail(&work->list, &wqe->work_list);",
          "882:   return;",
          "883:  }",
          "885:  hash = io_get_work_hash(work);",
          "886:  tail = wqe->hash_tail[hash];",
          "887:  wqe->hash_tail[hash] = work;",
          "888:  if (!tail)",
          "889:   goto append;",
          "891:  wq_list_add_after(&work->list, &tail->list, &wqe->work_list);",
          "892: }",
          "897:  int work_flags;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "731:  if (unlikely(!io_wq_can_queue(wqe, acct, work))) {",
          "734:   return;",
          "735:  }",
          "739:  wqe->flags &= ~IO_WQE_FLAG_STALLED;",
          "743:   io_wqe_wake_worker(wqe, acct);",
          "744: }",
          "",
          "[Removed Lines]",
          "732:   work->flags |= IO_WQ_WORK_CANCEL;",
          "733:   work->func(&work);",
          "737:  spin_lock_irqsave(&wqe->lock, flags);",
          "738:  wq_list_add_tail(&work->list, &wqe->work_list);",
          "740:  spin_unlock_irqrestore(&wqe->lock, flags);",
          "742:  if (!atomic_read(&acct->nr_running))",
          "",
          "[Added Lines]",
          "907:   io_run_cancel(work, wqe);",
          "911:  work_flags = work->flags;",
          "912:  raw_spin_lock_irqsave(&wqe->lock, flags);",
          "913:  io_wqe_insert_work(wqe, work);",
          "915:  raw_spin_unlock_irqrestore(&wqe->lock, flags);",
          "917:  if ((work_flags & IO_WQ_WORK_CONCURRENT) ||",
          "918:      !atomic_read(&acct->nr_running))",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "751: }",
          "759: {",
          "764:  bit = hash_ptr(val, IO_WQ_HASH_ORDER);",
          "765:  work->flags |= (IO_WQ_WORK_HASHED | (bit << IO_WQ_HASH_SHIFT));",
          "796: }",
          "798: void io_wq_cancel_all(struct io_wq *wq)",
          "",
          "[Removed Lines]",
          "758: void io_wq_enqueue_hashed(struct io_wq *wq, struct io_wq_work *work, void *val)",
          "760:  struct io_wqe *wqe = wq->wqes[numa_node_id()];",
          "761:  unsigned bit;",
          "766:  io_wqe_enqueue(wqe, work);",
          "767: }",
          "769: static bool io_wqe_worker_send_sig(struct io_worker *worker, void *data)",
          "770: {",
          "771:  send_sig(SIGINT, worker->task, 1);",
          "772:  return false;",
          "773: }",
          "779: static bool io_wq_for_each_worker(struct io_wqe *wqe,",
          "780:       bool (*func)(struct io_worker *, void *),",
          "781:       void *data)",
          "782: {",
          "783:  struct io_worker *worker;",
          "784:  bool ret = false;",
          "786:  list_for_each_entry_rcu(worker, &wqe->all_list, all_list) {",
          "787:   if (io_worker_get(worker)) {",
          "788:    ret = func(worker, data);",
          "789:    io_worker_release(worker);",
          "790:    if (ret)",
          "791:     break;",
          "792:   }",
          "793:  }",
          "795:  return ret;",
          "",
          "[Added Lines]",
          "933: void io_wq_hash_work(struct io_wq_work *work, void *val)",
          "935:  unsigned int bit;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "811: }",
          "813: struct io_cb_cancel_data {",
          "817: };",
          "820: {",
          "822:  unsigned long flags;",
          "",
          "[Removed Lines]",
          "814:  struct io_wqe *wqe;",
          "815:  work_cancel_fn *cancel;",
          "816:  void *caller_data;",
          "819: static bool io_work_cancel(struct io_worker *worker, void *cancel_data)",
          "821:  struct io_cb_cancel_data *data = cancel_data;",
          "823:  bool ret = false;",
          "",
          "[Added Lines]",
          "957:  work_cancel_fn *fn;",
          "958:  void *data;",
          "959:  int nr_running;",
          "960:  int nr_pending;",
          "961:  bool cancel_all;",
          "964: static bool io_wq_worker_cancel(struct io_worker *worker, void *data)",
          "966:  struct io_cb_cancel_data *match = data;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "829:  spin_lock_irqsave(&worker->lock, flags);",
          "830:  if (worker->cur_work &&",
          "832:   send_sig(SIGINT, worker->task, 1);",
          "834:  }",
          "835:  spin_unlock_irqrestore(&worker->lock, flags);",
          "838: }",
          "843: {",
          "849:  struct io_wq_work_node *node, *prev;",
          "850:  struct io_wq_work *work;",
          "851:  unsigned long flags;",
          "855:  wq_list_for_each(node, prev, &wqe->work_list) {",
          "856:   work = container_of(node, struct io_wq_work, list);",
          "870:  }",
          "872:  rcu_read_lock();",
          "874:  rcu_read_unlock();",
          "876: }",
          "878: enum io_wq_cancel io_wq_cancel_cb(struct io_wq *wq, work_cancel_fn *cancel,",
          "880: {",
          "882:  int node;",
          "945:  }",
          "",
          "[Removed Lines]",
          "831:      data->cancel(worker->cur_work, data->caller_data)) {",
          "833:   ret = true;",
          "837:  return ret;",
          "840: static enum io_wq_cancel io_wqe_cancel_cb_work(struct io_wqe *wqe,",
          "841:             work_cancel_fn *cancel,",
          "842:             void *cancel_data)",
          "844:  struct io_cb_cancel_data data = {",
          "845:   .wqe = wqe,",
          "846:   .cancel = cancel,",
          "847:   .caller_data = cancel_data,",
          "848:  };",
          "852:  bool found = false;",
          "854:  spin_lock_irqsave(&wqe->lock, flags);",
          "858:   if (cancel(work, cancel_data)) {",
          "859:    wq_node_del(&wqe->work_list, node, prev);",
          "860:    found = true;",
          "861:    break;",
          "862:   }",
          "863:  }",
          "864:  spin_unlock_irqrestore(&wqe->lock, flags);",
          "866:  if (found) {",
          "867:   work->flags |= IO_WQ_WORK_CANCEL;",
          "868:   work->func(&work);",
          "869:   return IO_WQ_CANCEL_OK;",
          "873:  found = io_wq_for_each_worker(wqe, io_work_cancel, &data);",
          "875:  return found ? IO_WQ_CANCEL_RUNNING : IO_WQ_CANCEL_NOTFOUND;",
          "879:       void *data)",
          "881:  enum io_wq_cancel ret = IO_WQ_CANCEL_NOTFOUND;",
          "884:  for_each_node(node) {",
          "885:   struct io_wqe *wqe = wq->wqes[node];",
          "887:   ret = io_wqe_cancel_cb_work(wqe, cancel, data);",
          "888:   if (ret != IO_WQ_CANCEL_NOTFOUND)",
          "889:    break;",
          "890:  }",
          "892:  return ret;",
          "893: }",
          "895: static bool io_wq_worker_cancel(struct io_worker *worker, void *data)",
          "896: {",
          "897:  struct io_wq_work *work = data;",
          "898:  unsigned long flags;",
          "899:  bool ret = false;",
          "901:  if (worker->cur_work != work)",
          "902:   return false;",
          "904:  spin_lock_irqsave(&worker->lock, flags);",
          "905:  if (worker->cur_work == work) {",
          "906:   send_sig(SIGINT, worker->task, 1);",
          "907:   ret = true;",
          "908:  }",
          "909:  spin_unlock_irqrestore(&worker->lock, flags);",
          "911:  return ret;",
          "912: }",
          "914: static enum io_wq_cancel io_wqe_cancel_work(struct io_wqe *wqe,",
          "915:          struct io_wq_work *cwork)",
          "916: {",
          "917:  struct io_wq_work_node *node, *prev;",
          "918:  struct io_wq_work *work;",
          "919:  unsigned long flags;",
          "920:  bool found = false;",
          "922:  cwork->flags |= IO_WQ_WORK_CANCEL;",
          "929:  spin_lock_irqsave(&wqe->lock, flags);",
          "930:  wq_list_for_each(node, prev, &wqe->work_list) {",
          "931:   work = container_of(node, struct io_wq_work, list);",
          "933:   if (work == cwork) {",
          "934:    wq_node_del(&wqe->work_list, node, prev);",
          "935:    found = true;",
          "936:    break;",
          "937:   }",
          "938:  }",
          "939:  spin_unlock_irqrestore(&wqe->lock, flags);",
          "941:  if (found) {",
          "942:   work->flags |= IO_WQ_WORK_CANCEL;",
          "943:   work->func(&work);",
          "944:   return IO_WQ_CANCEL_OK;",
          "",
          "[Added Lines]",
          "975:      !(worker->cur_work->flags & IO_WQ_WORK_NO_CANCEL) &&",
          "976:      match->fn(worker->cur_work, match->data)) {",
          "978:   match->nr_running++;",
          "982:  return match->nr_running && !match->cancel_all;",
          "985: static inline void io_wqe_remove_pending(struct io_wqe *wqe,",
          "986:       struct io_wq_work *work,",
          "987:       struct io_wq_work_node *prev)",
          "988: {",
          "989:  unsigned int hash = io_get_work_hash(work);",
          "990:  struct io_wq_work *prev_work = NULL;",
          "992:  if (io_wq_is_hashed(work) && work == wqe->hash_tail[hash]) {",
          "993:   if (prev)",
          "994:    prev_work = container_of(prev, struct io_wq_work, list);",
          "995:   if (prev_work && io_get_work_hash(prev_work) == hash)",
          "996:    wqe->hash_tail[hash] = prev_work;",
          "997:   else",
          "998:    wqe->hash_tail[hash] = NULL;",
          "999:  }",
          "1000:  wq_list_del(&wqe->work_list, &work->list, prev);",
          "1001: }",
          "1003: static void io_wqe_cancel_pending_work(struct io_wqe *wqe,",
          "1004:            struct io_cb_cancel_data *match)",
          "1010: retry:",
          "1011:  raw_spin_lock_irqsave(&wqe->lock, flags);",
          "1014:   if (!match->fn(work, match->data))",
          "1015:    continue;",
          "1016:   io_wqe_remove_pending(wqe, work, prev);",
          "1017:   raw_spin_unlock_irqrestore(&wqe->lock, flags);",
          "1018:   io_run_cancel(work, wqe);",
          "1019:   match->nr_pending++;",
          "1020:   if (!match->cancel_all)",
          "1021:    return;",
          "1024:   goto retry;",
          "1026:  raw_spin_unlock_irqrestore(&wqe->lock, flags);",
          "1027: }",
          "1029: static void io_wqe_cancel_running_work(struct io_wqe *wqe,",
          "1030:            struct io_cb_cancel_data *match)",
          "1031: {",
          "1033:  io_wq_for_each_worker(wqe, io_wq_worker_cancel, match);",
          "1038:       void *data, bool cancel_all)",
          "1040:  struct io_cb_cancel_data match = {",
          "1041:   .fn  = cancel,",
          "1042:   .data  = data,",
          "1043:   .cancel_all = cancel_all,",
          "1044:  };",
          "1052:  for_each_node(node) {",
          "1053:   struct io_wqe *wqe = wq->wqes[node];",
          "1055:   io_wqe_cancel_pending_work(wqe, &match);",
          "1056:   if (match.nr_pending && !match.cancel_all)",
          "1057:    return IO_WQ_CANCEL_OK;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "964:  for_each_node(node) {",
          "965:   struct io_wqe *wqe = wq->wqes[node];",
          "970:  }",
          "973: }",
          "981: {",
          "987: }",
          "994: {",
          "1007: }",
          "1009: struct io_wq *io_wq_create(unsigned bounded, struct io_wq_data *data)",
          "",
          "[Removed Lines]",
          "953:  rcu_read_lock();",
          "954:  found = io_wq_for_each_worker(wqe, io_wq_worker_cancel, cwork);",
          "955:  rcu_read_unlock();",
          "956:  return found ? IO_WQ_CANCEL_RUNNING : IO_WQ_CANCEL_NOTFOUND;",
          "957: }",
          "959: enum io_wq_cancel io_wq_cancel_work(struct io_wq *wq, struct io_wq_work *cwork)",
          "960: {",
          "961:  enum io_wq_cancel ret = IO_WQ_CANCEL_NOTFOUND;",
          "962:  int node;",
          "967:   ret = io_wqe_cancel_work(wqe, cwork);",
          "968:   if (ret != IO_WQ_CANCEL_NOTFOUND)",
          "969:    break;",
          "972:  return ret;",
          "975: struct io_wq_flush_data {",
          "976:  struct io_wq_work work;",
          "977:  struct completion done;",
          "978: };",
          "980: static void io_wq_flush_func(struct io_wq_work **workptr)",
          "982:  struct io_wq_work *work = *workptr;",
          "983:  struct io_wq_flush_data *data;",
          "985:  data = container_of(work, struct io_wq_flush_data, work);",
          "986:  complete(&data->done);",
          "993: void io_wq_flush(struct io_wq *wq)",
          "995:  struct io_wq_flush_data data;",
          "996:  int node;",
          "998:  for_each_node(node) {",
          "999:   struct io_wqe *wqe = wq->wqes[node];",
          "1001:   init_completion(&data.done);",
          "1002:   INIT_IO_WORK(&data.work, io_wq_flush_func);",
          "1003:   data.work.flags |= IO_WQ_WORK_INTERNAL;",
          "1004:   io_wqe_enqueue(wqe, &data.work);",
          "1005:   wait_for_completion(&data.done);",
          "1006:  }",
          "",
          "[Added Lines]",
          "1069:   io_wqe_cancel_running_work(wqe, &match);",
          "1070:   if (match.nr_running && !match.cancel_all)",
          "1071:    return IO_WQ_CANCEL_RUNNING;",
          "1074:  if (match.nr_running)",
          "1075:   return IO_WQ_CANCEL_RUNNING;",
          "1076:  if (match.nr_pending)",
          "1077:   return IO_WQ_CANCEL_OK;",
          "1078:  return IO_WQ_CANCEL_NOTFOUND;",
          "1081: static bool io_wq_io_cb_cancel_data(struct io_wq_work *work, void *data)",
          "1083:  return work == data;",
          "1086: enum io_wq_cancel io_wq_cancel_work(struct io_wq *wq, struct io_wq_work *cwork)",
          "1088:  return io_wq_cancel_cb(wq, io_wq_io_cb_cancel_data, (void *)cwork, false);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1011:  int ret = -ENOMEM, node;",
          "1012:  struct io_wq *wq;",
          "1014:  wq = kzalloc(sizeof(*wq), GFP_KERNEL);",
          "1015:  if (!wq)",
          "1016:   return ERR_PTR(-ENOMEM);",
          "1018:  wq->wqes = kcalloc(nr_node_ids, sizeof(struct io_wqe *), GFP_KERNEL);",
          "1028:  wq->user = data->user;",
          "1031:  for_each_node(node) {",
          "1032:   struct io_wqe *wqe;",
          "1035:   if (!wqe)",
          "1036:    goto err;",
          "1037:   wq->wqes[node] = wqe;",
          "1039:   wqe->acct[IO_WQ_ACCT_BOUND].max_workers = bounded;",
          "1040:   atomic_set(&wqe->acct[IO_WQ_ACCT_BOUND].nr_running, 0);",
          "1041:   if (wq->user) {",
          "",
          "[Removed Lines]",
          "1019:  if (!wq->wqes) {",
          "1020:   kfree(wq);",
          "1021:   return ERR_PTR(-ENOMEM);",
          "1022:  }",
          "1024:  wq->get_work = data->get_work;",
          "1025:  wq->put_work = data->put_work;",
          "1029:  wq->creds = data->creds;",
          "1034:   wqe = kzalloc_node(sizeof(struct io_wqe), GFP_KERNEL, node);",
          "1038:   wqe->node = node;",
          "",
          "[Added Lines]",
          "1096:  if (WARN_ON_ONCE(!data->free_work || !data->do_work))",
          "1097:   return ERR_PTR(-EINVAL);",
          "1104:  if (!wq->wqes)",
          "1105:   goto err_wq;",
          "1107:  ret = cpuhp_state_add_instance_nocalls(io_wq_online, &wq->cpuhp_node);",
          "1108:  if (ret)",
          "1109:   goto err_wqes;",
          "1111:  wq->free_work = data->free_work;",
          "1112:  wq->do_work = data->do_work;",
          "1117:  ret = -ENOMEM;",
          "1120:   int alloc_node = node;",
          "1122:   if (!node_online(alloc_node))",
          "1123:    alloc_node = NUMA_NO_NODE;",
          "1124:   wqe = kzalloc_node(sizeof(struct io_wqe), GFP_KERNEL, alloc_node);",
          "1128:   wqe->node = alloc_node;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1043:      task_rlimit(current, RLIMIT_NPROC);",
          "1044:   }",
          "1045:   atomic_set(&wqe->acct[IO_WQ_ACCT_UNBOUND].nr_running, 0);",
          "1047:   wqe->wq = wq;",
          "1049:   INIT_WQ_LIST(&wqe->work_list);",
          "1050:   INIT_HLIST_NULLS_HEAD(&wqe->free_list, 0);",
          "1051:   INIT_LIST_HEAD(&wqe->all_list);",
          "",
          "[Removed Lines]",
          "1046:   wqe->node = node;",
          "1048:   spin_lock_init(&wqe->lock);",
          "",
          "[Added Lines]",
          "1137:   raw_spin_lock_init(&wqe->lock);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1054:  init_completion(&wq->done);",
          "1059:  wq->manager = kthread_create(io_wq_manager, wq, \"io_wq_manager\");",
          "1060:  if (!IS_ERR(wq->manager)) {",
          "1061:   wake_up_process(wq->manager);",
          "",
          "[Removed Lines]",
          "1057:  wq->mm = data->mm;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1064:    ret = -ENOMEM;",
          "1065:    goto err;",
          "1066:   }",
          "1067:   reinit_completion(&wq->done);",
          "1068:   return wq;",
          "1069:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1153:   refcount_set(&wq->use_refs, 1);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1071:  ret = PTR_ERR(wq->manager);",
          "1072:  complete(&wq->done);",
          "1073: err:",
          "1074:  for_each_node(node)",
          "1075:   kfree(wq->wqes[node]);",
          "1076:  kfree(wq->wqes);",
          "1077:  kfree(wq);",
          "1078:  return ERR_PTR(ret);",
          "1079: }",
          "1082: {",
          "1085: }",
          "1088: {",
          "1089:  int node;",
          "1091:  set_bit(IO_WQ_BIT_EXIT, &wq->state);",
          "1092:  if (wq->manager)",
          "1093:   kthread_stop(wq->manager);",
          "",
          "[Removed Lines]",
          "1081: static bool io_wq_worker_wake(struct io_worker *worker, void *data)",
          "1083:  wake_up_process(worker->task);",
          "1084:  return false;",
          "1087: void io_wq_destroy(struct io_wq *wq)",
          "",
          "[Added Lines]",
          "1161:  cpuhp_state_remove_instance_nocalls(io_wq_online, &wq->cpuhp_node);",
          "1164: err_wqes:",
          "1166: err_wq:",
          "1171: bool io_wq_get(struct io_wq *wq, struct io_wq_data *data)",
          "1173:  if (data->free_work != wq->free_work || data->do_work != wq->do_work)",
          "1174:   return false;",
          "1176:  return refcount_inc_not_zero(&wq->use_refs);",
          "1179: static void __io_wq_destroy(struct io_wq *wq)",
          "1183:  cpuhp_state_remove_instance_nocalls(io_wq_online, &wq->cpuhp_node);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1104:  kfree(wq->wqes);",
          "1105:  kfree(wq);",
          "1106: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1202: void io_wq_destroy(struct io_wq *wq)",
          "1203: {",
          "1204:  if (refcount_dec_and_test(&wq->use_refs))",
          "1205:   __io_wq_destroy(wq);",
          "1206: }",
          "1208: struct task_struct *io_wq_get_task(struct io_wq *wq)",
          "1209: {",
          "1210:  return wq->manager;",
          "1211: }",
          "1213: static bool io_wq_worker_affinity(struct io_worker *worker, void *data)",
          "1214: {",
          "1215:  struct task_struct *task = worker->task;",
          "1216:  struct rq_flags rf;",
          "1217:  struct rq *rq;",
          "1219:  rq = task_rq_lock(task, &rf);",
          "1220:  do_set_cpus_allowed(task, cpumask_of_node(worker->wqe->node));",
          "1221:  task->flags |= PF_NO_SETAFFINITY;",
          "1222:  task_rq_unlock(rq, task, &rf);",
          "1223:  return false;",
          "1224: }",
          "1226: static int io_wq_cpu_online(unsigned int cpu, struct hlist_node *node)",
          "1227: {",
          "1228:  struct io_wq *wq = hlist_entry_safe(node, struct io_wq, cpuhp_node);",
          "1229:  int i;",
          "1231:  rcu_read_lock();",
          "1232:  for_each_node(i)",
          "1233:   io_wq_for_each_worker(wq->wqes[i], io_wq_worker_affinity, NULL);",
          "1234:  rcu_read_unlock();",
          "1235:  return 0;",
          "1236: }",
          "1238: static __init int io_wq_init(void)",
          "1239: {",
          "1240:  int ret;",
          "1242:  ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN, \"io-wq/online\",",
          "1243:      io_wq_cpu_online, NULL);",
          "1244:  if (ret < 0)",
          "1245:   return ret;",
          "1246:  io_wq_online = ret;",
          "1247:  return 0;",
          "1248: }",
          "1249: subsys_initcall(io_wq_init);",
          "",
          "---------------"
        ],
        "fs/io-wq.h||fs/io-wq.h": [
          "File: fs/io-wq.h -> fs/io-wq.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #ifndef INTERNAL_IO_WQ_H",
          "2: #define INTERNAL_IO_WQ_H",
          "4: struct io_wq;",
          "6: enum {",
          "7:  IO_WQ_WORK_CANCEL = 1,",
          "17: };",
          "",
          "[Removed Lines]",
          "8:  IO_WQ_WORK_HAS_MM = 2,",
          "9:  IO_WQ_WORK_HASHED = 4,",
          "10:  IO_WQ_WORK_NEEDS_USER = 8,",
          "11:  IO_WQ_WORK_NEEDS_FILES = 16,",
          "12:  IO_WQ_WORK_UNBOUND = 32,",
          "13:  IO_WQ_WORK_INTERNAL = 64,",
          "14:  IO_WQ_WORK_CB  = 128,",
          "",
          "[Added Lines]",
          "4: #include <linux/io_uring.h>",
          "10:  IO_WQ_WORK_HASHED = 2,",
          "11:  IO_WQ_WORK_UNBOUND = 4,",
          "12:  IO_WQ_WORK_NO_CANCEL = 8,",
          "13:  IO_WQ_WORK_CONCURRENT = 16,",
          "15:  IO_WQ_WORK_FILES = 32,",
          "16:  IO_WQ_WORK_FS  = 64,",
          "17:  IO_WQ_WORK_MM  = 128,",
          "18:  IO_WQ_WORK_CREDS = 256,",
          "19:  IO_WQ_WORK_BLKCG = 512,",
          "20:  IO_WQ_WORK_FSIZE = 1024,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "31:  struct io_wq_work_node *last;",
          "32: };",
          "34: static inline void wq_list_add_tail(struct io_wq_work_node *node,",
          "35:         struct io_wq_work_list *list)",
          "36: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: static inline void wq_list_add_after(struct io_wq_work_node *node,",
          "41:          struct io_wq_work_node *pos,",
          "42:          struct io_wq_work_list *list)",
          "43: {",
          "44:  struct io_wq_work_node *next = pos->next;",
          "46:  pos->next = node;",
          "47:  node->next = next;",
          "48:  if (!next)",
          "49:   list->last = node;",
          "50: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "43:  }",
          "44: }",
          "48:           struct io_wq_work_node *prev)",
          "49: {",
          "53:   list->last = prev;",
          "57: }",
          "59: #define wq_list_for_each(pos, prv, head)   \\",
          "",
          "[Removed Lines]",
          "46: static inline void wq_node_del(struct io_wq_work_list *list,",
          "47:           struct io_wq_work_node *node,",
          "50:  if (node == list->first)",
          "51:   WRITE_ONCE(list->first, node->next);",
          "52:  if (node == list->last)",
          "54:  if (prev)",
          "55:   prev->next = node->next;",
          "56:  node->next = NULL;",
          "",
          "[Added Lines]",
          "64: static inline void wq_list_cut(struct io_wq_work_list *list,",
          "65:           struct io_wq_work_node *last,",
          "69:  if (!prev)",
          "70:   WRITE_ONCE(list->first, last->next);",
          "71:  else",
          "72:   prev->next = last->next;",
          "74:  if (last == list->last)",
          "76:  last->next = NULL;",
          "77: }",
          "79: static inline void wq_list_del(struct io_wq_work_list *list,",
          "80:           struct io_wq_work_node *node,",
          "81:           struct io_wq_work_node *prev)",
          "82: {",
          "83:  wq_list_cut(list, node, prev);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "66: } while (0)",
          "68: struct io_wq_work {",
          "75:  unsigned flags;",
          "76: };",
          "89: struct io_wq_data {",
          "91:  struct user_struct *user;",
          "96: };",
          "98: struct io_wq *io_wq_create(unsigned bounded, struct io_wq_data *data);",
          "99: void io_wq_destroy(struct io_wq *wq);",
          "101: void io_wq_enqueue(struct io_wq *wq, struct io_wq_work *work);",
          "105: void io_wq_cancel_all(struct io_wq *wq);",
          "106: enum io_wq_cancel io_wq_cancel_work(struct io_wq *wq, struct io_wq_work *cwork);",
          "",
          "[Removed Lines]",
          "69:  union {",
          "70:   struct io_wq_work_node list;",
          "71:   void *data;",
          "72:  };",
          "73:  void (*func)(struct io_wq_work **);",
          "74:  struct files_struct *files;",
          "78: #define INIT_IO_WORK(work, _func)   \\",
          "79:  do {      \\",
          "80:   (work)->list.next = NULL;  \\",
          "81:   (work)->func = _func;   \\",
          "82:   (work)->flags = 0;   \\",
          "83:   (work)->files = NULL;   \\",
          "84:  } while (0)     \\",
          "86: typedef void (get_work_fn)(struct io_wq_work *);",
          "87: typedef void (put_work_fn)(struct io_wq_work *);",
          "90:  struct mm_struct *mm;",
          "92:  const struct cred *creds;",
          "94:  get_work_fn *get_work;",
          "95:  put_work_fn *put_work;",
          "102: void io_wq_enqueue_hashed(struct io_wq *wq, struct io_wq_work *work, void *val);",
          "103: void io_wq_flush(struct io_wq *wq);",
          "",
          "[Added Lines]",
          "96:  struct io_wq_work_node list;",
          "97:  struct io_identity *identity;",
          "101: static inline struct io_wq_work *wq_next_work(struct io_wq_work *work)",
          "102: {",
          "103:  if (!work->list.next)",
          "104:   return NULL;",
          "106:  return container_of(work->list.next, struct io_wq_work, list);",
          "107: }",
          "109: typedef void (free_work_fn)(struct io_wq_work *);",
          "110: typedef struct io_wq_work *(io_wq_work_fn)(struct io_wq_work *);",
          "115:  io_wq_work_fn *do_work;",
          "116:  free_work_fn *free_work;",
          "120: bool io_wq_get(struct io_wq *wq, struct io_wq_data *data);",
          "124: void io_wq_hash_work(struct io_wq_work *work, void *val);",
          "126: static inline bool io_wq_is_hashed(struct io_wq_work *work)",
          "127: {",
          "128:  return work->flags & IO_WQ_WORK_HASHED;",
          "129: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "108: typedef bool (work_cancel_fn)(struct io_wq_work *, void *);",
          "110: enum io_wq_cancel io_wq_cancel_cb(struct io_wq *wq, work_cancel_fn *cancel,",
          "113: #if defined(CONFIG_IO_WQ)",
          "114: extern void io_wq_worker_sleeping(struct task_struct *);",
          "",
          "[Removed Lines]",
          "111:      void *data);",
          "",
          "[Added Lines]",
          "137:      void *data, bool cancel_all);",
          "139: struct task_struct *io_wq_get_task(struct io_wq *wq);",
          "",
          "---------------"
        ],
        "fs/io_uring.c||fs/io_uring.c": [
          "File: fs/io_uring.c -> fs/io_uring.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "44: #include <linux/errno.h>",
          "45: #include <linux/syscalls.h>",
          "46: #include <linux/compat.h>",
          "47: #include <linux/refcount.h>",
          "48: #include <linux/uio.h>",
          "50: #include <linux/sched/signal.h>",
          "51: #include <linux/fs.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #include <net/compat.h>",
          "50: #include <linux/bits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53: #include <linux/fdtable.h>",
          "54: #include <linux/mm.h>",
          "55: #include <linux/mman.h>",
          "57: #include <linux/percpu.h>",
          "58: #include <linux/slab.h>",
          "59: #include <linux/kthread.h>",
          "",
          "[Removed Lines]",
          "56: #include <linux/mmu_context.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "70: #include <linux/sizes.h>",
          "71: #include <linux/hugetlb.h>",
          "72: #include <linux/highmem.h>",
          "74: #define CREATE_TRACE_POINTS",
          "75: #include <trace/events/io_uring.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74: #include <linux/namei.h>",
          "75: #include <linux/fsnotify.h>",
          "76: #include <linux/fadvise.h>",
          "77: #include <linux/eventpoll.h>",
          "78: #include <linux/fs_struct.h>",
          "79: #include <linux/splice.h>",
          "80: #include <linux/task_work.h>",
          "81: #include <linux/pagemap.h>",
          "82: #include <linux/io_uring.h>",
          "83: #include <linux/blk-cgroup.h>",
          "84: #include <linux/audit.h>",
          "85: #include <linux/mmu_context.h>",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "89: #define IORING_MAX_FILES_TABLE (1U << IORING_FILE_TABLE_SHIFT)",
          "90: #define IORING_FILE_TABLE_MASK (IORING_MAX_FILES_TABLE - 1)",
          "91: #define IORING_MAX_FIXED_FILES (64 * IORING_MAX_FILES_TABLE)",
          "93: struct io_uring {",
          "94:  u32 head ____cacheline_aligned_in_smp;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "105: #define IORING_MAX_RESTRICTIONS (IORING_RESTRICTION_LAST + \\",
          "106:      IORING_REGISTER_LAST + IORING_OP_LAST)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "144:  u32   sq_flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "166:  u32                     cq_flags;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "171:  size_t  len;",
          "172:  struct  bio_vec *bvec;",
          "173:  unsigned int nr_bvecs;",
          "174: };",
          "176: struct fixed_file_table {",
          "177:  struct file  **files;",
          "178: };",
          "180: struct io_ring_ctx {",
          "181:  struct {",
          "182:   struct percpu_ref refs;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "196:  unsigned long acct_pages;",
          "203: struct fixed_file_ref_node {",
          "204:  struct percpu_ref  refs;",
          "205:  struct list_head  node;",
          "206:  struct list_head  file_list;",
          "207:  struct fixed_file_data  *file_data;",
          "208:  struct llist_node  llist;",
          "209:  bool    done;",
          "210: };",
          "212: struct fixed_file_data {",
          "213:  struct fixed_file_table  *table;",
          "214:  struct io_ring_ctx  *ctx;",
          "216:  struct fixed_file_ref_node *node;",
          "217:  struct percpu_ref  refs;",
          "218:  struct completion  done;",
          "219:  struct list_head  ref_list;",
          "220:  spinlock_t   lock;",
          "221: };",
          "223: struct io_buffer {",
          "224:  struct list_head list;",
          "225:  __u64 addr;",
          "226:  __s32 len;",
          "227:  __u16 bid;",
          "228: };",
          "230: struct io_restriction {",
          "231:  DECLARE_BITMAP(register_op, IORING_REGISTER_LAST);",
          "232:  DECLARE_BITMAP(sqe_op, IORING_OP_LAST);",
          "233:  u8 sqe_flags_allowed;",
          "234:  u8 sqe_flags_required;",
          "235:  bool registered;",
          "236: };",
          "238: struct io_sq_data {",
          "239:  refcount_t  refs;",
          "240:  struct mutex  lock;",
          "243:  struct list_head ctx_list;",
          "244:  struct list_head ctx_new_list;",
          "245:  struct mutex  ctx_lock;",
          "247:  struct task_struct *thread;",
          "248:  struct wait_queue_head wait;",
          "249: };",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "185:  struct {",
          "186:   unsigned int  flags;",
          "",
          "[Removed Lines]",
          "187:   bool   compat;",
          "188:   bool   account_mem;",
          "189:   bool   cq_overflow_flushed;",
          "190:   bool   drain_next;",
          "",
          "[Added Lines]",
          "258:   unsigned int  compat: 1;",
          "259:   unsigned int  limit_mem: 1;",
          "260:   unsigned int  cq_overflow_flushed: 1;",
          "261:   unsigned int  drain_next: 1;",
          "262:   unsigned int  eventfd_async: 1;",
          "263:   unsigned int  restricted: 1;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "206:   unsigned  sq_mask;",
          "207:   unsigned  sq_thread_idle;",
          "208:   unsigned  cached_sq_dropped;",
          "212:   struct list_head defer_list;",
          "213:   struct list_head timeout_list;",
          "214:   struct list_head cq_overflow_list;",
          "216:   wait_queue_head_t inflight_wait;",
          "217:  } ____cacheline_aligned_in_smp;",
          "219:  struct io_rings *rings;",
          "222:  struct io_wq  *io_wq;",
          "233:  unsigned  nr_user_files;",
          "",
          "[Removed Lines]",
          "209:   atomic_t  cached_cq_overflow;",
          "210:   struct io_uring_sqe *sq_sqes;",
          "224:  struct mm_struct *sqo_mm;",
          "225:  wait_queue_head_t sqo_wait;",
          "232:  struct fixed_file_table *file_table;",
          "",
          "[Added Lines]",
          "282:   unsigned  cached_cq_overflow;",
          "283:   unsigned long  sq_check_overflow;",
          "290:   struct io_uring_sqe *sq_sqes;",
          "302:  struct task_struct *sqo_task;",
          "305:  struct mm_struct *mm_account;",
          "307: #ifdef CONFIG_BLK_CGROUP",
          "308:  struct cgroup_subsys_state *sqo_blkcg_css;",
          "309: #endif",
          "313:  struct wait_queue_head sqo_sq_wait;",
          "314:  struct wait_queue_entry sqo_wait_entry;",
          "315:  struct list_head sqd_list;",
          "322:  struct fixed_file_data *file_data;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "241:  const struct cred *creds;",
          "247:  struct io_kiocb  *fallback_req;",
          "",
          "[Removed Lines]",
          "244:  struct completion *completions;",
          "",
          "[Added Lines]",
          "333: #ifdef CONFIG_AUDIT",
          "334:  kuid_t   loginuid;",
          "335:  unsigned int  sessionid;",
          "336: #endif",
          "338:  struct completion ref_comp;",
          "339:  struct completion sq_thread_comp;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "250:  struct socket  *ring_sock;",
          "251: #endif",
          "253:  struct {",
          "254:   unsigned  cached_cq_tail;",
          "255:   unsigned  cq_entries;",
          "256:   unsigned  cq_mask;",
          "257:   atomic_t  cq_timeouts;",
          "258:   struct wait_queue_head cq_wait;",
          "259:   struct fasync_struct *cq_fasync;",
          "260:   struct eventfd_ctx *cq_ev_fd;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "348:  struct idr  io_buffer_idr;",
          "350:  struct idr  personality_idr;",
          "357:   unsigned long  cq_check_overflow;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "268:  struct {",
          "269:   spinlock_t  completion_lock;",
          "278:   struct hlist_head *cancel_hash;",
          "279:   unsigned  cancel_hash_bits;",
          "281:   spinlock_t  inflight_lock;",
          "282:   struct list_head inflight_list;",
          "283:  } ____cacheline_aligned_in_smp;",
          "284: };",
          "",
          "[Removed Lines]",
          "270:   bool   poll_multi_file;",
          "277:   struct list_head poll_list;",
          "",
          "[Added Lines]",
          "377:   struct list_head iopoll_list;",
          "380:   bool   poll_multi_file;",
          "386:  struct delayed_work  file_put_work;",
          "387:  struct llist_head  file_put_llist;",
          "389:  struct work_struct  exit_work;",
          "390:  struct io_restriction  restrictions;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "299:  struct wait_queue_entry  wait;",
          "300: };",
          "302: struct io_timeout_data {",
          "303:  struct io_kiocb   *req;",
          "304:  struct hrtimer   timer;",
          "305:  struct timespec64  ts;",
          "306:  enum hrtimer_mode  mode;",
          "308: };",
          "310: struct io_accept {",
          "",
          "[Removed Lines]",
          "307:  u32    seq_offset;",
          "",
          "[Added Lines]",
          "409: struct io_close {",
          "410:  struct file   *file;",
          "411:  struct file   *put_file;",
          "412:  int    fd;",
          "413: };",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "312:  struct sockaddr __user  *addr;",
          "313:  int __user   *addr_len;",
          "314:  int    flags;",
          "315: };",
          "317: struct io_sync {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "427:  unsigned long   nofile;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "319:  loff_t    len;",
          "320:  loff_t    off;",
          "321:  int    flags;",
          "322: };",
          "324: struct io_cancel {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "435:  int    mode;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "327: };",
          "329: struct io_timeout {",
          "330:  struct file   *file;",
          "331:  u64    addr;",
          "334: };",
          "336: struct io_rw {",
          "",
          "[Removed Lines]",
          "332:  int    flags;",
          "333:  unsigned   count;",
          "",
          "[Added Lines]",
          "444:  struct file   *file;",
          "445:  u32    off;",
          "446:  u32    target_seq;",
          "447:  struct list_head  list;",
          "448: };",
          "450: struct io_timeout_rem {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "349: struct io_sr_msg {",
          "350:  struct file   *file;",
          "352:  int    msg_flags;",
          "353: };",
          "355: struct io_async_connect {",
          "",
          "[Removed Lines]",
          "351:  struct user_msghdr __user *msg;",
          "",
          "[Added Lines]",
          "470:  union {",
          "471:   struct user_msghdr __user *umsg;",
          "472:   void __user  *buf;",
          "473:  };",
          "475:  int    bgid;",
          "476:  size_t    len;",
          "477:  struct io_buffer  *kbuf;",
          "478: };",
          "480: struct io_open {",
          "481:  struct file   *file;",
          "482:  int    dfd;",
          "483:  bool    ignore_nonblock;",
          "484:  struct filename   *filename;",
          "485:  struct open_how   how;",
          "486:  unsigned long   nofile;",
          "487: };",
          "489: struct io_files_update {",
          "490:  struct file   *file;",
          "491:  u64    arg;",
          "492:  u32    nr_args;",
          "493:  u32    offset;",
          "494: };",
          "496: struct io_fadvise {",
          "497:  struct file   *file;",
          "498:  u64    offset;",
          "499:  u32    len;",
          "500:  u32    advice;",
          "501: };",
          "503: struct io_madvise {",
          "504:  struct file   *file;",
          "505:  u64    addr;",
          "506:  u32    len;",
          "507:  u32    advice;",
          "508: };",
          "510: struct io_epoll {",
          "511:  struct file   *file;",
          "512:  int    epfd;",
          "513:  int    op;",
          "514:  int    fd;",
          "515:  struct epoll_event  event;",
          "516: };",
          "518: struct io_splice {",
          "519:  struct file   *file_out;",
          "520:  struct file   *file_in;",
          "521:  loff_t    off_out;",
          "522:  loff_t    off_in;",
          "523:  u64    len;",
          "524:  unsigned int   flags;",
          "525: };",
          "527: struct io_provide_buf {",
          "528:  struct file   *file;",
          "529:  __u64    addr;",
          "530:  __s32    len;",
          "531:  __u32    bgid;",
          "532:  __u16    nbufs;",
          "533:  __u16    bid;",
          "534: };",
          "536: struct io_statx {",
          "537:  struct file   *file;",
          "538:  int    dfd;",
          "539:  unsigned int   mask;",
          "540:  unsigned int   flags;",
          "541:  const char __user  *filename;",
          "542:  struct statx __user  *buffer;",
          "543: };",
          "545: struct io_completion {",
          "546:  struct file   *file;",
          "547:  struct list_head  list;",
          "548:  int    cflags;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "361:  struct iovec   *iov;",
          "362:  struct sockaddr __user  *uaddr;",
          "363:  struct msghdr   msg;",
          "364: };",
          "366: struct io_async_rw {",
          "367:  struct iovec   fast_iov[UIO_FASTIOV];",
          "371: };",
          "380: };",
          "",
          "[Removed Lines]",
          "368:  struct iovec   *iov;",
          "369:  ssize_t    nr_segs;",
          "370:  ssize_t    size;",
          "373: struct io_async_ctx {",
          "374:  union {",
          "375:   struct io_async_rw rw;",
          "376:   struct io_async_msghdr msg;",
          "377:   struct io_async_connect connect;",
          "378:   struct io_timeout_data timeout;",
          "379:  };",
          "",
          "[Added Lines]",
          "560:  struct sockaddr_storage  addr;",
          "565:  const struct iovec  *free_iovec;",
          "566:  struct iov_iter   iter;",
          "567:  size_t    bytes_done;",
          "568:  struct wait_page_queue  wpq;",
          "571: enum {",
          "572:  REQ_F_FIXED_FILE_BIT = IOSQE_FIXED_FILE_BIT,",
          "573:  REQ_F_IO_DRAIN_BIT = IOSQE_IO_DRAIN_BIT,",
          "574:  REQ_F_LINK_BIT  = IOSQE_IO_LINK_BIT,",
          "575:  REQ_F_HARDLINK_BIT = IOSQE_IO_HARDLINK_BIT,",
          "576:  REQ_F_FORCE_ASYNC_BIT = IOSQE_ASYNC_BIT,",
          "577:  REQ_F_BUFFER_SELECT_BIT = IOSQE_BUFFER_SELECT_BIT,",
          "579:  REQ_F_LINK_HEAD_BIT,",
          "580:  REQ_F_FAIL_LINK_BIT,",
          "581:  REQ_F_INFLIGHT_BIT,",
          "582:  REQ_F_CUR_POS_BIT,",
          "583:  REQ_F_NOWAIT_BIT,",
          "584:  REQ_F_LINK_TIMEOUT_BIT,",
          "585:  REQ_F_ISREG_BIT,",
          "586:  REQ_F_NEED_CLEANUP_BIT,",
          "587:  REQ_F_POLLED_BIT,",
          "588:  REQ_F_BUFFER_SELECTED_BIT,",
          "589:  REQ_F_NO_FILE_TABLE_BIT,",
          "590:  REQ_F_WORK_INITIALIZED_BIT,",
          "591:  REQ_F_LTIMEOUT_ACTIVE_BIT,",
          "594:  __REQ_F_LAST_BIT,",
          "595: };",
          "597: enum {",
          "599:  REQ_F_FIXED_FILE = BIT(REQ_F_FIXED_FILE_BIT),",
          "601:  REQ_F_IO_DRAIN  = BIT(REQ_F_IO_DRAIN_BIT),",
          "603:  REQ_F_LINK  = BIT(REQ_F_LINK_BIT),",
          "605:  REQ_F_HARDLINK  = BIT(REQ_F_HARDLINK_BIT),",
          "607:  REQ_F_FORCE_ASYNC = BIT(REQ_F_FORCE_ASYNC_BIT),",
          "609:  REQ_F_BUFFER_SELECT = BIT(REQ_F_BUFFER_SELECT_BIT),",
          "612:  REQ_F_LINK_HEAD  = BIT(REQ_F_LINK_HEAD_BIT),",
          "614:  REQ_F_FAIL_LINK  = BIT(REQ_F_FAIL_LINK_BIT),",
          "616:  REQ_F_INFLIGHT  = BIT(REQ_F_INFLIGHT_BIT),",
          "618:  REQ_F_CUR_POS  = BIT(REQ_F_CUR_POS_BIT),",
          "620:  REQ_F_NOWAIT  = BIT(REQ_F_NOWAIT_BIT),",
          "622:  REQ_F_LINK_TIMEOUT = BIT(REQ_F_LINK_TIMEOUT_BIT),",
          "624:  REQ_F_ISREG  = BIT(REQ_F_ISREG_BIT),",
          "626:  REQ_F_NEED_CLEANUP = BIT(REQ_F_NEED_CLEANUP_BIT),",
          "628:  REQ_F_POLLED  = BIT(REQ_F_POLLED_BIT),",
          "630:  REQ_F_BUFFER_SELECTED = BIT(REQ_F_BUFFER_SELECTED_BIT),",
          "632:  REQ_F_NO_FILE_TABLE = BIT(REQ_F_NO_FILE_TABLE_BIT),",
          "634:  REQ_F_WORK_INITIALIZED = BIT(REQ_F_WORK_INITIALIZED_BIT),",
          "636:  REQ_F_LTIMEOUT_ACTIVE = BIT(REQ_F_LTIMEOUT_ACTIVE_BIT),",
          "637: };",
          "639: struct async_poll {",
          "640:  struct io_poll_iocb poll;",
          "641:  struct io_poll_iocb *double_poll;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "394:   struct io_sync  sync;",
          "395:   struct io_cancel cancel;",
          "396:   struct io_timeout timeout;",
          "397:   struct io_connect connect;",
          "398:   struct io_sr_msg sr_msg;",
          "399:  };",
          "407:  u8    opcode;",
          "441: };",
          "444: #define IO_IOPOLL_BATCH   8",
          "446: struct io_submit_state {",
          "447:  struct blk_plug  plug;",
          "",
          "[Removed Lines]",
          "401:  struct io_async_ctx  *io;",
          "402:  struct file   *ring_file;",
          "403:  int    ring_fd;",
          "404:  bool    has_user;",
          "405:  bool    in_async;",
          "406:  bool    needs_fixed_file;",
          "409:  struct io_ring_ctx *ctx;",
          "410:  union {",
          "411:   struct list_head list;",
          "412:   struct hlist_node hash_node;",
          "413:  };",
          "414:  struct list_head link_list;",
          "415:  unsigned int  flags;",
          "416:  refcount_t  refs;",
          "434:  u64   user_data;",
          "435:  u32   result;",
          "436:  u32   sequence;",
          "438:  struct list_head inflight_entry;",
          "440:  struct io_wq_work work;",
          "443: #define IO_PLUG_THRESHOLD  2",
          "",
          "[Added Lines]",
          "659:   struct io_timeout_rem timeout_rem;",
          "662:   struct io_open  open;",
          "663:   struct io_close  close;",
          "664:   struct io_files_update files_update;",
          "665:   struct io_fadvise fadvise;",
          "666:   struct io_madvise madvise;",
          "667:   struct io_epoll  epoll;",
          "668:   struct io_splice splice;",
          "669:   struct io_provide_buf pbuf;",
          "670:   struct io_statx  statx;",
          "672:   struct io_completion compl;",
          "676:  void    *async_data;",
          "679:  u8    iopoll_completed;",
          "681:  u16    buf_index;",
          "682:  u32    result;",
          "684:  struct io_ring_ctx  *ctx;",
          "685:  unsigned int   flags;",
          "686:  refcount_t   refs;",
          "687:  struct task_struct  *task;",
          "688:  u64    user_data;",
          "690:  struct list_head  link_list;",
          "696:  struct list_head  inflight_entry;",
          "698:  struct percpu_ref  *fixed_file_refs;",
          "699:  struct callback_head  task_work;",
          "701:  struct hlist_node  hash_node;",
          "702:  struct async_poll  *apoll;",
          "703:  struct io_wq_work  work;",
          "704: };",
          "706: struct io_defer_entry {",
          "707:  struct list_head list;",
          "708:  struct io_kiocb  *req;",
          "709:  u32   seq;",
          "714: struct io_comp_state {",
          "715:  unsigned int  nr;",
          "716:  struct list_head list;",
          "717:  struct io_ring_ctx *ctx;",
          "718: };",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "452:  void   *reqs[IO_IOPOLL_BATCH];",
          "",
          "[Removed Lines]",
          "453:  unsigned  int free_reqs;",
          "454:  unsigned  int cur_req;",
          "",
          "[Added Lines]",
          "727:  unsigned int  free_reqs;",
          "732:  struct io_comp_state comp;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "459:  struct file  *file;",
          "460:  unsigned int  fd;",
          "461:  unsigned int  has_refs;",
          "463:  unsigned int  ios_left;",
          "464: };",
          "467: static void io_cqring_fill_event(struct io_kiocb *req, long res);",
          "469: static void io_put_req(struct io_kiocb *req);",
          "470: static void io_double_put_req(struct io_kiocb *req);",
          "472: static struct io_kiocb *io_prep_linked_timeout(struct io_kiocb *req);",
          "473: static void io_queue_linked_timeout(struct io_kiocb *req);",
          "475: static struct kmem_cache *req_cachep;",
          "",
          "[Removed Lines]",
          "462:  unsigned int  used_refs;",
          "466: static void io_wq_submit_work(struct io_wq_work **workptr);",
          "468: static void __io_free_req(struct io_kiocb *req);",
          "471: static void __io_double_put_req(struct io_kiocb *req);",
          "",
          "[Added Lines]",
          "743: struct io_op_def {",
          "745:  unsigned  needs_file : 1;",
          "747:  unsigned  needs_file_no_error : 1;",
          "749:  unsigned  hash_reg_file : 1;",
          "751:  unsigned  unbound_nonreg_file : 1;",
          "753:  unsigned  not_supported : 1;",
          "755:  unsigned  pollin : 1;",
          "756:  unsigned  pollout : 1;",
          "758:  unsigned  buffer_select : 1;",
          "760:  unsigned  needs_async_data : 1;",
          "762:  unsigned short  async_size;",
          "763:  unsigned  work_flags;",
          "764: };",
          "766: static const struct io_op_def io_op_defs[] = {",
          "767:  [IORING_OP_NOP] = {},",
          "768:  [IORING_OP_READV] = {",
          "769:   .needs_file  = 1,",
          "770:   .unbound_nonreg_file = 1,",
          "771:   .pollin   = 1,",
          "772:   .buffer_select  = 1,",
          "773:   .needs_async_data = 1,",
          "774:   .async_size  = sizeof(struct io_async_rw),",
          "775:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG,",
          "776:  },",
          "777:  [IORING_OP_WRITEV] = {",
          "778:   .needs_file  = 1,",
          "779:   .hash_reg_file  = 1,",
          "780:   .unbound_nonreg_file = 1,",
          "781:   .pollout  = 1,",
          "782:   .needs_async_data = 1,",
          "783:   .async_size  = sizeof(struct io_async_rw),",
          "784:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG |",
          "785:       IO_WQ_WORK_FSIZE,",
          "786:  },",
          "787:  [IORING_OP_FSYNC] = {",
          "788:   .needs_file  = 1,",
          "789:   .work_flags  = IO_WQ_WORK_BLKCG,",
          "790:  },",
          "791:  [IORING_OP_READ_FIXED] = {",
          "792:   .needs_file  = 1,",
          "793:   .unbound_nonreg_file = 1,",
          "794:   .pollin   = 1,",
          "795:   .async_size  = sizeof(struct io_async_rw),",
          "796:   .work_flags  = IO_WQ_WORK_BLKCG | IO_WQ_WORK_MM,",
          "797:  },",
          "798:  [IORING_OP_WRITE_FIXED] = {",
          "799:   .needs_file  = 1,",
          "800:   .hash_reg_file  = 1,",
          "801:   .unbound_nonreg_file = 1,",
          "802:   .pollout  = 1,",
          "803:   .async_size  = sizeof(struct io_async_rw),",
          "804:   .work_flags  = IO_WQ_WORK_BLKCG | IO_WQ_WORK_FSIZE |",
          "805:       IO_WQ_WORK_MM,",
          "806:  },",
          "807:  [IORING_OP_POLL_ADD] = {",
          "808:   .needs_file  = 1,",
          "809:   .unbound_nonreg_file = 1,",
          "810:  },",
          "811:  [IORING_OP_POLL_REMOVE] = {},",
          "812:  [IORING_OP_SYNC_FILE_RANGE] = {",
          "813:   .needs_file  = 1,",
          "814:   .work_flags  = IO_WQ_WORK_BLKCG,",
          "815:  },",
          "816:  [IORING_OP_SENDMSG] = {",
          "817:   .needs_file  = 1,",
          "818:   .unbound_nonreg_file = 1,",
          "819:   .pollout  = 1,",
          "820:   .needs_async_data = 1,",
          "821:   .async_size  = sizeof(struct io_async_msghdr),",
          "822:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG |",
          "823:       IO_WQ_WORK_FS,",
          "824:  },",
          "825:  [IORING_OP_RECVMSG] = {",
          "826:   .needs_file  = 1,",
          "827:   .unbound_nonreg_file = 1,",
          "828:   .pollin   = 1,",
          "829:   .buffer_select  = 1,",
          "830:   .needs_async_data = 1,",
          "831:   .async_size  = sizeof(struct io_async_msghdr),",
          "832:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG |",
          "833:       IO_WQ_WORK_FS,",
          "834:  },",
          "835:  [IORING_OP_TIMEOUT] = {",
          "836:   .needs_async_data = 1,",
          "837:   .async_size  = sizeof(struct io_timeout_data),",
          "838:   .work_flags  = IO_WQ_WORK_MM,",
          "839:  },",
          "840:  [IORING_OP_TIMEOUT_REMOVE] = {},",
          "841:  [IORING_OP_ACCEPT] = {",
          "842:   .needs_file  = 1,",
          "843:   .unbound_nonreg_file = 1,",
          "844:   .pollin   = 1,",
          "845:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_FILES,",
          "846:  },",
          "847:  [IORING_OP_ASYNC_CANCEL] = {},",
          "848:  [IORING_OP_LINK_TIMEOUT] = {",
          "849:   .needs_async_data = 1,",
          "850:   .async_size  = sizeof(struct io_timeout_data),",
          "851:   .work_flags  = IO_WQ_WORK_MM,",
          "852:  },",
          "853:  [IORING_OP_CONNECT] = {",
          "854:   .needs_file  = 1,",
          "855:   .unbound_nonreg_file = 1,",
          "856:   .pollout  = 1,",
          "857:   .needs_async_data = 1,",
          "858:   .async_size  = sizeof(struct io_async_connect),",
          "859:   .work_flags  = IO_WQ_WORK_MM,",
          "860:  },",
          "861:  [IORING_OP_FALLOCATE] = {",
          "862:   .needs_file  = 1,",
          "863:   .work_flags  = IO_WQ_WORK_BLKCG | IO_WQ_WORK_FSIZE,",
          "864:  },",
          "865:  [IORING_OP_OPENAT] = {",
          "866:   .work_flags  = IO_WQ_WORK_FILES | IO_WQ_WORK_BLKCG |",
          "867:       IO_WQ_WORK_FS,",
          "868:  },",
          "869:  [IORING_OP_CLOSE] = {",
          "870:   .needs_file  = 1,",
          "871:   .needs_file_no_error = 1,",
          "872:   .work_flags  = IO_WQ_WORK_FILES | IO_WQ_WORK_BLKCG,",
          "873:  },",
          "874:  [IORING_OP_FILES_UPDATE] = {",
          "875:   .work_flags  = IO_WQ_WORK_FILES | IO_WQ_WORK_MM,",
          "876:  },",
          "877:  [IORING_OP_STATX] = {",
          "878:   .work_flags  = IO_WQ_WORK_FILES | IO_WQ_WORK_MM |",
          "879:       IO_WQ_WORK_FS | IO_WQ_WORK_BLKCG,",
          "880:  },",
          "881:  [IORING_OP_READ] = {",
          "882:   .needs_file  = 1,",
          "883:   .unbound_nonreg_file = 1,",
          "884:   .pollin   = 1,",
          "885:   .buffer_select  = 1,",
          "886:   .async_size  = sizeof(struct io_async_rw),",
          "887:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG,",
          "888:  },",
          "889:  [IORING_OP_WRITE] = {",
          "890:   .needs_file  = 1,",
          "891:   .unbound_nonreg_file = 1,",
          "892:   .pollout  = 1,",
          "893:   .async_size  = sizeof(struct io_async_rw),",
          "894:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG |",
          "895:       IO_WQ_WORK_FSIZE,",
          "896:  },",
          "897:  [IORING_OP_FADVISE] = {",
          "898:   .needs_file  = 1,",
          "899:   .work_flags  = IO_WQ_WORK_BLKCG,",
          "900:  },",
          "901:  [IORING_OP_MADVISE] = {",
          "902:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG,",
          "903:  },",
          "904:  [IORING_OP_SEND] = {",
          "905:   .needs_file  = 1,",
          "906:   .unbound_nonreg_file = 1,",
          "907:   .pollout  = 1,",
          "908:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG,",
          "909:  },",
          "910:  [IORING_OP_RECV] = {",
          "911:   .needs_file  = 1,",
          "912:   .unbound_nonreg_file = 1,",
          "913:   .pollin   = 1,",
          "914:   .buffer_select  = 1,",
          "915:   .work_flags  = IO_WQ_WORK_MM | IO_WQ_WORK_BLKCG,",
          "916:  },",
          "917:  [IORING_OP_OPENAT2] = {",
          "918:   .work_flags  = IO_WQ_WORK_FILES | IO_WQ_WORK_FS |",
          "919:       IO_WQ_WORK_BLKCG,",
          "920:  },",
          "921:  [IORING_OP_EPOLL_CTL] = {",
          "922:   .unbound_nonreg_file = 1,",
          "923:   .work_flags  = IO_WQ_WORK_FILES,",
          "924:  },",
          "925:  [IORING_OP_SPLICE] = {",
          "926:   .needs_file  = 1,",
          "927:   .hash_reg_file  = 1,",
          "928:   .unbound_nonreg_file = 1,",
          "929:   .work_flags  = IO_WQ_WORK_BLKCG,",
          "930:  },",
          "931:  [IORING_OP_PROVIDE_BUFFERS] = {},",
          "932:  [IORING_OP_REMOVE_BUFFERS] = {},",
          "933:  [IORING_OP_TEE] = {",
          "934:   .needs_file  = 1,",
          "935:   .hash_reg_file  = 1,",
          "936:   .unbound_nonreg_file = 1,",
          "937:  },",
          "938: };",
          "940: enum io_mem_account {",
          "941:  ACCT_LOCKED,",
          "942:  ACCT_PINNED,",
          "943: };",
          "945: static void __io_complete_rw(struct io_kiocb *req, long res, long res2,",
          "946:         struct io_comp_state *cs);",
          "949: static void io_put_req_deferred(struct io_kiocb *req, int nr);",
          "952: static void __io_queue_linked_timeout(struct io_kiocb *req);",
          "954: static int __io_sqe_files_update(struct io_ring_ctx *ctx,",
          "955:      struct io_uring_files_update *ip,",
          "956:      unsigned nr_args);",
          "957: static void __io_clean_op(struct io_kiocb *req);",
          "958: static struct file *io_file_get(struct io_submit_state *state,",
          "959:     struct io_kiocb *req, int fd, bool fixed);",
          "960: static void __io_queue_sqe(struct io_kiocb *req, struct io_comp_state *cs);",
          "961: static void io_file_put_work(struct work_struct *work);",
          "963: static ssize_t io_import_iovec(int rw, struct io_kiocb *req,",
          "964:           struct iovec **iovec, struct iov_iter *iter,",
          "965:           bool needs_lock);",
          "966: static int io_setup_async_rw(struct io_kiocb *req, const struct iovec *iovec,",
          "967:         const struct iovec *fast_iov,",
          "968:         struct iov_iter *iter, bool force);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "489: }",
          "490: EXPORT_SYMBOL(io_uring_get_socket);",
          "492: static void io_ring_ctx_ref_free(struct percpu_ref *ref)",
          "493: {",
          "494:  struct io_ring_ctx *ctx = container_of(ref, struct io_ring_ctx, refs);",
          "497: }",
          "499: static struct io_ring_ctx *io_ring_ctx_alloc(struct io_uring_params *p)",
          "",
          "[Removed Lines]",
          "496:  complete(&ctx->completions[0]);",
          "",
          "[Added Lines]",
          "987: static inline void io_clean_op(struct io_kiocb *req)",
          "988: {",
          "989:  if (req->flags & (REQ_F_NEED_CLEANUP | REQ_F_BUFFER_SELECTED |",
          "990:      REQ_F_INFLIGHT))",
          "991:   __io_clean_op(req);",
          "992: }",
          "994: static void io_sq_thread_drop_mm(void)",
          "995: {",
          "996:  struct mm_struct *mm = current->mm;",
          "998:  if (mm) {",
          "999:   unuse_mm(mm);",
          "1000:   mmput(mm);",
          "1001:   current->mm = NULL;",
          "1002:  }",
          "1003: }",
          "1005: static int __io_sq_thread_acquire_mm(struct io_ring_ctx *ctx)",
          "1006: {",
          "1007:  struct mm_struct *mm;",
          "1009:  if (current->mm)",
          "1010:   return 0;",
          "1013:  if (unlikely(!(ctx->flags & IORING_SETUP_SQPOLL)))",
          "1014:   return -EFAULT;",
          "1016:  task_lock(ctx->sqo_task);",
          "1017:  mm = ctx->sqo_task->mm;",
          "1018:  if (unlikely(!mm || !mmget_not_zero(mm)))",
          "1019:   mm = NULL;",
          "1020:  task_unlock(ctx->sqo_task);",
          "1022:  if (mm) {",
          "1023:   use_mm(mm);",
          "1024:   return 0;",
          "1025:  }",
          "1027:  return -EFAULT;",
          "1028: }",
          "1030: static int io_sq_thread_acquire_mm(struct io_ring_ctx *ctx,",
          "1031:        struct io_kiocb *req)",
          "1032: {",
          "1033:  if (!(io_op_defs[req->opcode].work_flags & IO_WQ_WORK_MM))",
          "1034:   return 0;",
          "1035:  return __io_sq_thread_acquire_mm(ctx);",
          "1036: }",
          "1038: static void io_sq_thread_associate_blkcg(struct io_ring_ctx *ctx,",
          "1039:       struct cgroup_subsys_state **cur_css)",
          "1041: {",
          "1042: #ifdef CONFIG_BLK_CGROUP",
          "1044:  if (*cur_css != ctx->sqo_blkcg_css) {",
          "1045:   kthread_associate_blkcg(ctx->sqo_blkcg_css);",
          "1047:  }",
          "1048: #endif",
          "1049: }",
          "1051: static void io_sq_thread_unassociate_blkcg(void)",
          "1052: {",
          "1053: #ifdef CONFIG_BLK_CGROUP",
          "1054:  kthread_associate_blkcg(NULL);",
          "1055: #endif",
          "1056: }",
          "1058: static inline void req_set_fail_links(struct io_kiocb *req)",
          "1059: {",
          "1060:  if ((req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) == REQ_F_LINK)",
          "1061:   req->flags |= REQ_F_FAIL_LINK;",
          "1062: }",
          "1069: static void io_init_identity(struct io_identity *id)",
          "1070: {",
          "1071:  id->files = current->files;",
          "1072:  id->mm = current->mm;",
          "1073: #ifdef CONFIG_BLK_CGROUP",
          "1074:  rcu_read_lock();",
          "1075:  id->blkcg_css = blkcg_css();",
          "1076:  rcu_read_unlock();",
          "1077: #endif",
          "1078:  id->creds = current_cred();",
          "1079:  id->nsproxy = current->nsproxy;",
          "1080:  id->fs = current->fs;",
          "1081:  id->fsize = rlimit(RLIMIT_FSIZE);",
          "1082: #ifdef CONFIG_AUDIT",
          "1083:  id->loginuid = current->loginuid;",
          "1084:  id->sessionid = current->sessionid;",
          "1085: #endif",
          "1086:  refcount_set(&id->count, 1);",
          "1087: }",
          "1089: static inline void __io_req_init_async(struct io_kiocb *req)",
          "1090: {",
          "1091:  memset(&req->work, 0, sizeof(req->work));",
          "1092:  req->flags |= REQ_F_WORK_INITIALIZED;",
          "1093: }",
          "1099: static inline void io_req_init_async(struct io_kiocb *req)",
          "1100: {",
          "1101:  struct io_uring_task *tctx = current->io_uring;",
          "1103:  if (req->flags & REQ_F_WORK_INITIALIZED)",
          "1104:   return;",
          "1106:  __io_req_init_async(req);",
          "1109:  req->work.identity = tctx->identity;",
          "1110:  if (tctx->identity != &tctx->__identity)",
          "1111:   refcount_inc(&req->work.identity->count);",
          "1112: }",
          "1114: static inline bool io_async_submit(struct io_ring_ctx *ctx)",
          "1115: {",
          "1116:  return ctx->flags & IORING_SETUP_SQPOLL;",
          "1117: }",
          "1123:  complete(&ctx->ref_comp);",
          "1124: }",
          "1126: static inline bool io_is_timeout_noseq(struct io_kiocb *req)",
          "1127: {",
          "1128:  return !req->timeout.off;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "509:  if (!ctx->fallback_req)",
          "510:   goto err;",
          "",
          "[Removed Lines]",
          "512:  ctx->completions = kmalloc(2 * sizeof(struct completion), GFP_KERNEL);",
          "513:  if (!ctx->completions)",
          "514:   goto err;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "533:   goto err;",
          "535:  ctx->flags = p->flags;",
          "536:  init_waitqueue_head(&ctx->cq_wait);",
          "537:  INIT_LIST_HEAD(&ctx->cq_overflow_list);",
          "540:  mutex_init(&ctx->uring_lock);",
          "541:  init_waitqueue_head(&ctx->wait);",
          "542:  spin_lock_init(&ctx->completion_lock);",
          "544:  INIT_LIST_HEAD(&ctx->defer_list);",
          "545:  INIT_LIST_HEAD(&ctx->timeout_list);",
          "546:  init_waitqueue_head(&ctx->inflight_wait);",
          "547:  spin_lock_init(&ctx->inflight_lock);",
          "548:  INIT_LIST_HEAD(&ctx->inflight_list);",
          "549:  return ctx;",
          "550: err:",
          "551:  if (ctx->fallback_req)",
          "552:   kmem_cache_free(req_cachep, ctx->fallback_req);",
          "554:  kfree(ctx->cancel_hash);",
          "555:  kfree(ctx);",
          "556:  return NULL;",
          "557: }",
          "560: {",
          "572:  return false;",
          "573: }",
          "576: {",
          "583:  }",
          "586: }",
          "589: {",
          "600:  }",
          "603: }",
          "606: {",
          "617:  }",
          "624: }",
          "628: {",
          "653:  }",
          "659: }",
          "662: {",
          "663:  struct io_ring_ctx *ctx = req->ctx;",
          "673:  } else {",
          "676:  }",
          "683: {",
          "684:  int ret;",
          "687:  if (ret != -1) {",
          "690:   io_cqring_fill_event(req, 0);",
          "692:  }",
          "693: }",
          "696: {",
          "697:  struct io_kiocb *req, *tmp;",
          "699:  spin_lock_irq(&ctx->completion_lock);",
          "702:  spin_unlock_irq(&ctx->completion_lock);",
          "703: }",
          "706: {",
          "710:   io_kill_timeout(req);",
          "712:  __io_commit_cqring(ctx);",
          "718: }",
          "720: static struct io_uring_cqe *io_get_cqring(struct io_ring_ctx *ctx)",
          "",
          "[Removed Lines]",
          "538:  init_completion(&ctx->completions[0]);",
          "539:  init_completion(&ctx->completions[1]);",
          "543:  INIT_LIST_HEAD(&ctx->poll_list);",
          "553:  kfree(ctx->completions);",
          "559: static inline bool __req_need_defer(struct io_kiocb *req)",
          "561:  struct io_ring_ctx *ctx = req->ctx;",
          "563:  return req->sequence != ctx->cached_cq_tail + ctx->cached_sq_dropped",
          "564:      + atomic_read(&ctx->cached_cq_overflow);",
          "565: }",
          "567: static inline bool req_need_defer(struct io_kiocb *req)",
          "568: {",
          "569:  if ((req->flags & (REQ_F_IO_DRAIN|REQ_F_IO_DRAINED)) == REQ_F_IO_DRAIN)",
          "570:   return __req_need_defer(req);",
          "575: static struct io_kiocb *io_get_deferred_req(struct io_ring_ctx *ctx)",
          "577:  struct io_kiocb *req;",
          "579:  req = list_first_entry_or_null(&ctx->defer_list, struct io_kiocb, list);",
          "580:  if (req && !req_need_defer(req)) {",
          "581:   list_del_init(&req->list);",
          "582:   return req;",
          "585:  return NULL;",
          "588: static struct io_kiocb *io_get_timeout_req(struct io_ring_ctx *ctx)",
          "590:  struct io_kiocb *req;",
          "592:  req = list_first_entry_or_null(&ctx->timeout_list, struct io_kiocb, list);",
          "593:  if (req) {",
          "594:   if (req->flags & REQ_F_TIMEOUT_NOSEQ)",
          "595:    return NULL;",
          "596:   if (!__req_need_defer(req)) {",
          "597:    list_del_init(&req->list);",
          "598:    return req;",
          "599:   }",
          "602:  return NULL;",
          "605: static void __io_commit_cqring(struct io_ring_ctx *ctx)",
          "607:  struct io_rings *rings = ctx->rings;",
          "609:  if (ctx->cached_cq_tail != READ_ONCE(rings->cq.tail)) {",
          "611:   smp_store_release(&rings->cq.tail, ctx->cached_cq_tail);",
          "613:   if (wq_has_sleeper(&ctx->cq_wait)) {",
          "614:    wake_up_interruptible(&ctx->cq_wait);",
          "615:    kill_fasync(&ctx->cq_fasync, SIGIO, POLL_IN);",
          "616:   }",
          "618: }",
          "620: static inline bool io_req_needs_user(struct io_kiocb *req)",
          "621: {",
          "622:  return !(req->opcode == IORING_OP_READ_FIXED ||",
          "623:    req->opcode == IORING_OP_WRITE_FIXED);",
          "626: static inline bool io_prep_async_work(struct io_kiocb *req,",
          "627:           struct io_kiocb **link)",
          "629:  bool do_hashed = false;",
          "631:  switch (req->opcode) {",
          "632:  case IORING_OP_WRITEV:",
          "633:  case IORING_OP_WRITE_FIXED:",
          "635:   if (req->flags & REQ_F_ISREG)",
          "636:    do_hashed = true;",
          "638:  case IORING_OP_READV:",
          "639:  case IORING_OP_READ_FIXED:",
          "640:  case IORING_OP_SENDMSG:",
          "641:  case IORING_OP_RECVMSG:",
          "642:  case IORING_OP_ACCEPT:",
          "643:  case IORING_OP_POLL_ADD:",
          "644:  case IORING_OP_CONNECT:",
          "650:   if (!(req->flags & REQ_F_ISREG))",
          "651:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "652:   break;",
          "654:  if (io_req_needs_user(req))",
          "655:   req->work.flags |= IO_WQ_WORK_NEEDS_USER;",
          "658:  return do_hashed;",
          "661: static inline void io_queue_async_work(struct io_kiocb *req)",
          "664:  struct io_kiocb *link;",
          "665:  bool do_hashed;",
          "667:  do_hashed = io_prep_async_work(req, &link);",
          "669:  trace_io_uring_queue_async_work(ctx, do_hashed, req, &req->work,",
          "670:      req->flags);",
          "671:  if (!do_hashed) {",
          "672:   io_wq_enqueue(ctx->io_wq, &req->work);",
          "674:   io_wq_enqueue_hashed(ctx->io_wq, &req->work,",
          "675:      file_inode(req->file));",
          "678:  if (link)",
          "679:   io_queue_linked_timeout(link);",
          "680: }",
          "682: static void io_kill_timeout(struct io_kiocb *req)",
          "686:  ret = hrtimer_try_to_cancel(&req->io->timeout.timer);",
          "688:   atomic_inc(&req->ctx->cq_timeouts);",
          "689:   list_del_init(&req->list);",
          "691:   io_put_req(req);",
          "695: static void io_kill_timeouts(struct io_ring_ctx *ctx)",
          "700:  list_for_each_entry_safe(req, tmp, &ctx->timeout_list, list)",
          "701:   io_kill_timeout(req);",
          "705: static void io_commit_cqring(struct io_ring_ctx *ctx)",
          "707:  struct io_kiocb *req;",
          "709:  while ((req = io_get_timeout_req(ctx)) != NULL)",
          "714:  while ((req = io_get_deferred_req(ctx)) != NULL) {",
          "715:   req->flags |= REQ_F_IO_DRAINED;",
          "716:   io_queue_async_work(req);",
          "717:  }",
          "",
          "[Added Lines]",
          "1164:  init_waitqueue_head(&ctx->sqo_sq_wait);",
          "1165:  INIT_LIST_HEAD(&ctx->sqd_list);",
          "1168:  init_completion(&ctx->ref_comp);",
          "1169:  init_completion(&ctx->sq_thread_comp);",
          "1170:  idr_init(&ctx->io_buffer_idr);",
          "1171:  idr_init(&ctx->personality_idr);",
          "1175:  INIT_LIST_HEAD(&ctx->iopoll_list);",
          "1181:  INIT_DELAYED_WORK(&ctx->file_put_work, io_file_put_work);",
          "1182:  init_llist_head(&ctx->file_put_llist);",
          "1192: static bool req_need_defer(struct io_kiocb *req, u32 seq)",
          "1194:  if (unlikely(req->flags & REQ_F_IO_DRAIN)) {",
          "1195:   struct io_ring_ctx *ctx = req->ctx;",
          "1197:   return seq != ctx->cached_cq_tail",
          "1198:     + READ_ONCE(ctx->cached_cq_overflow);",
          "1199:  }",
          "1204: static void __io_commit_cqring(struct io_ring_ctx *ctx)",
          "1206:  struct io_rings *rings = ctx->rings;",
          "1209:  smp_store_release(&rings->cq.tail, ctx->cached_cq_tail);",
          "1211:  if (wq_has_sleeper(&ctx->cq_wait)) {",
          "1212:   wake_up_interruptible(&ctx->cq_wait);",
          "1213:   kill_fasync(&ctx->cq_fasync, SIGIO, POLL_IN);",
          "1215: }",
          "1217: static void io_put_identity(struct io_uring_task *tctx, struct io_kiocb *req)",
          "1218: {",
          "1219:  if (req->work.identity == &tctx->__identity)",
          "1220:   return;",
          "1221:  if (refcount_dec_and_test(&req->work.identity->count))",
          "1222:   kfree(req->work.identity);",
          "1225: static void io_req_clean_work(struct io_kiocb *req)",
          "1227:  if (!(req->flags & REQ_F_WORK_INITIALIZED))",
          "1228:   return;",
          "1230:  req->flags &= ~REQ_F_WORK_INITIALIZED;",
          "1232:  if (req->work.flags & IO_WQ_WORK_MM) {",
          "1233:   mmdrop(req->work.identity->mm);",
          "1234:   req->work.flags &= ~IO_WQ_WORK_MM;",
          "1235:  }",
          "1236: #ifdef CONFIG_BLK_CGROUP",
          "1237:  if (req->work.flags & IO_WQ_WORK_BLKCG) {",
          "1238:   css_put(req->work.identity->blkcg_css);",
          "1239:   req->work.flags &= ~IO_WQ_WORK_BLKCG;",
          "1240:  }",
          "1241: #endif",
          "1242:  if (req->work.flags & IO_WQ_WORK_CREDS) {",
          "1243:   put_cred(req->work.identity->creds);",
          "1244:   req->work.flags &= ~IO_WQ_WORK_CREDS;",
          "1246:  if (req->work.flags & IO_WQ_WORK_FS) {",
          "1247:   struct fs_struct *fs = req->work.identity->fs;",
          "1249:   spin_lock(&req->work.identity->fs->lock);",
          "1250:   if (--fs->users)",
          "1251:    fs = NULL;",
          "1252:   spin_unlock(&req->work.identity->fs->lock);",
          "1253:   if (fs)",
          "1254:    free_fs_struct(fs);",
          "1255:   req->work.flags &= ~IO_WQ_WORK_FS;",
          "1256:  }",
          "1258:  io_put_identity(req->task->io_uring, req);",
          "1265: static bool io_identity_cow(struct io_kiocb *req)",
          "1267:  struct io_uring_task *tctx = current->io_uring;",
          "1268:  const struct cred *creds = NULL;",
          "1269:  struct io_identity *id;",
          "1271:  if (req->work.flags & IO_WQ_WORK_CREDS)",
          "1272:   creds = req->work.identity->creds;",
          "1274:  id = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL);",
          "1275:  if (unlikely(!id)) {",
          "1276:   req->work.flags |= IO_WQ_WORK_CANCEL;",
          "1277:   return false;",
          "1286:  io_init_identity(id);",
          "1287:  if (creds)",
          "1288:   id->creds = creds;",
          "1291:  refcount_inc(&id->count);",
          "1294:  if (tctx->identity != &tctx->__identity &&",
          "1295:      refcount_dec_and_test(&tctx->identity->count))",
          "1296:   kfree(tctx->identity);",
          "1297:  if (req->work.identity != &tctx->__identity &&",
          "1298:      refcount_dec_and_test(&req->work.identity->count))",
          "1299:   kfree(req->work.identity);",
          "1301:  req->work.identity = id;",
          "1302:  tctx->identity = id;",
          "1303:  return true;",
          "1306: static bool io_grab_identity(struct io_kiocb *req)",
          "1308:  const struct io_op_def *def = &io_op_defs[req->opcode];",
          "1309:  struct io_identity *id = req->work.identity;",
          "1310:  struct io_ring_ctx *ctx = req->ctx;",
          "1312:  if (def->work_flags & IO_WQ_WORK_FSIZE) {",
          "1313:   if (id->fsize != rlimit(RLIMIT_FSIZE))",
          "1314:    return false;",
          "1315:   req->work.flags |= IO_WQ_WORK_FSIZE;",
          "1316:  }",
          "1317: #ifdef CONFIG_BLK_CGROUP",
          "1318:  if (!(req->work.flags & IO_WQ_WORK_BLKCG) &&",
          "1319:      (def->work_flags & IO_WQ_WORK_BLKCG)) {",
          "1320:   rcu_read_lock();",
          "1321:   if (id->blkcg_css != blkcg_css()) {",
          "1322:    rcu_read_unlock();",
          "1323:    return false;",
          "1324:   }",
          "1329:   if (css_tryget_online(id->blkcg_css))",
          "1330:    req->work.flags |= IO_WQ_WORK_BLKCG;",
          "1331:   rcu_read_unlock();",
          "1332:  }",
          "1333: #endif",
          "1334:  if (!(req->work.flags & IO_WQ_WORK_CREDS)) {",
          "1335:   if (id->creds != current_cred())",
          "1336:    return false;",
          "1337:   get_cred(id->creds);",
          "1338:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "1339:  }",
          "1340: #ifdef CONFIG_AUDIT",
          "1341:  if (!uid_eq(current->loginuid, id->loginuid) ||",
          "1342:      current->sessionid != id->sessionid)",
          "1343:   return false;",
          "1344: #endif",
          "1345:  if (!(req->work.flags & IO_WQ_WORK_FS) &&",
          "1346:      (def->work_flags & IO_WQ_WORK_FS)) {",
          "1347:   if (current->fs != id->fs)",
          "1348:    return false;",
          "1349:   spin_lock(&id->fs->lock);",
          "1350:   if (!id->fs->in_exec) {",
          "1351:    id->fs->users++;",
          "1352:    req->work.flags |= IO_WQ_WORK_FS;",
          "1353:   } else {",
          "1354:    req->work.flags |= IO_WQ_WORK_CANCEL;",
          "1355:   }",
          "1356:   spin_unlock(&current->fs->lock);",
          "1357:  }",
          "1358:  if (!(req->work.flags & IO_WQ_WORK_FILES) &&",
          "1359:      (def->work_flags & IO_WQ_WORK_FILES) &&",
          "1360:      !(req->flags & REQ_F_NO_FILE_TABLE)) {",
          "1361:   if (id->files != current->files ||",
          "1362:       id->nsproxy != current->nsproxy)",
          "1363:    return false;",
          "1364:   atomic_inc(&id->files->count);",
          "1365:   get_nsproxy(id->nsproxy);",
          "1366:   req->flags |= REQ_F_INFLIGHT;",
          "1368:   spin_lock_irq(&ctx->inflight_lock);",
          "1369:   list_add(&req->inflight_entry, &ctx->inflight_list);",
          "1370:   spin_unlock_irq(&ctx->inflight_lock);",
          "1371:   req->work.flags |= IO_WQ_WORK_FILES;",
          "1374:  return true;",
          "1377: static void io_prep_async_work(struct io_kiocb *req)",
          "1379:  const struct io_op_def *def = &io_op_defs[req->opcode];",
          "1381:  struct io_identity *id;",
          "1383:  io_req_init_async(req);",
          "1384:  id = req->work.identity;",
          "1386:  if (req->flags & REQ_F_FORCE_ASYNC)",
          "1387:   req->work.flags |= IO_WQ_WORK_CONCURRENT;",
          "1389:  if (req->flags & REQ_F_ISREG) {",
          "1390:   if (def->hash_reg_file || (ctx->flags & IORING_SETUP_IOPOLL))",
          "1391:    io_wq_hash_work(&req->work, file_inode(req->file));",
          "1393:   if (def->unbound_nonreg_file)",
          "1394:    req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "1398:  if (!(req->work.flags & IO_WQ_WORK_MM) &&",
          "1399:      (def->work_flags & IO_WQ_WORK_MM)) {",
          "1400:   mmgrab(id->mm);",
          "1401:   req->work.flags |= IO_WQ_WORK_MM;",
          "1402:  }",
          "1405:  if (io_grab_identity(req))",
          "1406:   return;",
          "1408:  if (!io_identity_cow(req))",
          "1409:   return;",
          "1412:  if (!io_grab_identity(req))",
          "1413:   WARN_ON(1);",
          "1414: }",
          "1416: static void io_prep_async_link(struct io_kiocb *req)",
          "1417: {",
          "1418:  struct io_kiocb *cur;",
          "1420:  io_prep_async_work(req);",
          "1421:  if (req->flags & REQ_F_LINK_HEAD)",
          "1422:   list_for_each_entry(cur, &req->link_list, link_list)",
          "1423:    io_prep_async_work(cur);",
          "1424: }",
          "1426: static struct io_kiocb *__io_queue_async_work(struct io_kiocb *req)",
          "1427: {",
          "1428:  struct io_ring_ctx *ctx = req->ctx;",
          "1429:  struct io_kiocb *link = io_prep_linked_timeout(req);",
          "1431:  trace_io_uring_queue_async_work(ctx, io_wq_is_hashed(&req->work), req,",
          "1432:      &req->work, req->flags);",
          "1433:  io_wq_enqueue(ctx->io_wq, &req->work);",
          "1434:  return link;",
          "1435: }",
          "1437: static void io_queue_async_work(struct io_kiocb *req)",
          "1438: {",
          "1439:  struct io_kiocb *link;",
          "1442:  io_prep_async_link(req);",
          "1443:  link = __io_queue_async_work(req);",
          "1445:  if (link)",
          "1446:   io_queue_linked_timeout(link);",
          "1447: }",
          "1449: static void io_kill_timeout(struct io_kiocb *req)",
          "1451:  struct io_timeout_data *io = req->async_data;",
          "1454:  ret = hrtimer_try_to_cancel(&io->timer);",
          "1456:   atomic_set(&req->ctx->cq_timeouts,",
          "1457:    atomic_read(&req->ctx->cq_timeouts) + 1);",
          "1458:   list_del_init(&req->timeout.list);",
          "1460:   io_put_req_deferred(req, 1);",
          "1461:  }",
          "1462: }",
          "1464: static bool io_task_match(struct io_kiocb *req, struct task_struct *tsk)",
          "1465: {",
          "1466:  struct io_ring_ctx *ctx = req->ctx;",
          "1468:  if (!tsk || req->task == tsk)",
          "1469:   return true;",
          "1470:  if (ctx->flags & IORING_SETUP_SQPOLL) {",
          "1471:   if (ctx->sq_data && req->task == ctx->sq_data->thread)",
          "1472:    return true;",
          "1474:  return false;",
          "1480: static bool io_kill_timeouts(struct io_ring_ctx *ctx, struct task_struct *tsk)",
          "1483:  int canceled = 0;",
          "1486:  list_for_each_entry_safe(req, tmp, &ctx->timeout_list, timeout.list) {",
          "1487:   if (io_task_match(req, tsk)) {",
          "1488:    io_kill_timeout(req);",
          "1489:    canceled++;",
          "1490:   }",
          "1491:  }",
          "1493:  return canceled != 0;",
          "1496: static void __io_queue_deferred(struct io_ring_ctx *ctx)",
          "1498:  do {",
          "1499:   struct io_defer_entry *de = list_first_entry(&ctx->defer_list,",
          "1500:       struct io_defer_entry, list);",
          "1501:   struct io_kiocb *link;",
          "1503:   if (req_need_defer(de->req, de->seq))",
          "1504:    break;",
          "1505:   list_del_init(&de->list);",
          "1507:   link = __io_queue_async_work(de->req);",
          "1508:   if (link) {",
          "1509:    __io_queue_linked_timeout(link);",
          "1511:    io_put_req_deferred(link, 1);",
          "1512:   }",
          "1513:   kfree(de);",
          "1514:  } while (!list_empty(&ctx->defer_list));",
          "1515: }",
          "1517: static void io_flush_timeouts(struct io_ring_ctx *ctx)",
          "1518: {",
          "1519:  while (!list_empty(&ctx->timeout_list)) {",
          "1520:   struct io_kiocb *req = list_first_entry(&ctx->timeout_list,",
          "1521:       struct io_kiocb, timeout.list);",
          "1523:   if (io_is_timeout_noseq(req))",
          "1524:    break;",
          "1525:   if (req->timeout.target_seq != ctx->cached_cq_tail",
          "1526:      - atomic_read(&ctx->cq_timeouts))",
          "1527:    break;",
          "1529:   list_del_init(&req->timeout.list);",
          "1531:  }",
          "1532: }",
          "1534: static void io_commit_cqring(struct io_ring_ctx *ctx)",
          "1535: {",
          "1536:  io_flush_timeouts(ctx);",
          "1539:  if (unlikely(!list_empty(&ctx->defer_list)))",
          "1540:   __io_queue_deferred(ctx);",
          "1541: }",
          "1543: static inline bool io_sqring_full(struct io_ring_ctx *ctx)",
          "1544: {",
          "1545:  struct io_rings *r = ctx->rings;",
          "1547:  return READ_ONCE(r->sq.tail) - ctx->cached_sq_head == r->sq_ring_entries;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "735:  return &rings->cqes[tail & ctx->cq_mask];",
          "736: }",
          "738: static void io_cqring_ev_posted(struct io_ring_ctx *ctx)",
          "739: {",
          "740:  if (waitqueue_active(&ctx->wait))",
          "741:   wake_up(&ctx->wait);",
          "745:   eventfd_signal(ctx->cq_ev_fd, 1);",
          "746: }",
          "750: {",
          "751:  struct io_rings *rings = ctx->rings;",
          "752:  struct io_uring_cqe *cqe;",
          "754:  unsigned long flags;",
          "755:  LIST_HEAD(list);",
          "",
          "[Removed Lines]",
          "742:  if (waitqueue_active(&ctx->sqo_wait))",
          "743:   wake_up(&ctx->sqo_wait);",
          "744:  if (ctx->cq_ev_fd)",
          "749: static bool io_cqring_overflow_flush(struct io_ring_ctx *ctx, bool force)",
          "753:  struct io_kiocb *req;",
          "",
          "[Added Lines]",
          "1568: static inline bool io_should_trigger_evfd(struct io_ring_ctx *ctx)",
          "1569: {",
          "1570:  if (!ctx->cq_ev_fd)",
          "1571:   return false;",
          "1572:  if (READ_ONCE(ctx->rings->cq_flags) & IORING_CQ_EVENTFD_DISABLED)",
          "1573:   return false;",
          "1574:  if (!ctx->eventfd_async)",
          "1575:   return true;",
          "1576:  return io_wq_current_is_worker();",
          "1577: }",
          "1583:  if (ctx->sq_data && waitqueue_active(&ctx->sq_data->wait))",
          "1584:   wake_up(&ctx->sq_data->wait);",
          "1585:  if (io_should_trigger_evfd(ctx))",
          "1589: static void io_cqring_mark_overflow(struct io_ring_ctx *ctx)",
          "1590: {",
          "1591:  if (list_empty(&ctx->cq_overflow_list)) {",
          "1592:   clear_bit(0, &ctx->sq_check_overflow);",
          "1593:   clear_bit(0, &ctx->cq_check_overflow);",
          "1594:   ctx->rings->sq_flags &= ~IORING_SQ_CQ_OVERFLOW;",
          "1595:  }",
          "1596: }",
          "1598: static inline bool __io_match_files(struct io_kiocb *req,",
          "1599:         struct files_struct *files)",
          "1600: {",
          "1601:  return ((req->flags & REQ_F_WORK_INITIALIZED) &&",
          "1602:          (req->work.flags & IO_WQ_WORK_FILES)) &&",
          "1603:   req->work.identity->files == files;",
          "1604: }",
          "1606: static bool io_match_files(struct io_kiocb *req,",
          "1607:       struct files_struct *files)",
          "1608: {",
          "1609:  struct io_kiocb *link;",
          "1611:  if (!files)",
          "1612:   return true;",
          "1613:  if (__io_match_files(req, files))",
          "1614:   return true;",
          "1615:  if (req->flags & REQ_F_LINK_HEAD) {",
          "1616:   list_for_each_entry(link, &req->link_list, link_list) {",
          "1617:    if (__io_match_files(link, files))",
          "1618:     return true;",
          "1619:   }",
          "1620:  }",
          "1621:  return false;",
          "1622: }",
          "1625: static bool io_cqring_overflow_flush(struct io_ring_ctx *ctx, bool force,",
          "1626:          struct task_struct *tsk,",
          "1627:          struct files_struct *files)",
          "1630:  struct io_kiocb *req, *tmp;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "768:  if (force)",
          "771:  cqe = NULL;",
          "773:   cqe = io_get_cqring(ctx);",
          "774:   if (!cqe && !force)",
          "775:    break;",
          "780:   if (cqe) {",
          "781:    WRITE_ONCE(cqe->user_data, req->user_data);",
          "782:    WRITE_ONCE(cqe->res, req->result);",
          "784:   } else {",
          "785:    WRITE_ONCE(ctx->rings->cq_overflow,",
          "787:   }",
          "788:  }",
          "790:  io_commit_cqring(ctx);",
          "791:  spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "792:  io_cqring_ev_posted(ctx);",
          "794:  while (!list_empty(&list)) {",
          "797:   io_put_req(req);",
          "798:  }",
          "800:  return cqe != NULL;",
          "801: }",
          "804: {",
          "805:  struct io_ring_ctx *ctx = req->ctx;",
          "806:  struct io_uring_cqe *cqe;",
          "",
          "[Removed Lines]",
          "769:   ctx->cq_overflow_flushed = true;",
          "772:  while (!list_empty(&ctx->cq_overflow_list)) {",
          "777:   req = list_first_entry(&ctx->cq_overflow_list, struct io_kiocb,",
          "778:       list);",
          "779:   list_move(&req->list, &list);",
          "783:    WRITE_ONCE(cqe->flags, 0);",
          "786:     atomic_inc_return(&ctx->cached_cq_overflow));",
          "795:   req = list_first_entry(&list, struct io_kiocb, list);",
          "796:   list_del(&req->list);",
          "803: static void io_cqring_fill_event(struct io_kiocb *req, long res)",
          "",
          "[Added Lines]",
          "1647:   ctx->cq_overflow_flushed = 1;",
          "1650:  list_for_each_entry_safe(req, tmp, &ctx->cq_overflow_list, compl.list) {",
          "1651:   if (tsk && req->task != tsk)",
          "1652:    continue;",
          "1653:   if (!io_match_files(req, files))",
          "1654:    continue;",
          "1660:   list_move(&req->compl.list, &list);",
          "1664:    WRITE_ONCE(cqe->flags, req->compl.cflags);",
          "1666:    ctx->cached_cq_overflow++;",
          "1668:        ctx->cached_cq_overflow);",
          "1673:  io_cqring_mark_overflow(ctx);",
          "1679:   req = list_first_entry(&list, struct io_kiocb, compl.list);",
          "1680:   list_del(&req->compl.list);",
          "1687: static void __io_cqring_fill_event(struct io_kiocb *req, long res, long cflags)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "816:  if (likely(cqe)) {",
          "817:   WRITE_ONCE(cqe->user_data, req->user_data);",
          "818:   WRITE_ONCE(cqe->res, res);",
          "823:  } else {",
          "825:   req->result = res;",
          "827:  }",
          "828: }",
          "831: {",
          "832:  struct io_ring_ctx *ctx = req->ctx;",
          "833:  unsigned long flags;",
          "835:  spin_lock_irqsave(&ctx->completion_lock, flags);",
          "837:  io_commit_cqring(ctx);",
          "838:  spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "840:  io_cqring_ev_posted(ctx);",
          "841: }",
          "843: static inline bool io_is_fallback_req(struct io_kiocb *req)",
          "844: {",
          "845:  return req == (struct io_kiocb *)",
          "",
          "[Removed Lines]",
          "819:   WRITE_ONCE(cqe->flags, 0);",
          "820:  } else if (ctx->cq_overflow_flushed) {",
          "821:   WRITE_ONCE(ctx->rings->cq_overflow,",
          "822:     atomic_inc_return(&ctx->cached_cq_overflow));",
          "824:   refcount_inc(&req->refs);",
          "826:   list_add_tail(&req->list, &ctx->cq_overflow_list);",
          "830: static void io_cqring_add_event(struct io_kiocb *req, long res)",
          "836:  io_cqring_fill_event(req, res);",
          "",
          "[Added Lines]",
          "1703:   WRITE_ONCE(cqe->flags, cflags);",
          "1704:  } else if (ctx->cq_overflow_flushed ||",
          "1705:      atomic_read(&req->task->io_uring->in_idle)) {",
          "1711:   ctx->cached_cq_overflow++;",
          "1712:   WRITE_ONCE(ctx->rings->cq_overflow, ctx->cached_cq_overflow);",
          "1714:   if (list_empty(&ctx->cq_overflow_list)) {",
          "1715:    set_bit(0, &ctx->sq_check_overflow);",
          "1716:    set_bit(0, &ctx->cq_check_overflow);",
          "1717:    ctx->rings->sq_flags |= IORING_SQ_CQ_OVERFLOW;",
          "1718:   }",
          "1719:   io_clean_op(req);",
          "1721:   req->compl.cflags = cflags;",
          "1722:   refcount_inc(&req->refs);",
          "1723:   list_add_tail(&req->compl.list, &ctx->cq_overflow_list);",
          "1727: static void io_cqring_fill_event(struct io_kiocb *req, long res)",
          "1728: {",
          "1729:  __io_cqring_fill_event(req, res, 0);",
          "1730: }",
          "1732: static void io_cqring_add_event(struct io_kiocb *req, long res, long cflags)",
          "1738:  __io_cqring_fill_event(req, res, cflags);",
          "1745: static void io_submit_flush_completions(struct io_comp_state *cs)",
          "1746: {",
          "1747:  struct io_ring_ctx *ctx = cs->ctx;",
          "1749:  spin_lock_irq(&ctx->completion_lock);",
          "1750:  while (!list_empty(&cs->list)) {",
          "1751:   struct io_kiocb *req;",
          "1753:   req = list_first_entry(&cs->list, struct io_kiocb, compl.list);",
          "1754:   list_del(&req->compl.list);",
          "1755:   __io_cqring_fill_event(req, req->result, req->compl.cflags);",
          "1762:   if (req->flags & (REQ_F_FAIL_LINK|REQ_F_LINK_TIMEOUT",
          "1763:      |REQ_F_WORK_INITIALIZED)) {",
          "1764:    spin_unlock_irq(&ctx->completion_lock);",
          "1765:    io_put_req(req);",
          "1766:    spin_lock_irq(&ctx->completion_lock);",
          "1767:   } else {",
          "1768:    io_put_req(req);",
          "1769:   }",
          "1770:  }",
          "1771:  io_commit_cqring(ctx);",
          "1772:  spin_unlock_irq(&ctx->completion_lock);",
          "1774:  io_cqring_ev_posted(ctx);",
          "1775:  cs->nr = 0;",
          "1776: }",
          "1778: static void __io_req_complete(struct io_kiocb *req, long res, unsigned cflags,",
          "1779:          struct io_comp_state *cs)",
          "1780: {",
          "1781:  if (!cs) {",
          "1782:   io_cqring_add_event(req, res, cflags);",
          "1783:   io_put_req(req);",
          "1784:  } else {",
          "1785:   io_clean_op(req);",
          "1786:   req->result = res;",
          "1787:   req->compl.cflags = cflags;",
          "1788:   list_add_tail(&req->compl.list, &cs->list);",
          "1789:   if (++cs->nr >= 32)",
          "1790:    io_submit_flush_completions(cs);",
          "1791:  }",
          "1792: }",
          "1794: static void io_req_complete(struct io_kiocb *req, long res)",
          "1795: {",
          "1796:  __io_req_complete(req, res, 0, NULL);",
          "1797: }",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "851:  struct io_kiocb *req;",
          "853:  req = ctx->fallback_req;",
          "855:   return req;",
          "857:  return NULL;",
          "858: }",
          "862: {",
          "874:   size_t sz;",
          "875:   int ret;",
          "",
          "[Removed Lines]",
          "854:  if (!test_and_set_bit_lock(0, (unsigned long *) ctx->fallback_req))",
          "860: static struct io_kiocb *io_get_req(struct io_ring_ctx *ctx,",
          "861:        struct io_submit_state *state)",
          "863:  gfp_t gfp = GFP_KERNEL | __GFP_NOWARN;",
          "864:  struct io_kiocb *req;",
          "866:  if (!percpu_ref_tryget(&ctx->refs))",
          "867:   return NULL;",
          "869:  if (!state) {",
          "870:   req = kmem_cache_alloc(req_cachep, gfp);",
          "871:   if (unlikely(!req))",
          "872:    goto fallback;",
          "873:  } else if (!state->free_reqs) {",
          "",
          "[Added Lines]",
          "1810:  if (!test_and_set_bit_lock(0, (unsigned long *) &ctx->fallback_req))",
          "1816: static struct io_kiocb *io_alloc_req(struct io_ring_ctx *ctx,",
          "1817:          struct io_submit_state *state)",
          "1819:  if (!state->free_reqs) {",
          "1820:   gfp_t gfp = GFP_KERNEL | __GFP_NOWARN;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "887:     goto fallback;",
          "888:    ret = 1;",
          "889:   }",
          "897:  }",
          "910: fallback:",
          "916: }",
          "919: {",
          "925: }",
          "927: static void __io_free_req(struct io_kiocb *req)",
          "928: {",
          "929:  struct io_ring_ctx *ctx = req->ctx;",
          "945:  if (likely(!io_is_fallback_req(req)))",
          "946:   kmem_cache_free(req_cachep, req);",
          "947:  else",
          "949: }",
          "952: {",
          "953:  struct io_ring_ctx *ctx = req->ctx;",
          "963:  }",
          "966: }",
          "969: {",
          "1004: }",
          "1009: static void io_fail_links(struct io_kiocb *req)",
          "1010: {",
          "",
          "[Removed Lines]",
          "890:   state->free_reqs = ret - 1;",
          "891:   state->cur_req = 1;",
          "892:   req = state->reqs[0];",
          "893:  } else {",
          "894:   req = state->reqs[state->cur_req];",
          "895:   state->free_reqs--;",
          "896:   state->cur_req++;",
          "899: got_it:",
          "900:  req->io = NULL;",
          "901:  req->ring_file = NULL;",
          "902:  req->file = NULL;",
          "903:  req->ctx = ctx;",
          "904:  req->flags = 0;",
          "906:  refcount_set(&req->refs, 2);",
          "907:  req->result = 0;",
          "908:  INIT_IO_WORK(&req->work, io_wq_submit_work);",
          "909:  return req;",
          "911:  req = io_get_fallback_req(ctx);",
          "912:  if (req)",
          "913:   goto got_it;",
          "914:  percpu_ref_put(&ctx->refs);",
          "915:  return NULL;",
          "918: static void io_free_req_many(struct io_ring_ctx *ctx, void **reqs, int *nr)",
          "920:  if (*nr) {",
          "921:   kmem_cache_free_bulk(req_cachep, *nr, reqs);",
          "922:   percpu_ref_put_many(&ctx->refs, *nr);",
          "924:  }",
          "931:  if (req->io)",
          "932:   kfree(req->io);",
          "933:  if (req->file && !(req->flags & REQ_F_FIXED_FILE))",
          "934:   fput(req->file);",
          "935:  if (req->flags & REQ_F_INFLIGHT) {",
          "936:   unsigned long flags;",
          "938:   spin_lock_irqsave(&ctx->inflight_lock, flags);",
          "939:   list_del(&req->inflight_entry);",
          "940:   if (waitqueue_active(&ctx->inflight_wait))",
          "941:    wake_up(&ctx->inflight_wait);",
          "942:   spin_unlock_irqrestore(&ctx->inflight_lock, flags);",
          "943:  }",
          "944:  percpu_ref_put(&ctx->refs);",
          "948:   clear_bit_unlock(0, (unsigned long *) ctx->fallback_req);",
          "951: static bool io_link_cancel_timeout(struct io_kiocb *req)",
          "954:  int ret;",
          "956:  ret = hrtimer_try_to_cancel(&req->io->timeout.timer);",
          "957:  if (ret != -1) {",
          "958:   io_cqring_fill_event(req, -ECANCELED);",
          "959:   io_commit_cqring(ctx);",
          "960:   req->flags &= ~REQ_F_LINK;",
          "961:   io_put_req(req);",
          "962:   return true;",
          "965:  return false;",
          "968: static void io_req_link_next(struct io_kiocb *req, struct io_kiocb **nxtptr)",
          "970:  struct io_ring_ctx *ctx = req->ctx;",
          "971:  bool wake_ev = false;",
          "974:  if (req->flags & REQ_F_LINK_NEXT)",
          "975:   return;",
          "982:  while (!list_empty(&req->link_list)) {",
          "983:   struct io_kiocb *nxt = list_first_entry(&req->link_list,",
          "984:       struct io_kiocb, link_list);",
          "986:   if (unlikely((req->flags & REQ_F_LINK_TIMEOUT) &&",
          "987:         (nxt->flags & REQ_F_TIMEOUT))) {",
          "988:    list_del_init(&nxt->link_list);",
          "989:    wake_ev |= io_link_cancel_timeout(nxt);",
          "990:    req->flags &= ~REQ_F_LINK_TIMEOUT;",
          "991:    continue;",
          "992:   }",
          "994:   list_del_init(&req->link_list);",
          "995:   if (!list_empty(&nxt->link_list))",
          "996:    nxt->flags |= REQ_F_LINK;",
          "998:   break;",
          "999:  }",
          "1001:  req->flags |= REQ_F_LINK_NEXT;",
          "1002:  if (wake_ev)",
          "1003:   io_cqring_ev_posted(ctx);",
          "",
          "[Added Lines]",
          "1837:   state->free_reqs = ret;",
          "1840:  state->free_reqs--;",
          "1841:  return state->reqs[state->free_reqs];",
          "1843:  return io_get_fallback_req(ctx);",
          "1846: static inline void io_put_file(struct io_kiocb *req, struct file *file,",
          "1847:      bool fixed)",
          "1849:  if (fixed)",
          "1850:   percpu_ref_put(req->fixed_file_refs);",
          "1851:  else",
          "1852:   fput(file);",
          "1853: }",
          "1855: static void io_dismantle_req(struct io_kiocb *req)",
          "1856: {",
          "1857:  io_clean_op(req);",
          "1859:  if (req->async_data)",
          "1860:   kfree(req->async_data);",
          "1861:  if (req->file)",
          "1862:   io_put_file(req, req->file, (req->flags & REQ_F_FIXED_FILE));",
          "1864:  io_req_clean_work(req);",
          "1869:  struct io_uring_task *tctx = req->task->io_uring;",
          "1872:  io_dismantle_req(req);",
          "1874:  percpu_counter_dec(&tctx->inflight);",
          "1875:  if (atomic_read(&tctx->in_idle))",
          "1876:   wake_up(&tctx->wait);",
          "1877:  put_task_struct(req->task);",
          "1882:   clear_bit_unlock(0, (unsigned long *) &ctx->fallback_req);",
          "1883:  percpu_ref_put(&ctx->refs);",
          "1886: static void io_kill_linked_timeout(struct io_kiocb *req)",
          "1889:  struct io_kiocb *link;",
          "1890:  bool cancelled = false;",
          "1891:  unsigned long flags;",
          "1893:  spin_lock_irqsave(&ctx->completion_lock, flags);",
          "1894:  link = list_first_entry_or_null(&req->link_list, struct io_kiocb,",
          "1895:      link_list);",
          "1900:  if (link && (link->flags & REQ_F_LTIMEOUT_ACTIVE)) {",
          "1901:   struct io_timeout_data *io = link->async_data;",
          "1902:   int ret;",
          "1904:   list_del_init(&link->link_list);",
          "1905:   ret = hrtimer_try_to_cancel(&io->timer);",
          "1906:   if (ret != -1) {",
          "1907:    io_cqring_fill_event(link, -ECANCELED);",
          "1908:    io_commit_cqring(ctx);",
          "1909:    cancelled = true;",
          "1910:   }",
          "1912:  req->flags &= ~REQ_F_LINK_TIMEOUT;",
          "1913:  spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "1915:  if (cancelled) {",
          "1916:   io_cqring_ev_posted(ctx);",
          "1917:   io_put_req(link);",
          "1918:  }",
          "1921: static struct io_kiocb *io_req_link_next(struct io_kiocb *req)",
          "1923:  struct io_kiocb *nxt;",
          "1930:  if (unlikely(list_empty(&req->link_list)))",
          "1931:   return NULL;",
          "1933:  nxt = list_first_entry(&req->link_list, struct io_kiocb, link_list);",
          "1934:  list_del_init(&req->link_list);",
          "1935:  if (!list_empty(&nxt->link_list))",
          "1936:   nxt->flags |= REQ_F_LINK_HEAD;",
          "1937:  return nxt;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1020:   list_del_init(&link->link_list);",
          "1021:   trace_io_uring_fail_link(req, link);",
          "1031:  }",
          "1033:  io_commit_cqring(ctx);",
          "1034:  spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "1035:  io_cqring_ev_posted(ctx);",
          "1036: }",
          "1039: {",
          "",
          "[Removed Lines]",
          "1023:   if ((req->flags & REQ_F_LINK_TIMEOUT) &&",
          "1024:       link->opcode == IORING_OP_LINK_TIMEOUT) {",
          "1025:    io_link_cancel_timeout(link);",
          "1026:   } else {",
          "1027:    io_cqring_fill_event(link, -ECANCELED);",
          "1028:    __io_double_put_req(link);",
          "1029:   }",
          "1030:   req->flags &= ~REQ_F_LINK_TIMEOUT;",
          "1038: static void io_req_find_next(struct io_kiocb *req, struct io_kiocb **nxt)",
          "1040:  if (likely(!(req->flags & REQ_F_LINK)))",
          "1041:   return;",
          "",
          "[Added Lines]",
          "1956:   io_cqring_fill_event(link, -ECANCELED);",
          "1963:   if (link->flags & REQ_F_WORK_INITIALIZED)",
          "1964:    io_put_req_deferred(link, 2);",
          "1965:   else",
          "1966:    io_double_put_req(link);",
          "1975: static struct io_kiocb *__io_req_find_next(struct io_kiocb *req)",
          "1977:  req->flags &= ~REQ_F_LINK_HEAD;",
          "1978:  if (req->flags & REQ_F_LINK_TIMEOUT)",
          "1979:   io_kill_linked_timeout(req);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1067: }",
          "1070: {",
          "1091: }",
          "1094: {",
          "1097: }",
          "1104: {",
          "1108: }",
          "1111: {",
          "1115: }",
          "1118: {",
          "1132:  smp_rmb();",
          "1134: }",
          "1136: static inline unsigned int io_sqring_entries(struct io_ring_ctx *ctx)",
          "",
          "[Removed Lines]",
          "1049:  if (req->flags & REQ_F_FAIL_LINK) {",
          "1050:   io_fail_links(req);",
          "1051:  } else if ((req->flags & (REQ_F_LINK_TIMEOUT | REQ_F_COMP_LOCKED)) ==",
          "1052:    REQ_F_LINK_TIMEOUT) {",
          "1053:   struct io_ring_ctx *ctx = req->ctx;",
          "1054:   unsigned long flags;",
          "1061:   spin_lock_irqsave(&ctx->completion_lock, flags);",
          "1062:   io_req_link_next(req, nxt);",
          "1063:   spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "1064:  } else {",
          "1065:   io_req_link_next(req, nxt);",
          "1066:  }",
          "1069: static void io_free_req(struct io_kiocb *req)",
          "1071:  struct io_kiocb *nxt = NULL;",
          "1073:  io_req_find_next(req, &nxt);",
          "1074:  __io_free_req(req);",
          "1076:  if (nxt)",
          "1077:   io_queue_async_work(nxt);",
          "1078: }",
          "1084: __attribute__((nonnull))",
          "1085: static void io_put_req_find_next(struct io_kiocb *req, struct io_kiocb **nxtptr)",
          "1086: {",
          "1087:  io_req_find_next(req, nxtptr);",
          "1089:  if (refcount_dec_and_test(&req->refs))",
          "1090:   __io_free_req(req);",
          "1093: static void io_put_req(struct io_kiocb *req)",
          "1095:  if (refcount_dec_and_test(&req->refs))",
          "1096:   io_free_req(req);",
          "1103: static void __io_double_put_req(struct io_kiocb *req)",
          "1106:  if (refcount_sub_and_test(2, &req->refs))",
          "1107:   __io_free_req(req);",
          "1110: static void io_double_put_req(struct io_kiocb *req)",
          "1113:  if (refcount_sub_and_test(2, &req->refs))",
          "1114:   io_free_req(req);",
          "1117: static unsigned io_cqring_events(struct io_ring_ctx *ctx, bool noflush)",
          "1119:  struct io_rings *rings = ctx->rings;",
          "1126:  if (noflush && !list_empty(&ctx->cq_overflow_list))",
          "1127:   return -1U;",
          "1129:  io_cqring_overflow_flush(ctx, false);",
          "1133:  return READ_ONCE(rings->cq.tail) - READ_ONCE(rings->cq.head);",
          "",
          "[Added Lines]",
          "1987:  if (likely(!(req->flags & REQ_F_FAIL_LINK)))",
          "1988:   return io_req_link_next(req);",
          "1989:  io_fail_links(req);",
          "1990:  return NULL;",
          "1991: }",
          "1993: static struct io_kiocb *io_req_find_next(struct io_kiocb *req)",
          "1994: {",
          "1995:  if (likely(!(req->flags & REQ_F_LINK_HEAD)))",
          "1996:   return NULL;",
          "1997:  return __io_req_find_next(req);",
          "2000: static int io_req_task_work_add(struct io_kiocb *req, bool twa_signal_ok)",
          "2002:  struct task_struct *tsk = req->task;",
          "2003:  struct io_ring_ctx *ctx = req->ctx;",
          "2004:  enum task_work_notify_mode notify;",
          "2005:  int ret;",
          "2007:  if (tsk->flags & PF_EXITING)",
          "2008:   return -ESRCH;",
          "2016:  notify = TWA_NONE;",
          "2017:  if (!(ctx->flags & IORING_SETUP_SQPOLL) && twa_signal_ok)",
          "2018:   notify = TWA_SIGNAL;",
          "2020:  ret = task_work_add(tsk, &req->task_work, notify);",
          "2021:  if (!ret)",
          "2022:   wake_up_process(tsk);",
          "2024:  return ret;",
          "2027: static void __io_req_task_cancel(struct io_kiocb *req, int error)",
          "2029:  struct io_ring_ctx *ctx = req->ctx;",
          "2031:  spin_lock_irq(&ctx->completion_lock);",
          "2032:  io_cqring_fill_event(req, error);",
          "2033:  io_commit_cqring(ctx);",
          "2034:  spin_unlock_irq(&ctx->completion_lock);",
          "2036:  io_cqring_ev_posted(ctx);",
          "2037:  req_set_fail_links(req);",
          "2038:  io_double_put_req(req);",
          "2041: static void io_req_task_cancel(struct callback_head *cb)",
          "2043:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "2044:  struct io_ring_ctx *ctx = req->ctx;",
          "2046:  __io_req_task_cancel(req, -ECANCELED);",
          "2047:  percpu_ref_put(&ctx->refs);",
          "2050: static void __io_req_task_submit(struct io_kiocb *req)",
          "2052:  struct io_ring_ctx *ctx = req->ctx;",
          "2054:  if (!__io_sq_thread_acquire_mm(ctx)) {",
          "2055:   mutex_lock(&ctx->uring_lock);",
          "2056:   __io_queue_sqe(req, NULL);",
          "2057:   mutex_unlock(&ctx->uring_lock);",
          "2058:  } else {",
          "2059:   __io_req_task_cancel(req, -EFAULT);",
          "2060:  }",
          "2063: static void io_req_task_submit(struct callback_head *cb)",
          "2065:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "2066:  struct io_ring_ctx *ctx = req->ctx;",
          "2068:  __io_req_task_submit(req);",
          "2069:  percpu_ref_put(&ctx->refs);",
          "2070: }",
          "2072: static void io_req_task_queue(struct io_kiocb *req)",
          "2073: {",
          "2074:  int ret;",
          "2076:  init_task_work(&req->task_work, io_req_task_submit);",
          "2077:  percpu_ref_get(&req->ctx->refs);",
          "2079:  ret = io_req_task_work_add(req, true);",
          "2080:  if (unlikely(ret)) {",
          "2081:   struct task_struct *tsk;",
          "2083:   init_task_work(&req->task_work, io_req_task_cancel);",
          "2084:   tsk = io_wq_get_task(req->ctx->io_wq);",
          "2085:   task_work_add(tsk, &req->task_work, TWA_NONE);",
          "2086:   wake_up_process(tsk);",
          "2087:  }",
          "2088: }",
          "2090: static void io_queue_next(struct io_kiocb *req)",
          "2091: {",
          "2092:  struct io_kiocb *nxt = io_req_find_next(req);",
          "2094:  if (nxt)",
          "2095:   io_req_task_queue(nxt);",
          "2096: }",
          "2098: static void io_free_req(struct io_kiocb *req)",
          "2099: {",
          "2100:  io_queue_next(req);",
          "2101:  __io_free_req(req);",
          "2102: }",
          "2104: struct req_batch {",
          "2105:  void *reqs[IO_IOPOLL_BATCH];",
          "2106:  int to_free;",
          "2108:  struct task_struct *task;",
          "2109:  int   task_refs;",
          "2110: };",
          "2112: static inline void io_init_req_batch(struct req_batch *rb)",
          "2113: {",
          "2114:  rb->to_free = 0;",
          "2115:  rb->task_refs = 0;",
          "2116:  rb->task = NULL;",
          "2117: }",
          "2119: static void __io_req_free_batch_flush(struct io_ring_ctx *ctx,",
          "2120:           struct req_batch *rb)",
          "2121: {",
          "2122:  kmem_cache_free_bulk(req_cachep, rb->to_free, rb->reqs);",
          "2123:  percpu_ref_put_many(&ctx->refs, rb->to_free);",
          "2124:  rb->to_free = 0;",
          "2125: }",
          "2127: static void io_req_free_batch_finish(struct io_ring_ctx *ctx,",
          "2128:          struct req_batch *rb)",
          "2129: {",
          "2130:  if (rb->to_free)",
          "2131:   __io_req_free_batch_flush(ctx, rb);",
          "2132:  if (rb->task) {",
          "2133:   struct io_uring_task *tctx = rb->task->io_uring;",
          "2135:   percpu_counter_sub(&tctx->inflight, rb->task_refs);",
          "2136:   put_task_struct_many(rb->task, rb->task_refs);",
          "2137:   rb->task = NULL;",
          "2138:  }",
          "2139: }",
          "2141: static void io_req_free_batch(struct req_batch *rb, struct io_kiocb *req)",
          "2142: {",
          "2143:  if (unlikely(io_is_fallback_req(req))) {",
          "2144:   io_free_req(req);",
          "2145:   return;",
          "2146:  }",
          "2147:  if (req->flags & REQ_F_LINK_HEAD)",
          "2148:   io_queue_next(req);",
          "2150:  if (req->task != rb->task) {",
          "2151:   if (rb->task) {",
          "2152:    struct io_uring_task *tctx = rb->task->io_uring;",
          "2154:    percpu_counter_sub(&tctx->inflight, rb->task_refs);",
          "2155:    put_task_struct_many(rb->task, rb->task_refs);",
          "2156:   }",
          "2157:   rb->task = req->task;",
          "2158:   rb->task_refs = 0;",
          "2159:  }",
          "2160:  rb->task_refs++;",
          "2162:  io_dismantle_req(req);",
          "2163:  rb->reqs[rb->to_free++] = req;",
          "2164:  if (unlikely(rb->to_free == ARRAY_SIZE(rb->reqs)))",
          "2165:   __io_req_free_batch_flush(req->ctx, rb);",
          "2166: }",
          "2172: static struct io_kiocb *io_put_req_find_next(struct io_kiocb *req)",
          "2173: {",
          "2174:  struct io_kiocb *nxt = NULL;",
          "2176:  if (refcount_dec_and_test(&req->refs)) {",
          "2177:   nxt = io_req_find_next(req);",
          "2178:   __io_free_req(req);",
          "2179:  }",
          "2180:  return nxt;",
          "2181: }",
          "2183: static void io_put_req(struct io_kiocb *req)",
          "2184: {",
          "2185:  if (refcount_dec_and_test(&req->refs))",
          "2186:   io_free_req(req);",
          "2187: }",
          "2189: static void io_put_req_deferred_cb(struct callback_head *cb)",
          "2190: {",
          "2191:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "2193:  io_free_req(req);",
          "2194: }",
          "2196: static void io_free_req_deferred(struct io_kiocb *req)",
          "2197: {",
          "2198:  int ret;",
          "2200:  init_task_work(&req->task_work, io_put_req_deferred_cb);",
          "2201:  ret = io_req_task_work_add(req, true);",
          "2202:  if (unlikely(ret)) {",
          "2203:   struct task_struct *tsk;",
          "2205:   tsk = io_wq_get_task(req->ctx->io_wq);",
          "2206:   task_work_add(tsk, &req->task_work, TWA_NONE);",
          "2207:   wake_up_process(tsk);",
          "2208:  }",
          "2209: }",
          "2211: static inline void io_put_req_deferred(struct io_kiocb *req, int refs)",
          "2212: {",
          "2213:  if (refcount_sub_and_test(refs, &req->refs))",
          "2214:   io_free_req_deferred(req);",
          "2215: }",
          "2217: static struct io_wq_work *io_steal_work(struct io_kiocb *req)",
          "2218: {",
          "2219:  struct io_kiocb *nxt;",
          "2226:  if (refcount_read(&req->refs) != 1)",
          "2227:   return NULL;",
          "2229:  nxt = io_req_find_next(req);",
          "2230:  return nxt ? &nxt->work : NULL;",
          "2231: }",
          "2233: static void io_double_put_req(struct io_kiocb *req)",
          "2234: {",
          "2236:  if (refcount_sub_and_test(2, &req->refs))",
          "2237:   io_free_req(req);",
          "2238: }",
          "2240: static unsigned io_cqring_events(struct io_ring_ctx *ctx, bool noflush)",
          "2241: {",
          "2242:  struct io_rings *rings = ctx->rings;",
          "2244:  if (test_bit(0, &ctx->cq_check_overflow)) {",
          "2250:   if (noflush && !list_empty(&ctx->cq_overflow_list))",
          "2251:    return -1U;",
          "2253:   io_cqring_overflow_flush(ctx, false, NULL, NULL);",
          "2254:  }",
          "2258:  return ctx->cached_cq_tail - READ_ONCE(rings->cq.head);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1141:  return smp_load_acquire(&rings->sq.tail) - ctx->cached_sq_head;",
          "1142: }",
          "1147: static void io_iopoll_complete(struct io_ring_ctx *ctx, unsigned int *nr_events,",
          "1148:           struct list_head *done)",
          "1149: {",
          "1151:  struct io_kiocb *req;",
          "1155:  while (!list_empty(done)) {",
          "1160:   (*nr_events)++;",
          "1178:  }",
          "1180:  io_commit_cqring(ctx);",
          "1182: }",
          "1184: static int io_do_iopoll(struct io_ring_ctx *ctx, unsigned int *nr_events,",
          "",
          "[Removed Lines]",
          "1150:  void *reqs[IO_IOPOLL_BATCH];",
          "1152:  int to_free;",
          "1154:  to_free = 0;",
          "1156:   req = list_first_entry(done, struct io_kiocb, list);",
          "1157:   list_del(&req->list);",
          "1159:   io_cqring_fill_event(req, req->result);",
          "1162:   if (refcount_dec_and_test(&req->refs)) {",
          "1168:    if (((req->flags & (REQ_F_FIXED_FILE|REQ_F_LINK)) ==",
          "1169:        REQ_F_FIXED_FILE) && !io_is_fallback_req(req) &&",
          "1170:        !req->io) {",
          "1171:     reqs[to_free++] = req;",
          "1172:     if (to_free == ARRAY_SIZE(reqs))",
          "1173:      io_free_req_many(ctx, reqs, &to_free);",
          "1174:    } else {",
          "1175:     io_free_req(req);",
          "1176:    }",
          "1177:   }",
          "1181:  io_free_req_many(ctx, reqs, &to_free);",
          "",
          "[Added Lines]",
          "2269: static unsigned int io_put_kbuf(struct io_kiocb *req, struct io_buffer *kbuf)",
          "2270: {",
          "2271:  unsigned int cflags;",
          "2273:  cflags = kbuf->bid << IORING_CQE_BUFFER_SHIFT;",
          "2274:  cflags |= IORING_CQE_F_BUFFER;",
          "2275:  req->flags &= ~REQ_F_BUFFER_SELECTED;",
          "2276:  kfree(kbuf);",
          "2277:  return cflags;",
          "2278: }",
          "2280: static inline unsigned int io_put_rw_kbuf(struct io_kiocb *req)",
          "2281: {",
          "2282:  struct io_buffer *kbuf;",
          "2284:  kbuf = (struct io_buffer *) (unsigned long) req->rw.addr;",
          "2285:  return io_put_kbuf(req, kbuf);",
          "2286: }",
          "2288: static inline bool io_run_task_work(void)",
          "2289: {",
          "2294:  if (unlikely(current->flags & PF_EXITING))",
          "2295:   return false;",
          "2296:  if (current->task_works) {",
          "2297:   __set_current_state(TASK_RUNNING);",
          "2298:   task_work_run();",
          "2299:   return true;",
          "2300:  }",
          "2302:  return false;",
          "2303: }",
          "2305: static void io_iopoll_queue(struct list_head *again)",
          "2306: {",
          "2307:  struct io_kiocb *req;",
          "2309:  do {",
          "2310:   req = list_first_entry(again, struct io_kiocb, inflight_entry);",
          "2311:   list_del(&req->inflight_entry);",
          "2312:   __io_complete_rw(req, -EAGAIN, 0, NULL);",
          "2313:  } while (!list_empty(again));",
          "2314: }",
          "2322:  struct req_batch rb;",
          "2324:  LIST_HEAD(again);",
          "2327:  smp_rmb();",
          "2329:  io_init_req_batch(&rb);",
          "2331:   int cflags = 0;",
          "2333:   req = list_first_entry(done, struct io_kiocb, inflight_entry);",
          "2334:   if (READ_ONCE(req->result) == -EAGAIN) {",
          "2335:    req->result = 0;",
          "2336:    req->iopoll_completed = 0;",
          "2337:    list_move_tail(&req->inflight_entry, &again);",
          "2338:    continue;",
          "2339:   }",
          "2340:   list_del(&req->inflight_entry);",
          "2342:   if (req->flags & REQ_F_BUFFER_SELECTED)",
          "2343:    cflags = io_put_rw_kbuf(req);",
          "2345:   __io_cqring_fill_event(req, req->result, cflags);",
          "2348:   if (refcount_dec_and_test(&req->refs))",
          "2349:    io_req_free_batch(&rb, req);",
          "2353:  if (ctx->flags & IORING_SETUP_SQPOLL)",
          "2354:   io_cqring_ev_posted(ctx);",
          "2355:  io_req_free_batch_finish(ctx, &rb);",
          "2357:  if (!list_empty(&again))",
          "2358:   io_iopoll_queue(&again);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1196:  spin = !ctx->poll_multi_file && *nr_events < min;",
          "1198:  ret = 0;",
          "1200:   struct kiocb *kiocb = &req->rw.kiocb;",
          "1209:    continue;",
          "1210:   }",
          "1211:   if (!list_empty(&done))",
          "",
          "[Removed Lines]",
          "1199:  list_for_each_entry_safe(req, tmp, &ctx->poll_list, list) {",
          "1207:   if (req->flags & REQ_F_IOPOLL_COMPLETED) {",
          "1208:    list_move_tail(&req->list, &done);",
          "",
          "[Added Lines]",
          "2376:  list_for_each_entry_safe(req, tmp, &ctx->iopoll_list, inflight_entry) {",
          "2384:   if (READ_ONCE(req->iopoll_completed)) {",
          "2385:    list_move_tail(&req->inflight_entry, &done);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1215:   if (ret < 0)",
          "1216:    break;",
          "1218:   if (ret && spin)",
          "1219:    spin = false;",
          "1220:   ret = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2396:   if (READ_ONCE(req->iopoll_completed))",
          "2397:    list_move_tail(&req->inflight_entry, &done);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1234: static int io_iopoll_getevents(struct io_ring_ctx *ctx, unsigned int *nr_events,",
          "1235:     long min)",
          "1236: {",
          "1238:   int ret;",
          "1240:   ret = io_do_iopoll(ctx, nr_events, min);",
          "1241:   if (ret < 0)",
          "1242:    return ret;",
          "1244:    return 0;",
          "1245:  }",
          "",
          "[Removed Lines]",
          "1237:  while (!list_empty(&ctx->poll_list) && !need_resched()) {",
          "1243:   if (!min || *nr_events >= min)",
          "",
          "[Added Lines]",
          "2418:  while (!list_empty(&ctx->iopoll_list) && !need_resched()) {",
          "2424:   if (*nr_events >= min)",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1255: {",
          "1256:  if (!(ctx->flags & IORING_SETUP_IOPOLL))",
          "1257:   return;",
          "1259:  mutex_lock(&ctx->uring_lock);",
          "1261:   unsigned int nr_events = 0;",
          "1270:  }",
          "1271:  mutex_unlock(&ctx->uring_lock);",
          "1272: }",
          "1276: {",
          "1277:  int iters = 0, ret = 0;",
          "1279:  do {",
          "",
          "[Removed Lines]",
          "1254: static void io_iopoll_reap_events(struct io_ring_ctx *ctx)",
          "1260:  while (!list_empty(&ctx->poll_list)) {",
          "1263:   io_iopoll_getevents(ctx, &nr_events, 1);",
          "1269:   cond_resched();",
          "1274: static int __io_iopoll_check(struct io_ring_ctx *ctx, unsigned *nr_events,",
          "1275:        long min)",
          "1280:   int tmin = 0;",
          "",
          "[Added Lines]",
          "2435: static void io_iopoll_try_reap_events(struct io_ring_ctx *ctx)",
          "2441:  while (!list_empty(&ctx->iopoll_list)) {",
          "2444:   io_do_iopoll(ctx, &nr_events, 0);",
          "2447:   if (nr_events == 0)",
          "2448:    break;",
          "2454:   if (need_resched()) {",
          "2455:    mutex_unlock(&ctx->uring_lock);",
          "2456:    cond_resched();",
          "2457:    mutex_lock(&ctx->uring_lock);",
          "2458:   }",
          "2463: static int io_iopoll_check(struct io_ring_ctx *ctx, long min)",
          "2465:  unsigned int nr_events = 0;",
          "2473:  mutex_lock(&ctx->uring_lock);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1300:   if (!(++iters & 7)) {",
          "1301:    mutex_unlock(&ctx->uring_lock);",
          "1302:    mutex_lock(&ctx->uring_lock);",
          "1303:   }",
          "1309:   if (ret <= 0)",
          "1310:    break;",
          "1311:   ret = 0;",
          "1329:  mutex_unlock(&ctx->uring_lock);",
          "1330:  return ret;",
          "1331: }",
          "",
          "[Removed Lines]",
          "1305:   if (*nr_events < min)",
          "1306:    tmin = min - *nr_events;",
          "1308:   ret = io_iopoll_getevents(ctx, nr_events, tmin);",
          "1312:  } while (min && !*nr_events && !need_resched());",
          "1314:  return ret;",
          "1315: }",
          "1317: static int io_iopoll_check(struct io_ring_ctx *ctx, unsigned *nr_events,",
          "1318:       long min)",
          "1319: {",
          "1320:  int ret;",
          "1327:  mutex_lock(&ctx->uring_lock);",
          "1328:  ret = __io_iopoll_check(ctx, nr_events, min);",
          "",
          "[Added Lines]",
          "2495:    io_run_task_work();",
          "2499:   ret = io_iopoll_getevents(ctx, &nr_events, min);",
          "2503:  } while (min && !nr_events && !need_resched());",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1344:  file_end_write(req->file);",
          "1345: }",
          "1354: {",
          "1355:  struct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);",
          "1357:  if (kiocb->ki_flags & IOCB_WRITE)",
          "1358:   kiocb_end_write(req);",
          "1360:  if (res != req->result)",
          "1361:   req_set_fail_links(req);",
          "1363: }",
          "1366: {",
          "1371: }",
          "1374: {",
          "1382: }",
          "1384: static void io_complete_rw_iopoll(struct kiocb *kiocb, long res, long res2)",
          "",
          "[Removed Lines]",
          "1347: static inline void req_set_fail_links(struct io_kiocb *req)",
          "1348: {",
          "1349:  if ((req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) == REQ_F_LINK)",
          "1350:   req->flags |= REQ_F_FAIL_LINK;",
          "1351: }",
          "1353: static void io_complete_rw_common(struct kiocb *kiocb, long res)",
          "1362:  io_cqring_add_event(req, res);",
          "1365: static void io_complete_rw(struct kiocb *kiocb, long res, long res2)",
          "1367:  struct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);",
          "1369:  io_complete_rw_common(kiocb, res);",
          "1370:  io_put_req(req);",
          "1373: static struct io_kiocb *__io_complete_rw(struct kiocb *kiocb, long res)",
          "1375:  struct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);",
          "1376:  struct io_kiocb *nxt = NULL;",
          "1378:  io_complete_rw_common(kiocb, res);",
          "1379:  io_put_req_find_next(req, &nxt);",
          "1381:  return nxt;",
          "",
          "[Added Lines]",
          "2523: static void io_complete_rw_common(struct kiocb *kiocb, long res,",
          "2524:       struct io_comp_state *cs)",
          "2527:  int cflags = 0;",
          "2534:  if (req->flags & REQ_F_BUFFER_SELECTED)",
          "2535:   cflags = io_put_rw_kbuf(req);",
          "2536:  __io_req_complete(req, res, cflags, cs);",
          "2539: #ifdef CONFIG_BLOCK",
          "2540: static bool io_resubmit_prep(struct io_kiocb *req, int error)",
          "2542:  struct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;",
          "2543:  ssize_t ret = -ECANCELED;",
          "2544:  struct iov_iter iter;",
          "2545:  int rw;",
          "2547:  if (error) {",
          "2548:   ret = error;",
          "2549:   goto end_req;",
          "2550:  }",
          "2552:  switch (req->opcode) {",
          "2553:  case IORING_OP_READV:",
          "2554:  case IORING_OP_READ_FIXED:",
          "2555:  case IORING_OP_READ:",
          "2556:   rw = READ;",
          "2557:   break;",
          "2558:  case IORING_OP_WRITEV:",
          "2559:  case IORING_OP_WRITE_FIXED:",
          "2560:  case IORING_OP_WRITE:",
          "2561:   rw = WRITE;",
          "2562:   break;",
          "2563:  default:",
          "2564:   printk_once(KERN_WARNING \"io_uring: bad opcode in resubmit %d\\n\",",
          "2565:     req->opcode);",
          "2566:   goto end_req;",
          "2567:  }",
          "2569:  if (!req->async_data) {",
          "2570:   ret = io_import_iovec(rw, req, &iovec, &iter, false);",
          "2571:   if (ret < 0)",
          "2572:    goto end_req;",
          "2573:   ret = io_setup_async_rw(req, iovec, inline_vecs, &iter, false);",
          "2574:   if (!ret)",
          "2575:    return true;",
          "2576:   kfree(iovec);",
          "2577:  } else {",
          "2578:   return true;",
          "2579:  }",
          "2580: end_req:",
          "2581:  req_set_fail_links(req);",
          "2582:  return false;",
          "2584: #endif",
          "2586: static bool io_rw_reissue(struct io_kiocb *req, long res)",
          "2588: #ifdef CONFIG_BLOCK",
          "2589:  umode_t mode = file_inode(req->file)->i_mode;",
          "2590:  int ret;",
          "2592:  if (!S_ISBLK(mode) && !S_ISREG(mode))",
          "2593:   return false;",
          "2594:  if ((res != -EAGAIN && res != -EOPNOTSUPP) || io_wq_current_is_worker())",
          "2595:   return false;",
          "2597:  ret = io_sq_thread_acquire_mm(req->ctx, req);",
          "2599:  if (io_resubmit_prep(req, ret)) {",
          "2600:   refcount_inc(&req->refs);",
          "2601:   io_queue_async_work(req);",
          "2602:   return true;",
          "2603:  }",
          "2605: #endif",
          "2606:  return false;",
          "2607: }",
          "2609: static void __io_complete_rw(struct io_kiocb *req, long res, long res2,",
          "2610:         struct io_comp_state *cs)",
          "2611: {",
          "2612:  if (!io_rw_reissue(req, res))",
          "2613:   io_complete_rw_common(&req->rw.kiocb, res, cs);",
          "2614: }",
          "2616: static void io_complete_rw(struct kiocb *kiocb, long res, long res2)",
          "2617: {",
          "2618:  struct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);",
          "2620:  __io_complete_rw(req, res, res2, NULL);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1388:  if (kiocb->ki_flags & IOCB_WRITE)",
          "1389:   kiocb_end_write(req);",
          "1392:   req_set_fail_links(req);",
          "1396: }",
          "",
          "[Removed Lines]",
          "1391:  if (res != req->result)",
          "1393:  req->result = res;",
          "1394:  if (res != -EAGAIN)",
          "1395:   req->flags |= REQ_F_IOPOLL_COMPLETED;",
          "",
          "[Added Lines]",
          "2630:  if (res != -EAGAIN && res != req->result)",
          "2633:  WRITE_ONCE(req->result, res);",
          "2635:  smp_wmb();",
          "2636:  WRITE_ONCE(req->iopoll_completed, 1);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1414:   ctx->poll_multi_file = false;",
          "1415:  } else if (!ctx->poll_multi_file) {",
          "1416:   struct io_kiocb *list_req;",
          "1420:   if (list_req->file != req->file)",
          "1421:    ctx->poll_multi_file = true;",
          "1422:  }",
          "",
          "[Removed Lines]",
          "1413:  if (list_empty(&ctx->poll_list)) {",
          "1418:   list_req = list_first_entry(&ctx->poll_list, struct io_kiocb,",
          "1419:       list);",
          "",
          "[Added Lines]",
          "2654:  if (list_empty(&ctx->iopoll_list)) {",
          "2659:   list_req = list_first_entry(&ctx->iopoll_list, struct io_kiocb,",
          "2660:       inflight_entry);",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1430:  else",
          "1432: }",
          "1435: {",
          "1443: }",
          "",
          "[Removed Lines]",
          "1428:  if (req->flags & REQ_F_IOPOLL_COMPLETED)",
          "1429:   list_add(&req->list, &ctx->poll_list);",
          "1431:   list_add_tail(&req->list, &ctx->poll_list);",
          "1434: static void io_file_put(struct io_submit_state *state)",
          "1436:  if (state->file) {",
          "1437:   int diff = state->has_refs - state->used_refs;",
          "1439:   if (diff)",
          "1440:    fput_many(state->file, diff);",
          "1441:   state->file = NULL;",
          "1442:  }",
          "",
          "[Added Lines]",
          "2669:  if (READ_ONCE(req->iopoll_completed))",
          "2670:   list_add(&req->inflight_entry, &ctx->iopoll_list);",
          "2672:   list_add_tail(&req->inflight_entry, &ctx->iopoll_list);",
          "2674:  if ((ctx->flags & IORING_SETUP_SQPOLL) &&",
          "2675:      wq_has_sleeper(&ctx->sq_data->wait))",
          "2676:   wake_up(&ctx->sq_data->wait);",
          "2679: static void __io_state_file_put(struct io_submit_state *state)",
          "2681:  if (state->has_refs)",
          "2682:   fput_many(state->file, state->has_refs);",
          "2683:  state->file = NULL;",
          "2684: }",
          "2686: static inline void io_state_file_put(struct io_submit_state *state)",
          "2687: {",
          "2688:  if (state->file)",
          "2689:   __io_state_file_put(state);",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1451: {",
          "1452:  if (!state)",
          "1453:   return fget(fd);",
          "1455:  if (state->file) {",
          "1456:   if (state->fd == fd) {",
          "1459:    return state->file;",
          "1460:   }",
          "1462:  }",
          "1463:  state->file = fget_many(fd, state->ios_left);",
          "1464:  if (!state->file)",
          "1465:   return NULL;",
          "1467:  state->fd = fd;",
          "1471:  return state->file;",
          "1472: }",
          "1480: {",
          "1481:  umode_t mode = file_inode(file)->i_mode;",
          "1486:   return true;",
          "1489: }",
          "1493: {",
          "1494:  struct io_ring_ctx *ctx = req->ctx;",
          "1495:  struct kiocb *kiocb = &req->rw.kiocb;",
          "1496:  unsigned ioprio;",
          "1497:  int ret;",
          "1502:  if (S_ISREG(file_inode(req->file)->i_mode))",
          "1503:   req->flags |= REQ_F_ISREG;",
          "1505:  kiocb->ki_pos = READ_ONCE(sqe->off);",
          "1507:  kiocb->ki_hint = ki_hint_validate(file_write_hint(kiocb->ki_filp));",
          "1509:  ioprio = READ_ONCE(sqe->ioprio);",
          "1510:  if (ioprio) {",
          "",
          "[Removed Lines]",
          "1450: static struct file *io_file_get(struct io_submit_state *state, int fd)",
          "1457:    state->used_refs++;",
          "1458:    state->ios_left--;",
          "1461:   io_file_put(state);",
          "1468:  state->has_refs = state->ios_left;",
          "1469:  state->used_refs = 1;",
          "1470:  state->ios_left--;",
          "1479: static bool io_file_supports_async(struct file *file)",
          "1483:  if (S_ISBLK(mode) || S_ISCHR(mode) || S_ISSOCK(mode))",
          "1484:   return true;",
          "1485:  if (S_ISREG(mode) && file->f_op != &io_uring_fops)",
          "1488:  return false;",
          "1491: static int io_prep_rw(struct io_kiocb *req, const struct io_uring_sqe *sqe,",
          "1492:         bool force_nonblock)",
          "1499:  if (!req->file)",
          "1500:   return -EBADF;",
          "1506:  kiocb->ki_flags = iocb_flags(kiocb->ki_filp);",
          "",
          "[Added Lines]",
          "2697: static struct file *__io_file_get(struct io_submit_state *state, int fd)",
          "2704:    state->has_refs--;",
          "2707:   __io_state_file_put(state);",
          "2714:  state->has_refs = state->ios_left - 1;",
          "2718: static bool io_bdev_nowait(struct block_device *bdev)",
          "2719: {",
          "2720: #ifdef CONFIG_BLOCK",
          "2721:  return !bdev || blk_queue_nowait(bdev_get_queue(bdev));",
          "2722: #else",
          "2723:  return true;",
          "2724: #endif",
          "2725: }",
          "2732: static bool io_file_supports_async(struct file *file, int rw)",
          "2736:  if (S_ISBLK(mode)) {",
          "2737:   if (io_bdev_nowait(file->f_inode->i_bdev))",
          "2738:    return true;",
          "2739:   return false;",
          "2740:  }",
          "2741:  if (S_ISCHR(mode) || S_ISSOCK(mode))",
          "2743:  if (S_ISREG(mode)) {",
          "2744:   if (io_bdev_nowait(file->f_inode->i_sb->s_bdev) &&",
          "2745:       file->f_op != &io_uring_fops)",
          "2746:    return true;",
          "2747:   return false;",
          "2748:  }",
          "2751:  if (file->f_flags & O_NONBLOCK)",
          "2752:   return true;",
          "2754:  if (!(file->f_mode & FMODE_NOWAIT))",
          "2755:   return false;",
          "2757:  if (rw == READ)",
          "2758:   return file->f_op->read_iter != NULL;",
          "2760:  return file->f_op->write_iter != NULL;",
          "2763: static int io_prep_rw(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "2774:  if (kiocb->ki_pos == -1 && !(req->file->f_mode & FMODE_STREAM)) {",
          "2775:   req->flags |= REQ_F_CUR_POS;",
          "2776:   kiocb->ki_pos = req->file->f_pos;",
          "2777:  }",
          "2779:  kiocb->ki_flags = iocb_flags(kiocb->ki_filp);",
          "2780:  ret = kiocb_set_rw_flags(kiocb, READ_ONCE(sqe->rw_flags));",
          "2781:  if (unlikely(ret))",
          "2782:   return ret;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1516:  } else",
          "1517:   kiocb->ki_ioprio = get_current_ioprio();",
          "1526:   req->flags |= REQ_F_NOWAIT;",
          "1531:  if (ctx->flags & IORING_SETUP_IOPOLL) {",
          "1532:   if (!(kiocb->ki_flags & IOCB_DIRECT) ||",
          "1533:       !kiocb->ki_filp->f_op->iopoll)",
          "",
          "[Removed Lines]",
          "1519:  ret = kiocb_set_rw_flags(kiocb, READ_ONCE(sqe->rw_flags));",
          "1520:  if (unlikely(ret))",
          "1521:   return ret;",
          "1524:  if ((kiocb->ki_flags & IOCB_NOWAIT) ||",
          "1525:      (req->file->f_flags & O_NONBLOCK))",
          "1528:  if (force_nonblock)",
          "1529:   kiocb->ki_flags |= IOCB_NOWAIT;",
          "",
          "[Added Lines]",
          "2795:  if (kiocb->ki_flags & IOCB_NOWAIT)",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1536:   kiocb->ki_flags |= IOCB_HIPRI;",
          "1537:   kiocb->ki_complete = io_complete_rw_iopoll;",
          "1539:  } else {",
          "1540:   if (kiocb->ki_flags & IOCB_HIPRI)",
          "1541:    return -EINVAL;",
          "",
          "[Removed Lines]",
          "1538:   req->result = 0;",
          "",
          "[Added Lines]",
          "2805:   req->iopoll_completed = 0;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1545:  req->rw.addr = READ_ONCE(sqe->addr);",
          "1546:  req->rw.len = READ_ONCE(sqe->len);",
          "1550:  return 0;",
          "1551: }",
          "",
          "[Removed Lines]",
          "1548:  req->rw.kiocb.private = (void *) (unsigned long)",
          "1549:      READ_ONCE(sqe->buf_index);",
          "",
          "[Added Lines]",
          "2814:  req->buf_index = READ_ONCE(sqe->buf_index);",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1567:   ret = -EINTR;",
          "1569:  default:",
          "1570:   kiocb->ki_complete(kiocb, ret, 0);",
          "1571:  }",
          "1572: }",
          "1576: {",
          "1579:  else",
          "1580:   io_rw_done(kiocb, ret);",
          "1581: }",
          "",
          "[Removed Lines]",
          "1574: static void kiocb_done(struct kiocb *kiocb, ssize_t ret, struct io_kiocb **nxt,",
          "1575:          bool in_async)",
          "1577:  if (in_async && ret >= 0 && kiocb->ki_complete == io_complete_rw)",
          "",
          "[Added Lines]",
          "2833:   fallthrough;",
          "2839: static void kiocb_done(struct kiocb *kiocb, ssize_t ret,",
          "2840:          struct io_comp_state *cs)",
          "2842:  struct io_kiocb *req = container_of(kiocb, struct io_kiocb, rw.kiocb);",
          "2843:  struct io_async_rw *io = req->async_data;",
          "2846:  if (io && io->bytes_done > 0) {",
          "2847:   if (ret < 0)",
          "2848:    ret = io->bytes_done;",
          "2849:   else",
          "2850:    ret += io->bytes_done;",
          "2851:  }",
          "2853:  if (req->flags & REQ_F_CUR_POS)",
          "2854:   req->file->f_pos = kiocb->ki_pos;",
          "2855:  if (ret >= 0 && kiocb->ki_complete == io_complete_rw)",
          "2856:   __io_complete_rw(req, ret, 0, cs);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1586:  struct io_ring_ctx *ctx = req->ctx;",
          "1587:  size_t len = req->rw.len;",
          "1588:  struct io_mapped_ubuf *imu;",
          "1590:  size_t offset;",
          "1591:  u64 buf_addr;",
          "1598:  if (unlikely(buf_index >= ctx->nr_user_bufs))",
          "1599:   return -EFAULT;",
          "1601:  index = array_index_nospec(buf_index, ctx->nr_user_bufs);",
          "1602:  imu = &ctx->user_bufs[index];",
          "1603:  buf_addr = req->rw.addr;",
          "",
          "[Removed Lines]",
          "1589:  unsigned index, buf_index;",
          "1594:  if (unlikely(!ctx->user_bufs))",
          "1595:   return -EFAULT;",
          "1597:  buf_index = (unsigned long) req->rw.kiocb.private;",
          "",
          "[Added Lines]",
          "2867:  u16 index, buf_index = req->buf_index;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1654:  return len;",
          "1655: }",
          "1659: {",
          "1660:  void __user *buf = u64_to_user_ptr(req->rw.addr);",
          "1661:  size_t sqe_len = req->rw.len;",
          "1662:  u8 opcode;",
          "1664:  opcode = req->opcode;",
          "",
          "[Removed Lines]",
          "1657: static ssize_t io_import_iovec(int rw, struct io_kiocb *req,",
          "1658:           struct iovec **iovec, struct iov_iter *iter)",
          "",
          "[Added Lines]",
          "2929: static void io_ring_submit_unlock(struct io_ring_ctx *ctx, bool needs_lock)",
          "2930: {",
          "2931:  if (needs_lock)",
          "2932:   mutex_unlock(&ctx->uring_lock);",
          "2933: }",
          "2935: static void io_ring_submit_lock(struct io_ring_ctx *ctx, bool needs_lock)",
          "2936: {",
          "2943:  if (needs_lock)",
          "2944:   mutex_lock(&ctx->uring_lock);",
          "2945: }",
          "2947: static struct io_buffer *io_buffer_select(struct io_kiocb *req, size_t *len,",
          "2948:        int bgid, struct io_buffer *kbuf,",
          "2949:        bool needs_lock)",
          "2950: {",
          "2951:  struct io_buffer *head;",
          "2953:  if (req->flags & REQ_F_BUFFER_SELECTED)",
          "2954:   return kbuf;",
          "2956:  io_ring_submit_lock(req->ctx, needs_lock);",
          "2958:  lockdep_assert_held(&req->ctx->uring_lock);",
          "2960:  head = idr_find(&req->ctx->io_buffer_idr, bgid);",
          "2961:  if (head) {",
          "2962:   if (!list_empty(&head->list)) {",
          "2963:    kbuf = list_last_entry(&head->list, struct io_buffer,",
          "2964:        list);",
          "2965:    list_del(&kbuf->list);",
          "2966:   } else {",
          "2967:    kbuf = head;",
          "2968:    idr_remove(&req->ctx->io_buffer_idr, bgid);",
          "2969:   }",
          "2970:   if (*len > kbuf->len)",
          "2972:  } else {",
          "2973:   kbuf = ERR_PTR(-ENOBUFS);",
          "2974:  }",
          "2976:  io_ring_submit_unlock(req->ctx, needs_lock);",
          "2978:  return kbuf;",
          "2979: }",
          "2981: static void __user *io_rw_buffer_select(struct io_kiocb *req, size_t *len,",
          "2982:      bool needs_lock)",
          "2983: {",
          "2984:  struct io_buffer *kbuf;",
          "2985:  u16 bgid;",
          "2987:  kbuf = (struct io_buffer *) (unsigned long) req->rw.addr;",
          "2988:  bgid = req->buf_index;",
          "2989:  kbuf = io_buffer_select(req, len, bgid, kbuf, needs_lock);",
          "2990:  if (IS_ERR(kbuf))",
          "2991:   return kbuf;",
          "2992:  req->rw.addr = (u64) (unsigned long) kbuf;",
          "2993:  req->flags |= REQ_F_BUFFER_SELECTED;",
          "2994:  return u64_to_user_ptr(kbuf->addr);",
          "2995: }",
          "2997: #ifdef CONFIG_COMPAT",
          "2998: static ssize_t io_compat_import(struct io_kiocb *req, struct iovec *iov,",
          "2999:     bool needs_lock)",
          "3000: {",
          "3001:  struct compat_iovec __user *uiov;",
          "3002:  compat_ssize_t clen;",
          "3003:  void __user *buf;",
          "3004:  ssize_t len;",
          "3006:  uiov = u64_to_user_ptr(req->rw.addr);",
          "3007:  if (!access_ok(uiov, sizeof(*uiov)))",
          "3008:   return -EFAULT;",
          "3009:  if (__get_user(clen, &uiov->iov_len))",
          "3010:   return -EFAULT;",
          "3011:  if (clen < 0)",
          "3012:   return -EINVAL;",
          "3014:  len = clen;",
          "3015:  buf = io_rw_buffer_select(req, &len, needs_lock);",
          "3016:  if (IS_ERR(buf))",
          "3017:   return PTR_ERR(buf);",
          "3018:  iov[0].iov_base = buf;",
          "3019:  iov[0].iov_len = (compat_size_t) len;",
          "3020:  return 0;",
          "3021: }",
          "3022: #endif",
          "3024: static ssize_t __io_iov_buffer_select(struct io_kiocb *req, struct iovec *iov,",
          "3025:           bool needs_lock)",
          "3026: {",
          "3027:  struct iovec __user *uiov = u64_to_user_ptr(req->rw.addr);",
          "3028:  void __user *buf;",
          "3029:  ssize_t len;",
          "3031:  if (copy_from_user(iov, uiov, sizeof(*uiov)))",
          "3032:   return -EFAULT;",
          "3034:  len = iov[0].iov_len;",
          "3035:  if (len < 0)",
          "3036:   return -EINVAL;",
          "3037:  buf = io_rw_buffer_select(req, &len, needs_lock);",
          "3038:  if (IS_ERR(buf))",
          "3039:   return PTR_ERR(buf);",
          "3040:  iov[0].iov_base = buf;",
          "3041:  iov[0].iov_len = len;",
          "3042:  return 0;",
          "3043: }",
          "3045: static ssize_t io_iov_buffer_select(struct io_kiocb *req, struct iovec *iov,",
          "3046:         bool needs_lock)",
          "3047: {",
          "3048:  if (req->flags & REQ_F_BUFFER_SELECTED) {",
          "3049:   struct io_buffer *kbuf;",
          "3051:   kbuf = (struct io_buffer *) (unsigned long) req->rw.addr;",
          "3052:   iov[0].iov_base = u64_to_user_ptr(kbuf->addr);",
          "3053:   iov[0].iov_len = kbuf->len;",
          "3054:   return 0;",
          "3055:  }",
          "3056:  if (!req->rw.len)",
          "3057:   return 0;",
          "3058:  else if (req->rw.len > 1)",
          "3059:   return -EINVAL;",
          "3061: #ifdef CONFIG_COMPAT",
          "3062:  if (req->ctx->compat)",
          "3063:   return io_compat_import(req, iov, needs_lock);",
          "3064: #endif",
          "3066:  return __io_iov_buffer_select(req, iov, needs_lock);",
          "3067: }",
          "3069: static ssize_t __io_import_iovec(int rw, struct io_kiocb *req,",
          "3070:      struct iovec **iovec, struct iov_iter *iter,",
          "3071:      bool needs_lock)",
          "3075:  ssize_t ret;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1667:   return io_import_fixed(req, rw, iter);",
          "1668:  }",
          "1672:   return -EINVAL;",
          "1682:  }",
          "1687: #ifdef CONFIG_COMPAT",
          "1688:  if (req->ctx->compat)",
          "",
          "[Removed Lines]",
          "1671:  if (req->rw.kiocb.private)",
          "1674:  if (req->io) {",
          "1675:   struct io_async_rw *iorw = &req->io->rw;",
          "1678:   iov_iter_init(iter, rw, *iovec, iorw->nr_segs, iorw->size);",
          "1679:   if (iorw->iov == iorw->fast_iov)",
          "1681:   return iorw->size;",
          "1684:  if (!req->has_user)",
          "1685:   return -EFAULT;",
          "",
          "[Added Lines]",
          "3085:  if (req->buf_index && !(req->flags & REQ_F_BUFFER_SELECT))",
          "3088:  if (opcode == IORING_OP_READ || opcode == IORING_OP_WRITE) {",
          "3089:   if (req->flags & REQ_F_BUFFER_SELECT) {",
          "3090:    buf = io_rw_buffer_select(req, &sqe_len, needs_lock);",
          "3091:    if (IS_ERR(buf))",
          "3092:     return PTR_ERR(buf);",
          "3093:    req->rw.len = sqe_len;",
          "3094:   }",
          "3096:   ret = import_single_range(rw, buf, sqe_len, *iovec, iter);",
          "3098:   return ret < 0 ? ret : sqe_len;",
          "3101:  if (req->flags & REQ_F_BUFFER_SELECT) {",
          "3102:   ret = io_iov_buffer_select(req, *iovec, needs_lock);",
          "3103:   if (!ret) {",
          "3104:    ret = (*iovec)->iov_len;",
          "3105:    iov_iter_init(iter, rw, *iovec, 1, ret);",
          "3106:   }",
          "3108:   return ret;",
          "3109:  }",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1693:  return import_iovec(rw, buf, sqe_len, UIO_FASTIOV, iovec, iter);",
          "1694: }",
          "1702: {",
          "1703:  ssize_t ret = 0;",
          "",
          "[Removed Lines]",
          "1700: static ssize_t loop_rw_iter(int rw, struct file *file, struct kiocb *kiocb,",
          "1701:       struct iov_iter *iter)",
          "",
          "[Added Lines]",
          "3120: static ssize_t io_import_iovec(int rw, struct io_kiocb *req,",
          "3121:           struct iovec **iovec, struct iov_iter *iter,",
          "3122:           bool needs_lock)",
          "3123: {",
          "3124:  struct io_async_rw *iorw = req->async_data;",
          "3126:  if (!iorw)",
          "3127:   return __io_import_iovec(rw, req, iovec, iter, needs_lock);",
          "3129:  return iov_iter_count(&iorw->iter);",
          "3130: }",
          "3132: static inline loff_t *io_kiocb_ppos(struct kiocb *kiocb)",
          "3133: {",
          "3134:  return (kiocb->ki_filp->f_mode & FMODE_STREAM) ? NULL : &kiocb->ki_pos;",
          "3135: }",
          "3141: static ssize_t loop_rw_iter(int rw, struct io_kiocb *req, struct iov_iter *iter)",
          "3143:  struct kiocb *kiocb = &req->rw.kiocb;",
          "3144:  struct file *file = req->file;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1719:   if (!iov_iter_is_bvec(iter)) {",
          "1720:    iovec = iov_iter_iovec(iter);",
          "1721:   } else {",
          "1727:   }",
          "1729:   if (rw == READ) {",
          "1730:    nr = file->f_op->read(file, iovec.iov_base,",
          "1732:   } else {",
          "1733:    nr = file->f_op->write(file, iovec.iov_base,",
          "1735:   }",
          "1740:   if (nr < 0) {",
          "1741:    if (!ret)",
          "1742:     ret = nr;",
          "",
          "[Removed Lines]",
          "1723:    iovec.iov_base = kmap(iter->bvec->bv_page)",
          "1724:       + iter->iov_offset;",
          "1725:    iovec.iov_len = min(iter->count,",
          "1726:      iter->bvec->bv_len - iter->iov_offset);",
          "1731:            iovec.iov_len, &kiocb->ki_pos);",
          "1734:             iovec.iov_len, &kiocb->ki_pos);",
          "1737:   if (iov_iter_is_bvec(iter))",
          "1738:    kunmap(iter->bvec->bv_page);",
          "",
          "[Added Lines]",
          "3164:    iovec.iov_base = u64_to_user_ptr(req->rw.addr);",
          "3165:    iovec.iov_len = req->rw.len;",
          "3170:            iovec.iov_len, io_kiocb_ppos(kiocb));",
          "3173:             iovec.iov_len, io_kiocb_ppos(kiocb));",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1745:   ret += nr;",
          "1746:   if (nr != iovec.iov_len)",
          "1747:    break;",
          "1748:   iov_iter_advance(iter, nr);",
          "1749:  }",
          "1751:  return ret;",
          "1752: }",
          "1757: {",
          "1765:  }",
          "1766: }",
          "1769: {",
          "1772: }",
          "1775: {",
          "1783: }",
          "1788: {",
          "1791:   return 0;",
          "1797:  return 0;",
          "1798: }",
          "1802: {",
          "1805:  ssize_t ret;",
          "1808:  if (ret)",
          "1809:   return ret;",
          "1811:  if (unlikely(!(req->file->f_mode & FMODE_READ)))",
          "1812:   return -EBADF;",
          "1815:   return 0;",
          "1827: }",
          "1831: {",
          "1832:  struct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;",
          "1833:  struct kiocb *kiocb = &req->rw.kiocb;",
          "1835:  size_t iov_count;",
          "1839:  if (ret < 0)",
          "1840:   return ret;",
          "1843:  if (!force_nonblock)",
          "1857:   goto copy_iov;",
          "1862:  if (!ret) {",
          "1874: copy_iov:",
          "1881:  }",
          "1882: out_free:",
          "1884:   kfree(iovec);",
          "1885:  return ret;",
          "1886: }",
          "1890: {",
          "1893:  ssize_t ret;",
          "1896:  if (ret)",
          "1897:   return ret;",
          "1899:  if (unlikely(!(req->file->f_mode & FMODE_WRITE)))",
          "1900:   return -EBADF;",
          "1903:   return 0;",
          "1915: }",
          "1919: {",
          "1920:  struct iovec inline_vecs[UIO_FASTIOV], *iovec = inline_vecs;",
          "1921:  struct kiocb *kiocb = &req->rw.kiocb;",
          "1923:  size_t iov_count;",
          "1927:  if (ret < 0)",
          "1928:   return ret;",
          "1931:  if (!force_nonblock)",
          "1945:   goto copy_iov;",
          "1949:  if (force_nonblock && !(kiocb->ki_flags & IOCB_DIRECT) &&",
          "1950:      (req->flags & REQ_F_ISREG))",
          "1951:   goto copy_iov;",
          "1980: copy_iov:",
          "1985:    return -EAGAIN;",
          "1987:  }",
          "1988: out_free:",
          "1990:   kfree(iovec);",
          "1991:  return ret;",
          "1992: }",
          "1998: {",
          "2002:   return -EINVAL;",
          "2014:   return -EBADF;",
          "2027:  return 0;",
          "2028: }",
          "2031: {",
          "2040: }",
          "2043: {",
          "2049: }",
          "2052: {",
          "2062: }",
          "2065: {",
          "2078:   req_set_fail_links(req);",
          "2083: }",
          "2087: {",
          "2101:  return 0;",
          "2102: }",
          "2105: {",
          "2106:  struct io_ring_ctx *ctx = req->ctx;",
          "",
          "[Removed Lines]",
          "1754: static void io_req_map_rw(struct io_kiocb *req, ssize_t io_size,",
          "1755:      struct iovec *iovec, struct iovec *fast_iov,",
          "1756:      struct iov_iter *iter)",
          "1758:  req->io->rw.nr_segs = iter->nr_segs;",
          "1759:  req->io->rw.size = io_size;",
          "1760:  req->io->rw.iov = iovec;",
          "1761:  if (!req->io->rw.iov) {",
          "1762:   req->io->rw.iov = req->io->rw.fast_iov;",
          "1763:   memcpy(req->io->rw.iov, fast_iov,",
          "1764:    sizeof(struct iovec) * iter->nr_segs);",
          "1768: static int io_alloc_async_ctx(struct io_kiocb *req)",
          "1770:  req->io = kmalloc(sizeof(*req->io), GFP_KERNEL);",
          "1771:  return req->io == NULL;",
          "1774: static void io_rw_async(struct io_wq_work **workptr)",
          "1776:  struct io_kiocb *req = container_of(*workptr, struct io_kiocb, work);",
          "1777:  struct iovec *iov = NULL;",
          "1779:  if (req->io->rw.iov != req->io->rw.fast_iov)",
          "1780:   iov = req->io->rw.iov;",
          "1781:  io_wq_submit_work(workptr);",
          "1782:  kfree(iov);",
          "1785: static int io_setup_async_rw(struct io_kiocb *req, ssize_t io_size,",
          "1786:         struct iovec *iovec, struct iovec *fast_iov,",
          "1787:         struct iov_iter *iter)",
          "1789:  if (req->opcode == IORING_OP_READ_FIXED ||",
          "1790:      req->opcode == IORING_OP_WRITE_FIXED)",
          "1792:  if (!req->io && io_alloc_async_ctx(req))",
          "1793:   return -ENOMEM;",
          "1795:  io_req_map_rw(req, io_size, iovec, fast_iov, iter);",
          "1796:  req->work.func = io_rw_async;",
          "1800: static int io_read_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,",
          "1801:    bool force_nonblock)",
          "1803:  struct io_async_ctx *io;",
          "1804:  struct iov_iter iter;",
          "1807:  ret = io_prep_rw(req, sqe, force_nonblock);",
          "1814:  if (!req->io)",
          "1817:  io = req->io;",
          "1818:  io->rw.iov = io->rw.fast_iov;",
          "1819:  req->io = NULL;",
          "1820:  ret = io_import_iovec(READ, req, &io->rw.iov, &iter);",
          "1821:  req->io = io;",
          "1822:  if (ret < 0)",
          "1823:   return ret;",
          "1825:  io_req_map_rw(req, ret, io->rw.iov, io->rw.fast_iov, &iter);",
          "1826:  return 0;",
          "1829: static int io_read(struct io_kiocb *req, struct io_kiocb **nxt,",
          "1830:      bool force_nonblock)",
          "1834:  struct iov_iter iter;",
          "1836:  ssize_t io_size, ret;",
          "1838:  ret = io_import_iovec(READ, req, &iovec, &iter);",
          "1844:   req->rw.kiocb.ki_flags &= ~IOCB_NOWAIT;",
          "1846:  req->result = 0;",
          "1847:  io_size = ret;",
          "1848:  if (req->flags & REQ_F_LINK)",
          "1849:   req->result = io_size;",
          "1855:  if (force_nonblock && !io_file_supports_async(req->file)) {",
          "1856:   req->flags |= REQ_F_MUST_PUNT;",
          "1858:  }",
          "1860:  iov_count = iov_iter_count(&iter);",
          "1861:  ret = rw_verify_area(READ, req->file, &kiocb->ki_pos, iov_count);",
          "1863:   ssize_t ret2;",
          "1865:   if (req->file->f_op->read_iter)",
          "1866:    ret2 = call_read_iter(req->file, kiocb, &iter);",
          "1867:   else",
          "1868:    ret2 = loop_rw_iter(READ, req->file, kiocb, &iter);",
          "1871:   if (!force_nonblock || ret2 != -EAGAIN) {",
          "1872:    kiocb_done(kiocb, ret2, nxt, req->in_async);",
          "1873:   } else {",
          "1875:    ret = io_setup_async_rw(req, io_size, iovec,",
          "1876:       inline_vecs, &iter);",
          "1877:    if (ret)",
          "1878:     goto out_free;",
          "1879:    return -EAGAIN;",
          "1880:   }",
          "1883:  if (!io_wq_current_is_worker())",
          "1888: static int io_write_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,",
          "1889:     bool force_nonblock)",
          "1891:  struct io_async_ctx *io;",
          "1892:  struct iov_iter iter;",
          "1895:  ret = io_prep_rw(req, sqe, force_nonblock);",
          "1902:  if (!req->io)",
          "1905:  io = req->io;",
          "1906:  io->rw.iov = io->rw.fast_iov;",
          "1907:  req->io = NULL;",
          "1908:  ret = io_import_iovec(WRITE, req, &io->rw.iov, &iter);",
          "1909:  req->io = io;",
          "1910:  if (ret < 0)",
          "1911:   return ret;",
          "1913:  io_req_map_rw(req, ret, io->rw.iov, io->rw.fast_iov, &iter);",
          "1914:  return 0;",
          "1917: static int io_write(struct io_kiocb *req, struct io_kiocb **nxt,",
          "1918:       bool force_nonblock)",
          "1922:  struct iov_iter iter;",
          "1924:  ssize_t ret, io_size;",
          "1926:  ret = io_import_iovec(WRITE, req, &iovec, &iter);",
          "1932:   req->rw.kiocb.ki_flags &= ~IOCB_NOWAIT;",
          "1934:  req->result = 0;",
          "1935:  io_size = ret;",
          "1936:  if (req->flags & REQ_F_LINK)",
          "1937:   req->result = io_size;",
          "1943:  if (force_nonblock && !io_file_supports_async(req->file)) {",
          "1944:   req->flags |= REQ_F_MUST_PUNT;",
          "1946:  }",
          "1953:  iov_count = iov_iter_count(&iter);",
          "1954:  ret = rw_verify_area(WRITE, req->file, &kiocb->ki_pos, iov_count);",
          "1955:  if (!ret) {",
          "1956:   ssize_t ret2;",
          "1965:   if (req->flags & REQ_F_ISREG) {",
          "1966:    __sb_start_write(file_inode(req->file)->i_sb,",
          "1967:       SB_FREEZE_WRITE, true);",
          "1968:    __sb_writers_release(file_inode(req->file)->i_sb,",
          "1969:       SB_FREEZE_WRITE);",
          "1970:   }",
          "1971:   kiocb->ki_flags |= IOCB_WRITE;",
          "1973:   if (req->file->f_op->write_iter)",
          "1974:    ret2 = call_write_iter(req->file, kiocb, &iter);",
          "1975:   else",
          "1976:    ret2 = loop_rw_iter(WRITE, req->file, kiocb, &iter);",
          "1977:   if (!force_nonblock || ret2 != -EAGAIN) {",
          "1978:    kiocb_done(kiocb, ret2, nxt, req->in_async);",
          "1979:   } else {",
          "1981:    ret = io_setup_async_rw(req, io_size, iovec,",
          "1982:       inline_vecs, &iter);",
          "1983:    if (ret)",
          "1984:     goto out_free;",
          "1986:   }",
          "1989:  if (!io_wq_current_is_worker())",
          "1997: static int io_nop(struct io_kiocb *req)",
          "1999:  struct io_ring_ctx *ctx = req->ctx;",
          "2001:  if (unlikely(ctx->flags & IORING_SETUP_IOPOLL))",
          "2004:  io_cqring_add_event(req, 0);",
          "2005:  io_put_req(req);",
          "2006:  return 0;",
          "2007: }",
          "2009: static int io_prep_fsync(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "2010: {",
          "2011:  struct io_ring_ctx *ctx = req->ctx;",
          "2013:  if (!req->file)",
          "2016:  if (unlikely(ctx->flags & IORING_SETUP_IOPOLL))",
          "2017:   return -EINVAL;",
          "2018:  if (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index))",
          "2019:   return -EINVAL;",
          "2021:  req->sync.flags = READ_ONCE(sqe->fsync_flags);",
          "2022:  if (unlikely(req->sync.flags & ~IORING_FSYNC_DATASYNC))",
          "2023:   return -EINVAL;",
          "2025:  req->sync.off = READ_ONCE(sqe->off);",
          "2026:  req->sync.len = READ_ONCE(sqe->len);",
          "2030: static bool io_req_cancelled(struct io_kiocb *req)",
          "2032:  if (req->work.flags & IO_WQ_WORK_CANCEL) {",
          "2033:   req_set_fail_links(req);",
          "2034:   io_cqring_add_event(req, -ECANCELED);",
          "2035:   io_put_req(req);",
          "2036:   return true;",
          "2037:  }",
          "2039:  return false;",
          "2042: static void io_link_work_cb(struct io_wq_work **workptr)",
          "2044:  struct io_wq_work *work = *workptr;",
          "2045:  struct io_kiocb *link = work->data;",
          "2047:  io_queue_linked_timeout(link);",
          "2048:  work->func = io_wq_submit_work;",
          "2051: static void io_wq_assign_next(struct io_wq_work **workptr, struct io_kiocb *nxt)",
          "2053:  struct io_kiocb *link;",
          "2055:  io_prep_async_work(nxt, &link);",
          "2057:  if (link) {",
          "2058:   nxt->work.flags |= IO_WQ_WORK_CB;",
          "2059:   nxt->work.func = io_link_work_cb;",
          "2060:   nxt->work.data = link;",
          "2061:  }",
          "2064: static void io_fsync_finish(struct io_wq_work **workptr)",
          "2066:  struct io_kiocb *req = container_of(*workptr, struct io_kiocb, work);",
          "2067:  loff_t end = req->sync.off + req->sync.len;",
          "2068:  struct io_kiocb *nxt = NULL;",
          "2069:  int ret;",
          "2071:  if (io_req_cancelled(req))",
          "2072:   return;",
          "2074:  ret = vfs_fsync_range(req->file, req->sync.off,",
          "2075:     end > 0 ? end : LLONG_MAX,",
          "2076:     req->sync.flags & IORING_FSYNC_DATASYNC);",
          "2077:  if (ret < 0)",
          "2079:  io_cqring_add_event(req, ret);",
          "2080:  io_put_req_find_next(req, &nxt);",
          "2081:  if (nxt)",
          "2082:   io_wq_assign_next(workptr, nxt);",
          "2085: static int io_fsync(struct io_kiocb *req, struct io_kiocb **nxt,",
          "2086:       bool force_nonblock)",
          "2088:  struct io_wq_work *work, *old_work;",
          "2091:  if (force_nonblock) {",
          "2092:   io_put_req(req);",
          "2093:   req->work.func = io_fsync_finish;",
          "2094:   return -EAGAIN;",
          "2095:  }",
          "2097:  work = old_work = &req->work;",
          "2098:  io_fsync_finish(&work);",
          "2099:  if (work && work != old_work)",
          "2104: static int io_prep_sfr(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "",
          "[Added Lines]",
          "3184:   req->rw.len -= nr;",
          "3185:   req->rw.addr += nr;",
          "3192: static void io_req_map_rw(struct io_kiocb *req, const struct iovec *iovec,",
          "3193:      const struct iovec *fast_iov, struct iov_iter *iter)",
          "3195:  struct io_async_rw *rw = req->async_data;",
          "3197:  memcpy(&rw->iter, iter, sizeof(*iter));",
          "3198:  rw->free_iovec = iovec;",
          "3199:  rw->bytes_done = 0;",
          "3201:  if (iov_iter_is_bvec(iter))",
          "3202:   return;",
          "3203:  if (!iovec) {",
          "3204:   unsigned iov_off = 0;",
          "3206:   rw->iter.iov = rw->fast_iov;",
          "3207:   if (iter->iov != fast_iov) {",
          "3208:    iov_off = iter->iov - fast_iov;",
          "3209:    rw->iter.iov += iov_off;",
          "3210:   }",
          "3211:   if (rw->fast_iov != fast_iov)",
          "3212:    memcpy(rw->fast_iov + iov_off, fast_iov + iov_off,",
          "3213:           sizeof(struct iovec) * iter->nr_segs);",
          "3214:  } else {",
          "3215:   req->flags |= REQ_F_NEED_CLEANUP;",
          "3219: static inline int __io_alloc_async_data(struct io_kiocb *req)",
          "3221:  WARN_ON_ONCE(!io_op_defs[req->opcode].async_size);",
          "3222:  req->async_data = kmalloc(io_op_defs[req->opcode].async_size, GFP_KERNEL);",
          "3223:  return req->async_data == NULL;",
          "3226: static int io_alloc_async_data(struct io_kiocb *req)",
          "3228:  if (!io_op_defs[req->opcode].needs_async_data)",
          "3229:   return 0;",
          "3231:  return  __io_alloc_async_data(req);",
          "3234: static int io_setup_async_rw(struct io_kiocb *req, const struct iovec *iovec,",
          "3235:         const struct iovec *fast_iov,",
          "3236:         struct iov_iter *iter, bool force)",
          "3238:  if (!force && !io_op_defs[req->opcode].needs_async_data)",
          "3240:  if (!req->async_data) {",
          "3241:   if (__io_alloc_async_data(req))",
          "3242:    return -ENOMEM;",
          "3244:   io_req_map_rw(req, iovec, fast_iov, iter);",
          "3245:  }",
          "3249: static inline int io_rw_prep_async(struct io_kiocb *req, int rw)",
          "3250: {",
          "3251:  struct io_async_rw *iorw = req->async_data;",
          "3252:  struct iovec *iov = iorw->fast_iov;",
          "3253:  ssize_t ret;",
          "3255:  ret = __io_import_iovec(rw, req, &iov, &iorw->iter, false);",
          "3256:  if (unlikely(ret < 0))",
          "3257:   return ret;",
          "3259:  iorw->bytes_done = 0;",
          "3260:  iorw->free_iovec = iov;",
          "3261:  if (iov)",
          "3262:   req->flags |= REQ_F_NEED_CLEANUP;",
          "3263:  return 0;",
          "3264: }",
          "3266: static int io_read_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3270:  ret = io_prep_rw(req, sqe);",
          "3278:  if (!req->async_data)",
          "3280:  return io_rw_prep_async(req, READ);",
          "3281: }",
          "3293: static int io_async_buf_func(struct wait_queue_entry *wait, unsigned mode,",
          "3294:         int sync, void *arg)",
          "3295: {",
          "3296:  struct wait_page_queue *wpq;",
          "3297:  struct io_kiocb *req = wait->private;",
          "3298:  struct wait_page_key *key = arg;",
          "3299:  int ret;",
          "3301:  wpq = container_of(wait, struct wait_page_queue, wait);",
          "3303:  if (!wake_page_match(wpq, key))",
          "3304:   return 0;",
          "3306:  req->rw.kiocb.ki_flags &= ~IOCB_WAITQ;",
          "3307:  list_del_init(&wait->entry);",
          "3309:  init_task_work(&req->task_work, io_req_task_submit);",
          "3310:  percpu_ref_get(&req->ctx->refs);",
          "3313:  refcount_inc(&req->refs);",
          "3314:  ret = io_req_task_work_add(req, true);",
          "3315:  if (unlikely(ret)) {",
          "3316:   struct task_struct *tsk;",
          "3319:   init_task_work(&req->task_work, io_req_task_cancel);",
          "3320:   tsk = io_wq_get_task(req->ctx->io_wq);",
          "3321:   task_work_add(tsk, &req->task_work, TWA_NONE);",
          "3322:   wake_up_process(tsk);",
          "3323:  }",
          "3324:  return 1;",
          "3325: }",
          "3339: static bool io_rw_should_retry(struct io_kiocb *req)",
          "3340: {",
          "3341:  struct io_async_rw *rw = req->async_data;",
          "3342:  struct wait_page_queue *wait = &rw->wpq;",
          "3343:  struct kiocb *kiocb = &req->rw.kiocb;",
          "3346:  if (req->flags & REQ_F_NOWAIT)",
          "3347:   return false;",
          "3350:  if (kiocb->ki_flags & (IOCB_DIRECT | IOCB_HIPRI))",
          "3351:   return false;",
          "3357:  if (file_can_poll(req->file) || !(req->file->f_mode & FMODE_BUF_RASYNC))",
          "3358:   return false;",
          "3360:  wait->wait.func = io_async_buf_func;",
          "3361:  wait->wait.private = req;",
          "3362:  wait->wait.flags = 0;",
          "3363:  INIT_LIST_HEAD(&wait->wait.entry);",
          "3364:  kiocb->ki_flags |= IOCB_WAITQ;",
          "3365:  kiocb->ki_flags &= ~IOCB_NOWAIT;",
          "3366:  kiocb->ki_waitq = wait;",
          "3367:  return true;",
          "3368: }",
          "3370: static int io_iter_do_read(struct io_kiocb *req, struct iov_iter *iter)",
          "3371: {",
          "3372:  if (req->file->f_op->read_iter)",
          "3373:   return call_read_iter(req->file, &req->rw.kiocb, iter);",
          "3374:  else if (req->file->f_op->read)",
          "3375:   return loop_rw_iter(READ, req, iter);",
          "3376:  else",
          "3377:   return -EINVAL;",
          "3380: static int io_read(struct io_kiocb *req, bool force_nonblock,",
          "3381:      struct io_comp_state *cs)",
          "3385:  struct iov_iter __iter, *iter = &__iter;",
          "3386:  struct io_async_rw *rw = req->async_data;",
          "3387:  ssize_t io_size, ret, ret2;",
          "3389:  bool no_async;",
          "3391:  if (rw)",
          "3392:   iter = &rw->iter;",
          "3394:  ret = io_import_iovec(READ, req, &iovec, iter, !force_nonblock);",
          "3397:  iov_count = iov_iter_count(iter);",
          "3398:  io_size = ret;",
          "3399:  req->result = io_size;",
          "3400:  ret = 0;",
          "3404:   kiocb->ki_flags &= ~IOCB_NOWAIT;",
          "3405:  else",
          "3406:   kiocb->ki_flags |= IOCB_NOWAIT;",
          "3410:  no_async = force_nonblock && !io_file_supports_async(req->file, READ);",
          "3411:  if (no_async)",
          "3414:  ret = rw_verify_area(READ, req->file, io_kiocb_ppos(kiocb), iov_count);",
          "3415:  if (unlikely(ret))",
          "3416:   goto out_free;",
          "3418:  ret = io_iter_do_read(req, iter);",
          "3421:   goto done;",
          "3422:  } else if (ret == -EIOCBQUEUED) {",
          "3423:   ret = 0;",
          "3424:   goto out_free;",
          "3425:  } else if (ret == -EAGAIN) {",
          "3427:   if (!force_nonblock && !(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "3428:    goto done;",
          "3430:   if (req->file->f_flags & O_NONBLOCK)",
          "3431:    goto done;",
          "3433:   iov_iter_revert(iter, iov_count - iov_iter_count(iter));",
          "3434:   ret = 0;",
          "3435:   goto copy_iov;",
          "3436:  } else if (ret < 0) {",
          "3438:   goto done;",
          "3439:  }",
          "3442:  if (!iov_iter_count(iter) || !force_nonblock ||",
          "3443:      (req->file->f_flags & O_NONBLOCK))",
          "3444:   goto done;",
          "3446:  io_size -= ret;",
          "3448:  ret2 = io_setup_async_rw(req, iovec, inline_vecs, iter, true);",
          "3449:  if (ret2) {",
          "3450:   ret = ret2;",
          "3451:   goto out_free;",
          "3452:  }",
          "3453:  if (no_async)",
          "3454:   return -EAGAIN;",
          "3455:  rw = req->async_data;",
          "3457:  iovec = NULL;",
          "3459:  iter = &rw->iter;",
          "3460: retry:",
          "3461:  rw->bytes_done += ret;",
          "3463:  if (!io_rw_should_retry(req)) {",
          "3464:   kiocb->ki_flags &= ~IOCB_WAITQ;",
          "3465:   return -EAGAIN;",
          "3466:  }",
          "3474:  ret = io_iter_do_read(req, iter);",
          "3475:  if (ret == -EIOCBQUEUED) {",
          "3476:   ret = 0;",
          "3477:   goto out_free;",
          "3478:  } else if (ret > 0 && ret < io_size) {",
          "3480:   goto retry;",
          "3482: done:",
          "3483:  kiocb_done(kiocb, ret, cs);",
          "3484:  ret = 0;",
          "3487:  if (iovec)",
          "3492: static int io_write_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3496:  ret = io_prep_rw(req, sqe);",
          "3504:  if (!req->async_data)",
          "3506:  return io_rw_prep_async(req, WRITE);",
          "3509: static int io_write(struct io_kiocb *req, bool force_nonblock,",
          "3510:       struct io_comp_state *cs)",
          "3514:  struct iov_iter __iter, *iter = &__iter;",
          "3515:  struct io_async_rw *rw = req->async_data;",
          "3517:  ssize_t ret, ret2, io_size;",
          "3519:  if (rw)",
          "3520:   iter = &rw->iter;",
          "3522:  ret = io_import_iovec(WRITE, req, &iovec, iter, !force_nonblock);",
          "3525:  iov_count = iov_iter_count(iter);",
          "3526:  io_size = ret;",
          "3527:  req->result = io_size;",
          "3531:   kiocb->ki_flags &= ~IOCB_NOWAIT;",
          "3532:  else",
          "3533:   kiocb->ki_flags |= IOCB_NOWAIT;",
          "3536:  if (force_nonblock && !io_file_supports_async(req->file, WRITE))",
          "3544:  ret = rw_verify_area(WRITE, req->file, io_kiocb_ppos(kiocb), iov_count);",
          "3545:  if (unlikely(ret))",
          "3546:   goto out_free;",
          "3555:  if (req->flags & REQ_F_ISREG) {",
          "3556:   sb_start_write(file_inode(req->file)->i_sb);",
          "3557:   __sb_writers_release(file_inode(req->file)->i_sb,",
          "3558:      SB_FREEZE_WRITE);",
          "3559:  }",
          "3560:  kiocb->ki_flags |= IOCB_WRITE;",
          "3562:  if (req->file->f_op->write_iter)",
          "3563:   ret2 = call_write_iter(req->file, kiocb, iter);",
          "3564:  else if (req->file->f_op->write)",
          "3565:   ret2 = loop_rw_iter(WRITE, req, iter);",
          "3566:  else",
          "3567:   ret2 = -EINVAL;",
          "3573:  if (ret2 == -EOPNOTSUPP && (kiocb->ki_flags & IOCB_NOWAIT))",
          "3574:   ret2 = -EAGAIN;",
          "3576:  if (ret2 == -EAGAIN && (req->file->f_flags & O_NONBLOCK))",
          "3577:   goto done;",
          "3578:  if (!force_nonblock || ret2 != -EAGAIN) {",
          "3580:   if ((req->ctx->flags & IORING_SETUP_IOPOLL) && ret2 == -EAGAIN)",
          "3581:    goto copy_iov;",
          "3582: done:",
          "3583:   kiocb_done(kiocb, ret2, cs);",
          "3584:  } else {",
          "3587:   iov_iter_revert(iter, iov_count - iov_iter_count(iter));",
          "3588:   ret = io_setup_async_rw(req, iovec, inline_vecs, iter, false);",
          "3589:   if (!ret)",
          "3594:  if (iovec)",
          "3599: static int __io_splice_prep(struct io_kiocb *req,",
          "3600:        const struct io_uring_sqe *sqe)",
          "3602:  struct io_splice* sp = &req->splice;",
          "3603:  unsigned int valid_flags = SPLICE_F_FD_IN_FIXED | SPLICE_F_ALL;",
          "3605:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "3608:  sp->file_in = NULL;",
          "3609:  sp->len = READ_ONCE(sqe->len);",
          "3610:  sp->flags = READ_ONCE(sqe->splice_flags);",
          "3612:  if (unlikely(sp->flags & ~valid_flags))",
          "3613:   return -EINVAL;",
          "3615:  sp->file_in = io_file_get(NULL, req, READ_ONCE(sqe->splice_fd_in),",
          "3616:       (sp->flags & SPLICE_F_FD_IN_FIXED));",
          "3617:  if (!sp->file_in)",
          "3619:  req->flags |= REQ_F_NEED_CLEANUP;",
          "3621:  if (!S_ISREG(file_inode(sp->file_in)->i_mode)) {",
          "3626:   io_req_init_async(req);",
          "3627:   req->work.flags |= IO_WQ_WORK_UNBOUND;",
          "3628:  }",
          "3633: static int io_tee_prep(struct io_kiocb *req,",
          "3634:          const struct io_uring_sqe *sqe)",
          "3636:  if (READ_ONCE(sqe->splice_off_in) || READ_ONCE(sqe->off))",
          "3637:   return -EINVAL;",
          "3638:  return __io_splice_prep(req, sqe);",
          "3641: static int io_tee(struct io_kiocb *req, bool force_nonblock)",
          "3643:  struct io_splice *sp = &req->splice;",
          "3644:  struct file *in = sp->file_in;",
          "3645:  struct file *out = sp->file_out;",
          "3646:  unsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;",
          "3647:  long ret = 0;",
          "3649:  if (force_nonblock)",
          "3650:   return -EAGAIN;",
          "3651:  if (sp->len)",
          "3652:   ret = do_tee(in, out, sp->len, flags);",
          "3654:  io_put_file(req, in, (sp->flags & SPLICE_F_FD_IN_FIXED));",
          "3655:  req->flags &= ~REQ_F_NEED_CLEANUP;",
          "3657:  if (ret != sp->len)",
          "3658:   req_set_fail_links(req);",
          "3659:  io_req_complete(req, ret);",
          "3660:  return 0;",
          "3663: static int io_splice_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3665:  struct io_splice* sp = &req->splice;",
          "3667:  sp->off_in = READ_ONCE(sqe->splice_off_in);",
          "3668:  sp->off_out = READ_ONCE(sqe->off);",
          "3669:  return __io_splice_prep(req, sqe);",
          "3672: static int io_splice(struct io_kiocb *req, bool force_nonblock)",
          "3674:  struct io_splice *sp = &req->splice;",
          "3675:  struct file *in = sp->file_in;",
          "3676:  struct file *out = sp->file_out;",
          "3677:  unsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED;",
          "3678:  loff_t *poff_in, *poff_out;",
          "3679:  long ret = 0;",
          "3681:  if (force_nonblock)",
          "3682:   return -EAGAIN;",
          "3684:  poff_in = (sp->off_in == -1) ? NULL : &sp->off_in;",
          "3685:  poff_out = (sp->off_out == -1) ? NULL : &sp->off_out;",
          "3687:  if (sp->len)",
          "3688:   ret = do_splice(in, poff_in, out, poff_out, sp->len, flags);",
          "3690:  io_put_file(req, in, (sp->flags & SPLICE_F_FD_IN_FIXED));",
          "3691:  req->flags &= ~REQ_F_NEED_CLEANUP;",
          "3693:  if (ret != sp->len)",
          "3695:  io_req_complete(req, ret);",
          "3696:  return 0;",
          "3702: static int io_nop(struct io_kiocb *req, struct io_comp_state *cs)",
          "3704:  struct io_ring_ctx *ctx = req->ctx;",
          "3706:  if (unlikely(ctx->flags & IORING_SETUP_IOPOLL))",
          "3707:   return -EINVAL;",
          "3709:  __io_req_complete(req, 0, 0, cs);",
          "3713: static int io_prep_fsync(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2113:  if (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index))",
          "2114:   return -EINVAL;",
          "2116:  req->sync.off = READ_ONCE(sqe->off);",
          "2117:  req->sync.len = READ_ONCE(sqe->len);",
          "2119:  return 0;",
          "2120: }",
          "2123: {",
          "2126:  int ret;",
          "2133:  if (ret < 0)",
          "2134:   req_set_fail_links(req);",
          "2139: }",
          "2143: {",
          "2157:  return 0;",
          "2158: }",
          "2162: {",
          "2170: }",
          "2174: {",
          "2191: }",
          "2195: {",
          "2199:  int ret;",
          "2202:   return -EINVAL;",
          "2245:   }",
          "2248:  }",
          "2253:  if (ret < 0)",
          "2254:   req_set_fail_links(req);",
          "2256:  return 0;",
          "2260: }",
          "2264: {",
          "2273:   return 0;",
          "2281: }",
          "2285: {",
          "2292:   return -EINVAL;",
          "2337:   }",
          "2340:  }",
          "2345:  if (ret < 0)",
          "2346:   req_set_fail_links(req);",
          "2348:  return 0;",
          "2352: }",
          "2355: {",
          "2360:   return -EINVAL;",
          "2362:   return -EINVAL;",
          "2367:  return 0;",
          "2368: #else",
          "2369:  return -EOPNOTSUPP;",
          "2370: #endif",
          "2371: }",
          "2376: {",
          "2379:  int ret;",
          "2385:   return -EAGAIN;",
          "2388:  if (ret < 0)",
          "2389:   req_set_fail_links(req);",
          "2392:  return 0;",
          "2393: }",
          "2396: {",
          "2406: #endif",
          "2410: {",
          "2412:  int ret;",
          "2419:   return -EAGAIN;",
          "2421:  return 0;",
          "2422: #else",
          "2423:  return -EOPNOTSUPP;",
          "2424: #endif",
          "2425: }",
          "2428: {",
          "2434:   return -EINVAL;",
          "2436:   return -EINVAL;",
          "2449: }",
          "2453: {",
          "2457:  int ret;",
          "2476:    return -EAGAIN;",
          "2480:   }",
          "2483:  }",
          "2487:  if (ret < 0)",
          "2488:   req_set_fail_links(req);",
          "2491:  return 0;",
          "2495: }",
          "2498: {",
          "2506:  }",
          "2509: }",
          "2512: {",
          "2526: }",
          "2529: {",
          "2539:  }",
          "2542: }",
          "2546: {",
          "2548:   return -EINVAL;",
          "2551:   return -EINVAL;",
          "2554:  return 0;",
          "2555: }",
          "2562: {",
          "2565:  int ret;",
          "2573:  if (ret < 0)",
          "2574:   req_set_fail_links(req);",
          "2576:  return 0;",
          "2577: }",
          "2580: {",
          "2589: }",
          "2592: {",
          "2624:  }",
          "2631:  if (ret < 0)",
          "2632:   req_set_fail_links(req);",
          "2636: }",
          "2640: {",
          "2672: }",
          "2682: {",
          "2693: }",
          "2696: {",
          "2702: }",
          "2704: static int io_poll_add_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "2705: {",
          "2706:  struct io_poll_iocb *poll = &req->poll;",
          "2709:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "2710:   return -EINVAL;",
          "2711:  if (sqe->addr || sqe->ioprio || sqe->off || sqe->len || sqe->buf_index)",
          "2712:   return -EINVAL;",
          "2718:  return 0;",
          "2719: }",
          "2722: {",
          "2723:  struct io_poll_iocb *poll = &req->poll;",
          "2724:  struct io_ring_ctx *ctx = req->ctx;",
          "2725:  struct io_poll_table ipt;",
          "2727:  __poll_t mask;",
          "2736:  ipt.pt._qproc = io_poll_queue_proc;",
          "2768:   ipt.error = 0;",
          "2769:   io_poll_complete(req, mask, 0);",
          "",
          "[Removed Lines]",
          "2118:  req->sync.flags = READ_ONCE(sqe->sync_range_flags);",
          "2122: static void io_sync_file_range_finish(struct io_wq_work **workptr)",
          "2124:  struct io_kiocb *req = container_of(*workptr, struct io_kiocb, work);",
          "2125:  struct io_kiocb *nxt = NULL;",
          "2128:  if (io_req_cancelled(req))",
          "2129:   return;",
          "2131:  ret = sync_file_range(req->file, req->sync.off, req->sync.len,",
          "2132:     req->sync.flags);",
          "2135:  io_cqring_add_event(req, ret);",
          "2136:  io_put_req_find_next(req, &nxt);",
          "2137:  if (nxt)",
          "2138:   io_wq_assign_next(workptr, nxt);",
          "2141: static int io_sync_file_range(struct io_kiocb *req, struct io_kiocb **nxt,",
          "2142:          bool force_nonblock)",
          "2144:  struct io_wq_work *work, *old_work;",
          "2147:  if (force_nonblock) {",
          "2148:   io_put_req(req);",
          "2149:   req->work.func = io_sync_file_range_finish;",
          "2150:   return -EAGAIN;",
          "2151:  }",
          "2153:  work = old_work = &req->work;",
          "2154:  io_sync_file_range_finish(&work);",
          "2155:  if (work && work != old_work)",
          "2160: #if defined(CONFIG_NET)",
          "2161: static void io_sendrecv_async(struct io_wq_work **workptr)",
          "2163:  struct io_kiocb *req = container_of(*workptr, struct io_kiocb, work);",
          "2164:  struct iovec *iov = NULL;",
          "2166:  if (req->io->rw.iov != req->io->rw.fast_iov)",
          "2167:   iov = req->io->msg.iov;",
          "2168:  io_wq_submit_work(workptr);",
          "2169:  kfree(iov);",
          "2171: #endif",
          "2173: static int io_sendmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "2175: #if defined(CONFIG_NET)",
          "2176:  struct io_sr_msg *sr = &req->sr_msg;",
          "2177:  struct io_async_ctx *io = req->io;",
          "2179:  sr->msg_flags = READ_ONCE(sqe->msg_flags);",
          "2180:  sr->msg = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "2182:  if (!io)",
          "2183:   return 0;",
          "2185:  io->msg.iov = io->msg.fast_iov;",
          "2186:  return sendmsg_copy_msghdr(&io->msg.msg, sr->msg, sr->msg_flags,",
          "2187:      &io->msg.iov);",
          "2188: #else",
          "2189:  return -EOPNOTSUPP;",
          "2190: #endif",
          "2193: static int io_sendmsg(struct io_kiocb *req, struct io_kiocb **nxt,",
          "2194:         bool force_nonblock)",
          "2196: #if defined(CONFIG_NET)",
          "2197:  struct io_async_msghdr *kmsg = NULL;",
          "2198:  struct socket *sock;",
          "2201:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "2204:  sock = sock_from_file(req->file, &ret);",
          "2205:  if (sock) {",
          "2206:   struct io_async_ctx io;",
          "2207:   struct sockaddr_storage addr;",
          "2208:   unsigned flags;",
          "2210:   if (req->io) {",
          "2211:    kmsg = &req->io->msg;",
          "2212:    kmsg->msg.msg_name = &addr;",
          "2214:    if (!kmsg->iov)",
          "2215:     kmsg->iov = kmsg->fast_iov;",
          "2216:    kmsg->msg.msg_iter.iov = kmsg->iov;",
          "2217:   } else {",
          "2218:    struct io_sr_msg *sr = &req->sr_msg;",
          "2220:    kmsg = &io.msg;",
          "2221:    kmsg->msg.msg_name = &addr;",
          "2223:    io.msg.iov = io.msg.fast_iov;",
          "2224:    ret = sendmsg_copy_msghdr(&io.msg.msg, sr->msg,",
          "2225:      sr->msg_flags, &io.msg.iov);",
          "2226:    if (ret)",
          "2227:     return ret;",
          "2228:   }",
          "2230:   flags = req->sr_msg.msg_flags;",
          "2231:   if (flags & MSG_DONTWAIT)",
          "2232:    req->flags |= REQ_F_NOWAIT;",
          "2233:   else if (force_nonblock)",
          "2234:    flags |= MSG_DONTWAIT;",
          "2236:   ret = __sys_sendmsg_sock(sock, &kmsg->msg, flags);",
          "2237:   if (force_nonblock && ret == -EAGAIN) {",
          "2238:    if (req->io)",
          "2239:     return -EAGAIN;",
          "2240:    if (io_alloc_async_ctx(req))",
          "2241:     return -ENOMEM;",
          "2242:    memcpy(&req->io->msg, &io.msg, sizeof(io.msg));",
          "2243:    req->work.func = io_sendrecv_async;",
          "2244:    return -EAGAIN;",
          "2246:   if (ret == -ERESTARTSYS)",
          "2247:    ret = -EINTR;",
          "2250:  if (!io_wq_current_is_worker() && kmsg && kmsg->iov != kmsg->fast_iov)",
          "2251:   kfree(kmsg->iov);",
          "2252:  io_cqring_add_event(req, ret);",
          "2255:  io_put_req_find_next(req, nxt);",
          "2257: #else",
          "2258:  return -EOPNOTSUPP;",
          "2259: #endif",
          "2262: static int io_recvmsg_prep(struct io_kiocb *req,",
          "2263:       const struct io_uring_sqe *sqe)",
          "2265: #if defined(CONFIG_NET)",
          "2266:  struct io_sr_msg *sr = &req->sr_msg;",
          "2267:  struct io_async_ctx *io = req->io;",
          "2269:  sr->msg_flags = READ_ONCE(sqe->msg_flags);",
          "2270:  sr->msg = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "2272:  if (!io)",
          "2275:  io->msg.iov = io->msg.fast_iov;",
          "2276:  return recvmsg_copy_msghdr(&io->msg.msg, sr->msg, sr->msg_flags,",
          "2277:      &io->msg.uaddr, &io->msg.iov);",
          "2278: #else",
          "2279:  return -EOPNOTSUPP;",
          "2280: #endif",
          "2283: static int io_recvmsg(struct io_kiocb *req, struct io_kiocb **nxt,",
          "2284:         bool force_nonblock)",
          "2286: #if defined(CONFIG_NET)",
          "2287:  struct io_async_msghdr *kmsg = NULL;",
          "2288:  struct socket *sock;",
          "2289:  int ret;",
          "2291:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "2294:  sock = sock_from_file(req->file, &ret);",
          "2295:  if (sock) {",
          "2296:   struct io_async_ctx io;",
          "2297:   struct sockaddr_storage addr;",
          "2298:   unsigned flags;",
          "2300:   if (req->io) {",
          "2301:    kmsg = &req->io->msg;",
          "2302:    kmsg->msg.msg_name = &addr;",
          "2304:    if (!kmsg->iov)",
          "2305:     kmsg->iov = kmsg->fast_iov;",
          "2306:    kmsg->msg.msg_iter.iov = kmsg->iov;",
          "2307:   } else {",
          "2308:    struct io_sr_msg *sr = &req->sr_msg;",
          "2310:    kmsg = &io.msg;",
          "2311:    kmsg->msg.msg_name = &addr;",
          "2313:    io.msg.iov = io.msg.fast_iov;",
          "2314:    ret = recvmsg_copy_msghdr(&io.msg.msg, sr->msg,",
          "2315:      sr->msg_flags, &io.msg.uaddr,",
          "2316:      &io.msg.iov);",
          "2317:    if (ret)",
          "2318:     return ret;",
          "2319:   }",
          "2321:   flags = req->sr_msg.msg_flags;",
          "2322:   if (flags & MSG_DONTWAIT)",
          "2323:    req->flags |= REQ_F_NOWAIT;",
          "2324:   else if (force_nonblock)",
          "2325:    flags |= MSG_DONTWAIT;",
          "2327:   ret = __sys_recvmsg_sock(sock, &kmsg->msg, req->sr_msg.msg,",
          "2328:       kmsg->uaddr, flags);",
          "2329:   if (force_nonblock && ret == -EAGAIN) {",
          "2330:    if (req->io)",
          "2331:     return -EAGAIN;",
          "2332:    if (io_alloc_async_ctx(req))",
          "2333:     return -ENOMEM;",
          "2334:    memcpy(&req->io->msg, &io.msg, sizeof(io.msg));",
          "2335:    req->work.func = io_sendrecv_async;",
          "2336:    return -EAGAIN;",
          "2338:   if (ret == -ERESTARTSYS)",
          "2339:    ret = -EINTR;",
          "2342:  if (!io_wq_current_is_worker() && kmsg && kmsg->iov != kmsg->fast_iov)",
          "2343:   kfree(kmsg->iov);",
          "2344:  io_cqring_add_event(req, ret);",
          "2347:  io_put_req_find_next(req, nxt);",
          "2349: #else",
          "2350:  return -EOPNOTSUPP;",
          "2351: #endif",
          "2354: static int io_accept_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "2356: #if defined(CONFIG_NET)",
          "2357:  struct io_accept *accept = &req->accept;",
          "2359:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL|IORING_SETUP_SQPOLL)))",
          "2361:  if (sqe->ioprio || sqe->len || sqe->buf_index)",
          "2364:  accept->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "2365:  accept->addr_len = u64_to_user_ptr(READ_ONCE(sqe->addr2));",
          "2366:  accept->flags = READ_ONCE(sqe->accept_flags);",
          "2373: #if defined(CONFIG_NET)",
          "2374: static int __io_accept(struct io_kiocb *req, struct io_kiocb **nxt,",
          "2375:          bool force_nonblock)",
          "2377:  struct io_accept *accept = &req->accept;",
          "2378:  unsigned file_flags;",
          "2381:  file_flags = force_nonblock ? O_NONBLOCK : 0;",
          "2382:  ret = __sys_accept4_file(req->file, file_flags, accept->addr,",
          "2383:      accept->addr_len, accept->flags);",
          "2384:  if (ret == -EAGAIN && force_nonblock)",
          "2386:  if (ret == -ERESTARTSYS)",
          "2387:   ret = -EINTR;",
          "2390:  io_cqring_add_event(req, ret);",
          "2391:  io_put_req_find_next(req, nxt);",
          "2395: static void io_accept_finish(struct io_wq_work **workptr)",
          "2397:  struct io_kiocb *req = container_of(*workptr, struct io_kiocb, work);",
          "2398:  struct io_kiocb *nxt = NULL;",
          "2400:  if (io_req_cancelled(req))",
          "2401:   return;",
          "2402:  __io_accept(req, &nxt, false);",
          "2403:  if (nxt)",
          "2404:   io_wq_assign_next(workptr, nxt);",
          "2405: }",
          "2408: static int io_accept(struct io_kiocb *req, struct io_kiocb **nxt,",
          "2409:        bool force_nonblock)",
          "2411: #if defined(CONFIG_NET)",
          "2414:  ret = __io_accept(req, nxt, force_nonblock);",
          "2415:  if (ret == -EAGAIN && force_nonblock) {",
          "2416:   req->work.func = io_accept_finish;",
          "2417:   req->work.flags |= IO_WQ_WORK_NEEDS_FILES;",
          "2418:   io_put_req(req);",
          "2420:  }",
          "2427: static int io_connect_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "2429: #if defined(CONFIG_NET)",
          "2430:  struct io_connect *conn = &req->connect;",
          "2431:  struct io_async_ctx *io = req->io;",
          "2433:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL|IORING_SETUP_SQPOLL)))",
          "2435:  if (sqe->ioprio || sqe->len || sqe->buf_index || sqe->rw_flags)",
          "2438:  conn->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "2439:  conn->addr_len =  READ_ONCE(sqe->addr2);",
          "2441:  if (!io)",
          "2442:   return 0;",
          "2444:  return move_addr_to_kernel(conn->addr, conn->addr_len,",
          "2445:      &io->connect.address);",
          "2446: #else",
          "2447:  return -EOPNOTSUPP;",
          "2448: #endif",
          "2451: static int io_connect(struct io_kiocb *req, struct io_kiocb **nxt,",
          "2452:         bool force_nonblock)",
          "2454: #if defined(CONFIG_NET)",
          "2455:  struct io_async_ctx __io, *io;",
          "2456:  unsigned file_flags;",
          "2459:  if (req->io) {",
          "2460:   io = req->io;",
          "2461:  } else {",
          "2462:   ret = move_addr_to_kernel(req->connect.addr,",
          "2463:       req->connect.addr_len,",
          "2464:       &__io.connect.address);",
          "2465:   if (ret)",
          "2466:    goto out;",
          "2467:   io = &__io;",
          "2468:  }",
          "2470:  file_flags = force_nonblock ? O_NONBLOCK : 0;",
          "2472:  ret = __sys_connect_file(req->file, &io->connect.address,",
          "2473:      req->connect.addr_len, file_flags);",
          "2474:  if ((ret == -EAGAIN || ret == -EINPROGRESS) && force_nonblock) {",
          "2475:   if (req->io)",
          "2477:   if (io_alloc_async_ctx(req)) {",
          "2478:    ret = -ENOMEM;",
          "2479:    goto out;",
          "2481:   memcpy(&req->io->connect, &__io.connect, sizeof(__io.connect));",
          "2482:   return -EAGAIN;",
          "2484:  if (ret == -ERESTARTSYS)",
          "2485:   ret = -EINTR;",
          "2486: out:",
          "2489:  io_cqring_add_event(req, ret);",
          "2490:  io_put_req_find_next(req, nxt);",
          "2492: #else",
          "2493:  return -EOPNOTSUPP;",
          "2494: #endif",
          "2497: static void io_poll_remove_one(struct io_kiocb *req)",
          "2499:  struct io_poll_iocb *poll = &req->poll;",
          "2501:  spin_lock(&poll->head->lock);",
          "2502:  WRITE_ONCE(poll->canceled, true);",
          "2503:  if (!list_empty(&poll->wait.entry)) {",
          "2504:   list_del_init(&poll->wait.entry);",
          "2505:   io_queue_async_work(req);",
          "2507:  spin_unlock(&poll->head->lock);",
          "2508:  hash_del(&req->hash_node);",
          "2511: static void io_poll_remove_all(struct io_ring_ctx *ctx)",
          "2513:  struct hlist_node *tmp;",
          "2514:  struct io_kiocb *req;",
          "2515:  int i;",
          "2517:  spin_lock_irq(&ctx->completion_lock);",
          "2518:  for (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {",
          "2519:   struct hlist_head *list;",
          "2521:   list = &ctx->cancel_hash[i];",
          "2522:   hlist_for_each_entry_safe(req, tmp, list, hash_node)",
          "2523:    io_poll_remove_one(req);",
          "2524:  }",
          "2525:  spin_unlock_irq(&ctx->completion_lock);",
          "2528: static int io_poll_cancel(struct io_ring_ctx *ctx, __u64 sqe_addr)",
          "2530:  struct hlist_head *list;",
          "2531:  struct io_kiocb *req;",
          "2533:  list = &ctx->cancel_hash[hash_long(sqe_addr, ctx->cancel_hash_bits)];",
          "2534:  hlist_for_each_entry(req, list, hash_node) {",
          "2535:   if (sqe_addr == req->user_data) {",
          "2536:    io_poll_remove_one(req);",
          "2537:    return 0;",
          "2538:   }",
          "2541:  return -ENOENT;",
          "2544: static int io_poll_remove_prep(struct io_kiocb *req,",
          "2545:           const struct io_uring_sqe *sqe)",
          "2547:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "2549:  if (sqe->ioprio || sqe->off || sqe->len || sqe->buf_index ||",
          "2550:      sqe->poll_events)",
          "2553:  req->poll.addr = READ_ONCE(sqe->addr);",
          "2561: static int io_poll_remove(struct io_kiocb *req)",
          "2563:  struct io_ring_ctx *ctx = req->ctx;",
          "2564:  u64 addr;",
          "2567:  addr = req->poll.addr;",
          "2568:  spin_lock_irq(&ctx->completion_lock);",
          "2569:  ret = io_poll_cancel(ctx, addr);",
          "2570:  spin_unlock_irq(&ctx->completion_lock);",
          "2572:  io_cqring_add_event(req, ret);",
          "2575:  io_put_req(req);",
          "2579: static void io_poll_complete(struct io_kiocb *req, __poll_t mask, int error)",
          "2581:  struct io_ring_ctx *ctx = req->ctx;",
          "2583:  req->poll.done = true;",
          "2584:  if (error)",
          "2585:   io_cqring_fill_event(req, error);",
          "2586:  else",
          "2587:   io_cqring_fill_event(req, mangle_poll(mask));",
          "2588:  io_commit_cqring(ctx);",
          "2591: static void io_poll_complete_work(struct io_wq_work **workptr)",
          "2593:  struct io_wq_work *work = *workptr;",
          "2594:  struct io_kiocb *req = container_of(work, struct io_kiocb, work);",
          "2595:  struct io_poll_iocb *poll = &req->poll;",
          "2596:  struct poll_table_struct pt = { ._key = poll->events };",
          "2597:  struct io_ring_ctx *ctx = req->ctx;",
          "2598:  struct io_kiocb *nxt = NULL;",
          "2599:  __poll_t mask = 0;",
          "2600:  int ret = 0;",
          "2602:  if (work->flags & IO_WQ_WORK_CANCEL) {",
          "2603:   WRITE_ONCE(poll->canceled, true);",
          "2604:   ret = -ECANCELED;",
          "2605:  } else if (READ_ONCE(poll->canceled)) {",
          "2606:   ret = -ECANCELED;",
          "2607:  }",
          "2609:  if (ret != -ECANCELED)",
          "2610:   mask = vfs_poll(poll->file, &pt) & poll->events;",
          "2619:  spin_lock_irq(&ctx->completion_lock);",
          "2620:  if (!mask && ret != -ECANCELED) {",
          "2621:   add_wait_queue(poll->head, &poll->wait);",
          "2622:   spin_unlock_irq(&ctx->completion_lock);",
          "2623:   return;",
          "2625:  hash_del(&req->hash_node);",
          "2626:  io_poll_complete(req, mask, ret);",
          "2627:  spin_unlock_irq(&ctx->completion_lock);",
          "2629:  io_cqring_ev_posted(ctx);",
          "2633:  io_put_req_find_next(req, &nxt);",
          "2634:  if (nxt)",
          "2635:   io_wq_assign_next(workptr, nxt);",
          "2638: static int io_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,",
          "2639:    void *key)",
          "2641:  struct io_poll_iocb *poll = wait->private;",
          "2642:  struct io_kiocb *req = container_of(poll, struct io_kiocb, poll);",
          "2643:  struct io_ring_ctx *ctx = req->ctx;",
          "2644:  __poll_t mask = key_to_poll(key);",
          "2645:  unsigned long flags;",
          "2648:  if (mask && !(mask & poll->events))",
          "2649:   return 0;",
          "2651:  list_del_init(&poll->wait.entry);",
          "2659:  if (mask && spin_trylock_irqsave(&ctx->completion_lock, flags)) {",
          "2660:   hash_del(&req->hash_node);",
          "2661:   io_poll_complete(req, mask, 0);",
          "2662:   req->flags |= REQ_F_COMP_LOCKED;",
          "2663:   io_put_req(req);",
          "2664:   spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "2666:   io_cqring_ev_posted(ctx);",
          "2667:  } else {",
          "2668:   io_queue_async_work(req);",
          "2669:  }",
          "2671:  return 1;",
          "2674: struct io_poll_table {",
          "2675:  struct poll_table_struct pt;",
          "2676:  struct io_kiocb *req;",
          "2677:  int error;",
          "2678: };",
          "2680: static void io_poll_queue_proc(struct file *file, struct wait_queue_head *head,",
          "2681:           struct poll_table_struct *p, unsigned long fixed_event)",
          "2683:  struct io_poll_table *pt = container_of(p, struct io_poll_table, pt);",
          "2685:  if (unlikely(pt->req->poll.head)) {",
          "2686:   pt->error = -EINVAL;",
          "2687:   return;",
          "2688:  }",
          "2690:  pt->error = 0;",
          "2691:  pt->req->poll.head = head;",
          "2692:  add_wait_queue(head, &pt->req->poll.wait);",
          "2695: static void io_poll_req_insert(struct io_kiocb *req)",
          "2697:  struct io_ring_ctx *ctx = req->ctx;",
          "2698:  struct hlist_head *list;",
          "2700:  list = &ctx->cancel_hash[hash_long(req->user_data, ctx->cancel_hash_bits)];",
          "2701:  hlist_add_head(&req->hash_node, list);",
          "2707:  u16 events;",
          "2713:  if (!poll->file)",
          "2714:   return -EBADF;",
          "2716:  events = READ_ONCE(sqe->poll_events);",
          "2717:  poll->events = demangle_poll(events) | EPOLLERR | EPOLLHUP;",
          "2721: static int io_poll_add(struct io_kiocb *req, struct io_kiocb **nxt)",
          "2726:  bool cancel = false;",
          "2729:  INIT_IO_WORK(&req->work, io_poll_complete_work);",
          "2730:  INIT_HLIST_NODE(&req->hash_node);",
          "2732:  poll->head = NULL;",
          "2733:  poll->done = false;",
          "2734:  poll->canceled = false;",
          "2737:  ipt.pt._key = poll->events;",
          "2738:  ipt.req = req;",
          "2742:  INIT_LIST_HEAD(&poll->wait.entry);",
          "2743:  init_waitqueue_func_entry(&poll->wait, io_poll_wake);",
          "2744:  poll->wait.private = poll;",
          "2746:  INIT_LIST_HEAD(&req->list);",
          "2748:  mask = vfs_poll(poll->file, &ipt.pt) & poll->events;",
          "2750:  spin_lock_irq(&ctx->completion_lock);",
          "2751:  if (likely(poll->head)) {",
          "2752:   spin_lock(&poll->head->lock);",
          "2753:   if (unlikely(list_empty(&poll->wait.entry))) {",
          "2754:    if (ipt.error)",
          "2755:     cancel = true;",
          "2756:    ipt.error = 0;",
          "2757:    mask = 0;",
          "2758:   }",
          "2759:   if (mask || ipt.error)",
          "2760:    list_del_init(&poll->wait.entry);",
          "2761:   else if (cancel)",
          "2762:    WRITE_ONCE(poll->canceled, true);",
          "2764:    io_poll_req_insert(req);",
          "2765:   spin_unlock(&poll->head->lock);",
          "2766:  }",
          "",
          "[Added Lines]",
          "3725:  req->sync.flags = READ_ONCE(sqe->fsync_flags);",
          "3726:  if (unlikely(req->sync.flags & ~IORING_FSYNC_DATASYNC))",
          "3727:   return -EINVAL;",
          "3734: static int io_fsync(struct io_kiocb *req, bool force_nonblock)",
          "3736:  loff_t end = req->sync.off + req->sync.len;",
          "3740:  if (force_nonblock)",
          "3741:   return -EAGAIN;",
          "3743:  ret = vfs_fsync_range(req->file, req->sync.off,",
          "3744:     end > 0 ? end : LLONG_MAX,",
          "3745:     req->sync.flags & IORING_FSYNC_DATASYNC);",
          "3748:  io_req_complete(req, ret);",
          "3749:  return 0;",
          "3752: static int io_fallocate_prep(struct io_kiocb *req,",
          "3753:         const struct io_uring_sqe *sqe)",
          "3755:  if (sqe->ioprio || sqe->buf_index || sqe->rw_flags)",
          "3756:   return -EINVAL;",
          "3757:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "3758:   return -EINVAL;",
          "3760:  req->sync.off = READ_ONCE(sqe->off);",
          "3761:  req->sync.len = READ_ONCE(sqe->addr);",
          "3762:  req->sync.mode = READ_ONCE(sqe->len);",
          "3766: static int io_fallocate(struct io_kiocb *req, bool force_nonblock)",
          "3768:  int ret;",
          "3771:  if (force_nonblock)",
          "3772:   return -EAGAIN;",
          "3773:  ret = vfs_fallocate(req->file, req->sync.mode, req->sync.off,",
          "3774:     req->sync.len);",
          "3775:  if (ret < 0)",
          "3776:   req_set_fail_links(req);",
          "3777:  io_req_complete(req, ret);",
          "3778:  return 0;",
          "3781: static int __io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3783:  const char __user *fname;",
          "3784:  int ret;",
          "3786:  if (unlikely(sqe->ioprio || sqe->buf_index))",
          "3787:   return -EINVAL;",
          "3788:  if (unlikely(req->flags & REQ_F_FIXED_FILE))",
          "3789:   return -EBADF;",
          "3792:  if (!(req->open.how.flags & O_PATH) && force_o_largefile())",
          "3793:   req->open.how.flags |= O_LARGEFILE;",
          "3795:  req->open.dfd = READ_ONCE(sqe->fd);",
          "3796:  fname = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "3797:  req->open.filename = getname(fname);",
          "3798:  if (IS_ERR(req->open.filename)) {",
          "3799:   ret = PTR_ERR(req->open.filename);",
          "3800:   req->open.filename = NULL;",
          "3801:   return ret;",
          "3802:  }",
          "3803:  req->open.nofile = rlimit(RLIMIT_NOFILE);",
          "3804:  req->open.ignore_nonblock = false;",
          "3805:  req->flags |= REQ_F_NEED_CLEANUP;",
          "3806:  return 0;",
          "3809: static int io_openat_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3811:  u64 flags, mode;",
          "3813:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL|IORING_SETUP_SQPOLL)))",
          "3814:   return -EINVAL;",
          "3815:  mode = READ_ONCE(sqe->len);",
          "3816:  flags = READ_ONCE(sqe->open_flags);",
          "3817:  req->open.how = build_open_how(flags, mode);",
          "3818:  return __io_openat_prep(req, sqe);",
          "3819: }",
          "3821: static int io_openat2_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3822: {",
          "3823:  struct open_how __user *how;",
          "3824:  size_t len;",
          "3827:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL|IORING_SETUP_SQPOLL)))",
          "3828:   return -EINVAL;",
          "3829:  how = u64_to_user_ptr(READ_ONCE(sqe->addr2));",
          "3830:  len = READ_ONCE(sqe->len);",
          "3831:  if (len < OPEN_HOW_SIZE_VER0)",
          "3834:  ret = copy_struct_from_user(&req->open.how, sizeof(req->open.how), how,",
          "3835:      len);",
          "3836:  if (ret)",
          "3837:   return ret;",
          "3839:  return __io_openat_prep(req, sqe);",
          "3840: }",
          "3842: static int io_openat2(struct io_kiocb *req, bool force_nonblock)",
          "3843: {",
          "3844:  struct open_flags op;",
          "3845:  struct file *file;",
          "3846:  int ret;",
          "3848:  if (force_nonblock && !req->open.ignore_nonblock)",
          "3849:   return -EAGAIN;",
          "3851:  ret = build_open_flags(&req->open.how, &op);",
          "3852:  if (ret)",
          "3853:   goto err;",
          "3855:  ret = __get_unused_fd_flags(req->open.how.flags, req->open.nofile);",
          "3856:  if (ret < 0)",
          "3857:   goto err;",
          "3859:  file = do_filp_open(req->open.dfd, req->open.filename, &op);",
          "3860:  if (IS_ERR(file)) {",
          "3861:   put_unused_fd(ret);",
          "3862:   ret = PTR_ERR(file);",
          "3872:   if (ret == -EOPNOTSUPP && io_wq_current_is_worker()) {",
          "3873:    req->open.ignore_nonblock = true;",
          "3874:    refcount_inc(&req->refs);",
          "3875:    io_req_task_queue(req);",
          "3876:    return 0;",
          "3878:  } else {",
          "3879:   fsnotify_open(file);",
          "3880:   fd_install(ret, file);",
          "3882: err:",
          "3883:  putname(req->open.filename);",
          "3884:  req->flags &= ~REQ_F_NEED_CLEANUP;",
          "3887:  io_req_complete(req, ret);",
          "3891: static int io_openat(struct io_kiocb *req, bool force_nonblock)",
          "3893:  return io_openat2(req, force_nonblock);",
          "3894: }",
          "3896: static int io_remove_buffers_prep(struct io_kiocb *req,",
          "3897:       const struct io_uring_sqe *sqe)",
          "3898: {",
          "3899:  struct io_provide_buf *p = &req->pbuf;",
          "3900:  u64 tmp;",
          "3902:  if (sqe->ioprio || sqe->rw_flags || sqe->addr || sqe->len || sqe->off)",
          "3903:   return -EINVAL;",
          "3905:  tmp = READ_ONCE(sqe->fd);",
          "3906:  if (!tmp || tmp > USHRT_MAX)",
          "3907:   return -EINVAL;",
          "3909:  memset(p, 0, sizeof(*p));",
          "3910:  p->nbufs = tmp;",
          "3911:  p->bgid = READ_ONCE(sqe->buf_group);",
          "3912:  return 0;",
          "3913: }",
          "3915: static int __io_remove_buffers(struct io_ring_ctx *ctx, struct io_buffer *buf,",
          "3916:           int bgid, unsigned nbufs)",
          "3917: {",
          "3918:  unsigned i = 0;",
          "3921:  if (!nbufs)",
          "3925:  while (!list_empty(&buf->list)) {",
          "3926:   struct io_buffer *nxt;",
          "3928:   nxt = list_first_entry(&buf->list, struct io_buffer, list);",
          "3929:   list_del(&nxt->list);",
          "3930:   kfree(nxt);",
          "3931:   if (++i == nbufs)",
          "3932:    return i;",
          "3933:  }",
          "3934:  i++;",
          "3935:  kfree(buf);",
          "3936:  idr_remove(&ctx->io_buffer_idr, bgid);",
          "3938:  return i;",
          "3941: static int io_remove_buffers(struct io_kiocb *req, bool force_nonblock,",
          "3942:         struct io_comp_state *cs)",
          "3944:  struct io_provide_buf *p = &req->pbuf;",
          "3945:  struct io_ring_ctx *ctx = req->ctx;",
          "3946:  struct io_buffer *head;",
          "3947:  int ret = 0;",
          "3949:  io_ring_submit_lock(ctx, !force_nonblock);",
          "3951:  lockdep_assert_held(&ctx->uring_lock);",
          "3953:  ret = -ENOENT;",
          "3954:  head = idr_find(&ctx->io_buffer_idr, p->bgid);",
          "3955:  if (head)",
          "3956:   ret = __io_remove_buffers(ctx, head, p->bgid, p->nbufs);",
          "3958:  io_ring_submit_lock(ctx, !force_nonblock);",
          "3959:  if (ret < 0)",
          "3960:   req_set_fail_links(req);",
          "3961:  __io_req_complete(req, ret, 0, cs);",
          "3962:  return 0;",
          "3963: }",
          "3965: static int io_provide_buffers_prep(struct io_kiocb *req,",
          "3966:        const struct io_uring_sqe *sqe)",
          "3967: {",
          "3968:  struct io_provide_buf *p = &req->pbuf;",
          "3969:  u64 tmp;",
          "3971:  if (sqe->ioprio || sqe->rw_flags)",
          "3974:  tmp = READ_ONCE(sqe->fd);",
          "3975:  if (!tmp || tmp > USHRT_MAX)",
          "3976:   return -E2BIG;",
          "3977:  p->nbufs = tmp;",
          "3978:  p->addr = READ_ONCE(sqe->addr);",
          "3979:  p->len = READ_ONCE(sqe->len);",
          "3981:  if (!access_ok(u64_to_user_ptr(p->addr), (p->len * p->nbufs)))",
          "3982:   return -EFAULT;",
          "3984:  p->bgid = READ_ONCE(sqe->buf_group);",
          "3985:  tmp = READ_ONCE(sqe->off);",
          "3986:  if (tmp > USHRT_MAX)",
          "3987:   return -E2BIG;",
          "3988:  p->bid = tmp;",
          "3989:  return 0;",
          "3990: }",
          "3992: static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)",
          "3993: {",
          "3994:  struct io_buffer *buf;",
          "3995:  u64 addr = pbuf->addr;",
          "3996:  int i, bid = pbuf->bid;",
          "3998:  for (i = 0; i < pbuf->nbufs; i++) {",
          "3999:   buf = kmalloc(sizeof(*buf), GFP_KERNEL);",
          "4000:   if (!buf)",
          "4001:    break;",
          "4003:   buf->addr = addr;",
          "4004:   buf->len = pbuf->len;",
          "4005:   buf->bid = bid;",
          "4006:   addr += pbuf->len;",
          "4007:   bid++;",
          "4008:   if (!*head) {",
          "4009:    INIT_LIST_HEAD(&buf->list);",
          "4011:   } else {",
          "4012:    list_add_tail(&buf->list, &(*head)->list);",
          "4016:  return i ? i : -ENOMEM;",
          "4017: }",
          "4019: static int io_provide_buffers(struct io_kiocb *req, bool force_nonblock,",
          "4020:          struct io_comp_state *cs)",
          "4021: {",
          "4022:  struct io_provide_buf *p = &req->pbuf;",
          "4023:  struct io_ring_ctx *ctx = req->ctx;",
          "4024:  struct io_buffer *head, *list;",
          "4025:  int ret = 0;",
          "4027:  io_ring_submit_lock(ctx, !force_nonblock);",
          "4029:  lockdep_assert_held(&ctx->uring_lock);",
          "4031:  list = head = idr_find(&ctx->io_buffer_idr, p->bgid);",
          "4033:  ret = io_add_buffers(p, &head);",
          "4034:  if (ret < 0)",
          "4035:   goto out;",
          "4037:  if (!list) {",
          "4038:   ret = idr_alloc(&ctx->io_buffer_idr, head, p->bgid, p->bgid + 1,",
          "4039:      GFP_KERNEL);",
          "4040:   if (ret < 0) {",
          "4041:    __io_remove_buffers(ctx, head, p->bgid, -1U);",
          "4042:    goto out;",
          "4043:   }",
          "4044:  }",
          "4045: out:",
          "4046:  io_ring_submit_unlock(ctx, !force_nonblock);",
          "4049:  __io_req_complete(req, ret, 0, cs);",
          "4053: static int io_epoll_ctl_prep(struct io_kiocb *req,",
          "4054:         const struct io_uring_sqe *sqe)",
          "4056: #if defined(CONFIG_EPOLL)",
          "4057:  if (sqe->ioprio || sqe->buf_index)",
          "4059:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL)))",
          "4062:  req->epoll.epfd = READ_ONCE(sqe->fd);",
          "4063:  req->epoll.op = READ_ONCE(sqe->len);",
          "4064:  req->epoll.fd = READ_ONCE(sqe->off);",
          "4066:  if (ep_op_has_event(req->epoll.op)) {",
          "4067:   struct epoll_event __user *ev;",
          "4069:   ev = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "4070:   if (copy_from_user(&req->epoll.event, ev, sizeof(*ev)))",
          "4071:    return -EFAULT;",
          "4072:  }",
          "4080: static int io_epoll_ctl(struct io_kiocb *req, bool force_nonblock,",
          "4081:    struct io_comp_state *cs)",
          "4083: #if defined(CONFIG_EPOLL)",
          "4084:  struct io_epoll *ie = &req->epoll;",
          "4087:  ret = do_epoll_ctl(ie->epfd, ie->op, ie->fd, &ie->event, force_nonblock);",
          "4088:  if (force_nonblock && ret == -EAGAIN)",
          "4093:  __io_req_complete(req, ret, 0, cs);",
          "4095: #else",
          "4096:  return -EOPNOTSUPP;",
          "4097: #endif",
          "4100: static int io_madvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4102: #if defined(CONFIG_ADVISE_SYSCALLS) && defined(CONFIG_MMU)",
          "4103:  if (sqe->ioprio || sqe->buf_index || sqe->off)",
          "4104:   return -EINVAL;",
          "4105:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "4106:   return -EINVAL;",
          "4108:  req->madvise.addr = READ_ONCE(sqe->addr);",
          "4109:  req->madvise.len = READ_ONCE(sqe->len);",
          "4110:  req->madvise.advice = READ_ONCE(sqe->fadvise_advice);",
          "4111:  return 0;",
          "4112: #else",
          "4113:  return -EOPNOTSUPP;",
          "4115: }",
          "4117: static int io_madvise(struct io_kiocb *req, bool force_nonblock)",
          "4119: #if defined(CONFIG_ADVISE_SYSCALLS) && defined(CONFIG_MMU)",
          "4120:  struct io_madvise *ma = &req->madvise;",
          "4123:  if (force_nonblock)",
          "4126:  ret = do_madvise(ma->addr, ma->len, ma->advice);",
          "4127:  if (ret < 0)",
          "4128:   req_set_fail_links(req);",
          "4129:  io_req_complete(req, ret);",
          "4136: static int io_fadvise_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4138:  if (sqe->ioprio || sqe->buf_index || sqe->addr)",
          "4140:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "4143:  req->fadvise.offset = READ_ONCE(sqe->off);",
          "4144:  req->fadvise.len = READ_ONCE(sqe->len);",
          "4145:  req->fadvise.advice = READ_ONCE(sqe->fadvise_advice);",
          "4146:  return 0;",
          "4149: static int io_fadvise(struct io_kiocb *req, bool force_nonblock)",
          "4151:  struct io_fadvise *fa = &req->fadvise;",
          "4154:  if (force_nonblock) {",
          "4155:   switch (fa->advice) {",
          "4156:   case POSIX_FADV_NORMAL:",
          "4157:   case POSIX_FADV_RANDOM:",
          "4158:   case POSIX_FADV_SEQUENTIAL:",
          "4159:    break;",
          "4160:   default:",
          "4165:  ret = vfs_fadvise(req->file, fa->offset, fa->len, fa->advice);",
          "4168:  io_req_complete(req, ret);",
          "4172: static int io_statx_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4174:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL)))",
          "4175:   return -EINVAL;",
          "4176:  if (sqe->ioprio || sqe->buf_index)",
          "4177:   return -EINVAL;",
          "4178:  if (req->flags & REQ_F_FIXED_FILE)",
          "4179:   return -EBADF;",
          "4181:  req->statx.dfd = READ_ONCE(sqe->fd);",
          "4182:  req->statx.mask = READ_ONCE(sqe->len);",
          "4183:  req->statx.filename = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "4184:  req->statx.buffer = u64_to_user_ptr(READ_ONCE(sqe->addr2));",
          "4185:  req->statx.flags = READ_ONCE(sqe->statx_flags);",
          "4187:  return 0;",
          "4188: }",
          "4190: static int io_statx(struct io_kiocb *req, bool force_nonblock)",
          "4191: {",
          "4192:  struct io_statx *ctx = &req->statx;",
          "4193:  int ret;",
          "4195:  if (force_nonblock) {",
          "4197:   if (ctx->dfd == -1 || ctx->dfd == AT_FDCWD)",
          "4198:    req->flags |= REQ_F_NO_FILE_TABLE;",
          "4199:   return -EAGAIN;",
          "4202:  ret = do_statx(ctx->dfd, ctx->filename, ctx->flags, ctx->mask,",
          "4203:          ctx->buffer);",
          "4205:  if (ret < 0)",
          "4206:   req_set_fail_links(req);",
          "4207:  io_req_complete(req, ret);",
          "4208:  return 0;",
          "4211: static int io_close_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4218:  io_req_init_async(req);",
          "4219:  req->work.flags |= IO_WQ_WORK_NO_CANCEL;",
          "4221:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL|IORING_SETUP_SQPOLL)))",
          "4222:   return -EINVAL;",
          "4223:  if (sqe->ioprio || sqe->off || sqe->addr || sqe->len ||",
          "4224:      sqe->rw_flags || sqe->buf_index)",
          "4225:   return -EINVAL;",
          "4226:  if (req->flags & REQ_F_FIXED_FILE)",
          "4227:   return -EBADF;",
          "4229:  req->close.fd = READ_ONCE(sqe->fd);",
          "4230:  if ((req->file && req->file->f_op == &io_uring_fops))",
          "4231:   return -EBADF;",
          "4233:  req->close.put_file = NULL;",
          "4234:  return 0;",
          "4237: static int io_close(struct io_kiocb *req, bool force_nonblock,",
          "4238:       struct io_comp_state *cs)",
          "4240:  struct io_close *close = &req->close;",
          "4241:  int ret;",
          "4244:  if (!close->put_file) {",
          "4245:   ret = __close_fd_get_file(close->fd, &close->put_file);",
          "4246:   if (ret < 0)",
          "4247:    return (ret == -ENOENT) ? -EBADF : ret;",
          "4251:  if (close->put_file->f_op->flush && force_nonblock) {",
          "4253:   req->flags &= ~REQ_F_NOWAIT;",
          "4255:   req->flags |= REQ_F_NO_FILE_TABLE;",
          "4256:   return -EAGAIN;",
          "4257:  }",
          "4260:  ret = filp_close(close->put_file, req->work.identity->files);",
          "4261:  if (ret < 0)",
          "4262:   req_set_fail_links(req);",
          "4263:  fput(close->put_file);",
          "4264:  close->put_file = NULL;",
          "4265:  __io_req_complete(req, ret, 0, cs);",
          "4266:  return 0;",
          "4269: static int io_prep_sfr(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4271:  struct io_ring_ctx *ctx = req->ctx;",
          "4273:  if (!req->file)",
          "4274:   return -EBADF;",
          "4276:  if (unlikely(ctx->flags & IORING_SETUP_IOPOLL))",
          "4278:  if (unlikely(sqe->addr || sqe->ioprio || sqe->buf_index))",
          "4281:  req->sync.off = READ_ONCE(sqe->off);",
          "4282:  req->sync.len = READ_ONCE(sqe->len);",
          "4283:  req->sync.flags = READ_ONCE(sqe->sync_range_flags);",
          "4287: static int io_sync_file_range(struct io_kiocb *req, bool force_nonblock)",
          "4292:  if (force_nonblock)",
          "4293:   return -EAGAIN;",
          "4295:  ret = sync_file_range(req->file, req->sync.off, req->sync.len,",
          "4296:     req->sync.flags);",
          "4299:  io_req_complete(req, ret);",
          "4303: #if defined(CONFIG_NET)",
          "4304: static int io_setup_async_msg(struct io_kiocb *req,",
          "4305:          struct io_async_msghdr *kmsg)",
          "4307:  struct io_async_msghdr *async_msg = req->async_data;",
          "4309:  if (async_msg)",
          "4310:   return -EAGAIN;",
          "4311:  if (io_alloc_async_data(req)) {",
          "4312:   if (kmsg->iov != kmsg->fast_iov)",
          "4313:    kfree(kmsg->iov);",
          "4314:   return -ENOMEM;",
          "4315:  }",
          "4316:  async_msg = req->async_data;",
          "4317:  req->flags |= REQ_F_NEED_CLEANUP;",
          "4318:  memcpy(async_msg, kmsg, sizeof(*kmsg));",
          "4319:  return -EAGAIN;",
          "4322: static int io_sendmsg_copy_hdr(struct io_kiocb *req,",
          "4323:           struct io_async_msghdr *iomsg)",
          "4325:  iomsg->iov = iomsg->fast_iov;",
          "4326:  iomsg->msg.msg_name = &iomsg->addr;",
          "4327:  return sendmsg_copy_msghdr(&iomsg->msg, req->sr_msg.umsg,",
          "4328:        req->sr_msg.msg_flags, &iomsg->iov);",
          "4329: }",
          "4331: static int io_sendmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4332: {",
          "4333:  struct io_async_msghdr *async_msg = req->async_data;",
          "4334:  struct io_sr_msg *sr = &req->sr_msg;",
          "4335:  int ret;",
          "4337:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "4338:   return -EINVAL;",
          "4340:  sr->msg_flags = READ_ONCE(sqe->msg_flags);",
          "4341:  sr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "4342:  sr->len = READ_ONCE(sqe->len);",
          "4344: #ifdef CONFIG_COMPAT",
          "4345:  if (req->ctx->compat)",
          "4346:   sr->msg_flags |= MSG_CMSG_COMPAT;",
          "4347: #endif",
          "4349:  if (!async_msg || !io_op_defs[req->opcode].needs_async_data)",
          "4350:   return 0;",
          "4351:  ret = io_sendmsg_copy_hdr(req, async_msg);",
          "4352:  if (!ret)",
          "4353:   req->flags |= REQ_F_NEED_CLEANUP;",
          "4354:  return ret;",
          "4355: }",
          "4357: static int io_sendmsg(struct io_kiocb *req, bool force_nonblock,",
          "4358:         struct io_comp_state *cs)",
          "4359: {",
          "4360:  struct io_async_msghdr iomsg, *kmsg;",
          "4361:  struct socket *sock;",
          "4362:  unsigned flags;",
          "4363:  int ret;",
          "4365:  sock = sock_from_file(req->file, &ret);",
          "4366:  if (unlikely(!sock))",
          "4367:   return ret;",
          "4369:  if (req->async_data) {",
          "4370:   kmsg = req->async_data;",
          "4371:   kmsg->msg.msg_name = &kmsg->addr;",
          "4373:   if (!kmsg->iov)",
          "4374:    kmsg->iov = kmsg->fast_iov;",
          "4375:   kmsg->msg.msg_iter.iov = kmsg->iov;",
          "4376:  } else {",
          "4377:   ret = io_sendmsg_copy_hdr(req, &iomsg);",
          "4378:   if (ret)",
          "4379:    return ret;",
          "4380:   kmsg = &iomsg;",
          "4383:  flags = req->sr_msg.msg_flags;",
          "4384:  if (flags & MSG_DONTWAIT)",
          "4385:   req->flags |= REQ_F_NOWAIT;",
          "4386:  else if (force_nonblock)",
          "4387:   flags |= MSG_DONTWAIT;",
          "4389:  ret = __sys_sendmsg_sock(sock, &kmsg->msg, flags);",
          "4390:  if (force_nonblock && ret == -EAGAIN)",
          "4391:   return io_setup_async_msg(req, kmsg);",
          "4392:  if (ret == -ERESTARTSYS)",
          "4393:   ret = -EINTR;",
          "4395:  if (kmsg->iov != kmsg->fast_iov)",
          "4396:   kfree(kmsg->iov);",
          "4397:  req->flags &= ~REQ_F_NEED_CLEANUP;",
          "4400:  __io_req_complete(req, ret, 0, cs);",
          "4401:  return 0;",
          "4404: static int io_send(struct io_kiocb *req, bool force_nonblock,",
          "4405:      struct io_comp_state *cs)",
          "4407:  struct io_sr_msg *sr = &req->sr_msg;",
          "4408:  struct msghdr msg;",
          "4409:  struct iovec iov;",
          "4410:  struct socket *sock;",
          "4411:  unsigned flags;",
          "4412:  int ret;",
          "4414:  sock = sock_from_file(req->file, &ret);",
          "4415:  if (unlikely(!sock))",
          "4416:   return ret;",
          "4418:  ret = import_single_range(WRITE, sr->buf, sr->len, &iov, &msg.msg_iter);",
          "4419:  if (unlikely(ret))",
          "4420:   return ret;",
          "4422:  msg.msg_name = NULL;",
          "4423:  msg.msg_control = NULL;",
          "4424:  msg.msg_controllen = 0;",
          "4425:  msg.msg_namelen = 0;",
          "4427:  flags = req->sr_msg.msg_flags;",
          "4428:  if (flags & MSG_DONTWAIT)",
          "4429:   req->flags |= REQ_F_NOWAIT;",
          "4430:  else if (force_nonblock)",
          "4431:   flags |= MSG_DONTWAIT;",
          "4433:  msg.msg_flags = flags;",
          "4434:  ret = sock_sendmsg(sock, &msg);",
          "4435:  if (force_nonblock && ret == -EAGAIN)",
          "4436:   return -EAGAIN;",
          "4437:  if (ret == -ERESTARTSYS)",
          "4438:   ret = -EINTR;",
          "4440:  if (ret < 0)",
          "4441:   req_set_fail_links(req);",
          "4442:  __io_req_complete(req, ret, 0, cs);",
          "4443:  return 0;",
          "4444: }",
          "4446: static int __io_recvmsg_copy_hdr(struct io_kiocb *req,",
          "4447:      struct io_async_msghdr *iomsg)",
          "4448: {",
          "4449:  struct io_sr_msg *sr = &req->sr_msg;",
          "4450:  struct iovec __user *uiov;",
          "4451:  size_t iov_len;",
          "4452:  int ret;",
          "4454:  ret = __copy_msghdr_from_user(&iomsg->msg, sr->umsg,",
          "4455:      &iomsg->uaddr, &uiov, &iov_len);",
          "4456:  if (ret)",
          "4457:   return ret;",
          "4459:  if (req->flags & REQ_F_BUFFER_SELECT) {",
          "4460:   if (iov_len > 1)",
          "4461:    return -EINVAL;",
          "4462:   if (copy_from_user(iomsg->iov, uiov, sizeof(*uiov)))",
          "4463:    return -EFAULT;",
          "4464:   sr->len = iomsg->iov[0].iov_len;",
          "4465:   iov_iter_init(&iomsg->msg.msg_iter, READ, iomsg->iov, 1,",
          "4466:     sr->len);",
          "4467:   iomsg->iov = NULL;",
          "4468:  } else {",
          "4469:   ret = import_iovec(READ, uiov, iov_len, UIO_FASTIOV,",
          "4470:          &iomsg->iov, &iomsg->msg.msg_iter);",
          "4471:   if (ret > 0)",
          "4472:    ret = 0;",
          "4473:  }",
          "4475:  return ret;",
          "4476: }",
          "4478: #ifdef CONFIG_COMPAT",
          "4479: static int __io_compat_recvmsg_copy_hdr(struct io_kiocb *req,",
          "4480:      struct io_async_msghdr *iomsg)",
          "4481: {",
          "4482:  struct compat_msghdr __user *msg_compat;",
          "4483:  struct io_sr_msg *sr = &req->sr_msg;",
          "4484:  struct compat_iovec __user *uiov;",
          "4485:  compat_uptr_t ptr;",
          "4486:  compat_size_t len;",
          "4487:  int ret;",
          "4489:  msg_compat = (struct compat_msghdr __user *) sr->umsg;",
          "4490:  ret = __get_compat_msghdr(&iomsg->msg, msg_compat, &iomsg->uaddr,",
          "4491:      &ptr, &len);",
          "4492:  if (ret)",
          "4493:   return ret;",
          "4495:  uiov = compat_ptr(ptr);",
          "4496:  if (req->flags & REQ_F_BUFFER_SELECT) {",
          "4497:   compat_ssize_t clen;",
          "4499:   if (len > 1)",
          "4500:    return -EINVAL;",
          "4501:   if (!access_ok(uiov, sizeof(*uiov)))",
          "4502:    return -EFAULT;",
          "4503:   if (__get_user(clen, &uiov->iov_len))",
          "4504:    return -EFAULT;",
          "4505:   if (clen < 0)",
          "4506:    return -EINVAL;",
          "4507:   sr->len = clen;",
          "4508:   iomsg->iov[0].iov_len = clen;",
          "4509:   iomsg->iov = NULL;",
          "4510:  } else {",
          "4511:   ret = compat_import_iovec(READ, uiov, len, UIO_FASTIOV,",
          "4512:        &iomsg->iov,",
          "4513:        &iomsg->msg.msg_iter);",
          "4514:   if (ret < 0)",
          "4515:    return ret;",
          "4516:  }",
          "4518:  return 0;",
          "4519: }",
          "4520: #endif",
          "4522: static int io_recvmsg_copy_hdr(struct io_kiocb *req,",
          "4523:           struct io_async_msghdr *iomsg)",
          "4524: {",
          "4525:  iomsg->msg.msg_name = &iomsg->addr;",
          "4526:  iomsg->iov = iomsg->fast_iov;",
          "4528: #ifdef CONFIG_COMPAT",
          "4529:  if (req->ctx->compat)",
          "4530:   return __io_compat_recvmsg_copy_hdr(req, iomsg);",
          "4531: #endif",
          "4533:  return __io_recvmsg_copy_hdr(req, iomsg);",
          "4534: }",
          "4536: static struct io_buffer *io_recv_buffer_select(struct io_kiocb *req,",
          "4537:             bool needs_lock)",
          "4538: {",
          "4539:  struct io_sr_msg *sr = &req->sr_msg;",
          "4540:  struct io_buffer *kbuf;",
          "4542:  kbuf = io_buffer_select(req, &sr->len, sr->bgid, sr->kbuf, needs_lock);",
          "4543:  if (IS_ERR(kbuf))",
          "4544:   return kbuf;",
          "4546:  sr->kbuf = kbuf;",
          "4547:  req->flags |= REQ_F_BUFFER_SELECTED;",
          "4548:  return kbuf;",
          "4549: }",
          "4551: static inline unsigned int io_put_recv_kbuf(struct io_kiocb *req)",
          "4552: {",
          "4553:  return io_put_kbuf(req, req->sr_msg.kbuf);",
          "4554: }",
          "4556: static int io_recvmsg_prep(struct io_kiocb *req,",
          "4557:       const struct io_uring_sqe *sqe)",
          "4558: {",
          "4559:  struct io_async_msghdr *async_msg = req->async_data;",
          "4560:  struct io_sr_msg *sr = &req->sr_msg;",
          "4561:  int ret;",
          "4563:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "4564:   return -EINVAL;",
          "4566:  sr->msg_flags = READ_ONCE(sqe->msg_flags);",
          "4567:  sr->umsg = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "4568:  sr->len = READ_ONCE(sqe->len);",
          "4569:  sr->bgid = READ_ONCE(sqe->buf_group);",
          "4571: #ifdef CONFIG_COMPAT",
          "4572:  if (req->ctx->compat)",
          "4573:   sr->msg_flags |= MSG_CMSG_COMPAT;",
          "4574: #endif",
          "4576:  if (!async_msg || !io_op_defs[req->opcode].needs_async_data)",
          "4577:   return 0;",
          "4578:  ret = io_recvmsg_copy_hdr(req, async_msg);",
          "4579:  if (!ret)",
          "4580:   req->flags |= REQ_F_NEED_CLEANUP;",
          "4581:  return ret;",
          "4582: }",
          "4584: static int io_recvmsg(struct io_kiocb *req, bool force_nonblock,",
          "4585:         struct io_comp_state *cs)",
          "4586: {",
          "4587:  struct io_async_msghdr iomsg, *kmsg;",
          "4588:  struct socket *sock;",
          "4589:  struct io_buffer *kbuf;",
          "4590:  unsigned flags;",
          "4591:  int ret, cflags = 0;",
          "4593:  sock = sock_from_file(req->file, &ret);",
          "4594:  if (unlikely(!sock))",
          "4595:   return ret;",
          "4597:  if (req->async_data) {",
          "4598:   kmsg = req->async_data;",
          "4599:   kmsg->msg.msg_name = &kmsg->addr;",
          "4601:   if (!kmsg->iov)",
          "4602:    kmsg->iov = kmsg->fast_iov;",
          "4603:   kmsg->msg.msg_iter.iov = kmsg->iov;",
          "4604:  } else {",
          "4605:   ret = io_recvmsg_copy_hdr(req, &iomsg);",
          "4606:   if (ret)",
          "4607:    return ret;",
          "4608:   kmsg = &iomsg;",
          "4609:  }",
          "4611:  if (req->flags & REQ_F_BUFFER_SELECT) {",
          "4612:   kbuf = io_recv_buffer_select(req, !force_nonblock);",
          "4613:   if (IS_ERR(kbuf))",
          "4614:    return PTR_ERR(kbuf);",
          "4615:   kmsg->fast_iov[0].iov_base = u64_to_user_ptr(kbuf->addr);",
          "4616:   iov_iter_init(&kmsg->msg.msg_iter, READ, kmsg->iov,",
          "4617:     1, req->sr_msg.len);",
          "4618:  }",
          "4620:  flags = req->sr_msg.msg_flags;",
          "4621:  if (flags & MSG_DONTWAIT)",
          "4622:   req->flags |= REQ_F_NOWAIT;",
          "4623:  else if (force_nonblock)",
          "4624:   flags |= MSG_DONTWAIT;",
          "4626:  ret = __sys_recvmsg_sock(sock, &kmsg->msg, req->sr_msg.umsg,",
          "4627:      kmsg->uaddr, flags);",
          "4628:  if (force_nonblock && ret == -EAGAIN)",
          "4629:   return io_setup_async_msg(req, kmsg);",
          "4630:  if (ret == -ERESTARTSYS)",
          "4631:   ret = -EINTR;",
          "4633:  if (req->flags & REQ_F_BUFFER_SELECTED)",
          "4634:   cflags = io_put_recv_kbuf(req);",
          "4635:  if (kmsg->iov != kmsg->fast_iov)",
          "4636:   kfree(kmsg->iov);",
          "4637:  req->flags &= ~REQ_F_NEED_CLEANUP;",
          "4638:  if (ret < 0)",
          "4639:   req_set_fail_links(req);",
          "4640:  __io_req_complete(req, ret, cflags, cs);",
          "4641:  return 0;",
          "4642: }",
          "4644: static int io_recv(struct io_kiocb *req, bool force_nonblock,",
          "4645:      struct io_comp_state *cs)",
          "4646: {",
          "4647:  struct io_buffer *kbuf;",
          "4648:  struct io_sr_msg *sr = &req->sr_msg;",
          "4649:  struct msghdr msg;",
          "4650:  void __user *buf = sr->buf;",
          "4651:  struct socket *sock;",
          "4652:  struct iovec iov;",
          "4653:  unsigned flags;",
          "4654:  int ret, cflags = 0;",
          "4656:  sock = sock_from_file(req->file, &ret);",
          "4657:  if (unlikely(!sock))",
          "4658:   return ret;",
          "4660:  if (req->flags & REQ_F_BUFFER_SELECT) {",
          "4661:   kbuf = io_recv_buffer_select(req, !force_nonblock);",
          "4662:   if (IS_ERR(kbuf))",
          "4663:    return PTR_ERR(kbuf);",
          "4664:   buf = u64_to_user_ptr(kbuf->addr);",
          "4665:  }",
          "4667:  ret = import_single_range(READ, buf, sr->len, &iov, &msg.msg_iter);",
          "4668:  if (unlikely(ret))",
          "4669:   goto out_free;",
          "4671:  msg.msg_name = NULL;",
          "4672:  msg.msg_control = NULL;",
          "4673:  msg.msg_controllen = 0;",
          "4674:  msg.msg_namelen = 0;",
          "4675:  msg.msg_iocb = NULL;",
          "4676:  msg.msg_flags = 0;",
          "4678:  flags = req->sr_msg.msg_flags;",
          "4679:  if (flags & MSG_DONTWAIT)",
          "4680:   req->flags |= REQ_F_NOWAIT;",
          "4681:  else if (force_nonblock)",
          "4682:   flags |= MSG_DONTWAIT;",
          "4684:  ret = sock_recvmsg(sock, &msg, flags);",
          "4685:  if (force_nonblock && ret == -EAGAIN)",
          "4686:   return -EAGAIN;",
          "4687:  if (ret == -ERESTARTSYS)",
          "4688:   ret = -EINTR;",
          "4689: out_free:",
          "4690:  if (req->flags & REQ_F_BUFFER_SELECTED)",
          "4691:   cflags = io_put_recv_kbuf(req);",
          "4692:  if (ret < 0)",
          "4693:   req_set_fail_links(req);",
          "4694:  __io_req_complete(req, ret, cflags, cs);",
          "4695:  return 0;",
          "4696: }",
          "4698: static int io_accept_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4699: {",
          "4700:  struct io_accept *accept = &req->accept;",
          "4702:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL|IORING_SETUP_SQPOLL)))",
          "4703:   return -EINVAL;",
          "4704:  if (sqe->ioprio || sqe->len || sqe->buf_index)",
          "4705:   return -EINVAL;",
          "4707:  accept->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "4708:  accept->addr_len = u64_to_user_ptr(READ_ONCE(sqe->addr2));",
          "4709:  accept->flags = READ_ONCE(sqe->accept_flags);",
          "4710:  accept->nofile = rlimit(RLIMIT_NOFILE);",
          "4711:  return 0;",
          "4712: }",
          "4714: static int io_accept(struct io_kiocb *req, bool force_nonblock,",
          "4715:        struct io_comp_state *cs)",
          "4716: {",
          "4717:  struct io_accept *accept = &req->accept;",
          "4718:  unsigned int file_flags = force_nonblock ? O_NONBLOCK : 0;",
          "4719:  int ret;",
          "4721:  if (req->file->f_flags & O_NONBLOCK)",
          "4722:   req->flags |= REQ_F_NOWAIT;",
          "4724:  ret = __sys_accept4_file(req->file, file_flags, accept->addr,",
          "4725:      accept->addr_len, accept->flags,",
          "4726:      accept->nofile);",
          "4727:  if (ret == -EAGAIN && force_nonblock)",
          "4728:   return -EAGAIN;",
          "4729:  if (ret < 0) {",
          "4730:   if (ret == -ERESTARTSYS)",
          "4731:    ret = -EINTR;",
          "4732:   req_set_fail_links(req);",
          "4733:  }",
          "4734:  __io_req_complete(req, ret, 0, cs);",
          "4735:  return 0;",
          "4736: }",
          "4738: static int io_connect_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4739: {",
          "4740:  struct io_connect *conn = &req->connect;",
          "4741:  struct io_async_connect *io = req->async_data;",
          "4743:  if (unlikely(req->ctx->flags & (IORING_SETUP_IOPOLL|IORING_SETUP_SQPOLL)))",
          "4744:   return -EINVAL;",
          "4745:  if (sqe->ioprio || sqe->len || sqe->buf_index || sqe->rw_flags)",
          "4746:   return -EINVAL;",
          "4748:  conn->addr = u64_to_user_ptr(READ_ONCE(sqe->addr));",
          "4749:  conn->addr_len =  READ_ONCE(sqe->addr2);",
          "4751:  if (!io)",
          "4752:   return 0;",
          "4754:  return move_addr_to_kernel(conn->addr, conn->addr_len,",
          "4755:      &io->address);",
          "4756: }",
          "4758: static int io_connect(struct io_kiocb *req, bool force_nonblock,",
          "4759:         struct io_comp_state *cs)",
          "4760: {",
          "4761:  struct io_async_connect __io, *io;",
          "4762:  unsigned file_flags;",
          "4763:  int ret;",
          "4765:  if (req->async_data) {",
          "4766:   io = req->async_data;",
          "4767:  } else {",
          "4768:   ret = move_addr_to_kernel(req->connect.addr,",
          "4769:       req->connect.addr_len,",
          "4770:       &__io.address);",
          "4771:   if (ret)",
          "4772:    goto out;",
          "4773:   io = &__io;",
          "4774:  }",
          "4776:  file_flags = force_nonblock ? O_NONBLOCK : 0;",
          "4778:  ret = __sys_connect_file(req->file, &io->address,",
          "4779:      req->connect.addr_len, file_flags);",
          "4780:  if ((ret == -EAGAIN || ret == -EINPROGRESS) && force_nonblock) {",
          "4781:   if (req->async_data)",
          "4782:    return -EAGAIN;",
          "4783:   if (io_alloc_async_data(req)) {",
          "4784:    ret = -ENOMEM;",
          "4785:    goto out;",
          "4786:   }",
          "4787:   io = req->async_data;",
          "4788:   memcpy(req->async_data, &__io, sizeof(__io));",
          "4789:   return -EAGAIN;",
          "4790:  }",
          "4791:  if (ret == -ERESTARTSYS)",
          "4792:   ret = -EINTR;",
          "4793: out:",
          "4794:  if (ret < 0)",
          "4795:   req_set_fail_links(req);",
          "4796:  __io_req_complete(req, ret, 0, cs);",
          "4797:  return 0;",
          "4798: }",
          "4800: static int io_sendmsg_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4801: {",
          "4802:  return -EOPNOTSUPP;",
          "4803: }",
          "4805: static int io_sendmsg(struct io_kiocb *req, bool force_nonblock,",
          "4806:         struct io_comp_state *cs)",
          "4807: {",
          "4808:  return -EOPNOTSUPP;",
          "4809: }",
          "4811: static int io_send(struct io_kiocb *req, bool force_nonblock,",
          "4812:      struct io_comp_state *cs)",
          "4813: {",
          "4814:  return -EOPNOTSUPP;",
          "4815: }",
          "4817: static int io_recvmsg_prep(struct io_kiocb *req,",
          "4818:       const struct io_uring_sqe *sqe)",
          "4819: {",
          "4820:  return -EOPNOTSUPP;",
          "4821: }",
          "4823: static int io_recvmsg(struct io_kiocb *req, bool force_nonblock,",
          "4824:         struct io_comp_state *cs)",
          "4825: {",
          "4826:  return -EOPNOTSUPP;",
          "4827: }",
          "4829: static int io_recv(struct io_kiocb *req, bool force_nonblock,",
          "4830:      struct io_comp_state *cs)",
          "4831: {",
          "4832:  return -EOPNOTSUPP;",
          "4833: }",
          "4835: static int io_accept_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4836: {",
          "4837:  return -EOPNOTSUPP;",
          "4838: }",
          "4840: static int io_accept(struct io_kiocb *req, bool force_nonblock,",
          "4841:        struct io_comp_state *cs)",
          "4842: {",
          "4843:  return -EOPNOTSUPP;",
          "4844: }",
          "4846: static int io_connect_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "4847: {",
          "4848:  return -EOPNOTSUPP;",
          "4849: }",
          "4851: static int io_connect(struct io_kiocb *req, bool force_nonblock,",
          "4852:         struct io_comp_state *cs)",
          "4853: {",
          "4854:  return -EOPNOTSUPP;",
          "4855: }",
          "4858: struct io_poll_table {",
          "4859:  struct poll_table_struct pt;",
          "4860:  struct io_kiocb *req;",
          "4861:  int error;",
          "4862: };",
          "4864: static int __io_async_wake(struct io_kiocb *req, struct io_poll_iocb *poll,",
          "4865:       __poll_t mask, task_work_func_t func)",
          "4866: {",
          "4867:  bool twa_signal_ok;",
          "4868:  int ret;",
          "4871:  if (mask && !(mask & poll->events))",
          "4872:   return 0;",
          "4874:  trace_io_uring_task_add(req->ctx, req->opcode, req->user_data, mask);",
          "4876:  list_del_init(&poll->wait.entry);",
          "4878:  req->result = mask;",
          "4879:  init_task_work(&req->task_work, func);",
          "4880:  percpu_ref_get(&req->ctx->refs);",
          "4888:  twa_signal_ok = (poll->head != &req->task->sighand->signalfd_wqh);",
          "4896:  ret = io_req_task_work_add(req, twa_signal_ok);",
          "4897:  if (unlikely(ret)) {",
          "4898:   struct task_struct *tsk;",
          "4900:   WRITE_ONCE(poll->canceled, true);",
          "4901:   tsk = io_wq_get_task(req->ctx->io_wq);",
          "4902:   task_work_add(tsk, &req->task_work, TWA_NONE);",
          "4903:   wake_up_process(tsk);",
          "4904:  }",
          "4905:  return 1;",
          "4906: }",
          "4908: static bool io_poll_rewait(struct io_kiocb *req, struct io_poll_iocb *poll)",
          "4909:  __acquires(&req->ctx->completion_lock)",
          "4910: {",
          "4911:  struct io_ring_ctx *ctx = req->ctx;",
          "4913:  if (!req->result && !READ_ONCE(poll->canceled)) {",
          "4914:   struct poll_table_struct pt = { ._key = poll->events };",
          "4916:   req->result = vfs_poll(req->file, &pt) & poll->events;",
          "4917:  }",
          "4919:  spin_lock_irq(&ctx->completion_lock);",
          "4920:  if (!req->result && !READ_ONCE(poll->canceled)) {",
          "4921:   add_wait_queue(poll->head, &poll->wait);",
          "4922:   return true;",
          "4923:  }",
          "4925:  return false;",
          "4926: }",
          "4928: static struct io_poll_iocb *io_poll_get_double(struct io_kiocb *req)",
          "4929: {",
          "4931:  if (req->opcode == IORING_OP_POLL_ADD)",
          "4932:   return req->async_data;",
          "4933:  return req->apoll->double_poll;",
          "4934: }",
          "4936: static struct io_poll_iocb *io_poll_get_single(struct io_kiocb *req)",
          "4937: {",
          "4938:  if (req->opcode == IORING_OP_POLL_ADD)",
          "4939:   return &req->poll;",
          "4940:  return &req->apoll->poll;",
          "4941: }",
          "4943: static void io_poll_remove_double(struct io_kiocb *req)",
          "4944: {",
          "4945:  struct io_poll_iocb *poll = io_poll_get_double(req);",
          "4947:  lockdep_assert_held(&req->ctx->completion_lock);",
          "4949:  if (poll && poll->head) {",
          "4950:   struct wait_queue_head *head = poll->head;",
          "4952:   spin_lock(&head->lock);",
          "4953:   list_del_init(&poll->wait.entry);",
          "4954:   if (poll->wait.private)",
          "4955:    refcount_dec(&req->refs);",
          "4956:   poll->head = NULL;",
          "4957:   spin_unlock(&head->lock);",
          "4958:  }",
          "4959: }",
          "4961: static void io_poll_complete(struct io_kiocb *req, __poll_t mask, int error)",
          "4962: {",
          "4963:  struct io_ring_ctx *ctx = req->ctx;",
          "4965:  io_poll_remove_double(req);",
          "4966:  req->poll.done = true;",
          "4967:  io_cqring_fill_event(req, error ? error : mangle_poll(mask));",
          "4968:  io_commit_cqring(ctx);",
          "4969: }",
          "4971: static void io_poll_task_func(struct callback_head *cb)",
          "4972: {",
          "4973:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "4974:  struct io_ring_ctx *ctx = req->ctx;",
          "4975:  struct io_kiocb *nxt;",
          "4977:  if (io_poll_rewait(req, &req->poll)) {",
          "4978:   spin_unlock_irq(&ctx->completion_lock);",
          "4979:  } else {",
          "4980:   hash_del(&req->hash_node);",
          "4981:   io_poll_complete(req, req->result, 0);",
          "4982:   spin_unlock_irq(&ctx->completion_lock);",
          "4984:   nxt = io_put_req_find_next(req);",
          "4985:   io_cqring_ev_posted(ctx);",
          "4986:   if (nxt)",
          "4987:    __io_req_task_submit(nxt);",
          "4988:  }",
          "4990:  percpu_ref_put(&ctx->refs);",
          "4991: }",
          "4993: static int io_poll_double_wake(struct wait_queue_entry *wait, unsigned mode,",
          "4994:           int sync, void *key)",
          "4995: {",
          "4996:  struct io_kiocb *req = wait->private;",
          "4997:  struct io_poll_iocb *poll = io_poll_get_single(req);",
          "4998:  __poll_t mask = key_to_poll(key);",
          "5001:  if (mask && !(mask & poll->events))",
          "5002:   return 0;",
          "5004:  list_del_init(&wait->entry);",
          "5006:  if (poll && poll->head) {",
          "5007:   bool done;",
          "5009:   spin_lock(&poll->head->lock);",
          "5010:   done = list_empty(&poll->wait.entry);",
          "5011:   if (!done)",
          "5012:    list_del_init(&poll->wait.entry);",
          "5014:   wait->private = NULL;",
          "5015:   spin_unlock(&poll->head->lock);",
          "5016:   if (!done) {",
          "5018:    poll->wait.func(&poll->wait, mode, sync, key);",
          "5019:   }",
          "5020:  }",
          "5021:  refcount_dec(&req->refs);",
          "5022:  return 1;",
          "5023: }",
          "5025: static void io_init_poll_iocb(struct io_poll_iocb *poll, __poll_t events,",
          "5026:          wait_queue_func_t wake_func)",
          "5027: {",
          "5028:  poll->head = NULL;",
          "5029:  poll->done = false;",
          "5030:  poll->canceled = false;",
          "5031:  poll->events = events;",
          "5032:  INIT_LIST_HEAD(&poll->wait.entry);",
          "5033:  init_waitqueue_func_entry(&poll->wait, wake_func);",
          "5034: }",
          "5036: static void __io_queue_proc(struct io_poll_iocb *poll, struct io_poll_table *pt,",
          "5037:        struct wait_queue_head *head,",
          "5038:        struct io_poll_iocb **poll_ptr)",
          "5039: {",
          "5040:  struct io_kiocb *req = pt->req;",
          "5047:  if (unlikely(poll->head)) {",
          "5048:   struct io_poll_iocb *poll_one = poll;",
          "5051:   if (*poll_ptr) {",
          "5052:    pt->error = -EINVAL;",
          "5053:    return;",
          "5054:   }",
          "5055:   poll = kmalloc(sizeof(*poll), GFP_ATOMIC);",
          "5056:   if (!poll) {",
          "5057:    pt->error = -ENOMEM;",
          "5058:    return;",
          "5059:   }",
          "5060:   io_init_poll_iocb(poll, poll_one->events, io_poll_double_wake);",
          "5061:   refcount_inc(&req->refs);",
          "5062:   poll->wait.private = req;",
          "5064:  }",
          "5066:  pt->error = 0;",
          "5067:  poll->head = head;",
          "5069:  if (poll->events & EPOLLEXCLUSIVE)",
          "5070:   add_wait_queue_exclusive(head, &poll->wait);",
          "5071:  else",
          "5072:   add_wait_queue(head, &poll->wait);",
          "5073: }",
          "5075: static void io_async_queue_proc(struct file *file, struct wait_queue_head *head,",
          "5076:           struct poll_table_struct *p,",
          "5077:           unsigned long fixed_event)",
          "5078: {",
          "5079:  struct io_poll_table *pt = container_of(p, struct io_poll_table, pt);",
          "5080:  struct async_poll *apoll = pt->req->apoll;",
          "5082:  __io_queue_proc(&apoll->poll, pt, head, &apoll->double_poll);",
          "5083: }",
          "5085: static void io_async_task_func(struct callback_head *cb)",
          "5086: {",
          "5087:  struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work);",
          "5088:  struct async_poll *apoll = req->apoll;",
          "5089:  struct io_ring_ctx *ctx = req->ctx;",
          "5091:  trace_io_uring_task_run(req->ctx, req->opcode, req->user_data);",
          "5093:  if (io_poll_rewait(req, &apoll->poll)) {",
          "5094:   spin_unlock_irq(&ctx->completion_lock);",
          "5095:   percpu_ref_put(&ctx->refs);",
          "5096:   return;",
          "5097:  }",
          "5100:  if (hash_hashed(&req->hash_node))",
          "5101:   hash_del(&req->hash_node);",
          "5103:  io_poll_remove_double(req);",
          "5104:  spin_unlock_irq(&ctx->completion_lock);",
          "5106:  if (!READ_ONCE(apoll->poll.canceled))",
          "5107:   __io_req_task_submit(req);",
          "5108:  else",
          "5109:   __io_req_task_cancel(req, -ECANCELED);",
          "5111:  percpu_ref_put(&ctx->refs);",
          "5112:  kfree(apoll->double_poll);",
          "5113:  kfree(apoll);",
          "5114: }",
          "5116: static int io_async_wake(struct wait_queue_entry *wait, unsigned mode, int sync,",
          "5117:    void *key)",
          "5118: {",
          "5119:  struct io_kiocb *req = wait->private;",
          "5120:  struct io_poll_iocb *poll = &req->apoll->poll;",
          "5122:  trace_io_uring_poll_wake(req->ctx, req->opcode, req->user_data,",
          "5123:      key_to_poll(key));",
          "5125:  return __io_async_wake(req, poll, key_to_poll(key), io_async_task_func);",
          "5126: }",
          "5128: static void io_poll_req_insert(struct io_kiocb *req)",
          "5129: {",
          "5130:  struct io_ring_ctx *ctx = req->ctx;",
          "5131:  struct hlist_head *list;",
          "5133:  list = &ctx->cancel_hash[hash_long(req->user_data, ctx->cancel_hash_bits)];",
          "5134:  hlist_add_head(&req->hash_node, list);",
          "5135: }",
          "5137: static __poll_t __io_arm_poll_handler(struct io_kiocb *req,",
          "5138:           struct io_poll_iocb *poll,",
          "5139:           struct io_poll_table *ipt, __poll_t mask,",
          "5140:           wait_queue_func_t wake_func)",
          "5141:  __acquires(&ctx->completion_lock)",
          "5142: {",
          "5143:  struct io_ring_ctx *ctx = req->ctx;",
          "5144:  bool cancel = false;",
          "5146:  INIT_HLIST_NODE(&req->hash_node);",
          "5147:  io_init_poll_iocb(poll, mask, wake_func);",
          "5148:  poll->file = req->file;",
          "5149:  poll->wait.private = req;",
          "5151:  ipt->pt._key = mask;",
          "5152:  ipt->req = req;",
          "5153:  ipt->error = -EINVAL;",
          "5155:  mask = vfs_poll(req->file, &ipt->pt) & poll->events;",
          "5157:  spin_lock_irq(&ctx->completion_lock);",
          "5158:  if (likely(poll->head)) {",
          "5159:   spin_lock(&poll->head->lock);",
          "5160:   if (unlikely(list_empty(&poll->wait.entry))) {",
          "5161:    if (ipt->error)",
          "5162:     cancel = true;",
          "5163:    ipt->error = 0;",
          "5164:    mask = 0;",
          "5165:   }",
          "5166:   if (mask || ipt->error)",
          "5167:    list_del_init(&poll->wait.entry);",
          "5168:   else if (cancel)",
          "5169:    WRITE_ONCE(poll->canceled, true);",
          "5171:    io_poll_req_insert(req);",
          "5172:   spin_unlock(&poll->head->lock);",
          "5173:  }",
          "5175:  return mask;",
          "5176: }",
          "5178: static bool io_arm_poll_handler(struct io_kiocb *req)",
          "5179: {",
          "5180:  const struct io_op_def *def = &io_op_defs[req->opcode];",
          "5181:  struct io_ring_ctx *ctx = req->ctx;",
          "5182:  struct async_poll *apoll;",
          "5183:  struct io_poll_table ipt;",
          "5184:  __poll_t mask, ret;",
          "5185:  int rw;",
          "5187:  if (!req->file || !file_can_poll(req->file))",
          "5188:   return false;",
          "5189:  if (req->flags & REQ_F_POLLED)",
          "5190:   return false;",
          "5191:  if (def->pollin)",
          "5192:   rw = READ;",
          "5193:  else if (def->pollout)",
          "5194:   rw = WRITE;",
          "5195:  else",
          "5196:   return false;",
          "5198:  if (!io_file_supports_async(req->file, rw))",
          "5199:   return false;",
          "5201:  apoll = kmalloc(sizeof(*apoll), GFP_ATOMIC);",
          "5202:  if (unlikely(!apoll))",
          "5203:   return false;",
          "5204:  apoll->double_poll = NULL;",
          "5206:  req->flags |= REQ_F_POLLED;",
          "5207:  req->apoll = apoll;",
          "5209:  mask = 0;",
          "5210:  if (def->pollin)",
          "5211:   mask |= POLLIN | POLLRDNORM;",
          "5212:  if (def->pollout)",
          "5213:   mask |= POLLOUT | POLLWRNORM;",
          "5216:  if ((req->opcode == IORING_OP_RECVMSG) &&",
          "5217:      (req->sr_msg.msg_flags & MSG_ERRQUEUE))",
          "5218:   mask &= ~POLLIN;",
          "5220:  mask |= POLLERR | POLLPRI;",
          "5222:  ipt.pt._qproc = io_async_queue_proc;",
          "5224:  ret = __io_arm_poll_handler(req, &apoll->poll, &ipt, mask,",
          "5225:      io_async_wake);",
          "5226:  if (ret || ipt.error) {",
          "5227:   io_poll_remove_double(req);",
          "5228:   spin_unlock_irq(&ctx->completion_lock);",
          "5229:   kfree(apoll->double_poll);",
          "5230:   kfree(apoll);",
          "5231:   return false;",
          "5232:  }",
          "5233:  spin_unlock_irq(&ctx->completion_lock);",
          "5234:  trace_io_uring_poll_arm(ctx, req->opcode, req->user_data, mask,",
          "5235:      apoll->poll.events);",
          "5236:  return true;",
          "5237: }",
          "5239: static bool __io_poll_remove_one(struct io_kiocb *req,",
          "5240:      struct io_poll_iocb *poll)",
          "5241: {",
          "5242:  bool do_complete = false;",
          "5244:  spin_lock(&poll->head->lock);",
          "5245:  WRITE_ONCE(poll->canceled, true);",
          "5246:  if (!list_empty(&poll->wait.entry)) {",
          "5247:   list_del_init(&poll->wait.entry);",
          "5248:   do_complete = true;",
          "5249:  }",
          "5250:  spin_unlock(&poll->head->lock);",
          "5251:  hash_del(&req->hash_node);",
          "5252:  return do_complete;",
          "5253: }",
          "5255: static bool io_poll_remove_one(struct io_kiocb *req)",
          "5256: {",
          "5257:  bool do_complete;",
          "5259:  io_poll_remove_double(req);",
          "5261:  if (req->opcode == IORING_OP_POLL_ADD) {",
          "5262:   do_complete = __io_poll_remove_one(req, &req->poll);",
          "5263:  } else {",
          "5264:   struct async_poll *apoll = req->apoll;",
          "5267:   do_complete = __io_poll_remove_one(req, &apoll->poll);",
          "5268:   if (do_complete) {",
          "5269:    io_put_req(req);",
          "5270:    kfree(apoll->double_poll);",
          "5271:    kfree(apoll);",
          "5272:   }",
          "5273:  }",
          "5275:  if (do_complete) {",
          "5276:   io_cqring_fill_event(req, -ECANCELED);",
          "5277:   io_commit_cqring(req->ctx);",
          "5278:   req_set_fail_links(req);",
          "5279:   io_put_req_deferred(req, 1);",
          "5280:  }",
          "5282:  return do_complete;",
          "5283: }",
          "5288: static bool io_poll_remove_all(struct io_ring_ctx *ctx, struct task_struct *tsk)",
          "5289: {",
          "5290:  struct hlist_node *tmp;",
          "5291:  struct io_kiocb *req;",
          "5292:  int posted = 0, i;",
          "5294:  spin_lock_irq(&ctx->completion_lock);",
          "5295:  for (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {",
          "5296:   struct hlist_head *list;",
          "5298:   list = &ctx->cancel_hash[i];",
          "5299:   hlist_for_each_entry_safe(req, tmp, list, hash_node) {",
          "5300:    if (io_task_match(req, tsk))",
          "5301:     posted += io_poll_remove_one(req);",
          "5302:   }",
          "5303:  }",
          "5304:  spin_unlock_irq(&ctx->completion_lock);",
          "5306:  if (posted)",
          "5307:   io_cqring_ev_posted(ctx);",
          "5309:  return posted != 0;",
          "5310: }",
          "5312: static int io_poll_cancel(struct io_ring_ctx *ctx, __u64 sqe_addr)",
          "5313: {",
          "5314:  struct hlist_head *list;",
          "5315:  struct io_kiocb *req;",
          "5317:  list = &ctx->cancel_hash[hash_long(sqe_addr, ctx->cancel_hash_bits)];",
          "5318:  hlist_for_each_entry(req, list, hash_node) {",
          "5319:   if (sqe_addr != req->user_data)",
          "5320:    continue;",
          "5321:   if (io_poll_remove_one(req))",
          "5322:    return 0;",
          "5323:   return -EALREADY;",
          "5324:  }",
          "5326:  return -ENOENT;",
          "5327: }",
          "5329: static int io_poll_remove_prep(struct io_kiocb *req,",
          "5330:           const struct io_uring_sqe *sqe)",
          "5331: {",
          "5332:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "5333:   return -EINVAL;",
          "5334:  if (sqe->ioprio || sqe->off || sqe->len || sqe->buf_index ||",
          "5335:      sqe->poll_events)",
          "5336:   return -EINVAL;",
          "5338:  req->poll.addr = READ_ONCE(sqe->addr);",
          "5339:  return 0;",
          "5340: }",
          "5346: static int io_poll_remove(struct io_kiocb *req)",
          "5347: {",
          "5348:  struct io_ring_ctx *ctx = req->ctx;",
          "5349:  u64 addr;",
          "5350:  int ret;",
          "5352:  addr = req->poll.addr;",
          "5353:  spin_lock_irq(&ctx->completion_lock);",
          "5354:  ret = io_poll_cancel(ctx, addr);",
          "5355:  spin_unlock_irq(&ctx->completion_lock);",
          "5357:  if (ret < 0)",
          "5358:   req_set_fail_links(req);",
          "5359:  io_req_complete(req, ret);",
          "5360:  return 0;",
          "5363: static int io_poll_wake(struct wait_queue_entry *wait, unsigned mode, int sync,",
          "5364:    void *key)",
          "5366:  struct io_kiocb *req = wait->private;",
          "5367:  struct io_poll_iocb *poll = &req->poll;",
          "5369:  return __io_async_wake(req, poll, key_to_poll(key), io_poll_task_func);",
          "5372: static void io_poll_queue_proc(struct file *file, struct wait_queue_head *head,",
          "5373:           struct poll_table_struct *p,",
          "5374:           unsigned long fixed_event)",
          "5376:  struct io_poll_table *pt = container_of(p, struct io_poll_table, pt);",
          "5378:  __io_queue_proc(&pt->req->poll, pt, head, (struct io_poll_iocb **) &pt->req->async_data);",
          "5384:  u32 events;",
          "5391:  events = READ_ONCE(sqe->poll32_events);",
          "5392: #ifdef __BIG_ENDIAN",
          "5393:  events = swahw32(events);",
          "5394: #endif",
          "5395:  poll->events = demangle_poll(events) | EPOLLERR | EPOLLHUP |",
          "5396:          (events & EPOLLEXCLUSIVE);",
          "5400: static int io_poll_add(struct io_kiocb *req)",
          "5409:  mask = __io_arm_poll_handler(req, &req->poll, &ipt, poll->events,",
          "5410:      io_poll_wake);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2773:  if (mask) {",
          "2774:   io_cqring_ev_posted(ctx);",
          "2776:  }",
          "2777:  return ipt.error;",
          "2778: }",
          "",
          "[Removed Lines]",
          "2775:   io_put_req_find_next(req, nxt);",
          "",
          "[Added Lines]",
          "5420:   io_put_req(req);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "2785:  struct io_ring_ctx *ctx = req->ctx;",
          "2786:  unsigned long flags;",
          "2790:  spin_lock_irqsave(&ctx->completion_lock, flags);",
          "2810:  io_cqring_fill_event(req, -ETIME);",
          "2811:  io_commit_cqring(ctx);",
          "",
          "[Removed Lines]",
          "2788:  atomic_inc(&ctx->cq_timeouts);",
          "2795:  if (!list_empty(&req->list)) {",
          "2796:   struct io_kiocb *prev;",
          "2804:   prev = req;",
          "2805:   list_for_each_entry_continue_reverse(prev, &ctx->timeout_list, list)",
          "2806:    prev->sequence++;",
          "2807:   list_del_init(&req->list);",
          "2808:  }",
          "",
          "[Added Lines]",
          "5434:  list_del_init(&req->timeout.list);",
          "5435:  atomic_set(&req->ctx->cq_timeouts,",
          "5436:   atomic_read(&req->ctx->cq_timeouts) + 1);",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "2817:  return HRTIMER_NORESTART;",
          "2818: }",
          "2820: static int io_timeout_cancel(struct io_ring_ctx *ctx, __u64 user_data)",
          "2821: {",
          "2822:  struct io_kiocb *req;",
          "2823:  int ret = -ENOENT;",
          "2826:   if (user_data == req->user_data) {",
          "2828:    ret = 0;",
          "2829:    break;",
          "2830:   }",
          "",
          "[Removed Lines]",
          "2825:  list_for_each_entry(req, &ctx->timeout_list, list) {",
          "2827:    list_del_init(&req->list);",
          "",
          "[Added Lines]",
          "5448: static int __io_timeout_cancel(struct io_kiocb *req)",
          "5449: {",
          "5450:  struct io_timeout_data *io = req->async_data;",
          "5451:  int ret;",
          "5453:  ret = hrtimer_try_to_cancel(&io->timer);",
          "5454:  if (ret == -1)",
          "5455:   return -EALREADY;",
          "5456:  list_del_init(&req->timeout.list);",
          "5458:  req_set_fail_links(req);",
          "5459:  io_cqring_fill_event(req, -ECANCELED);",
          "5460:  io_put_req_deferred(req, 1);",
          "5461:  return 0;",
          "5462: }",
          "5469:  list_for_each_entry(req, &ctx->timeout_list, timeout.list) {",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2833:  if (ret == -ENOENT)",
          "2834:   return ret;",
          "2844: }",
          "2846: static int io_timeout_remove_prep(struct io_kiocb *req,",
          "",
          "[Removed Lines]",
          "2836:  ret = hrtimer_try_to_cancel(&req->io->timeout.timer);",
          "2837:  if (ret == -1)",
          "2838:   return -EALREADY;",
          "2840:  req_set_fail_links(req);",
          "2841:  io_cqring_fill_event(req, -ECANCELED);",
          "2842:  io_put_req(req);",
          "2843:  return 0;",
          "",
          "[Added Lines]",
          "5479:  return __io_timeout_cancel(req);",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2848: {",
          "2849:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "2850:   return -EINVAL;",
          "2852:   return -EINVAL;",
          "2857:   return -EINVAL;",
          "2859:  return 0;",
          "2860: }",
          "",
          "[Removed Lines]",
          "2851:  if (sqe->flags || sqe->ioprio || sqe->buf_index || sqe->len)",
          "2854:  req->timeout.addr = READ_ONCE(sqe->addr);",
          "2855:  req->timeout.flags = READ_ONCE(sqe->timeout_flags);",
          "2856:  if (req->timeout.flags)",
          "",
          "[Added Lines]",
          "5487:  if (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))",
          "5489:  if (sqe->ioprio || sqe->buf_index || sqe->len || sqe->timeout_flags)",
          "5492:  req->timeout_rem.addr = READ_ONCE(sqe->addr);",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "2868:  int ret;",
          "2870:  spin_lock_irq(&ctx->completion_lock);",
          "2873:  io_cqring_fill_event(req, ret);",
          "2874:  io_commit_cqring(ctx);",
          "",
          "[Removed Lines]",
          "2871:  ret = io_timeout_cancel(ctx, req->timeout.addr);",
          "",
          "[Added Lines]",
          "5505:  ret = io_timeout_cancel(ctx, req->timeout_rem.addr);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2885: {",
          "2886:  struct io_timeout_data *data;",
          "2887:  unsigned flags;",
          "2889:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "2890:   return -EINVAL;",
          "2891:  if (sqe->ioprio || sqe->buf_index || sqe->len != 1)",
          "2892:   return -EINVAL;",
          "2894:   return -EINVAL;",
          "2895:  flags = READ_ONCE(sqe->timeout_flags);",
          "2896:  if (flags & ~IORING_TIMEOUT_ABS)",
          "2897:   return -EINVAL;",
          "2902:   return -ENOMEM;",
          "2905:  data->req = req;",
          "2908:  if (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))",
          "2909:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "2893:  if (sqe->off && is_timeout_link)",
          "2899:  req->timeout.count = READ_ONCE(sqe->off);",
          "2901:  if (!req->io && io_alloc_async_ctx(req))",
          "2904:  data = &req->io->timeout;",
          "2906:  req->flags |= REQ_F_TIMEOUT;",
          "",
          "[Added Lines]",
          "5522:  u32 off = READ_ONCE(sqe->off);",
          "5528:  if (off && is_timeout_link)",
          "5534:  req->timeout.off = off;",
          "5536:  if (!req->async_data && io_alloc_async_data(req))",
          "5539:  data = req->async_data;",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "2920: static int io_timeout(struct io_kiocb *req)",
          "2921: {",
          "2923:  struct io_ring_ctx *ctx = req->ctx;",
          "2925:  struct list_head *entry;",
          "2939:   entry = ctx->timeout_list.prev;",
          "2940:   goto add;",
          "2941:  }",
          "2951:  list_for_each_prev(entry, &ctx->timeout_list) {",
          "2958:    continue;",
          "2976:    break;",
          "2984:  }",
          "2986: add:",
          "2988:  data->timer.function = io_timeout_fn;",
          "2989:  hrtimer_start(&data->timer, timespec64_to_ktime(data->ts), data->mode);",
          "2990:  spin_unlock_irq(&ctx->completion_lock);",
          "",
          "[Removed Lines]",
          "2922:  unsigned count;",
          "2924:  struct io_timeout_data *data;",
          "2926:  unsigned span = 0;",
          "2928:  data = &req->io->timeout;",
          "2935:  count = req->timeout.count;",
          "2936:  if (!count) {",
          "2937:   req->flags |= REQ_F_TIMEOUT_NOSEQ;",
          "2938:   spin_lock_irq(&ctx->completion_lock);",
          "2943:  req->sequence = ctx->cached_sq_head + count - 1;",
          "2944:  data->seq_offset = count;",
          "2950:  spin_lock_irq(&ctx->completion_lock);",
          "2952:   struct io_kiocb *nxt = list_entry(entry, struct io_kiocb, list);",
          "2953:   unsigned nxt_sq_head;",
          "2954:   long long tmp, tmp_nxt;",
          "2955:   u32 nxt_offset = nxt->io->timeout.seq_offset;",
          "2957:   if (nxt->flags & REQ_F_TIMEOUT_NOSEQ)",
          "2964:   tmp = (long long)ctx->cached_sq_head + count - 1;",
          "2965:   nxt_sq_head = nxt->sequence - nxt_offset + 1;",
          "2966:   tmp_nxt = (long long)nxt_sq_head + nxt_offset - 1;",
          "2972:   if (ctx->cached_sq_head < nxt_sq_head)",
          "2973:    tmp += UINT_MAX;",
          "2975:   if (tmp > tmp_nxt)",
          "2982:   span++;",
          "2983:   nxt->sequence++;",
          "2985:  req->sequence -= span;",
          "2987:  list_add(&req->list, entry);",
          "",
          "[Added Lines]",
          "5557:  struct io_timeout_data *data = req->async_data;",
          "5559:  u32 tail, off = req->timeout.off;",
          "5561:  spin_lock_irq(&ctx->completion_lock);",
          "5568:  if (io_is_timeout_noseq(req)) {",
          "5573:  tail = ctx->cached_cq_tail - atomic_read(&ctx->cq_timeouts);",
          "5574:  req->timeout.target_seq = tail + off;",
          "5581:   struct io_kiocb *nxt = list_entry(entry, struct io_kiocb,",
          "5582:         timeout.list);",
          "5584:   if (io_is_timeout_noseq(nxt))",
          "5587:   if (off >= nxt->timeout.target_seq - tail)",
          "5591:  list_add(&req->timeout.list, entry);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "3003:  enum io_wq_cancel cancel_ret;",
          "3004:  int ret = 0;",
          "3007:  switch (cancel_ret) {",
          "3008:  case IO_WQ_CANCEL_OK:",
          "3009:   ret = 0;",
          "",
          "[Removed Lines]",
          "3006:  cancel_ret = io_wq_cancel_cb(ctx->io_wq, io_cancel_cb, sqe_addr);",
          "",
          "[Added Lines]",
          "5610:  cancel_ret = io_wq_cancel_cb(ctx->io_wq, io_cancel_cb, sqe_addr, false);",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "3022: static void io_async_find_and_cancel(struct io_ring_ctx *ctx,",
          "3023:          struct io_kiocb *req, __u64 sqe_addr,",
          "3025: {",
          "3026:  unsigned long flags;",
          "3027:  int ret;",
          "",
          "[Removed Lines]",
          "3024:          struct io_kiocb **nxt, int success_ret)",
          "",
          "[Added Lines]",
          "5628:          int success_ret)",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "3048:  if (ret < 0)",
          "3049:   req_set_fail_links(req);",
          "3051: }",
          "3053: static int io_async_cancel_prep(struct io_kiocb *req,",
          "",
          "[Removed Lines]",
          "3050:  io_put_req_find_next(req, nxt);",
          "",
          "[Added Lines]",
          "5654:  io_put_req(req);",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "3055: {",
          "3056:  if (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))",
          "3057:   return -EINVAL;",
          "3060:   return -EINVAL;",
          "3062:  req->cancel.addr = READ_ONCE(sqe->addr);",
          "3063:  return 0;",
          "3064: }",
          "3067: {",
          "3068:  struct io_ring_ctx *ctx = req->ctx;",
          "3071:  return 0;",
          "3072: }",
          "3076: {",
          "3079:  switch (req->opcode) {",
          "3080:  case IORING_OP_NOP:",
          "3082:  case IORING_OP_READV:",
          "3083:  case IORING_OP_READ_FIXED:",
          "3086:  case IORING_OP_WRITEV:",
          "3087:  case IORING_OP_WRITE_FIXED:",
          "3090:  case IORING_OP_POLL_ADD:",
          "3093:  case IORING_OP_POLL_REMOVE:",
          "3096:  case IORING_OP_FSYNC:",
          "3099:  case IORING_OP_SYNC_FILE_RANGE:",
          "3102:  case IORING_OP_SENDMSG:",
          "3105:  case IORING_OP_RECVMSG:",
          "3108:  case IORING_OP_CONNECT:",
          "3111:  case IORING_OP_TIMEOUT:",
          "3114:  case IORING_OP_TIMEOUT_REMOVE:",
          "3117:  case IORING_OP_ASYNC_CANCEL:",
          "3120:  case IORING_OP_LINK_TIMEOUT:",
          "3123:  case IORING_OP_ACCEPT:",
          "3134: }",
          "3136: static int io_req_defer(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3137: {",
          "3138:  struct io_ring_ctx *ctx = req->ctx;",
          "3139:  int ret;",
          "3143:   return 0;",
          "3152:  spin_lock_irq(&ctx->completion_lock);",
          "3154:   spin_unlock_irq(&ctx->completion_lock);",
          "3156:  }",
          "3158:  trace_io_uring_defer(ctx, req, req->user_data);",
          "3160:  spin_unlock_irq(&ctx->completion_lock);",
          "3161:  return -EIOCBQUEUED;",
          "3162: }",
          "3166: {",
          "3167:  struct io_ring_ctx *ctx = req->ctx;",
          "3168:  int ret;",
          "3170:  switch (req->opcode) {",
          "3171:  case IORING_OP_NOP:",
          "3173:   break;",
          "3174:  case IORING_OP_READV:",
          "3175:  case IORING_OP_READ_FIXED:",
          "3182:   break;",
          "3183:  case IORING_OP_WRITEV:",
          "3184:  case IORING_OP_WRITE_FIXED:",
          "3191:   break;",
          "3192:  case IORING_OP_FSYNC:",
          "3199:   break;",
          "3200:  case IORING_OP_POLL_ADD:",
          "3207:   break;",
          "3208:  case IORING_OP_POLL_REMOVE:",
          "3214:   ret = io_poll_remove(req);",
          "3215:   break;",
          "3216:  case IORING_OP_SYNC_FILE_RANGE:",
          "3223:   break;",
          "3224:  case IORING_OP_SENDMSG:",
          "3231:   break;",
          "3232:  case IORING_OP_RECVMSG:",
          "3239:   break;",
          "3240:  case IORING_OP_TIMEOUT:",
          "3246:   ret = io_timeout(req);",
          "3247:   break;",
          "3248:  case IORING_OP_TIMEOUT_REMOVE:",
          "3254:   ret = io_timeout_remove(req);",
          "3255:   break;",
          "3256:  case IORING_OP_ACCEPT:",
          "3263:   break;",
          "3264:  case IORING_OP_CONNECT:",
          "3271:   break;",
          "3272:  case IORING_OP_ASYNC_CANCEL:",
          "3279:   break;",
          "3280:  default:",
          "3281:   ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "3058:  if (sqe->flags || sqe->ioprio || sqe->off || sqe->len ||",
          "3059:      sqe->cancel_flags)",
          "3066: static int io_async_cancel(struct io_kiocb *req, struct io_kiocb **nxt)",
          "3070:  io_async_find_and_cancel(ctx, req, req->cancel.addr, nxt, 0);",
          "3074: static int io_req_defer_prep(struct io_kiocb *req,",
          "3075:         const struct io_uring_sqe *sqe)",
          "3077:  ssize_t ret = 0;",
          "3081:   break;",
          "3084:   ret = io_read_prep(req, sqe, true);",
          "3085:   break;",
          "3088:   ret = io_write_prep(req, sqe, true);",
          "3089:   break;",
          "3091:   ret = io_poll_add_prep(req, sqe);",
          "3092:   break;",
          "3094:   ret = io_poll_remove_prep(req, sqe);",
          "3095:   break;",
          "3097:   ret = io_prep_fsync(req, sqe);",
          "3098:   break;",
          "3100:   ret = io_prep_sfr(req, sqe);",
          "3101:   break;",
          "3103:   ret = io_sendmsg_prep(req, sqe);",
          "3104:   break;",
          "3106:   ret = io_recvmsg_prep(req, sqe);",
          "3107:   break;",
          "3109:   ret = io_connect_prep(req, sqe);",
          "3110:   break;",
          "3112:   ret = io_timeout_prep(req, sqe, false);",
          "3113:   break;",
          "3115:   ret = io_timeout_remove_prep(req, sqe);",
          "3116:   break;",
          "3118:   ret = io_async_cancel_prep(req, sqe);",
          "3119:   break;",
          "3121:   ret = io_timeout_prep(req, sqe, true);",
          "3122:   break;",
          "3124:   ret = io_accept_prep(req, sqe);",
          "3125:   break;",
          "3126:  default:",
          "3127:   printk_once(KERN_WARNING \"io_uring: unhandled opcode %d\\n\",",
          "3128:     req->opcode);",
          "3129:   ret = -EINVAL;",
          "3130:   break;",
          "3131:  }",
          "3133:  return ret;",
          "3142:  if (!req_need_defer(req) && list_empty(&ctx->defer_list))",
          "3145:  if (!req->io && io_alloc_async_ctx(req))",
          "3146:   return -EAGAIN;",
          "3148:  ret = io_req_defer_prep(req, sqe);",
          "3149:  if (ret < 0)",
          "3150:   return ret;",
          "3153:  if (!req_need_defer(req) && list_empty(&ctx->defer_list)) {",
          "3155:   return 0;",
          "3159:  list_add_tail(&req->list, &ctx->defer_list);",
          "3164: static int io_issue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,",
          "3165:    struct io_kiocb **nxt, bool force_nonblock)",
          "3172:   ret = io_nop(req);",
          "3176:   if (sqe) {",
          "3177:    ret = io_read_prep(req, sqe, force_nonblock);",
          "3178:    if (ret < 0)",
          "3179:     break;",
          "3180:   }",
          "3181:   ret = io_read(req, nxt, force_nonblock);",
          "3185:   if (sqe) {",
          "3186:    ret = io_write_prep(req, sqe, force_nonblock);",
          "3187:    if (ret < 0)",
          "3188:     break;",
          "3189:   }",
          "3190:   ret = io_write(req, nxt, force_nonblock);",
          "3193:   if (sqe) {",
          "3194:    ret = io_prep_fsync(req, sqe);",
          "3195:    if (ret < 0)",
          "3196:     break;",
          "3197:   }",
          "3198:   ret = io_fsync(req, nxt, force_nonblock);",
          "3201:   if (sqe) {",
          "3202:    ret = io_poll_add_prep(req, sqe);",
          "3203:    if (ret)",
          "3204:     break;",
          "3205:   }",
          "3206:   ret = io_poll_add(req, nxt);",
          "3209:   if (sqe) {",
          "3210:    ret = io_poll_remove_prep(req, sqe);",
          "3211:    if (ret < 0)",
          "3212:     break;",
          "3213:   }",
          "3217:   if (sqe) {",
          "3218:    ret = io_prep_sfr(req, sqe);",
          "3219:    if (ret < 0)",
          "3220:     break;",
          "3221:   }",
          "3222:   ret = io_sync_file_range(req, nxt, force_nonblock);",
          "3225:   if (sqe) {",
          "3226:    ret = io_sendmsg_prep(req, sqe);",
          "3227:    if (ret < 0)",
          "3228:     break;",
          "3229:   }",
          "3230:   ret = io_sendmsg(req, nxt, force_nonblock);",
          "3233:   if (sqe) {",
          "3234:    ret = io_recvmsg_prep(req, sqe);",
          "3235:    if (ret)",
          "3236:     break;",
          "3237:   }",
          "3238:   ret = io_recvmsg(req, nxt, force_nonblock);",
          "3241:   if (sqe) {",
          "3242:    ret = io_timeout_prep(req, sqe, false);",
          "3243:    if (ret)",
          "3244:     break;",
          "3245:   }",
          "3249:   if (sqe) {",
          "3250:    ret = io_timeout_remove_prep(req, sqe);",
          "3251:    if (ret)",
          "3252:     break;",
          "3253:   }",
          "3257:   if (sqe) {",
          "3258:    ret = io_accept_prep(req, sqe);",
          "3259:    if (ret)",
          "3260:     break;",
          "3261:   }",
          "3262:   ret = io_accept(req, nxt, force_nonblock);",
          "3265:   if (sqe) {",
          "3266:    ret = io_connect_prep(req, sqe);",
          "3267:    if (ret)",
          "3268:     break;",
          "3269:   }",
          "3270:   ret = io_connect(req, nxt, force_nonblock);",
          "3273:   if (sqe) {",
          "3274:    ret = io_async_cancel_prep(req, sqe);",
          "3275:    if (ret)",
          "3276:     break;",
          "3277:   }",
          "3278:   ret = io_async_cancel(req, nxt);",
          "",
          "[Added Lines]",
          "5662:  if (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))",
          "5663:   return -EINVAL;",
          "5664:  if (sqe->ioprio || sqe->off || sqe->len || sqe->cancel_flags)",
          "5671: static int io_async_cancel(struct io_kiocb *req)",
          "5675:  io_async_find_and_cancel(ctx, req, req->cancel.addr, 0);",
          "5679: static int io_files_update_prep(struct io_kiocb *req,",
          "5680:     const struct io_uring_sqe *sqe)",
          "5682:  if (unlikely(req->ctx->flags & IORING_SETUP_SQPOLL))",
          "5683:   return -EINVAL;",
          "5684:  if (unlikely(req->flags & (REQ_F_FIXED_FILE | REQ_F_BUFFER_SELECT)))",
          "5685:   return -EINVAL;",
          "5686:  if (sqe->ioprio || sqe->rw_flags)",
          "5687:   return -EINVAL;",
          "5689:  req->files_update.offset = READ_ONCE(sqe->off);",
          "5690:  req->files_update.nr_args = READ_ONCE(sqe->len);",
          "5691:  if (!req->files_update.nr_args)",
          "5692:   return -EINVAL;",
          "5693:  req->files_update.arg = READ_ONCE(sqe->addr);",
          "5694:  return 0;",
          "5695: }",
          "5697: static int io_files_update(struct io_kiocb *req, bool force_nonblock,",
          "5698:       struct io_comp_state *cs)",
          "5699: {",
          "5700:  struct io_ring_ctx *ctx = req->ctx;",
          "5701:  struct io_uring_files_update up;",
          "5702:  int ret;",
          "5704:  if (force_nonblock)",
          "5705:   return -EAGAIN;",
          "5707:  up.offset = req->files_update.offset;",
          "5708:  up.fds = req->files_update.arg;",
          "5710:  mutex_lock(&ctx->uring_lock);",
          "5711:  ret = __io_sqe_files_update(ctx, &up, req->files_update.nr_args);",
          "5712:  mutex_unlock(&ctx->uring_lock);",
          "5714:  if (ret < 0)",
          "5715:   req_set_fail_links(req);",
          "5716:  __io_req_complete(req, ret, 0, cs);",
          "5717:  return 0;",
          "5718: }",
          "5720: static int io_req_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "5721: {",
          "5724:   return 0;",
          "5727:  case IORING_OP_READ:",
          "5728:   return io_read_prep(req, sqe);",
          "5731:  case IORING_OP_WRITE:",
          "5732:   return io_write_prep(req, sqe);",
          "5734:   return io_poll_add_prep(req, sqe);",
          "5736:   return io_poll_remove_prep(req, sqe);",
          "5738:   return io_prep_fsync(req, sqe);",
          "5740:   return io_prep_sfr(req, sqe);",
          "5742:  case IORING_OP_SEND:",
          "5743:   return io_sendmsg_prep(req, sqe);",
          "5745:  case IORING_OP_RECV:",
          "5746:   return io_recvmsg_prep(req, sqe);",
          "5748:   return io_connect_prep(req, sqe);",
          "5750:   return io_timeout_prep(req, sqe, false);",
          "5752:   return io_timeout_remove_prep(req, sqe);",
          "5754:   return io_async_cancel_prep(req, sqe);",
          "5756:   return io_timeout_prep(req, sqe, true);",
          "5758:   return io_accept_prep(req, sqe);",
          "5759:  case IORING_OP_FALLOCATE:",
          "5760:   return io_fallocate_prep(req, sqe);",
          "5761:  case IORING_OP_OPENAT:",
          "5762:   return io_openat_prep(req, sqe);",
          "5763:  case IORING_OP_CLOSE:",
          "5764:   return io_close_prep(req, sqe);",
          "5765:  case IORING_OP_FILES_UPDATE:",
          "5766:   return io_files_update_prep(req, sqe);",
          "5767:  case IORING_OP_STATX:",
          "5768:   return io_statx_prep(req, sqe);",
          "5769:  case IORING_OP_FADVISE:",
          "5770:   return io_fadvise_prep(req, sqe);",
          "5771:  case IORING_OP_MADVISE:",
          "5772:   return io_madvise_prep(req, sqe);",
          "5773:  case IORING_OP_OPENAT2:",
          "5774:   return io_openat2_prep(req, sqe);",
          "5775:  case IORING_OP_EPOLL_CTL:",
          "5776:   return io_epoll_ctl_prep(req, sqe);",
          "5777:  case IORING_OP_SPLICE:",
          "5778:   return io_splice_prep(req, sqe);",
          "5779:  case IORING_OP_PROVIDE_BUFFERS:",
          "5780:   return io_provide_buffers_prep(req, sqe);",
          "5781:  case IORING_OP_REMOVE_BUFFERS:",
          "5782:   return io_remove_buffers_prep(req, sqe);",
          "5783:  case IORING_OP_TEE:",
          "5784:   return io_tee_prep(req, sqe);",
          "5785:  }",
          "5787:  printk_once(KERN_WARNING \"io_uring: unhandled opcode %d\\n\",",
          "5788:    req->opcode);",
          "5789:  return-EINVAL;",
          "5790: }",
          "5792: static int io_req_defer_prep(struct io_kiocb *req,",
          "5793:         const struct io_uring_sqe *sqe)",
          "5794: {",
          "5795:  if (!sqe)",
          "5796:   return 0;",
          "5797:  if (io_alloc_async_data(req))",
          "5798:   return -EAGAIN;",
          "5799:  return io_req_prep(req, sqe);",
          "5800: }",
          "5802: static u32 io_get_sequence(struct io_kiocb *req)",
          "5803: {",
          "5804:  struct io_kiocb *pos;",
          "5805:  struct io_ring_ctx *ctx = req->ctx;",
          "5806:  u32 total_submitted, nr_reqs = 1;",
          "5808:  if (req->flags & REQ_F_LINK_HEAD)",
          "5809:   list_for_each_entry(pos, &req->link_list, link_list)",
          "5810:    nr_reqs++;",
          "5812:  total_submitted = ctx->cached_sq_head - ctx->cached_sq_dropped;",
          "5813:  return total_submitted - nr_reqs;",
          "5819:  struct io_defer_entry *de;",
          "5821:  u32 seq;",
          "5824:  if (likely(list_empty_careful(&ctx->defer_list) &&",
          "5825:   !(req->flags & REQ_F_IO_DRAIN)))",
          "5828:  seq = io_get_sequence(req);",
          "5830:  if (!req_need_defer(req, seq) && list_empty_careful(&ctx->defer_list))",
          "5831:   return 0;",
          "5833:  if (!req->async_data) {",
          "5834:   ret = io_req_defer_prep(req, sqe);",
          "5835:   if (ret)",
          "5836:    return ret;",
          "5837:  }",
          "5838:  io_prep_async_link(req);",
          "5839:  de = kmalloc(sizeof(*de), GFP_KERNEL);",
          "5840:  if (!de)",
          "5841:   return -ENOMEM;",
          "5844:  if (!req_need_defer(req, seq) && list_empty(&ctx->defer_list)) {",
          "5846:   kfree(de);",
          "5847:   io_queue_async_work(req);",
          "5848:   return -EIOCBQUEUED;",
          "5852:  de->req = req;",
          "5853:  de->seq = seq;",
          "5854:  list_add_tail(&de->list, &ctx->defer_list);",
          "5859: static void io_req_drop_files(struct io_kiocb *req)",
          "5860: {",
          "5861:  struct io_ring_ctx *ctx = req->ctx;",
          "5862:  unsigned long flags;",
          "5864:  spin_lock_irqsave(&ctx->inflight_lock, flags);",
          "5865:  list_del(&req->inflight_entry);",
          "5866:  if (waitqueue_active(&ctx->inflight_wait))",
          "5867:   wake_up(&ctx->inflight_wait);",
          "5868:  spin_unlock_irqrestore(&ctx->inflight_lock, flags);",
          "5869:  req->flags &= ~REQ_F_INFLIGHT;",
          "5870:  put_files_struct(req->work.identity->files);",
          "5871:  put_nsproxy(req->work.identity->nsproxy);",
          "5872:  req->work.flags &= ~IO_WQ_WORK_FILES;",
          "5873: }",
          "5875: static void __io_clean_op(struct io_kiocb *req)",
          "5876: {",
          "5877:  if (req->flags & REQ_F_BUFFER_SELECTED) {",
          "5878:   switch (req->opcode) {",
          "5879:   case IORING_OP_READV:",
          "5880:   case IORING_OP_READ_FIXED:",
          "5881:   case IORING_OP_READ:",
          "5882:    kfree((void *)(unsigned long)req->rw.addr);",
          "5883:    break;",
          "5884:   case IORING_OP_RECVMSG:",
          "5885:   case IORING_OP_RECV:",
          "5886:    kfree(req->sr_msg.kbuf);",
          "5887:    break;",
          "5888:   }",
          "5889:   req->flags &= ~REQ_F_BUFFER_SELECTED;",
          "5890:  }",
          "5892:  if (req->flags & REQ_F_NEED_CLEANUP) {",
          "5893:   switch (req->opcode) {",
          "5894:   case IORING_OP_READV:",
          "5895:   case IORING_OP_READ_FIXED:",
          "5896:   case IORING_OP_READ:",
          "5897:   case IORING_OP_WRITEV:",
          "5898:   case IORING_OP_WRITE_FIXED:",
          "5899:   case IORING_OP_WRITE: {",
          "5900:    struct io_async_rw *io = req->async_data;",
          "5901:    if (io->free_iovec)",
          "5902:     kfree(io->free_iovec);",
          "5903:    break;",
          "5904:    }",
          "5905:   case IORING_OP_RECVMSG:",
          "5906:   case IORING_OP_SENDMSG: {",
          "5907:    struct io_async_msghdr *io = req->async_data;",
          "5908:    if (io->iov != io->fast_iov)",
          "5909:     kfree(io->iov);",
          "5910:    break;",
          "5911:    }",
          "5912:   case IORING_OP_SPLICE:",
          "5913:   case IORING_OP_TEE:",
          "5914:    io_put_file(req, req->splice.file_in,",
          "5915:         (req->splice.flags & SPLICE_F_FD_IN_FIXED));",
          "5916:    break;",
          "5917:   case IORING_OP_OPENAT:",
          "5918:   case IORING_OP_OPENAT2:",
          "5919:    if (req->open.filename)",
          "5920:     putname(req->open.filename);",
          "5921:    break;",
          "5922:   }",
          "5923:   req->flags &= ~REQ_F_NEED_CLEANUP;",
          "5924:  }",
          "5926:  if (req->flags & REQ_F_INFLIGHT)",
          "5927:   io_req_drop_files(req);",
          "5928: }",
          "5930: static int io_issue_sqe(struct io_kiocb *req, bool force_nonblock,",
          "5931:    struct io_comp_state *cs)",
          "5938:   ret = io_nop(req, cs);",
          "5942:  case IORING_OP_READ:",
          "5943:   ret = io_read(req, force_nonblock, cs);",
          "5947:  case IORING_OP_WRITE:",
          "5948:   ret = io_write(req, force_nonblock, cs);",
          "5951:   ret = io_fsync(req, force_nonblock);",
          "5954:   ret = io_poll_add(req);",
          "5960:   ret = io_sync_file_range(req, force_nonblock);",
          "5963:   ret = io_sendmsg(req, force_nonblock, cs);",
          "5964:   break;",
          "5965:  case IORING_OP_SEND:",
          "5966:   ret = io_send(req, force_nonblock, cs);",
          "5969:   ret = io_recvmsg(req, force_nonblock, cs);",
          "5970:   break;",
          "5971:  case IORING_OP_RECV:",
          "5972:   ret = io_recv(req, force_nonblock, cs);",
          "5981:   ret = io_accept(req, force_nonblock, cs);",
          "5984:   ret = io_connect(req, force_nonblock, cs);",
          "5987:   ret = io_async_cancel(req);",
          "5988:   break;",
          "5989:  case IORING_OP_FALLOCATE:",
          "5990:   ret = io_fallocate(req, force_nonblock);",
          "5991:   break;",
          "5992:  case IORING_OP_OPENAT:",
          "5993:   ret = io_openat(req, force_nonblock);",
          "5994:   break;",
          "5995:  case IORING_OP_CLOSE:",
          "5996:   ret = io_close(req, force_nonblock, cs);",
          "5997:   break;",
          "5998:  case IORING_OP_FILES_UPDATE:",
          "5999:   ret = io_files_update(req, force_nonblock, cs);",
          "6000:   break;",
          "6001:  case IORING_OP_STATX:",
          "6002:   ret = io_statx(req, force_nonblock);",
          "6003:   break;",
          "6004:  case IORING_OP_FADVISE:",
          "6005:   ret = io_fadvise(req, force_nonblock);",
          "6006:   break;",
          "6007:  case IORING_OP_MADVISE:",
          "6008:   ret = io_madvise(req, force_nonblock);",
          "6009:   break;",
          "6010:  case IORING_OP_OPENAT2:",
          "6011:   ret = io_openat2(req, force_nonblock);",
          "6012:   break;",
          "6013:  case IORING_OP_EPOLL_CTL:",
          "6014:   ret = io_epoll_ctl(req, force_nonblock, cs);",
          "6015:   break;",
          "6016:  case IORING_OP_SPLICE:",
          "6017:   ret = io_splice(req, force_nonblock);",
          "6018:   break;",
          "6019:  case IORING_OP_PROVIDE_BUFFERS:",
          "6020:   ret = io_provide_buffers(req, force_nonblock, cs);",
          "6021:   break;",
          "6022:  case IORING_OP_REMOVE_BUFFERS:",
          "6023:   ret = io_remove_buffers(req, force_nonblock, cs);",
          "6024:   break;",
          "6025:  case IORING_OP_TEE:",
          "6026:   ret = io_tee(req, force_nonblock);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "3285:  if (ret)",
          "3286:   return ret;",
          "3289:   const bool in_async = io_wq_current_is_worker();",
          "3295:   if (in_async)",
          "3296:    mutex_lock(&ctx->uring_lock);",
          "",
          "[Removed Lines]",
          "3288:  if (ctx->flags & IORING_SETUP_IOPOLL) {",
          "3291:   if (req->result == -EAGAIN)",
          "3292:    return -EAGAIN;",
          "",
          "[Added Lines]",
          "6037:  if ((ctx->flags & IORING_SETUP_IOPOLL) && req->file) {",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "3304:  return 0;",
          "3305: }",
          "3308: {",
          "3310:  struct io_kiocb *req = container_of(work, struct io_kiocb, work);",
          "3312:  int ret = 0;",
          "3315:   ret = -ECANCELED;",
          "3317:  if (!ret) {",
          "3320:   do {",
          "",
          "[Removed Lines]",
          "3307: static void io_wq_submit_work(struct io_wq_work **workptr)",
          "3309:  struct io_wq_work *work = *workptr;",
          "3311:  struct io_kiocb *nxt = NULL;",
          "3314:  if (work->flags & IO_WQ_WORK_CANCEL)",
          "3318:   req->has_user = (work->flags & IO_WQ_WORK_HAS_MM) != 0;",
          "3319:   req->in_async = true;",
          "3321:    ret = io_issue_sqe(req, NULL, &nxt, false);",
          "",
          "[Added Lines]",
          "6053: static struct io_wq_work *io_wq_submit_work(struct io_wq_work *work)",
          "6056:  struct io_kiocb *timeout;",
          "6059:  timeout = io_prep_linked_timeout(req);",
          "6060:  if (timeout)",
          "6061:   io_queue_linked_timeout(timeout);",
          "6064:  if ((work->flags & (IO_WQ_WORK_CANCEL|IO_WQ_WORK_NO_CANCEL)) ==",
          "6065:     IO_WQ_WORK_CANCEL) {",
          "6067:  }",
          "6071:    ret = io_issue_sqe(req, false, NULL);",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "3330:   } while (1);",
          "3331:  }",
          "3336:  if (ret) {",
          "3337:   req_set_fail_links(req);",
          "3340:  }",
          "3367: }",
          "3369: static inline struct file *io_file_from_index(struct io_ring_ctx *ctx,",
          "",
          "[Removed Lines]",
          "3334:  io_put_req(req);",
          "3338:   io_cqring_add_event(req, ret);",
          "3339:   io_put_req(req);",
          "3343:  if (!ret && nxt)",
          "3344:   io_wq_assign_next(workptr, nxt);",
          "3345: }",
          "3347: static bool io_req_op_valid(int op)",
          "3348: {",
          "3349:  return op >= IORING_OP_NOP && op < IORING_OP_LAST;",
          "3350: }",
          "3352: static int io_req_needs_file(struct io_kiocb *req)",
          "3353: {",
          "3354:  switch (req->opcode) {",
          "3355:  case IORING_OP_NOP:",
          "3356:  case IORING_OP_POLL_REMOVE:",
          "3357:  case IORING_OP_TIMEOUT:",
          "3358:  case IORING_OP_TIMEOUT_REMOVE:",
          "3359:  case IORING_OP_ASYNC_CANCEL:",
          "3360:  case IORING_OP_LINK_TIMEOUT:",
          "3361:   return 0;",
          "3362:  default:",
          "3363:   if (io_req_op_valid(req->opcode))",
          "3364:    return 1;",
          "3365:   return -EINVAL;",
          "3366:  }",
          "",
          "[Added Lines]",
          "6085:   io_req_complete(req, ret);",
          "6088:  return io_steal_work(req);",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "3371: {",
          "3372:  struct fixed_file_table *table;",
          "3375:  return table->files[index & IORING_FILE_TABLE_MASK];",
          "3376: }",
          "3380: {",
          "3381:  struct io_ring_ctx *ctx = req->ctx;",
          "3399:   fd = array_index_nospec(fd, ctx->nr_user_files);",
          "3404:  } else {",
          "3407:   trace_io_uring_file_get(ctx, fd);",
          "3411:  }",
          "3414: }",
          "3417: {",
          "3439: }",
          "3441: static enum hrtimer_restart io_link_timeout_fn(struct hrtimer *timer)",
          "",
          "[Removed Lines]",
          "3374:  table = &ctx->file_table[index >> IORING_FILE_TABLE_SHIFT];",
          "3378: static int io_req_set_file(struct io_submit_state *state, struct io_kiocb *req,",
          "3379:       const struct io_uring_sqe *sqe)",
          "3382:  unsigned flags;",
          "3383:  int fd, ret;",
          "3385:  flags = READ_ONCE(sqe->flags);",
          "3386:  fd = READ_ONCE(sqe->fd);",
          "3388:  if (flags & IOSQE_IO_DRAIN)",
          "3389:   req->flags |= REQ_F_IO_DRAIN;",
          "3391:  ret = io_req_needs_file(req);",
          "3392:  if (ret <= 0)",
          "3393:   return ret;",
          "3395:  if (flags & IOSQE_FIXED_FILE) {",
          "3396:   if (unlikely(!ctx->file_table ||",
          "3397:       (unsigned) fd >= ctx->nr_user_files))",
          "3398:    return -EBADF;",
          "3400:   req->file = io_file_from_index(ctx, fd);",
          "3401:   if (!req->file)",
          "3402:    return -EBADF;",
          "3403:   req->flags |= REQ_F_FIXED_FILE;",
          "3405:   if (req->needs_fixed_file)",
          "3406:    return -EBADF;",
          "3408:   req->file = io_file_get(state, fd);",
          "3409:   if (unlikely(!req->file))",
          "3410:    return -EBADF;",
          "3413:  return 0;",
          "3416: static int io_grab_files(struct io_kiocb *req)",
          "3418:  int ret = -EBADF;",
          "3419:  struct io_ring_ctx *ctx = req->ctx;",
          "3421:  rcu_read_lock();",
          "3422:  spin_lock_irq(&ctx->inflight_lock);",
          "3429:  if (fcheck(req->ring_fd) == req->ring_file) {",
          "3430:   list_add(&req->inflight_entry, &ctx->inflight_list);",
          "3431:   req->flags |= REQ_F_INFLIGHT;",
          "3432:   req->work.files = current->files;",
          "3433:   ret = 0;",
          "3434:  }",
          "3435:  spin_unlock_irq(&ctx->inflight_lock);",
          "3436:  rcu_read_unlock();",
          "3438:  return ret;",
          "",
          "[Added Lines]",
          "6096:  table = &ctx->file_data->table[index >> IORING_FILE_TABLE_SHIFT];",
          "6100: static struct file *io_file_get(struct io_submit_state *state,",
          "6101:     struct io_kiocb *req, int fd, bool fixed)",
          "6104:  struct file *file;",
          "6106:  if (fixed) {",
          "6107:   if (unlikely((unsigned int)fd >= ctx->nr_user_files))",
          "6108:    return NULL;",
          "6110:   file = io_file_from_index(ctx, fd);",
          "6111:   if (file) {",
          "6112:    req->fixed_file_refs = &ctx->file_data->node->refs;",
          "6113:    percpu_ref_get(req->fixed_file_refs);",
          "6114:   }",
          "6117:   file = __io_file_get(state, fd);",
          "6120:  return file;",
          "6123: static int io_req_set_file(struct io_submit_state *state, struct io_kiocb *req,",
          "6124:       int fd)",
          "6126:  bool fixed;",
          "6128:  fixed = (req->flags & REQ_F_FIXED_FILE) != 0;",
          "6129:  if (unlikely(!fixed && io_async_submit(req->ctx)))",
          "6130:   return -EBADF;",
          "6132:  req->file = io_file_get(state, req, fd, fixed);",
          "6133:  if (req->file || io_op_defs[req->opcode].needs_file_no_error)",
          "6134:   return 0;",
          "6135:  return -EBADF;",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "3456:  if (!list_empty(&req->link_list)) {",
          "3457:   prev = list_entry(req->link_list.prev, struct io_kiocb,",
          "3458:       link_list);",
          "3460:    list_del_init(&req->link_list);",
          "3463:    prev = NULL;",
          "3464:  }",
          "",
          "[Removed Lines]",
          "3459:   if (refcount_inc_not_zero(&prev->refs)) {",
          "3461:    prev->flags &= ~REQ_F_LINK_TIMEOUT;",
          "3462:   } else",
          "",
          "[Added Lines]",
          "6156:   if (refcount_inc_not_zero(&prev->refs))",
          "6158:   else",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "3468:  if (prev) {",
          "3469:   req_set_fail_links(prev);",
          "3472:   io_put_req(prev);",
          "3473:  } else {",
          "3476:  }",
          "3477:  return HRTIMER_NORESTART;",
          "3478: }",
          "3481: {",
          "3489:  if (!list_empty(&req->link_list)) {",
          "3492:   data->timer.function = io_link_timeout_fn;",
          "3493:   hrtimer_start(&data->timer, timespec64_to_ktime(data->ts),",
          "3494:     data->mode);",
          "3495:  }",
          "3496:  spin_unlock_irq(&ctx->completion_lock);",
          "",
          "[Removed Lines]",
          "3470:   io_async_find_and_cancel(ctx, req, prev->user_data, NULL,",
          "3471:       -ETIME);",
          "3474:   io_cqring_add_event(req, -ETIME);",
          "3475:   io_put_req(req);",
          "3480: static void io_queue_linked_timeout(struct io_kiocb *req)",
          "3482:  struct io_ring_ctx *ctx = req->ctx;",
          "3488:  spin_lock_irq(&ctx->completion_lock);",
          "3490:   struct io_timeout_data *data = &req->io->timeout;",
          "",
          "[Added Lines]",
          "6166:   io_async_find_and_cancel(ctx, req, prev->user_data, -ETIME);",
          "6169:   io_req_complete(req, -ETIME);",
          "6174: static void __io_queue_linked_timeout(struct io_kiocb *req)",
          "6181:   struct io_timeout_data *data = req->async_data;",
          "6187: }",
          "6189: static void io_queue_linked_timeout(struct io_kiocb *req)",
          "6190: {",
          "6191:  struct io_ring_ctx *ctx = req->ctx;",
          "6193:  spin_lock_irq(&ctx->completion_lock);",
          "6194:  __io_queue_linked_timeout(req);",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "3503: {",
          "3504:  struct io_kiocb *nxt;",
          "3507:   return NULL;",
          "3509:  nxt = list_first_entry_or_null(&req->link_list, struct io_kiocb,",
          "",
          "[Removed Lines]",
          "3506:  if (!(req->flags & REQ_F_LINK))",
          "",
          "[Added Lines]",
          "6205:  if (!(req->flags & REQ_F_LINK_HEAD))",
          "6206:   return NULL;",
          "6207:  if (req->flags & REQ_F_LINK_TIMEOUT)",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "3511:  if (!nxt || nxt->opcode != IORING_OP_LINK_TIMEOUT)",
          "3512:   return NULL;",
          "3514:  req->flags |= REQ_F_LINK_TIMEOUT;",
          "3515:  return nxt;",
          "3516: }",
          "3519: {",
          "3520:  struct io_kiocb *linked_timeout;",
          "3522:  int ret;",
          "3524: again:",
          "3525:  linked_timeout = io_prep_linked_timeout(req);",
          "3539:   }",
          "3555:    io_queue_linked_timeout(linked_timeout);",
          "3563:   req_set_fail_links(req);",
          "3564:   io_put_req(req);",
          "3565:  }",
          "3572: }",
          "3575: {",
          "3576:  int ret;",
          "3584:  ret = io_req_defer(req, sqe);",
          "3585:  if (ret) {",
          "3586:   if (ret != -EIOCBQUEUED) {",
          "3588:    req_set_fail_links(req);",
          "3590:   }",
          "3593: }",
          "3596: {",
          "3597:  if (unlikely(req->flags & REQ_F_FAIL_LINK)) {",
          "3600:  } else",
          "3602: }",
          "3609: {",
          "3610:  struct io_ring_ctx *ctx = req->ctx;",
          "3611:  int ret;",
          "",
          "[Removed Lines]",
          "3518: static void __io_queue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3521:  struct io_kiocb *nxt = NULL;",
          "3527:  ret = io_issue_sqe(req, sqe, &nxt, true);",
          "3533:  if (ret == -EAGAIN && (!(req->flags & REQ_F_NOWAIT) ||",
          "3534:      (req->flags & REQ_F_MUST_PUNT))) {",
          "3535:   if (req->work.flags & IO_WQ_WORK_NEEDS_FILES) {",
          "3536:    ret = io_grab_files(req);",
          "3537:    if (ret)",
          "3538:     goto err;",
          "3545:   io_queue_async_work(req);",
          "3546:   goto done_req;",
          "3547:  }",
          "3549: err:",
          "3551:  io_put_req(req);",
          "3553:  if (linked_timeout) {",
          "3554:   if (!ret)",
          "3556:   else",
          "3557:    io_put_req(linked_timeout);",
          "3558:  }",
          "3561:  if (ret) {",
          "3562:   io_cqring_add_event(req, ret);",
          "3566: done_req:",
          "3567:  if (nxt) {",
          "3568:   req = nxt;",
          "3569:   nxt = NULL;",
          "3570:   goto again;",
          "3571:  }",
          "3574: static void io_queue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe)",
          "3578:  if (unlikely(req->ctx->drain_next)) {",
          "3579:   req->flags |= REQ_F_IO_DRAIN;",
          "3580:   req->ctx->drain_next = false;",
          "3581:  }",
          "3582:  req->ctx->drain_next = (req->flags & REQ_F_DRAIN_LINK);",
          "3587:    io_cqring_add_event(req, ret);",
          "3589:    io_double_put_req(req);",
          "3591:  } else",
          "3592:   __io_queue_sqe(req, sqe);",
          "3595: static inline void io_queue_link_head(struct io_kiocb *req)",
          "3598:   io_cqring_add_event(req, -ECANCELED);",
          "3599:   io_double_put_req(req);",
          "3601:   io_queue_sqe(req, NULL);",
          "3604: #define SQE_VALID_FLAGS (IOSQE_FIXED_FILE|IOSQE_IO_DRAIN|IOSQE_IO_LINK| \\",
          "3605:     IOSQE_IO_HARDLINK)",
          "3607: static bool io_submit_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,",
          "3608:      struct io_submit_state *state, struct io_kiocb **link)",
          "3614:  if (unlikely(sqe->flags & ~SQE_VALID_FLAGS)) {",
          "3615:   ret = -EINVAL;",
          "3616:   goto err_req;",
          "3617:  }",
          "3619:  ret = io_req_set_file(state, req, sqe);",
          "3620:  if (unlikely(ret)) {",
          "3621: err_req:",
          "3622:   io_cqring_add_event(req, ret);",
          "3623:   io_double_put_req(req);",
          "3624:   return false;",
          "3625:  }",
          "",
          "[Added Lines]",
          "6215:  nxt->flags |= REQ_F_LTIMEOUT_ACTIVE;",
          "6220: static void __io_queue_sqe(struct io_kiocb *req, struct io_comp_state *cs)",
          "6223:  const struct cred *old_creds = NULL;",
          "6229:  if ((req->flags & REQ_F_WORK_INITIALIZED) &&",
          "6230:      (req->work.flags & IO_WQ_WORK_CREDS) &&",
          "6231:      req->work.identity->creds != current_cred()) {",
          "6232:   if (old_creds)",
          "6233:    revert_creds(old_creds);",
          "6234:   if (old_creds == req->work.identity->creds)",
          "6236:   else",
          "6237:    old_creds = override_creds(req->work.identity->creds);",
          "6238:  }",
          "6240:  ret = io_issue_sqe(req, true, cs);",
          "6246:  if (ret == -EAGAIN && !(req->flags & REQ_F_NOWAIT)) {",
          "6247:   if (!io_arm_poll_handler(req)) {",
          "6252:    io_queue_async_work(req);",
          "6255:   if (linked_timeout)",
          "6256:    io_queue_linked_timeout(linked_timeout);",
          "6257:  } else if (likely(!ret)) {",
          "6259:   req = io_put_req_find_next(req);",
          "6260:   if (linked_timeout)",
          "6263:   if (req) {",
          "6264:    if (!(req->flags & REQ_F_FORCE_ASYNC))",
          "6265:     goto again;",
          "6266:    io_queue_async_work(req);",
          "6267:   }",
          "6268:  } else {",
          "6270:   req->flags &= ~REQ_F_LINK_TIMEOUT;",
          "6273:   io_req_complete(req, ret);",
          "6276:  if (old_creds)",
          "6277:   revert_creds(old_creds);",
          "6280: static void io_queue_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,",
          "6281:     struct io_comp_state *cs)",
          "6288: fail_req:",
          "6290:    io_put_req(req);",
          "6291:    io_req_complete(req, ret);",
          "6293:  } else if (req->flags & REQ_F_FORCE_ASYNC) {",
          "6294:   if (!req->async_data) {",
          "6295:    ret = io_req_defer_prep(req, sqe);",
          "6296:    if (unlikely(ret))",
          "6297:     goto fail_req;",
          "6298:   }",
          "6299:   io_queue_async_work(req);",
          "6300:  } else {",
          "6301:   if (sqe) {",
          "6302:    ret = io_req_prep(req, sqe);",
          "6303:    if (unlikely(ret))",
          "6304:     goto fail_req;",
          "6305:   }",
          "6306:   __io_queue_sqe(req, cs);",
          "6307:  }",
          "6310: static inline void io_queue_link_head(struct io_kiocb *req,",
          "6311:           struct io_comp_state *cs)",
          "6314:   io_put_req(req);",
          "6315:   io_req_complete(req, -ECANCELED);",
          "6317:   io_queue_sqe(req, NULL, cs);",
          "6320: static int io_submit_sqe(struct io_kiocb *req, const struct io_uring_sqe *sqe,",
          "6321:     struct io_kiocb **link, struct io_comp_state *cs)",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "3634:  if (*link) {",
          "3646:   }",
          "3648:   ret = io_req_defer_prep(req, sqe);",
          "3653:   }",
          "3666:  } else {",
          "3668:  }",
          "3671: }",
          "",
          "[Removed Lines]",
          "3635:   struct io_kiocb *prev = *link;",
          "3637:   if (sqe->flags & IOSQE_IO_DRAIN)",
          "3638:    (*link)->flags |= REQ_F_DRAIN_LINK | REQ_F_IO_DRAIN;",
          "3640:   if (sqe->flags & IOSQE_IO_HARDLINK)",
          "3641:    req->flags |= REQ_F_HARDLINK;",
          "3643:   if (io_alloc_async_ctx(req)) {",
          "3644:    ret = -EAGAIN;",
          "3645:    goto err_req;",
          "3649:   if (ret) {",
          "3651:    prev->flags |= REQ_F_FAIL_LINK;",
          "3652:    goto err_req;",
          "3654:   trace_io_uring_link(ctx, req, prev);",
          "3655:   list_add_tail(&req->link_list, &prev->link_list);",
          "3656:  } else if (sqe->flags & (IOSQE_IO_LINK|IOSQE_IO_HARDLINK)) {",
          "3657:   req->flags |= REQ_F_LINK;",
          "3658:   if (sqe->flags & IOSQE_IO_HARDLINK)",
          "3659:    req->flags |= REQ_F_HARDLINK;",
          "3661:   INIT_LIST_HEAD(&req->link_list);",
          "3662:   ret = io_req_defer_prep(req, sqe);",
          "3663:   if (ret)",
          "3664:    req->flags |= REQ_F_FAIL_LINK;",
          "3667:   io_queue_sqe(req, sqe);",
          "3670:  return true;",
          "",
          "[Added Lines]",
          "6334:   struct io_kiocb *head = *link;",
          "6343:   if (req->flags & REQ_F_IO_DRAIN) {",
          "6344:    head->flags |= REQ_F_IO_DRAIN;",
          "6345:    ctx->drain_next = 1;",
          "6348:   if (unlikely(ret)) {",
          "6350:    head->flags |= REQ_F_FAIL_LINK;",
          "6351:    return ret;",
          "6352:   }",
          "6353:   trace_io_uring_link(ctx, req, head);",
          "6354:   list_add_tail(&req->link_list, &head->link_list);",
          "6357:   if (!(req->flags & (REQ_F_LINK | REQ_F_HARDLINK))) {",
          "6358:    io_queue_link_head(head, cs);",
          "6362:   if (unlikely(ctx->drain_next)) {",
          "6363:    req->flags |= REQ_F_IO_DRAIN;",
          "6364:    ctx->drain_next = 0;",
          "6365:   }",
          "6366:   if (req->flags & (REQ_F_LINK | REQ_F_HARDLINK)) {",
          "6367:    req->flags |= REQ_F_LINK_HEAD;",
          "6368:    INIT_LIST_HEAD(&req->link_list);",
          "6370:    ret = io_req_defer_prep(req, sqe);",
          "6371:    if (unlikely(ret))",
          "6372:     req->flags |= REQ_F_FAIL_LINK;",
          "6374:   } else {",
          "6375:    io_queue_sqe(req, sqe, cs);",
          "6376:   }",
          "6379:  return 0;",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "3676: static void io_submit_state_end(struct io_submit_state *state)",
          "3677: {",
          "3678:  blk_finish_plug(&state->plug);",
          "3680:  if (state->free_reqs)",
          "3683: }",
          "3688: static void io_submit_state_start(struct io_submit_state *state,",
          "3690: {",
          "3691:  blk_start_plug(&state->plug);",
          "3692:  state->free_reqs = 0;",
          "3693:  state->file = NULL;",
          "3694:  state->ios_left = max_ios;",
          "",
          "[Removed Lines]",
          "3679:  io_file_put(state);",
          "3681:   kmem_cache_free_bulk(req_cachep, state->free_reqs,",
          "3682:      &state->reqs[state->cur_req]);",
          "3689:       unsigned int max_ios)",
          "",
          "[Added Lines]",
          "6387:  if (!list_empty(&state->comp.list))",
          "6388:   io_submit_flush_completions(&state->comp);",
          "6390:  io_state_file_put(state);",
          "6392:   kmem_cache_free_bulk(req_cachep, state->free_reqs, state->reqs);",
          "6399:       struct io_ring_ctx *ctx, unsigned int max_ios)",
          "6402:  state->comp.nr = 0;",
          "6403:  INIT_LIST_HEAD(&state->comp.list);",
          "6404:  state->comp.ctx = ctx;",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "3698: {",
          "3699:  struct io_rings *rings = ctx->rings;",
          "3709: }",
          "",
          "[Removed Lines]",
          "3701:  if (ctx->cached_sq_head != READ_ONCE(rings->sq.head)) {",
          "3707:   smp_store_release(&rings->sq.head, ctx->cached_sq_head);",
          "3708:  }",
          "",
          "[Added Lines]",
          "6419:  smp_store_release(&rings->sq.head, ctx->cached_sq_head);",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "3721: {",
          "3723:  u32 *sq_array = ctx->sq_array;",
          "3724:  unsigned head;",
          "",
          "[Removed Lines]",
          "3719: static bool io_get_sqring(struct io_ring_ctx *ctx, struct io_kiocb *req,",
          "3720:      const struct io_uring_sqe **sqe_ptr)",
          "3722:  struct io_rings *rings = ctx->rings;",
          "",
          "[Added Lines]",
          "6430: static const struct io_uring_sqe *io_get_sqe(struct io_ring_ctx *ctx)",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "3751:   return true;",
          "3752:  }",
          "3759: }",
          "3764: {",
          "3778:  }",
          "3822:   }",
          "3823:  }",
          "3834: }",
          "3837: {",
          "3941:    }",
          "3945:   }",
          "3953:  }",
          "3962:  kthread_parkme();",
          "",
          "[Removed Lines]",
          "3734:  head = ctx->cached_sq_head;",
          "3736:  if (unlikely(head == smp_load_acquire(&rings->sq.tail)))",
          "3737:   return false;",
          "3739:  head = READ_ONCE(sq_array[head & ctx->sq_mask]);",
          "3740:  if (likely(head < ctx->sq_entries)) {",
          "3746:   req->sequence = ctx->cached_sq_head;",
          "3748:   req->opcode = READ_ONCE((*sqe_ptr)->opcode);",
          "3749:   req->user_data = READ_ONCE((*sqe_ptr)->user_data);",
          "3750:   ctx->cached_sq_head++;",
          "3755:  ctx->cached_sq_head++;",
          "3756:  ctx->cached_sq_dropped++;",
          "3757:  WRITE_ONCE(rings->sq_dropped, ctx->cached_sq_dropped);",
          "3758:  return false;",
          "3761: static int io_submit_sqes(struct io_ring_ctx *ctx, unsigned int nr,",
          "3762:      struct file *ring_file, int ring_fd,",
          "3763:      struct mm_struct **mm, bool async)",
          "3765:  struct io_submit_state state, *statep = NULL;",
          "3766:  struct io_kiocb *link = NULL;",
          "3767:  int i, submitted = 0;",
          "3768:  bool mm_fault = false;",
          "3771:  if (!list_empty(&ctx->cq_overflow_list) &&",
          "3772:      !io_cqring_overflow_flush(ctx, false))",
          "3773:   return -EBUSY;",
          "3775:  if (nr > IO_PLUG_THRESHOLD) {",
          "3776:   io_submit_state_start(&state, nr);",
          "3777:   statep = &state;",
          "3780:  for (i = 0; i < nr; i++) {",
          "3781:   const struct io_uring_sqe *sqe;",
          "3782:   struct io_kiocb *req;",
          "3783:   unsigned int sqe_flags;",
          "3785:   req = io_get_req(ctx, statep);",
          "3786:   if (unlikely(!req)) {",
          "3787:    if (!submitted)",
          "3788:     submitted = -EAGAIN;",
          "3789:    break;",
          "3790:   }",
          "3791:   if (!io_get_sqring(ctx, req, &sqe)) {",
          "3792:    __io_free_req(req);",
          "3793:    break;",
          "3794:   }",
          "3796:   if (io_req_needs_user(req) && !*mm) {",
          "3797:    mm_fault = mm_fault || !mmget_not_zero(ctx->sqo_mm);",
          "3798:    if (!mm_fault) {",
          "3799:     use_mm(ctx->sqo_mm);",
          "3801:    }",
          "3802:   }",
          "3804:   submitted++;",
          "3805:   sqe_flags = sqe->flags;",
          "3807:   req->ring_file = ring_file;",
          "3808:   req->ring_fd = ring_fd;",
          "3809:   req->has_user = *mm != NULL;",
          "3810:   req->in_async = async;",
          "3811:   req->needs_fixed_file = async;",
          "3812:   trace_io_uring_submit_sqe(ctx, req->user_data, true, async);",
          "3813:   if (!io_submit_sqe(req, sqe, statep, &link))",
          "3814:    break;",
          "3819:   if (!(sqe_flags & (IOSQE_IO_LINK|IOSQE_IO_HARDLINK)) && link) {",
          "3820:    io_queue_link_head(link);",
          "3821:    link = NULL;",
          "3825:  if (link)",
          "3826:   io_queue_link_head(link);",
          "3827:  if (statep)",
          "3828:   io_submit_state_end(&state);",
          "3831:  io_commit_sqring(ctx);",
          "3833:  return submitted;",
          "3836: static int io_sq_thread(void *data)",
          "3838:  struct io_ring_ctx *ctx = data;",
          "3839:  struct mm_struct *cur_mm = NULL;",
          "3840:  const struct cred *old_cred;",
          "3841:  mm_segment_t old_fs;",
          "3842:  DEFINE_WAIT(wait);",
          "3843:  unsigned inflight;",
          "3844:  unsigned long timeout;",
          "3845:  int ret;",
          "3847:  complete(&ctx->completions[1]);",
          "3849:  old_fs = get_fs();",
          "3850:  set_fs(USER_DS);",
          "3851:  old_cred = override_creds(ctx->creds);",
          "3853:  ret = timeout = inflight = 0;",
          "3854:  while (!kthread_should_park()) {",
          "3855:   unsigned int to_submit;",
          "3857:   if (inflight) {",
          "3858:    unsigned nr_events = 0;",
          "3860:    if (ctx->flags & IORING_SETUP_IOPOLL) {",
          "3869:     mutex_lock(&ctx->uring_lock);",
          "3870:     if (!list_empty(&ctx->poll_list))",
          "3871:      __io_iopoll_check(ctx, &nr_events, 0);",
          "3872:     else",
          "3873:      inflight = 0;",
          "3874:     mutex_unlock(&ctx->uring_lock);",
          "3875:    } else {",
          "3880:     nr_events = inflight;",
          "3881:    }",
          "3883:    inflight -= nr_events;",
          "3884:    if (!inflight)",
          "3885:     timeout = jiffies + ctx->sq_thread_idle;",
          "3886:   }",
          "3888:   to_submit = io_sqring_entries(ctx);",
          "3894:   if (!to_submit || ret == -EBUSY) {",
          "3902:    if (inflight ||",
          "3903:        (!time_after(jiffies, timeout) && ret != -EBUSY)) {",
          "3904:     cond_resched();",
          "3905:     continue;",
          "3906:    }",
          "3914:    if (cur_mm) {",
          "3915:     unuse_mm(cur_mm);",
          "3916:     mmput(cur_mm);",
          "3917:     cur_mm = NULL;",
          "3918:    }",
          "3920:    prepare_to_wait(&ctx->sqo_wait, &wait,",
          "3921:       TASK_INTERRUPTIBLE);",
          "3924:    ctx->rings->sq_flags |= IORING_SQ_NEED_WAKEUP;",
          "3926:    smp_mb();",
          "3928:    to_submit = io_sqring_entries(ctx);",
          "3929:    if (!to_submit || ret == -EBUSY) {",
          "3930:     if (kthread_should_park()) {",
          "3931:      finish_wait(&ctx->sqo_wait, &wait);",
          "3932:      break;",
          "3933:     }",
          "3934:     if (signal_pending(current))",
          "3935:      flush_signals(current);",
          "3936:     schedule();",
          "3937:     finish_wait(&ctx->sqo_wait, &wait);",
          "3939:     ctx->rings->sq_flags &= ~IORING_SQ_NEED_WAKEUP;",
          "3940:     continue;",
          "3942:    finish_wait(&ctx->sqo_wait, &wait);",
          "3944:    ctx->rings->sq_flags &= ~IORING_SQ_NEED_WAKEUP;",
          "3947:   to_submit = min(to_submit, ctx->sq_entries);",
          "3948:   mutex_lock(&ctx->uring_lock);",
          "3949:   ret = io_submit_sqes(ctx, to_submit, NULL, -1, &cur_mm, true);",
          "3950:   mutex_unlock(&ctx->uring_lock);",
          "3951:   if (ret > 0)",
          "3952:    inflight += ret;",
          "3955:  set_fs(old_fs);",
          "3956:  if (cur_mm) {",
          "3957:   unuse_mm(cur_mm);",
          "3958:   mmput(cur_mm);",
          "3959:  }",
          "3960:  revert_creds(old_cred);",
          "",
          "[Added Lines]",
          "6443:  head = READ_ONCE(sq_array[ctx->cached_sq_head & ctx->sq_mask]);",
          "6444:  if (likely(head < ctx->sq_entries))",
          "6445:   return &ctx->sq_sqes[head];",
          "6448:  ctx->cached_sq_dropped++;",
          "6449:  WRITE_ONCE(ctx->rings->sq_dropped, ctx->cached_sq_dropped);",
          "6450:  return NULL;",
          "6451: }",
          "6453: static inline void io_consume_sqe(struct io_ring_ctx *ctx)",
          "6454: {",
          "6455:  ctx->cached_sq_head++;",
          "6456: }",
          "6463: static inline bool io_check_restriction(struct io_ring_ctx *ctx,",
          "6464:      struct io_kiocb *req,",
          "6465:      unsigned int sqe_flags)",
          "6466: {",
          "6467:  if (!ctx->restricted)",
          "6470:  if (!test_bit(req->opcode, ctx->restrictions.sqe_op))",
          "6471:   return false;",
          "6473:  if ((sqe_flags & ctx->restrictions.sqe_flags_required) !=",
          "6474:      ctx->restrictions.sqe_flags_required)",
          "6475:   return false;",
          "6477:  if (sqe_flags & ~(ctx->restrictions.sqe_flags_allowed |",
          "6478:      ctx->restrictions.sqe_flags_required))",
          "6479:   return false;",
          "6481:  return true;",
          "6482: }",
          "6484: #define SQE_VALID_FLAGS (IOSQE_FIXED_FILE|IOSQE_IO_DRAIN|IOSQE_IO_LINK| \\",
          "6485:     IOSQE_IO_HARDLINK | IOSQE_ASYNC | \\",
          "6486:     IOSQE_BUFFER_SELECT)",
          "6488: static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req,",
          "6489:          const struct io_uring_sqe *sqe,",
          "6490:          struct io_submit_state *state)",
          "6491: {",
          "6492:  unsigned int sqe_flags;",
          "6493:  int id, ret;",
          "6495:  req->opcode = READ_ONCE(sqe->opcode);",
          "6496:  req->user_data = READ_ONCE(sqe->user_data);",
          "6497:  req->async_data = NULL;",
          "6498:  req->file = NULL;",
          "6499:  req->ctx = ctx;",
          "6500:  req->flags = 0;",
          "6502:  refcount_set(&req->refs, 2);",
          "6503:  req->task = current;",
          "6504:  req->result = 0;",
          "6506:  if (unlikely(req->opcode >= IORING_OP_LAST))",
          "6507:   return -EINVAL;",
          "6509:  if (unlikely(io_sq_thread_acquire_mm(ctx, req)))",
          "6510:   return -EFAULT;",
          "6512:  sqe_flags = READ_ONCE(sqe->flags);",
          "6514:  if (unlikely(sqe_flags & ~SQE_VALID_FLAGS))",
          "6515:   return -EINVAL;",
          "6517:  if (unlikely(!io_check_restriction(ctx, req, sqe_flags)))",
          "6518:   return -EACCES;",
          "6520:  if ((sqe_flags & IOSQE_BUFFER_SELECT) &&",
          "6521:      !io_op_defs[req->opcode].buffer_select)",
          "6522:   return -EOPNOTSUPP;",
          "6524:  id = READ_ONCE(sqe->personality);",
          "6525:  if (id) {",
          "6526:   struct io_identity *iod;",
          "6528:   iod = idr_find(&ctx->personality_idr, id);",
          "6529:   if (unlikely(!iod))",
          "6530:    return -EINVAL;",
          "6531:   refcount_inc(&iod->count);",
          "6533:   __io_req_init_async(req);",
          "6534:   get_cred(iod->creds);",
          "6535:   req->work.identity = iod;",
          "6536:   req->work.flags |= IO_WQ_WORK_CREDS;",
          "6540:  req->flags |= sqe_flags;",
          "6542:  if (!io_op_defs[req->opcode].needs_file)",
          "6543:   return 0;",
          "6545:  ret = io_req_set_file(state, req, READ_ONCE(sqe->fd));",
          "6546:  state->ios_left--;",
          "6547:  return ret;",
          "6548: }",
          "6550: static int io_submit_sqes(struct io_ring_ctx *ctx, unsigned int nr)",
          "6551: {",
          "6552:  struct io_submit_state state;",
          "6553:  struct io_kiocb *link = NULL;",
          "6554:  int i, submitted = 0;",
          "6557:  if (test_bit(0, &ctx->sq_check_overflow)) {",
          "6558:   if (!list_empty(&ctx->cq_overflow_list) &&",
          "6559:       !io_cqring_overflow_flush(ctx, false, NULL, NULL))",
          "6560:    return -EBUSY;",
          "6561:  }",
          "6564:  nr = min3(nr, ctx->sq_entries, io_sqring_entries(ctx));",
          "6566:  if (!percpu_ref_tryget_many(&ctx->refs, nr))",
          "6567:   return -EAGAIN;",
          "6569:  percpu_counter_add(&current->io_uring->inflight, nr);",
          "6570:  refcount_add(nr, &current->usage);",
          "6572:  io_submit_state_start(&state, ctx, nr);",
          "6574:  for (i = 0; i < nr; i++) {",
          "6575:   const struct io_uring_sqe *sqe;",
          "6576:   struct io_kiocb *req;",
          "6577:   int err;",
          "6579:   sqe = io_get_sqe(ctx);",
          "6580:   if (unlikely(!sqe)) {",
          "6581:    io_consume_sqe(ctx);",
          "6582:    break;",
          "6583:   }",
          "6584:   req = io_alloc_req(ctx, &state);",
          "6585:   if (unlikely(!req)) {",
          "6586:    if (!submitted)",
          "6587:     submitted = -EAGAIN;",
          "6588:    break;",
          "6589:   }",
          "6590:   io_consume_sqe(ctx);",
          "6592:   submitted++;",
          "6594:   err = io_init_req(ctx, req, sqe, &state);",
          "6595:   if (unlikely(err)) {",
          "6596: fail_req:",
          "6597:    io_put_req(req);",
          "6598:    io_req_complete(req, err);",
          "6599:    break;",
          "6600:   }",
          "6602:   trace_io_uring_submit_sqe(ctx, req->opcode, req->user_data,",
          "6603:       true, io_async_submit(ctx));",
          "6604:   err = io_submit_sqe(req, sqe, &link, &state.comp);",
          "6605:   if (err)",
          "6606:    goto fail_req;",
          "6607:  }",
          "6609:  if (unlikely(submitted != nr)) {",
          "6610:   int ref_used = (submitted == -EAGAIN) ? 0 : submitted;",
          "6611:   struct io_uring_task *tctx = current->io_uring;",
          "6612:   int unused = nr - ref_used;",
          "6614:   percpu_ref_put_many(&ctx->refs, unused);",
          "6615:   percpu_counter_sub(&tctx->inflight, unused);",
          "6616:   put_task_struct_many(current, unused);",
          "6617:  }",
          "6618:  if (link)",
          "6619:   io_queue_link_head(link, &state.comp);",
          "6620:  io_submit_state_end(&state);",
          "6623:  io_commit_sqring(ctx);",
          "6625:  return submitted;",
          "6626: }",
          "6628: static inline void io_ring_set_wakeup_flag(struct io_ring_ctx *ctx)",
          "6629: {",
          "6631:  spin_lock_irq(&ctx->completion_lock);",
          "6632:  ctx->rings->sq_flags |= IORING_SQ_NEED_WAKEUP;",
          "6633:  spin_unlock_irq(&ctx->completion_lock);",
          "6634: }",
          "6636: static inline void io_ring_clear_wakeup_flag(struct io_ring_ctx *ctx)",
          "6637: {",
          "6638:  spin_lock_irq(&ctx->completion_lock);",
          "6639:  ctx->rings->sq_flags &= ~IORING_SQ_NEED_WAKEUP;",
          "6640:  spin_unlock_irq(&ctx->completion_lock);",
          "6641: }",
          "6643: static int io_sq_wake_function(struct wait_queue_entry *wqe, unsigned mode,",
          "6644:           int sync, void *key)",
          "6645: {",
          "6646:  struct io_ring_ctx *ctx = container_of(wqe, struct io_ring_ctx, sqo_wait_entry);",
          "6647:  int ret;",
          "6649:  ret = autoremove_wake_function(wqe, mode, sync, key);",
          "6650:  if (ret) {",
          "6651:   unsigned long flags;",
          "6653:   spin_lock_irqsave(&ctx->completion_lock, flags);",
          "6654:   ctx->rings->sq_flags &= ~IORING_SQ_NEED_WAKEUP;",
          "6655:   spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "6656:  }",
          "6657:  return ret;",
          "6660: enum sq_ret {",
          "6661:  SQT_IDLE = 1,",
          "6662:  SQT_SPIN = 2,",
          "6663:  SQT_DID_WORK = 4,",
          "6664: };",
          "6666: static enum sq_ret __io_sq_thread(struct io_ring_ctx *ctx,",
          "6667:       unsigned long start_jiffies, bool cap_entries)",
          "6669:  unsigned long timeout = start_jiffies + ctx->sq_thread_idle;",
          "6670:  struct io_sq_data *sqd = ctx->sq_data;",
          "6671:  unsigned int to_submit;",
          "6672:  int ret = 0;",
          "6674: again:",
          "6675:  if (!list_empty(&ctx->iopoll_list)) {",
          "6676:   unsigned nr_events = 0;",
          "6678:   mutex_lock(&ctx->uring_lock);",
          "6679:   if (!list_empty(&ctx->iopoll_list) && !need_resched())",
          "6680:    io_do_iopoll(ctx, &nr_events, 0);",
          "6681:   mutex_unlock(&ctx->uring_lock);",
          "6684:  to_submit = io_sqring_entries(ctx);",
          "6690:  if (!to_submit || ret == -EBUSY || need_resched()) {",
          "6697:   io_sq_thread_drop_mm();",
          "6706:   if (!list_empty(&ctx->iopoll_list) || need_resched() ||",
          "6707:       (!time_after(jiffies, timeout) && ret != -EBUSY &&",
          "6708:       !percpu_ref_is_dying(&ctx->refs)))",
          "6709:    return SQT_SPIN;",
          "6711:   prepare_to_wait(&sqd->wait, &ctx->sqo_wait_entry,",
          "6712:      TASK_INTERRUPTIBLE);",
          "6721:   if ((ctx->flags & IORING_SETUP_IOPOLL) &&",
          "6722:       !list_empty_careful(&ctx->iopoll_list)) {",
          "6723:    finish_wait(&sqd->wait, &ctx->sqo_wait_entry);",
          "6724:    goto again;",
          "6727:   to_submit = io_sqring_entries(ctx);",
          "6728:   if (!to_submit || ret == -EBUSY)",
          "6729:    return SQT_IDLE;",
          "6732:  finish_wait(&sqd->wait, &ctx->sqo_wait_entry);",
          "6733:  io_ring_clear_wakeup_flag(ctx);",
          "6736:  if (cap_entries && to_submit > 8)",
          "6737:   to_submit = 8;",
          "6739:  mutex_lock(&ctx->uring_lock);",
          "6740:  if (likely(!percpu_ref_is_dying(&ctx->refs)))",
          "6741:   ret = io_submit_sqes(ctx, to_submit);",
          "6742:  mutex_unlock(&ctx->uring_lock);",
          "6744:  if (!io_sqring_full(ctx) && wq_has_sleeper(&ctx->sqo_sq_wait))",
          "6745:   wake_up(&ctx->sqo_sq_wait);",
          "6747:  return SQT_DID_WORK;",
          "6750: static void io_sqd_init_new(struct io_sq_data *sqd)",
          "6752:  struct io_ring_ctx *ctx;",
          "6754:  while (!list_empty(&sqd->ctx_new_list)) {",
          "6755:   ctx = list_first_entry(&sqd->ctx_new_list, struct io_ring_ctx, sqd_list);",
          "6756:   init_wait(&ctx->sqo_wait_entry);",
          "6757:   ctx->sqo_wait_entry.func = io_sq_wake_function;",
          "6758:   list_move_tail(&ctx->sqd_list, &sqd->ctx_list);",
          "6759:   complete(&ctx->sq_thread_comp);",
          "6760:  }",
          "6761: }",
          "6763: static int io_sq_thread(void *data)",
          "6764: {",
          "6765:  struct cgroup_subsys_state *cur_css = NULL;",
          "6766:  const struct cred *old_cred = NULL;",
          "6767:  struct io_sq_data *sqd = data;",
          "6768:  struct io_ring_ctx *ctx;",
          "6769:  unsigned long start_jiffies;",
          "6771:  start_jiffies = jiffies;",
          "6772:  while (!kthread_should_stop()) {",
          "6773:   enum sq_ret ret = 0;",
          "6774:   bool cap_entries;",
          "6781:   if (kthread_should_park())",
          "6782:    kthread_parkme();",
          "6784:   if (unlikely(!list_empty(&sqd->ctx_new_list)))",
          "6785:    io_sqd_init_new(sqd);",
          "6787:   cap_entries = !list_is_singular(&sqd->ctx_list);",
          "6789:   list_for_each_entry(ctx, &sqd->ctx_list, sqd_list) {",
          "6790:    if (current->cred != ctx->creds) {",
          "6791:     if (old_cred)",
          "6792:      revert_creds(old_cred);",
          "6793:     old_cred = override_creds(ctx->creds);",
          "6795:    io_sq_thread_associate_blkcg(ctx, &cur_css);",
          "6796: #ifdef CONFIG_AUDIT",
          "6797:    current->loginuid = ctx->loginuid;",
          "6798:    current->sessionid = ctx->sessionid;",
          "6799: #endif",
          "6801:    ret |= __io_sq_thread(ctx, start_jiffies, cap_entries);",
          "6803:    io_sq_thread_drop_mm();",
          "6806:   if (ret & SQT_SPIN) {",
          "6807:    io_run_task_work();",
          "6808:    cond_resched();",
          "6809:   } else if (ret == SQT_IDLE) {",
          "6810:    if (kthread_should_park())",
          "6811:     continue;",
          "6812:    list_for_each_entry(ctx, &sqd->ctx_list, sqd_list)",
          "6813:     io_ring_set_wakeup_flag(ctx);",
          "6814:    schedule();",
          "6815:    start_jiffies = jiffies;",
          "6816:    list_for_each_entry(ctx, &sqd->ctx_list, sqd_list)",
          "6817:     io_ring_clear_wakeup_flag(ctx);",
          "6818:   }",
          "6821:  io_run_task_work();",
          "6823:  if (cur_css)",
          "6824:   io_sq_thread_unassociate_blkcg();",
          "6825:  if (old_cred)",
          "6826:   revert_creds(old_cred);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "3997:  return autoremove_wake_function(curr, mode, wake_flags, key);",
          "3998: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6866: static int io_run_task_work_sig(void)",
          "6867: {",
          "6868:  if (io_run_task_work())",
          "6869:   return 1;",
          "6870:  if (!signal_pending(current))",
          "6871:   return 0;",
          "6872:  if (current->jobctl & JOBCTL_TASK_WORK) {",
          "6873:   spin_lock_irq(&current->sighand->siglock);",
          "6874:   current->jobctl &= ~JOBCTL_TASK_WORK;",
          "6875:   recalc_sigpending();",
          "6876:   spin_unlock_irq(&current->sighand->siglock);",
          "6877:   return 1;",
          "6878:  }",
          "6879:  return -EINTR;",
          "6880: }",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "4016:  struct io_rings *rings = ctx->rings;",
          "4017:  int ret = 0;",
          "4022:  if (sig) {",
          "4023: #ifdef CONFIG_COMPAT",
          "",
          "[Removed Lines]",
          "4019:  if (io_cqring_events(ctx, false) >= min_events)",
          "4020:   return 0;",
          "",
          "[Added Lines]",
          "6901:  do {",
          "6902:   if (io_cqring_events(ctx, false) >= min_events)",
          "6903:    return 0;",
          "6904:   if (!io_run_task_work())",
          "6905:    break;",
          "6906:  } while (1);",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "4037:  do {",
          "4038:   prepare_to_wait_exclusive(&ctx->wait, &iowq.wq,",
          "4039:       TASK_INTERRUPTIBLE);",
          "4040:   if (io_should_wake(&iowq, false))",
          "4041:    break;",
          "4042:   schedule();",
          "4047:  } while (1);",
          "4048:  finish_wait(&ctx->wait, &iowq.wq);",
          "",
          "[Removed Lines]",
          "4043:   if (signal_pending(current)) {",
          "4044:    ret = -EINTR;",
          "4045:    break;",
          "4046:   }",
          "",
          "[Added Lines]",
          "6927:   ret = io_run_task_work_sig();",
          "6928:   if (ret > 0)",
          "6929:    continue;",
          "6930:   else if (ret < 0)",
          "6931:    break;",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "4075: #endif",
          "4076: }",
          "4078: static int io_sqe_files_unregister(struct io_ring_ctx *ctx)",
          "4079: {",
          "4080:  unsigned nr_tables, i;",
          "4083:   return -ENXIO;",
          "4085:  __io_sqe_files_unregister(ctx);",
          "4086:  nr_tables = DIV_ROUND_UP(ctx->nr_user_files, IORING_MAX_FILES_TABLE);",
          "4087:  for (i = 0; i < nr_tables; i++)",
          "4091:  ctx->nr_user_files = 0;",
          "4092:  return 0;",
          "4093: }",
          "4096: {",
          "4107:  }",
          "4108: }",
          "",
          "[Removed Lines]",
          "4082:  if (!ctx->file_table)",
          "4088:   kfree(ctx->file_table[i].files);",
          "4089:  kfree(ctx->file_table);",
          "4090:  ctx->file_table = NULL;",
          "4095: static void io_sq_thread_stop(struct io_ring_ctx *ctx)",
          "4097:  if (ctx->sqo_thread) {",
          "4098:   wait_for_completion(&ctx->completions[1]);",
          "4104:   kthread_park(ctx->sqo_thread);",
          "4105:   kthread_stop(ctx->sqo_thread);",
          "4106:   ctx->sqo_thread = NULL;",
          "",
          "[Added Lines]",
          "6966: static void io_file_ref_kill(struct percpu_ref *ref)",
          "6967: {",
          "6968:  struct fixed_file_data *data;",
          "6970:  data = container_of(ref, struct fixed_file_data, refs);",
          "6971:  complete(&data->done);",
          "6972: }",
          "6976:  struct fixed_file_data *data = ctx->file_data;",
          "6977:  struct fixed_file_ref_node *ref_node = NULL;",
          "6980:  if (!data)",
          "6983:  spin_lock(&data->lock);",
          "6984:  ref_node = data->node;",
          "6985:  spin_unlock(&data->lock);",
          "6986:  if (ref_node)",
          "6987:   percpu_ref_kill(&ref_node->refs);",
          "6989:  percpu_ref_kill(&data->refs);",
          "6992:  flush_delayed_work(&ctx->file_put_work);",
          "6993:  wait_for_completion(&data->done);",
          "6998:   kfree(data->table[i].files);",
          "6999:  kfree(data->table);",
          "7000:  percpu_ref_exit(&data->refs);",
          "7001:  kfree(data);",
          "7002:  ctx->file_data = NULL;",
          "7007: static void io_put_sq_data(struct io_sq_data *sqd)",
          "7009:  if (refcount_dec_and_test(&sqd->refs)) {",
          "7015:   if (sqd->thread) {",
          "7016:    kthread_park(sqd->thread);",
          "7017:    kthread_stop(sqd->thread);",
          "7018:   }",
          "7020:   kfree(sqd);",
          "7021:  }",
          "7022: }",
          "7024: static struct io_sq_data *io_attach_sq_data(struct io_uring_params *p)",
          "7025: {",
          "7026:  struct io_ring_ctx *ctx_attach;",
          "7027:  struct io_sq_data *sqd;",
          "7028:  struct fd f;",
          "7030:  f = fdget(p->wq_fd);",
          "7031:  if (!f.file)",
          "7032:   return ERR_PTR(-ENXIO);",
          "7033:  if (f.file->f_op != &io_uring_fops) {",
          "7034:   fdput(f);",
          "7035:   return ERR_PTR(-EINVAL);",
          "7036:  }",
          "7038:  ctx_attach = f.file->private_data;",
          "7039:  sqd = ctx_attach->sq_data;",
          "7040:  if (!sqd) {",
          "7041:   fdput(f);",
          "7042:   return ERR_PTR(-EINVAL);",
          "7043:  }",
          "7045:  refcount_inc(&sqd->refs);",
          "7046:  fdput(f);",
          "7047:  return sqd;",
          "7048: }",
          "7050: static struct io_sq_data *io_get_sq_data(struct io_uring_params *p)",
          "7051: {",
          "7052:  struct io_sq_data *sqd;",
          "7054:  if (p->flags & IORING_SETUP_ATTACH_WQ)",
          "7055:   return io_attach_sq_data(p);",
          "7057:  sqd = kzalloc(sizeof(*sqd), GFP_KERNEL);",
          "7058:  if (!sqd)",
          "7059:   return ERR_PTR(-ENOMEM);",
          "7061:  refcount_set(&sqd->refs, 1);",
          "7062:  INIT_LIST_HEAD(&sqd->ctx_list);",
          "7063:  INIT_LIST_HEAD(&sqd->ctx_new_list);",
          "7064:  mutex_init(&sqd->ctx_lock);",
          "7065:  mutex_init(&sqd->lock);",
          "7066:  init_waitqueue_head(&sqd->wait);",
          "7067:  return sqd;",
          "7068: }",
          "7070: static void io_sq_thread_unpark(struct io_sq_data *sqd)",
          "7071:  __releases(&sqd->lock)",
          "7072: {",
          "7073:  if (!sqd->thread)",
          "7074:   return;",
          "7075:  kthread_unpark(sqd->thread);",
          "7076:  mutex_unlock(&sqd->lock);",
          "7077: }",
          "7079: static void io_sq_thread_park(struct io_sq_data *sqd)",
          "7080:  __acquires(&sqd->lock)",
          "7081: {",
          "7082:  if (!sqd->thread)",
          "7083:   return;",
          "7084:  mutex_lock(&sqd->lock);",
          "7085:  kthread_park(sqd->thread);",
          "7086: }",
          "7088: static void io_sq_thread_stop(struct io_ring_ctx *ctx)",
          "7089: {",
          "7090:  struct io_sq_data *sqd = ctx->sq_data;",
          "7092:  if (sqd) {",
          "7093:   if (sqd->thread) {",
          "7100:    wake_up_process(sqd->thread);",
          "7101:    wait_for_completion(&ctx->sq_thread_comp);",
          "7103:    io_sq_thread_park(sqd);",
          "7104:   }",
          "7106:   mutex_lock(&sqd->ctx_lock);",
          "7107:   list_del(&ctx->sqd_list);",
          "7108:   mutex_unlock(&sqd->ctx_lock);",
          "7110:   if (sqd->thread) {",
          "7111:    finish_wait(&sqd->wait, &ctx->sqo_wait_entry);",
          "7112:    io_sq_thread_unpark(sqd);",
          "7113:   }",
          "7115:   io_put_sq_data(sqd);",
          "7116:   ctx->sq_data = NULL;",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "4118: }",
          "4120: #if defined(CONFIG_UNIX)",
          "",
          "[Removed Lines]",
          "4121: static void io_destruct_skb(struct sk_buff *skb)",
          "4122: {",
          "4123:  struct io_ring_ctx *ctx = skb->sk->sk_user_data;",
          "4125:  if (ctx->io_wq)",
          "4126:   io_wq_flush(ctx->io_wq);",
          "4128:  unix_destruct_scm(skb);",
          "4129: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "4140:  struct sk_buff *skb;",
          "4141:  int i, nr_files;",
          "4150:  fpl = kzalloc(sizeof(*fpl), GFP_KERNEL);",
          "4151:  if (!fpl)",
          "4152:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "4143:  if (!capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {",
          "4144:   unsigned long inflight = ctx->user->unix_inflight + nr;",
          "4146:   if (inflight > task_rlimit(current, RLIMIT_NOFILE))",
          "4147:    return -EMFILE;",
          "4148:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "4175:   fpl->max = SCM_MAX_FD;",
          "4176:   fpl->count = nr_files;",
          "4177:   UNIXCB(skb).fp = fpl;",
          "4179:   refcount_add(skb->truesize, &sk->sk_wmem_alloc);",
          "4180:   skb_queue_head(&sk->sk_receive_queue, skb);",
          "",
          "[Removed Lines]",
          "4178:   skb->destructor = io_destruct_skb;",
          "",
          "[Added Lines]",
          "7171:   skb->destructor = unix_destruct_scm;",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "4231: }",
          "4232: #endif",
          "4236: {",
          "4237:  int i;",
          "4239:  for (i = 0; i < nr_tables; i++) {",
          "4241:   unsigned this_files;",
          "4243:   this_files = min(nr_files, IORING_MAX_FILES_TABLE);",
          "",
          "[Removed Lines]",
          "4234: static int io_sqe_alloc_file_tables(struct io_ring_ctx *ctx, unsigned nr_tables,",
          "4235:         unsigned nr_files)",
          "4240:   struct fixed_file_table *table = &ctx->file_table[i];",
          "",
          "[Added Lines]",
          "7227: static int io_sqe_alloc_file_tables(struct fixed_file_data *file_data,",
          "7228:         unsigned nr_tables, unsigned nr_files)",
          "7233:   struct fixed_file_table *table = &file_data->table[i];",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "4252:   return 0;",
          "4254:  for (i = 0; i < nr_tables; i++) {",
          "4256:   kfree(table->files);",
          "4257:  }",
          "4258:  return 1;",
          "4259: }",
          "4261: static int io_sqe_files_register(struct io_ring_ctx *ctx, void __user *arg,",
          "4262:      unsigned nr_args)",
          "4263: {",
          "4264:  __s32 __user *fds = (__s32 __user *) arg;",
          "4270:   return -EBUSY;",
          "4271:  if (!nr_args)",
          "4272:   return -EINVAL;",
          "4273:  if (nr_args > IORING_MAX_FIXED_FILES)",
          "4274:   return -EMFILE;",
          "4280:   return -ENOMEM;",
          "4288:  for (i = 0; i < nr_args; i++, ctx->nr_user_files++) {",
          "4289:   struct fixed_file_table *table;",
          "4290:   unsigned index;",
          "4298:    continue;",
          "4305:   ret = -EBADF;",
          "",
          "[Removed Lines]",
          "4255:   struct fixed_file_table *table = &ctx->file_table[i];",
          "4265:  unsigned nr_tables;",
          "4266:  int fd, ret = 0;",
          "4267:  unsigned i;",
          "4269:  if (ctx->file_table)",
          "4276:  nr_tables = DIV_ROUND_UP(nr_args, IORING_MAX_FILES_TABLE);",
          "4277:  ctx->file_table = kcalloc(nr_tables, sizeof(struct fixed_file_table),",
          "4278:      GFP_KERNEL);",
          "4279:  if (!ctx->file_table)",
          "4282:  if (io_sqe_alloc_file_tables(ctx, nr_tables, nr_args)) {",
          "4283:   kfree(ctx->file_table);",
          "4284:   ctx->file_table = NULL;",
          "4285:   return -ENOMEM;",
          "4286:  }",
          "4292:   ret = -EFAULT;",
          "4293:   if (copy_from_user(&fd, &fds[i], sizeof(fd)))",
          "4294:    break;",
          "4296:   if (fd == -1) {",
          "4297:    ret = 0;",
          "4299:   }",
          "4301:   table = &ctx->file_table[i >> IORING_FILE_TABLE_SHIFT];",
          "4302:   index = i & IORING_FILE_TABLE_MASK;",
          "4303:   table->files[index] = fget(fd);",
          "4306:   if (!table->files[index])",
          "4307:    break;",
          "",
          "[Added Lines]",
          "7248:   struct fixed_file_table *table = &file_data->table[i];",
          "7254: static void io_ring_file_put(struct io_ring_ctx *ctx, struct file *file)",
          "7255: {",
          "7256: #if defined(CONFIG_UNIX)",
          "7257:  struct sock *sock = ctx->ring_sock->sk;",
          "7258:  struct sk_buff_head list, *head = &sock->sk_receive_queue;",
          "7259:  struct sk_buff *skb;",
          "7260:  int i;",
          "7262:  __skb_queue_head_init(&list);",
          "7268:  skb = skb_dequeue(head);",
          "7269:  while (skb) {",
          "7270:   struct scm_fp_list *fp;",
          "7272:   fp = UNIXCB(skb).fp;",
          "7273:   for (i = 0; i < fp->count; i++) {",
          "7274:    int left;",
          "7276:    if (fp->fp[i] != file)",
          "7277:     continue;",
          "7279:    unix_notinflight(fp->user, fp->fp[i]);",
          "7280:    left = fp->count - 1 - i;",
          "7281:    if (left) {",
          "7282:     memmove(&fp->fp[i], &fp->fp[i + 1],",
          "7283:       left * sizeof(struct file *));",
          "7284:    }",
          "7285:    fp->count--;",
          "7286:    if (!fp->count) {",
          "7287:     kfree_skb(skb);",
          "7288:     skb = NULL;",
          "7289:    } else {",
          "7290:     __skb_queue_tail(&list, skb);",
          "7291:    }",
          "7292:    fput(file);",
          "7293:    file = NULL;",
          "7294:    break;",
          "7295:   }",
          "7297:   if (!file)",
          "7298:    break;",
          "7300:   __skb_queue_tail(&list, skb);",
          "7302:   skb = skb_dequeue(head);",
          "7303:  }",
          "7305:  if (skb_peek(&list)) {",
          "7306:   spin_lock_irq(&head->lock);",
          "7307:   while ((skb = __skb_dequeue(&list)) != NULL)",
          "7308:    __skb_queue_tail(head, skb);",
          "7309:   spin_unlock_irq(&head->lock);",
          "7310:  }",
          "7311: #else",
          "7312:  fput(file);",
          "7313: #endif",
          "7314: }",
          "7316: struct io_file_put {",
          "7317:  struct list_head list;",
          "7318:  struct file *file;",
          "7319: };",
          "7321: static void __io_file_put_work(struct fixed_file_ref_node *ref_node)",
          "7322: {",
          "7323:  struct fixed_file_data *file_data = ref_node->file_data;",
          "7324:  struct io_ring_ctx *ctx = file_data->ctx;",
          "7325:  struct io_file_put *pfile, *tmp;",
          "7327:  list_for_each_entry_safe(pfile, tmp, &ref_node->file_list, list) {",
          "7328:   list_del(&pfile->list);",
          "7329:   io_ring_file_put(ctx, pfile->file);",
          "7330:   kfree(pfile);",
          "7331:  }",
          "7333:  percpu_ref_exit(&ref_node->refs);",
          "7334:  kfree(ref_node);",
          "7335:  percpu_ref_put(&file_data->refs);",
          "7336: }",
          "7338: static void io_file_put_work(struct work_struct *work)",
          "7339: {",
          "7340:  struct io_ring_ctx *ctx;",
          "7341:  struct llist_node *node;",
          "7343:  ctx = container_of(work, struct io_ring_ctx, file_put_work.work);",
          "7344:  node = llist_del_all(&ctx->file_put_llist);",
          "7346:  while (node) {",
          "7347:   struct fixed_file_ref_node *ref_node;",
          "7348:   struct llist_node *next = node->next;",
          "7350:   ref_node = llist_entry(node, struct fixed_file_ref_node, llist);",
          "7351:   __io_file_put_work(ref_node);",
          "7352:   node = next;",
          "7353:  }",
          "7354: }",
          "7356: static void io_file_data_ref_zero(struct percpu_ref *ref)",
          "7357: {",
          "7358:  struct fixed_file_ref_node *ref_node;",
          "7359:  struct fixed_file_data *data;",
          "7360:  struct io_ring_ctx *ctx;",
          "7361:  bool first_add = false;",
          "7362:  int delay = HZ;",
          "7364:  ref_node = container_of(ref, struct fixed_file_ref_node, refs);",
          "7365:  data = ref_node->file_data;",
          "7366:  ctx = data->ctx;",
          "7368:  spin_lock(&data->lock);",
          "7369:  ref_node->done = true;",
          "7371:  while (!list_empty(&data->ref_list)) {",
          "7372:   ref_node = list_first_entry(&data->ref_list,",
          "7373:      struct fixed_file_ref_node, node);",
          "7375:   if (!ref_node->done)",
          "7376:    break;",
          "7377:   list_del(&ref_node->node);",
          "7378:   first_add |= llist_add(&ref_node->llist, &ctx->file_put_llist);",
          "7379:  }",
          "7380:  spin_unlock(&data->lock);",
          "7382:  if (percpu_ref_is_dying(&data->refs))",
          "7383:   delay = 0;",
          "7385:  if (!delay)",
          "7386:   mod_delayed_work(system_wq, &ctx->file_put_work, 0);",
          "7387:  else if (first_add)",
          "7388:   queue_delayed_work(system_wq, &ctx->file_put_work, delay);",
          "7389: }",
          "7391: static struct fixed_file_ref_node *alloc_fixed_file_ref_node(",
          "7392:    struct io_ring_ctx *ctx)",
          "7393: {",
          "7394:  struct fixed_file_ref_node *ref_node;",
          "7396:  ref_node = kzalloc(sizeof(*ref_node), GFP_KERNEL);",
          "7397:  if (!ref_node)",
          "7398:   return ERR_PTR(-ENOMEM);",
          "7400:  if (percpu_ref_init(&ref_node->refs, io_file_data_ref_zero,",
          "7401:        0, GFP_KERNEL)) {",
          "7402:   kfree(ref_node);",
          "7403:   return ERR_PTR(-ENOMEM);",
          "7404:  }",
          "7405:  INIT_LIST_HEAD(&ref_node->node);",
          "7406:  INIT_LIST_HEAD(&ref_node->file_list);",
          "7407:  ref_node->file_data = ctx->file_data;",
          "7408:  ref_node->done = false;",
          "7409:  return ref_node;",
          "7410: }",
          "7412: static void destroy_fixed_file_ref_node(struct fixed_file_ref_node *ref_node)",
          "7413: {",
          "7414:  percpu_ref_exit(&ref_node->refs);",
          "7415:  kfree(ref_node);",
          "7416: }",
          "7422:  unsigned nr_tables, i;",
          "7423:  struct file *file;",
          "7424:  int fd, ret = -ENOMEM;",
          "7425:  struct fixed_file_ref_node *ref_node;",
          "7426:  struct fixed_file_data *file_data;",
          "7428:  if (ctx->file_data)",
          "7435:  file_data = kzalloc(sizeof(*ctx->file_data), GFP_KERNEL);",
          "7436:  if (!file_data)",
          "7438:  file_data->ctx = ctx;",
          "7439:  init_completion(&file_data->done);",
          "7440:  INIT_LIST_HEAD(&file_data->ref_list);",
          "7441:  spin_lock_init(&file_data->lock);",
          "7443:  nr_tables = DIV_ROUND_UP(nr_args, IORING_MAX_FILES_TABLE);",
          "7444:  file_data->table = kcalloc(nr_tables, sizeof(*file_data->table),",
          "7445:        GFP_KERNEL);",
          "7446:  if (!file_data->table)",
          "7447:   goto out_free;",
          "7449:  if (percpu_ref_init(&file_data->refs, io_file_ref_kill,",
          "7450:     PERCPU_REF_ALLOW_REINIT, GFP_KERNEL))",
          "7451:   goto out_free;",
          "7453:  if (io_sqe_alloc_file_tables(file_data, nr_tables, nr_args))",
          "7454:   goto out_ref;",
          "7455:  ctx->file_data = file_data;",
          "7461:   if (copy_from_user(&fd, &fds[i], sizeof(fd))) {",
          "7462:    ret = -EFAULT;",
          "7463:    goto out_fput;",
          "7464:   }",
          "7466:   if (fd == -1)",
          "7469:   file = fget(fd);",
          "7471:   if (!file)",
          "7472:    goto out_fput;",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "4318:   }",
          "4320:  }",
          "4322:  if (ret) {",
          "4336:   return ret;",
          "4337:  }",
          "4341:   io_sqe_files_unregister(ctx);",
          "4343:  return ret;",
          "4385:    fput(file);",
          "4403:  }",
          "4407: }",
          "4409: static int io_sqe_file_register(struct io_ring_ctx *ctx, struct file *file,",
          "",
          "[Removed Lines]",
          "4315:   if (table->files[index]->f_op == &io_uring_fops) {",
          "4316:    fput(table->files[index]);",
          "4317:    break;",
          "4319:   ret = 0;",
          "4323:   for (i = 0; i < ctx->nr_user_files; i++) {",
          "4324:    struct file *file;",
          "4326:    file = io_file_from_index(ctx, i);",
          "4327:    if (file)",
          "4328:     fput(file);",
          "4329:   }",
          "4330:   for (i = 0; i < nr_tables; i++)",
          "4331:    kfree(ctx->file_table[i].files);",
          "4333:   kfree(ctx->file_table);",
          "4334:   ctx->file_table = NULL;",
          "4335:   ctx->nr_user_files = 0;",
          "4339:  ret = io_sqe_files_scm(ctx);",
          "4340:  if (ret)",
          "4344: }",
          "4346: static void io_sqe_file_unregister(struct io_ring_ctx *ctx, int index)",
          "4347: {",
          "4348: #if defined(CONFIG_UNIX)",
          "4349:  struct file *file = io_file_from_index(ctx, index);",
          "4350:  struct sock *sock = ctx->ring_sock->sk;",
          "4351:  struct sk_buff_head list, *head = &sock->sk_receive_queue;",
          "4352:  struct sk_buff *skb;",
          "4353:  int i;",
          "4355:  __skb_queue_head_init(&list);",
          "4361:  skb = skb_dequeue(head);",
          "4362:  while (skb) {",
          "4363:   struct scm_fp_list *fp;",
          "4365:   fp = UNIXCB(skb).fp;",
          "4366:   for (i = 0; i < fp->count; i++) {",
          "4367:    int left;",
          "4369:    if (fp->fp[i] != file)",
          "4370:     continue;",
          "4372:    unix_notinflight(fp->user, fp->fp[i]);",
          "4373:    left = fp->count - 1 - i;",
          "4374:    if (left) {",
          "4375:     memmove(&fp->fp[i], &fp->fp[i + 1],",
          "4376:       left * sizeof(struct file *));",
          "4377:    }",
          "4378:    fp->count--;",
          "4379:    if (!fp->count) {",
          "4380:     kfree_skb(skb);",
          "4381:     skb = NULL;",
          "4382:    } else {",
          "4383:     __skb_queue_tail(&list, skb);",
          "4384:    }",
          "4386:    file = NULL;",
          "4387:    break;",
          "4388:   }",
          "4390:   if (!file)",
          "4391:    break;",
          "4393:   __skb_queue_tail(&list, skb);",
          "4395:   skb = skb_dequeue(head);",
          "4396:  }",
          "4398:  if (skb_peek(&list)) {",
          "4399:   spin_lock_irq(&head->lock);",
          "4400:   while ((skb = __skb_dequeue(&list)) != NULL)",
          "4401:    __skb_queue_tail(head, skb);",
          "4402:   spin_unlock_irq(&head->lock);",
          "4404: #else",
          "4405:  fput(io_file_from_index(ctx, index));",
          "4406: #endif",
          "",
          "[Added Lines]",
          "7481:   if (file->f_op == &io_uring_fops) {",
          "7482:    fput(file);",
          "7483:    goto out_fput;",
          "7485:   table = &file_data->table[i >> IORING_FILE_TABLE_SHIFT];",
          "7486:   index = i & IORING_FILE_TABLE_MASK;",
          "7487:   table->files[index] = file;",
          "7490:  ret = io_sqe_files_scm(ctx);",
          "7492:   io_sqe_files_unregister(ctx);",
          "7496:  ref_node = alloc_fixed_file_ref_node(ctx);",
          "7497:  if (IS_ERR(ref_node)) {",
          "7499:   return PTR_ERR(ref_node);",
          "7500:  }",
          "7502:  file_data->node = ref_node;",
          "7503:  spin_lock(&file_data->lock);",
          "7504:  list_add_tail(&ref_node->node, &file_data->ref_list);",
          "7505:  spin_unlock(&file_data->lock);",
          "7506:  percpu_ref_get(&file_data->refs);",
          "7508: out_fput:",
          "7509:  for (i = 0; i < ctx->nr_user_files; i++) {",
          "7510:   file = io_file_from_index(ctx, i);",
          "7511:   if (file)",
          "7514:  for (i = 0; i < nr_tables; i++)",
          "7515:   kfree(file_data->table[i].files);",
          "7516:  ctx->nr_user_files = 0;",
          "7517: out_ref:",
          "7518:  percpu_ref_exit(&file_data->refs);",
          "7519: out_free:",
          "7520:  kfree(file_data->table);",
          "7521:  kfree(file_data);",
          "7522:  ctx->file_data = NULL;",
          "7523:  return ret;",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "4449: #endif",
          "4450: }",
          "4454: {",
          "4456:  __s32 __user *fds;",
          "4457:  int fd, i, err;",
          "4458:  __u32 done;",
          "4469:   return -EOVERFLOW;",
          "4470:  if (done > ctx->nr_user_files)",
          "4471:   return -EINVAL;",
          "4473:  done = 0;",
          "4475:  while (nr_args) {",
          "4476:   struct fixed_file_table *table;",
          "4477:   unsigned index;",
          "",
          "[Removed Lines]",
          "4452: static int io_sqe_files_update(struct io_ring_ctx *ctx, void __user *arg,",
          "4453:           unsigned nr_args)",
          "4455:  struct io_uring_files_update up;",
          "4460:  if (!ctx->file_table)",
          "4461:   return -ENXIO;",
          "4462:  if (!nr_args)",
          "4463:   return -EINVAL;",
          "4464:  if (copy_from_user(&up, arg, sizeof(up)))",
          "4465:   return -EFAULT;",
          "4466:  if (up.resv)",
          "4467:   return -EINVAL;",
          "4468:  if (check_add_overflow(up.offset, nr_args, &done))",
          "4474:  fds = u64_to_user_ptr(up.fds);",
          "",
          "[Added Lines]",
          "7569: static int io_queue_file_removal(struct fixed_file_data *data,",
          "7570:      struct file *file)",
          "7572:  struct io_file_put *pfile;",
          "7573:  struct fixed_file_ref_node *ref_node = data->node;",
          "7575:  pfile = kzalloc(sizeof(*pfile), GFP_KERNEL);",
          "7576:  if (!pfile)",
          "7577:   return -ENOMEM;",
          "7579:  pfile->file = file;",
          "7580:  list_add(&pfile->list, &ref_node->file_list);",
          "7582:  return 0;",
          "7583: }",
          "7585: static int __io_sqe_files_update(struct io_ring_ctx *ctx,",
          "7586:      struct io_uring_files_update *up,",
          "7587:      unsigned nr_args)",
          "7588: {",
          "7589:  struct fixed_file_data *data = ctx->file_data;",
          "7590:  struct fixed_file_ref_node *ref_node;",
          "7591:  struct file *file;",
          "7595:  bool needs_switch = false;",
          "7597:  if (check_add_overflow(up->offset, nr_args, &done))",
          "7602:  ref_node = alloc_fixed_file_ref_node(ctx);",
          "7603:  if (IS_ERR(ref_node))",
          "7604:   return PTR_ERR(ref_node);",
          "7607:  fds = u64_to_user_ptr(up->fds);",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "4481:    err = -EFAULT;",
          "4482:    break;",
          "4483:   }",
          "4486:   index = i & IORING_FILE_TABLE_MASK;",
          "4487:   if (table->files[index]) {",
          "4489:    table->files[index] = NULL;",
          "4490:   }",
          "4491:   if (fd != -1) {",
          "4494:    file = fget(fd);",
          "4495:    if (!file) {",
          "4496:     err = -EBADF;",
          "",
          "[Removed Lines]",
          "4484:   i = array_index_nospec(up.offset, ctx->nr_user_files);",
          "4485:   table = &ctx->file_table[i >> IORING_FILE_TABLE_SHIFT];",
          "4488:    io_sqe_file_unregister(ctx, i);",
          "4492:    struct file *file;",
          "",
          "[Added Lines]",
          "7617:   i = array_index_nospec(up->offset, ctx->nr_user_files);",
          "7618:   table = &ctx->file_data->table[i >> IORING_FILE_TABLE_SHIFT];",
          "7621:    file = table->files[index];",
          "7622:    err = io_queue_file_removal(data, file);",
          "7623:    if (err)",
          "7624:     break;",
          "7626:    needs_switch = true;",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "4511:    }",
          "4512:    table->files[index] = file;",
          "4513:    err = io_sqe_file_register(ctx, file, i);",
          "4515:     break;",
          "4516:   }",
          "4517:   nr_args--;",
          "4518:   done++;",
          "4520:  }",
          "4522:  return done ? done : err;",
          "4523: }",
          "4526: {",
          "4527:  struct io_kiocb *req = container_of(work, struct io_kiocb, work);",
          "4529:  io_put_req(req);",
          "4530: }",
          "4533: {",
          "4537: }",
          "4541: {",
          "4544:  int ret;",
          "4550:  if (ctx->flags & IORING_SETUP_SQPOLL) {",
          "4551:   ret = -EPERM;",
          "4552:   if (!capable(CAP_SYS_ADMIN))",
          "4553:    goto err;",
          "4555:   ctx->sq_thread_idle = msecs_to_jiffies(p->sq_thread_idle);",
          "4556:   if (!ctx->sq_thread_idle)",
          "4557:    ctx->sq_thread_idle = HZ;",
          "4559:   if (p->flags & IORING_SETUP_SQ_AFF) {",
          "4560:    int cpu = p->sq_thread_cpu;",
          "",
          "[Removed Lines]",
          "4514:    if (err)",
          "4519:   up.offset++;",
          "4525: static void io_put_work(struct io_wq_work *work)",
          "4532: static void io_get_work(struct io_wq_work *work)",
          "4534:  struct io_kiocb *req = container_of(work, struct io_kiocb, work);",
          "4536:  refcount_inc(&req->refs);",
          "4539: static int io_sq_offload_start(struct io_ring_ctx *ctx,",
          "4540:           struct io_uring_params *p)",
          "4542:  struct io_wq_data data;",
          "4543:  unsigned concurrency;",
          "4546:  init_waitqueue_head(&ctx->sqo_wait);",
          "4547:  mmgrab(current->mm);",
          "4548:  ctx->sqo_mm = current->mm;",
          "",
          "[Added Lines]",
          "7649:    if (err) {",
          "7650:     table->files[index] = NULL;",
          "7651:     fput(file);",
          "7653:    }",
          "7657:   up->offset++;",
          "7660:  if (needs_switch) {",
          "7661:   percpu_ref_kill(&data->node->refs);",
          "7662:   spin_lock(&data->lock);",
          "7663:   list_add_tail(&ref_node->node, &data->ref_list);",
          "7664:   data->node = ref_node;",
          "7665:   spin_unlock(&data->lock);",
          "7666:   percpu_ref_get(&ctx->file_data->refs);",
          "7667:  } else",
          "7668:   destroy_fixed_file_ref_node(ref_node);",
          "7673: static int io_sqe_files_update(struct io_ring_ctx *ctx, void __user *arg,",
          "7674:           unsigned nr_args)",
          "7675: {",
          "7676:  struct io_uring_files_update up;",
          "7678:  if (!ctx->file_data)",
          "7679:   return -ENXIO;",
          "7680:  if (!nr_args)",
          "7681:   return -EINVAL;",
          "7682:  if (copy_from_user(&up, arg, sizeof(up)))",
          "7683:   return -EFAULT;",
          "7684:  if (up.resv)",
          "7685:   return -EINVAL;",
          "7687:  return __io_sqe_files_update(ctx, &up, nr_args);",
          "7688: }",
          "7690: static void io_free_work(struct io_wq_work *work)",
          "7698: static int io_init_wq_offload(struct io_ring_ctx *ctx,",
          "7699:          struct io_uring_params *p)",
          "7701:  struct io_wq_data data;",
          "7702:  struct fd f;",
          "7703:  struct io_ring_ctx *ctx_attach;",
          "7704:  unsigned int concurrency;",
          "7705:  int ret = 0;",
          "7707:  data.user = ctx->user;",
          "7708:  data.free_work = io_free_work;",
          "7709:  data.do_work = io_wq_submit_work;",
          "7711:  if (!(p->flags & IORING_SETUP_ATTACH_WQ)) {",
          "7713:   concurrency = min(ctx->sq_entries, 4 * num_online_cpus());",
          "7715:   ctx->io_wq = io_wq_create(concurrency, &data);",
          "7716:   if (IS_ERR(ctx->io_wq)) {",
          "7717:    ret = PTR_ERR(ctx->io_wq);",
          "7718:    ctx->io_wq = NULL;",
          "7719:   }",
          "7720:   return ret;",
          "7721:  }",
          "7723:  f = fdget(p->wq_fd);",
          "7724:  if (!f.file)",
          "7725:   return -EBADF;",
          "7727:  if (f.file->f_op != &io_uring_fops) {",
          "7728:   ret = -EINVAL;",
          "7729:   goto out_fput;",
          "7730:  }",
          "7732:  ctx_attach = f.file->private_data;",
          "7734:  if (!io_wq_get(ctx_attach->io_wq, &data)) {",
          "7735:   ret = -EINVAL;",
          "7736:   goto out_fput;",
          "7737:  }",
          "7739:  ctx->io_wq = ctx_attach->io_wq;",
          "7740: out_fput:",
          "7741:  fdput(f);",
          "7742:  return ret;",
          "7745: static int io_uring_alloc_task_context(struct task_struct *task)",
          "7747:  struct io_uring_task *tctx;",
          "7750:  tctx = kmalloc(sizeof(*tctx), GFP_KERNEL);",
          "7751:  if (unlikely(!tctx))",
          "7752:   return -ENOMEM;",
          "7754:  ret = percpu_counter_init(&tctx->inflight, 0, GFP_KERNEL);",
          "7755:  if (unlikely(ret)) {",
          "7756:   kfree(tctx);",
          "7757:   return ret;",
          "7758:  }",
          "7760:  xa_init(&tctx->xa);",
          "7761:  init_waitqueue_head(&tctx->wait);",
          "7762:  tctx->last = NULL;",
          "7763:  atomic_set(&tctx->in_idle, 0);",
          "7764:  tctx->sqpoll = false;",
          "7765:  io_init_identity(&tctx->__identity);",
          "7766:  tctx->identity = &tctx->__identity;",
          "7767:  task->io_uring = tctx;",
          "7768:  return 0;",
          "7769: }",
          "7771: void __io_uring_free(struct task_struct *tsk)",
          "7772: {",
          "7773:  struct io_uring_task *tctx = tsk->io_uring;",
          "7775:  WARN_ON_ONCE(!xa_empty(&tctx->xa));",
          "7776:  WARN_ON_ONCE(refcount_read(&tctx->identity->count) != 1);",
          "7777:  if (tctx->identity != &tctx->__identity)",
          "7778:   kfree(tctx->identity);",
          "7779:  percpu_counter_destroy(&tctx->inflight);",
          "7780:  kfree(tctx);",
          "7781:  tsk->io_uring = NULL;",
          "7782: }",
          "7784: static int io_sq_offload_create(struct io_ring_ctx *ctx,",
          "7785:     struct io_uring_params *p)",
          "7786: {",
          "7787:  int ret;",
          "7790:   struct io_sq_data *sqd;",
          "7796:   sqd = io_get_sq_data(p);",
          "7797:   if (IS_ERR(sqd)) {",
          "7798:    ret = PTR_ERR(sqd);",
          "7799:    goto err;",
          "7800:   }",
          "7802:   ctx->sq_data = sqd;",
          "7803:   io_sq_thread_park(sqd);",
          "7804:   mutex_lock(&sqd->ctx_lock);",
          "7805:   list_add(&ctx->sqd_list, &sqd->ctx_new_list);",
          "7806:   mutex_unlock(&sqd->ctx_lock);",
          "7807:   io_sq_thread_unpark(sqd);",
          "7813:   if (sqd->thread)",
          "7814:    goto done;",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "4565:    if (!cpu_online(cpu))",
          "4566:     goto err;",
          "4571:   } else {",
          "4573:        \"io_uring-sq\");",
          "4574:   }",
          "4578:    goto err;",
          "4579:   }",
          "4581:  } else if (p->flags & IORING_SETUP_SQ_AFF) {",
          "4583:   ret = -EINVAL;",
          "4584:   goto err;",
          "4585:  }",
          "4599:   goto err;",
          "4602:  return 0;",
          "4603: err:",
          "4604:  io_finish_async(ctx);",
          "4607:  return ret;",
          "4608: }",
          "4611: {",
          "4612:  atomic_long_sub(nr_pages, &user->locked_vm);",
          "4613: }",
          "4616: {",
          "4617:  unsigned long page_limit, cur_pages, new_pages;",
          "",
          "[Removed Lines]",
          "4568:    ctx->sqo_thread = kthread_create_on_cpu(io_sq_thread,",
          "4569:        ctx, cpu,",
          "4570:        \"io_uring-sq\");",
          "4572:    ctx->sqo_thread = kthread_create(io_sq_thread, ctx,",
          "4575:   if (IS_ERR(ctx->sqo_thread)) {",
          "4576:    ret = PTR_ERR(ctx->sqo_thread);",
          "4577:    ctx->sqo_thread = NULL;",
          "4580:   wake_up_process(ctx->sqo_thread);",
          "4587:  data.mm = ctx->sqo_mm;",
          "4588:  data.user = ctx->user;",
          "4589:  data.creds = ctx->creds;",
          "4590:  data.get_work = io_get_work;",
          "4591:  data.put_work = io_put_work;",
          "4594:  concurrency = min(ctx->sq_entries, 4 * num_online_cpus());",
          "4595:  ctx->io_wq = io_wq_create(concurrency, &data);",
          "4596:  if (IS_ERR(ctx->io_wq)) {",
          "4597:   ret = PTR_ERR(ctx->io_wq);",
          "4598:   ctx->io_wq = NULL;",
          "4600:  }",
          "4605:  mmdrop(ctx->sqo_mm);",
          "4606:  ctx->sqo_mm = NULL;",
          "4610: static void io_unaccount_mem(struct user_struct *user, unsigned long nr_pages)",
          "4615: static int io_account_mem(struct user_struct *user, unsigned long nr_pages)",
          "",
          "[Added Lines]",
          "7825:    sqd->thread = kthread_create_on_cpu(io_sq_thread, sqd,",
          "7826:        cpu, \"io_uring-sq\");",
          "7828:    sqd->thread = kthread_create(io_sq_thread, sqd,",
          "7831:   if (IS_ERR(sqd->thread)) {",
          "7832:    ret = PTR_ERR(sqd->thread);",
          "7833:    sqd->thread = NULL;",
          "7836:   ret = io_uring_alloc_task_context(sqd->thread);",
          "7837:   if (ret)",
          "7838:    goto err;",
          "7845: done:",
          "7846:  ret = io_init_wq_offload(ctx, p);",
          "7847:  if (ret)",
          "7856: static void io_sq_offload_start(struct io_ring_ctx *ctx)",
          "7857: {",
          "7858:  struct io_sq_data *sqd = ctx->sq_data;",
          "7860:  if ((ctx->flags & IORING_SETUP_SQPOLL) && sqd->thread)",
          "7861:   wake_up_process(sqd->thread);",
          "7862: }",
          "7864: static inline void __io_unaccount_mem(struct user_struct *user,",
          "7865:           unsigned long nr_pages)",
          "7870: static inline int __io_account_mem(struct user_struct *user,",
          "7871:        unsigned long nr_pages)",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "4630:  return 0;",
          "4631: }",
          "4633: static void io_mem_free(void *ptr)",
          "4634: {",
          "4635:  struct page *page;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7889: static void io_unaccount_mem(struct io_ring_ctx *ctx, unsigned long nr_pages,",
          "7890:         enum io_mem_account acct)",
          "7891: {",
          "7892:  if (ctx->limit_mem)",
          "7893:   __io_unaccount_mem(ctx->user, nr_pages);",
          "7895:  if (ctx->mm_account) {",
          "7896:   if (acct == ACCT_LOCKED)",
          "7897:    ctx->mm_account->locked_vm -= nr_pages;",
          "7898:   else if (acct == ACCT_PINNED)",
          "7899:    atomic64_sub(nr_pages, &ctx->mm_account->pinned_vm);",
          "7900:  }",
          "7901: }",
          "7903: static int io_account_mem(struct io_ring_ctx *ctx, unsigned long nr_pages,",
          "7904:      enum io_mem_account acct)",
          "7905: {",
          "7906:  int ret;",
          "7908:  if (ctx->limit_mem) {",
          "7909:   ret = __io_account_mem(ctx->user, nr_pages);",
          "7910:   if (ret)",
          "7911:    return ret;",
          "7912:  }",
          "7914:  if (ctx->mm_account) {",
          "7915:   if (acct == ACCT_LOCKED)",
          "7916:    ctx->mm_account->locked_vm += nr_pages;",
          "7917:   else if (acct == ACCT_PINNED)",
          "7918:    atomic64_add(nr_pages, &ctx->mm_account->pinned_vm);",
          "7919:  }",
          "7921:  return 0;",
          "7922: }",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "4666:   return SIZE_MAX;",
          "4667: #endif",
          "4669:  sq_array_size = array_size(sizeof(u32), sq_entries);",
          "4670:  if (sq_array_size == SIZE_MAX)",
          "4671:   return SIZE_MAX;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7960:  if (sq_offset)",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "4673:  if (check_add_overflow(off, sq_array_size, &off))",
          "4674:   return SIZE_MAX;",
          "4679:  return off;",
          "4680: }",
          "",
          "[Removed Lines]",
          "4676:  if (sq_offset)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "4704:   for (j = 0; j < imu->nr_bvecs; j++)",
          "4705:    put_user_page(imu->bvec[j].bv_page);",
          "4709:   kvfree(imu->bvec);",
          "4710:   imu->nr_bvecs = 0;",
          "4711:  }",
          "",
          "[Removed Lines]",
          "4707:   if (ctx->account_mem)",
          "4708:    io_unaccount_mem(ctx->user, imu->nr_bvecs);",
          "",
          "[Added Lines]",
          "7998:   if (imu->acct_pages)",
          "7999:    io_unaccount_mem(ctx, imu->acct_pages, ACCT_PINNED);",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "4741:  return 0;",
          "4742: }",
          "4744: static int io_sqe_buffer_register(struct io_ring_ctx *ctx, void __user *arg,",
          "4745:       unsigned nr_args)",
          "4746: {",
          "4747:  struct vm_area_struct **vmas = NULL;",
          "4748:  struct page **pages = NULL;",
          "4749:  int i, j, got_pages = 0;",
          "4750:  int ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8044: static bool headpage_already_acct(struct io_ring_ctx *ctx, struct page **pages,",
          "8045:       int nr_pages, struct page *hpage)",
          "8046: {",
          "8047:  int i, j;",
          "8050:  for (i = 0; i < nr_pages; i++) {",
          "8051:   if (!PageCompound(pages[i]))",
          "8052:    continue;",
          "8053:   if (compound_head(pages[i]) == hpage)",
          "8054:    return true;",
          "8055:  }",
          "8058:  for (i = 0; i < ctx->nr_user_bufs; i++) {",
          "8059:   struct io_mapped_ubuf *imu = &ctx->user_bufs[i];",
          "8061:   for (j = 0; j < imu->nr_bvecs; j++) {",
          "8062:    if (!PageCompound(imu->bvec[j].bv_page))",
          "8063:     continue;",
          "8064:    if (compound_head(imu->bvec[j].bv_page) == hpage)",
          "8065:     return true;",
          "8066:   }",
          "8067:  }",
          "8069:  return false;",
          "8070: }",
          "8072: static int io_buffer_account_pin(struct io_ring_ctx *ctx, struct page **pages,",
          "8073:      int nr_pages, struct io_mapped_ubuf *imu,",
          "8074:      struct page **last_hpage)",
          "8075: {",
          "8076:  int i, ret;",
          "8078:  for (i = 0; i < nr_pages; i++) {",
          "8079:   if (!PageCompound(pages[i])) {",
          "8080:    imu->acct_pages++;",
          "8081:   } else {",
          "8082:    struct page *hpage;",
          "8084:    hpage = compound_head(pages[i]);",
          "8085:    if (hpage == *last_hpage)",
          "8086:     continue;",
          "8088:    if (headpage_already_acct(ctx, pages, i, hpage))",
          "8089:     continue;",
          "8090:    imu->acct_pages += page_size(hpage) >> PAGE_SHIFT;",
          "8091:   }",
          "8092:  }",
          "8094:  if (!imu->acct_pages)",
          "8095:   return 0;",
          "8097:  ret = io_account_mem(ctx, imu->acct_pages, ACCT_PINNED);",
          "8098:  if (ret)",
          "8099:   imu->acct_pages = 0;",
          "8100:  return ret;",
          "8101: }",
          "8108:  struct page *last_hpage = NULL;",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "4788:   start = ubuf >> PAGE_SHIFT;",
          "4789:   nr_pages = end - start;",
          "4797:   ret = 0;",
          "4798:   if (!pages || nr_pages > got_pages) {",
          "4801:    pages = kvmalloc_array(nr_pages, sizeof(struct page *),",
          "4802:       GFP_KERNEL);",
          "4803:    vmas = kvmalloc_array(nr_pages,",
          "",
          "[Removed Lines]",
          "4791:   if (ctx->account_mem) {",
          "4792:    ret = io_account_mem(ctx->user, nr_pages);",
          "4793:    if (ret)",
          "4794:     goto err;",
          "4795:   }",
          "4799:    kfree(vmas);",
          "4800:    kfree(pages);",
          "",
          "[Added Lines]",
          "8153:    kvfree(vmas);",
          "8154:    kvfree(pages);",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "4805:      GFP_KERNEL);",
          "4806:    if (!pages || !vmas) {",
          "4807:     ret = -ENOMEM;",
          "4810:     goto err;",
          "4811:    }",
          "4812:    got_pages = nr_pages;",
          "",
          "[Removed Lines]",
          "4808:     if (ctx->account_mem)",
          "4809:      io_unaccount_mem(ctx->user, nr_pages);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "4815:   imu->bvec = kvmalloc_array(nr_pages, sizeof(struct bio_vec),",
          "4816:       GFP_KERNEL);",
          "4817:   ret = -ENOMEM;",
          "4821:    goto err;",
          "4824:   ret = 0;",
          "4825:   down_read(&current->mm->mmap_sem);",
          "",
          "[Removed Lines]",
          "4818:   if (!imu->bvec) {",
          "4819:    if (ctx->account_mem)",
          "4820:     io_unaccount_mem(ctx->user, nr_pages);",
          "4822:   }",
          "",
          "[Added Lines]",
          "8170:   if (!imu->bvec)",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "4849:    if (pret > 0)",
          "4850:     put_user_pages(pages, pret);",
          "4853:    kvfree(imu->bvec);",
          "4854:    goto err;",
          "4855:   }",
          "",
          "[Removed Lines]",
          "4851:    if (ctx->account_mem)",
          "4852:     io_unaccount_mem(ctx->user, nr_pages);",
          "",
          "[Added Lines]",
          "8200:    kvfree(imu->bvec);",
          "8201:    goto err;",
          "8202:   }",
          "8204:   ret = io_buffer_account_pin(ctx, pages, pret, imu, &last_hpage);",
          "8205:   if (ret) {",
          "8206:    put_user_pages(pages, pret);",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "4915:  return -ENXIO;",
          "4916: }",
          "4918: static void io_ring_ctx_free(struct io_ring_ctx *ctx)",
          "4919: {",
          "4920:  io_finish_async(ctx);",
          "4925:  io_sqe_buffer_unregister(ctx);",
          "4926:  io_sqe_files_unregister(ctx);",
          "4927:  io_eventfd_unregister(ctx);",
          "4929: #if defined(CONFIG_UNIX)",
          "4930:  if (ctx->ring_sock) {",
          "",
          "[Removed Lines]",
          "4921:  if (ctx->sqo_mm)",
          "4922:   mmdrop(ctx->sqo_mm);",
          "4924:  io_iopoll_reap_events(ctx);",
          "",
          "[Added Lines]",
          "8272: static int __io_destroy_buffers(int id, void *p, void *data)",
          "8273: {",
          "8274:  struct io_ring_ctx *ctx = data;",
          "8275:  struct io_buffer *buf = p;",
          "8277:  __io_remove_buffers(ctx, buf, id, -1U);",
          "8278:  return 0;",
          "8279: }",
          "8281: static void io_destroy_buffers(struct io_ring_ctx *ctx)",
          "8282: {",
          "8283:  idr_for_each(&ctx->io_buffer_idr, __io_destroy_buffers, ctx);",
          "8284:  idr_destroy(&ctx->io_buffer_idr);",
          "8285: }",
          "8292:  if (ctx->sqo_task) {",
          "8293:   put_task_struct(ctx->sqo_task);",
          "8294:   ctx->sqo_task = NULL;",
          "8295:   mmdrop(ctx->mm_account);",
          "8296:   ctx->mm_account = NULL;",
          "8297:  }",
          "8299: #ifdef CONFIG_BLK_CGROUP",
          "8300:  if (ctx->sqo_blkcg_css)",
          "8301:   css_put(ctx->sqo_blkcg_css);",
          "8302: #endif",
          "8306:  io_destroy_buffers(ctx);",
          "8307:  idr_destroy(&ctx->personality_idr);",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "4937:  io_mem_free(ctx->sq_sqes);",
          "4939:  percpu_ref_exit(&ctx->refs);",
          "4943:  free_uid(ctx->user);",
          "4944:  put_cred(ctx->creds);",
          "4946:  kfree(ctx->cancel_hash);",
          "4947:  kmem_cache_free(req_cachep, ctx->fallback_req);",
          "4948:  kfree(ctx);",
          "",
          "[Removed Lines]",
          "4940:  if (ctx->account_mem)",
          "4941:   io_unaccount_mem(ctx->user,",
          "4942:     ring_pages(ctx->sq_entries, ctx->cq_entries));",
          "4945:  kfree(ctx->completions);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "4961:  smp_rmb();",
          "4964:   mask |= EPOLLOUT | EPOLLWRNORM;",
          "4966:   mask |= EPOLLIN | EPOLLRDNORM;",
          "4968:  return mask;",
          "",
          "[Removed Lines]",
          "4962:  if (READ_ONCE(ctx->rings->sq.tail) - ctx->cached_sq_head !=",
          "4963:      ctx->rings->sq_ring_entries)",
          "4965:  if (READ_ONCE(ctx->rings->cq.head) != ctx->cached_cq_tail)",
          "",
          "[Added Lines]",
          "8338:  if (!io_sqring_full(ctx))",
          "8340:  if (io_cqring_events(ctx, false))",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "4975:  return fasync_helper(fd, file, on, &ctx->cq_fasync);",
          "4976: }",
          "4978: static void io_ring_ctx_wait_and_kill(struct io_ring_ctx *ctx)",
          "4979: {",
          "4980:  mutex_lock(&ctx->uring_lock);",
          "4981:  percpu_ref_kill(&ctx->refs);",
          "4982:  mutex_unlock(&ctx->uring_lock);",
          "4987:  if (ctx->io_wq)",
          "4988:   io_wq_cancel_all(ctx->io_wq);",
          "4992:  if (ctx->rings)",
          "4996: }",
          "4998: static int io_uring_release(struct inode *inode, struct file *file)",
          "",
          "[Removed Lines]",
          "4984:  io_kill_timeouts(ctx);",
          "4985:  io_poll_remove_all(ctx);",
          "4990:  io_iopoll_reap_events(ctx);",
          "4993:   io_cqring_overflow_flush(ctx, true);",
          "4994:  wait_for_completion(&ctx->completions[0]);",
          "4995:  io_ring_ctx_free(ctx);",
          "",
          "[Added Lines]",
          "8353: static int io_remove_personalities(int id, void *p, void *data)",
          "8354: {",
          "8355:  struct io_ring_ctx *ctx = data;",
          "8356:  struct io_identity *iod;",
          "8358:  iod = idr_remove(&ctx->personality_idr, id);",
          "8359:  if (iod) {",
          "8360:   put_cred(iod->creds);",
          "8361:   if (refcount_dec_and_test(&iod->count))",
          "8362:    kfree(iod);",
          "8363:  }",
          "8364:  return 0;",
          "8365: }",
          "8367: static void io_ring_exit_work(struct work_struct *work)",
          "8368: {",
          "8369:  struct io_ring_ctx *ctx = container_of(work, struct io_ring_ctx,",
          "8370:             exit_work);",
          "8378:  do {",
          "8379:   if (ctx->rings)",
          "8380:    io_cqring_overflow_flush(ctx, true, NULL, NULL);",
          "8381:   io_iopoll_try_reap_events(ctx);",
          "8382:  } while (!wait_for_completion_timeout(&ctx->ref_comp, HZ/20));",
          "8383:  io_ring_ctx_free(ctx);",
          "8384: }",
          "8392:  io_kill_timeouts(ctx, NULL);",
          "8393:  io_poll_remove_all(ctx, NULL);",
          "8400:   io_cqring_overflow_flush(ctx, true, NULL, NULL);",
          "8401:  io_iopoll_try_reap_events(ctx);",
          "8402:  idr_for_each(&ctx->personality_idr, io_remove_personalities, ctx);",
          "8409:  io_unaccount_mem(ctx, ring_pages(ctx->sq_entries, ctx->cq_entries),",
          "8410:     ACCT_LOCKED);",
          "8412:  INIT_WORK(&ctx->exit_work, io_ring_exit_work);",
          "8419:  queue_work(system_unbound_wq, &ctx->exit_work);",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "5004:  return 0;",
          "5005: }",
          "5008:       struct files_struct *files)",
          "5009: {",
          "5011:  DEFINE_WAIT(wait);",
          "5024:    break;",
          "5037:   schedule();",
          "5040: }",
          "5042: static int io_uring_flush(struct file *file, void *data)",
          "5043: {",
          "5047:  return 0;",
          "5048: }",
          "",
          "[Removed Lines]",
          "5007: static void io_uring_cancel_files(struct io_ring_ctx *ctx,",
          "5010:  struct io_kiocb *req;",
          "5013:  while (!list_empty_careful(&ctx->inflight_list)) {",
          "5014:   struct io_kiocb *cancel_req = NULL;",
          "5016:   spin_lock_irq(&ctx->inflight_lock);",
          "5017:   list_for_each_entry(req, &ctx->inflight_list, inflight_entry) {",
          "5018:    if (req->work.files != files)",
          "5019:     continue;",
          "5021:    if (!refcount_inc_not_zero(&req->refs))",
          "5022:     continue;",
          "5023:    cancel_req = req;",
          "5025:   }",
          "5026:   if (cancel_req)",
          "5027:    prepare_to_wait(&ctx->inflight_wait, &wait,",
          "5028:       TASK_UNINTERRUPTIBLE);",
          "5029:   spin_unlock_irq(&ctx->inflight_lock);",
          "5032:   if (!cancel_req)",
          "5033:    break;",
          "5035:   io_wq_cancel_work(ctx->io_wq, &cancel_req->work);",
          "5036:   io_put_req(cancel_req);",
          "5038:  }",
          "5039:  finish_wait(&ctx->inflight_wait, &wait);",
          "5044:  struct io_ring_ctx *ctx = file->private_data;",
          "5046:  io_uring_cancel_files(ctx, data);",
          "",
          "[Added Lines]",
          "8431: static bool io_wq_files_match(struct io_wq_work *work, void *data)",
          "8432: {",
          "8433:  struct files_struct *files = data;",
          "8435:  return !files || ((work->flags & IO_WQ_WORK_FILES) &&",
          "8436:     work->identity->files == files);",
          "8437: }",
          "8442: static bool io_match_link(struct io_kiocb *preq, struct io_kiocb *req)",
          "8443: {",
          "8444:  struct io_kiocb *link;",
          "8446:  if (!(preq->flags & REQ_F_LINK_HEAD))",
          "8447:   return false;",
          "8449:  list_for_each_entry(link, &preq->link_list, link_list) {",
          "8450:   if (link == req)",
          "8451:    return true;",
          "8452:  }",
          "8454:  return false;",
          "8455: }",
          "8462: static bool io_poll_remove_link(struct io_ring_ctx *ctx, struct io_kiocb *req)",
          "8463: {",
          "8464:  struct hlist_node *tmp;",
          "8465:  struct io_kiocb *preq;",
          "8466:  bool found = false;",
          "8467:  int i;",
          "8469:  spin_lock_irq(&ctx->completion_lock);",
          "8470:  for (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {",
          "8471:   struct hlist_head *list;",
          "8473:   list = &ctx->cancel_hash[i];",
          "8474:   hlist_for_each_entry_safe(preq, tmp, list, hash_node) {",
          "8475:    found = io_match_link(preq, req);",
          "8476:    if (found) {",
          "8477:     io_poll_remove_one(preq);",
          "8478:     break;",
          "8479:    }",
          "8480:   }",
          "8481:  }",
          "8482:  spin_unlock_irq(&ctx->completion_lock);",
          "8483:  return found;",
          "8484: }",
          "8486: static bool io_timeout_remove_link(struct io_ring_ctx *ctx,",
          "8487:        struct io_kiocb *req)",
          "8488: {",
          "8489:  struct io_kiocb *preq;",
          "8490:  bool found = false;",
          "8492:  spin_lock_irq(&ctx->completion_lock);",
          "8493:  list_for_each_entry(preq, &ctx->timeout_list, timeout.list) {",
          "8494:   found = io_match_link(preq, req);",
          "8495:   if (found) {",
          "8496:    __io_timeout_cancel(preq);",
          "8497:    break;",
          "8498:   }",
          "8499:  }",
          "8500:  spin_unlock_irq(&ctx->completion_lock);",
          "8501:  return found;",
          "8502: }",
          "8504: static bool io_cancel_link_cb(struct io_wq_work *work, void *data)",
          "8505: {",
          "8506:  struct io_kiocb *req = container_of(work, struct io_kiocb, work);",
          "8507:  bool ret;",
          "8509:  if (req->flags & REQ_F_LINK_TIMEOUT) {",
          "8510:   unsigned long flags;",
          "8511:   struct io_ring_ctx *ctx = req->ctx;",
          "8514:   spin_lock_irqsave(&ctx->completion_lock, flags);",
          "8515:   ret = io_match_link(req, data);",
          "8516:   spin_unlock_irqrestore(&ctx->completion_lock, flags);",
          "8517:  } else {",
          "8518:   ret = io_match_link(req, data);",
          "8519:  }",
          "8520:  return ret;",
          "8521: }",
          "8523: static void io_attempt_cancel(struct io_ring_ctx *ctx, struct io_kiocb *req)",
          "8524: {",
          "8525:  enum io_wq_cancel cret;",
          "8528:  cret = io_wq_cancel_work(ctx->io_wq, &req->work);",
          "8529:  if (cret != IO_WQ_CANCEL_NOTFOUND)",
          "8530:   return;",
          "8533:  cret = io_wq_cancel_cb(ctx->io_wq, io_cancel_link_cb, req, true);",
          "8534:  if (cret != IO_WQ_CANCEL_NOTFOUND)",
          "8535:   return;",
          "8538:  if (io_poll_remove_link(ctx, req))",
          "8539:   return;",
          "8542:  io_timeout_remove_link(ctx, req);",
          "8543: }",
          "8545: static void io_cancel_defer_files(struct io_ring_ctx *ctx,",
          "8546:       struct task_struct *task,",
          "8547:       struct files_struct *files)",
          "8548: {",
          "8549:  struct io_defer_entry *de = NULL;",
          "8550:  LIST_HEAD(list);",
          "8552:  spin_lock_irq(&ctx->completion_lock);",
          "8553:  list_for_each_entry_reverse(de, &ctx->defer_list, list) {",
          "8554:   if (io_task_match(de->req, task) &&",
          "8555:       io_match_files(de->req, files)) {",
          "8556:    list_cut_position(&list, &ctx->defer_list, &de->list);",
          "8557:    break;",
          "8558:   }",
          "8559:  }",
          "8560:  spin_unlock_irq(&ctx->completion_lock);",
          "8562:  while (!list_empty(&list)) {",
          "8563:   de = list_first_entry(&list, struct io_defer_entry, list);",
          "8564:   list_del_init(&de->list);",
          "8565:   req_set_fail_links(de->req);",
          "8566:   io_put_req(de->req);",
          "8567:   io_req_complete(de->req, -ECANCELED);",
          "8568:   kfree(de);",
          "8569:  }",
          "8570: }",
          "8575: static bool io_uring_cancel_files(struct io_ring_ctx *ctx,",
          "8578:  if (list_empty_careful(&ctx->inflight_list))",
          "8579:   return false;",
          "8582:  io_wq_cancel_cb(ctx->io_wq, io_wq_files_match, files, true);",
          "8584:  while (!list_empty_careful(&ctx->inflight_list)) {",
          "8585:   struct io_kiocb *cancel_req = NULL, *req;",
          "8586:   DEFINE_WAIT(wait);",
          "8588:   spin_lock_irq(&ctx->inflight_lock);",
          "8589:   list_for_each_entry(req, &ctx->inflight_list, inflight_entry) {",
          "8590:    if (files && (req->work.flags & IO_WQ_WORK_FILES) &&",
          "8591:        req->work.identity->files != files)",
          "8592:     continue;",
          "8594:    if (!refcount_inc_not_zero(&req->refs))",
          "8595:     continue;",
          "8596:    cancel_req = req;",
          "8597:    break;",
          "8598:   }",
          "8599:   if (cancel_req)",
          "8600:    prepare_to_wait(&ctx->inflight_wait, &wait,",
          "8601:       TASK_UNINTERRUPTIBLE);",
          "8602:   spin_unlock_irq(&ctx->inflight_lock);",
          "8605:   if (!cancel_req)",
          "8606:    break;",
          "8608:   io_attempt_cancel(ctx, cancel_req);",
          "8609:   io_put_req(cancel_req);",
          "8611:   io_run_task_work();",
          "8612:   schedule();",
          "8613:   finish_wait(&ctx->inflight_wait, &wait);",
          "8614:  }",
          "8616:  return true;",
          "8617: }",
          "8619: static bool io_cancel_task_cb(struct io_wq_work *work, void *data)",
          "8620: {",
          "8621:  struct io_kiocb *req = container_of(work, struct io_kiocb, work);",
          "8622:  struct task_struct *task = data;",
          "8624:  return io_task_match(req, task);",
          "8625: }",
          "8627: static bool __io_uring_cancel_task_requests(struct io_ring_ctx *ctx,",
          "8628:          struct task_struct *task,",
          "8629:          struct files_struct *files)",
          "8630: {",
          "8631:  bool ret;",
          "8633:  ret = io_uring_cancel_files(ctx, files);",
          "8634:  if (!files) {",
          "8635:   enum io_wq_cancel cret;",
          "8637:   cret = io_wq_cancel_cb(ctx->io_wq, io_cancel_task_cb, task, true);",
          "8638:   if (cret != IO_WQ_CANCEL_NOTFOUND)",
          "8639:    ret = true;",
          "8642:   if (!(ctx->flags & IORING_SETUP_SQPOLL)) {",
          "8643:    while (!list_empty_careful(&ctx->iopoll_list)) {",
          "8644:     io_iopoll_try_reap_events(ctx);",
          "8645:     ret = true;",
          "8646:    }",
          "8647:   }",
          "8649:   ret |= io_poll_remove_all(ctx, task);",
          "8650:   ret |= io_kill_timeouts(ctx, task);",
          "8651:  }",
          "8653:  return ret;",
          "8654: }",
          "8661: static void io_uring_cancel_task_requests(struct io_ring_ctx *ctx,",
          "8662:        struct files_struct *files)",
          "8663: {",
          "8664:  struct task_struct *task = current;",
          "8666:  if ((ctx->flags & IORING_SETUP_SQPOLL) && ctx->sq_data) {",
          "8667:   task = ctx->sq_data->thread;",
          "8668:   atomic_inc(&task->io_uring->in_idle);",
          "8669:   io_sq_thread_park(ctx->sq_data);",
          "8670:  }",
          "8672:  if (files)",
          "8673:   io_cancel_defer_files(ctx, NULL, files);",
          "8674:  else",
          "8675:   io_cancel_defer_files(ctx, task, NULL);",
          "8677:  io_cqring_overflow_flush(ctx, true, task, files);",
          "8679:  while (__io_uring_cancel_task_requests(ctx, task, files)) {",
          "8680:   io_run_task_work();",
          "8681:   cond_resched();",
          "8682:  }",
          "8684:  if ((ctx->flags & IORING_SETUP_SQPOLL) && ctx->sq_data) {",
          "8685:   atomic_dec(&task->io_uring->in_idle);",
          "8690:   if (task->io_uring->identity->files == files)",
          "8691:    task->io_uring->identity->files = NULL;",
          "8692:   io_sq_thread_unpark(ctx->sq_data);",
          "8693:  }",
          "8694: }",
          "8699: static int io_uring_add_task_file(struct io_ring_ctx *ctx, struct file *file)",
          "8700: {",
          "8701:  struct io_uring_task *tctx = current->io_uring;",
          "8703:  if (unlikely(!tctx)) {",
          "8704:   int ret;",
          "8706:   ret = io_uring_alloc_task_context(current);",
          "8707:   if (unlikely(ret))",
          "8708:    return ret;",
          "8709:   tctx = current->io_uring;",
          "8710:  }",
          "8711:  if (tctx->last != file) {",
          "8712:   void *old = xa_load(&tctx->xa, (unsigned long)file);",
          "8714:   if (!old) {",
          "8715:    get_file(file);",
          "8716:    xa_store(&tctx->xa, (unsigned long)file, file, GFP_KERNEL);",
          "8717:   }",
          "8718:   tctx->last = file;",
          "8719:  }",
          "8726:  if (!tctx->sqpoll && (ctx->flags & IORING_SETUP_SQPOLL))",
          "8727:   tctx->sqpoll = true;",
          "8729:  return 0;",
          "8730: }",
          "8735: static void io_uring_del_task_file(struct file *file)",
          "8736: {",
          "8737:  struct io_uring_task *tctx = current->io_uring;",
          "8739:  if (tctx->last == file)",
          "8740:   tctx->last = NULL;",
          "8741:  file = xa_erase(&tctx->xa, (unsigned long)file);",
          "8742:  if (file)",
          "8743:   fput(file);",
          "8744: }",
          "8750: static void io_uring_attempt_task_drop(struct file *file)",
          "8751: {",
          "8752:  if (!current->io_uring)",
          "8753:   return;",
          "8758:  if (fatal_signal_pending(current) || (current->flags & PF_EXITING) ||",
          "8759:      atomic_long_read(&file->f_count) == 2)",
          "8760:   io_uring_del_task_file(file);",
          "8761: }",
          "8763: void __io_uring_files_cancel(struct files_struct *files)",
          "8764: {",
          "8765:  struct io_uring_task *tctx = current->io_uring;",
          "8766:  struct file *file;",
          "8767:  unsigned long index;",
          "8770:  atomic_inc(&tctx->in_idle);",
          "8772:  xa_for_each(&tctx->xa, index, file) {",
          "8773:   struct io_ring_ctx *ctx = file->private_data;",
          "8775:   io_uring_cancel_task_requests(ctx, files);",
          "8776:   if (files)",
          "8777:    io_uring_del_task_file(file);",
          "8778:  }",
          "8780:  atomic_dec(&tctx->in_idle);",
          "8781: }",
          "8783: static s64 tctx_inflight(struct io_uring_task *tctx)",
          "8784: {",
          "8785:  unsigned long index;",
          "8786:  struct file *file;",
          "8787:  s64 inflight;",
          "8789:  inflight = percpu_counter_sum(&tctx->inflight);",
          "8790:  if (!tctx->sqpoll)",
          "8791:   return inflight;",
          "8797:  xa_for_each(&tctx->xa, index, file) {",
          "8798:   struct io_ring_ctx *ctx = file->private_data;",
          "8800:   if (ctx->flags & IORING_SETUP_SQPOLL) {",
          "8801:    struct io_uring_task *__tctx = ctx->sqo_task->io_uring;",
          "8803:    inflight += percpu_counter_sum(&__tctx->inflight);",
          "8804:   }",
          "8805:  }",
          "8807:  return inflight;",
          "8808: }",
          "8814: void __io_uring_task_cancel(void)",
          "8815: {",
          "8816:  struct io_uring_task *tctx = current->io_uring;",
          "8818:  s64 inflight;",
          "8821:  atomic_inc(&tctx->in_idle);",
          "8823:  do {",
          "8825:   inflight = tctx_inflight(tctx);",
          "8826:   if (!inflight)",
          "8828:   __io_uring_files_cancel(NULL);",
          "8830:   prepare_to_wait(&tctx->wait, &wait, TASK_UNINTERRUPTIBLE);",
          "8836:   if (inflight != tctx_inflight(tctx))",
          "8837:    continue;",
          "8839:  } while (1);",
          "8841:  finish_wait(&tctx->wait, &wait);",
          "8842:  atomic_dec(&tctx->in_idle);",
          "8847:  io_uring_attempt_task_drop(file);",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "5120: SYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,",
          "5121:   u32, min_complete, u32, flags, const sigset_t __user *, sig,",
          "5122:   size_t, sigsz)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8921: static void io_sqpoll_wait_sq(struct io_ring_ctx *ctx)",
          "8922: {",
          "8923:  DEFINE_WAIT(wait);",
          "8925:  do {",
          "8926:   if (!io_sqring_full(ctx))",
          "8927:    break;",
          "8929:   prepare_to_wait(&ctx->sqo_sq_wait, &wait, TASK_INTERRUPTIBLE);",
          "8931:   if (!io_sqring_full(ctx))",
          "8932:    break;",
          "8934:   schedule();",
          "8935:  } while (!signal_pending(current));",
          "8937:  finish_wait(&ctx->sqo_sq_wait, &wait);",
          "8938: }",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "5126:  int submitted = 0;",
          "5127:  struct fd f;",
          "5130:   return -EINVAL;",
          "5132:  f = fdget(fd);",
          "",
          "[Removed Lines]",
          "5129:  if (flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP))",
          "",
          "[Added Lines]",
          "8949:  io_run_task_work();",
          "8951:  if (flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP |",
          "8952:    IORING_ENTER_SQ_WAIT))",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "5142:  if (!percpu_ref_tryget(&ctx->refs))",
          "5143:   goto out_fput;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8968:  ret = -EBADFD;",
          "8969:  if (ctx->flags & IORING_SETUP_R_DISABLED)",
          "8970:   goto out;",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "5150:  ret = 0;",
          "5151:  if (ctx->flags & IORING_SETUP_SQPOLL) {",
          "5152:   if (!list_empty_careful(&ctx->cq_overflow_list))",
          "5154:   if (flags & IORING_ENTER_SQ_WAKEUP)",
          "5156:   submitted = to_submit;",
          "5157:  } else if (to_submit) {",
          "5161:   mutex_lock(&ctx->uring_lock);",
          "5166:   mutex_unlock(&ctx->uring_lock);",
          "5168:   if (submitted != to_submit)",
          "5169:    goto out;",
          "5170:  }",
          "5171:  if (flags & IORING_ENTER_GETEVENTS) {",
          "5174:   min_complete = min(min_complete, ctx->cq_entries);",
          "5178:   } else {",
          "5179:    ret = io_cqring_wait(ctx, min_complete, sig, sigsz);",
          "5180:   }",
          "",
          "[Removed Lines]",
          "5153:    io_cqring_overflow_flush(ctx, false);",
          "5155:    wake_up(&ctx->sqo_wait);",
          "5158:   struct mm_struct *cur_mm;",
          "5160:   to_submit = min(to_submit, ctx->sq_entries);",
          "5163:   cur_mm = ctx->sqo_mm;",
          "5164:   submitted = io_submit_sqes(ctx, to_submit, f.file, fd,",
          "5165:         &cur_mm, false);",
          "5172:   unsigned nr_events = 0;",
          "5176:   if (ctx->flags & IORING_SETUP_IOPOLL) {",
          "5177:    ret = io_iopoll_check(ctx, &nr_events, min_complete);",
          "",
          "[Added Lines]",
          "8980:    io_cqring_overflow_flush(ctx, false, NULL, NULL);",
          "8982:    wake_up(&ctx->sq_data->wait);",
          "8983:   if (flags & IORING_ENTER_SQ_WAIT)",
          "8984:    io_sqpoll_wait_sq(ctx);",
          "8987:   ret = io_uring_add_task_file(ctx, f.file);",
          "8988:   if (unlikely(ret))",
          "8989:    goto out;",
          "8991:   submitted = io_submit_sqes(ctx, to_submit);",
          "9006:   if (ctx->flags & IORING_SETUP_IOPOLL &&",
          "9007:       !(ctx->flags & IORING_SETUP_SQPOLL)) {",
          "9008:    ret = io_iopoll_check(ctx, min_complete);",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "5187:  return submitted ? submitted : ret;",
          "5188: }",
          "5190: static const struct file_operations io_uring_fops = {",
          "5191:  .release = io_uring_release,",
          "5192:  .flush  = io_uring_flush,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9021: #ifdef CONFIG_PROC_FS",
          "9022: static int io_uring_show_cred(int id, void *p, void *data)",
          "9023: {",
          "9024:  struct io_identity *iod = p;",
          "9025:  const struct cred *cred = iod->creds;",
          "9026:  struct seq_file *m = data;",
          "9027:  struct user_namespace *uns = seq_user_ns(m);",
          "9028:  struct group_info *gi;",
          "9029:  kernel_cap_t cap;",
          "9030:  unsigned __capi;",
          "9031:  int g;",
          "9033:  seq_printf(m, \"%5d\\n\", id);",
          "9034:  seq_put_decimal_ull(m, \"\\tUid:\\t\", from_kuid_munged(uns, cred->uid));",
          "9035:  seq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->euid));",
          "9036:  seq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->suid));",
          "9037:  seq_put_decimal_ull(m, \"\\t\\t\", from_kuid_munged(uns, cred->fsuid));",
          "9038:  seq_put_decimal_ull(m, \"\\n\\tGid:\\t\", from_kgid_munged(uns, cred->gid));",
          "9039:  seq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->egid));",
          "9040:  seq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->sgid));",
          "9041:  seq_put_decimal_ull(m, \"\\t\\t\", from_kgid_munged(uns, cred->fsgid));",
          "9042:  seq_puts(m, \"\\n\\tGroups:\\t\");",
          "9043:  gi = cred->group_info;",
          "9044:  for (g = 0; g < gi->ngroups; g++) {",
          "9045:   seq_put_decimal_ull(m, g ? \" \" : \"\",",
          "9046:      from_kgid_munged(uns, gi->gid[g]));",
          "9047:  }",
          "9048:  seq_puts(m, \"\\n\\tCapEff:\\t\");",
          "9049:  cap = cred->cap_effective;",
          "9050:  CAP_FOR_EACH_U32(__capi)",
          "9051:   seq_put_hex_ll(m, NULL, cap.cap[CAP_LAST_U32 - __capi], 8);",
          "9052:  seq_putc(m, '\\n');",
          "9053:  return 0;",
          "9054: }",
          "9056: static void __io_uring_show_fdinfo(struct io_ring_ctx *ctx, struct seq_file *m)",
          "9057: {",
          "9058:  struct io_sq_data *sq = NULL;",
          "9059:  bool has_lock;",
          "9060:  int i;",
          "9068:  has_lock = mutex_trylock(&ctx->uring_lock);",
          "9070:  if (has_lock && (ctx->flags & IORING_SETUP_SQPOLL))",
          "9071:   sq = ctx->sq_data;",
          "9073:  seq_printf(m, \"SqThread:\\t%d\\n\", sq ? task_pid_nr(sq->thread) : -1);",
          "9074:  seq_printf(m, \"SqThreadCpu:\\t%d\\n\", sq ? task_cpu(sq->thread) : -1);",
          "9075:  seq_printf(m, \"UserFiles:\\t%u\\n\", ctx->nr_user_files);",
          "9076:  for (i = 0; has_lock && i < ctx->nr_user_files; i++) {",
          "9077:   struct fixed_file_table *table;",
          "9078:   struct file *f;",
          "9080:   table = &ctx->file_data->table[i >> IORING_FILE_TABLE_SHIFT];",
          "9081:   f = table->files[i & IORING_FILE_TABLE_MASK];",
          "9082:   if (f)",
          "9083:    seq_printf(m, \"%5u: %s\\n\", i, file_dentry(f)->d_iname);",
          "9084:   else",
          "9085:    seq_printf(m, \"%5u: <none>\\n\", i);",
          "9086:  }",
          "9087:  seq_printf(m, \"UserBufs:\\t%u\\n\", ctx->nr_user_bufs);",
          "9088:  for (i = 0; has_lock && i < ctx->nr_user_bufs; i++) {",
          "9089:   struct io_mapped_ubuf *buf = &ctx->user_bufs[i];",
          "9091:   seq_printf(m, \"%5u: 0x%llx/%u\\n\", i, buf->ubuf,",
          "9092:       (unsigned int) buf->len);",
          "9093:  }",
          "9094:  if (has_lock && !idr_is_empty(&ctx->personality_idr)) {",
          "9095:   seq_printf(m, \"Personalities:\\n\");",
          "9096:   idr_for_each(&ctx->personality_idr, io_uring_show_cred, m);",
          "9097:  }",
          "9098:  seq_printf(m, \"PollList:\\n\");",
          "9099:  spin_lock_irq(&ctx->completion_lock);",
          "9100:  for (i = 0; i < (1U << ctx->cancel_hash_bits); i++) {",
          "9101:   struct hlist_head *list = &ctx->cancel_hash[i];",
          "9102:   struct io_kiocb *req;",
          "9104:   hlist_for_each_entry(req, list, hash_node)",
          "9105:    seq_printf(m, \"  op=%d, task_works=%d\\n\", req->opcode,",
          "9106:      req->task->task_works != NULL);",
          "9107:  }",
          "9108:  spin_unlock_irq(&ctx->completion_lock);",
          "9109:  if (has_lock)",
          "9110:   mutex_unlock(&ctx->uring_lock);",
          "9111: }",
          "9113: static void io_uring_show_fdinfo(struct seq_file *m, struct file *f)",
          "9114: {",
          "9115:  struct io_ring_ctx *ctx = f->private_data;",
          "9117:  if (percpu_ref_tryget(&ctx->refs)) {",
          "9118:   __io_uring_show_fdinfo(ctx, m);",
          "9119:   percpu_ref_put(&ctx->refs);",
          "9120:  }",
          "9121: }",
          "9122: #endif",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "5197: #endif",
          "5198:  .poll  = io_uring_poll,",
          "5199:  .fasync  = io_uring_fasync,",
          "5200: };",
          "5202: static int io_allocate_scq_urings(struct io_ring_ctx *ctx,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9134: #ifdef CONFIG_PROC_FS",
          "9135:  .show_fdinfo = io_uring_show_fdinfo,",
          "9136: #endif",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "5205:  struct io_rings *rings;",
          "5206:  size_t size, sq_array_offset;",
          "5208:  size = rings_size(p->sq_entries, p->cq_entries, &sq_array_offset);",
          "5209:  if (size == SIZE_MAX)",
          "5210:   return -EOVERFLOW;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9146:  ctx->sq_entries = p->sq_entries;",
          "9147:  ctx->cq_entries = p->cq_entries;",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "5221:  rings->cq_ring_entries = p->cq_entries;",
          "5222:  ctx->sq_mask = rings->sq_ring_mask;",
          "5223:  ctx->cq_mask = rings->cq_ring_mask;",
          "5227:  size = array_size(sizeof(struct io_uring_sqe), p->sq_entries);",
          "5228:  if (size == SIZE_MAX) {",
          "",
          "[Removed Lines]",
          "5224:  ctx->sq_entries = rings->sq_ring_entries;",
          "5225:  ctx->cq_entries = rings->cq_ring_entries;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "5251: {",
          "5252:  struct file *file;",
          "5253:  int ret;",
          "5255: #if defined(CONFIG_UNIX)",
          "5256:  ret = sock_create_kern(&init_net, PF_UNIX, SOCK_RAW, IPPROTO_IP,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9193:  int fd;",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "5262:  ret = get_unused_fd_flags(O_RDWR | O_CLOEXEC);",
          "5263:  if (ret < 0)",
          "5264:   goto err;",
          "5266:  file = anon_inode_getfile(\"[io_uring]\", &io_uring_fops, ctx,",
          "5267:      O_RDWR | O_CLOEXEC);",
          "5268:  if (IS_ERR(file)) {",
          "5270:   ret = PTR_ERR(file);",
          "5271:   goto err;",
          "5272:  }",
          "5274: #if defined(CONFIG_UNIX)",
          "5275:  ctx->ring_sock->file = file;",
          "5277: #endif",
          "5280: err:",
          "5281: #if defined(CONFIG_UNIX)",
          "5282:  sock_release(ctx->ring_sock);",
          "",
          "[Removed Lines]",
          "5269:   put_unused_fd(ret);",
          "5276:  ctx->ring_sock->sk->sk_user_data = ctx;",
          "5278:  fd_install(ret, file);",
          "5279:  return ret;",
          "",
          "[Added Lines]",
          "9205:  fd = ret;",
          "9210:   put_unused_fd(fd);",
          "9218:  ret = io_uring_add_task_file(ctx, file);",
          "9219:  if (ret) {",
          "9220:   fput(file);",
          "9221:   put_unused_fd(fd);",
          "9222:   goto err;",
          "9223:  }",
          "9224:  fd_install(fd, file);",
          "9225:  return fd;",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "5285:  return ret;",
          "5286: }",
          "5289: {",
          "5290:  struct user_struct *user = NULL;",
          "5291:  struct io_ring_ctx *ctx;",
          "5293:  int ret;",
          "5296:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "5288: static int io_uring_create(unsigned entries, struct io_uring_params *p)",
          "5292:  bool account_mem;",
          "5295:  if (!entries || entries > IORING_MAX_ENTRIES)",
          "",
          "[Added Lines]",
          "9234: static int io_uring_create(unsigned entries, struct io_uring_params *p,",
          "9235:       struct io_uring_params __user *params)",
          "9239:  bool limit_mem;",
          "9242:  if (!entries)",
          "9244:  if (entries > IORING_MAX_ENTRIES) {",
          "9245:   if (!(p->flags & IORING_SETUP_CLAMP))",
          "9246:    return -EINVAL;",
          "9247:   entries = IORING_MAX_ENTRIES;",
          "9248:  }",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "5314:    return -EINVAL;",
          "5315:   p->cq_entries = roundup_pow_of_two(p->cq_entries);",
          "5316:  } else {",
          "5317:   p->cq_entries = 2 * p->sq_entries;",
          "5318:  }",
          "5320:  user = get_uid(current_user());",
          "5325:     ring_pages(p->sq_entries, p->cq_entries));",
          "5326:   if (ret) {",
          "5327:    free_uid(user);",
          "",
          "[Removed Lines]",
          "5313:   if (p->cq_entries < p->sq_entries || p->cq_entries > IORING_MAX_CQ_ENTRIES)",
          "5321:  account_mem = !capable(CAP_IPC_LOCK);",
          "5323:  if (account_mem) {",
          "5324:   ret = io_account_mem(user,",
          "",
          "[Added Lines]",
          "9265:   if (!p->cq_entries)",
          "9267:   if (p->cq_entries > IORING_MAX_CQ_ENTRIES) {",
          "9268:    if (!(p->flags & IORING_SETUP_CLAMP))",
          "9269:     return -EINVAL;",
          "9270:    p->cq_entries = IORING_MAX_CQ_ENTRIES;",
          "9271:   }",
          "9273:   if (p->cq_entries < p->sq_entries)",
          "9274:    return -EINVAL;",
          "9280:  limit_mem = !capable(CAP_IPC_LOCK);",
          "9282:  if (limit_mem) {",
          "9283:   ret = __io_account_mem(user,",
          "",
          "---------------",
          "--- Hunk 118 ---",
          "[Context before]",
          "5332:  ctx = io_ring_ctx_alloc(p);",
          "5333:  if (!ctx) {",
          "5336:         p->cq_entries));",
          "5337:   free_uid(user);",
          "5338:   return -ENOMEM;",
          "5339:  }",
          "5340:  ctx->compat = in_compat_syscall();",
          "5342:  ctx->user = user;",
          "5343:  ctx->creds = get_current_cred();",
          "5345:  ret = io_allocate_scq_urings(ctx, p);",
          "5346:  if (ret)",
          "5347:   goto err;",
          "5350:  if (ret)",
          "5351:   goto err;",
          "5353:  memset(&p->sq_off, 0, sizeof(p->sq_off));",
          "5354:  p->sq_off.head = offsetof(struct io_rings, sq.head);",
          "5355:  p->sq_off.tail = offsetof(struct io_rings, sq.tail);",
          "",
          "[Removed Lines]",
          "5334:   if (account_mem)",
          "5335:    io_unaccount_mem(user, ring_pages(p->sq_entries,",
          "5341:  ctx->account_mem = account_mem;",
          "5349:  ret = io_sq_offload_start(ctx, p);",
          "",
          "[Added Lines]",
          "9293:   if (limit_mem)",
          "9294:    __io_unaccount_mem(user, ring_pages(p->sq_entries,",
          "9302: #ifdef CONFIG_AUDIT",
          "9303:  ctx->loginuid = current->loginuid;",
          "9304:  ctx->sessionid = current->sessionid;",
          "9305: #endif",
          "9306:  ctx->sqo_task = get_task_struct(current);",
          "9314:  mmgrab(current->mm);",
          "9315:  ctx->mm_account = current->mm;",
          "9317: #ifdef CONFIG_BLK_CGROUP",
          "9324:  rcu_read_lock();",
          "9325:  ctx->sqo_blkcg_css = blkcg_css();",
          "9326:  ret = css_tryget_online(ctx->sqo_blkcg_css);",
          "9327:  rcu_read_unlock();",
          "9328:  if (!ret) {",
          "9330:   ctx->sqo_blkcg_css = NULL;",
          "9331:   ret = -ENODEV;",
          "9332:   goto err;",
          "9333:  }",
          "9334: #endif",
          "9342:  io_account_mem(ctx, ring_pages(p->sq_entries, p->cq_entries),",
          "9343:          ACCT_LOCKED);",
          "9344:  ctx->limit_mem = limit_mem;",
          "9350:  ret = io_sq_offload_create(ctx, p);",
          "9354:  if (!(p->flags & IORING_SETUP_R_DISABLED))",
          "9355:   io_sq_offload_start(ctx);",
          "",
          "---------------",
          "--- Hunk 119 ---",
          "[Context before]",
          "5366:  p->cq_off.ring_entries = offsetof(struct io_rings, cq_ring_entries);",
          "5367:  p->cq_off.overflow = offsetof(struct io_rings, cq_overflow);",
          "5368:  p->cq_off.cqes = offsetof(struct io_rings, cqes);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9373:  p->cq_off.flags = offsetof(struct io_rings, cq_flags);",
          "9375:  p->features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |",
          "9376:    IORING_FEAT_SUBMIT_STABLE | IORING_FEAT_RW_CUR_POS |",
          "9377:    IORING_FEAT_CUR_PERSONALITY | IORING_FEAT_FAST_POLL |",
          "9378:    IORING_FEAT_POLL_32BITS;",
          "9380:  if (copy_to_user(params, p, sizeof(*p))) {",
          "9381:   ret = -EFAULT;",
          "9382:   goto err;",
          "9383:  }",
          "",
          "---------------",
          "--- Hunk 120 ---",
          "[Context before]",
          "5375:  if (ret < 0)",
          "5376:   goto err;",
          "5380:  trace_io_uring_create(ret, ctx, p->sq_entries, p->cq_entries, p->flags);",
          "5381:  return ret;",
          "5382: err:",
          "",
          "[Removed Lines]",
          "5378:  p->features = IORING_FEAT_SINGLE_MMAP | IORING_FEAT_NODROP |",
          "5379:    IORING_FEAT_SUBMIT_STABLE;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 121 ---",
          "[Context before]",
          "5392: static long io_uring_setup(u32 entries, struct io_uring_params __user *params)",
          "5393: {",
          "5394:  struct io_uring_params p;",
          "5396:  int i;",
          "5398:  if (copy_from_user(&p, params, sizeof(p)))",
          "",
          "[Removed Lines]",
          "5395:  long ret;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 122 ---",
          "[Context before]",
          "5403:  }",
          "5405:  if (p.flags & ~(IORING_SETUP_IOPOLL | IORING_SETUP_SQPOLL |",
          "5407:   return -EINVAL;",
          "5417: }",
          "5419: SYSCALL_DEFINE2(io_uring_setup, u32, entries,",
          "",
          "[Removed Lines]",
          "5406:    IORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE))",
          "5409:  ret = io_uring_create(entries, &p);",
          "5410:  if (ret < 0)",
          "5411:   return ret;",
          "5413:  if (copy_to_user(params, &p, sizeof(p)))",
          "5414:   return -EFAULT;",
          "5416:  return ret;",
          "",
          "[Added Lines]",
          "9418:    IORING_SETUP_SQ_AFF | IORING_SETUP_CQSIZE |",
          "9419:    IORING_SETUP_CLAMP | IORING_SETUP_ATTACH_WQ |",
          "9420:    IORING_SETUP_R_DISABLED))",
          "9423:  return  io_uring_create(entries, &p, params);",
          "",
          "---------------",
          "--- Hunk 123 ---",
          "[Context before]",
          "5422:  return io_uring_setup(entries, params);",
          "5423: }",
          "5425: static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,",
          "5426:           void __user *arg, unsigned nr_args)",
          "5427:  __releases(ctx->uring_lock)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9432: static int io_probe(struct io_ring_ctx *ctx, void __user *arg, unsigned nr_args)",
          "9433: {",
          "9434:  struct io_uring_probe *p;",
          "9435:  size_t size;",
          "9436:  int i, ret;",
          "9438:  size = struct_size(p, ops, nr_args);",
          "9439:  if (size == SIZE_MAX)",
          "9440:   return -EOVERFLOW;",
          "9441:  p = kzalloc(size, GFP_KERNEL);",
          "9442:  if (!p)",
          "9443:   return -ENOMEM;",
          "9445:  ret = -EFAULT;",
          "9446:  if (copy_from_user(p, arg, size))",
          "9447:   goto out;",
          "9448:  ret = -EINVAL;",
          "9449:  if (memchr_inv(p, 0, size))",
          "9450:   goto out;",
          "9452:  p->last_op = IORING_OP_LAST - 1;",
          "9453:  if (nr_args > IORING_OP_LAST)",
          "9454:   nr_args = IORING_OP_LAST;",
          "9456:  for (i = 0; i < nr_args; i++) {",
          "9457:   p->ops[i].op = i;",
          "9458:   if (!io_op_defs[i].not_supported)",
          "9459:    p->ops[i].flags = IO_URING_OP_SUPPORTED;",
          "9460:  }",
          "9461:  p->ops_len = i;",
          "9463:  ret = 0;",
          "9464:  if (copy_to_user(arg, p, size))",
          "9465:   ret = -EFAULT;",
          "9466: out:",
          "9467:  kfree(p);",
          "9468:  return ret;",
          "9469: }",
          "9471: static int io_register_personality(struct io_ring_ctx *ctx)",
          "9472: {",
          "9473:  struct io_identity *id;",
          "9474:  int ret;",
          "9476:  id = kmalloc(sizeof(*id), GFP_KERNEL);",
          "9477:  if (unlikely(!id))",
          "9478:   return -ENOMEM;",
          "9480:  io_init_identity(id);",
          "9481:  id->creds = get_current_cred();",
          "9483:  ret = idr_alloc_cyclic(&ctx->personality_idr, id, 1, USHRT_MAX, GFP_KERNEL);",
          "9484:  if (ret < 0) {",
          "9485:   put_cred(id->creds);",
          "9486:   kfree(id);",
          "9487:  }",
          "9488:  return ret;",
          "9489: }",
          "9491: static int io_unregister_personality(struct io_ring_ctx *ctx, unsigned id)",
          "9492: {",
          "9493:  struct io_identity *iod;",
          "9495:  iod = idr_remove(&ctx->personality_idr, id);",
          "9496:  if (iod) {",
          "9497:   put_cred(iod->creds);",
          "9498:   if (refcount_dec_and_test(&iod->count))",
          "9499:    kfree(iod);",
          "9500:   return 0;",
          "9501:  }",
          "9503:  return -EINVAL;",
          "9504: }",
          "9506: static int io_register_restrictions(struct io_ring_ctx *ctx, void __user *arg,",
          "9507:         unsigned int nr_args)",
          "9508: {",
          "9509:  struct io_uring_restriction *res;",
          "9510:  size_t size;",
          "9511:  int i, ret;",
          "9514:  if (!(ctx->flags & IORING_SETUP_R_DISABLED))",
          "9515:   return -EBADFD;",
          "9518:  if (ctx->restrictions.registered)",
          "9519:   return -EBUSY;",
          "9521:  if (!arg || nr_args > IORING_MAX_RESTRICTIONS)",
          "9522:   return -EINVAL;",
          "9524:  size = array_size(nr_args, sizeof(*res));",
          "9525:  if (size == SIZE_MAX)",
          "9526:   return -EOVERFLOW;",
          "9528:  res = memdup_user(arg, size);",
          "9529:  if (IS_ERR(res))",
          "9530:   return PTR_ERR(res);",
          "9532:  ret = 0;",
          "9534:  for (i = 0; i < nr_args; i++) {",
          "9535:   switch (res[i].opcode) {",
          "9536:   case IORING_RESTRICTION_REGISTER_OP:",
          "9537:    if (res[i].register_op >= IORING_REGISTER_LAST) {",
          "9538:     ret = -EINVAL;",
          "9539:     goto out;",
          "9540:    }",
          "9542:    __set_bit(res[i].register_op,",
          "9543:       ctx->restrictions.register_op);",
          "9544:    break;",
          "9545:   case IORING_RESTRICTION_SQE_OP:",
          "9546:    if (res[i].sqe_op >= IORING_OP_LAST) {",
          "9547:     ret = -EINVAL;",
          "9548:     goto out;",
          "9549:    }",
          "9551:    __set_bit(res[i].sqe_op, ctx->restrictions.sqe_op);",
          "9552:    break;",
          "9553:   case IORING_RESTRICTION_SQE_FLAGS_ALLOWED:",
          "9554:    ctx->restrictions.sqe_flags_allowed = res[i].sqe_flags;",
          "9555:    break;",
          "9556:   case IORING_RESTRICTION_SQE_FLAGS_REQUIRED:",
          "9557:    ctx->restrictions.sqe_flags_required = res[i].sqe_flags;",
          "9558:    break;",
          "9559:   default:",
          "9560:    ret = -EINVAL;",
          "9561:    goto out;",
          "9562:   }",
          "9563:  }",
          "9565: out:",
          "9567:  if (ret != 0)",
          "9568:   memset(&ctx->restrictions, 0, sizeof(ctx->restrictions));",
          "9569:  else",
          "9570:   ctx->restrictions.registered = true;",
          "9572:  kfree(res);",
          "9573:  return ret;",
          "9574: }",
          "9576: static int io_register_enable_rings(struct io_ring_ctx *ctx)",
          "9577: {",
          "9578:  if (!(ctx->flags & IORING_SETUP_R_DISABLED))",
          "9579:   return -EBADFD;",
          "9581:  if (ctx->restrictions.registered)",
          "9582:   ctx->restricted = 1;",
          "9584:  ctx->flags &= ~IORING_SETUP_R_DISABLED;",
          "9586:  io_sq_offload_start(ctx);",
          "9588:  return 0;",
          "9589: }",
          "9591: static bool io_register_op_must_quiesce(int op)",
          "9592: {",
          "9593:  switch (op) {",
          "9594:  case IORING_UNREGISTER_FILES:",
          "9595:  case IORING_REGISTER_FILES_UPDATE:",
          "9596:  case IORING_REGISTER_PROBE:",
          "9597:  case IORING_REGISTER_PERSONALITY:",
          "9598:  case IORING_UNREGISTER_PERSONALITY:",
          "9599:   return false;",
          "9600:  default:",
          "9601:   return true;",
          "9602:  }",
          "9603: }",
          "",
          "---------------",
          "--- Hunk 124 ---",
          "[Context before]",
          "5437:  if (percpu_ref_is_dying(&ctx->refs))",
          "5438:   return -ENXIO;",
          "5453:  switch (opcode) {",
          "5454:  case IORING_REGISTER_BUFFERS:",
          "",
          "[Removed Lines]",
          "5440:  percpu_ref_kill(&ctx->refs);",
          "5449:  mutex_unlock(&ctx->uring_lock);",
          "5450:  wait_for_completion(&ctx->completions[0]);",
          "5451:  mutex_lock(&ctx->uring_lock);",
          "",
          "[Added Lines]",
          "9620:  if (io_register_op_must_quiesce(opcode)) {",
          "9621:   percpu_ref_kill(&ctx->refs);",
          "9631:   mutex_unlock(&ctx->uring_lock);",
          "9632:   do {",
          "9633:    ret = wait_for_completion_interruptible(&ctx->ref_comp);",
          "9634:    if (!ret)",
          "9635:     break;",
          "9636:    ret = io_run_task_work_sig();",
          "9637:    if (ret < 0)",
          "9638:     break;",
          "9639:   } while (1);",
          "9641:   mutex_lock(&ctx->uring_lock);",
          "9643:   if (ret) {",
          "9644:    percpu_ref_resurrect(&ctx->refs);",
          "9645:    goto out_quiesce;",
          "9646:   }",
          "9647:  }",
          "9649:  if (ctx->restricted) {",
          "9650:   if (opcode >= IORING_REGISTER_LAST) {",
          "9651:    ret = -EINVAL;",
          "9652:    goto out;",
          "9653:   }",
          "9655:   if (!test_bit(opcode, ctx->restrictions.register_op)) {",
          "9656:    ret = -EACCES;",
          "9657:    goto out;",
          "9658:   }",
          "9659:  }",
          "",
          "---------------",
          "--- Hunk 125 ---",
          "[Context before]",
          "5473:   ret = io_sqe_files_update(ctx, arg, nr_args);",
          "5474:   break;",
          "5475:  case IORING_REGISTER_EVENTFD:",
          "5476:   ret = -EINVAL;",
          "5477:   if (nr_args != 1)",
          "5478:    break;",
          "5479:   ret = io_eventfd_register(ctx, arg);",
          "5480:   break;",
          "5481:  case IORING_UNREGISTER_EVENTFD:",
          "5482:   ret = -EINVAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9684:  case IORING_REGISTER_EVENTFD_ASYNC:",
          "9689:   if (ret)",
          "9690:    break;",
          "9691:   if (opcode == IORING_REGISTER_EVENTFD_ASYNC)",
          "9692:    ctx->eventfd_async = 1;",
          "9693:   else",
          "9694:    ctx->eventfd_async = 0;",
          "",
          "---------------",
          "--- Hunk 126 ---",
          "[Context before]",
          "5484:    break;",
          "5485:   ret = io_eventfd_unregister(ctx);",
          "5486:   break;",
          "5487:  default:",
          "5488:   ret = -EINVAL;",
          "5489:   break;",
          "5490:  }",
          "5495:  return ret;",
          "5496: }",
          "",
          "[Removed Lines]",
          "5493:  reinit_completion(&ctx->completions[0]);",
          "5494:  percpu_ref_reinit(&ctx->refs);",
          "",
          "[Added Lines]",
          "9702:  case IORING_REGISTER_PROBE:",
          "9703:   ret = -EINVAL;",
          "9704:   if (!arg || nr_args > 256)",
          "9705:    break;",
          "9706:   ret = io_probe(ctx, arg, nr_args);",
          "9707:   break;",
          "9708:  case IORING_REGISTER_PERSONALITY:",
          "9709:   ret = -EINVAL;",
          "9710:   if (arg || nr_args)",
          "9711:    break;",
          "9712:   ret = io_register_personality(ctx);",
          "9713:   break;",
          "9714:  case IORING_UNREGISTER_PERSONALITY:",
          "9715:   ret = -EINVAL;",
          "9716:   if (arg)",
          "9717:    break;",
          "9718:   ret = io_unregister_personality(ctx, nr_args);",
          "9719:   break;",
          "9720:  case IORING_REGISTER_ENABLE_RINGS:",
          "9721:   ret = -EINVAL;",
          "9722:   if (arg || nr_args)",
          "9723:    break;",
          "9724:   ret = io_register_enable_rings(ctx);",
          "9725:   break;",
          "9726:  case IORING_REGISTER_RESTRICTIONS:",
          "9727:   ret = io_register_restrictions(ctx, arg, nr_args);",
          "9728:   break;",
          "9734: out:",
          "9735:  if (io_register_op_must_quiesce(opcode)) {",
          "9737:   percpu_ref_reinit(&ctx->refs);",
          "9738: out_quiesce:",
          "9739:   reinit_completion(&ctx->ref_comp);",
          "9740:  }",
          "",
          "---------------",
          "--- Hunk 127 ---",
          "[Context before]",
          "5525: static int __init io_uring_init(void)",
          "5526: {",
          "5527:  req_cachep = KMEM_CACHE(io_kiocb, SLAB_HWCACHE_ALIGN | SLAB_PANIC);",
          "5528:  return 0;",
          "5529: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9773: #define __BUILD_BUG_VERIFY_ELEMENT(stype, eoffset, etype, ename) do { \\",
          "9774:  BUILD_BUG_ON(offsetof(stype, ename) != eoffset); \\",
          "9775:  BUILD_BUG_ON(sizeof(etype) != sizeof_field(stype, ename)); \\",
          "9776: } while (0)",
          "9778: #define BUILD_BUG_SQE_ELEM(eoffset, etype, ename) \\",
          "9779:  __BUILD_BUG_VERIFY_ELEMENT(struct io_uring_sqe, eoffset, etype, ename)",
          "9780:  BUILD_BUG_ON(sizeof(struct io_uring_sqe) != 64);",
          "9781:  BUILD_BUG_SQE_ELEM(0,  __u8,   opcode);",
          "9782:  BUILD_BUG_SQE_ELEM(1,  __u8,   flags);",
          "9783:  BUILD_BUG_SQE_ELEM(2,  __u16,  ioprio);",
          "9784:  BUILD_BUG_SQE_ELEM(4,  __s32,  fd);",
          "9785:  BUILD_BUG_SQE_ELEM(8,  __u64,  off);",
          "9786:  BUILD_BUG_SQE_ELEM(8,  __u64,  addr2);",
          "9787:  BUILD_BUG_SQE_ELEM(16, __u64,  addr);",
          "9788:  BUILD_BUG_SQE_ELEM(16, __u64,  splice_off_in);",
          "9789:  BUILD_BUG_SQE_ELEM(24, __u32,  len);",
          "9790:  BUILD_BUG_SQE_ELEM(28,     __kernel_rwf_t, rw_flags);",
          "9791:  BUILD_BUG_SQE_ELEM(28, /* compat */   int, rw_flags);",
          "9792:  BUILD_BUG_SQE_ELEM(28, /* compat */ __u32, rw_flags);",
          "9793:  BUILD_BUG_SQE_ELEM(28, __u32,  fsync_flags);",
          "9794:  BUILD_BUG_SQE_ELEM(28, /* compat */ __u16,  poll_events);",
          "9795:  BUILD_BUG_SQE_ELEM(28, __u32,  poll32_events);",
          "9796:  BUILD_BUG_SQE_ELEM(28, __u32,  sync_range_flags);",
          "9797:  BUILD_BUG_SQE_ELEM(28, __u32,  msg_flags);",
          "9798:  BUILD_BUG_SQE_ELEM(28, __u32,  timeout_flags);",
          "9799:  BUILD_BUG_SQE_ELEM(28, __u32,  accept_flags);",
          "9800:  BUILD_BUG_SQE_ELEM(28, __u32,  cancel_flags);",
          "9801:  BUILD_BUG_SQE_ELEM(28, __u32,  open_flags);",
          "9802:  BUILD_BUG_SQE_ELEM(28, __u32,  statx_flags);",
          "9803:  BUILD_BUG_SQE_ELEM(28, __u32,  fadvise_advice);",
          "9804:  BUILD_BUG_SQE_ELEM(28, __u32,  splice_flags);",
          "9805:  BUILD_BUG_SQE_ELEM(32, __u64,  user_data);",
          "9806:  BUILD_BUG_SQE_ELEM(40, __u16,  buf_index);",
          "9807:  BUILD_BUG_SQE_ELEM(42, __u16,  personality);",
          "9808:  BUILD_BUG_SQE_ELEM(44, __s32,  splice_fd_in);",
          "9810:  BUILD_BUG_ON(ARRAY_SIZE(io_op_defs) != IORING_OP_LAST);",
          "9811:  BUILD_BUG_ON(__REQ_F_LAST_BIT >= 8 * sizeof(int));",
          "",
          "---------------"
        ],
        "fs/namespace.c||fs/namespace.c": [
          "File: fs/namespace.c -> fs/namespace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1178:   struct task_struct *task = current;",
          "1179:   if (likely(!(task->flags & PF_KTHREAD))) {",
          "1180:    init_task_work(&mnt->mnt_rcu, __cleanup_mnt);",
          "1182:     return;",
          "1183:   }",
          "1184:   if (llist_add(&mnt->mnt_llist, &delayed_mntput_list))",
          "",
          "[Removed Lines]",
          "1181:    if (!task_work_add(task, &mnt->mnt_rcu, true))",
          "",
          "[Added Lines]",
          "1181:    if (!task_work_add(task, &mnt->mnt_rcu, TWA_RESUME))",
          "",
          "---------------"
        ],
        "include/linux/file.h||include/linux/file.h": [
          "File: include/linux/file.h -> include/linux/file.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "83: extern int replace_fd(unsigned fd, struct file *file, unsigned flags);",
          "84: extern void set_close_on_exec(unsigned int fd, int flag);",
          "85: extern bool get_close_on_exec(unsigned int fd);",
          "86: extern int get_unused_fd_flags(unsigned flags);",
          "87: extern void put_unused_fd(unsigned int fd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86: extern int __get_unused_fd_flags(unsigned flags, unsigned long nofile);",
          "",
          "---------------"
        ],
        "include/linux/io_uring.h||include/linux/io_uring.h": [
          "File: include/linux/io_uring.h -> include/linux/io_uring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #ifndef _LINUX_IO_URING_H",
          "3: #define _LINUX_IO_URING_H",
          "5: #include <linux/sched.h>",
          "6: #include <linux/xarray.h>",
          "8: struct io_identity {",
          "9:  struct files_struct  *files;",
          "10:  struct mm_struct  *mm;",
          "11: #ifdef CONFIG_BLK_CGROUP",
          "12:  struct cgroup_subsys_state *blkcg_css;",
          "13: #endif",
          "14:  const struct cred  *creds;",
          "15:  struct nsproxy   *nsproxy;",
          "16:  struct fs_struct  *fs;",
          "17:  unsigned long   fsize;",
          "18: #ifdef CONFIG_AUDIT",
          "19:  kuid_t    loginuid;",
          "20:  unsigned int   sessionid;",
          "21: #endif",
          "22:  refcount_t   count;",
          "23: };",
          "25: struct io_uring_task {",
          "27:  struct xarray  xa;",
          "28:  struct wait_queue_head wait;",
          "29:  struct file  *last;",
          "30:  struct percpu_counter inflight;",
          "31:  struct io_identity __identity;",
          "32:  struct io_identity *identity;",
          "33:  atomic_t  in_idle;",
          "34:  bool   sqpoll;",
          "35: };",
          "37: #if defined(CONFIG_IO_URING)",
          "38: struct sock *io_uring_get_socket(struct file *file);",
          "39: void __io_uring_task_cancel(void);",
          "40: void __io_uring_files_cancel(struct files_struct *files);",
          "41: void __io_uring_free(struct task_struct *tsk);",
          "43: static inline void io_uring_task_cancel(void)",
          "44: {",
          "45:  if (current->io_uring && !xa_empty(&current->io_uring->xa))",
          "46:   __io_uring_task_cancel();",
          "47: }",
          "48: static inline void io_uring_files_cancel(struct files_struct *files)",
          "49: {",
          "50:  if (current->io_uring && !xa_empty(&current->io_uring->xa))",
          "51:   __io_uring_files_cancel(files);",
          "52: }",
          "53: static inline void io_uring_free(struct task_struct *tsk)",
          "54: {",
          "55:  if (tsk->io_uring)",
          "56:   __io_uring_free(tsk);",
          "57: }",
          "58: #else",
          "59: static inline struct sock *io_uring_get_socket(struct file *file)",
          "60: {",
          "61:  return NULL;",
          "62: }",
          "63: static inline void io_uring_task_cancel(void)",
          "64: {",
          "65: }",
          "66: static inline void io_uring_files_cancel(struct files_struct *files)",
          "67: {",
          "68: }",
          "69: static inline void io_uring_free(struct task_struct *tsk)",
          "70: {",
          "71: }",
          "72: #endif",
          "74: #endif",
          "",
          "---------------"
        ],
        "include/linux/sched.h||include/linux/sched.h": [
          "File: include/linux/sched.h -> include/linux/sched.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "61: struct signal_struct;",
          "62: struct task_delay_info;",
          "63: struct task_group;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64: struct io_uring_task;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1292:  UEK_KABI_RESERVE(5)",
          "1293: #endif",
          "1295:  UEK_KABI_RESERVE(6)",
          "1296:  UEK_KABI_RESERVE(7)",
          "1297:  UEK_KABI_RESERVE(8)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1296: #ifdef CONFIG_IO_URING",
          "1297:  UEK_KABI_USE(6, struct io_uring_task *io_uring)",
          "1298: #else",
          "1300: #endif",
          "",
          "---------------"
        ],
        "include/linux/socket.h||include/linux/socket.h": [
          "File: include/linux/socket.h -> include/linux/socket.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "405:    int addr_len);",
          "406: extern int __sys_accept4_file(struct file *file, unsigned file_flags,",
          "407:    struct sockaddr __user *upeer_sockaddr,",
          "409: extern int __sys_accept4(int fd, struct sockaddr __user *upeer_sockaddr,",
          "410:     int __user *upeer_addrlen, int flags);",
          "411: extern int __sys_socket(int family, int type, int protocol);",
          "",
          "[Removed Lines]",
          "408:     int __user *upeer_addrlen, int flags);",
          "",
          "[Added Lines]",
          "408:     int __user *upeer_addrlen, int flags,",
          "409:     unsigned long nofile);",
          "",
          "---------------"
        ],
        "include/linux/task_work.h||include/linux/task_work.h": [
          "File: include/linux/task_work.h -> include/linux/task_work.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13:  twork->func = func;",
          "14: }",
          "20: struct callback_head *task_work_cancel(struct task_struct *, task_work_func_t);",
          "21: void task_work_run(void);",
          "",
          "[Removed Lines]",
          "16: #define TWA_RESUME 1",
          "17: #define TWA_SIGNAL 2",
          "18: int task_work_add(struct task_struct *task, struct callback_head *twork, int);",
          "",
          "[Added Lines]",
          "16: enum task_work_notify_mode {",
          "17:  TWA_NONE,",
          "18:  TWA_RESUME,",
          "19:  TWA_SIGNAL,",
          "20: };",
          "22: int task_work_add(struct task_struct *task, struct callback_head *twork,",
          "23:    enum task_work_notify_mode mode);",
          "",
          "---------------"
        ],
        "include/trace/events/io_uring.h||include/trace/events/io_uring.h": [
          "File: include/trace/events/io_uring.h -> include/trace/events/io_uring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "330: TRACE_EVENT(io_uring_submit_sqe,",
          "336:  TP_STRUCT__entry (",
          "337:   __field(  void *, ctx  )",
          "338:   __field(  u64,  user_data )",
          "339:   __field(  bool,  force_nonblock )",
          "340:   __field(  bool,  sq_thread )",
          "",
          "[Removed Lines]",
          "332:  TP_PROTO(void *ctx, u64 user_data, bool force_nonblock, bool sq_thread),",
          "334:  TP_ARGS(ctx, user_data, force_nonblock, sq_thread),",
          "",
          "[Added Lines]",
          "333:  TP_PROTO(void *ctx, u8 opcode, u64 user_data, bool force_nonblock,",
          "334:    bool sq_thread),",
          "336:  TP_ARGS(ctx, opcode, user_data, force_nonblock, sq_thread),",
          "340:   __field(  u8,  opcode  )",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "343:  TP_fast_assign(",
          "344:   __entry->ctx  = ctx;",
          "345:   __entry->user_data = user_data;",
          "346:   __entry->force_nonblock = force_nonblock;",
          "347:   __entry->sq_thread = sq_thread;",
          "348:  ),",
          "352:      __entry->force_nonblock, __entry->sq_thread)",
          "353: );",
          "",
          "[Removed Lines]",
          "350:  TP_printk(\"ring %p, user data 0x%llx, non block %d, sq_thread %d\",",
          "351:      __entry->ctx, (unsigned long long) __entry->user_data,",
          "",
          "[Added Lines]",
          "348:   __entry->opcode  = opcode;",
          "354:  TP_printk(\"ring %p, op %d, data 0x%llx, non block %d, sq_thread %d\",",
          "355:      __entry->ctx, __entry->opcode,",
          "356:      (unsigned long long) __entry->user_data,",
          "360: TRACE_EVENT(io_uring_poll_arm,",
          "362:  TP_PROTO(void *ctx, u8 opcode, u64 user_data, int mask, int events),",
          "364:  TP_ARGS(ctx, opcode, user_data, mask, events),",
          "366:  TP_STRUCT__entry (",
          "367:   __field(  void *, ctx  )",
          "368:   __field(  u8,  opcode  )",
          "369:   __field(  u64,  user_data )",
          "370:   __field(  int,  mask  )",
          "371:   __field(  int,  events  )",
          "372:  ),",
          "374:  TP_fast_assign(",
          "375:   __entry->ctx  = ctx;",
          "376:   __entry->opcode  = opcode;",
          "377:   __entry->user_data = user_data;",
          "378:   __entry->mask  = mask;",
          "379:   __entry->events  = events;",
          "380:  ),",
          "382:  TP_printk(\"ring %p, op %d, data 0x%llx, mask 0x%x, events 0x%x\",",
          "383:      __entry->ctx, __entry->opcode,",
          "384:      (unsigned long long) __entry->user_data,",
          "385:      __entry->mask, __entry->events)",
          "386: );",
          "388: TRACE_EVENT(io_uring_poll_wake,",
          "390:  TP_PROTO(void *ctx, u8 opcode, u64 user_data, int mask),",
          "392:  TP_ARGS(ctx, opcode, user_data, mask),",
          "394:  TP_STRUCT__entry (",
          "395:   __field(  void *, ctx  )",
          "396:   __field(  u8,  opcode  )",
          "397:   __field(  u64,  user_data )",
          "398:   __field(  int,  mask  )",
          "399:  ),",
          "401:  TP_fast_assign(",
          "402:   __entry->ctx  = ctx;",
          "403:   __entry->opcode  = opcode;",
          "404:   __entry->user_data = user_data;",
          "405:   __entry->mask  = mask;",
          "406:  ),",
          "408:  TP_printk(\"ring %p, op %d, data 0x%llx, mask 0x%x\",",
          "409:      __entry->ctx, __entry->opcode,",
          "410:      (unsigned long long) __entry->user_data,",
          "411:      __entry->mask)",
          "412: );",
          "414: TRACE_EVENT(io_uring_task_add,",
          "416:  TP_PROTO(void *ctx, u8 opcode, u64 user_data, int mask),",
          "418:  TP_ARGS(ctx, opcode, user_data, mask),",
          "420:  TP_STRUCT__entry (",
          "421:   __field(  void *, ctx  )",
          "422:   __field(  u8,  opcode  )",
          "423:   __field(  u64,  user_data )",
          "424:   __field(  int,  mask  )",
          "425:  ),",
          "427:  TP_fast_assign(",
          "428:   __entry->ctx  = ctx;",
          "429:   __entry->opcode  = opcode;",
          "430:   __entry->user_data = user_data;",
          "431:   __entry->mask  = mask;",
          "432:  ),",
          "434:  TP_printk(\"ring %p, op %d, data 0x%llx, mask %x\",",
          "435:      __entry->ctx, __entry->opcode,",
          "436:      (unsigned long long) __entry->user_data,",
          "437:      __entry->mask)",
          "438: );",
          "440: TRACE_EVENT(io_uring_task_run,",
          "442:  TP_PROTO(void *ctx, u8 opcode, u64 user_data),",
          "444:  TP_ARGS(ctx, opcode, user_data),",
          "446:  TP_STRUCT__entry (",
          "447:   __field(  void *, ctx  )",
          "448:   __field(  u8,  opcode  )",
          "449:   __field(  u64,  user_data )",
          "450:  ),",
          "452:  TP_fast_assign(",
          "453:   __entry->ctx  = ctx;",
          "454:   __entry->opcode  = opcode;",
          "455:   __entry->user_data = user_data;",
          "456:  ),",
          "458:  TP_printk(\"ring %p, op %d, data 0x%llx\",",
          "459:      __entry->ctx, __entry->opcode,",
          "460:      (unsigned long long) __entry->user_data)",
          "461: );",
          "",
          "---------------"
        ],
        "include/uapi/linux/io_uring.h||include/uapi/linux/io_uring.h": [
          "File: include/uapi/linux/io_uring.h -> include/uapi/linux/io_uring.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24:   __u64 addr2;",
          "25:  };",
          "28:  union {",
          "29:   __kernel_rwf_t rw_flags;",
          "30:   __u32  fsync_flags;",
          "32:   __u32  sync_range_flags;",
          "33:   __u32  msg_flags;",
          "34:   __u32  timeout_flags;",
          "35:   __u32  accept_flags;",
          "36:   __u32  cancel_flags;",
          "37:  };",
          "39:  union {",
          "41:   __u64 __pad2[3];",
          "42:  };",
          "43: };",
          "",
          "[Removed Lines]",
          "31:   __u16  poll_events;",
          "",
          "[Added Lines]",
          "26:  union {",
          "28:   __u64 splice_off_in;",
          "29:  };",
          "41:   __u32  open_flags;",
          "42:   __u32  statx_flags;",
          "43:   __u32  fadvise_advice;",
          "44:   __u32  splice_flags;",
          "48:   struct {",
          "50:    union {",
          "52:     __u16 buf_index;",
          "54:     __u16 buf_group;",
          "55:    } __attribute__((packed));",
          "57:    __u16 personality;",
          "58:    __s32 splice_fd_in;",
          "59:   };",
          "64: enum {",
          "65:  IOSQE_FIXED_FILE_BIT,",
          "66:  IOSQE_IO_DRAIN_BIT,",
          "67:  IOSQE_IO_LINK_BIT,",
          "68:  IOSQE_IO_HARDLINK_BIT,",
          "69:  IOSQE_ASYNC_BIT,",
          "70:  IOSQE_BUFFER_SELECT_BIT,",
          "71: };",
          "77: #define IOSQE_FIXED_FILE (1U << IOSQE_FIXED_FILE_BIT)",
          "79: #define IOSQE_IO_DRAIN  (1U << IOSQE_IO_DRAIN_BIT)",
          "81: #define IOSQE_IO_LINK  (1U << IOSQE_IO_LINK_BIT)",
          "83: #define IOSQE_IO_HARDLINK (1U << IOSQE_IO_HARDLINK_BIT)",
          "85: #define IOSQE_ASYNC  (1U << IOSQE_ASYNC_BIT)",
          "87: #define IOSQE_BUFFER_SELECT (1U << IOSQE_BUFFER_SELECT_BIT)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:  IORING_OP_ASYNC_CANCEL,",
          "77:  IORING_OP_LINK_TIMEOUT,",
          "78:  IORING_OP_CONNECT,",
          "81:  IORING_OP_LAST,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "118:  IORING_OP_FALLOCATE,",
          "119:  IORING_OP_OPENAT,",
          "120:  IORING_OP_CLOSE,",
          "121:  IORING_OP_FILES_UPDATE,",
          "122:  IORING_OP_STATX,",
          "123:  IORING_OP_READ,",
          "124:  IORING_OP_WRITE,",
          "125:  IORING_OP_FADVISE,",
          "126:  IORING_OP_MADVISE,",
          "127:  IORING_OP_SEND,",
          "128:  IORING_OP_RECV,",
          "129:  IORING_OP_OPENAT2,",
          "130:  IORING_OP_EPOLL_CTL,",
          "131:  IORING_OP_SPLICE,",
          "132:  IORING_OP_PROVIDE_BUFFERS,",
          "133:  IORING_OP_REMOVE_BUFFERS,",
          "134:  IORING_OP_TEE,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "100:  __u32 flags;",
          "101: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "170: #define IORING_CQE_F_BUFFER  (1U << 0)",
          "172: enum {",
          "173:  IORING_CQE_BUFFER_SHIFT  = 16,",
          "174: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "134:  __u32 ring_entries;",
          "135:  __u32 overflow;",
          "136:  __u32 cqes;",
          "138: };",
          "143: #define IORING_ENTER_GETEVENTS (1U << 0)",
          "144: #define IORING_ENTER_SQ_WAKEUP (1U << 1)",
          "",
          "[Removed Lines]",
          "137:  __u64 resv[2];",
          "",
          "[Added Lines]",
          "211:  __u32 flags;",
          "212:  __u32 resv1;",
          "213:  __u64 resv2;",
          "221: #define IORING_CQ_EVENTFD_DISABLED (1U << 0)",
          "228: #define IORING_ENTER_SQ_WAIT (1U << 2)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "153:  __u32 sq_thread_cpu;",
          "154:  __u32 sq_thread_idle;",
          "155:  __u32 features;",
          "157:  struct io_sqring_offsets sq_off;",
          "158:  struct io_cqring_offsets cq_off;",
          "159: };",
          "",
          "[Removed Lines]",
          "156:  __u32 resv[4];",
          "",
          "[Added Lines]",
          "240:  __u32 wq_fd;",
          "241:  __u32 resv[3];",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "164: #define IORING_FEAT_SINGLE_MMAP  (1U << 0)",
          "165: #define IORING_FEAT_NODROP  (1U << 1)",
          "166: #define IORING_FEAT_SUBMIT_STABLE (1U << 2)",
          "179: struct io_uring_files_update {",
          "180:  __u32 offset;",
          "",
          "[Removed Lines]",
          "171: #define IORING_REGISTER_BUFFERS  0",
          "172: #define IORING_UNREGISTER_BUFFERS 1",
          "173: #define IORING_REGISTER_FILES  2",
          "174: #define IORING_UNREGISTER_FILES  3",
          "175: #define IORING_REGISTER_EVENTFD  4",
          "176: #define IORING_UNREGISTER_EVENTFD 5",
          "177: #define IORING_REGISTER_FILES_UPDATE 6",
          "",
          "[Added Lines]",
          "252: #define IORING_FEAT_RW_CUR_POS  (1U << 3)",
          "253: #define IORING_FEAT_CUR_PERSONALITY (1U << 4)",
          "254: #define IORING_FEAT_FAST_POLL  (1U << 5)",
          "255: #define IORING_FEAT_POLL_32BITS  (1U << 6)",
          "260: enum {",
          "261:  IORING_REGISTER_BUFFERS   = 0,",
          "262:  IORING_UNREGISTER_BUFFERS  = 1,",
          "263:  IORING_REGISTER_FILES   = 2,",
          "264:  IORING_UNREGISTER_FILES   = 3,",
          "265:  IORING_REGISTER_EVENTFD   = 4,",
          "266:  IORING_UNREGISTER_EVENTFD  = 5,",
          "267:  IORING_REGISTER_FILES_UPDATE  = 6,",
          "268:  IORING_REGISTER_EVENTFD_ASYNC  = 7,",
          "269:  IORING_REGISTER_PROBE   = 8,",
          "270:  IORING_REGISTER_PERSONALITY  = 9,",
          "271:  IORING_UNREGISTER_PERSONALITY  = 10,",
          "272:  IORING_REGISTER_RESTRICTIONS  = 11,",
          "273:  IORING_REGISTER_ENABLE_RINGS  = 12,",
          "276:  IORING_REGISTER_LAST",
          "277: };",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "182:  __aligned_u64 /* __s32 * */ fds;",
          "183: };",
          "185: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285: #define IO_URING_OP_SUPPORTED (1U << 0)",
          "287: struct io_uring_probe_op {",
          "288:  __u8 op;",
          "289:  __u8 resv;",
          "291:  __u32 resv2;",
          "292: };",
          "294: struct io_uring_probe {",
          "297:  __u16 resv;",
          "298:  __u32 resv2[3];",
          "299:  struct io_uring_probe_op ops[0];",
          "300: };",
          "302: struct io_uring_restriction {",
          "303:  __u16 opcode;",
          "304:  union {",
          "308:  };",
          "309:  __u8 resv;",
          "310:  __u32 resv2[3];",
          "311: };",
          "316: enum {",
          "318:  IORING_RESTRICTION_REGISTER_OP  = 0,",
          "321:  IORING_RESTRICTION_SQE_OP  = 1,",
          "324:  IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,",
          "327:  IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,",
          "329:  IORING_RESTRICTION_LAST",
          "330: };",
          "",
          "---------------"
        ],
        "init/init_task.c||init/init_task.c": [
          "File: init/init_task.c -> init/init_task.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "183: #ifdef CONFIG_SECURITY",
          "184:  .security = NULL,",
          "185: #endif",
          "186: };",
          "187: EXPORT_SYMBOL(init_task);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: #ifdef CONFIG_IO_URING",
          "187:  .io_uring = NULL,",
          "188: #endif",
          "",
          "---------------"
        ],
        "kernel/events/uprobes.c||kernel/events/uprobes.c": [
          "File: kernel/events/uprobes.c -> kernel/events/uprobes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1830:  t->utask->dup_xol_addr = area->vaddr;",
          "1831:  init_task_work(&t->utask->dup_xol_work, dup_xol_work);",
          "1833: }",
          "",
          "[Removed Lines]",
          "1832:  task_work_add(t, &t->utask->dup_xol_work, true);",
          "",
          "[Added Lines]",
          "1832:  task_work_add(t, &t->utask->dup_xol_work, TWA_RESUME);",
          "",
          "---------------"
        ],
        "kernel/fork.c||kernel/fork.c": [
          "File: kernel/fork.c -> kernel/fork.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "94: #include <linux/livepatch.h>",
          "95: #include <linux/thread_info.h>",
          "96: #include <linux/stackleak.h>",
          "98: #include <asm/pgtable.h>",
          "99: #include <asm/pgalloc.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97: #include <linux/io_uring.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "738:  WARN_ON(refcount_read(&tsk->usage));",
          "739:  WARN_ON(tsk == current);",
          "741:  cgroup_free(tsk);",
          "742:  task_numa_free(tsk, true);",
          "743:  security_task_free(tsk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "742:  io_uring_free(tsk);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1934:  p->vtime.state = VTIME_INACTIVE;",
          "1935: #endif",
          "1937: #if defined(SPLIT_RSS_COUNTING)",
          "1938:  memset(&p->rss_stat, 0, sizeof(p->rss_stat));",
          "1939: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1939: #ifdef CONFIG_IO_URING",
          "1940:  p->io_uring = NULL;",
          "1941: #endif",
          "",
          "---------------"
        ],
        "kernel/irq/manage.c||kernel/irq/manage.c": [
          "File: kernel/irq/manage.c -> kernel/irq/manage.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1120:   handler_fn = irq_thread_fn;",
          "1122:  init_task_work(&on_exit_work, irq_thread_dtor);",
          "1125:  irq_thread_check_affinity(desc, action);",
          "",
          "[Removed Lines]",
          "1123:  task_work_add(current, &on_exit_work, false);",
          "",
          "[Added Lines]",
          "1123:  task_work_add(current, &on_exit_work, TWA_NONE);",
          "",
          "---------------"
        ],
        "kernel/sched/fair.c||kernel/sched/fair.c": [
          "File: kernel/sched/fair.c -> kernel/sched/fair.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2763:   curr->node_stamp += period;",
          "2765:   if (!time_before(jiffies, curr->mm->numa_next_scan))",
          "2767:  }",
          "2768: }",
          "",
          "[Removed Lines]",
          "2766:    task_work_add(curr, work, true);",
          "",
          "[Added Lines]",
          "2766:    task_work_add(curr, work, TWA_RESUME);",
          "",
          "---------------"
        ],
        "kernel/task_work.c||kernel/task_work.c": [
          "File: kernel/task_work.c -> kernel/task_work.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: {",
          "30:  struct callback_head *head;",
          "31:  unsigned long flags;",
          "",
          "[Removed Lines]",
          "27: int",
          "28: task_work_add(struct task_struct *task, struct callback_head *work, int notify)",
          "",
          "[Added Lines]",
          "32: int task_work_add(struct task_struct *task, struct callback_head *work,",
          "33:     enum task_work_notify_mode notify)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38:  } while (cmpxchg(&task->task_works, head, work) != head);",
          "40:  switch (notify) {",
          "41:  case TWA_RESUME:",
          "42:   set_notify_resume(task);",
          "43:   break;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:  case TWA_NONE:",
          "47:   break;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:    unlock_task_sighand(task, &flags);",
          "55:   }",
          "56:   break;",
          "57:  }",
          "59:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:  default:",
          "65:   WARN_ON_ONCE(1);",
          "66:   break;",
          "",
          "---------------"
        ],
        "net/socket.c||net/socket.c": [
          "File: net/socket.c -> net/socket.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1680: int __sys_accept4_file(struct file *file, unsigned file_flags,",
          "1681:          struct sockaddr __user *upeer_sockaddr,",
          "1683: {",
          "1684:  struct socket *sock, *newsock;",
          "1685:  struct file *newfile;",
          "",
          "[Removed Lines]",
          "1682:          int __user *upeer_addrlen, int flags)",
          "",
          "[Added Lines]",
          "1682:          int __user *upeer_addrlen, int flags,",
          "1683:          unsigned long nofile)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1711:  __module_get(newsock->ops->owner);",
          "1714:  if (unlikely(newfd < 0)) {",
          "1715:   err = newfd;",
          "1716:   sock_release(newsock);",
          "",
          "[Removed Lines]",
          "1713:  newfd = get_unused_fd_flags(flags);",
          "",
          "[Added Lines]",
          "1714:  newfd = __get_unused_fd_flags(flags, nofile);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1779:  f = fdget(fd);",
          "1780:  if (f.file) {",
          "1781:   ret = __sys_accept4_file(f.file, 0, upeer_sockaddr,",
          "1783:   if (f.flags)",
          "1784:    fput(f.file);",
          "1785:  }",
          "",
          "[Removed Lines]",
          "1782:       upeer_addrlen, flags);",
          "",
          "[Added Lines]",
          "1783:       upeer_addrlen, flags,",
          "1784:       rlimit(RLIMIT_NOFILE));",
          "",
          "---------------"
        ],
        "security/keys/keyctl.c||security/keys/keyctl.c": [
          "File: security/keys/keyctl.c -> security/keys/keyctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1689:  if (!ret)",
          "1690:   newwork = NULL;",
          "1691: unlock:",
          "",
          "[Removed Lines]",
          "1688:  ret = task_work_add(parent, newwork, true);",
          "",
          "[Added Lines]",
          "1688:  ret = task_work_add(parent, newwork, TWA_RESUME);",
          "",
          "---------------"
        ],
        "security/yamyama_lsm.c||security/yama/yama_lsm.c": [
          "File: security/yamyama_lsm.c -> security/yama/yama_lsm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:  if (task_work_add(current, &info->work, TWA_RESUME) == 0)",
          "",
          "---------------"
        ],
        "tools/io_uring/io_uring-bench.c||tools/io_uring/io_uring-bench.c": [
          "File: tools/io_uring/io_uring-bench.c -> tools/io_uring/io_uring-bench.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "130:      s->nr_files);",
          "131: }",
          "134: {",
          "135:  return syscall(__NR_gettid);",
          "136: }",
          "",
          "[Removed Lines]",
          "133: static int gettid(void)",
          "",
          "[Added Lines]",
          "133: static int lk_gettid(void)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "281:  struct io_sq_ring *ring = &s->sq_ring;",
          "282:  int ret, prepped;",
          "286:  srand48_r(pthread_self(), &s->rand);",
          "",
          "[Removed Lines]",
          "284:  printf(\"submitter=%d\\n\", gettid());",
          "",
          "[Added Lines]",
          "284:  printf(\"submitter=%d\\n\", lk_gettid());",
          "",
          "---------------"
        ],
        "tools/io_uring/liburing.h||tools/io_uring/liburing.h": [
          "File: tools/io_uring/liburing.h -> tools/io_uring/liburing.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <string.h>",
          "11: #include \"../../include/uapi/linux/io_uring.h\"",
          "12: #include <inttypes.h>",
          "13: #include \"barrier.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <linux/swab.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145: }",
          "147: static inline void io_uring_prep_poll_add(struct io_uring_sqe *sqe, int fd,",
          "149: {",
          "150:  memset(sqe, 0, sizeof(*sqe));",
          "151:  sqe->opcode = IORING_OP_POLL_ADD;",
          "152:  sqe->fd = fd;",
          "153:  sqe->poll_events = poll_mask;",
          "154: }",
          "",
          "[Removed Lines]",
          "148:        short poll_mask)",
          "",
          "[Added Lines]",
          "149:        unsigned poll_mask)",
          "154: #if __BYTE_ORDER == __BIG_ENDIAN",
          "155:  poll_mask = __swahw32(poll_mask);",
          "156: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
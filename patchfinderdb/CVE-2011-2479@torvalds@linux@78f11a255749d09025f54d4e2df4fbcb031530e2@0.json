{
  "cve_id": "CVE-2011-2479",
  "cve_desc": "The Linux kernel before 2.6.39 does not properly create transparent huge pages in response to a MAP_PRIVATE mmap system call on /dev/zero, which allows local users to cause a denial of service (system crash) via a crafted application.",
  "repo": "torvalds/linux",
  "patch_hash": "78f11a255749d09025f54d4e2df4fbcb031530e2",
  "patch_info": {
    "commit_hash": "78f11a255749d09025f54d4e2df4fbcb031530e2",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/78f11a255749d09025f54d4e2df4fbcb031530e2",
    "files": [
      "include/linux/huge_mm.h",
      "include/linux/mm.h",
      "mm/huge_memory.c"
    ],
    "message": "mm: thp: fix /dev/zero MAP_PRIVATE and vm_flags cleanups\n\nThe huge_memory.c THP page fault was allowed to run if vm_ops was null\n(which would succeed for /dev/zero MAP_PRIVATE, as the f_op->mmap wouldn't\nsetup a special vma->vm_ops and it would fallback to regular anonymous\nmemory) but other THP logics weren't fully activated for vmas with vm_file\nnot NULL (/dev/zero has a not NULL vma->vm_file).\n\nSo this removes the vm_file checks so that /dev/zero also can safely use\nTHP (the other albeit safer approach to fix this bug would have been to\nprevent the THP initial page fault to run if vm_file was set).\n\nAfter removing the vm_file checks, this also makes huge_memory.c stricter\nin khugepaged for the DEBUG_VM=y case.  It doesn't replace the vm_file\ncheck with a is_pfn_mapping check (but it keeps checking for VM_PFNMAP\nunder VM_BUG_ON) because for a is_cow_mapping() mapping VM_PFNMAP should\nonly be allowed to exist before the first page fault, and in turn when\nvma->anon_vma is null (so preventing khugepaged registration).  So I tend\nto think the previous comment saying if vm_file was set, VM_PFNMAP might\nhave been set and we could still be registered in khugepaged (despite\nanon_vma was not NULL to be registered in khugepaged) was too paranoid.\nThe is_linear_pfn_mapping check is also I think superfluous (as described\nby comment) but under DEBUG_VM it is safe to stay.\n\nAddresses https://bugzilla.kernel.org/show_bug.cgi?id=33682\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nReported-by: Caspar Zhang <bugs@casparzhang.com>\nAcked-by: Mel Gorman <mel@csn.ul.ie>\nAcked-by: Rik van Riel <riel@redhat.com>\nCc: <stable@kernel.org>\t\t[2.6.38.x]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "include/linux/huge_mm.h||include/linux/huge_mm.h",
      "include/linux/mm.h||include/linux/mm.h",
      "mm/huge_memory.c||mm/huge_memory.c"
    ]
  },
  "patch_diff": {
    "include/linux/huge_mm.h||include/linux/huge_mm.h": [
      "File: include/linux/huge_mm.h -> include/linux/huge_mm.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "117:       unsigned long end,",
      "118:       long adjust_next)",
      "119: {",
      "121:   return;",
      "122:  __vma_adjust_trans_huge(vma, start, end, adjust_next);",
      "123: }",
      "",
      "[Removed Lines]",
      "120:  if (!vma->anon_vma || vma->vm_ops || vma->vm_file)",
      "",
      "[Added Lines]",
      "120:  if (!vma->anon_vma || vma->vm_ops)",
      "",
      "---------------"
    ],
    "include/linux/mm.h||include/linux/mm.h": [
      "File: include/linux/mm.h -> include/linux/mm.h"
    ],
    "mm/huge_memory.c||mm/huge_memory.c": [
      "File: mm/huge_memory.c -> mm/huge_memory.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1408:  return ret;",
      "1409: }",
      "1411: int hugepage_madvise(struct vm_area_struct *vma,",
      "1412:        unsigned long *vm_flags, int advice)",
      "1413: {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1411: #define VM_NO_THP (VM_SPECIAL|VM_INSERTPAGE|VM_MIXEDMAP|VM_SAO| \\",
      "1412:      VM_HUGETLB|VM_SHARED|VM_MAYSHARE)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1424:    return -EINVAL;",
      "",
      "[Removed Lines]",
      "1419:   if (*vm_flags & (VM_HUGEPAGE |",
      "1420:      VM_SHARED   | VM_MAYSHARE   |",
      "1421:      VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |",
      "1422:      VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |",
      "1423:      VM_MIXEDMAP | VM_SAO))",
      "",
      "[Added Lines]",
      "1422:   if (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1444:    return -EINVAL;",
      "",
      "[Removed Lines]",
      "1439:   if (*vm_flags & (VM_NOHUGEPAGE |",
      "1440:      VM_SHARED   | VM_MAYSHARE   |",
      "1441:      VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |",
      "1442:      VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |",
      "1443:      VM_MIXEDMAP | VM_SAO))",
      "",
      "[Added Lines]",
      "1438:   if (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1576:   return 0;",
      "1579:   return 0;",
      "1581:  hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;",
      "1582:  hend = vma->vm_end & HPAGE_PMD_MASK;",
      "1583:  if (hstart < hend)",
      "",
      "[Removed Lines]",
      "1577:  if (vma->vm_file || vma->vm_ops)",
      "1580:  VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
      "",
      "[Added Lines]",
      "1572:  if (vma->vm_ops)",
      "1579:  VM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1828:      (vma->vm_flags & VM_NOHUGEPAGE))",
      "1829:   goto out;",
      "1833:   goto out;",
      "1834:  if (is_vma_temporary_stack(vma))",
      "1835:   goto out;",
      "1838:  pgd = pgd_offset(mm, address);",
      "1839:  if (!pgd_present(*pgd))",
      "",
      "[Removed Lines]",
      "1832:  if (!vma->anon_vma || vma->vm_ops || vma->vm_file)",
      "1836:  VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
      "",
      "[Added Lines]",
      "1830:  if (!vma->anon_vma || vma->vm_ops)",
      "1838:  VM_BUG_ON(is_linear_pfn_mapping(vma) || vma->vm_flags & VM_NO_THP);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2066:    progress++;",
      "2067:    continue;",
      "2068:   }",
      "2071:    goto skip;",
      "2072:   if (is_vma_temporary_stack(vma))",
      "2073:    goto skip;",
      "2077:   hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;",
      "2078:   hend = vma->vm_end & HPAGE_PMD_MASK;",
      "",
      "[Removed Lines]",
      "2070:   if (!vma->anon_vma || vma->vm_ops || vma->vm_file)",
      "2075:   VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
      "",
      "[Added Lines]",
      "2071:   if (!vma->anon_vma || vma->vm_ops)",
      "2079:   VM_BUG_ON(is_linear_pfn_mapping(vma) ||",
      "2080:      vma->vm_flags & VM_NO_THP);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "60ab3244ec85c44276c585a2a20d3750402e1cf4",
      "candidate_info": {
        "commit_hash": "60ab3244ec85c44276c585a2a20d3750402e1cf4",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/60ab3244ec85c44276c585a2a20d3750402e1cf4",
        "files": [
          "include/linux/huge_mm.h",
          "mm/huge_memory.c",
          "mm/madvise.c"
        ],
        "message": "thp: khugepaged: make khugepaged aware about madvise\n\nMADV_HUGEPAGE and MADV_NOHUGEPAGE were fully effective only if run after\nmmap and before touching the memory.  While this is enough for most\nusages, it's little effort to make madvise more dynamic at runtime on an\nexisting mapping by making khugepaged aware about madvise.\n\nMADV_HUGEPAGE: register in khugepaged immediately without waiting a page\nfault (that may not ever happen if all pages are already mapped and the\n\"enabled\" knob was set to madvise during the initial page faults).\n\nMADV_NOHUGEPAGE: skip vmas marked VM_NOHUGEPAGE in khugepaged to stop\ncollapsing pages where not needed.\n\n[akpm@linux-foundation.org: tweak comment]\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nCc: Michael Kerrisk <mtk.manpages@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/huge_mm.h||include/linux/huge_mm.h",
          "mm/huge_memory.c||mm/huge_memory.c",
          "mm/madvise.c||mm/madvise.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ],
          "candidate": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/huge_mm.h||include/linux/huge_mm.h": [
          "File: include/linux/huge_mm.h -> include/linux/huge_mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "105: #if HPAGE_PMD_ORDER > MAX_ORDER",
          "106: #error \"hugepages can't be allocated by the buddy allocator\"",
          "107: #endif",
          "109: extern void __vma_adjust_trans_huge(struct vm_area_struct *vma,",
          "110:         unsigned long start,",
          "111:         unsigned long end,",
          "",
          "[Removed Lines]",
          "108: extern int hugepage_madvise(unsigned long *vm_flags, int advice);",
          "",
          "[Added Lines]",
          "108: extern int hugepage_madvise(struct vm_area_struct *vma,",
          "109:        unsigned long *vm_flags, int advice);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143:  do { } while (0)",
          "144: #define wait_split_huge_page(__anon_vma, __pmd) \\",
          "145:  do { } while (0)",
          "147: {",
          "148:  BUG();",
          "149:  return 0;",
          "",
          "[Removed Lines]",
          "146: static inline int hugepage_madvise(unsigned long *vm_flags, int advice)",
          "",
          "[Added Lines]",
          "147: static inline int hugepage_madvise(struct vm_area_struct *vma,",
          "148:        unsigned long *vm_flags, int advice)",
          "",
          "---------------"
        ],
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1389:  return ret;",
          "1390: }",
          "1393: {",
          "1394:  switch (advice) {",
          "1395:  case MADV_HUGEPAGE:",
          "",
          "[Removed Lines]",
          "1392: int hugepage_madvise(unsigned long *vm_flags, int advice)",
          "",
          "[Added Lines]",
          "1392: int hugepage_madvise(struct vm_area_struct *vma,",
          "1393:        unsigned long *vm_flags, int advice)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1404:    return -EINVAL;",
          "1407:   break;",
          "1408:  case MADV_NOHUGEPAGE:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1413:   if (unlikely(khugepaged_enter_vma_merge(vma)))",
          "1414:    return -ENOMEM;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1784:  if (address < hstart || address + HPAGE_PMD_SIZE > hend)",
          "1785:   goto out;",
          "1788:   goto out;",
          "",
          "[Removed Lines]",
          "1787:  if (!(vma->vm_flags & VM_HUGEPAGE) && !khugepaged_always())",
          "",
          "[Added Lines]",
          "1800:  if ((!(vma->vm_flags & VM_HUGEPAGE) && !khugepaged_always()) ||",
          "1801:      (vma->vm_flags & VM_NOHUGEPAGE))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2007:    break;",
          "2008:   }",
          "2012:    progress++;",
          "2013:    continue;",
          "2014:   }",
          "",
          "[Removed Lines]",
          "2010:   if (!(vma->vm_flags & VM_HUGEPAGE) &&",
          "2011:       !khugepaged_always()) {",
          "",
          "[Added Lines]",
          "2024:   if ((!(vma->vm_flags & VM_HUGEPAGE) &&",
          "2025:        !khugepaged_always()) ||",
          "2026:       (vma->vm_flags & VM_NOHUGEPAGE)) {",
          "",
          "---------------"
        ],
        "mm/madvise.c||mm/madvise.c": [
          "File: mm/madvise.c -> mm/madvise.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "73:   break;",
          "74:  case MADV_HUGEPAGE:",
          "75:  case MADV_NOHUGEPAGE:",
          "77:   if (error)",
          "78:    goto out;",
          "79:   break;",
          "",
          "[Removed Lines]",
          "76:   error = hugepage_madvise(&new_flags, behavior);",
          "",
          "[Added Lines]",
          "76:   error = hugepage_madvise(vma, &new_flags, behavior);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a7d6e4ecdb7648478ddec76d30d87d03d6e22b31",
      "candidate_info": {
        "commit_hash": "a7d6e4ecdb7648478ddec76d30d87d03d6e22b31",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a7d6e4ecdb7648478ddec76d30d87d03d6e22b31",
        "files": [
          "include/linux/huge_mm.h",
          "mm/huge_memory.c"
        ],
        "message": "thp: prevent hugepages during args/env copying into the user stack\n\nTransparent hugepages can only be created if rmap is fully\nfunctional. So we must prevent hugepages to be created while\nis_vma_temporary_stack() is true.\n\nThis also optmizes away some harmless but unnecessary setting of\nkhugepaged_scan.address and it switches some BUG_ON to VM_BUG_ON.\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/huge_mm.h||include/linux/huge_mm.h",
          "mm/huge_memory.c||mm/huge_memory.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ],
          "candidate": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/huge_mm.h||include/linux/huge_mm.h": [
          "File: include/linux/huge_mm.h -> include/linux/huge_mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:    (transparent_hugepage_flags &     \\",
          "58:     (1<<TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG) &&   \\",
          "59:     ((__vma)->vm_flags & VM_HUGEPAGE))) &&   \\",
          "61: #define transparent_hugepage_defrag(__vma)    \\",
          "62:  ((transparent_hugepage_flags &     \\",
          "63:    (1<<TRANSPARENT_HUGEPAGE_DEFRAG_FLAG)) ||   \\",
          "",
          "[Removed Lines]",
          "60:   !((__vma)->vm_flags & VM_NOHUGEPAGE))",
          "",
          "[Added Lines]",
          "60:   !((__vma)->vm_flags & VM_NOHUGEPAGE) &&   \\",
          "61:   !is_vma_temporary_stack(__vma))",
          "",
          "---------------"
        ],
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1812:  if (!vma->anon_vma || vma->vm_ops || vma->vm_file)",
          "1813:   goto out;",
          "1814:  VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
          "1816:  pgd = pgd_offset(mm, address);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1814:  if (is_vma_temporary_stack(vma))",
          "1815:   goto out;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2032:   if ((!(vma->vm_flags & VM_HUGEPAGE) &&",
          "2033:        !khugepaged_always()) ||",
          "2034:       (vma->vm_flags & VM_NOHUGEPAGE)) {",
          "2035:    progress++;",
          "2036:    continue;",
          "2037:   }",
          "2045:   VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
          "2047:   hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;",
          "2048:   hend = vma->vm_end & HPAGE_PMD_MASK;",
          "2053:   if (khugepaged_scan.address < hstart)",
          "2054:    khugepaged_scan.address = hstart;",
          "2062:   while (khugepaged_scan.address < hend) {",
          "2063:    int ret;",
          "",
          "[Removed Lines]",
          "2040:   if (!vma->anon_vma || vma->vm_ops || vma->vm_file) {",
          "2041:    khugepaged_scan.address = vma->vm_end;",
          "2042:    progress++;",
          "2043:    continue;",
          "2044:   }",
          "2049:   if (hstart >= hend) {",
          "2050:    progress++;",
          "2051:    continue;",
          "2052:   }",
          "2055:   if (khugepaged_scan.address > hend) {",
          "2056:    khugepaged_scan.address = hend + HPAGE_PMD_SIZE;",
          "2057:    progress++;",
          "2058:    continue;",
          "2059:   }",
          "2060:   BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);",
          "",
          "[Added Lines]",
          "2037:   skip:",
          "2042:   if (!vma->anon_vma || vma->vm_ops || vma->vm_file)",
          "2043:    goto skip;",
          "2044:   if (is_vma_temporary_stack(vma))",
          "2045:    goto skip;",
          "2051:   if (hstart >= hend)",
          "2052:    goto skip;",
          "2053:   if (khugepaged_scan.address > hend)",
          "2054:    goto skip;",
          "2057:   VM_BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2086: breakouterloop_mmap_sem:",
          "2088:  spin_lock(&khugepaged_mm_lock);",
          "",
          "[Removed Lines]",
          "2089:  BUG_ON(khugepaged_scan.mm_slot != mm_slot);",
          "",
          "[Added Lines]",
          "2086:  VM_BUG_ON(khugepaged_scan.mm_slot != mm_slot);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2242:  for (;;) {",
          "2243:   mutex_unlock(&khugepaged_mutex);",
          "2245:   khugepaged_loop();",
          "2248:   mutex_lock(&khugepaged_mutex);",
          "2249:   if (!khugepaged_enabled())",
          "",
          "[Removed Lines]",
          "2244:   BUG_ON(khugepaged_thread != current);",
          "2246:   BUG_ON(khugepaged_thread != current);",
          "",
          "[Added Lines]",
          "2241:   VM_BUG_ON(khugepaged_thread != current);",
          "2243:   VM_BUG_ON(khugepaged_thread != current);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94fcc585fb85ad7b059c70872489b50044d401f3",
      "candidate_info": {
        "commit_hash": "94fcc585fb85ad7b059c70872489b50044d401f3",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/94fcc585fb85ad7b059c70872489b50044d401f3",
        "files": [
          "include/linux/huge_mm.h",
          "mm/huge_memory.c",
          "mm/mmap.c"
        ],
        "message": "thp: avoid breaking huge pmd invariants in case of vma_adjust failures\n\nAn huge pmd can only be mapped if the corresponding 2M virtual range is\nfully contained in the vma.  At times the VM calls split_vma twice, if the\nfirst split_vma succeeds and the second fail, the first split_vma remains\nin effect and it's not rolled back.  For split_vma or vma_adjust to fail\nan allocation failure is needed so it's a very unlikely event (the out of\nmemory killer would normally fire before any allocation failure is visible\nto kernel and userland and if an out of memory condition happens it's\nunlikely to happen exactly here).  Nevertheless it's safer to ensure that\nno huge pmd can be left around if the vma is adjusted in a way that can't\nfit hugepages anymore at the new vm_start/vm_end address.\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/huge_mm.h||include/linux/huge_mm.h",
          "mm/huge_memory.c||mm/huge_memory.c",
          "mm/mmap.c||mm/mmap.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ],
          "candidate": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/huge_mm.h||include/linux/huge_mm.h": [
          "File: include/linux/huge_mm.h -> include/linux/huge_mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "104: #error \"hugepages can't be allocated by the buddy allocator\"",
          "105: #endif",
          "106: extern int hugepage_madvise(unsigned long *vm_flags);",
          "108: #define HPAGE_PMD_SHIFT ({ BUG(); 0; })",
          "109: #define HPAGE_PMD_MASK ({ BUG(); 0; })",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107: extern void __vma_adjust_trans_huge(struct vm_area_struct *vma,",
          "108:         unsigned long start,",
          "109:         unsigned long end,",
          "110:         long adjust_next);",
          "111: static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,",
          "112:       unsigned long start,",
          "113:       unsigned long end,",
          "114:       long adjust_next)",
          "115: {",
          "116:  if (!vma->anon_vma || vma->vm_ops || vma->vm_file)",
          "117:   return;",
          "118:  __vma_adjust_trans_huge(vma, start, end, adjust_next);",
          "119: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "125:  BUG();",
          "126:  return 0;",
          "127: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141: static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,",
          "142:       unsigned long start,",
          "143:       unsigned long end,",
          "144:       long adjust_next)",
          "145: {",
          "146: }",
          "",
          "---------------"
        ],
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1075:   goto out;",
          "1076:  if (pmd_page(*pmd) != page)",
          "1077:   goto out;",
          "1080:  if (pmd_trans_huge(*pmd)) {",
          "1081:   VM_BUG_ON(flag == PAGE_CHECK_ADDRESS_PMD_SPLITTING_FLAG &&",
          "1082:      !pmd_trans_splitting(*pmd));",
          "",
          "[Removed Lines]",
          "1078:  VM_BUG_ON(flag == PAGE_CHECK_ADDRESS_PMD_NOTSPLITTING_FLAG &&",
          "1079:     pmd_trans_splitting(*pmd));",
          "",
          "[Added Lines]",
          "1085:  if (flag == PAGE_CHECK_ADDRESS_PMD_NOTSPLITTING_FLAG &&",
          "1086:      pmd_trans_splitting(*pmd))",
          "1087:   goto out;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2196:  put_page(page);",
          "2197:  BUG_ON(pmd_trans_huge(*pmd));",
          "2198: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2208: static void split_huge_page_address(struct mm_struct *mm,",
          "2209:         unsigned long address)",
          "2210: {",
          "2211:  pgd_t *pgd;",
          "2212:  pud_t *pud;",
          "2213:  pmd_t *pmd;",
          "2215:  VM_BUG_ON(!(address & ~HPAGE_PMD_MASK));",
          "2217:  pgd = pgd_offset(mm, address);",
          "2218:  if (!pgd_present(*pgd))",
          "2219:   return;",
          "2221:  pud = pud_offset(pgd, address);",
          "2222:  if (!pud_present(*pud))",
          "2223:   return;",
          "2225:  pmd = pmd_offset(pud, address);",
          "2226:  if (!pmd_present(*pmd))",
          "2227:   return;",
          "2232:  split_huge_page_pmd(mm, pmd);",
          "2233: }",
          "2235: void __vma_adjust_trans_huge(struct vm_area_struct *vma,",
          "2236:         unsigned long start,",
          "2237:         unsigned long end,",
          "2238:         long adjust_next)",
          "2239: {",
          "2245:  if (start & ~HPAGE_PMD_MASK &&",
          "2246:      (start & HPAGE_PMD_MASK) >= vma->vm_start &&",
          "2247:      (start & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)",
          "2248:   split_huge_page_address(vma->vm_mm, start);",
          "2255:  if (end & ~HPAGE_PMD_MASK &&",
          "2256:      (end & HPAGE_PMD_MASK) >= vma->vm_start &&",
          "2257:      (end & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= vma->vm_end)",
          "2258:   split_huge_page_address(vma->vm_mm, end);",
          "2265:  if (adjust_next > 0) {",
          "2266:   struct vm_area_struct *next = vma->vm_next;",
          "2267:   unsigned long nstart = next->vm_start;",
          "2268:   nstart += adjust_next << PAGE_SHIFT;",
          "2269:   if (nstart & ~HPAGE_PMD_MASK &&",
          "2270:       (nstart & HPAGE_PMD_MASK) >= next->vm_start &&",
          "2271:       (nstart & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE <= next->vm_end)",
          "2272:    split_huge_page_address(next->vm_mm, nstart);",
          "2273:  }",
          "2274: }",
          "",
          "---------------"
        ],
        "mm/mmap.c||mm/mmap.c": [
          "File: mm/mmap.c -> mm/mmap.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "589:   }",
          "590:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "592:  vma_adjust_trans_huge(vma, start, end, adjust_next);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ba76149f47d8c939efa0acc07a191237af900471",
      "candidate_info": {
        "commit_hash": "ba76149f47d8c939efa0acc07a191237af900471",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ba76149f47d8c939efa0acc07a191237af900471",
        "files": [
          "include/linux/huge_mm.h",
          "include/linux/khugepaged.h",
          "include/linux/sched.h",
          "kernel/fork.c",
          "mm/huge_memory.c"
        ],
        "message": "thp: khugepaged\n\nAdd khugepaged to relocate fragmented pages into hugepages if new\nhugepages become available.  (this is indipendent of the defrag logic that\nwill have to make new hugepages available)\n\nThe fundamental reason why khugepaged is unavoidable, is that some memory\ncan be fragmented and not everything can be relocated.  So when a virtual\nmachine quits and releases gigabytes of hugepages, we want to use those\nfreely available hugepages to create huge-pmd in the other virtual\nmachines that may be running on fragmented memory, to maximize the CPU\nefficiency at all times.  The scan is slow, it takes nearly zero cpu time,\nexcept when it copies data (in which case it means we definitely want to\npay for that cpu time) so it seems a good tradeoff.\n\nIn addition to the hugepages being released by other process releasing\nmemory, we have the strong suspicion that the performance impact of\npotentially defragmenting hugepages during or before each page fault could\nlead to more performance inconsistency than allocating small pages at\nfirst and having them collapsed into large pages later...  if they prove\nthemselfs to be long lived mappings (khugepaged scan is slow so short\nlived mappings have low probability to run into khugepaged if compared to\nlong lived mappings).\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/huge_mm.h||include/linux/huge_mm.h",
          "include/linux/khugepaged.h||include/linux/khugepaged.h",
          "include/linux/sched.h||include/linux/sched.h",
          "kernel/fork.c||kernel/fork.c",
          "mm/huge_memory.c||mm/huge_memory.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ],
          "candidate": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/huge_mm.h||include/linux/huge_mm.h": [
          "File: include/linux/huge_mm.h -> include/linux/huge_mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG,",
          "26:  TRANSPARENT_HUGEPAGE_DEFRAG_FLAG,",
          "27:  TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG,",
          "28: #ifdef CONFIG_DEBUG_VM",
          "29:  TRANSPARENT_HUGEPAGE_DEBUG_COW_FLAG,",
          "30: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:  TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG,",
          "",
          "---------------"
        ],
        "include/linux/khugepaged.h||include/linux/khugepaged.h": [
          "File: include/linux/khugepaged.h -> include/linux/khugepaged.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef _LINUX_KHUGEPAGED_H",
          "2: #define _LINUX_KHUGEPAGED_H",
          "6: #ifdef CONFIG_TRANSPARENT_HUGEPAGE",
          "7: extern int __khugepaged_enter(struct mm_struct *mm);",
          "8: extern void __khugepaged_exit(struct mm_struct *mm);",
          "9: extern int khugepaged_enter_vma_merge(struct vm_area_struct *vma);",
          "11: #define khugepaged_enabled()            \\",
          "12:  (transparent_hugepage_flags &           \\",
          "13:   ((1<<TRANSPARENT_HUGEPAGE_FLAG) |         \\",
          "14:    (1<<TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG)))",
          "15: #define khugepaged_always()    \\",
          "16:  (transparent_hugepage_flags &   \\",
          "17:   (1<<TRANSPARENT_HUGEPAGE_FLAG))",
          "18: #define khugepaged_req_madv()     \\",
          "19:  (transparent_hugepage_flags &    \\",
          "20:   (1<<TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG))",
          "21: #define khugepaged_defrag()     \\",
          "22:  (transparent_hugepage_flags &    \\",
          "23:   (1<<TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG))",
          "25: static inline int khugepaged_fork(struct mm_struct *mm, struct mm_struct *oldmm)",
          "26: {",
          "27:  if (test_bit(MMF_VM_HUGEPAGE, &oldmm->flags))",
          "28:   return __khugepaged_enter(mm);",
          "29:  return 0;",
          "30: }",
          "32: static inline void khugepaged_exit(struct mm_struct *mm)",
          "33: {",
          "34:  if (test_bit(MMF_VM_HUGEPAGE, &mm->flags))",
          "35:   __khugepaged_exit(mm);",
          "36: }",
          "38: static inline int khugepaged_enter(struct vm_area_struct *vma)",
          "39: {",
          "40:  if (!test_bit(MMF_VM_HUGEPAGE, &vma->vm_mm->flags))",
          "41:   if (khugepaged_always() ||",
          "42:       (khugepaged_req_madv() &&",
          "43:        vma->vm_flags & VM_HUGEPAGE))",
          "44:    if (__khugepaged_enter(vma->vm_mm))",
          "45:     return -ENOMEM;",
          "46:  return 0;",
          "47: }",
          "49: static inline int khugepaged_fork(struct mm_struct *mm, struct mm_struct *oldmm)",
          "50: {",
          "51:  return 0;",
          "52: }",
          "53: static inline void khugepaged_exit(struct mm_struct *mm)",
          "54: {",
          "55: }",
          "56: static inline int khugepaged_enter(struct vm_area_struct *vma)",
          "57: {",
          "58:  return 0;",
          "59: }",
          "60: static inline int khugepaged_enter_vma_merge(struct vm_area_struct *vma)",
          "61: {",
          "62:  return 0;",
          "63: }",
          "",
          "---------------"
        ],
        "include/linux/sched.h||include/linux/sched.h": [
          "File: include/linux/sched.h -> include/linux/sched.h"
        ],
        "kernel/fork.c||kernel/fork.c": [
          "File: kernel/fork.c -> kernel/fork.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: #include <linux/posix-timers.h>",
          "67: #include <linux/user-return-notifier.h>",
          "68: #include <linux/oom.h>",
          "70: #include <asm/pgtable.h>",
          "71: #include <asm/pgalloc.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "69: #include <linux/khugepaged.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "328:  rb_parent = NULL;",
          "329:  pprev = &mm->mmap;",
          "330:  retval = ksm_fork(mm, oldmm);",
          "331:  if (retval)",
          "332:   goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "332:  if (retval)",
          "333:   goto out;",
          "334:  retval = khugepaged_fork(mm, oldmm);",
          "",
          "---------------"
        ],
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include <linux/mmu_notifier.h>",
          "13: #include <linux/rmap.h>",
          "14: #include <linux/swap.h>",
          "15: #include <asm/tlb.h>",
          "16: #include <asm/pgalloc.h>",
          "17: #include \"internal.h\"",
          "19: unsigned long transparent_hugepage_flags __read_mostly =",
          "22: #ifdef CONFIG_SYSFS",
          "23: static ssize_t double_flag_show(struct kobject *kobj,",
          "24:     struct kobj_attribute *attr, char *buf,",
          "25:     enum transparent_hugepage_flag enabled,",
          "",
          "[Removed Lines]",
          "20:  (1<<TRANSPARENT_HUGEPAGE_FLAG);",
          "",
          "[Added Lines]",
          "15: #include <linux/mm_inline.h>",
          "16: #include <linux/kthread.h>",
          "17: #include <linux/khugepaged.h>",
          "30:  (1<<TRANSPARENT_HUGEPAGE_FLAG)|",
          "31:  (1<<TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG);",
          "34: static unsigned int khugepaged_pages_to_scan __read_mostly = HPAGE_PMD_NR*8;",
          "35: static unsigned int khugepaged_pages_collapsed;",
          "36: static unsigned int khugepaged_full_scans;",
          "37: static unsigned int khugepaged_scan_sleep_millisecs __read_mostly = 10000;",
          "39: static unsigned int khugepaged_alloc_sleep_millisecs __read_mostly = 60000;",
          "40: static struct task_struct *khugepaged_thread __read_mostly;",
          "41: static DEFINE_MUTEX(khugepaged_mutex);",
          "42: static DEFINE_SPINLOCK(khugepaged_mm_lock);",
          "43: static DECLARE_WAIT_QUEUE_HEAD(khugepaged_wait);",
          "49: static unsigned int khugepaged_max_ptes_none __read_mostly = HPAGE_PMD_NR-1;",
          "51: static int khugepaged(void *none);",
          "52: static int mm_slots_hash_init(void);",
          "53: static int khugepaged_slab_init(void);",
          "54: static void khugepaged_slab_free(void);",
          "56: #define MM_SLOTS_HASH_HEADS 1024",
          "57: static struct hlist_head *mm_slots_hash __read_mostly;",
          "58: static struct kmem_cache *mm_slot_cache __read_mostly;",
          "66: struct mm_slot {",
          "67:  struct hlist_node hash;",
          "68:  struct list_head mm_node;",
          "69:  struct mm_struct *mm;",
          "70: };",
          "80: struct khugepaged_scan {",
          "81:  struct list_head mm_head;",
          "82:  struct mm_slot *mm_slot;",
          "83:  unsigned long address;",
          "84: } khugepaged_scan = {",
          "85:  .mm_head = LIST_HEAD_INIT(khugepaged_scan.mm_head),",
          "86: };",
          "88: static int start_khugepaged(void)",
          "89: {",
          "90:  int err = 0;",
          "91:  if (khugepaged_enabled()) {",
          "92:   int wakeup;",
          "93:   if (unlikely(!mm_slot_cache || !mm_slots_hash)) {",
          "94:    err = -ENOMEM;",
          "95:    goto out;",
          "96:   }",
          "97:   mutex_lock(&khugepaged_mutex);",
          "98:   if (!khugepaged_thread)",
          "99:    khugepaged_thread = kthread_run(khugepaged, NULL,",
          "100:        \"khugepaged\");",
          "101:   if (unlikely(IS_ERR(khugepaged_thread))) {",
          "102:    printk(KERN_ERR",
          "103:           \"khugepaged: kthread_run(khugepaged) failed\\n\");",
          "104:    err = PTR_ERR(khugepaged_thread);",
          "105:    khugepaged_thread = NULL;",
          "106:   }",
          "107:   wakeup = !list_empty(&khugepaged_scan.mm_head);",
          "108:   mutex_unlock(&khugepaged_mutex);",
          "109:   if (wakeup)",
          "110:    wake_up_interruptible(&khugepaged_wait);",
          "111:  } else",
          "113:   wake_up_interruptible(&khugepaged_wait);",
          "114: out:",
          "115:  return err;",
          "116: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:         struct kobj_attribute *attr,",
          "69:         const char *buf, size_t count)",
          "70: {",
          "74: }",
          "75: static struct kobj_attribute enabled_attr =",
          "76:  __ATTR(enabled, 0644, enabled_show, enabled_store);",
          "",
          "[Removed Lines]",
          "71:  return double_flag_store(kobj, attr, buf, count,",
          "72:      TRANSPARENT_HUGEPAGE_FLAG,",
          "73:      TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG);",
          "",
          "[Added Lines]",
          "168:  ssize_t ret;",
          "170:  ret = double_flag_store(kobj, attr, buf, count,",
          "171:     TRANSPARENT_HUGEPAGE_FLAG,",
          "172:     TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG);",
          "174:  if (ret > 0) {",
          "175:   int err = start_khugepaged();",
          "176:   if (err)",
          "177:    ret = err;",
          "178:  }",
          "180:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "154: static struct attribute_group hugepage_attr_group = {",
          "155:  .attrs = hugepage_attr,",
          "157: };",
          "160: static int __init hugepage_init(void)",
          "161: {",
          "163:  int err;",
          "168: #endif",
          "170: }",
          "171: module_init(hugepage_init)",
          "",
          "[Removed Lines]",
          "156:  .name = \"transparent_hugepage\",",
          "162: #ifdef CONFIG_SYSFS",
          "165:  err = sysfs_create_group(mm_kobj, &hugepage_attr_group);",
          "166:  if (err)",
          "167:   printk(KERN_ERR \"hugepage: register sysfs failed\\n\");",
          "169:  return 0;",
          "",
          "[Added Lines]",
          "263: };",
          "265: static ssize_t scan_sleep_millisecs_show(struct kobject *kobj,",
          "266:       struct kobj_attribute *attr,",
          "267:       char *buf)",
          "268: {",
          "269:  return sprintf(buf, \"%u\\n\", khugepaged_scan_sleep_millisecs);",
          "270: }",
          "272: static ssize_t scan_sleep_millisecs_store(struct kobject *kobj,",
          "273:        struct kobj_attribute *attr,",
          "274:        const char *buf, size_t count)",
          "275: {",
          "276:  unsigned long msecs;",
          "277:  int err;",
          "279:  err = strict_strtoul(buf, 10, &msecs);",
          "280:  if (err || msecs > UINT_MAX)",
          "281:   return -EINVAL;",
          "283:  khugepaged_scan_sleep_millisecs = msecs;",
          "284:  wake_up_interruptible(&khugepaged_wait);",
          "286:  return count;",
          "287: }",
          "288: static struct kobj_attribute scan_sleep_millisecs_attr =",
          "289:  __ATTR(scan_sleep_millisecs, 0644, scan_sleep_millisecs_show,",
          "290:         scan_sleep_millisecs_store);",
          "292: static ssize_t alloc_sleep_millisecs_show(struct kobject *kobj,",
          "293:        struct kobj_attribute *attr,",
          "294:        char *buf)",
          "295: {",
          "296:  return sprintf(buf, \"%u\\n\", khugepaged_alloc_sleep_millisecs);",
          "297: }",
          "299: static ssize_t alloc_sleep_millisecs_store(struct kobject *kobj,",
          "300:         struct kobj_attribute *attr,",
          "301:         const char *buf, size_t count)",
          "302: {",
          "303:  unsigned long msecs;",
          "304:  int err;",
          "306:  err = strict_strtoul(buf, 10, &msecs);",
          "307:  if (err || msecs > UINT_MAX)",
          "308:   return -EINVAL;",
          "310:  khugepaged_alloc_sleep_millisecs = msecs;",
          "311:  wake_up_interruptible(&khugepaged_wait);",
          "313:  return count;",
          "314: }",
          "315: static struct kobj_attribute alloc_sleep_millisecs_attr =",
          "316:  __ATTR(alloc_sleep_millisecs, 0644, alloc_sleep_millisecs_show,",
          "317:         alloc_sleep_millisecs_store);",
          "319: static ssize_t pages_to_scan_show(struct kobject *kobj,",
          "320:       struct kobj_attribute *attr,",
          "321:       char *buf)",
          "322: {",
          "323:  return sprintf(buf, \"%u\\n\", khugepaged_pages_to_scan);",
          "324: }",
          "325: static ssize_t pages_to_scan_store(struct kobject *kobj,",
          "326:        struct kobj_attribute *attr,",
          "327:        const char *buf, size_t count)",
          "328: {",
          "329:  int err;",
          "330:  unsigned long pages;",
          "332:  err = strict_strtoul(buf, 10, &pages);",
          "333:  if (err || !pages || pages > UINT_MAX)",
          "334:   return -EINVAL;",
          "336:  khugepaged_pages_to_scan = pages;",
          "338:  return count;",
          "339: }",
          "340: static struct kobj_attribute pages_to_scan_attr =",
          "341:  __ATTR(pages_to_scan, 0644, pages_to_scan_show,",
          "342:         pages_to_scan_store);",
          "344: static ssize_t pages_collapsed_show(struct kobject *kobj,",
          "345:         struct kobj_attribute *attr,",
          "346:         char *buf)",
          "347: {",
          "348:  return sprintf(buf, \"%u\\n\", khugepaged_pages_collapsed);",
          "349: }",
          "350: static struct kobj_attribute pages_collapsed_attr =",
          "351:  __ATTR_RO(pages_collapsed);",
          "353: static ssize_t full_scans_show(struct kobject *kobj,",
          "354:           struct kobj_attribute *attr,",
          "355:           char *buf)",
          "356: {",
          "357:  return sprintf(buf, \"%u\\n\", khugepaged_full_scans);",
          "358: }",
          "359: static struct kobj_attribute full_scans_attr =",
          "360:  __ATTR_RO(full_scans);",
          "362: static ssize_t khugepaged_defrag_show(struct kobject *kobj,",
          "363:           struct kobj_attribute *attr, char *buf)",
          "364: {",
          "365:  return single_flag_show(kobj, attr, buf,",
          "366:     TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG);",
          "367: }",
          "368: static ssize_t khugepaged_defrag_store(struct kobject *kobj,",
          "369:            struct kobj_attribute *attr,",
          "370:            const char *buf, size_t count)",
          "371: {",
          "372:  return single_flag_store(kobj, attr, buf, count,",
          "373:      TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG);",
          "374: }",
          "375: static struct kobj_attribute khugepaged_defrag_attr =",
          "376:  __ATTR(defrag, 0644, khugepaged_defrag_show,",
          "377:         khugepaged_defrag_store);",
          "387: static ssize_t khugepaged_max_ptes_none_show(struct kobject *kobj,",
          "388:           struct kobj_attribute *attr,",
          "389:           char *buf)",
          "390: {",
          "391:  return sprintf(buf, \"%u\\n\", khugepaged_max_ptes_none);",
          "392: }",
          "393: static ssize_t khugepaged_max_ptes_none_store(struct kobject *kobj,",
          "394:            struct kobj_attribute *attr,",
          "395:            const char *buf, size_t count)",
          "396: {",
          "397:  int err;",
          "398:  unsigned long max_ptes_none;",
          "400:  err = strict_strtoul(buf, 10, &max_ptes_none);",
          "401:  if (err || max_ptes_none > HPAGE_PMD_NR-1)",
          "402:   return -EINVAL;",
          "404:  khugepaged_max_ptes_none = max_ptes_none;",
          "406:  return count;",
          "407: }",
          "408: static struct kobj_attribute khugepaged_max_ptes_none_attr =",
          "409:  __ATTR(max_ptes_none, 0644, khugepaged_max_ptes_none_show,",
          "410:         khugepaged_max_ptes_none_store);",
          "412: static struct attribute *khugepaged_attr[] = {",
          "413:  &khugepaged_defrag_attr.attr,",
          "414:  &khugepaged_max_ptes_none_attr.attr,",
          "415:  &pages_to_scan_attr.attr,",
          "416:  &pages_collapsed_attr.attr,",
          "417:  &full_scans_attr.attr,",
          "418:  &scan_sleep_millisecs_attr.attr,",
          "419:  &alloc_sleep_millisecs_attr.attr,",
          "420:  NULL,",
          "421: };",
          "423: static struct attribute_group khugepaged_attr_group = {",
          "424:  .attrs = khugepaged_attr,",
          "425:  .name = \"khugepaged\",",
          "432: #ifdef CONFIG_SYSFS",
          "433:  static struct kobject *hugepage_kobj;",
          "435:  err = -ENOMEM;",
          "436:  hugepage_kobj = kobject_create_and_add(\"transparent_hugepage\", mm_kobj);",
          "437:  if (unlikely(!hugepage_kobj)) {",
          "438:   printk(KERN_ERR \"hugepage: failed kobject create\\n\");",
          "439:   goto out;",
          "440:  }",
          "442:  err = sysfs_create_group(hugepage_kobj, &hugepage_attr_group);",
          "443:  if (err) {",
          "444:   printk(KERN_ERR \"hugepage: failed register hugeage group\\n\");",
          "445:   goto out;",
          "446:  }",
          "448:  err = sysfs_create_group(hugepage_kobj, &khugepaged_attr_group);",
          "449:  if (err) {",
          "450:   printk(KERN_ERR \"hugepage: failed register hugeage group\\n\");",
          "451:   goto out;",
          "452:  }",
          "455:  err = khugepaged_slab_init();",
          "456:  if (err)",
          "457:   goto out;",
          "459:  err = mm_slots_hash_init();",
          "460:  if (err) {",
          "461:   khugepaged_slab_free();",
          "462:   goto out;",
          "463:  }",
          "465:  start_khugepaged();",
          "467: out:",
          "468:  return err;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "285:  if (haddr >= vma->vm_start && haddr + HPAGE_PMD_SIZE <= vma->vm_end) {",
          "286:   if (unlikely(anon_vma_prepare(vma)))",
          "287:    return VM_FAULT_OOM;",
          "288:   page = alloc_hugepage(transparent_hugepage_defrag(vma));",
          "289:   if (unlikely(!page))",
          "290:    goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "587:   if (unlikely(khugepaged_enter(vma)))",
          "588:    return VM_FAULT_OOM;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "941:  return 0;",
          "942: }",
          "944: void __split_huge_page_pmd(struct mm_struct *mm, pmd_t *pmd)",
          "945: {",
          "946:  struct page *page;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1245: static int __init khugepaged_slab_init(void)",
          "1246: {",
          "1247:  mm_slot_cache = kmem_cache_create(\"khugepaged_mm_slot\",",
          "1248:        sizeof(struct mm_slot),",
          "1249:        __alignof__(struct mm_slot), 0, NULL);",
          "1250:  if (!mm_slot_cache)",
          "1251:   return -ENOMEM;",
          "1253:  return 0;",
          "1254: }",
          "1256: static void __init khugepaged_slab_free(void)",
          "1257: {",
          "1258:  kmem_cache_destroy(mm_slot_cache);",
          "1259:  mm_slot_cache = NULL;",
          "1260: }",
          "1262: static inline struct mm_slot *alloc_mm_slot(void)",
          "1263: {",
          "1265:   return NULL;",
          "1266:  return kmem_cache_zalloc(mm_slot_cache, GFP_KERNEL);",
          "1267: }",
          "1269: static inline void free_mm_slot(struct mm_slot *mm_slot)",
          "1270: {",
          "1271:  kmem_cache_free(mm_slot_cache, mm_slot);",
          "1272: }",
          "1274: static int __init mm_slots_hash_init(void)",
          "1275: {",
          "1276:  mm_slots_hash = kzalloc(MM_SLOTS_HASH_HEADS * sizeof(struct hlist_head),",
          "1277:     GFP_KERNEL);",
          "1278:  if (!mm_slots_hash)",
          "1279:   return -ENOMEM;",
          "1280:  return 0;",
          "1281: }",
          "1283: #if 0",
          "1284: static void __init mm_slots_hash_free(void)",
          "1285: {",
          "1286:  kfree(mm_slots_hash);",
          "1287:  mm_slots_hash = NULL;",
          "1288: }",
          "1289: #endif",
          "1291: static struct mm_slot *get_mm_slot(struct mm_struct *mm)",
          "1292: {",
          "1293:  struct mm_slot *mm_slot;",
          "1294:  struct hlist_head *bucket;",
          "1295:  struct hlist_node *node;",
          "1297:  bucket = &mm_slots_hash[((unsigned long)mm / sizeof(struct mm_struct))",
          "1298:     % MM_SLOTS_HASH_HEADS];",
          "1299:  hlist_for_each_entry(mm_slot, node, bucket, hash) {",
          "1300:   if (mm == mm_slot->mm)",
          "1301:    return mm_slot;",
          "1302:  }",
          "1303:  return NULL;",
          "1304: }",
          "1306: static void insert_to_mm_slots_hash(struct mm_struct *mm,",
          "1307:         struct mm_slot *mm_slot)",
          "1308: {",
          "1309:  struct hlist_head *bucket;",
          "1311:  bucket = &mm_slots_hash[((unsigned long)mm / sizeof(struct mm_struct))",
          "1312:     % MM_SLOTS_HASH_HEADS];",
          "1313:  mm_slot->mm = mm;",
          "1314:  hlist_add_head(&mm_slot->hash, bucket);",
          "1315: }",
          "1317: static inline int khugepaged_test_exit(struct mm_struct *mm)",
          "1318: {",
          "1319:  return atomic_read(&mm->mm_users) == 0;",
          "1320: }",
          "1322: int __khugepaged_enter(struct mm_struct *mm)",
          "1323: {",
          "1324:  struct mm_slot *mm_slot;",
          "1325:  int wakeup;",
          "1327:  mm_slot = alloc_mm_slot();",
          "1328:  if (!mm_slot)",
          "1329:   return -ENOMEM;",
          "1332:  VM_BUG_ON(khugepaged_test_exit(mm));",
          "1333:  if (unlikely(test_and_set_bit(MMF_VM_HUGEPAGE, &mm->flags))) {",
          "1334:   free_mm_slot(mm_slot);",
          "1335:   return 0;",
          "1336:  }",
          "1338:  spin_lock(&khugepaged_mm_lock);",
          "1339:  insert_to_mm_slots_hash(mm, mm_slot);",
          "1344:  wakeup = list_empty(&khugepaged_scan.mm_head);",
          "1345:  list_add_tail(&mm_slot->mm_node, &khugepaged_scan.mm_head);",
          "1346:  spin_unlock(&khugepaged_mm_lock);",
          "1348:  atomic_inc(&mm->mm_count);",
          "1349:  if (wakeup)",
          "1350:   wake_up_interruptible(&khugepaged_wait);",
          "1352:  return 0;",
          "1353: }",
          "1355: int khugepaged_enter_vma_merge(struct vm_area_struct *vma)",
          "1356: {",
          "1357:  unsigned long hstart, hend;",
          "1358:  if (!vma->anon_vma)",
          "1363:   return 0;",
          "1364:  if (vma->vm_file || vma->vm_ops)",
          "1366:   return 0;",
          "1367:  VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
          "1368:  hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;",
          "1369:  hend = vma->vm_end & HPAGE_PMD_MASK;",
          "1370:  if (hstart < hend)",
          "1371:   return khugepaged_enter(vma);",
          "1372:  return 0;",
          "1373: }",
          "1375: void __khugepaged_exit(struct mm_struct *mm)",
          "1376: {",
          "1377:  struct mm_slot *mm_slot;",
          "1378:  int free = 0;",
          "1380:  spin_lock(&khugepaged_mm_lock);",
          "1381:  mm_slot = get_mm_slot(mm);",
          "1382:  if (mm_slot && khugepaged_scan.mm_slot != mm_slot) {",
          "1383:   hlist_del(&mm_slot->hash);",
          "1384:   list_del(&mm_slot->mm_node);",
          "1385:   free = 1;",
          "1386:  }",
          "1388:  if (free) {",
          "1389:   spin_unlock(&khugepaged_mm_lock);",
          "1390:   clear_bit(MMF_VM_HUGEPAGE, &mm->flags);",
          "1391:   free_mm_slot(mm_slot);",
          "1392:   mmdrop(mm);",
          "1393:  } else if (mm_slot) {",
          "1394:   spin_unlock(&khugepaged_mm_lock);",
          "1403:   down_write(&mm->mmap_sem);",
          "1404:   up_write(&mm->mmap_sem);",
          "1405:  } else",
          "1406:   spin_unlock(&khugepaged_mm_lock);",
          "1407: }",
          "1409: static void release_pte_page(struct page *page)",
          "1410: {",
          "1412:  dec_zone_page_state(page, NR_ISOLATED_ANON + 0);",
          "1413:  unlock_page(page);",
          "1414:  putback_lru_page(page);",
          "1415: }",
          "1417: static void release_pte_pages(pte_t *pte, pte_t *_pte)",
          "1418: {",
          "1419:  while (--_pte >= pte) {",
          "1420:   pte_t pteval = *_pte;",
          "1421:   if (!pte_none(pteval))",
          "1422:    release_pte_page(pte_page(pteval));",
          "1423:  }",
          "1424: }",
          "1426: static void release_all_pte_pages(pte_t *pte)",
          "1427: {",
          "1428:  release_pte_pages(pte, pte + HPAGE_PMD_NR);",
          "1429: }",
          "1431: static int __collapse_huge_page_isolate(struct vm_area_struct *vma,",
          "1432:      unsigned long address,",
          "1433:      pte_t *pte)",
          "1434: {",
          "1435:  struct page *page;",
          "1436:  pte_t *_pte;",
          "1437:  int referenced = 0, isolated = 0, none = 0;",
          "1438:  for (_pte = pte; _pte < pte+HPAGE_PMD_NR;",
          "1439:       _pte++, address += PAGE_SIZE) {",
          "1440:   pte_t pteval = *_pte;",
          "1441:   if (pte_none(pteval)) {",
          "1442:    if (++none <= khugepaged_max_ptes_none)",
          "1443:     continue;",
          "1444:    else {",
          "1445:     release_pte_pages(pte, _pte);",
          "1446:     goto out;",
          "1447:    }",
          "1448:   }",
          "1449:   if (!pte_present(pteval) || !pte_write(pteval)) {",
          "1450:    release_pte_pages(pte, _pte);",
          "1451:    goto out;",
          "1452:   }",
          "1453:   page = vm_normal_page(vma, address, pteval);",
          "1454:   if (unlikely(!page)) {",
          "1455:    release_pte_pages(pte, _pte);",
          "1456:    goto out;",
          "1457:   }",
          "1458:   VM_BUG_ON(PageCompound(page));",
          "1459:   BUG_ON(!PageAnon(page));",
          "1460:   VM_BUG_ON(!PageSwapBacked(page));",
          "1463:   if (page_count(page) != 1) {",
          "1464:    release_pte_pages(pte, _pte);",
          "1465:    goto out;",
          "1466:   }",
          "1473:   if (!trylock_page(page)) {",
          "1474:    release_pte_pages(pte, _pte);",
          "1475:    goto out;",
          "1476:   }",
          "1481:   if (isolate_lru_page(page)) {",
          "1482:    unlock_page(page);",
          "1483:    release_pte_pages(pte, _pte);",
          "1484:    goto out;",
          "1485:   }",
          "1487:   inc_zone_page_state(page, NR_ISOLATED_ANON + 0);",
          "1488:   VM_BUG_ON(!PageLocked(page));",
          "1489:   VM_BUG_ON(PageLRU(page));",
          "1492:   if (pte_young(pteval))",
          "1493:    referenced = 1;",
          "1494:  }",
          "1495:  if (unlikely(!referenced))",
          "1496:   release_all_pte_pages(pte);",
          "1497:  else",
          "1498:   isolated = 1;",
          "1499: out:",
          "1500:  return isolated;",
          "1501: }",
          "1503: static void __collapse_huge_page_copy(pte_t *pte, struct page *page,",
          "1504:           struct vm_area_struct *vma,",
          "1505:           unsigned long address,",
          "1506:           spinlock_t *ptl)",
          "1507: {",
          "1508:  pte_t *_pte;",
          "1509:  for (_pte = pte; _pte < pte+HPAGE_PMD_NR; _pte++) {",
          "1510:   pte_t pteval = *_pte;",
          "1511:   struct page *src_page;",
          "1513:   if (pte_none(pteval)) {",
          "1514:    clear_user_highpage(page, address);",
          "1515:    add_mm_counter(vma->vm_mm, MM_ANONPAGES, 1);",
          "1516:   } else {",
          "1517:    src_page = pte_page(pteval);",
          "1518:    copy_user_highpage(page, src_page, address, vma);",
          "1519:    VM_BUG_ON(page_mapcount(src_page) != 1);",
          "1520:    VM_BUG_ON(page_count(src_page) != 2);",
          "1521:    release_pte_page(src_page);",
          "1527:    spin_lock(ptl);",
          "1532:    pte_clear(vma->vm_mm, address, _pte);",
          "1533:    page_remove_rmap(src_page);",
          "1534:    spin_unlock(ptl);",
          "1535:    free_page_and_swap_cache(src_page);",
          "1536:   }",
          "1538:   address += PAGE_SIZE;",
          "1539:   page++;",
          "1540:  }",
          "1541: }",
          "1543: static void collapse_huge_page(struct mm_struct *mm,",
          "1544:           unsigned long address,",
          "1545:           struct page **hpage)",
          "1546: {",
          "1547:  struct vm_area_struct *vma;",
          "1548:  pgd_t *pgd;",
          "1549:  pud_t *pud;",
          "1550:  pmd_t *pmd, _pmd;",
          "1551:  pte_t *pte;",
          "1552:  pgtable_t pgtable;",
          "1553:  struct page *new_page;",
          "1554:  spinlock_t *ptl;",
          "1555:  int isolated;",
          "1556:  unsigned long hstart, hend;",
          "1558:  VM_BUG_ON(address & ~HPAGE_PMD_MASK);",
          "1559:  VM_BUG_ON(!*hpage);",
          "1566:  down_write(&mm->mmap_sem);",
          "1567:  if (unlikely(khugepaged_test_exit(mm)))",
          "1568:   goto out;",
          "1570:  vma = find_vma(mm, address);",
          "1571:  hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;",
          "1572:  hend = vma->vm_end & HPAGE_PMD_MASK;",
          "1573:  if (address < hstart || address + HPAGE_PMD_SIZE > hend)",
          "1574:   goto out;",
          "1576:  if (!(vma->vm_flags & VM_HUGEPAGE) && !khugepaged_always())",
          "1577:   goto out;",
          "1580:  if (!vma->anon_vma || vma->vm_ops || vma->vm_file)",
          "1581:   goto out;",
          "1582:  VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
          "1584:  pgd = pgd_offset(mm, address);",
          "1585:  if (!pgd_present(*pgd))",
          "1586:   goto out;",
          "1588:  pud = pud_offset(pgd, address);",
          "1589:  if (!pud_present(*pud))",
          "1590:   goto out;",
          "1592:  pmd = pmd_offset(pud, address);",
          "1594:  if (!pmd_present(*pmd) || pmd_trans_huge(*pmd))",
          "1595:   goto out;",
          "1597:  new_page = *hpage;",
          "1598:  if (unlikely(mem_cgroup_newpage_charge(new_page, mm, GFP_KERNEL)))",
          "1599:   goto out;",
          "1601:  anon_vma_lock(vma->anon_vma);",
          "1603:  pte = pte_offset_map(pmd, address);",
          "1604:  ptl = pte_lockptr(mm, pmd);",
          "1613:  _pmd = pmdp_clear_flush_notify(vma, address, pmd);",
          "1614:  spin_unlock(&mm->page_table_lock);",
          "1616:  spin_lock(ptl);",
          "1617:  isolated = __collapse_huge_page_isolate(vma, address, pte);",
          "1618:  spin_unlock(ptl);",
          "1619:  pte_unmap(pte);",
          "1621:  if (unlikely(!isolated)) {",
          "1622:   spin_lock(&mm->page_table_lock);",
          "1623:   BUG_ON(!pmd_none(*pmd));",
          "1624:   set_pmd_at(mm, address, pmd, _pmd);",
          "1625:   spin_unlock(&mm->page_table_lock);",
          "1626:   anon_vma_unlock(vma->anon_vma);",
          "1627:   mem_cgroup_uncharge_page(new_page);",
          "1628:   goto out;",
          "1629:  }",
          "1635:  anon_vma_unlock(vma->anon_vma);",
          "1637:  __collapse_huge_page_copy(pte, new_page, vma, address, ptl);",
          "1638:  __SetPageUptodate(new_page);",
          "1639:  pgtable = pmd_pgtable(_pmd);",
          "1640:  VM_BUG_ON(page_count(pgtable) != 1);",
          "1641:  VM_BUG_ON(page_mapcount(pgtable) != 0);",
          "1643:  _pmd = mk_pmd(new_page, vma->vm_page_prot);",
          "1644:  _pmd = maybe_pmd_mkwrite(pmd_mkdirty(_pmd), vma);",
          "1645:  _pmd = pmd_mkhuge(_pmd);",
          "1652:  smp_wmb();",
          "1654:  spin_lock(&mm->page_table_lock);",
          "1655:  BUG_ON(!pmd_none(*pmd));",
          "1656:  page_add_new_anon_rmap(new_page, vma, address);",
          "1657:  set_pmd_at(mm, address, pmd, _pmd);",
          "1658:  update_mmu_cache(vma, address, entry);",
          "1659:  prepare_pmd_huge_pte(pgtable, mm);",
          "1660:  mm->nr_ptes--;",
          "1661:  spin_unlock(&mm->page_table_lock);",
          "1664:  khugepaged_pages_collapsed++;",
          "1665: out:",
          "1666:  up_write(&mm->mmap_sem);",
          "1667: }",
          "1669: static int khugepaged_scan_pmd(struct mm_struct *mm,",
          "1670:           struct vm_area_struct *vma,",
          "1671:           unsigned long address,",
          "1672:           struct page **hpage)",
          "1673: {",
          "1674:  pgd_t *pgd;",
          "1675:  pud_t *pud;",
          "1676:  pmd_t *pmd;",
          "1677:  pte_t *pte, *_pte;",
          "1678:  int ret = 0, referenced = 0, none = 0;",
          "1679:  struct page *page;",
          "1680:  unsigned long _address;",
          "1681:  spinlock_t *ptl;",
          "1683:  VM_BUG_ON(address & ~HPAGE_PMD_MASK);",
          "1685:  pgd = pgd_offset(mm, address);",
          "1686:  if (!pgd_present(*pgd))",
          "1687:   goto out;",
          "1689:  pud = pud_offset(pgd, address);",
          "1690:  if (!pud_present(*pud))",
          "1691:   goto out;",
          "1693:  pmd = pmd_offset(pud, address);",
          "1694:  if (!pmd_present(*pmd) || pmd_trans_huge(*pmd))",
          "1695:   goto out;",
          "1697:  pte = pte_offset_map_lock(mm, pmd, address, &ptl);",
          "1698:  for (_address = address, _pte = pte; _pte < pte+HPAGE_PMD_NR;",
          "1699:       _pte++, _address += PAGE_SIZE) {",
          "1700:   pte_t pteval = *_pte;",
          "1701:   if (pte_none(pteval)) {",
          "1702:    if (++none <= khugepaged_max_ptes_none)",
          "1703:     continue;",
          "1704:    else",
          "1705:     goto out_unmap;",
          "1706:   }",
          "1707:   if (!pte_present(pteval) || !pte_write(pteval))",
          "1708:    goto out_unmap;",
          "1709:   page = vm_normal_page(vma, _address, pteval);",
          "1710:   if (unlikely(!page))",
          "1711:    goto out_unmap;",
          "1712:   VM_BUG_ON(PageCompound(page));",
          "1713:   if (!PageLRU(page) || PageLocked(page) || !PageAnon(page))",
          "1714:    goto out_unmap;",
          "1716:   if (page_count(page) != 1)",
          "1717:    goto out_unmap;",
          "1718:   if (pte_young(pteval))",
          "1719:    referenced = 1;",
          "1720:  }",
          "1721:  if (referenced)",
          "1722:   ret = 1;",
          "1723: out_unmap:",
          "1724:  pte_unmap_unlock(pte, ptl);",
          "1725:  if (ret) {",
          "1726:   up_read(&mm->mmap_sem);",
          "1727:   collapse_huge_page(mm, address, hpage);",
          "1728:  }",
          "1729: out:",
          "1730:  return ret;",
          "1731: }",
          "1733: static void collect_mm_slot(struct mm_slot *mm_slot)",
          "1734: {",
          "1735:  struct mm_struct *mm = mm_slot->mm;",
          "1737:  VM_BUG_ON(!spin_is_locked(&khugepaged_mm_lock));",
          "1739:  if (khugepaged_test_exit(mm)) {",
          "1741:   hlist_del(&mm_slot->hash);",
          "1742:   list_del(&mm_slot->mm_node);",
          "1751:   free_mm_slot(mm_slot);",
          "1752:   mmdrop(mm);",
          "1753:  }",
          "1754: }",
          "1756: static unsigned int khugepaged_scan_mm_slot(unsigned int pages,",
          "1757:          struct page **hpage)",
          "1758: {",
          "1759:  struct mm_slot *mm_slot;",
          "1760:  struct mm_struct *mm;",
          "1761:  struct vm_area_struct *vma;",
          "1762:  int progress = 0;",
          "1764:  VM_BUG_ON(!pages);",
          "1765:  VM_BUG_ON(!spin_is_locked(&khugepaged_mm_lock));",
          "1767:  if (khugepaged_scan.mm_slot)",
          "1768:   mm_slot = khugepaged_scan.mm_slot;",
          "1769:  else {",
          "1770:   mm_slot = list_entry(khugepaged_scan.mm_head.next,",
          "1771:          struct mm_slot, mm_node);",
          "1772:   khugepaged_scan.address = 0;",
          "1773:   khugepaged_scan.mm_slot = mm_slot;",
          "1774:  }",
          "1775:  spin_unlock(&khugepaged_mm_lock);",
          "1777:  mm = mm_slot->mm;",
          "1778:  down_read(&mm->mmap_sem);",
          "1779:  if (unlikely(khugepaged_test_exit(mm)))",
          "1780:   vma = NULL;",
          "1781:  else",
          "1782:   vma = find_vma(mm, khugepaged_scan.address);",
          "1784:  progress++;",
          "1785:  for (; vma; vma = vma->vm_next) {",
          "1786:   unsigned long hstart, hend;",
          "1788:   cond_resched();",
          "1789:   if (unlikely(khugepaged_test_exit(mm))) {",
          "1790:    progress++;",
          "1791:    break;",
          "1792:   }",
          "1794:   if (!(vma->vm_flags & VM_HUGEPAGE) &&",
          "1795:       !khugepaged_always()) {",
          "1796:    progress++;",
          "1797:    continue;",
          "1798:   }",
          "1801:   if (!vma->anon_vma || vma->vm_ops || vma->vm_file) {",
          "1802:    khugepaged_scan.address = vma->vm_end;",
          "1803:    progress++;",
          "1804:    continue;",
          "1805:   }",
          "1806:   VM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));",
          "1808:   hstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;",
          "1809:   hend = vma->vm_end & HPAGE_PMD_MASK;",
          "1810:   if (hstart >= hend) {",
          "1811:    progress++;",
          "1812:    continue;",
          "1813:   }",
          "1814:   if (khugepaged_scan.address < hstart)",
          "1815:    khugepaged_scan.address = hstart;",
          "1816:   if (khugepaged_scan.address > hend) {",
          "1817:    khugepaged_scan.address = hend + HPAGE_PMD_SIZE;",
          "1818:    progress++;",
          "1819:    continue;",
          "1820:   }",
          "1821:   BUG_ON(khugepaged_scan.address & ~HPAGE_PMD_MASK);",
          "1823:   while (khugepaged_scan.address < hend) {",
          "1824:    int ret;",
          "1825:    cond_resched();",
          "1826:    if (unlikely(khugepaged_test_exit(mm)))",
          "1827:     goto breakouterloop;",
          "1829:    VM_BUG_ON(khugepaged_scan.address < hstart ||",
          "1830:       khugepaged_scan.address + HPAGE_PMD_SIZE >",
          "1831:       hend);",
          "1832:    ret = khugepaged_scan_pmd(mm, vma,",
          "1833:         khugepaged_scan.address,",
          "1834:         hpage);",
          "1836:    khugepaged_scan.address += HPAGE_PMD_SIZE;",
          "1837:    progress += HPAGE_PMD_NR;",
          "1838:    if (ret)",
          "1840:     goto breakouterloop_mmap_sem;",
          "1841:    if (progress >= pages)",
          "1842:     goto breakouterloop;",
          "1843:   }",
          "1844:  }",
          "1845: breakouterloop:",
          "1847: breakouterloop_mmap_sem:",
          "1849:  spin_lock(&khugepaged_mm_lock);",
          "1850:  BUG_ON(khugepaged_scan.mm_slot != mm_slot);",
          "1855:  if (khugepaged_test_exit(mm) || !vma) {",
          "1861:   if (mm_slot->mm_node.next != &khugepaged_scan.mm_head) {",
          "1862:    khugepaged_scan.mm_slot = list_entry(",
          "1863:     mm_slot->mm_node.next,",
          "1864:     struct mm_slot, mm_node);",
          "1865:    khugepaged_scan.address = 0;",
          "1866:   } else {",
          "1867:    khugepaged_scan.mm_slot = NULL;",
          "1868:    khugepaged_full_scans++;",
          "1869:   }",
          "1871:   collect_mm_slot(mm_slot);",
          "1872:  }",
          "1874:  return progress;",
          "1875: }",
          "1877: static int khugepaged_has_work(void)",
          "1878: {",
          "1879:  return !list_empty(&khugepaged_scan.mm_head) &&",
          "1880:   khugepaged_enabled();",
          "1881: }",
          "1883: static int khugepaged_wait_event(void)",
          "1884: {",
          "1885:  return !list_empty(&khugepaged_scan.mm_head) ||",
          "1886:   !khugepaged_enabled();",
          "1887: }",
          "1889: static void khugepaged_do_scan(struct page **hpage)",
          "1890: {",
          "1891:  unsigned int progress = 0, pass_through_head = 0;",
          "1892:  unsigned int pages = khugepaged_pages_to_scan;",
          "1896:  while (progress < pages) {",
          "1897:   cond_resched();",
          "1899:   if (!*hpage) {",
          "1901:    if (unlikely(!*hpage))",
          "1902:     break;",
          "1903:   }",
          "1905:   spin_lock(&khugepaged_mm_lock);",
          "1906:   if (!khugepaged_scan.mm_slot)",
          "1907:    pass_through_head++;",
          "1908:   if (khugepaged_has_work() &&",
          "1909:       pass_through_head < 2)",
          "1910:    progress += khugepaged_scan_mm_slot(pages - progress,",
          "1911:            hpage);",
          "1912:   else",
          "1913:    progress = pages;",
          "1914:   spin_unlock(&khugepaged_mm_lock);",
          "1915:  }",
          "1916: }",
          "1918: static struct page *khugepaged_alloc_hugepage(void)",
          "1919: {",
          "1920:  struct page *hpage;",
          "1922:  do {",
          "1923:   hpage = alloc_hugepage(khugepaged_defrag());",
          "1924:   if (!hpage) {",
          "1925:    DEFINE_WAIT(wait);",
          "1926:    add_wait_queue(&khugepaged_wait, &wait);",
          "1927:    schedule_timeout_interruptible(",
          "1928:     msecs_to_jiffies(",
          "1929:      khugepaged_alloc_sleep_millisecs));",
          "1930:    remove_wait_queue(&khugepaged_wait, &wait);",
          "1931:   }",
          "1932:  } while (unlikely(!hpage) &&",
          "1933:    likely(khugepaged_enabled()));",
          "1934:  return hpage;",
          "1935: }",
          "1937: static void khugepaged_loop(void)",
          "1938: {",
          "1939:  struct page *hpage;",
          "1941:  while (likely(khugepaged_enabled())) {",
          "1942:   hpage = khugepaged_alloc_hugepage();",
          "1943:   if (unlikely(!hpage))",
          "1944:    break;",
          "1946:   khugepaged_do_scan(&hpage);",
          "1947:   if (hpage)",
          "1948:    put_page(hpage);",
          "1949:   if (khugepaged_has_work()) {",
          "1950:    DEFINE_WAIT(wait);",
          "1951:    if (!khugepaged_scan_sleep_millisecs)",
          "1952:     continue;",
          "1953:    add_wait_queue(&khugepaged_wait, &wait);",
          "1954:    schedule_timeout_interruptible(",
          "1955:     msecs_to_jiffies(",
          "1956:      khugepaged_scan_sleep_millisecs));",
          "1957:    remove_wait_queue(&khugepaged_wait, &wait);",
          "1958:   } else if (khugepaged_enabled())",
          "1959:    wait_event_interruptible(khugepaged_wait,",
          "1960:        khugepaged_wait_event());",
          "1961:  }",
          "1962: }",
          "1964: static int khugepaged(void *none)",
          "1965: {",
          "1966:  struct mm_slot *mm_slot;",
          "1968:  set_user_nice(current, 19);",
          "1971:  mutex_lock(&khugepaged_mutex);",
          "1973:  for (;;) {",
          "1974:   mutex_unlock(&khugepaged_mutex);",
          "1975:   BUG_ON(khugepaged_thread != current);",
          "1976:   khugepaged_loop();",
          "1977:   BUG_ON(khugepaged_thread != current);",
          "1979:   mutex_lock(&khugepaged_mutex);",
          "1980:   if (!khugepaged_enabled())",
          "1981:    break;",
          "1982:  }",
          "1984:  spin_lock(&khugepaged_mm_lock);",
          "1985:  mm_slot = khugepaged_scan.mm_slot;",
          "1986:  khugepaged_scan.mm_slot = NULL;",
          "1987:  if (mm_slot)",
          "1988:   collect_mm_slot(mm_slot);",
          "1989:  spin_unlock(&khugepaged_mm_lock);",
          "1991:  khugepaged_thread = NULL;",
          "1992:  mutex_unlock(&khugepaged_mutex);",
          "1994:  return 0;",
          "1995: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0af4e98b6b095c74588af04872f83d333c958c32",
      "candidate_info": {
        "commit_hash": "0af4e98b6b095c74588af04872f83d333c958c32",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0af4e98b6b095c74588af04872f83d333c958c32",
        "files": [
          "include/linux/huge_mm.h",
          "mm/huge_memory.c",
          "mm/madvise.c"
        ],
        "message": "thp: madvise(MADV_HUGEPAGE)\n\nAdd madvise MADV_HUGEPAGE to mark regions that are important to be\nhugepage backed.  Return -EINVAL if the vma is not of an anonymous type,\nor the feature isn't built into the kernel.  Never silently return\nsuccess.\n\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nAcked-by: Rik van Riel <riel@redhat.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/huge_mm.h||include/linux/huge_mm.h",
          "mm/huge_memory.c||mm/huge_memory.c",
          "mm/madvise.c||mm/madvise.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ],
          "candidate": [
            "include/linux/huge_mm.h||include/linux/huge_mm.h",
            "mm/huge_memory.c||mm/huge_memory.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/huge_mm.h||include/linux/huge_mm.h": [
          "File: include/linux/huge_mm.h -> include/linux/huge_mm.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "97: #if HPAGE_PMD_ORDER > MAX_ORDER",
          "98: #error \"hugepages can't be allocated by the buddy allocator\"",
          "99: #endif",
          "101: #define HPAGE_PMD_SHIFT ({ BUG(); 0; })",
          "102: #define HPAGE_PMD_MASK ({ BUG(); 0; })",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "100: extern int hugepage_madvise(unsigned long *vm_flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113:  do { } while (0)",
          "114: #define wait_split_huge_page(__anon_vma, __pmd) \\",
          "115:  do { } while (0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117: static inline int hugepage_madvise(unsigned long *vm_flags)",
          "118: {",
          "119:  BUG();",
          "120:  return 0;",
          "121: }",
          "",
          "---------------"
        ],
        "mm/huge_memory.c||mm/huge_memory.c": [
          "File: mm/huge_memory.c -> mm/huge_memory.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "896:  return ret;",
          "897: }",
          "899: void __split_huge_page_pmd(struct mm_struct *mm, pmd_t *pmd)",
          "900: {",
          "901:  struct page *page;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "899: int hugepage_madvise(unsigned long *vm_flags)",
          "900: {",
          "904:  if (*vm_flags & (VM_HUGEPAGE | VM_SHARED  | VM_MAYSHARE   |",
          "905:     VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |",
          "906:     VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |",
          "907:     VM_MIXEDMAP | VM_SAO))",
          "908:   return -EINVAL;",
          "912:  return 0;",
          "913: }",
          "",
          "---------------"
        ],
        "mm/madvise.c||mm/madvise.c": [
          "File: mm/madvise.c -> mm/madvise.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:   if (error)",
          "72:    goto out;",
          "73:   break;",
          "74:  }",
          "76:  if (new_flags == vma->vm_flags) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "74:  case MADV_HUGEPAGE:",
          "75:   error = hugepage_madvise(&new_flags);",
          "76:   if (error)",
          "77:    goto out;",
          "78:   break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "282: #ifdef CONFIG_KSM",
          "283:  case MADV_MERGEABLE:",
          "284:  case MADV_UNMERGEABLE:",
          "285: #endif",
          "286:   return 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290: #endif",
          "291: #ifdef CONFIG_TRANSPARENT_HUGEPAGE",
          "292:  case MADV_HUGEPAGE:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
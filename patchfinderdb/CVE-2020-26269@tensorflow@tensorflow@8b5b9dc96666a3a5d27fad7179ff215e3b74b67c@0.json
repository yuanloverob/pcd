{
  "cve_id": "CVE-2020-26269",
  "cve_desc": "In TensorFlow release candidate versions 2.4.0rc*, the general implementation for matching filesystem paths to globbing pattern is vulnerable to an access out of bounds of the array holding the directories. There are multiple invariants and preconditions that are assumed by the parallel implementation of GetMatchingPaths but are not verified by the PRs introducing it (#40861 and #44310). Thus, we are completely rewriting the implementation to fully specify and validate these. This is patched in version 2.4.0. This issue only impacts master branch and the release candidates for TF version 2.4. The final release of the 2.4 release will be patched.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "8b5b9dc96666a3a5d27fad7179ff215e3b74b67c",
  "patch_info": {
    "commit_hash": "8b5b9dc96666a3a5d27fad7179ff215e3b74b67c",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/8b5b9dc96666a3a5d27fad7179ff215e3b74b67c",
    "files": [
      "tensorflow/core/platform/file_system_helper.cc"
    ],
    "message": "Completely rewrite `GetMatchingPaths`.\n\nThe current parallel implementation is too complex (lambda inside lambda, two levels of parallelism) and has a read outside of bounds issue.\n\nThe new implementation cleans up artifacts from the previous implementations that were left in the code as it evolves. We add multiple helper functions, and document invariants and preconditions as well as every major step. This way, we fix the security issue and a potential new one which was not caught before\n\nPiperOrigin-RevId: 346146220\nChange-Id: Iec0f44673f43349797bf9944dffe9b2f779137d8",
    "before_after_code_files": [
      "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
      "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "52: #endif",
      "53: }",
      "55: }  // namespace",
      "57: Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,",
      "58:                         std::vector<string>* results) {",
      "59:   results->clear();",
      "60:   if (pattern.empty()) {",
      "61:     return Status::OK();",
      "62:   }",
      "86:   }",
      "110:       if (s.code() == tensorflow::error::PERMISSION_DENIED) {",
      "111:         return;",
      "112:       }",
      "129:               Status(tensorflow::error::CANCELLED, \"Operation not needed\");",
      "132:         } else {",
      "135:         }",
      "136:       };",
      "137:       ForEach(0, children.size(), handle_children);",
      "143:           continue;",
      "144:         }",
      "155:         }",
      "156:       }",
      "157:     };",
      "162:   }",
      "164: }",
      "166: }  // namespace internal",
      "",
      "[Removed Lines]",
      "64:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
      "65:   string eval_pattern = pattern;",
      "66:   string dir(io::Dirname(fixed_prefix));",
      "69:   if (dir.empty()) {",
      "70:     dir = \".\";",
      "71:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
      "72:     eval_pattern = io::JoinPath(dir, eval_pattern);",
      "73:   }",
      "74:   bool is_directory = pattern[pattern.size() - 1] == '/';",
      "75: #ifdef PLATFORM_WINDOWS",
      "76:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
      "77: #endif",
      "78:   std::vector<string> dirs;",
      "79:   if (!is_directory) {",
      "80:     dirs.emplace_back(eval_pattern);",
      "81:   }",
      "82:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
      "83:   while (tmp_dir.size() > dir.size()) {",
      "84:     dirs.emplace_back(string(tmp_dir));",
      "85:     tmp_dir = io::Dirname(tmp_dir);",
      "87:   dirs.emplace_back(dir);",
      "88:   std::reverse(dirs.begin(), dirs.end());",
      "90:   std::deque<std::pair<string, int>> dir_q;",
      "91:   std::deque<std::pair<string, int>> next_dir_q;",
      "92:   dir_q.emplace_back(std::make_pair(dirs[0], 0));",
      "93:   Status ret;  // Status to return.",
      "94:   mutex results_mutex;",
      "95:   condition_variable results_cond;",
      "96:   mutex next_que_mutex;",
      "97:   condition_variable next_que_cond;",
      "98:   while (!dir_q.empty()) {",
      "99:     next_dir_q.clear();",
      "100:     std::vector<Status> new_rets(dir_q.size());",
      "101:     auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,",
      "102:                          &is_directory, &dirs, &results_mutex, &results_cond,",
      "103:                          &next_que_mutex, &next_que_cond](int i) {",
      "104:       string current_dir = dir_q.at(i).first;",
      "105:       int dir_index = dir_q.at(i).second;",
      "106:       dir_index++;",
      "107:       std::vector<string> children;",
      "108:       Status s = fs->GetChildren(current_dir, &children);",
      "113:       new_rets[i] = s;",
      "114:       if (children.empty()) return;",
      "120:       std::vector<Status> children_dir_status;",
      "123:       children_dir_status.resize(children.size());",
      "124:       auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,",
      "125:                               is_directory, &children_dir_status](int j) {",
      "126:         const string child_path = io::JoinPath(current_dir, children[j]);",
      "127:         if (!fs->Match(child_path, dirs[dir_index])) {",
      "128:           children_dir_status[j] =",
      "130:         } else if (dir_index != dirs.size() - 1) {",
      "131:           children_dir_status[j] = fs->IsDirectory(child_path);",
      "133:           children_dir_status[j] =",
      "134:               is_directory ? fs->IsDirectory(child_path) : Status::OK();",
      "139:       for (size_t j = 0; j < children.size(); ++j) {",
      "140:         const string child_path = io::JoinPath(current_dir, children[j]);",
      "142:         if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {",
      "145:         if (children_dir_status[j].ok()) {",
      "146:           if (dir_index != dirs.size() - 1) {",
      "147:             mutex_lock lk(next_que_mutex);",
      "148:             next_dir_q.emplace_back(std::make_pair(child_path, dir_index));",
      "149:             next_que_cond.notify_one();",
      "150:           } else {",
      "151:             mutex_lock lk(results_mutex);",
      "152:             results->emplace_back(child_path);",
      "153:             results_cond.notify_one();",
      "154:           }",
      "158:     ForEach(0, dir_q.size(), handle_level);",
      "160:     ret.Update(new_rets[dir_q.size() - 1]);",
      "161:     std::swap(dir_q, next_dir_q);",
      "163:   return ret;",
      "",
      "[Added Lines]",
      "56: static const char kGlobbingChars[] = \"*?[\\\\\";",
      "58: static inline bool IsGlobbingPattern(const std::string& pattern) {",
      "59:   return (pattern.find_first_of(kGlobbingChars) != std::string::npos);",
      "60: }",
      "65: static std::string PatchPattern(const std::string& pattern) {",
      "66:   const std::string fixed_prefix =",
      "67:       pattern.substr(0, pattern.find_first_of(kGlobbingChars));",
      "70:   if (io::Dirname(fixed_prefix).empty()) {",
      "71:     return io::JoinPath(\".\", pattern);",
      "72:   }",
      "75:   return pattern;",
      "76: }",
      "78: static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {",
      "79:   std::vector<std::string> dirs;",
      "80:   const std::string patched = PatchPattern(d);",
      "81:   StringPiece dir(patched);",
      "86:   bool is_directory = d[d.size() - 1] == '/';",
      "87: #ifdef PLATFORM_WINDOWS",
      "88:   is_directory = is_directory || (d[d.size() - 1] == '\\\\');",
      "89: #endif",
      "90:   if (is_directory) {",
      "91:     dir = io::Dirname(dir);",
      "92:   }",
      "94:   while (!dir.empty()) {",
      "95:     dirs.emplace_back(dir);",
      "96:     StringPiece new_dir(io::Dirname(dir));",
      "100:     if (dir == new_dir) break;",
      "101:     dir = new_dir;",
      "102:   }",
      "105:   std::reverse(dirs.begin(), dirs.end());",
      "107:   return dirs;",
      "108: }",
      "110: static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {",
      "111:   int i = 0;",
      "112:   for (const auto& d : dirs) {",
      "113:     if (IsGlobbingPattern(d)) {",
      "114:       break;",
      "115:     }",
      "116:     i++;",
      "117:   }",
      "118:   return i;",
      "119: }",
      "126:   if (fs == nullptr || env == nullptr || results == nullptr) {",
      "127:     return Status(tensorflow::error::INVALID_ARGUMENT,",
      "128:                   \"Filesystem calls GetMatchingPaths with nullptr arguments\");",
      "129:   }",
      "144:   std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);",
      "149:   int matching_index = GetFirstGlobbingEntry(dirs);",
      "153:   if (matching_index == dirs.size()) {",
      "154:     if (fs->FileExists(pattern).ok()) {",
      "155:       results->emplace_back(pattern);",
      "156:     }",
      "157:     return Status::OK();",
      "182:   std::deque<std::pair<string, int>> expand_queue;",
      "183:   std::deque<std::pair<string, int>> next_expand_queue;",
      "184:   expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);",
      "188:   mutex result_mutex;",
      "189:   mutex queue_mutex;",
      "191:   while (!expand_queue.empty()) {",
      "192:     next_expand_queue.clear();",
      "196:     auto handle_level = [&fs, &results, &dirs, &expand_queue,",
      "197:                          &next_expand_queue, &result_mutex,",
      "198:                          &queue_mutex](int i) {",
      "200:       const auto& queue_item = expand_queue.at(i);",
      "201:       const std::string& parent = queue_item.first;",
      "202:       const int index = queue_item.second + 1;",
      "203:       const std::string& match_pattern = dirs[index];",
      "206:       std::vector<std::string> children;",
      "207:       Status s = fs->GetChildren(parent, &children);",
      "213:       if (children.empty()) {",
      "214:         return;",
      "215:       }",
      "222:       std::vector<Status> children_status(children.size());",
      "223:       auto handle_children = [&fs, &match_pattern, &parent, &children,",
      "224:                               &children_status](int j) {",
      "225:         const std::string path = io::JoinPath(parent, children[j]);",
      "226:         if (!fs->Match(path, match_pattern)) {",
      "227:           children_status[j] =",
      "230:           children_status[j] = fs->IsDirectory(path);",
      "244:       for (size_t j = 0; j < children.size(); j++) {",
      "245:         if (children_status[j].code() == tensorflow::error::CANCELLED) {",
      "249:         const std::string path = io::JoinPath(parent, children[j]);",
      "250:         if (index == dirs.size() - 1) {",
      "251:           mutex_lock l(result_mutex);",
      "252:           results->emplace_back(path);",
      "253:         } else if (children_status[j].ok()) {",
      "254:           mutex_lock l(queue_mutex);",
      "255:           next_expand_queue.emplace_back(path, index);",
      "259:     ForEach(0, expand_queue.size(), handle_level);",
      "262:     std::swap(expand_queue, next_expand_queue);",
      "265:   return Status::OK();",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8c24066d6dd62a9294e43564f5551d4bde061cf1",
      "candidate_info": {
        "commit_hash": "8c24066d6dd62a9294e43564f5551d4bde061cf1",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/8c24066d6dd62a9294e43564f5551d4bde061cf1",
        "files": [
          "tensorflow/core/platform/file_system_helper.cc"
        ],
        "message": "change GetMatchingPaths to speed it up\n\nThe old code will traverse all paths without using\nany wildcard characters, which will introduce lots of\ncalculation when matching patterns like \"/*\".",
        "before_after_code_files": [
          "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ],
          "candidate": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
          "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "55: Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,",
          "56:                         std::vector<string>* results) {",
          "57:   results->clear();",
          "69:   }",
          "74:   Status ret;  // Status to return.",
          "",
          "[Removed Lines]",
          "59:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
          "60:   string eval_pattern = pattern;",
          "61:   std::vector<string> all_files;",
          "62:   string dir(io::Dirname(fixed_prefix));",
          "65:   if (dir.empty()) {",
          "66:     dir = \".\";",
          "67:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
          "68:     eval_pattern = io::JoinPath(dir, pattern);",
          "72:   std::deque<string> dir_q;",
          "73:   dir_q.push_back(dir);",
          "",
          "[Added Lines]",
          "58:   if (pattern.empty()) {",
          "59:     return Status::OK();",
          "62:   string eval_pattern = pattern;",
          "63:   bool is_directory = pattern[pattern.size() - 1] == '/';",
          "64: #ifdef PLATFORM_WINDOWS",
          "65:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
          "66: #endif",
          "67:   if (!io::IsAbsolutePath(pattern)) {",
          "68:     eval_pattern = io::JoinPath(\".\", pattern);",
          "69:   }",
          "70:   std::vector<string> dirs;",
          "71:   if (!is_directory) {",
          "72:     dirs.push_back(eval_pattern);",
          "73:   }",
          "74:   StringPiece dir(io::Dirname(eval_pattern));",
          "75:   while (!dir.empty() && dir != \"/\") {",
          "76:     dirs.push_back(string(dir));",
          "77:     dir = io::Dirname(dir);",
          "78:   }",
          "79:   if (dir == \"/\") {",
          "80:     dirs.push_back(string(dir));",
          "81:   }",
          "82:   std::reverse(dirs.begin(), dirs.end());",
          "84:   std::deque<std::pair<string, int>> dir_q;",
          "85:   dir_q.push_back({dirs[0], 0});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "79:   std::vector<Status> children_dir_status;",
          "80:   while (!dir_q.empty()) {",
          "82:     dir_q.pop_front();",
          "83:     std::vector<string> children;",
          "84:     Status s = fs->GetChildren(current_dir, &children);",
          "",
          "[Removed Lines]",
          "81:     string current_dir = dir_q.front();",
          "",
          "[Added Lines]",
          "93:     string current_dir = dir_q.front().first;",
          "94:     int dir_index = dir_q.front().second;",
          "95:     dir_index++;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:     children_dir_status.resize(children.size());",
          "93:     ForEach(0, children.size(),",
          "96:               const string child_path = io::JoinPath(current_dir, children[i]);",
          "100:                 children_dir_status[i] = Status(tensorflow::error::CANCELLED,",
          "101:                                                 \"Operation not needed\");",
          "102:               } else {",
          "104:               }",
          "105:             });",
          "106:     for (size_t i = 0; i < children.size(); ++i) {",
          "",
          "[Removed Lines]",
          "94:             [fs, &current_dir, &children, &fixed_prefix,",
          "95:              &children_dir_status](int i) {",
          "99:               if (!absl::StartsWith(child_path, fixed_prefix)) {",
          "103:                 children_dir_status[i] = fs->IsDirectory(child_path);",
          "",
          "[Added Lines]",
          "108:             [fs, &current_dir, &children, &dirs, dir_index,",
          "109:              is_directory, &children_dir_status](int i) {",
          "111:               if (!fs->Match(child_path, dirs[dir_index])) {",
          "114:               } else if (dir_index != dirs.size() - 1){",
          "115:                 children_dir_status[i] = fs->IsDirectory(child_path);Status::OK();",
          "117:                 children_dir_status[i] = is_directory ?",
          "118:                     fs->IsDirectory(child_path) : Status::OK();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "109:       if (children_dir_status[i].code() == tensorflow::error::CANCELLED) {",
          "110:         continue;",
          "111:       }",
          "113:       if (children_dir_status[i].ok()) {",
          "115:       }",
          "124:     }",
          "125:   }",
          "126:   return ret;",
          "",
          "[Removed Lines]",
          "114:         dir_q.push_back(child_path);",
          "116:       all_files.push_back(child_path);",
          "117:     }",
          "118:   }",
          "121:   for (const auto& f : all_files) {",
          "122:     if (fs->Match(f, eval_pattern)) {",
          "123:       results->push_back(f);",
          "",
          "[Added Lines]",
          "128:         if (dir_index != dirs.size() - 1) {",
          "129:           dir_q.push_back({child_path, dir_index});",
          "130:         } else {",
          "131:           results->push_back(child_path);",
          "132:         }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7581d2a338c65086c6c7d0be1c65bd0621dd33c6",
      "candidate_info": {
        "commit_hash": "7581d2a338c65086c6c7d0be1c65bd0621dd33c6",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/7581d2a338c65086c6c7d0be1c65bd0621dd33c6",
        "files": [
          "tensorflow/core/platform/env.cc",
          "tensorflow/core/platform/file_system.cc",
          "tensorflow/core/platform/file_system_helper.cc",
          "tensorflow/core/platform/status.cc",
          "tensorflow/core/profiler/internal/parse_annotation.cc"
        ],
        "message": "in resolution of [Wsign-compare] warning ids : [16, 18, 19, 20, 21 ]",
        "before_after_code_files": [
          "tensorflow/core/platform/env.cc||tensorflow/core/platform/env.cc",
          "tensorflow/core/platform/file_system.cc||tensorflow/core/platform/file_system.cc",
          "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc",
          "tensorflow/core/platform/status.cc||tensorflow/core/platform/status.cc",
          "tensorflow/core/profiler/internal/parse_annotation.cc||tensorflow/core/profiler/internal/parse_annotation.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ],
          "candidate": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/platform/env.cc||tensorflow/core/platform/env.cc": [
          "File: tensorflow/core/platform/env.cc -> tensorflow/core/platform/env.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "214:     }",
          "215:     if (fs_status) {",
          "216:       result &= fs_result;",
          "218:         per_file_status[itr.second[i]] = fs_status->at(i);",
          "219:       }",
          "220:     } else if (!fs_result) {",
          "",
          "[Removed Lines]",
          "217:       for (int i = 0; i < itr.second.size(); ++i) {",
          "",
          "[Added Lines]",
          "217:       for (size_t i = 0; i < itr.second.size(); ++i) {",
          "",
          "---------------"
        ],
        "tensorflow/core/platform/file_system.cc||tensorflow/core/platform/file_system.cc": [
          "File: tensorflow/core/platform/file_system.cc -> tensorflow/core/platform/file_system.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "309:   StringPiece basename = this->Basename(path);",
          "311:   int pos = basename.rfind('.');",
          "313:     return StringPiece(path.data() + path.size(), 0);",
          "314:   } else {",
          "315:     return StringPiece(path.data() + pos + 1, path.size() - (pos + 1));",
          "",
          "[Removed Lines]",
          "312:   if (pos == StringPiece::npos) {",
          "",
          "[Added Lines]",
          "312:   if (static_cast<size_t>(pos) == StringPiece::npos) {",
          "",
          "---------------"
        ],
        "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
          "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:                 children_dir_status[i] = fs->IsDirectory(child_path);",
          "104:               }",
          "105:             });",
          "107:       const string child_path = io::JoinPath(current_dir, children[i]);",
          "109:       if (children_dir_status[i].code() == tensorflow::error::CANCELLED) {",
          "",
          "[Removed Lines]",
          "106:     for (int i = 0; i < children.size(); ++i) {",
          "",
          "[Added Lines]",
          "106:     for (size_t i = 0; i < children.size(); ++i) {",
          "",
          "---------------"
        ],
        "tensorflow/core/platform/status.cc||tensorflow/core/platform/status.cc": [
          "File: tensorflow/core/platform/status.cc -> tensorflow/core/platform/status.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "75:     mutex_lock lock(mu_);",
          "76:     messages_.emplace_back(entry.ToString());",
          "78:   }",
          "80:  private:",
          "",
          "[Removed Lines]",
          "77:     if (messages_.size() > num_messages_) messages_.pop_front();",
          "",
          "[Added Lines]",
          "77:     if (messages_.size() > static_cast<size_t>(num_messages_)) messages_.pop_front();",
          "",
          "---------------"
        ],
        "tensorflow/core/profiler/internal/parse_annotation.cc||tensorflow/core/profiler/internal/parse_annotation.cc": [
          "File: tensorflow/core/profiler/internal/parse_annotation.cc -> tensorflow/core/profiler/internal/parse_annotation.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:   std::vector<absl::string_view> key_value_pairs;",
          "52:   std::stack<char> quotes;",
          "53:   int start = 0, end = 0;",
          "55:     char ch = metadata[end];",
          "56:     switch (ch) {",
          "57:       case '\\\"':",
          "",
          "[Removed Lines]",
          "54:   for (; end < metadata.size(); ++end) {",
          "",
          "[Added Lines]",
          "54:   for (; static_cast<size_t>(end) < metadata.size(); ++end) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0f22b281a4a082ee05f1293ac19830322eef4e76",
      "candidate_info": {
        "commit_hash": "0f22b281a4a082ee05f1293ac19830322eef4e76",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/0f22b281a4a082ee05f1293ac19830322eef4e76",
        "files": [
          "tensorflow/core/platform/file_system_helper.cc"
        ],
        "message": "Parallelize each level of BFS in `GetMatchingPaths`",
        "before_after_code_files": [
          "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ],
          "candidate": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
          "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include \"tensorflow/core/platform/file_system_helper.h\"",
          "18: #include <deque>",
          "19: #include <string>",
          "20: #include <vector>",
          "22: #include \"tensorflow/core/platform/env.h\"",
          "23: #include \"tensorflow/core/platform/file_system.h\"",
          "24: #include \"tensorflow/core/platform/path.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <condition_variable>",
          "20: #include <mutex>",
          "24: #include \"tensorflow/core/platform/cpu_info.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33: namespace {",
          "",
          "[Removed Lines]",
          "35: constexpr int kNumThreads = 8;",
          "",
          "[Added Lines]",
          "38: const int kNumThreads = port::NumSchedulableCPUs();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "75: #endif",
          "76:   std::vector<string> dirs;",
          "77:   if (!is_directory) {",
          "79:   }",
          "80:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
          "81:   while (tmp_dir.size() > dir.size()) {",
          "83:     tmp_dir = io::Dirname(tmp_dir);",
          "84:   }",
          "86:   std::reverse(dirs.begin(), dirs.end());",
          "88:   std::deque<std::pair<string, int>> dir_q;",
          "90:   Status ret;  // Status to return.",
          "96:   while (!dir_q.empty()) {",
          "130:       }",
          "134:         } else {",
          "136:         }",
          "137:       }",
          "139:   }",
          "140:   return ret;",
          "141: }",
          "",
          "[Removed Lines]",
          "78:     dirs.push_back(eval_pattern);",
          "82:     dirs.push_back(string(tmp_dir));",
          "85:   dirs.push_back(dir);",
          "89:   dir_q.push_back({dirs[0], 0});",
          "95:   std::vector<Status> children_dir_status;",
          "97:     string current_dir = dir_q.front().first;",
          "98:     int dir_index = dir_q.front().second;",
          "99:     dir_index++;",
          "100:     dir_q.pop_front();",
          "101:     std::vector<string> children;",
          "102:     Status s = fs->GetChildren(current_dir, &children);",
          "104:     if (s.code() == tensorflow::error::PERMISSION_DENIED) {",
          "105:       continue;",
          "106:     }",
          "107:     ret.Update(s);",
          "108:     if (children.empty()) continue;",
          "110:     children_dir_status.resize(children.size());",
          "111:     ForEach(0, children.size(),",
          "112:             [fs, &current_dir, &children, &dirs, dir_index, is_directory,",
          "113:              &children_dir_status](int i) {",
          "114:               const string child_path = io::JoinPath(current_dir, children[i]);",
          "115:               if (!fs->Match(child_path, dirs[dir_index])) {",
          "116:                 children_dir_status[i] = Status(tensorflow::error::CANCELLED,",
          "117:                                                 \"Operation not needed\");",
          "118:               } else if (dir_index != dirs.size() - 1) {",
          "119:                 children_dir_status[i] = fs->IsDirectory(child_path);",
          "120:               } else {",
          "121:                 children_dir_status[i] =",
          "122:                     is_directory ? fs->IsDirectory(child_path) : Status::OK();",
          "123:               }",
          "124:             });",
          "125:     for (size_t i = 0; i < children.size(); ++i) {",
          "126:       const string child_path = io::JoinPath(current_dir, children[i]);",
          "128:       if (children_dir_status[i].code() == tensorflow::error::CANCELLED) {",
          "129:         continue;",
          "131:       if (children_dir_status[i].ok()) {",
          "132:         if (dir_index != dirs.size() - 1) {",
          "133:           dir_q.push_back({child_path, dir_index});",
          "135:           results->push_back(child_path);",
          "138:     }",
          "",
          "[Added Lines]",
          "81:     dirs.emplace_back(eval_pattern);",
          "85:     dirs.emplace_back(string(tmp_dir));",
          "88:   dirs.emplace_back(dir);",
          "92:   std::deque<std::pair<string, int>> next_dir_q;",
          "93:   dir_q.emplace_back({dirs[0], 0});",
          "95:   std::mutex results_mutex;",
          "96:   std::condition_variable results_cond;",
          "97:   std::mutex next_que_mutex;",
          "98:   std::condition_variable next_que_cond;",
          "100:     next_dir_q.clear();",
          "101:     std::vector<Status> new_rets(dir_q.size());",
          "102:     auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,",
          "103:       &results_mutex, &results_cond, &next_que_mutex, &next_que_cond](int i) {",
          "105:       string current_dir = dir_q.at(i).first;",
          "106:       int dir_index = dir_q.at(i).second;",
          "107:       dir_index++;",
          "108:       std::vector<string> children;",
          "109:       Status s = fs->GetChildren(current_dir, &children);",
          "111:       if (s.code() == tensorflow::error::PERMISSION_DENIED) {",
          "112:         return;",
          "114:       new_rets[i] = s;",
          "115:       if (children.empty()) return;",
          "121:       std::vector<Status> children_dir_status;",
          "124:       children_dir_status.resize(children.size());",
          "125:       auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,",
          "126:                               is_directory, &children_dir_status](int j) {",
          "127:         const string child_path = io::JoinPath(current_dir, children[j]);",
          "128:         if (!fs->Match(child_path, dirs[dir_index])) {",
          "129:           children_dir_status[j] = Status(tensorflow::error::CANCELLED,",
          "130:                                           \"Operation not needed\");",
          "131:         } else if (dir_index != dirs.size() - 1) {",
          "132:           children_dir_status[j] = fs->IsDirectory(child_path);",
          "134:           children_dir_status[j] =",
          "135:               is_directory ? fs->IsDirectory(child_path) : Status::OK();",
          "136:         }",
          "137:       };",
          "138:       ForEach(0, children.size(), handle_children);",
          "140:       for (size_t j = 0; j < children.size(); ++j) {",
          "141:         const string child_path = io::JoinPath(current_dir, children[j]);",
          "143:         if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {",
          "144:           continue;",
          "145:         }",
          "146:         if (children_dir_status[j].ok()) {",
          "147:           if (dir_index != dirs.size() - 1) {",
          "148:             std::lock_guard<std::mutex> lk(next_que_mutex);",
          "149:             next_dir_q.emplace_back(child_path);",
          "150:             next_que_cond.notify_one();",
          "151:           } else {",
          "152:             std::lock_guard<std::mutex> lk(results_mutex);",
          "153:             results->emplace_back(child_path);",
          "154:             results_cond.notify_one();",
          "155:           }",
          "158:     };",
          "159:     ForEach(0, dir_q.size(), handle_level);",
          "161:     ret.Update(new_rets[dir_q.size() - 1]);",
          "162:     std::swap(dir_q, next_dir_q);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80bedbb8baf761400900e5876eb403cf789e7a12",
      "candidate_info": {
        "commit_hash": "80bedbb8baf761400900e5876eb403cf789e7a12",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/80bedbb8baf761400900e5876eb403cf789e7a12",
        "files": [
          "tensorflow/core/platform/file_system_helper.cc"
        ],
        "message": "fix build failure",
        "before_after_code_files": [
          "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ],
          "candidate": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
          "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "62:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
          "63:   string eval_pattern = pattern;",
          "69:   }",
          "70:   bool is_directory = pattern[pattern.size() - 1] == '/';",
          "71: #ifdef PLATFORM_WINDOWS",
          "72:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
          "73: #endif",
          "78:   std::vector<string> dirs;",
          "79:   if (!is_directory) {",
          "86:   }",
          "89:   }",
          "90:   std::reverse(dirs.begin(), dirs.end());",
          "92:   std::deque<std::pair<string, int>> dir_q;",
          "",
          "[Removed Lines]",
          "64:   auto protocol_pos = fixed_prefix.find(\"://\");",
          "65:   string protocol = \"\";",
          "66:   if (protocol_pos != string::npos) {",
          "67:     protocol = pattern.substr(0, protocol_pos + 3);",
          "68:     eval_pattern = pattern.substr(protocol_pos + 3);",
          "74:   string base_dir(io::Dirname(fixed_prefix));",
          "75:   if (base_dir.empty()) {",
          "76:     eval_pattern = io::JoinPath(\".\", eval_pattern);",
          "77:   }",
          "80:     dirs.push_back(strings::StrCat(protocol, eval_pattern));",
          "81:   }",
          "82:   StringPiece dir(io::Dirname(eval_pattern));",
          "83:   while (!dir.empty() && dir != \"/\") {",
          "84:     dirs.push_back(strings::StrCat(protocol, dir));",
          "85:     dir = io::Dirname(dir);",
          "87:   if (dir == \"/\") {",
          "88:     dirs.push_back(strings::StrCat(protocol, dir));",
          "",
          "[Added Lines]",
          "64:   string dir(io::Dirname(fixed_prefix));",
          "67:   if (dir.empty()) {",
          "68:     dir = \".\";",
          "69:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
          "70:     eval_pattern = io::JoinPath(dir, eval_pattern);",
          "78:     dirs.push_back(eval_pattern);",
          "80:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
          "81:   while (tmp_dir.size() > dir.size()) {",
          "82:     dirs.push_back(string(tmp_dir));",
          "83:     tmp_dir = io::Dirname(tmp_dir);",
          "85:   dirs.push_back(dir);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "84607ed59e67595f916950098ae92ae835fd513a",
      "candidate_info": {
        "commit_hash": "84607ed59e67595f916950098ae92ae835fd513a",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/84607ed59e67595f916950098ae92ae835fd513a",
        "files": [
          "tensorflow/core/platform/file_system_helper.cc"
        ],
        "message": "Completely rewrite `GetMatchingPaths`.\n\nThe current parallel implementation is too complex (lambda inside lambda, two levels of parallelism) and has a read outside of bounds issue.\n\nThe new implementation cleans up artifacts from the previous implementations that were left in the code as it evolves. We add multiple helper functions, and document invariants and preconditions as well as every major step. This way, we fix the security issue and a potential new one which was not caught before\n\nPiperOrigin-RevId: 345787373\nChange-Id: Idcf3bd7bac7203995662db6765d97ec98b1edd7b",
        "before_after_code_files": [
          "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ],
          "candidate": [
            "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/platform/file_system_helper.cc||tensorflow/core/platform/file_system_helper.cc": [
          "File: tensorflow/core/platform/file_system_helper.cc -> tensorflow/core/platform/file_system_helper.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "52: #endif",
          "53: }",
          "55: }  // namespace",
          "57: Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,",
          "58:                         std::vector<string>* results) {",
          "59:   results->clear();",
          "60:   if (pattern.empty()) {",
          "61:     return Status::OK();",
          "62:   }",
          "86:   }",
          "110:       if (s.code() == tensorflow::error::PERMISSION_DENIED) {",
          "111:         return;",
          "112:       }",
          "129:               Status(tensorflow::error::CANCELLED, \"Operation not needed\");",
          "132:         } else {",
          "135:         }",
          "136:       };",
          "137:       ForEach(0, children.size(), handle_children);",
          "143:           continue;",
          "144:         }",
          "155:         }",
          "156:       }",
          "157:     };",
          "162:   }",
          "164: }",
          "166: }  // namespace internal",
          "",
          "[Removed Lines]",
          "64:   string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));",
          "65:   string eval_pattern = pattern;",
          "66:   string dir(io::Dirname(fixed_prefix));",
          "69:   if (dir.empty()) {",
          "70:     dir = \".\";",
          "71:     fixed_prefix = io::JoinPath(dir, fixed_prefix);",
          "72:     eval_pattern = io::JoinPath(dir, eval_pattern);",
          "73:   }",
          "74:   bool is_directory = pattern[pattern.size() - 1] == '/';",
          "75: #ifdef PLATFORM_WINDOWS",
          "76:   is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';",
          "77: #endif",
          "78:   std::vector<string> dirs;",
          "79:   if (!is_directory) {",
          "80:     dirs.emplace_back(eval_pattern);",
          "81:   }",
          "82:   StringPiece tmp_dir(io::Dirname(eval_pattern));",
          "83:   while (tmp_dir.size() > dir.size()) {",
          "84:     dirs.emplace_back(string(tmp_dir));",
          "85:     tmp_dir = io::Dirname(tmp_dir);",
          "87:   dirs.emplace_back(dir);",
          "88:   std::reverse(dirs.begin(), dirs.end());",
          "90:   std::deque<std::pair<string, int>> dir_q;",
          "91:   std::deque<std::pair<string, int>> next_dir_q;",
          "92:   dir_q.emplace_back(std::make_pair(dirs[0], 0));",
          "93:   Status ret;  // Status to return.",
          "94:   mutex results_mutex;",
          "95:   condition_variable results_cond;",
          "96:   mutex next_que_mutex;",
          "97:   condition_variable next_que_cond;",
          "98:   while (!dir_q.empty()) {",
          "99:     next_dir_q.clear();",
          "100:     std::vector<Status> new_rets(dir_q.size());",
          "101:     auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,",
          "102:                          &is_directory, &dirs, &results_mutex, &results_cond,",
          "103:                          &next_que_mutex, &next_que_cond](int i) {",
          "104:       string current_dir = dir_q.at(i).first;",
          "105:       int dir_index = dir_q.at(i).second;",
          "106:       dir_index++;",
          "107:       std::vector<string> children;",
          "108:       Status s = fs->GetChildren(current_dir, &children);",
          "113:       new_rets[i] = s;",
          "114:       if (children.empty()) return;",
          "120:       std::vector<Status> children_dir_status;",
          "123:       children_dir_status.resize(children.size());",
          "124:       auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,",
          "125:                               is_directory, &children_dir_status](int j) {",
          "126:         const string child_path = io::JoinPath(current_dir, children[j]);",
          "127:         if (!fs->Match(child_path, dirs[dir_index])) {",
          "128:           children_dir_status[j] =",
          "130:         } else if (dir_index != dirs.size() - 1) {",
          "131:           children_dir_status[j] = fs->IsDirectory(child_path);",
          "133:           children_dir_status[j] =",
          "134:               is_directory ? fs->IsDirectory(child_path) : Status::OK();",
          "139:       for (size_t j = 0; j < children.size(); ++j) {",
          "140:         const string child_path = io::JoinPath(current_dir, children[j]);",
          "142:         if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {",
          "145:         if (children_dir_status[j].ok()) {",
          "146:           if (dir_index != dirs.size() - 1) {",
          "147:             mutex_lock lk(next_que_mutex);",
          "148:             next_dir_q.emplace_back(std::make_pair(child_path, dir_index));",
          "149:             next_que_cond.notify_one();",
          "150:           } else {",
          "151:             mutex_lock lk(results_mutex);",
          "152:             results->emplace_back(child_path);",
          "153:             results_cond.notify_one();",
          "154:           }",
          "158:     ForEach(0, dir_q.size(), handle_level);",
          "160:     ret.Update(new_rets[dir_q.size() - 1]);",
          "161:     std::swap(dir_q, next_dir_q);",
          "163:   return ret;",
          "",
          "[Added Lines]",
          "56: static const char kGlobbingChars[] = \"*?[\\\\\";",
          "58: static inline bool IsGlobbingPattern(const std::string& pattern) {",
          "59:   return (pattern.find_first_of(kGlobbingChars) != std::string::npos);",
          "60: }",
          "65: static std::string PatchPattern(const std::string& pattern) {",
          "66:   const std::string fixed_prefix =",
          "67:       pattern.substr(0, pattern.find_first_of(kGlobbingChars));",
          "70:   if (io::Dirname(fixed_prefix).empty()) {",
          "71:     return io::JoinPath(\".\", pattern);",
          "72:   }",
          "75:   return pattern;",
          "76: }",
          "78: static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {",
          "79:   std::vector<std::string> dirs;",
          "80:   const std::string patched = PatchPattern(d);",
          "81:   StringPiece dir(patched);",
          "86:   bool is_directory = d[d.size() - 1] == '/';",
          "87: #ifdef PLATFORM_WINDOWS",
          "88:   is_directory = is_directory || (d[d.size() - 1] == '\\\\');",
          "89: #endif",
          "90:   if (is_directory) {",
          "91:     dir = io::Dirname(dir);",
          "92:   }",
          "94:   while (!dir.empty()) {",
          "95:     dirs.emplace_back(dir);",
          "96:     StringPiece new_dir(io::Dirname(dir));",
          "100:     if (dir == new_dir) break;",
          "101:     dir = new_dir;",
          "102:   }",
          "105:   std::reverse(dirs.begin(), dirs.end());",
          "107:   return dirs;",
          "108: }",
          "110: static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {",
          "111:   int i = 0;",
          "112:   for (const auto& d : dirs) {",
          "113:     if (IsGlobbingPattern(d)) {",
          "114:       break;",
          "115:     }",
          "116:     i++;",
          "117:   }",
          "118:   return i;",
          "119: }",
          "126:   if (fs == nullptr || env == nullptr || results == nullptr) {",
          "127:     return Status(tensorflow::error::INVALID_ARGUMENT,",
          "128:                   \"Filesystem calls GetMatchingPaths with nullptr arguments\");",
          "129:   }",
          "144:   std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);",
          "149:   int matching_index = GetFirstGlobbingEntry(dirs);",
          "153:   if (matching_index == dirs.size()) {",
          "154:     if (fs->FileExists(pattern).ok()) {",
          "155:       results->emplace_back(pattern);",
          "156:     }",
          "157:     return Status::OK();",
          "182:   std::deque<std::pair<string, int>> expand_queue;",
          "183:   std::deque<std::pair<string, int>> next_expand_queue;",
          "184:   expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);",
          "188:   mutex result_mutex;",
          "189:   mutex queue_mutex;",
          "191:   while (!expand_queue.empty()) {",
          "192:     next_expand_queue.clear();",
          "196:     auto handle_level = [&fs, &results, &dirs, &expand_queue,",
          "197:                          &next_expand_queue, &result_mutex,",
          "198:                          &queue_mutex](int i) {",
          "200:       const auto& queue_item = expand_queue.at(i);",
          "201:       const std::string& parent = queue_item.first;",
          "202:       const int index = queue_item.second + 1;",
          "203:       const std::string& match_pattern = dirs[index];",
          "206:       std::vector<std::string> children;",
          "207:       Status s = fs->GetChildren(parent, &children);",
          "213:       if (children.empty()) {",
          "214:         return;",
          "215:       }",
          "222:       std::vector<Status> children_status(children.size());",
          "223:       auto handle_children = [&fs, &match_pattern, &parent, &children,",
          "224:                               &children_status](int j) {",
          "225:         const std::string path = io::JoinPath(parent, children[j]);",
          "226:         if (!fs->Match(path, match_pattern)) {",
          "227:           children_status[j] =",
          "230:           children_status[j] = fs->IsDirectory(path);",
          "244:       for (size_t j = 0; j < children.size(); j++) {",
          "245:         if (children_status[j].code() == tensorflow::error::CANCELLED) {",
          "249:         const std::string path = io::JoinPath(parent, children[j]);",
          "250:         if (index == dirs.size() - 1) {",
          "251:           mutex_lock l(result_mutex);",
          "252:           results->emplace_back(path);",
          "253:         } else if (children_status[j].ok()) {",
          "254:           mutex_lock l(queue_mutex);",
          "255:           next_expand_queue.emplace_back(path, index);",
          "259:     ForEach(0, expand_queue.size(), handle_level);",
          "262:     std::swap(expand_queue, next_expand_queue);",
          "265:   return Status::OK();",
          "",
          "---------------"
        ]
      }
    }
  ]
}
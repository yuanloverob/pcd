{
  "cve_id": "CVE-2019-5489",
  "cve_desc": "The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server.",
  "repo": "torvalds/linux",
  "patch_hash": "574823bfab82d9d8fa47f422778043fbb4b4f50e",
  "patch_info": {
    "commit_hash": "574823bfab82d9d8fa47f422778043fbb4b4f50e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e",
    "files": [
      "mm/mincore.c"
    ],
    "message": "Change mincore() to count \"mapped\" pages rather than \"cached\" pages\n\nThe semantics of what \"in core\" means for the mincore() system call are\nsomewhat unclear, but Linux has always (since 2.3.52, which is when\nmincore() was initially done) treated it as \"page is available in page\ncache\" rather than \"page is mapped in the mapping\".\n\nThe problem with that traditional semantic is that it exposes a lot of\nsystem cache state that it really probably shouldn't, and that users\nshouldn't really even care about.\n\nSo let's try to avoid that information leak by simply changing the\nsemantics to be that mincore() counts actual mapped pages, not pages\nthat might be cheaply mapped if they were faulted (note the \"might be\"\npart of the old semantics: being in the cache doesn't actually guarantee\nthat you can access them without IO anyway, since things like network\nfilesystems may have to revalidate the cache before use).\n\nIn many ways the old semantics were somewhat insane even aside from the\ninformation leak issue.  From the very beginning (and that beginning is\na long time ago: 2.3.52 was released in March 2000, I think), the code\nhad a comment saying\n\n  Later we can get more picky about what \"in core\" means precisely.\n\nand this is that \"later\".  Admittedly it is much later than is really\ncomfortable.\n\nNOTE! This is a real semantic change, and it is for example known to\nchange the output of \"fincore\", since that program literally does a\nmmmap without populating it, and then doing \"mincore()\" on that mapping\nthat doesn't actually have any pages in it.\n\nI'm hoping that nobody actually has any workflow that cares, and the\ninfo leak is real.\n\nWe may have to do something different if it turns out that people have\nvalid reasons to want the old semantics, and if we can limit the\ninformation leak sanely.\n\nCc: Kevin Easton <kevin@guarana.org>\nCc: Jiri Kosina <jikos@kernel.org>\nCc: Masatake YAMATO <yamato@redhat.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Greg KH <gregkh@linuxfoundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Michal Hocko <mhocko@suse.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/mincore.c||mm/mincore.c"
    ]
  },
  "patch_diff": {
    "mm/mincore.c||mm/mincore.c": [
      "File: mm/mincore.c -> mm/mincore.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "42:  return 0;",
      "43: }",
      "106: static int mincore_unmapped_range(unsigned long addr, unsigned long end,",
      "107:        struct mm_walk *walk)",
      "108: {",
      "111:  return 0;",
      "112: }",
      "",
      "[Removed Lines]",
      "51: static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)",
      "52: {",
      "53:  unsigned char present = 0;",
      "54:  struct page *page;",
      "62: #ifdef CONFIG_SWAP",
      "63:  if (shmem_mapping(mapping)) {",
      "64:   page = find_get_entry(mapping, pgoff);",
      "69:   if (xa_is_value(page)) {",
      "70:    swp_entry_t swp = radix_to_swp_entry(page);",
      "71:    page = find_get_page(swap_address_space(swp),",
      "72:           swp_offset(swp));",
      "73:   }",
      "74:  } else",
      "75:   page = find_get_page(mapping, pgoff);",
      "76: #else",
      "77:  page = find_get_page(mapping, pgoff);",
      "78: #endif",
      "79:  if (page) {",
      "80:   present = PageUptodate(page);",
      "81:   put_page(page);",
      "82:  }",
      "84:  return present;",
      "85: }",
      "87: static int __mincore_unmapped_range(unsigned long addr, unsigned long end,",
      "88:     struct vm_area_struct *vma, unsigned char *vec)",
      "89: {",
      "90:  unsigned long nr = (end - addr) >> PAGE_SHIFT;",
      "91:  int i;",
      "93:  if (vma->vm_file) {",
      "94:   pgoff_t pgoff;",
      "96:   pgoff = linear_page_index(vma, addr);",
      "97:   for (i = 0; i < nr; i++, pgoff++)",
      "98:    vec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);",
      "99:  } else {",
      "100:   for (i = 0; i < nr; i++)",
      "101:    vec[i] = 0;",
      "102:  }",
      "103:  return nr;",
      "104: }",
      "109:  walk->private += __mincore_unmapped_range(addr, end,",
      "110:         walk->vma, walk->private);",
      "",
      "[Added Lines]",
      "48:  unsigned char *vec = walk->private;",
      "49:  unsigned long nr = (end - addr) >> PAGE_SHIFT;",
      "51:  memset(vec, 0, nr);",
      "52:  walk->private += nr;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "127:   goto out;",
      "128:  }",
      "130:  if (pmd_trans_unstable(pmd)) {",
      "132:   goto out;",
      "133:  }",
      "",
      "[Removed Lines]",
      "131:   __mincore_unmapped_range(addr, end, vma, vec);",
      "",
      "[Added Lines]",
      "74:   memset(vec, 1, nr);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "137:   pte_t pte = *ptep;",
      "139:   if (pte_none(pte))",
      "142:   else if (pte_present(pte))",
      "145:    swp_entry_t entry = pte_to_swp_entry(pte);",
      "162:   }",
      "163:   vec++;",
      "164:  }",
      "",
      "[Removed Lines]",
      "140:    __mincore_unmapped_range(addr, addr + PAGE_SIZE,",
      "141:        vma, vec);",
      "147:    if (non_swap_entry(entry)) {",
      "153:    } else {",
      "154: #ifdef CONFIG_SWAP",
      "156:           swp_offset(entry));",
      "157: #else",
      "158:     WARN_ON(1);",
      "160: #endif",
      "161:    }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "30bac164aca750892b93eef350439a0562a68647",
      "candidate_info": {
        "commit_hash": "30bac164aca750892b93eef350439a0562a68647",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/30bac164aca750892b93eef350439a0562a68647",
        "files": [
          "mm/mincore.c"
        ],
        "message": "Revert \"Change mincore() to count \"mapped\" pages rather than \"cached\" pages\"\n\nThis reverts commit 574823bfab82d9d8fa47f422778043fbb4b4f50e.\n\nIt turns out that my hope that we could just remove the code that\nexposes the cache residency status from mincore() was too optimistic.\n\nThere are various random users that want it, and one example would be\nthe Netflix database cluster maintenance. To quote Josh Snyder:\n\n \"For Netflix, losing accurate information from the mincore syscall\n  would lengthen database cluster maintenance operations from days to\n  months. We rely on cross-process mincore to migrate the contents of a\n  page cache from machine to machine, and across reboots.\n\n  To do this, I wrote and maintain happycache [1], a page cache\n  dumper/loader tool. It is quite similar in architecture to pgfincore,\n  except that it is agnostic to workload. The gist of happycache's\n  operation is \"produce a dump of residence status for each page, do\n  some operation, then reload exactly the same pages which were present\n  before.\" happycache is entirely dependent on accurate reporting of the\n  in-core status of file-backed pages, as accessed by another process.\n\n  We primarily use happycache with Cassandra, which (like Postgres +\n  pgfincore) relies heavily on OS page cache to reduce disk accesses.\n  Because our workloads never experience a cold page cache, we are able\n  to provision hardware for a peak utilization level that is far lower\n  than the hypothetical \"every query is a cache miss\" peak.\n\n  A database warmed by happycache can be ready for service in seconds\n  (bounded only by the performance of the drives and the I/O subsystem),\n  with no period of in-service degradation. By contrast, putting a\n  database in service without a page cache entails a potentially\n  unbounded period of degradation (at Netflix, the time to populate a\n  single node's cache via natural cache misses varies by workload from\n  hours to weeks). If a single node upgrade were to take weeks, then\n  upgrading an entire cluster would take months. Since we want to apply\n  security upgrades (and other things) on a somewhat tighter schedule,\n  we would have to develop more complex solutions to provide the same\n  functionality already provided by mincore.\n\n  At the bottom line, happycache is designed to benignly exploit the\n  same information leak documented in the paper [2]. I think it makes\n  perfect sense to remove cross-process mincore functionality from\n  unprivileged users, but not to remove it entirely\"\n\nWe do have an alternate approach that limits the cache residency\nreporting only to processes that have write permissions to the file, so\nwe can fix the original information leak issue that way.  It involves\n_adding_ code rather than removing it, which is sad, but hey, at least\nwe haven't found any users that would find the restrictions\nunacceptable.\n\nSo revert the optimistic first approach to make room for that alternate\nfix instead.\n\nReported-by: Josh Snyder <joshs@netflix.com>\nCc: Jiri Kosina <jikos@kernel.org>\nCc: Dominique Martinet <asmadeus@codewreck.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Dave Chinner <david@fromorbit.com>\nCc: Kevin Easton <kevin@guarana.org>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Cyril Hrubis <chrubis@suse.cz>\nCc: Vlastimil Babka <vbabka@suse.cz>\nCc: Tejun Heo <tj@kernel.org>\nCc: Kirill A. Shutemov <kirill@shutemov.name>\nCc: Daniel Gruss <daniel@gruss.cc>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/mincore.c||mm/mincore.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/mincore.c||mm/mincore.c"
          ],
          "candidate": [
            "mm/mincore.c||mm/mincore.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/mincore.c||mm/mincore.c": [
          "File: mm/mincore.c -> mm/mincore.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:  return 0;",
          "43: }",
          "47: {",
          "49:  unsigned long nr = (end - addr) >> PAGE_SHIFT;",
          "53:  return 0;",
          "54: }",
          "",
          "[Removed Lines]",
          "45: static int mincore_unmapped_range(unsigned long addr, unsigned long end,",
          "46:        struct mm_walk *walk)",
          "48:  unsigned char *vec = walk->private;",
          "51:  memset(vec, 0, nr);",
          "52:  walk->private += nr;",
          "",
          "[Added Lines]",
          "51: static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)",
          "52: {",
          "53:  unsigned char present = 0;",
          "54:  struct page *page;",
          "62: #ifdef CONFIG_SWAP",
          "63:  if (shmem_mapping(mapping)) {",
          "64:   page = find_get_entry(mapping, pgoff);",
          "69:   if (xa_is_value(page)) {",
          "70:    swp_entry_t swp = radix_to_swp_entry(page);",
          "71:    page = find_get_page(swap_address_space(swp),",
          "72:           swp_offset(swp));",
          "73:   }",
          "74:  } else",
          "75:   page = find_get_page(mapping, pgoff);",
          "76: #else",
          "77:  page = find_get_page(mapping, pgoff);",
          "78: #endif",
          "79:  if (page) {",
          "80:   present = PageUptodate(page);",
          "81:   put_page(page);",
          "82:  }",
          "84:  return present;",
          "85: }",
          "87: static int __mincore_unmapped_range(unsigned long addr, unsigned long end,",
          "88:     struct vm_area_struct *vma, unsigned char *vec)",
          "91:  int i;",
          "93:  if (vma->vm_file) {",
          "94:   pgoff_t pgoff;",
          "96:   pgoff = linear_page_index(vma, addr);",
          "97:   for (i = 0; i < nr; i++, pgoff++)",
          "98:    vec[i] = mincore_page(vma->vm_file->f_mapping, pgoff);",
          "99:  } else {",
          "100:   for (i = 0; i < nr; i++)",
          "101:    vec[i] = 0;",
          "102:  }",
          "103:  return nr;",
          "104: }",
          "106: static int mincore_unmapped_range(unsigned long addr, unsigned long end,",
          "107:        struct mm_walk *walk)",
          "108: {",
          "109:  walk->private += __mincore_unmapped_range(addr, end,",
          "110:         walk->vma, walk->private);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:   goto out;",
          "70:  }",
          "73:  if (pmd_trans_unstable(pmd)) {",
          "75:   goto out;",
          "76:  }",
          "",
          "[Removed Lines]",
          "74:   memset(vec, 1, nr);",
          "",
          "[Added Lines]",
          "131:   __mincore_unmapped_range(addr, end, vma, vec);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80:   pte_t pte = *ptep;",
          "82:   if (pte_none(pte))",
          "84:   else if (pte_present(pte))",
          "87:    swp_entry_t entry = pte_to_swp_entry(pte);",
          "94:   }",
          "95:   vec++;",
          "96:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "140:    __mincore_unmapped_range(addr, addr + PAGE_SIZE,",
          "141:        vma, vec);",
          "147:    if (non_swap_entry(entry)) {",
          "153:    } else {",
          "154: #ifdef CONFIG_SWAP",
          "156:           swp_offset(entry));",
          "157: #else",
          "158:     WARN_ON(1);",
          "160: #endif",
          "161:    }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
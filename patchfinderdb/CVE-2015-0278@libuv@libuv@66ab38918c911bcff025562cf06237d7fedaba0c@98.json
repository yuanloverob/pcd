{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "6de622c3e4d2c634ede34d86838d322967ff7772",
      "candidate_info": {
        "commit_hash": "6de622c3e4d2c634ede34d86838d322967ff7772",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/6de622c3e4d2c634ede34d86838d322967ff7772",
        "files": [
          "Makefile.mingw"
        ],
        "message": "build: add missing file to Makefile.mingw",
        "before_after_code_files": [
          "Makefile.mingw||Makefile.mingw"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.mingw||Makefile.mingw": [
          "File: Makefile.mingw -> Makefile.mingw",
          "--- Hunk 1 ---",
          "[Context before]",
          "51:        src/win/fs-event.o \\",
          "52:        src/win/fs.o \\",
          "53:        src/win/getaddrinfo.o \\",
          "54:        src/win/handle.o \\",
          "55:        src/win/loop-watcher.o \\",
          "56:        src/win/pipe.o \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54:        src/win/getnameinfo.o \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "86831fe99c625f3a8180c02e628758eb25a0bd3b",
      "candidate_info": {
        "commit_hash": "86831fe99c625f3a8180c02e628758eb25a0bd3b",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/86831fe99c625f3a8180c02e628758eb25a0bd3b",
        "files": [
          "src/unix/async.c"
        ],
        "message": "linux: reduce file descriptor count of async pipe\n\nReopen one of the pipe descriptors as read/write through the procfs.\nAllows us to close the original pipe file descriptors, saving a file\ndescriptor on kernels that don't support eventfd(2).",
        "before_after_code_files": [
          "src/unix/async.c||src/unix/async.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/async.c||src/unix/async.c": [
          "File: src/unix/async.c -> src/unix/async.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:     pipefd[0] = err;",
          "218:     pipefd[1] = -1;",
          "219:   }",
          "221:     err = uv__make_pipe(pipefd, UV__F_NONBLOCK);",
          "223:   if (err < 0)",
          "224:     return err;",
          "",
          "[Removed Lines]",
          "220:   else if (err == -ENOSYS)",
          "",
          "[Added Lines]",
          "221:   else if (err == -ENOSYS) {",
          "223: #if defined(__linux__)",
          "228:     if (err == 0) {",
          "229:       char buf[32];",
          "230:       int fd;",
          "232:       snprintf(buf, sizeof(buf), \"/proc/self/fd/%d\", pipefd[0]);",
          "233:       fd = uv__open_cloexec(buf, O_RDWR);",
          "234:       if (fd != -1) {",
          "235:         uv__close(pipefd[0]);",
          "236:         uv__close(pipefd[1]);",
          "237:         pipefd[0] = fd;",
          "238:         pipefd[1] = fd;",
          "239:       }",
          "240:     }",
          "241: #endif",
          "242:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "236:   if (wa->io_watcher.fd == -1)",
          "237:     return;",
          "243:   if (wa->wfd != -1) {",
          "245:     wa->wfd = -1;",
          "246:   }",
          "247: }",
          "",
          "[Removed Lines]",
          "239:   uv__io_stop(loop, &wa->io_watcher, UV__POLLIN);",
          "240:   uv__close(wa->io_watcher.fd);",
          "241:   wa->io_watcher.fd = -1;",
          "244:     uv__close(wa->wfd);",
          "",
          "[Added Lines]",
          "261:     if (wa->wfd != wa->io_watcher.fd)",
          "262:       uv__close(wa->wfd);",
          "266:   uv__io_stop(loop, &wa->io_watcher, UV__POLLIN);",
          "267:   uv__close(wa->io_watcher.fd);",
          "268:   wa->io_watcher.fd = -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b05a3ee4d1b25bd5515a5810b159299c250bf88f",
      "candidate_info": {
        "commit_hash": "b05a3ee4d1b25bd5515a5810b159299c250bf88f",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/b05a3ee4d1b25bd5515a5810b159299c250bf88f",
        "files": [
          "Makefile.am",
          "checksparse.sh",
          "include/uv-unix.h",
          "include/uv-win.h",
          "include/uv.h",
          "src/unix/internal.h",
          "src/unix/pipe.c",
          "src/unix/stream.c",
          "src/win/internal.h",
          "src/win/pipe.c",
          "src/win/stream.c",
          "src/win/tcp.c",
          "test/benchmark-multi-accept.c",
          "test/test-ipc-send-recv.c",
          "test/test-ipc.c",
          "test/test-list.h",
          "test/test-pipe-sendmsg.c",
          "uv.gyp"
        ],
        "message": "pipe: allow queueing pending handles\n\nIntroduce `int uv_pipe_pending_count(uv_pipe_t*)` and\n`uv_handle_type uv_pipe_pending_type(uv_pipe_t*)`. They should be\nused in IPC pipe's read cb to accept incoming handles:\n\n    int count = uv_pipe_pending_count(pipe);\n    int i;\n    for (i = 0; i < count; i++) {\n      uv_handle_type type = uv_pipe_pending_type(pipe);\n      /* ... */\n      uv_accept(...);\n    }",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "checksparse.sh||checksparse.sh",
          "include/uv-unix.h||include/uv-unix.h",
          "include/uv-win.h||include/uv-win.h",
          "include/uv.h||include/uv.h",
          "src/unix/internal.h||src/unix/internal.h",
          "src/unix/pipe.c||src/unix/pipe.c",
          "src/unix/stream.c||src/unix/stream.c",
          "src/win/internal.h||src/win/internal.h",
          "src/win/pipe.c||src/win/pipe.c",
          "src/win/stream.c||src/win/stream.c",
          "src/win/tcp.c||src/win/tcp.c",
          "test/benchmark-multi-accept.c||test/benchmark-multi-accept.c",
          "test/test-ipc-send-recv.c||test/test-ipc-send-recv.c",
          "test/test-ipc.c||test/test-ipc.c",
          "test/test-list.h||test/test-list.h",
          "test/test-pipe-sendmsg.c||test/test-pipe-sendmsg.c",
          "uv.gyp||uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "158:                          test/test-pipe-bind-error.c \\",
          "159:                          test/test-pipe-connect-error.c \\",
          "160:                          test/test-pipe-getsockname.c \\",
          "161:                          test/test-pipe-server-close.c \\",
          "162:                          test/test-platform-output.c \\",
          "163:                          test/test-poll-close.c \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "161:                          test/test-pipe-sendmsg.c \\",
          "",
          "---------------"
        ],
        "checksparse.sh||checksparse.sh": [
          "File: checksparse.sh -> checksparse.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "115: test/test-ping-pong.c",
          "116: test/test-pipe-bind-error.c",
          "117: test/test-pipe-connect-error.c",
          "118: test/test-pipe-server-close.c",
          "119: test/test-platform-output.c",
          "120: test/test-poll-close.c",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "118: test/test-pipe-sendmsg.c",
          "",
          "---------------"
        ],
        "include/uv-unix.h||include/uv-unix.h": [
          "File: include/uv-unix.h -> include/uv-unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "230:   uv_connection_cb connection_cb;                                             \\",
          "231:   int delayed_error;                                                          \\",
          "232:   int accepted_fd;                                                            \\",
          "233:   UV_STREAM_PRIVATE_PLATFORM_FIELDS                                           \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "233:   void* queued_fds;                                                           \\",
          "",
          "---------------"
        ],
        "include/uv-win.h||include/uv-win.h": [
          "File: include/uv-win.h -> include/uv-win.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "424:   uv_write_t ipc_header_write_req;                                            \\",
          "425:   int ipc_pid;                                                                \\",
          "426:   uint64_t remaining_ipc_rawdata_bytes;                                       \\",
          "428:   struct {                                                                    \\",
          "431:   } pending_ipc_info;                                                         \\",
          "432:   uv_write_t* non_overlapped_writes_tail;",
          "",
          "[Removed Lines]",
          "427:   unsigned char reserved[sizeof(void*)];                                      \\",
          "429:     WSAPROTOCOL_INFOW* socket_info;                                           \\",
          "430:     int tcp_connection;                                                       \\",
          "",
          "[Added Lines]",
          "428:     void* queue[2];                                                           \\",
          "429:     int queue_len;                                                            \\",
          "",
          "---------------"
        ],
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "398: typedef void (*uv_read_cb)(uv_stream_t* stream,",
          "399:                            ssize_t nread,",
          "400:                            const uv_buf_t* buf);",
          "412: typedef void (*uv_write_cb)(uv_write_t* req, int status);",
          "413: typedef void (*uv_connect_cb)(uv_connect_t* req, int status);",
          "414: typedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);",
          "",
          "[Removed Lines]",
          "407: typedef void (*uv_read2_cb)(uv_pipe_t* pipe,",
          "408:                             ssize_t nread,",
          "409:                             const uv_buf_t* buf,",
          "410:                             uv_handle_type pending);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "611:   size_t write_queue_size;                                                    \\",
          "612:   uv_alloc_cb alloc_cb;                                                       \\",
          "613:   uv_read_cb read_cb;                                                         \\",
          "616:   UV_STREAM_PRIVATE_FIELDS",
          "",
          "[Removed Lines]",
          "614:   uv_read2_cb read2_cb;                                                       \\",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "661: UV_EXTERN int uv_read_stop(uv_stream_t*);",
          "",
          "[Removed Lines]",
          "667: UV_EXTERN int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb,",
          "668:     uv_read2_cb read_cb);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1214: UV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1204: UV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);",
          "1205: UV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);",
          "",
          "---------------"
        ],
        "src/unix/internal.h||src/unix/internal.h": [
          "File: src/unix/internal.h -> src/unix/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "120: # define O_CLOEXEC 0x00100000",
          "121: #endif",
          "124: enum {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "123: typedef struct uv__stream_queued_fds_s uv__stream_queued_fds_t;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "143: } uv_clocktype_t;",
          "146: int uv__nonblock(int fd, int set);",
          "147: int uv__close(int fd);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147: struct uv__stream_queued_fds_s {",
          "148:   unsigned int size;",
          "149:   unsigned int offset;",
          "150:   int fds[1];",
          "151: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "226: void uv__timer_close(uv_timer_t* handle);",
          "227: void uv__udp_close(uv_udp_t* handle);",
          "228: void uv__udp_finish_close(uv_udp_t* handle);",
          "230: #if defined(__APPLE__)",
          "231: int uv___stream_fd(uv_stream_t* handle);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "238: uv_handle_type uv__handle_type(int fd);",
          "",
          "---------------"
        ],
        "src/unix/pipe.c||src/unix/pipe.c": [
          "File: src/unix/pipe.c -> src/unix/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "247: void uv_pipe_pending_instances(uv_pipe_t* handle, int count) {",
          "248: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "251: int uv_pipe_pending_count(uv_pipe_t* handle) {",
          "252:   uv__stream_queued_fds_t* queued_fds;",
          "254:   if (!handle->ipc)",
          "255:     return 0;",
          "257:   if (handle->accepted_fd == -1)",
          "258:     return 0;",
          "260:   if (handle->queued_fds == NULL)",
          "261:     return 1;",
          "263:   queued_fds = handle->queued_fds;",
          "264:   return queued_fds->offset + 1;",
          "265: }",
          "268: uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {",
          "269:   if (!handle->ipc)",
          "270:     return UV_UNKNOWN_HANDLE;",
          "272:   if (handle->accepted_fd == -1)",
          "273:     return UV_UNKNOWN_HANDLE;",
          "274:   else",
          "275:     return uv__handle_type(handle->accepted_fd);",
          "276: }",
          "",
          "---------------"
        ],
        "src/unix/stream.c||src/unix/stream.c": [
          "File: src/unix/stream.c -> src/unix/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:   uv__handle_init(loop, (uv_handle_t*)stream, type);",
          "114:   stream->read_cb = NULL;",
          "116:   stream->alloc_cb = NULL;",
          "117:   stream->close_cb = NULL;",
          "118:   stream->connection_cb = NULL;",
          "119:   stream->connect_req = NULL;",
          "120:   stream->shutdown_req = NULL;",
          "121:   stream->accepted_fd = -1;",
          "122:   stream->delayed_error = 0;",
          "123:   QUEUE_INIT(&stream->write_queue);",
          "124:   QUEUE_INIT(&stream->write_completed_queue);",
          "",
          "[Removed Lines]",
          "115:   stream->read2_cb = NULL;",
          "",
          "[Added Lines]",
          "121:   stream->queued_fds = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "570:   if (server->accepted_fd == -1)",
          "571:     return -EAGAIN;",
          "573:   switch (client->type) {",
          "574:     case UV_NAMED_PIPE:",
          "575:     case UV_TCP:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "573:   err = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "579:       if (err) {",
          "581:         uv__close(server->accepted_fd);",
          "584:       }",
          "585:       break;",
          "",
          "[Removed Lines]",
          "582:         server->accepted_fd = -1;",
          "583:         return err;",
          "",
          "[Added Lines]",
          "583:         goto done;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "588:       err = uv_udp_open((uv_udp_t*) client, server->accepted_fd);",
          "589:       if (err) {",
          "590:         uv__close(server->accepted_fd);",
          "593:       }",
          "594:       break;",
          "",
          "[Removed Lines]",
          "591:         server->accepted_fd = -1;",
          "592:         return err;",
          "",
          "[Added Lines]",
          "591:         goto done;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "597:       assert(0);",
          "598:   }",
          "603: }",
          "",
          "[Removed Lines]",
          "600:   uv__io_start(server->loop, &server->io_watcher, UV__POLLIN);",
          "601:   server->accepted_fd = -1;",
          "602:   return 0;",
          "",
          "[Added Lines]",
          "599: done:",
          "601:   if (server->queued_fds != NULL) {",
          "602:     uv__stream_queued_fds_t* queued_fds;",
          "604:     queued_fds = server->queued_fds;",
          "607:     server->accepted_fd = queued_fds->fds[0];",
          "610:     assert(queued_fds->offset > 0);",
          "611:     if (--queued_fds->offset == 0) {",
          "612:       free(queued_fds);",
          "613:       server->queued_fds = NULL;",
          "614:     } else {",
          "616:       memmove(queued_fds->fds,",
          "617:               queued_fds->fds + 1,",
          "618:               queued_fds->offset * sizeof(*queued_fds->fds));",
          "619:     }",
          "620:   } else {",
          "621:     server->accepted_fd = -1;",
          "622:     if (err == 0)",
          "623:       uv__io_start(server->loop, &server->io_watcher, UV__POLLIN);",
          "624:   }",
          "625:   return err;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "777:     msg.msg_flags = 0;",
          "779:     msg.msg_control = (void*) scratch;",
          "782:     cmsg = CMSG_FIRSTHDR(&msg);",
          "783:     cmsg->cmsg_level = SOL_SOCKET;",
          "784:     cmsg->cmsg_type = SCM_RIGHTS;",
          "788:     {",
          "",
          "[Removed Lines]",
          "780:     msg.msg_controllen = CMSG_LEN(sizeof(fd_to_send));",
          "785:     cmsg->cmsg_len = msg.msg_controllen;",
          "",
          "[Added Lines]",
          "803:     msg.msg_controllen = CMSG_SPACE(sizeof(fd_to_send));",
          "808:     cmsg->cmsg_len = CMSG_LEN(sizeof(fd_to_send));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "913: }",
          "917:   struct sockaddr_storage ss;",
          "918:   socklen_t len;",
          "919:   int type;",
          "",
          "[Removed Lines]",
          "916: static uv_handle_type uv__handle_type(int fd) {",
          "",
          "[Added Lines]",
          "939: uv_handle_type uv__handle_type(int fd) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "947: }",
          "961: static void uv__stream_eof(uv_stream_t* stream, const uv_buf_t* buf) {",
          "962:   stream->flags |= UV_STREAM_READ_EOF;",
          "963:   uv__io_stop(stream->loop, &stream->io_watcher, UV__POLLIN);",
          "964:   if (!uv__io_active(&stream->io_watcher, UV__POLLOUT))",
          "965:     uv__handle_stop(stream);",
          "966:   uv__stream_osx_interrupt_select(stream);",
          "968: }",
          "",
          "[Removed Lines]",
          "950: static void uv__stream_read_cb(uv_stream_t* stream,",
          "951:                                int status,",
          "952:                                const uv_buf_t* buf,",
          "953:                                uv_handle_type type) {",
          "954:   if (stream->read_cb != NULL)",
          "955:     stream->read_cb(stream, status, buf);",
          "956:   else",
          "957:     stream->read2_cb((uv_pipe_t*) stream, status, buf, type);",
          "958: }",
          "967:   uv__stream_read_cb(stream, UV_EOF, buf, UV_UNKNOWN_HANDLE);",
          "",
          "[Added Lines]",
          "979:   stream->read_cb(stream, UV_EOF, buf);",
          "980: }",
          "983: static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {",
          "984:   uv__stream_queued_fds_t* queued_fds;",
          "985:   unsigned int queue_size;",
          "987:   queued_fds = stream->queued_fds;",
          "988:   if (queued_fds == NULL) {",
          "989:     queue_size = 8;",
          "990:     queued_fds = malloc((queue_size - 1) * sizeof(*queued_fds->fds) +",
          "991:                         sizeof(*queued_fds));",
          "992:     if (queued_fds == NULL)",
          "993:       return -ENOMEM;",
          "994:     queued_fds->size = queue_size;",
          "995:     queued_fds->offset = 0;",
          "996:     stream->queued_fds = queued_fds;",
          "999:   } else if (queued_fds->size == queued_fds->offset) {",
          "1000:     queue_size = queued_fds->size + 8;",
          "1001:     queued_fds = realloc(queued_fds,",
          "1002:                          (queue_size - 1) * sizeof(*queued_fds->fds) +",
          "1003:                              sizeof(*queued_fds));",
          "1009:     if (queued_fds == NULL)",
          "1010:       return -ENOMEM;",
          "1011:     queued_fds->size = queue_size;",
          "1012:     stream->queued_fds = queued_fds;",
          "1013:   }",
          "1016:   queued_fds->fds[queued_fds->offset++] = fd;",
          "1018:   return 0;",
          "1019: }",
          "1022: #define UV__CMSG_FD_COUNT 64",
          "1023: #define UV__CMSG_FD_SIZE (UV__CMSG_FD_COUNT * sizeof(int))",
          "1026: static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {",
          "1027:   struct cmsghdr* cmsg;",
          "1029:   for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg)) {",
          "1030:     char* start;",
          "1031:     char* end;",
          "1032:     int err;",
          "1033:     void* pv;",
          "1034:     int* pi;",
          "1035:     unsigned int i;",
          "1036:     unsigned int count;",
          "1038:     if (cmsg->cmsg_type != SCM_RIGHTS) {",
          "1039:       fprintf(stderr, \"ignoring non-SCM_RIGHTS ancillary data: %d\\n\",",
          "1040:           cmsg->cmsg_type);",
          "1041:       continue;",
          "1042:     }",
          "1045:     pv = CMSG_DATA(cmsg);",
          "1046:     pi = pv;",
          "1049:     start = (char*) cmsg;",
          "1050:     end = (char*) cmsg + cmsg->cmsg_len;",
          "1051:     count = 0;",
          "1052:     while (start + CMSG_LEN(count * sizeof(*pi)) < end)",
          "1053:       count++;",
          "1054:     assert(start + CMSG_LEN(count * sizeof(*pi)) == end);",
          "1056:     for (i = 0; i < count; i++) {",
          "1058:       if (stream->accepted_fd != -1) {",
          "1059:         err = uv__stream_queue_fd(stream, pi[i]);",
          "1060:         if (err != 0) {",
          "1062:           for (; i < count; i++)",
          "1063:             uv__close(pi[i]);",
          "1064:           return err;",
          "1065:         }",
          "1066:       } else {",
          "1067:         stream->accepted_fd = pi[i];",
          "1068:       }",
          "1069:     }",
          "1070:   }",
          "1072:   return 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "972:   uv_buf_t buf;",
          "973:   ssize_t nread;",
          "974:   struct msghdr msg;",
          "977:   int count;",
          "979:   stream->flags &= ~UV_STREAM_READ_PARTIAL;",
          "",
          "[Removed Lines]",
          "975:   struct cmsghdr* cmsg;",
          "976:   char cmsg_space[64];",
          "",
          "[Added Lines]",
          "1080:   char cmsg_space[CMSG_SPACE(UV__CMSG_FD_SIZE)];",
          "1082:   int err;",
          "1083:   int is_ipc;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "984:   count = 32;",
          "990:       && (stream->flags & UV_STREAM_READING)",
          "991:       && (count-- > 0)) {",
          "992:     assert(stream->alloc_cb != NULL);",
          "",
          "[Removed Lines]",
          "989:   while ((stream->read_cb || stream->read2_cb)",
          "",
          "[Added Lines]",
          "1092:   is_ipc = stream->type == UV_NAMED_PIPE && ((uv_pipe_t*) stream)->ipc;",
          "1097:   while (stream->read_cb",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "994:     stream->alloc_cb((uv_handle_t*)stream, 64 * 1024, &buf);",
          "995:     if (buf.len == 0) {",
          "998:       return;",
          "999:     }",
          "1001:     assert(buf.base != NULL);",
          "1002:     assert(uv__stream_fd(stream) >= 0);",
          "1005:       do {",
          "1006:         nread = read(uv__stream_fd(stream), buf.base, buf.len);",
          "1007:       }",
          "1008:       while (nread < 0 && errno == EINTR);",
          "1009:     } else {",
          "1012:       msg.msg_flags = 0;",
          "1013:       msg.msg_iov = (struct iovec*) &buf;",
          "1014:       msg.msg_iovlen = 1;",
          "1015:       msg.msg_name = NULL;",
          "1016:       msg.msg_namelen = 0;",
          "1021:       do {",
          "1022:         nread = uv__recvmsg(uv__stream_fd(stream), &msg, 0);",
          "",
          "[Removed Lines]",
          "997:       uv__stream_read_cb(stream, UV_ENOBUFS, &buf, UV_UNKNOWN_HANDLE);",
          "1004:     if (stream->read_cb) {",
          "1010:       assert(stream->read2_cb);",
          "1018:       msg.msg_controllen = 64;",
          "1019:       msg.msg_control = (void*)  cmsg_space;",
          "",
          "[Added Lines]",
          "1105:       stream->read_cb(stream, UV_ENOBUFS, &buf);",
          "1112:     if (!is_ipc) {",
          "1125:       msg.msg_controllen = sizeof(cmsg_space);",
          "1126:       msg.msg_control = cmsg_space;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1032:           uv__io_start(stream->loop, &stream->io_watcher, UV__POLLIN);",
          "1033:           uv__stream_osx_interrupt_select(stream);",
          "1034:         }",
          "1036:       } else {",
          "1039:         assert(!uv__io_active(&stream->io_watcher, UV__POLLIN) &&",
          "1040:                \"stream->read_cb(status=-1) did not call uv_close()\");",
          "1041:       }",
          "",
          "[Removed Lines]",
          "1035:         uv__stream_read_cb(stream, 0, &buf, UV_UNKNOWN_HANDLE);",
          "1038:         uv__stream_read_cb(stream, -errno, &buf, UV_UNKNOWN_HANDLE);",
          "",
          "[Added Lines]",
          "1142:         stream->read_cb(stream, 0, &buf);",
          "1145:         stream->read_cb(stream, -errno, &buf);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1048:       ssize_t buflen = buf.len;",
          "1092:         }",
          "1093:       }",
          "1096:       if (nread < buflen) {",
          "",
          "[Removed Lines]",
          "1050:       if (stream->read_cb) {",
          "1051:         stream->read_cb(stream, nread, &buf);",
          "1052:       } else {",
          "1053:         assert(stream->read2_cb);",
          "1062:         for (cmsg = CMSG_FIRSTHDR(&msg);",
          "1063:              msg.msg_controllen > 0 && cmsg != NULL;",
          "1064:              cmsg = CMSG_NXTHDR(&msg, cmsg)) {",
          "1066:           if (cmsg->cmsg_type == SCM_RIGHTS) {",
          "1067:             if (stream->accepted_fd != -1) {",
          "1068:               fprintf(stderr, \"(libuv) ignoring extra FD received\\n\");",
          "1069:             }",
          "1072:             {",
          "1073:               void* pv = CMSG_DATA(cmsg);",
          "1074:               int* pi = pv;",
          "1075:               stream->accepted_fd = *pi;",
          "1076:             }",
          "1078:           } else {",
          "1079:             fprintf(stderr, \"ignoring non-SCM_RIGHTS ancillary data: %d\\n\",",
          "1080:                 cmsg->cmsg_type);",
          "1081:           }",
          "1082:         }",
          "1085:         if (stream->accepted_fd >= 0) {",
          "1086:           stream->read2_cb((uv_pipe_t*) stream,",
          "1087:                            nread,",
          "1088:                            &buf,",
          "1089:                            uv__handle_type(stream->accepted_fd));",
          "1090:         } else {",
          "1091:           stream->read2_cb((uv_pipe_t*) stream, nread, &buf, UV_UNKNOWN_HANDLE);",
          "",
          "[Added Lines]",
          "1157:       if (is_ipc) {",
          "1158:         err = uv__stream_recv_cmsg(stream, &msg);",
          "1159:         if (err != 0) {",
          "1160:           stream->read_cb(stream, err, NULL);",
          "1161:           return;",
          "1164:       stream->read_cb(stream, nread, &buf);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1102: }",
          "1105: int uv_shutdown(uv_shutdown_t* req, uv_stream_t* stream, uv_shutdown_cb cb) {",
          "1106:   assert((stream->type == UV_TCP || stream->type == UV_NAMED_PIPE) &&",
          "1107:          \"uv_shutdown (unix) only supports uv_handle_t right now\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1176: #undef UV__CMSG_FD_COUNT",
          "1177: #undef UV__CMSG_FD_SIZE",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1371: }",
          "1378:   assert(stream->type == UV_TCP || stream->type == UV_NAMED_PIPE ||",
          "1379:       stream->type == UV_TTY);",
          "",
          "[Removed Lines]",
          "1374: static int uv__read_start_common(uv_stream_t* stream,",
          "1375:                                  uv_alloc_cb alloc_cb,",
          "1376:                                  uv_read_cb read_cb,",
          "1377:                                  uv_read2_cb read2_cb) {",
          "",
          "[Added Lines]",
          "1449: int uv_read_start(uv_stream_t* stream,",
          "1450:                   uv_alloc_cb alloc_cb,",
          "1451:                   uv_read_cb read_cb) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1394:   assert(alloc_cb);",
          "1396:   stream->read_cb = read_cb;",
          "1398:   stream->alloc_cb = alloc_cb;",
          "1400:   uv__io_start(stream->loop, &stream->io_watcher, UV__POLLIN);",
          "",
          "[Removed Lines]",
          "1397:   stream->read2_cb = read2_cb;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1405: }",
          "1420: int uv_read_stop(uv_stream_t* stream) {",
          "",
          "[Removed Lines]",
          "1408: int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb,",
          "1409:     uv_read_cb read_cb) {",
          "1410:   return uv__read_start_common(stream, alloc_cb, read_cb, NULL);",
          "1411: }",
          "1414: int uv_read2_start(uv_stream_t* stream, uv_alloc_cb alloc_cb,",
          "1415:     uv_read2_cb read_cb) {",
          "1416:   return uv__read_start_common(stream, alloc_cb, NULL, read_cb);",
          "1417: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1435:   uv__stream_osx_interrupt_select(stream);",
          "1437:   stream->read_cb = NULL;",
          "1439:   stream->alloc_cb = NULL;",
          "1440:   return 0;",
          "1441: }",
          "",
          "[Removed Lines]",
          "1438:   stream->read2_cb = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1471: void uv__stream_close(uv_stream_t* handle) {",
          "1472: #if defined(__APPLE__)",
          "1474:   if (handle->select != NULL) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1532:   unsigned int i;",
          "1533:   uv__stream_queued_fds_t* queued_fds;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1506:     handle->accepted_fd = -1;",
          "1507:   }",
          "1509:   assert(!uv__io_active(&handle->io_watcher, UV__POLLIN | UV__POLLOUT));",
          "1510: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1573:   if (handle->queued_fds != NULL) {",
          "1574:     queued_fds = handle->queued_fds;",
          "1575:     for (i = 0; i < queued_fds->offset; i++)",
          "1576:       uv__close(queued_fds->fds[i]);",
          "1577:     free(handle->queued_fds);",
          "1578:     handle->queued_fds = NULL;",
          "1579:   }",
          "",
          "---------------"
        ],
        "src/win/internal.h||src/win/internal.h": [
          "File: src/win/internal.h -> src/win/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "166: int uv_pipe_accept(uv_pipe_t* server, uv_stream_t* client);",
          "167: int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,",
          "168:     uv_read_cb read_cb);",
          "171: int uv_pipe_write(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,",
          "172:     const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb);",
          "173: int uv_pipe_write2(uv_loop_t* loop, uv_write_t* req, uv_pipe_t* handle,",
          "",
          "[Removed Lines]",
          "169: int uv_pipe_read2_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,",
          "170:     uv_read2_cb read_cb);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: #include \"stream-inl.h\"",
          "32: #include \"req-inl.h\"",
          "36: static char uv_zero_[] = \"\";",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34: typedef struct uv__ipc_queue_item_s uv__ipc_queue_item_t;",
          "36: struct uv__ipc_queue_item_s {",
          "41:   WSAPROTOCOL_INFOW socket_info;",
          "42:   QUEUE member;",
          "43:   int tcp_connection;",
          "44: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:   handle->name = NULL;",
          "87:   handle->ipc_pid = 0;",
          "88:   handle->remaining_ipc_rawdata_bytes = 0;",
          "91:   handle->ipc = ipc;",
          "92:   handle->non_overlapped_writes_tail = NULL;",
          "",
          "[Removed Lines]",
          "89:   handle->pending_ipc_info.socket_info = NULL;",
          "90:   handle->pending_ipc_info.tcp_connection = 0;",
          "",
          "[Added Lines]",
          "100:   QUEUE_INIT(&handle->pending_ipc_info.queue);",
          "101:   handle->pending_ipc_info.queue_len = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "287:   NTSTATUS nt_status;",
          "288:   IO_STATUS_BLOCK io_status;",
          "289:   FILE_PIPE_LOCAL_INFORMATION pipe_info;",
          "291:   if ((handle->flags & UV_HANDLE_CONNECTION) &&",
          "292:       handle->shutdown_req != NULL &&",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "301:   uv__ipc_queue_item_t* item;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "362:     assert(!(handle->flags & UV_HANDLE_CLOSED));",
          "364:     if (handle->flags & UV_HANDLE_CONNECTION) {",
          "368:       }",
          "370:       if (handle->flags & UV_HANDLE_EMULATE_IOCP) {",
          "371:         if (handle->read_req.wait_handle != INVALID_HANDLE_VALUE) {",
          "",
          "[Removed Lines]",
          "365:       if (handle->pending_ipc_info.socket_info) {",
          "366:         free(handle->pending_ipc_info.socket_info);",
          "367:         handle->pending_ipc_info.socket_info = NULL;",
          "",
          "[Added Lines]",
          "378:       while (!QUEUE_EMPTY(&handle->pending_ipc_info.queue)) {",
          "379:         QUEUE* q;",
          "380:         SOCKET socket;",
          "382:         q = QUEUE_HEAD(&handle->pending_ipc_info.queue);",
          "383:         QUEUE_REMOVE(q);",
          "384:         item = QUEUE_DATA(q, uv__ipc_queue_item_t, member);",
          "387:         socket = WSASocketW(FROM_PROTOCOL_INFO,",
          "388:                             FROM_PROTOCOL_INFO,",
          "389:                             FROM_PROTOCOL_INFO,",
          "390:                             &item->socket_info,",
          "391:                             0,",
          "392:                             WSA_FLAG_OVERLAPPED);",
          "393:         free(item);",
          "395:         if (socket != INVALID_SOCKET)",
          "396:           closesocket(socket);",
          "398:       handle->pending_ipc_info.queue_len = 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "720:   uv_loop_t* loop = server->loop;",
          "721:   uv_pipe_t* pipe_client;",
          "722:   uv_pipe_accept_t* req;",
          "724:   if (server->ipc) {",
          "727:       return WSAEWOULDBLOCK;",
          "728:     }",
          "732:   } else {",
          "733:     pipe_client = (uv_pipe_t*)client;",
          "",
          "[Removed Lines]",
          "725:     if (!server->pending_ipc_info.socket_info) {",
          "730:     return uv_tcp_import((uv_tcp_t*)client, server->pending_ipc_info.socket_info,",
          "731:                          server->pending_ipc_info.tcp_connection);",
          "",
          "[Added Lines]",
          "753:   QUEUE* q;",
          "754:   uv__ipc_queue_item_t* item;",
          "755:   int err;",
          "758:     if (QUEUE_EMPTY(&server->pending_ipc_info.queue)) {",
          "763:     q = QUEUE_HEAD(&server->pending_ipc_info.queue);",
          "764:     QUEUE_REMOVE(q);",
          "765:     server->pending_ipc_info.queue_len--;",
          "766:     item = QUEUE_DATA(q, uv__ipc_queue_item_t, member);",
          "768:     err = uv_tcp_import((uv_tcp_t*)client,",
          "769:                         &item->socket_info,",
          "770:                         item->tcp_connection);",
          "771:     if (err != 0)",
          "772:       return err;",
          "774:     free(item);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "956: }",
          "961:   uv_loop_t* loop = handle->loop;",
          "963:   handle->flags |= UV_HANDLE_READING;",
          "964:   INCREASE_ACTIVE_COUNT(loop, handle);",
          "965:   handle->read_cb = read_cb;",
          "967:   handle->alloc_cb = alloc_cb;",
          "",
          "[Removed Lines]",
          "959: static int uv_pipe_read_start_impl(uv_pipe_t* handle, uv_alloc_cb alloc_cb,",
          "960:     uv_read_cb read_cb, uv_read2_cb read2_cb) {",
          "966:   handle->read2_cb = read2_cb;",
          "",
          "[Added Lines]",
          "1003: int uv_pipe_read_start(uv_pipe_t* handle,",
          "1004:                        uv_alloc_cb alloc_cb,",
          "1005:                        uv_read_cb read_cb) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "975: }",
          "990: static void uv_insert_non_overlapped_write_req(uv_pipe_t* handle,",
          "991:     uv_write_t* req) {",
          "992:   req->next_req = NULL;",
          "",
          "[Removed Lines]",
          "978: int uv_pipe_read_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,",
          "979:     uv_read_cb read_cb) {",
          "980:   return uv_pipe_read_start_impl(handle, alloc_cb, read_cb, NULL);",
          "981: }",
          "984: int uv_pipe_read2_start(uv_pipe_t* handle, uv_alloc_cb alloc_cb,",
          "985:     uv_read2_cb read_cb) {",
          "986:   return uv_pipe_read_start_impl(handle, alloc_cb, NULL, read_cb);",
          "987: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1314:   handle->flags &= ~UV_HANDLE_READABLE;",
          "1315:   uv_read_stop((uv_stream_t*) handle);",
          "1322: }",
          "",
          "[Removed Lines]",
          "1317:   if (handle->read2_cb) {",
          "1318:     handle->read2_cb(handle, UV_EOF, &uv_null_buf_, UV_UNKNOWN_HANDLE);",
          "1319:   } else {",
          "1320:     handle->read_cb((uv_stream_t*) handle, UV_EOF, &uv_null_buf_);",
          "1321:   }",
          "",
          "[Added Lines]",
          "1349:   handle->read_cb((uv_stream_t*) handle, UV_EOF, &uv_null_buf_);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1331:   uv_read_stop((uv_stream_t*) handle);",
          "1341: }",
          "",
          "[Removed Lines]",
          "1333:   if (handle->read2_cb) {",
          "1334:     handle->read2_cb(handle,",
          "1335:                      uv_translate_sys_error(error),",
          "1336:                      &buf,",
          "1337:                      UV_UNKNOWN_HANDLE);",
          "1338:   } else {",
          "1339:     handle->read_cb((uv_stream_t*)handle, uv_translate_sys_error(error), &buf);",
          "1340:   }",
          "",
          "[Added Lines]",
          "1361:   handle->read_cb((uv_stream_t*)handle, uv_translate_sys_error(error), &buf);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1351: }",
          "1354: void uv_process_pipe_read_req(uv_loop_t* loop, uv_pipe_t* handle,",
          "1355:     uv_req_t* req) {",
          "1356:   DWORD bytes, avail;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1375: void uv__pipe_insert_pending_socket(uv_pipe_t* handle,",
          "1376:                                     WSAPROTOCOL_INFOW* info,",
          "1377:                                     int tcp_connection) {",
          "1378:   WSAPROTOCOL_INFOW* socket_info;",
          "1379:   uv__ipc_queue_item_t* item;",
          "1381:   item = (uv__ipc_queue_item_t*) malloc(sizeof(*item));",
          "1382:   if (item == NULL)",
          "1383:     uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "1385:   memcpy(&item->socket_info, info, sizeof(item->socket_info));",
          "1386:   item->tcp_connection = tcp_connection;",
          "1387:   QUEUE_INSERT_TAIL(&handle->pending_ipc_info.queue, &item->member);",
          "1388:   handle->pending_ipc_info.queue_len++;",
          "1389: }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1426:             assert(bytes == sizeof(ipc_frame) - sizeof(ipc_frame.header));",
          "1439:           }",
          "1441:           if (ipc_frame.header.flags & UV_IPC_RAW_DATA) {",
          "",
          "[Removed Lines]",
          "1429:             assert(!handle->pending_ipc_info.socket_info);",
          "1430:             handle->pending_ipc_info.socket_info =",
          "1431:               (WSAPROTOCOL_INFOW*)malloc(sizeof(*(handle->pending_ipc_info.socket_info)));",
          "1432:             if (!handle->pending_ipc_info.socket_info) {",
          "1433:               uv_fatal_error(ERROR_OUTOFMEMORY, \"malloc\");",
          "1434:             }",
          "1437:             handle->pending_ipc_info.tcp_connection =",
          "1438:               ipc_frame.header.flags & UV_IPC_TCP_CONNECTION;",
          "",
          "[Added Lines]",
          "1467:             uv__pipe_insert_pending_socket(",
          "1468:                 handle,",
          "1469:                 &ipc_frame.socket_info,",
          "1470:                 ipc_frame.header.flags & UV_IPC_TCP_CONNECTION);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1451:       handle->alloc_cb((uv_handle_t*) handle, avail, &buf);",
          "1452:       if (buf.len == 0) {",
          "1458:         break;",
          "1459:       }",
          "1460:       assert(buf.base != NULL);",
          "",
          "[Removed Lines]",
          "1453:         if (handle->read2_cb) {",
          "1454:           handle->read2_cb(handle, UV_ENOBUFS, &buf, UV_UNKNOWN_HANDLE);",
          "1455:         } else if (handle->read_cb) {",
          "1456:           handle->read_cb((uv_stream_t*) handle, UV_ENOBUFS, &buf);",
          "1457:         }",
          "",
          "[Added Lines]",
          "1485:         handle->read_cb((uv_stream_t*) handle, UV_ENOBUFS, &buf);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1469:           assert(handle->remaining_ipc_rawdata_bytes >= bytes);",
          "1470:           handle->remaining_ipc_rawdata_bytes =",
          "1471:             handle->remaining_ipc_rawdata_bytes - bytes;",
          "1485:         }",
          "1488:         if (bytes <= buf.len) {",
          "",
          "[Removed Lines]",
          "1472:           if (handle->read2_cb) {",
          "1473:             handle->read2_cb(handle, bytes, &buf,",
          "1474:               handle->pending_ipc_info.socket_info ? UV_TCP : UV_UNKNOWN_HANDLE);",
          "1475:           } else if (handle->read_cb) {",
          "1476:             handle->read_cb((uv_stream_t*)handle, bytes, &buf);",
          "1477:           }",
          "1479:           if (handle->pending_ipc_info.socket_info) {",
          "1480:             free(handle->pending_ipc_info.socket_info);",
          "1481:             handle->pending_ipc_info.socket_info = NULL;",
          "1482:           }",
          "1483:         } else {",
          "1484:           handle->read_cb((uv_stream_t*)handle, bytes, &buf);",
          "",
          "[Added Lines]",
          "1501:         handle->read_cb((uv_stream_t*)handle, bytes, &buf);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1859:   free(name_info);",
          "1860:   return err;",
          "1861: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1880: int uv_pipe_pending_count(uv_pipe_t* handle) {",
          "1881:   if (!handle->ipc)",
          "1882:     return 0;",
          "1883:   return handle->pending_ipc_info.queue_len;",
          "1884: }",
          "1887: uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {",
          "1888:   if (!handle->ipc)",
          "1889:     return UV_UNKNOWN_HANDLE;",
          "1890:   if (handle->pending_ipc_info.queue_len == 0)",
          "1891:     return UV_UNKNOWN_HANDLE;",
          "1892:   else",
          "1893:     return UV_TCP;",
          "1894: }",
          "",
          "---------------"
        ],
        "src/win/stream.c||src/win/stream.c": [
          "File: src/win/stream.c -> src/win/stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "116:     default:",
          "117:       assert(0);",
          "118:   }",
          "120:   return uv_translate_sys_error(err);",
          "121: }",
          "124: int uv_read_stop(uv_stream_t* handle) {",
          "125:   int err;",
          "",
          "[Removed Lines]",
          "96: }",
          "99: int uv_read2_start(uv_stream_t* handle, uv_alloc_cb alloc_cb,",
          "100:     uv_read2_cb read_cb) {",
          "101:   int err;",
          "103:   if (handle->flags & UV_HANDLE_READING) {",
          "104:     return UV_EALREADY;",
          "105:   }",
          "107:   if (!(handle->flags & UV_HANDLE_READABLE)) {",
          "108:     return UV_ENOTCONN;",
          "109:   }",
          "111:   err = ERROR_INVALID_PARAMETER;",
          "112:   switch (handle->type) {",
          "113:     case UV_NAMED_PIPE:",
          "114:       err = uv_pipe_read2_start((uv_pipe_t*)handle, alloc_cb, read_cb);",
          "115:       break;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/win/tcp.c||src/win/tcp.c": [
          "File: src/win/tcp.c -> src/win/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1099:     int tcp_connection) {",
          "1100:   int err;",
          "1105:                              socket_protocol_info,",
          "1106:                              0,",
          "1107:                              WSA_FLAG_OVERLAPPED);",
          "",
          "[Removed Lines]",
          "1102:   SOCKET socket = WSASocketW(AF_INET,",
          "1103:                              SOCK_STREAM,",
          "1104:                              IPPROTO_IP,",
          "",
          "[Added Lines]",
          "1102:   SOCKET socket = WSASocketW(FROM_PROTOCOL_INFO,",
          "1103:                              FROM_PROTOCOL_INFO,",
          "1104:                              FROM_PROTOCOL_INFO,",
          "",
          "---------------"
        ],
        "test/benchmark-multi-accept.c||test/benchmark-multi-accept.c": [
          "File: test/benchmark-multi-accept.c -> test/benchmark-multi-accept.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "83: static void ipc_write_cb(uv_write_t* req, int status);",
          "84: static void ipc_close_cb(uv_handle_t* handle);",
          "85: static void ipc_connect_cb(uv_connect_t* req, int status);",
          "90: static void ipc_alloc_cb(uv_handle_t* handle,",
          "91:                          size_t suggested_size,",
          "92:                          uv_buf_t* buf);",
          "",
          "[Removed Lines]",
          "86: static void ipc_read2_cb(uv_pipe_t* ipc_pipe,",
          "87:                          ssize_t nread,",
          "88:                          const uv_buf_t* buf,",
          "89:                          uv_handle_type type);",
          "",
          "[Added Lines]",
          "86: static void ipc_read_cb(uv_stream_t* handle,",
          "87:                         ssize_t nread,",
          "88:                         const uv_buf_t* buf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "155:   struct ipc_client_ctx* ctx;",
          "156:   ctx = container_of(req, struct ipc_client_ctx, connect_req);",
          "157:   ASSERT(0 == status);",
          "161: }",
          "",
          "[Removed Lines]",
          "158:   ASSERT(0 == uv_read2_start((uv_stream_t*) &ctx->ipc_pipe,",
          "159:                              ipc_alloc_cb,",
          "160:                              ipc_read2_cb));",
          "",
          "[Added Lines]",
          "157:   ASSERT(0 == uv_read_start((uv_stream_t*) &ctx->ipc_pipe,",
          "158:                             ipc_alloc_cb,",
          "159:                             ipc_read_cb));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "171: }",
          "178:   struct ipc_client_ctx* ctx;",
          "179:   uv_loop_t* loop;",
          "181:   ctx = container_of(ipc_pipe, struct ipc_client_ctx, ipc_pipe);",
          "182:   loop = ipc_pipe->loop;",
          "184:   if (type == UV_TCP)",
          "185:     ASSERT(0 == uv_tcp_init(loop, (uv_tcp_t*) ctx->server_handle));",
          "186:   else if (type == UV_NAMED_PIPE)",
          "",
          "[Removed Lines]",
          "174: static void ipc_read2_cb(uv_pipe_t* ipc_pipe,",
          "175:                          ssize_t nread,",
          "176:                          const uv_buf_t* buf,",
          "177:                          uv_handle_type type) {",
          "",
          "[Added Lines]",
          "173: static void ipc_read_cb(uv_stream_t* handle,",
          "174:                         ssize_t nread,",
          "175:                         const uv_buf_t* buf) {",
          "178:   uv_handle_type type;",
          "179:   uv_pipe_t* ipc_pipe;",
          "181:   ipc_pipe = (uv_pipe_t*) handle;",
          "185:   ASSERT(1 == uv_pipe_pending_count(ipc_pipe));",
          "186:   type = uv_pipe_pending_type(ipc_pipe);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "188:   else",
          "189:     ASSERT(0);",
          "192:   uv_close((uv_handle_t*) &ctx->ipc_pipe, NULL);",
          "193: }",
          "",
          "[Removed Lines]",
          "191:   ASSERT(0 == uv_accept((uv_stream_t*) &ctx->ipc_pipe, ctx->server_handle));",
          "",
          "[Added Lines]",
          "194:   ASSERT(0 == uv_accept(handle, ctx->server_handle));",
          "",
          "---------------"
        ],
        "test/test-ipc-send-recv.c||test/test-ipc-send-recv.c": [
          "File: test/test-ipc-send-recv.c -> test/test-ipc-send-recv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60: }",
          "64:                     ssize_t nread,",
          "67:   int r;",
          "71:   ASSERT(nread >= 0);",
          "73:   if (pending == UV_NAMED_PIPE)",
          "74:     r = uv_pipe_init(ctx.channel.loop, &ctx.recv.pipe, 0);",
          "",
          "[Removed Lines]",
          "63: static void recv_cb(uv_pipe_t* handle,",
          "65:                     const uv_buf_t* buf,",
          "66:                     uv_handle_type pending) {",
          "69:   ASSERT(pending == ctx.expected_type);",
          "70:   ASSERT(handle == &ctx.channel);",
          "",
          "[Added Lines]",
          "63: static void recv_cb(uv_stream_t* handle,",
          "65:                     const uv_buf_t* buf) {",
          "66:   uv_handle_type pending;",
          "67:   uv_pipe_t* pipe;",
          "70:   pipe = (uv_pipe_t*) handle;",
          "71:   ASSERT(pipe == &ctx.channel);",
          "73:   ASSERT(1 == uv_pipe_pending_count(pipe));",
          "75:   pending = uv_pipe_pending_type(pipe);",
          "76:   ASSERT(pending == ctx.expected_type);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:     abort();",
          "79:   ASSERT(r == 0);",
          "82:   ASSERT(r == 0);",
          "84:   uv_close((uv_handle_t*)&ctx.channel, NULL);",
          "",
          "[Removed Lines]",
          "81:   r = uv_accept((uv_stream_t*)&ctx.channel, &ctx.recv.stream);",
          "",
          "[Added Lines]",
          "86:   r = uv_accept(handle, &ctx.recv.stream);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103:                 NULL);",
          "104:   ASSERT(r == 0);",
          "107:   ASSERT(r == 0);",
          "109:   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "",
          "[Removed Lines]",
          "106:   r = uv_read2_start((uv_stream_t*)&ctx.channel, alloc_cb, recv_cb);",
          "",
          "[Added Lines]",
          "111:   r = uv_read_start((uv_stream_t*)&ctx.channel, alloc_cb, recv_cb);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "165: }",
          "172:   uv_buf_t wrbuf;",
          "173:   int r;",
          "177:   ASSERT(nread >= 0);",
          "179:   wrbuf = uv_buf_init(\".\", 1);",
          "",
          "[Removed Lines]",
          "168: static void read2_cb(uv_pipe_t* handle,",
          "169:                      ssize_t nread,",
          "170:                      const uv_buf_t* rdbuf,",
          "171:                      uv_handle_type pending) {",
          "175:   ASSERT(pending == UV_NAMED_PIPE || pending == UV_TCP);",
          "176:   ASSERT(handle == &ctx.channel);",
          "",
          "[Added Lines]",
          "173: static void read_cb(uv_stream_t* handle,",
          "174:                     ssize_t nread,",
          "175:                     const uv_buf_t* rdbuf) {",
          "177:   uv_pipe_t* pipe;",
          "178:   uv_handle_type pending;",
          "181:   pipe = (uv_pipe_t*) handle;",
          "182:   ASSERT(pipe == &ctx.channel);",
          "184:   ASSERT(1 == uv_pipe_pending_count(pipe));",
          "186:   pending = uv_pipe_pending_type(pipe);",
          "187:   ASSERT(pending == UV_NAMED_PIPE || pending == UV_TCP);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "186:     abort();",
          "187:   ASSERT(r == 0);",
          "190:   ASSERT(r == 0);",
          "192:   r = uv_write2(&ctx.write_req,",
          "",
          "[Removed Lines]",
          "189:   r = uv_accept((uv_stream_t*)handle, &ctx.recv.stream);",
          "",
          "[Added Lines]",
          "199:   r = uv_accept(handle, &ctx.recv.stream);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "215:   ASSERT(1 == uv_is_writable((uv_stream_t*)&ctx.channel));",
          "216:   ASSERT(0 == uv_is_closing((uv_handle_t*)&ctx.channel));",
          "219:   ASSERT(r == 0);",
          "221:   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "",
          "[Removed Lines]",
          "218:   r = uv_read2_start((uv_stream_t*)&ctx.channel, alloc_cb, read2_cb);",
          "",
          "[Added Lines]",
          "228:   r = uv_read_start((uv_stream_t*)&ctx.channel, alloc_cb, read_cb);",
          "",
          "---------------"
        ],
        "test/test-ipc.c||test/test-ipc.c": [
          "File: test/test-ipc.c -> test/test-ipc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: static uv_tcp_t tcp_connection;",
          "32: static int exit_cb_called;",
          "34: static int tcp_write_cb_called;",
          "35: static int tcp_read_cb_called;",
          "36: static int on_pipe_read_called;",
          "",
          "[Removed Lines]",
          "33: static int read2_cb_called;",
          "",
          "[Added Lines]",
          "33: static int read_cb_called;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138: }",
          "142:                     ssize_t nread,",
          "145:   int r;",
          "146:   uv_buf_t outbuf;",
          "148:   if (nread == 0) {",
          "150:     free(buf->base);",
          "",
          "[Removed Lines]",
          "141: static void on_read(uv_pipe_t* pipe,",
          "143:                     const uv_buf_t* buf,",
          "144:                     uv_handle_type pending) {",
          "",
          "[Added Lines]",
          "141: static void on_read(uv_stream_t* handle,",
          "143:                     const uv_buf_t* buf) {",
          "145:   uv_pipe_t* pipe;",
          "146:   uv_handle_type pending;",
          "149:   pipe = (uv_pipe_t*) handle;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "164:   fprintf(stderr, \"got %d bytes\\n\", (int)nread);",
          "166:   if (!tcp_server_listening) {",
          "167:     ASSERT(nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE);",
          "171:     ASSERT(pending == UV_TCP);",
          "",
          "[Removed Lines]",
          "168:     read2_cb_called++;",
          "",
          "[Added Lines]",
          "169:   pending = uv_pipe_pending_type(pipe);",
          "171:     ASSERT(1 == uv_pipe_pending_count(pipe));",
          "173:     read_cb_called++;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191:     make_many_connections();",
          "192:   } else if (memcmp(\"accepted_connection\\n\", buf->base, nread) == 0) {",
          "194:     ASSERT(pending == UV_UNKNOWN_HANDLE);",
          "195:     remote_conn_accepted = 1;",
          "196:     uv_close((uv_handle_t*)&channel, NULL);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "199:     ASSERT(0 == uv_pipe_pending_count(pipe));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "267: }",
          "271:                                ssize_t nread,",
          "274:   int r;",
          "275:   uv_buf_t outbuf;",
          "277:   if (nread == 0) {",
          "279:     free(buf->base);",
          "",
          "[Removed Lines]",
          "270: static void on_read_connection(uv_pipe_t* pipe,",
          "272:                                const uv_buf_t* buf,",
          "273:                                uv_handle_type pending) {",
          "",
          "[Added Lines]",
          "276: static void on_read_connection(uv_stream_t* handle,",
          "278:                                const uv_buf_t* buf) {",
          "281:   uv_pipe_t* pipe;",
          "282:   uv_handle_type pending;",
          "284:   pipe = (uv_pipe_t*) handle;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "293:   fprintf(stderr, \"got %d bytes\\n\", (int)nread);",
          "295:   ASSERT(nread > 0 && buf->base && pending != UV_UNKNOWN_HANDLE);",
          "299:   ASSERT(pending == UV_TCP);",
          "300:   r = uv_tcp_init(uv_default_loop(), &tcp_connection);",
          "301:   ASSERT(r == 0);",
          "304:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "296:   read2_cb_called++;",
          "303:   r = uv_accept((uv_stream_t*)pipe, (uv_stream_t*)&tcp_connection);",
          "",
          "[Added Lines]",
          "303:   ASSERT(1 == uv_pipe_pending_count(pipe));",
          "304:   pending = uv_pipe_pending_type(pipe);",
          "307:   read_cb_called++;",
          "314:   r = uv_accept(handle, (uv_stream_t*)&tcp_connection);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "319: }",
          "323:   uv_process_t process;",
          "324:   int r;",
          "326:   spawn_helper(&channel, &process, helper);",
          "329:   r = uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "330:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "322: static int run_ipc_test(const char* helper, uv_read2_cb read_cb) {",
          "327:   uv_read2_start((uv_stream_t*)&channel, on_alloc, read_cb);",
          "",
          "[Added Lines]",
          "333: static int run_ipc_test(const char* helper, uv_read_cb read_cb) {",
          "338:   uv_read_start((uv_stream_t*)&channel, on_alloc, read_cb);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "338:   int r = run_ipc_test(\"ipc_helper_listen_before_write\", on_read);",
          "339:   ASSERT(local_conn_accepted == 1);",
          "340:   ASSERT(remote_conn_accepted == 1);",
          "342:   ASSERT(exit_cb_called == 1);",
          "343:   return r;",
          "344: }",
          "",
          "[Removed Lines]",
          "341:   ASSERT(read2_cb_called == 1);",
          "",
          "[Added Lines]",
          "352:   ASSERT(read_cb_called == 1);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "348:   int r = run_ipc_test(\"ipc_helper_listen_after_write\", on_read);",
          "349:   ASSERT(local_conn_accepted == 1);",
          "350:   ASSERT(remote_conn_accepted == 1);",
          "352:   ASSERT(exit_cb_called == 1);",
          "353:   return r;",
          "354: }",
          "",
          "[Removed Lines]",
          "351:   ASSERT(read2_cb_called == 1);",
          "",
          "[Added Lines]",
          "362:   ASSERT(read_cb_called == 1);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "357: TEST_IMPL(ipc_tcp_connection) {",
          "358:   int r = run_ipc_test(\"ipc_helper_tcp_connection\", on_read_connection);",
          "360:   ASSERT(tcp_write_cb_called == 1);",
          "361:   ASSERT(tcp_read_cb_called == 1);",
          "362:   ASSERT(exit_cb_called == 1);",
          "",
          "[Removed Lines]",
          "359:   ASSERT(read2_cb_called == 1);",
          "",
          "[Added Lines]",
          "370:   ASSERT(read_cb_called == 1);",
          "",
          "---------------"
        ],
        "test/test-list.h||test/test-list.h": [
          "File: test/test-list.h -> test/test-list.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "96: TEST_DECLARE   (pipe_connect_to_file)",
          "97: TEST_DECLARE   (pipe_getsockname)",
          "98: TEST_DECLARE   (pipe_getsockname_abstract)",
          "99: TEST_DECLARE   (pipe_server_close)",
          "100: TEST_DECLARE   (connection_fail)",
          "101: TEST_DECLARE   (connection_fail_doesnt_auto_close)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "99: TEST_DECLARE   (pipe_sendmsg)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "362:   TEST_ENTRY  (pipe_listen_without_bind)",
          "363:   TEST_ENTRY  (pipe_getsockname)",
          "364:   TEST_ENTRY  (pipe_getsockname_abstract)",
          "366:   TEST_ENTRY  (connection_fail)",
          "367:   TEST_ENTRY  (connection_fail_doesnt_auto_close)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "366:   TEST_ENTRY  (pipe_sendmsg)",
          "",
          "---------------"
        ],
        "test/test-pipe-sendmsg.c||test/test-pipe-sendmsg.c": [
          "File: test/test-pipe-sendmsg.c -> test/test-pipe-sendmsg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include \"uv.h\"",
          "23: #include \"task.h\"",
          "26: #ifndef _WIN32",
          "28: #include <fcntl.h>",
          "29: #include <errno.h>",
          "30: #include <stdio.h>",
          "31: #include <stdlib.h>",
          "32: #include <string.h>",
          "33: #include <sys/socket.h>",
          "34: #include <unistd.h>",
          "38: static uv_pipe_t incoming[4];",
          "39: static unsigned int incoming_count;",
          "40: static unsigned int close_called;",
          "43: static void set_nonblocking(uv_os_sock_t sock) {",
          "44:   int r;",
          "45: #ifdef _WIN32",
          "46:   unsigned long on = 1;",
          "47:   r = ioctlsocket(sock, FIONBIO, &on);",
          "48:   ASSERT(r == 0);",
          "49: #else",
          "50:   int flags = fcntl(sock, F_GETFL, 0);",
          "51:   ASSERT(flags >= 0);",
          "52:   r = fcntl(sock, F_SETFL, flags | O_NONBLOCK);",
          "53:   ASSERT(r >= 0);",
          "54: #endif",
          "55: }",
          "60: static void close_cb(uv_handle_t* handle) {",
          "61:   close_called++;",
          "62: }",
          "65: static void alloc_cb(uv_handle_t* handle, size_t size, uv_buf_t* buf) {",
          "66:   static char base[1];",
          "68:   buf->base = base;",
          "69:   buf->len = sizeof(base);",
          "70: }",
          "73: static void read_cb(uv_stream_t* handle,",
          "74:                     ssize_t nread,",
          "75:                     const uv_buf_t* buf) {",
          "76:   uv_pipe_t* p;",
          "77:   uv_pipe_t* inc;",
          "78:   uv_handle_type pending;",
          "79:   unsigned int i;",
          "81:   p = (uv_pipe_t*) handle;",
          "82:   ASSERT(nread >= 0);",
          "84:   while (uv_pipe_pending_count(p) != 0) {",
          "85:     pending = uv_pipe_pending_type(p);",
          "86:     ASSERT(pending == UV_NAMED_PIPE);",
          "88:     ASSERT(incoming_count < ARRAY_SIZE(incoming));",
          "89:     inc = &incoming[incoming_count++];",
          "90:     ASSERT(0 == uv_pipe_init(p->loop, inc, 0));",
          "91:     ASSERT(0 == uv_accept(handle, (uv_stream_t*) inc));",
          "92:   }",
          "94:   if (incoming_count != ARRAY_SIZE(incoming))",
          "95:     return;",
          "97:   ASSERT(0 == uv_read_stop((uv_stream_t*) p));",
          "98:   uv_close((uv_handle_t*) p, close_cb);",
          "99:   for (i = 0; i < ARRAY_SIZE(incoming); i++)",
          "100:     uv_close((uv_handle_t*) &incoming[i], close_cb);",
          "101: }",
          "104: TEST_IMPL(pipe_sendmsg) {",
          "105:   uv_pipe_t p;",
          "106:   int r;",
          "107:   int fds[2];",
          "108:   int send_fds[ARRAY_SIZE(incoming)];",
          "109:   struct msghdr msg;",
          "110:   char scratch[64];",
          "111:   struct cmsghdr *cmsg;",
          "112:   unsigned int i;",
          "113:   uv_buf_t buf;",
          "115:   ASSERT(0 == socketpair(AF_UNIX, SOCK_STREAM, 0, fds));",
          "116:   for (i = 0; i < ARRAY_SIZE(send_fds); i += 2)",
          "117:     ASSERT(0 == socketpair(AF_UNIX, SOCK_STREAM, 0, send_fds + i));",
          "118:   ASSERT(i == ARRAY_SIZE(send_fds));",
          "119:   ASSERT(0 == uv_pipe_init(uv_default_loop(), &p, 1));",
          "120:   ASSERT(0 == uv_pipe_open(&p, fds[1]));",
          "122:   buf = uv_buf_init(\"X\", 1);",
          "123:   memset(&msg, 0, sizeof(msg));",
          "124:   msg.msg_iov = (struct iovec*) &buf;",
          "125:   msg.msg_iovlen = 1;",
          "126:   msg.msg_flags = 0;",
          "128:   msg.msg_control = (void*) scratch;",
          "129:   msg.msg_controllen = CMSG_LEN(sizeof(send_fds));",
          "130:   ASSERT(sizeof(scratch) >= msg.msg_controllen);",
          "132:   cmsg = CMSG_FIRSTHDR(&msg);",
          "133:   cmsg->cmsg_level = SOL_SOCKET;",
          "134:   cmsg->cmsg_type = SCM_RIGHTS;",
          "135:   cmsg->cmsg_len = msg.msg_controllen;",
          "138:   {",
          "139:     void* pv = CMSG_DATA(cmsg);",
          "140:     int* pi = pv;",
          "141:     for (i = 0; i < ARRAY_SIZE(send_fds); i++)",
          "142:       pi[i] = send_fds[i];",
          "143:   }",
          "145:   set_nonblocking(fds[1]);",
          "146:   ASSERT(0 == uv_read_start((uv_stream_t*) &p, alloc_cb, read_cb));",
          "148:   do",
          "149:     r = sendmsg(fds[0], &msg, 0);",
          "150:   while (r == -1 && errno == EINTR);",
          "151:   ASSERT(r == 1);",
          "153:   uv_run(uv_default_loop(), UV_RUN_DEFAULT);",
          "154:   ASSERT(ARRAY_SIZE(incoming) == incoming_count);",
          "155:   ASSERT(ARRAY_SIZE(incoming) + 1 == close_called);",
          "156:   close(fds[0]);",
          "158:   MAKE_VALGRIND_HAPPY();",
          "159:   return 0;",
          "160: }",
          "164: TEST_IMPL(pipe_sendmsg) {",
          "165:   MAKE_VALGRIND_HAPPY();",
          "166:   return 0;",
          "167: }",
          "",
          "---------------"
        ],
        "uv.gyp||uv.gyp": [
          "File: uv.gyp -> uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "338:         'test/test-pipe-bind-error.c',",
          "339:         'test/test-pipe-connect-error.c',",
          "340:         'test/test-pipe-getsockname.c',",
          "341:         'test/test-pipe-server-close.c',",
          "342:         'test/test-platform-output.c',",
          "343:         'test/test-poll.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341:         'test/test-pipe-sendmsg.c',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "616167e149be17f459e6a08fec0e3170802eb595",
      "candidate_info": {
        "commit_hash": "616167e149be17f459e6a08fec0e3170802eb595",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/616167e149be17f459e6a08fec0e3170802eb595",
        "files": [
          "src/win/fs.c"
        ],
        "message": "win: fix C99/C++ comment\n\nThis commit converts C++ style comment to C style comment",
        "before_after_code_files": [
          "src/win/fs.c||src/win/fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/win/fs.c||src/win/fs.c": [
          "File: src/win/fs.c -> src/win/fs.c"
        ]
      }
    },
    {
      "candidate_hash": "977e8337baecb3a0174e5694d1840fce21798d78",
      "candidate_info": {
        "commit_hash": "977e8337baecb3a0174e5694d1840fce21798d78",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/977e8337baecb3a0174e5694d1840fce21798d78",
        "files": [
          "Makefile.mingw",
          "src/win/fs.c",
          "src/win/pipe.c",
          "src/win/tcp.c",
          "src/win/util.c"
        ],
        "message": "build: add mingw makefile\n\n* add a very simple Makefile.mingw that builds libuv.a\n* apply a couple of fixes to src/win so it actually builds with mingw\n  (mostly missing includes)\n\nFixes #847.",
        "before_after_code_files": [
          "Makefile.mingw||Makefile.mingw",
          "src/win/fs.c||src/win/fs.c",
          "src/win/pipe.c||src/win/pipe.c",
          "src/win/tcp.c||src/win/tcp.c",
          "src/win/util.c||src/win/util.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "Makefile.mingw||Makefile.mingw": [
          "File: Makefile.mingw -> Makefile.mingw",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>",
          "2: #",
          "3: # Permission to use, copy, modify, and/or distribute this software for any",
          "4: # purpose with or without fee is hereby granted, provided that the above",
          "5: # copyright notice and this permission notice appear in all copies.",
          "6: #",
          "7: # THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES",
          "8: # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF",
          "9: # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR",
          "10: # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES",
          "11: # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN",
          "12: # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF",
          "13: # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
          "15: CFLAGS = -Wall \\",
          "16:          -Wextra \\",
          "17:          -Wno-unused-parameter \\",
          "18:          -Iinclude \\",
          "19:          -Isrc \\",
          "20:          -Isrc/win \\",
          "21:          -DWIN32_LEAN_AND_MEAN \\",
          "22:          -D_WIN32_WINNT=0x0600",
          "24: INCLUDES = include/stdint-msvc2008.h \\",
          "25:            include/tree.h \\",
          "26:            include/uv-errno.h \\",
          "27:            include/uv-win.h \\",
          "28:            include/uv.h \\",
          "29:            src/queue.h \\",
          "30:            src/uv-common.h \\",
          "31:            src/win/atomicops-inl.h \\",
          "32:            src/win/handle-inl.h \\",
          "33:            src/win/internal.h \\",
          "34:            src/win/req-inl.h \\",
          "35:            src/win/stream-inl.h \\",
          "36:            src/win/winapi.h \\",
          "37:            src/win/winsock.h",
          "39: OBJS = src/fs-poll.o \\",
          "40:        src/inet.o \\",
          "41:        src/uv-common.o \\",
          "42:        src/version.o \\",
          "43:        src/win/async.o \\",
          "44:        src/win/core.o \\",
          "45:        src/win/dl.o \\",
          "46:        src/win/error.o \\",
          "47:        src/win/fs-event.o \\",
          "48:        src/win/fs.o \\",
          "49:        src/win/getaddrinfo.o \\",
          "50:        src/win/handle.o \\",
          "51:        src/win/loop-watcher.o \\",
          "52:        src/win/pipe.o \\",
          "53:        src/win/poll.o \\",
          "54:        src/win/process-stdio.o \\",
          "55:        src/win/process.o \\",
          "56:        src/win/req.o \\",
          "57:        src/win/signal.o \\",
          "58:        src/win/stream.o \\",
          "59:        src/win/tcp.o \\",
          "60:        src/win/thread.o \\",
          "61:        src/win/threadpool.o \\",
          "62:        src/win/timer.o \\",
          "63:        src/win/tty.o \\",
          "64:        src/win/udp.o \\",
          "65:        src/win/util.o \\",
          "66:        src/win/winapi.o \\",
          "67:        src/win/winsock.o",
          "69: all: libuv.a",
          "71: libuv.a: $(OBJS)",
          "72:  $(AR) crs $@ $^",
          "74: # FIXME(bnoordhuis) Don't rebuild everything when a source file changes.",
          "75: $(OBJS): $(OBJS:.o=.c) $(INCLUDES)",
          "",
          "---------------"
        ],
        "src/win/fs.c||src/win/fs.c": [
          "File: src/win/fs.c -> src/win/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include <assert.h>",
          "23: #include <malloc.h>",
          "24: #include <direct.h>",
          "25: #include <errno.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include <stdlib.h>",
          "",
          "---------------"
        ],
        "src/win/pipe.c||src/win/pipe.c": [
          "File: src/win/pipe.c -> src/win/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include <io.h>",
          "24: #include <string.h>",
          "25: #include <stdio.h>",
          "27: #include \"uv.h\"",
          "28: #include \"internal.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include <stdlib.h>",
          "",
          "---------------"
        ],
        "src/win/tcp.c||src/win/tcp.c": [
          "File: src/win/tcp.c -> src/win/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22: #include <assert.h>",
          "24: #include \"uv.h\"",
          "25: #include \"internal.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: #include <stdlib.h>",
          "",
          "---------------"
        ],
        "src/win/util.c||src/win/util.c": [
          "File: src/win/util.c -> src/win/util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"internal.h\"",
          "34: #include <winsock2.h>",
          "35: #include <iphlpapi.h>",
          "36: #include <psapi.h>",
          "37: #include <tlhelp32.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35: #include <winperf.h>",
          "",
          "---------------"
        ]
      }
    }
  ]
}
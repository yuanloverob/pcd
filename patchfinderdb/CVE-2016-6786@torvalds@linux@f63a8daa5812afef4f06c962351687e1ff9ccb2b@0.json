{
  "cve_id": "CVE-2016-6786",
  "cve_desc": "kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 30955111.",
  "repo": "torvalds/linux",
  "patch_hash": "f63a8daa5812afef4f06c962351687e1ff9ccb2b",
  "patch_info": {
    "commit_hash": "f63a8daa5812afef4f06c962351687e1ff9ccb2b",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b",
    "files": [
      "kernel/events/core.c"
    ],
    "message": "perf: Fix event->ctx locking\n\nThere have been a few reported issues wrt. the lack of locking around\nchanging event->ctx. This patch tries to address those.\n\nIt avoids the whole rwsem thing; and while it appears to work, please\ngive it some thought in review.\n\nWhat I did fail at is sensible runtime checks on the use of\nevent->ctx, the RCU use makes it very hard.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nLink: http://lkml.kernel.org/r/20150123125834.209535886@infradead.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
    "before_after_code_files": [
      "kernel/events/core.c||kernel/events/core.c"
    ]
  },
  "patch_diff": {
    "kernel/events/core.c||kernel/events/core.c": [
      "File: kernel/events/core.c -> kernel/events/core.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "906:  }",
      "907: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "950: static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)",
      "951: {",
      "952:  struct perf_event_context *ctx;",
      "954: again:",
      "955:  rcu_read_lock();",
      "956:  ctx = ACCESS_ONCE(event->ctx);",
      "957:  if (!atomic_inc_not_zero(&ctx->refcount)) {",
      "958:   rcu_read_unlock();",
      "959:   goto again;",
      "960:  }",
      "961:  rcu_read_unlock();",
      "963:  mutex_lock(&ctx->mutex);",
      "964:  if (event->ctx != ctx) {",
      "965:   mutex_unlock(&ctx->mutex);",
      "966:   put_ctx(ctx);",
      "967:   goto again;",
      "968:  }",
      "970:  return ctx;",
      "971: }",
      "973: static void perf_event_ctx_unlock(struct perf_event *event,",
      "974:       struct perf_event_context *ctx)",
      "975: {",
      "976:  mutex_unlock(&ctx->mutex);",
      "977:  put_ctx(ctx);",
      "978: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1670: {",
      "1671:  struct perf_event_context *ctx = event->ctx;",
      "1672:  struct task_struct *task = ctx->task;",
      "",
      "[Removed Lines]",
      "1669: void perf_event_disable(struct perf_event *event)",
      "",
      "[Added Lines]",
      "1740: static void _perf_event_disable(struct perf_event *event)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1707:  }",
      "1708:  raw_spin_unlock_irq(&ctx->lock);",
      "1709: }",
      "1710: EXPORT_SYMBOL_GPL(perf_event_disable);",
      "1712: static void perf_set_shadow_time(struct perf_event *event,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1786: void perf_event_disable(struct perf_event *event)",
      "1787: {",
      "1788:  struct perf_event_context *ctx;",
      "1790:  ctx = perf_event_ctx_lock(event);",
      "1791:  _perf_event_disable(event);",
      "1792:  perf_event_ctx_unlock(event, ctx);",
      "1793: }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2174: {",
      "2175:  struct perf_event_context *ctx = event->ctx;",
      "2176:  struct task_struct *task = ctx->task;",
      "",
      "[Removed Lines]",
      "2173: void perf_event_enable(struct perf_event *event)",
      "",
      "[Added Lines]",
      "2257: static void _perf_event_enable(struct perf_event *event)",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2226: out:",
      "2227:  raw_spin_unlock_irq(&ctx->lock);",
      "2228: }",
      "2229: EXPORT_SYMBOL_GPL(perf_event_enable);",
      "2232: {",
      "",
      "[Removed Lines]",
      "2231: int perf_event_refresh(struct perf_event *event, int refresh)",
      "",
      "[Added Lines]",
      "2317: void perf_event_enable(struct perf_event *event)",
      "2318: {",
      "2319:  struct perf_event_context *ctx;",
      "2321:  ctx = perf_event_ctx_lock(event);",
      "2322:  _perf_event_enable(event);",
      "2323:  perf_event_ctx_unlock(event, ctx);",
      "2324: }",
      "2327: static int _perf_event_refresh(struct perf_event *event, int refresh)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2237:   return -EINVAL;",
      "2239:  atomic_add(refresh, &event->event_limit);",
      "2242:  return 0;",
      "2243: }",
      "2244: EXPORT_SYMBOL_GPL(perf_event_refresh);",
      "2246: static void ctx_sched_out(struct perf_event_context *ctx,",
      "",
      "[Removed Lines]",
      "2240:  perf_event_enable(event);",
      "",
      "[Added Lines]",
      "2336:  _perf_event_enable(event);",
      "2344: int perf_event_refresh(struct perf_event *event, int refresh)",
      "2345: {",
      "2346:  struct perf_event_context *ctx;",
      "2347:  int ret;",
      "2349:  ctx = perf_event_ctx_lock(event);",
      "2350:  ret = _perf_event_refresh(event, refresh);",
      "2351:  perf_event_ctx_unlock(event, ctx);",
      "2353:  return ret;",
      "2354: }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "3433:  rcu_read_unlock();",
      "3435:  if (owner) {",
      "",
      "[Removed Lines]",
      "3436:   mutex_lock(&owner->perf_event_mutex);",
      "",
      "[Added Lines]",
      "3555:   mutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "3559:        u64 read_format, char __user *buf)",
      "3560: {",
      "3561:  struct perf_event *leader = event->group_leader, *sub;",
      "3563:  struct perf_event_context *ctx = leader->ctx;",
      "3565:  u64 count, enabled, running;",
      "3568:  count = perf_event_read_value(leader, &enabled, &running);",
      "3570:  values[n++] = 1 + leader->nr_siblings;",
      "",
      "[Removed Lines]",
      "3562:  int n = 0, size = 0, ret = -EFAULT;",
      "3564:  u64 values[5];",
      "3567:  mutex_lock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "3683:  int n = 0, size = 0, ret;",
      "3685:  u64 values[5];",
      "3687:  lockdep_assert_held(&ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "3579:  size = n * sizeof(u64);",
      "3581:  if (copy_to_user(buf, values, size))",
      "3584:  ret = size;",
      "",
      "[Removed Lines]",
      "3582:   goto unlock;",
      "",
      "[Added Lines]",
      "3703:   return -EFAULT;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "3593:   size = n * sizeof(u64);",
      "3595:   if (copy_to_user(buf + ret, values, size)) {",
      "3598:   }",
      "3600:   ret += size;",
      "3601:  }",
      "3605:  return ret;",
      "3606: }",
      "",
      "[Removed Lines]",
      "3596:    ret = -EFAULT;",
      "3597:    goto unlock;",
      "3602: unlock:",
      "3603:  mutex_unlock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "3717:    return -EFAULT;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "3672: perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)",
      "3673: {",
      "3674:  struct perf_event *event = file->private_data;",
      "3677: }",
      "3679: static unsigned int perf_poll(struct file *file, poll_table *wait)",
      "",
      "[Removed Lines]",
      "3676:  return perf_read_hw(event, buf, count);",
      "",
      "[Added Lines]",
      "3793:  struct perf_event_context *ctx;",
      "3794:  int ret;",
      "3796:  ctx = perf_event_ctx_lock(event);",
      "3797:  ret = perf_read_hw(event, buf, count);",
      "3798:  perf_event_ctx_unlock(event, ctx);",
      "3800:  return ret;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "3699:  return events;",
      "3700: }",
      "3703: {",
      "3704:  (void)perf_event_read(event);",
      "3705:  local64_set(&event->count, 0);",
      "",
      "[Removed Lines]",
      "3702: static void perf_event_reset(struct perf_event *event)",
      "",
      "[Added Lines]",
      "3826: static void _perf_event_reset(struct perf_event *event)",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "3731:  struct perf_event_context *ctx = event->ctx;",
      "3732:  struct perf_event *sibling;",
      "3736:  event = event->group_leader;",
      "3738:  perf_event_for_each_child(event, func);",
      "3739:  list_for_each_entry(sibling, &event->sibling_list, group_entry)",
      "3740:   perf_event_for_each_child(sibling, func);",
      "3742: }",
      "3744: static int perf_event_period(struct perf_event *event, u64 __user *arg)",
      "",
      "[Removed Lines]",
      "3734:  WARN_ON_ONCE(ctx->parent_ctx);",
      "3735:  mutex_lock(&ctx->mutex);",
      "3741:  mutex_unlock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "3859:  lockdep_assert_held(&ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "3808:      struct perf_event *output_event);",
      "3809: static int perf_event_set_filter(struct perf_event *event, void __user *arg);",
      "3812: {",
      "3814:  void (*func)(struct perf_event *);",
      "3815:  u32 flags = arg;",
      "3817:  switch (cmd) {",
      "3818:  case PERF_EVENT_IOC_ENABLE:",
      "3820:   break;",
      "3821:  case PERF_EVENT_IOC_DISABLE:",
      "3823:   break;",
      "3824:  case PERF_EVENT_IOC_RESET:",
      "3826:   break;",
      "3828:  case PERF_EVENT_IOC_REFRESH:",
      "3831:  case PERF_EVENT_IOC_PERIOD:",
      "3832:   return perf_event_period(event, (u64 __user *)arg);",
      "",
      "[Removed Lines]",
      "3811: static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
      "3813:  struct perf_event *event = file->private_data;",
      "3819:   func = perf_event_enable;",
      "3822:   func = perf_event_disable;",
      "3825:   func = perf_event_reset;",
      "3829:   return perf_event_refresh(event, arg);",
      "",
      "[Added Lines]",
      "3935: static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)",
      "3942:   func = _perf_event_enable;",
      "3945:   func = _perf_event_disable;",
      "3948:   func = _perf_event_reset;",
      "3952:   return _perf_event_refresh(event, arg);",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "3873:  return 0;",
      "3874: }",
      "3876: #ifdef CONFIG_COMPAT",
      "3877: static long perf_compat_ioctl(struct file *file, unsigned int cmd,",
      "3878:     unsigned long arg)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3999: static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)",
      "4000: {",
      "4001:  struct perf_event *event = file->private_data;",
      "4002:  struct perf_event_context *ctx;",
      "4003:  long ret;",
      "4005:  ctx = perf_event_ctx_lock(event);",
      "4006:  ret = _perf_ioctl(event, cmd, arg);",
      "4007:  perf_event_ctx_unlock(event, ctx);",
      "4009:  return ret;",
      "4010: }",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "3896: int perf_event_task_enable(void)",
      "3897: {",
      "3898:  struct perf_event *event;",
      "3900:  mutex_lock(&current->perf_event_mutex);",
      "3903:  mutex_unlock(&current->perf_event_mutex);",
      "3905:  return 0;",
      "",
      "[Removed Lines]",
      "3901:  list_for_each_entry(event, &current->perf_event_list, owner_entry)",
      "3902:   perf_event_for_each_child(event, perf_event_enable);",
      "",
      "[Added Lines]",
      "4034:  struct perf_event_context *ctx;",
      "4038:  list_for_each_entry(event, &current->perf_event_list, owner_entry) {",
      "4039:   ctx = perf_event_ctx_lock(event);",
      "4040:   perf_event_for_each_child(event, _perf_event_enable);",
      "4041:   perf_event_ctx_unlock(event, ctx);",
      "4042:  }",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "3908: int perf_event_task_disable(void)",
      "3909: {",
      "3910:  struct perf_event *event;",
      "3912:  mutex_lock(&current->perf_event_mutex);",
      "3915:  mutex_unlock(&current->perf_event_mutex);",
      "3917:  return 0;",
      "",
      "[Removed Lines]",
      "3913:  list_for_each_entry(event, &current->perf_event_list, owner_entry)",
      "3914:   perf_event_for_each_child(event, perf_event_disable);",
      "",
      "[Added Lines]",
      "4050:  struct perf_event_context *ctx;",
      "4054:  list_for_each_entry(event, &current->perf_event_list, owner_entry) {",
      "4055:   ctx = perf_event_ctx_lock(event);",
      "4056:   perf_event_for_each_child(event, _perf_event_disable);",
      "4057:   perf_event_ctx_unlock(event, ctx);",
      "4058:  }",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "7269:  return ret;",
      "7270: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7416: static void mutex_lock_double(struct mutex *a, struct mutex *b)",
      "7417: {",
      "7418:  if (b < a)",
      "7419:   swap(a, b);",
      "7421:  mutex_lock(a);",
      "7422:  mutex_lock_nested(b, SINGLE_DEPTH_NESTING);",
      "7423: }",
      "",
      "---------------",
      "--- Hunk 19 ---",
      "[Context before]",
      "7284:  struct perf_event *group_leader = NULL, *output_event = NULL;",
      "7285:  struct perf_event *event, *sibling;",
      "7286:  struct perf_event_attr attr;",
      "7288:  struct file *event_file = NULL;",
      "7289:  struct fd group = {NULL, 0};",
      "7290:  struct task_struct *task = NULL;",
      "",
      "[Removed Lines]",
      "7287:  struct perf_event_context *ctx;",
      "",
      "[Added Lines]",
      "7440:  struct perf_event_context *ctx, *uninitialized_var(gctx);",
      "",
      "---------------",
      "--- Hunk 20 ---",
      "[Context before]",
      "7482:  }",
      "7484:  if (move_group) {",
      "7488:   perf_remove_from_context(group_leader, false);",
      "",
      "[Removed Lines]",
      "7485:   struct perf_event_context *gctx = group_leader->ctx;",
      "7487:   mutex_lock(&gctx->mutex);",
      "",
      "[Added Lines]",
      "7638:   gctx = group_leader->ctx;",
      "7644:   mutex_lock_double(&gctx->mutex, &ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 21 ---",
      "[Context before]",
      "7499:    perf_event__state_init(sibling);",
      "7500:    put_ctx(gctx);",
      "7501:   }",
      "7504:  }",
      "7506:  WARN_ON_ONCE(ctx->parent_ctx);",
      "7509:  if (move_group) {",
      "7510:   synchronize_rcu();",
      "7511:   perf_install_in_context(ctx, group_leader, group_leader->cpu);",
      "7512:   get_ctx(ctx);",
      "7513:   list_for_each_entry(sibling, &group_leader->sibling_list,",
      "",
      "[Removed Lines]",
      "7502:   mutex_unlock(&gctx->mutex);",
      "7503:   put_ctx(gctx);",
      "7507:  mutex_lock(&ctx->mutex);",
      "",
      "[Added Lines]",
      "7660:  } else {",
      "7661:   mutex_lock(&ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 22 ---",
      "[Context before]",
      "7520:  perf_install_in_context(ctx, event, event->cpu);",
      "7521:  perf_unpin_context(ctx);",
      "7522:  mutex_unlock(&ctx->mutex);",
      "7524:  put_online_cpus();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7685:  if (move_group) {",
      "7686:   mutex_unlock(&gctx->mutex);",
      "7687:   put_ctx(gctx);",
      "7688:  }",
      "",
      "---------------",
      "--- Hunk 23 ---",
      "[Context before]",
      "7626:  src_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;",
      "7627:  dst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;",
      "7630:  list_for_each_entry_safe(event, tmp, &src_ctx->event_list,",
      "7631:      event_entry) {",
      "7632:   perf_remove_from_context(event, false);",
      "",
      "[Removed Lines]",
      "7629:  mutex_lock(&src_ctx->mutex);",
      "",
      "[Added Lines]",
      "7800:  mutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);",
      "",
      "---------------",
      "--- Hunk 24 ---",
      "[Context before]",
      "7634:   put_ctx(src_ctx);",
      "7635:   list_add(&event->migrate_entry, &events);",
      "7636:  }",
      "7639:  synchronize_rcu();",
      "7642:  list_for_each_entry_safe(event, tmp, &events, migrate_entry) {",
      "7643:   list_del(&event->migrate_entry);",
      "7644:   if (event->state >= PERF_EVENT_STATE_OFF)",
      "",
      "[Removed Lines]",
      "7637:  mutex_unlock(&src_ctx->mutex);",
      "7641:  mutex_lock(&dst_ctx->mutex);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 25 ---",
      "[Context before]",
      "7648:   get_ctx(dst_ctx);",
      "7649:  }",
      "7650:  mutex_unlock(&dst_ctx->mutex);",
      "7651: }",
      "7652: EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7820:  mutex_unlock(&src_ctx->mutex);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fa8c269353d560b7c28119ad7617029f92e40b15",
      "candidate_info": {
        "commit_hash": "fa8c269353d560b7c28119ad7617029f92e40b15",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fa8c269353d560b7c28119ad7617029f92e40b15",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf/core: Invert perf_read_group() loops\n\nIn order to enable the use of perf_event_read(.group = true), we need\nto invert the sibling-child loop nesting of perf_read_group().\n\nCurrently we iterate the child list for each sibling, this precludes\nusing group reads. Flip things around so we iterate each group for\neach child.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\n[ Made the patch compile and things. ]\nSigned-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Michael Ellerman <mpe@ellerman.id.au>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nLink: http://lkml.kernel.org/r/1441336073-22750-7-git-send-email-sukadev@linux.vnet.ibm.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3862: }",
          "3863: EXPORT_SYMBOL_GPL(perf_event_read_value);",
          "3867: {",
          "3884:  if (read_format & PERF_FORMAT_ID)",
          "3885:   values[n++] = primary_event_id(leader);",
          "3910:  return ret;",
          "3911: }",
          "",
          "[Removed Lines]",
          "3865: static int perf_read_group(struct perf_event *event,",
          "3866:        u64 read_format, char __user *buf)",
          "3868:  struct perf_event *leader = event->group_leader, *sub;",
          "3869:  struct perf_event_context *ctx = leader->ctx;",
          "3870:  int n = 0, size = 0, ret;",
          "3871:  u64 count, enabled, running;",
          "3872:  u64 values[5];",
          "3874:  lockdep_assert_held(&ctx->mutex);",
          "3876:  count = perf_event_read_value(leader, &enabled, &running);",
          "3878:  values[n++] = 1 + leader->nr_siblings;",
          "3879:  if (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED)",
          "3880:   values[n++] = enabled;",
          "3881:  if (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING)",
          "3882:   values[n++] = running;",
          "3883:  values[n++] = count;",
          "3887:  size = n * sizeof(u64);",
          "3889:  if (copy_to_user(buf, values, size))",
          "3890:   return -EFAULT;",
          "3892:  ret = size;",
          "3894:  list_for_each_entry(sub, &leader->sibling_list, group_entry) {",
          "3895:   n = 0;",
          "3897:   values[n++] = perf_event_read_value(sub, &enabled, &running);",
          "3898:   if (read_format & PERF_FORMAT_ID)",
          "3899:    values[n++] = primary_event_id(sub);",
          "3901:   size = n * sizeof(u64);",
          "3903:   if (copy_to_user(buf + ret, values, size)) {",
          "3904:    return -EFAULT;",
          "3905:   }",
          "3907:   ret += size;",
          "3908:  }",
          "",
          "[Added Lines]",
          "3865: static void __perf_read_group_add(struct perf_event *leader,",
          "3866:      u64 read_format, u64 *values)",
          "3868:  struct perf_event *sub;",
          "3871:  perf_event_read(leader, true);",
          "3878:  if (read_format & PERF_FORMAT_TOTAL_TIME_ENABLED) {",
          "3879:   values[n++] += leader->total_time_enabled +",
          "3880:    atomic64_read(&leader->child_total_time_enabled);",
          "3881:  }",
          "3883:  if (read_format & PERF_FORMAT_TOTAL_TIME_RUNNING) {",
          "3884:   values[n++] += leader->total_time_running +",
          "3885:    atomic64_read(&leader->child_total_time_running);",
          "3886:  }",
          "3891:  values[n++] += perf_event_count(leader);",
          "3895:  list_for_each_entry(sub, &leader->sibling_list, group_entry) {",
          "3896:   values[n++] += perf_event_count(sub);",
          "3897:   if (read_format & PERF_FORMAT_ID)",
          "3898:    values[n++] = primary_event_id(sub);",
          "3899:  }",
          "3900: }",
          "3902: static int perf_read_group(struct perf_event *event,",
          "3903:        u64 read_format, char __user *buf)",
          "3904: {",
          "3905:  struct perf_event *leader = event->group_leader, *child;",
          "3906:  struct perf_event_context *ctx = leader->ctx;",
          "3907:  int ret = event->read_size;",
          "3908:  u64 *values;",
          "3910:  lockdep_assert_held(&ctx->mutex);",
          "3912:  values = kzalloc(event->read_size, GFP_KERNEL);",
          "3913:  if (!values)",
          "3914:   return -ENOMEM;",
          "3916:  values[0] = 1 + leader->nr_siblings;",
          "3922:  mutex_lock(&leader->child_mutex);",
          "3924:  __perf_read_group_add(leader, read_format, values);",
          "3925:  list_for_each_entry(child, &leader->child_list, child_list)",
          "3926:   __perf_read_group_add(child, read_format, values);",
          "3928:  mutex_unlock(&leader->child_mutex);",
          "3930:  if (copy_to_user(buf, values, event->read_size))",
          "3931:   ret = -EFAULT;",
          "3933:  kfree(values);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f55fc2a57cc9ca3b1bb4fb8eb25b6e1989e5b993",
      "candidate_info": {
        "commit_hash": "f55fc2a57cc9ca3b1bb4fb8eb25b6e1989e5b993",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f55fc2a57cc9ca3b1bb4fb8eb25b6e1989e5b993",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf: Restructure perf syscall point of no return\n\nThe exclusive_event_installable() stuff only works because its\nexclusive with the grouping bits.\n\nRework the code such that there is a sane place to error out before we\ngo do things we cannot undo.\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: linux-kernel@vger.kernel.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8298:  if (move_group) {",
          "8299:   gctx = group_leader->ctx;",
          "8307:   perf_remove_from_context(group_leader, false);",
          "8309:   list_for_each_entry(sibling, &group_leader->sibling_list,",
          "",
          "[Removed Lines]",
          "8305:   mutex_lock_double(&gctx->mutex, &ctx->mutex);",
          "",
          "[Added Lines]",
          "8300:   mutex_lock_double(&gctx->mutex, &ctx->mutex);",
          "8301:  } else {",
          "8302:   mutex_lock(&ctx->mutex);",
          "8303:  }",
          "8309:  if (!exclusive_event_installable(event, ctx)) {",
          "8311:   WARN_ON_ONCE(move_group);",
          "8313:   err = -EBUSY;",
          "8314:   goto err_locked;",
          "8315:  }",
          "8317:  WARN_ON_ONCE(ctx->parent_ctx);",
          "8319:  if (move_group) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8311:    perf_remove_from_context(sibling, false);",
          "8312:    put_ctx(gctx);",
          "8313:   }",
          "",
          "[Removed Lines]",
          "8314:  } else {",
          "8315:   mutex_lock(&ctx->mutex);",
          "8316:  }",
          "8318:  WARN_ON_ONCE(ctx->parent_ctx);",
          "8320:  if (move_group) {",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "8349:   perf_event__state_init(group_leader);",
          "8350:   perf_install_in_context(ctx, group_leader, group_leader->cpu);",
          "8351:   get_ctx(ctx);",
          "8359:  }",
          "8361:  perf_install_in_context(ctx, event, event->cpu);",
          "8362:  perf_unpin_context(ctx);",
          "8365:   mutex_unlock(&gctx->mutex);",
          "8368:  mutex_unlock(&ctx->mutex);",
          "8370:  put_online_cpus();",
          "",
          "[Removed Lines]",
          "8352:  }",
          "8354:  if (!exclusive_event_installable(event, ctx)) {",
          "8355:   err = -EBUSY;",
          "8356:   mutex_unlock(&ctx->mutex);",
          "8357:   fput(event_file);",
          "8358:   goto err_context;",
          "8364:  if (move_group) {",
          "8366:   put_ctx(gctx);",
          "8367:  }",
          "",
          "[Added Lines]",
          "8369:   put_ctx(gctx);",
          "8375:  if (move_group)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "8391:  fd_install(event_fd, event_file);",
          "8392:  return event_fd;",
          "8394: err_context:",
          "8395:  perf_unpin_context(ctx);",
          "8396:  put_ctx(ctx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8403: err_locked:",
          "8404:  if (move_group)",
          "8405:   mutex_unlock(&gctx->mutex);",
          "8406:  mutex_unlock(&ctx->mutex);",
          "8408:  fput(event_file);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7d88962e230c8342080e7e2fe9dd5be43dc13b79",
      "candidate_info": {
        "commit_hash": "7d88962e230c8342080e7e2fe9dd5be43dc13b79",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7d88962e230c8342080e7e2fe9dd5be43dc13b79",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf/core: Add return value for perf_event_read()\n\nWhen we implement the ability to read several counters at once (using\nthe PERF_PMU_TXN_READ transaction interface), perf_event_read() can\nfail when the 'group' parameter is true (eg: trying to read too many\nevents at once).\n\nFor now, have perf_event_read() return an integer. Ignore the return\nvalue when the 'group' parameter is false.\n\nSigned-off-by: Sukadev Bhattiprolu <sukadev@linux.vnet.ibm.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Michael Ellerman <mpe@ellerman.id.au>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nLink: http://lkml.kernel.org/r/1441336073-22750-8-git-send-email-sukadev@linux.vnet.ibm.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3187: struct perf_read_data {",
          "3188:  struct perf_event *event;",
          "3189:  bool group;",
          "3190: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3190:  int ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3227:   if (sub->state == PERF_EVENT_STATE_ACTIVE)",
          "3228:    sub->pmu->read(sub);",
          "3229:  }",
          "3231: unlock:",
          "3232:  raw_spin_unlock(&ctx->lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3231:  data->ret = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3293:  return val;",
          "3294: }",
          "3297: {",
          "",
          "[Removed Lines]",
          "3296: static void perf_event_read(struct perf_event *event, bool group)",
          "",
          "[Added Lines]",
          "3298: static int perf_event_read(struct perf_event *event, bool group)",
          "3300:  int ret = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3303:   struct perf_read_data data = {",
          "3304:    .event = event,",
          "3305:    .group = group,",
          "3306:   };",
          "3307:   smp_call_function_single(event->oncpu,",
          "3308:       __perf_event_read, &data, 1);",
          "3309:  } else if (event->state == PERF_EVENT_STATE_INACTIVE) {",
          "3310:   struct perf_event_context *ctx = event->ctx;",
          "3311:   unsigned long flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3310:    .ret = 0,",
          "3314:   ret = data.ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3326:    update_event_times(event);",
          "3327:   raw_spin_unlock_irqrestore(&ctx->lock, flags);",
          "3328:  }",
          "3329: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3336:  return ret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3843:  mutex_lock(&event->child_mutex);",
          "3846:  total += perf_event_count(event);",
          "",
          "[Removed Lines]",
          "3845:  perf_event_read(event, false);",
          "",
          "[Added Lines]",
          "3853:  (void)perf_event_read(event, false);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3851:    atomic64_read(&event->child_total_time_running);",
          "3853:  list_for_each_entry(child, &event->child_list, child_list) {",
          "3855:   total += perf_event_count(child);",
          "",
          "[Removed Lines]",
          "3854:   perf_event_read(child, false);",
          "",
          "[Added Lines]",
          "3862:   (void)perf_event_read(child, false);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "3862: }",
          "3863: EXPORT_SYMBOL_GPL(perf_event_read_value);",
          "3866:      u64 read_format, u64 *values)",
          "3867: {",
          "3868:  struct perf_event *sub;",
          "",
          "[Removed Lines]",
          "3865: static void __perf_read_group_add(struct perf_event *leader,",
          "3871:  perf_event_read(leader, true);",
          "",
          "[Added Lines]",
          "3873: static int __perf_read_group_add(struct perf_event *leader,",
          "3878:  int ret;",
          "3880:  ret = perf_event_read(leader, true);",
          "3881:  if (ret)",
          "3882:   return ret;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3897:   if (read_format & PERF_FORMAT_ID)",
          "3898:    values[n++] = primary_event_id(sub);",
          "3899:  }",
          "3900: }",
          "3902: static int perf_read_group(struct perf_event *event,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3912:  return 0;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "3904: {",
          "3905:  struct perf_event *leader = event->group_leader, *child;",
          "3906:  struct perf_event_context *ctx = leader->ctx;",
          "3908:  u64 *values;",
          "3910:  lockdep_assert_held(&ctx->mutex);",
          "",
          "[Removed Lines]",
          "3907:  int ret = event->read_size;",
          "",
          "[Added Lines]",
          "3920:  int ret;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3922:  mutex_lock(&leader->child_mutex);",
          "3928:  mutex_unlock(&leader->child_mutex);",
          "3930:  if (copy_to_user(buf, values, event->read_size))",
          "3931:   ret = -EFAULT;",
          "3933:  kfree(values);",
          "3935:  return ret;",
          "3936: }",
          "",
          "[Removed Lines]",
          "3924:  __perf_read_group_add(leader, read_format, values);",
          "3925:  list_for_each_entry(child, &leader->child_list, child_list)",
          "3926:   __perf_read_group_add(child, read_format, values);",
          "",
          "[Added Lines]",
          "3937:  ret = __perf_read_group_add(leader, read_format, values);",
          "3938:  if (ret)",
          "3939:   goto unlock;",
          "3941:  list_for_each_entry(child, &leader->child_list, child_list) {",
          "3942:   ret = __perf_read_group_add(child, read_format, values);",
          "3943:   if (ret)",
          "3944:    goto unlock;",
          "3945:  }",
          "3949:  ret = event->read_size;",
          "3952:  goto out;",
          "3954: unlock:",
          "3955:  mutex_unlock(&leader->child_mutex);",
          "3956: out:",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4038: static void _perf_event_reset(struct perf_event *event)",
          "4039: {",
          "4041:  local64_set(&event->count, 0);",
          "4042:  perf_event_update_userpage(event);",
          "4043: }",
          "",
          "[Removed Lines]",
          "4040:  perf_event_read(event, false);",
          "",
          "[Added Lines]",
          "4063:  (void)perf_event_read(event, false);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b15f495b4e9295cf21065d8569835a2f18cfe41b",
      "candidate_info": {
        "commit_hash": "b15f495b4e9295cf21065d8569835a2f18cfe41b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b15f495b4e9295cf21065d8569835a2f18cfe41b",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf/core: Rename perf_event_read_{one,group}, perf_read_hw\n\nIn order to free up the perf_event_read_group() name:\n\n s/perf_event_read_\\(one\\|group\\)/perf_read_\\1/g\n s/perf_read_hw/__perf_read/g\n\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Michael Ellerman <mpe@ellerman.id.au>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nLink: http://lkml.kernel.org/r/1441336073-22750-5-git-send-email-sukadev@linux.vnet.ibm.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3837: }",
          "3838: EXPORT_SYMBOL_GPL(perf_event_read_value);",
          "3841:        u64 read_format, char __user *buf)",
          "3842: {",
          "3843:  struct perf_event *leader = event->group_leader, *sub;",
          "",
          "[Removed Lines]",
          "3840: static int perf_event_read_group(struct perf_event *event,",
          "",
          "[Added Lines]",
          "3840: static int perf_read_group(struct perf_event *event,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3885:  return ret;",
          "3886: }",
          "3889:      u64 read_format, char __user *buf)",
          "3890: {",
          "3891:  u64 enabled, running;",
          "",
          "[Removed Lines]",
          "3888: static int perf_event_read_one(struct perf_event *event,",
          "",
          "[Added Lines]",
          "3888: static int perf_read_one(struct perf_event *event,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3925: static ssize_t",
          "3927: {",
          "3928:  u64 read_format = event->attr.read_format;",
          "3929:  int ret;",
          "",
          "[Removed Lines]",
          "3926: perf_read_hw(struct perf_event *event, char __user *buf, size_t count)",
          "",
          "[Added Lines]",
          "3926: __perf_read(struct perf_event *event, char __user *buf, size_t count)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3942:  WARN_ON_ONCE(event->ctx->parent_ctx);",
          "3943:  if (read_format & PERF_FORMAT_GROUP)",
          "3945:  else",
          "3948:  return ret;",
          "3949: }",
          "",
          "[Removed Lines]",
          "3944:   ret = perf_event_read_group(event, read_format, buf);",
          "3946:   ret = perf_event_read_one(event, read_format, buf);",
          "",
          "[Added Lines]",
          "3944:   ret = perf_read_group(event, read_format, buf);",
          "3946:   ret = perf_read_one(event, read_format, buf);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3956:  int ret;",
          "3958:  ctx = perf_event_ctx_lock(event);",
          "3960:  perf_event_ctx_unlock(event, ctx);",
          "3962:  return ret;",
          "",
          "[Removed Lines]",
          "3959:  ret = perf_read_hw(event, buf, count);",
          "",
          "[Added Lines]",
          "3959:  ret = __perf_read(event, buf, count);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1f4ee5038f0c1ef95f8e6d47ad6623e006b5bce1",
      "candidate_info": {
        "commit_hash": "1f4ee5038f0c1ef95f8e6d47ad6623e006b5bce1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1f4ee5038f0c1ef95f8e6d47ad6623e006b5bce1",
        "files": [
          "kernel/events/core.c"
        ],
        "message": "perf: Ensure consistent inherit state in groups\n\nMake sure all events in a group have the same inherit state. It was\npossible for group leaders to have inherit set while sibling events\nwould not have inherit set.\n\nIn this case we'd still inherit the siblings, leading to some\nnon-fatal weirdness.\n\nSigned-off-by: Peter Zijlstra <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Paul Mackerras <paulus@samba.org>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nCc: Stephane Eranian <eranian@google.com>\nLink: http://lkml.kernel.org/n/tip-r32tt8yldvic3jlcghd3g35u@git.kernel.org\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/events/core.c||kernel/events/core.c"
          ],
          "candidate": [
            "kernel/events/core.c||kernel/events/core.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7081:   }",
          "7082:  }",
          "7084:  get_online_cpus();",
          "7086:  event = perf_event_alloc(&attr, cpu, task, group_leader, NULL,",
          "7087:      NULL, NULL);",
          "7088:  if (IS_ERR(event)) {",
          "7089:   err = PTR_ERR(event);",
          "7091:  }",
          "7093:  if (flags & PERF_FLAG_PID_CGROUP) {",
          "7094:   err = perf_cgroup_connect(pid, event, &attr, group_leader);",
          "7095:   if (err) {",
          "7096:    __free_event(event);",
          "7098:   }",
          "7099:  }",
          "",
          "[Removed Lines]",
          "7090:   goto err_task;",
          "7097:    goto err_task;",
          "",
          "[Added Lines]",
          "7084:  if (task && group_leader &&",
          "7085:      group_leader->attr.inherit != attr.inherit) {",
          "7086:   err = -EINVAL;",
          "7087:   goto err_task;",
          "7088:  }",
          "7096:   goto err_cpus;",
          "7103:    goto err_cpus;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7256:  put_ctx(ctx);",
          "7257: err_alloc:",
          "7258:  free_event(event);",
          "7260:  put_online_cpus();",
          "7261:  if (task)",
          "7262:   put_task_struct(task);",
          "7263: err_group_fd:",
          "",
          "[Removed Lines]",
          "7259: err_task:",
          "",
          "[Added Lines]",
          "7265: err_cpus:",
          "7267: err_task:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
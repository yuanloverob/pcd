{
  "cve_id": "CVE-2016-0705",
  "cve_desc": "Double free vulnerability in the dsa_priv_decode function in crypto/dsa/dsa_ameth.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via a malformed DSA private key.",
  "repo": "openssl/openssl",
  "patch_hash": "ab4a81f69ec88d06c9d8de15326b9296d7f498ed",
  "patch_info": {
    "commit_hash": "ab4a81f69ec88d06c9d8de15326b9296d7f498ed",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/ab4a81f69ec88d06c9d8de15326b9296d7f498ed",
    "files": [
      "crypto/dsa/dsa_ameth.c"
    ],
    "message": "Remove broken DSA private key workarounds.\n\nRemove old code that handled various invalid DSA formats in ancient\nsoftware.\n\nThis also fixes a double free bug when parsing malformed DSA private keys.\n\nThanks to Adam Langley (Google/BoringSSL) for discovering this bug using\nlibFuzzer.\n\nCVE-2016-0705\n\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>",
    "before_after_code_files": [
      "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
    ]
  },
  "patch_diff": {
    "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c": [
      "File: crypto/dsa/dsa_ameth.c -> crypto/dsa/dsa_ameth.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "184: static int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)",
      "185: {",
      "187:     int pklen, pmlen;",
      "188:     int ptype;",
      "189:     void *pval;",
      "",
      "[Removed Lines]",
      "186:     const unsigned char *p, *pm;",
      "",
      "[Added Lines]",
      "186:     const unsigned char *p, *q, *pm;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "192:     ASN1_INTEGER *privkey = NULL;",
      "193:     BN_CTX *ctx = NULL;",
      "196:     DSA *dsa = NULL;",
      "198:     if (!PKCS8_pkey_get0(NULL, &p, &pklen, &palg, p8))",
      "199:         return 0;",
      "200:     X509_ALGOR_get0(NULL, &ptype, &pval, palg);",
      "240:             goto decerr;",
      "241:     }",
      "243:     pstr = pval;",
      "244:     pm = pstr->data;",
      "",
      "[Removed Lines]",
      "195:     STACK_OF(ASN1_TYPE) *ndsa = NULL;",
      "203:     if (*p == (V_ASN1_SEQUENCE | V_ASN1_CONSTRUCTED)) {",
      "204:         ASN1_TYPE *t1, *t2;",
      "205:         if ((ndsa = d2i_ASN1_SEQUENCE_ANY(NULL, &p, pklen)) == NULL)",
      "206:             goto decerr;",
      "207:         if (sk_ASN1_TYPE_num(ndsa) != 2)",
      "208:             goto decerr;",
      "215:         t1 = sk_ASN1_TYPE_value(ndsa, 0);",
      "216:         t2 = sk_ASN1_TYPE_value(ndsa, 1);",
      "217:         if (t1->type == V_ASN1_SEQUENCE) {",
      "218:             p8->broken = PKCS8_EMBEDDED_PARAM;",
      "219:             pval = t1->value.ptr;",
      "220:         } else if (ptype == V_ASN1_SEQUENCE)",
      "221:             p8->broken = PKCS8_NS_DB;",
      "222:         else",
      "223:             goto decerr;",
      "225:         if (t2->type != V_ASN1_INTEGER)",
      "226:             goto decerr;",
      "228:         privkey = t2->value.integer;",
      "229:     } else {",
      "230:         const unsigned char *q = p;",
      "231:         if ((privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)) == NULL)",
      "232:             goto decerr;",
      "233:         if (privkey->type == V_ASN1_NEG_INTEGER) {",
      "234:             p8->broken = PKCS8_NEG_PRIVKEY;",
      "235:             ASN1_STRING_clear_free(privkey);",
      "236:             if ((privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)) == NULL)",
      "237:                 goto decerr;",
      "238:         }",
      "239:         if (ptype != V_ASN1_SEQUENCE)",
      "",
      "[Added Lines]",
      "197:     int ret = 0;",
      "203:     q = p;",
      "205:     if ((privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)) == NULL)",
      "206:         goto decerr;",
      "207:     if (privkey->type == V_ASN1_NEG_INTEGER) {",
      "208:         p8->broken = PKCS8_NEG_PRIVKEY;",
      "209:         ASN1_STRING_clear_free(privkey);",
      "210:         if ((privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)) == NULL)",
      "213:     if (ptype != V_ASN1_SEQUENCE)",
      "214:         goto decerr;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "267:     }",
      "269:     EVP_PKEY_assign_DSA(pkey, dsa);",
      "278:  decerr:",
      "279:     DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_DECODE_ERROR);",
      "280:  dsaerr:",
      "281:     BN_CTX_free(ctx);",
      "282:     ASN1_STRING_clear_free(privkey);",
      "286: }",
      "288: static int dsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)",
      "",
      "[Removed Lines]",
      "270:     BN_CTX_free(ctx);",
      "271:     if (ndsa)",
      "272:         sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);",
      "273:     else",
      "274:         ASN1_STRING_clear_free(privkey);",
      "276:     return 1;",
      "283:     sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);",
      "284:     DSA_free(dsa);",
      "285:     return 0;",
      "",
      "[Added Lines]",
      "244:     ret = 1;",
      "245:     goto done;",
      "250:     DSA_free(dsa);",
      "251:  done:",
      "254:     return ret;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "74924dcb3802640d7e2ae2e80ca6515d0a53de7a",
      "candidate_info": {
        "commit_hash": "74924dcb3802640d7e2ae2e80ca6515d0a53de7a",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/74924dcb3802640d7e2ae2e80ca6515d0a53de7a",
        "files": [
          "CHANGES",
          "crypto/Makefile",
          "crypto/asn1/x_bignum.c",
          "crypto/bio/bss_mem.c",
          "crypto/bn/bn_ctx.c",
          "crypto/bn/bn_lib.c",
          "crypto/buffer/buffer.c",
          "crypto/dh/dh_ameth.c",
          "crypto/dh/dh_key.c",
          "crypto/dsa/dsa_ameth.c",
          "crypto/dsa/dsa_asn1.c",
          "crypto/dsa/dsa_key.c",
          "crypto/ec/ec_asn1.c",
          "crypto/mem.c",
          "crypto/rsa/rsa_asn1.c",
          "crypto/rsa/rsa_gen.c",
          "crypto/sec_mem.c",
          "doc/crypto/BIO_s_mem.pod",
          "doc/crypto/BN_CTX_new.pod",
          "doc/crypto/CRYPTO_secure_malloc.pod",
          "doc/crypto/bio.pod",
          "doc/crypto/bn.pod",
          "doc/crypto/buffer.pod",
          "include/openssl/bio.h",
          "include/openssl/bn.h",
          "include/openssl/buffer.h",
          "include/openssl/crypto.h",
          "test/Makefile",
          "test/secmemtest.c",
          "util/libeay.num"
        ],
        "message": "More secure storage of key material.\n\nAdd secure heap for storage of private keys (when possible).\nAdd BIO_s_secmem(), CBIGNUM, etc.\nAdd BIO_CTX_secure_new so all BIGNUM's in the context are secure.\nContributed by Akamai Technologies under the Corporate CLA.\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
        "before_after_code_files": [
          "crypto/asn1/x_bignum.c||crypto/asn1/x_bignum.c",
          "crypto/bio/bss_mem.c||crypto/bio/bss_mem.c",
          "crypto/bn/bn_ctx.c||crypto/bn/bn_ctx.c",
          "crypto/bn/bn_lib.c||crypto/bn/bn_lib.c",
          "crypto/buffer/buffer.c||crypto/buffer/buffer.c",
          "crypto/dh/dh_ameth.c||crypto/dh/dh_ameth.c",
          "crypto/dh/dh_key.c||crypto/dh/dh_key.c",
          "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c",
          "crypto/dsa/dsa_asn1.c||crypto/dsa/dsa_asn1.c",
          "crypto/dsa/dsa_key.c||crypto/dsa/dsa_key.c",
          "crypto/ec/ec_asn1.c||crypto/ec/ec_asn1.c",
          "crypto/mem.c||crypto/mem.c",
          "crypto/rsa/rsa_asn1.c||crypto/rsa/rsa_asn1.c",
          "crypto/rsa/rsa_gen.c||crypto/rsa/rsa_gen.c",
          "crypto/sec_mem.c||crypto/sec_mem.c",
          "include/openssl/bio.h||include/openssl/bio.h",
          "include/openssl/bn.h||include/openssl/bn.h",
          "include/openssl/buffer.h||include/openssl/buffer.h",
          "include/openssl/crypto.h||include/openssl/crypto.h",
          "test/secmemtest.c||test/secmemtest.c",
          "util/libeay.num||util/libeay.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
          ],
          "candidate": [
            "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/asn1/x_bignum.c||crypto/asn1/x_bignum.c": [
          "File: crypto/asn1/x_bignum.c -> crypto/asn1/x_bignum.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: #define BN_SENSITIVE    1",
          "74: static int bn_new(ASN1_VALUE **pval, const ASN1_ITEM *it);",
          "75: static void bn_free(ASN1_VALUE **pval, const ASN1_ITEM *it);",
          "77: static int bn_i2c(ASN1_VALUE **pval, unsigned char *cont, int *putype,",
          "78:                   const ASN1_ITEM *it);",
          "79: static int bn_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "80:                   int utype, char *free_cont, const ASN1_ITEM *it);",
          "82: static ASN1_PRIMITIVE_FUNCS bignum_pf = {",
          "83:     NULL, 0,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "75: static int bn_secure_new(ASN1_VALUE **pval, const ASN1_ITEM *it);",
          "82: static int bn_secure_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "83:                          int utype, char *free_cont, const ASN1_ITEM *it);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "88:     bn_i2c",
          "89: };",
          "91: ASN1_ITEM_start(BIGNUM)",
          "92:         ASN1_ITYPE_PRIMITIVE, V_ASN1_INTEGER, NULL, 0, &bignum_pf, 0, \"BIGNUM\"",
          "93: ASN1_ITEM_end(BIGNUM)",
          "95: ASN1_ITEM_start(CBIGNUM)",
          "97: ASN1_ITEM_end(CBIGNUM)",
          "99: static int bn_new(ASN1_VALUE **pval, const ASN1_ITEM *it)",
          "",
          "[Removed Lines]",
          "96:         ASN1_ITYPE_PRIMITIVE, V_ASN1_INTEGER, NULL, 0, &bignum_pf, BN_SENSITIVE, \"BIGNUM\"",
          "",
          "[Added Lines]",
          "94: static ASN1_PRIMITIVE_FUNCS cbignum_pf = {",
          "95:     NULL, 0,",
          "96:     bn_secure_new,",
          "97:     bn_free,",
          "98:     0,",
          "99:     bn_secure_c2i,",
          "100:     bn_i2c",
          "101: };",
          "108:         ASN1_ITYPE_PRIMITIVE, V_ASN1_INTEGER, NULL, 0, &cbignum_pf, BN_SENSITIVE, \"CBIGNUM\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "105:         return 0;",
          "106: }",
          "108: static void bn_free(ASN1_VALUE **pval, const ASN1_ITEM *it)",
          "109: {",
          "110:     if (!*pval)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "120: static int bn_secure_new(ASN1_VALUE **pval, const ASN1_ITEM *it)",
          "121: {",
          "123:     if (*pval)",
          "124:         return 1;",
          "125:     else",
          "126:         return 0;",
          "127: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:     }",
          "151:     return 1;",
          "152: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "176: static int bn_secure_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len,",
          "177:                          int utype, char *free_cont, const ASN1_ITEM *it)",
          "178: {",
          "179:     if (!*pval)",
          "180:         bn_secure_new(pval, it);",
          "181:     return bn_c2i(pval, cont, len, utype, free_cont, it);",
          "182: }",
          "",
          "---------------"
        ],
        "crypto/bio/bss_mem.c||crypto/bio/bss_mem.c": [
          "File: crypto/bio/bss_mem.c -> crypto/bio/bss_mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: static int mem_gets(BIO *h, char *str, int size);",
          "68: static long mem_ctrl(BIO *h, int cmd, long arg1, void *arg2);",
          "69: static int mem_new(BIO *h);",
          "70: static int mem_free(BIO *data);",
          "71: static BIO_METHOD mem_method = {",
          "72:     BIO_TYPE_MEM,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: static int secmem_new(BIO *h);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:     mem_free,",
          "81:     NULL,",
          "82: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84: static BIO_METHOD secmem_method = {",
          "85:     BIO_TYPE_MEM,",
          "86:     \"secure memory buffer\",",
          "87:     mem_write,",
          "88:     mem_read,",
          "89:     mem_puts,",
          "90:     mem_gets,",
          "91:     mem_ctrl,",
          "92:     secmem_new,",
          "93:     mem_free,",
          "94:     NULL,",
          "95: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "91:     return (&mem_method);",
          "92: }",
          "94: BIO *BIO_new_mem_buf(void *buf, int len)",
          "95: {",
          "96:     BIO *ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107: BIO_METHOD *BIO_s_secmem(void)",
          "108: {",
          "109:     return(&secmem_method);",
          "110: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "114:     return ret;",
          "115: }",
          "118: {",
          "119:     BUF_MEM *b;",
          "123:     bi->shutdown = 1;",
          "124:     bi->init = 1;",
          "125:     bi->num = -1;",
          "126:     bi->ptr = (char *)b;",
          "128: }",
          "130: static int mem_free(BIO *a)",
          "",
          "[Removed Lines]",
          "117: static int mem_new(BIO *bi)",
          "121:     if ((b = BUF_MEM_new()) == NULL)",
          "122:         return (0);",
          "127:     return (1);",
          "",
          "[Added Lines]",
          "135: static int mem_init(BIO *bi, unsigned long flags)",
          "139:     if ((b = BUF_MEM_new_ex(flags)) == NULL)",
          "140:         return(0);",
          "145:     return(1);",
          "146: }",
          "148: static int mem_new(BIO *bi)",
          "149: {",
          "150:     return (mem_init(bi, 0L));",
          "151: }",
          "153: static int secmem_new(BIO *bi)",
          "154: {",
          "155:     return (mem_init(bi, BUF_MEM_FLAG_SECURE));",
          "",
          "---------------"
        ],
        "crypto/bn/bn_ctx.c||crypto/bn/bn_ctx.c": [
          "File: crypto/bn/bn_ctx.c -> crypto/bn/bn_ctx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: } BN_POOL;",
          "104: static void BN_POOL_init(BN_POOL *);",
          "105: static void BN_POOL_finish(BN_POOL *);",
          "107: static void BN_POOL_release(BN_POOL *, unsigned int);",
          "",
          "[Removed Lines]",
          "106: static BIGNUM *BN_POOL_get(BN_POOL *);",
          "",
          "[Added Lines]",
          "106: static BIGNUM *BN_POOL_get(BN_POOL *, int);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138:     int err_stack;",
          "140:     int too_many;",
          "141: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "142:     int flags;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "187: BN_CTX *BN_CTX_new(void)",
          "188: {",
          "191:         BNerr(BN_F_BN_CTX_NEW, ERR_R_MALLOC_FAILURE);",
          "192:         return NULL;",
          "193:     }",
          "",
          "[Removed Lines]",
          "189:     BN_CTX *ret = OPENSSL_malloc(sizeof(*ret));",
          "190:     if (!ret) {",
          "",
          "[Added Lines]",
          "191:     BN_CTX *ret;",
          "193:     if ((ret = OPENSSL_malloc(sizeof(*ret))) == NULL) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "197:     ret->used = 0;",
          "198:     ret->err_stack = 0;",
          "199:     ret->too_many = 0;",
          "200:     return ret;",
          "201: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "203:     ret->flags = 0;",
          "204:     return ret;",
          "205: }",
          "207: BN_CTX *BN_CTX_secure_new(void)",
          "208: {",
          "209:     BN_CTX *ret = BN_CTX_new();",
          "211:     if (ret)",
          "212:         ret->flags = BN_FLG_SECURE;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "258: BIGNUM *BN_CTX_get(BN_CTX *ctx)",
          "259: {",
          "260:     BIGNUM *ret;",
          "261:     CTXDBG_ENTRY(\"BN_CTX_get\", ctx);",
          "262:     if (ctx->err_stack || ctx->too_many)",
          "263:         return NULL;",
          "",
          "[Removed Lines]",
          "264:     if ((ret = BN_POOL_get(&ctx->pool)) == NULL) {",
          "",
          "[Added Lines]",
          "278:     if ((ret = BN_POOL_get(&ctx->pool, ctx->flags)) == NULL) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "290: static void BN_STACK_finish(BN_STACK *st)",
          "291: {",
          "294: }",
          "297: static int BN_STACK_push(BN_STACK *st, unsigned int idx)",
          "298: {",
          "307:             return 0;",
          "308:         if (st->depth)",
          "312:         st->indexes = newitems;",
          "313:         st->size = newsize;",
          "314:     }",
          "",
          "[Removed Lines]",
          "292:     if (st->size)",
          "293:         OPENSSL_free(st->indexes);",
          "299:     if (st->depth == st->size)",
          "301:     {",
          "302:         unsigned int newsize = (st->size ?",
          "303:                                 (st->size * 3 / 2) : BN_CTX_START_FRAMES);",
          "304:         unsigned int *newitems = OPENSSL_malloc(newsize *",
          "305:                                                 sizeof(unsigned int));",
          "306:         if (!newitems)",
          "309:             memcpy(newitems, st->indexes, st->depth * sizeof(unsigned int));",
          "310:         if (st->size)",
          "311:             OPENSSL_free(st->indexes);",
          "",
          "[Added Lines]",
          "306:     OPENSSL_free(st->indexes);",
          "307:     st->indexes = NULL;",
          "313:     if (st->depth == st->size) {",
          "315:         unsigned int newsize =",
          "316:             st->size ? (st->size * 3 / 2) : BN_CTX_START_FRAMES;",
          "317:         unsigned int *newitems = OPENSSL_malloc(sizeof(*newitems) * newsize);",
          "318:         if (newitems == NULL)",
          "321:             memcpy(newitems, st->indexes, sizeof(*newitems) * st->depth);",
          "322:         OPENSSL_free(st->indexes);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "334: static void BN_POOL_finish(BN_POOL *p)",
          "335: {",
          "336:     while (p->head) {",
          "340:             if (bn->d)",
          "341:                 BN_clear_free(bn);",
          "344:         p->current = p->head->next;",
          "345:         OPENSSL_free(p->head);",
          "346:         p->head = p->current;",
          "",
          "[Removed Lines]",
          "337:         unsigned int loop = 0;",
          "338:         BIGNUM *bn = p->head->vals;",
          "339:         while (loop++ < BN_CTX_POOL_SIZE) {",
          "342:             bn++;",
          "343:         }",
          "",
          "[Added Lines]",
          "347:     unsigned int loop;",
          "348:     BIGNUM *bn;",
          "351:         for (loop = 0, bn = p->head->vals; loop++ < BN_CTX_POOL_SIZE; bn++)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "348: }",
          "352: {",
          "353:     if (p->used == p->size) {",
          "356:         BN_POOL_ITEM *item = OPENSSL_malloc(sizeof(*item));",
          "358:             return NULL;",
          "363:         item->prev = p->tail;",
          "364:         item->next = NULL;",
          "367:             p->head = p->current = p->tail = item;",
          "368:         else {",
          "369:             p->tail->next = item;",
          "",
          "[Removed Lines]",
          "351: static BIGNUM *BN_POOL_get(BN_POOL *p)",
          "354:         BIGNUM *bn;",
          "355:         unsigned int loop = 0;",
          "357:         if (!item)",
          "360:         bn = item->vals;",
          "361:         while (loop++ < BN_CTX_POOL_SIZE)",
          "362:             BN_init(bn++);",
          "366:         if (!p->head)",
          "",
          "[Added Lines]",
          "361: static BIGNUM *BN_POOL_get(BN_POOL *p, int flag)",
          "363:     BIGNUM *bn;",
          "364:     unsigned int loop;",
          "369:         if (item == NULL)",
          "371:         for (loop = 0, bn = item->vals; loop++ < BN_CTX_POOL_SIZE; bn++) {",
          "372:             BN_init(bn);",
          "373:             if ((flag & BN_FLG_SECURE) != 0)",
          "374:                 BN_set_flags(bn, BN_FLG_SECURE);",
          "375:         }",
          "379:         if (p->head == NULL)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "385: static void BN_POOL_release(BN_POOL *p, unsigned int num)",
          "386: {",
          "387:     unsigned int offset = (p->used - 1) % BN_CTX_POOL_SIZE;",
          "388:     p->used -= num;",
          "389:     while (num--) {",
          "390:         bn_check_top(p->current->vals + offset);",
          "392:             offset = BN_CTX_POOL_SIZE - 1;",
          "393:             p->current = p->current->prev;",
          "394:         } else",
          "",
          "[Removed Lines]",
          "391:         if (!offset) {",
          "",
          "[Added Lines]",
          "406:         if (offset == 0) {",
          "",
          "---------------"
        ],
        "crypto/bn/bn_lib.c||crypto/bn/bn_lib.c": [
          "File: crypto/bn/bn_lib.c -> crypto/bn/bn_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "232:     bn_check_top(a);",
          "233:     if (a->d != NULL) {",
          "234:         OPENSSL_cleanse(a->d, a->dmax * sizeof(a->d[0]));",
          "237:     }",
          "238:     i = BN_get_flags(a, BN_FLG_MALLOCED);",
          "239:     OPENSSL_cleanse(a, sizeof(BIGNUM));",
          "",
          "[Removed Lines]",
          "235:         if (!(BN_get_flags(a, BN_FLG_STATIC_DATA)))",
          "236:             OPENSSL_free(a->d);",
          "",
          "[Added Lines]",
          "235:         if (!(BN_get_flags(a, BN_FLG_STATIC_DATA))) {",
          "236:             if (BN_get_flags(a,BN_FLG_SECURE))",
          "237:                 OPENSSL_secure_free(a->d);",
          "238:             else",
          "239:                 OPENSSL_free(a->d);",
          "240:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:         return;",
          "248:     bn_check_top(a);",
          "249:     if (!BN_get_flags(a, BN_FLG_STATIC_DATA))",
          "251:     if (a->flags & BN_FLG_MALLOCED)",
          "252:         OPENSSL_free(a);",
          "253:     else {",
          "",
          "[Removed Lines]",
          "250:         OPENSSL_free(a->d);",
          "",
          "[Added Lines]",
          "254:     if ((a->d != NULL) && !(BN_get_flags(a, BN_FLG_STATIC_DATA))) {",
          "255:         if (BN_get_flags(a, BN_FLG_SECURE))",
          "256:             OPENSSL_secure_free(a->d);",
          "257:         else",
          "258:             OPENSSL_free(a->d);",
          "259:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "281:     return (ret);",
          "282: }",
          "286: static BN_ULONG *bn_expand_internal(const BIGNUM *b, int words)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:  BIGNUM *BN_secure_new(void)",
          "294:  {",
          "295:      BIGNUM *ret = BN_new();",
          "296:      if (ret)",
          "297:          ret->flags |= BN_FLG_SECURE;",
          "298:      return (ret);",
          "299:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "299:         BNerr(BN_F_BN_EXPAND_INTERNAL, BN_R_EXPAND_ON_STATIC_BIGNUM_DATA);",
          "300:         return (NULL);",
          "301:     }",
          "303:     if (A == NULL) {",
          "304:         BNerr(BN_F_BN_EXPAND_INTERNAL, ERR_R_MALLOC_FAILURE);",
          "305:         return (NULL);",
          "",
          "[Removed Lines]",
          "302:     a = A = OPENSSL_malloc(sizeof(*a) * words);",
          "",
          "[Added Lines]",
          "319:     if (BN_get_flags(b,BN_FLG_SECURE))",
          "320:         a = A = OPENSSL_secure_malloc(words * sizeof(*a));",
          "321:     else",
          "322:         a = A = OPENSSL_malloc(words * sizeof(*a));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "378:         BN_ULONG *a = bn_expand_internal(b, words);",
          "379:         if (!a)",
          "380:             return NULL;",
          "382:         b->d = a;",
          "383:         b->dmax = words;",
          "384:     }",
          "",
          "[Removed Lines]",
          "381:         OPENSSL_free(b->d);",
          "",
          "[Added Lines]",
          "401:         if (b->d) {",
          "402:             if (BN_get_flags(b,BN_FLG_SECURE))",
          "403:                 OPENSSL_secure_free(b->d);",
          "404:             else",
          "405:                 OPENSSL_free(b->d);",
          "406:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "395:         return NULL;",
          "396:     bn_check_top(a);",
          "399:     if (t == NULL)",
          "400:         return NULL;",
          "401:     if (!BN_copy(t, a)) {",
          "",
          "[Removed Lines]",
          "398:     t = BN_new();",
          "",
          "[Added Lines]",
          "423:     t = BN_get_flags(a, BN_FLG_SECURE) ? BN_secure_new() : BN_new();",
          "",
          "---------------"
        ],
        "crypto/buffer/buffer.c||crypto/buffer/buffer.c": [
          "File: crypto/buffer/buffer.c -> crypto/buffer/buffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: #define LIMIT_BEFORE_EXPANSION 0x5ffffffc",
          "70: BUF_MEM *BUF_MEM_new(void)",
          "71: {",
          "72:     BUF_MEM *ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: BUF_MEM *BUF_MEM_new_ex(unsigned long flags)",
          "71: {",
          "72:     BUF_MEM *ret;",
          "74:     ret = BUF_MEM_new();",
          "75:     if (ret != NULL)",
          "76:         ret->flags = flags;",
          "77:     return (ret);",
          "78: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "76:         BUFerr(BUF_F_BUF_MEM_NEW, ERR_R_MALLOC_FAILURE);",
          "77:         return (NULL);",
          "78:     }",
          "79:     ret->length = 0;",
          "80:     ret->max = 0;",
          "81:     ret->data = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89:     ret->flags = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "88:         return;",
          "90:     if (a->data != NULL) {",
          "92:     }",
          "93:     OPENSSL_free(a);",
          "94: }",
          "96: size_t BUF_MEM_grow(BUF_MEM *str, size_t len)",
          "97: {",
          "98:     char *ret;",
          "",
          "[Removed Lines]",
          "91:         OPENSSL_clear_free(a->data, a->max);",
          "",
          "[Added Lines]",
          "102:         memset(a->data, 0, (unsigned int)a->max);",
          "103:         if (a->flags & BUF_MEM_FLAG_SECURE)",
          "104:             OPENSSL_secure_free(a->data);",
          "105:         else",
          "106:             OPENSSL_clear_free(a->data, a->max);",
          "113: static char *sec_alloc_realloc(BUF_MEM *str, size_t len)",
          "114: {",
          "115:     char *ret;",
          "117:     ret = OPENSSL_secure_malloc(len);",
          "118:     if (str->data != NULL) {",
          "119:         if (ret != NULL)",
          "120:             memcpy(ret, str->data, str->length);",
          "121:         OPENSSL_secure_free(str->data);",
          "122:     }",
          "123:     return (ret);",
          "124: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "113:         return 0;",
          "114:     }",
          "115:     n = (len + 3) / 3 * 4;",
          "117:     if (ret == NULL) {",
          "118:         BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);",
          "119:         len = 0;",
          "",
          "[Removed Lines]",
          "116:     ret = OPENSSL_realloc(str->data, n);",
          "",
          "[Added Lines]",
          "146:     if ((str->flags & BUF_MEM_FLAG_SECURE))",
          "147:         ret = sec_alloc_realloc(str, n);",
          "148:     else",
          "149:         ret = OPENSSL_realloc(str->data, n);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "147:         return 0;",
          "148:     }",
          "149:     n = (len + 3) / 3 * 4;",
          "151:     if (ret == NULL) {",
          "152:         BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);",
          "153:         len = 0;",
          "",
          "[Removed Lines]",
          "150:     ret = OPENSSL_realloc_clean(str->data, str->max, n);",
          "",
          "[Added Lines]",
          "183:     if ((str->flags & BUF_MEM_FLAG_SECURE))",
          "184:         ret = sec_alloc_realloc(str, n);",
          "185:     else",
          "186:         ret = OPENSSL_realloc_clean(str->data, str->max, n);",
          "",
          "---------------"
        ],
        "crypto/dh/dh_ameth.c||crypto/dh/dh_ameth.c": [
          "File: crypto/dh/dh_ameth.c -> crypto/dh/dh_ameth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "228:         goto decerr;",
          "232:         DHerr(DH_F_DH_PRIV_DECODE, DH_R_BN_ERROR);",
          "233:         goto dherr;",
          "234:     }",
          "",
          "[Removed Lines]",
          "231:     if ((dh->priv_key = ASN1_INTEGER_to_BN(privkey, NULL)) == NULL) {",
          "",
          "[Added Lines]",
          "231:     if ((dh->priv_key = BN_secure_new()) == NULL",
          "232:         || !ASN1_INTEGER_to_BN(privkey, dh->priv_key)) {",
          "",
          "---------------"
        ],
        "crypto/dh/dh_key.c||crypto/dh/dh_key.c": [
          "File: crypto/dh/dh_key.c -> crypto/dh/dh_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "125:         goto err;",
          "127:     if (dh->priv_key == NULL) {",
          "129:         if (priv_key == NULL)",
          "130:             goto err;",
          "131:         generate_new_key = 1;",
          "",
          "[Removed Lines]",
          "128:         priv_key = BN_new();",
          "",
          "[Added Lines]",
          "128:         priv_key = BN_secure_new();",
          "",
          "---------------"
        ],
        "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c": [
          "File: crypto/dsa/dsa_ameth.c -> crypto/dsa/dsa_ameth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "245:     if ((dsa = d2i_DSAparams(NULL, &pm, pmlen)) == NULL)",
          "246:         goto decerr;",
          "249:         DSAerr(DSA_F_DSA_PRIV_DECODE, DSA_R_BN_ERROR);",
          "250:         goto dsaerr;",
          "251:     }",
          "",
          "[Removed Lines]",
          "248:     if ((dsa->priv_key = ASN1_INTEGER_to_BN(privkey, NULL)) == NULL) {",
          "",
          "[Added Lines]",
          "248:     if ((dsa->priv_key = BN_secure_new()) == NULL",
          "249:         || !ASN1_INTEGER_to_BN(privkey, dsa->priv_key)) {",
          "",
          "---------------"
        ],
        "crypto/dsa/dsa_asn1.c||crypto/dsa/dsa_asn1.c": [
          "File: crypto/dsa/dsa_asn1.c -> crypto/dsa/dsa_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "113:         ASN1_SIMPLE(DSA, q, BIGNUM),",
          "114:         ASN1_SIMPLE(DSA, g, BIGNUM),",
          "115:         ASN1_SIMPLE(DSA, pub_key, BIGNUM),",
          "117: } ASN1_SEQUENCE_END_cb(DSA, DSAPrivateKey)",
          "119: IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(DSA, DSAPrivateKey, DSAPrivateKey)",
          "",
          "[Removed Lines]",
          "116:         ASN1_SIMPLE(DSA, priv_key, BIGNUM)",
          "",
          "[Added Lines]",
          "116:         ASN1_SIMPLE(DSA, priv_key, CBIGNUM)",
          "",
          "---------------"
        ],
        "crypto/dsa/dsa_key.c||crypto/dsa/dsa_key.c": [
          "File: crypto/dsa/dsa_key.c -> crypto/dsa/dsa_key.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:         goto err;",
          "84:     if (dsa->priv_key == NULL) {",
          "86:             goto err;",
          "87:     } else",
          "88:         priv_key = dsa->priv_key;",
          "",
          "[Removed Lines]",
          "85:         if ((priv_key = BN_new()) == NULL)",
          "",
          "[Added Lines]",
          "85:         if ((priv_key = BN_secure_new()) == NULL)",
          "",
          "---------------"
        ],
        "crypto/ec/ec_asn1.c||crypto/ec/ec_asn1.c": [
          "File: crypto/ec/ec_asn1.c -> crypto/ec/ec_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1023:     ret->version = priv_key->version;",
          "1025:     if (priv_key->privateKey) {",
          "1026:         ret->priv_key = BN_bin2bn(ASN1_STRING_data(priv_key->privateKey),",
          "1027:                                   ASN1_STRING_length(priv_key->privateKey),",
          "1028:                                   ret->priv_key);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1026:         if (ret->priv_key == NULL)",
          "1027:             ret->priv_key = BN_secure_new();",
          "",
          "---------------"
        ],
        "crypto/mem.c||crypto/mem.c": [
          "File: crypto/mem.c -> crypto/mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "95: static void (*free_func) (void *) = free;",
          "97: static void *(*malloc_locked_func) (size_t) = malloc;",
          "98: static void *default_malloc_locked_ex(size_t num, const char *file, int line)",
          "99: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97: static void *(*malloc_secure_func)(size_t) = malloc;",
          "98: static void *default_malloc_secure_ex(size_t num, const char *file, int line)",
          "99: {",
          "100:     return malloc_secure_func(num);",
          "101: }",
          "102: static void *(*malloc_secure_ex_func)(size_t, const char *file, int line)",
          "103:     = default_malloc_secure_ex;",
          "104: static void (*free_secure_func)(void *) = free;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:     realloc_func = r;",
          "146:     realloc_ex_func = default_realloc_ex;",
          "147:     free_func = f;",
          "148:     malloc_locked_func = m;",
          "149:     malloc_locked_ex_func = default_malloc_locked_ex;",
          "150:     free_locked_func = f;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:     malloc_secure_func = m;",
          "160:     malloc_secure_ex_func = default_malloc_secure_ex;",
          "161:     free_secure_func = f;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "164:     realloc_func = 0;",
          "165:     realloc_ex_func = r;",
          "166:     free_func = f;",
          "167:     malloc_locked_func = 0;",
          "168:     malloc_locked_ex_func = m;",
          "169:     free_locked_func = f;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181:     malloc_secure_func = 0;",
          "182:     malloc_secure_ex_func = m;",
          "183:     free_secure_func = f;",
          "184:     malloc_locked_func = 0;",
          "185:     malloc_locked_ex_func = m;",
          "186:     free_locked_func = f;",
          "187:     return 1;",
          "188: }",
          "190: int CRYPTO_set_secure_mem_functions(void *(*m)(size_t), void (*f)(void *))",
          "191: {",
          "193:     OPENSSL_init();",
          "194:     if (!allow_customize)",
          "195:         return 0;",
          "196:     if ((m == 0) || (f == 0))",
          "197:         return 0;",
          "198:     malloc_secure_func = m;",
          "199:     malloc_secure_ex_func = default_malloc_secure_ex;",
          "200:     free_secure_func = f;",
          "203:     malloc_locked_func = m;",
          "204:     malloc_locked_ex_func = default_malloc_secure_ex;",
          "205:     free_locked_func = f;",
          "206:     return 1;",
          "207: }",
          "209: int CRYPTO_set_secure_mem_ex_functions(void *(*m)(size_t, const char *, int),",
          "210:                                        void (*f)(void *))",
          "211: {",
          "212:     if (!allow_customize)",
          "213:         return 0;",
          "214:     if ((m == NULL) || (f == NULL))",
          "215:         return 0;",
          "216:     malloc_secure_func = 0;",
          "217:     malloc_secure_ex_func = m;",
          "218:     free_secure_func = f;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "191:         return 0;",
          "192:     malloc_locked_func = 0;",
          "193:     malloc_locked_ex_func = m;",
          "195:     return 1;",
          "196: }",
          "",
          "[Removed Lines]",
          "194:     free_func = f;",
          "",
          "[Added Lines]",
          "246:     free_locked_func = f;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "237: }",
          "239: void CRYPTO_get_locked_mem_functions(void *(**m) (size_t),",
          "240:                                      void (**f) (void *))",
          "241: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "291: void CRYPTO_get_secure_mem_functions(void *(**m)(size_t), void (**f)(void *))",
          "292: {",
          "293:     if (m != NULL)",
          "295:             malloc_secure_func : 0;",
          "296:     if (f != NULL)",
          "298:  }",
          "300: void CRYPTO_get_secure_mem_ex_functions(void *(**m)(size_t,const char *,int),",
          "301:                                         void (**f)(void *))",
          "302: {",
          "303:     if (m != NULL)",
          "305:             malloc_secure_ex_func : 0;",
          "306:     if (f != NULL)",
          "308: }",
          "",
          "---------------"
        ],
        "crypto/rsa/rsa_asn1.c||crypto/rsa/rsa_asn1.c": [
          "File: crypto/rsa/rsa_asn1.c -> crypto/rsa/rsa_asn1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85:         ASN1_SIMPLE(RSA, version, LONG),",
          "86:         ASN1_SIMPLE(RSA, n, BIGNUM),",
          "87:         ASN1_SIMPLE(RSA, e, BIGNUM),",
          "94: } ASN1_SEQUENCE_END_cb(RSA, RSAPrivateKey)",
          "",
          "[Removed Lines]",
          "88:         ASN1_SIMPLE(RSA, d, BIGNUM),",
          "89:         ASN1_SIMPLE(RSA, p, BIGNUM),",
          "90:         ASN1_SIMPLE(RSA, q, BIGNUM),",
          "91:         ASN1_SIMPLE(RSA, dmp1, BIGNUM),",
          "92:         ASN1_SIMPLE(RSA, dmq1, BIGNUM),",
          "93:         ASN1_SIMPLE(RSA, iqmp, BIGNUM)",
          "",
          "[Added Lines]",
          "88:         ASN1_SIMPLE(RSA, d, CBIGNUM),",
          "89:         ASN1_SIMPLE(RSA, p, CBIGNUM),",
          "90:         ASN1_SIMPLE(RSA, q, CBIGNUM),",
          "91:         ASN1_SIMPLE(RSA, dmp1, CBIGNUM),",
          "92:         ASN1_SIMPLE(RSA, dmq1, CBIGNUM),",
          "93:         ASN1_SIMPLE(RSA, iqmp, CBIGNUM)",
          "",
          "---------------"
        ],
        "crypto/rsa/rsa_gen.c||crypto/rsa/rsa_gen.c": [
          "File: crypto/rsa/rsa_gen.c -> crypto/rsa/rsa_gen.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:     if (!rsa->n && ((rsa->n = BN_new()) == NULL))",
          "119:         goto err;",
          "121:         goto err;",
          "122:     if (!rsa->e && ((rsa->e = BN_new()) == NULL))",
          "123:         goto err;",
          "125:         goto err;",
          "127:         goto err;",
          "129:         goto err;",
          "131:         goto err;",
          "133:         goto err;",
          "135:     BN_copy(rsa->e, e_value);",
          "",
          "[Removed Lines]",
          "120:     if (!rsa->d && ((rsa->d = BN_new()) == NULL))",
          "124:     if (!rsa->p && ((rsa->p = BN_new()) == NULL))",
          "126:     if (!rsa->q && ((rsa->q = BN_new()) == NULL))",
          "128:     if (!rsa->dmp1 && ((rsa->dmp1 = BN_new()) == NULL))",
          "130:     if (!rsa->dmq1 && ((rsa->dmq1 = BN_new()) == NULL))",
          "132:     if (!rsa->iqmp && ((rsa->iqmp = BN_new()) == NULL))",
          "",
          "[Added Lines]",
          "120:     if (!rsa->d && ((rsa->d = BN_secure_new()) == NULL))",
          "124:     if (!rsa->p && ((rsa->p = BN_secure_new()) == NULL))",
          "126:     if (!rsa->q && ((rsa->q = BN_secure_new()) == NULL))",
          "128:     if (!rsa->dmp1 && ((rsa->dmp1 = BN_secure_new()) == NULL))",
          "130:     if (!rsa->dmq1 && ((rsa->dmq1 = BN_secure_new()) == NULL))",
          "132:     if (!rsa->iqmp && ((rsa->iqmp = BN_secure_new()) == NULL))",
          "",
          "---------------"
        ],
        "crypto/sec_mem.c||crypto/sec_mem.c": [
          "File: crypto/sec_mem.c -> crypto/sec_mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <openssl/crypto.h>",
          "14: #include <e_os.h>",
          "15: #include <stdlib.h>",
          "16: #include <unistd.h>",
          "17: #include <string.h>",
          "18: #include <assert.h>",
          "20: #if defined(OPENSSL_SYS_LINUX) || defined(OPENSSL_SYS_UNIX)",
          "21: # define IMPLEMENTED",
          "22: # include <sys/mman.h>",
          "23: # include <sys/param.h>",
          "24: #endif",
          "26: #define LOCK()      CRYPTO_w_lock(CRYPTO_LOCK_MALLOC)",
          "27: #define UNLOCK()    CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC)",
          "28: #define CLEAR(p, s) OPENSSL_cleanse(p, s)",
          "29: #define PAGE_SIZE    4096",
          "31: #ifdef IMPLEMENTED",
          "32: size_t secure_mem_used;",
          "34: static int secure_mem_initialized;",
          "35: static int too_late;",
          "40: static int sh_init(size_t size, int minsize);",
          "41: static char *sh_malloc(size_t size);",
          "42: static void sh_free(char *ptr);",
          "43: static void sh_done(void);",
          "44: static int sh_actual_size(char *ptr);",
          "45: static int sh_allocated(const char *ptr);",
          "46: #endif",
          "48: int CRYPTO_secure_malloc_init(size_t size, int minsize)",
          "49: {",
          "50: #ifdef IMPLEMENTED",
          "51:     int ret = 0;",
          "53:     if (too_late)",
          "54:         return ret;",
          "55:     LOCK();",
          "56:     OPENSSL_assert(!secure_mem_initialized);",
          "57:     if (!secure_mem_initialized) {",
          "58:         ret = sh_init(size, minsize);",
          "59:         secure_mem_initialized = 1;",
          "60:     }",
          "61:     UNLOCK();",
          "62:     return ret;",
          "63: #else",
          "64:     return 0;",
          "66: }",
          "68: void CRYPTO_secure_malloc_done()",
          "69: {",
          "70: #ifdef IMPLEMENTED",
          "71:     LOCK();",
          "72:     sh_done();",
          "73:     secure_mem_initialized = 0;",
          "74:     UNLOCK();",
          "76: }",
          "78: int CRYPTO_secure_malloc_initialized()",
          "79: {",
          "80: #ifdef IMPLEMENTED",
          "81:     return secure_mem_initialized;",
          "82: #else",
          "83:     return 0;",
          "85: }",
          "87: void *CRYPTO_secure_malloc(int num, const char *file, int line)",
          "88: {",
          "89: #ifdef IMPLEMENTED",
          "90:     void *ret;",
          "91:     size_t actual_size;",
          "93:     if (!secure_mem_initialized) {",
          "94:         too_late = 1;",
          "95:         return CRYPTO_malloc(num, file, line);",
          "96:     }",
          "97:     LOCK();",
          "98:     ret = sh_malloc(num);",
          "99:     actual_size = ret ? sh_actual_size(ret) : 0;",
          "100:     secure_mem_used += actual_size;",
          "101:     UNLOCK();",
          "102:     return ret;",
          "103: #else",
          "104:     return CRYPTO_malloc(num, file, line);",
          "106: }",
          "108: void CRYPTO_secure_free(void *ptr)",
          "109: {",
          "110: #ifdef IMPLEMENTED",
          "111:     size_t actual_size;",
          "113:     if (ptr == NULL)",
          "114:         return;",
          "115:     if (!secure_mem_initialized) {",
          "116:         CRYPTO_free(ptr);",
          "117:         return;",
          "118:     }",
          "119:     LOCK();",
          "120:     actual_size = sh_actual_size(ptr);",
          "121:     CLEAR(ptr, actual_size);",
          "122:     secure_mem_used -= actual_size;",
          "123:     sh_free(ptr);",
          "124:     UNLOCK();",
          "125: #else",
          "126:     CRYPTO_free(ptr);",
          "128: }",
          "130: int CRYPTO_secure_allocated(const void *ptr)",
          "131: {",
          "132: #ifdef IMPLEMENTED",
          "133:     int ret;",
          "135:     if (!secure_mem_initialized)",
          "136:         return 0;",
          "137:     LOCK();",
          "138:     ret = sh_allocated(ptr);",
          "139:     UNLOCK();",
          "140:     return ret;",
          "141: #else",
          "142:     return 0;",
          "144: }",
          "153: #ifdef IMPLEMENTED",
          "171: # define TESTBIT(t, b)  (t[(b) >> 3] &  (1 << ((b) & 7)))",
          "172: # define SETBIT(t, b)   (t[(b) >> 3] |= (1 << ((b) & 7)))",
          "173: # define CLEARBIT(t, b) (t[(b) >> 3] &= (0xFF & ~(1 << ((b) & 7))))",
          "175: #define WITHIN_ARENA(p) \\",
          "176:     ((char*)(p) >= sh.arena && (char*)(p) < &sh.arena[sh.arena_size])",
          "177: #define WITHIN_FREELIST(p) \\",
          "178:     ((char*)(p) >= (char*)sh.freelist && (char*)(p) < (char*)&sh.freelist[sh.freelist_size])",
          "181: typedef struct sh_list_st",
          "182: {",
          "183:     struct sh_list_st *next;",
          "184:     struct sh_list_st **p_next;",
          "185: } SH_LIST;",
          "187: typedef struct sh_st",
          "188: {",
          "189:     char* map_result;",
          "190:     size_t map_size;",
          "191:     char *arena;",
          "192:     int arena_size;",
          "193:     char **freelist;",
          "194:     int freelist_size;",
          "195:     int minsize;",
          "196:     unsigned char *bittable;",
          "197:     unsigned char *bitmalloc;",
          "199: } SH;",
          "201: static SH sh;",
          "203: static int sh_getlist(char *ptr)",
          "204: {",
          "205:     int list = sh.freelist_size - 1;",
          "206:     int bit = (sh.arena_size + ptr - sh.arena) / sh.minsize;",
          "208:     for (; bit; bit >>= 1, list--) {",
          "209:         if (TESTBIT(sh.bittable, bit))",
          "210:             break;",
          "211:         OPENSSL_assert((bit & 1) == 0);",
          "212:     }",
          "214:     return list;",
          "215: }",
          "218: static int sh_testbit(char *ptr, int list, unsigned char *table)",
          "219: {",
          "220:     int bit;",
          "222:     OPENSSL_assert(list >= 0 && list < sh.freelist_size);",
          "223:     OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);",
          "224:     bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));",
          "225:     OPENSSL_assert(bit > 0 && bit < sh.bittable_size);",
          "226:     return TESTBIT(table, bit);",
          "227: }",
          "229: static void sh_clearbit(char *ptr, int list, unsigned char *table)",
          "230: {",
          "231:     int bit;",
          "233:     OPENSSL_assert(list >= 0 && list < sh.freelist_size);",
          "234:     OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);",
          "235:     bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));",
          "236:     OPENSSL_assert(bit > 0 && bit < sh.bittable_size);",
          "237:     OPENSSL_assert(TESTBIT(table, bit));",
          "238:     CLEARBIT(table, bit);",
          "239: }",
          "241: static void sh_setbit(char *ptr, int list, unsigned char *table)",
          "242: {",
          "243:     int bit;",
          "245:     OPENSSL_assert(list >= 0 && list < sh.freelist_size);",
          "246:     OPENSSL_assert(((ptr - sh.arena) & ((sh.arena_size >> list) - 1)) == 0);",
          "247:     bit = (1 << list) + ((ptr - sh.arena) / (sh.arena_size >> list));",
          "248:     OPENSSL_assert(bit > 0 && bit < sh.bittable_size);",
          "249:     OPENSSL_assert(!TESTBIT(table, bit));",
          "250:     SETBIT(table, bit);",
          "251: }",
          "253: static void sh_add_to_list(char **list, char *ptr)",
          "254: {",
          "255:     SH_LIST *temp;",
          "257:     OPENSSL_assert(WITHIN_FREELIST(list));",
          "258:     OPENSSL_assert(WITHIN_ARENA(ptr));",
          "260:     temp = (SH_LIST *)ptr;",
          "261:     temp->next = *(SH_LIST **)list;",
          "262:     OPENSSL_assert(temp->next == NULL || WITHIN_ARENA(temp->next));",
          "263:     temp->p_next = (SH_LIST **)list;",
          "265:     if (temp->next != NULL) {",
          "266:         OPENSSL_assert((char **)temp->next->p_next == list);",
          "267:         temp->next->p_next = &(temp->next);",
          "268:     }",
          "271: }",
          "273: static void sh_remove_from_list(char *ptr, char *list)",
          "274: {",
          "275:     SH_LIST *temp, *temp2;",
          "277:     temp = (SH_LIST *)ptr;",
          "278:     if (temp->next != NULL)",
          "279:         temp->next->p_next = temp->p_next;",
          "281:     if (temp->next == NULL)",
          "282:         return;",
          "284:     temp2 = temp->next;",
          "285:     OPENSSL_assert(WITHIN_FREELIST(temp2->p_next) || WITHIN_ARENA(temp2->p_next));",
          "286: }",
          "289: static int sh_init(size_t size, int minsize)",
          "290: {",
          "291:     int i, ret;",
          "292:     size_t pgsize;",
          "293:     size_t aligned;",
          "295:     memset(&sh, 0, sizeof sh);",
          "298:     OPENSSL_assert(size > 0);",
          "299:     OPENSSL_assert((size & (size - 1)) == 0);",
          "300:     OPENSSL_assert(minsize > 0);",
          "301:     OPENSSL_assert((minsize & (minsize - 1)) == 0);",
          "302:     if (size <= 0 || (size & (size - 1)) != 0)",
          "303:         goto err;",
          "304:     if (minsize <= 0 || (minsize & (minsize - 1)) != 0)",
          "305:         goto err;",
          "307:     sh.arena_size = size;",
          "308:     sh.minsize = minsize;",
          "309:     sh.bittable_size = (sh.arena_size / sh.minsize) * 2;",
          "311:     sh.freelist_size = -1;",
          "312:     for (i = sh.bittable_size; i; i >>= 1)",
          "313:         sh.freelist_size++;",
          "315:     sh.freelist = OPENSSL_malloc(sh.freelist_size * sizeof (char *));",
          "316:     OPENSSL_assert(sh.freelist != NULL);",
          "317:     if (sh.freelist == NULL)",
          "318:         goto err;",
          "319:     memset(sh.freelist, 0, sh.freelist_size * sizeof (char *));",
          "321:     sh.bittable = OPENSSL_malloc(sh.bittable_size >> 3);",
          "322:     OPENSSL_assert(sh.bittable != NULL);",
          "323:     if (sh.bittable == NULL)",
          "324:         goto err;",
          "325:     memset(sh.bittable, 0, sh.bittable_size >> 3);",
          "327:     sh.bitmalloc = OPENSSL_malloc(sh.bittable_size >> 3);",
          "328:     OPENSSL_assert(sh.bitmalloc != NULL);",
          "329:     if (sh.bitmalloc == NULL)",
          "330:         goto err;",
          "331:     memset(sh.bitmalloc, 0, sh.bittable_size >> 3);",
          "334: #ifdef _SC_PAGE_SIZE",
          "335:     pgsize = (size_t)sysconf(_SC_PAGE_SIZE);",
          "336: #else",
          "337:     pgsize = PAGE_SIZE;",
          "338: #endif",
          "339:     sh.map_size = pgsize + sh.arena_size + pgsize;",
          "340:     sh.map_result = mmap(NULL, sh.map_size,",
          "341:                          PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);",
          "342:     OPENSSL_assert(sh.map_result != MAP_FAILED);",
          "343:     if (sh.map_result == MAP_FAILED)",
          "344:         goto err;",
          "345:     sh.arena = (char *)(sh.map_result + pgsize);",
          "346:     sh_setbit(sh.arena, 0, sh.bittable);",
          "347:     sh_add_to_list(&sh.freelist[0], sh.arena);",
          "350:     ret = 1;",
          "353:     if (mprotect(sh.map_result, pgsize, PROT_NONE) < 0)",
          "354:         ret = 2;",
          "357:     aligned = (pgsize + sh.arena_size + (pgsize - 1)) & ~(pgsize - 1);",
          "358:     if (mprotect(sh.map_result + aligned, pgsize, PROT_NONE) < 0)",
          "359:         ret = 2;",
          "361:     if (mlock(sh.arena, sh.arena_size) < 0)",
          "362:         ret = 2;",
          "363: #ifdef MADV_DONTDUMP",
          "364:     if (madvise(sh.arena, sh.arena_size, MADV_DONTDUMP) < 0)",
          "365:         ret = 2;",
          "366: #endif",
          "368:     return ret;",
          "370:  err:",
          "371:     sh_done();",
          "372:     return 0;",
          "373: }",
          "375: static void sh_done()",
          "376: {",
          "377:     OPENSSL_free(sh.freelist);",
          "378:     OPENSSL_free(sh.bittable);",
          "379:     OPENSSL_free(sh.bitmalloc);",
          "380:     if (sh.map_result != NULL && sh.map_size)",
          "381:         munmap(sh.map_result, sh.map_size);",
          "382:     memset(&sh, 0, sizeof sh);",
          "383: }",
          "385: static int sh_allocated(const char *ptr)",
          "386: {",
          "387:     return WITHIN_ARENA(ptr) ? 1 : 0;",
          "388: }",
          "390: static char *sh_find_my_buddy(char *ptr, int list)",
          "391: {",
          "392:     int bit;",
          "393:     char *chunk = NULL;",
          "395:     bit = (1 << list) + (ptr - sh.arena) / (sh.arena_size >> list);",
          "396:     bit ^= 1;",
          "398:     if (TESTBIT(sh.bittable, bit) && !TESTBIT(sh.bitmalloc, bit))",
          "399:         chunk = sh.arena + ((bit & ((1 << list) - 1)) * (sh.arena_size >> list));",
          "401:     return chunk;",
          "402: }",
          "404: static char *sh_malloc(size_t size)",
          "405: {",
          "406:     int list, slist;",
          "407:     size_t i;",
          "408:     char *chunk;",
          "410:     list = sh.freelist_size - 1;",
          "411:     for (i = sh.minsize; i < size; i <<= 1)",
          "412:         list--;",
          "413:     if (list < 0)",
          "414:         return NULL;",
          "417:     for (slist = list; slist >= 0; slist--)",
          "418:         if (sh.freelist[slist] != NULL)",
          "419:             break;",
          "420:     if (slist < 0)",
          "421:         return NULL;",
          "424:     while (slist != list) {",
          "425:         char *temp = sh.freelist[slist];",
          "428:         OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));",
          "429:         sh_clearbit(temp, slist, sh.bittable);",
          "430:         sh_remove_from_list(temp, sh.freelist[slist]);",
          "431:         OPENSSL_assert(temp != sh.freelist[slist]);",
          "434:         slist++;",
          "437:         OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));",
          "438:         sh_setbit(temp, slist, sh.bittable);",
          "439:         sh_add_to_list(&sh.freelist[slist], temp);",
          "440:         OPENSSL_assert(sh.freelist[slist] == temp);",
          "443:         temp += sh.arena_size >> slist;",
          "444:         OPENSSL_assert(!sh_testbit(temp, slist, sh.bitmalloc));",
          "445:         sh_setbit(temp, slist, sh.bittable);",
          "446:         sh_add_to_list(&sh.freelist[slist], temp);",
          "447:         OPENSSL_assert(sh.freelist[slist] == temp);",
          "449:         OPENSSL_assert(temp-(sh.arena_size >> slist) == sh_find_my_buddy(temp, slist));",
          "450:     }",
          "453:     chunk = sh.freelist[list];",
          "454:     OPENSSL_assert(sh_testbit(chunk, list, sh.bittable));",
          "455:     sh_setbit(chunk, list, sh.bitmalloc);",
          "456:     sh_remove_from_list(chunk, sh.freelist[list]);",
          "458:     OPENSSL_assert(WITHIN_ARENA(chunk));",
          "460:     return chunk;",
          "461: }",
          "463: static void sh_free(char *ptr)",
          "464: {",
          "465:     int list;",
          "466:     char *buddy;",
          "468:     if (ptr == NULL)",
          "469:         return;",
          "470:     OPENSSL_assert(WITHIN_ARENA(ptr));",
          "471:     if (!WITHIN_ARENA(ptr))",
          "472:         return;",
          "474:     list = sh_getlist(ptr);",
          "475:     OPENSSL_assert(sh_testbit(ptr, list, sh.bittable));",
          "476:     sh_clearbit(ptr, list, sh.bitmalloc);",
          "477:     sh_add_to_list(&sh.freelist[list], ptr);",
          "480:     while ((buddy = sh_find_my_buddy(ptr, list)) != NULL) {",
          "481:         OPENSSL_assert(ptr == sh_find_my_buddy(buddy, list));",
          "482:         OPENSSL_assert(ptr != NULL);",
          "483:         OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));",
          "484:         sh_clearbit(ptr, list, sh.bittable);",
          "485:         sh_remove_from_list(ptr, sh.freelist[list]);",
          "486:         OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));",
          "487:         sh_clearbit(buddy, list, sh.bittable);",
          "488:         sh_remove_from_list(buddy, sh.freelist[list]);",
          "490:         list--;",
          "492:         if (ptr > buddy)",
          "493:             ptr = buddy;",
          "495:         OPENSSL_assert(!sh_testbit(ptr, list, sh.bitmalloc));",
          "496:         sh_setbit(ptr, list, sh.bittable);",
          "497:         sh_add_to_list(&sh.freelist[list], ptr);",
          "498:         OPENSSL_assert(sh.freelist[list] == ptr);",
          "499:     }",
          "500: }",
          "502: static int sh_actual_size(char *ptr)",
          "503: {",
          "504:     int list;",
          "506:     OPENSSL_assert(WITHIN_ARENA(ptr));",
          "507:     if (!WITHIN_ARENA(ptr))",
          "508:         return 0;",
          "509:     list = sh_getlist(ptr);",
          "510:     OPENSSL_assert(sh_testbit(ptr, list, sh.bittable));",
          "511:     return sh.arena_size / (1 << list);",
          "512: }",
          "",
          "---------------"
        ],
        "include/openssl/bio.h||include/openssl/bio.h": [
          "File: include/openssl/bio.h -> include/openssl/bio.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "670:                         long argl, long ret);",
          "672: BIO_METHOD *BIO_s_mem(void);",
          "673: BIO *BIO_new_mem_buf(void *buf, int len);",
          "674: BIO_METHOD *BIO_s_socket(void);",
          "675: BIO_METHOD *BIO_s_connect(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "673: BIO_METHOD *BIO_s_secmem(void);",
          "",
          "---------------"
        ],
        "include/openssl/bn.h||include/openssl/bn.h": [
          "File: include/openssl/bn.h -> include/openssl/bn.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "270: # define BN_FLG_CONSTTIME        0x04",
          "272: # ifdef OPENSSL_USE_DEPRECATED",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "271: # define BN_FLG_SECURE           0x08",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "349: const BIGNUM *BN_value_one(void);",
          "350: char *BN_options(void);",
          "351: BN_CTX *BN_CTX_new(void);",
          "352: void BN_CTX_free(BN_CTX *c);",
          "353: void BN_CTX_start(BN_CTX *ctx);",
          "354: BIGNUM *BN_CTX_get(BN_CTX *ctx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353: BN_CTX *BN_CTX_secure_new(void);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "361: int BN_num_bits_word(BN_ULONG l);",
          "362: int BN_security_bits(int L, int N);",
          "363: BIGNUM *BN_new(void);",
          "364: void BN_clear_free(BIGNUM *a);",
          "365: BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);",
          "366: void BN_swap(BIGNUM *a, BIGNUM *b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "366: BIGNUM *BN_secure_new(void);",
          "",
          "---------------"
        ],
        "include/openssl/buffer.h||include/openssl/buffer.h": [
          "File: include/openssl/buffer.h -> include/openssl/buffer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:     char *data;",
          "81: };",
          "83: BUF_MEM *BUF_MEM_new(void);",
          "84: void BUF_MEM_free(BUF_MEM *a);",
          "85: size_t BUF_MEM_grow(BUF_MEM *str, size_t len);",
          "86: size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "81:     unsigned long flags;",
          "84: # define BUF_MEM_FLAG_SECURE  0x01",
          "87: BUF_MEM *BUF_MEM_new_ex(unsigned long flags);",
          "",
          "---------------"
        ],
        "include/openssl/crypto.h||include/openssl/crypto.h": [
          "File: include/openssl/crypto.h -> include/openssl/crypto.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "491: int CRYPTO_set_mem_functions(void *(*m) (size_t), void *(*r) (void *, size_t),",
          "492:                              void (*f) (void *));",
          "493: int CRYPTO_set_locked_mem_functions(void *(*m) (size_t),",
          "495: int CRYPTO_set_mem_ex_functions(void *(*m) (size_t, const char *, int),",
          "496:                                 void *(*r) (void *, size_t, const char *,",
          "497:                                             int), void (*f) (void *));",
          "498: int CRYPTO_set_locked_mem_ex_functions(void *(*m) (size_t, const char *, int),",
          "500: int CRYPTO_set_mem_debug_functions(void (*m)",
          "501:                                     (void *, int, const char *, int, int),",
          "502:                                    void (*r) (void *, void *, int,",
          "",
          "[Removed Lines]",
          "494:                                     void (*free_func) (void *));",
          "499:                                        void (*free_func) (void *));",
          "",
          "[Added Lines]",
          "494:                                     void (*f) (void *));",
          "499:                                        void (*f) (void *));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "532:                            int line);",
          "533: void *CRYPTO_remalloc(void *addr, int num, const char *file, int line);",
          "535: void OPENSSL_cleanse(void *ptr, size_t len);",
          "537: void CRYPTO_set_mem_debug_options(long bits);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535: # define OPENSSL_secure_malloc(num) \\",
          "536:         CRYPTO_secure_malloc((int)num,__FILE__,__LINE__)",
          "537: # define OPENSSL_secure_free(addr) \\",
          "538:         CRYPTO_secure_free(addr)",
          "540: int CRYPTO_secure_malloc_init(size_t sz, int minsize);",
          "541: void CRYPTO_secure_malloc_done(void);",
          "542: void *CRYPTO_secure_malloc(int num, const char *file, int line);",
          "543: void CRYPTO_secure_free(void *ptr);",
          "544: int CRYPTO_secure_allocated(const void *ptr);",
          "545: int CRYPTO_secure_malloc_initialized(void);",
          "547: int CRYPTO_set_secure_mem_functions(void *(*m)(size_t), void (*f)(void *));",
          "548: int CRYPTO_set_secure_mem_ex_functions(void *(*m)(size_t,const char *,int),",
          "549:                                        void (*f)(void *));",
          "550: void CRYPTO_get_secure_mem_functions(void *(**m)(size_t), void (**f)(void *));",
          "551: void CRYPTO_get_secure_mem_ex_functions(void *(**m)(size_t,const char *,int),",
          "552:                                         void (**f)(void *));",
          "",
          "---------------"
        ],
        "test/secmemtest.c||test/secmemtest.c": [
          "File: test/secmemtest.c -> test/secmemtest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2: #include <openssl/crypto.h>",
          "4: int main(int argc, char **argv)",
          "5: {",
          "6: #if defined(OPENSSL_SYS_LINUX) || defined(OPENSSL_SYS_UNIX)",
          "7:     char *p = NULL, *q = NULL;",
          "9:     if (!CRYPTO_secure_malloc_init(4096, 32)) {",
          "10:         perror(\"failed\");",
          "11:         return 1;",
          "12:     }",
          "13:     p = OPENSSL_secure_malloc(20);",
          "14:     if (!CRYPTO_secure_allocated(p)) {",
          "15:         perror(\"failed 1\");",
          "16:         return 1;",
          "17:     }",
          "18:     q = OPENSSL_malloc(20);",
          "19:     if (CRYPTO_secure_allocated(q)) {",
          "20:         perror(\"failed 1\");",
          "21:         return 1;",
          "22:     }",
          "23:     CRYPTO_secure_free(p);",
          "24:     CRYPTO_free(q);",
          "25:     CRYPTO_secure_malloc_done();",
          "26: #else",
          "28:     if (CRYPTO_secure_malloc_init(4096, 32)) {",
          "29:         perror(\"failed\");",
          "30:         return 1;",
          "31:     }",
          "32: #endif",
          "33:     return 0;",
          "34: }",
          "",
          "---------------"
        ],
        "util/libeay.num||util/libeay.num": [
          "File: util/libeay.num -> util/libeay.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4573: PKCS8_set0_pbe                          4932 EXIST::FUNCTION:",
          "4574: DH_bits                                 4933 EXIST::FUNCTION:DH",
          "4575: RSA_bits                                4934 EXIST::FUNCTION:RSA",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4576: CRYPTO_set_secure_mem_ex_functions      4935 EXIST::FUNCTION:",
          "4577: CRYPTO_secure_allocated                 4936 EXIST::FUNCTION:",
          "4578: BN_CTX_secure_new                       4937 EXIST::FUNCTION:",
          "4579: CRYPTO_secure_malloc                    4938 EXIST::FUNCTION:",
          "4580: CRYPTO_secure_malloc_done               4939 EXIST::FUNCTION:",
          "4581: BUF_MEM_new_ex                          4940 EXIST::FUNCTION:",
          "4582: CRYPTO_secure_malloc_initialized        4941 EXIST::FUNCTION:",
          "4583: CRYPTO_secure_malloc_init               4942 EXIST::FUNCTION:",
          "4584: CRYPTO_get_secure_mem_functions         4943 EXIST::FUNCTION:",
          "4585: BN_secure_new                           4944 EXIST::FUNCTION:",
          "4586: CRYPTO_secure_free                      4945 EXIST::FUNCTION:",
          "4587: BIO_s_secmem                            4946 EXIST::FUNCTION:",
          "4588: CRYPTO_get_secure_mem_ex_functions      4947 EXIST::FUNCTION:",
          "4589: CRYPTO_set_secure_mem_functions         4948 EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a8ae0891d4bfd18f224777aed1fbb172504421f1",
      "candidate_info": {
        "commit_hash": "a8ae0891d4bfd18f224777aed1fbb172504421f1",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/a8ae0891d4bfd18f224777aed1fbb172504421f1",
        "files": [
          "crypto/asn1/asn1.h",
          "crypto/asn1/asn1_lib.c",
          "crypto/dh/dh_ameth.c",
          "crypto/dsa/dsa_ameth.c"
        ],
        "message": "Cleanse PKCS#8 private key components.\n\nNew function ASN1_STRING_clear_free which cleanses an ASN1_STRING\nstructure before freeing it.\n\nCall ASN1_STRING_clear_free on PKCS#8 private key components.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
        "before_after_code_files": [
          "crypto/asn1/asn1.h||crypto/asn1/asn1.h",
          "crypto/asn1/asn1_lib.c||crypto/asn1/asn1_lib.c",
          "crypto/dh/dh_ameth.c||crypto/dh/dh_ameth.c",
          "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
          ],
          "candidate": [
            "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/asn1/asn1.h||crypto/asn1/asn1.h": [
          "File: crypto/asn1/asn1.h -> crypto/asn1/asn1.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "800: ASN1_STRING *ASN1_STRING_new(void);",
          "801: void ASN1_STRING_free(ASN1_STRING *a);",
          "802: int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str);",
          "803: ASN1_STRING *ASN1_STRING_dup(const ASN1_STRING *a);",
          "804: ASN1_STRING *ASN1_STRING_type_new(int type);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "802: void ASN1_STRING_clear_free(ASN1_STRING *a);",
          "",
          "---------------"
        ],
        "crypto/asn1/asn1_lib.c||crypto/asn1/asn1_lib.c": [
          "File: crypto/asn1/asn1_lib.c -> crypto/asn1/asn1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "427:     OPENSSL_free(a);",
          "428: }",
          "430: int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b)",
          "431: {",
          "432:     int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "430: void ASN1_STRING_clear_free(ASN1_STRING *a)",
          "431: {",
          "432:     if (a && a->data && !(a->flags & ASN1_STRING_FLAG_NDEF))",
          "433:         OPENSSL_cleanse(a->data, a->length);",
          "434:     ASN1_STRING_free(a);",
          "435: }",
          "",
          "---------------"
        ],
        "crypto/dh/dh_ameth.c||crypto/dh/dh_ameth.c": [
          "File: crypto/dh/dh_ameth.c -> crypto/dh/dh_ameth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "241:     EVP_PKEY_assign(pkey, pkey->ameth->pkey_id, dh);",
          "245:     return 1;",
          "",
          "[Removed Lines]",
          "243:     ASN1_INTEGER_free(privkey);",
          "",
          "[Added Lines]",
          "243:     ASN1_STRING_clear_free(privkey);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "248:     DHerr(DH_F_DH_PRIV_DECODE, EVP_R_DECODE_ERROR);",
          "249:  dherr:",
          "250:     DH_free(dh);",
          "252:     return 0;",
          "253: }",
          "",
          "[Removed Lines]",
          "251:     ASN1_INTEGER_free(privkey);",
          "",
          "[Added Lines]",
          "251:     ASN1_STRING_clear_free(privkey);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "284:     dplen = i2d_ASN1_INTEGER(prkey, &dp);",
          "287:     prkey = NULL;",
          "289:     if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(pkey->ameth->pkey_id), 0,",
          "",
          "[Removed Lines]",
          "286:     ASN1_INTEGER_free(prkey);",
          "",
          "[Added Lines]",
          "286:     ASN1_STRING_clear_free(prkey);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "298:     if (params != NULL)",
          "299:         ASN1_STRING_free(params);",
          "300:     if (prkey != NULL)",
          "302:     return 0;",
          "303: }",
          "",
          "[Removed Lines]",
          "301:         ASN1_INTEGER_free(prkey);",
          "",
          "[Added Lines]",
          "301:         ASN1_STRING_clear_free(prkey);",
          "",
          "---------------"
        ],
        "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c": [
          "File: crypto/dsa/dsa_ameth.c -> crypto/dsa/dsa_ameth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "226:             goto decerr;",
          "227:         if (privkey->type == V_ASN1_NEG_INTEGER) {",
          "228:             p8->broken = PKCS8_NEG_PRIVKEY;",
          "230:             if (!(privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)))",
          "231:                 goto decerr;",
          "232:         }",
          "",
          "[Removed Lines]",
          "229:             ASN1_INTEGER_free(privkey);",
          "",
          "[Added Lines]",
          "229:             ASN1_STRING_clear_free(privkey);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:     if (ndsa)",
          "265:         sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);",
          "266:     else",
          "269:     return 1;",
          "",
          "[Removed Lines]",
          "267:         ASN1_INTEGER_free(privkey);",
          "",
          "[Added Lines]",
          "267:         ASN1_STRING_clear_free(privkey);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "273:  dsaerr:",
          "274:     BN_CTX_free(ctx);",
          "275:     if (privkey)",
          "277:     sk_ASN1_TYPE_pop_free(ndsa, ASN1_TYPE_free);",
          "278:     DSA_free(dsa);",
          "279:     return 0;",
          "",
          "[Removed Lines]",
          "276:         ASN1_INTEGER_free(privkey);",
          "",
          "[Added Lines]",
          "276:         ASN1_STRING_clear_free(privkey);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "316:     dplen = i2d_ASN1_INTEGER(prkey, &dp);",
          "320:     if (!PKCS8_pkey_set0(p8, OBJ_nid2obj(NID_dsa), 0,",
          "321:                          V_ASN1_SEQUENCE, params, dp, dplen))",
          "",
          "[Removed Lines]",
          "318:     ASN1_INTEGER_free(prkey);",
          "",
          "[Added Lines]",
          "318:     ASN1_STRING_clear_free(prkey);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "329:     if (params != NULL)",
          "330:         ASN1_STRING_free(params);",
          "331:     if (prkey != NULL)",
          "333:     return 0;",
          "334: }",
          "",
          "[Removed Lines]",
          "332:         ASN1_INTEGER_free(prkey);",
          "",
          "[Added Lines]",
          "332:         ASN1_STRING_clear_free(prkey);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dfb10af92e9663ce4eefaa1d6b678817fa85344d",
      "candidate_info": {
        "commit_hash": "dfb10af92e9663ce4eefaa1d6b678817fa85344d",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/dfb10af92e9663ce4eefaa1d6b678817fa85344d",
        "files": [
          "crypto/dsa/dsa_ameth.c"
        ],
        "message": "Remove DSA negative integer workaround code.\n\nRemove DSA private key code which tolerates broken implementations which\nuse negative integers.\n\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>",
        "before_after_code_files": [
          "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
          ],
          "candidate": [
            "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c"
          ]
        }
      },
      "candidate_diff": {
        "crypto/dsa/dsa_ameth.c||crypto/dsa/dsa_ameth.c": [
          "File: crypto/dsa/dsa_ameth.c -> crypto/dsa/dsa_ameth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "184: static int dsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)",
          "185: {",
          "187:     int pklen, pmlen;",
          "188:     int ptype;",
          "189:     void *pval;",
          "",
          "[Removed Lines]",
          "186:     const unsigned char *p, *q, *pm;",
          "",
          "[Added Lines]",
          "186:     const unsigned char *p, *pm;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "200:         return 0;",
          "201:     X509_ALGOR_get0(NULL, &ptype, &pval, palg);",
          "205:     if ((privkey = d2i_ASN1_INTEGER(NULL, &p, pklen)) == NULL)",
          "206:         goto decerr;",
          "214:         goto decerr;",
          "216:     pstr = pval;",
          "",
          "[Removed Lines]",
          "203:     q = p;",
          "207:     if (privkey->type == V_ASN1_NEG_INTEGER) {",
          "208:         p8->broken = PKCS8_NEG_PRIVKEY;",
          "209:         ASN1_STRING_clear_free(privkey);",
          "210:         if ((privkey = d2i_ASN1_UINTEGER(NULL, &q, pklen)) == NULL)",
          "211:             goto decerr;",
          "212:     }",
          "213:     if (ptype != V_ASN1_SEQUENCE)",
          "",
          "[Added Lines]",
          "205:     if (privkey->type == V_ASN1_NEG_INTEGER || ptype != V_ASN1_SEQUENCE)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
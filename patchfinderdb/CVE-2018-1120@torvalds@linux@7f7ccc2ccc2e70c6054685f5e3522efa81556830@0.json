{
  "cve_id": "CVE-2018-1120",
  "cve_desc": "A flaw was found affecting the Linux kernel before version 4.17. By mmap()ing a FUSE-backed file onto a process's memory containing command line arguments (or environment strings), an attacker can cause utilities from psutils or procps (such as ps, w) or any other program which makes a read() call to the /proc/<pid>/cmdline (or /proc/<pid>/environ) files to block indefinitely (denial of service) or for some controlled time (as a synchronization primitive for other attacks).",
  "repo": "torvalds/linux",
  "patch_hash": "7f7ccc2ccc2e70c6054685f5e3522efa81556830",
  "patch_info": {
    "commit_hash": "7f7ccc2ccc2e70c6054685f5e3522efa81556830",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7f7ccc2ccc2e70c6054685f5e3522efa81556830",
    "files": [
      "fs/proc/base.c",
      "include/linux/mm.h",
      "mm/gup.c"
    ],
    "message": "proc: do not access cmdline nor environ from file-backed areas\n\nproc_pid_cmdline_read() and environ_read() directly access the target\nprocess' VM to retrieve the command line and environment. If this\nprocess remaps these areas onto a file via mmap(), the requesting\nprocess may experience various issues such as extra delays if the\nunderlying device is slow to respond.\n\nLet's simply refuse to access file-backed areas in these functions.\nFor this we add a new FOLL_ANON gup flag that is passed to all calls\nto access_remote_vm(). The code already takes care of such failures\n(including unmapped areas). Accesses via /proc/pid/mem were not\nchanged though.\n\nThis was assigned CVE-2018-1120.\n\nNote for stable backports: the patch may apply to kernels prior to 4.11\nbut silently miss one location; it must be checked that no call to\naccess_remote_vm() keeps zero as the last argument.\n\nReported-by: Qualys Security Advisory <qsa@qualys.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "fs/proc/base.c||fs/proc/base.c",
      "include/linux/mm.h||include/linux/mm.h",
      "mm/gup.c||mm/gup.c"
    ]
  },
  "patch_diff": {
    "fs/proc/base.c||fs/proc/base.c": [
      "File: fs/proc/base.c -> fs/proc/base.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "265:  if (rv <= 0)",
      "266:   goto out_free_page;",
      "",
      "[Removed Lines]",
      "264:  rv = access_remote_vm(mm, arg_end - 1, &c, 1, 0);",
      "",
      "[Added Lines]",
      "264:  rv = access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "279:    int nr_read;",
      "281:    _count = min3(count, len, PAGE_SIZE);",
      "283:    if (nr_read < 0)",
      "284:     rv = nr_read;",
      "285:    if (nr_read <= 0)",
      "",
      "[Removed Lines]",
      "282:    nr_read = access_remote_vm(mm, p, page, _count, 0);",
      "",
      "[Added Lines]",
      "282:    nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "325:     bool final;",
      "327:     _count = min3(count, len, PAGE_SIZE);",
      "329:     if (nr_read < 0)",
      "330:      rv = nr_read;",
      "331:     if (nr_read <= 0)",
      "",
      "[Removed Lines]",
      "328:     nr_read = access_remote_vm(mm, p, page, _count, 0);",
      "",
      "[Added Lines]",
      "328:     nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "946:   max_len = min_t(size_t, PAGE_SIZE, count);",
      "947:   this_len = min(max_len, this_len);",
      "951:   if (retval <= 0) {",
      "952:    ret = retval;",
      "",
      "[Removed Lines]",
      "949:   retval = access_remote_vm(mm, (env_start + src), page, this_len, 0);",
      "",
      "[Added Lines]",
      "949:   retval = access_remote_vm(mm, (env_start + src), page, this_len, FOLL_ANON);",
      "",
      "---------------"
    ],
    "include/linux/mm.h||include/linux/mm.h": [
      "File: include/linux/mm.h -> include/linux/mm.h"
    ],
    "mm/gup.c||mm/gup.c": [
      "File: mm/gup.c -> mm/gup.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "544:  if (vm_flags & (VM_IO | VM_PFNMAP))",
      "545:   return -EFAULT;",
      "547:  if (write) {",
      "548:   if (!(vm_flags & VM_WRITE)) {",
      "549:    if (!(gup_flags & FOLL_FORCE))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "547:  if (gup_flags & FOLL_ANON && !vma_is_anonymous(vma))",
      "548:   return -EFAULT;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5ab8271899658042fabc5ae7e6a99066a210bc0e",
      "candidate_info": {
        "commit_hash": "5ab8271899658042fabc5ae7e6a99066a210bc0e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5ab8271899658042fabc5ae7e6a99066a210bc0e",
        "files": [
          "fs/proc/base.c"
        ],
        "message": "fs/proc: simplify and clarify get_mm_cmdline() function\n\nWe have some very odd semantics for reading the command line through\n/proc, because we allow people to rewrite their own command line pretty\nmuch at will, and things get positively funky when you extend your\ncommand line past the point that used to be the end of the command line,\nand is now in the environment variable area.\n\nBut our weird semantics doesn't mean that we should write weird and\ncomplex code to handle them.\n\nSo re-write get_mm_cmdline() to be much simpler, and much more explicit\nabout what it is actually doing and why.  And avoid the extra check for\n\"is there a NUL character at the end of the command line where I expect\none to be\", by simply making the NUL character handling be part of the\nnormal \"once you hit the end of the command line, stop at the first NUL\ncharacter\" logic.\n\nIt's quite possible that we should stop the crazy \"walk into\nenvironment\" entirely, but happily it's not really the usual case.\n\nNOTE! We tried to really simplify and limit our odd cmdline parsing some\ntime ago, but people complained.  See commit c2c0bb44620d (\"proc: fix\nPAGE_SIZE limit of /proc/$PID/cmdline\") for details about why we have\nthis complexity.\n\nCc: Tejun Heo <tj@kernel.org>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nCc: Jarod Wilson <jarod@redhat.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/proc/base.c||fs/proc/base.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/proc/base.c||fs/proc/base.c"
          ],
          "candidate": [
            "fs/proc/base.c||fs/proc/base.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/proc/base.c||fs/proc/base.c": [
          "File: fs/proc/base.c -> fs/proc/base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "206: }",
          "208: static ssize_t get_mm_cmdline(struct mm_struct *mm, char __user *buf,",
          "210: {",
          "213:  unsigned long arg_start, arg_end, env_start, env_end;",
          "220:  if (!mm->env_end)",
          "221:   return 0;",
          "227:  down_read(&mm->mmap_sem);",
          "228:  arg_start = mm->arg_start;",
          "229:  arg_end = mm->arg_end;",
          "",
          "[Removed Lines]",
          "209:          size_t _count, loff_t *pos)",
          "211:  char *page;",
          "212:  unsigned long count = _count;",
          "214:  unsigned long len1, len2, len;",
          "215:  unsigned long p;",
          "216:  char c;",
          "217:  ssize_t rv;",
          "223:  page = (char *)__get_free_page(GFP_KERNEL);",
          "224:  if (!page)",
          "225:   return -ENOMEM;",
          "",
          "[Added Lines]",
          "209:          size_t count, loff_t *ppos)",
          "212:  unsigned long pos, len;",
          "213:  char *page;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231:  env_end = mm->env_end;",
          "232:  up_read(&mm->mmap_sem);",
          "303:   }",
          "348:   }",
          "349:  }",
          "352:  free_page((unsigned long)page);",
          "354: }",
          "356: static ssize_t get_task_cmdline(struct task_struct *tsk, char __user *buf,",
          "",
          "[Removed Lines]",
          "234:  BUG_ON(arg_start > arg_end);",
          "235:  BUG_ON(env_start > env_end);",
          "237:  len1 = arg_end - arg_start;",
          "238:  len2 = env_end - env_start;",
          "241:  if (len1 == 0) {",
          "242:   rv = 0;",
          "243:   goto out_free_page;",
          "244:  }",
          "249:  rv = access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON);",
          "250:  if (rv <= 0)",
          "251:   goto out_free_page;",
          "253:  rv = 0;",
          "255:  if (c == '\\0') {",
          "257:   if (len1 <= *pos)",
          "258:    goto out_free_page;",
          "260:   p = arg_start + *pos;",
          "261:   len = len1 - *pos;",
          "262:   while (count > 0 && len > 0) {",
          "263:    unsigned int _count;",
          "264:    int nr_read;",
          "266:    _count = min3(count, len, PAGE_SIZE);",
          "267:    nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);",
          "268:    if (nr_read < 0)",
          "269:     rv = nr_read;",
          "270:    if (nr_read <= 0)",
          "271:     goto out_free_page;",
          "273:    if (copy_to_user(buf, page, nr_read)) {",
          "274:     rv = -EFAULT;",
          "275:     goto out_free_page;",
          "276:    }",
          "278:    p += nr_read;",
          "279:    len -= nr_read;",
          "280:    buf += nr_read;",
          "281:    count -= nr_read;",
          "282:    rv += nr_read;",
          "283:   }",
          "284:  } else {",
          "289:   struct {",
          "290:    unsigned long p;",
          "291:    unsigned long len;",
          "292:   } cmdline[2] = {",
          "293:    { .p = arg_start, .len = len1 },",
          "294:    { .p = env_start, .len = len2 },",
          "295:   };",
          "296:   loff_t pos1 = *pos;",
          "297:   unsigned int i;",
          "299:   i = 0;",
          "300:   while (i < 2 && pos1 >= cmdline[i].len) {",
          "301:    pos1 -= cmdline[i].len;",
          "302:    i++;",
          "304:   while (i < 2) {",
          "305:    p = cmdline[i].p + pos1;",
          "306:    len = cmdline[i].len - pos1;",
          "307:    while (count > 0 && len > 0) {",
          "308:     unsigned int _count, l;",
          "309:     int nr_read;",
          "310:     bool final;",
          "312:     _count = min3(count, len, PAGE_SIZE);",
          "313:     nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);",
          "314:     if (nr_read < 0)",
          "315:      rv = nr_read;",
          "316:     if (nr_read <= 0)",
          "317:      goto out_free_page;",
          "323:     final = false;",
          "324:     l = strnlen(page, nr_read);",
          "325:     if (l < nr_read) {",
          "326:      nr_read = l;",
          "327:      final = true;",
          "328:     }",
          "330:     if (copy_to_user(buf, page, nr_read)) {",
          "331:      rv = -EFAULT;",
          "332:      goto out_free_page;",
          "333:     }",
          "335:     p += nr_read;",
          "336:     len -= nr_read;",
          "337:     buf += nr_read;",
          "338:     count -= nr_read;",
          "339:     rv += nr_read;",
          "341:     if (final)",
          "342:      goto out_free_page;",
          "343:    }",
          "346:    pos1 = 0;",
          "347:    i++;",
          "351: out_free_page:",
          "353:  return rv;",
          "",
          "[Added Lines]",
          "226:  if (arg_start >= arg_end)",
          "227:   return 0;",
          "235:  if (env_start != arg_end || env_start >= env_end)",
          "236:   env_start = env_end = arg_end;",
          "239:  pos = arg_start + *ppos;",
          "242:  if (pos < arg_start || pos >= env_end)",
          "243:   return 0;",
          "246:  if (env_end - pos < count)",
          "247:   count = env_end - pos;",
          "249:  page = (char *)__get_free_page(GFP_KERNEL);",
          "250:  if (!page)",
          "251:   return -ENOMEM;",
          "253:  len = 0;",
          "254:  while (count) {",
          "255:   int got;",
          "256:   size_t size = min_t(size_t, PAGE_SIZE, count);",
          "258:   got = access_remote_vm(mm, pos, page, size, FOLL_ANON);",
          "259:   if (got <= 0)",
          "260:    break;",
          "263:   if (pos + got >= arg_end) {",
          "264:    int n = 0;",
          "275:    if (pos < arg_end)",
          "276:     n = arg_end - pos - 1;",
          "279:    got = n + strnlen(page+n, got-n);",
          "280:    if (!got)",
          "281:     break;",
          "284:   got -= copy_to_user(buf, page, got);",
          "285:   if (unlikely(!got)) {",
          "286:    if (!len)",
          "287:     len = -EFAULT;",
          "288:    break;",
          "290:   pos += got;",
          "291:   buf += got;",
          "292:   len += got;",
          "293:   count -= got;",
          "297:  return len;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3cb4e162e4e258d906c07c411283b42b7f20a285",
      "candidate_info": {
        "commit_hash": "3cb4e162e4e258d906c07c411283b42b7f20a285",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/3cb4e162e4e258d906c07c411283b42b7f20a285",
        "files": [
          "fs/proc/base.c"
        ],
        "message": "proc: deduplicate /proc/*/cmdline implementation\n\nCode can be sonsolidated if a dummy region of 0 length is used in normal\ncase of \\0-separated command line:\n\n1) [arg_start, arg_end) + [dummy len=0]\n2) [arg_start, arg_end) + [env_start, env_end)\n\nLink: http://lkml.kernel.org/r/20180221193335.GB28678@avx2\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Andy Shevchenko <andy.shevchenko@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/proc/base.c||fs/proc/base.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/proc/base.c||fs/proc/base.c"
          ],
          "candidate": [
            "fs/proc/base.c||fs/proc/base.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/proc/base.c||fs/proc/base.c": [
          "File: fs/proc/base.c -> fs/proc/base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "213:  char *page;",
          "214:  unsigned long count = _count;",
          "215:  unsigned long arg_start, arg_end, env_start, env_end;",
          "218:  char __user *buf0 = buf;",
          "219:  char c;",
          "220:  int rv;",
          "",
          "[Removed Lines]",
          "216:  unsigned long len1, len2, len;",
          "217:  unsigned long p;",
          "",
          "[Added Lines]",
          "216:  unsigned long len1, len2;",
          "218:  struct {",
          "219:   unsigned long p;",
          "220:   unsigned long len;",
          "221:  } cmdline[2];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "264:  if (access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON) != 1)",
          "265:   goto end;",
          "267:  if (c == '\\0') {",
          "292:  } else {",
          "304:   loff_t pos1 = *pos;",
          "305:   unsigned int i;",
          "",
          "[Removed Lines]",
          "269:   if (len1 <= *pos)",
          "270:    goto end;",
          "272:   p = arg_start + *pos;",
          "273:   len = len1 - *pos;",
          "274:   while (count > 0 && len > 0) {",
          "275:    unsigned int nr_read;",
          "277:    nr_read = min3(count, len, PAGE_SIZE);",
          "278:    nr_read = access_remote_vm(mm, p, page, nr_read, FOLL_ANON);",
          "279:    if (nr_read == 0)",
          "280:     goto end;",
          "282:    if (copy_to_user(buf, page, nr_read)) {",
          "283:     rv = -EFAULT;",
          "284:     goto out_free_page;",
          "285:    }",
          "287:    p += nr_read;",
          "288:    len -= nr_read;",
          "289:    buf += nr_read;",
          "290:    count -= nr_read;",
          "291:   }",
          "297:   struct {",
          "298:    unsigned long p;",
          "299:    unsigned long len;",
          "300:   } cmdline[2] = {",
          "301:    { .p = arg_start, .len = len1 },",
          "302:    { .p = env_start, .len = len2 },",
          "303:   };",
          "",
          "[Added Lines]",
          "270:  cmdline[0].p = arg_start;",
          "271:  cmdline[0].len = len1;",
          "274:   cmdline[1].len = 0;",
          "280:   cmdline[1].p = env_start;",
          "281:   cmdline[1].len = len2;",
          "282:  }",
          "284:  {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "310:    i++;",
          "311:   }",
          "312:   while (i < 2) {",
          "313:    p = cmdline[i].p + pos1;",
          "314:    len = cmdline[i].len - pos1;",
          "315:    while (count > 0 && len > 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "294:    unsigned long p;",
          "295:    unsigned long len;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "329:     if (copy_to_user(buf, page, nr_write)) {",
          "330:      rv = -EFAULT;",
          "",
          "[Removed Lines]",
          "327:     nr_write = strnlen(page, nr_read);",
          "",
          "[Added Lines]",
          "311:     if (c == '\\0')",
          "312:      nr_write = nr_read;",
          "313:     else",
          "314:      nr_write = strnlen(page, nr_read);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f5b65348fd77839b50e79bc0a5e536832ea52d8d",
      "candidate_info": {
        "commit_hash": "f5b65348fd77839b50e79bc0a5e536832ea52d8d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f5b65348fd77839b50e79bc0a5e536832ea52d8d",
        "files": [
          "fs/proc/base.c"
        ],
        "message": "proc: fix missing final NUL in get_mm_cmdline() rewrite\n\nThe rewrite of the cmdline fetching missed the fact that we used to also\nreturn the final terminating NUL character of the last argument.  I\nhadn't noticed, and none of the tools I tested cared, but something\nobviously must care, because Michal Kubecek noticed the change in\nbehavior.\n\nTweak the \"find the end\" logic to actually include the NUL character,\nand once past the eend of argv, always start the strnlen() at the\nexpected (original) argument end.\n\nThis whole \"allow people to rewrite their arguments in place\" is a nasty\nhack and requires that odd slop handling at the end of the argv array,\nbut it's our traditional model, so we continue to support it.\n\nRepored-and-bisected-by: Michal Kubecek <mkubecek@suse.cz>\nReviewed-and-tested-by: Michal Kubecek <mkubecek@suse.cz>\nCc: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/proc/base.c||fs/proc/base.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/proc/base.c||fs/proc/base.c"
          ],
          "candidate": [
            "fs/proc/base.c||fs/proc/base.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/proc/base.c||fs/proc/base.c": [
          "File: fs/proc/base.c -> fs/proc/base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "235:  if (env_start != arg_end || env_start >= env_end)",
          "236:   env_start = env_end = arg_end;",
          "239:  pos = arg_start + *ppos;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "239:  if (env_end >= arg_end + PAGE_SIZE)",
          "240:   env_end = arg_end + PAGE_SIZE - 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "254:  while (count) {",
          "255:   int got;",
          "256:   size_t size = min_t(size_t, PAGE_SIZE, count);",
          "260:    break;",
          "263:   if (pos + got >= arg_end) {",
          "",
          "[Removed Lines]",
          "258:   got = access_remote_vm(mm, pos, page, size, FOLL_ANON);",
          "259:   if (got <= 0)",
          "",
          "[Added Lines]",
          "261:   long offset;",
          "268:   offset = (pos >= arg_end) ? pos - arg_end + 1 : 0;",
          "270:   got = access_remote_vm(mm, pos - offset, page, size + offset, FOLL_ANON);",
          "271:   if (got <= offset)",
          "273:   got -= offset;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "276:     n = arg_end - pos - 1;",
          "281:     break;",
          "282:   }",
          "285:   if (unlikely(!got)) {",
          "286:    if (!len)",
          "287:     len = -EFAULT;",
          "",
          "[Removed Lines]",
          "279:    got = n + strnlen(page+n, got-n);",
          "280:    if (!got)",
          "284:   got -= copy_to_user(buf, page, got);",
          "",
          "[Added Lines]",
          "292:    got = n + strnlen(page+n, offset+got-n);",
          "293:    if (got < offset)",
          "295:    got -= offset;",
          "298:    if (got < size)",
          "299:     got++;",
          "302:   got -= copy_to_user(buf, page+offset, got);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6a6cbe75dbdfaed6c4bbc2f109d69808f9cfa421",
      "candidate_info": {
        "commit_hash": "6a6cbe75dbdfaed6c4bbc2f109d69808f9cfa421",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6a6cbe75dbdfaed6c4bbc2f109d69808f9cfa421",
        "files": [
          "fs/proc/base.c"
        ],
        "message": "proc: simpler iterations for /proc/*/cmdline\n\n\"rv\" variable is used both as a counter of bytes transferred and an\nerror value holder but it can be reduced solely to error values if\noriginal start of userspace buffer is stashed and used at the very end.\n\n[akpm@linux-foundation.org: simplify cleanup code]\nLink: http://lkml.kernel.org/r/20180221193009.GA28678@avx2\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Andy Shevchenko <andy.shevchenko@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/proc/base.c||fs/proc/base.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/proc/base.c||fs/proc/base.c"
          ],
          "candidate": [
            "fs/proc/base.c||fs/proc/base.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/proc/base.c||fs/proc/base.c": [
          "File: fs/proc/base.c -> fs/proc/base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "215:  unsigned long arg_start, arg_end, env_start, env_end;",
          "216:  unsigned long len1, len2, len;",
          "217:  unsigned long p;",
          "218:  char c;",
          "221:  BUG_ON(*pos < 0);",
          "",
          "[Removed Lines]",
          "219:  ssize_t rv;",
          "",
          "[Added Lines]",
          "218:  char __user *buf0 = buf;",
          "220:  int rv;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "253:  len2 = env_end - env_start;",
          "271:  if (c == '\\0') {",
          "273:   if (len1 <= *pos)",
          "276:   p = arg_start + *pos;",
          "277:   len = len1 - *pos;",
          "",
          "[Removed Lines]",
          "256:  if (len1 == 0) {",
          "257:   rv = 0;",
          "258:   goto out_free_page;",
          "259:  }",
          "264:  if (access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON) != 1) {",
          "265:   rv = 0;",
          "266:   goto out_free_page;",
          "267:  }",
          "269:  rv = 0;",
          "274:    goto out_free_page;",
          "",
          "[Added Lines]",
          "257:  if (len1 == 0)",
          "258:   goto end;",
          "264:  if (access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON) != 1)",
          "265:   goto end;",
          "270:    goto end;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "281:    nr_read = min3(count, len, PAGE_SIZE);",
          "282:    nr_read = access_remote_vm(mm, p, page, nr_read, FOLL_ANON);",
          "283:    if (nr_read == 0)",
          "286:    if (copy_to_user(buf, page, nr_read)) {",
          "287:     rv = -EFAULT;",
          "",
          "[Removed Lines]",
          "284:     goto out_free_page;",
          "",
          "[Added Lines]",
          "280:     goto end;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "292:    len -= nr_read;",
          "293:    buf += nr_read;",
          "294:    count -= nr_read;",
          "296:   }",
          "297:  } else {",
          "",
          "[Removed Lines]",
          "295:    rv += nr_read;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "323:     nr_read = min3(count, len, PAGE_SIZE);",
          "324:     nr_read = access_remote_vm(mm, p, page, nr_read, FOLL_ANON);",
          "325:     if (nr_read == 0)",
          "",
          "[Removed Lines]",
          "326:      goto out_free_page;",
          "",
          "[Added Lines]",
          "321:      goto end;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "340:     len -= nr_write;",
          "341:     buf += nr_write;",
          "342:     count -= nr_write;",
          "345:     if (nr_write < nr_read)",
          "347:    }",
          "",
          "[Removed Lines]",
          "343:     rv += nr_write;",
          "346:      goto out_free_page;",
          "",
          "[Added Lines]",
          "340:      goto end;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "352:   }",
          "353:  }",
          "355: out_free_page:",
          "356:  free_page((unsigned long)page);",
          "357: out_mmput:",
          "358:  mmput(mm);",
          "361:  return rv;",
          "362: }",
          "",
          "[Removed Lines]",
          "359:  if (rv > 0)",
          "",
          "[Added Lines]",
          "349: end:",
          "351:  rv = buf - buf0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b42262af5ecfc64f92423dc1e5ef634d9195f4b0",
      "candidate_info": {
        "commit_hash": "b42262af5ecfc64f92423dc1e5ef634d9195f4b0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b42262af5ecfc64f92423dc1e5ef634d9195f4b0",
        "files": [
          "fs/proc/base.c"
        ],
        "message": "proc: more \"unsigned int\" in /proc/*/cmdline\n\naccess_remote_vm() doesn't return negative errors, it returns number of\nbytes read/written (0 if error occurs).  This allows to delete some\ncomparisons which never trigger.\n\nReuse \"nr_read\" variable while I'm at it.\n\nLink: http://lkml.kernel.org/r/20180221192605.GB28548@avx2\nSigned-off-by: Alexey Dobriyan <adobriyan@gmail.com>\nReviewed-by: Andrew Morton <akpm@linux-foundation.org>\nCc: Andy Shevchenko <andy.shevchenko@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/proc/base.c||fs/proc/base.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/proc/base.c||fs/proc/base.c"
          ],
          "candidate": [
            "fs/proc/base.c||fs/proc/base.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/proc/base.c||fs/proc/base.c": [
          "File: fs/proc/base.c -> fs/proc/base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "266:   goto out_free_page;",
          "268:  rv = 0;",
          "",
          "[Removed Lines]",
          "264:  rv = access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON);",
          "265:  if (rv <= 0)",
          "",
          "[Added Lines]",
          "264:  if (access_remote_vm(mm, arg_end - 1, &c, 1, FOLL_ANON) != 1) {",
          "265:   rv = 0;",
          "267:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "275:   p = arg_start + *pos;",
          "276:   len = len1 - *pos;",
          "277:   while (count > 0 && len > 0) {",
          "286:     goto out_free_page;",
          "288:    if (copy_to_user(buf, page, nr_read)) {",
          "",
          "[Removed Lines]",
          "278:    unsigned int _count;",
          "279:    int nr_read;",
          "281:    _count = min3(count, len, PAGE_SIZE);",
          "282:    nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);",
          "283:    if (nr_read < 0)",
          "284:     rv = nr_read;",
          "285:    if (nr_read <= 0)",
          "",
          "[Added Lines]",
          "279:    unsigned int nr_read;",
          "281:    nr_read = min3(count, len, PAGE_SIZE);",
          "282:    nr_read = access_remote_vm(mm, p, page, nr_read, FOLL_ANON);",
          "283:    if (nr_read == 0)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "320:    p = cmdline[i].p + pos1;",
          "321:    len = cmdline[i].len - pos1;",
          "322:    while (count > 0 && len > 0) {",
          "325:     bool final;",
          "332:      goto out_free_page;",
          "",
          "[Removed Lines]",
          "323:     unsigned int _count, l;",
          "324:     int nr_read;",
          "327:     _count = min3(count, len, PAGE_SIZE);",
          "328:     nr_read = access_remote_vm(mm, p, page, _count, FOLL_ANON);",
          "329:     if (nr_read < 0)",
          "330:      rv = nr_read;",
          "331:     if (nr_read <= 0)",
          "",
          "[Added Lines]",
          "321:     unsigned int nr_read, l;",
          "324:     nr_read = min3(count, len, PAGE_SIZE);",
          "325:     nr_read = access_remote_vm(mm, p, page, nr_read, FOLL_ANON);",
          "326:     if (nr_read == 0)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
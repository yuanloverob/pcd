{
  "cve_id": "CVE-2014-0063",
  "cve_desc": "Multiple stack-based buffer overflows in PostgreSQL before 8.4.20, 9.0.x before 9.0.16, 9.1.x before 9.1.12, 9.2.x before 9.2.7, and 9.3.x before 9.3.3 allow remote authenticated users to cause a denial of service (crash) or possibly execute arbitrary code via vectors related to an incorrect MAXDATELEN constant and datetime values involving (1) intervals, (2) timestamps, or (3) timezones, a different vulnerability than CVE-2014-0065.",
  "repo": "postgres/postgres",
  "patch_hash": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
  "patch_info": {
    "commit_hash": "4318daecc959886d001a6e79c6ea853e8b1dfb4b",
    "repo": "postgres/postgres",
    "commit_url": "https://github.com/postgres/postgres/commit/4318daecc959886d001a6e79c6ea853e8b1dfb4b",
    "files": [
      "src/include/utils/datetime.h",
      "src/interfaces/ecpg/pgtypeslib/datetime.c",
      "src/interfaces/ecpg/pgtypeslib/dt.h",
      "src/interfaces/ecpg/pgtypeslib/dt_common.c",
      "src/interfaces/ecpg/pgtypeslib/interval.c",
      "src/interfaces/ecpg/pgtypeslib/timestamp.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
      "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
      "src/test/regress/expected/interval.out",
      "src/test/regress/sql/interval.sql"
    ],
    "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
    "before_after_code_files": [
      "src/include/utils/datetime.h||src/include/utils/datetime.h",
      "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
      "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
      "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
      "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
      "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
      "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
      "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
      "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
    ]
  },
  "patch_diff": {
    "src/include/utils/datetime.h||src/include/utils/datetime.h": [
      "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "188: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
      "189: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
      "199: typedef struct",
      "",
      "[Removed Lines]",
      "191: #define MAXDATELEN  63  /* maximum possible length of an input date",
      "193: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
      "195: #define TOKMAXLEN  10  /* only this many chars are stored in",
      "",
      "[Added Lines]",
      "197: #define MAXDATELEN  128",
      "199: #define MAXDATEFIELDS 25",
      "201: #define TOKMAXLEN  10",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
      "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "60:  int   nf;",
      "61:  char    *field[MAXDATEFIELDS];",
      "62:  int   ftype[MAXDATEFIELDS];",
      "64:  char    *realptr;",
      "65:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
      "67:  bool  EuroDates = FALSE;",
      "69:  errno = 0;",
      "71:  {",
      "72:   errno = PGTYPES_DATE_BAD_DATE;",
      "73:   return INT_MIN;",
      "",
      "[Removed Lines]",
      "63:  char  lowstr[MAXDATELEN + 1];",
      "70:  if (strlen(str) >= sizeof(lowstr))",
      "",
      "[Added Lines]",
      "63:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
      "70:  if (strlen(str) > MAXDATELEN)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
      "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
      "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
      "203: typedef struct",
      "",
      "[Removed Lines]",
      "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
      "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
      "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
      "",
      "[Added Lines]",
      "201: #define MAXDATELEN  128",
      "203: #define MAXDATEFIELDS 25",
      "205: #define TOKMAXLEN  10",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
      "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1171:  if ((cp = strchr(str, '.')) != NULL)",
      "1172:  {",
      "1173: #ifdef HAVE_INT64_TIMESTAMP",
      "1184: #else",
      "",
      "[Removed Lines]",
      "1174:   char  fstr[MAXDATELEN + 1];",
      "1180:   strcpy(fstr, (cp + 1));",
      "1181:   strcpy(fstr + strlen(fstr), \"000000\");",
      "",
      "[Added Lines]",
      "1174:   char  fstr[7];",
      "1175:   int   i;",
      "1177:   cp++;",
      "1187:   for (i = 0; i < 6; i++)",
      "1188:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
      "1189:   fstr[i] = '\\0';",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1531:   else if (*cp == '.')",
      "1532:   {",
      "1533: #ifdef HAVE_INT64_TIMESTAMP",
      "1544: #else",
      "1545:    str = cp;",
      "",
      "[Removed Lines]",
      "1534:    char  fstr[MAXDATELEN + 1];",
      "1540:    strncpy(fstr, (cp + 1), 7);",
      "1541:    strcpy(fstr + strlen(fstr), \"000000\");",
      "",
      "[Added Lines]",
      "1541:    char  fstr[7];",
      "1542:    int   i;",
      "1544:    cp++;",
      "1554:    for (i = 0; i < 6; i++)",
      "1555:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
      "1556:    fstr[i] = '\\0';",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1678:  while (*(*endstr) != '\\0')",
      "1679:  {",
      "1680:   field[nf] = lp;",
      "1683:   if (isdigit((unsigned char) *(*endstr)))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1699:   if (nf >= MAXDATEFIELDS)",
      "1700:    return -1;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1820:   nf++;",
      "1823:  }",
      "",
      "[Removed Lines]",
      "1821:   if (nf > MAXDATEFIELDS)",
      "1822:    return -1;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
      "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1094:  tm->tm_sec = 0;",
      "1095:  fsec = 0;",
      "1098:  {",
      "1099:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
      "1100:   return NULL;",
      "",
      "[Removed Lines]",
      "1097:  if (strlen(str) >= sizeof(lowstr))",
      "",
      "[Added Lines]",
      "1097:  if (strlen(str) > MAXDATELEN)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
      "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "294:  char    *realptr;",
      "295:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
      "298:  {",
      "299:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
      "300:   return (noresult);",
      "",
      "[Removed Lines]",
      "297:  if (strlen(str) >= sizeof(lowstr))",
      "",
      "[Added Lines]",
      "297:  if (strlen(str) > MAXDATELEN)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
      "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "45:       \"1999.008\",",
      "46:       \"J2451187\",",
      "47:       \"January 8, 99 BC\",",
      "48:       NULL };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "52:       \"1:59 PDT\",",
      "53:       \"13:24:40 -8:00\",",
      "54:       \"13:24:40.495+3\",",
      "55:       NULL };",
      "57: char *intervals[] = { \"1 minute\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "64:       \"13:24:40.123456789+3\",",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "77:  date date1 ;",
      "80:  timestamp ts1 , ts2 ;",
      "83:  char * text ;",
      "86:  interval * i1 ;",
      "89:  date * dc ;",
      "94:  int i, j;",
      "",
      "[Removed Lines]",
      "76: #line 52 \"dt_test2.pgc\"",
      "79: #line 53 \"dt_test2.pgc\"",
      "82: #line 54 \"dt_test2.pgc\"",
      "85: #line 55 \"dt_test2.pgc\"",
      "88: #line 56 \"dt_test2.pgc\"",
      "91: #line 57 \"dt_test2.pgc\"",
      "",
      "[Added Lines]",
      "86: #line 62 \"dt_test2.pgc\"",
      "89: #line 63 \"dt_test2.pgc\"",
      "92: #line 64 \"dt_test2.pgc\"",
      "95: #line 65 \"dt_test2.pgc\"",
      "98: #line 66 \"dt_test2.pgc\"",
      "101: #line 67 \"dt_test2.pgc\"",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
      "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: TS[3,1]: 1999-01-08 01:59:00",
      "9: TS[3,2]: 1999-01-08 13:24:40",
      "10: TS[3,3]: 1999-01-08 13:24:40.495",
      "11: Date[4]: 1999-01-08 (N - F)",
      "12: TS[4,0]: 1999-01-08 00:04:00",
      "13: TS[4,1]: 1999-01-08 01:59:00",
      "14: TS[4,2]: 1999-01-08 13:24:40",
      "15: TS[4,3]: 1999-01-08 13:24:40.495",
      "16: Date[5]: 1999-01-08 (N - F)",
      "17: TS[5,0]: 1999-01-08 00:04:00",
      "18: TS[5,1]: 1999-01-08 01:59:00",
      "19: TS[5,2]: 1999-01-08 13:24:40",
      "20: TS[5,3]: 1999-01-08 13:24:40.495",
      "21: Date[6]: 1999-01-18 (N - F)",
      "22: TS[6,0]: 1999-01-18 00:04:00",
      "23: TS[6,1]: 1999-01-18 01:59:00",
      "24: TS[6,2]: 1999-01-18 13:24:40",
      "25: TS[6,3]: 1999-01-18 13:24:40.495",
      "26: Date[7]: 2003-01-02 (N - F)",
      "27: TS[7,0]: 2003-01-02 00:04:00",
      "28: TS[7,1]: 2003-01-02 01:59:00",
      "29: TS[7,2]: 2003-01-02 13:24:40",
      "30: TS[7,3]: 2003-01-02 13:24:40.495",
      "31: Date[8]: 1999-01-08 (N - F)",
      "32: TS[8,0]: 1999-01-08 00:04:00",
      "33: TS[8,1]: 1999-01-08 01:59:00",
      "34: TS[8,2]: 1999-01-08 13:24:40",
      "35: TS[8,3]: 1999-01-08 13:24:40.495",
      "36: Date[9]: 1999-01-08 (N - F)",
      "37: TS[9,0]: 1999-01-08 00:04:00",
      "38: TS[9,1]: 1999-01-08 01:59:00",
      "39: TS[9,2]: 1999-01-08 13:24:40",
      "40: TS[9,3]: 1999-01-08 13:24:40.495",
      "41: Date[10]: 1999-01-08 (N - F)",
      "42: TS[10,0]: 1999-01-08 00:04:00",
      "43: TS[10,1]: 1999-01-08 01:59:00",
      "44: TS[10,2]: 1999-01-08 13:24:40",
      "45: TS[10,3]: 1999-01-08 13:24:40.495",
      "46: Date[11]: 1999-01-08 (N - F)",
      "47: TS[11,0]: 1999-01-08 00:04:00",
      "48: TS[11,1]: 1999-01-08 01:59:00",
      "49: TS[11,2]: 1999-01-08 13:24:40",
      "50: TS[11,3]: 1999-01-08 13:24:40.495",
      "51: Date[12]: 1999-01-08 (N - F)",
      "52: TS[12,0]: 1999-01-08 00:04:00",
      "53: TS[12,1]: 1999-01-08 01:59:00",
      "54: TS[12,2]: 1999-01-08 13:24:40",
      "55: TS[12,3]: 1999-01-08 13:24:40.495",
      "56: Date[13]: 2006-01-08 (N - F)",
      "57: TS[13,0]: 2006-01-08 00:04:00",
      "58: TS[13,1]: 2006-01-08 01:59:00",
      "59: TS[13,2]: 2006-01-08 13:24:40",
      "60: TS[13,3]: 2006-01-08 13:24:40.495",
      "61: Date[14]: 1999-01-08 (N - F)",
      "62: TS[14,0]: 1999-01-08 00:04:00",
      "63: TS[14,1]: 1999-01-08 01:59:00",
      "64: TS[14,2]: 1999-01-08 13:24:40",
      "65: TS[14,3]: 1999-01-08 13:24:40.495",
      "66: Date[15]: 1999-01-08 (N - F)",
      "67: TS[15,0]: 1999-01-08 00:04:00",
      "68: TS[15,1]: 1999-01-08 01:59:00",
      "69: TS[15,2]: 1999-01-08 13:24:40",
      "70: TS[15,3]: 1999-01-08 13:24:40.495",
      "71: Date[16]: 1999-01-08 (N - F)",
      "72: TS[16,0]: 1999-01-08 00:04:00",
      "73: TS[16,1]: 1999-01-08 01:59:00",
      "74: TS[16,2]: 1999-01-08 13:24:40",
      "75: TS[16,3]: 1999-01-08 13:24:40.495",
      "76: Date[17]: 1999-01-08 (N - F)",
      "77: TS[17,0]: 1999-01-08 00:04:00",
      "78: TS[17,1]: 1999-01-08 01:59:00",
      "79: TS[17,2]: 1999-01-08 13:24:40",
      "80: TS[17,3]: 1999-01-08 13:24:40.495",
      "81: Date[18]: 1999-01-08 (N - F)",
      "82: TS[18,0]: 1999-01-08 00:04:00",
      "83: TS[18,1]: 1999-01-08 01:59:00",
      "84: TS[18,2]: 1999-01-08 13:24:40",
      "85: TS[18,3]: 1999-01-08 13:24:40.495",
      "86: Date[19]: 0099-01-08 BC (N - F)",
      "87: TS[19,0]: 0099-01-08 00:04:00 BC",
      "88: TS[19,1]: 0099-01-08 01:59:00 BC",
      "89: TS[19,2]: 0099-01-08 13:24:40 BC",
      "90: interval[0]: @ 1 min",
      "91: interval_copy[0]: @ 1 min",
      "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: TS[3,4]: 1999-01-08 13:24:40.123456",
      "17: TS[4,4]: 1999-01-08 13:24:40.123456",
      "23: TS[5,4]: 1999-01-08 13:24:40.123456",
      "29: TS[6,4]: 1999-01-18 13:24:40.123456",
      "35: TS[7,4]: 2003-01-02 13:24:40.123456",
      "41: TS[8,4]: 1999-01-08 13:24:40.123456",
      "47: TS[9,4]: 1999-01-08 13:24:40.123456",
      "53: TS[10,4]: 1999-01-08 13:24:40.123456",
      "59: TS[11,4]: 1999-01-08 13:24:40.123456",
      "65: TS[12,4]: 1999-01-08 13:24:40.123456",
      "71: TS[13,4]: 2006-01-08 13:24:40.123456",
      "77: TS[14,4]: 1999-01-08 13:24:40.123456",
      "83: TS[15,4]: 1999-01-08 13:24:40.123456",
      "89: TS[16,4]: 1999-01-08 13:24:40.123456",
      "95: TS[17,4]: 1999-01-08 13:24:40.123456",
      "101: TS[18,4]: 1999-01-08 13:24:40.123456",
      "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
      "107: Date[20]: - (N - T)",
      "108: Date[21]: - (N - T)",
      "",
      "---------------"
    ],
    "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
      "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
      "--- Hunk 1 ---",
      "[Context before]",
      "27:       \"1999.008\",",
      "28:       \"J2451187\",",
      "29:       \"January 8, 99 BC\",",
      "30:       NULL };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
      "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "34:       \"1:59 PDT\",",
      "35:       \"13:24:40 -8:00\",",
      "36:       \"13:24:40.495+3\",",
      "37:       NULL };",
      "39: char *intervals[] = { \"1 minute\",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "46:       \"13:24:40.123456789+3\",",
      "",
      "---------------"
    ],
    "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
      "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
      "--- Hunk 1 ---",
      "[Context before]",
      "108: -- test long interval input",
      "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
      "112: -- test justify_hours() and justify_days()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "111: -- test long interval output",
      "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0b7026d964c79515c8df00b37ab41d550bcdcbde",
      "candidate_info": {
        "commit_hash": "0b7026d964c79515c8df00b37ab41d550bcdcbde",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/0b7026d964c79515c8df00b37ab41d550bcdcbde",
        "files": [
          "contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h"
        ],
        "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
        "before_after_code_files": [
          "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h||contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h||src/include/utils/varbit.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "contrib/hstore/hstore.h||contrib/hstore/hstore.h": [
          "File: contrib/hstore/hstore.h -> contrib/hstore/hstore.h"
        ],
        "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c": [
          "File: contrib/hstore/hstore_io.c -> contrib/hstore/hstore_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #include \"funcapi.h\"",
          "12: #include \"libpq/pqformat.h\"",
          "13: #include \"utils/lsyscache.h\"",
          "14: #include \"utils/typcache.h\"",
          "16: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "438:   PG_RETURN_POINTER(out);",
          "439:  }",
          "441:  pairs = palloc(pcount * sizeof(Pairs));",
          "443:  for (i = 0; i < pcount; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "442:  if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))",
          "443:   ereport(ERROR,",
          "444:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "445:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "446:       pcount, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "553:        TEXTOID, -1, false, 'i',",
          "554:        &key_datums, &key_nulls, &key_count);",
          "558:  if (PG_ARGISNULL(1))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "563:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "564:   ereport(ERROR,",
          "565:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "566:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "567:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "676:  count = in_count / 2;",
          "678:  pairs = palloc(count * sizeof(Pairs));",
          "680:  for (i = 0; i < count; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692:  if (count > MaxAllocSize / sizeof(Pairs))",
          "693:   ereport(ERROR,",
          "694:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "695:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "696:       count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c": [
          "File: contrib/hstore/hstore_op.c -> contrib/hstore/hstore_op.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"catalog/pg_type.h\"",
          "10: #include \"funcapi.h\"",
          "11: #include \"utils/builtins.h\"",
          "13: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:   return NULL;",
          "92:  }",
          "94:  key_pairs = palloc(sizeof(Pairs) * key_count);",
          "96:  for (i = 0, j = 0; i < key_count; i++)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "103:   ereport(ERROR,",
          "104:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "105:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "106:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/intarray/_int.h||contrib/intarray/_int.h": [
          "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define ___INT_H__",
          "7: #include \"utils/array.h\"",
          "10: #define MAXNUMRANGE 100",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138: #define HDRSIZEQT offsetof(QUERYTYPE, items)",
          "139: #define COMPUTESIZE(size) ( HDRSIZEQT + (size) * sizeof(ITEM) )",
          "140: #define GETQUERY(x)  ( (x)->items )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
          "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "451: static void",
          "452: findoprnd(ITEM *ptr, int4 *pos)",
          "453: {",
          "454: #ifdef BS_DEBUG",
          "455:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
          "456:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "455:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "511:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
          "512:      errmsg(\"empty query\")));",
          "514:  commonlen = COMPUTESIZE(state.num);",
          "515:  query = (QUERYTYPE *) palloc(commonlen);",
          "516:  SET_VARSIZE(query, commonlen);",
          "517:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "517:  if (state.num > QUERYTYPEMAXITEMS)",
          "518:   ereport(ERROR,",
          "519:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "520:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
          "521:       state.num, (int) QUERYTYPEMAXITEMS)));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
          "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"postgres.h\"",
          "7: #include \"fmgr.h\"",
          "8: #include \"tsearch/ts_locale.h\"",
          "10: typedef struct",
          "11: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "113: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int4))",
          "114: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
          "115: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "116: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "116: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
          "117:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
          "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <ctype.h>",
          "10: #include \"ltree.h\"",
          "11: #include \"crc32.h\"",
          "13: PG_FUNCTION_INFO_V1(ltree_in);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   ptr += charlen;",
          "65:  }",
          "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
          "68:  ptr = buf;",
          "69:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
          "69:   ereport(ERROR,",
          "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:  }",
          "230:  num++;",
          "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
          "232:  ptr = buf;",
          "233:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:  if (num > MaxAllocSize / ITEMSIZE)",
          "238:   ereport(ERROR,",
          "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
          "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"crc32.h\"",
          "11: #include \"ltree.h\"",
          "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
          "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"miscadmin.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  int4  lenstack = 0;",
          "214:  uint16  flag = 0;",
          "216:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
          "217:  {",
          "218:   switch (type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277: static void",
          "278: findoprnd(ITEM *ptr, int4 *pos)",
          "279: {",
          "280:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
          "281:  {",
          "282:   ptr[*pos].left = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:      errmsg(\"syntax error\"),",
          "342:      errdetail(\"Empty query.\")));",
          "345:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
          "346:  query = (ltxtquery *) palloc(commonlen);",
          "347:  SET_VARSIZE(query, commonlen);",
          "348:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
          "352:   ereport(ERROR,",
          "353:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "354:      errmsg(\"ltxtquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
          "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1403:  char    *s;",
          "1404:  int   npts;",
          "1405:  int   size;",
          "1406:  int   depth = 0;",
          "1408:  if ((npts = pair_count(str, ',')) <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1406:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1421:   depth++;",
          "1422:  }",
          "1425:  path = (PATH *) palloc(size);",
          "1427:  SET_VARSIZE(path, size);",
          "",
          "[Removed Lines]",
          "1424:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
          "",
          "[Added Lines]",
          "1425:  base_size = sizeof(path->p[0]) * npts;",
          "1426:  size = offsetof(PATH, p[0]) + base_size;",
          "1429:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
          "1430:   ereport(ERROR,",
          "1431:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "1432:      errmsg(\"too many points requested\")));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3465:  POLYGON    *poly;",
          "3466:  int   npts;",
          "3467:  int   size;",
          "3468:  int   isopen;",
          "3469:  char    *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3477:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3473:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
          "3474:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
          "3479:  SET_VARSIZE(poly, size);",
          "",
          "[Removed Lines]",
          "3476:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
          "",
          "[Added Lines]",
          "3486:  base_size = sizeof(poly->p[0]) * npts;",
          "3487:  size = offsetof(POLYGON, p[0]) + base_size;",
          "3490:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
          "3491:   ereport(ERROR,",
          "3492:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "3493:      errmsg(\"too many points requested\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
          "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "517:   return query;",
          "518:  }",
          "521:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
          "522:  query = (TSQuery) palloc0(commonlen);",
          "523:  SET_VARSIZE(query, commonlen);",
          "524:  query->size = list_length(state.polstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "520:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
          "521:   ereport(ERROR,",
          "522:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "523:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
          "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:  QTN2QTState state;",
          "336:  cntsize(in, &sumlen, &nnode);",
          "337:  len = COMPUTESIZE(nnode, sumlen);",
          "339:  out = (TSQuery) palloc0(len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
          "339:   ereport(ERROR,",
          "340:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "341:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
          "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"miscadmin.h\"",
          "28: #include \"libpq/pqformat.h\"",
          "29: #include \"utils/builtins.h\"",
          "30: #include \"utils/snapmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: #define TXID_SNAPSHOT_SIZE(nxip) \\",
          "68:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: #define TXID_SNAPSHOT_MAX_NXIP \\",
          "71:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "444:  txid  last = 0;",
          "445:  int   nxip;",
          "446:  int   i;",
          "449:  txid  xmin,",
          "450:     xmax;",
          "457:  nxip = pq_getmsgint(buf, 4);",
          "461:   goto bad_format;",
          "463:  xmin = pq_getmsgint64(buf);",
          "",
          "[Removed Lines]",
          "447:  int   avail;",
          "448:  int   expect;",
          "458:  avail = buf->len - buf->cursor;",
          "459:  expect = 8 + 8 + nxip * 8;",
          "460:  if (nxip < 0 || nxip > avail || expect > avail)",
          "",
          "[Added Lines]",
          "455:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
          "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:   sp = input_string;",
          "148:  }",
          "150:  slen = strlen(sp);",
          "152:  if (bit_not_hex)",
          "153:   bitlen = slen;",
          "154:  else",
          "155:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "158:  {",
          "159:   if (slen > VARBITMAXLEN / 4)",
          "160:    ereport(ERROR,",
          "161:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "162:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "163:       VARBITMAXLEN)));",
          "165:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "449:   sp = input_string;",
          "450:  }",
          "452:  slen = strlen(sp);",
          "454:  if (bit_not_hex)",
          "455:   bitlen = slen;",
          "456:  else",
          "457:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "470:  {",
          "471:   if (slen > VARBITMAXLEN / 4)",
          "472:    ereport(ERROR,",
          "473:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "474:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "475:       VARBITMAXLEN)));",
          "477:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "910:  bitlen1 = VARBITLEN(arg1);",
          "911:  bitlen2 = VARBITLEN(arg2);",
          "913:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
          "915:  result = (VarBit *) palloc(bytelen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "936:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
          "937:   ereport(ERROR,",
          "938:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "939:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "940:       VARBITMAXLEN)));",
          "",
          "---------------"
        ],
        "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
          "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #define _PG_TSTYPE_H_",
          "15: #include \"fmgr.h\"",
          "16: #include \"utils/pg_crc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
          "247: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "246: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
          "247:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
          "",
          "---------------"
        ],
        "src/include/utils/varbit.h||src/include/utils/varbit.h": [
          "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #ifndef VARBIT_H",
          "16: #define VARBIT_H",
          "18: #include \"fmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <limits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
          "55:          VARHDRSZ + VARBITHDRSZ)",
          "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e4a4fa22352b062bc3548c91fa9bfc6caed7b073",
      "candidate_info": {
        "commit_hash": "e4a4fa22352b062bc3548c91fa9bfc6caed7b073",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/e4a4fa22352b062bc3548c91fa9bfc6caed7b073",
        "files": [
          "src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/expected/interval.out",
          "src/test/regress/sql/interval.sql"
        ],
        "message": "Fix handling of wide datetime input/output.\n\nMany server functions use the MAXDATELEN constant to size a buffer for\nparsing or displaying a datetime value.  It was much too small for the\nlongest possible interval output and slightly too small for certain\nvalid timestamp input, particularly input with a long timezone name.\nThe long input was rejected needlessly; the long output caused\ninterval_out() to overrun its buffer.  ECPG's pgtypes library has a copy\nof the vulnerable functions, which bore the same vulnerabilities along\nwith some of its own.  In contrast to the server, certain long inputs\ncaused stack overflow rather than failing cleanly.  Back-patch to 8.4\n(all supported versions).\n\nReported by Daniel Sch\u00fcssler, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0063",
        "before_after_code_files": [
          "src/include/utils/datetime.h||src/include/utils/datetime.h",
          "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
          "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
          "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
          "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/include/utils/datetime.h||src/include/utils/datetime.h",
            "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
            "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
            "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
            "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
            "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
            "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
            "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
          ],
          "candidate": [
            "src/include/utils/datetime.h||src/include/utils/datetime.h",
            "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c",
            "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h",
            "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c",
            "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c",
            "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
            "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
            "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
            "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql"
          ]
        }
      },
      "candidate_diff": {
        "src/include/utils/datetime.h||src/include/utils/datetime.h": [
          "File: src/include/utils/datetime.h -> src/include/utils/datetime.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "188: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "189: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_ALL_SECS_M)",
          "199: typedef struct",
          "",
          "[Removed Lines]",
          "191: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "193: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "195: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "197: #define MAXDATELEN  128",
          "199: #define MAXDATEFIELDS 25",
          "201: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/datetime.c||src/interfaces/ecpg/pgtypeslib/datetime.c": [
          "File: src/interfaces/ecpg/pgtypeslib/datetime.c -> src/interfaces/ecpg/pgtypeslib/datetime.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:  int   nf;",
          "61:  char    *field[MAXDATEFIELDS];",
          "62:  int   ftype[MAXDATEFIELDS];",
          "64:  char    *realptr;",
          "65:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "67:  bool  EuroDates = FALSE;",
          "69:  errno = 0;",
          "71:  {",
          "72:   errno = PGTYPES_DATE_BAD_DATE;",
          "73:   return INT_MIN;",
          "",
          "[Removed Lines]",
          "63:  char  lowstr[MAXDATELEN + 1];",
          "70:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "63:  char  lowstr[MAXDATELEN + MAXDATEFIELDS];",
          "70:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt.h||src/interfaces/ecpg/pgtypeslib/dt.h": [
          "File: src/interfaces/ecpg/pgtypeslib/dt.h -> src/interfaces/ecpg/pgtypeslib/dt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "192: #define DTK_DATE_M  (DTK_M(YEAR) | DTK_M(MONTH) | DTK_M(DAY))",
          "193: #define DTK_TIME_M  (DTK_M(HOUR) | DTK_M(MINUTE) | DTK_M(SECOND))",
          "203: typedef struct",
          "",
          "[Removed Lines]",
          "195: #define MAXDATELEN  63  /* maximum possible length of an input date",
          "197: #define MAXDATEFIELDS 25  /* maximum possible number of fields in a date",
          "199: #define TOKMAXLEN  10  /* only this many chars are stored in",
          "",
          "[Added Lines]",
          "201: #define MAXDATELEN  128",
          "203: #define MAXDATEFIELDS 25",
          "205: #define TOKMAXLEN  10",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/dt_common.c||src/interfaces/ecpg/pgtypeslib/dt_common.c": [
          "File: src/interfaces/ecpg/pgtypeslib/dt_common.c -> src/interfaces/ecpg/pgtypeslib/dt_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1171:  if ((cp = strchr(str, '.')) != NULL)",
          "1172:  {",
          "1173: #ifdef HAVE_INT64_TIMESTAMP",
          "1184: #else",
          "",
          "[Removed Lines]",
          "1174:   char  fstr[MAXDATELEN + 1];",
          "1180:   strcpy(fstr, (cp + 1));",
          "1181:   strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1174:   char  fstr[7];",
          "1175:   int   i;",
          "1177:   cp++;",
          "1187:   for (i = 0; i < 6; i++)",
          "1188:    fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1189:   fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1531:   else if (*cp == '.')",
          "1532:   {",
          "1533: #ifdef HAVE_INT64_TIMESTAMP",
          "1544: #else",
          "1545:    str = cp;",
          "",
          "[Removed Lines]",
          "1534:    char  fstr[MAXDATELEN + 1];",
          "1540:    strncpy(fstr, (cp + 1), 7);",
          "1541:    strcpy(fstr + strlen(fstr), \"000000\");",
          "",
          "[Added Lines]",
          "1541:    char  fstr[7];",
          "1542:    int   i;",
          "1544:    cp++;",
          "1554:    for (i = 0; i < 6; i++)",
          "1555:     fstr[i] = *cp != '\\0' ? *cp++ : '0';",
          "1556:    fstr[i] = '\\0';",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1678:  while (*(*endstr) != '\\0')",
          "1679:  {",
          "1680:   field[nf] = lp;",
          "1683:   if (isdigit((unsigned char) *(*endstr)))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1699:   if (nf >= MAXDATEFIELDS)",
          "1700:    return -1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1820:   nf++;",
          "1823:  }",
          "",
          "[Removed Lines]",
          "1821:   if (nf > MAXDATEFIELDS)",
          "1822:    return -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/interval.c||src/interfaces/ecpg/pgtypeslib/interval.c": [
          "File: src/interfaces/ecpg/pgtypeslib/interval.c -> src/interfaces/ecpg/pgtypeslib/interval.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1091:  tm->tm_sec = 0;",
          "1092:  fsec = 0;",
          "1095:  {",
          "1096:   errno = PGTYPES_INTVL_BAD_INTERVAL;",
          "1097:   return NULL;",
          "",
          "[Removed Lines]",
          "1094:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "1094:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/pgtypeslib/timestamp.c||src/interfaces/ecpg/pgtypeslib/timestamp.c": [
          "File: src/interfaces/ecpg/pgtypeslib/timestamp.c -> src/interfaces/ecpg/pgtypeslib/timestamp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "297:  char    *realptr;",
          "298:  char   **ptr = (endptr != NULL) ? endptr : &realptr;",
          "301:  {",
          "302:   errno = PGTYPES_TS_BAD_TIMESTAMP;",
          "303:   return (noresult);",
          "",
          "[Removed Lines]",
          "300:  if (strlen(str) >= sizeof(lowstr))",
          "",
          "[Added Lines]",
          "300:  if (strlen(str) > MAXDATELEN)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:       \"1999.008\",",
          "46:       \"J2451187\",",
          "47:       \"January 8, 99 BC\",",
          "48:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "53:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "55:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "56:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "52:       \"1:59 PDT\",",
          "53:       \"13:24:40 -8:00\",",
          "54:       \"13:24:40.495+3\",",
          "55:       NULL };",
          "57: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "64:       \"13:24:40.123456789+3\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  date date1 ;",
          "80:  timestamp ts1 , ts2 ;",
          "83:  char * text ;",
          "86:  interval * i1 ;",
          "89:  date * dc ;",
          "94:  int i, j;",
          "",
          "[Removed Lines]",
          "76: #line 52 \"dt_test2.pgc\"",
          "79: #line 53 \"dt_test2.pgc\"",
          "82: #line 54 \"dt_test2.pgc\"",
          "85: #line 55 \"dt_test2.pgc\"",
          "88: #line 56 \"dt_test2.pgc\"",
          "91: #line 57 \"dt_test2.pgc\"",
          "",
          "[Added Lines]",
          "86: #line 62 \"dt_test2.pgc\"",
          "89: #line 63 \"dt_test2.pgc\"",
          "92: #line 64 \"dt_test2.pgc\"",
          "95: #line 65 \"dt_test2.pgc\"",
          "98: #line 66 \"dt_test2.pgc\"",
          "101: #line 67 \"dt_test2.pgc\"",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout||src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout": [
          "File: src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout -> src/interfaces/ecpg/test/expected/pgtypeslib-dt_test2.stdout",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: TS[3,1]: 1999-01-08 01:59:00",
          "9: TS[3,2]: 1999-01-08 13:24:40",
          "10: TS[3,3]: 1999-01-08 13:24:40.495",
          "11: Date[4]: 1999-01-08 (N - F)",
          "12: TS[4,0]: 1999-01-08 00:04:00",
          "13: TS[4,1]: 1999-01-08 01:59:00",
          "14: TS[4,2]: 1999-01-08 13:24:40",
          "15: TS[4,3]: 1999-01-08 13:24:40.495",
          "16: Date[5]: 1999-01-08 (N - F)",
          "17: TS[5,0]: 1999-01-08 00:04:00",
          "18: TS[5,1]: 1999-01-08 01:59:00",
          "19: TS[5,2]: 1999-01-08 13:24:40",
          "20: TS[5,3]: 1999-01-08 13:24:40.495",
          "21: Date[6]: 1999-01-18 (N - F)",
          "22: TS[6,0]: 1999-01-18 00:04:00",
          "23: TS[6,1]: 1999-01-18 01:59:00",
          "24: TS[6,2]: 1999-01-18 13:24:40",
          "25: TS[6,3]: 1999-01-18 13:24:40.495",
          "26: Date[7]: 2003-01-02 (N - F)",
          "27: TS[7,0]: 2003-01-02 00:04:00",
          "28: TS[7,1]: 2003-01-02 01:59:00",
          "29: TS[7,2]: 2003-01-02 13:24:40",
          "30: TS[7,3]: 2003-01-02 13:24:40.495",
          "31: Date[8]: 1999-01-08 (N - F)",
          "32: TS[8,0]: 1999-01-08 00:04:00",
          "33: TS[8,1]: 1999-01-08 01:59:00",
          "34: TS[8,2]: 1999-01-08 13:24:40",
          "35: TS[8,3]: 1999-01-08 13:24:40.495",
          "36: Date[9]: 1999-01-08 (N - F)",
          "37: TS[9,0]: 1999-01-08 00:04:00",
          "38: TS[9,1]: 1999-01-08 01:59:00",
          "39: TS[9,2]: 1999-01-08 13:24:40",
          "40: TS[9,3]: 1999-01-08 13:24:40.495",
          "41: Date[10]: 1999-01-08 (N - F)",
          "42: TS[10,0]: 1999-01-08 00:04:00",
          "43: TS[10,1]: 1999-01-08 01:59:00",
          "44: TS[10,2]: 1999-01-08 13:24:40",
          "45: TS[10,3]: 1999-01-08 13:24:40.495",
          "46: Date[11]: 1999-01-08 (N - F)",
          "47: TS[11,0]: 1999-01-08 00:04:00",
          "48: TS[11,1]: 1999-01-08 01:59:00",
          "49: TS[11,2]: 1999-01-08 13:24:40",
          "50: TS[11,3]: 1999-01-08 13:24:40.495",
          "51: Date[12]: 1999-01-08 (N - F)",
          "52: TS[12,0]: 1999-01-08 00:04:00",
          "53: TS[12,1]: 1999-01-08 01:59:00",
          "54: TS[12,2]: 1999-01-08 13:24:40",
          "55: TS[12,3]: 1999-01-08 13:24:40.495",
          "56: Date[13]: 2006-01-08 (N - F)",
          "57: TS[13,0]: 2006-01-08 00:04:00",
          "58: TS[13,1]: 2006-01-08 01:59:00",
          "59: TS[13,2]: 2006-01-08 13:24:40",
          "60: TS[13,3]: 2006-01-08 13:24:40.495",
          "61: Date[14]: 1999-01-08 (N - F)",
          "62: TS[14,0]: 1999-01-08 00:04:00",
          "63: TS[14,1]: 1999-01-08 01:59:00",
          "64: TS[14,2]: 1999-01-08 13:24:40",
          "65: TS[14,3]: 1999-01-08 13:24:40.495",
          "66: Date[15]: 1999-01-08 (N - F)",
          "67: TS[15,0]: 1999-01-08 00:04:00",
          "68: TS[15,1]: 1999-01-08 01:59:00",
          "69: TS[15,2]: 1999-01-08 13:24:40",
          "70: TS[15,3]: 1999-01-08 13:24:40.495",
          "71: Date[16]: 1999-01-08 (N - F)",
          "72: TS[16,0]: 1999-01-08 00:04:00",
          "73: TS[16,1]: 1999-01-08 01:59:00",
          "74: TS[16,2]: 1999-01-08 13:24:40",
          "75: TS[16,3]: 1999-01-08 13:24:40.495",
          "76: Date[17]: 1999-01-08 (N - F)",
          "77: TS[17,0]: 1999-01-08 00:04:00",
          "78: TS[17,1]: 1999-01-08 01:59:00",
          "79: TS[17,2]: 1999-01-08 13:24:40",
          "80: TS[17,3]: 1999-01-08 13:24:40.495",
          "81: Date[18]: 1999-01-08 (N - F)",
          "82: TS[18,0]: 1999-01-08 00:04:00",
          "83: TS[18,1]: 1999-01-08 01:59:00",
          "84: TS[18,2]: 1999-01-08 13:24:40",
          "85: TS[18,3]: 1999-01-08 13:24:40.495",
          "86: Date[19]: 0099-01-08 BC (N - F)",
          "87: TS[19,0]: 0099-01-08 00:04:00 BC",
          "88: TS[19,1]: 0099-01-08 01:59:00 BC",
          "89: TS[19,2]: 0099-01-08 13:24:40 BC",
          "90: interval[0]: @ 1 min",
          "91: interval_copy[0]: @ 1 min",
          "92: interval[1]: @ 1 day 12 hours 59 mins 10 secs",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: TS[3,4]: 1999-01-08 13:24:40.123456",
          "17: TS[4,4]: 1999-01-08 13:24:40.123456",
          "23: TS[5,4]: 1999-01-08 13:24:40.123456",
          "29: TS[6,4]: 1999-01-18 13:24:40.123456",
          "35: TS[7,4]: 2003-01-02 13:24:40.123456",
          "41: TS[8,4]: 1999-01-08 13:24:40.123456",
          "47: TS[9,4]: 1999-01-08 13:24:40.123456",
          "53: TS[10,4]: 1999-01-08 13:24:40.123456",
          "59: TS[11,4]: 1999-01-08 13:24:40.123456",
          "65: TS[12,4]: 1999-01-08 13:24:40.123456",
          "71: TS[13,4]: 2006-01-08 13:24:40.123456",
          "77: TS[14,4]: 1999-01-08 13:24:40.123456",
          "83: TS[15,4]: 1999-01-08 13:24:40.123456",
          "89: TS[16,4]: 1999-01-08 13:24:40.123456",
          "95: TS[17,4]: 1999-01-08 13:24:40.123456",
          "101: TS[18,4]: 1999-01-08 13:24:40.123456",
          "106: TS[19,4]: 0099-01-08 13:24:40.123456 BC",
          "107: Date[20]: - (N - T)",
          "108: Date[21]: - (N - T)",
          "",
          "---------------"
        ],
        "src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc||src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc": [
          "File: src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc -> src/interfaces/ecpg/test/pgtypeslib/dt_test2.pgc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27:       \"1999.008\",",
          "28:       \"J2451187\",",
          "29:       \"January 8, 99 BC\",",
          "30:       NULL };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "34:       \"........................Xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "35:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "37:       \".........................aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"",
          "38:       \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "34:       \"1:59 PDT\",",
          "35:       \"13:24:40 -8:00\",",
          "36:       \"13:24:40.495+3\",",
          "37:       NULL };",
          "39: char *intervals[] = { \"1 minute\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:       \"13:24:40.123456789+3\",",
          "",
          "---------------"
        ],
        "src/test/regress/sql/interval.sql||src/test/regress/sql/interval.sql": [
          "File: src/test/regress/sql/interval.sql -> src/test/regress/sql/interval.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: -- test long interval input",
          "109: select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;",
          "112: -- test justify_hours() and justify_days()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: -- test long interval output",
          "112: select '100000000y 10mon -1000000000d -1000000000h -10min -10.000001s ago'::interval;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ff35425c8f81541c8dc10486ed21ef1cfdae693e",
      "candidate_info": {
        "commit_hash": "ff35425c8f81541c8dc10486ed21ef1cfdae693e",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/ff35425c8f81541c8dc10486ed21ef1cfdae693e",
        "files": [
          "doc/src/sgml/ref/grant.sgml",
          "src/backend/commands/user.c",
          "src/backend/utils/adt/acl.c",
          "src/test/regress/expected/privileges.out",
          "src/test/regress/sql/privileges.sql"
        ],
        "message": "Shore up ADMIN OPTION restrictions.\n\nGranting a role without ADMIN OPTION is supposed to prevent the grantee\nfrom adding or removing members from the granted role.  Issuing SET ROLE\nbefore the GRANT bypassed that, because the role itself had an implicit\nright to add or remove members.  Plug that hole by recognizing that\nimplicit right only when the session user matches the current role.\nAdditionally, do not recognize it during a security-restricted operation\nor during execution of a SECURITY DEFINER function.  The restriction on\nSECURITY DEFINER is not security-critical.  However, it seems best for a\nuser testing his own SECURITY DEFINER function to see the same behavior\nothers will see.  Back-patch to 8.4 (all supported versions).\n\nThe SQL standards do not conflate roles and users as PostgreSQL does;\nonly SQL roles have members, and only SQL users initiate sessions.  An\napplication using PostgreSQL users and roles as SQL users and roles will\nnever attempt to grant membership in the role that is the session user,\nso the implicit right to add or remove members will never arise.\n\nThe security impact was mostly that a role member could revoke access\nfrom others, contrary to the wishes of his own grantor.  Unapproved role\nmember additions are less notable, because the member can still largely\nachieve that by creating a view or a SECURITY DEFINER function.\n\nReviewed by Andres Freund and Tom Lane.  Reported, independently, by\nJonas Sundman and Noah Misch.\n\nSecurity: CVE-2014-0060",
        "before_after_code_files": [
          "src/backend/commands/user.c||src/backend/commands/user.c",
          "src/backend/utils/adt/acl.c||src/backend/utils/adt/acl.c",
          "src/test/regress/sql/privileges.sql||src/test/regress/sql/privileges.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/commands/user.c||src/backend/commands/user.c": [
          "File: src/backend/commands/user.c -> src/backend/commands/user.c"
        ],
        "src/backend/utils/adt/acl.c||src/backend/utils/adt/acl.c": [
          "File: src/backend/utils/adt/acl.c -> src/backend/utils/adt/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4236:  List    *roles_list;",
          "4237:  ListCell   *l;",
          "4244:  if (superuser_arg(member))",
          "4245:   return true;",
          "",
          "[Removed Lines]",
          "4240:  if (member == role)",
          "4241:   return true;",
          "",
          "[Added Lines]",
          "4245:  if (member == role)",
          "4274:   return member == GetSessionUserId() &&",
          "4275:    !InLocalUserIdChange() && !InSecurityRestrictedOperation();",
          "",
          "---------------"
        ],
        "src/test/regress/sql/privileges.sql||src/test/regress/sql/privileges.sql": [
          "File: src/test/regress/sql/privileges.sql -> src/test/regress/sql/privileges.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "35: ALTER GROUP regressgroup2 ADD USER regressuser2; -- duplicate",
          "36: ALTER GROUP regressgroup2 DROP USER regressuser2;",
          "40: -- test owner privileges",
          "",
          "[Removed Lines]",
          "37: ALTER GROUP regressgroup2 ADD USER regressuser4;",
          "",
          "[Added Lines]",
          "37: GRANT regressgroup2 TO regressuser4 WITH ADMIN OPTION;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "469: SELECT has_table_privilege('regressuser1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true",
          "472: -- test that dependent privileges are revoked (or not) properly",
          "473: \\c -",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "472: -- Admin options",
          "474: SET SESSION AUTHORIZATION regressuser4;",
          "475: CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS",
          "476:  'GRANT regressgroup2 TO regressuser5';",
          "477: GRANT regressgroup2 TO regressuser5; -- ok: had ADMIN OPTION",
          "478: SET ROLE regressgroup2;",
          "479: GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE suspended privilege",
          "481: SET SESSION AUTHORIZATION regressuser1;",
          "482: GRANT regressgroup2 TO regressuser5; -- fails: no ADMIN OPTION",
          "483: SELECT dogrant_ok();   -- ok: SECURITY DEFINER conveys ADMIN",
          "484: SET ROLE regressgroup2;",
          "485: GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE did not help",
          "487: SET SESSION AUTHORIZATION regressgroup2;",
          "488: GRANT regressgroup2 TO regressuser5; -- ok: a role can self-admin",
          "489: CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS",
          "490:  'GRANT regressgroup2 TO regressuser5';",
          "491: SELECT dogrant_fails();   -- fails: no self-admin in SECURITY DEFINER",
          "492: DROP FUNCTION dogrant_fails();",
          "494: SET SESSION AUTHORIZATION regressuser4;",
          "495: DROP FUNCTION dogrant_ok();",
          "496: REVOKE regressgroup2 FROM regressuser5;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12bbce15d93d7692ddff1405aa04b67f8a327f57",
      "candidate_info": {
        "commit_hash": "12bbce15d93d7692ddff1405aa04b67f8a327f57",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/12bbce15d93d7692ddff1405aa04b67f8a327f57",
        "files": [
          "contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h"
        ],
        "message": "Predict integer overflow to avoid buffer overruns.\n\nSeveral functions, mostly type input functions, calculated an allocation\nsize such that the calculation wrapped to a small positive value when\narguments implied a sufficiently-large requirement.  Writes past the end\nof the inadvertent small allocation followed shortly thereafter.\nCoverity identified the path_in() vulnerability; code inspection led to\nthe rest.  In passing, add check_stack_depth() to prevent stack overflow\nin related functions.\n\nBack-patch to 8.4 (all supported versions).  The non-comment hstore\nchanges touch code that did not exist in 8.4, so that part stops at 9.0.\n\nNoah Misch and Heikki Linnakangas, reviewed by Tom Lane.\n\nSecurity: CVE-2014-0064",
        "before_after_code_files": [
          "contrib/hstore/hstore.h||contrib/hstore/hstore.h",
          "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c",
          "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c",
          "contrib/intarray/_int.h||contrib/intarray/_int.h",
          "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c",
          "contrib/ltree/ltree.h||contrib/ltree/ltree.h",
          "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c",
          "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c",
          "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c",
          "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c",
          "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c",
          "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c",
          "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c",
          "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h",
          "src/include/utils/varbit.h||src/include/utils/varbit.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "contrib/hstore/hstore.h||contrib/hstore/hstore.h": [
          "File: contrib/hstore/hstore.h -> contrib/hstore/hstore.h"
        ],
        "contrib/hstore/hstore_io.c||contrib/hstore/hstore_io.c": [
          "File: contrib/hstore/hstore_io.c -> contrib/hstore/hstore_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"funcapi.h\"",
          "10: #include \"libpq/pqformat.h\"",
          "11: #include \"utils/lsyscache.h\"",
          "12: #include \"utils/typcache.h\"",
          "14: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "437:   PG_RETURN_POINTER(out);",
          "438:  }",
          "440:  pairs = palloc(pcount * sizeof(Pairs));",
          "442:  for (i = 0; i < pcount; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "441:  if (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))",
          "442:   ereport(ERROR,",
          "443:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "444:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "445:       pcount, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "552:        TEXTOID, -1, false, 'i',",
          "553:        &key_datums, &key_nulls, &key_count);",
          "557:  if (PG_ARGISNULL(1))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "562:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "563:   ereport(ERROR,",
          "564:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "565:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "566:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "675:  count = in_count / 2;",
          "677:  pairs = palloc(count * sizeof(Pairs));",
          "679:  for (i = 0; i < count; ++i)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "691:  if (count > MaxAllocSize / sizeof(Pairs))",
          "692:   ereport(ERROR,",
          "693:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "694:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "695:       count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/hstore/hstore_op.c||contrib/hstore/hstore_op.c": [
          "File: contrib/hstore/hstore_op.c -> contrib/hstore/hstore_op.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: #include \"catalog/pg_type.h\"",
          "8: #include \"funcapi.h\"",
          "9: #include \"utils/builtins.h\"",
          "11: #include \"hstore.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:   return NULL;",
          "90:  }",
          "92:  key_pairs = palloc(sizeof(Pairs) * key_count);",
          "94:  for (i = 0, j = 0; i < key_count; i++)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "100:  if (key_count > MaxAllocSize / sizeof(Pairs))",
          "101:   ereport(ERROR,",
          "102:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "103:      errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",",
          "104:       key_count, (int) (MaxAllocSize / sizeof(Pairs)))));",
          "",
          "---------------"
        ],
        "contrib/intarray/_int.h||contrib/intarray/_int.h": [
          "File: contrib/intarray/_int.h -> contrib/intarray/_int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #define ___INT_H__",
          "7: #include \"utils/array.h\"",
          "10: #define MAXNUMRANGE 100",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "138: #define HDRSIZEQT offsetof(QUERYTYPE, items)",
          "139: #define COMPUTESIZE(size) ( HDRSIZEQT + (size) * sizeof(ITEM) )",
          "140: #define GETQUERY(x)  ( (x)->items )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141: #define QUERYTYPEMAXITEMS ((MaxAllocSize - HDRSIZEQT) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/intarray/_int_bool.c||contrib/intarray/_int_bool.c": [
          "File: contrib/intarray/_int_bool.c -> contrib/intarray/_int_bool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "451: static void",
          "452: findoprnd(ITEM *ptr, int4 *pos)",
          "453: {",
          "454: #ifdef BS_DEBUG",
          "455:  elog(DEBUG3, (ptr[*pos].type == OPR) ?",
          "456:    \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "455:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "511:     (errcode(ERRCODE_INVALID_PARAMETER_VALUE),",
          "512:      errmsg(\"empty query\")));",
          "514:  commonlen = COMPUTESIZE(state.num);",
          "515:  query = (QUERYTYPE *) palloc(commonlen);",
          "516:  SET_VARSIZE(query, commonlen);",
          "517:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "517:  if (state.num > QUERYTYPEMAXITEMS)",
          "518:   ereport(ERROR,",
          "519:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "520:   errmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",",
          "521:       state.num, (int) QUERYTYPEMAXITEMS)));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree.h||contrib/ltree/ltree.h": [
          "File: contrib/ltree/ltree.h -> contrib/ltree/ltree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include \"fmgr.h\"",
          "7: #include \"tsearch/ts_locale.h\"",
          "9: typedef struct",
          "10: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "112: #define HDRSIZEQT  MAXALIGN(VARHDRSZ + sizeof(int4))",
          "113: #define COMPUTESIZE(size,lenofoperand) ( HDRSIZEQT + (size) * sizeof(ITEM) + (lenofoperand) )",
          "114: #define GETQUERY(x)  (ITEM*)( (char*)(x)+HDRSIZEQT )",
          "115: #define GETOPERAND(x) ( (char*)GETQUERY(x) + ((ltxtquery*)x)->size * sizeof(ITEM) )",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "115: #define LTXTQUERY_TOO_BIG(size,lenofoperand) \\",
          "116:  ((size) > (MaxAllocSize - HDRSIZEQT - (lenofoperand)) / sizeof(ITEM))",
          "",
          "---------------"
        ],
        "contrib/ltree/ltree_io.c||contrib/ltree/ltree_io.c": [
          "File: contrib/ltree/ltree_io.c -> contrib/ltree/ltree_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <ctype.h>",
          "10: #include \"ltree.h\"",
          "11: #include \"crc32.h\"",
          "13: PG_FUNCTION_INFO_V1(ltree_in);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "64:   ptr += charlen;",
          "65:  }",
          "67:  list = lptr = (nodeitem *) palloc(sizeof(nodeitem) * (num + 1));",
          "68:  ptr = buf;",
          "69:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68:  if (num + 1 > MaxAllocSize / sizeof(nodeitem))",
          "69:   ereport(ERROR,",
          "70:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "71:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "72:      num + 1, (int) (MaxAllocSize / sizeof(nodeitem)))));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "228:  }",
          "230:  num++;",
          "231:  curqlevel = tmpql = (lquery_level *) palloc0(ITEMSIZE * num);",
          "232:  ptr = buf;",
          "233:  while (*ptr)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:  if (num > MaxAllocSize / ITEMSIZE)",
          "238:   ereport(ERROR,",
          "239:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "240:     errmsg(\"number of levels (%d) exceeds the maximum allowed (%d)\",",
          "241:      num, (int) (MaxAllocSize / ITEMSIZE))));",
          "",
          "---------------"
        ],
        "contrib/ltree/ltxtquery_io.c||contrib/ltree/ltxtquery_io.c": [
          "File: contrib/ltree/ltxtquery_io.c -> contrib/ltree/ltxtquery_io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"crc32.h\"",
          "11: #include \"ltree.h\"",
          "13: PG_FUNCTION_INFO_V1(ltxtq_in);",
          "14: Datum  ltxtq_in(PG_FUNCTION_ARGS);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include \"miscadmin.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  int4  lenstack = 0;",
          "214:  uint16  flag = 0;",
          "216:  while ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)",
          "217:  {",
          "218:   switch (type)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "218:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277: static void",
          "278: findoprnd(ITEM *ptr, int4 *pos)",
          "279: {",
          "280:  if (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)",
          "281:  {",
          "282:   ptr[*pos].left = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:  check_stack_depth();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "341:      errmsg(\"syntax error\"),",
          "342:      errdetail(\"Empty query.\")));",
          "345:  commonlen = COMPUTESIZE(state.num, state.sumlen);",
          "346:  query = (ltxtquery *) palloc(commonlen);",
          "347:  SET_VARSIZE(query, commonlen);",
          "348:  query->size = state.num;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  if (LTXTQUERY_TOO_BIG(state.num, state.sumlen))",
          "352:   ereport(ERROR,",
          "353:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "354:      errmsg(\"ltxtquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/geo_ops.c||src/backend/utils/adt/geo_ops.c": [
          "File: src/backend/utils/adt/geo_ops.c -> src/backend/utils/adt/geo_ops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1403:  char    *s;",
          "1404:  int   npts;",
          "1405:  int   size;",
          "1406:  int   depth = 0;",
          "1408:  if ((npts = pair_count(str, ',')) <= 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1406:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1421:   depth++;",
          "1422:  }",
          "1425:  path = (PATH *) palloc(size);",
          "1427:  SET_VARSIZE(path, size);",
          "",
          "[Removed Lines]",
          "1424:  size = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;",
          "",
          "[Added Lines]",
          "1425:  base_size = sizeof(path->p[0]) * npts;",
          "1426:  size = offsetof(PATH, p[0]) + base_size;",
          "1429:  if (base_size / npts != sizeof(path->p[0]) || size <= base_size)",
          "1430:   ereport(ERROR,",
          "1431:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "1432:      errmsg(\"too many points requested\")));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3465:  POLYGON    *poly;",
          "3466:  int   npts;",
          "3467:  int   size;",
          "3468:  int   isopen;",
          "3469:  char    *s;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3477:  int   base_size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3473:     (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),",
          "3474:      errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));",
          "3479:  SET_VARSIZE(poly, size);",
          "",
          "[Removed Lines]",
          "3476:  size = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;",
          "",
          "[Added Lines]",
          "3486:  base_size = sizeof(poly->p[0]) * npts;",
          "3487:  size = offsetof(POLYGON, p[0]) + base_size;",
          "3490:  if (base_size / npts != sizeof(poly->p[0]) || size <= base_size)",
          "3491:   ereport(ERROR,",
          "3492:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "3493:      errmsg(\"too many points requested\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery.c||src/backend/utils/adt/tsquery.c": [
          "File: src/backend/utils/adt/tsquery.c -> src/backend/utils/adt/tsquery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "515:   return query;",
          "516:  }",
          "519:  commonlen = COMPUTESIZE(list_length(state.polstr), state.sumlen);",
          "520:  query = (TSQuery) palloc0(commonlen);",
          "521:  SET_VARSIZE(query, commonlen);",
          "522:  query->size = list_length(state.polstr);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "518:  if (TSQUERY_TOO_BIG(list_length(state.polstr), state.sumlen))",
          "519:   ereport(ERROR,",
          "520:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "521:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/tsquery_util.c||src/backend/utils/adt/tsquery_util.c": [
          "File: src/backend/utils/adt/tsquery_util.c -> src/backend/utils/adt/tsquery_util.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "333:  QTN2QTState state;",
          "335:  cntsize(in, &sumlen, &nnode);",
          "336:  len = COMPUTESIZE(nnode, sumlen);",
          "338:  out = (TSQuery) palloc0(len);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "337:  if (TSQUERY_TOO_BIG(nnode, sumlen))",
          "338:   ereport(ERROR,",
          "339:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "340:      errmsg(\"tsquery is too large\")));",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/txid.c||src/backend/utils/adt/txid.c": [
          "File: src/backend/utils/adt/txid.c -> src/backend/utils/adt/txid.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"miscadmin.h\"",
          "28: #include \"libpq/pqformat.h\"",
          "29: #include \"utils/builtins.h\"",
          "30: #include \"utils/snapmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67: #define TXID_SNAPSHOT_SIZE(nxip) \\",
          "68:  (offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "70: #define TXID_SNAPSHOT_MAX_NXIP \\",
          "71:  ((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "445:  txid  last = 0;",
          "446:  int   nxip;",
          "447:  int   i;",
          "450:  txid  xmin,",
          "451:     xmax;",
          "458:  nxip = pq_getmsgint(buf, 4);",
          "462:   goto bad_format;",
          "464:  xmin = pq_getmsgint64(buf);",
          "",
          "[Removed Lines]",
          "448:  int   avail;",
          "449:  int   expect;",
          "459:  avail = buf->len - buf->cursor;",
          "460:  expect = 8 + 8 + nxip * 8;",
          "461:  if (nxip < 0 || nxip > avail || expect > avail)",
          "",
          "[Added Lines]",
          "456:  if (nxip < 0 || nxip > TXID_SNAPSHOT_MAX_NXIP)",
          "",
          "---------------"
        ],
        "src/backend/utils/adt/varbit.c||src/backend/utils/adt/varbit.c": [
          "File: src/backend/utils/adt/varbit.c -> src/backend/utils/adt/varbit.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "148:   sp = input_string;",
          "149:  }",
          "151:  slen = strlen(sp);",
          "153:  if (bit_not_hex)",
          "154:   bitlen = slen;",
          "155:  else",
          "156:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:  {",
          "160:   if (slen > VARBITMAXLEN / 4)",
          "161:    ereport(ERROR,",
          "162:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "163:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "164:       VARBITMAXLEN)));",
          "166:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "450:   sp = input_string;",
          "451:  }",
          "453:  slen = strlen(sp);",
          "455:  if (bit_not_hex)",
          "456:   bitlen = slen;",
          "457:  else",
          "458:   bitlen = slen * 4;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "471:  {",
          "472:   if (slen > VARBITMAXLEN / 4)",
          "473:    ereport(ERROR,",
          "474:      (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "475:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "476:       VARBITMAXLEN)));",
          "478:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "944:  bitlen1 = VARBITLEN(arg1);",
          "945:  bitlen2 = VARBITLEN(arg2);",
          "947:  bytelen = VARBITTOTALLEN(bitlen1 + bitlen2);",
          "949:  result = (VarBit *) palloc(bytelen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "970:  if (bitlen1 > VARBITMAXLEN - bitlen2)",
          "971:   ereport(ERROR,",
          "972:     (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),",
          "973:      errmsg(\"bit string length exceeds the maximum allowed (%d)\",",
          "974:       VARBITMAXLEN)));",
          "",
          "---------------"
        ],
        "src/include/tsearch/ts_type.h||src/include/tsearch/ts_type.h": [
          "File: src/include/tsearch/ts_type.h -> src/include/tsearch/ts_type.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #define _PG_TSTYPE_H_",
          "15: #include \"fmgr.h\"",
          "16: #include \"utils/pg_crc.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include \"utils/memutils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "246: #define COMPUTESIZE(size, lenofoperand) ( HDRSIZETQ + (size) * sizeof(QueryItem) + (lenofoperand) )",
          "249: #define GETQUERY(x)  ((QueryItem*)( (char*)(x)+HDRSIZETQ ))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248: #define TSQUERY_TOO_BIG(size, lenofoperand) \\",
          "249:  ((size) > (MaxAllocSize - HDRSIZETQ - (lenofoperand)) / sizeof(QueryItem))",
          "",
          "---------------"
        ],
        "src/include/utils/varbit.h||src/include/utils/varbit.h": [
          "File: src/include/utils/varbit.h -> src/include/utils/varbit.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #ifndef VARBIT_H",
          "16: #define VARBIT_H",
          "18: #include \"fmgr.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include <limits.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #define VARBITTOTALLEN(BITLEN) (((BITLEN) + BITS_PER_BYTE-1)/BITS_PER_BYTE + \\",
          "55:          VARHDRSZ + VARBITHDRSZ)",
          "57: #define VARBITEND(PTR)  (((bits8 *) (PTR)) + VARSIZE(PTR))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "62: #define VARBITMAXLEN  (INT_MAX - BITS_PER_BYTE + 1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "789063697908d7531fc4fe9c72976ea642e68d15",
      "candidate_info": {
        "commit_hash": "789063697908d7531fc4fe9c72976ea642e68d15",
        "repo": "postgres/postgres",
        "commit_url": "https://github.com/postgres/postgres/commit/789063697908d7531fc4fe9c72976ea642e68d15",
        "files": [
          "doc/src/sgml/ref/grant.sgml",
          "src/backend/commands/user.c",
          "src/backend/utils/adt/acl.c",
          "src/test/regress/expected/privileges.out",
          "src/test/regress/sql/privileges.sql"
        ],
        "message": "Shore up ADMIN OPTION restrictions.\n\nGranting a role without ADMIN OPTION is supposed to prevent the grantee\nfrom adding or removing members from the granted role.  Issuing SET ROLE\nbefore the GRANT bypassed that, because the role itself had an implicit\nright to add or remove members.  Plug that hole by recognizing that\nimplicit right only when the session user matches the current role.\nAdditionally, do not recognize it during a security-restricted operation\nor during execution of a SECURITY DEFINER function.  The restriction on\nSECURITY DEFINER is not security-critical.  However, it seems best for a\nuser testing his own SECURITY DEFINER function to see the same behavior\nothers will see.  Back-patch to 8.4 (all supported versions).\n\nThe SQL standards do not conflate roles and users as PostgreSQL does;\nonly SQL roles have members, and only SQL users initiate sessions.  An\napplication using PostgreSQL users and roles as SQL users and roles will\nnever attempt to grant membership in the role that is the session user,\nso the implicit right to add or remove members will never arise.\n\nThe security impact was mostly that a role member could revoke access\nfrom others, contrary to the wishes of his own grantor.  Unapproved role\nmember additions are less notable, because the member can still largely\nachieve that by creating a view or a SECURITY DEFINER function.\n\nReviewed by Andres Freund and Tom Lane.  Reported, independently, by\nJonas Sundman and Noah Misch.\n\nSecurity: CVE-2014-0060",
        "before_after_code_files": [
          "src/backend/commands/user.c||src/backend/commands/user.c",
          "src/backend/utils/adt/acl.c||src/backend/utils/adt/acl.c",
          "src/test/regress/sql/privileges.sql||src/test/regress/sql/privileges.sql"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/backend/commands/user.c||src/backend/commands/user.c": [
          "File: src/backend/commands/user.c -> src/backend/commands/user.c"
        ],
        "src/backend/utils/adt/acl.c||src/backend/utils/adt/acl.c": [
          "File: src/backend/utils/adt/acl.c -> src/backend/utils/adt/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4671:  List    *roles_list;",
          "4672:  ListCell   *l;",
          "4679:  if (superuser_arg(member))",
          "4680:   return true;",
          "",
          "[Removed Lines]",
          "4675:  if (member == role)",
          "4676:   return true;",
          "",
          "[Added Lines]",
          "4680:  if (member == role)",
          "4709:   return member == GetSessionUserId() &&",
          "4710:    !InLocalUserIdChange() && !InSecurityRestrictedOperation();",
          "",
          "---------------"
        ],
        "src/test/regress/sql/privileges.sql||src/test/regress/sql/privileges.sql": [
          "File: src/test/regress/sql/privileges.sql -> src/test/regress/sql/privileges.sql",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: ALTER GROUP regressgroup2 ADD USER regressuser2; -- duplicate",
          "39: ALTER GROUP regressgroup2 DROP USER regressuser2;",
          "42: -- test owner privileges",
          "",
          "[Removed Lines]",
          "40: ALTER GROUP regressgroup2 ADD USER regressuser4;",
          "",
          "[Added Lines]",
          "40: GRANT regressgroup2 TO regressuser4 WITH ADMIN OPTION;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "472: SELECT has_table_privilege('regressuser1', 'atest4', 'SELECT WITH GRANT OPTION'); -- true",
          "475: -- has_sequence_privilege tests",
          "476: \\c -",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "475: -- Admin options",
          "477: SET SESSION AUTHORIZATION regressuser4;",
          "478: CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS",
          "479:  'GRANT regressgroup2 TO regressuser5';",
          "480: GRANT regressgroup2 TO regressuser5; -- ok: had ADMIN OPTION",
          "481: SET ROLE regressgroup2;",
          "482: GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE suspended privilege",
          "484: SET SESSION AUTHORIZATION regressuser1;",
          "485: GRANT regressgroup2 TO regressuser5; -- fails: no ADMIN OPTION",
          "486: SELECT dogrant_ok();   -- ok: SECURITY DEFINER conveys ADMIN",
          "487: SET ROLE regressgroup2;",
          "488: GRANT regressgroup2 TO regressuser5; -- fails: SET ROLE did not help",
          "490: SET SESSION AUTHORIZATION regressgroup2;",
          "491: GRANT regressgroup2 TO regressuser5; -- ok: a role can self-admin",
          "492: CREATE FUNCTION dogrant_fails() RETURNS void LANGUAGE sql SECURITY DEFINER AS",
          "493:  'GRANT regressgroup2 TO regressuser5';",
          "494: SELECT dogrant_fails();   -- fails: no self-admin in SECURITY DEFINER",
          "495: DROP FUNCTION dogrant_fails();",
          "497: SET SESSION AUTHORIZATION regressuser4;",
          "498: DROP FUNCTION dogrant_ok();",
          "499: REVOKE regressgroup2 FROM regressuser5;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-25761",
  "cve_desc": "The package open62541/open62541 before 1.2.5, from 1.3-rc1 and before 1.3.1 are vulnerable to Denial of Service (DoS) due to a missing limitation on the number of received chunks - per single session or in total for all concurrent sessions. An attacker can exploit this vulnerability by sending an unlimited number of huge chunks (e.g. 2GB each) without sending the Final closing chunk.",
  "repo": "open62541/open62541",
  "patch_hash": "b79db1ac78146fc06b0b8435773d3967de2d659c",
  "patch_info": {
    "commit_hash": "b79db1ac78146fc06b0b8435773d3967de2d659c",
    "repo": "open62541/open62541",
    "commit_url": "https://github.com/open62541/open62541/commit/b79db1ac78146fc06b0b8435773d3967de2d659c",
    "files": [
      "plugins/ua_config_default.c",
      "tests/check_securechannel.c"
    ],
    "message": "fix(plugin): Add default limits for chunks and message size\n\nBased on a reported DoS vulnerability reported by Team82 (Claroty\nResearch).",
    "before_after_code_files": [
      "plugins/ua_config_default.c||plugins/ua_config_default.c",
      "tests/check_securechannel.c||tests/check_securechannel.c"
    ]
  },
  "patch_diff": {
    "plugins/ua_config_default.c||plugins/ua_config_default.c": [
      "File: plugins/ua_config_default.c -> plugins/ua_config_default.c"
    ],
    "tests/check_securechannel.c||tests/check_securechannel.c": [
      "File: tests/check_securechannel.c -> tests/check_securechannel.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "45:     UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);",
      "46:     UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);",
      "49:     UA_Connection_attachSecureChannel(&testingConnection, &testChannel);",
      "50:     testChannel.connection = &testingConnection;",
      "",
      "[Removed Lines]",
      "48:     testingConnection = createDummyConnection(65535, &sentData);",
      "",
      "[Added Lines]",
      "48:     testingConnection =",
      "49:         createDummyConnection(UA_ConnectionConfig_default.sendBufferSize, &sentData);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "38ff117bcedb5eb2a81e7f4871d026b7c1d92a25",
      "candidate_info": {
        "commit_hash": "38ff117bcedb5eb2a81e7f4871d026b7c1d92a25",
        "repo": "open62541/open62541",
        "commit_url": "https://github.com/open62541/open62541/commit/38ff117bcedb5eb2a81e7f4871d026b7c1d92a25",
        "files": [
          "src/ua_securechannel.c",
          "src/ua_securechannel.h",
          "src/ua_securechannel_crypto.c",
          "tests/check_securechannel.c",
          "tests/testing-plugins/testing_networklayers.c",
          "tests/testing-plugins/testing_networklayers.h"
        ],
        "message": "refactor(core): The SecureChannel directly uses the EventLoop connection",
        "before_after_code_files": [
          "src/ua_securechannel.c||src/ua_securechannel.c",
          "src/ua_securechannel.h||src/ua_securechannel.h",
          "src/ua_securechannel_crypto.c||src/ua_securechannel_crypto.c",
          "tests/check_securechannel.c||tests/check_securechannel.c",
          "tests/testing-plugins/testing_networklayers.c||tests/testing-plugins/testing_networklayers.c",
          "tests/testing-plugins/testing_networklayers.h||tests/testing-plugins/testing_networklayers.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/check_securechannel.c||tests/check_securechannel.c"
          ],
          "candidate": [
            "tests/check_securechannel.c||tests/check_securechannel.c"
          ]
        }
      },
      "candidate_diff": {
        "src/ua_securechannel.c||src/ua_securechannel.c": [
          "File: src/ua_securechannel.c -> src/ua_securechannel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147: }",
          "149: void",
          "169:         if(sh->serverSession) {",
          "170:             UA_Session_detachFromSecureChannel((UA_Session *)sh);",
          "171:         } else {",
          "",
          "[Removed Lines]",
          "150: UA_SecureChannel_close(UA_SecureChannel *channel) {",
          "152:     channel->state = UA_SECURECHANNELSTATE_CLOSED;",
          "155:     if(channel->connection) {",
          "156:         if(channel->connection->state != UA_CONNECTIONSTATE_CLOSED) {",
          "157:             if(channel->connection->close)",
          "158:                 channel->connection->close(channel->connection);",
          "159:             else",
          "160:                 channel->connection->state = UA_CONNECTIONSTATE_CLOSED;",
          "161:         }",
          "162:         UA_Connection_detachSecureChannel(channel->connection);",
          "163:     }",
          "167:     UA_SessionHeader *sh;",
          "168:     while((sh = SLIST_FIRST(&channel->sessions))) {",
          "",
          "[Added Lines]",
          "150: UA_SecureChannel_shutdown(UA_SecureChannel *channel) {",
          "152:     if(!UA_SecureChannel_isConnected(channel))",
          "153:         return;",
          "156:     UA_ConnectionManager *cm = channel->connectionManager;",
          "157:     cm->closeConnection(cm, channel->connectionId);",
          "158:     channel->state = UA_SECURECHANNELSTATE_CLOSING;",
          "159: }",
          "161: void",
          "162: UA_SecureChannel_clear(UA_SecureChannel *channel) {",
          "165:     UA_SessionHeader *sh, *sh_tmp;",
          "166:     SLIST_FOREACH_SAFE(sh, &channel->sessions, next, sh_tmp) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "188:     UA_ChannelSecurityToken_clear(&channel->securityToken);",
          "189:     UA_ChannelSecurityToken_clear(&channel->altSecurityToken);",
          "190:     UA_SecureChannel_deleteBuffered(channel);",
          "191: }",
          "193: UA_StatusCode",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "191:     channel->connectionId = 0;",
          "192:     channel->connectionManager = NULL;",
          "195:     channel->state = UA_SECURECHANNELSTATE_CLOSED;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "216:         channel->config.remoteMaxMessageSize < 8192))",
          "217:         return UA_STATUSCODE_BADINTERNALERROR;",
          "220:     return UA_STATUSCODE_GOOD;",
          "221: }",
          "",
          "[Removed Lines]",
          "219:     channel->connection->state = UA_CONNECTIONSTATE_ESTABLISHED;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "228:     UA_CHECK(channel->securityMode != UA_MESSAGESECURITYMODE_INVALID,",
          "229:              return UA_STATUSCODE_BADSECURITYMODEREJECTED);",
          "231:     const UA_SecurityPolicy *sp = channel->securityPolicy;",
          "233:     UA_CHECK_MEM(sp, return UA_STATUSCODE_BADINTERNALERROR);",
          "237:     UA_ByteString buf = UA_BYTESTRING_NULL;",
          "239:     UA_CHECK_STATUS(res, return res);",
          "",
          "[Removed Lines]",
          "232:     UA_Connection *conn = channel->connection;",
          "234:     UA_CHECK_MEM(conn, return UA_STATUSCODE_BADINTERNALERROR);",
          "238:     UA_StatusCode res = conn->getSendBuffer(conn, channel->config.sendBufferSize, &buf);",
          "",
          "[Added Lines]",
          "236:     UA_ConnectionManager *cm = channel->connectionManager;",
          "237:     if(!UA_SecureChannel_isConnected(channel))",
          "238:         return UA_STATUSCODE_BADCONNECTIONCLOSED;",
          "245:     UA_StatusCode res = cm->allocNetworkBuffer(cm, channel->connectionId, &buf,",
          "246:                                                channel->config.sendBufferSize);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "243:     const UA_Byte *buf_end = &buf.data[buf.length];",
          "244:     hideBytesAsym(channel, &buf_pos, &buf_end);",
          "247:     res |= UA_NodeId_encodeBinary(&contentType->binaryEncodingId, &buf_pos, buf_end);",
          "258:     if(channel->securityMode != UA_MESSAGESECURITYMODE_NONE)",
          "259:         padChunk(channel, &channel->securityPolicy->asymmetricModule.cryptoModule,",
          "260:                  &buf.data[UA_SECURECHANNEL_CHANNELHEADER_LENGTH + securityHeaderLength],",
          "",
          "[Removed Lines]",
          "248:     res |= UA_encodeBinaryInternal(content, contentType,",
          "249:                                    &buf_pos, &buf_end, NULL, NULL);",
          "250:     UA_CHECK_STATUS(res, conn->releaseSendBuffer(conn, &buf); return res);",
          "252:     const size_t securityHeaderLength = calculateAsymAlgSecurityHeaderLength(channel);",
          "254: #ifdef UA_ENABLE_ENCRYPTION",
          "",
          "[Added Lines]",
          "255:     size_t securityHeaderLength, pre_sig_length, total_length, encryptedLength;",
          "259:     res |= UA_encodeBinaryInternal(content, contentType, &buf_pos, &buf_end, NULL, NULL);",
          "260:     UA_CHECK_STATUS(res, goto error);",
          "263:     securityHeaderLength = calculateAsymAlgSecurityHeaderLength(channel);",
          "268: #ifdef UA_ENABLE_ENCRYPTION",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "262: #endif",
          "267:     if(channel->securityMode == UA_MESSAGESECURITYMODE_SIGN ||",
          "268:        channel->securityMode == UA_MESSAGESECURITYMODE_SIGNANDENCRYPT)",
          "269:         total_length += sp->asymmetricModule.cryptoModule.signatureAlgorithm.",
          "",
          "[Removed Lines]",
          "265:     size_t pre_sig_length = (uintptr_t)buf_pos - (uintptr_t)buf.data;",
          "266:     size_t total_length = pre_sig_length;",
          "",
          "[Added Lines]",
          "276:     pre_sig_length = (uintptr_t)buf_pos - (uintptr_t)buf.data;",
          "277:     total_length = pre_sig_length;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "275:     res = prependHeadersAsym(channel, buf.data, buf_end, total_length,",
          "276:                              securityHeaderLength, requestId, &encryptedLength);",
          "279: #ifdef UA_ENABLE_ENCRYPTION",
          "280:     res = signAndEncryptAsym(channel, pre_sig_length, &buf,",
          "281:                              securityHeaderLength, total_length);",
          "283: #endif",
          "286:     buf.length = encryptedLength;",
          "291:     return res;",
          "292: }",
          "",
          "[Removed Lines]",
          "274:     size_t encryptedLength = 0;",
          "277:     UA_CHECK_STATUS(res, conn->releaseSendBuffer(conn, &buf); return res);",
          "282:     UA_CHECK_STATUS(res, conn->releaseSendBuffer(conn, &buf); return res);",
          "287:     res = conn->send(conn, &buf);",
          "288: #ifdef UA_ENABLE_UNIT_TEST_FAILURE_HOOKS",
          "289:     res |= sendAsym_sendFailure;",
          "290: #endif",
          "",
          "[Added Lines]",
          "287:     UA_CHECK_STATUS(res, goto error);",
          "292:     UA_CHECK_STATUS(res, goto error);",
          "297:     return cm->sendWithConnection(cm, channel->connectionId, 0, NULL, &buf);",
          "299:  error:",
          "300:     cm->freeNetworkBuffer(cm, channel->connectionId, &buf);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "345: sendSymmetricChunk(UA_MessageContext *mc) {",
          "346:     UA_SecureChannel *channel = mc->channel;",
          "347:     const UA_SecurityPolicy *sp = channel->securityPolicy;",
          "352:     size_t bodyLength = (uintptr_t)mc->buf_pos -",
          "",
          "[Removed Lines]",
          "348:     UA_Connection *connection = channel->connection;",
          "349:     UA_CHECK_MEM(connection, return UA_STATUSCODE_BADINTERNALERROR);",
          "",
          "[Added Lines]",
          "358:     UA_ConnectionManager *cm = channel->connectionManager;",
          "359:     if(!UA_SecureChannel_isConnected(channel))",
          "360:         return UA_STATUSCODE_BADCONNECTIONCLOSED;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "405:     UA_CHECK_STATUS(res, goto error);",
          "406: #endif",
          "411:  error:",
          "414:     return res;",
          "415: }",
          "",
          "[Removed Lines]",
          "409:     return connection->send(channel->connection, &mc->messageBuffer);",
          "413:     connection->releaseSendBuffer(channel->connection, &mc->messageBuffer);",
          "",
          "[Added Lines]",
          "422:     res = cm->sendWithConnection(cm, channel->connectionId,",
          "423:                                  0, NULL, &mc->messageBuffer);",
          "424:     if(res != UA_STATUSCODE_GOOD && UA_SecureChannel_isConnected(channel))",
          "425:         channel->state = UA_SECURECHANNELSTATE_CLOSING;",
          "429:     cm->freeNetworkBuffer(cm, channel->connectionId, &mc->messageBuffer);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "428:     UA_CHECK_STATUS(res, return res);",
          "436:     UA_CHECK_STATUS(res, return res);",
          "",
          "[Removed Lines]",
          "431:     UA_Connection *c = mc->channel->connection;",
          "432:     UA_CHECK_MEM(c, return UA_STATUSCODE_BADINTERNALERROR);",
          "434:     res = c->getSendBuffer(c, mc->channel->config.sendBufferSize,",
          "435:                            &mc->messageBuffer);",
          "",
          "[Added Lines]",
          "447:     UA_ConnectionManager *cm = mc->channel->connectionManager;",
          "448:     if(!UA_SecureChannel_isConnected(mc->channel))",
          "449:         return UA_STATUSCODE_BADCONNECTIONCLOSED;",
          "451:     res = cm->allocNetworkBuffer(cm, mc->channel->connectionId,",
          "452:                                  &mc->messageBuffer,",
          "453:                                  mc->channel->config.sendBufferSize);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "448:     UA_CHECK(messageType == UA_MESSAGETYPE_MSG || messageType == UA_MESSAGETYPE_CLO,",
          "449:              return UA_STATUSCODE_BADINTERNALERROR);",
          "455:     mc->channel = channel;",
          "",
          "[Removed Lines]",
          "451:     UA_Connection *c = channel->connection;",
          "452:     UA_CHECK_MEM(c, return UA_STATUSCODE_BADINTERNALERROR);",
          "",
          "[Added Lines]",
          "469:     UA_ConnectionManager *cm = channel->connectionManager;",
          "470:     if(!UA_SecureChannel_isConnected(channel))",
          "471:         return UA_STATUSCODE_BADCONNECTIONCLOSED;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "461:     mc->messageType = messageType;",
          "466:     UA_CHECK_STATUS(res, return res);",
          "",
          "[Removed Lines]",
          "464:     UA_StatusCode res = c->getSendBuffer(c, channel->config.sendBufferSize,",
          "465:                                          &mc->messageBuffer);",
          "",
          "[Added Lines]",
          "483:     UA_StatusCode res =",
          "484:         cm->allocNetworkBuffer(cm, channel->connectionId,",
          "485:                                &mc->messageBuffer,",
          "486:                                channel->config.sendBufferSize);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "490: void",
          "491: UA_MessageContext_abort(UA_MessageContext *mc) {",
          "494: }",
          "496: UA_StatusCode",
          "497: UA_SecureChannel_sendSymmetricMessage(UA_SecureChannel *channel, UA_UInt32 requestId,",
          "498:                                       UA_MessageType messageType, void *payload,",
          "499:                                       const UA_DataType *payloadType) {",
          "501:         return UA_STATUSCODE_BADINTERNALERROR;",
          "503:     if(channel->state != UA_SECURECHANNELSTATE_OPEN)",
          "504:         return UA_STATUSCODE_BADCONNECTIONCLOSED;",
          "509:     UA_MessageContext mc;",
          "510:     UA_StatusCode res = UA_MessageContext_begin(&mc, channel, requestId, messageType);",
          "511:     UA_CHECK_STATUS(res, return res);",
          "",
          "[Removed Lines]",
          "492:     UA_Connection *connection = mc->channel->connection;",
          "493:     connection->releaseSendBuffer(connection, &mc->messageBuffer);",
          "500:     if(!channel || !channel->connection || !payload || !payloadType)",
          "506:     if(channel->connection->state != UA_CONNECTIONSTATE_ESTABLISHED)",
          "507:         return UA_STATUSCODE_BADCONNECTIONCLOSED;",
          "",
          "[Added Lines]",
          "513:     UA_ConnectionManager *cm = mc->channel->connectionManager;",
          "514:     if(!UA_SecureChannel_isConnected(mc->channel))",
          "515:         return;",
          "516:     cm->freeNetworkBuffer(cm, mc->channel->connectionId, &mc->messageBuffer);",
          "523:     if(!channel || !payload || !payloadType)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "583:     if(secureChannelId != 0 && channel->securityToken.channelId == 0)",
          "584:         channel->securityToken.channelId = secureChannelId;",
          "586: #if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)",
          "588:     if(secureChannelId != channel->securityToken.channelId) {",
          "591:     }",
          "592: #endif",
          "595:     res = checkAsymHeader(channel, &asymHeader);",
          "596:     UA_AsymmetricAlgorithmSecurityHeader_clear(&asymHeader);",
          "597:     UA_CHECK_STATUS(res, return res);",
          "",
          "[Removed Lines]",
          "589:         res = UA_STATUSCODE_BADSECURECHANNELIDINVALID;",
          "590:         goto error;",
          "",
          "[Added Lines]",
          "613:         if(secureChannelId != 0 || channel->securityToken.tokenId != 0) {",
          "614:             res = UA_STATUSCODE_BADSECURECHANNELIDINVALID;",
          "615:             goto error;",
          "616:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "639: #if !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)",
          "643: #endif",
          "",
          "[Removed Lines]",
          "641:     UA_CHECK(secureChannelId == channel->securityToken.channelId,",
          "642:              return UA_STATUSCODE_BADSECURECHANNELIDINVALID);",
          "",
          "[Added Lines]",
          "667:     if(secureChannelId != channel->securityToken.channelId)",
          "668:         return UA_STATUSCODE_BADSECURECHANNELIDINVALID;",
          "",
          "---------------"
        ],
        "src/ua_securechannel.h||src/ua_securechannel.h": [
          "File: src/ua_securechannel.h -> src/ua_securechannel.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include <open62541/types.h>",
          "16: #include <open62541/plugin/log.h>",
          "17: #include <open62541/plugin/securitypolicy.h>",
          "18: #include <open62541/transport_generated.h>",
          "20: #include \"open62541_queue.h\"",
          "21: #include \"ua_util_internal.h\"",
          "24: _UA_BEGIN_DECLS",
          "",
          "[Removed Lines]",
          "22: #include \"ua_connection_internal.h\"",
          "",
          "[Added Lines]",
          "18: #include <open62541/plugin/eventloop.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "101:     UA_MessageSecurityMode securityMode;",
          "102:     UA_ConnectionConfig config;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "105:     UA_ConnectionManager *connectionManager;",
          "106:     uintptr_t connectionId;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "116:     const UA_SecurityPolicy *securityPolicy;",
          "121:     UA_ByteString remoteCertificate;",
          "",
          "[Removed Lines]",
          "118:     UA_Connection *connection;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "157: void UA_SecureChannel_init(UA_SecureChannel *channel);",
          "",
          "[Removed Lines]",
          "159: void UA_SecureChannel_close(UA_SecureChannel *channel);",
          "",
          "[Added Lines]",
          "163: void UA_SecureChannel_shutdown(UA_SecureChannel *channel);",
          "167: void UA_SecureChannel_clear(UA_SecureChannel *channel);",
          "",
          "---------------"
        ],
        "src/ua_securechannel_crypto.c||src/ua_securechannel_crypto.c": [
          "File: src/ua_securechannel_crypto.c -> src/ua_securechannel_crypto.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "561:        timeout < UA_DateTime_nowMonotonic()) {",
          "562:         UA_LOG_WARNING_CHANNEL(channel->securityPolicy->logger, channel,",
          "563:                                \"SecurityToken timed out\");",
          "565:         return UA_STATUSCODE_BADSECURECHANNELCLOSED;",
          "566:     }",
          "",
          "[Removed Lines]",
          "564:         UA_SecureChannel_close(channel);",
          "",
          "[Added Lines]",
          "564:         UA_SecureChannel_shutdown(channel);",
          "",
          "---------------"
        ],
        "tests/check_securechannel.c||tests/check_securechannel.c": [
          "File: tests/check_securechannel.c -> tests/check_securechannel.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "31: UA_ByteString dummyCertificate =",
          "32:     UA_BYTESTRING_STATIC(\"DUMMY CERTIFICATE DUMMY CERTIFICATE DUMMY CERTIFICATE\");",
          "33: UA_SecurityPolicy dummyPolicy;",
          "35: UA_ByteString sentData;",
          "38: static funcs_called fCalled;",
          "39: static key_sizes keySizes;",
          "41: static void",
          "42: setup_secureChannel(void) {",
          "43:     TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);",
          "45:     UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);",
          "52:     testChannel.state = UA_SECURECHANNELSTATE_OPEN;",
          "53: }",
          "55: static void",
          "56: teardown_secureChannel(void) {",
          "58:     dummyPolicy.clear(&dummyPolicy);",
          "60: }",
          "62: static void",
          "",
          "[Removed Lines]",
          "34: UA_Connection testingConnection;",
          "44:     UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);",
          "47:     testingConnection =",
          "48:         createDummyConnection(UA_ConnectionConfig_default.sendBufferSize, &sentData);",
          "49:     UA_Connection_attachSecureChannel(&testingConnection, &testChannel);",
          "50:     testChannel.connection = &testingConnection;",
          "57:     UA_SecureChannel_close(&testChannel);",
          "59:     testingConnection.close(&testingConnection);",
          "",
          "[Added Lines]",
          "42:     UA_SecureChannel_init(&testChannel);",
          "43:     testChannel.config = UA_ConnectionConfig_default;",
          "46:     testChannel.connectionManager = &testConnectionManagerTCP;",
          "48:     testConnectionLastSentBuf = &sentData;",
          "53:     UA_SecureChannel_clear(&testChannel);",
          "55:     UA_ByteString_clear(&sentData);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "97:     UA_StatusCode retval;",
          "99:     UA_SecureChannel channel;",
          "101:     retval = UA_SecureChannel_setSecurityPolicy(&channel, &dummyPolicy, &dummyCertificate);",
          "103:     ck_assert_msg(retval == UA_STATUSCODE_GOOD, \"Expected StatusCode to be good\");",
          "",
          "[Removed Lines]",
          "100:     UA_SecureChannel_init(&channel, &UA_ConnectionConfig_default);",
          "",
          "[Added Lines]",
          "96:     UA_SecureChannel_init(&channel);",
          "97:     channel.config = UA_ConnectionConfig_default;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:                   \"Expected makeCertificateThumbprint to have been called\");",
          "108:     ck_assert_msg(channel.securityPolicy == &dummyPolicy, \"SecurityPolicy not set correctly\");",
          "111:     ck_assert_msg(fCalled.deleteContext, \"Expected deleteContext to have been called\");",
          "113:     dummyPolicy.clear(&dummyPolicy);",
          "",
          "[Removed Lines]",
          "110:     UA_SecureChannel_close(&channel);",
          "",
          "[Added Lines]",
          "107:     UA_SecureChannel_clear(&channel);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "119:     memset(response, 0, sizeof(UA_OpenSecureChannelResponse));",
          "120: }",
          "138: START_TEST(SecureChannel_sendAsymmetricOPNMessage_invalidParameters) {",
          "139:     UA_OpenSecureChannelResponse dummyResponse;",
          "140:     createDummyResponse(&dummyResponse);",
          "",
          "[Removed Lines]",
          "122: START_TEST(SecureChannel_sendAsymmetricOPNMessage_withoutConnection) {",
          "123:     UA_OpenSecureChannelResponse dummyResponse;",
          "124:     createDummyResponse(&dummyResponse);",
          "125:     testChannel.securityMode = UA_MESSAGESECURITYMODE_NONE;",
          "128:     UA_Connection_detachSecureChannel(testChannel.connection);",
          "129:     testChannel.connection = NULL;",
          "131:     UA_StatusCode retval =",
          "132:         UA_SecureChannel_sendAsymmetricOPNMessage(&testChannel, 42, &dummyResponse,",
          "133:                                                   &UA_TYPES[UA_TYPES_OPENSECURECHANNELRESPONSE]);",
          "135:     ck_assert_msg(retval != UA_STATUSCODE_GOOD, \"Expected failure without a connection\");",
          "136: }END_TEST",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "568:     tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_funcs_called, teardown_funcs_called);",
          "569:     tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_key_sizes, teardown_key_sizes);",
          "570:     tcase_add_checked_fixture(tc_sendAsymmetricOPNMessage, setup_secureChannel, teardown_secureChannel);",
          "572:     tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_invalidParameters);",
          "573:     tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeInvalid);",
          "574:     tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_SecurityModeNone);",
          "",
          "[Removed Lines]",
          "571:     tcase_add_test(tc_sendAsymmetricOPNMessage, SecureChannel_sendAsymmetricOPNMessage_withoutConnection);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "tests/testing-plugins/testing_networklayers.c||tests/testing-plugins/testing_networklayers.c": [
          "File: tests/testing-plugins/testing_networklayers.c -> tests/testing-plugins/testing_networklayers.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include \"testing_networklayers.h\"",
          "19: static UA_StatusCode",
          "30: }",
          "32: static UA_StatusCode",
          "40:     }",
          "41:     return UA_STATUSCODE_GOOD;",
          "42: }",
          "46: }",
          "53: }",
          "72: }",
          "",
          "[Removed Lines]",
          "7: #include <open62541/server_config_default.h>",
          "9: #include <assert.h>",
          "10: #include <stdlib.h>",
          "12: #include \"testing_clock.h\"",
          "14: static UA_ByteString *vBuffer;",
          "15: static UA_ByteString sendBuffer;",
          "17: UA_StatusCode UA_Client_recvTesting_result = UA_STATUSCODE_GOOD;",
          "20: dummyGetSendBuffer(UA_Connection *connection, size_t length, UA_ByteString *buf) {",
          "21:     if(length > sendBuffer.length)",
          "22:         return UA_STATUSCODE_BADCOMMUNICATIONERROR;",
          "24:     buf->length = length;",
          "25:     return UA_STATUSCODE_GOOD;",
          "26: }",
          "28: static void",
          "29: dummyReleaseSendBuffer(UA_Connection *connection, UA_ByteString *buf) {",
          "33: dummySend(UA_Connection *connection, UA_ByteString *buf) {",
          "34:     assert(connection != NULL);",
          "35:     assert(buf != NULL);",
          "37:     if(vBuffer) {",
          "38:         UA_ByteString_clear(vBuffer);",
          "39:         UA_ByteString_copy(buf, vBuffer);",
          "44: static void",
          "45: dummyReleaseRecvBuffer(UA_Connection *connection, UA_ByteString *buf) {",
          "48: static void",
          "49: dummyClose(UA_Connection *connection) {",
          "50:     if(vBuffer)",
          "51:         UA_ByteString_clear(vBuffer);",
          "52:     UA_ByteString_clear(&sendBuffer);",
          "55: UA_Connection createDummyConnection(size_t sendBufferSize,",
          "56:                                     UA_ByteString *verificationBuffer) {",
          "57:     vBuffer = verificationBuffer;",
          "58:     UA_ByteString_allocBuffer(&sendBuffer, sendBufferSize);",
          "60:     UA_Connection c;",
          "61:     c.state = UA_CONNECTIONSTATE_ESTABLISHED;",
          "62:     c.channel = NULL;",
          "63:     c.sockfd = UA_INVALID_SOCKET;",
          "64:     c.handle = NULL;",
          "65:     c.getSendBuffer = dummyGetSendBuffer;",
          "66:     c.releaseSendBuffer = dummyReleaseSendBuffer;",
          "67:     c.send = dummySend;",
          "68:     c.recv = NULL;",
          "69:     c.releaseRecvBuffer = dummyReleaseRecvBuffer;",
          "70:     c.close = dummyClose;",
          "71:     return c;",
          "74: UA_UInt32 UA_Client_recvSleepDuration;",
          "75: UA_StatusCode (*UA_Client_recv)(UA_Connection *connection, UA_ByteString *response,",
          "76:                                 UA_UInt32 timeout);",
          "78: UA_StatusCode",
          "79: UA_Client_recvTesting(UA_Connection *connection, UA_ByteString *response,",
          "80:                     UA_UInt32 timeout) {",
          "82:     if(UA_Client_recvTesting_result != UA_STATUSCODE_GOOD) {",
          "83:         UA_StatusCode temp = UA_Client_recvTesting_result;",
          "84:         UA_Client_recvTesting_result = UA_STATUSCODE_GOOD;",
          "85:         UA_fakeSleep(timeout);",
          "86:         return temp;",
          "87:     }",
          "89:     UA_StatusCode res = UA_Client_recv(connection, response, timeout);",
          "90:     if(res == UA_STATUSCODE_GOODNONCRITICALTIMEOUT)",
          "91:         UA_fakeSleep(timeout);",
          "92:     else",
          "93:         UA_fakeSleep(UA_Client_recvSleepDuration);",
          "94:     UA_Client_recvSleepDuration = 0;",
          "95:     return res;",
          "96: }",
          "",
          "[Added Lines]",
          "7: UA_ByteString *testConnectionLastSentBuf;",
          "10: testOpenConnection(UA_ConnectionManager *cm,",
          "11:                     size_t paramsSize, const UA_KeyValuePair *params,",
          "12:                     void *application, void *context,",
          "13:                     UA_ConnectionManager_connectionCallback connectionCallback) {",
          "14:     return UA_STATUSCODE_BADNOTCONNECTED;",
          "18: testSendWithConnection(UA_ConnectionManager *cm, uintptr_t connectionId,",
          "19:                        size_t paramsSize, const UA_KeyValuePair *params,",
          "20:                        UA_ByteString *buf) {",
          "21:     if(testConnectionLastSentBuf) {",
          "22:         UA_ByteString_clear(testConnectionLastSentBuf);",
          "24:         UA_ByteString_init(buf);",
          "25:     } else {",
          "26:         UA_ByteString_clear(buf);",
          "31: static UA_StatusCode",
          "32: testCloseConnection(UA_ConnectionManager *cm, uintptr_t connectionId) {",
          "33:     return UA_STATUSCODE_GOOD;",
          "36: static UA_StatusCode",
          "37: testAllocNetworkBuffer(UA_ConnectionManager *cm, uintptr_t connectionId,",
          "38:                         UA_ByteString *buf, size_t bufSize) {",
          "39:     return UA_ByteString_allocBuffer(buf, bufSize);",
          "42: static void",
          "43: testFreeNetworkBuffer(UA_ConnectionManager *cm, uintptr_t connectionId,",
          "44:                       UA_ByteString *buf) {",
          "45:     UA_ByteString_clear(buf);",
          "48: UA_ConnectionManager testConnectionManagerTCP = {",
          "50:     UA_STRING_STATIC(\"tcp\"),",
          "51:     testOpenConnection,",
          "52:     testSendWithConnection,",
          "53:     testCloseConnection,",
          "54:     testAllocNetworkBuffer,",
          "55:     testFreeNetworkBuffer",
          "56: };",
          "",
          "---------------"
        ],
        "tests/testing-plugins/testing_networklayers.h||tests/testing-plugins/testing_networklayers.h": [
          "File: tests/testing-plugins/testing_networklayers.h -> tests/testing-plugins/testing_networklayers.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #ifndef TESTING_NETWORKLAYERS_H_",
          "6: #define TESTING_NETWORKLAYERS_H_",
          "10: _UA_BEGIN_DECLS",
          "35: _UA_END_DECLS",
          "",
          "[Removed Lines]",
          "8: #include <open62541/server.h>",
          "19: UA_Connection createDummyConnection(size_t sendBufferSize,",
          "20:                                     UA_ByteString *verificationBuffer);",
          "22: extern UA_UInt32 UA_Client_recvSleepDuration;",
          "23: extern UA_StatusCode (*UA_Client_recv)(UA_Connection *connection, UA_ByteString *response,",
          "24:                                        UA_UInt32 timeout);",
          "26: extern UA_StatusCode UA_Client_recvTesting_result;",
          "31: UA_StatusCode",
          "32: UA_Client_recvTesting(UA_Connection *connection, UA_ByteString *response,",
          "33:                     UA_UInt32 timeout);",
          "",
          "[Added Lines]",
          "8: #include <open62541/plugin/eventloop.h>",
          "14: extern UA_ByteString *testConnectionLastSentBuf;",
          "16: extern UA_ConnectionManager testConnectionManagerTCP;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
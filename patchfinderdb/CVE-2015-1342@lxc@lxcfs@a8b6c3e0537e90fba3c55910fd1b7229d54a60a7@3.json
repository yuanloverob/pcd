{
  "cve_id": "CVE-2015-1342",
  "cve_desc": "LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",
  "repo": "lxc/lxcfs",
  "patch_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
  "patch_info": {
    "commit_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "repo": "lxc/lxcfs",
    "commit_url": "https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "files": [
      "Makefile.am",
      "lxcfs.c",
      "tests/test_confinement.sh",
      "tests/test_syscalls.c"
    ],
    "message": "Fix checking of parent directories\n\nTaken from the justification in the launchpad bug:\n\nTo a task in freezer cgroup /a/b/c/d, it should appear that there are no\ncgroups other than its descendents. Since this is a filesystem, we must have\nthe parent directories, but each parent cgroup should only contain the child\nwhich the task can see.\n\nSo, when this task looks at /a/b, it should see only directory 'c' and no\nfiles. Attempt to create /a/b/x should result in -EPERM, whether /a/b/x already\nexists or not. Attempts to query /a/b/x should result in -ENOENT whether /a/b/x\nexists or not. Opening /a/b/tasks should result in -ENOENT.\n\nThe caller_may_see_dir checks specifically whether a task may see a cgroup\ndirectory - i.e. /a/b/x if opening /a/b/x/tasks, and /a/b/c/d if doing\nopendir('/a/b/c/d').\n\ncaller_is_in_ancestor() will return true if the caller in /a/b/c/d looks at\n/a/b/c/d/e. If the caller is in a child cgroup of the queried one - i.e. if the\ntask in /a/b/c/d queries /a/b, then *nextcg will container the next (the only)\ndirectory which he can see in the path - 'c'.\n\nBeyond this, regular DAC permissions should apply, with the\nroot-in-user-namespace privilege over its mapped uids being respected. The\nfc_may_access check does this check for both directories and files.\n\nThis is CVE-2015-1342 (LP: #1508481)\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
    "before_after_code_files": [
      "Makefile.am||Makefile.am",
      "lxcfs.c||lxcfs.c",
      "tests/test_confinement.sh||tests/test_confinement.sh",
      "tests/test_syscalls.c||tests/test_syscalls.c"
    ]
  },
  "patch_diff": {
    "Makefile.am||Makefile.am": [
      "File: Makefile.am -> Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: TEST_READ: tests/test-read.c",
      "31:  $(CC) -o tests/test-read tests/test-read.c",
      "33: TEST_CPUSET: tests/cpusetrange.c cpuset.c",
      "34:  $(CC) -o tests/cpusetrange tests/cpusetrange.c cpuset.c",
      "38: distclean:",
      "39:  rm -rf .deps/ \\",
      "",
      "[Removed Lines]",
      "36: tests: TEST_READ TEST_CPUSET",
      "",
      "[Added Lines]",
      "34: TEST_SYSCALLS: tests/test_syscalls.c",
      "35:  $(CC) -o tests/test_syscalls tests/test_syscalls.c",
      "37: tests: TEST_READ TEST_CPUSET TEST_SYSCALLS",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "60:   lxcfs.o \\",
      "61:   m4/ \\",
      "62:   missing \\",
      "",
      "[Removed Lines]",
      "63:   stamp-h1",
      "",
      "[Added Lines]",
      "64:   stamp-h1 \\",
      "65:   tests/test_syscalls",
      "",
      "---------------"
    ],
    "lxcfs.c||lxcfs.c": [
      "File: lxcfs.c -> lxcfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "379: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
      "380: {",
      "383:  bool answer = false;",
      "392:   return false;",
      "420:   }",
      "421:   answer = true;",
      "422:   goto out;",
      "423:  }",
      "425: out:",
      "428:  return answer;",
      "429: }",
      "",
      "[Removed Lines]",
      "381:  char fnam[PROCLEN];",
      "382:  FILE *f;",
      "384:  char *line = NULL;",
      "385:  size_t len = 0;",
      "386:  int ret;",
      "388:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
      "389:  if (ret < 0 || ret >= PROCLEN)",
      "390:   return false;",
      "391:  if (!(f = fopen(fnam, \"r\")))",
      "394:  while (getline(&line, &len, f) != -1) {",
      "395:   char *c1, *c2, *linecmp;",
      "396:   if (!line[0])",
      "397:    continue;",
      "398:   c1 = strchr(line, ':');",
      "399:   if (!c1)",
      "400:    goto out;",
      "401:   c1++;",
      "402:   c2 = strchr(c1, ':');",
      "403:   if (!c2)",
      "404:    goto out;",
      "406:   if (strcmp(c1, contrl) != 0)",
      "407:    continue;",
      "408:   c2++;",
      "409:   stripnewline(c2);",
      "410:   prune_init_slice(c2);",
      "415:   linecmp = *cg == '/' ? c2 : c2+1;",
      "416:   if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "417:    if (nextcg)",
      "419:    goto out;",
      "426:  fclose(f);",
      "427:  free(line);",
      "",
      "[Added Lines]",
      "388:  char *c2 = get_pid_cgroup(pid, contrl);",
      "389:  char *linecmp;",
      "391:  if (!c2)",
      "393:  prune_init_slice(c2);",
      "399:  linecmp = *cg == '/' ? c2 : c2+1;",
      "400:  if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "401:   if (nextcg) {",
      "404:   goto out;",
      "405:  }",
      "406:  answer = true;",
      "408: out:",
      "409:  free(c2);",
      "410:  return answer;",
      "411: }",
      "416: static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)",
      "417: {",
      "418:  bool answer = false;",
      "419:  char *c2, *task_cg;",
      "420:  size_t target_len, task_len;",
      "422:  if (strcmp(cg, \"/\") == 0)",
      "423:   return true;",
      "425:  c2 = get_pid_cgroup(pid, contrl);",
      "427:  if (!c2)",
      "428:   return false;",
      "430:  task_cg = c2 + 1;",
      "431:  target_len = strlen(cg);",
      "432:  task_len = strlen(task_cg);",
      "433:  if (strcmp(cg, task_cg) == 0) {",
      "437:  if (target_len < task_len) {",
      "439:   if (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')",
      "440:    answer = true;",
      "441:   goto out;",
      "442:  }",
      "443:  if (target_len > task_len) {",
      "445:   if (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')",
      "446:    answer = true;",
      "447:   goto out;",
      "448:  }",
      "451:  free(c2);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "554:  if (is_child_cgroup(controller, path1, path2)) {",
      "555:   if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {",
      "557:    sb->st_mode = S_IFDIR | 00555;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "579:   if (!caller_may_see_dir(fc->pid, controller, cgroup)) {",
      "580:    ret = -ENOENT;",
      "581:    goto out;",
      "582:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "630:   }",
      "631:  }",
      "635:  }",
      "",
      "[Removed Lines]",
      "633:  if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
      "634:   return -EACCES;",
      "",
      "[Added Lines]",
      "661:  if (cgroup) {",
      "662:   if (!caller_may_see_dir(fc->pid, controller, cgroup))",
      "663:    return -ENOENT;",
      "664:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
      "665:    return -EACCES;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "780:  }",
      "781:  free_key(k);",
      "783:  if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {",
      "785:   ret = -EACCES;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "814:  if (!caller_may_see_dir(fc->pid, controller, path1)) {",
      "815:   ret = -ENOENT;",
      "816:   goto out;",
      "817:  }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1563: int cg_mkdir(const char *path, mode_t mode)",
      "1564: {",
      "1565:  struct fuse_context *fc = fuse_get_context();",
      "1567:  const char *cgroup;",
      "1568:  int ret;",
      "",
      "[Removed Lines]",
      "1566:  char *fpath = NULL, *path1, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1601:  char *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1585:  else",
      "1586:   path1 = cgdir;",
      "1588:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {",
      "1589:   ret = -EACCES;",
      "1590:   goto out;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1623:  if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {",
      "1624:   if (fpath && strcmp(next, fpath) == 0)",
      "1625:    ret = -EEXIST;",
      "1626:   else",
      "1627:    ret = -ENOENT;",
      "1628:   goto out;",
      "1629:  }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1600: out:",
      "1601:  free(cgdir);",
      "1602:  return ret;",
      "1603: }",
      "1605: static int cg_rmdir(const char *path)",
      "1606: {",
      "1607:  struct fuse_context *fc = fuse_get_context();",
      "1609:  const char *cgroup;",
      "1610:  int ret;",
      "",
      "[Removed Lines]",
      "1608:  char *fpath = NULL, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1645:  free(next);",
      "1652:  char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1626:   goto out;",
      "1627:  }",
      "1631:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {",
      "1632:   ret = -EACCES;",
      "1633:   goto out;",
      "",
      "[Removed Lines]",
      "1629:  fprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",",
      "1630:    controller, cgdir, path);",
      "",
      "[Added Lines]",
      "1673:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {",
      "1674:   if (!fpath || strcmp(next, fpath) == 0)",
      "1675:    ret = -EBUSY;",
      "1676:   else",
      "1677:    ret = -ENOENT;",
      "1678:   goto out;",
      "1679:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1647: out:",
      "1648:  free(cgdir);",
      "1649:  return ret;",
      "1650: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1699:  free(next);",
      "",
      "---------------"
    ],
    "tests/test_confinement.sh||tests/test_confinement.sh": [
      "File: tests/test_confinement.sh -> tests/test_confinement.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #!/bin/bash",
      "3: set -ex",
      "5: [ $(id -u) -eq 0 ]",
      "7: d=$(mktemp -t -d tmp.XXX)",
      "8: d2=$(mktemp -t -d tmp.XXX)",
      "10: pid=-1",
      "11: cleanup() {",
      "12:  [ $pid -ne -1 ] && kill -9 $pid",
      "13:  umount -l $d || true",
      "14:  umount -l $d2 || true",
      "15:  rm -rf $d $d2",
      "16: }",
      "18: cmdline=$(realpath $0)",
      "19: dirname=$(dirname ${cmdline})",
      "20: topdir=$(dirname ${dirname})",
      "22: trap cleanup EXIT HUP INT TERM",
      "24: ${topdir}/lxcfs $d &",
      "25: pid=$!",
      "27: # put ourselves into x1",
      "28: cgm movepidabs freezer / $$",
      "29: cgm create freezer x1",
      "30: cgm movepid freezer x1 $$",
      "32: mount -t cgroup -o freezer freezer $d2",
      "33: sudo rmdir $d2/lxcfs_test_a1/lxcfs_test_a2 || true",
      "34: sudo rmdir $d2/lxcfs_test_a1 || true",
      "36: echo \"Making sure root cannot mkdir\"",
      "37: bad=0",
      "38: mkdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "39: if [ \"${bad}\" -eq 1 ]; then",
      "40:  false",
      "41: fi",
      "43: echo \"Making sure root cannot rmdir\"",
      "44: mkdir $d2/lxcfs_test_a1",
      "45: mkdir $d2/lxcfs_test_a1/lxcfs_test_a2",
      "46: rmdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "47: if [ \"${bad}\" -eq 1 ]; then",
      "48:  false",
      "49: fi",
      "50: [ -d $d2/lxcfs_test_a1 ]",
      "51: rmdir $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2 && bad=1",
      "52: if [ \"${bad}\" -eq 1 ]; then",
      "53:  false",
      "54: fi",
      "55: [ -d $d2/lxcfs_test_a1/lxcfs_test_a2 ]",
      "57: echo \"Making sure root cannot read/write\"",
      "58: sleep 200 &",
      "59: p=$!",
      "60: echo $p > $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "61: if [ \"${bad}\" -eq 1 ]; then",
      "62:  false",
      "63: fi",
      "64: cat $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "65: if [ \"${bad}\" -eq 1 ]; then",
      "66:  false",
      "67: fi",
      "68: echo $p > $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "69: if [ \"${bad}\" -eq 1 ]; then",
      "70:  false",
      "71: fi",
      "72: cat $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "73: if [ \"${bad}\" -eq 1 ]; then",
      "74:  false",
      "75: fi",
      "77: # make sure things like truncate and access don't leak info about",
      "78: # the /lxcfs_test_a1 cgroup which we shouldn't be able to reach",
      "79: echo \"Testing other system calls\"",
      "80: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1",
      "81: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2",
      "83: echo \"Making sure root can act on descendents\"",
      "84: mycg=$(cgm getpidcgroupabs freezer $$)",
      "85: newcg=${mycg}/lxcfs_test_a1",
      "86: rmdir $d2/$newcg || true  # cleanup previosu run",
      "87: mkdir $d/cgroup/freezer/$newcg",
      "88: echo $p > $d/cgroup/freezer/$newcg/tasks",
      "89: cat $d/cgroup/freezer/$newcg/tasks",
      "90: kill -9 $p",
      "91: while [ `wc -l $d/cgroup/freezer/$newcg/tasks | awk '{ print $1 }'` -ne 0 ]; do",
      "92:  sleep 1",
      "93: done",
      "94: rmdir $d/cgroup/freezer/$newcg",
      "96: echo \"All tests passed!\"",
      "",
      "---------------"
    ],
    "tests/test_syscalls.c||tests/test_syscalls.c": [
      "File: tests/test_syscalls.c -> tests/test_syscalls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #define _GNU_SOURCE",
      "2: #include <stdio.h>",
      "3: #include <stdlib.h>",
      "4: #include <string.h>",
      "5: #include <unistd.h>",
      "6: #include <sys/types.h>",
      "7: #include <sys/socket.h>",
      "8: #include <linux/un.h>",
      "9: #include <attr/xattr.h>",
      "10: #include <utime.h>",
      "11: #include <sys/stat.h>",
      "12: #include <sys/mount.h>",
      "13: #include <libgen.h>",
      "14: #include <fcntl.h>",
      "15: #include <errno.h>",
      "18: void test_open(const char *path)",
      "19: {",
      "20:  int fd = open(path, O_RDONLY);",
      "21:  if (fd >= 0) {",
      "22:   fprintf(stderr, \"leak at open of %s\\n\", path);",
      "23:   exit(1);",
      "24:  }",
      "25:  if (errno != ENOENT) {",
      "26:   fprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);",
      "27:   exit(1);",
      "28:  }",
      "29: }",
      "31: void test_stat(const char *path)",
      "32: {",
      "33:  struct stat sb;",
      "34:  if (stat(path, &sb) >= 0) {",
      "35:   fprintf(stderr, \"leak at stat of %s\\n\", path);",
      "36:   exit(1);",
      "37:  }",
      "38:  if (errno != ENOENT) {",
      "39:   fprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);",
      "40:   exit(1);",
      "41:  }",
      "42: }",
      "44: void test_access(const char *path)",
      "45: {",
      "46:  if (access(path, O_RDONLY) >= 0) {",
      "47:   fprintf(stderr, \"leak at access of %s\\n\", path);",
      "48:   exit(1);",
      "49:  }",
      "50:  if (errno != ENOENT) {",
      "51:   fprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);",
      "52:   exit(1);",
      "53:  }",
      "54: }",
      "56: void test_bind(const char *path)",
      "57: {",
      "58:  int sfd;",
      "59:  struct sockaddr_un my_addr, peer_addr;",
      "61:  sfd = socket(AF_UNIX, SOCK_STREAM, 0);",
      "63:  if (sfd < 0) {",
      "64:   fprintf(stderr, \"Failed to open a socket for bind test\\n\");",
      "65:   exit(1);",
      "66:  }",
      "67:  memset(&my_addr, 0, sizeof(struct sockaddr_un));",
      "68:  my_addr.sun_family = AF_UNIX;",
      "69:  strncpy(my_addr.sun_path, path,",
      "70:    sizeof(my_addr.sun_path) - 1);",
      "71:  if (bind(sfd, (struct sockaddr *) &my_addr,",
      "72:     sizeof(struct sockaddr_un)) != -1) {",
      "73:   fprintf(stderr, \"leak at bind of %s\\n\", path);",
      "74:   exit(1);",
      "75:  }",
      "76:  if (errno != ENOENT && errno != ENOSYS) {",
      "77:   fprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));",
      "78:   exit(1);",
      "79:  }",
      "80:  close(sfd);",
      "81: }",
      "83: void test_bindmount(const char *path)",
      "84: {",
      "85:  if (mount(path, path, \"none\", MS_BIND, NULL) == 0) {",
      "86:   fprintf(stderr, \"leak at bind mount of %s\\n\", path);",
      "87:   exit(1);",
      "88:  }",
      "89: }",
      "91: void test_truncate(const char *path)",
      "92: {",
      "93:  if (truncate(path, 0) == 0) {",
      "94:   fprintf(stderr, \"leak at truncate of %s\\n\", path);",
      "95:   exit(1);",
      "96:  }",
      "97: }",
      "99: void test_chdir(const char *path)",
      "100: {",
      "101:  if (chdir(path) == 0) {",
      "102:   fprintf(stderr, \"leak at chdir to %s\\n\", path);",
      "103:   exit(1);",
      "104:  }",
      "105: }",
      "107: void test_rename(const char *path)",
      "108: {",
      "109:  char *d = strdupa(path), *tmpname;",
      "110:  d = dirname(d);",
      "111:  size_t len = strlen(path) + 30;",
      "113:  tmpname = alloca(len);",
      "114:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "115:  if (rename(path, tmpname) == 0 || errno != ENOENT) {",
      "116:   fprintf(stderr, \"leak at rename of %s\\n\", path);",
      "117:   exit(1);",
      "118:  }",
      "119: }",
      "121: void test_mkdir(const char *path)",
      "122: {",
      "123:  size_t len = strlen(path) + 30;",
      "124:  char *tmpname = alloca(len);",
      "125:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "127:  if (mkdir(path, 0755) == 0) {",
      "128:   fprintf(stderr, \"leak at mkdir of %s\\n\", path);",
      "129:   exit(1);",
      "130:  }",
      "131:  if (errno != ENOENT) {",
      "132:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "133:   exit(1);",
      "134:  }",
      "135:  if (mkdir(tmpname, 0755) == 0) {",
      "136:   fprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);",
      "137:   exit(1);",
      "138:  }",
      "139:  if (errno != ENOENT) {",
      "140:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "141:   exit(1);",
      "142:  }",
      "143: }",
      "145: void test_rmdir(const char *path)",
      "146: {",
      "147:  size_t len = strlen(path) + 30;",
      "148:  char *tmpname = alloca(len);",
      "149:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "151:  if (rmdir(path) == 0 || errno != ENOENT) {",
      "152:   fprintf(stderr, \"leak at rmdir of %s\\n\", path);",
      "153:   exit(1);",
      "154:  }",
      "155:  if (rmdir(tmpname) == 0 || errno != ENOENT) {",
      "156:   fprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);",
      "157:   exit(1);",
      "158:  }",
      "159: }",
      "161: void test_creat(const char *path)",
      "162: {",
      "163:  if (creat(path, 0755) >= 0) {",
      "164:   fprintf(stderr, \"leak at creat of %s\\n\", path);",
      "165:   exit(1);",
      "166:  }",
      "167:  if (errno != ENOENT && errno != ENOSYS) {",
      "168:   fprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));",
      "169:   exit(1);",
      "170:  }",
      "171: }",
      "173: void test_link(const char *path)",
      "174: {",
      "175:  char *d = strdupa(path), *tmpname;",
      "176:  d = dirname(d);",
      "177:  size_t len = strlen(path) + 30;",
      "178:  tmpname = alloca(len);",
      "179:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "181:  if (link(path, tmpname) == 0) {",
      "182:   fprintf(stderr, \"leak at link of %s\\n\", path);",
      "183:   exit(1);",
      "184:  }",
      "185:  if (errno != ENOENT && errno != ENOSYS) {",
      "186:   fprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));",
      "187:   exit(1);",
      "188:  }",
      "190:  if (link(tmpname, path) == 0) {",
      "191:   fprintf(stderr, \"leak at link (2) of %s\\n\", path);",
      "192:   exit(1);",
      "193:  }",
      "194:  if (errno != ENOENT && errno != ENOSYS) {",
      "195:   fprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "196:   exit(1);",
      "197:  }",
      "198: }",
      "200: void test_unlink(const char *path)",
      "201: {",
      "202:  if (unlink(path) == 0) {",
      "203:   fprintf(stderr, \"leak at unlink of %s\\n\", path);",
      "204:   exit(1);",
      "205:  }",
      "206:  if (errno != ENOENT && errno != ENOSYS) {",
      "207:   fprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));",
      "208:   exit(1);",
      "209:  }",
      "210: }",
      "212: void test_symlink(const char *path)",
      "213: {",
      "214:  char *d = strdupa(path), *tmpname;",
      "215:  d = dirname(d);",
      "216:  size_t len = strlen(path) + 30;",
      "217:  tmpname = alloca(len);",
      "218:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "220:  if (symlink(tmpname, path) == 0) {",
      "221:   fprintf(stderr, \"leak at symlink of %s\\n\", path);",
      "222:   exit(1);",
      "223:  }",
      "224:  if (errno != ENOENT && errno != ENOSYS) {",
      "225:   fprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));",
      "226:   exit(1);",
      "227:  }",
      "228:  if (symlink(path, tmpname) == 0) {",
      "229:   fprintf(stderr, \"leak at symlink (2) of %s\\n\", path);",
      "230:   exit(1);",
      "231:  }",
      "232:  if (errno != ENOENT && errno != ENOSYS) {",
      "233:   fprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "234:   exit(1);",
      "235:  }",
      "236: }",
      "238: void test_readlink(const char *path)",
      "239: {",
      "240:  char *dest = alloca(2 * strlen(path));",
      "242:  if (readlink(path, dest, 2 * strlen(path)) >= 0) {",
      "243:   fprintf(stderr, \"leak at readlink of %s\\n\", path);",
      "244:   exit(1);",
      "245:  }",
      "246:  if (errno != ENOENT && errno != ENOSYS) {",
      "247:   fprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));",
      "248:   exit(1);",
      "249:  }",
      "250: }",
      "252: void test_chmod(const char *path)",
      "253: {",
      "254:  if (chmod(path, 0755) == 0) {",
      "255:   fprintf(stderr, \"leak at chmod of %s\\n\", path);",
      "256:   exit(1);",
      "257:  }",
      "258:  if (errno != ENOENT && errno != ENOSYS) {",
      "259:   fprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));",
      "260:   exit(1);",
      "261:  }",
      "262: }",
      "264: void test_chown(const char *path)",
      "265: {",
      "266:  if (chown(path, 0, 0) == 0) {",
      "267:   fprintf(stderr, \"leak at chown of %s\\n\", path);",
      "268:   exit(1);",
      "269:  }",
      "270:  if (errno != ENOENT && errno != ENOSYS) {",
      "271:   fprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));",
      "272:   exit(1);",
      "273:  }",
      "274: }",
      "276: void test_lchown(const char *path)",
      "277: {",
      "278:  if (lchown(path, 0, 0) == 0) {",
      "279:   fprintf(stderr, \"leak at lchown of %s\\n\", path);",
      "280:   exit(1);",
      "281:  }",
      "282:  if (errno != ENOENT && errno != ENOSYS) {",
      "283:   fprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));",
      "284:   exit(1);",
      "285:  }",
      "286: }",
      "288: void test_mknod(const char *path)",
      "289: {",
      "290:  if (mknod(path, 0755, makedev(0, 0)) == 0) {",
      "291:   fprintf(stderr, \"leak at mknod of %s\\n\", path);",
      "292:   exit(1);",
      "293:  }",
      "294:  if (errno != ENOENT && errno != ENOSYS) {",
      "295:   fprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));",
      "296:   exit(1);",
      "297:  }",
      "298: }",
      "300: void test_chroot(const char *path)",
      "301: {",
      "302:  if (chroot(path) == 0) {",
      "303:   fprintf(stderr, \"leak at chroot of %s\\n\", path);",
      "304:   exit(1);",
      "305:  }",
      "306:  if (errno != ENOENT && errno != ENOSYS) {",
      "307:   fprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));",
      "308:   exit(1);",
      "309:  }",
      "310: }",
      "312: void test_xattrs(const char *path)",
      "313: {",
      "325:   char value[200];",
      "326:   if (getxattr(path, \"security.selinux\", value, 200) >= 0) {",
      "327:   fprintf(stderr, \"leak at getxattr of %s\\n\", path);",
      "328:   exit(1);",
      "329:  }",
      "330:  if (errno != ENOENT && errno != ENOSYS) {",
      "331:   fprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));",
      "332:   exit(1);",
      "333:  }",
      "334: }",
      "336: void test_utimes(const char *path)",
      "337: {",
      "338:  struct utimbuf times;",
      "339:  times.actime = 0;",
      "340:  times.modtime = 0;",
      "342:  if (utime(path, &times) == 0) {",
      "343:   fprintf(stderr, \"leak at utime of %s\\n\", path);",
      "344:   exit(1);",
      "345:  }",
      "346:  if (errno != ENOENT && errno != ENOSYS) {",
      "347:   fprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));",
      "348:   exit(1);",
      "349:  }",
      "350: }",
      "352: void test_openat(const char *path)",
      "353: {",
      "354:  char *d = strdupa(path), *f, *tmpname;",
      "355:  int fd, fd2;",
      "356:  f = basename(d);",
      "357:  d = dirname(d);",
      "358:  fd = open(d, O_RDONLY);",
      "359:  if (fd < 0) {",
      "360:   fprintf(stderr, \"Error in openat test: could not open parent dir\\n\");",
      "361:   fprintf(stderr, \"(this is expected on the second run)\\n\");",
      "362:   return;",
      "363:  }",
      "364:  fd2 = openat(fd, f, O_RDONLY);",
      "365:  if (fd2 >= 0 || errno != ENOENT) {",
      "366:   fprintf(stderr, \"leak at openat of %s\\n\", f);",
      "367:   exit(1);",
      "368:  }",
      "369:  size_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;",
      "370:  tmpname = alloca(len);",
      "371:  snprintf(tmpname, len, \"%s/cgroup.procs\", f);",
      "372:  fd2 = openat(fd, tmpname, O_RDONLY);",
      "373:  if (fd2 >= 0 || errno != ENOENT) {",
      "374:   fprintf(stderr, \"leak at openat of %s\\n\", tmpname);",
      "375:   exit(1);",
      "376:  }",
      "377:  close(fd);",
      "378: }",
      "380: int main(int argc, char *argv[])",
      "381: {",
      "382:  char *procspath;",
      "383:  size_t len;",
      "385:  if (geteuid() != 0) {",
      "386:   fprintf(stderr, \"Run me as root\\n\");",
      "387:   exit(1);",
      "388:  }",
      "390:  if (argc != 2)  {",
      "391:   fprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);",
      "392:   exit(1);",
      "393:  }",
      "396:  len = strlen(argv[1]) + strlen(\"/cgroup.procs\") + 1;",
      "397:  procspath = alloca(len);",
      "398:  snprintf(procspath, len, \"%s/cgroup.procs\", argv[1]);",
      "400:  test_open(argv[1]);",
      "401:  test_open(procspath);",
      "402:  test_stat(argv[1]);",
      "403:  test_stat(procspath);",
      "404:  test_access(argv[1]);",
      "405:  test_access(procspath);",
      "407:  test_bind(argv[1]);",
      "408:  test_bind(procspath);",
      "409:  test_bindmount(argv[1]);",
      "410:  test_bindmount(procspath);",
      "411:  test_truncate(argv[1]);",
      "412:  test_truncate(procspath);",
      "413:  test_chdir(argv[1]);",
      "414:  test_chdir(procspath);",
      "415:  test_rename(argv[1]);",
      "416:  test_rename(procspath);",
      "417:  test_mkdir(argv[1]);",
      "418:  test_mkdir(procspath);",
      "419:  test_rmdir(argv[1]);",
      "420:  test_rmdir(procspath);",
      "421:  test_creat(argv[1]);",
      "422:  test_creat(procspath);",
      "423:  test_link(argv[1]);",
      "424:  test_link(procspath);",
      "425:  test_unlink(argv[1]);",
      "426:  test_unlink(procspath);",
      "427:  test_symlink(argv[1]);",
      "428:  test_symlink(procspath);",
      "429:  test_readlink(argv[1]);",
      "430:  test_readlink(procspath);",
      "431:  test_chmod(argv[1]);",
      "432:  test_chmod(procspath);",
      "433:  test_chown(argv[1]);",
      "434:  test_chown(procspath);",
      "435:  test_lchown(argv[1]);",
      "436:  test_lchown(procspath);",
      "437:  test_mknod(argv[1]);",
      "438:  test_mknod(procspath);",
      "439:  test_chroot(argv[1]);",
      "440:  test_chroot(procspath);",
      "441:  test_xattrs(argv[1]);",
      "442:  test_xattrs(procspath);",
      "443:  test_utimes(argv[1]);",
      "444:  test_utimes(procspath);",
      "446:  test_openat(argv[1]);",
      "449:  printf(\"All tests passed\\n\");",
      "450:  return 0;",
      "451: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "97f1f27b88a28081cf52e728cb41956cbc13f489",
      "candidate_info": {
        "commit_hash": "97f1f27b88a28081cf52e728cb41956cbc13f489",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/97f1f27b88a28081cf52e728cb41956cbc13f489",
        "files": [
          "Makefile.am",
          "lxcfs.c",
          "tests/test-read.c",
          "tests/test_read_proc.sh"
        ],
        "message": "add cache for proc file, for support multiple read\n\nSigned-off-by: Ye Yin <eyniy@qq.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "lxcfs.c||lxcfs.c",
          "tests/test-read.c||tests/test-read.c",
          "tests/test_read_proc.sh||tests/test_read_proc.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  $(HELP2MAN) -n \"Set up cgroup fs for containers\" --no-discard-stderr -s 1 -I lxcfs.man.add -N ./lxcfs > lxcfs.1",
          "26: endif",
          "28: distclean:",
          "29:  rm -rf .deps/ \\",
          "30:   INSTALL \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: TEST_READ: tests/test-read.c",
          "29:  $(CC) -o tests/test-read tests/test-read.c",
          "31: tests: TEST_READ",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "60:  int type;",
          "61:  char *buf;  // unused as of yet",
          "62:  int buflen;",
          "63: };",
          "65: static char *must_copy_string(void *parent, const char *str)",
          "66: {",
          "67:  if (!str)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:  int size; //actual data size",
          "67: #define BUF_RESERVE_SIZE 256",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "665:  nih_free(f);",
          "666: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "669:  if (!f->buf) {",
          "670:   nih_free(f->buf);",
          "671:   f->buf = NULL;",
          "672:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1591:   struct fuse_file_info *fi)",
          "1592: {",
          "1593:  struct fuse_context *fc = fuse_get_context();",
          "1594:  nih_local char *cg = get_pid_cgroup(fc->pid, \"memory\");",
          "1595:  nih_local char *memlimit_str = NULL, *memusage_str = NULL, *memstat_str = NULL;",
          "1596:  unsigned long memlimit = 0, memusage = 0, cached = 0, hosttotal = 0;",
          "1597:  char *line = NULL;",
          "1598:  size_t linelen = 0, total_len = 0;",
          "1599:  FILE *f;",
          "1604:  if (!cg)",
          "1605:   return 0;",
          "",
          "[Removed Lines]",
          "1601:  if (offset)",
          "1602:   return -EINVAL;",
          "",
          "[Added Lines]",
          "1602:  struct file_info *d = (struct file_info *)fi->fh;",
          "1608:  char *cache = d->buf;",
          "1609:  size_t cache_size = d->buflen;",
          "1612:  if (offset){",
          "1613:   if (offset > d->size)",
          "1614:    return -EINVAL;",
          "1615:   int left = d->size - offset;",
          "1616:   total_len = left > size ? size: left;",
          "1617:   memcpy(buf, cache + offset, total_len);",
          "1618:   return total_len;",
          "1619:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1648:    printme = lbuf;",
          "1649:   } else",
          "1650:    printme = line;",
          "1655:  }",
          "1657:  fclose(f);",
          "1658:  free(line);",
          "1659:  return total_len;",
          "",
          "[Removed Lines]",
          "1651:   l = snprintf(buf, size, \"%s\", printme);",
          "1652:   buf += l;",
          "1653:   size -= l;",
          "1654:   total_len += l;",
          "",
          "[Added Lines]",
          "1669:   l = snprintf(cache, cache_size, \"%s\", printme);",
          "1670:   cache += l;",
          "1671:   cache_size -= l;",
          "1672:   total_len += l;",
          "1675:  d->size = total_len;",
          "1676:  if (total_len > size ) total_len = size;",
          "1677:  memcpy(buf, d->buf, total_len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1739:   struct fuse_file_info *fi)",
          "1740: {",
          "1741:  struct fuse_context *fc = fuse_get_context();",
          "1742:  nih_local char *cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "1743:  nih_local char *cpuset = NULL;",
          "1744:  char *line = NULL;",
          "1745:  size_t linelen = 0, total_len = 0;",
          "1746:  bool am_printing = false;",
          "1747:  int curcpu = -1;",
          "1748:  FILE *f;",
          "1753:  if (!cg)",
          "1754:   return 0;",
          "",
          "[Removed Lines]",
          "1750:  if (offset)",
          "1751:   return -EINVAL;",
          "",
          "[Added Lines]",
          "1764:  struct file_info *d = (struct file_info *)fi->fh;",
          "1771:  char *cache = d->buf;",
          "1772:  size_t cache_size = d->buflen;",
          "1775:  if (offset){",
          "1776:   if (offset > d->size)",
          "1777:    return -EINVAL;",
          "1778:   int left = d->size - offset;",
          "1779:   total_len = left > size ? size: left;",
          "1780:   memcpy(buf, cache + offset, total_len);",
          "1781:   return total_len;",
          "1782:  }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1767:    am_printing = cpuline_in_cpuset(line, cpuset);",
          "1768:    if (am_printing) {",
          "1769:     curcpu ++;",
          "1774:    }",
          "1775:    continue;",
          "1776:   }",
          "1777:   if (am_printing) {",
          "1782:   }",
          "1783:  }",
          "1785:  fclose(f);",
          "1786:  free(line);",
          "1787:  return total_len;",
          "",
          "[Removed Lines]",
          "1770:     l = snprintf(buf, size, \"processor : %d\\n\", curcpu);",
          "1771:     buf += l;",
          "1772:     size -= l;",
          "1773:     total_len += l;",
          "1778:    l = snprintf(buf, size, \"%s\", line);",
          "1779:    buf += l;",
          "1780:    size -= l;",
          "1781:    total_len += l;",
          "",
          "[Added Lines]",
          "1801:     l = snprintf(cache, cache_size, \"processor : %d\\n\", curcpu);",
          "1802:     if (l < cache_size){",
          "1803:      cache += l;",
          "1804:      cache_size -= l;",
          "1805:      total_len += l;",
          "1806:     }else{",
          "1807:      cache += cache_size;",
          "1808:      total_len += cache_size;",
          "1809:      cache_size = 0;",
          "1810:      break;",
          "1811:     }",
          "1816:    l = snprintf(cache, cache_size, \"%s\", line);",
          "1817:    if (l < cache_size) {",
          "1818:     cache += l;",
          "1819:     cache_size -= l;",
          "1820:     total_len += l;",
          "1821:    } else {",
          "1822:     cache += cache_size;",
          "1823:     total_len += cache_size;",
          "1824:     cache_size = 0;",
          "1825:     break;",
          "1826:    }",
          "1830:  d->size = total_len;",
          "1831:  if (total_len > size ) total_len = size;",
          "1834:  memcpy(buf, d->buf, total_len);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1791:   struct fuse_file_info *fi)",
          "1792: {",
          "1793:  struct fuse_context *fc = fuse_get_context();",
          "1794:  nih_local char *cg = get_pid_cgroup(fc->pid, \"cpuset\");",
          "1795:  nih_local char *cpuset = NULL;",
          "1796:  char *line = NULL;",
          "1797:  size_t linelen = 0, total_len = 0;",
          "1799:  FILE *f;",
          "1804:  if (!cg)",
          "1805:   return 0;",
          "",
          "[Removed Lines]",
          "1801:  if (offset)",
          "1802:   return -EINVAL;",
          "",
          "[Added Lines]",
          "1845:  struct file_info *d = (struct file_info *)fi->fh;",
          "1851:  unsigned long user = 0, nice = 0, system = 0, idle = 0, iowait = 0, irq = 0, softirq = 0, steal = 0, guest = 0;",
          "1852:  unsigned long user_sum = 0, nice_sum = 0, system_sum = 0, idle_sum = 0, iowait_sum = 0,",
          "1853:      irq_sum = 0, softirq_sum = 0, steal_sum = 0, guest_sum = 0;",
          "1854: #define CPUALL_MAX_SIZE BUF_RESERVE_SIZE",
          "1855:  char cpuall[CPUALL_MAX_SIZE];",
          "1857:  char *cache = d->buf + CPUALL_MAX_SIZE;",
          "1858:  size_t cache_size = d->buflen - CPUALL_MAX_SIZE;",
          "1861:  if (offset){",
          "1862:   if (offset > d->size)",
          "1863:    return -EINVAL;",
          "1864:   int left = d->size - offset;",
          "1865:   total_len = left > size ? size: left;",
          "1866:   memcpy(buf, d->buf + offset, total_len);",
          "1867:   return total_len;",
          "1868:  }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1812:  if (!f)",
          "1813:   return 0;",
          "1815:  while (getline(&line, &linelen, f) != -1) {",
          "1816:   size_t l;",
          "1817:   int cpu;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1882:  if (getline(&line, &linelen, f) < 0) {",
          "1883:   fprintf(stderr, \"proc_stat_read read first line failed\\n\");",
          "1884:   goto out;",
          "1885:  }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1821:   if (sscanf(line, \"cpu%9[^ ]\", cpu_char) != 1) {",
          "1828:   }",
          "1830:   if (sscanf(cpu_char, \"%d\", &cpu) != 1)",
          "",
          "[Removed Lines]",
          "1823:    l = snprintf(buf, size, \"%s\", line);",
          "1824:    buf += l;",
          "1825:    size -= l;",
          "1826:    total_len += l;",
          "1827:    continue;",
          "",
          "[Added Lines]",
          "1895:    l = snprintf(cache, cache_size, \"%s\", line);",
          "1896:    if (l < cache_size){",
          "1897:     cache += l;",
          "1898:     cache_size -= l;",
          "1899:     total_len += l;",
          "1900:     continue;",
          "1901:    }else{",
          "1903:     cache += cache_size;",
          "1904:     total_len += cache_size;",
          "1905:     cache_size = 0;",
          "1906:     break;",
          "1907:    }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1836:   c = strchr(line, ' ');",
          "1837:   if (!c)",
          "1838:    continue;",
          "1842:   total_len += l;",
          "1845:  fclose(f);",
          "1846:  free(line);",
          "1847:  return total_len;",
          "",
          "[Removed Lines]",
          "1839:   l = snprintf(buf, size, \"cpu%d %s\", curcpu, c);",
          "1840:   buf += l;",
          "1841:   size -= l;",
          "1843:  }",
          "",
          "[Added Lines]",
          "1919:   l = snprintf(cache, cache_size, \"cpu%d %s\", curcpu, c);",
          "1920:   cache += l;",
          "1921:   cache_size -= l;",
          "1924:   if (sscanf(line, \"%*s %lu %lu %lu %lu %lu %lu %lu %lu %lu\", &user, &nice, &system, &idle, &iowait, &irq,",
          "1925:    &softirq, &steal, &guest) != 9)",
          "1926:    continue;",
          "1927:   user_sum += user;",
          "1928:   nice_sum += nice;",
          "1929:   system_sum += system;",
          "1930:   idle_sum += idle;",
          "1931:   iowait_sum += iowait;",
          "1932:   irq_sum += irq;",
          "1933:   softirq_sum += softirq;",
          "1934:   steal_sum += steal;",
          "1935:   guest_sum += guest;",
          "1936:  }",
          "1938:  cache = d->buf;",
          "1940:  int cpuall_len = snprintf(cpuall, CPUALL_MAX_SIZE, \"%s %lu %lu %lu %lu %lu %lu %lu %lu %lu\\n\",",
          "1941:   \"cpu \", user_sum, nice_sum, system_sum, idle_sum, iowait_sum, irq_sum, softirq_sum, steal_sum, guest_sum);",
          "1942:  if (cpuall_len > 0 && cpuall_len < CPUALL_MAX_SIZE){",
          "1943:   memcpy(cache, cpuall, cpuall_len);",
          "1944:   cache += cpuall_len;",
          "1945:  }else{",
          "1947:   fprintf(stderr, \"proc_stat_read copy cpuall failed, cpuall_len=%d\\n\", cpuall_len);",
          "1948:   cpuall_len = 0;",
          "1949:  }",
          "1951:  memmove(cache, d->buf + CPUALL_MAX_SIZE, total_len);",
          "1952:  total_len += cpuall_len;",
          "1953:  d->size = total_len;",
          "1954:  if (total_len > size ) total_len = size;",
          "1956:  memcpy(buf, d->buf, total_len);",
          "1957:  fprintf(stderr, \"total_len = %d, buflen = %d\\n\", d->size, d->buflen);",
          "1958: out:",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2017:   struct fuse_file_info *fi)",
          "2018: {",
          "2019:  struct fuse_context *fc = fuse_get_context();",
          "2020:  long int reaperage = getreaperage(fc->pid);;",
          "2021:  long int idletime = getprocidle();",
          "2026: }",
          "2028: static int proc_diskstats_read(char *buf, size_t size, off_t offset,",
          "",
          "[Removed Lines]",
          "2023:  if (offset)",
          "2024:   return -EINVAL;",
          "2025:  return snprintf(buf, size, \"%ld %ld\\n\", reaperage, idletime);",
          "",
          "[Added Lines]",
          "2134:  struct file_info *d = (struct file_info *)fi->fh;",
          "2137:  size_t total_len = 0;",
          "2139:  if (offset){",
          "2140:   if (offset > d->size)",
          "2141:    return -EINVAL;",
          "2142:   return 0;",
          "2143:  }",
          "2145:  total_len = snprintf(buf, size, \"%ld %ld\\n\", reaperage, idletime);",
          "2146:  d->size = total_len;",
          "2147:  return total_len;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2030: {",
          "2031:  char dev_name[72];",
          "2032:  struct fuse_context *fc = fuse_get_context();",
          "2033:  nih_local char *cg = get_pid_cgroup(fc->pid, \"blkio\");",
          "2034:  nih_local char *io_serviced_str = NULL, *io_merged_str = NULL, *io_service_bytes_str = NULL,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2155:  struct file_info *d = (struct file_info *)fi->fh;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2045:  int i = 0;",
          "2046:  FILE *f;",
          "2051:  if (!cg)",
          "2052:   return 0;",
          "",
          "[Removed Lines]",
          "2048:  if (offset)",
          "2049:   return -EINVAL;",
          "",
          "[Added Lines]",
          "2171:  if (offset){",
          "2172:   if (offset > d->size)",
          "2173:    return -EINVAL;",
          "2174:   return 0;",
          "2175:  }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2115:   total_len += l;",
          "2116:  }",
          "2118:  fclose(f);",
          "2119:  free(line);",
          "2120:  return total_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2244:  d->size = total_len;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2199:  memset(info, 0, sizeof(*info));",
          "2200:  info->type = type;",
          "2202:  fi->fh = (unsigned long)info;",
          "2203:  return 0;",
          "2204: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2330:  info->buflen = get_procfile_size(path) + BUF_RESERVE_SIZE;",
          "2331:  info->buf = NIH_MUST( nih_alloc(NULL, info->buflen) );",
          "2332:  memset(info->buf, 0, info->buflen);",
          "2334:  info->size = info->buflen;",
          "",
          "---------------"
        ],
        "tests/test-read.c||tests/test-read.c": [
          "File: tests/test-read.c -> tests/test-read.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #define _GNU_SOURCE",
          "2: #include <stdio.h>",
          "3: #include <unistd.h>",
          "4: #include <sys/types.h>",
          "5: #include <sys/stat.h>",
          "6: #include <fcntl.h>",
          "7: #include <errno.h>",
          "8: #include <string.h>",
          "9: #include <stdlib.h>",
          "11: #define BUFSIZE 1025",
          "12: char buf[BUFSIZE];",
          "14: int read_count = 2;",
          "16: int main(int argc, char *argv[]){",
          "17:  if(argc < 3){",
          "18:   fprintf(stderr, \"usage: %s <file> <count> [buffer|direct]\\n\", argv[0]);",
          "19:   exit(1);",
          "20:  }",
          "21:  char *file = argv[1];",
          "22:  read_count = atoi(argv[2]);",
          "23:  int ret = 0,sum = 0, i = 0, fd = -1;",
          "24:  if(argc == 4 && strncmp(argv[3], \"direct\",6) == 0)",
          "25:   fd = open(file, O_RDONLY|O_DIRECT);",
          "26:  else",
          "27:   fd = open(file, O_RDONLY);",
          "29:  while(i++ < read_count){",
          "30:   memset(buf, 0, BUFSIZE);",
          "31:   ret = read(fd, buf, BUFSIZE-1);",
          "32:   if(ret > 0){",
          "33:    write(STDOUT_FILENO, buf, ret);",
          "34:    sum += ret;",
          "35:   }else if(ret == 0){",
          "36:    printf(\"======read end======\\n\");",
          "37:    break;",
          "38:   }else{",
          "39:    printf(\"error:%d\\n\", errno);",
          "40:    break;",
          "41:   }",
          "42:   sleep(1);",
          "43:  }",
          "44:  printf(\"======read sum: %d======\\n\", sum);",
          "45:  close(fd);",
          "46:  return 0;",
          "47: }",
          "",
          "---------------"
        ],
        "tests/test_read_proc.sh||tests/test_read_proc.sh": [
          "File: tests/test_read_proc.sh -> tests/test_read_proc.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #/bin/bash",
          "2: #./lxcfs -s -f -d -o allow_other -o direct_io /var/lib/lxcfs",
          "4: red_c() {",
          "5:      echo -e $2 \"\\e[31;1m${1}\\e[0m\"",
          "6: }",
          "7: DIR=/var/lib/lxcfs",
          "9: if ! mountpoint -q $DIR; then",
          "10:     echo \"lxcfs isn't mounted on /var/lib/lxcfs\"",
          "11:     exit 1",
          "12: fi",
          "15: PWD=`pwd`",
          "16: COUNT=3",
          "18: for i in test-read",
          "19: do",
          "20:  BIN=$PWD/$i",
          "22:  red_c \"$BIN test cpuinfo\"",
          "23:  $BIN $DIR/proc/cpuinfo $COUNT",
          "25:  red_c \"$BIN test stat\"",
          "26:  $BIN $DIR/proc/stat $COUNT",
          "28:  red_c \"$BIN test meminfo\"",
          "29:  $BIN $DIR/proc/meminfo $COUNT",
          "31: done",
          "32: exit 0",
          "",
          "---------------"
        ]
      }
    }
  ]
}
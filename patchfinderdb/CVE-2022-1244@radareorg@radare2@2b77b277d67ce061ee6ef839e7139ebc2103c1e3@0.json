{
  "cve_id": "CVE-2022-1244",
  "cve_desc": "heap-buffer-overflow in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability is capable of inducing denial of service.",
  "repo": "radareorg/radare2",
  "patch_hash": "2b77b277d67ce061ee6ef839e7139ebc2103c1e3",
  "patch_info": {
    "commit_hash": "2b77b277d67ce061ee6ef839e7139ebc2103c1e3",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/2b77b277d67ce061ee6ef839e7139ebc2103c1e3",
    "files": [
      "libr/bin/format/mach0/dyldcache.h",
      "libr/bin/p/bin_dyldcache.c"
    ],
    "message": "Fix oobread in dyldcache ##crash\n\n* Reported by @hdthky via huntr.dev\n* Reproducers: poc1\n* BountyID: 8ae2c61a-2220-47a5-bfe8-fe6d41ab1f82",
    "before_after_code_files": [
      "libr/bin/format/mach0/dyldcache.h||libr/bin/format/mach0/dyldcache.h",
      "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c"
    ]
  },
  "patch_diff": {
    "libr/bin/format/mach0/dyldcache.h||libr/bin/format/mach0/dyldcache.h": [
      "File: libr/bin/format/mach0/dyldcache.h -> libr/bin/format/mach0/dyldcache.h"
    ],
    "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c": [
      "File: libr/bin/p/bin_dyldcache.c -> libr/bin/p/bin_dyldcache.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1247:    if (deps && !deps[j]) {",
      "1248:     continue;",
      "1249:    }",
      "1251:    if (pa == UT64_MAX) {",
      "1252:     continue;",
      "1253:    }",
      "",
      "[Removed Lines]",
      "1250:    ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
      "",
      "[Added Lines]",
      "1251:    ut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "09e20cd53d00a1497bf50349fe6eb812b4f54ac5",
      "candidate_info": {
        "commit_hash": "09e20cd53d00a1497bf50349fe6eb812b4f54ac5",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/09e20cd53d00a1497bf50349fe6eb812b4f54ac5",
        "files": [
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_specs.h",
          "libr/bin/format/objc/mach0_classes.c",
          "libr/bin/format/objc/mach0_classes.h",
          "libr/bin/p/bin_dyldcache.c",
          "libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_mach064.c",
          "libr/util/buf.c"
        ],
        "message": "Add Support For dyld4 Atlas-style Shared Library Caches ##bin\n\n* Fix signed overflow in r_buf_fread_at ##util\n* Tweak \"malformed export trie\" debug logs",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_specs.h||libr/bin/format/mach0/mach0_specs.h",
          "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c",
          "libr/bin/format/objc/mach0_classes.h||libr/bin/format/objc/mach0_classes.h",
          "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_mach064.c||libr/bin/p/bin_mach064.c",
          "libr/util/buf.c||libr/util/buf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c"
          ],
          "candidate": [
            "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "461:  }",
          "462:  st.cmd = r_read_ble32 (symt, be);",
          "463:  st.cmdsize = r_read_ble32 (symt + 4, be);",
          "465:  st.nsyms = r_read_ble32 (symt + 12, be);",
          "467:  st.strsize = r_read_ble32 (symt + 20, be);",
          "469:  mo->symtab = NULL;",
          "",
          "[Removed Lines]",
          "464:  st.symoff = r_read_ble32 (symt + 8, be);",
          "466:  st.stroff = r_read_ble32 (symt + 16, be);",
          "",
          "[Added Lines]",
          "464:  st.symoff = r_read_ble32 (symt + 8, be) + mo->symbols_off;",
          "466:  st.stroff = r_read_ble32 (symt + 16, be) + mo->symbols_off;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1947:      bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);",
          "1948:      bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);",
          "1949:      bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);",
          "1951:      bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);",
          "1952:     }",
          "1953:    }",
          "",
          "[Removed Lines]",
          "1950:      bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);",
          "",
          "[Added Lines]",
          "1950:      bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian) + bin->symbols_off;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2128: void MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf) {",
          "2129:  r_return_if_fail (options && bf && bf->rbin);",
          "2130:  options->header_at = 0;",
          "2131:  options->verbose = bf->rbin->verbose;",
          "2132: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2131:  options->symbols_off = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2153:  if (options) {",
          "2154:   bin->verbose = options->verbose;",
          "2155:   bin->header_at = options->header_at;",
          "2156:  }",
          "2157:  bin->file = file;",
          "2158:  size_t binsz;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2157:   bin->symbols_off = options->symbols_off;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2188:   if (options) {",
          "2189:    bin->verbose = options->verbose;",
          "2190:    bin->header_at = options->header_at;",
          "2191:   }",
          "2192:   if (!init (bin)) {",
          "2193:    return MACH0_(mach0_free)(bin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2193:    bin->symbols_off = options->symbols_off;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2553:      }",
          "2554:      name = r_str_append (name, s->label);",
          "2555:     }",
          "2558:      goto beach;",
          "2559:     }",
          "2560:     if (hasResolver) {",
          "",
          "[Removed Lines]",
          "2556:     if (name == NULL) {",
          "2557:      eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2559:     if (!name) {",
          "2560:      bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2594:   next->label = (char *) p;",
          "2595:   p += strlen (next->label) + 1;",
          "2596:   if (p >= end) {",
          "2598:    R_FREE (next);",
          "2599:    goto beach;",
          "2600:   }",
          "",
          "[Removed Lines]",
          "2597:    eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2600:    bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2605:   }",
          "2606:   next->node = tr + trie;",
          "2607:   if (next->node >= end) {",
          "2609:    R_FREE (next);",
          "2610:    goto beach;",
          "2611:   }",
          "",
          "[Removed Lines]",
          "2608:    eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2611:    bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2615:    RTrieState *s;",
          "2616:    r_list_foreach (states, it, s) {",
          "2617:     if (s->node == next->node) {",
          "2619:      R_FREE (next);",
          "2620:      goto beach;",
          "2621:     }",
          "",
          "[Removed Lines]",
          "2618:      eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2621:      bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
          "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "109: struct MACH0_(opts_t) {",
          "110:  bool verbose;",
          "111:  ut64 header_at;",
          "112: };",
          "114: struct MACH0_(obj_t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112:  ut64 symbols_off;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170:  int func_size;",
          "171:  bool verbose;",
          "172:  ut64 header_at;",
          "173:  void *user;",
          "174:  ut64 (*va2pa)(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf);",
          "175:  struct symbol_t *symbols;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174:  ut64 symbols_off;",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0_specs.h||libr/bin/format/mach0/mach0_specs.h": [
          "File: libr/bin/format/mach0/mach0_specs.h -> libr/bin/format/mach0/mach0_specs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:  uint32_t nlistCount;",
          "322: } cache_locsym_entry_t;",
          "324: typedef struct {",
          "325:  uint64_t address;",
          "326:  uint64_t size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "324: typedef struct {",
          "325:  uint64_t dylibOffset;",
          "326:  uint32_t nlistStartIndex;",
          "327:  uint32_t nlistCount;",
          "328: } cache_locsym_entry_large_t;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "332:  uint32_t initProt;",
          "333: } cache_mapping_slide;",
          "335: #define DYLD_CACHE_SLIDE_PAGE_ATTRS 0xC000",
          "336: #define DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA 0x8000",
          "337: #define DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE 0x4000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341: typedef struct {",
          "342:  uint64_t sel_string_base;",
          "343: } objc_cache_opt_info;",
          "",
          "---------------"
        ],
        "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c": [
          "File: libr/bin/format/objc/mach0_classes.c -> libr/bin/format/objc/mach0_classes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: static void copy_sym_name_with_namespace(char *class_name, char *read_name, RBinSymbol *sym);",
          "109: static void get_ivar_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass);",
          "110: static void get_objc_property_list(mach0_ut p, RBinFile *bf, RBinClass *klass);",
          "115: static bool read_ptr_pa(RBinFile *bf, ut64 paddr, mach0_ut *out);",
          "116: static bool read_ptr_va(RBinFile *bf, ut64 vaddr, mach0_ut *out);",
          "117: static char *read_str(RBinFile *bf, mach0_ut p, ut32 *offset, ut32 *left);",
          "",
          "[Removed Lines]",
          "111: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static);",
          "112: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass);",
          "113: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass);",
          "114: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs);",
          "",
          "[Added Lines]",
          "111: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static, objc_cache_opt_info *oi);",
          "112: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass, objc_cache_opt_info *oi);",
          "113: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass, objc_cache_opt_info *oi);",
          "114: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs, objc_cache_opt_info *oi);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "515: }",
          "519:  struct MACH0_(SMethodList) ml;",
          "520:  mach0_ut r;",
          "521:  ut32 offset, left, i;",
          "",
          "[Removed Lines]",
          "518: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static) {",
          "",
          "[Added Lines]",
          "518: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "613:    m.imp = r_read_ble (&sm[2 * sizeof (mach0_ut)], bigendian, 8 * sizeof (mach0_ut));",
          "614:   } else {",
          "615:    st64 name_offset = (st32) r_read_ble (&sm[0], bigendian, 8 * sizeof (ut32));",
          "617:    if (mlflags != METHOD_LIST_FLAG_IS_PREOPT) {",
          "618:     r = va2pa (name, &offset, &left, bf);",
          "619:     if (!r) {",
          "",
          "[Removed Lines]",
          "616:    mach0_ut name = p + name_offset;",
          "",
          "[Added Lines]",
          "616:    mach0_ut name;",
          "617:    if (oi && oi->sel_string_base) {",
          "618:     name = oi->sel_string_base + name_offset;",
          "619:    } else {",
          "620:     name = p + name_offset;",
          "621:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "715: }",
          "719:  struct MACH0_(SProtocolList) pl = { 0 };",
          "720:  struct MACH0_(SProtocol) pc;",
          "721:  char *class_name = NULL;",
          "",
          "[Removed Lines]",
          "718: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass) {",
          "",
          "[Added Lines]",
          "723: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "852:   }",
          "854:   if (pc.instanceMethods > 0) {",
          "856:   }",
          "857:   if (pc.classMethods > 0) {",
          "859:   }",
          "860:   R_FREE (class_name);",
          "861:   p += sizeof (ut32);",
          "",
          "[Removed Lines]",
          "855:    get_method_list_t (pc.instanceMethods, bf, class_name, klass, false);",
          "858:    get_method_list_t (pc.classMethods, bf, class_name, klass, true);",
          "",
          "[Added Lines]",
          "860:    get_method_list_t (pc.instanceMethods, bf, class_name, klass, false, oi);",
          "863:    get_method_list_t (pc.classMethods, bf, class_name, klass, true, oi);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1004: }",
          "1008:  struct MACH0_(obj_t) *bin;",
          "1009:  struct MACH0_(SClassRoT) cro = { 0 };",
          "1010:  ut32 offset, left, i;",
          "",
          "[Removed Lines]",
          "1007: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass) {",
          "",
          "[Added Lines]",
          "1012: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1102: #endif",
          "1104:  if (cro.baseMethods > 0) {",
          "1106:  }",
          "1108:  if (cro.baseProtocols > 0) {",
          "1110:  }",
          "1112:  if (cro.ivars > 0) {",
          "",
          "[Removed Lines]",
          "1105:   get_method_list_t (cro.baseMethods, bf, klass->name, klass, (cro.flags & RO_META) ? true : false);",
          "1109:   get_protocol_list_t (cro.baseProtocols, bf, klass);",
          "",
          "[Added Lines]",
          "1110:   get_method_list_t (cro.baseMethods, bf, klass->name, klass, (cro.flags & RO_META) ? true : false, oi);",
          "1114:   get_protocol_list_t (cro.baseProtocols, bf, klass, oi);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1127:  return 0;",
          "1128: }",
          "1131:  struct MACH0_(SClass) c = { 0 };",
          "1132:  const int size = sizeof (struct MACH0_(SClass));",
          "1133:  mach0_ut r = 0;",
          "",
          "[Removed Lines]",
          "1130: void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1135: void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1191:    }",
          "1192:   }",
          "1193:  }",
          "1196: #if SWIFT_SUPPORT",
          "1197:  if (q (c.data + n_value) & 7) {",
          "",
          "[Removed Lines]",
          "1194:  get_class_ro_t (RO_DATA_PTR (c.data), bf, &is_meta_class, klass);",
          "",
          "[Added Lines]",
          "1199:  get_class_ro_t (RO_DATA_PTR (c.data), bf, &is_meta_class, klass, oi);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1201:  if (!is_meta_class && !dupe) {",
          "1202:   mach0_ut isa_n_value = get_isa_value ();",
          "1203:   ut64 tmp = klass->addr;",
          "1205:   klass->addr = tmp;",
          "1206:  }",
          "1207: }",
          "",
          "[Removed Lines]",
          "1204:   MACH0_(get_class_t) (c.isa + isa_n_value, bf, klass, true, relocs);",
          "",
          "[Added Lines]",
          "1209:   MACH0_(get_class_t) (c.isa + isa_n_value, bf, klass, true, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1242: }",
          "1243: #endif",
          "1246:  RList /*<RBinClass>*/ *ret = NULL;",
          "1247:  ut64 num_of_unnamed_class = 0;",
          "1248:  RBinClass *klass = NULL;",
          "",
          "[Removed Lines]",
          "1245: RList *MACH0_(parse_classes)(RBinFile *bf) {",
          "",
          "[Added Lines]",
          "1250: RList *MACH0_(parse_classes)(RBinFile *bf, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1267:  RSkipList *relocs = MACH0_(get_relocs) (bf->o->bin_obj);",
          "",
          "[Removed Lines]",
          "1269:  ret = MACH0_(parse_categories) (bf, relocs);",
          "",
          "[Added Lines]",
          "1274:  ret = MACH0_(parse_categories) (bf, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1336:    goto get_classes_error;",
          "1337:   }",
          "1338:   p = r_read_ble (&pp[0], bigendian, 8 * sizeof (mach0_ut));",
          "1340:   if (!klass->name) {",
          "1341:    klass->name = r_str_newf (\"UnnamedClass%\" PFMT64d, num_of_unnamed_class);",
          "1342:    if (!klass->name) {",
          "",
          "[Removed Lines]",
          "1339:   MACH0_(get_class_t) (p, bf, klass, false, relocs);",
          "",
          "[Added Lines]",
          "1344:   MACH0_(get_class_t) (p, bf, klass, false, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1357:  return NULL;",
          "1358: }",
          "1361:  r_return_val_if_fail (bf && bf->o && bf->o->bin_obj && bf->o->info, NULL);",
          "1363:  RList /*<RBinClass>*/ *ret = NULL;",
          "",
          "[Removed Lines]",
          "1360: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1365: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1419:    R_FREE (klass);",
          "1420:    goto error;",
          "1421:   }",
          "1423:   if (!klass->name) {",
          "1424:    R_FREE (klass);",
          "1425:    continue;",
          "",
          "[Removed Lines]",
          "1422:   MACH0_(get_category_t) (p, bf, klass, relocs);",
          "",
          "[Added Lines]",
          "1427:   MACH0_(get_category_t) (p, bf, klass, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1433:  return NULL;",
          "1434: }",
          "1437:  r_return_if_fail (bf && bf->o && bf->o->info);",
          "1439:  struct MACH0_(SCategory) c = { 0 };",
          "",
          "[Removed Lines]",
          "1436: void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1441: void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1542:  R_FREE (category_name);",
          "1544:  if (c.instanceMethods > 0) {",
          "1546:  }",
          "1548:  if (c.classMethods > 0) {",
          "1550:  }",
          "1552:  if (c.protocols > 0) {",
          "1554:  }",
          "1556:  if (c.properties > 0) {",
          "",
          "[Removed Lines]",
          "1545:   get_method_list_t (c.instanceMethods, bf, klass->name, klass, false);",
          "1549:   get_method_list_t (c.classMethods, bf, klass->name, klass, true);",
          "1553:   get_protocol_list_t (c.protocols, bf, klass);",
          "",
          "[Added Lines]",
          "1550:   get_method_list_t (c.instanceMethods, bf, klass->name, klass, false, oi);",
          "1554:   get_method_list_t (c.classMethods, bf, klass->name, klass, true, oi);",
          "1558:   get_protocol_list_t (c.protocols, bf, klass, oi);",
          "",
          "---------------"
        ],
        "libr/bin/format/objc/mach0_classes.h||libr/bin/format/objc/mach0_classes.h": [
          "File: libr/bin/format/objc/mach0_classes.h -> libr/bin/format/objc/mach0_classes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #ifndef MACH0_CLASSES_H",
          "18: #define MACH0_CLASSES_H",
          "24: #endif // MACH0_CLASSES_H",
          "",
          "[Removed Lines]",
          "20: R_API RList *MACH0_(parse_classes)(RBinFile *bf);",
          "21: R_API void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs);",
          "22: R_API void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs);",
          "",
          "[Added Lines]",
          "20: R_API RList *MACH0_(parse_classes)(RBinFile *bf, objc_cache_opt_info *oi);",
          "21: R_API void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs, objc_cache_opt_info *oi);",
          "22: R_API void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs, objc_cache_opt_info *oi);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c": [
          "File: libr/bin/p/bin_dyldcache.c -> libr/bin/p/bin_dyldcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include \"objc/mach0_classes.h\"",
          "15: #define R_IS_PTR_AUTHENTICATED(x) B_IS_SET(x, 63)",
          "17: typedef struct {",
          "18:  ut8 version;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #define MAX_N_HDR 16",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: } RDyldRebaseInfo1;",
          "77: typedef struct {",
          "81:  ut64 nlists_count;",
          "84: } RDyldLocSym;",
          "86: typedef struct _r_dyldcache {",
          "87:  ut8 magic[8];",
          "88:  RList *bins;",
          "89:  RBuffer *buf;",
          "90:  int (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);",
          "91:  RDyldRebaseInfos *rebase_infos;",
          "94:  cache_accel_t *accel;",
          "95:  RDyldLocSym *locsym;",
          "96: } RDyldCache;",
          "98: typedef struct _r_bin_image {",
          "99:  char *file;",
          "100:  ut64 header_at;",
          "101: } RDyldBinImage;",
          "103: static RList * pending_bin_files = NULL;",
          "107: static void free_bin(RDyldBinImage *bin) {",
          "108:  if (!bin) {",
          "",
          "[Removed Lines]",
          "78:  char *strings;",
          "79:  ut64 strings_size;",
          "80:  struct MACH0_(nlist) *nlists;",
          "82:  cache_locsym_entry_t *entries;",
          "83:  ut64 entries_count;",
          "92:  cache_hdr_t *hdr;",
          "93:  cache_map_t *maps;",
          "105: static ut64 va2pa(uint64_t addr, cache_hdr_t *hdr, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left);",
          "",
          "[Added Lines]",
          "79:  ut64 local_symbols_offset;",
          "80:  ut64 nlists_offset;",
          "82:  ut64 strings_offset;",
          "83:  ut64 strings_size;",
          "89:  cache_hdr_t *hdr;",
          "90:  ut64 *hdr_offset;",
          "91:  ut64 symbols_off_base;",
          "92:  ut32 *maps_index;",
          "93:  ut32 n_hdr;",
          "94:  cache_map_t *maps;",
          "95:  ut32 n_maps;",
          "103:  objc_cache_opt_info *oi;",
          "104:  bool objc_opt_info_loaded;",
          "110:  ut64 hdr_offset;",
          "111:  ut64 symbols_off;",
          "112:  ut64 va;",
          "113:  ut32 nlist_start_index;",
          "114:  ut32 nlist_count;",
          "119: static ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "162:  }",
          "163: }",
          "167:   return NULL;",
          "168:  }",
          "182:  }",
          "192:  }",
          "201:  }",
          "207:  }",
          "211:  }",
          "216:  }",
          "242:  }",
          "247: }",
          "249: static ut64 rebase_infos_get_slide(RDyldCache *cache) {",
          "",
          "[Removed Lines]",
          "165: static RDyldLocSym *r_dyld_locsym_new(RBuffer *cache_buf, cache_hdr_t *hdr) {",
          "166:  if (!cache_buf || !hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {",
          "170:  cache_locsym_info_t *info = NULL;",
          "171:  char *strings = NULL;",
          "172:  cache_locsym_entry_t *entries = NULL;",
          "173:  struct MACH0_(nlist) *nlists = NULL;",
          "175:  ut64 info_size = sizeof (cache_locsym_info_t);",
          "176:  info = R_NEW0 (cache_locsym_info_t);",
          "177:  if (!info) {",
          "178:   goto beach;",
          "179:  }",
          "180:  if (r_buf_fread_at (cache_buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {",
          "181:   goto beach;",
          "184:  ut64 nlists_size = sizeof (struct MACH0_(nlist)) * info->nlistCount;",
          "185:  nlists = R_NEWS0 (struct MACH0_(nlist), info->nlistCount);",
          "186:  if (!nlists) {",
          "187:   goto beach;",
          "188:  }",
          "189:  if (r_buf_fread_at (cache_buf, hdr->localSymbolsOffset + info->nlistOffset, (ut8*) nlists, \"iccsl\",",
          "190:    info->nlistCount) != nlists_size) {",
          "191:   goto beach;",
          "194:  strings = malloc (info->stringsSize);",
          "195:  if (!strings) {",
          "196:   goto beach;",
          "197:  }",
          "198:  if (r_buf_read_at (cache_buf, hdr->localSymbolsOffset + info->stringsOffset, (ut8*) strings,",
          "199:    info->stringsSize) != info->stringsSize) {",
          "200:   goto beach;",
          "203:  ut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;",
          "204:  entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);",
          "205:  if (!entries) {",
          "206:   goto beach;",
          "208:  if (r_buf_fread_at (cache_buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) entries, \"3i\",",
          "209:    info->entriesCount) != entries_size) {",
          "210:   goto beach;",
          "213:  RDyldLocSym * locsym = R_NEW0 (RDyldLocSym);",
          "214:  if (!locsym) {",
          "215:   goto beach;",
          "218:  locsym->nlists = nlists;",
          "219:  locsym->nlists_count = info->nlistCount;",
          "220:  locsym->strings = strings;",
          "221:  locsym->strings_size = info->stringsSize;",
          "222:  locsym->entries = entries;",
          "223:  locsym->entries_count = info->entriesCount;",
          "225:  free (info);",
          "227:  return locsym;",
          "229: beach:",
          "230:  free (info);",
          "231:  free (strings);",
          "232:  free (entries);",
          "233:  free (nlists);",
          "235:  eprintf (\"dyldcache: malformed local symbols metadata\\n\");",
          "236:  return NULL;",
          "237: }",
          "239: static void r_dyld_locsym_free(RDyldLocSym *locsym) {",
          "240:  if (!locsym) {",
          "241:   return;",
          "243:  R_FREE (locsym->strings);",
          "244:  R_FREE (locsym->entries);",
          "245:  R_FREE (locsym->nlists);",
          "246:  free (locsym);",
          "",
          "[Added Lines]",
          "179: static cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {",
          "180:  if (!cache_buf || !hdr) {",
          "183:  if (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {",
          "184:   return NULL;",
          "187:  ut64 size = sizeof (cache_img_t) * hdr->imagesCount;",
          "188:  cache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);",
          "189:  if (!images) {",
          "190:   return NULL;",
          "193:  if (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {",
          "194:   R_FREE (images);",
          "195:   return NULL;",
          "198:  if (hdr_offset) {",
          "199:   ut32 i;",
          "200:   for (i = 0; i < hdr->imagesCount; i++) {",
          "201:    cache_img_t *img = &images[i];",
          "202:    img->pathFileOffset += hdr_offset;",
          "203:   }",
          "206:  return images;",
          "207: }",
          "209: static void match_bin_entries(RDyldCache *cache, void *entries) {",
          "210:  r_return_if_fail (cache && cache->bins && entries);",
          "212:  cache_img_t *imgs = read_cache_images (cache->buf, cache->hdr, 0);",
          "213:  if (!imgs) {",
          "214:   return;",
          "217:  RDyldBinImage *bin = NULL;",
          "218:  RListIter *it = r_list_iterator (cache->bins);",
          "220:  bool has_large_entries = cache->n_hdr > 1;",
          "222:  ut32 i;",
          "223:  for (i = 0; i < cache->hdr->imagesCount; i++) {",
          "224:   cache_img_t *img = &imgs[i];",
          "225:   if (!it) {",
          "226:    break;",
          "227:   }",
          "228:   bin = it->data;",
          "229:   if (!bin) {",
          "230:    break;",
          "231:   }",
          "232:   if (bin && bin->va == img->address) {",
          "233:    if (has_large_entries) {",
          "234:     cache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *) entries)[i];",
          "235:     bin->nlist_start_index = e->nlistStartIndex;",
          "236:     bin->nlist_count = e->nlistCount;",
          "237:    } else {",
          "238:     cache_locsym_entry_t *e = &((cache_locsym_entry_t *) entries)[i];",
          "239:     bin->nlist_start_index = e->nlistStartIndex;",
          "240:     bin->nlist_count = e->nlistCount;",
          "241:    }",
          "242:    it = it->n;",
          "243:   }",
          "246:  R_FREE (imgs);",
          "247: }",
          "249: static RDyldLocSym *r_dyld_locsym_new(RDyldCache *cache) {",
          "250:  r_return_val_if_fail (cache && cache->buf, NULL);",
          "252:  ut32 i;",
          "253:  for (i = 0; i < cache->n_hdr; i++) {",
          "254:   cache_hdr_t *hdr = &cache->hdr[i];",
          "255:   if (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {",
          "256:    continue;",
          "257:   }",
          "259:   cache_locsym_info_t *info = NULL;",
          "260:   void *entries = NULL;",
          "262:   ut64 info_size = sizeof (cache_locsym_info_t);",
          "263:   info = R_NEW0 (cache_locsym_info_t);",
          "264:   if (!info) {",
          "265:    goto beach;",
          "266:   }",
          "267:   if (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {",
          "268:    eprintf (\"locsym err 01\\n\");",
          "269:    goto beach;",
          "270:   }",
          "271:   if (info->entriesCount != cache->hdr->imagesCount) {",
          "272:    eprintf (\"locsym err 02\\n\");",
          "273:    goto beach;",
          "274:   }",
          "276:   bool has_large_entries = cache->n_hdr > 1;",
          "277:   if (has_large_entries) {",
          "278:    ut64 entries_size = sizeof (cache_locsym_entry_large_t) * info->entriesCount;",
          "279:    cache_locsym_entry_large_t *large_entries = R_NEWS0 (cache_locsym_entry_large_t, info->entriesCount);",
          "280:    if (!large_entries) {",
          "281:     goto beach;",
          "282:    }",
          "283:    if (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) large_entries, \"lii\",",
          "284:      info->entriesCount) != entries_size) {",
          "285:     eprintf (\"locsym err 03\\n\");",
          "286:     goto beach;",
          "287:    }",
          "288:    entries = large_entries;",
          "289:   } else {",
          "290:    ut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;",
          "291:    cache_locsym_entry_t *regular_entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);",
          "292:    if (!regular_entries) {",
          "293:     goto beach;",
          "294:    }",
          "295:    if (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) regular_entries, \"iii\",",
          "296:      info->entriesCount) != entries_size) {",
          "297:     eprintf (\"locsym err 04\\n\");",
          "298:     goto beach;",
          "299:    }",
          "300:    entries = regular_entries;",
          "301:   }",
          "302:   RDyldLocSym * locsym = R_NEW0 (RDyldLocSym);",
          "303:   if (!locsym) {",
          "304:    goto beach;",
          "305:   }",
          "307:   match_bin_entries (cache, entries);",
          "309:   locsym->local_symbols_offset = hdr->localSymbolsOffset;",
          "310:   locsym->nlists_offset = info->nlistOffset;",
          "311:   locsym->nlists_count = info->nlistCount;",
          "312:   locsym->strings_offset = info->stringsOffset;",
          "313:   locsym->strings_size = info->stringsSize;",
          "315:   free (info);",
          "316:   free (entries);",
          "318:   return locsym;",
          "320: beach:",
          "321:   free (info);",
          "322:   free (entries);",
          "324:   eprintf (\"dyldcache: malformed local symbols metadata\\n\");",
          "325:   break;",
          "327:  return NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "261:  return 0;",
          "262: }",
          "265:  RDyldLocSym *locsym = cache->locsym;",
          "267:   return;",
          "268:  }",
          "274:    continue;",
          "275:   }",
          "280:    break;",
          "281:   }",
          "318:   }",
          "320:  }",
          "321: }",
          "323: static void r_dyldcache_free(RDyldCache *cache) {",
          "",
          "[Removed Lines]",
          "264: static void r_dyld_locsym_entries_by_offset(RDyldCache *cache, RList *symbols, SetU *hash, ut64 bin_header_offset) {",
          "266:  if (!locsym || !locsym->entries) {",
          "270:  ut64 i;",
          "271:  for (i = 0; i != locsym->entries_count; i++) {",
          "272:   cache_locsym_entry_t *entry = &locsym->entries[i];",
          "273:   if (entry->dylibOffset != bin_header_offset) {",
          "277:   if (entry->nlistStartIndex >= locsym->nlists_count ||",
          "278:     entry->nlistStartIndex + entry->nlistCount > locsym->nlists_count) {",
          "279:    eprintf (\"dyldcache: malformed local symbol entry\\n\");",
          "283:   ut32 j;",
          "284:   for (j = 0; j != entry->nlistCount; j++) {",
          "285:    struct MACH0_(nlist) *nlist = &locsym->nlists[j + entry->nlistStartIndex];",
          "286:    if (set_u_contains (hash, (ut64)nlist->n_value)) {",
          "287:     continue;",
          "288:    }",
          "289:    set_u_add (hash, (ut64)nlist->n_value);",
          "290:    if (nlist->n_strx >= locsym->strings_size) {",
          "291:     continue;",
          "292:    }",
          "293:    char *symstr = &locsym->strings[nlist->n_strx];",
          "294:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "295:    if (!sym) {",
          "296:     return;",
          "297:    }",
          "298:    sym->type = \"LOCAL\";",
          "299:    sym->vaddr = nlist->n_value;",
          "300:    ut64 slide = rebase_infos_get_slide (cache);",
          "301:    sym->paddr = va2pa (nlist->n_value, cache->hdr, cache->maps, cache->buf, slide, NULL, NULL);",
          "303:    int len = locsym->strings_size - nlist->n_strx;",
          "304:    ut32 k;",
          "305:    for (k = 0; k < len; k++) {",
          "306:     if (((ut8) symstr[k] & 0xff) == 0xff || !symstr[k]) {",
          "307:      len = k;",
          "308:      break;",
          "309:     }",
          "310:    }",
          "311:    if (len > 0) {",
          "312:     sym->name = r_str_ndup (symstr, len);",
          "313:    } else {",
          "314:     sym->name = r_str_newf (\"unk_local%d\", k);",
          "315:    }",
          "317:    r_list_append (symbols, sym);",
          "319:   break;",
          "",
          "[Added Lines]",
          "345: static void symbols_from_locsym(RDyldCache *cache, RDyldBinImage *bin, RList *symbols, SetU *hash) {",
          "347:  if (!locsym) {",
          "348:   return;",
          "349:  }",
          "351:  if (bin->nlist_start_index >= locsym->nlists_count ||",
          "352:    bin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {",
          "353:   eprintf (\"dyldcache: malformed local symbol entry\\n\");",
          "357:  ut64 nlists_size = sizeof (struct MACH0_(nlist)) * bin->nlist_count;",
          "358:  struct MACH0_(nlist) *nlists = R_NEWS0 (struct MACH0_(nlist), bin->nlist_count);",
          "359:  if (!nlists) {",
          "360:   return;",
          "361:  }",
          "362:  ut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +",
          "363:   bin->nlist_start_index * sizeof (struct MACH0_(nlist));",
          "364:  if (r_buf_fread_at (cache->buf, nlists_offset, (ut8*) nlists, \"iccsl\", bin->nlist_count) != nlists_size) {",
          "365:   free (nlists);",
          "366:   return;",
          "367:  }",
          "369:  ut32 j;",
          "370:  for (j = 0; j != bin->nlist_count; j++) {",
          "371:   struct MACH0_(nlist) *nlist = &nlists[j];",
          "372:   if (set_u_contains (hash, (ut64)nlist->n_value)) {",
          "375:   set_u_add (hash, (ut64)nlist->n_value);",
          "376:   if (nlist->n_strx >= locsym->strings_size) {",
          "377:    continue;",
          "378:   }",
          "379:   RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "380:   if (!sym) {",
          "383:   sym->type = \"LOCAL\";",
          "384:   sym->vaddr = nlist->n_value;",
          "385:   ut64 slide = rebase_infos_get_slide (cache);",
          "386:   sym->paddr = va2pa (nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "388:   char *symstr =r_buf_get_string (cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);",
          "389:   if (symstr) {",
          "390:    sym->name = symstr;",
          "391:   } else {",
          "392:    static ut32 k = 0;",
          "393:    sym->name = r_str_newf (\"unk_local%d\", k++);",
          "396:   r_list_append (symbols, sym);",
          "399:  free (nlists);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "340:  }",
          "341:  R_FREE (cache->hdr);",
          "342:  R_FREE (cache->maps);",
          "343:  R_FREE (cache->accel);",
          "345:  R_FREE (cache);",
          "346: }",
          "349:  ut64 res = UT64_MAX;",
          "352:  addr -= slide;",
          "355:   if (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {",
          "356:    res = maps[i].fileOffset + addr - maps[i].address;",
          "357:    if (offset) {",
          "",
          "[Removed Lines]",
          "344:  r_dyld_locsym_free (cache->locsym);",
          "348: static ut64 va2pa(uint64_t addr, cache_hdr_t *hdr, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {",
          "350:  uint32_t i;",
          "354:  for (i = 0; i < hdr->mappingCount; i++) {",
          "",
          "[Added Lines]",
          "422:  R_FREE (cache->maps_index);",
          "423:  R_FREE (cache->hdr_offset);",
          "425:  R_FREE (cache->locsym);",
          "426:  R_FREE (cache->oi);",
          "430: static ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {",
          "432:  ut32 i;",
          "436:  for (i = 0; i < n_maps; i++) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "378:  }",
          "380:  ut64 slide = rebase_infos_get_slide (cache);",
          "382:  if (res == UT64_MAX) {",
          "383:   res = 0;",
          "384:  }",
          "",
          "[Removed Lines]",
          "381:  ut64 res = va2pa (p, cache->hdr, cache->maps, cache->buf, slide, offset, left);",
          "",
          "[Added Lines]",
          "463:  ut64 res = va2pa (p, cache->n_maps, cache->maps, cache->buf, slide, offset, left);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "395:   return NULL;",
          "396:  }",
          "398:  struct MACH0_(opts_t) opts;",
          "399:  MACH0_(opts_set_default) (&opts, bf);",
          "402:  mach0->user = cache;",
          "403:  mach0->va2pa = &bin_obj_va2pa;",
          "404:  return mach0;",
          "405: }",
          "",
          "[Removed Lines]",
          "400:  opts.header_at = bin->header_at;",
          "401:  struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);",
          "",
          "[Added Lines]",
          "480:  RBuffer *buf = r_buf_new_slice (cache->buf, bin->hdr_offset, r_buf_size (cache->buf) - bin->hdr_offset);",
          "481:  if (!buf) {",
          "482:   return NULL;",
          "483:  }",
          "487:  opts.header_at = bin->header_at - bin->hdr_offset;",
          "488:  opts.symbols_off = bin->symbols_off;",
          "490:  struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);",
          "495:  r_buf_free (buf);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "442: static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {",
          "443:  ut64 slide = 0;",
          "444:  ut64 *classlist = malloc (64);",
          "445:  if (!classlist) {",
          "446:   goto beach;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "537:  if (cache->n_hdr > 1) {",
          "538:   return slide;",
          "539:  }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "492:   int classlist_sample_size = R_MIN (64, sections[classlist_idx].size);",
          "493:   int n_classes = classlist_sample_size / 8;",
          "496:    goto next_bin;",
          "497:   }",
          "",
          "[Removed Lines]",
          "495:   if (r_buf_fread_at (cache->buf, sections[classlist_idx].offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {",
          "",
          "[Added Lines]",
          "590:   ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;",
          "592:   if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "752: }",
          "754: static RDyldRebaseInfos *get_rebase_infos(RBinFile *bf, RDyldCache *cache) {",
          "757:  RDyldRebaseInfos *result = R_NEW0 (RDyldRebaseInfos);",
          "758:  if (!result) {",
          "759:   return NULL;",
          "760:  }",
          "762:  if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {",
          "770:   }",
          "772:    goto beach;",
          "773:   }",
          "776:   if (!infos) {",
          "777:    goto beach;",
          "778:   }",
          "788:    }",
          "797:    }",
          "798:   }",
          "801:    free (infos);",
          "802:    goto beach;",
          "803:   }",
          "807:    if (!pruned_infos) {",
          "808:     free (infos);",
          "809:     goto beach;",
          "810:    }",
          "813:    free (infos);",
          "814:    infos = pruned_infos;",
          "815:   }",
          "817:   result->entries = infos;",
          "819:   return result;",
          "820:  }",
          "",
          "[Removed Lines]",
          "755:  RBuffer *cache_buf = cache->buf;",
          "763:   ut64 slide_infos_offset;",
          "764:   size_t n_slide_infos;",
          "765:   if ((slide_infos_offset = r_buf_read_le32_at (cache_buf, 0x138)) == UT32_MAX) {",
          "766:    goto beach;",
          "767:   }",
          "768:   if ((n_slide_infos = r_buf_read_le32_at (cache_buf, 0x13c)) == UT32_MAX) {",
          "769:    goto beach;",
          "771:   if (!n_slide_infos) {",
          "775:   RDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, n_slide_infos);",
          "780:   size_t i, j;",
          "781:   RDyldRebaseInfo *prev_info = NULL;",
          "782:   for (i = 0, j = 0; i < n_slide_infos; i++) {",
          "783:    ut64 offset = slide_infos_offset + i * sizeof (cache_mapping_slide);",
          "784:    cache_mapping_slide entry;",
          "785:    if (r_buf_fread_at (cache_buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {",
          "786:     free (infos);",
          "787:     goto beach;",
          "790:    if (entry.slideInfoOffset && entry.slideInfoSize) {",
          "791:     infos[j].start = entry.fileOffset;",
          "792:     infos[j].end = entry.fileOffset + entry.size;",
          "793:     ut64 slide = prev_info ? prev_info->slide : UT64_MAX;",
          "794:     infos[j].info = get_rebase_info (bf, cache, entry.slideInfoOffset, entry.slideInfoSize, entry.fileOffset, slide);",
          "795:     prev_info = infos[j].info;",
          "796:     j++;",
          "800:   if (!j) {",
          "805:   if (j != n_slide_infos) {",
          "806:    RDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, j);",
          "812:    memcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * j);",
          "818:   result->length = j;",
          "",
          "[Added Lines]",
          "858:   ut32 total_slide_infos = 0;",
          "859:   ut32 n_slide_infos[MAX_N_HDR];",
          "861:   ut32 i;",
          "862:   for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {",
          "863:    ut64 hdr_offset = cache->hdr_offset[i];",
          "864:    if ((n_slide_infos[i] = r_buf_read_le32_at (cache->buf, 0x13c + hdr_offset)) == UT32_MAX) {",
          "865:     goto beach;",
          "866:    }",
          "867:    total_slide_infos += n_slide_infos[i];",
          "870:   if (!total_slide_infos) {",
          "874:   RDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, total_slide_infos);",
          "879:   ut32 k = 0;",
          "880:   for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {",
          "881:    ut64 hdr_offset = cache->hdr_offset[i];",
          "882:    ut64 slide_infos_offset;",
          "883:    if (!n_slide_infos[i]) {",
          "884:     continue;",
          "886:    if ((slide_infos_offset = r_buf_read_le32_at (cache->buf, 0x138 + hdr_offset)) == UT32_MAX) {",
          "887:     continue;",
          "888:    }",
          "889:    if (!slide_infos_offset) {",
          "890:     continue;",
          "891:    }",
          "892:    slide_infos_offset += hdr_offset;",
          "894:    ut32 j;",
          "895:    RDyldRebaseInfo *prev_info = NULL;",
          "896:    for (j = 0; j < n_slide_infos[i]; j++) {",
          "897:     ut64 offset = slide_infos_offset + j * sizeof (cache_mapping_slide);",
          "898:     cache_mapping_slide entry;",
          "899:     if (r_buf_fread_at (cache->buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {",
          "900:      break;",
          "901:     }",
          "903:     if (entry.slideInfoOffset && entry.slideInfoSize) {",
          "904:      infos[k].start = entry.fileOffset + hdr_offset;",
          "905:      infos[k].end = infos[k].start + entry.size;",
          "906:      ut64 slide = prev_info ? prev_info->slide : UT64_MAX;",
          "907:      infos[k].info = get_rebase_info (bf, cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);",
          "908:      prev_info = infos[k].info;",
          "909:      k++;",
          "910:     }",
          "914:   if (!k) {",
          "919:   if (k < total_slide_infos) {",
          "920:    RDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, k);",
          "926:    memcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * k);",
          "932:   result->length = k;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "839:  return NULL;",
          "840: }",
          "842: static bool check_buffer(RBinFile *bf, RBuffer *buf) {",
          "843:  if (r_buf_size (buf) < 32) {",
          "844:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "956: static bool check_magic(const char *magic) {",
          "957:  return !strcmp (magic, \"dyld_v1   arm64\")",
          "958:   || !strcmp (magic, \"dyld_v1  arm64e\")",
          "959:   || !strcmp (magic, \"dyld_v1  x86_64\")",
          "960:   || !strcmp (magic, \"dyld_v1 x86_64h\");",
          "961: }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "850:   return false;",
          "851:  }",
          "876: }",
          "878: static cache_imgxtr_t *read_cache_imgextra(RBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {",
          "",
          "[Removed Lines]",
          "853:  return !strcmp (hdr, \"dyld_v1   arm64\")",
          "854:   || !strcmp (hdr, \"dyld_v1  arm64e\")",
          "855:   || !strcmp (hdr, \"dyld_v1  x86_64\")",
          "856:   || !strcmp (hdr, \"dyld_v1 x86_64h\");",
          "857: }",
          "859: static cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr) {",
          "860:  if (!cache_buf || !hdr || !hdr->imagesCount || !hdr->imagesOffset) {",
          "861:   return NULL;",
          "862:  }",
          "864:  ut64 size = sizeof (cache_img_t) * hdr->imagesCount;",
          "865:  cache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);",
          "866:  if (!images) {",
          "867:   return NULL;",
          "868:  }",
          "870:  if (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {",
          "871:   R_FREE (images);",
          "872:   return NULL;",
          "873:  }",
          "875:  return images;",
          "",
          "[Added Lines]",
          "974:  return check_magic (hdr);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "929:  return path_to_idx;",
          "930: }",
          "934:  if (pa == UT64_MAX) {",
          "935:   return;",
          "936:  }",
          "937:  struct MACH0_(mach_header) mh;",
          "939:   return;",
          "940:  }",
          "941:  if (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {",
          "",
          "[Removed Lines]",
          "932: static void carve_deps_at_address(RBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr, cache_map_t *maps, HtPU *path_to_idx, ut64 address, int *deps) {",
          "933:  ut64 pa = va2pa (address, hdr, maps, cache_buf, 0, NULL, NULL);",
          "938:  if (r_buf_fread_at (cache_buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {",
          "",
          "[Added Lines]",
          "1031: static void carve_deps_at_address(RDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {",
          "1032:  ut64 pa = va2pa (address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);",
          "1037:  if (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "943:  }",
          "944:  ut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));",
          "945:  ut8 *cmds = malloc (mh.sizeofcmds + 1);",
          "947:   goto beach;",
          "948:  }",
          "949:  cmds[mh.sizeofcmds] = 0;",
          "",
          "[Removed Lines]",
          "946:  if (!cmds || r_buf_read_at (cache_buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {",
          "",
          "[Added Lines]",
          "1045:  if (!cmds || r_buf_read_at (cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "962:    }",
          "963:    const char *key = (const char *) cursor + 24;",
          "964:    size_t dep_index = (size_t)ht_pu_find (path_to_idx, key, &found);",
          "966:     eprintf (\"Warning: alien dep '%s'\\n\", key);",
          "967:     continue;",
          "968:    }",
          "969:    deps[dep_index]++;",
          "971:   }",
          "972:   cursor += cmdsize;",
          "973:  }",
          "",
          "[Removed Lines]",
          "965:    if (!found || dep_index >= hdr->imagesCount) {",
          "970:    eprintf (\"-> %s\\n\", key);",
          "",
          "[Added Lines]",
          "1064:    if (!found || dep_index >= cache->hdr->imagesCount) {",
          "1069:    if (printing) {",
          "1070:     eprintf (\"-> %s\\n\", key);",
          "1071:    }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "976:  free (cmds);",
          "977: }",
          "980:  RList *bins = r_list_newf ((RListFree)free_bin);",
          "981:  if (!bins) {",
          "982:   return NULL;",
          "983:  }",
          "993:  char *target_libs = NULL;",
          "995:  RList *target_lib_names = NULL;",
          "998:  if (target_libs) {",
          "999:   target_lib_names = r_str_split_list (target_libs, \":\", 0);",
          "1000:   if (!target_lib_names) {",
          "1002:   }",
          "1005:   if (!deps) {",
          "1007:   }",
          "1035:    }",
          "1037:     R_FREE (lib_name);",
          "1053:      }",
          "1056:     }",
          "1059:    }",
          "1073:   }",
          "1091:    }",
          "1104:       } else {",
          "1105:        bin->file = strdup (last_slash + 1);",
          "1106:       }",
          "1107:      } else {",
          "1109:      }",
          "1112:     }",
          "1113:    }",
          "1120:   }",
          "1121:  }",
          "1126:   r_list_free (bins);",
          "1135:  }",
          "1136:  R_FREE (deps);",
          "1138:  return bins;",
          "1139: }",
          "",
          "[Removed Lines]",
          "979: static RList *create_cache_bins(RBinFile *bf, RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, cache_accel_t *accel) {",
          "985:  cache_img_t *img = read_cache_images (cache_buf, hdr);",
          "986:  if (!img) {",
          "987:   r_list_free (bins);",
          "988:   return NULL;",
          "989:  }",
          "991:  int i;",
          "992:  int *deps = NULL;",
          "994:  target_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");",
          "996:  ut16 *depArray = NULL;",
          "997:  cache_imgxtr_t *extras = NULL;",
          "1001:    goto error;",
          "1004:   deps = R_NEWS0 (int, hdr->imagesCount);",
          "1006:    goto error;",
          "1009:   HtPU *path_to_idx = NULL;",
          "1010:   if (accel) {",
          "1011:    depArray = R_NEWS0 (ut16, accel->depListCount);",
          "1012:    if (!depArray) {",
          "1013:     goto error;",
          "1014:    }",
          "1016:    if (r_buf_fread_at (cache_buf, accel->depListOffset, (ut8*) depArray, \"s\", accel->depListCount) != accel->depListCount * 2) {",
          "1017:     goto error;",
          "1018:    }",
          "1020:    extras = read_cache_imgextra (cache_buf, hdr, accel);",
          "1021:    if (!extras) {",
          "1022:     goto error;",
          "1023:    }",
          "1024:   } else {",
          "1025:    path_to_idx = create_path_to_index (cache_buf, img, hdr);",
          "1026:   }",
          "1028:   for (i = 0; i < hdr->imagesCount; i++) {",
          "1029:    char *lib_name = get_lib_name (cache_buf, &img[i]);",
          "1030:    if (!lib_name) {",
          "1031:     break;",
          "1032:    }",
          "1033:    if (strstr (lib_name, \"libobjc.A.dylib\")) {",
          "1034:     deps[i]++;",
          "1036:    if (!r_list_find (target_lib_names, lib_name, string_contains)) {",
          "1038:     continue;",
          "1039:    }",
          "1040:    eprintf (\"FILTER: %s\\n\", lib_name);",
          "1041:    R_FREE (lib_name);",
          "1042:    deps[i]++;",
          "1044:    if (extras && depArray) {",
          "1045:     ut32 j;",
          "1046:     for (j = extras[i].dependentsStartArrayIndex; depArray[j] != 0xffff; j++) {",
          "1047:      ut16 dep_index = depArray[j] & 0x7fff;",
          "1048:      deps[dep_index]++;",
          "1050:      char *dep_name = get_lib_name (cache_buf, &img[dep_index]);",
          "1051:      if (!dep_name) {",
          "1052:       break;",
          "1054:      eprintf (\"-> %s\\n\", dep_name);",
          "1055:      free (dep_name);",
          "1057:    } else if (path_to_idx) {",
          "1058:     carve_deps_at_address (cache_buf, img, hdr, maps, path_to_idx, img[i].address, deps);",
          "1060:   }",
          "1062:   ht_pu_free (path_to_idx);",
          "1063:   R_FREE (depArray);",
          "1064:   R_FREE (extras);",
          "1065:   R_FREE (target_libs);",
          "1066:   r_list_free (target_lib_names);",
          "1067:   target_lib_names = NULL;",
          "1068:  }",
          "1070:  for (i = 0; i < hdr->imagesCount; i++) {",
          "1071:   if (deps && !deps[i]) {",
          "1072:    continue;",
          "1074:   ut64 pa = va2pa (img[i].address, hdr, maps, cache_buf, 0, NULL, NULL);",
          "1075:   if (pa == UT64_MAX) {",
          "1076:    continue;",
          "1077:   }",
          "1078:   ut8 magicbytes[4];",
          "1079:   r_buf_read_at (cache_buf, pa, magicbytes, 4);",
          "1080:   int magic = r_read_le32 (magicbytes);",
          "1081:   switch (magic) {",
          "1082:   case MH_MAGIC:",
          "1084:    break;",
          "1085:   case MH_MAGIC_64:",
          "1086:   {",
          "1087:    char file[256];",
          "1088:    RDyldBinImage *bin = R_NEW0 (RDyldBinImage);",
          "1089:    if (!bin) {",
          "1090:     goto error;",
          "1092:    bin->header_at = pa;",
          "1093:    if (r_buf_read_at (cache_buf, img[i].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {",
          "1094:     file[255] = 0;",
          "1095:     char *last_slash = strrchr (file, '/');",
          "1096:     if (last_slash && *last_slash) {",
          "1097:      if (last_slash > file) {",
          "1098:       char *scan = last_slash - 1;",
          "1099:       while (scan > file && *scan != '/') {",
          "1100:        scan--;",
          "1101:       }",
          "1102:       if (*scan == '/') {",
          "1103:        bin->file = strdup (scan + 1);",
          "1108:       bin->file = strdup (last_slash + 1);",
          "1110:     } else {",
          "1111:      bin->file = strdup (file);",
          "1114:    r_list_append (bins, bin);",
          "1115:    break;",
          "1116:   }",
          "1117:   default:",
          "1118:    eprintf (\"Unknown sub-bin\\n\");",
          "1119:    break;",
          "1123:  goto beach;",
          "1124: error:",
          "1125:  if (bins) {",
          "1127:  }",
          "1128:  bins = NULL;",
          "1129: beach:",
          "1130:  R_FREE (depArray);",
          "1131:  R_FREE (extras);",
          "1132:  R_FREE (target_libs);",
          "1133:  if (target_lib_names) {",
          "1134:   r_list_free (target_lib_names);",
          "1137:  R_FREE (img);",
          "",
          "[Added Lines]",
          "1080: static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {",
          "1088:  int *deps = NULL;",
          "1089:  target_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");",
          "1093:    r_list_free (bins);",
          "1094:    return NULL;",
          "1096:   deps = R_NEWS0 (int, cache->hdr->imagesCount);",
          "1098:    r_list_free (bins);",
          "1099:    r_list_free (target_lib_names);",
          "1100:    return NULL;",
          "1102:  }",
          "1104:  ut32 i;",
          "1105:  for (i = 0; i < cache->n_hdr; i++) {",
          "1106:   cache_hdr_t *hdr = &cache->hdr[i];",
          "1107:   ut64 hdr_offset = cache->hdr_offset[i];",
          "1108:   ut64 symbols_off = cache->symbols_off_base - hdr_offset;",
          "1109:   ut32 maps_index = cache->maps_index[i];",
          "1110:   cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);",
          "1111:   if (!img) {",
          "1112:    goto next;",
          "1113:   }",
          "1115:   ut32 j;",
          "1116:   ut16 *depArray = NULL;",
          "1117:   cache_imgxtr_t *extras = NULL;",
          "1118:   if (target_libs) {",
          "1119:    HtPU *path_to_idx = NULL;",
          "1120:    if (cache->accel) {",
          "1121:     depArray = R_NEWS0 (ut16, cache->accel->depListCount);",
          "1122:     if (!depArray) {",
          "1123:      goto next;",
          "1124:     }",
          "1126:     if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {",
          "1127:      goto next;",
          "1128:     }",
          "1130:     extras = read_cache_imgextra (cache->buf, hdr, cache->accel);",
          "1131:     if (!extras) {",
          "1132:      goto next;",
          "1133:     }",
          "1134:    } else {",
          "1135:     path_to_idx = create_path_to_index (cache->buf, img, hdr);",
          "1138:    for (j = 0; j < hdr->imagesCount; j++) {",
          "1139:     bool printing = !deps[j];",
          "1140:     char *lib_name = get_lib_name (cache->buf, &img[j]);",
          "1141:     if (!lib_name) {",
          "1142:      break;",
          "1143:     }",
          "1144:     if (strstr (lib_name, \"libobjc.A.dylib\")) {",
          "1145:      deps[j]++;",
          "1146:     }",
          "1147:     if (!r_list_find (target_lib_names, lib_name, string_contains)) {",
          "1148:      R_FREE (lib_name);",
          "1149:      continue;",
          "1150:     }",
          "1151:     if (printing) {",
          "1152:      eprintf (\"FILTER: %s\\n\", lib_name);",
          "1153:     }",
          "1155:     deps[j]++;",
          "1157:     if (extras && depArray) {",
          "1158:      ut32 k;",
          "1159:      for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {",
          "1160:       ut16 dep_index = depArray[k] & 0x7fff;",
          "1161:       deps[dep_index]++;",
          "1163:       char *dep_name = get_lib_name (cache->buf, &img[dep_index]);",
          "1164:       if (!dep_name) {",
          "1165:        break;",
          "1166:       }",
          "1167:       if (printing) {",
          "1168:        eprintf (\"-> %s\\n\", dep_name);",
          "1169:       }",
          "1170:       free (dep_name);",
          "1172:     } else if (path_to_idx) {",
          "1173:      carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);",
          "1177:    ht_pu_free (path_to_idx);",
          "1178:    R_FREE (depArray);",
          "1179:    R_FREE (extras);",
          "1182:   for (j = 0; j < hdr->imagesCount; j++) {",
          "1183:    if (deps && !deps[j]) {",
          "1184:     continue;",
          "1186:    ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
          "1187:    if (pa == UT64_MAX) {",
          "1188:     continue;",
          "1189:    }",
          "1190:    ut8 magicbytes[4];",
          "1191:    r_buf_read_at (cache->buf, pa, magicbytes, 4);",
          "1192:    int magic = r_read_le32 (magicbytes);",
          "1193:    switch (magic) {",
          "1194:    case MH_MAGIC_64:",
          "1195:    {",
          "1196:     char file[256];",
          "1197:     RDyldBinImage *bin = R_NEW0 (RDyldBinImage);",
          "1198:     if (!bin) {",
          "1199:      goto next;",
          "1200:     }",
          "1201:     bin->header_at = pa;",
          "1202:     bin->hdr_offset = hdr_offset;",
          "1203:     bin->symbols_off = symbols_off;",
          "1204:     bin->va = img[j].address;",
          "1205:     if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {",
          "1206:      file[255] = 0;",
          "1207:      char *last_slash = strrchr (file, '/');",
          "1208:      if (last_slash && *last_slash) {",
          "1209:       if (last_slash > file) {",
          "1210:        char *scan = last_slash - 1;",
          "1211:        while (scan > file && *scan != '/') {",
          "1212:         scan--;",
          "1213:        }",
          "1214:        if (*scan == '/') {",
          "1215:         bin->file = strdup (scan + 1);",
          "1216:        } else {",
          "1217:         bin->file = strdup (last_slash + 1);",
          "1218:        }",
          "1223:       bin->file = strdup (file);",
          "1226:     r_list_append (bins, bin);",
          "1227:     break;",
          "1228:    }",
          "1229:    default:",
          "1230:     eprintf (\"Unknown sub-bin\\n\");",
          "1231:     break;",
          "1234: next:",
          "1235:   R_FREE (depArray);",
          "1236:   R_FREE (extras);",
          "1237:   R_FREE (img);",
          "1239:  if (r_list_empty (bins)) {",
          "1241:   bins = NULL;",
          "1244:  R_FREE (target_libs);",
          "1245:  r_list_free (target_lib_names);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1412:  plugin->read = &dyldcache_io_read;",
          "1413: }",
          "1416:  if (!cache_buf) {",
          "1417:   return NULL;",
          "1418:  }",
          "",
          "[Removed Lines]",
          "1415: static cache_hdr_t *read_cache_header(RBuffer *cache_buf) {",
          "",
          "[Added Lines]",
          "1523: static cache_hdr_t *read_cache_header(RBuffer *cache_buf, ut64 offset) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1423:  }",
          "1425:  ut64 size = sizeof (cache_hdr_t);",
          "1427:   R_FREE (hdr);",
          "1428:   return NULL;",
          "1429:  }",
          "1431:  return hdr;",
          "1432: }",
          "1437:  }",
          "1441:  if (!maps) {",
          "1443:  }",
          "1448:  }",
          "1451: }",
          "1453: static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {",
          "",
          "[Removed Lines]",
          "1426:  if (r_buf_fread_at (cache_buf, 0, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {",
          "1434: static cache_map_t *read_cache_maps(RBuffer *cache_buf, cache_hdr_t *hdr) {",
          "1435:  if (!cache_buf || !hdr || !hdr->mappingCount || !hdr->mappingOffset) {",
          "1436:   return NULL;",
          "1439:  ut64 size = sizeof (cache_map_t) * hdr->mappingCount;",
          "1440:  cache_map_t *maps = R_NEWS0 (cache_map_t, hdr->mappingCount);",
          "1442:   return NULL;",
          "1445:  if (r_buf_fread_at (cache_buf, hdr->mappingOffset, (ut8*) maps, \"3l2i\", hdr->mappingCount) != size) {",
          "1446:   R_FREE (maps);",
          "1447:   return NULL;",
          "1450:  return maps;",
          "",
          "[Added Lines]",
          "1534:  if (r_buf_fread_at (cache_buf, offset, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {",
          "1535:   R_FREE (hdr);",
          "1536:   return NULL;",
          "1537:  }",
          "1538:  if (!check_magic (hdr->magic)) {",
          "1543:  if (!hdr->imagesCount && !hdr->imagesOffset) {",
          "1544:   hdr->imagesOffset = r_buf_read_le32_at (cache_buf, 0x1c0 + offset);",
          "1545:   hdr->imagesCount = r_buf_read_le32_at (cache_buf, 0x1c4 + offset);",
          "1546:  }",
          "1551: static void populate_cache_headers(RDyldCache *cache) {",
          "1552:  cache->n_hdr = 0;",
          "1553:  RList *hdrs = r_list_newf (NULL);",
          "1554:  if (!hdrs) {",
          "1555:   return;",
          "1558:  cache_hdr_t *h;",
          "1559:  ut64 offsets[MAX_N_HDR];",
          "1560:  ut64 offset = 0;",
          "1561:  do {",
          "1562:   offsets[cache->n_hdr] = offset;",
          "1563:   h = read_cache_header (cache->buf, offset);",
          "1564:   if (!h) {",
          "1565:    break;",
          "1566:   }",
          "1567:   r_list_append (hdrs, h);",
          "1569:   ut64 size = h->codeSignatureOffset + h->codeSignatureSize;",
          "1571: #define SHIFT_MAYBE(x) \\",
          "1572:  if (x) { \\",
          "1573:   x += offset; \\",
          "1574:  }",
          "1576:   SHIFT_MAYBE (h->mappingOffset);",
          "1577:   SHIFT_MAYBE (h->imagesOffset);",
          "1578:   SHIFT_MAYBE (h->codeSignatureOffset);",
          "1579:   SHIFT_MAYBE (h->slideInfoOffset);",
          "1580:   SHIFT_MAYBE (h->localSymbolsOffset);",
          "1581:   SHIFT_MAYBE (h->branchPoolsOffset);",
          "1582:   SHIFT_MAYBE (h->imagesTextOffset);",
          "1584:   offset += size;",
          "1585:   cache->n_hdr++;",
          "1586:  } while (cache->n_hdr < MAX_N_HDR);",
          "1588:  if (!cache->n_hdr) {",
          "1589:   goto beach;",
          "1590:  }",
          "1592:  cache->hdr = R_NEWS0 (cache_hdr_t, cache->n_hdr);",
          "1593:  if (!cache->hdr) {",
          "1594:   cache->n_hdr = 0;",
          "1595:   goto beach;",
          "1596:  }",
          "1598:  cache->hdr_offset = R_NEWS0 (ut64, cache->n_hdr);",
          "1599:  if (!cache->hdr_offset) {",
          "1600:   cache->n_hdr = 0;",
          "1601:   R_FREE (cache->hdr);",
          "1602:   goto beach;",
          "1603:  }",
          "1605:  memcpy (cache->hdr_offset, offsets, cache->n_hdr * sizeof (ut64));",
          "1607:  ut32 i = 0;",
          "1608:  RListIter *iter;",
          "1609:  cache_hdr_t *item;",
          "1610:  r_list_foreach (hdrs, iter, item) {",
          "1611:   if (i >= cache->n_hdr) {",
          "1612:    break;",
          "1613:   }",
          "1614:   memcpy (&cache->hdr[i++], item, sizeof (cache_hdr_t));",
          "1615:  }",
          "1617: beach:",
          "1618:  r_list_free (hdrs);",
          "1619: }",
          "1621: static void populate_cache_maps(RDyldCache *cache) {",
          "1622:  r_return_if_fail (cache && cache->buf);",
          "1624:  ut32 i;",
          "1625:  ut32 n_maps = 0;",
          "1626:  for (i = 0; i < cache->n_hdr; i++) {",
          "1627:   cache_hdr_t *hdr = &cache->hdr[i];",
          "1628:   if (!hdr->mappingCount || !hdr->mappingOffset) {",
          "1629:    continue;",
          "1630:   }",
          "1631:   n_maps += hdr->mappingCount;",
          "1632:  }",
          "1634:  cache_map_t *maps = NULL;",
          "1635:  if (n_maps != 0) {",
          "1636:   cache->maps_index = R_NEWS0 (ut32, cache->n_hdr);",
          "1637:   if (!cache->maps_index) {",
          "1638:    return;",
          "1639:   }",
          "1640:   maps = R_NEWS0 (cache_map_t, n_maps);",
          "1641:  }",
          "1643:   cache->maps = NULL;",
          "1644:   cache->n_maps = 0;",
          "1645:   return;",
          "1648:  ut32 next_map = 0;",
          "1649:  ut32 last_idx = UT32_MAX;",
          "1650:  ut64 max_address = 0;",
          "1651:  for (i = 0; i < cache->n_hdr; i++) {",
          "1652:   cache_hdr_t *hdr = &cache->hdr[i];",
          "1653:   cache->maps_index[i] = next_map;",
          "1655:   if (!hdr->mappingCount || !hdr->mappingOffset) {",
          "1656:    continue;",
          "1657:   }",
          "1658:   ut64 size = sizeof (cache_map_t) * hdr->mappingCount;",
          "1659:   if (r_buf_fread_at (cache->buf, hdr->mappingOffset, (ut8*) &maps[next_map], \"3l2i\", hdr->mappingCount) != size) {",
          "1660:    continue;",
          "1661:   }",
          "1662:   ut32 j;",
          "1663:   ut64 hdr_offset = cache->hdr_offset[i];",
          "1664:   for (j = 0; j < hdr->mappingCount; j++) {",
          "1665:    cache_map_t *map = &maps[next_map + j];",
          "1666:    map->fileOffset += hdr_offset;",
          "1667:    if (map->address > max_address) {",
          "1668:     last_idx = i;",
          "1669:     max_address = map->address;",
          "1670:    }",
          "1671:   }",
          "1672:   next_map += hdr->mappingCount;",
          "1675:  cache->maps = maps;",
          "1676:  cache->n_maps = next_map;",
          "1677:  if (last_idx == UT32_MAX) {",
          "1678:   cache->symbols_off_base = 0;",
          "1679:  } else {",
          "1680:   cache->symbols_off_base = cache->hdr_offset[last_idx];",
          "1681:  }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1455:   return NULL;",
          "1456:  }",
          "1459:  if (!offset) {",
          "1460:   return NULL;",
          "1461:  }",
          "",
          "[Removed Lines]",
          "1458:  ut64 offset = va2pa (hdr->accelerateInfoAddr, hdr, maps, cache_buf, 0, NULL, NULL);",
          "",
          "[Added Lines]",
          "1689:  ut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1483:  return accel;",
          "1484: }",
          "1486: static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {",
          "1487:  RDyldCache *cache = R_NEW0 (RDyldCache);",
          "1488:  memcpy (cache->magic, \"dyldcac\", 7);",
          "1489:  cache->buf = r_buf_ref (buf);",
          "1491:  if (!cache->hdr) {",
          "1492:   r_dyldcache_free (cache);",
          "1493:   return false;",
          "1494:  }",
          "1496:  if (!cache->maps) {",
          "1497:   r_dyldcache_free (cache);",
          "1498:   return false;",
          "1499:  }",
          "1500:  cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);",
          "1503:  if (!cache->bins) {",
          "1504:   r_dyldcache_free (cache);",
          "1505:   return false;",
          "1506:  }",
          "1507:  cache->rebase_infos = get_rebase_infos (bf, cache);",
          "1508:  if (cache->rebase_infos) {",
          "1509:   if (!rebase_infos_get_slide (cache)) {",
          "",
          "[Removed Lines]",
          "1490:  cache->hdr = read_cache_header (cache->buf);",
          "1495:  cache->maps = read_cache_maps (cache->buf, cache->hdr);",
          "1501:  cache->locsym = r_dyld_locsym_new (cache->buf, cache->hdr);",
          "1502:  cache->bins = create_cache_bins (bf, cache->buf, cache->hdr, cache->maps, cache->accel);",
          "",
          "[Added Lines]",
          "1717: static objc_cache_opt_info *get_objc_opt_info(RBinFile *bf, RDyldCache *cache) {",
          "1718:  objc_cache_opt_info *result = NULL;",
          "1719:  RListIter *iter;",
          "1720:  RDyldBinImage *bin;",
          "1721:  r_list_foreach (cache->bins, iter, bin) {",
          "1722:   if (strcmp (bin->file, \"lib/libobjc.A.dylib\")) {",
          "1723:    continue;",
          "1724:   }",
          "1726:   struct MACH0_(opts_t) opts;",
          "1727:   opts.verbose = bf->rbin->verbose;",
          "1728:   opts.header_at = bin->header_at;",
          "1730:   struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);",
          "1731:   if (!mach0) {",
          "1732:    goto beach;",
          "1733:   }",
          "1735:   struct section_t *sections = NULL;",
          "1736:   if (!(sections = MACH0_(get_sections) (mach0))) {",
          "1737:    MACH0_(mach0_free) (mach0);",
          "1738:    goto beach;",
          "1739:   }",
          "1741:   int i;",
          "1742:   ut64 scoffs_offset = 0;",
          "1743:   ut64 scoffs_size = 0;",
          "1744:   ut64 slide = rebase_infos_get_slide (cache);",
          "1745:   for (i = 0; !sections[i].last; i++) {",
          "1746:    if (sections[i].size == 0) {",
          "1747:     continue;",
          "1748:    }",
          "1749:    if (strstr (sections[i].name, \"__objc_scoffs\")) {",
          "1750:     scoffs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "1751:     scoffs_size = sections[i].size;",
          "1752:     break;",
          "1753:    }",
          "1754:   }",
          "1756:   MACH0_(mach0_free) (mach0);",
          "1757:   R_FREE (sections);",
          "1759:   if (!scoffs_offset || scoffs_size < 40) {",
          "1760:    break;",
          "1761:   }",
          "1762:   ut64 check = r_buf_read_le64_at (cache->buf, scoffs_offset);",
          "1763:   if (check != 2) {",
          "1764:    break;",
          "1765:   }",
          "1766:   ut64 sel_string_base = r_buf_read_le64_at (cache->buf, scoffs_offset + 8);",
          "1767:   if (sel_string_base == UT64_MAX) {",
          "1768:    break;",
          "1769:   }",
          "1770:   ut64 sel_string_end = r_buf_read_le64_at (cache->buf, scoffs_offset + 16);",
          "1771:   if (sel_string_end == sel_string_base || sel_string_end == UT64_MAX) {",
          "1772:    break;",
          "1773:   }",
          "1774:   result = R_NEW0 (objc_cache_opt_info);",
          "1775:   if (!result) {",
          "1776:    break;",
          "1777:   }",
          "1778:   result->sel_string_base = sel_string_base;",
          "1779:  }",
          "1780: beach:",
          "1781:  return result;",
          "1782: }",
          "1788:  populate_cache_headers (cache);",
          "1793:  populate_cache_maps (cache);",
          "1799:  cache->bins = create_cache_bins (bf, cache);",
          "1804:  cache->locsym = r_dyld_locsym_new (cache);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1581:  return 0x180000000;",
          "1582: }",
          "1585:  struct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);",
          "1586:  if (!mach0) {",
          "1587:   return;",
          "",
          "[Removed Lines]",
          "1584: void symbols_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {",
          "",
          "[Added Lines]",
          "1882: void symbols_from_bin(RDyldCache *cache, RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1594:  }",
          "1595:  int i;",
          "1596:  for (i = 0; !symbols[i].last; i++) {",
          "1598:    continue;",
          "1599:   }",
          "1600:   if (strstr (symbols[i].name, \"<redacted>\")) {",
          "",
          "[Removed Lines]",
          "1597:   if (!symbols[i].name[0] || symbols[i].addr < 100) {",
          "",
          "[Added Lines]",
          "1895:   if (!symbols[i].name || !symbols[i].name[0] || symbols[i].addr < 100) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1639: }",
          "1641: static void sections_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin) {",
          "1642:  struct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);",
          "1643:  if (!mach0) {",
          "1644:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1940:  RDyldCache *cache = (RDyldCache*) bf->o->bin_obj;",
          "1941:  if (!cache) {",
          "1942:   return;",
          "1943:  }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1649:   return;",
          "1650:  }",
          "1652:  int i;",
          "1653:  for (i = 0; !sections[i].last; i++) {",
          "1654:   RBinSection *ptr = R_NEW0 (RBinSection);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1955:  ut64 slide = rebase_infos_get_slide (cache);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1667:   ptr->is_data = __is_data_section (ptr->name);",
          "1668:   ptr->size = sections[i].size;",
          "1669:   ptr->vsize = sections[i].vsize;",
          "1671:   ptr->vaddr = sections[i].addr;",
          "1672:   if (!ptr->vaddr) {",
          "1673:    ptr->vaddr = ptr->paddr;",
          "1674:   }",
          "",
          "[Removed Lines]",
          "1670:   ptr->paddr = sections[i].offset + bf->o->boffset;",
          "",
          "[Added Lines]",
          "1975:   ptr->paddr = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1699:  RBinSection *ptr = NULL;",
          "1700:  int i;",
          "1702:   if (!(ptr = R_NEW0 (RBinSection))) {",
          "1703:    r_list_free (ret);",
          "1704:    return NULL;",
          "",
          "[Removed Lines]",
          "1701:  for (i = 0; i < cache->hdr->mappingCount; i++) {",
          "",
          "[Added Lines]",
          "2005:  for (i = 0; i < cache->n_maps; i++) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1744:    r_list_free (ret);",
          "1745:    return NULL;",
          "1746:   }",
          "1749:   set_u_free (hash);",
          "1750:  }",
          "",
          "[Removed Lines]",
          "1747:   symbols_from_bin (ret, bf, bin, hash);",
          "1748:   r_dyld_locsym_entries_by_offset (cache, ret, hash, bin->header_at);",
          "",
          "[Added Lines]",
          "2051:   symbols_from_bin (cache, ret, bf, bin, hash);",
          "2052:   symbols_from_locsym (cache, bin, ret, hash);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1787:   return NULL;",
          "1788:  }",
          "1790:  RListIter *iter;",
          "1791:  RDyldBinImage *bin;",
          "1793:  RBuffer *orig_buf = bf->buf;",
          "1794:  ut32 num_of_unnamed_class = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2094:  if (!cache->objc_opt_info_loaded) {",
          "2095:   cache->oi = get_objc_opt_info (bf, cache);",
          "2096:   cache->objc_opt_info_loaded = true;",
          "2097:  }",
          "2101:  ut64 slide = rebase_infos_get_slide (cache);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1818:    }",
          "1820:    ut8 *pointers = malloc (sections[i].size);",
          "1822:     R_FREE (pointers);",
          "1823:     continue;",
          "1824:    }",
          "",
          "[Removed Lines]",
          "1821:    if (r_buf_read_at (cache->buf, sections[i].offset, pointers, sections[i].size) < sections[i].size) {",
          "",
          "[Added Lines]",
          "2131:    if (!pointers) {",
          "2132:     continue;",
          "2133:    }",
          "2135:    ut64 offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "2136:    if (r_buf_read_at (cache->buf, offset, pointers, sections[i].size) < sections[i].size) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1842:     bf->o->bin_obj = mach0;",
          "1843:     bf->buf = cache->buf;",
          "1844:     if (is_classlist) {",
          "1846:     } else {",
          "1848:     }",
          "1849:     bf->o->bin_obj = cache;",
          "1850:     bf->buf = orig_buf;",
          "1852:     if (!klass->name) {",
          "1853:      klass->name = r_str_newf (\"UnnamedClass%u\", num_of_unnamed_class);",
          "1854:      if (!klass->name) {",
          "1855:       R_FREE (klass);",
          "",
          "[Removed Lines]",
          "1845:      MACH0_(get_class_t) ((ut64) pointer_to_class, bf, klass, false, NULL);",
          "1847:      MACH0_(get_category_t) ((ut64) pointer_to_class, bf, klass, NULL);",
          "",
          "[Added Lines]",
          "2160:      MACH0_(get_class_t) (pointer_to_class, bf, klass, false, NULL, cache->oi);",
          "2162:      MACH0_(get_category_t) (pointer_to_class, bf, klass, NULL, cache->oi);",
          "2168:      eprintf (\"KLASS ERROR AT 0x%llx, is_classlist %d\\n\", pointer_to_class, is_classlist);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "835:  obj->rebasing_buffer = false;",
          "836: }",
          "838: #if !R_BIN_MACH064",
          "840: static bool check_buffer(RBinFile *bf, RBuffer *b) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "838: static RList *classes(RBinFile *bf) {",
          "839:  return MACH0_(parse_classes) (bf, NULL);",
          "840: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1174:  .relocs = &relocs,",
          "1175:  .patch_relocs = &patch_relocs,",
          "1176:  .create = &create,",
          "1178:  .write = &r_bin_write_mach0,",
          "1179: };",
          "",
          "[Removed Lines]",
          "1177:  .classes = &MACH0_(parse_classes),",
          "",
          "[Added Lines]",
          "1181:  .classes = &classes,",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach064.c||libr/bin/p/bin_mach064.c": [
          "File: libr/bin/p/bin_mach064.c -> libr/bin/p/bin_mach064.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "301:  .patch_relocs = &patch_relocs,",
          "302:  .fields = &MACH0_(mach_fields),",
          "303:  .create = &create,",
          "305:  .write = &r_bin_write_mach0,",
          "306: };",
          "",
          "[Removed Lines]",
          "304:  .classes = &MACH0_(parse_classes),",
          "",
          "[Added Lines]",
          "304:  .classes = &classes,",
          "",
          "---------------"
        ],
        "libr/util/buf.c||libr/util/buf.c": [
          "File: libr/util/buf.c -> libr/util/buf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "562: R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {",
          "563:  r_return_val_if_fail (b && buf && fmt, -1);",
          "564:  st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);",
          "566:  if (r < 0) {",
          "567:   return r;",
          "568:  }",
          "",
          "[Removed Lines]",
          "565:  int r = r_buf_seek (b, addr, R_BUF_SET);",
          "",
          "[Added Lines]",
          "565:  st64 r = r_buf_seek (b, addr, R_BUF_SET);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5247af02670dae0a9f0ee67545670fd9354c68fa",
      "candidate_info": {
        "commit_hash": "5247af02670dae0a9f0ee67545670fd9354c68fa",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/5247af02670dae0a9f0ee67545670fd9354c68fa",
        "files": [
          "libr/bin/p/bin_dyldcache.c"
        ],
        "message": "Update dyld shared cache parser ##bin",
        "before_after_code_files": [
          "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c"
          ],
          "candidate": [
            "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c": [
          "File: libr/bin/p/bin_dyldcache.c -> libr/bin/p/bin_dyldcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: #include \"objc/mach0_classes.h\"",
          "11: #define R_IS_PTR_AUTHENTICATED(x) B_IS_SET(x, 63)",
          "14: typedef struct {",
          "15:  ut8 version;",
          "",
          "[Removed Lines]",
          "12: #define MAX_N_HDR 16",
          "",
          "[Added Lines]",
          "12: #define MAX_N_HDR 128",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1176:   ut32 j;",
          "1177:   if (target_libs) {",
          "1178:    HtPU *path_to_idx = NULL;",
          "1180:     depArray = R_NEWS0 (ut16, cache->accel->depListCount);",
          "1181:     if (!depArray) {",
          "1182:      goto next;",
          "",
          "[Removed Lines]",
          "1179:    if (cache->accel) {",
          "",
          "[Added Lines]",
          "1179:    if (cache->accel && cache->accel->depListCount > 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1242:    if (deps && !deps[j]) {",
          "1243:     continue;",
          "1244:    }",
          "1247:    if (pa == UT64_MAX) {",
          "1248:     continue;",
          "1249:    }",
          "",
          "[Removed Lines]",
          "1246:    ut64 pa = va2pa (img[j].address, cache->n_maps, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
          "",
          "[Added Lines]",
          "1245:    ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1287:     break;",
          "1288:    }",
          "1289:    default:",
          "1291:     break;",
          "1292:    }",
          "1293:   }",
          "",
          "[Removed Lines]",
          "1290:     eprintf (\"Unknown sub-bin\\n\");",
          "",
          "[Added Lines]",
          "1289:     if (magic != 0) {",
          "1290:      R_LOG_WARN (\"Unknown sub-bin 0x%x\", magic);",
          "1291:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1798:   ut64 scoffs_size = 0;",
          "1799:   ut64 selrefs_offset = 0;",
          "1800:   ut64 selrefs_size = 0;",
          "1802:   ut64 slide = rebase_infos_get_slide (cache);",
          "1803:   for (i = 0; !sections[i].last; i++) {",
          "1804:    if (sections[i].size == 0) {",
          "",
          "[Removed Lines]",
          "1801:   ut8 remaining = 2;",
          "",
          "[Added Lines]",
          "1801:   ut64 const_selrefs_offset = 0;",
          "1802:   ut64 const_selrefs_size = 0;",
          "1803:   ut8 remaining = 3;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1820:      break;",
          "1821:     }",
          "1822:    }",
          "1823:   }",
          "1825:   MACH0_(mach0_free) (mach0);",
          "1826:   R_FREE (sections);",
          "1828:   ut64 sel_string_base = 0;",
          "1829:   if (!scoffs_offset || scoffs_size < 40) {",
          "1830:    if (!selrefs_offset || !selrefs_size || cache->n_hdr == 1) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1825:    if (strstr (sections[i].name, \"__DATA_CONST.__objc_selrefs\")) {",
          "1826:     const_selrefs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "1827:     const_selrefs_size = sections[i].size;",
          "1828:     remaining--;",
          "1829:     if (remaining == 0) {",
          "1830:      break;",
          "1831:     }",
          "1832:    }",
          "1838:   if (!selrefs_offset || !selrefs_size) {",
          "1839:    selrefs_offset = const_selrefs_offset;",
          "1840:    selrefs_size = const_selrefs_size;",
          "1841:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1859:    }",
          "1860:   } else {",
          "1861:    ut64 check = r_buf_read_le64_at (cache->buf, scoffs_offset);",
          "1863:     break;",
          "1864:    }",
          "1865:    sel_string_base = r_buf_read_le64_at (cache->buf, scoffs_offset + 8);",
          "",
          "[Removed Lines]",
          "1862:    if (check != 2) {",
          "",
          "[Added Lines]",
          "1877:    if (check < 2) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1885: static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {",
          "1886:  RDyldCache *cache = R_NEW0 (RDyldCache);",
          "1887:  memcpy (cache->magic, \"dyldcac\", 7);",
          "1888:  cache->buf = r_buf_ref (buf);",
          "1889:  populate_cache_headers (cache);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1902:  if (!cache) {",
          "1903:   return false;",
          "1904:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-18200",
  "cve_desc": "The f2fs implementation in the Linux kernel before 4.14 mishandles reference counts associated with f2fs_wait_discard_bios calls, which allows local users to cause a denial of service (BUG), as demonstrated by fstrim.",
  "repo": "torvalds/linux",
  "patch_hash": "638164a2718f337ea224b747cf5977ef143166a4",
  "patch_info": {
    "commit_hash": "638164a2718f337ea224b747cf5977ef143166a4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/638164a2718f337ea224b747cf5977ef143166a4",
    "files": [
      "fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c",
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix potential panic during fstrim\n\nAs Ju Hyung Park reported:\n\n\"When 'fstrim' is called for manual trim, a BUG() can be triggered\nrandomly with this patch.\n\nI'm seeing this issue on both x86 Desktop and arm64 Android phone.\n\nOn x86 Desktop, this was caused during Ubuntu boot-up. I have a\ncronjob installed which calls 'fstrim -v /' during boot. On arm64\nAndroid, this was caused during GC looping with 1ms gc_min_sleep_time\n& gc_max_sleep_time.\"\n\nRoot cause of this issue is that f2fs_wait_discard_bios can only be\nused by f2fs_put_super, because during put_super there must be no\nother referrers, so it can ignore discard entry's reference count\nwhen removing the entry, otherwise in other caller we will hit bug_on\nin __remove_discard_cmd as there may be other issuer added reference\ncount in discard entry.\n\nThread A\t\t\t\tThread B\n\t\t\t\t\t- issue_discard_thread\n- f2fs_ioc_fitrim\n - f2fs_trim_fs\n  - f2fs_wait_discard_bios\n   - __issue_discard_cmd\n    - __submit_discard_cmd\n\t\t\t\t\t - __wait_discard_cmd\n\t\t\t\t\t  - dc->ref++\n\t\t\t\t\t  - __wait_one_discard_bio\n   - __wait_discard_cmd\n    - __remove_discard_cmd\n     - f2fs_bug_on(sbi, dc->ref)\n\nFixes: 969d1b180d987c2be02de890d0fff0f66a0e80de\nReported-by: Ju Hyung Park <qkrwngud825@gmail.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
      "fs/f2fs/segment.c||fs/f2fs/segment.c",
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
      "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "2525: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
      "2526: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
      "2527: void stop_discard_thread(struct f2fs_sb_info *sbi);",
      "2529: void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc);",
      "2530: void release_discard_addrs(struct f2fs_sb_info *sbi);",
      "2531: int npages_for_summary_flush(struct f2fs_sb_info *sbi, bool for_ra);",
      "",
      "[Removed Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
      "",
      "[Added Lines]",
      "2528: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount);",
      "",
      "---------------"
    ],
    "fs/f2fs/segment.c||fs/f2fs/segment.c": [
      "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1210: }",
      "1214: {",
      "1215:  __issue_discard_cmd(sbi, false);",
      "1216:  __drop_discard_cmd(sbi);",
      "1218: }",
      "1220: static void mark_discard_range_all(struct f2fs_sb_info *sbi)",
      "",
      "[Removed Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
      "1217:  __wait_discard_cmd(sbi, false);",
      "",
      "[Added Lines]",
      "1213: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi, bool umount)",
      "1217:  __wait_discard_cmd(sbi, !umount);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2244:  }",
      "2246:  mark_discard_range_all(sbi);",
      "2248: out:",
      "2249:  range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);",
      "2250:  return err;",
      "",
      "[Removed Lines]",
      "2247:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "2247:  f2fs_wait_discard_bios(sbi, false);",
      "",
      "---------------"
    ],
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "801:  }",
      "806:  if (f2fs_discard_en(sbi) && !sbi->discard_blks) {",
      "807:   struct cp_control cpc = {",
      "",
      "[Removed Lines]",
      "804:  f2fs_wait_discard_bios(sbi);",
      "",
      "[Added Lines]",
      "804:  f2fs_wait_discard_bios(sbi, true);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1546996348b33dc44dff829bc86fea8a8536164d",
      "candidate_info": {
        "commit_hash": "1546996348b33dc44dff829bc86fea8a8536164d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1546996348b33dc44dff829bc86fea8a8536164d",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: add a kernel thread to issue discard commands asynchronously\n\nThis patch adds a kernel thread to issue discard commands.\nIt proposes three states, D_PREP, D_SUBMIT, and D_DONE to identify current\nbio status.\n\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "133:   (SM_I(sbi)->trim_sections * (sbi)->segs_per_sec)",
          "134: #define BATCHED_TRIM_BLOCKS(sbi) \\",
          "135:   (BATCHED_TRIM_SEGMENTS(sbi) << (sbi)->log_blocks_per_seg)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: #define DISCARD_ISSUE_RATE 8",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "182: };",
          "184: struct discard_cmd {",
          "190: };",
          "192: struct discard_cmd_control {",
          "197: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: enum {",
          "187:  D_PREP,",
          "188:  D_SUBMIT,",
          "189:  D_DONE,",
          "190: };",
          "207:  struct mutex cmd_lock;",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "628:  mutex_unlock(&dirty_i->seglist_lock);",
          "629: }",
          "632:    struct bio *bio, block_t lstart, block_t len)",
          "633: {",
          "634:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "",
          "[Removed Lines]",
          "631: static struct discard_cmd *__add_discard_cmd(struct f2fs_sb_info *sbi,",
          "",
          "[Added Lines]",
          "631: static void __add_discard_cmd(struct f2fs_sb_info *sbi,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "638:  dc = f2fs_kmem_cache_alloc(discard_cmd_slab, GFP_NOFS);",
          "639:  INIT_LIST_HEAD(&dc->list);",
          "640:  dc->bio = bio;",
          "641:  dc->lstart = lstart;",
          "642:  dc->len = len;",
          "643:  init_completion(&dc->wait);",
          "644:  list_add_tail(&dc->list, cmd_list);",
          "647: }",
          "",
          "[Removed Lines]",
          "646:  return dc;",
          "",
          "[Added Lines]",
          "641:  bio->bi_private = dc;",
          "644:  dc->state = D_PREP;",
          "647:  mutex_lock(&dcc->cmd_lock);",
          "649:  mutex_unlock(&dcc->cmd_lock);",
          "650: }",
          "652: static void __remove_discard_cmd(struct f2fs_sb_info *sbi, struct discard_cmd *dc)",
          "653: {",
          "654:  int err = dc->bio->bi_error;",
          "656:  if (err == -EOPNOTSUPP)",
          "657:   err = 0;",
          "659:  if (err)",
          "660:   f2fs_msg(sbi->sb, KERN_INFO,",
          "661:     \"Issue discard failed, ret: %d\", err);",
          "662:  bio_put(dc->bio);",
          "663:  list_del(&dc->list);",
          "664:  kmem_cache_free(discard_cmd_slab, dc);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "653:  struct list_head *wait_list = &(dcc->discard_cmd_list);",
          "654:  struct discard_cmd *dc, *tmp;",
          "656:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "664:     wait_for_completion_io(&dc->wait);",
          "665:    else",
          "667:   }",
          "680:  }",
          "681: }",
          "683: static void f2fs_submit_discard_endio(struct bio *bio)",
          "",
          "[Removed Lines]",
          "657:   struct bio *bio = dc->bio;",
          "658:   int err;",
          "660:   if (!completion_done(&dc->wait)) {",
          "661:    if ((dc->lstart <= blkaddr &&",
          "662:      blkaddr < dc->lstart + dc->len) ||",
          "663:      blkaddr == NULL_ADDR)",
          "666:     continue;",
          "669:   err = bio->bi_error;",
          "670:   if (err == -EOPNOTSUPP)",
          "671:    err = 0;",
          "673:   if (err)",
          "674:    f2fs_msg(sbi->sb, KERN_INFO,",
          "675:     \"Issue discard failed, ret: %d\", err);",
          "677:   bio_put(bio);",
          "678:   list_del(&dc->list);",
          "679:   kmem_cache_free(discard_cmd_slab, dc);",
          "",
          "[Added Lines]",
          "674:  mutex_lock(&dcc->cmd_lock);",
          "677:   if (blkaddr == NULL_ADDR) {",
          "678:    if (dc->state == D_PREP) {",
          "679:     dc->state = D_SUBMIT;",
          "680:     submit_bio(dc->bio);",
          "681:    }",
          "682:    wait_for_completion_io(&dc->wait);",
          "684:    __remove_discard_cmd(sbi, dc);",
          "685:    continue;",
          "686:   }",
          "688:   if (dc->lstart <= blkaddr && blkaddr < dc->lstart + dc->len) {",
          "689:    if (dc->state == D_SUBMIT)",
          "692:     __remove_discard_cmd(sbi, dc);",
          "695:  mutex_unlock(&dcc->cmd_lock);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "685:  struct discard_cmd *dc = (struct discard_cmd *)bio->bi_private;",
          "687:  complete(&dc->wait);",
          "688: }",
          "691: static int __f2fs_issue_discard_async(struct f2fs_sb_info *sbi,",
          "692:   struct block_device *bdev, block_t blkstart, block_t blklen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "703:  dc->state = D_DONE;",
          "706: static int issue_discard_thread(void *data)",
          "707: {",
          "708:  struct f2fs_sb_info *sbi = data;",
          "709:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "710:  wait_queue_head_t *q = &dcc->discard_wait_queue;",
          "711:  struct list_head *cmd_list = &dcc->discard_cmd_list;",
          "712:  struct discard_cmd *dc, *tmp;",
          "713:  struct blk_plug plug;",
          "714:  int iter = 0;",
          "715: repeat:",
          "716:  if (kthread_should_stop())",
          "717:   return 0;",
          "719:  blk_start_plug(&plug);",
          "721:  mutex_lock(&dcc->cmd_lock);",
          "722:  list_for_each_entry_safe(dc, tmp, cmd_list, list) {",
          "723:   if (dc->state == D_PREP) {",
          "724:    dc->state = D_SUBMIT;",
          "725:    submit_bio(dc->bio);",
          "726:    if (iter++ > DISCARD_ISSUE_RATE)",
          "727:     break;",
          "728:   } else if (dc->state == D_DONE) {",
          "729:    __remove_discard_cmd(sbi, dc);",
          "730:   }",
          "731:  }",
          "732:  mutex_unlock(&dcc->cmd_lock);",
          "734:  blk_finish_plug(&plug);",
          "736:  iter = 0;",
          "737:  congestion_wait(BLK_RW_SYNC, HZ/50);",
          "739:  wait_event_interruptible(*q,",
          "740:   kthread_should_stop() || !list_empty(&dcc->discard_cmd_list));",
          "741:  goto repeat;",
          "742: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "707:     SECTOR_FROM_BLOCK(blklen),",
          "708:     GFP_NOFS, 0, &bio);",
          "709:  if (!err && bio) {",
          "714:   bio->bi_end_io = f2fs_submit_discard_endio;",
          "715:   bio->bi_opf |= REQ_SYNC;",
          "717:  }",
          "718:  return err;",
          "719: }",
          "",
          "[Removed Lines]",
          "710:   struct discard_cmd *dc = __add_discard_cmd(sbi, bio,",
          "711:       lblkstart, blklen);",
          "713:   bio->bi_private = dc;",
          "716:   submit_bio(bio);",
          "",
          "[Added Lines]",
          "768:   __add_discard_cmd(sbi, bio, lblkstart, blklen);",
          "769:   wake_up(&SM_I(sbi)->dcc_info->discard_wait_queue);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "919:  struct list_head *head = &(SM_I(sbi)->dcc_info->discard_entry_list);",
          "920:  struct discard_entry *entry, *this;",
          "921:  struct dirty_seglist_info *dirty_i = DIRTY_I(sbi);",
          "923:  unsigned long *prefree_map = dirty_i->dirty_segmap[PRE];",
          "924:  unsigned int start = 0, end = -1;",
          "925:  unsigned int secno, start_segno;",
          "926:  bool force = (cpc->reason == CP_DISCARD);",
          "930:  mutex_lock(&dirty_i->seglist_lock);",
          "932:  while (1) {",
          "",
          "[Removed Lines]",
          "922:  struct blk_plug plug;",
          "928:  blk_start_plug(&plug);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "979:   SM_I(sbi)->dcc_info->nr_discards -= entry->len;",
          "980:   kmem_cache_free(discard_entry_slab, entry);",
          "981:  }",
          "984: }",
          "986: int create_discard_cmd_control(struct f2fs_sb_info *sbi)",
          "987: {",
          "988:  struct discard_cmd_control *dcc;",
          "989:  int err = 0;",
          "",
          "[Removed Lines]",
          "983:  blk_finish_plug(&plug);",
          "",
          "[Added Lines]",
          "1036:  dev_t dev = sbi->sb->s_bdev->bd_dev;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1000:  INIT_LIST_HEAD(&dcc->discard_entry_list);",
          "1001:  INIT_LIST_HEAD(&dcc->discard_cmd_list);",
          "1002:  dcc->nr_discards = 0;",
          "1003:  dcc->max_discards = 0;",
          "1005:  SM_I(sbi)->dcc_info = dcc;",
          "1006: init_thread:",
          "1007:  return err;",
          "1008: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1051:  mutex_init(&dcc->cmd_lock);",
          "1055:  init_waitqueue_head(&dcc->discard_wait_queue);",
          "1058:  dcc->f2fs_issue_discard = kthread_run(issue_discard_thread, sbi,",
          "1059:     \"f2fs_discard-%u:%u\", MAJOR(dev), MINOR(dev));",
          "1060:  if (IS_ERR(dcc->f2fs_issue_discard)) {",
          "1061:   err = PTR_ERR(dcc->f2fs_issue_discard);",
          "1062:   kfree(dcc);",
          "1063:   SM_I(sbi)->dcc_info = NULL;",
          "1064:   return err;",
          "1065:  }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1011: {",
          "1012:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1014:  if (free) {",
          "1015:   kfree(dcc);",
          "1016:   SM_I(sbi)->dcc_info = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1074:  if (dcc && dcc->f2fs_issue_discard) {",
          "1075:   struct task_struct *discard_thread = dcc->f2fs_issue_discard;",
          "1077:   dcc->f2fs_issue_discard = NULL;",
          "1078:   kthread_stop(discard_thread);",
          "1079:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "78997b569f5625f2762b3c4e743c33becdd5d99d",
      "candidate_info": {
        "commit_hash": "78997b569f5625f2762b3c4e743c33becdd5d99d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/78997b569f5625f2762b3c4e743c33becdd5d99d",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c",
          "fs/f2fs/segment.h",
          "fs/f2fs/sysfs.c"
        ],
        "message": "f2fs: split discard policy\n\nThere are many different scenarios such as fstrim, umount, urgent or\nbackground where we will issue discards, actually, they need use\ndifferent policy in aspect of io aware, discard granularity, delay\ninterval and so on. But now they just share one common discard policy,\nso there will be race when changing policy in between these scenarios,\nthe interference of changing discard policy will be very serious.\n\nThis patch changes to split discard policy for different scenarios.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/segment.h||fs/f2fs/segment.h",
          "fs/f2fs/sysfs.c||fs/f2fs/sysfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "208: #define plist_idx(blk_num) ((blk_num) >= MAX_PLIST_NUM ?  \\",
          "209:      (MAX_PLIST_NUM - 1) : (blk_num - 1))",
          "215: enum {",
          "216:  D_PREP,",
          "217:  D_SUBMIT,",
          "",
          "[Removed Lines]",
          "211: #define P_ACTIVE 0x01",
          "212: #define P_TRIM  0x02",
          "213: #define plist_issue(tag) (((tag) & P_ACTIVE) || ((tag) & P_TRIM))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "244: };",
          "246: struct discard_policy {",
          "253: };",
          "255: struct discard_cmd_control {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "242: enum {",
          "243:  DPOLICY_BG,",
          "244:  DPOLICY_FORCE,",
          "245:  DPOLICY_FSTRIM,",
          "246:  DPOLICY_UMOUNT,",
          "247:  MAX_DPOLICY,",
          "248: };",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2544: void destroy_flush_cmd_control(struct f2fs_sb_info *sbi, bool free);",
          "2545: void invalidate_blocks(struct f2fs_sb_info *sbi, block_t addr);",
          "2546: bool is_checkpointed_data(struct f2fs_sb_info *sbi, block_t blkaddr);",
          "2547: void refresh_sit_entry(struct f2fs_sb_info *sbi, block_t old, block_t new);",
          "2548: void stop_discard_thread(struct f2fs_sb_info *sbi);",
          "2549: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2552: void init_discard_policy(struct discard_policy *dpolicy, int discard_type,",
          "2553:       unsigned int granularity);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "875: static void __submit_discard_cmd(struct f2fs_sb_info *sbi,",
          "877: {",
          "878:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "881:  struct bio *bio = NULL;",
          "884:  if (dc->state != D_PREP)",
          "885:   return;",
          "",
          "[Removed Lines]",
          "876:     struct discard_cmd *dc, bool fstrim)",
          "879:  struct list_head *wait_list = fstrim ? &(dcc->fstrim_list) :",
          "880:        &(dcc->wait_list);",
          "882:  int flag = dcc->dpolicy.sync ? REQ_SYNC : 0;",
          "",
          "[Added Lines]",
          "876:       struct discard_policy *dpolicy,",
          "877:       struct discard_cmd *dc)",
          "880:  struct list_head *wait_list = (dpolicy->type == DPOLICY_FSTRIM) ?",
          "881:      &(dcc->fstrim_list) : &(dcc->wait_list);",
          "883:  int flag = dpolicy->sync ? REQ_SYNC : 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1086: }",
          "1088: static void __issue_discard_cmd_range(struct f2fs_sb_info *sbi,",
          "1091: {",
          "1092:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1093:  struct discard_cmd *prev_dc = NULL, *next_dc = NULL;",
          "1094:  struct rb_node **insert_p = NULL, *insert_parent = NULL;",
          "1095:  struct discard_cmd *dc;",
          "1097:  struct blk_plug plug;",
          "1098:  int issued;",
          "",
          "[Removed Lines]",
          "1089:      unsigned int start, unsigned int end,",
          "1090:      unsigned int granularity)",
          "1096:  struct discard_policy *dpolicy = &dcc->dpolicy;",
          "",
          "[Added Lines]",
          "1090:      struct discard_policy *dpolicy,",
          "1091:      unsigned int start, unsigned int end)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1116:  while (dc && dc->lstart <= end) {",
          "1117:   struct rb_node *node;",
          "1120:    goto skip;",
          "1122:   if (dc->state != D_PREP) {",
          "",
          "[Removed Lines]",
          "1119:   if (dc->len < granularity)",
          "",
          "[Added Lines]",
          "1119:   if (dc->len < dpolicy->granularity)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1124:    goto skip;",
          "1125:   }",
          "1129:   if (++issued >= dpolicy->max_requests) {",
          "1130:    start = dc->lstart + dc->len;",
          "",
          "[Removed Lines]",
          "1127:   __submit_discard_cmd(sbi, dc, true);",
          "",
          "[Added Lines]",
          "1127:   __submit_discard_cmd(sbi, dpolicy, dc);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1148:  mutex_unlock(&dcc->cmd_lock);",
          "1149: }",
          "1152: {",
          "1153:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1154:  struct list_head *pend_list;",
          "1155:  struct discard_cmd *dc, *tmp;",
          "1156:  struct blk_plug plug;",
          "1160:  bool io_interrupted = false;",
          "1162:  mutex_lock(&dcc->cmd_lock);",
          "1163:  f2fs_bug_on(sbi,",
          "1164:   !__check_rb_tree_consistence(sbi, &dcc->root));",
          "1165:  blk_start_plug(&plug);",
          "1168:   pend_list = &dcc->pend_list[i];",
          "1169:   list_for_each_entry_safe(dc, tmp, pend_list, list) {",
          "1170:    f2fs_bug_on(sbi, dc->state != D_PREP);",
          "1185:    if (dpolicy->io_aware && i < dpolicy->io_aware_gran &&",
          "1186:         !is_idle(sbi)) {",
          "1187:     io_interrupted = true;",
          "1188:     goto skip;",
          "1189:    }",
          "1192:    issued++;",
          "1193: skip:",
          "1194:    if (++iter >= dpolicy->max_requests)",
          "1195:     goto out;",
          "1196:   }",
          "1199:  }",
          "1200: out:",
          "1201:  blk_finish_plug(&plug);",
          "",
          "[Removed Lines]",
          "1151: static int __issue_discard_cmd(struct f2fs_sb_info *sbi, bool issue_cond)",
          "1157:  struct discard_policy *dpolicy = &dcc->dpolicy;",
          "1158:  int iter = 0, issued = 0;",
          "1159:  int i;",
          "1166:  for (i = MAX_PLIST_NUM - 1;",
          "1167:    i >= 0 && plist_issue(dcc->pend_list_tag[i]); i--) {",
          "1173:    if (dcc->pend_list_tag[i] & P_TRIM) {",
          "1174:     __submit_discard_cmd(sbi, dc, false);",
          "1175:     issued++;",
          "1176:     continue;",
          "1177:    }",
          "1179:    if (!issue_cond) {",
          "1180:     __submit_discard_cmd(sbi, dc, false);",
          "1181:     issued++;",
          "1182:     continue;",
          "1183:    }",
          "1191:    __submit_discard_cmd(sbi, dc, false);",
          "1197:   if (list_empty(pend_list) && dcc->pend_list_tag[i] & P_TRIM)",
          "1198:    dcc->pend_list_tag[i] &= (~P_TRIM);",
          "",
          "[Added Lines]",
          "1151: static int __issue_discard_cmd(struct f2fs_sb_info *sbi,",
          "1152:      struct discard_policy *dpolicy)",
          "1158:  int i, iter = 0, issued = 0;",
          "1165:  for (i = MAX_PLIST_NUM - 1; i >= 0; i--) {",
          "1166:   if (i + 1 < dpolicy->granularity)",
          "1167:    break;",
          "1178:    __submit_discard_cmd(sbi, dpolicy, dc);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1239:  mutex_unlock(&dcc->cmd_lock);",
          "1240: }",
          "1246: {",
          "1247:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1250:  struct discard_cmd *dc, *tmp;",
          "1251:  bool need_wait;",
          "",
          "[Removed Lines]",
          "1242: static void __wait_discard_cmd_range(struct f2fs_sb_info *sbi, bool wait_cond,",
          "1243:       block_t start, block_t end,",
          "1244:       unsigned int granularity,",
          "1245:       bool fstrim)",
          "1248:  struct list_head *wait_list = fstrim ? &(dcc->fstrim_list) :",
          "1249:        &(dcc->wait_list);",
          "",
          "[Added Lines]",
          "1227: static void __wait_discard_cmd_range(struct f2fs_sb_info *sbi,",
          "1228:       struct discard_policy *dpolicy,",
          "1229:       block_t start, block_t end)",
          "1232:  struct list_head *wait_list = (dpolicy->type == DPOLICY_FSTRIM) ?",
          "1233:      &(dcc->fstrim_list) : &(dcc->wait_list);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1257:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "1258:   if (dc->lstart + dc->len <= start || end <= dc->lstart)",
          "1259:    continue;",
          "1261:    continue;",
          "1263:    wait_for_completion_io(&dc->wait);",
          "1264:    __remove_discard_cmd(sbi, dc);",
          "1265:   } else {",
          "",
          "[Removed Lines]",
          "1260:   if (dc->len < granularity)",
          "1262:   if (!wait_cond || (dc->state == D_DONE && !dc->ref)) {",
          "",
          "[Added Lines]",
          "1244:   if (dc->len < dpolicy->granularity)",
          "1246:   if (dc->state == D_DONE && !dc->ref) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1276:  }",
          "1277: }",
          "1280: {",
          "1282: }",
          "",
          "[Removed Lines]",
          "1279: static void __wait_all_discard_cmd(struct f2fs_sb_info *sbi, bool wait_cond)",
          "1281:  __wait_discard_cmd_range(sbi, wait_cond, 0, UINT_MAX, 1, false);",
          "",
          "[Added Lines]",
          "1263: static void __wait_all_discard_cmd(struct f2fs_sb_info *sbi,",
          "1264:       struct discard_policy *dpolicy)",
          "1266:  __wait_discard_cmd_range(sbi, dpolicy, 0, UINT_MAX);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1320: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
          "1328: {",
          "1329:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1336: }",
          "1338: static int issue_discard_thread(void *data)",
          "",
          "[Removed Lines]",
          "1321: {",
          "1322:  __issue_discard_cmd(sbi, false);",
          "1323:  __drop_discard_cmd(sbi);",
          "1324:  __wait_all_discard_cmd(sbi, false);",
          "1325: }",
          "1327: static void mark_discard_range_all(struct f2fs_sb_info *sbi)",
          "1330:  int i;",
          "1332:  mutex_lock(&dcc->cmd_lock);",
          "1333:  for (i = 0; i < MAX_PLIST_NUM; i++)",
          "1334:   dcc->pend_list_tag[i] |= P_TRIM;",
          "1335:  mutex_unlock(&dcc->cmd_lock);",
          "",
          "[Added Lines]",
          "1308:  struct discard_policy dpolicy;",
          "1310:  init_discard_policy(&dpolicy, DPOLICY_UMOUNT, dcc->discard_granularity);",
          "1311:  __issue_discard_cmd(sbi, &dpolicy);",
          "1312:  __drop_discard_cmd(sbi);",
          "1313:  __wait_all_discard_cmd(sbi, &dpolicy);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1340:  struct f2fs_sb_info *sbi = data;",
          "1341:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1342:  wait_queue_head_t *q = &dcc->discard_wait_queue;",
          "1344:  unsigned int wait_ms = DEF_MIN_DISCARD_ISSUE_TIME;",
          "1345:  int issued;",
          "1347:  set_freezable();",
          "1349:  do {",
          "1350:   wait_event_interruptible_timeout(*q,",
          "1351:     kthread_should_stop() || freezing(current) ||",
          "1352:     dcc->discard_wake,",
          "",
          "[Removed Lines]",
          "1343:  struct discard_policy *dpolicy = &dcc->dpolicy;",
          "",
          "[Added Lines]",
          "1321:  struct discard_policy dpolicy;",
          "1328:   init_discard_policy(&dpolicy, DPOLICY_BG,",
          "1329:      dcc->discard_granularity);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1359:   if (dcc->discard_wake) {",
          "1360:    dcc->discard_wake = 0;",
          "1361:    if (sbi->gc_thread && sbi->gc_thread->gc_urgent)",
          "1363:   }",
          "1365:   sb_start_intwrite(sbi->sb);",
          "1368:   if (issued) {",
          "1371:   } else {",
          "1373:   }",
          "1375:   sb_end_intwrite(sbi->sb);",
          "",
          "[Removed Lines]",
          "1362:     mark_discard_range_all(sbi);",
          "1367:   issued = __issue_discard_cmd(sbi, true);",
          "1369:    __wait_all_discard_cmd(sbi, true);",
          "1370:    wait_ms = dpolicy->min_interval;",
          "1372:    wait_ms = dpolicy->max_interval;",
          "",
          "[Added Lines]",
          "1343:     init_discard_policy(&dpolicy,",
          "1344:        DPOLICY_FORCE, 1);",
          "1349:   issued = __issue_discard_cmd(sbi, &dpolicy);",
          "1351:    __wait_all_discard_cmd(sbi, &dpolicy);",
          "1352:    wait_ms = dpolicy.min_interval;",
          "1354:    wait_ms = dpolicy.max_interval;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1654:  wake_up_discard_thread(sbi, false);",
          "1655: }",
          "1658: {",
          "1666:  dpolicy->sync = true;",
          "1667: }",
          "1669: static int create_discard_cmd_control(struct f2fs_sb_info *sbi)",
          "",
          "[Removed Lines]",
          "1657: static void inline init_discard_policy(struct discard_cmd_control *dcc)",
          "1659:  struct discard_policy *dpolicy = &dcc->dpolicy;",
          "1661:  dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "1662:  dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;",
          "1663:  dpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;",
          "1664:  dpolicy->io_aware_gran = MAX_PLIST_NUM;",
          "1665:  dpolicy->io_aware = true;",
          "",
          "[Added Lines]",
          "1639: void init_discard_policy(struct discard_policy *dpolicy,",
          "1640:     int discard_type, unsigned int granularity)",
          "1643:  dpolicy->type = discard_type;",
          "1645:  dpolicy->granularity = granularity;",
          "1647:  if (discard_type == DPOLICY_BG) {",
          "1648:   dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "1649:   dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;",
          "1650:   dpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;",
          "1651:   dpolicy->io_aware_gran = MAX_PLIST_NUM;",
          "1652:   dpolicy->io_aware = true;",
          "1653:  } else if (discard_type == DPOLICY_FORCE) {",
          "1654:   dpolicy->min_interval = DEF_MIN_DISCARD_ISSUE_TIME;",
          "1655:   dpolicy->max_interval = DEF_MAX_DISCARD_ISSUE_TIME;",
          "1656:   dpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;",
          "1657:   dpolicy->io_aware_gran = MAX_PLIST_NUM;",
          "1658:   dpolicy->io_aware = true;",
          "1659:  } else if (discard_type == DPOLICY_FSTRIM) {",
          "1660:   dpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;",
          "1661:   dpolicy->io_aware_gran = MAX_PLIST_NUM;",
          "1662:   dpolicy->io_aware = false;",
          "1663:  } else if (discard_type == DPOLICY_UMOUNT) {",
          "1664:   dpolicy->max_requests = DEF_MAX_DISCARD_REQUEST;",
          "1665:   dpolicy->io_aware_gran = MAX_PLIST_NUM;",
          "1666:   dpolicy->io_aware = false;",
          "1667:  }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1684:  dcc->discard_granularity = DEFAULT_DISCARD_GRANULARITY;",
          "1685:  INIT_LIST_HEAD(&dcc->entry_list);",
          "1687:   INIT_LIST_HEAD(&dcc->pend_list[i]);",
          "1691:  INIT_LIST_HEAD(&dcc->wait_list);",
          "1692:  INIT_LIST_HEAD(&dcc->fstrim_list);",
          "1693:  mutex_init(&dcc->cmd_lock);",
          "",
          "[Removed Lines]",
          "1686:  for (i = 0; i < MAX_PLIST_NUM; i++) {",
          "1688:   if (i >= dcc->discard_granularity - 1)",
          "1689:    dcc->pend_list_tag[i] |= P_ACTIVE;",
          "1690:  }",
          "",
          "[Added Lines]",
          "1687:  for (i = 0; i < MAX_PLIST_NUM; i++)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1699:  dcc->undiscard_blks = 0;",
          "1700:  dcc->root = RB_ROOT;",
          "1704:  init_waitqueue_head(&dcc->discard_wait_queue);",
          "1705:  SM_I(sbi)->dcc_info = dcc;",
          "1706: init_thread:",
          "",
          "[Removed Lines]",
          "1702:  init_discard_policy(dcc);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2322:  unsigned int start_segno, end_segno, cur_segno;",
          "2323:  block_t start_block, end_block;",
          "2324:  struct cp_control cpc;",
          "2325:  int err = 0;",
          "2327:  if (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2321:  struct discard_policy dpolicy;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2375:  start_block = START_BLOCK(sbi, start_segno);",
          "2376:  end_block = START_BLOCK(sbi, min(cur_segno, end_segno) + 1);",
          "2381: out:",
          "2382:  range->len = F2FS_BLK_TO_BYTES(cpc.trimmed);",
          "2383:  return err;",
          "",
          "[Removed Lines]",
          "2378:  __issue_discard_cmd_range(sbi, start_block, end_block, cpc.trim_minlen);",
          "2379:  __wait_discard_cmd_range(sbi, true, start_block, end_block,",
          "2380:       cpc.trim_minlen, true);",
          "",
          "[Added Lines]",
          "2375:  init_discard_policy(&dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "2376:  __issue_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2377:  __wait_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.h||fs/f2fs/segment.h": [
          "File: fs/f2fs/segment.h -> fs/f2fs/segment.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "796:   goto wake_up;",
          "798:  mutex_lock(&dcc->cmd_lock);",
          "801:   if (!list_empty(&dcc->pend_list[i])) {",
          "802:    wakeup = true;",
          "803:    break;",
          "",
          "[Removed Lines]",
          "799:  for (i = MAX_PLIST_NUM - 1;",
          "800:    i >= 0 && plist_issue(dcc->pend_list_tag[i]); i--) {",
          "",
          "[Added Lines]",
          "799:  for (i = MAX_PLIST_NUM - 1; i >= 0; i--) {",
          "800:   if (i + 1 < dcc->discard_granularity)",
          "801:    break;",
          "",
          "---------------"
        ],
        "fs/f2fs/sysfs.c||fs/f2fs/sysfs.c": [
          "File: fs/f2fs/sysfs.c -> fs/f2fs/sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:  }",
          "156:  if (!strcmp(a->attr.name, \"discard_granularity\")) {",
          "160:   if (t == 0 || t > MAX_PLIST_NUM)",
          "161:    return -EINVAL;",
          "162:   if (t == *ui)",
          "163:    return count;",
          "175:   return count;",
          "176:  }",
          "",
          "[Removed Lines]",
          "157:   struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "158:   int i;",
          "165:   mutex_lock(&dcc->cmd_lock);",
          "166:   for (i = 0; i < MAX_PLIST_NUM; i++) {",
          "167:    if (i >= t - 1)",
          "168:     dcc->pend_list_tag[i] |= P_ACTIVE;",
          "169:    else",
          "170:     dcc->pend_list_tag[i] &= (~P_ACTIVE);",
          "171:   }",
          "172:   mutex_unlock(&dcc->cmd_lock);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e555da9f31210d2b62805cd7faf29228af7c3cfb",
      "candidate_info": {
        "commit_hash": "e555da9f31210d2b62805cd7faf29228af7c3cfb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e555da9f31210d2b62805cd7faf29228af7c3cfb",
        "files": [
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: run fstrim asynchronously if runtime discard is on\n\nWe don't need to wait for whole bunch of discard candidates in fstrim, since\nruntime discard will issue them in idle time.\n\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2440:  __init_discard_policy(sbi, &dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "2441:  __issue_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2443:      start_block, end_block);",
          "2445: out:",
          "2446:  return err;",
          "2447: }",
          "",
          "[Removed Lines]",
          "2442:  trimmed = __wait_discard_cmd_range(sbi, &dpolicy,",
          "2444:  range->len = F2FS_BLK_TO_BYTES(trimmed);",
          "",
          "[Added Lines]",
          "2449:  if (!test_opt(sbi, DISCARD)) {",
          "2450:   trimmed = __wait_discard_cmd_range(sbi, &dpolicy,",
          "2452:   range->len = F2FS_BLK_TO_BYTES(trimmed);",
          "2453:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "377224c471188a2c9a838f919160546f4e842ab8",
      "candidate_info": {
        "commit_hash": "377224c471188a2c9a838f919160546f4e842ab8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/377224c471188a2c9a838f919160546f4e842ab8",
        "files": [
          "Documentation/ABI/testing/sysfs-fs-f2fs",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c",
          "fs/f2fs/sysfs.c"
        ],
        "message": "f2fs: don't split checkpoint in fstrim\n\nNow, we issue discard asynchronously in separated thread instead of in\ncheckpoint, after that, we won't encounter long latency in checkpoint\ndue to huge number of synchronous discard command handling, so, we don't\nneed to split checkpoint to do trim in batch, merge it and obsolete\nrelated sysfs entry.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/sysfs.c||fs/f2fs/sysfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "176: #define CP_DISCARD 0x00000010",
          "177: #define CP_TRIMMED 0x00000020",
          "184: #define MAX_DISCARD_BLOCKS(sbi)  BLKS_PER_SEC(sbi)",
          "",
          "[Removed Lines]",
          "179: #define DEF_BATCHED_TRIM_SECTIONS 2048",
          "180: #define BATCHED_TRIM_SEGMENTS(sbi) \\",
          "181:   (GET_SEG_FROM_SEC(sbi, SM_I(sbi)->trim_sections))",
          "182: #define BATCHED_TRIM_BLOCKS(sbi) \\",
          "183:   (BATCHED_TRIM_SEGMENTS(sbi) << (sbi)->log_blocks_per_seg)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2395: {",
          "2396:  __u64 start = F2FS_BYTES_TO_BLK(range->start);",
          "2397:  __u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;",
          "2399:  block_t start_block, end_block;",
          "2400:  struct cp_control cpc;",
          "2401:  struct discard_policy dpolicy;",
          "",
          "[Removed Lines]",
          "2398:  unsigned int start_segno, end_segno, cur_segno;",
          "",
          "[Added Lines]",
          "2398:  unsigned int start_segno, end_segno;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2422:  cpc.reason = CP_DISCARD;",
          "2423:  cpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));",
          "2449:  start_block = START_BLOCK(sbi, start_segno);",
          "2452:  __init_discard_policy(sbi, &dpolicy, DPOLICY_FSTRIM, cpc.trim_minlen);",
          "2453:  __issue_discard_cmd_range(sbi, &dpolicy, start_block, end_block);",
          "2454:  trimmed = __wait_discard_cmd_range(sbi, &dpolicy,",
          "2455:      start_block, end_block);",
          "2457:  range->len = F2FS_BLK_TO_BYTES(trimmed);",
          "2458:  return err;",
          "2459: }",
          "",
          "[Removed Lines]",
          "2426:  for (cur_segno = start_segno; cur_segno <= end_segno;",
          "2427:      cur_segno = cpc.trim_end + 1) {",
          "2428:   cpc.trim_start = cur_segno;",
          "2430:   if (sbi->discard_blks == 0)",
          "2431:    break;",
          "2432:   else if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))",
          "2433:    cpc.trim_end = end_segno;",
          "2434:   else",
          "2435:    cpc.trim_end = min_t(unsigned int,",
          "2436:     rounddown(cur_segno +",
          "2437:     BATCHED_TRIM_SEGMENTS(sbi),",
          "2438:     sbi->segs_per_sec) - 1, end_segno);",
          "2440:   mutex_lock(&sbi->gc_mutex);",
          "2441:   err = write_checkpoint(sbi, &cpc);",
          "2442:   mutex_unlock(&sbi->gc_mutex);",
          "2443:   if (err)",
          "2444:    break;",
          "2446:   schedule();",
          "2447:  }",
          "2450:  end_block = START_BLOCK(sbi, min(cur_segno, end_segno) + 1);",
          "2456: out:",
          "",
          "[Added Lines]",
          "2424:  cpc.trim_start = start_segno;",
          "2425:  cpc.trim_end = end_segno;",
          "2427:  if (sbi->discard_blks == 0)",
          "2428:   goto out;",
          "2430:  mutex_lock(&sbi->gc_mutex);",
          "2431:  err = write_checkpoint(sbi, &cpc);",
          "2432:  mutex_unlock(&sbi->gc_mutex);",
          "2433:  if (err)",
          "2434:   goto out;",
          "2437:  end_block = START_BLOCK(sbi, end_segno + 1);",
          "2444: out:",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3841:  sm_info->min_hot_blocks = DEF_MIN_HOT_BLOCKS;",
          "3842:  sm_info->min_ssr_sections = reserved_sections(sbi);",
          "3846:  INIT_LIST_HEAD(&sm_info->sit_entry_set);",
          "3848:  init_rwsem(&sm_info->curseg_lock);",
          "",
          "[Removed Lines]",
          "3844:  sm_info->trim_sections = DEF_BATCHED_TRIM_SECTIONS;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/sysfs.c||fs/f2fs/sysfs.c": [
          "File: fs/f2fs/sysfs.c -> fs/f2fs/sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "245:   return count;",
          "246:  }",
          "250:  if (!strcmp(a->attr.name, \"iostat_enable\") && *ui == 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "248:  if (!strcmp(a->attr.name, \"trim_sections\"))",
          "249:   return -EINVAL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "63a94fa1d79dfbb94a2c923f8810e3b45b27570e",
      "candidate_info": {
        "commit_hash": "63a94fa1d79dfbb94a2c923f8810e3b45b27570e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/63a94fa1d79dfbb94a2c923f8810e3b45b27570e",
        "files": [
          "fs/f2fs/segment.c"
        ],
        "message": "f2fs: introduce __wait_discard_cmd\n\nJust cleanup, no logic change.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/segment.c||fs/f2fs/segment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ],
          "candidate": [
            "fs/f2fs/segment.c||fs/f2fs/segment.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "997:  mutex_unlock(&dcc->cmd_lock);",
          "998: }",
          "1001: void f2fs_wait_discard_bio(struct f2fs_sb_info *sbi, block_t blkaddr)",
          "1002: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1000: static void __wait_discard_cmd(struct f2fs_sb_info *sbi, bool wait_cond)",
          "1001: {",
          "1002:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1003:  struct list_head *wait_list = &(dcc->wait_list);",
          "1004:  struct discard_cmd *dc, *tmp;",
          "1006:  mutex_lock(&dcc->cmd_lock);",
          "1007:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "1008:   if (!wait_cond || dc->state == D_DONE) {",
          "1009:    wait_for_completion_io(&dc->wait);",
          "1010:    __remove_discard_cmd(sbi, dc);",
          "1011:   }",
          "1012:  }",
          "1013:  mutex_unlock(&dcc->cmd_lock);",
          "1014: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1019: void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)",
          "1020: {",
          "1025:  __issue_discard_cmd(sbi, false);",
          "1033: }",
          "1035: static int issue_discard_thread(void *data)",
          "",
          "[Removed Lines]",
          "1021:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1022:  struct list_head *wait_list = &(dcc->wait_list);",
          "1023:  struct discard_cmd *dc, *tmp;",
          "1027:  mutex_lock(&dcc->cmd_lock);",
          "1028:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "1029:   wait_for_completion_io(&dc->wait);",
          "1030:   __remove_discard_cmd(sbi, dc);",
          "1031:  }",
          "1032:  mutex_unlock(&dcc->cmd_lock);",
          "",
          "[Added Lines]",
          "1038:  __wait_discard_cmd(sbi, false);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1037:  struct f2fs_sb_info *sbi = data;",
          "1038:  struct discard_cmd_control *dcc = SM_I(sbi)->dcc_info;",
          "1039:  wait_queue_head_t *q = &dcc->discard_wait_queue;",
          "1042: repeat:",
          "1043:  if (kthread_should_stop())",
          "1044:   return 0;",
          "1046:  __issue_discard_cmd(sbi, true);",
          "1057:  congestion_wait(BLK_RW_SYNC, HZ/50);",
          "",
          "[Removed Lines]",
          "1040:  struct list_head *wait_list = &dcc->wait_list;",
          "1041:  struct discard_cmd *dc, *tmp;",
          "1048:  mutex_lock(&dcc->cmd_lock);",
          "1049:  list_for_each_entry_safe(dc, tmp, wait_list, list) {",
          "1050:   if (dc->state == D_DONE) {",
          "1051:    wait_for_completion_io(&dc->wait);",
          "1052:    __remove_discard_cmd(sbi, dc);",
          "1053:   }",
          "1054:  }",
          "1055:  mutex_unlock(&dcc->cmd_lock);",
          "",
          "[Added Lines]",
          "1051:  __wait_discard_cmd(sbi, true);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
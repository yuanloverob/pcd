{
  "cve_id": "CVE-2013-4563",
  "cve_desc": "The udp6_ufo_fragment function in net/ipv6/udp_offload.c in the Linux kernel through 3.12, when UDP Fragmentation Offload (UFO) is enabled, does not properly perform a certain size comparison before inserting a fragment header, which allows remote attackers to cause a denial of service (panic) via a large IPv6 UDP packet, as demonstrated by use of the Token Bucket Filter (TBF) queueing discipline.",
  "repo": "torvalds/linux",
  "patch_hash": "0e033e04c2678dbbe74a46b23fffb7bb918c288e",
  "patch_info": {
    "commit_hash": "0e033e04c2678dbbe74a46b23fffb7bb918c288e",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/0e033e04c2678dbbe74a46b23fffb7bb918c288e",
    "files": [
      "net/ipv6/udp_offload.c"
    ],
    "message": "ipv6: fix headroom calculation in udp6_ufo_fragment\n\nCommit 1e2bd517c108816220f262d7954b697af03b5f9c (\"udp6: Fix udp\nfragmentation for tunnel traffic.\") changed the calculation if\nthere is enough space to include a fragment header in the skb from a\nskb->mac_header dervived one to skb_headroom. Because we already peeled\noff the skb to transport_header this is wrong. Change this back to check\nif we have enough room before the mac_header.\n\nThis fixes a panic Saran Neti reported. He used the tbf scheduler which\nskb_gso_segments the skb. The offsets get negative and we panic in memcpy\nbecause the skb was erroneously not expanded at the head.\n\nReported-by: Saran Neti <Saran.Neti@telus.com>\nCc: Pravin B Shelar <pshelar@nicira.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c": [
      "File: net/ipv6/udp_offload.c -> net/ipv6/udp_offload.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "92:   tnl_hlen = skb_tnl_header_len(skb);",
      "94:    if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))",
      "95:     goto out;",
      "96:   }",
      "",
      "[Removed Lines]",
      "93:   if (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {",
      "",
      "[Added Lines]",
      "93:   if (skb->mac_header < (tnl_hlen + frag_hdr_sz)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1e2bd517c108816220f262d7954b697af03b5f9c",
      "candidate_info": {
        "commit_hash": "1e2bd517c108816220f262d7954b697af03b5f9c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/1e2bd517c108816220f262d7954b697af03b5f9c",
        "files": [
          "include/linux/skbuff.h",
          "net/ipv6/udp_offload.c"
        ],
        "message": "udp6: Fix udp fragmentation for tunnel traffic.\n\nudp6 over GRE tunnel does not work after to GRE tso changes. GRE\ntso handler passes inner packet but keeps track of outer header\nstart in SKB_GSO_CB(skb)->mac_offset.  udp6 fragment need to\ntake care of outer header, which start at the mac_offset, while\nadding fragment header.\nThis bug is introduced by commit 68c3316311 (GRE: Add TCP\nsegmentation offload for GRE).\n\nReported-by: Dmitry Kravkov <dkravkov@gmail.com>\nSigned-off-by: Pravin B Shelar <pshelar@nicira.com>\nTested-by: Dmitry Kravkov <dmitry@broadcom.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/skbuff.h||include/linux/skbuff.h",
          "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ],
          "candidate": [
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/skbuff.h||include/linux/skbuff.h": [
          "File: include/linux/skbuff.h -> include/linux/skbuff.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2852:   SKB_GSO_CB(inner_skb)->mac_offset;",
          "2853: }",
          "2855: static inline bool skb_is_gso(const struct sk_buff *skb)",
          "2856: {",
          "2857:  return skb_shinfo(skb)->gso_size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2855: static inline int gso_pskb_expand_head(struct sk_buff *skb, int extra)",
          "2856: {",
          "2857:  int new_headroom, headroom;",
          "2858:  int ret;",
          "2860:  headroom = skb_headroom(skb);",
          "2861:  ret = pskb_expand_head(skb, extra, 0, GFP_ATOMIC);",
          "2862:  if (ret)",
          "2863:   return ret;",
          "2865:  new_headroom = skb_headroom(skb);",
          "2866:  SKB_GSO_CB(skb)->mac_offset += (new_headroom - headroom);",
          "2867:  return 0;",
          "2868: }",
          "",
          "---------------"
        ],
        "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c": [
          "File: net/ipv6/udp_offload.c -> net/ipv6/udp_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46:  unsigned int mss;",
          "47:  unsigned int unfrag_ip6hlen, unfrag_len;",
          "48:  struct frag_hdr *fptr;",
          "50:  u8 nexthdr;",
          "51:  u8 frag_hdr_sz = sizeof(struct frag_hdr);",
          "52:  int offset;",
          "53:  __wsum csum;",
          "55:  mss = skb_shinfo(skb)->gso_size;",
          "56:  if (unlikely(skb->len <= mss))",
          "",
          "[Removed Lines]",
          "49:  u8 *mac_start, *prevhdr;",
          "",
          "[Added Lines]",
          "49:  u8 *packet_start, *prevhdr;",
          "54:  int tnl_hlen;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "83:  skb->ip_summed = CHECKSUM_NONE;",
          "",
          "[Removed Lines]",
          "86:  if ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&",
          "87:      pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))",
          "88:   goto out;",
          "",
          "[Added Lines]",
          "87:  tnl_hlen = skb_tnl_header_len(skb);",
          "88:  if (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {",
          "89:   if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))",
          "90:    goto out;",
          "91:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "93:  unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "94:  nexthdr = *prevhdr;",
          "101:  skb->mac_header -= frag_hdr_sz;",
          "102:  skb->network_header -= frag_hdr_sz;",
          "",
          "[Removed Lines]",
          "96:  unfrag_len = skb_network_header(skb) - skb_mac_header(skb) +",
          "97:        unfrag_ip6hlen;",
          "98:  mac_start = skb_mac_header(skb);",
          "99:  memmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);",
          "",
          "[Added Lines]",
          "99:  unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +",
          "100:        unfrag_ip6hlen + tnl_hlen;",
          "101:  packet_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;",
          "102:  memmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);",
          "104:  SKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d949d826c09fb65e230f55868ff70dc581ec06fa",
      "candidate_info": {
        "commit_hash": "d949d826c09fb65e230f55868ff70dc581ec06fa",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d949d826c09fb65e230f55868ff70dc581ec06fa",
        "files": [
          "net/ipv6/ip6_offload.c",
          "net/ipv6/udp_offload.c"
        ],
        "message": "ipv6: Add generic UDP Tunnel segmentation\n\nSimilar to commit 731362674580cb0c696cd1b1a03d8461a10cf90a\n(tunneling: Add generic Tunnel segmentation)\n\nThis patch adds generic tunneling offloading support for\nIPv6-UDP based tunnels.\n\nThis can be used by tunneling protocols like VXLAN.\n\nCc: Jesse Gross <jesse@nicira.com>\nCc: Pravin B Shelar <pshelar@nicira.com>\nCc: Stephen Hemminger <stephen@networkplumber.org>\nCc: David S. Miller <davem@davemloft.net>\nSigned-off-by: Cong Wang <amwang@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c",
          "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ],
          "candidate": [
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_offload.c||net/ipv6/ip6_offload.c": [
          "File: net/ipv6/ip6_offload.c -> net/ipv6/ip6_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "91:  unsigned int unfrag_ip6hlen;",
          "92:  u8 *prevhdr;",
          "93:  int offset = 0;",
          "95:  if (unlikely(skb_shinfo(skb)->gso_type &",
          "96:        ~(SKB_GSO_UDP |",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:  bool tunnel;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "106:  if (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))",
          "107:   goto out;",
          "109:  ipv6h = ipv6_hdr(skb);",
          "110:  __skb_pull(skb, sizeof(*ipv6h));",
          "111:  segs = ERR_PTR(-EPROTONOSUPPORT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:  tunnel = skb->encapsulation;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:   ipv6h = ipv6_hdr(skb);",
          "127:   ipv6h->payload_len = htons(skb->len - skb->mac_len -",
          "128:         sizeof(*ipv6h));",
          "130:    unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "131:    fptr = (struct frag_hdr *)(skb_network_header(skb) +",
          "132:     unfrag_ip6hlen);",
          "",
          "[Removed Lines]",
          "129:   if (proto == IPPROTO_UDP) {",
          "",
          "[Added Lines]",
          "131:   if (!tunnel && proto == IPPROTO_UDP) {",
          "",
          "---------------"
        ],
        "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c": [
          "File: net/ipv6/udp_offload.c -> net/ipv6/udp_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21:  const struct ipv6hdr *ipv6h;",
          "22:  struct udphdr *uh;",
          "28:  if (!pskb_may_pull(skb, sizeof(*uh)))",
          "29:   return -EINVAL;",
          "39:  return 0;",
          "40: }",
          "42: static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,",
          "44: {",
          "45:  struct sk_buff *segs = ERR_PTR(-EINVAL);",
          "46:  unsigned int mss;",
          "",
          "[Removed Lines]",
          "25:  if (skb->encapsulation)",
          "26:   return -EINVAL;",
          "31:  ipv6h = ipv6_hdr(skb);",
          "32:  uh = udp_hdr(skb);",
          "34:  uh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,",
          "35:          IPPROTO_UDP, 0);",
          "36:  skb->csum_start = skb_transport_header(skb) - skb->head;",
          "37:  skb->csum_offset = offsetof(struct udphdr, check);",
          "38:  skb->ip_summed = CHECKSUM_PARTIAL;",
          "43:  netdev_features_t features)",
          "",
          "[Added Lines]",
          "27:  if (likely(!skb->encapsulation)) {",
          "28:   ipv6h = ipv6_hdr(skb);",
          "29:   uh = udp_hdr(skb);",
          "31:   uh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,",
          "32:           IPPROTO_UDP, 0);",
          "33:   skb->csum_start = skb_transport_header(skb) - skb->head;",
          "34:   skb->csum_offset = offsetof(struct udphdr, check);",
          "35:   skb->ip_summed = CHECKSUM_PARTIAL;",
          "36:  }",
          "41: static struct sk_buff *skb_udp6_tunnel_segment(struct sk_buff *skb,",
          "42:             netdev_features_t features)",
          "43: {",
          "44:  struct sk_buff *segs = ERR_PTR(-EINVAL);",
          "45:  int mac_len = skb->mac_len;",
          "46:  int tnl_hlen = skb_inner_mac_header(skb) - skb_transport_header(skb);",
          "47:  int outer_hlen;",
          "48:  netdev_features_t enc_features;",
          "50:  if (unlikely(!pskb_may_pull(skb, tnl_hlen)))",
          "51:   goto out;",
          "53:  skb->encapsulation = 0;",
          "54:  __skb_pull(skb, tnl_hlen);",
          "55:  skb_reset_mac_header(skb);",
          "56:  skb_set_network_header(skb, skb_inner_network_offset(skb));",
          "57:  skb->mac_len = skb_inner_network_offset(skb);",
          "60:  enc_features = skb->dev->hw_enc_features & netif_skb_features(skb);",
          "61:  segs = skb_mac_gso_segment(skb, enc_features);",
          "62:  if (!segs || IS_ERR(segs))",
          "63:   goto out;",
          "65:  outer_hlen = skb_tnl_header_len(skb);",
          "66:  skb = segs;",
          "67:  do {",
          "68:   struct udphdr *uh;",
          "69:   struct ipv6hdr *ipv6h;",
          "70:   int udp_offset = outer_hlen - tnl_hlen;",
          "71:   u32 len;",
          "73:   skb->mac_len = mac_len;",
          "75:   skb_push(skb, outer_hlen);",
          "76:   skb_reset_mac_header(skb);",
          "77:   skb_set_network_header(skb, mac_len);",
          "78:   skb_set_transport_header(skb, udp_offset);",
          "79:   uh = udp_hdr(skb);",
          "80:   uh->len = htons(skb->len - udp_offset);",
          "81:   ipv6h = ipv6_hdr(skb);",
          "82:   len = skb->len - udp_offset;",
          "84:   uh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr,",
          "85:           len, IPPROTO_UDP, 0);",
          "86:   uh->check = csum_fold(skb_checksum(skb, udp_offset, len, 0));",
          "87:   if (uh->check == 0)",
          "88:    uh->check = CSUM_MANGLED_0;",
          "89:   skb->ip_summed = CHECKSUM_NONE;",
          "90:  } while ((skb = skb->next));",
          "91: out:",
          "92:  return segs;",
          "93: }",
          "96:       netdev_features_t features)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75:   goto out;",
          "76:  }",
          "92:  }",
          "119: out:",
          "120:  return segs;",
          "121: }",
          "",
          "[Removed Lines]",
          "81:  offset = skb_checksum_start_offset(skb);",
          "82:  csum = skb_checksum(skb, offset, skb->len - offset, 0);",
          "83:  offset += skb->csum_offset;",
          "85:  skb->ip_summed = CHECKSUM_NONE;",
          "88:  tnl_hlen = skb_tnl_header_len(skb);",
          "89:  if (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {",
          "90:   if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))",
          "91:    goto out;",
          "97:  unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "98:  nexthdr = *prevhdr;",
          "100:  unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +",
          "101:        unfrag_ip6hlen + tnl_hlen;",
          "102:  packet_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;",
          "103:  memmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);",
          "105:  SKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;",
          "106:  skb->mac_header -= frag_hdr_sz;",
          "107:  skb->network_header -= frag_hdr_sz;",
          "109:  fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);",
          "110:  fptr->nexthdr = nexthdr;",
          "111:  fptr->reserved = 0;",
          "112:  ipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));",
          "117:  segs = skb_segment(skb, features);",
          "",
          "[Added Lines]",
          "131:  if (skb->encapsulation && skb_shinfo(skb)->gso_type & SKB_GSO_UDP_TUNNEL)",
          "132:   segs = skb_udp6_tunnel_segment(skb, features);",
          "133:  else {",
          "137:   offset = skb_checksum_start_offset(skb);",
          "138:   csum = skb_checksum(skb, offset, skb->len - offset, 0);",
          "139:   offset += skb->csum_offset;",
          "141:   skb->ip_summed = CHECKSUM_NONE;",
          "144:   tnl_hlen = skb_tnl_header_len(skb);",
          "145:   if (skb_headroom(skb) < (tnl_hlen + frag_hdr_sz)) {",
          "146:    if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz))",
          "147:     goto out;",
          "148:   }",
          "153:   unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "154:   nexthdr = *prevhdr;",
          "156:   unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) +",
          "157:         unfrag_ip6hlen + tnl_hlen;",
          "158:   packet_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset;",
          "159:   memmove(packet_start-frag_hdr_sz, packet_start, unfrag_len);",
          "161:   SKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz;",
          "162:   skb->mac_header -= frag_hdr_sz;",
          "163:   skb->network_header -= frag_hdr_sz;",
          "165:   fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);",
          "166:   fptr->nexthdr = nexthdr;",
          "167:   fptr->reserved = 0;",
          "168:   ipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));",
          "173:   segs = skb_segment(skb, features);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5edbb07dc9474b7d4cd4391a2e6551ad067a0f96",
      "candidate_info": {
        "commit_hash": "5edbb07dc9474b7d4cd4391a2e6551ad067a0f96",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5edbb07dc9474b7d4cd4391a2e6551ad067a0f96",
        "files": [
          "net/ipv6/Makefile",
          "net/ipv6/ip6_offload.h",
          "net/ipv6/udp.c",
          "net/ipv6/udp_offload.c"
        ],
        "message": "ipv6: Separate out UDP offload functionality\n\nPull UDP GSO code into a separate file in preparation for moving\nthe code out of the module.\n\nSigned-off-by: Vlad Yasevich <vyasevic@redhat.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/ipv6/ip6_offload.h||net/ipv6/ip6_offload.h",
          "net/ipv6/udp.c||net/ipv6/udp.c",
          "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ],
          "candidate": [
            "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c"
          ]
        }
      },
      "candidate_diff": {
        "net/ipv6/ip6_offload.h||net/ipv6/ip6_offload.h": [
          "File: net/ipv6/ip6_offload.h -> net/ipv6/ip6_offload.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: #ifndef __ip6_offload_h",
          "12: #define __ip6_offload_h",
          "14: int tcpv6_offload_init(void);",
          "15: void tcpv6_offload_cleanup(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: int udp_offload_init(void);",
          "15: void udp_offload_cleanup(void);",
          "",
          "---------------"
        ],
        "net/ipv6/udp.c||net/ipv6/udp.c": [
          "File: net/ipv6/udp.c -> net/ipv6/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "50: #include <linux/seq_file.h>",
          "51: #include <trace/events/skb.h>",
          "52: #include \"udp_impl.h\"",
          "54: int ipv6_rcv_saddr_equal(const struct sock *sk, const struct sock *sk2)",
          "55: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "53: #include \"ip6_offload.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1343: }",
          "1344: #endif",
          "1438: static const struct inet6_protocol udpv6_protocol = {",
          "1439:  .handler = udpv6_rcv,",
          "1440:  .err_handler = udpv6_err,",
          "1441:  .flags  = INET6_PROTO_NOPOLICY|INET6_PROTO_FINAL,",
          "1442: };",
          "1450: #ifdef CONFIG_PROC_FS",
          "",
          "[Removed Lines]",
          "1346: static int udp6_ufo_send_check(struct sk_buff *skb)",
          "1347: {",
          "1348:  const struct ipv6hdr *ipv6h;",
          "1349:  struct udphdr *uh;",
          "1351:  if (!pskb_may_pull(skb, sizeof(*uh)))",
          "1352:   return -EINVAL;",
          "1354:  ipv6h = ipv6_hdr(skb);",
          "1355:  uh = udp_hdr(skb);",
          "1357:  uh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,",
          "1358:          IPPROTO_UDP, 0);",
          "1359:  skb->csum_start = skb_transport_header(skb) - skb->head;",
          "1360:  skb->csum_offset = offsetof(struct udphdr, check);",
          "1361:  skb->ip_summed = CHECKSUM_PARTIAL;",
          "1362:  return 0;",
          "1363: }",
          "1365: static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,",
          "1366:  netdev_features_t features)",
          "1367: {",
          "1368:  struct sk_buff *segs = ERR_PTR(-EINVAL);",
          "1369:  unsigned int mss;",
          "1370:  unsigned int unfrag_ip6hlen, unfrag_len;",
          "1371:  struct frag_hdr *fptr;",
          "1372:  u8 *mac_start, *prevhdr;",
          "1373:  u8 nexthdr;",
          "1374:  u8 frag_hdr_sz = sizeof(struct frag_hdr);",
          "1375:  int offset;",
          "1376:  __wsum csum;",
          "1378:  mss = skb_shinfo(skb)->gso_size;",
          "1379:  if (unlikely(skb->len <= mss))",
          "1380:   goto out;",
          "1382:  if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {",
          "1384:   int type = skb_shinfo(skb)->gso_type;",
          "1386:   if (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||",
          "1387:         !(type & (SKB_GSO_UDP))))",
          "1388:    goto out;",
          "1390:   skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);",
          "1392:   segs = NULL;",
          "1393:   goto out;",
          "1394:  }",
          "1399:  offset = skb_checksum_start_offset(skb);",
          "1400:  csum = skb_checksum(skb, offset, skb->len - offset, 0);",
          "1401:  offset += skb->csum_offset;",
          "1403:  skb->ip_summed = CHECKSUM_NONE;",
          "1406:  if ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&",
          "1407:      pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))",
          "1408:   goto out;",
          "1413:  unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "1414:  nexthdr = *prevhdr;",
          "1416:  unfrag_len = skb_network_header(skb) - skb_mac_header(skb) +",
          "1417:        unfrag_ip6hlen;",
          "1418:  mac_start = skb_mac_header(skb);",
          "1419:  memmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);",
          "1421:  skb->mac_header -= frag_hdr_sz;",
          "1422:  skb->network_header -= frag_hdr_sz;",
          "1424:  fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);",
          "1425:  fptr->nexthdr = nexthdr;",
          "1426:  fptr->reserved = 0;",
          "1427:  ipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));",
          "1432:  segs = skb_segment(skb, features);",
          "1434: out:",
          "1435:  return segs;",
          "1436: }",
          "1444: static const struct net_offload udpv6_offload = {",
          "1445:  .gso_send_check = udp6_ufo_send_check,",
          "1446:  .gso_segment = udp6_ufo_fragment,",
          "1447: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1568: {",
          "1569:  int ret;",
          "1572:  if (ret)",
          "1573:   goto out;",
          "",
          "[Removed Lines]",
          "1571:  ret = inet6_add_offload(&udpv6_offload, IPPROTO_UDP);",
          "",
          "[Added Lines]",
          "1475:  ret = udp_offload_init();",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1585: out_udpv6_protocol:",
          "1586:  inet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);",
          "1587: out_offload:",
          "1589:  goto out;",
          "1590: }",
          "",
          "[Removed Lines]",
          "1588:  inet6_del_offload(&udpv6_offload, IPPROTO_UDP);",
          "",
          "[Added Lines]",
          "1492:  udp_offload_cleanup();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1593: {",
          "1594:  inet6_unregister_protosw(&udpv6_protosw);",
          "1595:  inet6_del_protocol(&udpv6_protocol, IPPROTO_UDP);",
          "1597: }",
          "",
          "[Removed Lines]",
          "1596:  inet6_del_offload(&udpv6_offload, IPPROTO_UDP);",
          "",
          "[Added Lines]",
          "1500:  udp_offload_cleanup();",
          "",
          "---------------"
        ],
        "net/ipv6/udp_offload.c||net/ipv6/udp_offload.c": [
          "File: net/ipv6/udp_offload.c -> net/ipv6/udp_offload.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: #include <linux/skbuff.h>",
          "13: #include <net/protocol.h>",
          "14: #include <net/ipv6.h>",
          "15: #include <net/udp.h>",
          "16: #include \"ip6_offload.h\"",
          "18: static int udp6_ufo_send_check(struct sk_buff *skb)",
          "19: {",
          "20:  const struct ipv6hdr *ipv6h;",
          "21:  struct udphdr *uh;",
          "23:  if (!pskb_may_pull(skb, sizeof(*uh)))",
          "24:   return -EINVAL;",
          "26:  ipv6h = ipv6_hdr(skb);",
          "27:  uh = udp_hdr(skb);",
          "29:  uh->check = ~csum_ipv6_magic(&ipv6h->saddr, &ipv6h->daddr, skb->len,",
          "30:          IPPROTO_UDP, 0);",
          "31:  skb->csum_start = skb_transport_header(skb) - skb->head;",
          "32:  skb->csum_offset = offsetof(struct udphdr, check);",
          "33:  skb->ip_summed = CHECKSUM_PARTIAL;",
          "34:  return 0;",
          "35: }",
          "37: static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,",
          "38:  netdev_features_t features)",
          "39: {",
          "40:  struct sk_buff *segs = ERR_PTR(-EINVAL);",
          "41:  unsigned int mss;",
          "42:  unsigned int unfrag_ip6hlen, unfrag_len;",
          "43:  struct frag_hdr *fptr;",
          "44:  u8 *mac_start, *prevhdr;",
          "45:  u8 nexthdr;",
          "46:  u8 frag_hdr_sz = sizeof(struct frag_hdr);",
          "47:  int offset;",
          "48:  __wsum csum;",
          "50:  mss = skb_shinfo(skb)->gso_size;",
          "51:  if (unlikely(skb->len <= mss))",
          "52:   goto out;",
          "54:  if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {",
          "56:   int type = skb_shinfo(skb)->gso_type;",
          "58:   if (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||",
          "59:         !(type & (SKB_GSO_UDP))))",
          "60:    goto out;",
          "62:   skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);",
          "64:   segs = NULL;",
          "65:   goto out;",
          "66:  }",
          "71:  offset = skb_checksum_start_offset(skb);",
          "72:  csum = skb_checksum(skb, offset, skb->len - offset, 0);",
          "73:  offset += skb->csum_offset;",
          "75:  skb->ip_summed = CHECKSUM_NONE;",
          "78:  if ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&",
          "79:      pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))",
          "80:   goto out;",
          "85:  unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);",
          "86:  nexthdr = *prevhdr;",
          "88:  unfrag_len = skb_network_header(skb) - skb_mac_header(skb) +",
          "89:        unfrag_ip6hlen;",
          "90:  mac_start = skb_mac_header(skb);",
          "91:  memmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);",
          "93:  skb->mac_header -= frag_hdr_sz;",
          "94:  skb->network_header -= frag_hdr_sz;",
          "96:  fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);",
          "97:  fptr->nexthdr = nexthdr;",
          "98:  fptr->reserved = 0;",
          "99:  ipv6_select_ident(fptr, (struct rt6_info *)skb_dst(skb));",
          "104:  segs = skb_segment(skb, features);",
          "106: out:",
          "107:  return segs;",
          "108: }",
          "109: static const struct net_offload udpv6_offload = {",
          "110:  .gso_send_check = udp6_ufo_send_check,",
          "111:  .gso_segment = udp6_ufo_fragment,",
          "112: };",
          "114: int __init udp_offload_init(void)",
          "115: {",
          "116:  return inet6_add_offload(&udpv6_offload, IPPROTO_UDP);",
          "117: }",
          "119: void udp_offload_cleanup(void)",
          "120: {",
          "121:  inet6_del_offload(&udpv6_offload, IPPROTO_UDP);",
          "122: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
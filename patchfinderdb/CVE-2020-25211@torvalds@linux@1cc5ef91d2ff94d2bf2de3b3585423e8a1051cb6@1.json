{
  "cve_id": "CVE-2020-25211",
  "cve_desc": "In the Linux kernel through 5.8.7, local attackers able to inject conntrack netlink configuration could overflow a local buffer, causing crashes or triggering use of incorrect protocol numbers in ctnetlink_parse_tuple_filter in net/netfilter/nf_conntrack_netlink.c, aka CID-1cc5ef91d2ff.",
  "repo": "torvalds/linux",
  "patch_hash": "1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
  "patch_info": {
    "commit_hash": "1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/1cc5ef91d2ff94d2bf2de3b3585423e8a1051cb6",
    "files": [
      "net/netfilter/nf_conntrack_netlink.c"
    ],
    "message": "netfilter: ctnetlink: add a range check for l3/l4 protonum\n\nThe indexes to the nf_nat_l[34]protos arrays come from userspace. So\ncheck the tuple's family, e.g. l3num, when creating the conntrack in\norder to prevent an OOB memory access during setup.  Here is an example\nkernel panic on 4.14.180 when userspace passes in an index greater than\nNFPROTO_NUMPROTO.\n\nInternal error: Oops - BUG: 0 [#1] PREEMPT SMP\nModules linked in:...\nProcess poc (pid: 5614, stack limit = 0x00000000a3933121)\nCPU: 4 PID: 5614 Comm: poc Tainted: G S      W  O    4.14.180-g051355490483\nHardware name: Qualcomm Technologies, Inc. SM8150 V2 PM8150 Google Inc. MSM\ntask: 000000002a3dfffe task.stack: 00000000a3933121\npc : __cfi_check_fail+0x1c/0x24\nlr : __cfi_check_fail+0x1c/0x24\n...\nCall trace:\n__cfi_check_fail+0x1c/0x24\nname_to_dev_t+0x0/0x468\nnfnetlink_parse_nat_setup+0x234/0x258\nctnetlink_parse_nat_setup+0x4c/0x228\nctnetlink_new_conntrack+0x590/0xc40\nnfnetlink_rcv_msg+0x31c/0x4d4\nnetlink_rcv_skb+0x100/0x184\nnfnetlink_rcv+0xf4/0x180\nnetlink_unicast+0x360/0x770\nnetlink_sendmsg+0x5a0/0x6a4\n___sys_sendmsg+0x314/0x46c\nSyS_sendmsg+0xb4/0x108\nel0_svc_naked+0x34/0x38\n\nThis crash is not happening since 5.4+, however, ctnetlink still\nallows for creating entries with unsupported layer 3 protocol number.\n\nFixes: c1d10adb4a521 (\"[NETFILTER]: Add ctnetlink port for nf_conntrack\")\nSigned-off-by: Will McVicker <willmcvicker@google.com>\n[pablo@netfilter.org: rebased original patch on top of nf.git]\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
    "before_after_code_files": [
      "net/netfilter/nf_conntrack_netlink.c||net/netfilter/nf_conntrack_netlink.c"
    ]
  },
  "patch_diff": {
    "net/netfilter/nf_conntrack_netlink.c||net/netfilter/nf_conntrack_netlink.c": [
      "File: net/netfilter/nf_conntrack_netlink.c -> net/netfilter/nf_conntrack_netlink.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1404:  if (err < 0)",
      "1405:   return err;",
      "1408:  tuple->src.l3num = l3num;",
      "1410:  if (flags & CTA_FILTER_FLAG(CTA_IP_DST) ||",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1407:  if (l3num != NFPROTO_IPV4 && l3num != NFPROTO_IPV6)",
      "1408:   return -EOPNOTSUPP;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9179ba31367bcf481c3c79b5f028c94faad9f30a",
      "candidate_info": {
        "commit_hash": "9179ba31367bcf481c3c79b5f028c94faad9f30a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9179ba31367bcf481c3c79b5f028c94faad9f30a",
        "files": [
          "drivers/net/wireguard/noise.c"
        ],
        "message": "wireguard: noise: take lock when removing handshake entry from table\n\nEric reported that syzkaller found a race of this variety:\n\nCPU 1                                       CPU 2\n-------------------------------------------|---------------------------------------\nwg_index_hashtable_replace(old, ...)       |\n  if (hlist_unhashed(&old->index_hash))    |\n                                           | wg_index_hashtable_remove(old)\n                                           |   hlist_del_init_rcu(&old->index_hash)\n\t\t\t\t           |     old->index_hash.pprev = NULL\n  hlist_replace_rcu(&old->index_hash, ...) |\n    *old->index_hash.pprev                 |\n\nSyzbot wasn't actually able to reproduce this more than once or create a\nreproducer, because the race window between checking \"hlist_unhashed\" and\ncalling \"hlist_replace_rcu\" is just so small. Adding an mdelay(5) or\nsimilar there helps make this demonstrable using this simple script:\n\n    #!/bin/bash\n    set -ex\n    trap 'kill $pid1; kill $pid2; ip link del wg0; ip link del wg1' EXIT\n    ip link add wg0 type wireguard\n    ip link add wg1 type wireguard\n    wg set wg0 private-key <(wg genkey) listen-port 9999\n    wg set wg1 private-key <(wg genkey) peer $(wg show wg0 public-key) endpoint 127.0.0.1:9999 persistent-keepalive 1\n    wg set wg0 peer $(wg show wg1 public-key)\n    ip link set wg0 up\n    yes link set wg1 up | ip -force -batch - &\n    pid1=$!\n    yes link set wg1 down | ip -force -batch - &\n    pid2=$!\n    wait\n\nThe fundumental underlying problem is that we permit calls to wg_index_\nhashtable_remove(handshake.entry) without requiring the caller to take\nthe handshake mutex that is intended to protect members of handshake\nduring mutations. This is consistently the case with calls to wg_index_\nhashtable_insert(handshake.entry) and wg_index_hashtable_replace(\nhandshake.entry), but it's missing from a pertinent callsite of wg_\nindex_hashtable_remove(handshake.entry). So, this patch makes sure that\nmutex is taken.\n\nThe original code was a little bit funky though, in the form of:\n\n    remove(handshake.entry)\n    lock(), memzero(handshake.some_members), unlock()\n    remove(handshake.entry)\n\nThe original intention of that double removal pattern outside the lock\nappears to be some attempt to prevent insertions that might happen while\nlocks are dropped during expensive crypto operations, but actually, all\ncallers of wg_index_hashtable_insert(handshake.entry) take the write\nlock and then explicitly check handshake.state, as they should, which\nthe aforementioned memzero clears, which means an insertion should\nalready be impossible. And regardless, the original intention was\nnecessarily racy, since it wasn't guaranteed that something else would\nrun after the unlock() instead of after the remove(). So, from a\nsoundness perspective, it seems positive to remove what looks like a\nhack at best.\n\nThe crash from both syzbot and from the script above is as follows:\n\n  general protection fault, probably for non-canonical address 0xdffffc0000000000: 0000 [#1] PREEMPT SMP KASAN\n  KASAN: null-ptr-deref in range [0x0000000000000000-0x0000000000000007]\n  CPU: 0 PID: 7395 Comm: kworker/0:3 Not tainted 5.9.0-rc4-syzkaller #0\n  Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\n  Workqueue: wg-kex-wg1 wg_packet_handshake_receive_worker\n  RIP: 0010:hlist_replace_rcu include/linux/rculist.h:505 [inline]\n  RIP: 0010:wg_index_hashtable_replace+0x176/0x330 drivers/net/wireguard/peerlookup.c:174\n  Code: 00 fc ff df 48 89 f9 48 c1 e9 03 80 3c 01 00 0f 85 44 01 00 00 48 b9 00 00 00 00 00 fc ff df 48 8b 45 10 48 89 c6 48 c1 ee 03 <80> 3c 0e 00 0f 85 06 01 00 00 48 85 d2 4c 89 28 74 47 e8 a3 4f b5\n  RSP: 0018:ffffc90006a97bf8 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffff888050ffc4f8 RCX: dffffc0000000000\n  RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffff88808e04e010\n  RBP: ffff88808e04e000 R08: 0000000000000001 R09: ffff8880543d0000\n  R10: ffffed100a87a000 R11: 000000000000016e R12: ffff8880543d0000\n  R13: ffff88808e04e008 R14: ffff888050ffc508 R15: ffff888050ffc500\n  FS:  0000000000000000(0000) GS:ffff8880ae600000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: 00000000f5505db0 CR3: 0000000097cf7000 CR4: 00000000001526f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n  wg_noise_handshake_begin_session+0x752/0xc9a drivers/net/wireguard/noise.c:820\n  wg_receive_handshake_packet drivers/net/wireguard/receive.c:183 [inline]\n  wg_packet_handshake_receive_worker+0x33b/0x730 drivers/net/wireguard/receive.c:220\n  process_one_work+0x94c/0x1670 kernel/workqueue.c:2269\n  worker_thread+0x64c/0x1120 kernel/workqueue.c:2415\n  kthread+0x3b5/0x4a0 kernel/kthread.c:292\n  ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:294\n\nReported-by: syzbot <syzkaller@googlegroups.com>\nReported-by: Eric Dumazet <edumazet@google.com>\nLink: https://lore.kernel.org/wireguard/20200908145911.4090480-1-edumazet@google.com/\nFixes: e7096c131e51 (\"net: WireGuard secure network tunnel\")\nSigned-off-by: Jason A. Donenfeld <Jason@zx2c4.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/wireguard/noise.c||drivers/net/wireguard/noise.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireguard/noise.c||drivers/net/wireguard/noise.c": [
          "File: drivers/net/wireguard/noise.c -> drivers/net/wireguard/noise.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "88: void wg_noise_handshake_clear(struct noise_handshake *handshake)",
          "89: {",
          "90:  wg_index_hashtable_remove(",
          "91:    handshake->entry.peer->device->index_hashtable,",
          "92:    &handshake->entry);",
          "94:  handshake_zero(handshake);",
          "95:  up_write(&handshake->lock);",
          "99: }",
          "101: static struct noise_keypair *keypair_create(struct wg_peer *peer)",
          "",
          "[Removed Lines]",
          "93:  down_write(&handshake->lock);",
          "96:  wg_index_hashtable_remove(",
          "97:    handshake->entry.peer->device->index_hashtable,",
          "98:    &handshake->entry);",
          "",
          "[Added Lines]",
          "90:  down_write(&handshake->lock);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2d892ccdc163a3d2e08c5ed1cea8b61bf7e4f531",
      "candidate_info": {
        "commit_hash": "2d892ccdc163a3d2e08c5ed1cea8b61bf7e4f531",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2d892ccdc163a3d2e08c5ed1cea8b61bf7e4f531",
        "files": [
          "fs/btrfs/transaction.c"
        ],
        "message": "btrfs: fix NULL pointer dereference after failure to create snapshot\n\nWhen trying to get a new fs root for a snapshot during the transaction\nat transaction.c:create_pending_snapshot(), if btrfs_get_new_fs_root()\nfails we leave \"pending->snap\" pointing to an error pointer, and then\nlater at ioctl.c:create_snapshot() we dereference that pointer, resulting\nin a crash:\n\n  [12264.614689] BUG: kernel NULL pointer dereference, address: 00000000000007c4\n  [12264.615650] #PF: supervisor write access in kernel mode\n  [12264.616487] #PF: error_code(0x0002) - not-present page\n  [12264.617436] PGD 0 P4D 0\n  [12264.618328] Oops: 0002 [#1] PREEMPT SMP DEBUG_PAGEALLOC PTI\n  [12264.619150] CPU: 0 PID: 2310635 Comm: fsstress Tainted: G        W         5.9.0-rc3-btrfs-next-67 #1\n  [12264.619960] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n  [12264.621769] RIP: 0010:btrfs_mksubvol+0x438/0x4a0 [btrfs]\n  [12264.622528] Code: bc ef ff ff (...)\n  [12264.624092] RSP: 0018:ffffaa6fc7277cd8 EFLAGS: 00010282\n  [12264.624669] RAX: 00000000fffffff4 RBX: ffff9d3e8f151a60 RCX: 0000000000000000\n  [12264.625249] RDX: 0000000000000001 RSI: ffffffff9d56c9be RDI: fffffffffffffff4\n  [12264.625830] RBP: ffff9d3e8f151b48 R08: 0000000000000000 R09: 0000000000000000\n  [12264.626413] R10: 0000000000000000 R11: 0000000000000000 R12: 00000000fffffff4\n  [12264.626994] R13: ffff9d3ede380538 R14: ffff9d3ede380500 R15: ffff9d3f61b2eeb8\n  [12264.627582] FS:  00007f140d5d8200(0000) GS:ffff9d3fb5e00000(0000) knlGS:0000000000000000\n  [12264.628176] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [12264.628773] CR2: 00000000000007c4 CR3: 000000020f8e8004 CR4: 00000000003706f0\n  [12264.629379] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  [12264.629994] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  [12264.630594] Call Trace:\n  [12264.631227]  btrfs_mksnapshot+0x7b/0xb0 [btrfs]\n  [12264.631840]  __btrfs_ioctl_snap_create+0x16f/0x1a0 [btrfs]\n  [12264.632458]  btrfs_ioctl_snap_create_v2+0xb0/0xf0 [btrfs]\n  [12264.633078]  btrfs_ioctl+0x1864/0x3130 [btrfs]\n  [12264.633689]  ? do_sys_openat2+0x1a7/0x2d0\n  [12264.634295]  ? kmem_cache_free+0x147/0x3a0\n  [12264.634899]  ? __x64_sys_ioctl+0x83/0xb0\n  [12264.635488]  __x64_sys_ioctl+0x83/0xb0\n  [12264.636058]  do_syscall_64+0x33/0x80\n  [12264.636616]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n  (gdb) list *(btrfs_mksubvol+0x438)\n  0x7c7b8 is in btrfs_mksubvol (fs/btrfs/ioctl.c:858).\n  853\t\tret = 0;\n  854\t\tpending_snapshot->anon_dev = 0;\n  855\tfail:\n  856\t\t/* Prevent double freeing of anon_dev */\n  857\t\tif (ret && pending_snapshot->snap)\n  858\t\t\tpending_snapshot->snap->anon_dev = 0;\n  859\t\tbtrfs_put_root(pending_snapshot->snap);\n  860\t\tbtrfs_subvolume_release_metadata(root, &pending_snapshot->block_rsv);\n  861\tfree_pending:\n  862\t\tif (pending_snapshot->anon_dev)\n\nSo fix this by setting \"pending->snap\" to NULL if we get an error from the\ncall to btrfs_get_new_fs_root() at transaction.c:create_pending_snapshot().\n\nFixes: 2dfb1e43f57dd3 (\"btrfs: preallocate anon block device at first phase of snapshot creation\")\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/transaction.c||fs/btrfs/transaction.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/transaction.c||fs/btrfs/transaction.c": [
          "File: fs/btrfs/transaction.c -> fs/btrfs/transaction.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1636:  pending->snap = btrfs_get_new_fs_root(fs_info, objectid, pending->anon_dev);",
          "1637:  if (IS_ERR(pending->snap)) {",
          "1638:   ret = PTR_ERR(pending->snap);",
          "1639:   btrfs_abort_transaction(trans, ret);",
          "1640:   goto fail;",
          "1641:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1639:   pending->snap = NULL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2d33b7d631d9dc81c78bb71368645cf7f0e68cb1",
      "candidate_info": {
        "commit_hash": "2d33b7d631d9dc81c78bb71368645cf7f0e68cb1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2d33b7d631d9dc81c78bb71368645cf7f0e68cb1",
        "files": [
          "drivers/iommu/intel/iommu.c"
        ],
        "message": "iommu/vt-d: Fix NULL pointer dereference in dev_iommu_priv_set()\n\nThe dev_iommu_priv_set() must be called after probe_device(). This fixes\na NULL pointer deference bug when booting a system with kernel cmdline\n\"intel_iommu=on,igfx_off\", where the dev_iommu_priv_set() is abused.\n\nThe following stacktrace was produced:\n\n Command line: BOOT_IMAGE=/isolinux/bzImage console=tty1 intel_iommu=on,igfx_off\n ...\n DMAR: Host address width 39\n DMAR: DRHD base: 0x000000fed90000 flags: 0x0\n DMAR: dmar0: reg_base_addr fed90000 ver 1:0 cap 1c0000c40660462 ecap 19e2ff0505e\n DMAR: DRHD base: 0x000000fed91000 flags: 0x1\n DMAR: dmar1: reg_base_addr fed91000 ver 1:0 cap d2008c40660462 ecap f050da\n DMAR: RMRR base: 0x0000009aa9f000 end: 0x0000009aabefff\n DMAR: RMRR base: 0x0000009d000000 end: 0x0000009f7fffff\n DMAR: No ATSR found\n BUG: kernel NULL pointer dereference, address: 0000000000000038\n #PF: supervisor write access in kernel mode\n #PF: error_code(0x0002) - not-present page\n PGD 0 P4D 0\n Oops: 0002 [#1] SMP PTI\n CPU: 1 PID: 1 Comm: swapper/0 Not tainted 5.9.0-devel+ #2\n Hardware name: LENOVO 20HGS0TW00/20HGS0TW00, BIOS N1WET46S (1.25s ) 03/30/2018\n RIP: 0010:intel_iommu_init+0xed0/0x1136\n Code: fe e9 61 02 00 00 bb f4 ff ff ff e9 57 02 00 00 48 63 d1 48 c1 e2 04 48\n       03 50 20 48 8b 12 48 85 d2 74 0b 48 8b 92 d0 02 00 00 48 89 7a 38 ff c1\n       e9 15 f5 ff ff 48 c7 c7 60 99 ac a7 49 c7 c7 a0\n RSP: 0000:ffff96d180073dd0 EFLAGS: 00010282\n RAX: ffff8c91037a7d20 RBX: 0000000000000000 RCX: 0000000000000000\n RDX: 0000000000000000 RSI: 0000000000000000 RDI: ffffffffffffffff\n RBP: ffff96d180073e90 R08: 0000000000000001 R09: ffff8c91039fe3c0\n R10: 0000000000000226 R11: 0000000000000226 R12: 000000000000000b\n R13: ffff8c910367c650 R14: ffffffffa8426d60 R15: 0000000000000000\n FS:  0000000000000000(0000) GS:ffff8c9107480000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: 0000000000000038 CR3: 00000004b100a001 CR4: 00000000003706e0\n Call Trace:\n  ? _raw_spin_unlock_irqrestore+0x1f/0x30\n  ? call_rcu+0x10e/0x320\n  ? trace_hardirqs_on+0x2c/0xd0\n  ? rdinit_setup+0x2c/0x2c\n  ? e820__memblock_setup+0x8b/0x8b\n  pci_iommu_init+0x16/0x3f\n  do_one_initcall+0x46/0x1e4\n  kernel_init_freeable+0x169/0x1b2\n  ? rest_init+0x9f/0x9f\n  kernel_init+0xa/0x101\n  ret_from_fork+0x22/0x30\n Modules linked in:\n CR2: 0000000000000038\n ---[ end trace 3653722a6f936f18 ]---\n\nFixes: 01b9d4e21148c (\"iommu/vt-d: Use dev_iommu_priv_get/set()\")\nReported-by: Torsten Hilbrich <torsten.hilbrich@secunet.com>\nReported-by: Wendy Wang <wendy.wang@intel.com>\nSigned-off-by: Lu Baolu <baolu.lu@linux.intel.com>\nTested-by: Torsten Hilbrich <torsten.hilbrich@secunet.com>\nLink: https://lore.kernel.org/linux-iommu/96717683-70be-7388-3d2f-61131070a96a@secunet.com/\nLink: https://lore.kernel.org/r/20200903065132.16879-1-baolu.lu@linux.intel.com\nSigned-off-by: Joerg Roedel <jroedel@suse.de>",
        "before_after_code_files": [
          "drivers/iommu/intel/iommu.c||drivers/iommu/intel/iommu.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/iommu/intel/iommu.c||drivers/iommu/intel/iommu.c": [
          "File: drivers/iommu/intel/iommu.c -> drivers/iommu/intel/iommu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "364: int intel_iommu_gfx_mapped;",
          "365: EXPORT_SYMBOL_GPL(intel_iommu_gfx_mapped);",
          "368: #define DEFER_DEVICE_DOMAIN_INFO ((struct device_domain_info *)(-2))",
          "369: struct device_domain_info *get_domain_info(struct device *dev)",
          "370: {",
          "",
          "[Removed Lines]",
          "367: #define DUMMY_DEVICE_DOMAIN_INFO ((struct device_domain_info *)(-1))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "374:   return NULL;",
          "376:  info = dev_iommu_priv_get(dev);",
          "379:   return NULL;",
          "381:  return info;",
          "",
          "[Removed Lines]",
          "377:  if (unlikely(info == DUMMY_DEVICE_DOMAIN_INFO ||",
          "378:        info == DEFER_DEVICE_DOMAIN_INFO))",
          "",
          "[Added Lines]",
          "376:  if (unlikely(info == DEFER_DEVICE_DOMAIN_INFO))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "742:  return &context[devfn];",
          "743: }",
          "750: static bool attach_deferred(struct device *dev)",
          "751: {",
          "752:  return dev_iommu_priv_get(dev) == DEFER_DEVICE_DOMAIN_INFO;",
          "",
          "[Removed Lines]",
          "745: static int iommu_dummy(struct device *dev)",
          "746: {",
          "747:  return dev_iommu_priv_get(dev) == DUMMY_DEVICE_DOMAIN_INFO;",
          "748: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "779:  return false;",
          "780: }",
          "782: struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devfn)",
          "783: {",
          "784:  struct dmar_drhd_unit *drhd = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "775: static bool quirk_ioat_snb_local_iommu(struct pci_dev *pdev)",
          "776: {",
          "777:  struct dmar_drhd_unit *drhd;",
          "778:  u32 vtbar;",
          "779:  int rc;",
          "786:  rc = pci_bus_read_config_dword(pdev->bus, PCI_DEVFN(0, 0), 0xb0, &vtbar);",
          "787:  if (rc) {",
          "789:   dev_info(&pdev->dev, \"failed to run vt-d quirk\\n\");",
          "790:   return false;",
          "791:  }",
          "792:  vtbar &= 0xffff0000;",
          "795:  drhd = dmar_find_matched_drhd_unit(pdev);",
          "796:  if (!drhd || drhd->reg_base_addr - vtbar != 0xa000) {",
          "797:   pr_warn_once(FW_BUG \"BIOS assigned incorrect VT-d unit for Intel(R) QuickData Technology device\\n\");",
          "798:   add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);",
          "799:   return true;",
          "800:  }",
          "802:  return false;",
          "803: }",
          "805: static bool iommu_is_dummy(struct intel_iommu *iommu, struct device *dev)",
          "806: {",
          "807:  if (!iommu || iommu->drhd->ignored)",
          "808:   return true;",
          "810:  if (dev_is_pci(dev)) {",
          "811:   struct pci_dev *pdev = to_pci_dev(dev);",
          "813:   if (pdev->vendor == PCI_VENDOR_ID_INTEL &&",
          "814:       pdev->device == PCI_DEVICE_ID_INTEL_IOAT_SNB &&",
          "815:       quirk_ioat_snb_local_iommu(pdev))",
          "816:    return true;",
          "817:  }",
          "819:  return false;",
          "820: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "788:  u16 segment = 0;",
          "789:  int i;",
          "792:   return NULL;",
          "794:  if (dev_is_pci(dev)) {",
          "",
          "[Removed Lines]",
          "791:  if (!dev || iommu_dummy(dev))",
          "",
          "[Added Lines]",
          "831:  if (!dev)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "805:   dev = &ACPI_COMPANION(dev)->dev;",
          "807:  rcu_read_lock();",
          "809:   if (pdev && segment != drhd->segment)",
          "810:    continue;",
          "",
          "[Removed Lines]",
          "808:  for_each_active_iommu(iommu, drhd) {",
          "",
          "[Added Lines]",
          "848:  for_each_iommu(iommu, drhd) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "841:  }",
          "842:  iommu = NULL;",
          "843:  out:",
          "844:  rcu_read_unlock();",
          "846:  return iommu;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "884:  if (iommu_is_dummy(iommu, dev))",
          "885:   iommu = NULL;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2447: {",
          "2448:  struct device_domain_info *info;",
          "2451:   return NULL;",
          "",
          "[Removed Lines]",
          "2450:  if (unlikely(attach_deferred(dev) || iommu_dummy(dev)))",
          "",
          "[Added Lines]",
          "2493:  if (unlikely(attach_deferred(dev)))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "3989:  iova_cache_put();",
          "3990: }",
          "4021: static void __init init_no_remapping_devices(void)",
          "4022: {",
          "4023:  struct dmar_drhd_unit *drhd;",
          "",
          "[Removed Lines]",
          "3992: static void quirk_ioat_snb_local_iommu(struct pci_dev *pdev)",
          "3993: {",
          "3994:  struct dmar_drhd_unit *drhd;",
          "3995:  u32 vtbar;",
          "3996:  int rc;",
          "4003:  rc = pci_bus_read_config_dword(pdev->bus, PCI_DEVFN(0, 0), 0xb0, &vtbar);",
          "4004:  if (rc) {",
          "4006:   dev_info(&pdev->dev, \"failed to run vt-d quirk\\n\");",
          "4007:   return;",
          "4008:  }",
          "4009:  vtbar &= 0xffff0000;",
          "4012:  drhd = dmar_find_matched_drhd_unit(pdev);",
          "4013:  if (!drhd || drhd->reg_base_addr - vtbar != 0xa000) {",
          "4014:   pr_warn_once(FW_BUG \"BIOS assigned incorrect VT-d unit for Intel(R) QuickData Technology device\\n\");",
          "4015:   add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);",
          "4016:   dev_iommu_priv_set(&pdev->dev, DUMMY_DEVICE_DOMAIN_INFO);",
          "4017:  }",
          "4018: }",
          "4019: DECLARE_PCI_FIXUP_ENABLE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_IOAT_SNB, quirk_ioat_snb_local_iommu);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4051:   drhd->gfx_dedicated = 1;",
          "4053:    drhd->ignored = 1;",
          "4058:  }",
          "4059: }",
          "",
          "[Removed Lines]",
          "4052:   if (!dmar_map_gfx) {",
          "4054:    for_each_active_dev_scope(drhd->devices,",
          "4055:         drhd->devices_cnt, i, dev)",
          "4056:     dev_iommu_priv_set(dev, DUMMY_DEVICE_DOMAIN_INFO);",
          "4057:   }",
          "",
          "[Added Lines]",
          "4066:   if (!dmar_map_gfx)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71a174b39f10b4b93223d374722aa894b5d8a82e",
      "candidate_info": {
        "commit_hash": "71a174b39f10b4b93223d374722aa894b5d8a82e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/71a174b39f10b4b93223d374722aa894b5d8a82e",
        "files": [
          "drivers/tty/pty.c"
        ],
        "message": "pty: do tty_flip_buffer_push without port->lock in pty_write\n\nb6da31b2c07c \"tty: Fix data race in tty_insert_flip_string_fixed_flag\"\nputs tty_flip_buffer_push under port->lock introducing the following\npossible circular locking dependency:\n\n[30129.876566] ======================================================\n[30129.876566] WARNING: possible circular locking dependency detected\n[30129.876567] 5.9.0-rc2+ #3 Tainted: G S      W\n[30129.876568] ------------------------------------------------------\n[30129.876568] sysrq.sh/1222 is trying to acquire lock:\n[30129.876569] ffffffff92c39480 (console_owner){....}-{0:0}, at: console_unlock+0x3fe/0xa90\n\n[30129.876572] but task is already holding lock:\n[30129.876572] ffff888107cb9018 (&pool->lock/1){-.-.}-{2:2}, at: show_workqueue_state.cold.55+0x15b/0x6ca\n\n[30129.876576] which lock already depends on the new lock.\n\n[30129.876577] the existing dependency chain (in reverse order) is:\n\n[30129.876578] -> #3 (&pool->lock/1){-.-.}-{2:2}:\n[30129.876581]        _raw_spin_lock+0x30/0x70\n[30129.876581]        __queue_work+0x1a3/0x10f0\n[30129.876582]        queue_work_on+0x78/0x80\n[30129.876582]        pty_write+0x165/0x1e0\n[30129.876583]        n_tty_write+0x47f/0xf00\n[30129.876583]        tty_write+0x3d6/0x8d0\n[30129.876584]        vfs_write+0x1a8/0x650\n\n[30129.876588] -> #2 (&port->lock#2){-.-.}-{2:2}:\n[30129.876590]        _raw_spin_lock_irqsave+0x3b/0x80\n[30129.876591]        tty_port_tty_get+0x1d/0xb0\n[30129.876592]        tty_port_default_wakeup+0xb/0x30\n[30129.876592]        serial8250_tx_chars+0x3d6/0x970\n[30129.876593]        serial8250_handle_irq.part.12+0x216/0x380\n[30129.876593]        serial8250_default_handle_irq+0x82/0xe0\n[30129.876594]        serial8250_interrupt+0xdd/0x1b0\n[30129.876595]        __handle_irq_event_percpu+0xfc/0x850\n\n[30129.876602] -> #1 (&port->lock){-.-.}-{2:2}:\n[30129.876605]        _raw_spin_lock_irqsave+0x3b/0x80\n[30129.876605]        serial8250_console_write+0x12d/0x900\n[30129.876606]        console_unlock+0x679/0xa90\n[30129.876606]        register_console+0x371/0x6e0\n[30129.876607]        univ8250_console_init+0x24/0x27\n[30129.876607]        console_init+0x2f9/0x45e\n\n[30129.876609] -> #0 (console_owner){....}-{0:0}:\n[30129.876611]        __lock_acquire+0x2f70/0x4e90\n[30129.876612]        lock_acquire+0x1ac/0xad0\n[30129.876612]        console_unlock+0x460/0xa90\n[30129.876613]        vprintk_emit+0x130/0x420\n[30129.876613]        printk+0x9f/0xc5\n[30129.876614]        show_pwq+0x154/0x618\n[30129.876615]        show_workqueue_state.cold.55+0x193/0x6ca\n[30129.876615]        __handle_sysrq+0x244/0x460\n[30129.876616]        write_sysrq_trigger+0x48/0x4a\n[30129.876616]        proc_reg_write+0x1a6/0x240\n[30129.876617]        vfs_write+0x1a8/0x650\n\n[30129.876619] other info that might help us debug this:\n\n[30129.876620] Chain exists of:\n[30129.876621]   console_owner --> &port->lock#2 --> &pool->lock/1\n\n[30129.876625]  Possible unsafe locking scenario:\n\n[30129.876626]        CPU0                    CPU1\n[30129.876626]        ----                    ----\n[30129.876627]   lock(&pool->lock/1);\n[30129.876628]                                lock(&port->lock#2);\n[30129.876630]                                lock(&pool->lock/1);\n[30129.876631]   lock(console_owner);\n\n[30129.876633]  *** DEADLOCK ***\n\n[30129.876634] 5 locks held by sysrq.sh/1222:\n[30129.876634]  #0: ffff8881d3ce0470 (sb_writers#3){.+.+}-{0:0}, at: vfs_write+0x359/0x650\n[30129.876637]  #1: ffffffff92c612c0 (rcu_read_lock){....}-{1:2}, at: __handle_sysrq+0x4d/0x460\n[30129.876640]  #2: ffffffff92c612c0 (rcu_read_lock){....}-{1:2}, at: show_workqueue_state+0x5/0xf0\n[30129.876642]  #3: ffff888107cb9018 (&pool->lock/1){-.-.}-{2:2}, at: show_workqueue_state.cold.55+0x15b/0x6ca\n[30129.876645]  #4: ffffffff92c39980 (console_lock){+.+.}-{0:0}, at: vprintk_emit+0x123/0x420\n\n[30129.876648] stack backtrace:\n[30129.876649] CPU: 3 PID: 1222 Comm: sysrq.sh Tainted: G S      W         5.9.0-rc2+ #3\n[30129.876649] Hardware name: Intel Corporation 2012 Client Platform/Emerald Lake 2, BIOS ACRVMBY1.86C.0078.P00.1201161002 01/16/2012\n[30129.876650] Call Trace:\n[30129.876650]  dump_stack+0x9d/0xe0\n[30129.876651]  check_noncircular+0x34f/0x410\n[30129.876653]  __lock_acquire+0x2f70/0x4e90\n[30129.876656]  lock_acquire+0x1ac/0xad0\n[30129.876658]  console_unlock+0x460/0xa90\n[30129.876660]  vprintk_emit+0x130/0x420\n[30129.876660]  printk+0x9f/0xc5\n[30129.876661]  show_pwq+0x154/0x618\n[30129.876662]  show_workqueue_state.cold.55+0x193/0x6ca\n[30129.876664]  __handle_sysrq+0x244/0x460\n[30129.876665]  write_sysrq_trigger+0x48/0x4a\n[30129.876665]  proc_reg_write+0x1a6/0x240\n[30129.876666]  vfs_write+0x1a8/0x650\n\nIt looks like the commit was aimed to protect tty_insert_flip_string and\nthere is no need for tty_flip_buffer_push to be under this lock.\n\nFixes: b6da31b2c07c (\"tty: Fix data race in tty_insert_flip_string_fixed_flag\")\nSigned-off-by: Artem Savkov <asavkov@redhat.com>\nAcked-by: Jiri Slaby <jirislaby@kernel.org>\nLink: https://lore.kernel.org/r/20200902120045.3693075-1-asavkov@redhat.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/tty/pty.c||drivers/tty/pty.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/tty/pty.c||drivers/tty/pty.c": [
          "File: drivers/tty/pty.c -> drivers/tty/pty.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "120:   spin_lock_irqsave(&to->port->lock, flags);",
          "122:   c = tty_insert_flip_string(to->port, buf, c);",
          "124:   if (c)",
          "125:    tty_flip_buffer_push(to->port);",
          "127:  }",
          "128:  return c;",
          "129: }",
          "",
          "[Removed Lines]",
          "126:   spin_unlock_irqrestore(&to->port->lock, flags);",
          "",
          "[Added Lines]",
          "123:   spin_unlock_irqrestore(&to->port->lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fccc0007b8dc952c6bc0805cdf842eb8ea06a639",
      "candidate_info": {
        "commit_hash": "fccc0007b8dc952c6bc0805cdf842eb8ea06a639",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fccc0007b8dc952c6bc0805cdf842eb8ea06a639",
        "files": [
          "fs/btrfs/volumes.c"
        ],
        "message": "btrfs: fix lockdep splat in add_missing_dev\n\nNikolay reported a lockdep splat in generic/476 that I could reproduce\nwith btrfs/187.\n\n  ======================================================\n  WARNING: possible circular locking dependency detected\n  5.9.0-rc2+ #1 Tainted: G        W\n  ------------------------------------------------------\n  kswapd0/100 is trying to acquire lock:\n  ffff9e8ef38b6268 (&delayed_node->mutex){+.+.}-{3:3}, at: __btrfs_release_delayed_node.part.0+0x3f/0x330\n\n  but task is already holding lock:\n  ffffffffa9d74700 (fs_reclaim){+.+.}-{0:0}, at: __fs_reclaim_acquire+0x5/0x30\n\n  which lock already depends on the new lock.\n\n  the existing dependency chain (in reverse order) is:\n\n  -> #2 (fs_reclaim){+.+.}-{0:0}:\n\t fs_reclaim_acquire+0x65/0x80\n\t slab_pre_alloc_hook.constprop.0+0x20/0x200\n\t kmem_cache_alloc_trace+0x3a/0x1a0\n\t btrfs_alloc_device+0x43/0x210\n\t add_missing_dev+0x20/0x90\n\t read_one_chunk+0x301/0x430\n\t btrfs_read_sys_array+0x17b/0x1b0\n\t open_ctree+0xa62/0x1896\n\t btrfs_mount_root.cold+0x12/0xea\n\t legacy_get_tree+0x30/0x50\n\t vfs_get_tree+0x28/0xc0\n\t vfs_kern_mount.part.0+0x71/0xb0\n\t btrfs_mount+0x10d/0x379\n\t legacy_get_tree+0x30/0x50\n\t vfs_get_tree+0x28/0xc0\n\t path_mount+0x434/0xc00\n\t __x64_sys_mount+0xe3/0x120\n\t do_syscall_64+0x33/0x40\n\t entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n  -> #1 (&fs_info->chunk_mutex){+.+.}-{3:3}:\n\t __mutex_lock+0x7e/0x7e0\n\t btrfs_chunk_alloc+0x125/0x3a0\n\t find_free_extent+0xdf6/0x1210\n\t btrfs_reserve_extent+0xb3/0x1b0\n\t btrfs_alloc_tree_block+0xb0/0x310\n\t alloc_tree_block_no_bg_flush+0x4a/0x60\n\t __btrfs_cow_block+0x11a/0x530\n\t btrfs_cow_block+0x104/0x220\n\t btrfs_search_slot+0x52e/0x9d0\n\t btrfs_lookup_inode+0x2a/0x8f\n\t __btrfs_update_delayed_inode+0x80/0x240\n\t btrfs_commit_inode_delayed_inode+0x119/0x120\n\t btrfs_evict_inode+0x357/0x500\n\t evict+0xcf/0x1f0\n\t vfs_rmdir.part.0+0x149/0x160\n\t do_rmdir+0x136/0x1a0\n\t do_syscall_64+0x33/0x40\n\t entry_SYSCALL_64_after_hwframe+0x44/0xa9\n\n  -> #0 (&delayed_node->mutex){+.+.}-{3:3}:\n\t __lock_acquire+0x1184/0x1fa0\n\t lock_acquire+0xa4/0x3d0\n\t __mutex_lock+0x7e/0x7e0\n\t __btrfs_release_delayed_node.part.0+0x3f/0x330\n\t btrfs_evict_inode+0x24c/0x500\n\t evict+0xcf/0x1f0\n\t dispose_list+0x48/0x70\n\t prune_icache_sb+0x44/0x50\n\t super_cache_scan+0x161/0x1e0\n\t do_shrink_slab+0x178/0x3c0\n\t shrink_slab+0x17c/0x290\n\t shrink_node+0x2b2/0x6d0\n\t balance_pgdat+0x30a/0x670\n\t kswapd+0x213/0x4c0\n\t kthread+0x138/0x160\n\t ret_from_fork+0x1f/0x30\n\n  other info that might help us debug this:\n\n  Chain exists of:\n    &delayed_node->mutex --> &fs_info->chunk_mutex --> fs_reclaim\n\n   Possible unsafe locking scenario:\n\n\t CPU0                    CPU1\n\t ----                    ----\n    lock(fs_reclaim);\n\t\t\t\t lock(&fs_info->chunk_mutex);\n\t\t\t\t lock(fs_reclaim);\n    lock(&delayed_node->mutex);\n\n   *** DEADLOCK ***\n\n  3 locks held by kswapd0/100:\n   #0: ffffffffa9d74700 (fs_reclaim){+.+.}-{0:0}, at: __fs_reclaim_acquire+0x5/0x30\n   #1: ffffffffa9d65c50 (shrinker_rwsem){++++}-{3:3}, at: shrink_slab+0x115/0x290\n   #2: ffff9e8e9da260e0 (&type->s_umount_key#48){++++}-{3:3}, at: super_cache_scan+0x38/0x1e0\n\n  stack backtrace:\n  CPU: 1 PID: 100 Comm: kswapd0 Tainted: G        W         5.9.0-rc2+ #1\n  Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.13.0-2.fc32 04/01/2014\n  Call Trace:\n   dump_stack+0x92/0xc8\n   check_noncircular+0x12d/0x150\n   __lock_acquire+0x1184/0x1fa0\n   lock_acquire+0xa4/0x3d0\n   ? __btrfs_release_delayed_node.part.0+0x3f/0x330\n   __mutex_lock+0x7e/0x7e0\n   ? __btrfs_release_delayed_node.part.0+0x3f/0x330\n   ? __btrfs_release_delayed_node.part.0+0x3f/0x330\n   ? lock_acquire+0xa4/0x3d0\n   ? btrfs_evict_inode+0x11e/0x500\n   ? find_held_lock+0x2b/0x80\n   __btrfs_release_delayed_node.part.0+0x3f/0x330\n   btrfs_evict_inode+0x24c/0x500\n   evict+0xcf/0x1f0\n   dispose_list+0x48/0x70\n   prune_icache_sb+0x44/0x50\n   super_cache_scan+0x161/0x1e0\n   do_shrink_slab+0x178/0x3c0\n   shrink_slab+0x17c/0x290\n   shrink_node+0x2b2/0x6d0\n   balance_pgdat+0x30a/0x670\n   kswapd+0x213/0x4c0\n   ? _raw_spin_unlock_irqrestore+0x46/0x60\n   ? add_wait_queue_exclusive+0x70/0x70\n   ? balance_pgdat+0x670/0x670\n   kthread+0x138/0x160\n   ? kthread_create_worker_on_cpu+0x40/0x40\n   ret_from_fork+0x1f/0x30\n\nThis is because we are holding the chunk_mutex when we call\nbtrfs_alloc_device, which does a GFP_KERNEL allocation.  We don't want\nto switch that to a GFP_NOFS lock because this is the only place where\nit matters.  So instead use memalloc_nofs_save() around the allocation\nin order to avoid the lockdep splat.\n\nReported-by: Nikolay Borisov <nborisov@suse.com>\nCC: stable@vger.kernel.org # 4.4+\nReviewed-by: Anand Jain <anand.jain@oracle.com>\nSigned-off-by: Josef Bacik <josef@toxicpanda.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include <linux/sched.h>",
          "7: #include <linux/bio.h>",
          "8: #include <linux/slab.h>",
          "9: #include <linux/blkdev.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7: #include <linux/sched/mm.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6484:          u64 devid, u8 *dev_uuid)",
          "6485: {",
          "6486:  struct btrfs_device *device;",
          "6488:  device = btrfs_alloc_device(NULL, &devid, dev_uuid);",
          "6489:  if (IS_ERR(device))",
          "6490:   return device;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6488:  unsigned int nofs_flag;",
          "6496:  nofs_flag = memalloc_nofs_save();",
          "6498:  memalloc_nofs_restore(nofs_flag);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-9993",
  "cve_desc": "FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "189ff4219644532bdfa7bab28dfedaee4d6d4021",
  "patch_info": {
    "commit_hash": "189ff4219644532bdfa7bab28dfedaee4d6d4021",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/189ff4219644532bdfa7bab28dfedaee4d6d4021",
    "files": [
      "libavformat/hls.c"
    ],
    "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavformat/hls.c||libavformat/hls.c"
    ]
  },
  "patch_diff": {
    "libavformat/hls.c||libavformat/hls.c": [
      "File: libavformat/hls.c -> libavformat/hls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "204:     char *http_proxy;                    ///< holds the address of the HTTP proxy server",
      "205:     AVDictionary *avio_opts;",
      "206:     int strict_std_compliance;",
      "207: } HLSContext;",
      "209: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "207:     char *allowed_extensions;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "618:         return AVERROR_INVALIDDATA;",
      "622:         return AVERROR_INVALIDDATA;",
      "623:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
      "624:         ;",
      "625:     else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')",
      "",
      "[Removed Lines]",
      "621:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
      "",
      "[Added Lines]",
      "622:     if (av_strstart(proto_name, \"file\", NULL)) {",
      "623:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
      "624:             av_log(s, AV_LOG_ERROR,",
      "625:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
      "626:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
      "627:                 url);",
      "628:             return AVERROR_INVALIDDATA;",
      "629:         }",
      "630:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
      "631:         ;",
      "632:     } else",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2134: static const AVOption hls_options[] = {",
      "2135:     {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",",
      "2136:         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},",
      "2137:     {NULL}",
      "2138: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2149:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
      "2150:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
      "2151:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
      "2152:         INT_MIN, INT_MAX, FLAGS},",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "3dd1f38329e7bd7225445c92fc0019adc43899f4",
      "candidate_info": {
        "commit_hash": "3dd1f38329e7bd7225445c92fc0019adc43899f4",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/3dd1f38329e7bd7225445c92fc0019adc43899f4",
        "files": [
          "libavformat/hls.c"
        ],
        "message": "avformat/hls: Check local file extensions\n\nThis reduces the attack surface of local file-system\ninformation leaking.\n\nIt prevents the existing exploit leading to an information leak. As\nwell as similar hypothetical attacks.\n\nLeaks of information from files and symlinks ending in common multimedia extensions\nare still possible. But files with sensitive information like private keys and passwords\ngenerally do not use common multimedia filename extensions.\nIt does not stop leaks via remote addresses in the LAN.\n\nThe existing exploit depends on a specific decoder as well.\nIt does appear though that the exploit should be possible with any decoder.\nThe problem is that as long as sensitive information gets into the decoder,\nthe output of the decoder becomes sensitive as well.\nThe only obvious solution is to prevent access to sensitive information. Or to\ndisable hls or possibly some of its feature. More complex solutions like\nchecking the path to limit access to only subdirectories of the hls path may\nwork as an alternative. But such solutions are fragile and tricky to implement\nportably and would not stop every possible attack nor would they work with all\nvalid hls files.\n\nDevelopers have expressed their dislike / objected to disabling hls by default as well\nas disabling hls with local files. There also where objections against restricting\nremote url file extensions. This here is a less robust but also lower\ninconvenience solution.\nIt can be applied stand alone or together with other solutions.\nlimiting the check to local files was suggested by nevcairiel\n\nThis recommits the security fix without the author name joke which was\noriginally requested by Nicolas.\n\nFound-by: Emil Lerner and Pavel Cheremushkin\nReported-by: Thierry Foucu <tfoucu@google.com>\n\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 189ff4219644532bdfa7bab28dfedaee4d6d4021)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/hls.c||libavformat/hls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/hls.c||libavformat/hls.c"
          ],
          "candidate": [
            "libavformat/hls.c||libavformat/hls.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/hls.c||libavformat/hls.c": [
          "File: libavformat/hls.c -> libavformat/hls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "204:     char *http_proxy;                    ///< holds the address of the HTTP proxy server",
          "205:     AVDictionary *avio_opts;",
          "206:     int strict_std_compliance;",
          "207: } HLSContext;",
          "209: static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:     char *allowed_extensions;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "618:         return AVERROR_INVALIDDATA;",
          "622:         return AVERROR_INVALIDDATA;",
          "623:     if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')",
          "624:         ;",
          "625:     else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')",
          "",
          "[Removed Lines]",
          "621:     if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))",
          "",
          "[Added Lines]",
          "622:     if (av_strstart(proto_name, \"file\", NULL)) {",
          "623:         if (strcmp(c->allowed_extensions, \"ALL\") && !av_match_ext(url, c->allowed_extensions)) {",
          "624:             av_log(s, AV_LOG_ERROR,",
          "625:                 \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\"",
          "626:                 \"If you wish to override this adjust allowed_extensions, you can set it to \\'ALL\\' to allow all\\n\",",
          "627:                 url);",
          "628:             return AVERROR_INVALIDDATA;",
          "629:         }",
          "630:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
          "631:         ;",
          "632:     } else",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2134: static const AVOption hls_options[] = {",
          "2135:     {\"live_start_index\", \"segment index to start live streams at (negative values are from the end)\",",
          "2136:         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},",
          "2137:     {NULL}",
          "2138: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2149:     {\"allowed_extensions\", \"List of file extensions that hls is allowed to access\",",
          "2150:         OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,",
          "2151:         {.str = \"3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav\"},",
          "2152:         INT_MIN, INT_MAX, FLAGS},",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f9ca64556cba9a7edcca9a1c55923a60022937d",
      "candidate_info": {
        "commit_hash": "2f9ca64556cba9a7edcca9a1c55923a60022937d",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2f9ca64556cba9a7edcca9a1c55923a60022937d",
        "files": [
          "libavformat/hls.c"
        ],
        "message": "avformat/hls: remove repeated http proto_name checks in open_url()\n\nSigned-off-by: Aman Gupta <aman@tmm1.net>",
        "before_after_code_files": [
          "libavformat/hls.c||libavformat/hls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/hls.c||libavformat/hls.c"
          ],
          "candidate": [
            "libavformat/hls.c||libavformat/hls.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/hls.c||libavformat/hls.c": [
          "File: libavformat/hls.c -> libavformat/hls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "623: }",
          "625: static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,",
          "627: {",
          "628:     HLSContext *c = s->priv_data;",
          "629:     AVDictionary *tmp = NULL;",
          "630:     const char *proto_name = NULL;",
          "631:     int ret;",
          "633:     av_dict_copy(&tmp, opts, 0);",
          "634:     av_dict_copy(&tmp, opts2, 0);",
          "",
          "[Removed Lines]",
          "626:                     AVDictionary *opts, AVDictionary *opts2, int *is_http)",
          "",
          "[Added Lines]",
          "626:                     AVDictionary *opts, AVDictionary *opts2, int *is_http_out)",
          "632:     int is_http = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "654:             return AVERROR_INVALIDDATA;",
          "655:         }",
          "656:     } else if (av_strstart(proto_name, \"http\", NULL)) {",
          "658:     } else",
          "659:         return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "657:         ;",
          "",
          "[Added Lines]",
          "658:         is_http = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "665:     else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))",
          "666:         return AVERROR_INVALIDDATA;",
          "669:         ret = open_url_keepalive(c->ctx, pb, url);",
          "670:         if (ret == AVERROR_EXIT) {",
          "671:             return ret;",
          "",
          "[Removed Lines]",
          "668:     if (c->http_persistent && *pb && av_strstart(proto_name, \"http\", NULL)) {",
          "",
          "[Added Lines]",
          "669:     if (is_http && c->http_persistent && *pb) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "697:     av_dict_free(&tmp);",
          "702:     return ret;",
          "703: }",
          "",
          "[Removed Lines]",
          "699:     if (is_http)",
          "",
          "[Added Lines]",
          "700:     if (is_http_out)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-0142",
  "cve_desc": "QEMU, possibly before 2.0.0, allows local users to cause a denial of service (divide-by-zero error and crash) via a zero value in the (1) tracks field to the seek_to_sector function in block/parallels.c or (2) extent_size field in the bochs function in block/bochs.c.",
  "repo": "qemu/qemu",
  "patch_hash": "8e53abbc20d08ae3ec30c2054e1161314ad9501d",
  "patch_info": {
    "commit_hash": "8e53abbc20d08ae3ec30c2054e1161314ad9501d",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/8e53abbc20d08ae3ec30c2054e1161314ad9501d",
    "files": [
      "block/bochs.c",
      "tests/qemu-iotests/078",
      "tests/qemu-iotests/078.out"
    ],
    "message": "bochs: Check extent_size header field (CVE-2014-0142)\n\nThis fixes two possible division by zero crashes: In bochs_open() and in\nseek_to_sector().\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>",
    "before_after_code_files": [
      "block/bochs.c||block/bochs.c"
    ]
  },
  "patch_diff": {
    "block/bochs.c||block/bochs.c": [
      "File: block/bochs.c -> block/bochs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "148:     s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;",
      "150:     s->extent_size = le32_to_cpu(bochs.extent);",
      "152:     if (s->catalog_size < bs->total_sectors / s->extent_size) {",
      "153:         error_setg(errp, \"Catalog size is too small for this disk size\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "151:     if (s->extent_size == 0) {",
      "152:         error_setg(errp, \"Extent size may not be zero\");",
      "153:         return -EINVAL;",
      "154:     } else if (s->extent_size > 0x800000) {",
      "155:         error_setg(errp, \"Extent size %\" PRIu32 \" is too large\",",
      "156:                    s->extent_size);",
      "157:         return -EINVAL;",
      "158:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b0a7517c244d09bbb087af0f8b455cabedc126ee",
      "candidate_info": {
        "commit_hash": "b0a7517c244d09bbb087af0f8b455cabedc126ee",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/b0a7517c244d09bbb087af0f8b455cabedc126ee",
        "files": [
          "block/bochs.c",
          "tests/qemu-iotests/078",
          "tests/qemu-iotests/078.out"
        ],
        "message": "bochs: Check extent_size header field (CVE-2014-0142)\n\nThis fixes two possible division by zero crashes: In bochs_open() and in\nseek_to_sector().\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Stefan Hajnoczi <stefanha@redhat.com>\nReviewed-by: Max Reitz <mreitz@redhat.com>\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>\n(cherry picked from commit 8e53abbc20d08ae3ec30c2054e1161314ad9501d)\nSigned-off-by: Michael Roth <mdroth@linux.vnet.ibm.com>",
        "before_after_code_files": [
          "block/bochs.c||block/bochs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "block/bochs.c||block/bochs.c"
          ],
          "candidate": [
            "block/bochs.c||block/bochs.c"
          ]
        }
      },
      "candidate_diff": {
        "block/bochs.c||block/bochs.c": [
          "File: block/bochs.c -> block/bochs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:     s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;",
          "149:     s->extent_size = le32_to_cpu(bochs.extent);",
          "151:     if (s->catalog_size < bs->total_sectors / s->extent_size) {",
          "152:         error_setg(errp, \"Catalog size is too small for this disk size\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "150:     if (s->extent_size == 0) {",
          "151:         error_setg(errp, \"Extent size may not be zero\");",
          "152:         return -EINVAL;",
          "153:     } else if (s->extent_size > 0x800000) {",
          "154:         error_setg(errp, \"Extent size %\" PRIu32 \" is too large\",",
          "155:                    s->extent_size);",
          "156:         return -EINVAL;",
          "157:     }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "28ec11bc882387e51c7450558af5a49b8be95a36",
      "candidate_info": {
        "commit_hash": "28ec11bc882387e51c7450558af5a49b8be95a36",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/28ec11bc882387e51c7450558af5a49b8be95a36",
        "files": [
          "block/bochs.c"
        ],
        "message": "bochs: Fix memory leak in bochs_open() error path\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Laszlo Ersek <lersek@redhat.com>",
        "before_after_code_files": [
          "block/bochs.c||block/bochs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "block/bochs.c||block/bochs.c"
          ],
          "candidate": [
            "block/bochs.c||block/bochs.c"
          ]
        }
      },
      "candidate_diff": {
        "block/bochs.c||block/bochs.c": [
          "File: block/bochs.c -> block/bochs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "150:     s->extent_size = le32_to_cpu(bochs.extent);",
          "151:     if (s->extent_size == 0) {",
          "152:         error_setg(errp, \"Extent size may not be zero\");",
          "154:     } else if (s->extent_size > 0x800000) {",
          "155:         error_setg(errp, \"Extent size %\" PRIu32 \" is too large\",",
          "156:                    s->extent_size);",
          "158:     }",
          "160:     if (s->catalog_size < bs->total_sectors / s->extent_size) {",
          "",
          "[Removed Lines]",
          "153:         return -EINVAL;",
          "157:         return -EINVAL;",
          "",
          "[Added Lines]",
          "153:         ret = -EINVAL;",
          "154:         goto fail;",
          "158:         ret = -EINVAL;",
          "159:         goto fail;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "715c3f60efa9801a777a71cd06eaf8efa7eaa2a8",
      "candidate_info": {
        "commit_hash": "715c3f60efa9801a777a71cd06eaf8efa7eaa2a8",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/715c3f60efa9801a777a71cd06eaf8efa7eaa2a8",
        "files": [
          "block/bochs.c",
          "tests/qemu-iotests/078",
          "tests/qemu-iotests/078.out"
        ],
        "message": "bochs: Fix catalog size check\n\nThe old check was off by a factor of 512 and didn't consider cases where\nwe don't get an exact division. This could lead to an out-of-bounds\narray access in seek_to_sector().\n\nSigned-off-by: Kevin Wolf <kwolf@redhat.com>\nReviewed-by: Laszlo Ersek <lersek@redhat.com>",
        "before_after_code_files": [
          "block/bochs.c||block/bochs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "block/bochs.c||block/bochs.c"
          ],
          "candidate": [
            "block/bochs.c||block/bochs.c"
          ]
        }
      },
      "candidate_diff": {
        "block/bochs.c||block/bochs.c": [
          "File: block/bochs.c -> block/bochs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "148:     s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;",
          "150:     s->extent_size = le32_to_cpu(bochs.extent);",
          "153:         ret = -EINVAL;",
          "154:         goto fail;",
          "155:     } else if (s->extent_size > 0x800000) {",
          "",
          "[Removed Lines]",
          "151:     if (s->extent_size == 0) {",
          "152:         error_setg(errp, \"Extent size may not be zero\");",
          "",
          "[Added Lines]",
          "151:     if (s->extent_size < BDRV_SECTOR_SIZE) {",
          "153:         error_setg(errp, \"Extent size must be at least 512\");",
          "154:         ret = -EINVAL;",
          "155:         goto fail;",
          "156:     } else if (!is_power_of_2(s->extent_size)) {",
          "157:         error_setg(errp, \"Extent size %\" PRIu32 \" is not a power of two\",",
          "158:                    s->extent_size);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "159:         goto fail;",
          "160:     }",
          "163:         error_setg(errp, \"Catalog size is too small for this disk size\");",
          "164:         ret = -EINVAL;",
          "165:         goto fail;",
          "",
          "[Removed Lines]",
          "162:     if (s->catalog_size < bs->total_sectors / s->extent_size) {",
          "",
          "[Added Lines]",
          "168:     if (s->catalog_size < DIV_ROUND_UP(bs->total_sectors,",
          "169:                                        s->extent_size / BDRV_SECTOR_SIZE))",
          "170:     {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
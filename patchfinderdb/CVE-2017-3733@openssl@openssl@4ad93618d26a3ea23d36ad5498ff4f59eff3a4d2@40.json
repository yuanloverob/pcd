{
  "cve_id": "CVE-2017-3733",
  "cve_desc": "During a renegotiation handshake if the Encrypt-Then-Mac extension is negotiated where it was not in the original handshake (or vice-versa) then this can cause OpenSSL 1.1.0 before 1.1.0e to crash (dependent on ciphersuite). Both clients and servers are affected.",
  "repo": "openssl/openssl",
  "patch_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
  "patch_info": {
    "commit_hash": "4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/4ad93618d26a3ea23d36ad5498ff4f59eff3a4d2",
    "files": [
      "include/openssl/ssl3.h",
      "ssl/record/rec_layer_s3.c",
      "ssl/record/ssl3_record.c",
      "ssl/ssl_locl.h",
      "ssl/t1_enc.c",
      "ssl/t1_lib.c"
    ],
    "message": "Don't change the state of the ETM flags until CCS processing\n\nChanging the ciphersuite during a renegotiation can result in a crash\nleading to a DoS attack. ETM has not been implemented in 1.1.0 for DTLS\nso this is TLS only.\n\nThe problem is caused by changing the flag indicating whether to use ETM\nor not immediately on negotiation of ETM, rather than at CCS. Therefore,\nduring a renegotiation, if the ETM state is changing (usually due to a\nchange of ciphersuite), then an error/crash will occur.\n\nDue to the fact that there are separate CCS messages for read and write\nwe actually now need two flags to determine whether to use ETM or not.\n\nCVE-2017-3733\n\nReviewed-by: Richard Levitte <levitte@openssl.org>",
    "before_after_code_files": [
      "include/openssl/ssl3.h||include/openssl/ssl3.h",
      "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c",
      "ssl/record/ssl3_record.c||ssl/record/ssl3_record.c",
      "ssl/ssl_locl.h||ssl/ssl_locl.h",
      "ssl/t1_enc.c||ssl/t1_enc.c",
      "ssl/t1_lib.c||ssl/t1_lib.c"
    ]
  },
  "patch_diff": {
    "include/openssl/ssl3.h||include/openssl/ssl3.h": [
      "File: include/openssl/ssl3.h -> include/openssl/ssl3.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "264: # define TLS1_FLAGS_SKIP_CERT_VERIFY             0x0010",
      "270: # define TLS1_FLAGS_RECEIVED_EXTMS               0x0200",
      "272: # define SSL3_MT_HELLO_REQUEST                   0",
      "273: # define SSL3_MT_CLIENT_HELLO                    1",
      "274: # define SSL3_MT_SERVER_HELLO                    2",
      "",
      "[Removed Lines]",
      "267: # define TLS1_FLAGS_ENCRYPT_THEN_MAC             0x0100",
      "",
      "[Added Lines]",
      "267: # define TLS1_FLAGS_ENCRYPT_THEN_MAC_READ        0x0100",
      "268: # define TLS1_FLAGS_ENCRYPT_THEN_MAC             TLS1_FLAGS_ENCRYPT_THEN_MAC_READ",
      "273: # define TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE       0x0400",
      "",
      "---------------"
    ],
    "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c": [
      "File: ssl/record/rec_layer_s3.c -> ssl/record/rec_layer_s3.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "395:     if (type == SSL3_RT_APPLICATION_DATA &&",
      "396:         u_len >= 4 * (max_send_fragment = s->max_send_fragment) &&",
      "397:         s->compress == NULL && s->msg_callback == NULL &&",
      "399:         EVP_CIPHER_flags(EVP_CIPHER_CTX_cipher(s->enc_write_ctx)) &",
      "400:         EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK) {",
      "401:         unsigned char aad[13];",
      "",
      "[Removed Lines]",
      "398:         !SSL_USE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&",
      "",
      "[Added Lines]",
      "398:         !SSL_WRITE_ETM(s) && SSL_USE_EXPLICIT_IV(s) &&",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "795:             if (s->method->ssl3_enc->mac(s, &wr[j],",
      "796:                                          &(outbuf[j][wr[j].length + eivlen]),",
      "797:                                          1) < 0)",
      "",
      "[Removed Lines]",
      "794:         if (!SSL_USE_ETM(s) && mac_size != 0) {",
      "",
      "[Added Lines]",
      "794:         if (!SSL_WRITE_ETM(s) && mac_size != 0) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "814:         goto err;",
      "816:     for (j = 0; j < numpipes; j++) {",
      "818:             if (s->method->ssl3_enc->mac(s, &wr[j],",
      "819:                                          outbuf[j] + wr[j].length, 1) < 0)",
      "820:                 goto err;",
      "",
      "[Removed Lines]",
      "817:         if (SSL_USE_ETM(s) && mac_size != 0) {",
      "",
      "[Added Lines]",
      "817:         if (SSL_WRITE_ETM(s) && mac_size != 0) {",
      "",
      "---------------"
    ],
    "ssl/record/ssl3_record.c||ssl/record/ssl3_record.c": [
      "File: ssl/record/ssl3_record.c -> ssl/record/ssl3_record.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "350:         unsigned char *mac;",
      "351:         mac_size = EVP_MD_CTX_size(s->read_hash);",
      "352:         OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);",
      "",
      "[Removed Lines]",
      "349:     if (SSL_USE_ETM(s) && s->read_hash) {",
      "",
      "[Added Lines]",
      "349:     if (SSL_READ_ETM(s) && s->read_hash) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "394:     if ((sess != NULL) &&",
      "395:         (s->enc_read_ctx != NULL) &&",
      "398:         unsigned char *mac = NULL;",
      "399:         unsigned char mac_tmp[EVP_MAX_MD_SIZE];",
      "",
      "[Removed Lines]",
      "396:         (EVP_MD_CTX_md(s->read_hash) != NULL) && !SSL_USE_ETM(s)) {",
      "",
      "[Added Lines]",
      "396:         (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "823:         }",
      "825:         ret = 1;",
      "827:             mac_size = EVP_MD_CTX_size(s->read_hash);",
      "828:         if ((bs != 1) && !send) {",
      "829:             int tmpret;",
      "",
      "[Removed Lines]",
      "826:         if (!SSL_USE_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)",
      "",
      "[Added Lines]",
      "826:         if (!SSL_READ_ETM(s) && EVP_MD_CTX_md(s->read_hash) != NULL)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "997:     header[11] = (rec->length) >> 8;",
      "998:     header[12] = (rec->length) & 0xff;",
      "1001:         EVP_CIPHER_CTX_mode(ssl->enc_read_ctx) == EVP_CIPH_CBC_MODE &&",
      "1002:         ssl3_cbc_record_digest_supported(mac_ctx)) {",
      "",
      "[Removed Lines]",
      "1000:     if (!send && !SSL_USE_ETM(ssl) &&",
      "",
      "[Added Lines]",
      "1000:     if (!send && !SSL_READ_ETM(ssl) &&",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1022:             EVP_MD_CTX_free(hmac);",
      "1023:             return -1;",
      "1024:         }",
      "1026:             if (!tls_fips_digest_extra(ssl->enc_read_ctx,",
      "1027:                                        mac_ctx, rec->input,",
      "1028:                                        rec->length, rec->orig_len)) {",
      "",
      "[Removed Lines]",
      "1025:         if (!send && !SSL_USE_ETM(ssl) && FIPS_mode())",
      "",
      "[Added Lines]",
      "1025:         if (!send && !SSL_READ_ETM(ssl) && FIPS_mode())",
      "",
      "---------------"
    ],
    "ssl/ssl_locl.h||ssl/ssl_locl.h": [
      "File: ssl/ssl_locl.h -> ssl/ssl_locl.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "378: # define SSL_CLIENT_USE_SIGALGS(s)        \\",
      "379:     SSL_CLIENT_USE_TLS1_2_CIPHERS(s)",
      "384: # define SSL_PKEY_RSA_ENC        0",
      "",
      "[Removed Lines]",
      "381: # define SSL_USE_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC)",
      "",
      "[Added Lines]",
      "381: # define SSL_READ_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_READ)",
      "382: # define SSL_WRITE_ETM(s) (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1111:     unsigned char *alpn_client_proto_list;",
      "1112:     unsigned alpn_client_proto_list_len;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1116:     int tlsext_use_etm;",
      "",
      "---------------"
    ],
    "ssl/t1_enc.c||ssl/t1_enc.c": [
      "File: ssl/t1_enc.c -> ssl/t1_enc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130: #endif",
      "132:     if (which & SSL3_CC_READ) {",
      "133:         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)",
      "134:             s->mac_flags |= SSL_MAC_FLAG_READ_MAC_STREAM;",
      "135:         else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:         if (s->tlsext_use_etm)",
      "134:             s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;",
      "135:         else",
      "136:             s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "168:         mac_secret = &(s->s3->read_mac_secret[0]);",
      "169:         mac_secret_size = &(s->s3->read_mac_secret_size);",
      "170:     } else {",
      "171:         if (s->s3->tmp.new_cipher->algorithm2 & TLS1_STREAM_MAC)",
      "172:             s->mac_flags |= SSL_MAC_FLAG_WRITE_MAC_STREAM;",
      "173:         else",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "176:         if (s->tlsext_use_etm)",
      "177:             s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;",
      "178:         else",
      "179:             s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "367:     if (s->s3->tmp.key_block_length != 0)",
      "368:         return (1);",
      "373:         SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE);",
      "374:         return (0);",
      "375:     }",
      "",
      "[Removed Lines]",
      "370:     if (!ssl_cipher_get_evp",
      "371:         (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp,",
      "372:          SSL_USE_ETM(s))) {",
      "",
      "[Added Lines]",
      "380:     if (!ssl_cipher_get_evp(s->session, &c, &hash, &mac_type, &mac_secret_size,",
      "381:                             &comp, s->tlsext_use_etm)) {",
      "",
      "---------------"
    ],
    "ssl/t1_lib.c||ssl/t1_lib.c": [
      "File: ssl/t1_lib.c -> ssl/t1_lib.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1674: #endif",
      "1675:     if (!custom_ext_add(s, 1, &ret, limit, al))",
      "1676:         return NULL;",
      "",
      "[Removed Lines]",
      "1677:     if (s->s3->flags & TLS1_FLAGS_ENCRYPT_THEN_MAC) {",
      "",
      "[Added Lines]",
      "1677:     if (s->tlsext_use_etm) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1683:             || s->s3->tmp.new_cipher->algorithm_enc == SSL_RC4",
      "1684:             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT",
      "1685:             || s->s3->tmp.new_cipher->algorithm_enc == SSL_eGOST2814789CNT12)",
      "1687:         else {",
      "",
      "[Removed Lines]",
      "1686:             s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "1686:             s->tlsext_use_etm = 0;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1917:     OPENSSL_free(s->s3->tmp.peer_sigalgs);",
      "1918:     s->s3->tmp.peer_sigalgs = NULL;",
      "1921: #ifndef OPENSSL_NO_SRP",
      "1922:     OPENSSL_free(s->srp_ctx.login);",
      "",
      "[Removed Lines]",
      "1919:     s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "1919:     s->tlsext_use_etm = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2264:         }",
      "2265: #endif",
      "2266:         else if (type == TLSEXT_TYPE_encrypt_then_mac)",
      "",
      "[Removed Lines]",
      "2267:             s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "2267:             s->tlsext_use_etm = 1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2366:                              SSL_DTLSEXT_HB_DONT_SEND_REQUESTS);",
      "2367: #endif",
      "2371:     s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS;",
      "",
      "[Removed Lines]",
      "2369:     s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "2369:     s->tlsext_use_etm = 0;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2586:             if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD",
      "2587:                 && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4)",
      "2589:         } else if (type == TLSEXT_TYPE_extended_master_secret) {",
      "2590:             s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS;",
      "2591:             if (!s->hit)",
      "",
      "[Removed Lines]",
      "2588:                 s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC;",
      "",
      "[Added Lines]",
      "2588:                 s->tlsext_use_etm = 1;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ca423a693a619b38fb96d94b0385f8ce91a8e759",
      "candidate_info": {
        "commit_hash": "ca423a693a619b38fb96d94b0385f8ce91a8e759",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/ca423a693a619b38fb96d94b0385f8ce91a8e759",
        "files": [
          "crypto/des/set_key.c",
          "doc/crypto/DES_random_key.pod"
        ],
        "message": "DES keys are not 7 days long.\n\nCLA: trivial\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2604)\n\n(cherry picked from commit 4fd7b54dc224930a0ce6dd67b35c598c5072857c)",
        "before_after_code_files": [
          "crypto/des/set_key.c||crypto/des/set_key.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/des/set_key.c||crypto/des/set_key.c": [
          "File: crypto/des/set_key.c -> crypto/des/set_key.c"
        ]
      }
    },
    {
      "candidate_hash": "a504540fcbc779e7e2b855dccaae9e4d7156c88d",
      "candidate_info": {
        "commit_hash": "a504540fcbc779e7e2b855dccaae9e4d7156c88d",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/a504540fcbc779e7e2b855dccaae9e4d7156c88d",
        "files": [
          "doc/ssl/SSL_CTX_set_alpn_select_cb.pod",
          "ssl/t1_lib.c",
          "test/handshake_helper.c"
        ],
        "message": "Allow an ALPN callback to pretend to not exist\n\nRFC 7301 mandates that the server SHALL respond with a fatal\n\"no_application_protocol\" alert when there is no overlap between\nthe client's supplied list and the server's list of supported protocols.\nIn commit 062178678f5374b09f00d70796f6e692e8775aca we changed from\nignoring non-success returns from the supplied alpn_select_cb() to\ntreating such non-success returns as indicative of non-overlap and\nsending the fatal alert.\n\nIn effect, this is using the presence of an alpn_select_cb() as a proxy\nto attempt to determine whether the application has configured a list\nof supported protocols.  However, there may be cases in which an\napplication's architecture leads it to supply an alpn_select_cb() but\nhave that callback be configured to take no action on connections that\ndo not have ALPN configured; returning SSL_TLSEXT_ERR_NOACK from\nthe callback would be the natural way to do so.  Unfortunately, the\naforementioned behavior change also treated SSL_TLSEXT_ERR_NOACK as\nindicative of no overlap and terminated the connection; this change\nsupplies special handling for SSL_TLSEXT_ERR_NOACK returns from the\ncallback.  In effect, it provides a way for a callback to obtain the\nbehavior that would have occurred if no callback was registered at\nall, which was not possible prior to this change.\n\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3158)\n(cherry picked from commit 8313a787d770ac1d7ddafcbc41b13e7fb5841eae)",
        "before_after_code_files": [
          "ssl/t1_lib.c||ssl/t1_lib.c",
          "test/handshake_helper.c||test/handshake_helper.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ],
          "candidate": [
            "ssl/t1_lib.c||ssl/t1_lib.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/t1_lib.c||ssl/t1_lib.c": [
          "File: ssl/t1_lib.c -> ssl/t1_lib.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1800:             s->s3->next_proto_neg_seen = 0;",
          "1801: #endif",
          "1802:         } else {",
          "1804:             return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1802:         } else if (r == SSL_TLSEXT_ERR_NOACK) {",
          "1804:             return 1;",
          "",
          "---------------"
        ],
        "test/handshake_helper.c||test/handshake_helper.c": [
          "File: test/handshake_helper.c -> test/handshake_helper.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "299:     return ret == OPENSSL_NPN_NEGOTIATED ? SSL_TLSEXT_ERR_OK",
          "301: }",
          "",
          "[Removed Lines]",
          "300:         : SSL_TLSEXT_ERR_NOACK;",
          "",
          "[Added Lines]",
          "300:         : SSL_TLSEXT_ERR_ALERT_FATAL;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6302d9373829ff37c257d93f8566f2272968d67d",
      "candidate_info": {
        "commit_hash": "6302d9373829ff37c257d93f8566f2272968d67d",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/6302d9373829ff37c257d93f8566f2272968d67d",
        "files": [
          "ssl/record/rec_layer_s3.c"
        ],
        "message": "Additional check to handle BAD SSL_write retry\n\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3123)",
        "before_after_code_files": [
          "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [
            "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c"
          ],
          "candidate": [
            "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c"
          ]
        }
      },
      "candidate_diff": {
        "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c": [
          "File: ssl/record/rec_layer_s3.c -> ssl/record/rec_layer_s3.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "372:         SSLerr(SSL_F_SSL3_WRITE_BYTES, SSL_R_BAD_LENGTH);",
          "373:         return -1;",
          "374:     }",
          "",
          "[Removed Lines]",
          "371:     if ((unsigned int)len < s->rlayer.wnum) {",
          "",
          "[Added Lines]",
          "371:     if (((unsigned int)len < s->rlayer.wnum)",
          "372:         || ((wb->left != 0) && ((unsigned int)len < (s->rlayer.wnum + s->rlayer.wpend_tot)))) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80204e6731ac0fc3438d9b193c749abf8305189b",
      "candidate_info": {
        "commit_hash": "80204e6731ac0fc3438d9b193c749abf8305189b",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/80204e6731ac0fc3438d9b193c749abf8305189b",
        "files": [
          "test/ecdhtest.c"
        ],
        "message": "Remove stale code in ecdhtest.c\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3188)",
        "before_after_code_files": [
          "test/ecdhtest.c||test/ecdhtest.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/ecdhtest.c||test/ecdhtest.c": [
          "File: test/ecdhtest.c -> test/ecdhtest.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: static const char rnd_seed[] =",
          "50:     \"string to make the random number generator think it has entropy\";",
          "246: typedef struct {",
          "247:     const int nid;",
          "248:     const char *da;",
          "",
          "[Removed Lines]",
          "52: static const int KDF1_SHA1_len = 20;",
          "53: static void *KDF1_SHA1(const void *in, size_t inlen, void *out,",
          "54:                        size_t *outlen)",
          "55: {",
          "56:     if (*outlen < SHA_DIGEST_LENGTH)",
          "57:         return NULL;",
          "59:     return SHA1(in, inlen, out);",
          "60: }",
          "62: static int test_ecdh_curve(int nid, BN_CTX *ctx, BIO *out)",
          "63: {",
          "64:     EC_KEY *a = NULL;",
          "65:     EC_KEY *b = NULL;",
          "66:     BIGNUM *x_a = NULL, *y_a = NULL, *x_b = NULL, *y_b = NULL;",
          "67:     char buf[12];",
          "68:     unsigned char *abuf = NULL, *bbuf = NULL;",
          "69:     int i, alen, blen, aout, bout, ret = 0;",
          "70:     const EC_GROUP *group;",
          "72:     a = EC_KEY_new_by_curve_name(nid);",
          "73:     b = EC_KEY_new_by_curve_name(nid);",
          "74:     if (a == NULL || b == NULL)",
          "75:         goto err;",
          "77:     group = EC_KEY_get0_group(a);",
          "79:     if ((x_a = BN_new()) == NULL)",
          "80:         goto err;",
          "81:     if ((y_a = BN_new()) == NULL)",
          "82:         goto err;",
          "83:     if ((x_b = BN_new()) == NULL)",
          "84:         goto err;",
          "85:     if ((y_b = BN_new()) == NULL)",
          "86:         goto err;",
          "88:     BIO_puts(out, \"Testing key generation with \");",
          "89:     BIO_puts(out, OBJ_nid2sn(nid));",
          "90: # ifdef NOISY",
          "91:     BIO_puts(out, \"\\n\");",
          "92: # else",
          "93:     (void)BIO_flush(out);",
          "94: # endif",
          "96:     if (!EC_KEY_generate_key(a))",
          "97:         goto err;",
          "99:     if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) ==",
          "100:         NID_X9_62_prime_field) {",
          "101:         if (!EC_POINT_get_affine_coordinates_GFp",
          "102:             (group, EC_KEY_get0_public_key(a), x_a, y_a, ctx))",
          "103:             goto err;",
          "104:     }",
          "105: # ifndef OPENSSL_NO_EC2M",
          "106:     else {",
          "107:         if (!EC_POINT_get_affine_coordinates_GF2m(group,",
          "108:                                                   EC_KEY_get0_public_key(a),",
          "109:                                                   x_a, y_a, ctx))",
          "110:             goto err;",
          "111:     }",
          "112: # endif",
          "113: # ifdef NOISY",
          "114:     BIO_puts(out, \"  pri 1=\");",
          "115:     BN_print(out, a->priv_key);",
          "116:     BIO_puts(out, \"\\n  pub 1=\");",
          "117:     BN_print(out, x_a);",
          "118:     BIO_puts(out, \",\");",
          "119:     BN_print(out, y_a);",
          "120:     BIO_puts(out, \"\\n\");",
          "121: # else",
          "122:     BIO_printf(out, \" .\");",
          "123:     (void)BIO_flush(out);",
          "124: # endif",
          "126:     if (!EC_KEY_generate_key(b))",
          "127:         goto err;",
          "129:     if (EC_METHOD_get_field_type(EC_GROUP_method_of(group)) ==",
          "130:         NID_X9_62_prime_field) {",
          "131:         if (!EC_POINT_get_affine_coordinates_GFp",
          "132:             (group, EC_KEY_get0_public_key(b), x_b, y_b, ctx))",
          "133:             goto err;",
          "134:     }",
          "135: # ifndef OPENSSL_NO_EC2M",
          "136:     else {",
          "137:         if (!EC_POINT_get_affine_coordinates_GF2m(group,",
          "138:                                                   EC_KEY_get0_public_key(b),",
          "139:                                                   x_b, y_b, ctx))",
          "140:             goto err;",
          "141:     }",
          "142: # endif",
          "144: # ifdef NOISY",
          "145:     BIO_puts(out, \"  pri 2=\");",
          "146:     BN_print(out, b->priv_key);",
          "147:     BIO_puts(out, \"\\n  pub 2=\");",
          "148:     BN_print(out, x_b);",
          "149:     BIO_puts(out, \",\");",
          "150:     BN_print(out, y_b);",
          "151:     BIO_puts(out, \"\\n\");",
          "152: # else",
          "153:     BIO_printf(out, \".\");",
          "154:     (void)BIO_flush(out);",
          "155: # endif",
          "157:     alen = KDF1_SHA1_len;",
          "158:     abuf = OPENSSL_malloc(alen);",
          "159:     aout =",
          "160:         ECDH_compute_key(abuf, alen, EC_KEY_get0_public_key(b), a, KDF1_SHA1);",
          "162: # ifdef NOISY",
          "163:     BIO_puts(out, \"  key1 =\");",
          "164:     for (i = 0; i < aout; i++) {",
          "165:         sprintf(buf, \"%02X\", abuf[i]);",
          "166:         BIO_puts(out, buf);",
          "167:     }",
          "168:     BIO_puts(out, \"\\n\");",
          "169: # else",
          "170:     BIO_printf(out, \".\");",
          "171:     (void)BIO_flush(out);",
          "172: # endif",
          "174:     blen = KDF1_SHA1_len;",
          "175:     bbuf = OPENSSL_malloc(blen);",
          "176:     bout =",
          "177:         ECDH_compute_key(bbuf, blen, EC_KEY_get0_public_key(a), b, KDF1_SHA1);",
          "179: # ifdef NOISY",
          "180:     BIO_puts(out, \"  key2 =\");",
          "181:     for (i = 0; i < bout; i++) {",
          "182:         sprintf(buf, \"%02X\", bbuf[i]);",
          "183:         BIO_puts(out, buf);",
          "184:     }",
          "185:     BIO_puts(out, \"\\n\");",
          "186: # else",
          "187:     BIO_printf(out, \".\");",
          "188:     (void)BIO_flush(out);",
          "189: # endif",
          "191:     if ((aout < 4) || (bout != aout) || (memcmp(abuf, bbuf, aout) != 0)) {",
          "192: # ifndef NOISY",
          "193:         BIO_printf(out, \" failed\\n\\n\");",
          "194:         BIO_printf(out, \"key a:\\n\");",
          "195:         BIO_printf(out, \"private key: \");",
          "196:         BN_print(out, EC_KEY_get0_private_key(a));",
          "197:         BIO_printf(out, \"\\n\");",
          "198:         BIO_printf(out, \"public key (x,y): \");",
          "199:         BN_print(out, x_a);",
          "200:         BIO_printf(out, \",\");",
          "201:         BN_print(out, y_a);",
          "202:         BIO_printf(out, \"\\nkey b:\\n\");",
          "203:         BIO_printf(out, \"private key: \");",
          "204:         BN_print(out, EC_KEY_get0_private_key(b));",
          "205:         BIO_printf(out, \"\\n\");",
          "206:         BIO_printf(out, \"public key (x,y): \");",
          "207:         BN_print(out, x_b);",
          "208:         BIO_printf(out, \",\");",
          "209:         BN_print(out, y_b);",
          "210:         BIO_printf(out, \"\\n\");",
          "211:         BIO_printf(out, \"generated key a: \");",
          "212:         for (i = 0; i < bout; i++) {",
          "213:             sprintf(buf, \"%02X\", bbuf[i]);",
          "214:             BIO_puts(out, buf);",
          "215:         }",
          "216:         BIO_printf(out, \"\\n\");",
          "217:         BIO_printf(out, \"generated key b: \");",
          "218:         for (i = 0; i < aout; i++) {",
          "219:             sprintf(buf, \"%02X\", abuf[i]);",
          "220:             BIO_puts(out, buf);",
          "221:         }",
          "222:         BIO_printf(out, \"\\n\");",
          "223: # endif",
          "224:         fprintf(stderr, \"Error in ECDH routines\\n\");",
          "225:         ret = 0;",
          "226:     } else {",
          "227: # ifndef NOISY",
          "228:         BIO_printf(out, \" ok\\n\");",
          "229: # endif",
          "230:         ret = 1;",
          "231:     }",
          "232:  err:",
          "233:     ERR_print_errors_fp(stderr);",
          "235:     OPENSSL_free(abuf);",
          "236:     OPENSSL_free(bbuf);",
          "237:     BN_free(x_a);",
          "238:     BN_free(y_a);",
          "239:     BN_free(x_b);",
          "240:     BN_free(y_b);",
          "241:     EC_KEY_free(b);",
          "242:     EC_KEY_free(a);",
          "243:     return (ret);",
          "244: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "545: int main(int argc, char *argv[])",
          "546: {",
          "547:     BN_CTX *ctx = NULL;",
          "549:     EC_builtin_curve *curves = NULL;",
          "550:     size_t crv_len = 0, n = 0;",
          "551:     BIO *out;",
          "",
          "[Removed Lines]",
          "548:     int nid, ret = 1;",
          "",
          "[Added Lines]",
          "354:     int ret = 1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1320d2501d0c9c6ad9ea0dc1f5115f4e6b3e0c3b",
      "candidate_info": {
        "commit_hash": "1320d2501d0c9c6ad9ea0dc1f5115f4e6b3e0c3b",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/1320d2501d0c9c6ad9ea0dc1f5115f4e6b3e0c3b",
        "files": [
          "test/recipes/60-test_x509_store.t"
        ],
        "message": "Fix test_x509_store\n\nDon't run this test unless 'openssl rehash' works properly.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2664)\n(cherry picked from commit 73540f4729bb856ab066c6e7a57513a97e3ca36f)",
        "before_after_code_files": [
          "test/recipes/60-test_x509_store.t||test/recipes/60-test_x509_store.t"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/recipes/60-test_x509_store.t||test/recipes/60-test_x509_store.t": [
          "File: test/recipes/60-test_x509_store.t -> test/recipes/60-test_x509_store.t",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: setup(\"test_x509_store\");",
          "19: # We use 'openssl verify' for these tests, as it contains everything",
          "20: # we need to conduct these tests.  The tests here are a subset of the",
          "21: # ones found in 25-test_verify.t",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #If \"openssl rehash -help\" fails it's most likely because we're on a platform",
          "20: #that doesn't support the rehash command (e.g. Windows)",
          "21: plan skip_all => \"test_rehash is not available on this platform\"",
          "22:     unless run(app([\"openssl\", \"rehash\", \"-help\"]));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
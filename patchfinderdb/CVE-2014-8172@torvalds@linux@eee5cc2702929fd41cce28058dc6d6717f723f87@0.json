{
  "cve_id": "CVE-2014-8172",
  "cve_desc": "The filesystem implementation in the Linux kernel before 3.13 performs certain operations on lists of files with an inappropriate locking approach, which allows local users to cause a denial of service (soft lockup or system crash) via unspecified use of Asynchronous I/O (AIO) operations.",
  "repo": "torvalds/linux",
  "patch_hash": "eee5cc2702929fd41cce28058dc6d6717f723f87",
  "patch_info": {
    "commit_hash": "eee5cc2702929fd41cce28058dc6d6717f723f87",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/eee5cc2702929fd41cce28058dc6d6717f723f87",
    "files": [
      "fs/file_table.c",
      "fs/internal.h",
      "fs/open.c",
      "fs/super.c",
      "include/linux/fs.h"
    ],
    "message": "get rid of s_files and files_lock\n\nThe only thing we need it for is alt-sysrq-r (emergency remount r/o)\nand these days we can do just as well without going through the\nlist of files.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "fs/file_table.c||fs/file_table.c",
      "fs/internal.h||fs/internal.h",
      "fs/open.c||fs/open.c",
      "fs/super.c||fs/super.c",
      "include/linux/fs.h||include/linux/fs.h"
    ]
  },
  "patch_diff": {
    "fs/file_table.c||fs/file_table.c": [
      "File: fs/file_table.c -> fs/file_table.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "36:  .max_files = NR_FILE",
      "37: };",
      "42: static struct kmem_cache *filp_cachep __read_mostly;",
      "",
      "[Removed Lines]",
      "39: DEFINE_STATIC_LGLOCK(files_lglock);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "134:   return ERR_PTR(error);",
      "135:  }",
      "138:  atomic_long_set(&f->f_count, 1);",
      "139:  rwlock_init(&f->f_owner.lock);",
      "140:  spin_lock_init(&f->f_lock);",
      "",
      "[Removed Lines]",
      "137:  INIT_LIST_HEAD(&f->f_u.fu_list);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "304:  if (atomic_long_dec_and_test(&file->f_count)) {",
      "305:   struct task_struct *task = current;",
      "308:   if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {",
      "309:    init_task_work(&file->f_u.fu_rcuhead, ____fput);",
      "310:    if (!task_work_add(task, &file->f_u.fu_rcuhead, true))",
      "",
      "[Removed Lines]",
      "307:   file_sb_list_del(file);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "333: {",
      "334:  if (atomic_long_dec_and_test(&file->f_count)) {",
      "335:   struct task_struct *task = current;",
      "337:   BUG_ON(!(task->flags & PF_KTHREAD));",
      "338:   __fput(file);",
      "339:  }",
      "",
      "[Removed Lines]",
      "336:   file_sb_list_del(file);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "345: {",
      "346:  if (atomic_long_dec_and_test(&file->f_count)) {",
      "347:   security_file_free(file);",
      "349:   file_free(file);",
      "350:  }",
      "351: }",
      "471: void __init files_init(unsigned long mempages)",
      "472: {",
      "473:  unsigned long n;",
      "",
      "[Removed Lines]",
      "348:   file_sb_list_del(file);",
      "353: static inline int file_list_cpu(struct file *file)",
      "354: {",
      "355: #ifdef CONFIG_SMP",
      "356:  return file->f_sb_list_cpu;",
      "357: #else",
      "358:  return smp_processor_id();",
      "359: #endif",
      "360: }",
      "363: static inline void __file_sb_list_add(struct file *file, struct super_block *sb)",
      "364: {",
      "365:  struct list_head *list;",
      "366: #ifdef CONFIG_SMP",
      "367:  int cpu;",
      "368:  cpu = smp_processor_id();",
      "369:  file->f_sb_list_cpu = cpu;",
      "370:  list = per_cpu_ptr(sb->s_files, cpu);",
      "371: #else",
      "372:  list = &sb->s_files;",
      "373: #endif",
      "374:  list_add(&file->f_u.fu_list, list);",
      "375: }",
      "385: void file_sb_list_add(struct file *file, struct super_block *sb)",
      "386: {",
      "387:  if (likely(!(file->f_mode & FMODE_WRITE)))",
      "388:   return;",
      "389:  if (!S_ISREG(file_inode(file)->i_mode))",
      "390:   return;",
      "391:  lg_local_lock(&files_lglock);",
      "392:  __file_sb_list_add(file, sb);",
      "393:  lg_local_unlock(&files_lglock);",
      "394: }",
      "403: void file_sb_list_del(struct file *file)",
      "404: {",
      "405:  if (!list_empty(&file->f_u.fu_list)) {",
      "406:   lg_local_lock_cpu(&files_lglock, file_list_cpu(file));",
      "407:   list_del_init(&file->f_u.fu_list);",
      "408:   lg_local_unlock_cpu(&files_lglock, file_list_cpu(file));",
      "409:  }",
      "410: }",
      "412: #ifdef CONFIG_SMP",
      "418: #define do_file_list_for_each_entry(__sb, __file)  \\",
      "419: {        \\",
      "420:  int i;       \\",
      "421:  for_each_possible_cpu(i) {    \\",
      "422:   struct list_head *list;    \\",
      "423:   list = per_cpu_ptr((__sb)->s_files, i);  \\",
      "424:   list_for_each_entry((__file), list, f_u.fu_list)",
      "426: #define while_file_list_for_each_entry    \\",
      "427:  }       \\",
      "428: }",
      "430: #else",
      "432: #define do_file_list_for_each_entry(__sb, __file)  \\",
      "433: {        \\",
      "434:  struct list_head *list;     \\",
      "435:  list = &(sb)->s_files;     \\",
      "436:  list_for_each_entry((__file), list, f_u.fu_list)",
      "438: #define while_file_list_for_each_entry    \\",
      "439: }",
      "441: #endif",
      "450: void mark_files_ro(struct super_block *sb)",
      "451: {",
      "452:  struct file *f;",
      "454:  lg_global_lock(&files_lglock);",
      "455:  do_file_list_for_each_entry(sb, f) {",
      "456:   if (!file_count(f))",
      "457:    continue;",
      "458:   if (!(f->f_mode & FMODE_WRITE))",
      "459:    continue;",
      "460:   spin_lock(&f->f_lock);",
      "461:   f->f_mode &= ~FMODE_WRITE;",
      "462:   spin_unlock(&f->f_lock);",
      "463:   if (file_check_writeable(f) != 0)",
      "464:    continue;",
      "465:   __mnt_drop_write(f->f_path.mnt);",
      "466:   file_release_write(f);",
      "467:  } while_file_list_for_each_entry;",
      "468:  lg_global_unlock(&files_lglock);",
      "469: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "483:  n = (mempages * (PAGE_SIZE / 1024)) / 10;",
      "484:  files_stat.max_files = max_t(unsigned long, n, NR_FILE);",
      "485:  files_defer_init();",
      "487:  percpu_counter_init(&nr_files, 0);",
      "488: }",
      "",
      "[Removed Lines]",
      "486:  lg_lock_init(&files_lglock, \"files_lglock\");",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/internal.h||fs/internal.h": [
      "File: fs/internal.h -> fs/internal.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "79: extern struct file *get_empty_filp(void);",
      "",
      "[Removed Lines]",
      "76: extern void file_sb_list_add(struct file *f, struct super_block *sb);",
      "77: extern void file_sb_list_del(struct file *f);",
      "78: extern void mark_files_ro(struct super_block *);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/open.c||fs/open.c": [
      "File: fs/open.c -> fs/open.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "685:  }",
      "687:  f->f_mapping = inode->i_mapping;",
      "690:  if (unlikely(f->f_mode & FMODE_PATH)) {",
      "691:   f->f_op = &empty_fops;",
      "",
      "[Removed Lines]",
      "688:  file_sb_list_add(f, inode->i_sb);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "725: cleanup_all:",
      "726:  fops_put(f->f_op);",
      "728:  if (f->f_mode & FMODE_WRITE) {",
      "729:   put_write_access(inode);",
      "730:   if (!special_file(inode->i_mode)) {",
      "",
      "[Removed Lines]",
      "727:  file_sb_list_del(f);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "fs/super.c||fs/super.c": [
      "File: fs/super.c -> fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "140:  int i;",
      "141:  list_lru_destroy(&s->s_dentry_lru);",
      "142:  list_lru_destroy(&s->s_inode_lru);",
      "146:  for (i = 0; i < SB_FREEZE_LEVELS; i++)",
      "147:   percpu_counter_destroy(&s->s_writers.counter[i]);",
      "148:  security_sb_free(s);",
      "",
      "[Removed Lines]",
      "143: #ifdef CONFIG_SMP",
      "144:  free_percpu(s->s_files);",
      "145: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "172:  if (security_sb_alloc(s))",
      "173:   goto fail;",
      "184:  for (i = 0; i < SB_FREEZE_LEVELS; i++) {",
      "185:   if (percpu_counter_init(&s->s_writers.counter[i], 0) < 0)",
      "186:    goto fail;",
      "",
      "[Removed Lines]",
      "175: #ifdef CONFIG_SMP",
      "176:  s->s_files = alloc_percpu(struct list_head);",
      "177:  if (!s->s_files)",
      "178:   goto fail;",
      "179:  for_each_possible_cpu(i)",
      "180:   INIT_LIST_HEAD(per_cpu_ptr(s->s_files, i));",
      "181: #else",
      "182:  INIT_LIST_HEAD(&s->s_files);",
      "183: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "723:  if (remount_ro) {",
      "724:   if (force) {",
      "726:   } else {",
      "727:    retval = sb_prepare_remount_readonly(sb);",
      "728:    if (retval)",
      "",
      "[Removed Lines]",
      "725:    mark_files_ro(sb);",
      "",
      "[Added Lines]",
      "713:    sb->s_readonly_remount = 1;",
      "714:    smp_wmb();",
      "",
      "---------------"
    ],
    "include/linux/fs.h||include/linux/fs.h": [
      "File: include/linux/fs.h -> include/linux/fs.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "764: #define FILE_MNT_WRITE_RELEASED 2",
      "766: struct file {",
      "771:  union {",
      "773:   struct llist_node fu_llist;",
      "774:   struct rcu_head  fu_rcuhead;",
      "775:  } f_u;",
      "",
      "[Removed Lines]",
      "772:   struct list_head fu_list;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "785:  spinlock_t  f_lock;",
      "789:  atomic_long_t  f_count;",
      "790:  unsigned int   f_flags;",
      "791:  fmode_t   f_mode;",
      "",
      "[Removed Lines]",
      "786: #ifdef CONFIG_SMP",
      "787:  int   f_sb_list_cpu;",
      "788: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1273:  struct block_device *s_bdev;",
      "1274:  struct backing_dev_info *s_bdi;",
      "",
      "[Removed Lines]",
      "1267: #ifdef CONFIG_SMP",
      "1268:  struct list_head __percpu *s_files;",
      "1269: #else",
      "1270:  struct list_head s_files;",
      "1271: #endif",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f604156751db77e08afe47ce29fe8f3d51ad9b04",
      "candidate_info": {
        "commit_hash": "f604156751db77e08afe47ce29fe8f3d51ad9b04",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/f604156751db77e08afe47ce29fe8f3d51ad9b04",
        "files": [
          "fs/dcache.c",
          "fs/super.c",
          "include/linux/fs.h"
        ],
        "message": "dcache: convert to use new lru list infrastructure\n\n[glommer@openvz.org: don't reintroduce double decrement of nr_unused_dentries, adapted for new LRU return codes]\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nSigned-off-by: Glauber Costa <glommer@openvz.org>\nCc: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>\nCc: Arve Hj\u00f8nnev\u00e5g <arve@android.com>\nCc: Carlos Maiolino <cmaiolino@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Chuck Lever <chuck.lever@oracle.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: David Rientjes <rientjes@google.com>\nCc: Gleb Natapov <gleb@redhat.com>\nCc: Greg Thelen <gthelen@google.com>\nCc: J. Bruce Fields <bfields@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Jerome Glisse <jglisse@redhat.com>\nCc: John Stultz <john.stultz@linaro.org>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Kent Overstreet <koverstreet@google.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Marcelo Tosatti <mtosatti@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Steven Whitehouse <swhiteho@redhat.com>\nCc: Thomas Hellstrom <thellstrom@vmware.com>\nCc: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/dcache.c||fs/dcache.c",
          "fs/super.c||fs/super.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ],
          "candidate": [
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/dcache.c||fs/dcache.c": [
          "File: fs/dcache.c -> fs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <linux/rculist_bl.h>",
          "38: #include <linux/prefetch.h>",
          "39: #include <linux/ratelimit.h>",
          "40: #include \"internal.h\"",
          "41: #include \"mount.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #include <linux/list_lru.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "356: }",
          "361: static void dentry_lru_add(struct dentry *dentry)",
          "362: {",
          "363:  if (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST))) {",
          "365:   dentry->d_flags |= DCACHE_LRU_LIST;",
          "370:  }",
          "371: }",
          "",
          "[Removed Lines]",
          "364:   spin_lock(&dentry->d_sb->s_dentry_lru_lock);",
          "366:   list_add(&dentry->d_lru, &dentry->d_sb->s_dentry_lru);",
          "367:   dentry->d_sb->s_nr_dentry_unused++;",
          "368:   this_cpu_inc(nr_dentry_unused);",
          "369:   spin_unlock(&dentry->d_sb->s_dentry_lru_lock);",
          "373: static void __dentry_lru_del(struct dentry *dentry)",
          "374: {",
          "375:  list_del_init(&dentry->d_lru);",
          "376:  dentry->d_flags &= ~DCACHE_LRU_LIST;",
          "377:  dentry->d_sb->s_nr_dentry_unused--;",
          "378:  this_cpu_dec(nr_dentry_unused);",
          "379: }",
          "",
          "[Added Lines]",
          "365:   if (list_lru_add(&dentry->d_sb->s_dentry_lru, &dentry->d_lru))",
          "366:    this_cpu_inc(nr_dentry_unused);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "393:   return;",
          "394:  }",
          "414:   this_cpu_dec(nr_dentry_unused);",
          "417: }",
          "",
          "[Removed Lines]",
          "396:  if (!list_empty(&dentry->d_lru)) {",
          "397:   spin_lock(&dentry->d_sb->s_dentry_lru_lock);",
          "398:   __dentry_lru_del(dentry);",
          "399:   spin_unlock(&dentry->d_sb->s_dentry_lru_lock);",
          "400:  }",
          "401: }",
          "403: static void dentry_lru_move_list(struct dentry *dentry, struct list_head *list)",
          "404: {",
          "405:  BUG_ON(dentry->d_flags & DCACHE_SHRINK_LIST);",
          "407:  spin_lock(&dentry->d_sb->s_dentry_lru_lock);",
          "408:  if (list_empty(&dentry->d_lru)) {",
          "409:   dentry->d_flags |= DCACHE_LRU_LIST;",
          "410:   list_add_tail(&dentry->d_lru, list);",
          "411:  } else {",
          "412:   list_move_tail(&dentry->d_lru, list);",
          "413:   dentry->d_sb->s_nr_dentry_unused--;",
          "415:  }",
          "416:  spin_unlock(&dentry->d_sb->s_dentry_lru_lock);",
          "",
          "[Added Lines]",
          "386:  if (list_lru_del(&dentry->d_sb->s_dentry_lru, &dentry->d_lru))",
          "388:  dentry->d_flags &= ~DCACHE_LRU_LIST;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "901:  rcu_read_unlock();",
          "902: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "876: static enum lru_status",
          "877: dentry_lru_isolate(struct list_head *item, spinlock_t *lru_lock, void *arg)",
          "878: {",
          "879:  struct list_head *freeable = arg;",
          "880:  struct dentry *dentry = container_of(item, struct dentry, d_lru);",
          "888:  if (!spin_trylock(&dentry->d_lock))",
          "889:   return LRU_SKIP;",
          "896:  if (dentry->d_lockref.count) {",
          "897:   list_del_init(&dentry->d_lru);",
          "898:   spin_unlock(&dentry->d_lock);",
          "899:   return LRU_REMOVED;",
          "900:  }",
          "902:  if (dentry->d_flags & DCACHE_REFERENCED) {",
          "903:   dentry->d_flags &= ~DCACHE_REFERENCED;",
          "904:   spin_unlock(&dentry->d_lock);",
          "925:   return LRU_ROTATE;",
          "926:  }",
          "928:  dentry->d_flags |= DCACHE_SHRINK_LIST;",
          "929:  list_move_tail(&dentry->d_lru, freeable);",
          "930:  this_cpu_dec(nr_dentry_unused);",
          "931:  spin_unlock(&dentry->d_lock);",
          "933:  return LRU_REMOVED;",
          "934: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "916: long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan)",
          "917: {",
          "957:  return freed;",
          "958: }",
          "",
          "[Removed Lines]",
          "918:  struct dentry *dentry;",
          "919:  LIST_HEAD(referenced);",
          "920:  LIST_HEAD(tmp);",
          "921:  long freed = 0;",
          "923: relock:",
          "924:  spin_lock(&sb->s_dentry_lru_lock);",
          "925:  while (!list_empty(&sb->s_dentry_lru)) {",
          "926:   dentry = list_entry(sb->s_dentry_lru.prev,",
          "927:     struct dentry, d_lru);",
          "928:   BUG_ON(dentry->d_sb != sb);",
          "930:   if (!spin_trylock(&dentry->d_lock)) {",
          "931:    spin_unlock(&sb->s_dentry_lru_lock);",
          "932:    cpu_relax();",
          "933:    goto relock;",
          "934:   }",
          "936:   if (dentry->d_flags & DCACHE_REFERENCED) {",
          "937:    dentry->d_flags &= ~DCACHE_REFERENCED;",
          "938:    list_move(&dentry->d_lru, &referenced);",
          "939:    spin_unlock(&dentry->d_lock);",
          "940:   } else {",
          "941:    list_move(&dentry->d_lru, &tmp);",
          "942:    dentry->d_flags |= DCACHE_SHRINK_LIST;",
          "943:    this_cpu_dec(nr_dentry_unused);",
          "944:    sb->s_nr_dentry_unused--;",
          "945:    spin_unlock(&dentry->d_lock);",
          "946:    freed++;",
          "947:    if (!--nr_to_scan)",
          "948:     break;",
          "949:   }",
          "950:   cond_resched_lock(&sb->s_dentry_lru_lock);",
          "951:  }",
          "952:  if (!list_empty(&referenced))",
          "953:   list_splice(&referenced, &sb->s_dentry_lru);",
          "954:  spin_unlock(&sb->s_dentry_lru_lock);",
          "956:  shrink_dentry_list(&tmp);",
          "",
          "[Added Lines]",
          "950:  LIST_HEAD(dispose);",
          "951:  long freed;",
          "953:  freed = list_lru_walk(&sb->s_dentry_lru, dentry_lru_isolate,",
          "954:          &dispose, nr_to_scan);",
          "955:  shrink_dentry_list(&dispose);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "988: void shrink_dcache_sb(struct super_block *sb)",
          "989: {",
          "1008: }",
          "1009: EXPORT_SYMBOL(shrink_dcache_sb);",
          "",
          "[Removed Lines]",
          "990:  LIST_HEAD(tmp);",
          "992:  spin_lock(&sb->s_dentry_lru_lock);",
          "993:  while (!list_empty(&sb->s_dentry_lru)) {",
          "998:   list_splice_init(&sb->s_dentry_lru, &tmp);",
          "999:   this_cpu_sub(nr_dentry_unused, sb->s_nr_dentry_unused);",
          "1000:   sb->s_nr_dentry_unused = 0;",
          "1001:   spin_unlock(&sb->s_dentry_lru_lock);",
          "1003:   shrink_dcache_list(&tmp);",
          "1005:   spin_lock(&sb->s_dentry_lru_lock);",
          "1006:  }",
          "1007:  spin_unlock(&sb->s_dentry_lru_lock);",
          "",
          "[Added Lines]",
          "989:  long disposed;",
          "991:  disposed = list_lru_dispose_all(&sb->s_dentry_lru, shrink_dcache_list);",
          "992:  this_cpu_sub(nr_dentry_unused, disposed);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1366:  if (dentry->d_lockref.count) {",
          "1367:   dentry_lru_del(dentry);",
          "1368:  } else if (!(dentry->d_flags & DCACHE_SHRINK_LIST)) {",
          "1370:   dentry->d_flags |= DCACHE_SHRINK_LIST;",
          "1371:   data->found++;",
          "1372:   ret = D_WALK_NORETRY;",
          "",
          "[Removed Lines]",
          "1369:   dentry_lru_move_list(dentry, &data->dispose);",
          "",
          "[Added Lines]",
          "1354:   dentry_lru_del(dentry);",
          "1355:   list_add_tail(&dentry->d_lru, &data->dispose);",
          "",
          "---------------"
        ],
        "fs/super.c||fs/super.c": [
          "File: fs/super.c -> fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "79:   fs_objects = sb->s_op->nr_cached_objects(sb);",
          "81:  inodes = list_lru_count(&sb->s_inode_lru);",
          "87:  inodes = mult_frac(sc->nr_to_scan, inodes, total_objects);",
          "",
          "[Removed Lines]",
          "82:  total_objects = sb->s_nr_dentry_unused + inodes + fs_objects + 1;",
          "85:  dentries = mult_frac(sc->nr_to_scan, sb->s_nr_dentry_unused,",
          "86:         total_objects);",
          "",
          "[Added Lines]",
          "82:  dentries = list_lru_count(&sb->s_dentry_lru);",
          "83:  total_objects = dentries + inodes + fs_objects + 1;",
          "86:  dentries = mult_frac(sc->nr_to_scan, dentries, total_objects);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "117:  if (sb->s_op && sb->s_op->nr_cached_objects)",
          "118:   total_objects = sb->s_op->nr_cached_objects(sb);",
          "121:  total_objects += list_lru_count(&sb->s_inode_lru);",
          "123:  total_objects = vfs_pressure_ratio(total_objects);",
          "",
          "[Removed Lines]",
          "120:  total_objects += sb->s_nr_dentry_unused;",
          "",
          "[Added Lines]",
          "120:  total_objects += list_lru_count(&sb->s_dentry_lru);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "191:   INIT_HLIST_NODE(&s->s_instances);",
          "192:   INIT_HLIST_BL_HEAD(&s->s_anon);",
          "193:   INIT_LIST_HEAD(&s->s_inodes);",
          "196:   list_lru_init(&s->s_inode_lru);",
          "197:   INIT_LIST_HEAD(&s->s_mounts);",
          "198:   init_rwsem(&s->s_umount);",
          "",
          "[Removed Lines]",
          "194:   INIT_LIST_HEAD(&s->s_dentry_lru);",
          "195:   spin_lock_init(&s->s_dentry_lru_lock);",
          "",
          "[Added Lines]",
          "194:   list_lru_init(&s->s_dentry_lru);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1270:  struct list_head s_files;",
          "1271: #endif",
          "1281:  struct block_device *s_bdev;",
          "1282:  struct backing_dev_info *s_bdi;",
          "1283:  struct mtd_info  *s_mtd;",
          "",
          "[Removed Lines]",
          "1275:  spinlock_t  s_dentry_lru_lock ____cacheline_aligned_in_smp;",
          "1279:  struct list_lru  s_inode_lru ____cacheline_aligned_in_smp;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1333:  struct workqueue_struct *s_dio_done_wq;",
          "1334: };",
          "1336: extern struct timespec current_fs_time(struct super_block *sb);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1331:  struct list_lru  s_dentry_lru ____cacheline_aligned_in_smp;",
          "1332:  struct list_lru  s_inode_lru ____cacheline_aligned_in_smp;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5ca302c8e502ca53b7d75f12127ec0289904003a",
      "candidate_info": {
        "commit_hash": "5ca302c8e502ca53b7d75f12127ec0289904003a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5ca302c8e502ca53b7d75f12127ec0289904003a",
        "files": [
          "fs/super.c",
          "fs/xfs/xfs_buf.c",
          "fs/xfs/xfs_qm.c",
          "include/linux/list_lru.h",
          "mm/list_lru.c"
        ],
        "message": "list_lru: dynamically adjust node arrays\n\nWe currently use a compile-time constant to size the node array for the\nlist_lru structure.  Due to this, we don't need to allocate any memory at\ninitialization time.  But as a consequence, the structures that contain\nembedded list_lru lists can become way too big (the superblock for\ninstance contains two of them).\n\nThis patch aims at ameliorating this situation by dynamically allocating\nthe node arrays with the firmware provided nr_node_ids.\n\nSigned-off-by: Glauber Costa <glommer@openvz.org>\nCc: Dave Chinner <dchinner@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>\nCc: Arve Hj\u00f8nnev\u00e5g <arve@android.com>\nCc: Carlos Maiolino <cmaiolino@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Chuck Lever <chuck.lever@oracle.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: David Rientjes <rientjes@google.com>\nCc: Gleb Natapov <gleb@redhat.com>\nCc: Greg Thelen <gthelen@google.com>\nCc: J. Bruce Fields <bfields@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Jerome Glisse <jglisse@redhat.com>\nCc: John Stultz <john.stultz@linaro.org>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Kent Overstreet <koverstreet@google.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Marcelo Tosatti <mtosatti@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Steven Whitehouse <swhiteho@redhat.com>\nCc: Thomas Hellstrom <thellstrom@vmware.com>\nCc: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/super.c||fs/super.c",
          "fs/xfs/xfs_buf.c||fs/xfs/xfs_buf.c",
          "fs/xfs/xfs_qm.c||fs/xfs/xfs_qm.c",
          "include/linux/list_lru.h||include/linux/list_lru.h",
          "mm/list_lru.c||mm/list_lru.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/super.c||fs/super.c"
          ],
          "candidate": [
            "fs/super.c||fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/super.c||fs/super.c": [
          "File: fs/super.c -> fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "195:   INIT_HLIST_NODE(&s->s_instances);",
          "196:   INIT_HLIST_BL_HEAD(&s->s_anon);",
          "197:   INIT_LIST_HEAD(&s->s_inodes);",
          "200:   INIT_LIST_HEAD(&s->s_mounts);",
          "201:   init_rwsem(&s->s_umount);",
          "202:   lockdep_set_class(&s->s_umount, &type->s_umount_key);",
          "",
          "[Removed Lines]",
          "198:   list_lru_init(&s->s_dentry_lru);",
          "199:   list_lru_init(&s->s_inode_lru);",
          "",
          "[Added Lines]",
          "199:   if (list_lru_init(&s->s_dentry_lru))",
          "200:    goto err_out;",
          "201:   if (list_lru_init(&s->s_inode_lru))",
          "202:    goto err_out_dentry_lru;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "236:  }",
          "237: out:",
          "238:  return s;",
          "239: err_out:",
          "240:  security_sb_free(s);",
          "241: #ifdef CONFIG_SMP",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "244: err_out_dentry_lru:",
          "245:  list_lru_destroy(&s->s_dentry_lru);",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_buf.c||fs/xfs/xfs_buf.c": [
          "File: fs/xfs/xfs_buf.c -> fs/xfs/xfs_buf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1592:  struct xfs_mount *mp,",
          "1593:  struct xfs_buftarg *btp)",
          "1594: {",
          "1595:  unregister_shrinker(&btp->bt_shrinker);",
          "1597:  if (mp->m_flags & XFS_MOUNT_BARRIER)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1595:  list_lru_destroy(&btp->bt_lru);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1666:  if (!btp->bt_bdi)",
          "1667:   goto error;",
          "1670:  if (xfs_setsize_buftarg_early(btp, bdev))",
          "1671:   goto error;",
          "1672:  btp->bt_shrinker.count_objects = xfs_buftarg_shrink_count;",
          "1673:  btp->bt_shrinker.scan_objects = xfs_buftarg_shrink_scan;",
          "1674:  btp->bt_shrinker.seeks = DEFAULT_SEEKS;",
          "",
          "[Removed Lines]",
          "1669:  list_lru_init(&btp->bt_lru);",
          "",
          "[Added Lines]",
          "1673:  if (list_lru_init(&btp->bt_lru))",
          "1674:   goto error;",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_qm.c||fs/xfs/xfs_qm.c": [
          "File: fs/xfs/xfs_qm.c -> fs/xfs/xfs_qm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "832:  qinf = mp->m_quotainfo = kmem_zalloc(sizeof(xfs_quotainfo_t), KM_SLEEP);",
          "838:  if ((error = xfs_qm_init_quotainos(mp))) {",
          "839:   kmem_free(qinf);",
          "840:   mp->m_quotainfo = NULL;",
          "841:   return error;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "834:  if ((error = list_lru_init(&qinf->qi_lru))) {",
          "835:   kmem_free(qinf);",
          "836:   mp->m_quotainfo = NULL;",
          "837:   return error;",
          "838:  }",
          "845:   list_lru_destroy(&qinf->qi_lru);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "846:  INIT_RADIX_TREE(&qinf->qi_pquota_tree, GFP_NOFS);",
          "847:  mutex_init(&qinf->qi_tree_lock);",
          "852:  mutex_init(&qinf->qi_quotaofflock);",
          "",
          "[Removed Lines]",
          "849:  list_lru_init(&qinf->qi_lru);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "935:  qi = mp->m_quotainfo;",
          "936:  ASSERT(qi != NULL);",
          "938:  unregister_shrinker(&qi->qi_shrinker);",
          "940:  if (qi->qi_uquotaip) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "943:  list_lru_destroy(&qi->qi_lru);",
          "",
          "---------------"
        ],
        "include/linux/list_lru.h||include/linux/list_lru.h": [
          "File: include/linux/list_lru.h -> include/linux/list_lru.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: } ____cacheline_aligned_in_smp;",
          "29: struct list_lru {",
          "41:  nodemask_t  active_nodes;",
          "42: };",
          "44: int list_lru_init(struct list_lru *lru);",
          "",
          "[Removed Lines]",
          "40:  struct list_lru_node node[MAX_NUMNODES];",
          "",
          "[Added Lines]",
          "30:  struct list_lru_node *node;",
          "34: void list_lru_destroy(struct list_lru *lru);",
          "",
          "---------------"
        ],
        "mm/list_lru.c||mm/list_lru.c": [
          "File: mm/list_lru.c -> mm/list_lru.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include <linux/module.h>",
          "9: #include <linux/mm.h>",
          "10: #include <linux/list_lru.h>",
          "12: bool list_lru_add(struct list_lru *lru, struct list_head *item)",
          "13: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11: #include <linux/slab.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115: int list_lru_init(struct list_lru *lru)",
          "116: {",
          "117:  int i;",
          "119:  nodes_clear(lru->active_nodes);",
          "121:   spin_lock_init(&lru->node[i].lock);",
          "122:   INIT_LIST_HEAD(&lru->node[i].list);",
          "123:   lru->node[i].nr_items = 0;",
          "",
          "[Removed Lines]",
          "120:  for (i = 0; i < MAX_NUMNODES; i++) {",
          "",
          "[Added Lines]",
          "119:  size_t size = sizeof(*lru->node) * nr_node_ids;",
          "121:  lru->node = kzalloc(size, GFP_KERNEL);",
          "122:  if (!lru->node)",
          "123:   return -ENOMEM;",
          "126:  for (i = 0; i < nr_node_ids; i++) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "125:  return 0;",
          "126: }",
          "127: EXPORT_SYMBOL_GPL(list_lru_init);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "135: void list_lru_destroy(struct list_lru *lru)",
          "136: {",
          "137:  kfree(lru->node);",
          "138: }",
          "139: EXPORT_SYMBOL_GPL(list_lru_destroy);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bc3b14cb2d505dda969dbe3a31038dbb24aca945",
      "candidate_info": {
        "commit_hash": "bc3b14cb2d505dda969dbe3a31038dbb24aca945",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/bc3b14cb2d505dda969dbe3a31038dbb24aca945",
        "files": [
          "fs/inode.c",
          "fs/super.c",
          "include/linux/fs.h"
        ],
        "message": "inode: convert inode lru list to generic lru list code.\n\n[glommer@openvz.org: adapted for new LRU return codes]\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nSigned-off-by: Glauber Costa <glommer@openvz.org>\nCc: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>\nCc: Arve Hj\u00f8nnev\u00e5g <arve@android.com>\nCc: Carlos Maiolino <cmaiolino@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Chuck Lever <chuck.lever@oracle.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: David Rientjes <rientjes@google.com>\nCc: Gleb Natapov <gleb@redhat.com>\nCc: Greg Thelen <gthelen@google.com>\nCc: J. Bruce Fields <bfields@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Jerome Glisse <jglisse@redhat.com>\nCc: John Stultz <john.stultz@linaro.org>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Kent Overstreet <koverstreet@google.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Marcelo Tosatti <mtosatti@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Steven Whitehouse <swhiteho@redhat.com>\nCc: Thomas Hellstrom <thellstrom@vmware.com>\nCc: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/inode.c||fs/inode.c",
          "fs/super.c||fs/super.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ],
          "candidate": [
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/inode.c||fs/inode.c": [
          "File: fs/inode.c -> fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #include <linux/prefetch.h>",
          "19: #include <linux/ratelimit.h>",
          "20: #include \"internal.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include <linux/list_lru.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "402: static void inode_lru_list_add(struct inode *inode)",
          "403: {",
          "408:   this_cpu_inc(nr_unused);",
          "411: }",
          "",
          "[Removed Lines]",
          "404:  spin_lock(&inode->i_sb->s_inode_lru_lock);",
          "405:  if (list_empty(&inode->i_lru)) {",
          "406:   list_add(&inode->i_lru, &inode->i_sb->s_inode_lru);",
          "407:   inode->i_sb->s_nr_inodes_unused++;",
          "409:  }",
          "410:  spin_unlock(&inode->i_sb->s_inode_lru_lock);",
          "",
          "[Added Lines]",
          "405:  if (list_lru_add(&inode->i_sb->s_inode_lru, &inode->i_lru))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "426: static void inode_lru_list_del(struct inode *inode)",
          "427: {",
          "432:   this_cpu_dec(nr_unused);",
          "435: }",
          "",
          "[Removed Lines]",
          "428:  spin_lock(&inode->i_sb->s_inode_lru_lock);",
          "429:  if (!list_empty(&inode->i_lru)) {",
          "430:   list_del_init(&inode->i_lru);",
          "431:   inode->i_sb->s_nr_inodes_unused--;",
          "433:  }",
          "434:  spin_unlock(&inode->i_sb->s_inode_lru_lock);",
          "",
          "[Added Lines]",
          "425:  if (list_lru_del(&inode->i_sb->s_inode_lru, &inode->i_lru))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "675:  return busy;",
          "676: }",
          "",
          "[Removed Lines]",
          "678: static int can_unuse(struct inode *inode)",
          "679: {",
          "680:  if (inode->i_state & ~I_REFERENCED)",
          "681:   return 0;",
          "682:  if (inode_has_buffers(inode))",
          "683:   return 0;",
          "684:  if (atomic_read(&inode->i_count))",
          "685:   return 0;",
          "686:  if (inode->i_data.nrpages)",
          "687:   return 0;",
          "688:  return 1;",
          "689: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "710: {",
          "733:   }",
          "793:  dispose_list(&freeable);",
          "794:  return freed;",
          "795: }",
          "",
          "[Removed Lines]",
          "709: long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan)",
          "711:  LIST_HEAD(freeable);",
          "712:  long nr_scanned;",
          "713:  long freed = 0;",
          "714:  unsigned long reap = 0;",
          "716:  spin_lock(&sb->s_inode_lru_lock);",
          "717:  for (nr_scanned = nr_to_scan; nr_scanned >= 0; nr_scanned--) {",
          "718:   struct inode *inode;",
          "720:   if (list_empty(&sb->s_inode_lru))",
          "721:    break;",
          "723:   inode = list_entry(sb->s_inode_lru.prev, struct inode, i_lru);",
          "730:   if (!spin_trylock(&inode->i_lock)) {",
          "731:    list_move(&inode->i_lru, &sb->s_inode_lru);",
          "732:    continue;",
          "739:   if (atomic_read(&inode->i_count) ||",
          "740:       (inode->i_state & ~I_REFERENCED)) {",
          "741:    list_del_init(&inode->i_lru);",
          "742:    spin_unlock(&inode->i_lock);",
          "743:    sb->s_nr_inodes_unused--;",
          "744:    this_cpu_dec(nr_unused);",
          "745:    continue;",
          "746:   }",
          "749:   if (inode->i_state & I_REFERENCED) {",
          "750:    inode->i_state &= ~I_REFERENCED;",
          "751:    list_move(&inode->i_lru, &sb->s_inode_lru);",
          "752:    spin_unlock(&inode->i_lock);",
          "753:    continue;",
          "754:   }",
          "755:   if (inode_has_buffers(inode) || inode->i_data.nrpages) {",
          "756:    __iget(inode);",
          "757:    spin_unlock(&inode->i_lock);",
          "758:    spin_unlock(&sb->s_inode_lru_lock);",
          "759:    if (remove_inode_buffers(inode))",
          "760:     reap += invalidate_mapping_pages(&inode->i_data,",
          "761:         0, -1);",
          "762:    iput(inode);",
          "763:    spin_lock(&sb->s_inode_lru_lock);",
          "765:    if (inode != list_entry(sb->s_inode_lru.next,",
          "766:       struct inode, i_lru))",
          "769:    if (!spin_trylock(&inode->i_lock))",
          "770:     continue;",
          "771:    if (!can_unuse(inode)) {",
          "772:     spin_unlock(&inode->i_lock);",
          "773:     continue;",
          "774:    }",
          "775:   }",
          "776:   WARN_ON(inode->i_state & I_NEW);",
          "777:   inode->i_state |= I_FREEING;",
          "778:   spin_unlock(&inode->i_lock);",
          "780:   list_move(&inode->i_lru, &freeable);",
          "781:   sb->s_nr_inodes_unused--;",
          "782:   this_cpu_dec(nr_unused);",
          "783:   freed++;",
          "784:  }",
          "785:  if (current_is_kswapd())",
          "786:   __count_vm_events(KSWAPD_INODESTEAL, reap);",
          "787:  else",
          "788:   __count_vm_events(PGINODESTEAL, reap);",
          "789:  spin_unlock(&sb->s_inode_lru_lock);",
          "790:  if (current->reclaim_state)",
          "791:   current->reclaim_state->reclaimed_slab += reap;",
          "",
          "[Added Lines]",
          "685: static enum lru_status",
          "686: inode_lru_isolate(struct list_head *item, spinlock_t *lru_lock, void *arg)",
          "688:  struct list_head *freeable = arg;",
          "689:  struct inode *inode = container_of(item, struct inode, i_lru);",
          "695:  if (!spin_trylock(&inode->i_lock))",
          "696:   return LRU_SKIP;",
          "702:  if (atomic_read(&inode->i_count) ||",
          "703:      (inode->i_state & ~I_REFERENCED)) {",
          "704:   list_del_init(&inode->i_lru);",
          "705:   spin_unlock(&inode->i_lock);",
          "706:   this_cpu_dec(nr_unused);",
          "707:   return LRU_REMOVED;",
          "708:  }",
          "711:  if (inode->i_state & I_REFERENCED) {",
          "712:   inode->i_state &= ~I_REFERENCED;",
          "713:   spin_unlock(&inode->i_lock);",
          "714:   return LRU_ROTATE;",
          "715:  }",
          "717:  if (inode_has_buffers(inode) || inode->i_data.nrpages) {",
          "718:   __iget(inode);",
          "719:   spin_unlock(&inode->i_lock);",
          "720:   spin_unlock(lru_lock);",
          "721:   if (remove_inode_buffers(inode)) {",
          "722:    unsigned long reap;",
          "723:    reap = invalidate_mapping_pages(&inode->i_data, 0, -1);",
          "724:    if (current_is_kswapd())",
          "725:     __count_vm_events(KSWAPD_INODESTEAL, reap);",
          "726:    else",
          "727:     __count_vm_events(PGINODESTEAL, reap);",
          "728:    if (current->reclaim_state)",
          "729:     current->reclaim_state->reclaimed_slab += reap;",
          "731:   iput(inode);",
          "732:   spin_lock(lru_lock);",
          "733:   return LRU_RETRY;",
          "734:  }",
          "736:  WARN_ON(inode->i_state & I_NEW);",
          "737:  inode->i_state |= I_FREEING;",
          "738:  spin_unlock(&inode->i_lock);",
          "740:  list_move(&inode->i_lru, freeable);",
          "741:  this_cpu_dec(nr_unused);",
          "742:  return LRU_REMOVED;",
          "743: }",
          "751: long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan)",
          "752: {",
          "753:  LIST_HEAD(freeable);",
          "754:  long freed;",
          "756:  freed = list_lru_walk(&sb->s_inode_lru, inode_lru_isolate,",
          "757:       &freeable, nr_to_scan);",
          "",
          "---------------"
        ],
        "fs/super.c||fs/super.c": [
          "File: fs/super.c -> fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "78:  if (sb->s_op->nr_cached_objects)",
          "79:   fs_objects = sb->s_op->nr_cached_objects(sb);",
          "85:  dentries = mult_frac(sc->nr_to_scan, sb->s_nr_dentry_unused,",
          "86:         total_objects);",
          "",
          "[Removed Lines]",
          "81:  total_objects = sb->s_nr_dentry_unused +",
          "82:    sb->s_nr_inodes_unused + fs_objects + 1;",
          "87:  inodes = mult_frac(sc->nr_to_scan, sb->s_nr_inodes_unused,",
          "88:         total_objects);",
          "",
          "[Added Lines]",
          "81:  inodes = list_lru_count(&sb->s_inode_lru);",
          "82:  total_objects = sb->s_nr_dentry_unused + inodes + fs_objects + 1;",
          "87:  inodes = mult_frac(sc->nr_to_scan, inodes, total_objects);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:   total_objects = sb->s_op->nr_cached_objects(sb);",
          "121:  total_objects += sb->s_nr_dentry_unused;",
          "124:  total_objects = vfs_pressure_ratio(total_objects);",
          "125:  drop_super(sb);",
          "",
          "[Removed Lines]",
          "122:  total_objects += sb->s_nr_inodes_unused;",
          "",
          "[Added Lines]",
          "121:  total_objects += list_lru_count(&sb->s_inode_lru);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "194:   INIT_LIST_HEAD(&s->s_inodes);",
          "195:   INIT_LIST_HEAD(&s->s_dentry_lru);",
          "196:   spin_lock_init(&s->s_dentry_lru_lock);",
          "199:   INIT_LIST_HEAD(&s->s_mounts);",
          "200:   init_rwsem(&s->s_umount);",
          "201:   lockdep_set_class(&s->s_umount, &type->s_umount_key);",
          "",
          "[Removed Lines]",
          "197:   INIT_LIST_HEAD(&s->s_inode_lru);",
          "198:   spin_lock_init(&s->s_inode_lru_lock);",
          "",
          "[Added Lines]",
          "196:   list_lru_init(&s->s_inode_lru);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include <linux/stat.h>",
          "11: #include <linux/cache.h>",
          "12: #include <linux/list.h>",
          "13: #include <linux/llist.h>",
          "14: #include <linux/radix-tree.h>",
          "15: #include <linux/rbtree.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #include <linux/list_lru.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1283:  struct block_device *s_bdev;",
          "1284:  struct backing_dev_info *s_bdi;",
          "",
          "[Removed Lines]",
          "1279:  spinlock_t  s_inode_lru_lock ____cacheline_aligned_in_smp;",
          "",
          "[Added Lines]",
          "1279:  struct list_lru  s_inode_lru ____cacheline_aligned_in_smp;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e7b2c4069252732d52f1de6d1f7c82d99a156659",
      "candidate_info": {
        "commit_hash": "e7b2c4069252732d52f1de6d1f7c82d99a156659",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e7b2c4069252732d52f1de6d1f7c82d99a156659",
        "files": [
          "fs/file_table.c"
        ],
        "message": "fput: task_work_add() can fail if the caller has passed exit_task_work()\n\nfput() assumes that it can't be called after exit_task_work() but\nthis is not true, for example free_ipc_ns()->shm_destroy() can do\nthis. In this case fput() silently leaks the file.\n\nChange it to fallback to delayed_fput_work if task_work_add() fails.\nThe patch looks complicated but it is not, it changes the code from\n\n\tif (PF_KTHREAD) {\n\t\tschedule_work(...);\n\t\treturn;\n\t}\n\ttask_work_add(...)\n\nto\n\tif (!PF_KTHREAD) {\n\t\tif (!task_work_add(...))\n\t\t\treturn;\n\t\t/* fallback */\n\t}\n\tschedule_work(...);\n\nAs for shm_destroy() in particular, we could make another fix but I\nthink this change makes sense anyway. There could be another similar\nuser, it is not safe to assume that task_work_add() can't fail.\n\nReported-by: Andrey Vagin <avagin@openvz.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/file_table.c||fs/file_table.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/file_table.c||fs/file_table.c"
          ],
          "candidate": [
            "fs/file_table.c||fs/file_table.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/file_table.c||fs/file_table.c": [
          "File: fs/file_table.c -> fs/file_table.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "306: {",
          "307:  if (atomic_long_dec_and_test(&file->f_count)) {",
          "308:   struct task_struct *task = current;",
          "309:   file_sb_list_del(file);",
          "317:   }",
          "320:  }",
          "321: }",
          "",
          "[Removed Lines]",
          "310:   if (unlikely(in_interrupt() || task->flags & PF_KTHREAD)) {",
          "311:    unsigned long flags;",
          "312:    spin_lock_irqsave(&delayed_fput_lock, flags);",
          "313:    list_add(&file->f_u.fu_list, &delayed_fput_list);",
          "314:    schedule_work(&delayed_fput_work);",
          "315:    spin_unlock_irqrestore(&delayed_fput_lock, flags);",
          "316:    return;",
          "318:   init_task_work(&file->f_u.fu_rcuhead, ____fput);",
          "319:   task_work_add(task, &file->f_u.fu_rcuhead, true);",
          "",
          "[Added Lines]",
          "309:   unsigned long flags;",
          "312:   if (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {",
          "313:    init_task_work(&file->f_u.fu_rcuhead, ____fput);",
          "314:    if (!task_work_add(task, &file->f_u.fu_rcuhead, true))",
          "315:     return;",
          "317:   spin_lock_irqsave(&delayed_fput_lock, flags);",
          "318:   list_add(&file->f_u.fu_list, &delayed_fput_list);",
          "319:   schedule_work(&delayed_fput_work);",
          "320:   spin_unlock_irqrestore(&delayed_fput_lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a234c6dcb79a270803f5c9773ed650b78730962",
      "candidate_info": {
        "commit_hash": "0a234c6dcb79a270803f5c9773ed650b78730962",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0a234c6dcb79a270803f5c9773ed650b78730962",
        "files": [
          "fs/dcache.c",
          "fs/inode.c",
          "fs/internal.h",
          "fs/super.c",
          "fs/xfs/xfs_icache.c",
          "fs/xfs/xfs_icache.h",
          "fs/xfs/xfs_super.c",
          "include/linux/fs.h"
        ],
        "message": "shrinker: convert superblock shrinkers to new API\n\nConvert superblock shrinker to use the new count/scan API, and propagate\nthe API changes through to the filesystem callouts.  The filesystem\ncallouts already use a count/scan API, so it's just changing counters to\nlongs to match the VM API.\n\nThis requires the dentry and inode shrinker callouts to be converted to\nthe count/scan API.  This is mainly a mechanical change.\n\n[glommer@openvz.org: use mult_frac for fractional proportions, build fixes]\nSigned-off-by: Dave Chinner <dchinner@redhat.com>\nSigned-off-by: Glauber Costa <glommer@openvz.org>\nAcked-by: Mel Gorman <mgorman@suse.de>\nCc: \"Theodore Ts'o\" <tytso@mit.edu>\nCc: Adrian Hunter <adrian.hunter@intel.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: Artem Bityutskiy <artem.bityutskiy@linux.intel.com>\nCc: Arve Hj\u00f8nnev\u00e5g <arve@android.com>\nCc: Carlos Maiolino <cmaiolino@redhat.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Chuck Lever <chuck.lever@oracle.com>\nCc: Daniel Vetter <daniel.vetter@ffwll.ch>\nCc: David Rientjes <rientjes@google.com>\nCc: Gleb Natapov <gleb@redhat.com>\nCc: Greg Thelen <gthelen@google.com>\nCc: J. Bruce Fields <bfields@redhat.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Jerome Glisse <jglisse@redhat.com>\nCc: John Stultz <john.stultz@linaro.org>\nCc: KAMEZAWA Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Kent Overstreet <koverstreet@google.com>\nCc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>\nCc: Marcelo Tosatti <mtosatti@redhat.com>\nCc: Mel Gorman <mgorman@suse.de>\nCc: Steven Whitehouse <swhiteho@redhat.com>\nCc: Thomas Hellstrom <thellstrom@vmware.com>\nCc: Trond Myklebust <Trond.Myklebust@netapp.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/dcache.c||fs/dcache.c",
          "fs/inode.c||fs/inode.c",
          "fs/internal.h||fs/internal.h",
          "fs/super.c||fs/super.c",
          "fs/xfs/xfs_icache.c||fs/xfs/xfs_icache.c",
          "fs/xfs/xfs_icache.h||fs/xfs/xfs_icache.h",
          "fs/xfs/xfs_super.c||fs/xfs/xfs_super.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/internal.h||fs/internal.h",
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ],
          "candidate": [
            "fs/internal.h||fs/internal.h",
            "fs/super.c||fs/super.c",
            "include/linux/fs.h||include/linux/fs.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/dcache.c||fs/dcache.c": [
          "File: fs/dcache.c -> fs/dcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "917: {",
          "918:  struct dentry *dentry;",
          "919:  LIST_HEAD(referenced);",
          "920:  LIST_HEAD(tmp);",
          "922: relock:",
          "923:  spin_lock(&sb->s_dentry_lru_lock);",
          "",
          "[Removed Lines]",
          "916: void prune_dcache_sb(struct super_block *sb, int count)",
          "",
          "[Added Lines]",
          "916: long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan)",
          "921:  long freed = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "942:    this_cpu_dec(nr_dentry_unused);",
          "943:    sb->s_nr_dentry_unused--;",
          "944:    spin_unlock(&dentry->d_lock);",
          "946:     break;",
          "947:   }",
          "948:   cond_resched_lock(&sb->s_dentry_lru_lock);",
          "",
          "[Removed Lines]",
          "945:    if (!--count)",
          "",
          "[Added Lines]",
          "946:    freed++;",
          "947:    if (!--nr_to_scan)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "952:  spin_unlock(&sb->s_dentry_lru_lock);",
          "954:  shrink_dentry_list(&tmp);",
          "955: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "957:  return freed;",
          "",
          "---------------"
        ],
        "fs/inode.c||fs/inode.c": [
          "File: fs/inode.c -> fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "710: {",
          "711:  LIST_HEAD(freeable);",
          "713:  unsigned long reap = 0;",
          "715:  spin_lock(&sb->s_inode_lru_lock);",
          "",
          "[Removed Lines]",
          "709: void prune_icache_sb(struct super_block *sb, int nr_to_scan)",
          "712:  int nr_scanned;",
          "",
          "[Added Lines]",
          "709: long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan)",
          "712:  long nr_scanned;",
          "713:  long freed = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "779:   list_move(&inode->i_lru, &freeable);",
          "780:   sb->s_nr_inodes_unused--;",
          "781:   this_cpu_dec(nr_unused);",
          "782:  }",
          "783:  if (current_is_kswapd())",
          "784:   __count_vm_events(KSWAPD_INODESTEAL, reap);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "783:   freed++;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "789:   current->reclaim_state->reclaimed_slab += reap;",
          "791:  dispose_list(&freeable);",
          "792: }",
          "794: static void __wait_on_freeing_inode(struct inode *inode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "794:  return freed;",
          "",
          "---------------"
        ],
        "fs/internal.h||fs/internal.h": [
          "File: fs/internal.h -> fs/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "116: extern spinlock_t inode_sb_list_lock;",
          "117: extern void inode_add_lru(struct inode *inode);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117: extern long prune_icache_sb(struct super_block *sb, unsigned long nr_to_scan);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131: extern struct dentry *__d_alloc(struct super_block *, const struct qstr *);",
          "132: extern int d_set_mounted(struct dentry *dentry);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134: extern long prune_dcache_sb(struct super_block *sb, unsigned long nr_to_scan);",
          "",
          "---------------"
        ],
        "fs/super.c||fs/super.c": [
          "File: fs/super.c -> fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: {",
          "58:  struct super_block *sb;",
          "62:  sb = container_of(shrink, struct super_block, s_shrink);",
          "",
          "[Removed Lines]",
          "56: static int prune_super(struct shrinker *shrink, struct shrink_control *sc)",
          "59:  int fs_objects = 0;",
          "60:  int total_objects;",
          "",
          "[Added Lines]",
          "56: static unsigned long super_cache_scan(struct shrinker *shrink,",
          "57:           struct shrink_control *sc)",
          "60:  long fs_objects = 0;",
          "61:  long total_objects;",
          "62:  long freed = 0;",
          "63:  long dentries;",
          "64:  long inodes;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "71:  if (!grab_super_passive(sb))",
          "74:  if (sb->s_op->nr_cached_objects)",
          "75:   fs_objects = sb->s_op->nr_cached_objects(sb);",
          "",
          "[Removed Lines]",
          "68:  if (sc->nr_to_scan && !(sc->gfp_mask & __GFP_FS))",
          "69:   return -1;",
          "72:   return -1;",
          "",
          "[Added Lines]",
          "72:  if (!(sc->gfp_mask & __GFP_FS))",
          "73:   return SHRINK_STOP;",
          "76:   return SHRINK_STOP;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "77:  total_objects = sb->s_nr_dentry_unused +",
          "78:    sb->s_nr_inodes_unused + fs_objects + 1;",
          "105:  }",
          "107:  total_objects = vfs_pressure_ratio(total_objects);",
          "108:  drop_super(sb);",
          "109:  return total_objects;",
          "",
          "[Removed Lines]",
          "80:  if (sc->nr_to_scan) {",
          "81:   int dentries;",
          "82:   int inodes;",
          "85:   dentries = mult_frac(sc->nr_to_scan, sb->s_nr_dentry_unused,",
          "86:        total_objects);",
          "87:   inodes = mult_frac(sc->nr_to_scan, sb->s_nr_inodes_unused,",
          "88:        total_objects);",
          "89:   if (fs_objects)",
          "90:    fs_objects = mult_frac(sc->nr_to_scan, fs_objects,",
          "91:        total_objects);",
          "96:   prune_dcache_sb(sb, dentries);",
          "97:   prune_icache_sb(sb, inodes);",
          "99:   if (fs_objects && sb->s_op->free_cached_objects) {",
          "100:    sb->s_op->free_cached_objects(sb, fs_objects);",
          "101:    fs_objects = sb->s_op->nr_cached_objects(sb);",
          "102:   }",
          "103:   total_objects = sb->s_nr_dentry_unused +",
          "104:     sb->s_nr_inodes_unused + fs_objects;",
          "",
          "[Added Lines]",
          "85:  dentries = mult_frac(sc->nr_to_scan, sb->s_nr_dentry_unused,",
          "86:         total_objects);",
          "87:  inodes = mult_frac(sc->nr_to_scan, sb->s_nr_inodes_unused,",
          "88:         total_objects);",
          "94:  freed = prune_dcache_sb(sb, dentries);",
          "95:  freed += prune_icache_sb(sb, inodes);",
          "97:  if (fs_objects) {",
          "98:   fs_objects = mult_frac(sc->nr_to_scan, fs_objects,",
          "99:         total_objects);",
          "100:   freed += sb->s_op->free_cached_objects(sb, fs_objects);",
          "103:  drop_super(sb);",
          "104:  return freed;",
          "105: }",
          "107: static unsigned long super_cache_count(struct shrinker *shrink,",
          "108:            struct shrink_control *sc)",
          "109: {",
          "110:  struct super_block *sb;",
          "111:  long total_objects = 0;",
          "113:  sb = container_of(shrink, struct super_block, s_shrink);",
          "115:  if (!grab_super_passive(sb))",
          "116:   return 0;",
          "118:  if (sb->s_op && sb->s_op->nr_cached_objects)",
          "119:   total_objects = sb->s_op->nr_cached_objects(sb);",
          "121:  total_objects += sb->s_nr_dentry_unused;",
          "122:  total_objects += sb->s_nr_inodes_unused;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "211:   s->cleancache_poolid = -1;",
          "213:   s->s_shrink.seeks = DEFAULT_SEEKS;",
          "215:   s->s_shrink.batch = 1024;",
          "216:  }",
          "217: out:",
          "",
          "[Removed Lines]",
          "214:   s->s_shrink.shrink = prune_super;",
          "",
          "[Added Lines]",
          "231:   s->s_shrink.scan_objects = super_cache_scan;",
          "232:   s->s_shrink.count_objects = super_cache_count;",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_icache.c||fs/xfs/xfs_icache.c": [
          "File: fs/xfs/xfs_icache.c -> fs/xfs/xfs_icache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1171: xfs_reclaim_inodes_nr(",
          "1172:  struct xfs_mount *mp,",
          "1173:  int   nr_to_scan)",
          "",
          "[Removed Lines]",
          "1170: void",
          "",
          "[Added Lines]",
          "1170: long",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1176:  xfs_reclaim_work_queue(mp);",
          "1177:  xfs_ail_push_all(mp->m_ail);",
          "1180: }",
          "",
          "[Removed Lines]",
          "1179:  xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);",
          "",
          "[Added Lines]",
          "1179:  return xfs_reclaim_inodes_ag(mp, SYNC_TRYLOCK | SYNC_WAIT, &nr_to_scan);",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_icache.h||fs/xfs/xfs_icache.h": [
          "File: fs/xfs/xfs_icache.h -> fs/xfs/xfs_icache.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "47: int xfs_reclaim_inodes(struct xfs_mount *mp, int mode);",
          "48: int xfs_reclaim_inodes_count(struct xfs_mount *mp);",
          "51: void xfs_inode_set_reclaim_tag(struct xfs_inode *ip);",
          "",
          "[Removed Lines]",
          "49: void xfs_reclaim_inodes_nr(struct xfs_mount *mp, int nr_to_scan);",
          "",
          "[Added Lines]",
          "49: long xfs_reclaim_inodes_nr(struct xfs_mount *mp, int nr_to_scan);",
          "",
          "---------------"
        ],
        "fs/xfs/xfs_super.c||fs/xfs/xfs_super.c": [
          "File: fs/xfs/xfs_super.c -> fs/xfs/xfs_super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1535:  return mount_bdev(fs_type, flags, dev_name, data, xfs_fs_fill_super);",
          "1536: }",
          "1539: xfs_fs_nr_cached_objects(",
          "1540:  struct super_block *sb)",
          "1541: {",
          "1542:  return xfs_reclaim_inodes_count(XFS_M(sb));",
          "1543: }",
          "1546: xfs_fs_free_cached_objects(",
          "1547:  struct super_block *sb,",
          "1549: {",
          "1551: }",
          "1553: static const struct super_operations xfs_super_operations = {",
          "",
          "[Removed Lines]",
          "1538: static int",
          "1545: static void",
          "1548:  int   nr_to_scan)",
          "1550:  xfs_reclaim_inodes_nr(XFS_M(sb), nr_to_scan);",
          "",
          "[Added Lines]",
          "1538: static long",
          "1545: static long",
          "1548:  long   nr_to_scan)",
          "1550:  return xfs_reclaim_inodes_nr(XFS_M(sb), nr_to_scan);",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1335:  struct workqueue_struct *s_dio_done_wq;",
          "1336: };",
          "1342: extern struct timespec current_fs_time(struct super_block *sb);",
          "",
          "[Removed Lines]",
          "1339: extern void prune_icache_sb(struct super_block *sb, int nr_to_scan);",
          "1340: extern void prune_dcache_sb(struct super_block *sb, int nr_to_scan);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1631:  ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);",
          "1632: #endif",
          "1633:  int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);",
          "1636: };",
          "",
          "[Removed Lines]",
          "1634:  int (*nr_cached_objects)(struct super_block *);",
          "1635:  void (*free_cached_objects)(struct super_block *, int);",
          "",
          "[Added Lines]",
          "1630:  long (*nr_cached_objects)(struct super_block *);",
          "1631:  long (*free_cached_objects)(struct super_block *, long);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
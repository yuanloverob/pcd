{
  "cve_id": "CVE-2011-4098",
  "cve_desc": "The fallocate implementation in the GFS2 filesystem in the Linux kernel before 3.2 relies on the page cache, which might allow local users to cause a denial of service by preallocating blocks in certain situations involving insufficient memory.",
  "repo": "torvalds/linux",
  "patch_hash": "64dd153c83743af81f20924c6343652d731eeecb",
  "patch_info": {
    "commit_hash": "64dd153c83743af81f20924c6343652d731eeecb",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/64dd153c83743af81f20924c6343652d731eeecb",
    "files": [
      "fs/gfs2/bmap.c",
      "fs/gfs2/file.c",
      "fs/gfs2/incore.h"
    ],
    "message": "GFS2: rewrite fallocate code to write blocks directly\n\nGFS2's fallocate code currently goes through the page cache. Since it's only\nwriting to the end of the file or to holes in it, it doesn't need to, and it\nwas causing issues on low memory environments. This patch pulls in some of\nSteve's block allocation work, and uses it to simply allocate the blocks for\nthe file, and zero them out at allocation time.  It provides a slight\nperformance increase, and it dramatically simplifies the code.\n\nSigned-off-by: Benjamin Marzinski <bmarzins@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
    "before_after_code_files": [
      "fs/gfs2/bmap.c||fs/gfs2/bmap.c",
      "fs/gfs2/file.c||fs/gfs2/file.c",
      "fs/gfs2/incore.h||fs/gfs2/incore.h"
    ]
  },
  "patch_diff": {
    "fs/gfs2/bmap.c||fs/gfs2/bmap.c": [
      "File: fs/gfs2/bmap.c -> fs/gfs2/bmap.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "10: #include <linux/spinlock.h>",
      "11: #include <linux/completion.h>",
      "12: #include <linux/buffer_head.h>",
      "13: #include <linux/gfs2_ondisk.h>",
      "14: #include <linux/crc32.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13: #include <linux/blkdev.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "427: {",
      "428:  struct gfs2_inode *ip = GFS2_I(inode);",
      "429:  struct gfs2_sbd *sdp = GFS2_SB(inode);",
      "430:  struct buffer_head *dibh = mp->mp_bh[0];",
      "431:  u64 bn, dblock = 0;",
      "432:  unsigned n, i, blks, alloced = 0, iblks = 0, branch_start = 0;",
      "433:  unsigned dblks = 0;",
      "434:  unsigned ptrs_per_blk;",
      "435:  const unsigned end_of_metadata = height - 1;",
      "436:  int eob = 0;",
      "437:  enum alloc_state state;",
      "438:  __be64 *ptr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "431:  struct super_block *sb = sdp->sd_vfs;",
      "438:  int ret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "535:    dblock = bn;",
      "536:    while (n-- > 0)",
      "538:    break;",
      "539:   }",
      "540:  } while ((state != ALLOC_DATA) || !dblock);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "541:    if (buffer_zeronew(bh_map)) {",
      "542:     ret = sb_issue_zeroout(sb, dblock, dblks,",
      "543:              GFP_NOFS);",
      "544:     if (ret) {",
      "545:      fs_err(sdp,",
      "546:             \"Failed to zero data buffers\\n\");",
      "547:      clear_buffer_zeronew(bh_map);",
      "548:     }",
      "549:    }",
      "",
      "---------------"
    ],
    "fs/gfs2/file.c||fs/gfs2/file.c": [
      "File: fs/gfs2/file.c -> fs/gfs2/file.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "669:  return generic_file_aio_write(iocb, iov, nr_segs, pos);",
      "670: }",
      "781: static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,",
      "782:       int mode)",
      "783: {",
      "784:  struct gfs2_inode *ip = GFS2_I(inode);",
      "785:  struct buffer_head *dibh;",
      "786:  int error;",
      "798:  error = gfs2_meta_inode_buffer(ip, &dibh);",
      "799:  if (unlikely(error))",
      "802:  gfs2_trans_add_bh(ip->i_gl, dibh, 1);",
      "",
      "[Removed Lines]",
      "672: static int empty_write_end(struct page *page, unsigned from,",
      "673:       unsigned to, int mode)",
      "674: {",
      "675:  struct inode *inode = page->mapping->host;",
      "676:  struct gfs2_inode *ip = GFS2_I(inode);",
      "677:  struct buffer_head *bh;",
      "678:  unsigned offset, blksize = 1 << inode->i_blkbits;",
      "679:  pgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;",
      "681:  zero_user(page, from, to-from);",
      "682:  mark_page_accessed(page);",
      "684:  if (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {",
      "685:   if (!gfs2_is_writeback(ip))",
      "686:    gfs2_page_add_databufs(ip, page, from, to);",
      "688:   block_commit_write(page, from, to);",
      "689:   return 0;",
      "690:  }",
      "692:  offset = 0;",
      "693:  bh = page_buffers(page);",
      "694:  while (offset < to) {",
      "695:   if (offset >= from) {",
      "696:    set_buffer_uptodate(bh);",
      "697:    mark_buffer_dirty(bh);",
      "698:    clear_buffer_new(bh);",
      "699:    write_dirty_buffer(bh, WRITE);",
      "700:   }",
      "701:   offset += blksize;",
      "702:   bh = bh->b_this_page;",
      "703:  }",
      "705:  offset = 0;",
      "706:  bh = page_buffers(page);",
      "707:  while (offset < to) {",
      "708:   if (offset >= from) {",
      "709:    wait_on_buffer(bh);",
      "710:    if (!buffer_uptodate(bh))",
      "711:     return -EIO;",
      "712:   }",
      "713:   offset += blksize;",
      "714:   bh = bh->b_this_page;",
      "715:  }",
      "716:  return 0;",
      "717: }",
      "719: static int needs_empty_write(sector_t block, struct inode *inode)",
      "720: {",
      "721:  int error;",
      "722:  struct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };",
      "724:  bh_map.b_size = 1 << inode->i_blkbits;",
      "725:  error = gfs2_block_map(inode, block, &bh_map, 0);",
      "726:  if (unlikely(error))",
      "727:   return error;",
      "728:  return !buffer_mapped(&bh_map);",
      "729: }",
      "731: static int write_empty_blocks(struct page *page, unsigned from, unsigned to,",
      "732:          int mode)",
      "733: {",
      "734:  struct inode *inode = page->mapping->host;",
      "735:  unsigned start, end, next, blksize;",
      "736:  sector_t block = page->index << (PAGE_CACHE_SHIFT - inode->i_blkbits);",
      "737:  int ret;",
      "739:  blksize = 1 << inode->i_blkbits;",
      "740:  next = end = 0;",
      "741:  while (next < from) {",
      "742:   next += blksize;",
      "743:   block++;",
      "744:  }",
      "745:  start = next;",
      "746:  do {",
      "747:   next += blksize;",
      "748:   ret = needs_empty_write(block, inode);",
      "749:   if (unlikely(ret < 0))",
      "750:    return ret;",
      "751:   if (ret == 0) {",
      "752:    if (end) {",
      "753:     ret = __block_write_begin(page, start, end - start,",
      "754:          gfs2_block_map);",
      "755:     if (unlikely(ret))",
      "756:      return ret;",
      "757:     ret = empty_write_end(page, start, end, mode);",
      "758:     if (unlikely(ret))",
      "759:      return ret;",
      "760:     end = 0;",
      "761:    }",
      "762:    start = next;",
      "763:   }",
      "764:   else",
      "765:    end = next;",
      "766:   block++;",
      "767:  } while (next < to);",
      "769:  if (end) {",
      "770:   ret = __block_write_begin(page, start, end - start, gfs2_block_map);",
      "771:   if (unlikely(ret))",
      "772:    return ret;",
      "773:   ret = empty_write_end(page, start, end, mode);",
      "774:   if (unlikely(ret))",
      "775:    return ret;",
      "776:  }",
      "778:  return 0;",
      "779: }",
      "787:  u64 start = offset >> PAGE_CACHE_SHIFT;",
      "788:  unsigned int start_offset = offset & ~PAGE_CACHE_MASK;",
      "789:  u64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;",
      "790:  pgoff_t curr;",
      "791:  struct page *page;",
      "792:  unsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;",
      "793:  unsigned int from, to;",
      "795:  if (!end_offset)",
      "796:   end_offset = PAGE_CACHE_SIZE;",
      "800:   goto out;",
      "",
      "[Added Lines]",
      "678:  unsigned int nr_blks;",
      "679:  sector_t lblock = offset >> inode->i_blkbits;",
      "683:   return error;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "807:    goto out;",
      "808:  }",
      "832:    goto out;",
      "836:  }",
      "838:  mark_inode_dirty(inode);",
      "842: out:",
      "843:  return error;",
      "844: }",
      "",
      "[Removed Lines]",
      "810:  curr = start;",
      "811:  offset = start << PAGE_CACHE_SHIFT;",
      "812:  from = start_offset;",
      "813:  to = PAGE_CACHE_SIZE;",
      "814:  while (curr <= end) {",
      "815:   page = grab_cache_page_write_begin(inode->i_mapping, curr,",
      "816:          AOP_FLAG_NOFS);",
      "817:   if (unlikely(!page)) {",
      "818:    error = -ENOMEM;",
      "819:    goto out;",
      "820:   }",
      "822:   if (curr == end)",
      "823:    to = end_offset;",
      "824:   error = write_empty_blocks(page, from, to, mode);",
      "825:   if (!error && offset + to > inode->i_size &&",
      "826:       !(mode & FALLOC_FL_KEEP_SIZE)) {",
      "827:    i_size_write(inode, offset + to);",
      "828:   }",
      "829:   unlock_page(page);",
      "830:   page_cache_release(page);",
      "831:   if (error)",
      "833:   curr++;",
      "834:   offset += PAGE_CACHE_SIZE;",
      "835:   from = 0;",
      "840:  brelse(dibh);",
      "",
      "[Added Lines]",
      "693:  while (len) {",
      "694:   struct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };",
      "695:   bh_map.b_size = len;",
      "696:   set_buffer_zeronew(&bh_map);",
      "698:   error = gfs2_block_map(inode, lblock, &bh_map, 1);",
      "699:   if (unlikely(error))",
      "700:    goto out;",
      "701:   len -= bh_map.b_size;",
      "702:   nr_blks = bh_map.b_size >> inode->i_blkbits;",
      "703:   lblock += nr_blks;",
      "704:   if (!buffer_new(&bh_map))",
      "705:    continue;",
      "706:   if (unlikely(!buffer_zeronew(&bh_map))) {",
      "707:    error = -EIO;",
      "709:   }",
      "711:  if (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))",
      "712:   i_size_write(inode, offset + len);",
      "717:  brelse(dibh);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "879:  int error;",
      "880:  loff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);",
      "881:  loff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;",
      "882:  next = (next + 1) << sdp->sd_sb.sb_bsize_shift;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "757:  loff_t max_chunk_size = UINT_MAX & bsize_mask;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "932:    goto out_qunlock;",
      "933:   }",
      "934:   max_bytes = bytes;",
      "936:   al->al_requested = data_blocks + ind_blocks;",
      "938:   rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +",
      "",
      "[Removed Lines]",
      "935:   calc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);",
      "",
      "[Added Lines]",
      "811:   calc_max_reserv(ip, (len > max_chunk_size)? max_chunk_size: len,",
      "812:     &max_bytes, &data_blocks, &ind_blocks);",
      "",
      "---------------"
    ],
    "fs/gfs2/incore.h||fs/gfs2/incore.h": [
      "File: fs/gfs2/incore.h -> fs/gfs2/incore.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "103: enum gfs2_state_bits {",
      "104:  BH_Pinned = BH_PrivateStart,",
      "105:  BH_Escaped = BH_PrivateStart + 1,",
      "106: };",
      "108: BUFFER_FNS(Pinned, pinned)",
      "109: TAS_BUFFER_FNS(Pinned, pinned)",
      "110: BUFFER_FNS(Escaped, escaped)",
      "111: TAS_BUFFER_FNS(Escaped, escaped)",
      "113: struct gfs2_bufdata {",
      "114:  struct buffer_head *bd_bh;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "106:  BH_Zeronew = BH_PrivateStart + 2,",
      "113: BUFFER_FNS(Zeronew, zeronew)",
      "114: TAS_BUFFER_FNS(Zeronew, zeronew)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "58a7d5fb8e31279b992db4027e44b053a84b7344",
      "candidate_info": {
        "commit_hash": "58a7d5fb8e31279b992db4027e44b053a84b7344",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/58a7d5fb8e31279b992db4027e44b053a84b7344",
        "files": [
          "fs/gfs2/file.c"
        ],
        "message": "GFS2: call gfs2_write_alloc_required for each chunk\n\ngfs2_fallocate was calling gfs2_write_alloc_required() once at the start of\nthe function. This caused problems since gfs2_write_alloc_required used a\nlong unsigned int for the len, but gfs2_fallocate could allocate a much\nlarger amount.  This patch will move the call into the loop where the\nchunks are actually allocated and zeroed out. This will keep the allocation\nsize under the limit, and also allow gfs2_fallocate to quickly skip over\nsections of the file that are already completely allocated.\n\nfallcate_chunk was also not correctly setting the file size.  It was using the\nlen veriable to find the last block written to, but by the time it was setting\nthe size, the len variable had already been decremented to 0.\n\nSigned-off-by: Benjamin Marzinski <bmarzins@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
        "before_after_code_files": [
          "fs/gfs2/file.c||fs/gfs2/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ],
          "candidate": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/gfs2/file.c||fs/gfs2/file.c": [
          "File: fs/gfs2/file.c -> fs/gfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "676:  struct gfs2_inode *ip = GFS2_I(inode);",
          "677:  struct buffer_head *dibh;",
          "678:  int error;",
          "679:  unsigned int nr_blks;",
          "680:  sector_t lblock = offset >> inode->i_blkbits;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "679:  loff_t size = len;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "709:    goto out;",
          "710:   }",
          "711:  }",
          "715:  mark_inode_dirty(inode);",
          "",
          "[Removed Lines]",
          "712:  if (offset + len > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))",
          "713:   i_size_write(inode, offset + len);",
          "",
          "[Added Lines]",
          "713:  if (offset + size > inode->i_size && !(mode & FALLOC_FL_KEEP_SIZE))",
          "714:   i_size_write(inode, offset + size);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "779:  if (unlikely(error))",
          "780:   goto out_uninit;",
          "785:  while (len > 0) {",
          "786:   if (len < bytes)",
          "787:    bytes = len;",
          "788:   qa = gfs2_qadata_get(ip);",
          "789:   if (!qa) {",
          "790:    error = -ENOMEM;",
          "",
          "[Removed Lines]",
          "782:  if (!gfs2_write_alloc_required(ip, offset, len))",
          "783:   goto out_unlock;",
          "",
          "[Added Lines]",
          "786:   if (!gfs2_write_alloc_required(ip, offset, bytes)) {",
          "787:    len -= bytes;",
          "788:    offset += bytes;",
          "789:    continue;",
          "790:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ab9bbda0204dfd0e5342562d9979d1241b14ea5f",
      "candidate_info": {
        "commit_hash": "ab9bbda0204dfd0e5342562d9979d1241b14ea5f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ab9bbda0204dfd0e5342562d9979d1241b14ea5f",
        "files": [
          "fs/gfs2/acl.c",
          "fs/gfs2/aops.c",
          "fs/gfs2/dir.c",
          "fs/gfs2/file.c",
          "fs/gfs2/inode.c",
          "fs/gfs2/inode.h",
          "fs/gfs2/quota.c",
          "fs/gfs2/super.c",
          "fs/gfs2/xattr.c"
        ],
        "message": "GFS2: Use ->dirty_inode()\n\nThe aim of this patch is to use the newly enhanced ->dirty_inode()\nsuper block operation to deal with atime updates, rather than\npiggy backing that code into ->write_inode() as is currently\ndone.\n\nThe net result is a simplification of the code in various places\nand a reduction of the number of gfs2_dinode_out() calls since\nthis is now implied by ->dirty_inode().\n\nSome of the mark_inode_dirty() calls have been moved under glocks\nin order to take advantage of then being able to avoid locking in\n->dirty_inode() when we already have suitable locks.\n\nOne consequence is that generic_write_end() now correctly deals\nwith file size updates, so that we do not need a separate check\nfor that afterwards. This also, indirectly, means that fdatasync\nshould work correctly on GFS2 - the current code always syncs the\nmetadata whether it needs to or not.\n\nHas survived testing with postmark (with and without atime) and\nalso fsx.\n\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
        "before_after_code_files": [
          "fs/gfs2/acl.c||fs/gfs2/acl.c",
          "fs/gfs2/aops.c||fs/gfs2/aops.c",
          "fs/gfs2/dir.c||fs/gfs2/dir.c",
          "fs/gfs2/file.c||fs/gfs2/file.c",
          "fs/gfs2/inode.c||fs/gfs2/inode.c",
          "fs/gfs2/inode.h||fs/gfs2/inode.h",
          "fs/gfs2/quota.c||fs/gfs2/quota.c",
          "fs/gfs2/super.c||fs/gfs2/super.c",
          "fs/gfs2/xattr.c||fs/gfs2/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ],
          "candidate": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/gfs2/acl.c||fs/gfs2/acl.c": [
          "File: fs/gfs2/acl.c -> fs/gfs2/acl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "82:   iattr.ia_valid = ATTR_MODE;",
          "83:   iattr.ia_mode = mode;",
          "86:  }",
          "88:  return error;",
          "",
          "[Removed Lines]",
          "85:   error = gfs2_setattr_simple(GFS2_I(inode), &iattr);",
          "",
          "[Added Lines]",
          "85:   error = gfs2_setattr_simple(inode, &iattr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "161: int gfs2_acl_chmod(struct gfs2_inode *ip, struct iattr *attr)",
          "162: {",
          "163:  struct posix_acl *acl;",
          "164:  char *data;",
          "165:  unsigned int len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "163:  struct inode *inode = &ip->i_inode;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "169:  if (IS_ERR(acl))",
          "170:   return PTR_ERR(acl);",
          "171:  if (!acl)",
          "174:  error = posix_acl_chmod(&acl, GFP_NOFS, attr->ia_mode);",
          "175:  if (error)",
          "",
          "[Removed Lines]",
          "172:   return gfs2_setattr_simple(ip, attr);",
          "",
          "[Added Lines]",
          "173:   return gfs2_setattr_simple(inode, attr);",
          "",
          "---------------"
        ],
        "fs/gfs2/aops.c||fs/gfs2/aops.c": [
          "File: fs/gfs2/aops.c -> fs/gfs2/aops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "787:  u64 to = pos + copied;",
          "788:  void *kaddr;",
          "789:  unsigned char *buf = dibh->b_data + sizeof(struct gfs2_dinode);",
          "792:  BUG_ON((pos + len) > (dibh->b_size - sizeof(struct gfs2_dinode)));",
          "793:  kaddr = kmap_atomic(page, KM_USER0);",
          "",
          "[Removed Lines]",
          "790:  struct gfs2_dinode *di = (struct gfs2_dinode *)dibh->b_data;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "804:  if (copied) {",
          "805:   if (inode->i_size < to)",
          "806:    i_size_write(inode, to);",
          "808:   mark_inode_dirty(inode);",
          "809:  }",
          "",
          "[Removed Lines]",
          "807:   gfs2_dinode_out(ip, di);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "873:   gfs2_page_add_databufs(ip, page, from, to);",
          "875:  ret = generic_write_end(file, mapping, pos, len, copied, page, fsdata);",
          "881:  if (inode == sdp->sd_rindex) {",
          "882:   adjust_fs_space(inode);",
          "",
          "[Removed Lines]",
          "876:  if (ret > 0) {",
          "877:   gfs2_dinode_out(ip, dibh->b_data);",
          "878:   mark_inode_dirty(inode);",
          "879:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/gfs2/dir.c||fs/gfs2/dir.c": [
          "File: fs/gfs2/dir.c -> fs/gfs2/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1681:  const struct qstr *name = &dentry->d_name;",
          "1682:  struct gfs2_dirent *dent, *prev = NULL;",
          "1683:  struct buffer_head *bh;",
          "",
          "[Removed Lines]",
          "1684:  int error;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1710:  }",
          "1711:  brelse(bh);",
          "1717:  if (!dip->i_entries)",
          "1718:   gfs2_consist_inode(dip);",
          "1720:  dip->i_entries--;",
          "1721:  dip->i_inode.i_mtime = dip->i_inode.i_ctime = CURRENT_TIME;",
          "1722:  if (S_ISDIR(dentry->d_inode->i_mode))",
          "1723:   drop_nlink(&dip->i_inode);",
          "1726:  mark_inode_dirty(&dip->i_inode);",
          "1729: }",
          "",
          "[Removed Lines]",
          "1713:  error = gfs2_meta_inode_buffer(dip, &bh);",
          "1714:  if (error)",
          "1715:   return error;",
          "1719:  gfs2_trans_add_bh(dip->i_gl, bh, 1);",
          "1724:  gfs2_dinode_out(dip, bh->b_data);",
          "1725:  brelse(bh);",
          "1728:  return error;",
          "",
          "[Added Lines]",
          "1720:  return 0;",
          "",
          "---------------"
        ],
        "fs/gfs2/file.c||fs/gfs2/file.c": [
          "File: fs/gfs2/file.c -> fs/gfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "802:   from = 0;",
          "803:  }",
          "806:  mark_inode_dirty(inode);",
          "808:  brelse(dibh);",
          "",
          "[Removed Lines]",
          "805:  gfs2_dinode_out(ip, dibh->b_data);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/gfs2/inode.c||fs/gfs2/inode.c": [
          "File: fs/gfs2/inode.c -> fs/gfs2/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "729:   gfs2_inplace_release(dip);",
          "730:  gfs2_quota_unlock(dip);",
          "731:  gfs2_alloc_put(dip);",
          "733:  mark_inode_dirty(inode);",
          "734:  d_instantiate(dentry, inode);",
          "735:  return 0;",
          "",
          "[Removed Lines]",
          "732:  gfs2_glock_dq_uninit_m(2, ghs);",
          "",
          "[Added Lines]",
          "733:  gfs2_glock_dq_uninit_m(2, ghs);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "926:  gfs2_trans_add_bh(ip->i_gl, dibh, 1);",
          "927:  inc_nlink(&ip->i_inode);",
          "928:  ip->i_inode.i_ctime = CURRENT_TIME;",
          "932: out_brelse:",
          "933:  brelse(dibh);",
          "",
          "[Removed Lines]",
          "929:  gfs2_dinode_out(ip, dibh->b_data);",
          "930:  mark_inode_dirty(&ip->i_inode);",
          "",
          "[Added Lines]",
          "929:  ihold(inode);",
          "930:  d_instantiate(dentry, inode);",
          "931:  mark_inode_dirty(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "949: out_parent:",
          "950:  gfs2_holder_uninit(ghs);",
          "951:  gfs2_holder_uninit(ghs + 1);",
          "957:  return error;",
          "958: }",
          "",
          "[Removed Lines]",
          "952:  if (!error) {",
          "953:   ihold(inode);",
          "954:   d_instantiate(dentry, inode);",
          "955:   mark_inode_dirty(inode);",
          "956:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1026:   clear_nlink(inode);",
          "1027:  else",
          "1028:   drop_nlink(inode);",
          "1031:  mark_inode_dirty(inode);",
          "1032:  if (inode->i_nlink == 0)",
          "1033:   gfs2_unlink_di(inode);",
          "",
          "[Removed Lines]",
          "1029:  gfs2_trans_add_bh(ip->i_gl, bh, 1);",
          "1030:  gfs2_dinode_out(ip, bh->b_data);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1565:  return error;",
          "1566: }",
          "1569: {",
          "1578:  setattr_copy(inode, attr);",
          "1579:  mark_inode_dirty(inode);",
          "1583:  return 0;",
          "1584: }",
          "",
          "[Removed Lines]",
          "1568: static int __gfs2_setattr_simple(struct gfs2_inode *ip, struct iattr *attr)",
          "1570:  struct inode *inode = &ip->i_inode;",
          "1571:  struct buffer_head *dibh;",
          "1572:  int error;",
          "1574:  error = gfs2_meta_inode_buffer(ip, &dibh);",
          "1575:  if (error)",
          "1576:   return error;",
          "1580:  gfs2_trans_add_bh(ip->i_gl, dibh, 1);",
          "1581:  gfs2_dinode_out(ip, dibh->b_data);",
          "1582:  brelse(dibh);",
          "",
          "[Added Lines]",
          "1562: static int __gfs2_setattr_simple(struct inode *inode, struct iattr *attr)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1595: {",
          "1596:  int error;",
          "1598:  if (current->journal_info)",
          "1602:  if (error)",
          "1603:   return error;",
          "1607:  return error;",
          "1608: }",
          "",
          "[Removed Lines]",
          "1594: int gfs2_setattr_simple(struct gfs2_inode *ip, struct iattr *attr)",
          "1599:   return __gfs2_setattr_simple(ip, attr);",
          "1601:  error = gfs2_trans_begin(GFS2_SB(&ip->i_inode), RES_DINODE, 0);",
          "1605:  error = __gfs2_setattr_simple(ip, attr);",
          "1606:  gfs2_trans_end(GFS2_SB(&ip->i_inode));",
          "",
          "[Added Lines]",
          "1577: int gfs2_setattr_simple(struct inode *inode, struct iattr *attr)",
          "1582:   return __gfs2_setattr_simple(inode, attr);",
          "1584:  error = gfs2_trans_begin(GFS2_SB(inode), RES_DINODE, 0);",
          "1588:  error = __gfs2_setattr_simple(inode, attr);",
          "1589:  gfs2_trans_end(GFS2_SB(inode));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1641:  if (error)",
          "1642:   goto out_gunlock_q;",
          "1645:  if (error)",
          "1646:   goto out_end_trans;",
          "",
          "[Removed Lines]",
          "1644:  error = gfs2_setattr_simple(ip, attr);",
          "",
          "[Added Lines]",
          "1627:  error = gfs2_setattr_simple(inode, attr);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1697:  else if ((attr->ia_valid & ATTR_MODE) && IS_POSIXACL(inode))",
          "1698:   error = gfs2_acl_chmod(ip, attr);",
          "1699:  else",
          "1702: out:",
          "1704:  if (!error)",
          "1705:   mark_inode_dirty(inode);",
          "1706:  return error;",
          "1707: }",
          "",
          "[Removed Lines]",
          "1700:   error = gfs2_setattr_simple(ip, attr);",
          "1703:  gfs2_glock_dq_uninit(&i_gh);",
          "",
          "[Added Lines]",
          "1683:   error = gfs2_setattr_simple(inode, attr);",
          "1688:  gfs2_glock_dq_uninit(&i_gh);",
          "",
          "---------------"
        ],
        "fs/gfs2/inode.h||fs/gfs2/inode.h": [
          "File: fs/gfs2/inode.h -> fs/gfs2/inode.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "109: extern struct inode *gfs2_lookupi(struct inode *dir, const struct qstr *name,",
          "110:       int is_root);",
          "111: extern int gfs2_permission(struct inode *inode, int mask);",
          "113: extern struct inode *gfs2_lookup_simple(struct inode *dip, const char *name);",
          "114: extern void gfs2_dinode_out(const struct gfs2_inode *ip, void *buf);",
          "",
          "[Removed Lines]",
          "112: extern int gfs2_setattr_simple(struct gfs2_inode *ip, struct iattr *attr);",
          "",
          "[Added Lines]",
          "112: extern int gfs2_setattr_simple(struct inode *inode, struct iattr *attr);",
          "",
          "---------------"
        ],
        "fs/gfs2/quota.c||fs/gfs2/quota.c": [
          "File: fs/gfs2/quota.c -> fs/gfs2/quota.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "638:  unsigned long index = loc >> PAGE_CACHE_SHIFT;",
          "639:  unsigned offset = loc & (PAGE_CACHE_SIZE - 1);",
          "640:  unsigned blocksize, iblock, pos;",
          "642:  struct page *page;",
          "643:  void *kaddr, *ptr;",
          "644:  struct gfs2_quota q, *qp;",
          "",
          "[Removed Lines]",
          "641:  struct buffer_head *bh, *dibh;",
          "",
          "[Added Lines]",
          "641:  struct buffer_head *bh;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "736:   goto get_a_page;",
          "737:  }",
          "744:  size = loc + sizeof(struct gfs2_quota);",
          "745:  if (size > inode->i_size)",
          "746:   i_size_write(inode, size);",
          "747:  inode->i_mtime = inode->i_atime = CURRENT_TIME;",
          "751:  mark_inode_dirty(inode);",
          "754:  return err;",
          "755: unlock_out:",
          "756:  unlock_page(page);",
          "757:  page_cache_release(page);",
          "",
          "[Removed Lines]",
          "740:  err = gfs2_meta_inode_buffer(ip, &dibh);",
          "741:  if (err)",
          "742:   goto out;",
          "748:  gfs2_trans_add_bh(ip->i_gl, dibh, 1);",
          "749:  gfs2_dinode_out(ip, dibh->b_data);",
          "750:  brelse(dibh);",
          "753: out:",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/gfs2/super.c||fs/gfs2/super.c": [
          "File: fs/gfs2/super.c -> fs/gfs2/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "752:  struct gfs2_sbd *sdp = GFS2_SB(inode);",
          "753:  struct address_space *metamapping = gfs2_glock2aspace(ip->i_gl);",
          "754:  struct backing_dev_info *bdi = metamapping->backing_dev_info;",
          "789:  if (wbc->sync_mode == WB_SYNC_ALL)",
          "790:   gfs2_log_flush(GFS2_SB(inode), ip->i_gl);",
          "791:  if (bdi->dirty_exceeded)",
          "792:   gfs2_ail1_flush(sdp, wbc);",
          "793:  else",
          "794:   filemap_fdatawrite(metamapping);",
          "796:   ret = filemap_fdatawait(metamapping);",
          "797:  if (ret)",
          "798:   mark_inode_dirty_sync(inode);",
          "799:  return ret;",
          "800: }",
          "",
          "[Removed Lines]",
          "755:  struct gfs2_holder gh;",
          "756:  struct buffer_head *bh;",
          "757:  struct timespec atime;",
          "758:  struct gfs2_dinode *di;",
          "759:  int ret = -EAGAIN;",
          "760:  int unlock_required = 0;",
          "763:  if (current->flags & PF_MEMALLOC)",
          "764:   goto do_flush;",
          "765:  if (!gfs2_glock_is_locked_by_me(ip->i_gl)) {",
          "766:   ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);",
          "767:   if (ret)",
          "768:    goto do_flush;",
          "769:   unlock_required = 1;",
          "770:  }",
          "771:  ret = gfs2_meta_inode_buffer(ip, &bh);",
          "772:  if (ret == 0) {",
          "773:   di = (struct gfs2_dinode *)bh->b_data;",
          "774:   atime.tv_sec = be64_to_cpu(di->di_atime);",
          "775:   atime.tv_nsec = be32_to_cpu(di->di_atime_nsec);",
          "776:   if (timespec_compare(&inode->i_atime, &atime) > 0) {",
          "777:    ret = gfs2_trans_begin(sdp, RES_DINODE, 0);",
          "778:    if (ret == 0) {",
          "779:     gfs2_trans_add_bh(ip->i_gl, bh, 1);",
          "780:     gfs2_dinode_out(ip, bh->b_data);",
          "781:     gfs2_trans_end(sdp);",
          "782:    }",
          "783:   }",
          "784:   brelse(bh);",
          "785:  }",
          "786:  if (unlock_required)",
          "787:   gfs2_glock_dq_uninit(&gh);",
          "788: do_flush:",
          "795:  if (!ret && (wbc->sync_mode == WB_SYNC_ALL))",
          "",
          "[Added Lines]",
          "755:  int ret = 0;",
          "763:  if (wbc->sync_mode == WB_SYNC_ALL)",
          "783: static void gfs2_dirty_inode(struct inode *inode, int flags)",
          "784: {",
          "785:  struct gfs2_inode *ip = GFS2_I(inode);",
          "786:  struct gfs2_sbd *sdp = GFS2_SB(inode);",
          "787:  struct buffer_head *bh;",
          "788:  struct gfs2_holder gh;",
          "789:  int need_unlock = 0;",
          "790:  int need_endtrans = 0;",
          "791:  int ret;",
          "793:  if (!(flags & (I_DIRTY_DATASYNC|I_DIRTY_SYNC)))",
          "794:   return;",
          "796:  if (!gfs2_glock_is_locked_by_me(ip->i_gl)) {",
          "797:   ret = gfs2_glock_nq_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &gh);",
          "798:   if (ret) {",
          "799:    fs_err(sdp, \"dirty_inode: glock %d\\n\", ret);",
          "800:    return;",
          "801:   }",
          "802:   need_unlock = 1;",
          "803:  }",
          "805:  if (current->journal_info == NULL) {",
          "806:   ret = gfs2_trans_begin(sdp, RES_DINODE, 0);",
          "807:   if (ret) {",
          "808:    fs_err(sdp, \"dirty_inode: gfs2_trans_begin %d\\n\", ret);",
          "809:    goto out;",
          "810:   }",
          "811:   need_endtrans = 1;",
          "812:  }",
          "814:  ret = gfs2_meta_inode_buffer(ip, &bh);",
          "815:  if (ret == 0) {",
          "816:   gfs2_trans_add_bh(ip->i_gl, bh, 1);",
          "817:   gfs2_dinode_out(ip, bh->b_data);",
          "818:   brelse(bh);",
          "819:  }",
          "821:  if (need_endtrans)",
          "822:   gfs2_trans_end(sdp);",
          "823: out:",
          "824:  if (need_unlock)",
          "825:   gfs2_glock_dq_uninit(&gh);",
          "826: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1578:  .alloc_inode  = gfs2_alloc_inode,",
          "1579:  .destroy_inode  = gfs2_destroy_inode,",
          "1580:  .write_inode  = gfs2_write_inode,",
          "1581:  .evict_inode  = gfs2_evict_inode,",
          "1582:  .put_super  = gfs2_put_super,",
          "1583:  .sync_fs  = gfs2_sync_fs,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1607:  .dirty_inode  = gfs2_dirty_inode,",
          "",
          "---------------"
        ],
        "fs/gfs2/xattr.c||fs/gfs2/xattr.c": [
          "File: fs/gfs2/xattr.c -> fs/gfs2/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1297: int gfs2_xattr_acl_chmod(struct gfs2_inode *ip, struct iattr *attr, char *data)",
          "1298: {",
          "1300:  struct gfs2_ea_location el;",
          "1301:  int error;",
          "",
          "[Removed Lines]",
          "1299:  struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);",
          "",
          "[Added Lines]",
          "1299:  struct inode *inode = &ip->i_inode;",
          "1300:  struct gfs2_sbd *sdp = GFS2_SB(inode);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1319:  if (error)",
          "1320:   return error;",
          "1323:  gfs2_trans_end(sdp);",
          "1324:  return error;",
          "1325: }",
          "",
          "[Removed Lines]",
          "1322:  error = gfs2_setattr_simple(ip, attr);",
          "",
          "[Added Lines]",
          "1323:  error = gfs2_setattr_simple(inode, attr);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "54335b1fca27b84baa75b1f45985d98262003837",
      "candidate_info": {
        "commit_hash": "54335b1fca27b84baa75b1f45985d98262003837",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/54335b1fca27b84baa75b1f45985d98262003837",
        "files": [
          "fs/gfs2/aops.c",
          "fs/gfs2/file.c",
          "fs/gfs2/incore.h",
          "fs/gfs2/inode.c",
          "fs/gfs2/quota.c",
          "fs/gfs2/rgrp.c",
          "fs/gfs2/super.c",
          "fs/gfs2/trans.h",
          "fs/gfs2/xattr.c"
        ],
        "message": "GFS2: Cache the most recently used resource group in the inode\n\nThis means that after the initial allocation for any inode, the\nlast used resource group is cached in the inode for future use.\nThis drastically reduces the number of lookups of resource\ngroups in the common case, and this the contention on that\ndata structure.\n\nThe allocation algorithm is the same as previously, except that we\nalways check to see if the goal block is within the cached rgrp\nfirst before going to the rbtree to look one up.\n\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
        "before_after_code_files": [
          "fs/gfs2/aops.c||fs/gfs2/aops.c",
          "fs/gfs2/file.c||fs/gfs2/file.c",
          "fs/gfs2/incore.h||fs/gfs2/incore.h",
          "fs/gfs2/inode.c||fs/gfs2/inode.c",
          "fs/gfs2/quota.c||fs/gfs2/quota.c",
          "fs/gfs2/rgrp.c||fs/gfs2/rgrp.c",
          "fs/gfs2/super.c||fs/gfs2/super.c",
          "fs/gfs2/trans.h||fs/gfs2/trans.h",
          "fs/gfs2/xattr.c||fs/gfs2/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/gfs2/file.c||fs/gfs2/file.c",
            "fs/gfs2/incore.h||fs/gfs2/incore.h"
          ],
          "candidate": [
            "fs/gfs2/file.c||fs/gfs2/file.c",
            "fs/gfs2/incore.h||fs/gfs2/incore.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/gfs2/aops.c||fs/gfs2/aops.c": [
          "File: fs/gfs2/aops.c -> fs/gfs2/aops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "663:  if (&ip->i_inode == sdp->sd_rindex)",
          "664:   rblocks += 2 * RES_STATFS;",
          "665:  if (alloc_required)",
          "668:  error = gfs2_trans_begin(sdp, rblocks,",
          "669:      PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);",
          "",
          "[Removed Lines]",
          "666:   rblocks += gfs2_rg_blocks(al);",
          "",
          "[Added Lines]",
          "666:   rblocks += gfs2_rg_blocks(ip);",
          "",
          "---------------"
        ],
        "fs/gfs2/file.c||fs/gfs2/file.c": [
          "File: fs/gfs2/file.c -> fs/gfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "397:   rblocks += data_blocks ? data_blocks : 1;",
          "398:  if (ind_blocks || data_blocks) {",
          "399:   rblocks += RES_STATFS + RES_QUOTA;",
          "401:  }",
          "402:  ret = gfs2_trans_begin(sdp, rblocks, 0);",
          "403:  if (ret)",
          "",
          "[Removed Lines]",
          "400:   rblocks += gfs2_rg_blocks(al);",
          "",
          "[Added Lines]",
          "400:   rblocks += gfs2_rg_blocks(ip);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "823:        unsigned int *data_blocks, unsigned int *ind_blocks)",
          "824: {",
          "825:  const struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);",
          "827:  unsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);",
          "829:  for (tmp = max_data; tmp > sdp->sd_diptrs;) {",
          "",
          "[Removed Lines]",
          "826:  unsigned int max_blocks = ip->i_alloc->al_rgd->rd_free_clone;",
          "",
          "[Added Lines]",
          "826:  unsigned int max_blocks = ip->i_rgd->rd_free_clone;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "912:   al->al_requested = data_blocks + ind_blocks;",
          "914:   rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +",
          "916:   if (gfs2_is_jdata(ip))",
          "917:    rblocks += data_blocks ? data_blocks : 1;",
          "",
          "[Removed Lines]",
          "915:      RES_RG_HDR + gfs2_rg_blocks(al);",
          "",
          "[Added Lines]",
          "915:      RES_RG_HDR + gfs2_rg_blocks(ip);",
          "",
          "---------------"
        ],
        "fs/gfs2/incore.h||fs/gfs2/incore.h": [
          "File: fs/gfs2/incore.h -> fs/gfs2/incore.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "256:  unsigned int al_line;",
          "257:  char *al_file;",
          "258:  struct gfs2_holder al_rgd_gh;",
          "261: };",
          "263: enum {",
          "",
          "[Removed Lines]",
          "259:  struct gfs2_rgrpd *al_rgd;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "279:  struct gfs2_holder i_iopen_gh;",
          "281:  struct gfs2_alloc *i_alloc;",
          "283:  struct rw_semaphore i_rw_mutex;",
          "284:  struct list_head i_trunc_list;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "280:  struct gfs2_rgrpd *i_rgd;",
          "",
          "---------------"
        ],
        "fs/gfs2/inode.c||fs/gfs2/inode.c": [
          "File: fs/gfs2/inode.c -> fs/gfs2/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "583:    goto fail_quota_locks;",
          "585:   error = gfs2_trans_begin(sdp, sdp->sd_max_dirres +",
          "587:       2 * RES_DINODE +",
          "588:       RES_STATFS + RES_QUOTA, 0);",
          "589:   if (error)",
          "",
          "[Removed Lines]",
          "586:       al->al_rgd->rd_length +",
          "",
          "[Added Lines]",
          "586:       dip->i_rgd->rd_length +",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "613:  gfs2_trans_end(sdp);",
          "615: fail_ipreserv:",
          "619: fail_quota_locks:",
          "620:  gfs2_quota_unlock(dip);",
          "",
          "[Removed Lines]",
          "616:  if (dip->i_alloc->al_rgd)",
          "617:   gfs2_inplace_release(dip);",
          "",
          "[Added Lines]",
          "616:  gfs2_inplace_release(dip);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "731:   brelse(bh);",
          "733:  gfs2_trans_end(sdp);",
          "736:  gfs2_quota_unlock(dip);",
          "737:  gfs2_alloc_put(dip);",
          "738:  mark_inode_dirty(inode);",
          "",
          "[Removed Lines]",
          "734:  if (dip->i_alloc->al_rgd)",
          "735:   gfs2_inplace_release(dip);",
          "",
          "[Added Lines]",
          "733:  gfs2_inplace_release(dip);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "896:    goto out_gunlock_q;",
          "898:   error = gfs2_trans_begin(sdp, sdp->sd_max_dirres +",
          "900:       2 * RES_DINODE + RES_STATFS +",
          "901:       RES_QUOTA, 0);",
          "902:   if (error)",
          "",
          "[Removed Lines]",
          "899:       gfs2_rg_blocks(al) +",
          "",
          "[Added Lines]",
          "897:       gfs2_rg_blocks(dip) +",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1371:    goto out_gunlock_q;",
          "1373:   error = gfs2_trans_begin(sdp, sdp->sd_max_dirres +",
          "1375:       4 * RES_DINODE + 4 * RES_LEAF +",
          "1376:       RES_STATFS + RES_QUOTA + 4, 0);",
          "1377:   if (error)",
          "",
          "[Removed Lines]",
          "1374:       gfs2_rg_blocks(al) +",
          "",
          "[Added Lines]",
          "1372:       gfs2_rg_blocks(ndip) +",
          "",
          "---------------"
        ],
        "fs/gfs2/quota.c||fs/gfs2/quota.c": [
          "File: fs/gfs2/quota.c -> fs/gfs2/quota.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "813:   goto out_alloc;",
          "815:  if (nalloc)",
          "818:  error = gfs2_trans_begin(sdp, blocks, 0);",
          "819:  if (error)",
          "",
          "[Removed Lines]",
          "816:   blocks += gfs2_rg_blocks(al) + nalloc * ind_blocks + RES_STATFS;",
          "",
          "[Added Lines]",
          "816:   blocks += gfs2_rg_blocks(ip) + nalloc * ind_blocks + RES_STATFS;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1598:   error = gfs2_inplace_reserve(ip);",
          "1599:   if (error)",
          "1600:    goto out_alloc;",
          "1602:  }",
          "",
          "[Removed Lines]",
          "1601:   blocks += gfs2_rg_blocks(al);",
          "",
          "[Added Lines]",
          "1601:   blocks += gfs2_rg_blocks(ip);",
          "",
          "---------------"
        ],
        "fs/gfs2/rgrp.c||fs/gfs2/rgrp.c": [
          "File: fs/gfs2/rgrp.c -> fs/gfs2/rgrp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "894: {",
          "895:  if (rgd->rd_flags & (GFS2_RGF_NOALLOC | GFS2_RDF_ERROR))",
          "896:   return 0;",
          "900:   return 1;",
          "903:  return 0;",
          "904: }",
          "",
          "[Removed Lines]",
          "893: static int try_rgrp_fit(struct gfs2_rgrpd *rgd, struct gfs2_alloc *al)",
          "898:  if (rgd->rd_free_clone >= al->al_requested) {",
          "899:   al->al_rgd = rgd;",
          "901:  }",
          "",
          "[Added Lines]",
          "892: static int try_rgrp_fit(const struct gfs2_rgrpd *rgd, const struct gfs2_inode *ip)",
          "894:  const struct gfs2_alloc *al = ip->i_alloc;",
          "898:  if (rgd->rd_free_clone >= al->al_requested)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "985:  int error, rg_locked;",
          "986:  int loops = 0;",
          "990:  if (rgd == NULL)",
          "991:   return -EBADSLT;",
          "",
          "[Removed Lines]",
          "988:  rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal);",
          "",
          "[Added Lines]",
          "985:  if (ip->i_rgd && rgrp_contains_block(ip->i_rgd, ip->i_goal))",
          "986:   rgd = begin = ip->i_rgd;",
          "987:  else",
          "988:   rgd = begin = gfs2_blk2rgrpd(sdp, ip->i_goal);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1002:   }",
          "1003:   switch (error) {",
          "1004:   case 0:",
          "1006:     return 0;",
          "1007:    if (rgd->rd_flags & GFS2_RDF_CHECK)",
          "1008:     try_rgrp_unlink(rgd, last_unlinked, ip->i_no_addr);",
          "1009:    if (!rg_locked)",
          "",
          "[Removed Lines]",
          "1005:    if (try_rgrp_fit(rgd, al))",
          "",
          "[Added Lines]",
          "1005:    if (try_rgrp_fit(rgd, ip)) {",
          "1006:     ip->i_rgd = rgd;",
          "1008:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1042:  if (gfs2_assert_warn(sdp, al->al_requested))",
          "1043:   return -EINVAL;",
          "1046:  do {",
          "1047:   error = get_local_rgrp(ip, &last_unlinked);",
          "1058:   }",
          "1061:  if (error)",
          "1062:   return error;",
          "",
          "[Removed Lines]",
          "1045: try_again:",
          "1049:   if (error) {",
          "1050:    if (ip == GFS2_I(sdp->sd_rindex) &&",
          "1051:        !sdp->sd_rindex_uptodate) {",
          "1052:     error = gfs2_ri_update(ip);",
          "1053:     if (error)",
          "1054:      return error;",
          "1055:     goto try_again;",
          "1056:    }",
          "1057:    gfs2_log_flush(sdp, NULL);",
          "1059:  } while (error && tries++ < 3);",
          "",
          "[Added Lines]",
          "1048:   if (error != -ENOSPC)",
          "1049:    break;",
          "1051:   if (ip == GFS2_I(sdp->sd_rindex) && !sdp->sd_rindex_uptodate) {",
          "1052:    error = gfs2_ri_update(ip);",
          "1053:    if (error)",
          "1054:     break;",
          "1055:    continue;",
          "1058:   gfs2_log_flush(sdp, NULL);",
          "1059:  } while (tries++ < 3);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1086:                al->al_alloced, al->al_requested, al->al_file,",
          "1087:         al->al_line);",
          "1090:  if (al->al_rgd_gh.gh_gl)",
          "1091:   gfs2_glock_dq_uninit(&al->al_rgd_gh);",
          "1092: }",
          "",
          "[Removed Lines]",
          "1089:  al->al_rgd = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1339:  if (al == NULL)",
          "1340:   return -ECANCELED;",
          "1344:  if (rgrp_contains_block(rgd, ip->i_goal))",
          "1345:   goal = ip->i_goal - rgd->rd_data0;",
          "",
          "[Removed Lines]",
          "1342:  rgd = al->al_rgd;",
          "",
          "[Added Lines]",
          "1341:  rgd = ip->i_rgd;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1398: {",
          "1399:  struct gfs2_sbd *sdp = GFS2_SB(&dip->i_inode);",
          "1400:  struct gfs2_alloc *al = dip->i_alloc;",
          "1402:  u32 blk;",
          "1403:  u64 block;",
          "1404:  unsigned int n = 1;",
          "",
          "[Removed Lines]",
          "1401:  struct gfs2_rgrpd *rgd = al->al_rgd;",
          "",
          "[Added Lines]",
          "1400:  struct gfs2_rgrpd *rgd = dip->i_rgd;",
          "",
          "---------------"
        ],
        "fs/gfs2/super.c||fs/gfs2/super.c": [
          "File: fs/gfs2/super.c -> fs/gfs2/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1574:  if (ip) {",
          "1575:   ip->i_flags = 0;",
          "1576:   ip->i_gl = NULL;",
          "1577:  }",
          "1578:  return &ip->i_inode;",
          "1579: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1577:   ip->i_rgd = NULL;",
          "",
          "---------------"
        ],
        "fs/gfs2/trans.h||fs/gfs2/trans.h": [
          "File: fs/gfs2/trans.h -> fs/gfs2/trans.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: {",
          "35: }",
          "37: extern int gfs2_trans_begin(struct gfs2_sbd *sdp, unsigned int blocks,",
          "",
          "[Removed Lines]",
          "31: static inline unsigned int gfs2_rg_blocks(const struct gfs2_alloc *al)",
          "33:  return (al->al_requested < al->al_rgd->rd_length)?",
          "34:         al->al_requested + 1 : al->al_rgd->rd_length;",
          "",
          "[Added Lines]",
          "31: static inline unsigned int gfs2_rg_blocks(const struct gfs2_inode *ip)",
          "33:  const struct gfs2_alloc *al = ip->i_alloc;",
          "34:  if (al->al_requested < ip->i_rgd->rd_length)",
          "35:   return al->al_requested + 1;",
          "36:  return ip->i_rgd->rd_length;",
          "",
          "---------------"
        ],
        "fs/gfs2/xattr.c||fs/gfs2/xattr.c": [
          "File: fs/gfs2/xattr.c -> fs/gfs2/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "727:   goto out_gunlock_q;",
          "729:  error = gfs2_trans_begin(GFS2_SB(&ip->i_inode),",
          "731:      RES_DINODE + RES_STATFS + RES_QUOTA, 0);",
          "732:  if (error)",
          "733:   goto out_ipres;",
          "",
          "[Removed Lines]",
          "730:      blks + gfs2_rg_blocks(al) +",
          "",
          "[Added Lines]",
          "730:      blks + gfs2_rg_blocks(ip) +",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6905d9e4dda6112f007e9090bca80507da158e63",
      "candidate_info": {
        "commit_hash": "6905d9e4dda6112f007e9090bca80507da158e63",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6905d9e4dda6112f007e9090bca80507da158e63",
        "files": [
          "fs/gfs2/file.c"
        ],
        "message": "GFS2: make sure fallocate bytes is a multiple of blksize\n\nThe GFS2 fallocate code chooses a target size to for allocating chunks of\nspace.  Whenever it can't find any resource groups with enough space free, it\nhalves its target. Since this target is in bytes, eventually it will no longer\nbe a multiple of blksize.  As long as there is more space available in the\nresource group than the target, this isn't a problem, since gfs2 will use the\nactual space available, which is always a multiple of blksize.  However,\nwhen gfs couldn't fallocate a bigger chunk than the target, it was using the\nnon-blksize aligned number. This caused a BUG in later code that required\nblksize aligned offsets.  GFS2 now ensures that bytes is always a multiple of\nblksize\n\nSigned-off-by: Benjamin Marzinski <bmarzins@redhat.com>\nSigned-off-by: Steven Whitehouse <swhiteho@redhat.com>",
        "before_after_code_files": [
          "fs/gfs2/file.c||fs/gfs2/file.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ],
          "candidate": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/gfs2/file.c||fs/gfs2/file.c": [
          "File: fs/gfs2/file.c -> fs/gfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "816:  loff_t bytes, max_bytes;",
          "817:  struct gfs2_alloc *al;",
          "818:  int error;",
          "819:  loff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;",
          "820:  next = (next + 1) << sdp->sd_sb.sb_bsize_shift;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "819:  loff_t bsize_mask = ~((loff_t)sdp->sd_sb.sb_bsize - 1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "823:  if (mode & ~FALLOC_FL_KEEP_SIZE)",
          "824:   return -EOPNOTSUPP;",
          "829:  len = next - offset;",
          "830:  bytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;",
          "831:  if (!bytes)",
          "832:   bytes = UINT_MAX;",
          "834:  gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);",
          "835:  error = gfs2_glock_nq(&ip->i_gh);",
          "",
          "[Removed Lines]",
          "826:  offset = (offset >> sdp->sd_sb.sb_bsize_shift) <<",
          "827:    sdp->sd_sb.sb_bsize_shift;",
          "",
          "[Added Lines]",
          "827:  offset &= bsize_mask;",
          "833:  bytes &= bsize_mask;",
          "834:  if (bytes == 0)",
          "835:   bytes = sdp->sd_sb.sb_bsize;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "860:   if (error) {",
          "861:    if (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {",
          "862:     bytes >>= 1;",
          "863:     goto retry;",
          "864:    }",
          "865:    goto out_qunlock;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "866:     bytes &= bsize_mask;",
          "867:     if (bytes == 0)",
          "868:      bytes = sdp->sd_sb.sb_bsize;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2fe17c1075836b66678ed2a305fd09b6773883aa",
      "candidate_info": {
        "commit_hash": "2fe17c1075836b66678ed2a305fd09b6773883aa",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2fe17c1075836b66678ed2a305fd09b6773883aa",
        "files": [
          "Documentation/filesystems/Locking",
          "fs/btrfs/file.c",
          "fs/btrfs/inode.c",
          "fs/ext4/ext4.h",
          "fs/ext4/extents.c",
          "fs/ext4/file.c",
          "fs/gfs2/file.c",
          "fs/gfs2/ops_inode.c",
          "fs/ocfs2/file.c",
          "fs/open.c",
          "fs/xfs/linux-2.6/xfs_file.c",
          "fs/xfs/linux-2.6/xfs_iops.c",
          "include/linux/fs.h"
        ],
        "message": "fallocate should be a file operation\n\nCurrently all filesystems except XFS implement fallocate asynchronously,\nwhile XFS forced a commit.  Both of these are suboptimal - in case of O_SYNC\nI/O we really want our allocation on disk, especially for the !KEEP_SIZE\ncase where we actually grow the file with user-visible zeroes.  On the\nother hand always commiting the transaction is a bad idea for fast-path\nuses of fallocate like for example in recent Samba versions.   Given\nthat block allocation is a data plane operation anyway change it from\nan inode operation to a file operation so that we have the file structure\navailable that lets us check for O_SYNC.\n\nThis also includes moving the code around for a few of the filesystems,\nand remove the already unnedded S_ISDIR checks given that we only wire\nup fallocate for regular files.\n\nSigned-off-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "before_after_code_files": [
          "fs/btrfs/file.c||fs/btrfs/file.c",
          "fs/btrfs/inode.c||fs/btrfs/inode.c",
          "fs/ext4/ext4.h||fs/ext4/ext4.h",
          "fs/ext4/extents.c||fs/ext4/extents.c",
          "fs/ext4/file.c||fs/ext4/file.c",
          "fs/gfs2/file.c||fs/gfs2/file.c",
          "fs/gfs2/ops_inode.c||fs/gfs2/ops_inode.c",
          "fs/ocfs2/file.c||fs/ocfs2/file.c",
          "fs/open.c||fs/open.c",
          "fs/xfs/linux-2.6/xfs_file.c||fs/xfs/linux-2.6/xfs_file.c",
          "fs/xfs/linux-2.6/xfs_iops.c||fs/xfs/linux-2.6/xfs_iops.c",
          "include/linux/fs.h||include/linux/fs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ],
          "candidate": [
            "fs/gfs2/file.c||fs/gfs2/file.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/file.c||fs/btrfs/file.c": [
          "File: fs/btrfs/file.c -> fs/btrfs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include <linux/string.h>",
          "25: #include <linux/backing-dev.h>",
          "26: #include <linux/mpage.h>",
          "27: #include <linux/swap.h>",
          "28: #include <linux/writeback.h>",
          "29: #include <linux/statfs.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <linux/falloc.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1237:  return 0;",
          "1238: }",
          "1240: const struct file_operations btrfs_file_operations = {",
          "1241:  .llseek  = generic_file_llseek,",
          "1242:  .read  = do_sync_read,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1241: static long btrfs_fallocate(struct file *file, int mode,",
          "1242:        loff_t offset, loff_t len)",
          "1243: {",
          "1244:  struct inode *inode = file->f_path.dentry->d_inode;",
          "1245:  struct extent_state *cached_state = NULL;",
          "1246:  u64 cur_offset;",
          "1247:  u64 last_byte;",
          "1248:  u64 alloc_start;",
          "1249:  u64 alloc_end;",
          "1250:  u64 alloc_hint = 0;",
          "1251:  u64 locked_end;",
          "1252:  u64 mask = BTRFS_I(inode)->root->sectorsize - 1;",
          "1253:  struct extent_map *em;",
          "1254:  int ret;",
          "1256:  alloc_start = offset & ~mask;",
          "1257:  alloc_end =  (offset + len + mask) & ~mask;",
          "1260:  if (mode & ~FALLOC_FL_KEEP_SIZE)",
          "1261:   return -EOPNOTSUPP;",
          "1267:  btrfs_wait_ordered_range(inode, alloc_start, alloc_end - alloc_start);",
          "1269:  mutex_lock(&inode->i_mutex);",
          "1270:  ret = inode_newsize_ok(inode, alloc_end);",
          "1271:  if (ret)",
          "1272:   goto out;",
          "1274:  if (alloc_start > inode->i_size) {",
          "1275:   ret = btrfs_cont_expand(inode, alloc_start);",
          "1276:   if (ret)",
          "1277:    goto out;",
          "1278:  }",
          "1280:  ret = btrfs_check_data_free_space(inode, alloc_end - alloc_start);",
          "1281:  if (ret)",
          "1282:   goto out;",
          "1284:  locked_end = alloc_end - 1;",
          "1285:  while (1) {",
          "1286:   struct btrfs_ordered_extent *ordered;",
          "1291:   lock_extent_bits(&BTRFS_I(inode)->io_tree, alloc_start,",
          "1292:      locked_end, 0, &cached_state, GFP_NOFS);",
          "1293:   ordered = btrfs_lookup_first_ordered_extent(inode,",
          "1294:            alloc_end - 1);",
          "1295:   if (ordered &&",
          "1296:       ordered->file_offset + ordered->len > alloc_start &&",
          "1297:       ordered->file_offset < alloc_end) {",
          "1298:    btrfs_put_ordered_extent(ordered);",
          "1299:    unlock_extent_cached(&BTRFS_I(inode)->io_tree,",
          "1300:           alloc_start, locked_end,",
          "1301:           &cached_state, GFP_NOFS);",
          "1306:    btrfs_wait_ordered_range(inode, alloc_start,",
          "1307:        alloc_end - alloc_start);",
          "1308:   } else {",
          "1309:    if (ordered)",
          "1310:     btrfs_put_ordered_extent(ordered);",
          "1311:    break;",
          "1312:   }",
          "1313:  }",
          "1315:  cur_offset = alloc_start;",
          "1316:  while (1) {",
          "1317:   em = btrfs_get_extent(inode, NULL, 0, cur_offset,",
          "1318:           alloc_end - cur_offset, 0);",
          "1319:   BUG_ON(IS_ERR(em) || !em);",
          "1320:   last_byte = min(extent_map_end(em), alloc_end);",
          "1321:   last_byte = (last_byte + mask) & ~mask;",
          "1322:   if (em->block_start == EXTENT_MAP_HOLE ||",
          "1323:       (cur_offset >= inode->i_size &&",
          "1324:        !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))) {",
          "1325:    ret = btrfs_prealloc_file_range(inode, mode, cur_offset,",
          "1326:        last_byte - cur_offset,",
          "1327:        1 << inode->i_blkbits,",
          "1328:        offset + len,",
          "1329:        &alloc_hint);",
          "1330:    if (ret < 0) {",
          "1331:     free_extent_map(em);",
          "1332:     break;",
          "1333:    }",
          "1334:   }",
          "1335:   free_extent_map(em);",
          "1337:   cur_offset = last_byte;",
          "1338:   if (cur_offset >= alloc_end) {",
          "1339:    ret = 0;",
          "1340:    break;",
          "1341:   }",
          "1342:  }",
          "1343:  unlock_extent_cached(&BTRFS_I(inode)->io_tree, alloc_start, locked_end,",
          "1344:         &cached_state, GFP_NOFS);",
          "1346:  btrfs_free_reserved_data_space(inode, alloc_end - alloc_start);",
          "1347: out:",
          "1348:  mutex_unlock(&inode->i_mutex);",
          "1349:  return ret;",
          "1350: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1248:  .open  = generic_file_open,",
          "1249:  .release = btrfs_release_file,",
          "1250:  .fsync  = btrfs_sync_file,",
          "1251:  .unlocked_ioctl = btrfs_ioctl,",
          "1252: #ifdef CONFIG_COMPAT",
          "1253:  .compat_ioctl = btrfs_ioctl,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1363:  .fallocate = btrfs_fallocate,",
          "",
          "---------------"
        ],
        "fs/btrfs/inode.c||fs/btrfs/inode.c": [
          "File: fs/btrfs/inode.c -> fs/btrfs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7098:         min_size, actual_len, alloc_hint, trans);",
          "7099: }",
          "7211: static int btrfs_set_page_dirty(struct page *page)",
          "7212: {",
          "7213:  return __set_page_dirty_nobuffers(page);",
          "",
          "[Removed Lines]",
          "7101: static long btrfs_fallocate(struct inode *inode, int mode,",
          "7102:        loff_t offset, loff_t len)",
          "7103: {",
          "7104:  struct extent_state *cached_state = NULL;",
          "7105:  u64 cur_offset;",
          "7106:  u64 last_byte;",
          "7107:  u64 alloc_start;",
          "7108:  u64 alloc_end;",
          "7109:  u64 alloc_hint = 0;",
          "7110:  u64 locked_end;",
          "7111:  u64 mask = BTRFS_I(inode)->root->sectorsize - 1;",
          "7112:  struct extent_map *em;",
          "7113:  int ret;",
          "7115:  alloc_start = offset & ~mask;",
          "7116:  alloc_end =  (offset + len + mask) & ~mask;",
          "7119:  if (mode & ~FALLOC_FL_KEEP_SIZE)",
          "7120:   return -EOPNOTSUPP;",
          "7126:  btrfs_wait_ordered_range(inode, alloc_start, alloc_end - alloc_start);",
          "7128:  mutex_lock(&inode->i_mutex);",
          "7129:  ret = inode_newsize_ok(inode, alloc_end);",
          "7130:  if (ret)",
          "7131:   goto out;",
          "7133:  if (alloc_start > inode->i_size) {",
          "7134:   ret = btrfs_cont_expand(inode, alloc_start);",
          "7135:   if (ret)",
          "7136:    goto out;",
          "7137:  }",
          "7139:  ret = btrfs_check_data_free_space(inode, alloc_end - alloc_start);",
          "7140:  if (ret)",
          "7141:   goto out;",
          "7143:  locked_end = alloc_end - 1;",
          "7144:  while (1) {",
          "7145:   struct btrfs_ordered_extent *ordered;",
          "7150:   lock_extent_bits(&BTRFS_I(inode)->io_tree, alloc_start,",
          "7151:      locked_end, 0, &cached_state, GFP_NOFS);",
          "7152:   ordered = btrfs_lookup_first_ordered_extent(inode,",
          "7153:            alloc_end - 1);",
          "7154:   if (ordered &&",
          "7155:       ordered->file_offset + ordered->len > alloc_start &&",
          "7156:       ordered->file_offset < alloc_end) {",
          "7157:    btrfs_put_ordered_extent(ordered);",
          "7158:    unlock_extent_cached(&BTRFS_I(inode)->io_tree,",
          "7159:           alloc_start, locked_end,",
          "7160:           &cached_state, GFP_NOFS);",
          "7165:    btrfs_wait_ordered_range(inode, alloc_start,",
          "7166:        alloc_end - alloc_start);",
          "7167:   } else {",
          "7168:    if (ordered)",
          "7169:     btrfs_put_ordered_extent(ordered);",
          "7170:    break;",
          "7171:   }",
          "7172:  }",
          "7174:  cur_offset = alloc_start;",
          "7175:  while (1) {",
          "7176:   em = btrfs_get_extent(inode, NULL, 0, cur_offset,",
          "7177:           alloc_end - cur_offset, 0);",
          "7178:   BUG_ON(IS_ERR(em) || !em);",
          "7179:   last_byte = min(extent_map_end(em), alloc_end);",
          "7180:   last_byte = (last_byte + mask) & ~mask;",
          "7181:   if (em->block_start == EXTENT_MAP_HOLE ||",
          "7182:       (cur_offset >= inode->i_size &&",
          "7183:        !test_bit(EXTENT_FLAG_PREALLOC, &em->flags))) {",
          "7184:    ret = btrfs_prealloc_file_range(inode, mode, cur_offset,",
          "7185:        last_byte - cur_offset,",
          "7186:        1 << inode->i_blkbits,",
          "7187:        offset + len,",
          "7188:        &alloc_hint);",
          "7189:    if (ret < 0) {",
          "7190:     free_extent_map(em);",
          "7191:     break;",
          "7192:    }",
          "7193:   }",
          "7194:   free_extent_map(em);",
          "7196:   cur_offset = last_byte;",
          "7197:   if (cur_offset >= alloc_end) {",
          "7198:    ret = 0;",
          "7199:    break;",
          "7200:   }",
          "7201:  }",
          "7202:  unlock_extent_cached(&BTRFS_I(inode)->io_tree, alloc_start, locked_end,",
          "7203:         &cached_state, GFP_NOFS);",
          "7205:  btrfs_free_reserved_data_space(inode, alloc_end - alloc_start);",
          "7206: out:",
          "7207:  mutex_unlock(&inode->i_mutex);",
          "7208:  return ret;",
          "7209: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7310:  .listxattr      = btrfs_listxattr,",
          "7311:  .removexattr = btrfs_removexattr,",
          "7312:  .permission = btrfs_permission,",
          "7314:  .fiemap  = btrfs_fiemap,",
          "7315: };",
          "7316: static const struct inode_operations btrfs_special_inode_operations = {",
          "",
          "[Removed Lines]",
          "7313:  .fallocate = btrfs_fallocate,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/ext4.h||fs/ext4/ext4.h": [
          "File: fs/ext4/ext4.h -> fs/ext4/ext4.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2065: extern void ext4_ext_truncate(struct inode *);",
          "2066: extern void ext4_ext_init(struct super_block *);",
          "2067: extern void ext4_ext_release(struct super_block *);",
          "2069:      loff_t len);",
          "2070: extern int ext4_convert_unwritten_extents(struct inode *inode, loff_t offset,",
          "2071:      ssize_t len);",
          "",
          "[Removed Lines]",
          "2068: extern long ext4_fallocate(struct inode *inode, int mode, loff_t offset,",
          "",
          "[Added Lines]",
          "2068: extern long ext4_fallocate(struct file *file, int mode, loff_t offset,",
          "",
          "---------------"
        ],
        "fs/ext4/extents.c||fs/ext4/extents.c": [
          "File: fs/ext4/extents.c -> fs/ext4/extents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3627: }",
          "3637: {",
          "3638:  handle_t *handle;",
          "3639:  loff_t new_size;",
          "3640:  unsigned int max_blocks;",
          "",
          "[Removed Lines]",
          "3636: long ext4_fallocate(struct inode *inode, int mode, loff_t offset, loff_t len)",
          "",
          "[Added Lines]",
          "3636: long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)",
          "3638:  struct inode *inode = file->f_path.dentry->d_inode;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3655:  if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))",
          "3656:   return -EOPNOTSUPP;",
          "3662:  map.m_lblk = offset >> blkbits;",
          "",
          "[Removed Lines]",
          "3659:  if (S_ISDIR(inode->i_mode))",
          "3660:   return -ENODEV;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ext4/file.c||fs/ext4/file.c": [
          "File: fs/ext4/file.c -> fs/ext4/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "210:  .fsync  = ext4_sync_file,",
          "211:  .splice_read = generic_file_splice_read,",
          "212:  .splice_write = generic_file_splice_write,",
          "213: };",
          "215: const struct inode_operations ext4_file_inode_operations = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213:  .fallocate = ext4_fallocate,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:  .removexattr = generic_removexattr,",
          "224: #endif",
          "225:  .check_acl = ext4_check_acl,",
          "227:  .fiemap  = ext4_fiemap,",
          "228: };",
          "",
          "[Removed Lines]",
          "226:  .fallocate = ext4_fallocate,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/gfs2/file.c||fs/gfs2/file.c": [
          "File: fs/gfs2/file.c -> fs/gfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: #include <linux/fs.h>",
          "20: #include <linux/gfs2_ondisk.h>",
          "21: #include <linux/ext2_fs.h>",
          "22: #include <linux/crc32.h>",
          "23: #include <linux/writeback.h>",
          "24: #include <asm/uaccess.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include <linux/falloc.h>",
          "23: #include <linux/swap.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "610:  return generic_file_aio_write(iocb, iov, nr_segs, pos);",
          "611: }",
          "613: #ifdef CONFIG_GFS2_FS_LOCKING_DLM",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "615: static void empty_write_end(struct page *page, unsigned from,",
          "616:       unsigned to)",
          "617: {",
          "618:  struct gfs2_inode *ip = GFS2_I(page->mapping->host);",
          "620:  page_zero_new_buffers(page, from, to);",
          "621:  flush_dcache_page(page);",
          "622:  mark_page_accessed(page);",
          "624:  if (!gfs2_is_writeback(ip))",
          "625:   gfs2_page_add_databufs(ip, page, from, to);",
          "627:  block_commit_write(page, from, to);",
          "628: }",
          "630: static int write_empty_blocks(struct page *page, unsigned from, unsigned to)",
          "631: {",
          "632:  unsigned start, end, next;",
          "633:  struct buffer_head *bh, *head;",
          "634:  int error;",
          "636:  if (!page_has_buffers(page)) {",
          "637:   error = __block_write_begin(page, from, to - from, gfs2_block_map);",
          "638:   if (unlikely(error))",
          "639:    return error;",
          "641:   empty_write_end(page, from, to);",
          "642:   return 0;",
          "643:  }",
          "645:  bh = head = page_buffers(page);",
          "646:  next = end = 0;",
          "647:  while (next < from) {",
          "648:   next += bh->b_size;",
          "649:   bh = bh->b_this_page;",
          "650:  }",
          "651:  start = next;",
          "652:  do {",
          "653:   next += bh->b_size;",
          "654:   if (buffer_mapped(bh)) {",
          "655:    if (end) {",
          "656:     error = __block_write_begin(page, start, end - start,",
          "657:            gfs2_block_map);",
          "658:     if (unlikely(error))",
          "659:      return error;",
          "660:     empty_write_end(page, start, end);",
          "661:     end = 0;",
          "662:    }",
          "663:    start = next;",
          "664:   }",
          "665:   else",
          "666:    end = next;",
          "667:   bh = bh->b_this_page;",
          "668:  } while (next < to);",
          "670:  if (end) {",
          "671:   error = __block_write_begin(page, start, end - start, gfs2_block_map);",
          "672:   if (unlikely(error))",
          "673:    return error;",
          "674:   empty_write_end(page, start, end);",
          "675:  }",
          "677:  return 0;",
          "678: }",
          "680: static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,",
          "681:       int mode)",
          "682: {",
          "683:  struct gfs2_inode *ip = GFS2_I(inode);",
          "684:  struct buffer_head *dibh;",
          "685:  int error;",
          "686:  u64 start = offset >> PAGE_CACHE_SHIFT;",
          "687:  unsigned int start_offset = offset & ~PAGE_CACHE_MASK;",
          "688:  u64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;",
          "689:  pgoff_t curr;",
          "690:  struct page *page;",
          "691:  unsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;",
          "692:  unsigned int from, to;",
          "694:  if (!end_offset)",
          "695:   end_offset = PAGE_CACHE_SIZE;",
          "697:  error = gfs2_meta_inode_buffer(ip, &dibh);",
          "698:  if (unlikely(error))",
          "699:   goto out;",
          "701:  gfs2_trans_add_bh(ip->i_gl, dibh, 1);",
          "703:  if (gfs2_is_stuffed(ip)) {",
          "704:   error = gfs2_unstuff_dinode(ip, NULL);",
          "705:   if (unlikely(error))",
          "706:    goto out;",
          "707:  }",
          "709:  curr = start;",
          "710:  offset = start << PAGE_CACHE_SHIFT;",
          "711:  from = start_offset;",
          "712:  to = PAGE_CACHE_SIZE;",
          "713:  while (curr <= end) {",
          "714:   page = grab_cache_page_write_begin(inode->i_mapping, curr,",
          "715:          AOP_FLAG_NOFS);",
          "716:   if (unlikely(!page)) {",
          "717:    error = -ENOMEM;",
          "718:    goto out;",
          "719:   }",
          "721:   if (curr == end)",
          "722:    to = end_offset;",
          "723:   error = write_empty_blocks(page, from, to);",
          "724:   if (!error && offset + to > inode->i_size &&",
          "725:       !(mode & FALLOC_FL_KEEP_SIZE)) {",
          "726:    i_size_write(inode, offset + to);",
          "727:   }",
          "728:   unlock_page(page);",
          "729:   page_cache_release(page);",
          "730:   if (error)",
          "731:    goto out;",
          "732:   curr++;",
          "733:   offset += PAGE_CACHE_SIZE;",
          "734:   from = 0;",
          "735:  }",
          "737:  gfs2_dinode_out(ip, dibh->b_data);",
          "738:  mark_inode_dirty(inode);",
          "740:  brelse(dibh);",
          "742: out:",
          "743:  return error;",
          "744: }",
          "746: static void calc_max_reserv(struct gfs2_inode *ip, loff_t max, loff_t *len,",
          "747:        unsigned int *data_blocks, unsigned int *ind_blocks)",
          "748: {",
          "749:  const struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);",
          "750:  unsigned int max_blocks = ip->i_alloc->al_rgd->rd_free_clone;",
          "751:  unsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);",
          "753:  for (tmp = max_data; tmp > sdp->sd_diptrs;) {",
          "754:   tmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);",
          "755:   max_data -= tmp;",
          "756:  }",
          "759:  if (max_data <= *data_blocks)",
          "760:   return;",
          "764:  if (*len > max) {",
          "766:   gfs2_write_calc_reserv(ip, max, data_blocks, ind_blocks);",
          "767:  }",
          "768: }",
          "770: static long gfs2_fallocate(struct file *file, int mode, loff_t offset,",
          "771:       loff_t len)",
          "772: {",
          "773:  struct inode *inode = file->f_path.dentry->d_inode;",
          "774:  struct gfs2_sbd *sdp = GFS2_SB(inode);",
          "775:  struct gfs2_inode *ip = GFS2_I(inode);",
          "776:  unsigned int data_blocks = 0, ind_blocks = 0, rblocks;",
          "777:  loff_t bytes, max_bytes;",
          "778:  struct gfs2_alloc *al;",
          "779:  int error;",
          "780:  loff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;",
          "781:  next = (next + 1) << sdp->sd_sb.sb_bsize_shift;",
          "784:  if (mode & ~FALLOC_FL_KEEP_SIZE)",
          "785:   return -EOPNOTSUPP;",
          "787:  offset = (offset >> sdp->sd_sb.sb_bsize_shift) <<",
          "788:    sdp->sd_sb.sb_bsize_shift;",
          "790:  len = next - offset;",
          "791:  bytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;",
          "792:  if (!bytes)",
          "793:   bytes = UINT_MAX;",
          "795:  gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);",
          "796:  error = gfs2_glock_nq(&ip->i_gh);",
          "797:  if (unlikely(error))",
          "798:   goto out_uninit;",
          "800:  if (!gfs2_write_alloc_required(ip, offset, len))",
          "801:   goto out_unlock;",
          "803:  while (len > 0) {",
          "804:   if (len < bytes)",
          "805:    bytes = len;",
          "806:   al = gfs2_alloc_get(ip);",
          "807:   if (!al) {",
          "808:    error = -ENOMEM;",
          "809:    goto out_unlock;",
          "810:   }",
          "812:   error = gfs2_quota_lock_check(ip);",
          "813:   if (error)",
          "814:    goto out_alloc_put;",
          "816: retry:",
          "817:   gfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);",
          "819:   al->al_requested = data_blocks + ind_blocks;",
          "820:   error = gfs2_inplace_reserve(ip);",
          "821:   if (error) {",
          "822:    if (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {",
          "823:     bytes >>= 1;",
          "824:     goto retry;",
          "825:    }",
          "826:    goto out_qunlock;",
          "827:   }",
          "828:   max_bytes = bytes;",
          "829:   calc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);",
          "830:   al->al_requested = data_blocks + ind_blocks;",
          "832:   rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +",
          "833:      RES_RG_HDR + gfs2_rg_blocks(al);",
          "834:   if (gfs2_is_jdata(ip))",
          "835:    rblocks += data_blocks ? data_blocks : 1;",
          "837:   error = gfs2_trans_begin(sdp, rblocks,",
          "838:       PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);",
          "839:   if (error)",
          "840:    goto out_trans_fail;",
          "842:   error = fallocate_chunk(inode, offset, max_bytes, mode);",
          "843:   gfs2_trans_end(sdp);",
          "845:   if (error)",
          "846:    goto out_trans_fail;",
          "848:   len -= max_bytes;",
          "849:   offset += max_bytes;",
          "850:   gfs2_inplace_release(ip);",
          "851:   gfs2_quota_unlock(ip);",
          "852:   gfs2_alloc_put(ip);",
          "853:  }",
          "854:  goto out_unlock;",
          "856: out_trans_fail:",
          "857:  gfs2_inplace_release(ip);",
          "858: out_qunlock:",
          "859:  gfs2_quota_unlock(ip);",
          "860: out_alloc_put:",
          "861:  gfs2_alloc_put(ip);",
          "862: out_unlock:",
          "863:  gfs2_glock_dq(&ip->i_gh);",
          "864: out_uninit:",
          "865:  gfs2_holder_uninit(&ip->i_gh);",
          "866:  return error;",
          "867: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "765:  .splice_read = generic_file_splice_read,",
          "766:  .splice_write = generic_file_splice_write,",
          "767:  .setlease = gfs2_setlease,",
          "768: };",
          "770: const struct file_operations gfs2_dir_fops = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1024:  .fallocate = gfs2_fallocate,",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "794:  .splice_read = generic_file_splice_read,",
          "795:  .splice_write = generic_file_splice_write,",
          "796:  .setlease = generic_setlease,",
          "797: };",
          "799: const struct file_operations gfs2_dir_fops_nolock = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1054:  .fallocate = gfs2_fallocate,",
          "",
          "---------------"
        ],
        "fs/gfs2/ops_inode.c||fs/gfs2/ops_inode.c": [
          "File: fs/gfs2/ops_inode.c -> fs/gfs2/ops_inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <linux/gfs2_ondisk.h>",
          "19: #include <linux/crc32.h>",
          "20: #include <linux/fiemap.h>",
          "23: #include <asm/uaccess.h>",
          "25: #include \"gfs2.h\"",
          "",
          "[Removed Lines]",
          "21: #include <linux/swap.h>",
          "22: #include <linux/falloc.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1257:  return ret;",
          "1258: }",
          "1515: static int gfs2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,",
          "1516:          u64 start, u64 len)",
          "1517: {",
          "",
          "[Removed Lines]",
          "1260: static void empty_write_end(struct page *page, unsigned from,",
          "1261:       unsigned to)",
          "1262: {",
          "1263:  struct gfs2_inode *ip = GFS2_I(page->mapping->host);",
          "1265:  page_zero_new_buffers(page, from, to);",
          "1266:  flush_dcache_page(page);",
          "1267:  mark_page_accessed(page);",
          "1269:  if (!gfs2_is_writeback(ip))",
          "1270:   gfs2_page_add_databufs(ip, page, from, to);",
          "1272:  block_commit_write(page, from, to);",
          "1273: }",
          "1276: static int write_empty_blocks(struct page *page, unsigned from, unsigned to)",
          "1277: {",
          "1278:  unsigned start, end, next;",
          "1279:  struct buffer_head *bh, *head;",
          "1280:  int error;",
          "1282:  if (!page_has_buffers(page)) {",
          "1283:   error = __block_write_begin(page, from, to - from, gfs2_block_map);",
          "1284:   if (unlikely(error))",
          "1285:    return error;",
          "1287:   empty_write_end(page, from, to);",
          "1288:   return 0;",
          "1289:  }",
          "1291:  bh = head = page_buffers(page);",
          "1292:  next = end = 0;",
          "1293:  while (next < from) {",
          "1294:   next += bh->b_size;",
          "1295:   bh = bh->b_this_page;",
          "1296:  }",
          "1297:  start = next;",
          "1298:  do {",
          "1299:   next += bh->b_size;",
          "1300:   if (buffer_mapped(bh)) {",
          "1301:    if (end) {",
          "1302:     error = __block_write_begin(page, start, end - start,",
          "1303:            gfs2_block_map);",
          "1304:     if (unlikely(error))",
          "1305:      return error;",
          "1306:     empty_write_end(page, start, end);",
          "1307:     end = 0;",
          "1308:    }",
          "1309:    start = next;",
          "1310:   }",
          "1311:   else",
          "1312:    end = next;",
          "1313:   bh = bh->b_this_page;",
          "1314:  } while (next < to);",
          "1316:  if (end) {",
          "1317:   error = __block_write_begin(page, start, end - start, gfs2_block_map);",
          "1318:   if (unlikely(error))",
          "1319:    return error;",
          "1320:   empty_write_end(page, start, end);",
          "1321:  }",
          "1323:  return 0;",
          "1324: }",
          "1326: static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,",
          "1327:       int mode)",
          "1328: {",
          "1329:  struct gfs2_inode *ip = GFS2_I(inode);",
          "1330:  struct buffer_head *dibh;",
          "1331:  int error;",
          "1332:  u64 start = offset >> PAGE_CACHE_SHIFT;",
          "1333:  unsigned int start_offset = offset & ~PAGE_CACHE_MASK;",
          "1334:  u64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;",
          "1335:  pgoff_t curr;",
          "1336:  struct page *page;",
          "1337:  unsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;",
          "1338:  unsigned int from, to;",
          "1340:  if (!end_offset)",
          "1341:   end_offset = PAGE_CACHE_SIZE;",
          "1343:  error = gfs2_meta_inode_buffer(ip, &dibh);",
          "1344:  if (unlikely(error))",
          "1345:   goto out;",
          "1347:  gfs2_trans_add_bh(ip->i_gl, dibh, 1);",
          "1349:  if (gfs2_is_stuffed(ip)) {",
          "1350:   error = gfs2_unstuff_dinode(ip, NULL);",
          "1351:   if (unlikely(error))",
          "1352:    goto out;",
          "1353:  }",
          "1355:  curr = start;",
          "1356:  offset = start << PAGE_CACHE_SHIFT;",
          "1357:  from = start_offset;",
          "1358:  to = PAGE_CACHE_SIZE;",
          "1359:  while (curr <= end) {",
          "1360:   page = grab_cache_page_write_begin(inode->i_mapping, curr,",
          "1361:          AOP_FLAG_NOFS);",
          "1362:   if (unlikely(!page)) {",
          "1363:    error = -ENOMEM;",
          "1364:    goto out;",
          "1365:   }",
          "1367:   if (curr == end)",
          "1368:    to = end_offset;",
          "1369:   error = write_empty_blocks(page, from, to);",
          "1370:   if (!error && offset + to > inode->i_size &&",
          "1371:       !(mode & FALLOC_FL_KEEP_SIZE)) {",
          "1372:    i_size_write(inode, offset + to);",
          "1373:   }",
          "1374:   unlock_page(page);",
          "1375:   page_cache_release(page);",
          "1376:   if (error)",
          "1377:    goto out;",
          "1378:   curr++;",
          "1379:   offset += PAGE_CACHE_SIZE;",
          "1380:   from = 0;",
          "1381:  }",
          "1383:  gfs2_dinode_out(ip, dibh->b_data);",
          "1384:  mark_inode_dirty(inode);",
          "1386:  brelse(dibh);",
          "1388: out:",
          "1389:  return error;",
          "1390: }",
          "1392: static void calc_max_reserv(struct gfs2_inode *ip, loff_t max, loff_t *len,",
          "1393:        unsigned int *data_blocks, unsigned int *ind_blocks)",
          "1394: {",
          "1395:  const struct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);",
          "1396:  unsigned int max_blocks = ip->i_alloc->al_rgd->rd_free_clone;",
          "1397:  unsigned int tmp, max_data = max_blocks - 3 * (sdp->sd_max_height - 1);",
          "1399:  for (tmp = max_data; tmp > sdp->sd_diptrs;) {",
          "1400:   tmp = DIV_ROUND_UP(tmp, sdp->sd_inptrs);",
          "1401:   max_data -= tmp;",
          "1402:  }",
          "1405:  if (max_data <= *data_blocks)",
          "1406:   return;",
          "1410:  if (*len > max) {",
          "1412:   gfs2_write_calc_reserv(ip, max, data_blocks, ind_blocks);",
          "1413:  }",
          "1414: }",
          "1416: static long gfs2_fallocate(struct inode *inode, int mode, loff_t offset,",
          "1417:       loff_t len)",
          "1418: {",
          "1419:  struct gfs2_sbd *sdp = GFS2_SB(inode);",
          "1420:  struct gfs2_inode *ip = GFS2_I(inode);",
          "1421:  unsigned int data_blocks = 0, ind_blocks = 0, rblocks;",
          "1422:  loff_t bytes, max_bytes;",
          "1423:  struct gfs2_alloc *al;",
          "1424:  int error;",
          "1425:  loff_t next = (offset + len - 1) >> sdp->sd_sb.sb_bsize_shift;",
          "1426:  next = (next + 1) << sdp->sd_sb.sb_bsize_shift;",
          "1429:  if (mode & ~FALLOC_FL_KEEP_SIZE)",
          "1430:   return -EOPNOTSUPP;",
          "1432:  offset = (offset >> sdp->sd_sb.sb_bsize_shift) <<",
          "1433:    sdp->sd_sb.sb_bsize_shift;",
          "1435:  len = next - offset;",
          "1436:  bytes = sdp->sd_max_rg_data * sdp->sd_sb.sb_bsize / 2;",
          "1437:  if (!bytes)",
          "1438:   bytes = UINT_MAX;",
          "1440:  gfs2_holder_init(ip->i_gl, LM_ST_EXCLUSIVE, 0, &ip->i_gh);",
          "1441:  error = gfs2_glock_nq(&ip->i_gh);",
          "1442:  if (unlikely(error))",
          "1443:   goto out_uninit;",
          "1445:  if (!gfs2_write_alloc_required(ip, offset, len))",
          "1446:   goto out_unlock;",
          "1448:  while (len > 0) {",
          "1449:   if (len < bytes)",
          "1450:    bytes = len;",
          "1451:   al = gfs2_alloc_get(ip);",
          "1452:   if (!al) {",
          "1453:    error = -ENOMEM;",
          "1454:    goto out_unlock;",
          "1455:   }",
          "1457:   error = gfs2_quota_lock_check(ip);",
          "1458:   if (error)",
          "1459:    goto out_alloc_put;",
          "1461: retry:",
          "1462:   gfs2_write_calc_reserv(ip, bytes, &data_blocks, &ind_blocks);",
          "1464:   al->al_requested = data_blocks + ind_blocks;",
          "1465:   error = gfs2_inplace_reserve(ip);",
          "1466:   if (error) {",
          "1467:    if (error == -ENOSPC && bytes > sdp->sd_sb.sb_bsize) {",
          "1468:     bytes >>= 1;",
          "1469:     goto retry;",
          "1470:    }",
          "1471:    goto out_qunlock;",
          "1472:   }",
          "1473:   max_bytes = bytes;",
          "1474:   calc_max_reserv(ip, len, &max_bytes, &data_blocks, &ind_blocks);",
          "1475:   al->al_requested = data_blocks + ind_blocks;",
          "1477:   rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA +",
          "1478:      RES_RG_HDR + gfs2_rg_blocks(al);",
          "1479:   if (gfs2_is_jdata(ip))",
          "1480:    rblocks += data_blocks ? data_blocks : 1;",
          "1482:   error = gfs2_trans_begin(sdp, rblocks,",
          "1483:       PAGE_CACHE_SIZE/sdp->sd_sb.sb_bsize);",
          "1484:   if (error)",
          "1485:    goto out_trans_fail;",
          "1487:   error = fallocate_chunk(inode, offset, max_bytes, mode);",
          "1488:   gfs2_trans_end(sdp);",
          "1490:   if (error)",
          "1491:    goto out_trans_fail;",
          "1493:   len -= max_bytes;",
          "1494:   offset += max_bytes;",
          "1495:   gfs2_inplace_release(ip);",
          "1496:   gfs2_quota_unlock(ip);",
          "1497:   gfs2_alloc_put(ip);",
          "1498:  }",
          "1499:  goto out_unlock;",
          "1501: out_trans_fail:",
          "1502:  gfs2_inplace_release(ip);",
          "1503: out_qunlock:",
          "1504:  gfs2_quota_unlock(ip);",
          "1505: out_alloc_put:",
          "1506:  gfs2_alloc_put(ip);",
          "1507: out_unlock:",
          "1508:  gfs2_glock_dq(&ip->i_gh);",
          "1509: out_uninit:",
          "1510:  gfs2_holder_uninit(&ip->i_gh);",
          "1511:  return error;",
          "1512: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1562:  .getxattr = gfs2_getxattr,",
          "1563:  .listxattr = gfs2_listxattr,",
          "1564:  .removexattr = gfs2_removexattr,",
          "1566:  .fiemap = gfs2_fiemap,",
          "1567: };",
          "",
          "[Removed Lines]",
          "1565:  .fallocate = gfs2_fallocate,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/ocfs2/file.c||fs/ocfs2/file.c": [
          "File: fs/ocfs2/file.c -> fs/ocfs2/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1989:  return __ocfs2_change_file_space(file, inode, file->f_pos, cmd, sr, 0);",
          "1990: }",
          "1993:        loff_t len)",
          "1994: {",
          "1995:  struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);",
          "1996:  struct ocfs2_space_resv sr;",
          "1997:  int change_size = 1;",
          "",
          "[Removed Lines]",
          "1992: static long ocfs2_fallocate(struct inode *inode, int mode, loff_t offset,",
          "",
          "[Added Lines]",
          "1992: static long ocfs2_fallocate(struct file *file, int mode, loff_t offset,",
          "1995:  struct inode *inode = file->f_path.dentry->d_inode;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2002:  if (!ocfs2_writes_unwritten_extents(osb))",
          "2003:   return -EOPNOTSUPP;",
          "2008:  if (mode & FALLOC_FL_KEEP_SIZE)",
          "2009:   change_size = 0;",
          "",
          "[Removed Lines]",
          "2005:  if (S_ISDIR(inode->i_mode))",
          "2006:   return -ENODEV;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2612:  .getxattr = generic_getxattr,",
          "2613:  .listxattr = ocfs2_listxattr,",
          "2614:  .removexattr = generic_removexattr,",
          "2616:  .fiemap  = ocfs2_fiemap,",
          "2617: };",
          "",
          "[Removed Lines]",
          "2615:  .fallocate = ocfs2_fallocate,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2644:  .flock  = ocfs2_flock,",
          "2645:  .splice_read = ocfs2_file_splice_read,",
          "2646:  .splice_write = ocfs2_file_splice_write,",
          "2647: };",
          "2649: const struct file_operations ocfs2_dops = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2644:  .fallocate = ocfs2_fallocate,",
          "",
          "---------------"
        ],
        "fs/open.c||fs/open.c": [
          "File: fs/open.c -> fs/open.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "255:  if (((offset + len) > inode->i_sb->s_maxbytes) || ((offset + len) < 0))",
          "256:   return -EFBIG;",
          "259:   return -EOPNOTSUPP;",
          "262: }",
          "264: SYSCALL_DEFINE(fallocate)(int fd, int mode, loff_t offset, loff_t len)",
          "",
          "[Removed Lines]",
          "258:  if (!inode->i_op->fallocate)",
          "261:  return inode->i_op->fallocate(inode, mode, offset, len);",
          "",
          "[Added Lines]",
          "258:  if (!file->f_op->fallocate)",
          "261:  return file->f_op->fallocate(file, mode, offset, len);",
          "",
          "---------------"
        ],
        "fs/xfs/linux-2.6/xfs_file.c||fs/xfs/linux-2.6/xfs_file.c": [
          "File: fs/xfs/linux-2.6/xfs_file.c -> fs/xfs/linux-2.6/xfs_file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include \"xfs_trace.h\"",
          "39: #include <linux/dcache.h>",
          "41: static const struct vm_operations_struct xfs_file_vm_ops;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #include <linux/falloc.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "882:  return ret;",
          "883: }",
          "885: STATIC int",
          "886: xfs_file_open(",
          "887:  struct inode *inode,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "886: STATIC long",
          "887: xfs_file_fallocate(",
          "888:  struct file *file,",
          "889:  int  mode,",
          "890:  loff_t  offset,",
          "891:  loff_t  len)",
          "892: {",
          "893:  struct inode *inode = file->f_path.dentry->d_inode;",
          "894:  long  error;",
          "895:  loff_t  new_size = 0;",
          "896:  xfs_flock64_t bf;",
          "897:  xfs_inode_t *ip = XFS_I(inode);",
          "898:  int  cmd = XFS_IOC_RESVSP;",
          "900:  if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))",
          "901:   return -EOPNOTSUPP;",
          "903:  bf.l_whence = 0;",
          "904:  bf.l_start = offset;",
          "905:  bf.l_len = len;",
          "907:  xfs_ilock(ip, XFS_IOLOCK_EXCL);",
          "909:  if (mode & FALLOC_FL_PUNCH_HOLE)",
          "910:   cmd = XFS_IOC_UNRESVSP;",
          "913:  if (!(mode & FALLOC_FL_KEEP_SIZE) &&",
          "914:      offset + len > i_size_read(inode)) {",
          "915:   new_size = offset + len;",
          "916:   error = inode_newsize_ok(inode, new_size);",
          "917:   if (error)",
          "918:    goto out_unlock;",
          "919:  }",
          "921:  error = -xfs_change_file_space(ip, cmd, &bf, 0, XFS_ATTR_NOLOCK);",
          "922:  if (error)",
          "923:   goto out_unlock;",
          "926:  if (new_size) {",
          "927:   struct iattr iattr;",
          "929:   iattr.ia_valid = ATTR_SIZE;",
          "930:   iattr.ia_size = new_size;",
          "931:   error = -xfs_setattr(ip, &iattr, XFS_ATTR_NOLOCK);",
          "932:  }",
          "934: out_unlock:",
          "935:  xfs_iunlock(ip, XFS_IOLOCK_EXCL);",
          "936:  return error;",
          "937: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1000:  .open  = xfs_file_open,",
          "1001:  .release = xfs_file_release,",
          "1002:  .fsync  = xfs_file_fsync,",
          "1003: };",
          "1005: const struct file_operations xfs_dir_file_operations = {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1058:  .fallocate = xfs_file_fallocate,",
          "",
          "---------------"
        ],
        "fs/xfs/linux-2.6/xfs_iops.c||fs/xfs/linux-2.6/xfs_iops.c": [
          "File: fs/xfs/linux-2.6/xfs_iops.c -> fs/xfs/linux-2.6/xfs_iops.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "46: #include <linux/namei.h>",
          "47: #include <linux/posix_acl.h>",
          "48: #include <linux/security.h>",
          "50: #include <linux/fiemap.h>",
          "51: #include <linux/slab.h>",
          "",
          "[Removed Lines]",
          "49: #include <linux/falloc.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "505:  return -xfs_setattr(XFS_I(dentry->d_inode), iattr, 0);",
          "506: }",
          "566: #define XFS_FIEMAP_FLAGS (FIEMAP_FLAG_SYNC|FIEMAP_FLAG_XATTR)",
          "",
          "[Removed Lines]",
          "508: STATIC long",
          "509: xfs_vn_fallocate(",
          "510:  struct inode *inode,",
          "511:  int  mode,",
          "512:  loff_t  offset,",
          "513:  loff_t  len)",
          "514: {",
          "515:  long  error;",
          "516:  loff_t  new_size = 0;",
          "517:  xfs_flock64_t bf;",
          "518:  xfs_inode_t *ip = XFS_I(inode);",
          "519:  int  cmd = XFS_IOC_RESVSP;",
          "521:  if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE))",
          "522:   return -EOPNOTSUPP;",
          "525:  error = -ENODEV;",
          "526:  if (S_ISDIR(inode->i_mode))",
          "527:   goto out_error;",
          "529:  bf.l_whence = 0;",
          "530:  bf.l_start = offset;",
          "531:  bf.l_len = len;",
          "533:  xfs_ilock(ip, XFS_IOLOCK_EXCL);",
          "535:  if (mode & FALLOC_FL_PUNCH_HOLE)",
          "536:   cmd = XFS_IOC_UNRESVSP;",
          "539:  if (!(mode & FALLOC_FL_KEEP_SIZE) &&",
          "540:      offset + len > i_size_read(inode)) {",
          "541:   new_size = offset + len;",
          "542:   error = inode_newsize_ok(inode, new_size);",
          "543:   if (error)",
          "544:    goto out_unlock;",
          "545:  }",
          "547:  error = -xfs_change_file_space(ip, cmd, &bf, 0, XFS_ATTR_NOLOCK);",
          "548:  if (error)",
          "549:   goto out_unlock;",
          "552:  if (new_size) {",
          "553:   struct iattr iattr;",
          "555:   iattr.ia_valid = ATTR_SIZE;",
          "556:   iattr.ia_size = new_size;",
          "557:   error = -xfs_setattr(ip, &iattr, XFS_ATTR_NOLOCK);",
          "558:  }",
          "560: out_unlock:",
          "561:  xfs_iunlock(ip, XFS_IOLOCK_EXCL);",
          "562: out_error:",
          "563:  return error;",
          "564: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "656:  .getxattr  = generic_getxattr,",
          "657:  .removexattr  = generic_removexattr,",
          "658:  .listxattr  = xfs_vn_listxattr,",
          "660:  .fiemap   = xfs_vn_fiemap,",
          "661: };",
          "",
          "[Removed Lines]",
          "659:  .fallocate  = xfs_vn_fallocate,",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/fs.h||include/linux/fs.h": [
          "File: include/linux/fs.h -> include/linux/fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1552:  ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);",
          "1553:  ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);",
          "1554:  int (*setlease)(struct file *, long, struct file_lock **);",
          "1555: };",
          "1557: #define IPERM_FLAG_RCU 0x0001",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1555:  long (*fallocate)(struct file *file, int mode, loff_t offset,",
          "1556:      loff_t len);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1582:  ssize_t (*listxattr) (struct dentry *, char *, size_t);",
          "1583:  int (*removexattr) (struct dentry *, const char *);",
          "1584:  void (*truncate_range)(struct inode *, loff_t, loff_t);",
          "1587:  int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,",
          "1588:         u64 len);",
          "1589: } ____cacheline_aligned;",
          "",
          "[Removed Lines]",
          "1585:  long (*fallocate)(struct inode *inode, int mode, loff_t offset,",
          "1586:      loff_t len);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
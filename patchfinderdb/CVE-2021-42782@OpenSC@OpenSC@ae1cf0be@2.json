{
  "cve_id": "CVE-2021-42782",
  "cve_desc": "Stack buffer overflow issues were found in Opensc before version 0.22.0 in various places that could potentially crash programs using the library.",
  "repo": "OpenSC/OpenSC",
  "patch_hash": "ae1cf0be90396fb6c0be95829bf0d3eecbd2fd1c",
  "patch_info": {
    "commit_hash": "ae1cf0be90396fb6c0be95829bf0d3eecbd2fd1c",
    "repo": "OpenSC/OpenSC",
    "commit_url": "https://github.com/OpenSC/OpenSC/commit/ae1cf0be90396fb6c0be95829bf0d3eecbd2fd1c",
    "files": [
      "src/libopensc/card-iasecc.c"
    ],
    "message": "iasecc: Prevent stack buffer overflow when empty ACL is returned\n\nThanks oss-fuzz\n\nhttps://bugs.chromium.org/p/oss-fuzz/issues/detail?id=30800",
    "before_after_code_files": [
      "src/libopensc/card-iasecc.c||src/libopensc/card-iasecc.c"
    ]
  },
  "patch_diff": {
    "src/libopensc/card-iasecc.c||src/libopensc/card-iasecc.c": [
      "File: src/libopensc/card-iasecc.c -> src/libopensc/card-iasecc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1171:  else",
      "1172:   acls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);",
      "1175:   sc_log(ctx,",
      "1176:          \"ACLs not found in data(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\",",
      "1177:          buflen, sc_dump_hex(buf, buflen));",
      "",
      "[Removed Lines]",
      "1174:  if (!acls)   {",
      "",
      "[Added Lines]",
      "1174:  if (!acls || taglen < 7)   {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ffed34663da07681f8133a8edc3d879a2e61bf83",
      "candidate_info": {
        "commit_hash": "ffed34663da07681f8133a8edc3d879a2e61bf83",
        "repo": "OpenSC/OpenSC",
        "commit_url": "https://github.com/OpenSC/OpenSC/commit/ffed34663da07681f8133a8edc3d879a2e61bf83",
        "files": [
          "src/smm/sm-global-platform.c"
        ],
        "message": "sm-global-platform: Fix possible memory leak\n\nThanks coverity\n\nCID 365821",
        "before_after_code_files": [
          "src/smm/sm-global-platform.c||src/smm/sm-global-platform.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/OpenSC/OpenSC/pull/2219"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/smm/sm-global-platform.c||src/smm/sm-global-platform.c": [
          "File: src/smm/sm-global-platform.c -> src/smm/sm-global-platform.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "384:   if (sm_gp_encrypt_command_data(ctx, gp_session->session_enc, apdu->data, apdu->datalen, &encrypted, &encrypted_len))",
          "385:    LOG_TEST_RET(ctx, SC_ERROR_SM_ENCRYPT_FAILED, \"SM GP securize APDU: data encryption error\");",
          "390:   sc_debug(ctx, SC_LOG_DEBUG_SM,",
          "391:          \"SM GP securize APDU: encrypted length %\"SC_FORMAT_LEN_SIZE_T\"u\",",
          "",
          "[Removed Lines]",
          "387:   if (encrypted_len + 8 > SC_MAX_APDU_BUFFER_SIZE)",
          "388:    LOG_TEST_RET(ctx, SC_ERROR_BUFFER_TOO_SMALL, \"SM GP securize APDU: not enough place for encrypted data\");",
          "",
          "[Added Lines]",
          "387:   if (encrypted_len + 8 > SC_MAX_APDU_BUFFER_SIZE) {",
          "388:    rv = SC_ERROR_BUFFER_TOO_SMALL;",
          "389:    LOG_TEST_GOTO_ERR(ctx, rv, \"SM GP securize APDU: not enough place for encrypted data\");",
          "390:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "404:  memcpy(buff + 5, apdu_data, apdu->datalen);",
          "406:  rv = sm_gp_get_mac(gp_session->session_mac, &gp_session->mac_icv, buff, 5 + apdu->datalen, &mac);",
          "409:  if (gp_level == SM_GP_SECURITY_MAC)   {",
          "410:   memcpy(apdu_data + apdu->datalen, mac, 8);",
          "",
          "[Removed Lines]",
          "407:  LOG_TEST_RET(ctx, rv, \"SM GP securize APDU: get MAC error\");",
          "",
          "[Added Lines]",
          "409:  LOG_TEST_GOTO_ERR(ctx, rv, \"SM GP securize APDU: get MAC error\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "432:    apdu->cse = SC_APDU_CASE_3_SHORT;",
          "434:   free(encrypted);",
          "435:  }",
          "437:  memcpy(sm_info->session.gp.mac_icv, mac, 8);",
          "439:  LOG_FUNC_RETURN(ctx, rv);",
          "440: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "437:   encrypted = NULL;",
          "442: err:",
          "443:  free(encrypted);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3b556ef6188bd286f804f65b59e6d3ffc0798e0c",
      "candidate_info": {
        "commit_hash": "3b556ef6188bd286f804f65b59e6d3ffc0798e0c",
        "repo": "OpenSC/OpenSC",
        "commit_url": "https://github.com/OpenSC/OpenSC/commit/3b556ef6188bd286f804f65b59e6d3ffc0798e0c",
        "files": [
          "src/smm/sm-cwa14890.c"
        ],
        "message": "sm-cwa14890: Fix resource leak\n\nCID 365822\n\nThanks oss-fuzz",
        "before_after_code_files": [
          "src/smm/sm-cwa14890.c||src/smm/sm-cwa14890.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/OpenSC/OpenSC/pull/2219"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/smm/sm-cwa14890.c||src/smm/sm-cwa14890.c": [
          "File: src/smm/sm-cwa14890.c -> src/smm/sm-cwa14890.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:  size_t icc_sn_len = sizeof(cwa_session->icc.sn);",
          "235:  struct sc_remote_apdu *new_rapdu = NULL;",
          "236:  struct sc_apdu *apdu = NULL;",
          "238:  size_t encrypted_len;",
          "239:  DES_cblock icv = {0, 0, 0, 0, 0, 0, 0, 0}, cblock;",
          "240:  int rv, offs;",
          "",
          "[Removed Lines]",
          "237:  unsigned char buf[0x100], *encrypted;",
          "",
          "[Added Lines]",
          "237:  unsigned char buf[0x100], *encrypted = NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "282:  offs = encrypted_len;",
          "284:  rv = sm_cwa_get_mac(ctx, cwa_keyset->mac, &icv, buf, offs, &cblock, 1);",
          "286:  sc_debug(ctx, SC_LOG_DEBUG_SM, \"MACed(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\", sizeof(cblock),",
          "287:         sc_dump_hex(cblock, sizeof(cblock)));",
          "",
          "[Removed Lines]",
          "285:  LOG_TEST_RET(ctx, rv, \"sm_ecc_get_mac() failed\");",
          "",
          "[Added Lines]",
          "285:  LOG_TEST_GOTO_ERR(ctx, rv, \"sm_ecc_get_mac() failed\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "296:  apdu->datalen = encrypted_len + sizeof(cblock);",
          "297:  memcpy(new_rapdu->sbuf, encrypted, encrypted_len);",
          "298:  memcpy(new_rapdu->sbuf + encrypted_len, cblock, sizeof(cblock));",
          "300:  free(encrypted);",
          "302: }",
          "",
          "[Removed Lines]",
          "301:  LOG_FUNC_RETURN(ctx, SC_SUCCESS);",
          "",
          "[Added Lines]",
          "299:  rv = SC_SUCCESS;",
          "301: err:",
          "303:  LOG_FUNC_RETURN(ctx, rv);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2f232f217b24a3b4ef2fd2b974710a2ff14b7f2f",
      "candidate_info": {
        "commit_hash": "2f232f217b24a3b4ef2fd2b974710a2ff14b7f2f",
        "repo": "OpenSC/OpenSC",
        "commit_url": "https://github.com/OpenSC/OpenSC/commit/2f232f217b24a3b4ef2fd2b974710a2ff14b7f2f",
        "files": [
          "src/tools/pkcs11-tool.c"
        ],
        "message": "pkcs11-tool: Avoid double free and check allocation\n\n366349 Double free\n\nThanks coverity",
        "before_after_code_files": [
          "src/tools/pkcs11-tool.c||src/tools/pkcs11-tool.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/OpenSC/OpenSC/pull/2219"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/tools/pkcs11-tool.c||src/tools/pkcs11-tool.c": [
          "File: src/tools/pkcs11-tool.c -> src/tools/pkcs11-tool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7319:    fprintf(stderr, \"Test thread %d l_p11_num_slots:%ld\\n\", ttd->tnum, l_p11_num_slots);",
          "7320:    if (rv == CKR_OK) {",
          "7321:     free(l_p11_slots);",
          "7322:     if (l_p11_num_slots > 0) {",
          "7323:      l_p11_slots = calloc(l_p11_num_slots, sizeof(CK_SLOT_ID));",
          "7324:      fprintf(stderr, \"Test thread %d C_GetSlotList\\n\", ttd->tnum);",
          "7325:      rv = p11->C_GetSlotList(1, l_p11_slots, &l_p11_num_slots);",
          "7326:      ttd->rv = rv;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7322:     l_p11_slots = NULL;",
          "7325:      if (l_p11_slots == NULL) {",
          "7326:       goto err;",
          "7327:      }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b18234a7d9a2d63df1f1df6fa31a2b81447ede46",
      "candidate_info": {
        "commit_hash": "b18234a7d9a2d63df1f1df6fa31a2b81447ede46",
        "repo": "OpenSC/OpenSC",
        "commit_url": "https://github.com/OpenSC/OpenSC/commit/b18234a7d9a2d63df1f1df6fa31a2b81447ede46",
        "files": [
          "src/libopensc/card-iasecc.c"
        ],
        "message": "iasecc: Fix ACLs support when length is 6 (#2264)\n\n* IASECC: offset is a size_t\n\nLet's use a size_t for the offset in order to have a proper logic\nalong with the related arithmetics.\n\nFix: part if issue #2262\nSuggested-by: Frank Morgner <frankmorgner@gmail.com>\n\n* iasecc: Fix ACLs support when length is 6\n\nACLs with length < 6 are allowed, depending on the mask of the offset 0.\nFor instance, when the offset 0 is 0x7B, then length can be up to 7\nwhen the offset 0 is 0x7A, the loop was never performing any access to\nthe acls[7] thanks to:\n  if (!(mask & acls[0]))\n    continue;\n\nHowever, the oss-fuzz tools cannot guess such behavior. So let's have a\nrobust boundary check.\n\nFix: issue #2262\nFix: ae1cf0be90396f 'Prevent stack buffer overflow when empty ACL is returned'\n\nCo-authored-by: Vincent JARDIN <vjardin@free.fr>\nCo-authored-by: Frank Morgner <frankmorgner@gmail.com>",
        "before_after_code_files": [
          "src/libopensc/card-iasecc.c||src/libopensc/card-iasecc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/libopensc/card-iasecc.c||src/libopensc/card-iasecc.c"
          ],
          "candidate": [
            "src/libopensc/card-iasecc.c||src/libopensc/card-iasecc.c"
          ]
        }
      },
      "candidate_diff": {
        "src/libopensc/card-iasecc.c||src/libopensc/card-iasecc.c": [
          "File: src/libopensc/card-iasecc.c -> src/libopensc/card-iasecc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1188:    const unsigned char *buf, size_t buflen)",
          "1189: {",
          "1190:  struct sc_context *ctx = card->ctx;",
          "1193:  const unsigned char *acls = NULL, *tag = NULL;",
          "1194:  unsigned char mask;",
          "1195:  unsigned char ops_DF[7] = {",
          "",
          "[Removed Lines]",
          "1191:  size_t taglen;",
          "1192:  int rv, ii, offs;",
          "",
          "[Added Lines]",
          "1191:  size_t taglen, offs, ii;",
          "1192:  int rv;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1232:  else",
          "1233:   acls = sc_asn1_find_tag(ctx, buf, buflen, IASECC_DOCP_TAG_ACLS_CONTACT, &taglen);",
          "1236:   sc_log(ctx,",
          "1237:          \"ACLs not found in data(%\"SC_FORMAT_LEN_SIZE_T\"u) %s\",",
          "1238:          buflen, sc_dump_hex(buf, buflen));",
          "",
          "[Removed Lines]",
          "1235:  if (!acls || taglen < 7)   {",
          "",
          "[Added Lines]",
          "1235:  if (!acls)   {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1245:  for (ii = 0; ii < 7; ii++, mask /= 2)  {",
          "1246:   unsigned char op = file->type == SC_FILE_TYPE_DF ? ops_DF[ii] : ops_EF[ii];",
          "1248:   if (!(mask & acls[0]))",
          "1249:    continue;",
          "1252:   if (op == 0xFF)   {",
          "1253:    ;",
          "1254:   }",
          "",
          "[Removed Lines]",
          "1251:   sc_log(ctx, \"ACLs mask 0x%X, offs %i, op 0x%X, acls[offs] 0x%X\", mask, offs, op, acls[offs]);",
          "",
          "[Added Lines]",
          "1249:   if (offs >= taglen) {",
          "1250:    sc_log(ctx, \"Warning: Invalid offset reached during ACL parsing\");",
          "1251:    break;",
          "1252:   }",
          "1256:   sc_log(ctx, \"ACLs mask 0x%X, offs %\"SC_FORMAT_LEN_SIZE_T\"u, op 0x%X, acls[offs] 0x%X\", mask, offs, op, acls[offs]);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-0695",
  "cve_desc": "Denial of Service in GitHub repository radareorg/radare2 prior to 5.6.4.",
  "repo": "radareorg/radare2",
  "patch_hash": "634b886e84a5c568d243e744becc6b3223e089cf",
  "patch_info": {
    "commit_hash": "634b886e84a5c568d243e744becc6b3223e089cf",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/634b886e84a5c568d243e744becc6b3223e089cf",
    "files": [
      "libr/bin/format/pe/pe.c",
      "libr/bin/p/bin_dyldcache.c",
      "libr/bin/p/bin_psxexe.c",
      "libr/bin/p/bin_qnx.c",
      "libr/util/buf.c"
    ],
    "message": "Fix DoS in PE/QNX/DYLDCACHE/PSX parsers ##crash\n\n* Reported by lazymio\n* Reproducer: AAA4AAAAAB4=",
    "before_after_code_files": [
      "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c",
      "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c",
      "libr/bin/p/bin_psxexe.c||libr/bin/p/bin_psxexe.c",
      "libr/bin/p/bin_qnx.c||libr/bin/p/bin_qnx.c",
      "libr/util/buf.c||libr/util/buf.c"
    ]
  },
  "patch_diff": {
    "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c": [
      "File: libr/bin/format/pe/pe.c -> libr/bin/format/pe/pe.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "278: }",
      "280: struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {",
      "282:  bool sw = false;",
      "284:  size_t n = 0;",
      "285:  if (!pe || !pe->b) {",
      "286:   return 0LL;",
      "287:  }",
      "290:  if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {",
      "291:   pe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);",
      "292:   free (entry);",
      "",
      "[Removed Lines]",
      "281:  struct r_bin_pe_addr_t* entry;",
      "283:  ut8 b[1024];",
      "288:  entry = PE_(r_bin_pe_get_entrypoint) (pe);",
      "289:  ZERO_FILL (b);",
      "",
      "[Added Lines]",
      "282:  ut8 b[1024] = {0};",
      "287:  struct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "339:  if (!pe || !pe->b) {",
      "340:   return 0LL;",
      "341:  }",
      "343:  ZERO_FILL (b);",
      "344:  entry = PE_ (r_bin_pe_get_entrypoint) (pe);",
      "347:   pe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);",
      "348:   free (entry);",
      "349:   return NULL;",
      "",
      "[Removed Lines]",
      "342:  ut8 b[512];",
      "346:  if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {",
      "",
      "[Added Lines]",
      "340:  ut8 b[512] = {0};",
      "344:  if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) != sizeof (b)) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "537:     if (len < 1) {",
      "538:      pe_printf (\"Warning: read (import name)\\n\");",
      "539:      goto error;",
      "541:      break;",
      "542:     }",
      "543:     name[PE_NAME_LENGTH] = '\\0';",
      "",
      "[Removed Lines]",
      "540:     } else if (!*name) {",
      "",
      "[Added Lines]",
      "538:     }",
      "539:     if (!*name) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1820:   free_Var (var);",
      "1821:   return NULL;",
      "1822:  }",
      "1824:   pe_printf (\"Warning: read (Var szKey)\\n\");",
      "1825:   free_Var (var);",
      "1826:   return NULL;",
      "",
      "[Removed Lines]",
      "1823:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {",
      "",
      "[Added Lines]",
      "1821:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {",
      "",
      "---------------"
    ],
    "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c": [
      "File: libr/bin/p/bin_dyldcache.c -> libr/bin/p/bin_dyldcache.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "587:   int n_classes = classlist_sample_size / 8;",
      "588:   ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;",
      "591:    goto next_bin;",
      "592:   }",
      "",
      "[Removed Lines]",
      "590:   if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {",
      "",
      "[Added Lines]",
      "590:   if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) != classlist_sample_size) {",
      "",
      "---------------"
    ],
    "libr/bin/p/bin_psxexe.c||libr/bin/p/bin_psxexe.c": [
      "File: libr/bin/p/bin_psxexe.c -> libr/bin/p/bin_psxexe.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:   return NULL;",
      "58:  }",
      "61:   eprintf (\"Truncated Header\\n\");",
      "62:   free (sect);",
      "63:   r_list_free (ret);",
      "",
      "[Removed Lines]",
      "60:  if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {",
      "",
      "[Added Lines]",
      "60:  if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) != sizeof (psxexe_header)) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "93:   return NULL;",
      "94:  }",
      "97:   eprintf (\"PSXEXE Header truncated\\n\");",
      "98:   r_list_free (ret);",
      "99:   free (addr);",
      "",
      "[Removed Lines]",
      "96:  if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {",
      "",
      "[Added Lines]",
      "96:  if (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) != sizeof (psxexe_header)) {",
      "",
      "---------------"
    ],
    "libr/bin/p/bin_qnx.c||libr/bin/p/bin_qnx.c": [
      "File: libr/bin/p/bin_qnx.c -> libr/bin/p/bin_qnx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "7:  if (r_buf_size (buf) < sizeof (lmf_header)) {",
      "8:   return false;",
      "9:  }",
      "11:   return false;",
      "12:  }",
      "13:  r_strf_buffer (32);",
      "",
      "[Removed Lines]",
      "10:  if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {",
      "",
      "[Added Lines]",
      "10:  if (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) != QNX_HDR_SIZE) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "64:   goto beach;",
      "65:  }",
      "68:   goto beach;",
      "69:  }",
      "",
      "[Removed Lines]",
      "67:  if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {",
      "",
      "[Added Lines]",
      "67:  if (r_buf_fread_at (bf->buf, 0, (ut8 *)&lrec, \"ccss\", 1) != QNX_RECORD_SIZE) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "72:  offset += lrec.data_nbytes;",
      "74:  for (;;) {",
      "76:    goto beach;",
      "77:   }",
      "78:   offset += sizeof (lmf_record);",
      "",
      "[Removed Lines]",
      "75:   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) < QNX_RECORD_SIZE) {",
      "",
      "[Added Lines]",
      "75:   if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lrec, \"ccss\", 1) != QNX_RECORD_SIZE) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "84:    if (!ptr) {",
      "85:     goto beach;",
      "86:    }",
      "88:     goto beach;",
      "89:    }",
      "90:    ptr->name = strdup (\"LMF_RESOURCE\");",
      "",
      "[Removed Lines]",
      "87:    if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) < sizeof (lmf_resource)) {",
      "",
      "[Added Lines]",
      "87:    if (r_buf_fread_at (bf->buf, offset, (ut8 *)&lres, \"ssss\", 1) != sizeof (lmf_resource)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "95:     r_list_append (sections, ptr);",
      "96:   } else if (lrec.rec_type == LMF_LOAD_REC) {",
      "97:    RBinSection *ptr = R_NEW0 (RBinSection);",
      "99:     goto beach;",
      "100:    }",
      "101:    if (!ptr) {",
      "",
      "[Removed Lines]",
      "98:    if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {",
      "",
      "[Added Lines]",
      "98:    if (r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "110:     r_list_append (sections, ptr);",
      "111:   } else if (lrec.rec_type == LMF_FIXUP_REC) {",
      "112:    RBinReloc *ptr = R_NEW0 (RBinReloc);",
      "114:     goto beach;",
      "115:    }",
      "116:    ptr->vaddr = ptr->paddr = ldata.offset;",
      "",
      "[Removed Lines]",
      "113:    if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {",
      "",
      "[Added Lines]",
      "113:    if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "118:    r_list_append (fixups, ptr);",
      "119:   } else if (lrec.rec_type == LMF_8087_FIXUP_REC) {",
      "120:    RBinReloc *ptr = R_NEW0 (RBinReloc);",
      "122:     goto beach;",
      "123:    }",
      "124:    ptr->vaddr = ptr->paddr = ldata.offset;",
      "",
      "[Removed Lines]",
      "121:    if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) < sizeof (lmf_data)) {",
      "",
      "[Added Lines]",
      "121:    if (!ptr || r_buf_fread_at (bf->buf, offset, (ut8 *)&ldata, \"si\", 1) != sizeof (lmf_data)) {",
      "",
      "---------------"
    ],
    "libr/util/buf.c||libr/util/buf.c": [
      "File: libr/util/buf.c -> libr/util/buf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "516:     ut32 d3;",
      "517:     ut64 d4;",
      "518:     st64 r = r_buf_read (src, tmp, tsize);",
      "520:      return -1;",
      "521:     }",
      "523:     switch (tsize) {",
      "524:     case 1:",
      "525:      d1 = r_read_ble8 (tmp);",
      "",
      "[Removed Lines]",
      "519:     if (r < tsize) {",
      "",
      "[Added Lines]",
      "519:     if (r != tsize) {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "566:   return r;",
      "567:  }",
      "568:  r = r_buf_fread (b, buf, fmt, n);",
      "570:  return r;",
      "571: }",
      "",
      "[Removed Lines]",
      "569:  r_buf_seek (b, o_addr, R_BUF_SET);",
      "",
      "[Added Lines]",
      "568:  (void)r_buf_seek (b, o_addr, R_BUF_SET);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "09e20cd53d00a1497bf50349fe6eb812b4f54ac5",
      "candidate_info": {
        "commit_hash": "09e20cd53d00a1497bf50349fe6eb812b4f54ac5",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/09e20cd53d00a1497bf50349fe6eb812b4f54ac5",
        "files": [
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_specs.h",
          "libr/bin/format/objc/mach0_classes.c",
          "libr/bin/format/objc/mach0_classes.h",
          "libr/bin/p/bin_dyldcache.c",
          "libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_mach064.c",
          "libr/util/buf.c"
        ],
        "message": "Add Support For dyld4 Atlas-style Shared Library Caches ##bin\n\n* Fix signed overflow in r_buf_fread_at ##util\n* Tweak \"malformed export trie\" debug logs",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_specs.h||libr/bin/format/mach0/mach0_specs.h",
          "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c",
          "libr/bin/format/objc/mach0_classes.h||libr/bin/format/objc/mach0_classes.h",
          "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c",
          "libr/bin/p/bin_mach064.c||libr/bin/p/bin_mach064.c",
          "libr/util/buf.c||libr/util/buf.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c",
            "libr/util/buf.c||libr/util/buf.c"
          ],
          "candidate": [
            "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c",
            "libr/util/buf.c||libr/util/buf.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "461:  }",
          "462:  st.cmd = r_read_ble32 (symt, be);",
          "463:  st.cmdsize = r_read_ble32 (symt + 4, be);",
          "465:  st.nsyms = r_read_ble32 (symt + 12, be);",
          "467:  st.strsize = r_read_ble32 (symt + 20, be);",
          "469:  mo->symtab = NULL;",
          "",
          "[Removed Lines]",
          "464:  st.symoff = r_read_ble32 (symt + 8, be);",
          "466:  st.stroff = r_read_ble32 (symt + 16, be);",
          "",
          "[Added Lines]",
          "464:  st.symoff = r_read_ble32 (symt + 8, be) + mo->symbols_off;",
          "466:  st.stroff = r_read_ble32 (symt + 16, be) + mo->symbols_off;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1947:      bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);",
          "1948:      bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);",
          "1949:      bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);",
          "1951:      bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);",
          "1952:     }",
          "1953:    }",
          "",
          "[Removed Lines]",
          "1950:      bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);",
          "",
          "[Added Lines]",
          "1950:      bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian) + bin->symbols_off;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2128: void MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf) {",
          "2129:  r_return_if_fail (options && bf && bf->rbin);",
          "2130:  options->header_at = 0;",
          "2131:  options->verbose = bf->rbin->verbose;",
          "2132: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2131:  options->symbols_off = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2153:  if (options) {",
          "2154:   bin->verbose = options->verbose;",
          "2155:   bin->header_at = options->header_at;",
          "2156:  }",
          "2157:  bin->file = file;",
          "2158:  size_t binsz;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2157:   bin->symbols_off = options->symbols_off;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2188:   if (options) {",
          "2189:    bin->verbose = options->verbose;",
          "2190:    bin->header_at = options->header_at;",
          "2191:   }",
          "2192:   if (!init (bin)) {",
          "2193:    return MACH0_(mach0_free)(bin);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2193:    bin->symbols_off = options->symbols_off;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2553:      }",
          "2554:      name = r_str_append (name, s->label);",
          "2555:     }",
          "2558:      goto beach;",
          "2559:     }",
          "2560:     if (hasResolver) {",
          "",
          "[Removed Lines]",
          "2556:     if (name == NULL) {",
          "2557:      eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2559:     if (!name) {",
          "2560:      bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2594:   next->label = (char *) p;",
          "2595:   p += strlen (next->label) + 1;",
          "2596:   if (p >= end) {",
          "2598:    R_FREE (next);",
          "2599:    goto beach;",
          "2600:   }",
          "",
          "[Removed Lines]",
          "2597:    eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2600:    bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2605:   }",
          "2606:   next->node = tr + trie;",
          "2607:   if (next->node >= end) {",
          "2609:    R_FREE (next);",
          "2610:    goto beach;",
          "2611:   }",
          "",
          "[Removed Lines]",
          "2608:    eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2611:    bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2615:    RTrieState *s;",
          "2616:    r_list_foreach (states, it, s) {",
          "2617:     if (s->node == next->node) {",
          "2619:      R_FREE (next);",
          "2620:      goto beach;",
          "2621:     }",
          "",
          "[Removed Lines]",
          "2618:      eprintf (\"malformed export trie\\n\");",
          "",
          "[Added Lines]",
          "2621:      bprintf (\"malformed export trie %d\\n\", __LINE__);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
          "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "109: struct MACH0_(opts_t) {",
          "110:  bool verbose;",
          "111:  ut64 header_at;",
          "112: };",
          "114: struct MACH0_(obj_t) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "112:  ut64 symbols_off;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "170:  int func_size;",
          "171:  bool verbose;",
          "172:  ut64 header_at;",
          "173:  void *user;",
          "174:  ut64 (*va2pa)(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf);",
          "175:  struct symbol_t *symbols;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "174:  ut64 symbols_off;",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0_specs.h||libr/bin/format/mach0/mach0_specs.h": [
          "File: libr/bin/format/mach0/mach0_specs.h -> libr/bin/format/mach0/mach0_specs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "321:  uint32_t nlistCount;",
          "322: } cache_locsym_entry_t;",
          "324: typedef struct {",
          "325:  uint64_t address;",
          "326:  uint64_t size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "324: typedef struct {",
          "325:  uint64_t dylibOffset;",
          "326:  uint32_t nlistStartIndex;",
          "327:  uint32_t nlistCount;",
          "328: } cache_locsym_entry_large_t;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "332:  uint32_t initProt;",
          "333: } cache_mapping_slide;",
          "335: #define DYLD_CACHE_SLIDE_PAGE_ATTRS 0xC000",
          "336: #define DYLD_CACHE_SLIDE_PAGE_ATTR_EXTRA 0x8000",
          "337: #define DYLD_CACHE_SLIDE_PAGE_ATTR_NO_REBASE 0x4000",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341: typedef struct {",
          "342:  uint64_t sel_string_base;",
          "343: } objc_cache_opt_info;",
          "",
          "---------------"
        ],
        "libr/bin/format/objc/mach0_classes.c||libr/bin/format/objc/mach0_classes.c": [
          "File: libr/bin/format/objc/mach0_classes.c -> libr/bin/format/objc/mach0_classes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: static void copy_sym_name_with_namespace(char *class_name, char *read_name, RBinSymbol *sym);",
          "109: static void get_ivar_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass);",
          "110: static void get_objc_property_list(mach0_ut p, RBinFile *bf, RBinClass *klass);",
          "115: static bool read_ptr_pa(RBinFile *bf, ut64 paddr, mach0_ut *out);",
          "116: static bool read_ptr_va(RBinFile *bf, ut64 vaddr, mach0_ut *out);",
          "117: static char *read_str(RBinFile *bf, mach0_ut p, ut32 *offset, ut32 *left);",
          "",
          "[Removed Lines]",
          "111: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static);",
          "112: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass);",
          "113: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass);",
          "114: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs);",
          "",
          "[Added Lines]",
          "111: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static, objc_cache_opt_info *oi);",
          "112: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass, objc_cache_opt_info *oi);",
          "113: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass, objc_cache_opt_info *oi);",
          "114: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs, objc_cache_opt_info *oi);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "515: }",
          "519:  struct MACH0_(SMethodList) ml;",
          "520:  mach0_ut r;",
          "521:  ut32 offset, left, i;",
          "",
          "[Removed Lines]",
          "518: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static) {",
          "",
          "[Added Lines]",
          "518: static void get_method_list_t(mach0_ut p, RBinFile *bf, char *class_name, RBinClass *klass, bool is_static, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "613:    m.imp = r_read_ble (&sm[2 * sizeof (mach0_ut)], bigendian, 8 * sizeof (mach0_ut));",
          "614:   } else {",
          "615:    st64 name_offset = (st32) r_read_ble (&sm[0], bigendian, 8 * sizeof (ut32));",
          "617:    if (mlflags != METHOD_LIST_FLAG_IS_PREOPT) {",
          "618:     r = va2pa (name, &offset, &left, bf);",
          "619:     if (!r) {",
          "",
          "[Removed Lines]",
          "616:    mach0_ut name = p + name_offset;",
          "",
          "[Added Lines]",
          "616:    mach0_ut name;",
          "617:    if (oi && oi->sel_string_base) {",
          "618:     name = oi->sel_string_base + name_offset;",
          "619:    } else {",
          "620:     name = p + name_offset;",
          "621:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "715: }",
          "719:  struct MACH0_(SProtocolList) pl = { 0 };",
          "720:  struct MACH0_(SProtocol) pc;",
          "721:  char *class_name = NULL;",
          "",
          "[Removed Lines]",
          "718: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass) {",
          "",
          "[Added Lines]",
          "723: static void get_protocol_list_t(mach0_ut p, RBinFile *bf, RBinClass *klass, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "852:   }",
          "854:   if (pc.instanceMethods > 0) {",
          "856:   }",
          "857:   if (pc.classMethods > 0) {",
          "859:   }",
          "860:   R_FREE (class_name);",
          "861:   p += sizeof (ut32);",
          "",
          "[Removed Lines]",
          "855:    get_method_list_t (pc.instanceMethods, bf, class_name, klass, false);",
          "858:    get_method_list_t (pc.classMethods, bf, class_name, klass, true);",
          "",
          "[Added Lines]",
          "860:    get_method_list_t (pc.instanceMethods, bf, class_name, klass, false, oi);",
          "863:    get_method_list_t (pc.classMethods, bf, class_name, klass, true, oi);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1004: }",
          "1008:  struct MACH0_(obj_t) *bin;",
          "1009:  struct MACH0_(SClassRoT) cro = { 0 };",
          "1010:  ut32 offset, left, i;",
          "",
          "[Removed Lines]",
          "1007: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass) {",
          "",
          "[Added Lines]",
          "1012: static void get_class_ro_t(mach0_ut p, RBinFile *bf, ut32 *is_meta_class, RBinClass *klass, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1102: #endif",
          "1104:  if (cro.baseMethods > 0) {",
          "1106:  }",
          "1108:  if (cro.baseProtocols > 0) {",
          "1110:  }",
          "1112:  if (cro.ivars > 0) {",
          "",
          "[Removed Lines]",
          "1105:   get_method_list_t (cro.baseMethods, bf, klass->name, klass, (cro.flags & RO_META) ? true : false);",
          "1109:   get_protocol_list_t (cro.baseProtocols, bf, klass);",
          "",
          "[Added Lines]",
          "1110:   get_method_list_t (cro.baseMethods, bf, klass->name, klass, (cro.flags & RO_META) ? true : false, oi);",
          "1114:   get_protocol_list_t (cro.baseProtocols, bf, klass, oi);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1127:  return 0;",
          "1128: }",
          "1131:  struct MACH0_(SClass) c = { 0 };",
          "1132:  const int size = sizeof (struct MACH0_(SClass));",
          "1133:  mach0_ut r = 0;",
          "",
          "[Removed Lines]",
          "1130: void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1135: void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1191:    }",
          "1192:   }",
          "1193:  }",
          "1196: #if SWIFT_SUPPORT",
          "1197:  if (q (c.data + n_value) & 7) {",
          "",
          "[Removed Lines]",
          "1194:  get_class_ro_t (RO_DATA_PTR (c.data), bf, &is_meta_class, klass);",
          "",
          "[Added Lines]",
          "1199:  get_class_ro_t (RO_DATA_PTR (c.data), bf, &is_meta_class, klass, oi);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1201:  if (!is_meta_class && !dupe) {",
          "1202:   mach0_ut isa_n_value = get_isa_value ();",
          "1203:   ut64 tmp = klass->addr;",
          "1205:   klass->addr = tmp;",
          "1206:  }",
          "1207: }",
          "",
          "[Removed Lines]",
          "1204:   MACH0_(get_class_t) (c.isa + isa_n_value, bf, klass, true, relocs);",
          "",
          "[Added Lines]",
          "1209:   MACH0_(get_class_t) (c.isa + isa_n_value, bf, klass, true, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1242: }",
          "1243: #endif",
          "1246:  RList /*<RBinClass>*/ *ret = NULL;",
          "1247:  ut64 num_of_unnamed_class = 0;",
          "1248:  RBinClass *klass = NULL;",
          "",
          "[Removed Lines]",
          "1245: RList *MACH0_(parse_classes)(RBinFile *bf) {",
          "",
          "[Added Lines]",
          "1250: RList *MACH0_(parse_classes)(RBinFile *bf, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1267:  RSkipList *relocs = MACH0_(get_relocs) (bf->o->bin_obj);",
          "",
          "[Removed Lines]",
          "1269:  ret = MACH0_(parse_categories) (bf, relocs);",
          "",
          "[Added Lines]",
          "1274:  ret = MACH0_(parse_categories) (bf, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1336:    goto get_classes_error;",
          "1337:   }",
          "1338:   p = r_read_ble (&pp[0], bigendian, 8 * sizeof (mach0_ut));",
          "1340:   if (!klass->name) {",
          "1341:    klass->name = r_str_newf (\"UnnamedClass%\" PFMT64d, num_of_unnamed_class);",
          "1342:    if (!klass->name) {",
          "",
          "[Removed Lines]",
          "1339:   MACH0_(get_class_t) (p, bf, klass, false, relocs);",
          "",
          "[Added Lines]",
          "1344:   MACH0_(get_class_t) (p, bf, klass, false, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1357:  return NULL;",
          "1358: }",
          "1361:  r_return_val_if_fail (bf && bf->o && bf->o->bin_obj && bf->o->info, NULL);",
          "1363:  RList /*<RBinClass>*/ *ret = NULL;",
          "",
          "[Removed Lines]",
          "1360: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1365: static RList *MACH0_(parse_categories)(RBinFile *bf, RSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1419:    R_FREE (klass);",
          "1420:    goto error;",
          "1421:   }",
          "1423:   if (!klass->name) {",
          "1424:    R_FREE (klass);",
          "1425:    continue;",
          "",
          "[Removed Lines]",
          "1422:   MACH0_(get_category_t) (p, bf, klass, relocs);",
          "",
          "[Added Lines]",
          "1427:   MACH0_(get_category_t) (p, bf, klass, relocs, oi);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1433:  return NULL;",
          "1434: }",
          "1437:  r_return_if_fail (bf && bf->o && bf->o->info);",
          "1439:  struct MACH0_(SCategory) c = { 0 };",
          "",
          "[Removed Lines]",
          "1436: void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs) {",
          "",
          "[Added Lines]",
          "1441: void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs, objc_cache_opt_info *oi) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1542:  R_FREE (category_name);",
          "1544:  if (c.instanceMethods > 0) {",
          "1546:  }",
          "1548:  if (c.classMethods > 0) {",
          "1550:  }",
          "1552:  if (c.protocols > 0) {",
          "1554:  }",
          "1556:  if (c.properties > 0) {",
          "",
          "[Removed Lines]",
          "1545:   get_method_list_t (c.instanceMethods, bf, klass->name, klass, false);",
          "1549:   get_method_list_t (c.classMethods, bf, klass->name, klass, true);",
          "1553:   get_protocol_list_t (c.protocols, bf, klass);",
          "",
          "[Added Lines]",
          "1550:   get_method_list_t (c.instanceMethods, bf, klass->name, klass, false, oi);",
          "1554:   get_method_list_t (c.classMethods, bf, klass->name, klass, true, oi);",
          "1558:   get_protocol_list_t (c.protocols, bf, klass, oi);",
          "",
          "---------------"
        ],
        "libr/bin/format/objc/mach0_classes.h||libr/bin/format/objc/mach0_classes.h": [
          "File: libr/bin/format/objc/mach0_classes.h -> libr/bin/format/objc/mach0_classes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: #ifndef MACH0_CLASSES_H",
          "18: #define MACH0_CLASSES_H",
          "24: #endif // MACH0_CLASSES_H",
          "",
          "[Removed Lines]",
          "20: R_API RList *MACH0_(parse_classes)(RBinFile *bf);",
          "21: R_API void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs);",
          "22: R_API void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs);",
          "",
          "[Added Lines]",
          "20: R_API RList *MACH0_(parse_classes)(RBinFile *bf, objc_cache_opt_info *oi);",
          "21: R_API void MACH0_(get_class_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, bool dupe, RSkipList *relocs, objc_cache_opt_info *oi);",
          "22: R_API void MACH0_(get_category_t)(mach0_ut p, RBinFile *bf, RBinClass *klass, RSkipList *relocs, objc_cache_opt_info *oi);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_dyldcache.c||libr/bin/p/bin_dyldcache.c": [
          "File: libr/bin/p/bin_dyldcache.c -> libr/bin/p/bin_dyldcache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include \"objc/mach0_classes.h\"",
          "15: #define R_IS_PTR_AUTHENTICATED(x) B_IS_SET(x, 63)",
          "17: typedef struct {",
          "18:  ut8 version;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #define MAX_N_HDR 16",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "75: } RDyldRebaseInfo1;",
          "77: typedef struct {",
          "81:  ut64 nlists_count;",
          "84: } RDyldLocSym;",
          "86: typedef struct _r_dyldcache {",
          "87:  ut8 magic[8];",
          "88:  RList *bins;",
          "89:  RBuffer *buf;",
          "90:  int (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);",
          "91:  RDyldRebaseInfos *rebase_infos;",
          "94:  cache_accel_t *accel;",
          "95:  RDyldLocSym *locsym;",
          "96: } RDyldCache;",
          "98: typedef struct _r_bin_image {",
          "99:  char *file;",
          "100:  ut64 header_at;",
          "101: } RDyldBinImage;",
          "103: static RList * pending_bin_files = NULL;",
          "107: static void free_bin(RDyldBinImage *bin) {",
          "108:  if (!bin) {",
          "",
          "[Removed Lines]",
          "78:  char *strings;",
          "79:  ut64 strings_size;",
          "80:  struct MACH0_(nlist) *nlists;",
          "82:  cache_locsym_entry_t *entries;",
          "83:  ut64 entries_count;",
          "92:  cache_hdr_t *hdr;",
          "93:  cache_map_t *maps;",
          "105: static ut64 va2pa(uint64_t addr, cache_hdr_t *hdr, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left);",
          "",
          "[Added Lines]",
          "79:  ut64 local_symbols_offset;",
          "80:  ut64 nlists_offset;",
          "82:  ut64 strings_offset;",
          "83:  ut64 strings_size;",
          "89:  cache_hdr_t *hdr;",
          "90:  ut64 *hdr_offset;",
          "91:  ut64 symbols_off_base;",
          "92:  ut32 *maps_index;",
          "93:  ut32 n_hdr;",
          "94:  cache_map_t *maps;",
          "95:  ut32 n_maps;",
          "103:  objc_cache_opt_info *oi;",
          "104:  bool objc_opt_info_loaded;",
          "110:  ut64 hdr_offset;",
          "111:  ut64 symbols_off;",
          "112:  ut64 va;",
          "113:  ut32 nlist_start_index;",
          "114:  ut32 nlist_count;",
          "119: static ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "162:  }",
          "163: }",
          "167:   return NULL;",
          "168:  }",
          "182:  }",
          "192:  }",
          "201:  }",
          "207:  }",
          "211:  }",
          "216:  }",
          "242:  }",
          "247: }",
          "249: static ut64 rebase_infos_get_slide(RDyldCache *cache) {",
          "",
          "[Removed Lines]",
          "165: static RDyldLocSym *r_dyld_locsym_new(RBuffer *cache_buf, cache_hdr_t *hdr) {",
          "166:  if (!cache_buf || !hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {",
          "170:  cache_locsym_info_t *info = NULL;",
          "171:  char *strings = NULL;",
          "172:  cache_locsym_entry_t *entries = NULL;",
          "173:  struct MACH0_(nlist) *nlists = NULL;",
          "175:  ut64 info_size = sizeof (cache_locsym_info_t);",
          "176:  info = R_NEW0 (cache_locsym_info_t);",
          "177:  if (!info) {",
          "178:   goto beach;",
          "179:  }",
          "180:  if (r_buf_fread_at (cache_buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {",
          "181:   goto beach;",
          "184:  ut64 nlists_size = sizeof (struct MACH0_(nlist)) * info->nlistCount;",
          "185:  nlists = R_NEWS0 (struct MACH0_(nlist), info->nlistCount);",
          "186:  if (!nlists) {",
          "187:   goto beach;",
          "188:  }",
          "189:  if (r_buf_fread_at (cache_buf, hdr->localSymbolsOffset + info->nlistOffset, (ut8*) nlists, \"iccsl\",",
          "190:    info->nlistCount) != nlists_size) {",
          "191:   goto beach;",
          "194:  strings = malloc (info->stringsSize);",
          "195:  if (!strings) {",
          "196:   goto beach;",
          "197:  }",
          "198:  if (r_buf_read_at (cache_buf, hdr->localSymbolsOffset + info->stringsOffset, (ut8*) strings,",
          "199:    info->stringsSize) != info->stringsSize) {",
          "200:   goto beach;",
          "203:  ut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;",
          "204:  entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);",
          "205:  if (!entries) {",
          "206:   goto beach;",
          "208:  if (r_buf_fread_at (cache_buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) entries, \"3i\",",
          "209:    info->entriesCount) != entries_size) {",
          "210:   goto beach;",
          "213:  RDyldLocSym * locsym = R_NEW0 (RDyldLocSym);",
          "214:  if (!locsym) {",
          "215:   goto beach;",
          "218:  locsym->nlists = nlists;",
          "219:  locsym->nlists_count = info->nlistCount;",
          "220:  locsym->strings = strings;",
          "221:  locsym->strings_size = info->stringsSize;",
          "222:  locsym->entries = entries;",
          "223:  locsym->entries_count = info->entriesCount;",
          "225:  free (info);",
          "227:  return locsym;",
          "229: beach:",
          "230:  free (info);",
          "231:  free (strings);",
          "232:  free (entries);",
          "233:  free (nlists);",
          "235:  eprintf (\"dyldcache: malformed local symbols metadata\\n\");",
          "236:  return NULL;",
          "237: }",
          "239: static void r_dyld_locsym_free(RDyldLocSym *locsym) {",
          "240:  if (!locsym) {",
          "241:   return;",
          "243:  R_FREE (locsym->strings);",
          "244:  R_FREE (locsym->entries);",
          "245:  R_FREE (locsym->nlists);",
          "246:  free (locsym);",
          "",
          "[Added Lines]",
          "179: static cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr, ut64 hdr_offset) {",
          "180:  if (!cache_buf || !hdr) {",
          "183:  if (!hdr->imagesCount || !hdr->imagesOffset || hdr->imagesOffset == UT32_MAX || hdr->imagesCount == UT32_MAX) {",
          "184:   return NULL;",
          "187:  ut64 size = sizeof (cache_img_t) * hdr->imagesCount;",
          "188:  cache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);",
          "189:  if (!images) {",
          "190:   return NULL;",
          "193:  if (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {",
          "194:   R_FREE (images);",
          "195:   return NULL;",
          "198:  if (hdr_offset) {",
          "199:   ut32 i;",
          "200:   for (i = 0; i < hdr->imagesCount; i++) {",
          "201:    cache_img_t *img = &images[i];",
          "202:    img->pathFileOffset += hdr_offset;",
          "203:   }",
          "206:  return images;",
          "207: }",
          "209: static void match_bin_entries(RDyldCache *cache, void *entries) {",
          "210:  r_return_if_fail (cache && cache->bins && entries);",
          "212:  cache_img_t *imgs = read_cache_images (cache->buf, cache->hdr, 0);",
          "213:  if (!imgs) {",
          "214:   return;",
          "217:  RDyldBinImage *bin = NULL;",
          "218:  RListIter *it = r_list_iterator (cache->bins);",
          "220:  bool has_large_entries = cache->n_hdr > 1;",
          "222:  ut32 i;",
          "223:  for (i = 0; i < cache->hdr->imagesCount; i++) {",
          "224:   cache_img_t *img = &imgs[i];",
          "225:   if (!it) {",
          "226:    break;",
          "227:   }",
          "228:   bin = it->data;",
          "229:   if (!bin) {",
          "230:    break;",
          "231:   }",
          "232:   if (bin && bin->va == img->address) {",
          "233:    if (has_large_entries) {",
          "234:     cache_locsym_entry_large_t *e = &((cache_locsym_entry_large_t *) entries)[i];",
          "235:     bin->nlist_start_index = e->nlistStartIndex;",
          "236:     bin->nlist_count = e->nlistCount;",
          "237:    } else {",
          "238:     cache_locsym_entry_t *e = &((cache_locsym_entry_t *) entries)[i];",
          "239:     bin->nlist_start_index = e->nlistStartIndex;",
          "240:     bin->nlist_count = e->nlistCount;",
          "241:    }",
          "242:    it = it->n;",
          "243:   }",
          "246:  R_FREE (imgs);",
          "247: }",
          "249: static RDyldLocSym *r_dyld_locsym_new(RDyldCache *cache) {",
          "250:  r_return_val_if_fail (cache && cache->buf, NULL);",
          "252:  ut32 i;",
          "253:  for (i = 0; i < cache->n_hdr; i++) {",
          "254:   cache_hdr_t *hdr = &cache->hdr[i];",
          "255:   if (!hdr || !hdr->localSymbolsSize || !hdr->localSymbolsOffset) {",
          "256:    continue;",
          "257:   }",
          "259:   cache_locsym_info_t *info = NULL;",
          "260:   void *entries = NULL;",
          "262:   ut64 info_size = sizeof (cache_locsym_info_t);",
          "263:   info = R_NEW0 (cache_locsym_info_t);",
          "264:   if (!info) {",
          "265:    goto beach;",
          "266:   }",
          "267:   if (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset, (ut8*) info, \"6i\", 1) != info_size) {",
          "268:    eprintf (\"locsym err 01\\n\");",
          "269:    goto beach;",
          "270:   }",
          "271:   if (info->entriesCount != cache->hdr->imagesCount) {",
          "272:    eprintf (\"locsym err 02\\n\");",
          "273:    goto beach;",
          "274:   }",
          "276:   bool has_large_entries = cache->n_hdr > 1;",
          "277:   if (has_large_entries) {",
          "278:    ut64 entries_size = sizeof (cache_locsym_entry_large_t) * info->entriesCount;",
          "279:    cache_locsym_entry_large_t *large_entries = R_NEWS0 (cache_locsym_entry_large_t, info->entriesCount);",
          "280:    if (!large_entries) {",
          "281:     goto beach;",
          "282:    }",
          "283:    if (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) large_entries, \"lii\",",
          "284:      info->entriesCount) != entries_size) {",
          "285:     eprintf (\"locsym err 03\\n\");",
          "286:     goto beach;",
          "287:    }",
          "288:    entries = large_entries;",
          "289:   } else {",
          "290:    ut64 entries_size = sizeof (cache_locsym_entry_t) * info->entriesCount;",
          "291:    cache_locsym_entry_t *regular_entries = R_NEWS0 (cache_locsym_entry_t, info->entriesCount);",
          "292:    if (!regular_entries) {",
          "293:     goto beach;",
          "294:    }",
          "295:    if (r_buf_fread_at (cache->buf, hdr->localSymbolsOffset + info->entriesOffset, (ut8*) regular_entries, \"iii\",",
          "296:      info->entriesCount) != entries_size) {",
          "297:     eprintf (\"locsym err 04\\n\");",
          "298:     goto beach;",
          "299:    }",
          "300:    entries = regular_entries;",
          "301:   }",
          "302:   RDyldLocSym * locsym = R_NEW0 (RDyldLocSym);",
          "303:   if (!locsym) {",
          "304:    goto beach;",
          "305:   }",
          "307:   match_bin_entries (cache, entries);",
          "309:   locsym->local_symbols_offset = hdr->localSymbolsOffset;",
          "310:   locsym->nlists_offset = info->nlistOffset;",
          "311:   locsym->nlists_count = info->nlistCount;",
          "312:   locsym->strings_offset = info->stringsOffset;",
          "313:   locsym->strings_size = info->stringsSize;",
          "315:   free (info);",
          "316:   free (entries);",
          "318:   return locsym;",
          "320: beach:",
          "321:   free (info);",
          "322:   free (entries);",
          "324:   eprintf (\"dyldcache: malformed local symbols metadata\\n\");",
          "325:   break;",
          "327:  return NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "261:  return 0;",
          "262: }",
          "265:  RDyldLocSym *locsym = cache->locsym;",
          "267:   return;",
          "268:  }",
          "274:    continue;",
          "275:   }",
          "280:    break;",
          "281:   }",
          "318:   }",
          "320:  }",
          "321: }",
          "323: static void r_dyldcache_free(RDyldCache *cache) {",
          "",
          "[Removed Lines]",
          "264: static void r_dyld_locsym_entries_by_offset(RDyldCache *cache, RList *symbols, SetU *hash, ut64 bin_header_offset) {",
          "266:  if (!locsym || !locsym->entries) {",
          "270:  ut64 i;",
          "271:  for (i = 0; i != locsym->entries_count; i++) {",
          "272:   cache_locsym_entry_t *entry = &locsym->entries[i];",
          "273:   if (entry->dylibOffset != bin_header_offset) {",
          "277:   if (entry->nlistStartIndex >= locsym->nlists_count ||",
          "278:     entry->nlistStartIndex + entry->nlistCount > locsym->nlists_count) {",
          "279:    eprintf (\"dyldcache: malformed local symbol entry\\n\");",
          "283:   ut32 j;",
          "284:   for (j = 0; j != entry->nlistCount; j++) {",
          "285:    struct MACH0_(nlist) *nlist = &locsym->nlists[j + entry->nlistStartIndex];",
          "286:    if (set_u_contains (hash, (ut64)nlist->n_value)) {",
          "287:     continue;",
          "288:    }",
          "289:    set_u_add (hash, (ut64)nlist->n_value);",
          "290:    if (nlist->n_strx >= locsym->strings_size) {",
          "291:     continue;",
          "292:    }",
          "293:    char *symstr = &locsym->strings[nlist->n_strx];",
          "294:    RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "295:    if (!sym) {",
          "296:     return;",
          "297:    }",
          "298:    sym->type = \"LOCAL\";",
          "299:    sym->vaddr = nlist->n_value;",
          "300:    ut64 slide = rebase_infos_get_slide (cache);",
          "301:    sym->paddr = va2pa (nlist->n_value, cache->hdr, cache->maps, cache->buf, slide, NULL, NULL);",
          "303:    int len = locsym->strings_size - nlist->n_strx;",
          "304:    ut32 k;",
          "305:    for (k = 0; k < len; k++) {",
          "306:     if (((ut8) symstr[k] & 0xff) == 0xff || !symstr[k]) {",
          "307:      len = k;",
          "308:      break;",
          "309:     }",
          "310:    }",
          "311:    if (len > 0) {",
          "312:     sym->name = r_str_ndup (symstr, len);",
          "313:    } else {",
          "314:     sym->name = r_str_newf (\"unk_local%d\", k);",
          "315:    }",
          "317:    r_list_append (symbols, sym);",
          "319:   break;",
          "",
          "[Added Lines]",
          "345: static void symbols_from_locsym(RDyldCache *cache, RDyldBinImage *bin, RList *symbols, SetU *hash) {",
          "347:  if (!locsym) {",
          "348:   return;",
          "349:  }",
          "351:  if (bin->nlist_start_index >= locsym->nlists_count ||",
          "352:    bin->nlist_start_index + bin->nlist_count > locsym->nlists_count) {",
          "353:   eprintf (\"dyldcache: malformed local symbol entry\\n\");",
          "357:  ut64 nlists_size = sizeof (struct MACH0_(nlist)) * bin->nlist_count;",
          "358:  struct MACH0_(nlist) *nlists = R_NEWS0 (struct MACH0_(nlist), bin->nlist_count);",
          "359:  if (!nlists) {",
          "360:   return;",
          "361:  }",
          "362:  ut64 nlists_offset = locsym->local_symbols_offset + locsym->nlists_offset +",
          "363:   bin->nlist_start_index * sizeof (struct MACH0_(nlist));",
          "364:  if (r_buf_fread_at (cache->buf, nlists_offset, (ut8*) nlists, \"iccsl\", bin->nlist_count) != nlists_size) {",
          "365:   free (nlists);",
          "366:   return;",
          "367:  }",
          "369:  ut32 j;",
          "370:  for (j = 0; j != bin->nlist_count; j++) {",
          "371:   struct MACH0_(nlist) *nlist = &nlists[j];",
          "372:   if (set_u_contains (hash, (ut64)nlist->n_value)) {",
          "375:   set_u_add (hash, (ut64)nlist->n_value);",
          "376:   if (nlist->n_strx >= locsym->strings_size) {",
          "377:    continue;",
          "378:   }",
          "379:   RBinSymbol *sym = R_NEW0 (RBinSymbol);",
          "380:   if (!sym) {",
          "383:   sym->type = \"LOCAL\";",
          "384:   sym->vaddr = nlist->n_value;",
          "385:   ut64 slide = rebase_infos_get_slide (cache);",
          "386:   sym->paddr = va2pa (nlist->n_value, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "388:   char *symstr =r_buf_get_string (cache->buf, locsym->local_symbols_offset + locsym->strings_offset + nlist->n_strx);",
          "389:   if (symstr) {",
          "390:    sym->name = symstr;",
          "391:   } else {",
          "392:    static ut32 k = 0;",
          "393:    sym->name = r_str_newf (\"unk_local%d\", k++);",
          "396:   r_list_append (symbols, sym);",
          "399:  free (nlists);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "340:  }",
          "341:  R_FREE (cache->hdr);",
          "342:  R_FREE (cache->maps);",
          "343:  R_FREE (cache->accel);",
          "345:  R_FREE (cache);",
          "346: }",
          "349:  ut64 res = UT64_MAX;",
          "352:  addr -= slide;",
          "355:   if (addr >= maps[i].address && addr < maps[i].address + maps[i].size) {",
          "356:    res = maps[i].fileOffset + addr - maps[i].address;",
          "357:    if (offset) {",
          "",
          "[Removed Lines]",
          "344:  r_dyld_locsym_free (cache->locsym);",
          "348: static ut64 va2pa(uint64_t addr, cache_hdr_t *hdr, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {",
          "350:  uint32_t i;",
          "354:  for (i = 0; i < hdr->mappingCount; i++) {",
          "",
          "[Added Lines]",
          "422:  R_FREE (cache->maps_index);",
          "423:  R_FREE (cache->hdr_offset);",
          "425:  R_FREE (cache->locsym);",
          "426:  R_FREE (cache->oi);",
          "430: static ut64 va2pa(uint64_t addr, ut32 n_maps, cache_map_t *maps, RBuffer *cache_buf, ut64 slide, ut32 *offset, ut32 *left) {",
          "432:  ut32 i;",
          "436:  for (i = 0; i < n_maps; i++) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "378:  }",
          "380:  ut64 slide = rebase_infos_get_slide (cache);",
          "382:  if (res == UT64_MAX) {",
          "383:   res = 0;",
          "384:  }",
          "",
          "[Removed Lines]",
          "381:  ut64 res = va2pa (p, cache->hdr, cache->maps, cache->buf, slide, offset, left);",
          "",
          "[Added Lines]",
          "463:  ut64 res = va2pa (p, cache->n_maps, cache->maps, cache->buf, slide, offset, left);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "395:   return NULL;",
          "396:  }",
          "398:  struct MACH0_(opts_t) opts;",
          "399:  MACH0_(opts_set_default) (&opts, bf);",
          "402:  mach0->user = cache;",
          "403:  mach0->va2pa = &bin_obj_va2pa;",
          "404:  return mach0;",
          "405: }",
          "",
          "[Removed Lines]",
          "400:  opts.header_at = bin->header_at;",
          "401:  struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);",
          "",
          "[Added Lines]",
          "480:  RBuffer *buf = r_buf_new_slice (cache->buf, bin->hdr_offset, r_buf_size (cache->buf) - bin->hdr_offset);",
          "481:  if (!buf) {",
          "482:   return NULL;",
          "483:  }",
          "487:  opts.header_at = bin->header_at - bin->hdr_offset;",
          "488:  opts.symbols_off = bin->symbols_off;",
          "490:  struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (buf, &opts);",
          "495:  r_buf_free (buf);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "442: static ut64 estimate_slide(RBinFile *bf, RDyldCache *cache, ut64 value_mask, ut64 value_add) {",
          "443:  ut64 slide = 0;",
          "444:  ut64 *classlist = malloc (64);",
          "445:  if (!classlist) {",
          "446:   goto beach;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "537:  if (cache->n_hdr > 1) {",
          "538:   return slide;",
          "539:  }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "492:   int classlist_sample_size = R_MIN (64, sections[classlist_idx].size);",
          "493:   int n_classes = classlist_sample_size / 8;",
          "496:    goto next_bin;",
          "497:   }",
          "",
          "[Removed Lines]",
          "495:   if (r_buf_fread_at (cache->buf, sections[classlist_idx].offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {",
          "",
          "[Added Lines]",
          "590:   ut64 sect_offset = sections[classlist_idx].offset + bin->hdr_offset;",
          "592:   if (r_buf_fread_at (cache->buf, sect_offset, (ut8*) classlist, \"l\", n_classes) < classlist_sample_size) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "752: }",
          "754: static RDyldRebaseInfos *get_rebase_infos(RBinFile *bf, RDyldCache *cache) {",
          "757:  RDyldRebaseInfos *result = R_NEW0 (RDyldRebaseInfos);",
          "758:  if (!result) {",
          "759:   return NULL;",
          "760:  }",
          "762:  if (!cache->hdr->slideInfoOffset || !cache->hdr->slideInfoSize) {",
          "770:   }",
          "772:    goto beach;",
          "773:   }",
          "776:   if (!infos) {",
          "777:    goto beach;",
          "778:   }",
          "788:    }",
          "797:    }",
          "798:   }",
          "801:    free (infos);",
          "802:    goto beach;",
          "803:   }",
          "807:    if (!pruned_infos) {",
          "808:     free (infos);",
          "809:     goto beach;",
          "810:    }",
          "813:    free (infos);",
          "814:    infos = pruned_infos;",
          "815:   }",
          "817:   result->entries = infos;",
          "819:   return result;",
          "820:  }",
          "",
          "[Removed Lines]",
          "755:  RBuffer *cache_buf = cache->buf;",
          "763:   ut64 slide_infos_offset;",
          "764:   size_t n_slide_infos;",
          "765:   if ((slide_infos_offset = r_buf_read_le32_at (cache_buf, 0x138)) == UT32_MAX) {",
          "766:    goto beach;",
          "767:   }",
          "768:   if ((n_slide_infos = r_buf_read_le32_at (cache_buf, 0x13c)) == UT32_MAX) {",
          "769:    goto beach;",
          "771:   if (!n_slide_infos) {",
          "775:   RDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, n_slide_infos);",
          "780:   size_t i, j;",
          "781:   RDyldRebaseInfo *prev_info = NULL;",
          "782:   for (i = 0, j = 0; i < n_slide_infos; i++) {",
          "783:    ut64 offset = slide_infos_offset + i * sizeof (cache_mapping_slide);",
          "784:    cache_mapping_slide entry;",
          "785:    if (r_buf_fread_at (cache_buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {",
          "786:     free (infos);",
          "787:     goto beach;",
          "790:    if (entry.slideInfoOffset && entry.slideInfoSize) {",
          "791:     infos[j].start = entry.fileOffset;",
          "792:     infos[j].end = entry.fileOffset + entry.size;",
          "793:     ut64 slide = prev_info ? prev_info->slide : UT64_MAX;",
          "794:     infos[j].info = get_rebase_info (bf, cache, entry.slideInfoOffset, entry.slideInfoSize, entry.fileOffset, slide);",
          "795:     prev_info = infos[j].info;",
          "796:     j++;",
          "800:   if (!j) {",
          "805:   if (j != n_slide_infos) {",
          "806:    RDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, j);",
          "812:    memcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * j);",
          "818:   result->length = j;",
          "",
          "[Added Lines]",
          "858:   ut32 total_slide_infos = 0;",
          "859:   ut32 n_slide_infos[MAX_N_HDR];",
          "861:   ut32 i;",
          "862:   for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {",
          "863:    ut64 hdr_offset = cache->hdr_offset[i];",
          "864:    if ((n_slide_infos[i] = r_buf_read_le32_at (cache->buf, 0x13c + hdr_offset)) == UT32_MAX) {",
          "865:     goto beach;",
          "866:    }",
          "867:    total_slide_infos += n_slide_infos[i];",
          "870:   if (!total_slide_infos) {",
          "874:   RDyldRebaseInfosEntry * infos = R_NEWS0 (RDyldRebaseInfosEntry, total_slide_infos);",
          "879:   ut32 k = 0;",
          "880:   for (i = 0; i < cache->n_hdr && i < MAX_N_HDR; i++) {",
          "881:    ut64 hdr_offset = cache->hdr_offset[i];",
          "882:    ut64 slide_infos_offset;",
          "883:    if (!n_slide_infos[i]) {",
          "884:     continue;",
          "886:    if ((slide_infos_offset = r_buf_read_le32_at (cache->buf, 0x138 + hdr_offset)) == UT32_MAX) {",
          "887:     continue;",
          "888:    }",
          "889:    if (!slide_infos_offset) {",
          "890:     continue;",
          "891:    }",
          "892:    slide_infos_offset += hdr_offset;",
          "894:    ut32 j;",
          "895:    RDyldRebaseInfo *prev_info = NULL;",
          "896:    for (j = 0; j < n_slide_infos[i]; j++) {",
          "897:     ut64 offset = slide_infos_offset + j * sizeof (cache_mapping_slide);",
          "898:     cache_mapping_slide entry;",
          "899:     if (r_buf_fread_at (cache->buf, offset, (ut8*)&entry, \"6lii\", 1) != sizeof (cache_mapping_slide)) {",
          "900:      break;",
          "901:     }",
          "903:     if (entry.slideInfoOffset && entry.slideInfoSize) {",
          "904:      infos[k].start = entry.fileOffset + hdr_offset;",
          "905:      infos[k].end = infos[k].start + entry.size;",
          "906:      ut64 slide = prev_info ? prev_info->slide : UT64_MAX;",
          "907:      infos[k].info = get_rebase_info (bf, cache, entry.slideInfoOffset + hdr_offset, entry.slideInfoSize, entry.fileOffset + hdr_offset, slide);",
          "908:      prev_info = infos[k].info;",
          "909:      k++;",
          "910:     }",
          "914:   if (!k) {",
          "919:   if (k < total_slide_infos) {",
          "920:    RDyldRebaseInfosEntry * pruned_infos = R_NEWS0 (RDyldRebaseInfosEntry, k);",
          "926:    memcpy (pruned_infos, infos, sizeof (RDyldRebaseInfosEntry) * k);",
          "932:   result->length = k;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "839:  return NULL;",
          "840: }",
          "842: static bool check_buffer(RBinFile *bf, RBuffer *buf) {",
          "843:  if (r_buf_size (buf) < 32) {",
          "844:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "956: static bool check_magic(const char *magic) {",
          "957:  return !strcmp (magic, \"dyld_v1   arm64\")",
          "958:   || !strcmp (magic, \"dyld_v1  arm64e\")",
          "959:   || !strcmp (magic, \"dyld_v1  x86_64\")",
          "960:   || !strcmp (magic, \"dyld_v1 x86_64h\");",
          "961: }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "850:   return false;",
          "851:  }",
          "876: }",
          "878: static cache_imgxtr_t *read_cache_imgextra(RBuffer *cache_buf, cache_hdr_t *hdr, cache_accel_t *accel) {",
          "",
          "[Removed Lines]",
          "853:  return !strcmp (hdr, \"dyld_v1   arm64\")",
          "854:   || !strcmp (hdr, \"dyld_v1  arm64e\")",
          "855:   || !strcmp (hdr, \"dyld_v1  x86_64\")",
          "856:   || !strcmp (hdr, \"dyld_v1 x86_64h\");",
          "857: }",
          "859: static cache_img_t *read_cache_images(RBuffer *cache_buf, cache_hdr_t *hdr) {",
          "860:  if (!cache_buf || !hdr || !hdr->imagesCount || !hdr->imagesOffset) {",
          "861:   return NULL;",
          "862:  }",
          "864:  ut64 size = sizeof (cache_img_t) * hdr->imagesCount;",
          "865:  cache_img_t *images = R_NEWS0 (cache_img_t, hdr->imagesCount);",
          "866:  if (!images) {",
          "867:   return NULL;",
          "868:  }",
          "870:  if (r_buf_fread_at (cache_buf, hdr->imagesOffset, (ut8*) images, \"3l2i\", hdr->imagesCount) != size) {",
          "871:   R_FREE (images);",
          "872:   return NULL;",
          "873:  }",
          "875:  return images;",
          "",
          "[Added Lines]",
          "974:  return check_magic (hdr);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "929:  return path_to_idx;",
          "930: }",
          "934:  if (pa == UT64_MAX) {",
          "935:   return;",
          "936:  }",
          "937:  struct MACH0_(mach_header) mh;",
          "939:   return;",
          "940:  }",
          "941:  if (mh.magic != MH_MAGIC_64 || mh.sizeofcmds == 0) {",
          "",
          "[Removed Lines]",
          "932: static void carve_deps_at_address(RBuffer *cache_buf, cache_img_t *img, cache_hdr_t *hdr, cache_map_t *maps, HtPU *path_to_idx, ut64 address, int *deps) {",
          "933:  ut64 pa = va2pa (address, hdr, maps, cache_buf, 0, NULL, NULL);",
          "938:  if (r_buf_fread_at (cache_buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {",
          "",
          "[Added Lines]",
          "1031: static void carve_deps_at_address(RDyldCache *cache, cache_img_t *img, HtPU *path_to_idx, ut64 address, int *deps, bool printing) {",
          "1032:  ut64 pa = va2pa (address, cache->n_maps, cache->maps, cache->buf, 0, NULL, NULL);",
          "1037:  if (r_buf_fread_at (cache->buf, pa, (ut8*) &mh, \"8i\", 1) != sizeof (struct MACH0_(mach_header))) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "943:  }",
          "944:  ut64 cmds_at = pa + sizeof (struct MACH0_(mach_header));",
          "945:  ut8 *cmds = malloc (mh.sizeofcmds + 1);",
          "947:   goto beach;",
          "948:  }",
          "949:  cmds[mh.sizeofcmds] = 0;",
          "",
          "[Removed Lines]",
          "946:  if (!cmds || r_buf_read_at (cache_buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {",
          "",
          "[Added Lines]",
          "1045:  if (!cmds || r_buf_read_at (cache->buf, cmds_at, cmds, mh.sizeofcmds) != mh.sizeofcmds) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "962:    }",
          "963:    const char *key = (const char *) cursor + 24;",
          "964:    size_t dep_index = (size_t)ht_pu_find (path_to_idx, key, &found);",
          "966:     eprintf (\"Warning: alien dep '%s'\\n\", key);",
          "967:     continue;",
          "968:    }",
          "969:    deps[dep_index]++;",
          "971:   }",
          "972:   cursor += cmdsize;",
          "973:  }",
          "",
          "[Removed Lines]",
          "965:    if (!found || dep_index >= hdr->imagesCount) {",
          "970:    eprintf (\"-> %s\\n\", key);",
          "",
          "[Added Lines]",
          "1064:    if (!found || dep_index >= cache->hdr->imagesCount) {",
          "1069:    if (printing) {",
          "1070:     eprintf (\"-> %s\\n\", key);",
          "1071:    }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "976:  free (cmds);",
          "977: }",
          "980:  RList *bins = r_list_newf ((RListFree)free_bin);",
          "981:  if (!bins) {",
          "982:   return NULL;",
          "983:  }",
          "993:  char *target_libs = NULL;",
          "995:  RList *target_lib_names = NULL;",
          "998:  if (target_libs) {",
          "999:   target_lib_names = r_str_split_list (target_libs, \":\", 0);",
          "1000:   if (!target_lib_names) {",
          "1002:   }",
          "1005:   if (!deps) {",
          "1007:   }",
          "1035:    }",
          "1037:     R_FREE (lib_name);",
          "1053:      }",
          "1056:     }",
          "1059:    }",
          "1073:   }",
          "1091:    }",
          "1104:       } else {",
          "1105:        bin->file = strdup (last_slash + 1);",
          "1106:       }",
          "1107:      } else {",
          "1109:      }",
          "1112:     }",
          "1113:    }",
          "1120:   }",
          "1121:  }",
          "1126:   r_list_free (bins);",
          "1135:  }",
          "1136:  R_FREE (deps);",
          "1138:  return bins;",
          "1139: }",
          "",
          "[Removed Lines]",
          "979: static RList *create_cache_bins(RBinFile *bf, RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps, cache_accel_t *accel) {",
          "985:  cache_img_t *img = read_cache_images (cache_buf, hdr);",
          "986:  if (!img) {",
          "987:   r_list_free (bins);",
          "988:   return NULL;",
          "989:  }",
          "991:  int i;",
          "992:  int *deps = NULL;",
          "994:  target_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");",
          "996:  ut16 *depArray = NULL;",
          "997:  cache_imgxtr_t *extras = NULL;",
          "1001:    goto error;",
          "1004:   deps = R_NEWS0 (int, hdr->imagesCount);",
          "1006:    goto error;",
          "1009:   HtPU *path_to_idx = NULL;",
          "1010:   if (accel) {",
          "1011:    depArray = R_NEWS0 (ut16, accel->depListCount);",
          "1012:    if (!depArray) {",
          "1013:     goto error;",
          "1014:    }",
          "1016:    if (r_buf_fread_at (cache_buf, accel->depListOffset, (ut8*) depArray, \"s\", accel->depListCount) != accel->depListCount * 2) {",
          "1017:     goto error;",
          "1018:    }",
          "1020:    extras = read_cache_imgextra (cache_buf, hdr, accel);",
          "1021:    if (!extras) {",
          "1022:     goto error;",
          "1023:    }",
          "1024:   } else {",
          "1025:    path_to_idx = create_path_to_index (cache_buf, img, hdr);",
          "1026:   }",
          "1028:   for (i = 0; i < hdr->imagesCount; i++) {",
          "1029:    char *lib_name = get_lib_name (cache_buf, &img[i]);",
          "1030:    if (!lib_name) {",
          "1031:     break;",
          "1032:    }",
          "1033:    if (strstr (lib_name, \"libobjc.A.dylib\")) {",
          "1034:     deps[i]++;",
          "1036:    if (!r_list_find (target_lib_names, lib_name, string_contains)) {",
          "1038:     continue;",
          "1039:    }",
          "1040:    eprintf (\"FILTER: %s\\n\", lib_name);",
          "1041:    R_FREE (lib_name);",
          "1042:    deps[i]++;",
          "1044:    if (extras && depArray) {",
          "1045:     ut32 j;",
          "1046:     for (j = extras[i].dependentsStartArrayIndex; depArray[j] != 0xffff; j++) {",
          "1047:      ut16 dep_index = depArray[j] & 0x7fff;",
          "1048:      deps[dep_index]++;",
          "1050:      char *dep_name = get_lib_name (cache_buf, &img[dep_index]);",
          "1051:      if (!dep_name) {",
          "1052:       break;",
          "1054:      eprintf (\"-> %s\\n\", dep_name);",
          "1055:      free (dep_name);",
          "1057:    } else if (path_to_idx) {",
          "1058:     carve_deps_at_address (cache_buf, img, hdr, maps, path_to_idx, img[i].address, deps);",
          "1060:   }",
          "1062:   ht_pu_free (path_to_idx);",
          "1063:   R_FREE (depArray);",
          "1064:   R_FREE (extras);",
          "1065:   R_FREE (target_libs);",
          "1066:   r_list_free (target_lib_names);",
          "1067:   target_lib_names = NULL;",
          "1068:  }",
          "1070:  for (i = 0; i < hdr->imagesCount; i++) {",
          "1071:   if (deps && !deps[i]) {",
          "1072:    continue;",
          "1074:   ut64 pa = va2pa (img[i].address, hdr, maps, cache_buf, 0, NULL, NULL);",
          "1075:   if (pa == UT64_MAX) {",
          "1076:    continue;",
          "1077:   }",
          "1078:   ut8 magicbytes[4];",
          "1079:   r_buf_read_at (cache_buf, pa, magicbytes, 4);",
          "1080:   int magic = r_read_le32 (magicbytes);",
          "1081:   switch (magic) {",
          "1082:   case MH_MAGIC:",
          "1084:    break;",
          "1085:   case MH_MAGIC_64:",
          "1086:   {",
          "1087:    char file[256];",
          "1088:    RDyldBinImage *bin = R_NEW0 (RDyldBinImage);",
          "1089:    if (!bin) {",
          "1090:     goto error;",
          "1092:    bin->header_at = pa;",
          "1093:    if (r_buf_read_at (cache_buf, img[i].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {",
          "1094:     file[255] = 0;",
          "1095:     char *last_slash = strrchr (file, '/');",
          "1096:     if (last_slash && *last_slash) {",
          "1097:      if (last_slash > file) {",
          "1098:       char *scan = last_slash - 1;",
          "1099:       while (scan > file && *scan != '/') {",
          "1100:        scan--;",
          "1101:       }",
          "1102:       if (*scan == '/') {",
          "1103:        bin->file = strdup (scan + 1);",
          "1108:       bin->file = strdup (last_slash + 1);",
          "1110:     } else {",
          "1111:      bin->file = strdup (file);",
          "1114:    r_list_append (bins, bin);",
          "1115:    break;",
          "1116:   }",
          "1117:   default:",
          "1118:    eprintf (\"Unknown sub-bin\\n\");",
          "1119:    break;",
          "1123:  goto beach;",
          "1124: error:",
          "1125:  if (bins) {",
          "1127:  }",
          "1128:  bins = NULL;",
          "1129: beach:",
          "1130:  R_FREE (depArray);",
          "1131:  R_FREE (extras);",
          "1132:  R_FREE (target_libs);",
          "1133:  if (target_lib_names) {",
          "1134:   r_list_free (target_lib_names);",
          "1137:  R_FREE (img);",
          "",
          "[Added Lines]",
          "1080: static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {",
          "1088:  int *deps = NULL;",
          "1089:  target_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");",
          "1093:    r_list_free (bins);",
          "1094:    return NULL;",
          "1096:   deps = R_NEWS0 (int, cache->hdr->imagesCount);",
          "1098:    r_list_free (bins);",
          "1099:    r_list_free (target_lib_names);",
          "1100:    return NULL;",
          "1102:  }",
          "1104:  ut32 i;",
          "1105:  for (i = 0; i < cache->n_hdr; i++) {",
          "1106:   cache_hdr_t *hdr = &cache->hdr[i];",
          "1107:   ut64 hdr_offset = cache->hdr_offset[i];",
          "1108:   ut64 symbols_off = cache->symbols_off_base - hdr_offset;",
          "1109:   ut32 maps_index = cache->maps_index[i];",
          "1110:   cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);",
          "1111:   if (!img) {",
          "1112:    goto next;",
          "1113:   }",
          "1115:   ut32 j;",
          "1116:   ut16 *depArray = NULL;",
          "1117:   cache_imgxtr_t *extras = NULL;",
          "1118:   if (target_libs) {",
          "1119:    HtPU *path_to_idx = NULL;",
          "1120:    if (cache->accel) {",
          "1121:     depArray = R_NEWS0 (ut16, cache->accel->depListCount);",
          "1122:     if (!depArray) {",
          "1123:      goto next;",
          "1124:     }",
          "1126:     if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {",
          "1127:      goto next;",
          "1128:     }",
          "1130:     extras = read_cache_imgextra (cache->buf, hdr, cache->accel);",
          "1131:     if (!extras) {",
          "1132:      goto next;",
          "1133:     }",
          "1134:    } else {",
          "1135:     path_to_idx = create_path_to_index (cache->buf, img, hdr);",
          "1138:    for (j = 0; j < hdr->imagesCount; j++) {",
          "1139:     bool printing = !deps[j];",
          "1140:     char *lib_name = get_lib_name (cache->buf, &img[j]);",
          "1141:     if (!lib_name) {",
          "1142:      break;",
          "1143:     }",
          "1144:     if (strstr (lib_name, \"libobjc.A.dylib\")) {",
          "1145:      deps[j]++;",
          "1146:     }",
          "1147:     if (!r_list_find (target_lib_names, lib_name, string_contains)) {",
          "1148:      R_FREE (lib_name);",
          "1149:      continue;",
          "1150:     }",
          "1151:     if (printing) {",
          "1152:      eprintf (\"FILTER: %s\\n\", lib_name);",
          "1153:     }",
          "1155:     deps[j]++;",
          "1157:     if (extras && depArray) {",
          "1158:      ut32 k;",
          "1159:      for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) {",
          "1160:       ut16 dep_index = depArray[k] & 0x7fff;",
          "1161:       deps[dep_index]++;",
          "1163:       char *dep_name = get_lib_name (cache->buf, &img[dep_index]);",
          "1164:       if (!dep_name) {",
          "1165:        break;",
          "1166:       }",
          "1167:       if (printing) {",
          "1168:        eprintf (\"-> %s\\n\", dep_name);",
          "1169:       }",
          "1170:       free (dep_name);",
          "1172:     } else if (path_to_idx) {",
          "1173:      carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing);",
          "1177:    ht_pu_free (path_to_idx);",
          "1178:    R_FREE (depArray);",
          "1179:    R_FREE (extras);",
          "1182:   for (j = 0; j < hdr->imagesCount; j++) {",
          "1183:    if (deps && !deps[j]) {",
          "1184:     continue;",
          "1186:    ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL);",
          "1187:    if (pa == UT64_MAX) {",
          "1188:     continue;",
          "1189:    }",
          "1190:    ut8 magicbytes[4];",
          "1191:    r_buf_read_at (cache->buf, pa, magicbytes, 4);",
          "1192:    int magic = r_read_le32 (magicbytes);",
          "1193:    switch (magic) {",
          "1194:    case MH_MAGIC_64:",
          "1195:    {",
          "1196:     char file[256];",
          "1197:     RDyldBinImage *bin = R_NEW0 (RDyldBinImage);",
          "1198:     if (!bin) {",
          "1199:      goto next;",
          "1200:     }",
          "1201:     bin->header_at = pa;",
          "1202:     bin->hdr_offset = hdr_offset;",
          "1203:     bin->symbols_off = symbols_off;",
          "1204:     bin->va = img[j].address;",
          "1205:     if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) {",
          "1206:      file[255] = 0;",
          "1207:      char *last_slash = strrchr (file, '/');",
          "1208:      if (last_slash && *last_slash) {",
          "1209:       if (last_slash > file) {",
          "1210:        char *scan = last_slash - 1;",
          "1211:        while (scan > file && *scan != '/') {",
          "1212:         scan--;",
          "1213:        }",
          "1214:        if (*scan == '/') {",
          "1215:         bin->file = strdup (scan + 1);",
          "1216:        } else {",
          "1217:         bin->file = strdup (last_slash + 1);",
          "1218:        }",
          "1223:       bin->file = strdup (file);",
          "1226:     r_list_append (bins, bin);",
          "1227:     break;",
          "1228:    }",
          "1229:    default:",
          "1230:     eprintf (\"Unknown sub-bin\\n\");",
          "1231:     break;",
          "1234: next:",
          "1235:   R_FREE (depArray);",
          "1236:   R_FREE (extras);",
          "1237:   R_FREE (img);",
          "1239:  if (r_list_empty (bins)) {",
          "1241:   bins = NULL;",
          "1244:  R_FREE (target_libs);",
          "1245:  r_list_free (target_lib_names);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1412:  plugin->read = &dyldcache_io_read;",
          "1413: }",
          "1416:  if (!cache_buf) {",
          "1417:   return NULL;",
          "1418:  }",
          "",
          "[Removed Lines]",
          "1415: static cache_hdr_t *read_cache_header(RBuffer *cache_buf) {",
          "",
          "[Added Lines]",
          "1523: static cache_hdr_t *read_cache_header(RBuffer *cache_buf, ut64 offset) {",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1423:  }",
          "1425:  ut64 size = sizeof (cache_hdr_t);",
          "1427:   R_FREE (hdr);",
          "1428:   return NULL;",
          "1429:  }",
          "1431:  return hdr;",
          "1432: }",
          "1437:  }",
          "1441:  if (!maps) {",
          "1443:  }",
          "1448:  }",
          "1451: }",
          "1453: static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {",
          "",
          "[Removed Lines]",
          "1426:  if (r_buf_fread_at (cache_buf, 0, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {",
          "1434: static cache_map_t *read_cache_maps(RBuffer *cache_buf, cache_hdr_t *hdr) {",
          "1435:  if (!cache_buf || !hdr || !hdr->mappingCount || !hdr->mappingOffset) {",
          "1436:   return NULL;",
          "1439:  ut64 size = sizeof (cache_map_t) * hdr->mappingCount;",
          "1440:  cache_map_t *maps = R_NEWS0 (cache_map_t, hdr->mappingCount);",
          "1442:   return NULL;",
          "1445:  if (r_buf_fread_at (cache_buf, hdr->mappingOffset, (ut8*) maps, \"3l2i\", hdr->mappingCount) != size) {",
          "1446:   R_FREE (maps);",
          "1447:   return NULL;",
          "1450:  return maps;",
          "",
          "[Added Lines]",
          "1534:  if (r_buf_fread_at (cache_buf, offset, (ut8*) hdr, \"16c4i7l16clii4l\", 1) != size) {",
          "1535:   R_FREE (hdr);",
          "1536:   return NULL;",
          "1537:  }",
          "1538:  if (!check_magic (hdr->magic)) {",
          "1543:  if (!hdr->imagesCount && !hdr->imagesOffset) {",
          "1544:   hdr->imagesOffset = r_buf_read_le32_at (cache_buf, 0x1c0 + offset);",
          "1545:   hdr->imagesCount = r_buf_read_le32_at (cache_buf, 0x1c4 + offset);",
          "1546:  }",
          "1551: static void populate_cache_headers(RDyldCache *cache) {",
          "1552:  cache->n_hdr = 0;",
          "1553:  RList *hdrs = r_list_newf (NULL);",
          "1554:  if (!hdrs) {",
          "1555:   return;",
          "1558:  cache_hdr_t *h;",
          "1559:  ut64 offsets[MAX_N_HDR];",
          "1560:  ut64 offset = 0;",
          "1561:  do {",
          "1562:   offsets[cache->n_hdr] = offset;",
          "1563:   h = read_cache_header (cache->buf, offset);",
          "1564:   if (!h) {",
          "1565:    break;",
          "1566:   }",
          "1567:   r_list_append (hdrs, h);",
          "1569:   ut64 size = h->codeSignatureOffset + h->codeSignatureSize;",
          "1571: #define SHIFT_MAYBE(x) \\",
          "1572:  if (x) { \\",
          "1573:   x += offset; \\",
          "1574:  }",
          "1576:   SHIFT_MAYBE (h->mappingOffset);",
          "1577:   SHIFT_MAYBE (h->imagesOffset);",
          "1578:   SHIFT_MAYBE (h->codeSignatureOffset);",
          "1579:   SHIFT_MAYBE (h->slideInfoOffset);",
          "1580:   SHIFT_MAYBE (h->localSymbolsOffset);",
          "1581:   SHIFT_MAYBE (h->branchPoolsOffset);",
          "1582:   SHIFT_MAYBE (h->imagesTextOffset);",
          "1584:   offset += size;",
          "1585:   cache->n_hdr++;",
          "1586:  } while (cache->n_hdr < MAX_N_HDR);",
          "1588:  if (!cache->n_hdr) {",
          "1589:   goto beach;",
          "1590:  }",
          "1592:  cache->hdr = R_NEWS0 (cache_hdr_t, cache->n_hdr);",
          "1593:  if (!cache->hdr) {",
          "1594:   cache->n_hdr = 0;",
          "1595:   goto beach;",
          "1596:  }",
          "1598:  cache->hdr_offset = R_NEWS0 (ut64, cache->n_hdr);",
          "1599:  if (!cache->hdr_offset) {",
          "1600:   cache->n_hdr = 0;",
          "1601:   R_FREE (cache->hdr);",
          "1602:   goto beach;",
          "1603:  }",
          "1605:  memcpy (cache->hdr_offset, offsets, cache->n_hdr * sizeof (ut64));",
          "1607:  ut32 i = 0;",
          "1608:  RListIter *iter;",
          "1609:  cache_hdr_t *item;",
          "1610:  r_list_foreach (hdrs, iter, item) {",
          "1611:   if (i >= cache->n_hdr) {",
          "1612:    break;",
          "1613:   }",
          "1614:   memcpy (&cache->hdr[i++], item, sizeof (cache_hdr_t));",
          "1615:  }",
          "1617: beach:",
          "1618:  r_list_free (hdrs);",
          "1619: }",
          "1621: static void populate_cache_maps(RDyldCache *cache) {",
          "1622:  r_return_if_fail (cache && cache->buf);",
          "1624:  ut32 i;",
          "1625:  ut32 n_maps = 0;",
          "1626:  for (i = 0; i < cache->n_hdr; i++) {",
          "1627:   cache_hdr_t *hdr = &cache->hdr[i];",
          "1628:   if (!hdr->mappingCount || !hdr->mappingOffset) {",
          "1629:    continue;",
          "1630:   }",
          "1631:   n_maps += hdr->mappingCount;",
          "1632:  }",
          "1634:  cache_map_t *maps = NULL;",
          "1635:  if (n_maps != 0) {",
          "1636:   cache->maps_index = R_NEWS0 (ut32, cache->n_hdr);",
          "1637:   if (!cache->maps_index) {",
          "1638:    return;",
          "1639:   }",
          "1640:   maps = R_NEWS0 (cache_map_t, n_maps);",
          "1641:  }",
          "1643:   cache->maps = NULL;",
          "1644:   cache->n_maps = 0;",
          "1645:   return;",
          "1648:  ut32 next_map = 0;",
          "1649:  ut32 last_idx = UT32_MAX;",
          "1650:  ut64 max_address = 0;",
          "1651:  for (i = 0; i < cache->n_hdr; i++) {",
          "1652:   cache_hdr_t *hdr = &cache->hdr[i];",
          "1653:   cache->maps_index[i] = next_map;",
          "1655:   if (!hdr->mappingCount || !hdr->mappingOffset) {",
          "1656:    continue;",
          "1657:   }",
          "1658:   ut64 size = sizeof (cache_map_t) * hdr->mappingCount;",
          "1659:   if (r_buf_fread_at (cache->buf, hdr->mappingOffset, (ut8*) &maps[next_map], \"3l2i\", hdr->mappingCount) != size) {",
          "1660:    continue;",
          "1661:   }",
          "1662:   ut32 j;",
          "1663:   ut64 hdr_offset = cache->hdr_offset[i];",
          "1664:   for (j = 0; j < hdr->mappingCount; j++) {",
          "1665:    cache_map_t *map = &maps[next_map + j];",
          "1666:    map->fileOffset += hdr_offset;",
          "1667:    if (map->address > max_address) {",
          "1668:     last_idx = i;",
          "1669:     max_address = map->address;",
          "1670:    }",
          "1671:   }",
          "1672:   next_map += hdr->mappingCount;",
          "1675:  cache->maps = maps;",
          "1676:  cache->n_maps = next_map;",
          "1677:  if (last_idx == UT32_MAX) {",
          "1678:   cache->symbols_off_base = 0;",
          "1679:  } else {",
          "1680:   cache->symbols_off_base = cache->hdr_offset[last_idx];",
          "1681:  }",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1455:   return NULL;",
          "1456:  }",
          "1459:  if (!offset) {",
          "1460:   return NULL;",
          "1461:  }",
          "",
          "[Removed Lines]",
          "1458:  ut64 offset = va2pa (hdr->accelerateInfoAddr, hdr, maps, cache_buf, 0, NULL, NULL);",
          "",
          "[Added Lines]",
          "1689:  ut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1483:  return accel;",
          "1484: }",
          "1486: static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {",
          "1487:  RDyldCache *cache = R_NEW0 (RDyldCache);",
          "1488:  memcpy (cache->magic, \"dyldcac\", 7);",
          "1489:  cache->buf = r_buf_ref (buf);",
          "1491:  if (!cache->hdr) {",
          "1492:   r_dyldcache_free (cache);",
          "1493:   return false;",
          "1494:  }",
          "1496:  if (!cache->maps) {",
          "1497:   r_dyldcache_free (cache);",
          "1498:   return false;",
          "1499:  }",
          "1500:  cache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);",
          "1503:  if (!cache->bins) {",
          "1504:   r_dyldcache_free (cache);",
          "1505:   return false;",
          "1506:  }",
          "1507:  cache->rebase_infos = get_rebase_infos (bf, cache);",
          "1508:  if (cache->rebase_infos) {",
          "1509:   if (!rebase_infos_get_slide (cache)) {",
          "",
          "[Removed Lines]",
          "1490:  cache->hdr = read_cache_header (cache->buf);",
          "1495:  cache->maps = read_cache_maps (cache->buf, cache->hdr);",
          "1501:  cache->locsym = r_dyld_locsym_new (cache->buf, cache->hdr);",
          "1502:  cache->bins = create_cache_bins (bf, cache->buf, cache->hdr, cache->maps, cache->accel);",
          "",
          "[Added Lines]",
          "1717: static objc_cache_opt_info *get_objc_opt_info(RBinFile *bf, RDyldCache *cache) {",
          "1718:  objc_cache_opt_info *result = NULL;",
          "1719:  RListIter *iter;",
          "1720:  RDyldBinImage *bin;",
          "1721:  r_list_foreach (cache->bins, iter, bin) {",
          "1722:   if (strcmp (bin->file, \"lib/libobjc.A.dylib\")) {",
          "1723:    continue;",
          "1724:   }",
          "1726:   struct MACH0_(opts_t) opts;",
          "1727:   opts.verbose = bf->rbin->verbose;",
          "1728:   opts.header_at = bin->header_at;",
          "1730:   struct MACH0_(obj_t) *mach0 = MACH0_(new_buf) (cache->buf, &opts);",
          "1731:   if (!mach0) {",
          "1732:    goto beach;",
          "1733:   }",
          "1735:   struct section_t *sections = NULL;",
          "1736:   if (!(sections = MACH0_(get_sections) (mach0))) {",
          "1737:    MACH0_(mach0_free) (mach0);",
          "1738:    goto beach;",
          "1739:   }",
          "1741:   int i;",
          "1742:   ut64 scoffs_offset = 0;",
          "1743:   ut64 scoffs_size = 0;",
          "1744:   ut64 slide = rebase_infos_get_slide (cache);",
          "1745:   for (i = 0; !sections[i].last; i++) {",
          "1746:    if (sections[i].size == 0) {",
          "1747:     continue;",
          "1748:    }",
          "1749:    if (strstr (sections[i].name, \"__objc_scoffs\")) {",
          "1750:     scoffs_offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "1751:     scoffs_size = sections[i].size;",
          "1752:     break;",
          "1753:    }",
          "1754:   }",
          "1756:   MACH0_(mach0_free) (mach0);",
          "1757:   R_FREE (sections);",
          "1759:   if (!scoffs_offset || scoffs_size < 40) {",
          "1760:    break;",
          "1761:   }",
          "1762:   ut64 check = r_buf_read_le64_at (cache->buf, scoffs_offset);",
          "1763:   if (check != 2) {",
          "1764:    break;",
          "1765:   }",
          "1766:   ut64 sel_string_base = r_buf_read_le64_at (cache->buf, scoffs_offset + 8);",
          "1767:   if (sel_string_base == UT64_MAX) {",
          "1768:    break;",
          "1769:   }",
          "1770:   ut64 sel_string_end = r_buf_read_le64_at (cache->buf, scoffs_offset + 16);",
          "1771:   if (sel_string_end == sel_string_base || sel_string_end == UT64_MAX) {",
          "1772:    break;",
          "1773:   }",
          "1774:   result = R_NEW0 (objc_cache_opt_info);",
          "1775:   if (!result) {",
          "1776:    break;",
          "1777:   }",
          "1778:   result->sel_string_base = sel_string_base;",
          "1779:  }",
          "1780: beach:",
          "1781:  return result;",
          "1782: }",
          "1788:  populate_cache_headers (cache);",
          "1793:  populate_cache_maps (cache);",
          "1799:  cache->bins = create_cache_bins (bf, cache);",
          "1804:  cache->locsym = r_dyld_locsym_new (cache);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1581:  return 0x180000000;",
          "1582: }",
          "1585:  struct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);",
          "1586:  if (!mach0) {",
          "1587:   return;",
          "",
          "[Removed Lines]",
          "1584: void symbols_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {",
          "",
          "[Added Lines]",
          "1882: void symbols_from_bin(RDyldCache *cache, RList *ret, RBinFile *bf, RDyldBinImage *bin, SetU *hash) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1594:  }",
          "1595:  int i;",
          "1596:  for (i = 0; !symbols[i].last; i++) {",
          "1598:    continue;",
          "1599:   }",
          "1600:   if (strstr (symbols[i].name, \"<redacted>\")) {",
          "",
          "[Removed Lines]",
          "1597:   if (!symbols[i].name[0] || symbols[i].addr < 100) {",
          "",
          "[Added Lines]",
          "1895:   if (!symbols[i].name || !symbols[i].name[0] || symbols[i].addr < 100) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1639: }",
          "1641: static void sections_from_bin(RList *ret, RBinFile *bf, RDyldBinImage *bin) {",
          "1642:  struct MACH0_(obj_t) *mach0 = bin_to_mach0 (bf, bin);",
          "1643:  if (!mach0) {",
          "1644:   return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1940:  RDyldCache *cache = (RDyldCache*) bf->o->bin_obj;",
          "1941:  if (!cache) {",
          "1942:   return;",
          "1943:  }",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1649:   return;",
          "1650:  }",
          "1652:  int i;",
          "1653:  for (i = 0; !sections[i].last; i++) {",
          "1654:   RBinSection *ptr = R_NEW0 (RBinSection);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1955:  ut64 slide = rebase_infos_get_slide (cache);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1667:   ptr->is_data = __is_data_section (ptr->name);",
          "1668:   ptr->size = sections[i].size;",
          "1669:   ptr->vsize = sections[i].vsize;",
          "1671:   ptr->vaddr = sections[i].addr;",
          "1672:   if (!ptr->vaddr) {",
          "1673:    ptr->vaddr = ptr->paddr;",
          "1674:   }",
          "",
          "[Removed Lines]",
          "1670:   ptr->paddr = sections[i].offset + bf->o->boffset;",
          "",
          "[Added Lines]",
          "1975:   ptr->paddr = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1699:  RBinSection *ptr = NULL;",
          "1700:  int i;",
          "1702:   if (!(ptr = R_NEW0 (RBinSection))) {",
          "1703:    r_list_free (ret);",
          "1704:    return NULL;",
          "",
          "[Removed Lines]",
          "1701:  for (i = 0; i < cache->hdr->mappingCount; i++) {",
          "",
          "[Added Lines]",
          "2005:  for (i = 0; i < cache->n_maps; i++) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1744:    r_list_free (ret);",
          "1745:    return NULL;",
          "1746:   }",
          "1749:   set_u_free (hash);",
          "1750:  }",
          "",
          "[Removed Lines]",
          "1747:   symbols_from_bin (ret, bf, bin, hash);",
          "1748:   r_dyld_locsym_entries_by_offset (cache, ret, hash, bin->header_at);",
          "",
          "[Added Lines]",
          "2051:   symbols_from_bin (cache, ret, bf, bin, hash);",
          "2052:   symbols_from_locsym (cache, bin, ret, hash);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1787:   return NULL;",
          "1788:  }",
          "1790:  RListIter *iter;",
          "1791:  RDyldBinImage *bin;",
          "1793:  RBuffer *orig_buf = bf->buf;",
          "1794:  ut32 num_of_unnamed_class = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2094:  if (!cache->objc_opt_info_loaded) {",
          "2095:   cache->oi = get_objc_opt_info (bf, cache);",
          "2096:   cache->objc_opt_info_loaded = true;",
          "2097:  }",
          "2101:  ut64 slide = rebase_infos_get_slide (cache);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1818:    }",
          "1820:    ut8 *pointers = malloc (sections[i].size);",
          "1822:     R_FREE (pointers);",
          "1823:     continue;",
          "1824:    }",
          "",
          "[Removed Lines]",
          "1821:    if (r_buf_read_at (cache->buf, sections[i].offset, pointers, sections[i].size) < sections[i].size) {",
          "",
          "[Added Lines]",
          "2131:    if (!pointers) {",
          "2132:     continue;",
          "2133:    }",
          "2135:    ut64 offset = va2pa (sections[i].addr, cache->n_maps, cache->maps, cache->buf, slide, NULL, NULL);",
          "2136:    if (r_buf_read_at (cache->buf, offset, pointers, sections[i].size) < sections[i].size) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1842:     bf->o->bin_obj = mach0;",
          "1843:     bf->buf = cache->buf;",
          "1844:     if (is_classlist) {",
          "1846:     } else {",
          "1848:     }",
          "1849:     bf->o->bin_obj = cache;",
          "1850:     bf->buf = orig_buf;",
          "1852:     if (!klass->name) {",
          "1853:      klass->name = r_str_newf (\"UnnamedClass%u\", num_of_unnamed_class);",
          "1854:      if (!klass->name) {",
          "1855:       R_FREE (klass);",
          "",
          "[Removed Lines]",
          "1845:      MACH0_(get_class_t) ((ut64) pointer_to_class, bf, klass, false, NULL);",
          "1847:      MACH0_(get_category_t) ((ut64) pointer_to_class, bf, klass, NULL);",
          "",
          "[Added Lines]",
          "2160:      MACH0_(get_class_t) (pointer_to_class, bf, klass, false, NULL, cache->oi);",
          "2162:      MACH0_(get_category_t) (pointer_to_class, bf, klass, NULL, cache->oi);",
          "2168:      eprintf (\"KLASS ERROR AT 0x%llx, is_classlist %d\\n\", pointer_to_class, is_classlist);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "835:  obj->rebasing_buffer = false;",
          "836: }",
          "838: #if !R_BIN_MACH064",
          "840: static bool check_buffer(RBinFile *bf, RBuffer *b) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "838: static RList *classes(RBinFile *bf) {",
          "839:  return MACH0_(parse_classes) (bf, NULL);",
          "840: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1174:  .relocs = &relocs,",
          "1175:  .patch_relocs = &patch_relocs,",
          "1176:  .create = &create,",
          "1178:  .write = &r_bin_write_mach0,",
          "1179: };",
          "",
          "[Removed Lines]",
          "1177:  .classes = &MACH0_(parse_classes),",
          "",
          "[Added Lines]",
          "1181:  .classes = &classes,",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach064.c||libr/bin/p/bin_mach064.c": [
          "File: libr/bin/p/bin_mach064.c -> libr/bin/p/bin_mach064.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "301:  .patch_relocs = &patch_relocs,",
          "302:  .fields = &MACH0_(mach_fields),",
          "303:  .create = &create,",
          "305:  .write = &r_bin_write_mach0,",
          "306: };",
          "",
          "[Removed Lines]",
          "304:  .classes = &MACH0_(parse_classes),",
          "",
          "[Added Lines]",
          "304:  .classes = &classes,",
          "",
          "---------------"
        ],
        "libr/util/buf.c||libr/util/buf.c": [
          "File: libr/util/buf.c -> libr/util/buf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "562: R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {",
          "563:  r_return_val_if_fail (b && buf && fmt, -1);",
          "564:  st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);",
          "566:  if (r < 0) {",
          "567:   return r;",
          "568:  }",
          "",
          "[Removed Lines]",
          "565:  int r = r_buf_seek (b, addr, R_BUF_SET);",
          "",
          "[Added Lines]",
          "565:  st64 r = r_buf_seek (b, addr, R_BUF_SET);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8ddec017c8a3eb92b6f43b2b2fa949a2ee8b3231",
      "candidate_info": {
        "commit_hash": "8ddec017c8a3eb92b6f43b2b2fa949a2ee8b3231",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/8ddec017c8a3eb92b6f43b2b2fa949a2ee8b3231",
        "files": [
          "libr/bin/bobj.c",
          "libr/bin/format/mdmp/mdmp.h",
          "libr/bin/format/mdmp/mdmp_pe.h",
          "libr/bin/format/pe/pe.c",
          "libr/bin/format/pe/pe.h",
          "libr/bin/format/pe/pe_write.c",
          "libr/bin/format/pe/pemixed.c",
          "libr/bin/format/pe/pemixed.h",
          "libr/bin/p/bin_mdmp.c",
          "libr/bin/p/bin_pe.c",
          "libr/bin/p/bin_pe.inc"
        ],
        "message": "Cleanup varnames in PE and MDMP plugins",
        "before_after_code_files": [
          "libr/bin/bobj.c||libr/bin/bobj.c",
          "libr/bin/format/mdmp/mdmp.h||libr/bin/format/mdmp/mdmp.h",
          "libr/bin/format/mdmp/mdmp_pe.h||libr/bin/format/mdmp/mdmp_pe.h",
          "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c",
          "libr/bin/format/pe/pe.h||libr/bin/format/pe/pe.h",
          "libr/bin/format/pe/pe_write.c||libr/bin/format/pe/pe_write.c",
          "libr/bin/format/pe/pemixed.c||libr/bin/format/pe/pemixed.c",
          "libr/bin/format/pe/pemixed.h||libr/bin/format/pe/pemixed.h",
          "libr/bin/p/bin_mdmp.c||libr/bin/p/bin_mdmp.c",
          "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c",
          "libr/bin/p/bin_pe.inc||libr/bin/p/bin_pe.inc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c"
          ],
          "candidate": [
            "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/bobj.c||libr/bin/bobj.c": [
          "File: libr/bin/bobj.c -> libr/bin/bobj.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "125: R_IPI RBinObject *r_bin_object_new(RBinFile *bf, RBinPlugin *plugin, ut64 baseaddr, ut64 loadaddr, ut64 offset, ut64 sz) {",
          "126:  r_return_val_if_fail (bf && plugin, NULL);",
          "127:  ut64 bytes_sz = r_buf_size (bf->buf);",
          "131:   return NULL;",
          "132:  }",
          "146:  if (plugin && plugin->load_buffer) {",
          "148:    if (bf->rbin->verbose) {",
          "149:     eprintf (\"Error in r_bin_object_new: load_buffer failed for %s plugin\\n\", plugin->name);",
          "150:    }",
          "153:    return NULL;",
          "154:   }",
          "155:  } else {",
          "156:   R_LOG_WARN (\"Plugin %s should implement load_buffer method.\\n\", plugin->name);",
          "159:   return NULL;",
          "160:  }",
          "",
          "[Removed Lines]",
          "128:  Sdb *sdb = bf->sdb;",
          "129:  RBinObject *o = R_NEW0 (RBinObject);",
          "130:  if (!o) {",
          "133:  o->obj_size = (bytes_sz >= sz + offset)? sz: 0;",
          "134:  o->boffset = offset;",
          "135:  o->strings_db = ht_up_new0 ();",
          "136:  o->regstate = NULL;",
          "137:  o->kv = sdb_new0 (); // XXX bf->sdb bf->o->sdb wtf",
          "138:  o->baddr = baseaddr;",
          "139:  o->classes = r_list_newf ((RListFree)r_bin_class_free);",
          "140:  o->classes_ht = ht_pp_new0 ();",
          "141:  o->methods_ht = ht_pp_new0 ();",
          "142:  o->baddr_shift = 0;",
          "143:  o->plugin = plugin;",
          "144:  o->loadaddr = loadaddr != UT64_MAX ? loadaddr : 0;",
          "147:   if (!plugin->load_buffer (bf, &o->bin_obj, bf->buf, loadaddr, sdb)) {",
          "151:    sdb_free (o->kv);",
          "152:    free (o);",
          "157:   sdb_free (o->kv);",
          "158:   free (o);",
          "",
          "[Added Lines]",
          "128:  RBinObject *bo = R_NEW0 (RBinObject);",
          "129:  if (!bo) {",
          "132:  bo->obj_size = (bytes_sz >= sz + offset)? sz: 0;",
          "133:  bo->boffset = offset;",
          "134:  bo->strings_db = ht_up_new0 ();",
          "135:  bo->regstate = NULL;",
          "136:  bo->kv = sdb_new0 (); // XXX bf->sdb bf->bo->sdb wtf",
          "137:  bo->baddr = baseaddr;",
          "138:  bo->classes = r_list_newf ((RListFree)r_bin_class_free);",
          "139:  bo->classes_ht = ht_pp_new0 ();",
          "140:  bo->methods_ht = ht_pp_new0 ();",
          "141:  bo->baddr_shift = 0;",
          "142:  bo->plugin = plugin;",
          "143:  bo->loadaddr = loadaddr != UT64_MAX ? loadaddr : 0;",
          "145:  Sdb *sdb = bf->sdb; // should be bo->kv ?",
          "147:   if (!plugin->load_buffer (bf, &bo->bin_obj, bf->buf, loadaddr, sdb)) {",
          "151:    sdb_free (bo->kv);",
          "152:    free (bo);",
          "157:   sdb_free (bo->kv);",
          "158:   free (bo);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "173:   Sdb *bdb = bf->sdb; // sdb_new0 ();",
          "174:   if (!sdb_ns (bdb, \"info\", 0)) {",
          "176:   }",
          "177:   sdb_ns_set (bdb, \"addrinfo\", bf->sdb_addrinfo);",
          "179:   sdb_set (bf->sdb, \"archs\", \"0:0:x86:32\", 0); // x86??",
          "",
          "[Removed Lines]",
          "166:  r_bin_file_set_obj (bf->rbin, bf, o);",
          "167:  r_bin_set_baddr (bf->rbin, o->baddr);",
          "168:  r_bin_object_set_items (bf, o);",
          "170:  bf->sdb_info = o->kv;",
          "171:  sdb = bf->rbin->sdb;",
          "172:  if (sdb) {",
          "175:    sdb_ns_set (bdb, \"info\", o->kv);",
          "178:   o->kv = bdb;",
          "",
          "[Added Lines]",
          "166:  r_bin_file_set_obj (bf->rbin, bf, bo);",
          "167:  r_bin_set_baddr (bf->rbin, bo->baddr);",
          "168:  r_bin_object_set_items (bf, bo);",
          "170:  bf->sdb_info = bo->kv;",
          "171:  Sdb *root_bin_sdb = bf->rbin->sdb;",
          "172:  if (root_bin_sdb) {",
          "175:    sdb_ns_set (bdb, \"info\", bo->kv);",
          "178:   bo->kv = bdb;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "189:   r_strf_var (fdns, 32, \"fd.%d\", bf->fd);",
          "191:   bf->sdb->refs++;",
          "192:  }",
          "194: }",
          "196: static void filter_classes(RBinFile *bf, RList *list) {",
          "",
          "[Removed Lines]",
          "188:   sdb_ns_set (sdb, \"cur\", bdb); // bf->sdb);",
          "190:   sdb_ns_set (sdb, fdns, bdb); // bf->sdb);",
          "193:  return o;",
          "",
          "[Added Lines]",
          "188:   sdb_ns_set (root_bin_sdb, \"cur\", bdb); // bf->sdb);",
          "190:   sdb_ns_set (root_bin_sdb, fdns, bdb); // bf->sdb);",
          "193:  return bo;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "240:  return tree;",
          "241: }",
          "249:  RListIter *it, *it2;",
          "250:  RBinClass *klass;",
          "251:  RBinSymbol *method;",
          "253:   if (klass->name) {",
          "256:    r_list_foreach (klass->methods, it2, method) {",
          "257:     char *name = r_str_newf (\"%s::%s\", klass->name, method->name);",
          "259:     free (name);",
          "260:    }",
          "261:   }",
          "262:  }",
          "263: }",
          "268:  int i;",
          "269:  bool isSwift = false;",
          "270:  RBin *bin = bf->rbin;",
          "272:  int minlen = (bf->rbin->minstrlen > 0) ? bf->rbin->minstrlen : p->minstrlen;",
          "275:  if (p->file_type) {",
          "276:   int type = p->file_type (bf);",
          "277:   if (type == R_BIN_TYPE_CORE) {",
          "278:    if (p->regstate) {",
          "280:    }",
          "281:    if (p->maps) {",
          "283:    }",
          "284:   }",
          "285:  }",
          "287:  if (p->boffset) {",
          "289:  }",
          "293:  if (p->size) {",
          "295:  }",
          "297:  if (p->binsym) {",
          "298:   for (i = 0; i < R_BIN_SYM_LAST; i++) {",
          "302:    }",
          "303:   }",
          "304:  }",
          "305:  if (p->entries) {",
          "308:  }",
          "309:  if (p->fields) {",
          "314:   }",
          "315:  }",
          "316:  if (p->imports) {",
          "321:   }",
          "322:  }",
          "323:  if (p->symbols) {",
          "328:    if (bin->filter) {",
          "330:    }",
          "331:   }",
          "332:  }",
          "334:  if (p->libs) {",
          "336:  }",
          "337:  if (p->sections) {",
          "341:   }",
          "343:   if (bin->filter) {",
          "345:   }",
          "346:  }",
          "347:  if (bin->filter_rules & (R_BIN_REQ_RELOCS | R_BIN_REQ_IMPORTS)) {",
          "348:   if (p->relocs) {",
          "349:    RList *l = p->relocs (bf);",
          "350:    if (l) {",
          "353:     l->free = NULL;",
          "354:     r_list_free (l);",
          "355:    }",
          "356:   }",
          "357:  }",
          "358:  if (bin->filter_rules & R_BIN_REQ_STRINGS) {",
          "360:    ? p->strings (bf)",
          "361:    : r_bin_file_get_strings (bf, minlen, 0, bf->rawstr);",
          "362:   if (bin->debase64) {",
          "364:   }",
          "366:  }",
          "367:  if (bin->filter_rules & R_BIN_REQ_CLASSES) {",
          "368:   if (p->classes) {",
          "369:    RList *classes = p->classes (bf);",
          "370:    if (classes) {",
          "375:    }",
          "376:    isSwift = r_bin_lang_swift (bf);",
          "377:    if (isSwift) {",
          "379:    }",
          "380:   } else {",
          "381:    RList *classes = classes_from_symbols (bf);",
          "382:    if (classes) {",
          "384:    }",
          "385:   }",
          "386:   if (bin->filter) {",
          "388:   }",
          "392:    RListIter *iter, *iter2;",
          "393:    RBinClass *klass;",
          "394:    RBinSymbol *method;",
          "398:     r_list_foreach (klasses, iter, klass) {",
          "399:      r_list_foreach (klass->methods, iter2, method) {",
          "401:      }",
          "402:     }",
          "403:    }",
          "404:   }",
          "405:  }",
          "406:  if (p->lines) {",
          "408:  }",
          "409:  if (p->get_sdb) {",
          "410:   Sdb* new_kv = p->get_sdb (bf);",
          "413:   }",
          "415:  }",
          "416:  if (p->mem)  {",
          "418:  }",
          "421:  }",
          "422:  return true;",
          "423: }",
          "428:  static bool first = true;",
          "434:   first = false;",
          "435:   if (!tmp) {",
          "437:   }",
          "441:   first = false;",
          "442:   bin->is_reloc_patched = true;",
          "443:   tmp->free = NULL;",
          "444:   r_list_free (tmp);",
          "445:  }",
          "447: }",
          "449: R_IPI RBinObject *r_bin_object_get_cur(RBin *bin) {",
          "",
          "[Removed Lines]",
          "243: static void r_bin_object_rebuild_classes_ht(RBinObject *o) {",
          "244:  ht_pp_free (o->classes_ht);",
          "245:  ht_pp_free (o->methods_ht);",
          "246:  o->classes_ht = ht_pp_new0 ();",
          "247:  o->methods_ht = ht_pp_new0 ();",
          "252:  r_list_foreach (o->classes, it, klass) {",
          "254:    ht_pp_insert (o->classes_ht, klass->name, klass);",
          "258:     ht_pp_insert (o->methods_ht, name, method);",
          "265: R_API int r_bin_object_set_items(RBinFile *bf, RBinObject *o) {",
          "266:  r_return_val_if_fail (bf && o && o->plugin, false);",
          "271:  RBinPlugin *p = o->plugin;",
          "273:  bf->o = o;",
          "279:     o->regstate = p->regstate (bf);",
          "282:     o->maps = p->maps (bf);",
          "288:   o->boffset = p->boffset (bf);",
          "294:   o->size = p->size (bf);",
          "299:    o->binsym[i] = p->binsym (bf, i);",
          "300:    if (o->binsym[i]) {",
          "301:     o->binsym[i]->paddr += o->loadaddr;",
          "306:   o->entries = p->entries (bf);",
          "307:   REBASE_PADDR (o, o->entries, RBinAddr);",
          "310:   o->fields = p->fields (bf);",
          "311:   if (o->fields) {",
          "312:    o->fields->free = r_bin_field_free;",
          "313:    REBASE_PADDR (o, o->fields, RBinField);",
          "317:   r_list_free (o->imports);",
          "318:   o->imports = p->imports (bf);",
          "319:   if (o->imports) {",
          "320:    o->imports->free = (RListFree)r_bin_import_free;",
          "324:   o->symbols = p->symbols (bf); // 5s",
          "325:   if (o->symbols) {",
          "326:    o->symbols->free = r_bin_symbol_free;",
          "327:    REBASE_PADDR (o, o->symbols, RBinSymbol);",
          "329:     r_bin_filter_symbols (bf, o->symbols); // 5s",
          "333:  o->info = p->info? p->info (bf): NULL;",
          "335:   o->libs = p->libs (bf);",
          "339:   if (!o->sections) {",
          "340:    o->sections = p->sections (bf);",
          "342:   REBASE_PADDR (o, o->sections, RBinSection);",
          "344:    r_bin_filter_sections (bf, o->sections);",
          "351:     REBASE_PADDR (o, l, RBinReloc);",
          "352:     o->relocs = list2rbtree (l);",
          "359:   o->strings = p->strings",
          "363:    r_bin_object_filter_strings (o);",
          "365:   REBASE_PADDR (o, o->strings, RBinString);",
          "372:     r_list_free (o->classes);",
          "373:     o->classes = classes;",
          "374:     r_bin_object_rebuild_classes_ht (o);",
          "378:     o->classes = classes_from_symbols (bf);",
          "383:     o->classes = classes;",
          "387:    filter_classes (bf, o->classes);",
          "390:   if (o->classes) {",
          "391:    RList *klasses = o->classes;",
          "395:    if (!o->addr2klassmethod) {",
          "397:     o->addr2klassmethod = ht_up_new0 ();",
          "400:       ht_up_insert (o->addr2klassmethod, method->vaddr, method);",
          "407:   o->lines = p->lines (bf);",
          "411:   if (new_kv != o->kv) {",
          "412:    sdb_free (o->kv);",
          "414:   o->kv = new_kv;",
          "417:   o->mem = p->mem (bf);",
          "419:  if (o->info && bin->filter_rules & (R_BIN_REQ_INFO | R_BIN_REQ_SYMBOLS | R_BIN_REQ_IMPORTS)) {",
          "420:   o->lang = isSwift? R_BIN_NM_SWIFT: r_bin_load_languages (bf);",
          "425: R_IPI RRBTree *r_bin_object_patch_relocs(RBin *bin, RBinObject *o) {",
          "426:  r_return_val_if_fail (bin && o, NULL);",
          "432:  if (first && o->plugin && o->plugin->patch_relocs) {",
          "433:   RList *tmp = o->plugin->patch_relocs (bin);",
          "436:    return o->relocs;",
          "438:   r_crbtree_free (o->relocs);",
          "439:   REBASE_PADDR (o, tmp, RBinReloc);",
          "440:   o->relocs = list2rbtree (tmp);",
          "446:  return o->relocs;",
          "",
          "[Added Lines]",
          "243: static void r_bin_object_rebuild_classes_ht(RBinObject *bo) {",
          "244:  ht_pp_free (bo->classes_ht);",
          "245:  ht_pp_free (bo->methods_ht);",
          "246:  bo->classes_ht = ht_pp_new0 ();",
          "247:  bo->methods_ht = ht_pp_new0 ();",
          "252:  r_list_foreach (bo->classes, it, klass) {",
          "254:    ht_pp_insert (bo->classes_ht, klass->name, klass);",
          "258:     ht_pp_insert (bo->methods_ht, name, method);",
          "265: R_API int r_bin_object_set_items(RBinFile *bf, RBinObject *bo) {",
          "266:  r_return_val_if_fail (bf && bo && bo->plugin, false);",
          "271:  RBinPlugin *p = bo->plugin;",
          "273:  bf->o = bo;",
          "279:     bo->regstate = p->regstate (bf);",
          "282:     bo->maps = p->maps (bf);",
          "288:   bo->boffset = p->boffset (bf);",
          "294:   bo->size = p->size (bf);",
          "299:    bo->binsym[i] = p->binsym (bf, i);",
          "300:    if (bo->binsym[i]) {",
          "301:     bo->binsym[i]->paddr += bo->loadaddr;",
          "306:   bo->entries = p->entries (bf);",
          "307:   REBASE_PADDR (bo, bo->entries, RBinAddr);",
          "310:   bo->fields = p->fields (bf);",
          "311:   if (bo->fields) {",
          "312:    bo->fields->free = r_bin_field_free;",
          "313:    REBASE_PADDR (bo, bo->fields, RBinField);",
          "317:   r_list_free (bo->imports);",
          "318:   bo->imports = p->imports (bf);",
          "319:   if (bo->imports) {",
          "320:    bo->imports->free = (RListFree)r_bin_import_free;",
          "324:   bo->symbols = p->symbols (bf); // 5s",
          "325:   if (bo->symbols) {",
          "326:    bo->symbols->free = r_bin_symbol_free;",
          "327:    REBASE_PADDR (bo, bo->symbols, RBinSymbol);",
          "329:     r_bin_filter_symbols (bf, bo->symbols); // 5s",
          "333:  bo->info = p->info? p->info (bf): NULL;",
          "335:   bo->libs = p->libs (bf);",
          "339:   if (!bo->sections) {",
          "340:    bo->sections = p->sections (bf);",
          "342:   REBASE_PADDR (bo, bo->sections, RBinSection);",
          "344:    r_bin_filter_sections (bf, bo->sections);",
          "351:     REBASE_PADDR (bo, l, RBinReloc);",
          "352:     bo->relocs = list2rbtree (l);",
          "359:   bo->strings = p->strings",
          "363:    r_bin_object_filter_strings (bo);",
          "365:   REBASE_PADDR (bo, bo->strings, RBinString);",
          "372:     r_list_free (bo->classes);",
          "373:     bo->classes = classes;",
          "374:     r_bin_object_rebuild_classes_ht (bo);",
          "378:     bo->classes = classes_from_symbols (bf);",
          "383:     bo->classes = classes;",
          "387:    filter_classes (bf, bo->classes);",
          "390:   if (bo->classes) {",
          "391:    RList *klasses = bo->classes;",
          "395:    if (!bo->addr2klassmethod) {",
          "397:     bo->addr2klassmethod = ht_up_new0 ();",
          "400:       ht_up_insert (bo->addr2klassmethod, method->vaddr, method);",
          "407:   bo->lines = p->lines (bf);",
          "411:   if (new_kv != bo->kv) {",
          "412:    sdb_free (bo->kv);",
          "414:   bo->kv = new_kv;",
          "417:   bo->mem = p->mem (bf);",
          "419:  if (bo->info && bin->filter_rules & (R_BIN_REQ_INFO | R_BIN_REQ_SYMBOLS | R_BIN_REQ_IMPORTS)) {",
          "420:   bo->lang = isSwift? R_BIN_NM_SWIFT: r_bin_load_languages (bf);",
          "425: R_IPI RRBTree *r_bin_object_patch_relocs(RBin *bin, RBinObject *bo) {",
          "426:  r_return_val_if_fail (bin && bo, NULL);",
          "432:  if (first && bo->plugin && bo->plugin->patch_relocs) {",
          "433:   RList *tmp = bo->plugin->patch_relocs (bin);",
          "436:    return bo->relocs;",
          "438:   r_crbtree_free (bo->relocs);",
          "439:   REBASE_PADDR (bo, tmp, RBinReloc);",
          "440:   bo->relocs = list2rbtree (tmp);",
          "446:  return bo->relocs;",
          "",
          "---------------"
        ],
        "libr/bin/format/mdmp/mdmp.h||libr/bin/format/mdmp/mdmp.h": [
          "File: libr/bin/format/mdmp/mdmp.h -> libr/bin/format/mdmp/mdmp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #include \"mdmp_pe.h\"",
          "13: #include \"mdmp_pe64.h\"",
          "16:  struct minidump_header *hdr;",
          "",
          "[Removed Lines]",
          "15: struct r_bin_mdmp_obj {",
          "",
          "[Added Lines]",
          "15: typedef struct r_bin_mdmp_obj {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54:  size_t size;",
          "55:  ut8 endian;",
          "56:  Sdb *kv;",
          "",
          "[Removed Lines]",
          "57: };",
          "59: struct r_bin_mdmp_obj *r_bin_mdmp_new_buf(RBuffer *buf);",
          "60: void r_bin_mdmp_free(struct r_bin_mdmp_obj *obj);",
          "61: ut64 r_bin_mdmp_get_paddr(struct r_bin_mdmp_obj *obj, ut64 vaddr);",
          "62: ut32 r_bin_mdmp_get_perm(struct r_bin_mdmp_obj *obj, ut64 vaddr);",
          "63: struct minidump_memory_info *r_bin_mdmp_get_mem_info(struct r_bin_mdmp_obj *obj, ut64 vaddr);",
          "",
          "[Added Lines]",
          "57: } RBinMdmpObj;",
          "60: RBinMdmpObj *r_bin_mdmp_new_buf(RBuffer *buf);",
          "61: void r_bin_mdmp_free(RBinMdmpObj *obj);",
          "62: ut64 r_bin_mdmp_get_paddr(RBinMdmpObj *obj, ut64 vaddr);",
          "63: ut32 r_bin_mdmp_get_perm(RBinMdmpObj *obj, ut64 vaddr);",
          "64: struct minidump_memory_info *r_bin_mdmp_get_mem_info(RBinMdmpObj *obj, ut64 vaddr);",
          "",
          "---------------"
        ],
        "libr/bin/format/mdmp/mdmp_pe.h||libr/bin/format/mdmp/mdmp_pe.h": [
          "File: libr/bin/format/mdmp/mdmp_pe.h -> libr/bin/format/mdmp/mdmp_pe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include \"mdmp_specs.h\"",
          "16:  ut64 vaddr;",
          "17:  ut64 paddr;",
          "18:  struct PE_(r_bin_pe_obj_t) *bin;",
          "",
          "[Removed Lines]",
          "15: struct PE_(r_bin_mdmp_pe_bin) {",
          "19: };",
          "22: RList *PE_(r_bin_mdmp_pe_get_entrypoint)(struct PE_(r_bin_mdmp_pe_bin) *pe_bin);",
          "23: RList *PE_(r_bin_mdmp_pe_get_imports)(struct PE_(r_bin_mdmp_pe_bin) *pe_bin);",
          "24: RList *PE_(r_bin_mdmp_pe_get_sections)(struct PE_(r_bin_mdmp_pe_bin) *pe_bin);",
          "25: RList *PE_(r_bin_mdmp_pe_get_symbols)(RBin *rbin, struct PE_(r_bin_mdmp_pe_bin) *pe_bin);",
          "",
          "[Added Lines]",
          "13: typedef struct PE_(r_bin_mdmp_pe_bin) {",
          "17: } PE_(RBinMdmp);",
          "19: RList *PE_(r_bin_mdmp_pe_get_entrypoint)(PE_(RBinMdmp) *mdmp);",
          "20: RList *PE_(r_bin_mdmp_pe_get_imports)(PE_(RBinMdmp) *mdmp);",
          "21: RList *PE_(r_bin_mdmp_pe_get_sections)(PE_(RBinMdmp) *mdmp);",
          "22: RList *PE_(r_bin_mdmp_pe_get_symbols)(RBin *rbin, PE_(RBinMdmp) *mdmp);",
          "",
          "---------------"
        ],
        "libr/bin/format/pe/pe.c||libr/bin/format/pe/pe.c": [
          "File: libr/bin/format/pe/pe.c -> libr/bin/format/pe/pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #define PE_IMAGE_FILE_MACHINE_RPI2 452",
          "14: #define MAX_METADATA_STRING_LENGTH 256",
          "16: #define COFF_SYMBOL_SIZE 18",
          "17: #define PE_READ_STRUCT_FIELD(var, struct_type, field, size) var->field = r_read_le##size (buf + offsetof (struct_type, field))",
          "",
          "[Removed Lines]",
          "15: #define bprintf if (bin->verbose) eprintf",
          "",
          "[Added Lines]",
          "15: #define pe_printf if (pe->verbose) eprintf",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:  void (* free)(struct SCV_RSDS_HEADER* rsds_hdr);",
          "43: } SCV_RSDS_HEADER;",
          "47: }",
          "51:  case PE_IMAGE_FILE_MACHINE_RPI2: // 462",
          "52:  case PE_IMAGE_FILE_MACHINE_ARM:",
          "53:  case PE_IMAGE_FILE_MACHINE_THUMB:",
          "",
          "[Removed Lines]",
          "45: static inline int is_thumb(struct PE_(r_bin_pe_obj_t)* bin) {",
          "46:  return bin->nt_headers->optional_header.AddressOfEntryPoint & 1;",
          "49: static inline int is_arm(struct PE_(r_bin_pe_obj_t)* bin) {",
          "50:  switch (bin->nt_headers->file_header.Machine) {",
          "",
          "[Added Lines]",
          "45: R_API RBinPEObj* PE_(get)(RBinFile *bf) {",
          "46:  return (bf && bf->o)? bf->o->bin_obj: NULL;",
          "49: static inline int is_thumb(RBinPEObj* pe) {",
          "50:  return pe->nt_headers->optional_header.AddressOfEntryPoint & 1;",
          "51: }",
          "53: static inline int is_arm(RBinPEObj* pe) {",
          "54:  switch (pe->nt_headers->file_header.Machine) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76:  return read_and_follow_jump (entry, buf, b, len, big_endian);",
          "77: }",
          "81:  ut8 b[512];",
          "82:  size_t n = 0;",
          "84:  ZERO_FILL (b);",
          "87:   free (entry);",
          "88:   return NULL;",
          "89:  }",
          "96:  if (b[0] == 0xe8 && b[5] == 0xe9) {",
          "103:    for (n = 0; n < sizeof (b) - 6; n++) {",
          "105:     if (b[n] == 0x68 && tmp_imgbase == imageBase && b[n + 5] == 0xe8) {",
          "107:      return entry;",
          "108:     }",
          "109:    }",
          "",
          "[Removed Lines]",
          "79: struct r_bin_pe_addr_t *PE_(check_msvcseh)(struct PE_(r_bin_pe_obj_t) *bin) {",
          "80:  r_return_val_if_fail (bin && bin->b, NULL);",
          "83:  struct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (bin);",
          "85:  if (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) < 0) {",
          "86:   bprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);",
          "91:  read_and_follow_jump (entry, bin->b, b, sizeof (b), bin->big_endian);",
          "97:   if (follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 5)) {",
          "102:    ut32 imageBase = bin->nt_headers->optional_header.ImageBase;",
          "104:     const ut32 tmp_imgbase = r_read_ble32 (b + n + 1, bin->big_endian);",
          "106:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 5);",
          "",
          "[Added Lines]",
          "83: struct r_bin_pe_addr_t *PE_(check_msvcseh)(RBinPEObj *pe) {",
          "84:  r_return_val_if_fail (pe && pe->b, NULL);",
          "87:  struct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);",
          "89:  if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {",
          "90:   pe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);",
          "95:  read_and_follow_jump (entry, pe->b, b, sizeof (b), pe->big_endian);",
          "101:   if (follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 5)) {",
          "106:    ut32 imageBase = pe->nt_headers->optional_header.ImageBase;",
          "108:     const ut32 tmp_imgbase = r_read_ble32 (b + n + 1, pe->big_endian);",
          "110:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 5);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "116:    for (n = 0; n < sizeof (b) - 6; n++) {",
          "117:     if (b[n] == 0x50 && b[n+1] == 0xff && b[n + 3] == 0xff && b[n + 5] == 0xe8) {",
          "119:      return entry;",
          "120:     }",
          "121:    }",
          "",
          "[Removed Lines]",
          "118:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 5);",
          "",
          "[Added Lines]",
          "122:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 5);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "127:    for (n = 0; n < sizeof (b) - 20; n++) {",
          "128:     if (b[n] == 0x50 && b[n + 1] == 0xff && b[n + 7] == 0xff && b[n + 13] == 0xe8) {",
          "130:      return entry;",
          "131:     }",
          "132:    }",
          "",
          "[Removed Lines]",
          "129:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 13);",
          "",
          "[Added Lines]",
          "133:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 13);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "138:    for (n = 0; n < sizeof (b) - 5; n++) {",
          "139:     if (b[n] == 0x50 && b[n + 1] == 0x57 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {",
          "141:      return entry;",
          "142:     }",
          "143:    }",
          "",
          "[Removed Lines]",
          "140:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 4);",
          "",
          "[Added Lines]",
          "144:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 4);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "149:    for (n = 0; n < sizeof (b) - 5; n++) {",
          "150:     if (b[n] == 0x57 && b[n + 1] == 0x56 && b[n + 2] == 0xff && b[n + 4] == 0xe8) {",
          "152:      return entry;",
          "153:     }",
          "154:    }",
          "",
          "[Removed Lines]",
          "151:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 4);",
          "",
          "[Added Lines]",
          "155:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 4);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "166:   if (b[8] == 0xe8) {",
          "",
          "[Removed Lines]",
          "165:   follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 3);",
          "",
          "[Added Lines]",
          "169:   follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 3);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "174:    for (n = 0; n + 16 < sizeof (b); n++) {",
          "",
          "[Removed Lines]",
          "173:    follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 8);",
          "",
          "[Added Lines]",
          "177:    follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 8);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "180:     if (b[n] == 0xe8 && n + 8 <= sizeof (b) && !memcmp (b + n + 5, \"\\x83\\xc4\\x04\", 3)",
          "181:      && b[n + 8] == 0xe8 && b[n + 13] == 0x89 && b[n + 16] == 0xe8) {",
          "183:      int j, calls = 0;",
          "184:      for (j = 0; j < sizeof (b) - 4; j++) {",
          "185:       if (b[j] == 0xe8) {",
          "187:        calls++;",
          "188:        if (calls == 4) {",
          "190:         return entry;",
          "191:        }",
          "192:       }",
          "",
          "[Removed Lines]",
          "182:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 8);",
          "189:         follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, j);",
          "",
          "[Added Lines]",
          "186:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);",
          "193:         follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, j);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "208:   } else {",
          "215:    if (b[9] == 0xe8) {",
          "222:     if (b[0x129] == 0xe8) {",
          "225:     }",
          "226:    }",
          "227:   }",
          "",
          "[Removed Lines]",
          "207:    found_caller = follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 13);",
          "214:    follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 4);",
          "221:     follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 9);",
          "224:      found_caller = follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 0x129);",
          "",
          "[Added Lines]",
          "211:    found_caller = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 13);",
          "218:    follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 4);",
          "225:     follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 9);",
          "228:      found_caller = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 0x129);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "239:    for (n = 0; n + 14 < sizeof (b); n++) {",
          "240:     if (b[n] == 0x4c && b[n + 3] == 0x48 && b[n + 6] == 0x8b && b[n + 8] == 0xe8) {",
          "242:      return entry;",
          "243:     }",
          "244:     if (b[n] == 0x4c && b [n + 5] == 0x48 && b[n + 10] == 0x8b && b[n + 14] == 0xe8) {",
          "246:      return entry;",
          "247:     }",
          "248:    }",
          "",
          "[Removed Lines]",
          "241:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 8);",
          "245:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 14);",
          "",
          "[Added Lines]",
          "245:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);",
          "249:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 14);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "262:  if (b[188] == 0x50 && b[201] == 0xe8) {",
          "264:   return entry;",
          "265:  }",
          "267:  if (b[292] == 0x50 && b[303] == 0xe8) {",
          "269:   return entry;",
          "270:  }",
          "",
          "[Removed Lines]",
          "263:   follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 201);",
          "268:   follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 303);",
          "",
          "[Added Lines]",
          "267:   follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 201);",
          "272:   follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 303);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "273:  return NULL;",
          "274: }",
          "277:  struct r_bin_pe_addr_t* entry;",
          "278:  bool sw = false;",
          "279:  ut8 b[1024];",
          "280:  size_t n = 0;",
          "282:   return 0LL;",
          "283:  }",
          "285:  ZERO_FILL (b);",
          "288:   free (entry);",
          "289:   return NULL;",
          "290:  }",
          "",
          "[Removed Lines]",
          "276: struct r_bin_pe_addr_t *PE_(check_mingw)(struct PE_(r_bin_pe_obj_t) *bin) {",
          "281:  if (!bin || !bin->b) {",
          "284:  entry = PE_(r_bin_pe_get_entrypoint) (bin);",
          "286:  if (r_buf_read_at (bin->b, entry->paddr, b, sizeof (b)) < 0) {",
          "287:   bprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);",
          "",
          "[Added Lines]",
          "280: struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {",
          "285:  if (!pe || !pe->b) {",
          "288:  entry = PE_(r_bin_pe_get_entrypoint) (pe);",
          "290:  if (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {",
          "291:   pe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "298:  if (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {",
          "300:  }",
          "305:  if (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {",
          "307:  }",
          "",
          "[Removed Lines]",
          "299:   sw = follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 19);",
          "306:   sw = follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 16);",
          "",
          "[Added Lines]",
          "303:   sw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 19);",
          "310:   sw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 16);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "313:  if (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {",
          "315:  }",
          "316:  if (sw) {",
          "",
          "[Removed Lines]",
          "314:   sw = follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 21);",
          "",
          "[Added Lines]",
          "318:   sw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 21);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "322:   for (n = 0; n < sizeof (b) - 12; n++) {",
          "323:    if (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {",
          "325:     return entry;",
          "326:    }",
          "327:   }",
          "",
          "[Removed Lines]",
          "324:     sw = follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, n + 8);",
          "",
          "[Added Lines]",
          "328:     sw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "330:  return NULL;",
          "331: }",
          "334:  struct r_bin_pe_addr_t *entry;",
          "336:   return 0LL;",
          "337:  }",
          "338:  ut8 b[512];",
          "339:  ZERO_FILL (b);",
          "344:   free (entry);",
          "345:   return NULL;",
          "346:  }",
          "",
          "[Removed Lines]",
          "333: struct r_bin_pe_addr_t *PE_(check_unknow)(struct PE_(r_bin_pe_obj_t) *bin) {",
          "335:  if (!bin || !bin->b) {",
          "340:  entry = PE_ (r_bin_pe_get_entrypoint) (bin);",
          "342:  if (r_buf_read_at (bin->b, entry->paddr, b, 512) < 1) {",
          "343:   bprintf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);",
          "",
          "[Added Lines]",
          "337: struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {",
          "339:  if (!pe || !pe->b) {",
          "344:  entry = PE_ (r_bin_pe_get_entrypoint) (pe);",
          "346:  if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {",
          "347:   pe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "351:  if (b[367] == 0xe8) {",
          "353:   return entry;",
          "354:  }",
          "355:  size_t i;",
          "",
          "[Removed Lines]",
          "352:   follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, 367);",
          "",
          "[Added Lines]",
          "356:   follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "358:   if (!memcmp (b + i, \"\\xff\\x15\", 2)) {",
          "359:    if (b[i + 6] == 0x50) {",
          "360:     if (b[i + 7] == 0xe8) {",
          "362:      return entry;",
          "363:     }",
          "364:    }",
          "",
          "[Removed Lines]",
          "361:      follow_offset (entry, bin->b, b, sizeof (b), bin->big_endian, i + 7);",
          "",
          "[Added Lines]",
          "365:      follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "368:  return NULL;",
          "369: }",
          "373:  if (!winmain) {",
          "375:   if (!winmain) {",
          "377:   }",
          "378:  }",
          "379:  return winmain;",
          "380: }",
          "383:  PE_DWord section_base;",
          "384:  int i, section_size;",
          "386:  if (rva > image_base) {",
          "387:   rva -= image_base;",
          "388:  }",
          "392:   if (rva >= section_base && rva < section_base + section_size) {",
          "394:   }",
          "395:  }",
          "396:  return rva;",
          "397: }",
          "400:  ut64 imageBase = 0;",
          "402:   return 0LL;",
          "403:  }",
          "405:  if (!imageBase) {",
          "",
          "[Removed Lines]",
          "371: struct r_bin_pe_addr_t *PE_(r_bin_pe_get_main_vaddr)(struct PE_(r_bin_pe_obj_t) *bin) {",
          "372:  struct r_bin_pe_addr_t *winmain = PE_(check_msvcseh) (bin);",
          "374:   winmain = PE_(check_mingw) (bin);",
          "376:    winmain = PE_(check_unknow) (bin);",
          "382: R_IPI PE_DWord PE_(va2pa)(RBinPEObj* bin, PE_DWord rva) {",
          "385:  ut32 image_base = bin->nt_headers->optional_header.ImageBase;",
          "389:  for (i = 0; i < bin->num_sections; i++) {",
          "390:   section_base = bin->sections[i].vaddr;",
          "391:   section_size = bin->sections[i].vsize;",
          "393:    return bin->sections[i].paddr + (rva - section_base);",
          "399: ut64 PE_(r_bin_pe_get_image_base)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "401:  if (!bin || !bin->nt_headers) {",
          "404:  imageBase = bin->nt_headers->optional_header.ImageBase;",
          "",
          "[Added Lines]",
          "375: struct r_bin_pe_addr_t *PE_(r_bin_pe_get_main_vaddr)(RBinPEObj *pe) {",
          "376:  struct r_bin_pe_addr_t *winmain = PE_(check_msvcseh) (pe);",
          "378:   winmain = PE_(check_mingw) (pe);",
          "380:    winmain = PE_(check_unknow) (pe);",
          "386: R_API PE_DWord PE_(va2pa)(RBinPEObj* pe, PE_DWord rva) {",
          "389:  ut32 image_base = pe->nt_headers->optional_header.ImageBase;",
          "393:  for (i = 0; i < pe->num_sections; i++) {",
          "394:   section_base = pe->sections[i].vaddr;",
          "395:   section_size = pe->sections[i].vsize;",
          "397:    return pe->sections[i].paddr + (rva - section_base);",
          "403: ut64 PE_(r_bin_pe_get_image_base)(RBinPEObj* pe) {",
          "405:  if (!pe || !pe->nt_headers) {",
          "408:  imageBase = pe->nt_headers->optional_header.ImageBase;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "411:  return imageBase;",
          "412: }",
          "416: }",
          "420:  if (va < imageBase) {",
          "421:   return va;",
          "422:  }",
          "",
          "[Removed Lines]",
          "414: static PE_DWord bin_pe_rva_to_va(RBinPEObj* bin, PE_DWord rva) {",
          "415:  return PE_(r_bin_pe_get_image_base) (bin) + rva;",
          "418: static PE_DWord bin_pe_va_to_rva(RBinPEObj* bin, PE_DWord va) {",
          "419:  ut64 imageBase = PE_(r_bin_pe_get_image_base) (bin);",
          "",
          "[Added Lines]",
          "418: static PE_DWord bin_pe_rva_to_va(RBinPEObj* pe, PE_DWord rva) {",
          "419:  return PE_(r_bin_pe_get_image_base) (pe) + rva;",
          "422: static PE_DWord bin_pe_va_to_rva(RBinPEObj* pe, PE_DWord va) {",
          "423:  ut64 imageBase = PE_(r_bin_pe_get_image_base) (pe);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "435:  return NULL;",
          "436: }",
          "439:                                 struct r_bin_pe_import_t** importp, int* nimp,",
          "440:                                 const char* dll_name,",
          "441:                                 PE_DWord OriginalFirstThunk,",
          "",
          "[Removed Lines]",
          "438: static int bin_pe_parse_imports(struct PE_(r_bin_pe_obj_t)* bin,",
          "",
          "[Added Lines]",
          "442: static int bin_pe_parse_imports(RBinPEObj* pe,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "454:   return 0;",
          "455:  }",
          "459:   return 0;",
          "460:  }",
          "461:  do {",
          "462:   if (import_ordinal >= UT16_MAX) {",
          "463:    break;",
          "464:   }",
          "466:    break;",
          "467:   }",
          "469:   if (import_table == PE_DWORD_MAX) {",
          "471:    goto error;",
          "472:   } else if (import_table) {",
          "473:    if (import_table & ILT_MASK1) {",
          "",
          "[Removed Lines]",
          "457:  if (!(off = PE_(va2pa) (bin, OriginalFirstThunk)) &&",
          "458:  !(off = PE_(va2pa) (bin, FirstThunk))) {",
          "465:   if (off + i * sizeof (PE_DWord) > bin->size) {",
          "468:   import_table = R_BUF_READ_PE_DWORD_AT (bin->b, off + i * sizeof (PE_DWord));",
          "470:    bprintf (\"Warning: read (import table)\\n\");",
          "",
          "[Added Lines]",
          "461:  if (!(off = PE_(va2pa) (pe, OriginalFirstThunk)) &&",
          "462:  !(off = PE_(va2pa) (pe, FirstThunk))) {",
          "469:   if (off + i * sizeof (PE_DWord) > pe->size) {",
          "472:   import_table = R_BUF_READ_PE_DWORD_AT (pe->b, off + i * sizeof (PE_DWord));",
          "474:    pe_printf (\"Warning: read (import table)\\n\");",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "513:       R_FREE (symname);",
          "514:      }",
          "515:     } else {",
          "517:     }",
          "518:     free (filename);",
          "519:    } else {",
          "520:     import_ordinal++;",
          "524:      goto error;",
          "525:     }",
          "527:     if (import_hint == UT16_MAX) {",
          "529:      goto error;",
          "530:     }",
          "531:     name[0] = '\\0';",
          "533:     if (len < 1) {",
          "535:      goto error;",
          "536:     } else if (!*name) {",
          "537:      break;",
          "",
          "[Removed Lines]",
          "516:      bprintf (\"Cannot find %s\\n\", filename);",
          "521:     const ut64 off = PE_(va2pa) (bin, import_table);",
          "522:     if (off > bin->size || (off + sizeof (PE_Word)) > bin->size) {",
          "523:      bprintf (\"Warning: off > bin->size\\n\");",
          "526:     import_hint = r_buf_read_le16_at (bin->b, off);",
          "528:      bprintf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);",
          "532:     len = r_buf_read_at (bin->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);",
          "534:      bprintf (\"Warning: read (import name)\\n\");",
          "",
          "[Added Lines]",
          "520:      pe_printf (\"Cannot find %s\\n\", filename);",
          "525:     const ut64 off = PE_(va2pa) (pe, import_table);",
          "526:     if (off > pe->size || (off + sizeof (PE_Word)) > pe->size) {",
          "527:      pe_printf (\"Warning: off > pe->size\\n\");",
          "530:     import_hint = r_buf_read_le16_at (pe->b, off);",
          "532:      pe_printf (\"Warning: read import hint at 0x%08\"PFMT64x \"\\n\", off);",
          "536:     len = r_buf_read_at (pe->b, off + sizeof (PE_Word), (ut8*) name, PE_NAME_LENGTH);",
          "538:      pe_printf (\"Warning: read (import name)\\n\");",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "552:    (*importp)[*nimp].name[PE_NAME_LENGTH] = '\\0';",
          "553:    memcpy ((*importp)[*nimp].libname, dll_name, PE_NAME_LENGTH);",
          "554:    (*importp)[*nimp].libname[PE_NAME_LENGTH] = '\\0';",
          "557:    (*importp)[*nimp].hint = import_hint;",
          "558:    (*importp)[*nimp].ordinal = import_ordinal;",
          "559:    (*importp)[*nimp].last = 0;",
          "",
          "[Removed Lines]",
          "555:    (*importp)[*nimp].vaddr = bin_pe_rva_to_va (bin, FirstThunk + i * sizeof (PE_DWord));",
          "556:    (*importp)[*nimp].paddr = PE_(va2pa) (bin, FirstThunk) + i * sizeof (PE_DWord);",
          "",
          "[Added Lines]",
          "559:    (*importp)[*nimp].vaddr = bin_pe_rva_to_va (pe, FirstThunk + i * sizeof (PE_DWord));",
          "560:    (*importp)[*nimp].paddr = PE_(va2pa) (pe, FirstThunk) + i * sizeof (PE_DWord);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "680:  return sizeof (PE_(image_nt_headers));",
          "681: }",
          "685:   r_sys_perror (\"malloc (dos header)\");",
          "686:   return false;",
          "687:  }",
          "690:   return false;",
          "691:  }",
          "694:   \" e_magic e_cblp e_cp e_crlc e_cparhdr e_minalloc e_maxalloc\"",
          "695:   \" e_ss e_sp e_csum e_ip e_cs e_lfarlc e_ovno e_res e_oemid\"",
          "696:   \" e_oeminfo e_res2 e_lfanew\", 0);",
          "699:   return false;",
          "700:  }",
          "702:   r_sys_perror (\"malloc (nt header)\");",
          "703:   return false;",
          "704:  }",
          "708:   return false;",
          "709:  }",
          "712:   \" IMAGE_SUBSYSTEM_WINDOWS_CUI=3, IMAGE_SUBSYSTEM_OS2_CUI=5, IMAGE_SUBSYSTEM_POSIX_CUI=7, IMAGE_SUBSYSTEM_WINDOWS_CE_GUI=9, \"",
          "713:   \" IMAGE_SUBSYSTEM_EFI_APPLICATION=10, IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER=11, IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER=12, \"",
          "714:   \" IMAGE_SUBSYSTEM_EFI_ROM=13, IMAGE_SUBSYSTEM_XBOX=14, IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION=16 };\", 0);",
          "716:   \" IMAGE_LIBRARY_THREAD_INIT=0x0004, IMAGE_LIBRARY_THREAD_TERM=0x0008, IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA=0x0020, \"",
          "717:   \" IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE=0x0040, IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY=0x0080, \"",
          "718:   \" IMAGE_DLLCHARACTERISTICS_NX_COMPAT=0x0100, IMAGE_DLLCHARACTERISTICS_NO_ISOLATION=0x0200,IMAGE_DLLCHARACTERISTICS_NO_SEH=0x0400, \"",
          "719:   \" IMAGE_DLLCHARACTERISTICS_NO_BIND=0x0800, IMAGE_DLLCHARACTERISTICS_APPCONTAINER=0x1000, IMAGE_DLLCHARACTERISTICS_WDM_DRIVER=0x2000, \"",
          "720:   \" IMAGE_DLLCHARACTERISTICS_GUARD_CF=0x4000, IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE=0x8000};\", 0);",
          "721: #if R_BIN_PE64",
          "725:   \" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"",
          "726:   \" sizeOfUninitializedData addressOfEntryPoint baseOfCode imageBase\"",
          "727:   \" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"",
          "",
          "[Removed Lines]",
          "683: static int bin_pe_init_hdr(struct PE_(r_bin_pe_obj_t)* bin) {",
          "684:  if (!(bin->dos_header = malloc (sizeof (PE_(image_dos_header))))) {",
          "688:  if (PE_(read_dos_header) (bin->b, bin->dos_header) < 0) {",
          "689:   bprintf (\"Warning: read (dos header)\\n\");",
          "692:  sdb_num_set (bin->kv, \"pe_dos_header.offset\", 0, 0);",
          "693:  sdb_set (bin->kv, \"pe_dos_header.format\", \"[2]zwwwwwwwwwwwww[4]www[10]wx\"",
          "697:  if (bin->dos_header->e_lfanew > (unsigned int) bin->size) {",
          "698:   bprintf (\"Invalid e_lfanew field\\n\");",
          "701:  if (!(bin->nt_headers = malloc (sizeof (PE_(image_nt_headers))))) {",
          "705:  bin->nt_header_offset = bin->dos_header->e_lfanew;",
          "706:  if (PE_(read_nt_headers) (bin->b, bin->dos_header->e_lfanew, bin->nt_headers) < 0) {",
          "707:   bprintf (\"Warning: read (nt header)\\n\");",
          "710:  sdb_set (bin->kv, \"pe_magic.cparse\",     \"enum pe_magic { IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b, IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b, IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107 };\", 0);",
          "711:  sdb_set (bin->kv, \"pe_subsystem.cparse\", \"enum pe_subsystem { IMAGE_SUBSYSTEM_UNKNOWN=0, IMAGE_SUBSYSTEM_NATIVE=1, IMAGE_SUBSYSTEM_WINDOWS_GUI=2, \"",
          "715:  sdb_set (bin->kv, \"pe_dllcharacteristics.cparse\", \"enum pe_dllcharacteristics { IMAGE_LIBRARY_PROCESS_INIT=0x0001, IMAGE_LIBRARY_PROCESS_TERM=0x0002, \"",
          "722:  sdb_num_set (bin->kv, \"pe_nt_image_headers64.offset\", bin->dos_header->e_lfanew, 0);",
          "723:  sdb_set (bin->kv, \"pe_nt_image_headers64.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header64)optionalHeader\", 0);",
          "724:  sdb_set (bin->kv, \"pe_image_optional_header64.format\", \"[2]Ebbxxxxxqxxwwwwwwxxxx[2]E[2]Bqqqqxx[16]?\"",
          "",
          "[Added Lines]",
          "687: static int bin_pe_init_hdr(RBinPEObj* pe) {",
          "688:  if (!(pe->dos_header = malloc (sizeof (PE_(image_dos_header))))) {",
          "692:  if (PE_(read_dos_header) (pe->b, pe->dos_header) < 0) {",
          "693:   pe_printf (\"Warning: read (dos header)\\n\");",
          "696:  sdb_num_set (pe->kv, \"pe_dos_header.offset\", 0, 0);",
          "697:  sdb_set (pe->kv, \"pe_dos_header.format\", \"[2]zwwwwwwwwwwwww[4]www[10]wx\"",
          "701:  if (pe->dos_header->e_lfanew > (unsigned int) pe->size) {",
          "702:   pe_printf (\"Invalid e_lfanew field\\n\");",
          "705:  if (!(pe->nt_headers = malloc (sizeof (PE_(image_nt_headers))))) {",
          "709:  pe->nt_header_offset = pe->dos_header->e_lfanew;",
          "710:  if (PE_(read_nt_headers) (pe->b, pe->dos_header->e_lfanew, pe->nt_headers) < 0) {",
          "711:   pe_printf (\"Warning: read (nt header)\\n\");",
          "714:  sdb_set (pe->kv, \"pe_magic.cparse\",     \"enum pe_magic { IMAGE_NT_OPTIONAL_HDR32_MAGIC=0x10b, IMAGE_NT_OPTIONAL_HDR64_MAGIC=0x20b, IMAGE_ROM_OPTIONAL_HDR_MAGIC=0x107 };\", 0);",
          "715:  sdb_set (pe->kv, \"pe_subsystem.cparse\", \"enum pe_subsystem { IMAGE_SUBSYSTEM_UNKNOWN=0, IMAGE_SUBSYSTEM_NATIVE=1, IMAGE_SUBSYSTEM_WINDOWS_GUI=2, \"",
          "719:  sdb_set (pe->kv, \"pe_dllcharacteristics.cparse\", \"enum pe_dllcharacteristics { IMAGE_LIBRARY_PROCESS_INIT=0x0001, IMAGE_LIBRARY_PROCESS_TERM=0x0002, \"",
          "726:  sdb_num_set (pe->kv, \"pe_nt_image_headers64.offset\", pe->dos_header->e_lfanew, 0);",
          "727:  sdb_set (pe->kv, \"pe_nt_image_headers64.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header64)optionalHeader\", 0);",
          "728:  sdb_set (pe->kv, \"pe_image_optional_header64.format\", \"[2]Ebbxxxxxqxxwwwwwwxxxx[2]E[2]Bqqqqxx[16]?\"",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "730:   \" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags\"",
          "731:   \" numberOfRvaAndSizes (pe_image_data_directory)dataDirectory\", 0);",
          "732: #else",
          "736:   \" (pe_magic)magic majorLinkerVersion minorLinkerVersion sizeOfCode sizeOfInitializedData\"",
          "737:   \" sizeOfUninitializedData addressOfEntryPoint baseOfCode baseOfData imageBase\"",
          "738:   \" sectionAlignment fileAlignment majorOperatingSystemVersion minorOperatingSystemVersion\"",
          "",
          "[Removed Lines]",
          "733:  sdb_num_set (bin->kv, \"pe_nt_image_headers32.offset\", bin->dos_header->e_lfanew, 0);",
          "734:  sdb_set (bin->kv, \"pe_nt_image_headers32.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header32)optionalHeader\", 0);",
          "735:  sdb_set (bin->kv, \"pe_image_optional_header32.format\", \"[2]Ebbxxxxxxxxxwwwwwwxxxx[2]E[2]Bxxxxxx[16]?\"",
          "",
          "[Added Lines]",
          "737:  sdb_num_set (pe->kv, \"pe_nt_image_headers32.offset\", pe->dos_header->e_lfanew, 0);",
          "738:  sdb_set (pe->kv, \"pe_nt_image_headers32.format\",      \"[4]z?? signature (pe_image_file_header)fileHeader (pe_image_optional_header32)optionalHeader\", 0);",
          "739:  sdb_set (pe->kv, \"pe_image_optional_header32.format\", \"[2]Ebbxxxxxxxxxwwwwwwxxxx[2]E[2]Bxxxxxx[16]?\"",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "741:   \" sizeOfStackReserve sizeOfStackCommit sizeOfHeapReserve sizeOfHeapCommit loaderFlags numberOfRvaAndSizes\"",
          "742:   \" (pe_image_data_directory)dataDirectory\", 0);",
          "743: #endif",
          "746:   \" IMAGE_FILE_RELOCS_STRIPPED=0x0001, IMAGE_FILE_EXECUTABLE_IMAGE=0x0002, IMAGE_FILE_LINE_NUMS_STRIPPED=0x0004, \"",
          "747:   \" IMAGE_FILE_LOCAL_SYMS_STRIPPED=0x0008, IMAGE_FILE_AGGRESIVE_WS_TRIM=0x0010, IMAGE_FILE_LARGE_ADDRESS_AWARE=0x0020, \"",
          "748:   \" IMAGE_FILE_BYTES_REVERSED_LO=0x0080, IMAGE_FILE_32BIT_MACHINE=0x0100, IMAGE_FILE_DEBUG_STRIPPED=0x0200, \"",
          "749:   \" IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP=0x0400, IMAGE_FILE_NET_RUN_FROM_SWAP=0x0800, IMAGE_FILE_SYSTEM=0x1000, \"",
          "750:   \" IMAGE_FILE_DLL=0x2000, IMAGE_FILE_UP_SYSTEM_ONLY=0x4000, IMAGE_FILE_BYTES_REVERSED_HI=0x8000 };\", 0);",
          "752:   \" (pe_machine)machine numberOfSections timeDateStamp pointerToSymbolTable\"",
          "753:   \" numberOfSymbols sizeOfOptionalHeader (pe_characteristics)characteristics\", 0);",
          "757:  {",
          "761:  }",
          "769:   return false;",
          "770:  }",
          "771:  return true;",
          "",
          "[Removed Lines]",
          "744:  sdb_set (bin->kv, \"pe_machine.cparse\",         \"enum pe_machine { IMAGE_FILE_MACHINE_I386=0x014c, IMAGE_FILE_MACHINE_IA64=0x0200, IMAGE_FILE_MACHINE_AMD64=0x8664 };\", 0);",
          "745:  sdb_set (bin->kv, \"pe_characteristics.cparse\", \"enum pe_characteristics { \"",
          "751:  sdb_set (bin->kv, \"pe_image_file_header.format\",    \"[2]Ewtxxw[2]B\"",
          "754:  sdb_set (bin->kv, \"pe_image_data_directory.format\", \"xx virtualAddress size\",0);",
          "758:   sdb_num_set (bin->kv, \"image_file_header.TimeDateStamp\", bin->nt_headers->file_header.TimeDateStamp, 0);",
          "759:   char *timestr = r_time_stamp_to_str (bin->nt_headers->file_header.TimeDateStamp);",
          "760:   sdb_set_owned (bin->kv, \"image_file_header.TimeDateStamp_string\", timestr, 0);",
          "762:  bin->optional_header = &bin->nt_headers->optional_header;",
          "763:  bin->data_directory = (PE_(image_data_directory*)) & bin->optional_header->DataDirectory;",
          "765:  if (bin->dos_header->e_magic != 0x5a4d || // \"MZ\"",
          "766:   (bin->nt_headers->Signature != 0x4550 && // \"PE\"",
          "768:   bin->nt_headers->Signature != 0x4c50)) { // \"PL\"",
          "",
          "[Added Lines]",
          "748:  sdb_set (pe->kv, \"pe_machine.cparse\",         \"enum pe_machine { IMAGE_FILE_MACHINE_I386=0x014c, IMAGE_FILE_MACHINE_IA64=0x0200, IMAGE_FILE_MACHINE_AMD64=0x8664 };\", 0);",
          "749:  sdb_set (pe->kv, \"pe_characteristics.cparse\", \"enum pe_characteristics { \"",
          "755:  sdb_set (pe->kv, \"pe_image_file_header.format\",    \"[2]Ewtxxw[2]B\"",
          "758:  sdb_set (pe->kv, \"pe_image_data_directory.format\", \"xx virtualAddress size\",0);",
          "762:   sdb_num_set (pe->kv, \"image_file_header.TimeDateStamp\", pe->nt_headers->file_header.TimeDateStamp, 0);",
          "763:   char *timestr = r_time_stamp_to_str (pe->nt_headers->file_header.TimeDateStamp);",
          "764:   sdb_set_owned (pe->kv, \"image_file_header.TimeDateStamp_string\", timestr, 0);",
          "766:  pe->optional_header = &pe->nt_headers->optional_header;",
          "767:  pe->data_directory = (PE_(image_data_directory*)) & pe->optional_header->DataDirectory;",
          "769:  if (pe->dos_header->e_magic != 0x5a4d || // \"MZ\"",
          "770:   (pe->nt_headers->Signature != 0x4550 && // \"PE\"",
          "772:   pe->nt_headers->Signature != 0x4c50)) { // \"PL\"",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "780:  ut8 numaux;",
          "781: } SymbolRecord;",
          "784:  ut64 sym_tbl_off, num = 0;",
          "785:  const int srsz = COFF_SYMBOL_SIZE; // symbol record size",
          "786:  struct r_bin_pe_section_t* sections;",
          "",
          "[Removed Lines]",
          "783: static struct r_bin_pe_export_t* parse_symbol_table(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_pe_export_t* exports, int sz) {",
          "",
          "[Added Lines]",
          "787: static struct r_bin_pe_export_t* parse_symbol_table(RBinPEObj* pe, struct r_bin_pe_export_t* exports, int sz) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "796:  int symctr = 0;",
          "797:  char* buf;",
          "800:   return NULL;",
          "801:  }",
          "805:  shsz = bufsz = num * srsz;",
          "807:   return NULL;",
          "808:  }",
          "809:  buf = calloc (num, srsz);",
          "",
          "[Removed Lines]",
          "799:  if (!bin || !bin->nt_headers) {",
          "803:  sym_tbl_off = bin->nt_headers->file_header.PointerToSymbolTable;",
          "804:  num = bin->nt_headers->file_header.NumberOfSymbols;",
          "806:  if (bufsz < 1 || bufsz > bin->size) {",
          "",
          "[Added Lines]",
          "803:  if (!pe || !pe->nt_headers) {",
          "807:  sym_tbl_off = pe->nt_headers->file_header.PointerToSymbolTable;",
          "808:  num = pe->nt_headers->file_header.NumberOfSymbols;",
          "810:  if (bufsz < 1 || bufsz > pe->size) {",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "828:   exp = exports;",
          "829:  }",
          "834:   if (!strcmp ((char*) sections[i].name, \".text\")) {",
          "835:    text_rva = sections[i].vaddr;",
          "",
          "[Removed Lines]",
          "831:  sections = bin->sections;",
          "832:  for (i = 0; i < bin->num_sections; i++) {",
          "",
          "[Added Lines]",
          "835:  sections = pe->sections;",
          "836:  for (i = 0; i < pe->num_sections; i++) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "838:   }",
          "839:  }",
          "840:  symctr = 0;",
          "842:   for (i = 0; i < shsz; i += srsz) {",
          "844:    if (i + sizeof (sr) >= bufsz) {",
          "845:     break;",
          "846:    }",
          "847:    memcpy (&sr, buf + i, sizeof (sr));",
          "849:    if (sr.secnum == textn) {",
          "850:     if (sr.symtype == 32) {",
          "851:      char shortname[9];",
          "",
          "[Removed Lines]",
          "841:  if (r_buf_read_at (bin->b, sym_tbl_off, (ut8*) buf, bufsz) > 0) {",
          "",
          "[Added Lines]",
          "845:  if (r_buf_read_at (pe->b, sym_tbl_off, (ut8*) buf, bufsz) > 0) {",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "856:      } else {",
          "857:       char* longname, name[128];",
          "858:       ut32 idx = r_read_le32 (buf + i + 4);",
          "860:        longname = name;",
          "861:        name[sizeof (name) - 1] = 0;",
          "862:        strncpy ((char*) exp[symctr].name, longname, PE_NAME_LENGTH - 1);",
          "",
          "[Removed Lines]",
          "859:       if (r_buf_read_at (bin->b, sym_tbl_off + idx + shsz, (ut8*) name, 128)) { // == 128) {",
          "",
          "[Added Lines]",
          "863:       if (r_buf_read_at (pe->b, sym_tbl_off + idx + shsz, (ut8*) name, 128)) { // == 128) {",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "866:      }",
          "867:      exp[symctr].name[PE_NAME_LENGTH] = '\\0';",
          "868:      exp[symctr].libname[0] = '\\0';",
          "870:      exp[symctr].paddr = text_off + sr.value;",
          "871:      exp[symctr].ordinal = symctr;",
          "872:      exp[symctr].forwarder[0] = 0;",
          "",
          "[Removed Lines]",
          "869:      exp[symctr].vaddr = bin_pe_rva_to_va (bin, text_rva + sr.value);",
          "",
          "[Added Lines]",
          "873:      exp[symctr].vaddr = bin_pe_rva_to_va (pe, text_rva + sr.value);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "919:  r_buf_write_at (b, addr, buf, sizeof (PE_(image_section_header)));",
          "920: }",
          "926:   return true;",
          "927:  }",
          "935:  }",
          "937:   r_sys_perror (\"malloc (section header)\");",
          "938:   goto out_error;",
          "939:  }",
          "942:  int i;",
          "948:    goto out_error;",
          "949:   }",
          "950:  }",
          "",
          "[Removed Lines]",
          "922: static struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(struct PE_(r_bin_pe_obj_t)* bin);",
          "923: static int bin_pe_init_sections(struct PE_(r_bin_pe_obj_t)* bin) {",
          "924:  bin->num_sections = bin->nt_headers->file_header.NumberOfSections;",
          "925:  if (bin->num_sections < 1) {",
          "928:  int sections_size = sizeof (PE_(image_section_header)) * bin->num_sections;",
          "929:  if (sections_size > bin->size) {",
          "930:   sections_size = bin->size;",
          "931:   bin->num_sections = bin->size / sizeof (PE_(image_section_header));",
          "936:  if (!(bin->section_header = malloc (sections_size))) {",
          "940:  bin->section_header_offset = bin->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) +",
          "941:   bin->nt_headers->file_header.SizeOfOptionalHeader;",
          "943:  for (i = 0; i < bin->num_sections; i++) {",
          "944:   if (PE_(read_image_section_header) (bin->b, bin->section_header_offset + i * sizeof (PE_(image_section_header)),",
          "945:    bin->section_header + i) < 0) {",
          "946:    bprintf (\"Warning: read (sections)\\n\");",
          "947:    R_FREE (bin->section_header);",
          "",
          "[Added Lines]",
          "926: static struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(RBinPEObj* pe);",
          "927: static int bin_pe_init_sections(RBinPEObj* pe) {",
          "928:  pe->num_sections = pe->nt_headers->file_header.NumberOfSections;",
          "929:  if (pe->num_sections < 1) {",
          "932:  int sections_size = sizeof (PE_(image_section_header)) * pe->num_sections;",
          "933:  if (sections_size > pe->size) {",
          "934:   sections_size = pe->size;",
          "935:   pe->num_sections = pe->size / sizeof (PE_(image_section_header));",
          "940:  if (!(pe->section_header = malloc (sections_size))) {",
          "944:  pe->section_header_offset = pe->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) +",
          "945:   pe->nt_headers->file_header.SizeOfOptionalHeader;",
          "947:  for (i = 0; i < pe->num_sections; i++) {",
          "948:   if (PE_(read_image_section_header) (pe->b, pe->section_header_offset + i * sizeof (PE_(image_section_header)),",
          "949:    pe->section_header + i) < 0) {",
          "950:    pe_printf (\"Warning: read (sections)\\n\");",
          "951:    R_FREE (pe->section_header);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "988: #endif",
          "989:  return true;",
          "990: out_error:",
          "992:  return false;",
          "993: }",
          "997:   return 0;",
          "998:  }",
          "1000: }",
          "1003:  size_t i, j, checksum_offset = 0;",
          "1004:  ut64 computed_cs = 0;",
          "1005:  int remaining_bytes;",
          "1006:  int shift;",
          "1007:  ut32 cur;",
          "1009:   return 0;",
          "1010:  }",
          "1011:  const size_t buf_sz = 0x1000;",
          "",
          "[Removed Lines]",
          "991:  bin->num_sections = 0;",
          "995: int PE_(bin_pe_get_claimed_checksum)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "996:  if (!bin || !bin->optional_header) {",
          "999:  return bin->optional_header->CheckSum;",
          "1002: int PE_(bin_pe_get_actual_checksum)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1008:  if (!bin || !bin->nt_header_offset) {",
          "",
          "[Added Lines]",
          "995:  pe->num_sections = 0;",
          "999: int PE_(bin_pe_get_claimed_checksum)(RBinPEObj* pe) {",
          "1000:  if (!pe || !pe->optional_header) {",
          "1003:  return pe->optional_header->CheckSum;",
          "1006: int PE_(bin_pe_get_actual_checksum)(RBinPEObj* pe) {",
          "1012:  if (!pe || !pe->nt_header_offset) {",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1013:  if (!buf) {",
          "1014:   return 0;",
          "1015:  }",
          "1017:   free (buf);",
          "1018:   return 0;",
          "1019:  }",
          "1023:   j++;",
          "1025:   if (i * 4 == checksum_offset) {",
          "",
          "[Removed Lines]",
          "1016:  if (r_buf_read_at (bin->b, 0, (ut8 *)buf, buf_sz) < 0) {",
          "1020:  checksum_offset = bin->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;",
          "1021:  for (i = 0, j = 0; i < bin->size / 4; i++) {",
          "1022:   cur = r_read_at_ble32 (buf, j * 4, bin->endian);",
          "",
          "[Added Lines]",
          "1020:  if (r_buf_read_at (pe->b, 0, (ut8 *)buf, buf_sz) < 0) {",
          "1024:  checksum_offset = pe->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;",
          "1025:  for (i = 0, j = 0; i < pe->size / 4; i++) {",
          "1026:   cur = r_read_at_ble32 (buf, j * 4, pe->endian);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1031:    computed_cs = (computed_cs & 0xFFFFFFFF) + (computed_cs >> 32);",
          "1032:   }",
          "1033:   if (j == buf_sz / 4) {",
          "1035:     break;",
          "1036:    }",
          "1037:    j = 0;",
          "",
          "[Removed Lines]",
          "1034:    if (r_buf_read_at (bin->b, (i + 1) * 4, (ut8 *)buf, buf_sz) < 0) {",
          "",
          "[Added Lines]",
          "1038:    if (r_buf_read_at (pe->b, (i + 1) * 4, (ut8 *)buf, buf_sz) < 0) {",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1039:  }",
          "1043:  i = i * 4;",
          "1044:  if (remaining_bytes != 0) {",
          "1046:   shift = 8;",
          "1047:   for (j = 1; j < remaining_bytes; j++, shift += 8) {",
          "1049:   }",
          "1050:   computed_cs = (computed_cs & 0xFFFFFFFF) + cur + (computed_cs >> 32);",
          "1051:   if (computed_cs >> 32) {",
          "",
          "[Removed Lines]",
          "1042:  remaining_bytes = bin->size % 4;",
          "1045:   cur = r_buf_read8_at (bin->b, i);",
          "1048:    cur |= r_buf_read8_at (bin->b, i + j) << shift;",
          "",
          "[Added Lines]",
          "1046:  remaining_bytes = pe->size % 4;",
          "1049:   cur = r_buf_read8_at (pe->b, i);",
          "1052:    cur |= r_buf_read8_at (pe->b, i + j) << shift;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1059:  computed_cs = (computed_cs & 0xFFFF);",
          "1063:  free (buf);",
          "1064:  return computed_cs;",
          "1065: }",
          "1069:   return NULL;",
          "1070:  }",
          "1072:  return digest? r_hex_bin2strdup (digest->binary, digest->length): NULL;",
          "1073: }",
          "1077:   return NULL;",
          "1078:  }",
          "1081:  r_str_replace_char (hashtype, '-', 0);",
          "1082:  ut64 algobit = r_hash_name_to_bits (hashtype);",
          "1083:  if (!(algobit & (R_HASH_MD5 | R_HASH_SHA1 | R_HASH_SHA256))) {",
          "",
          "[Removed Lines]",
          "1062:  computed_cs += bin->size;",
          "1067: static const char* PE_(bin_pe_get_claimed_authentihash)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1068:  if (!bin->spcinfo) {",
          "1071:  RASN1Binary *digest = bin->spcinfo->messageDigest.digest;",
          "1075: const char* PE_(bin_pe_compute_authentihash)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1076:  if (!bin->spcinfo || !bin->spcinfo->messageDigest.digestAlgorithm.algorithm) {",
          "1080:  char *hashtype = strdup (bin->spcinfo->messageDigest.digestAlgorithm.algorithm->string);",
          "",
          "[Added Lines]",
          "1066:  computed_cs += pe->size;",
          "1071: static const char* PE_(bin_pe_get_claimed_authentihash)(RBinPEObj* pe) {",
          "1072:  if (!pe->spcinfo) {",
          "1075:  RASN1Binary *digest = pe->spcinfo->messageDigest.digest;",
          "1079: const char* PE_(bin_pe_compute_authentihash)(RBinPEObj* pe) {",
          "1080:  if (!pe->spcinfo || !pe->spcinfo->messageDigest.digestAlgorithm.algorithm) {",
          "1084:  char *hashtype = strdup (pe->spcinfo->messageDigest.digestAlgorithm.algorithm->string);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1086:   return NULL;",
          "1087:  }",
          "1088:  free (hashtype);",
          "1092:  PE_DWord security_dir_offset = data_dir_security->VirtualAddress;",
          "1093:  ut32 security_dir_size = data_dir_security->Size;",
          "1095:  RBuffer *buf = r_buf_new ();",
          "1098:   checksum_paddr + 4,",
          "1099:   security_entry_offset - checksum_paddr - 4);",
          "1101:   security_entry_offset + 8,",
          "1102:   security_dir_offset - security_entry_offset - 8);",
          "1104:   security_dir_offset + security_dir_size,",
          "1107:  ut64 len;",
          "1108:  const ut8 *data = r_buf_data (buf, &len);",
          "",
          "[Removed Lines]",
          "1089:  ut32 checksum_paddr = bin->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;",
          "1090:  ut32 security_entry_offset =  bin->nt_header_offset + sizeof (PE_(image_nt_headers)) - 96;",
          "1091:  PE_(image_data_directory) *data_dir_security = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];",
          "1096:  r_buf_append_buf_slice (buf, bin->b, 0, checksum_paddr);",
          "1097:  r_buf_append_buf_slice (buf, bin->b,",
          "1100:  r_buf_append_buf_slice (buf, bin->b,",
          "1103:  r_buf_append_buf_slice (buf, bin->b,",
          "1105:   r_buf_size (bin->b) - security_dir_offset - security_dir_size);",
          "",
          "[Added Lines]",
          "1093:  ut32 checksum_paddr = pe->nt_header_offset + 4 + sizeof (PE_(image_file_header)) + 0x40;",
          "1094:  ut32 security_entry_offset =  pe->nt_header_offset + sizeof (PE_(image_nt_headers)) - 96;",
          "1095:  PE_(image_data_directory) *data_dir_security = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];",
          "1100:  r_buf_append_buf_slice (buf, pe->b, 0, checksum_paddr);",
          "1101:  r_buf_append_buf_slice (buf, pe->b,",
          "1104:  r_buf_append_buf_slice (buf, pe->b,",
          "1107:  r_buf_append_buf_slice (buf, pe->b,",
          "1109:   r_buf_size (pe->b) - security_dir_offset - security_dir_size);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1119:  return hashstr;",
          "1120: }",
          "1124: }",
          "1128: }",
          "1130: static void computeOverlayOffset(ut64 offset, ut64 size, ut64 file_size, ut64* largest_offset, ut64* largest_size) {",
          "",
          "[Removed Lines]",
          "1122: const char* PE_(bin_pe_get_authentihash)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1123:  return bin->authentihash;",
          "1126: int PE_(bin_pe_is_authhash_valid)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1127:  return bin? bin->is_authhash_valid: false;",
          "",
          "[Added Lines]",
          "1126: const char* PE_(bin_pe_get_authentihash)(RBinPEObj* pe) {",
          "1127:  return pe->authentihash;",
          "1130: int PE_(bin_pe_is_authhash_valid)(RBinPEObj* pe) {",
          "1131:  return pe? pe->is_authhash_valid: false;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1135: }",
          "1139:  ut64 largest_offset = 0;",
          "1140:  ut64 largest_size = 0;",
          "1142:  int i;",
          "1145:   return 0;",
          "1146:  }",
          "1149:   computeOverlayOffset (",
          "1153:     &largest_offset,",
          "1154:     &largest_size);",
          "1155:  }",
          "1158:  for (i = 0; !sects[i].last; i++) {",
          "1159:   computeOverlayOffset(",
          "1160:     sects[i].paddr,",
          "1161:     sects[i].size,",
          "1163:     &largest_offset,",
          "1164:     &largest_size",
          "1165:     );",
          "1166:  }",
          "1169:   for (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES; i++) {",
          "1170:    if (i == PE_IMAGE_DIRECTORY_ENTRY_SECURITY) {",
          "1171:     continue;",
          "1172:    }",
          "1174:    computeOverlayOffset (",
          "1178:     &largest_offset,",
          "1179:     &largest_size);",
          "1180:   }",
          "1182:  }",
          "1186:   return largest_offset + largest_size;",
          "1187:  }",
          "1188:  return 0;",
          "",
          "[Removed Lines]",
          "1138: int PE_(bin_pe_get_overlay)(struct PE_(r_bin_pe_obj_t)* bin, ut64* size) {",
          "1144:  if (!bin) {",
          "1148:  if (bin->optional_header) {",
          "1150:     bin->nt_header_offset+4+sizeof (bin->nt_headers->file_header),",
          "1151:     bin->nt_headers->file_header.SizeOfOptionalHeader,",
          "1152:     bin->size,",
          "1157:  struct r_bin_pe_section_t *sects = bin->sections;",
          "1162:     bin->size,",
          "1168:  if (bin->optional_header) {",
          "1175:     PE_(va2pa) (bin, bin->data_directory[i].VirtualAddress),",
          "1176:     bin->data_directory[i].Size,",
          "1177:     bin->size,",
          "1184:  if ((ut64) bin->size > largest_offset + largest_size) {",
          "",
          "[Added Lines]",
          "1142: int PE_(bin_pe_get_overlay)(RBinPEObj* pe, ut64* size) {",
          "1148:  if (!pe) {",
          "1152:  if (pe->optional_header) {",
          "1154:     pe->nt_header_offset+4+sizeof (pe->nt_headers->file_header),",
          "1155:     pe->nt_headers->file_header.SizeOfOptionalHeader,",
          "1156:     pe->size,",
          "1161:  struct r_bin_pe_section_t *sects = pe->sections;",
          "1166:     pe->size,",
          "1172:  if (pe->optional_header) {",
          "1179:     PE_(va2pa) (pe, pe->data_directory[i].VirtualAddress),",
          "1180:     pe->data_directory[i].Size,",
          "1181:     pe->size,",
          "1188:  if ((ut64) pe->size > largest_offset + largest_size) {",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1202:  return covered;",
          "1203: }",
          "1206:  PE_(image_metadata_header) * metadata = R_NEW0 (PE_(image_metadata_header));",
          "1207:  if (!metadata) {",
          "1208:   return false;",
          "1209:  }",
          "1211:  if (!metadata_directory) {",
          "1212:   free (metadata);",
          "1213:   return false;",
          "1214:  }",
          "1217:  if (rr < 1) {",
          "1218:   goto fail;",
          "1219:  }",
          "1223:  if (rr < 1) {",
          "1224:   goto fail;",
          "1225:  }",
          "1229:  if (rr < 1) {",
          "1230:   goto fail;",
          "1231:  }",
          "",
          "[Removed Lines]",
          "1205: static bool bin_pe_init_metadata_hdr(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1210:  PE_DWord metadata_directory = bin->clr_hdr? PE_(va2pa) (bin, bin->clr_hdr->MetaDataDirectoryAddress): 0;",
          "1215:  int rr = r_buf_fread_at (bin->b, metadata_directory,",
          "1216:   (ut8*) metadata, bin->big_endian? \"1I2S\": \"1i2s\", 1);",
          "1221:  rr = r_buf_fread_at (bin->b, metadata_directory + 8,",
          "1222:   (ut8*) (&metadata->Reserved), bin->big_endian? \"1I\": \"1i\", 1);",
          "1227:  rr = r_buf_fread_at (bin->b, metadata_directory + 12,",
          "1228:   (ut8*) (&metadata->VersionStringLength), bin->big_endian? \"1I\": \"1i\", 1);",
          "",
          "[Added Lines]",
          "1209: static bool bin_pe_init_metadata_hdr(RBinPEObj* pe) {",
          "1214:  PE_DWord metadata_directory = pe->clr_hdr? PE_(va2pa) (pe, pe->clr_hdr->MetaDataDirectoryAddress): 0;",
          "1219:  int rr = r_buf_fread_at (pe->b, metadata_directory,",
          "1220:   (ut8*) metadata, pe->big_endian? \"1I2S\": \"1i2s\", 1);",
          "1225:  rr = r_buf_fread_at (pe->b, metadata_directory + 8,",
          "1226:   (ut8*) (&metadata->Reserved), pe->big_endian? \"1I\": \"1i\", 1);",
          "1231:  rr = r_buf_fread_at (pe->b, metadata_directory + 12,",
          "1232:   (ut8*) (&metadata->VersionStringLength), pe->big_endian? \"1I\": \"1i\", 1);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1241:    goto fail;",
          "1242:   }",
          "1245:   if (rr != len) {",
          "1246:    eprintf (\"Warning: read (metadata header) - cannot parse version string\\n\");",
          "1247:    free (metadata->VersionString);",
          "",
          "[Removed Lines]",
          "1244:   rr = r_buf_read_at (bin->b, metadata_directory + 16, (ut8*)(metadata->VersionString), len);",
          "",
          "[Added Lines]",
          "1248:   rr = r_buf_read_at (pe->b, metadata_directory + 16, (ut8*)(metadata->VersionString), len);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1252:  }",
          "1258:  if (rr < 1) {",
          "1259:   goto fail;",
          "1260:  }",
          "1262:  eprintf (\"Number of Metadata Streams: %d\\n\", metadata->NumberOfStreams);",
          "",
          "[Removed Lines]",
          "1255:  rr = r_buf_fread_at (bin->b, metadata_directory + 16 + metadata->VersionStringLength,",
          "1256:   (ut8*) (&metadata->Flags), bin->big_endian? \"2S\": \"2s\", 1);",
          "1263:  bin->metadata_header = metadata;",
          "",
          "[Added Lines]",
          "1259:  rr = r_buf_fread_at (pe->b, metadata_directory + 16 + metadata->VersionStringLength,",
          "1260:   (ut8*) (&metadata->Flags), pe->big_endian? \"2S\": \"2s\", 1);",
          "1267:  pe->metadata_header = metadata;",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1277:    free (streams);",
          "1278:    goto fail;",
          "1279:   }",
          "1281:    eprintf (\"Truncated\\n\");",
          "1282:    free (stream);",
          "1283:    free (streams);",
          "1284:    goto fail;",
          "1285:   }",
          "1287:    free (stream);",
          "1288:    free (streams);",
          "1289:    goto fail;",
          "",
          "[Removed Lines]",
          "1280:   if (r_buf_size (bin->b) < (stream_addr + 8 + MAX_METADATA_STRING_LENGTH)) {",
          "1286:   if (r_buf_fread_at (bin->b, stream_addr, (ut8*) stream, bin->big_endian? \"2I\": \"2i\", 1) < 1) {",
          "",
          "[Added Lines]",
          "1284:   if (r_buf_size (pe->b) < (stream_addr + 8 + MAX_METADATA_STRING_LENGTH)) {",
          "1290:   if (r_buf_fread_at (pe->b, stream_addr, (ut8*) stream, pe->big_endian? \"2I\": \"2i\", 1) < 1) {",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1297:    goto fail;",
          "1298:   }",
          "1301:   if (c == 0) {",
          "1302:    free (stream_name);",
          "1303:    free (stream);",
          "",
          "[Removed Lines]",
          "1300:   int c = bin_pe_read_metadata_string (stream_name, bin->b, stream_addr + 8);",
          "",
          "[Added Lines]",
          "1304:   int c = bin_pe_read_metadata_string (stream_name, pe->b, stream_addr + 8);",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1309:   streams[count] = stream;",
          "1310:   stream_addr += 8 + c;",
          "1311:  }",
          "1313:  return true;",
          "1314: fail:",
          "1315:  eprintf (\"Warning: read (metadata header)\\n\");",
          "",
          "[Removed Lines]",
          "1312:  bin->streams = streams;",
          "",
          "[Added Lines]",
          "1316:  pe->streams = streams;",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1317:  return false;",
          "1318: }",
          "1321:  ut64 pe_overlay_size;",
          "1323:  if (pe_overlay_offset) {",
          "1326:  }",
          "1327:  return 0;",
          "1328: }",
          "",
          "[Removed Lines]",
          "1320: static int bin_pe_init_overlay(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1322:  ut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (bin, &pe_overlay_size);",
          "1324:   sdb_num_set (bin->kv, \"pe_overlay.offset\", pe_overlay_offset, 0);",
          "1325:   sdb_num_set (bin->kv, \"pe_overlay.size\", pe_overlay_size, 0);",
          "",
          "[Added Lines]",
          "1324: static int bin_pe_init_overlay(RBinPEObj* pe) {",
          "1326:  ut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (pe, &pe_overlay_size);",
          "1328:   sdb_num_set (pe->kv, \"pe_overlay.offset\", pe_overlay_offset, 0);",
          "1329:   sdb_num_set (pe->kv, \"pe_overlay.size\", pe_overlay_size, 0);",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1357:  return sizeof (PE_(image_clr_header));",
          "1358: }",
          "1364:  PE_(image_clr_header) * clr_hdr = R_NEW0 (PE_(image_clr_header));",
          "1365:  int rr, len = sizeof (PE_(image_clr_header));",
          "",
          "[Removed Lines]",
          "1360: static int bin_pe_init_clr_hdr(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1361:  PE_(image_data_directory) * clr_dir = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];",
          "1362:  PE_DWord image_clr_hdr_paddr = PE_(va2pa) (bin, clr_dir->VirtualAddress);",
          "",
          "[Added Lines]",
          "1364: static int bin_pe_init_clr_hdr(RBinPEObj* pe) {",
          "1365:  PE_(image_data_directory) * clr_dir = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];",
          "1366:  PE_DWord image_clr_hdr_paddr = PE_(va2pa) (pe, clr_dir->VirtualAddress);",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1367:  if (!clr_hdr) {",
          "1368:   return 0;",
          "1369:  }",
          "",
          "[Removed Lines]",
          "1370:  rr = read_image_clr_header (bin->b, image_clr_hdr_paddr, clr_hdr);",
          "",
          "[Added Lines]",
          "1374:  rr = read_image_clr_header (pe->b, image_clr_hdr_paddr, clr_hdr);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1382:   return 0;",
          "1383:  }",
          "1386:  return 1;",
          "1387: }",
          "",
          "[Removed Lines]",
          "1385:  bin->clr_hdr = clr_hdr;",
          "",
          "[Added Lines]",
          "1389:  pe->clr_hdr = clr_hdr;",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1421:  return sizeof (PE_(image_delay_import_directory));",
          "1422: }",
          "1430:  PE_DWord delay_import_dir_offset = data_dir_delay_import",
          "1432:      : 0;",
          "1434:  PE_(image_import_directory) * import_dir = NULL;",
          "",
          "[Removed Lines]",
          "1424: static int bin_pe_init_imports(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1425:  PE_(image_data_directory) * data_dir_import = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_IMPORT];",
          "1426:  PE_(image_data_directory) * data_dir_delay_import = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];",
          "1428:  PE_DWord import_dir_paddr = PE_(va2pa) (bin, data_dir_import->VirtualAddress);",
          "1429:  PE_DWord import_dir_offset = PE_(va2pa) (bin, data_dir_import->VirtualAddress);",
          "1431:  ? PE_(va2pa) (bin, data_dir_delay_import->VirtualAddress)",
          "",
          "[Added Lines]",
          "1428: static int bin_pe_init_imports(RBinPEObj* pe) {",
          "1429:  PE_(image_data_directory) * data_dir_import = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_IMPORT];",
          "1430:  PE_(image_data_directory) * data_dir_delay_import = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];",
          "1432:  PE_DWord import_dir_paddr = PE_(va2pa) (pe, data_dir_import->VirtualAddress);",
          "1433:  PE_DWord import_dir_offset = PE_(va2pa) (pe, data_dir_import->VirtualAddress);",
          "1435:  ? PE_(va2pa) (pe, data_dir_delay_import->VirtualAddress)",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1455:   delay_import_dir_size = data_dir_delay_import->Size = 0xffff;",
          "1456:  }",
          "1458:  maxidsz -= import_dir_offset;",
          "1459:  if (maxidsz < 0) {",
          "1460:   maxidsz = 0;",
          "1461:  }",
          "1465:  if (import_dir_paddr != 0) {",
          "1466:   if (import_dir_size < 1 || import_dir_size > maxidsz) {",
          "1468:    import_dir_size = maxidsz;",
          "1469:   }",
          "1471:   count = 0;",
          "1472:   do {",
          "1473:    new_import_dir = (PE_(image_import_directory)*)realloc (import_dir, ((1 + indx) * dir_size));",
          "",
          "[Removed Lines]",
          "1457:  int maxidsz = R_MIN ((PE_DWord) bin->size, import_dir_offset + import_dir_size);",
          "1464:  R_FREE (bin->import_directory);",
          "1467:    bprintf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);",
          "1470:   bin->import_directory_offset = import_dir_offset;",
          "",
          "[Added Lines]",
          "1461:  int maxidsz = R_MIN ((PE_DWord) pe->size, import_dir_offset + import_dir_size);",
          "1468:  R_FREE (pe->import_directory);",
          "1471:    pe_printf (\"Warning: Invalid import directory size: 0x%x is now 0x%x\\n\", import_dir_size, maxidsz);",
          "1474:   pe->import_directory_offset = import_dir_offset;",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1480:    import_dir = new_import_dir;",
          "1481:    new_import_dir = NULL;",
          "1482:    curr_import_dir = import_dir + indx;",
          "1485:     R_FREE (import_dir);",
          "1486:     break; //return false;",
          "1487:    }",
          "",
          "[Removed Lines]",
          "1483:    if (read_image_import_directory (bin->b, import_dir_offset + indx * dir_size, curr_import_dir) <= 0) {",
          "1484:     bprintf (\"Warning: read (import directory)\\n\");",
          "",
          "[Added Lines]",
          "1487:    if (read_image_import_directory (pe->b, import_dir_offset + indx * dir_size, curr_import_dir) <= 0) {",
          "1488:     pe_printf (\"Warning: read (import directory)\\n\");",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1494:   curr_import_dir->TimeDateStamp != 0 || curr_import_dir->Characteristics != 0 ||",
          "1495:   curr_import_dir->ForwarderChain != 0);",
          "1499:  }",
          "1501:  indx = 0;",
          "1504:    ut64 off;",
          "1506:    do {",
          "1507:     indx++;",
          "1508:     off = indx * delay_import_size;",
          "1511:      break;",
          "1512:     }",
          "1513:     new_delay_import_dir = (PE_(image_delay_import_directory)*)realloc (",
          "",
          "[Removed Lines]",
          "1497:   bin->import_directory = import_dir;",
          "1498:   bin->import_directory_size = import_dir_size;",
          "1502:  if (r_buf_size (bin->b) > 0) {",
          "1503:   if ((delay_import_dir_offset != 0) && (delay_import_dir_offset < (ut32)r_buf_size (bin->b))) {",
          "1505:    bin->delay_import_directory_offset = delay_import_dir_offset;",
          "1509:     if (off >= r_buf_size (bin->b)) {",
          "1510:      bprintf (\"Warning: Cannot find end of import symbols\\n\");",
          "",
          "[Added Lines]",
          "1501:   pe->import_directory = import_dir;",
          "1502:   pe->import_directory_size = import_dir_size;",
          "1506:  if (r_buf_size (pe->b) > 0) {",
          "1507:   if ((delay_import_dir_offset != 0) && (delay_import_dir_offset < (ut32)r_buf_size (pe->b))) {",
          "1509:    pe->delay_import_directory_offset = delay_import_dir_offset;",
          "1513:     if (off >= r_buf_size (pe->b)) {",
          "1514:      pe_printf (\"Warning: Cannot find end of import symbols\\n\");",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "1519:     }",
          "1520:     delay_import_dir = new_delay_import_dir;",
          "1521:     curr_delay_import_dir = delay_import_dir + (indx - 1);",
          "1523:      curr_delay_import_dir);",
          "1524:     if (rr != dir_size) {",
          "1526:      goto fail;",
          "1527:     }",
          "1528:    } while (curr_delay_import_dir->Name != 0);",
          "1530:   }",
          "1531:  }",
          "1533:  return true;",
          "1534: fail:",
          "1535:  R_FREE (import_dir);",
          "1537:  free (delay_import_dir);",
          "1538:  return false;",
          "1539: }",
          "",
          "[Removed Lines]",
          "1522:     rr = read_image_delay_import_directory (bin->b, delay_import_dir_offset + (indx - 1) * delay_import_size,",
          "1525:      bprintf (\"Warning: read (delay import directory)\\n\");",
          "1529:    bin->delay_import_directory = delay_import_dir;",
          "1536:  bin->import_directory = import_dir;",
          "",
          "[Added Lines]",
          "1526:     rr = read_image_delay_import_directory (pe->b, delay_import_dir_offset + (indx - 1) * delay_import_size,",
          "1529:      pe_printf (\"Warning: read (delay import directory)\\n\");",
          "1533:    pe->delay_import_directory = delay_import_dir;",
          "1540:  pe->import_directory = import_dir;",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "1560:  return sizeof (PE_(image_export_directory));",
          "1561: }",
          "1566:  if (!export_dir_paddr) {",
          "1569:   return false;",
          "1570:  }",
          "1574:   r_sys_perror (\"malloc (export directory)\");",
          "1575:   return false;",
          "1576:  }",
          "1580:   return false;",
          "1581:  }",
          "1582:  return true;",
          "",
          "[Removed Lines]",
          "1563: static int bin_pe_init_exports(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1564:  PE_(image_data_directory) * data_dir_export = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];",
          "1565:  PE_DWord export_dir_paddr = PE_(va2pa) (bin, data_dir_export->VirtualAddress);",
          "1573:  if (!(bin->export_directory = malloc (sizeof (PE_(image_export_directory))))) {",
          "1577:  if (read_image_export_directory (bin->b, export_dir_paddr, bin->export_directory) < 0) {",
          "1578:   bprintf (\"Warning: read (export directory)\\n\");",
          "1579:   R_FREE (bin->export_directory);",
          "",
          "[Added Lines]",
          "1567: static int bin_pe_init_exports(RBinPEObj* pe) {",
          "1568:  PE_(image_data_directory) * data_dir_export = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];",
          "1569:  PE_DWord export_dir_paddr = PE_(va2pa) (pe, data_dir_export->VirtualAddress);",
          "1577:  if (!(pe->export_directory = malloc (sizeof (PE_(image_export_directory))))) {",
          "1581:  if (read_image_export_directory (pe->b, export_dir_paddr, pe->export_directory) < 0) {",
          "1582:   pe_printf (\"Warning: read (export directory)\\n\");",
          "1583:   R_FREE (pe->export_directory);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "1608:  return sizeof (Pe_image_resource_directory);",
          "1609: }",
          "1614:  if (!resource_dir_paddr) {",
          "1615:   return false;",
          "1616:  }",
          "1620:   return false;",
          "1621:  }",
          "1623:   r_sys_perror (\"malloc (resource directory)\");",
          "1624:   return false;",
          "1625:  }",
          "1629:   return false;",
          "1630:  }",
          "1632:  return true;",
          "1633: }",
          "1636:  r_strf_buffer (64);",
          "1637:  PE_DWord paddr, haddr;",
          "1638:  int count = 0;",
          "",
          "[Removed Lines]",
          "1611: static int bin_pe_init_resource(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1612:  PE_(image_data_directory) * resource_dir = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_RESOURCE];",
          "1613:  PE_DWord resource_dir_paddr = PE_(va2pa) (bin, resource_dir->VirtualAddress);",
          "1618:  bin->resources = r_list_newf ((RListFree)_free_resource);",
          "1619:  if (!bin->resources) {",
          "1622:  if (!(bin->resource_directory = malloc (sizeof (*bin->resource_directory)))) {",
          "1626:  if (read_image_resource_directory (bin->b, resource_dir_paddr, bin->resource_directory) < 0) {",
          "1627:   bprintf (\"Warning: read (resource directory)\\n\");",
          "1628:   R_FREE (bin->resource_directory);",
          "1631:  bin->resource_directory_offset = resource_dir_paddr;",
          "1635: static void bin_pe_store_tls_callbacks(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord callbacks) {",
          "",
          "[Added Lines]",
          "1615: static int bin_pe_init_resource(RBinPEObj* pe) {",
          "1616:  PE_(image_data_directory) * resource_dir = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_RESOURCE];",
          "1617:  PE_DWord resource_dir_paddr = PE_(va2pa) (pe, resource_dir->VirtualAddress);",
          "1622:  pe->resources = r_list_newf ((RListFree)_free_resource);",
          "1623:  if (!pe->resources) {",
          "1626:  if (!(pe->resource_directory = malloc (sizeof (*pe->resource_directory)))) {",
          "1630:  if (read_image_resource_directory (pe->b, resource_dir_paddr, pe->resource_directory) < 0) {",
          "1631:   pe_printf (\"Warning: read (resource directory)\\n\");",
          "1632:   R_FREE (pe->resource_directory);",
          "1635:  pe->resource_directory_offset = resource_dir_paddr;",
          "1639: static void bin_pe_store_tls_callbacks(RBinPEObj* pe, PE_DWord callbacks) {",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "1640:  char* key;",
          "1642:  while (addressOfTLSCallback != 0) {",
          "1644:   if (addressOfTLSCallback == PE_DWORD_MAX) {",
          "1646:    return;",
          "1647:   }",
          "1648:   if (!addressOfTLSCallback) {",
          "1649:    break;",
          "1650:   }",
          "1654:     break;",
          "1655:    }",
          "1656:   }",
          "1657:   key = r_strf (\"pe.tls_callback%d_vaddr\", count);",
          "1659:   key = r_strf (\"pe.tls_callback%d_paddr\", count);",
          "1662:   key = r_strf (\"pe.tls_callback%d_haddr\", count);",
          "1663:   haddr = callbacks;",
          "1665:   count++;",
          "1666:   callbacks += sizeof (addressOfTLSCallback);",
          "1667:  }",
          "",
          "[Removed Lines]",
          "1643:   addressOfTLSCallback = R_BUF_READ_PE_DWORD_AT (bin->b, callbacks);",
          "1645:    bprintf (\"Warning: read (tls_callback)\\n\");",
          "1651:   if (bin->optional_header->SizeOfImage) {",
          "1652:    int rva_callback = bin_pe_va_to_rva (bin, (PE_DWord) addressOfTLSCallback);",
          "1653:    if (rva_callback > bin->optional_header->SizeOfImage) {",
          "1658:   sdb_num_set (bin->kv, key, addressOfTLSCallback, 0);",
          "1660:   paddr = PE_(va2pa) (bin, bin_pe_va_to_rva (bin, (PE_DWord) addressOfTLSCallback));",
          "1661:   sdb_num_set (bin->kv, key, paddr,                0);",
          "1664:   sdb_num_set (bin->kv, key, haddr,                0);",
          "",
          "[Added Lines]",
          "1647:   addressOfTLSCallback = R_BUF_READ_PE_DWORD_AT (pe->b, callbacks);",
          "1649:    pe_printf (\"Warning: read (tls_callback)\\n\");",
          "1655:   if (pe->optional_header->SizeOfImage) {",
          "1656:    int rva_callback = bin_pe_va_to_rva (pe, (PE_DWord) addressOfTLSCallback);",
          "1657:    if (rva_callback > pe->optional_header->SizeOfImage) {",
          "1662:   sdb_num_set (pe->kv, key, addressOfTLSCallback, 0);",
          "1664:   paddr = PE_(va2pa) (pe, bin_pe_va_to_rva (pe, (PE_DWord) addressOfTLSCallback));",
          "1665:   sdb_num_set (pe->kv, key, paddr, 0);",
          "1668:   sdb_num_set (pe->kv, key, haddr, 0);",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "1682:  return sizeof (PE_(image_tls_directory));",
          "1683: }",
          "1686:  PE_(image_tls_directory) * image_tls_directory;",
          "1690:  image_tls_directory = R_NEW0 (PE_(image_tls_directory));",
          "1693:   free (image_tls_directory);",
          "1694:   return 0;",
          "1695:  }",
          "1697:  if (!image_tls_directory->AddressOfCallBacks) {",
          "1698:   return 0;",
          "1699:  }",
          "1700:  if (image_tls_directory->EndAddressOfRawData < image_tls_directory->StartAddressOfRawData) {",
          "1701:   return 0;",
          "1702:  }",
          "1704:    (PE_DWord) image_tls_directory->AddressOfCallBacks));",
          "1706:  return 0;",
          "1707: }",
          "",
          "[Removed Lines]",
          "1685: static int bin_pe_init_tls(struct PE_(r_bin_pe_obj_t)* bin) {",
          "1687:  PE_(image_data_directory) * data_dir_tls = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_TLS];",
          "1688:  PE_DWord tls_paddr = PE_(va2pa) (bin, data_dir_tls->VirtualAddress);",
          "1691:  if (read_tls_directory (bin->b, tls_paddr, image_tls_directory) < 0) {",
          "1692:   bprintf (\"Warning: read (image_tls_directory)\\n\");",
          "1696:  bin->tls_directory = image_tls_directory;",
          "1703:  PE_DWord callbacks_paddr = PE_(va2pa) (bin, bin_pe_va_to_rva (bin,",
          "1705:  bin_pe_store_tls_callbacks (bin, callbacks_paddr);",
          "",
          "[Added Lines]",
          "1689: static int bin_pe_init_tls(RBinPEObj* pe) {",
          "1691:  PE_(image_data_directory) * data_dir_tls = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_TLS];",
          "1692:  PE_DWord tls_paddr = PE_(va2pa) (pe, data_dir_tls->VirtualAddress);",
          "1695:  if (read_tls_directory (pe->b, tls_paddr, image_tls_directory) < 0) {",
          "1696:   pe_printf (\"Warning: read (image_tls_directory)\\n\");",
          "1700:  pe->tls_directory = image_tls_directory;",
          "1707:  PE_DWord callbacks_paddr = PE_(va2pa) (pe, bin_pe_va_to_rva (pe,",
          "1709:  bin_pe_store_tls_callbacks (pe, callbacks_paddr);",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "1780:  free_VS_VERSIONINFO (vs_VersionInfo);",
          "1781: }",
          "1784:  Var* var = calloc (1, sizeof (*var));",
          "1785:  if (!var) {",
          "1787:   return NULL;",
          "1788:  }",
          "1791:   free_Var (var);",
          "1792:   return NULL;",
          "1793:  }",
          "1797:   free_Var (var);",
          "1798:   return NULL;",
          "1799:  }",
          "1803:   free_Var (var);",
          "1804:   return NULL;",
          "1805:  }",
          "1807:  if (var->wType != 0 && var->wType != 1) {",
          "1809:   free_Var (var);",
          "1810:   return NULL;",
          "1811:  }",
          "1813:  var->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L\"Translation\"",
          "1814:  if (!var->szKey) {",
          "1816:   free_Var (var);",
          "1817:   return NULL;",
          "1818:  }",
          "1821:   free_Var (var);",
          "1822:   return NULL;",
          "1823:  }",
          "1825:  if (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {",
          "1827:   free_Var (var);",
          "1828:   return NULL;",
          "1829:  }",
          "1830:  align32 (*curAddr);",
          "1831:  var->numOfValues = var->wValueLength / 4;",
          "1832:  if (!var->numOfValues) {",
          "1834:   free_Var (var);",
          "1835:   return NULL;",
          "1836:  }",
          "1837:  var->Value = (ut32*) malloc (var->wValueLength);",
          "1838:  if (!var->Value) {",
          "1840:   free_Var (var);",
          "1841:   return NULL;",
          "1842:  }",
          "1845:   free_Var (var);",
          "1846:   return NULL;",
          "1847:  }",
          "",
          "[Removed Lines]",
          "1783: static Var* Pe_r_bin_pe_parse_var(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {",
          "1786:   bprintf (\"Warning: calloc (Var)\\n\");",
          "1789:  if ((var->wLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1790:   bprintf (\"Warning: read (Var wLength)\\n\");",
          "1795:  if ((var->wValueLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1796:   bprintf (\"Warning: read (Var wValueLength)\\n\");",
          "1801:  if ((var->wType = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1802:   bprintf (\"Warning: read (Var wType)\\n\");",
          "1808:   bprintf (\"Warning: check (Var wType)\\n\");",
          "1815:   bprintf (\"Warning: malloc (Var szKey)\\n\");",
          "1819:  if (r_buf_read_at (bin->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {",
          "1820:   bprintf (\"Warning: read (Var szKey)\\n\");",
          "1826:   bprintf (\"Warning: check (Var szKey)\\n\");",
          "1833:   bprintf (\"Warning: check (Var numOfValues)\\n\");",
          "1839:   bprintf (\"Warning: malloc (Var Value)\\n\");",
          "1843:  if (r_buf_read_at (bin->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {",
          "1844:   bprintf (\"Warning: read (Var Value)\\n\");",
          "",
          "[Added Lines]",
          "1787: static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) {",
          "1790:   pe_printf (\"Warning: calloc (Var)\\n\");",
          "1793:  if ((var->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1794:   pe_printf (\"Warning: read (Var wLength)\\n\");",
          "1799:  if ((var->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1800:   pe_printf (\"Warning: read (Var wValueLength)\\n\");",
          "1805:  if ((var->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1806:   pe_printf (\"Warning: read (Var wType)\\n\");",
          "1812:   pe_printf (\"Warning: check (Var wType)\\n\");",
          "1819:   pe_printf (\"Warning: malloc (Var szKey)\\n\");",
          "1823:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {",
          "1824:   pe_printf (\"Warning: read (Var szKey)\\n\");",
          "1830:   pe_printf (\"Warning: check (Var szKey)\\n\");",
          "1837:   pe_printf (\"Warning: check (Var numOfValues)\\n\");",
          "1843:   pe_printf (\"Warning: malloc (Var Value)\\n\");",
          "1847:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) {",
          "1848:   pe_printf (\"Warning: read (Var Value)\\n\");",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "1849:  return var;",
          "1850: }",
          "1853:  VarFileInfo* varFileInfo = calloc (1, sizeof (*varFileInfo));",
          "1854:  if (!varFileInfo) {",
          "1856:   return NULL;",
          "1857:  }",
          "1858:  PE_DWord startAddr = *curAddr;",
          "1861:   free_VarFileInfo (varFileInfo);",
          "1862:   return NULL;",
          "1863:  }",
          "1868:   free_VarFileInfo (varFileInfo);",
          "1869:   return NULL;",
          "1870:  }",
          "1873:  if (varFileInfo->wValueLength != 0) {",
          "1875:   free_VarFileInfo (varFileInfo);",
          "1876:   return NULL;",
          "1877:  }",
          "1881:   free_VarFileInfo (varFileInfo);",
          "1882:   return NULL;",
          "1883:  }",
          "1885:  if (varFileInfo->wType && varFileInfo->wType != 1) {",
          "1887:   free_VarFileInfo (varFileInfo);",
          "1888:   return NULL;",
          "1889:  }",
          "1891:  varFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (VARFILEINFO_UTF_16_LEN ));  //L\"VarFileInfo\"",
          "1892:  if (!varFileInfo->szKey) {",
          "1894:   free_VarFileInfo (varFileInfo);",
          "1895:   return NULL;",
          "1896:  }",
          "1900:   free_VarFileInfo (varFileInfo);",
          "1901:   return NULL;",
          "1902:  }",
          "1905:  if (memcmp (varFileInfo->szKey, VARFILEINFO_UTF_16, VARFILEINFO_UTF_16_LEN)) {",
          "1907:   free_VarFileInfo (varFileInfo);",
          "1908:   return NULL;",
          "1909:  }",
          "",
          "[Removed Lines]",
          "1852: static VarFileInfo* Pe_r_bin_pe_parse_var_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {",
          "1855:   bprintf (\"Warning: calloc (VarFileInfo)\\n\");",
          "1859:  if ((varFileInfo->wLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1860:   bprintf (\"Warning: read (VarFileInfo wLength)\\n\");",
          "1866:  if ((varFileInfo->wValueLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1867:   bprintf (\"Warning: read (VarFileInfo wValueLength)\\n\");",
          "1874:   bprintf (\"Warning: check (VarFileInfo wValueLength)\\n\");",
          "1879:  if ((varFileInfo->wType = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1880:   bprintf (\"Warning: read (VarFileInfo wType)\\n\");",
          "1886:   bprintf (\"Warning: check (VarFileInfo wType)\\n\");",
          "1893:   bprintf (\"Warning: malloc (VarFileInfo szKey)\\n\");",
          "1898:  if (r_buf_read_at (bin->b, *curAddr, (ut8*) varFileInfo->szKey, VARFILEINFO_UTF_16_LEN) != VARFILEINFO_UTF_16_LEN) {",
          "1899:   bprintf (\"Warning: read (VarFileInfo szKey)\\n\");",
          "1906:   bprintf (\"Warning: check (VarFileInfo szKey)\\n\");",
          "",
          "[Added Lines]",
          "1856: static VarFileInfo* Pe_r_bin_pe_parse_var_file_info(RBinPEObj* pe, PE_DWord* curAddr) {",
          "1859:   pe_printf (\"Warning: calloc (VarFileInfo)\\n\");",
          "1863:  if ((varFileInfo->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1864:   pe_printf (\"Warning: read (VarFileInfo wLength)\\n\");",
          "1870:  if ((varFileInfo->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1871:   pe_printf (\"Warning: read (VarFileInfo wValueLength)\\n\");",
          "1878:   pe_printf (\"Warning: check (VarFileInfo wValueLength)\\n\");",
          "1883:  if ((varFileInfo->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1884:   pe_printf (\"Warning: read (VarFileInfo wType)\\n\");",
          "1890:   pe_printf (\"Warning: check (VarFileInfo wType)\\n\");",
          "1897:   pe_printf (\"Warning: malloc (VarFileInfo szKey)\\n\");",
          "1902:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) varFileInfo->szKey, VARFILEINFO_UTF_16_LEN) != VARFILEINFO_UTF_16_LEN) {",
          "1903:   pe_printf (\"Warning: read (VarFileInfo szKey)\\n\");",
          "1910:   pe_printf (\"Warning: check (VarFileInfo szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "1911:  while (startAddr + varFileInfo->wLength > *curAddr) {",
          "1912:   Var** tmp = (Var**) realloc (varFileInfo->Children, (varFileInfo->numOfChildren + 1) * sizeof (*varFileInfo->Children));",
          "1913:   if (!tmp) {",
          "1915:    free_VarFileInfo (varFileInfo);",
          "1916:    return NULL;",
          "1917:   }",
          "1918:   varFileInfo->Children = tmp;",
          "1921:    free_VarFileInfo (varFileInfo);",
          "1922:    return NULL;",
          "1923:   }",
          "",
          "[Removed Lines]",
          "1914:    bprintf (\"Warning: realloc (VarFileInfo Children)\\n\");",
          "1919:   if (!(varFileInfo->Children[varFileInfo->numOfChildren] = Pe_r_bin_pe_parse_var (bin, curAddr))) {",
          "1920:    bprintf (\"Warning: bad parsing Var\\n\");",
          "",
          "[Added Lines]",
          "1918:    pe_printf (\"Warning: realloc (VarFileInfo Children)\\n\");",
          "1923:   if (!(varFileInfo->Children[varFileInfo->numOfChildren] = Pe_r_bin_pe_parse_var (pe, curAddr))) {",
          "1924:    pe_printf (\"Warning: bad parsing Var\\n\");",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "1927:  return varFileInfo;",
          "1928: }",
          "1931:  String* string = calloc (1, sizeof (*string));",
          "1932:  PE_DWord begAddr = *curAddr;",
          "1933:  int len_value = 0;",
          "1934:  int i = 0;",
          "1935:  if (!string) {",
          "1937:   return NULL;",
          "1938:  }",
          "1940:   free_String (string);",
          "1941:   return NULL;",
          "1942:  }",
          "1945:   goto out_error;",
          "1946:  }",
          "1949:   goto out_error;",
          "1950:  }",
          "1953:   goto out_error;",
          "1954:  }",
          "1958:   goto out_error;",
          "1959:  }",
          "1962:   goto out_error;",
          "1963:  }",
          "1965:  if (string->wType != 0 && string->wType != 1) {",
          "1967:   goto out_error;",
          "1968:  }",
          "1970:  for (i = 0; *curAddr < begAddr + string->wLength; i++, *curAddr += sizeof (ut16)) {",
          "1971:   ut16 utf16_char;",
          "1972:   ut16 *tmpKey;",
          "1974:    goto out_error;",
          "1975:   }",
          "1978:    goto out_error;",
          "1979:   }",
          "1980:   tmpKey = (ut16*) realloc (string->szKey, (i + 1) * sizeof (ut16));",
          "1981:   if (!tmpKey) {",
          "1983:    goto out_error;",
          "1984:   }",
          "1985:   string->szKey = tmpKey;",
          "",
          "[Removed Lines]",
          "1930: static String* Pe_r_bin_pe_parse_string(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {",
          "1936:   bprintf (\"Warning: calloc (String)\\n\");",
          "1939:  if (begAddr > bin->size || begAddr + sizeof (string->wLength) > bin->size) {",
          "1943:  if ((string->wLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1944:   bprintf (\"Warning: read (String wLength)\\n\");",
          "1948:  if (*curAddr > bin->size || *curAddr + sizeof (string->wValueLength) > bin->size) {",
          "1951:  if ((string->wValueLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1952:   bprintf (\"Warning: read (String wValueLength)\\n\");",
          "1957:  if (*curAddr > bin->size || *curAddr + sizeof (string->wType) > bin->size) {",
          "1960:  if ((string->wType = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "1961:   bprintf (\"Warning: read (String wType)\\n\");",
          "1966:   bprintf (\"Warning: check (String wType)\\n\");",
          "1973:   if (*curAddr > bin->size || *curAddr + sizeof (ut16) > bin->size) {",
          "1976:   if (r_buf_read_at (bin->b, *curAddr, (ut8*) &utf16_char, sizeof (ut16)) != sizeof (ut16)) {",
          "1977:    bprintf (\"Warning: check (String szKey)\\n\");",
          "1982:    bprintf (\"Warning: realloc (String szKey)\\n\");",
          "",
          "[Added Lines]",
          "1934: static String* Pe_r_bin_pe_parse_string(RBinPEObj* pe, PE_DWord* curAddr) {",
          "1940:   pe_printf (\"Warning: calloc (String)\\n\");",
          "1943:  if (begAddr > pe->size || begAddr + sizeof (string->wLength) > pe->size) {",
          "1947:  if ((string->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1948:   pe_printf (\"Warning: read (String wLength)\\n\");",
          "1952:  if (*curAddr > pe->size || *curAddr + sizeof (string->wValueLength) > pe->size) {",
          "1955:  if ((string->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1956:   pe_printf (\"Warning: read (String wValueLength)\\n\");",
          "1961:  if (*curAddr > pe->size || *curAddr + sizeof (string->wType) > pe->size) {",
          "1964:  if ((string->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "1965:   pe_printf (\"Warning: read (String wType)\\n\");",
          "1970:   pe_printf (\"Warning: check (String wType)\\n\");",
          "1977:   if (*curAddr > pe->size || *curAddr + sizeof (ut16) > pe->size) {",
          "1980:   if (r_buf_read_at (pe->b, *curAddr, (ut8*) &utf16_char, sizeof (ut16)) != sizeof (ut16)) {",
          "1981:    pe_printf (\"Warning: check (String szKey)\\n\");",
          "1986:    pe_printf (\"Warning: realloc (String szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "1998:  }",
          "1999:  string->Value = (ut16*) calloc (len_value + 1, 1);",
          "2000:  if (!string->Value) {",
          "2002:   goto out_error;",
          "2003:  }",
          "2005:   goto out_error;",
          "2006:  }",
          "2009:   goto out_error;",
          "2010:  }",
          "",
          "[Removed Lines]",
          "2001:   bprintf (\"Warning: malloc (String Value)\\n\");",
          "2004:  if (*curAddr > bin->size || *curAddr + len_value > bin->size) {",
          "2007:  if (r_buf_read_at (bin->b, *curAddr, (ut8*) string->Value, len_value) != len_value) {",
          "2008:   bprintf (\"Warning: read (String Value)\\n\");",
          "",
          "[Added Lines]",
          "2005:   pe_printf (\"Warning: malloc (String Value)\\n\");",
          "2008:  if (*curAddr > pe->size || *curAddr + len_value > pe->size) {",
          "2011:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) string->Value, len_value) != len_value) {",
          "2012:   pe_printf (\"Warning: read (String Value)\\n\");",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2015:  return NULL;",
          "2016: }",
          "2019:  StringTable* stringTable = calloc (1, sizeof (*stringTable));",
          "2020:  if (!stringTable) {",
          "2022:   return NULL;",
          "2023:  }",
          "2025:  PE_DWord startAddr = *curAddr;",
          "2028:   free_StringTable (stringTable);",
          "2029:   return NULL;",
          "2030:  }",
          "2035:   free_StringTable (stringTable);",
          "2036:   return NULL;",
          "2037:  }",
          "2040:  if (stringTable->wValueLength) {",
          "2042:   free_StringTable (stringTable);",
          "2043:   return NULL;",
          "2044:  }",
          "2048:   free_StringTable (stringTable);",
          "2049:   return NULL;",
          "2050:  }",
          "2052:  if (stringTable->wType && stringTable->wType != 1) {",
          "2054:   free_StringTable (stringTable);",
          "2055:   return NULL;",
          "2056:  }",
          "2057:  stringTable->szKey = (ut16*) malloc (UT16_ALIGN (EIGHT_HEX_DIG_UTF_16_LEN));  //EIGHT_HEX_DIG_UTF_16_LEN",
          "2058:  if (!stringTable->szKey) {",
          "2060:   free_StringTable (stringTable);",
          "2061:   return NULL;",
          "2062:  }",
          "2066:   free_StringTable (stringTable);",
          "2067:   return NULL;",
          "2068:  }",
          "",
          "[Removed Lines]",
          "2018: static StringTable* Pe_r_bin_pe_parse_string_table(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {",
          "2021:   bprintf (\"Warning: calloc (stringTable)\\n\");",
          "2026:  if ((stringTable->wLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "2027:   bprintf (\"Warning: read (StringTable wLength)\\n\");",
          "2033:  if ((stringTable->wValueLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "2034:   bprintf (\"Warning: read (StringTable wValueLength)\\n\");",
          "2041:   bprintf (\"Warning: check (StringTable wValueLength)\\n\");",
          "2046:  if ((stringTable->wType = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "2047:   bprintf (\"Warning: read (StringTable wType)\\n\");",
          "2053:   bprintf (\"Warning: check (StringTable wType)\\n\");",
          "2059:   bprintf (\"Warning: malloc (stringTable szKey)\\n\");",
          "2064:  if (r_buf_read_at (bin->b, *curAddr, (ut8*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN) != EIGHT_HEX_DIG_UTF_16_LEN) {",
          "2065:   bprintf (\"Warning: read (StringTable szKey)\\n\");",
          "",
          "[Added Lines]",
          "2022: static StringTable* Pe_r_bin_pe_parse_string_table(RBinPEObj* pe, PE_DWord* curAddr) {",
          "2025:   pe_printf (\"Warning: calloc (stringTable)\\n\");",
          "2030:  if ((stringTable->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "2031:   pe_printf (\"Warning: read (StringTable wLength)\\n\");",
          "2037:  if ((stringTable->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "2038:   pe_printf (\"Warning: read (StringTable wValueLength)\\n\");",
          "2045:   pe_printf (\"Warning: check (StringTable wValueLength)\\n\");",
          "2050:  if ((stringTable->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "2051:   pe_printf (\"Warning: read (StringTable wType)\\n\");",
          "2057:   pe_printf (\"Warning: check (StringTable wType)\\n\");",
          "2063:   pe_printf (\"Warning: malloc (stringTable szKey)\\n\");",
          "2068:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) stringTable->szKey, EIGHT_HEX_DIG_UTF_16_LEN) != EIGHT_HEX_DIG_UTF_16_LEN) {",
          "2069:   pe_printf (\"Warning: read (StringTable szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2071:  while (startAddr + stringTable->wLength > *curAddr) {",
          "2072:   String** tmp = (String**) realloc (stringTable->Children, (stringTable->numOfChildren + 1) * sizeof (*stringTable->Children));",
          "2073:   if (!tmp) {",
          "2075:    free_StringTable (stringTable);",
          "2076:    return NULL;",
          "2077:   }",
          "2078:   stringTable->Children = tmp;",
          "2081:    free_StringTable (stringTable);",
          "2082:    return NULL;",
          "2083:   }",
          "",
          "[Removed Lines]",
          "2074:    bprintf (\"Warning: realloc (StringTable Children)\\n\");",
          "2079:   if (!(stringTable->Children[stringTable->numOfChildren] = Pe_r_bin_pe_parse_string (bin, curAddr))) {",
          "2080:    bprintf (\"Warning: bad parsing String\\n\");",
          "",
          "[Added Lines]",
          "2078:    pe_printf (\"Warning: realloc (StringTable Children)\\n\");",
          "2083:   if (!(stringTable->Children[stringTable->numOfChildren] = Pe_r_bin_pe_parse_string (pe, curAddr))) {",
          "2084:    pe_printf (\"Warning: bad parsing String\\n\");",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2086:  }",
          "2088:  if (!stringTable->numOfChildren) {",
          "2090:   free_StringTable (stringTable);",
          "2091:   return NULL;",
          "2092:  }",
          "",
          "[Removed Lines]",
          "2089:   bprintf (\"Warning: check (StringTable numOfChildren)\\n\");",
          "",
          "[Added Lines]",
          "2093:   pe_printf (\"Warning: check (StringTable numOfChildren)\\n\");",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2094:  return stringTable;",
          "2095: }",
          "2098:  StringFileInfo* stringFileInfo = calloc (1, sizeof (*stringFileInfo));",
          "2099:  if (!stringFileInfo) {",
          "2101:   return NULL;",
          "2102:  }",
          "2104:  PE_DWord startAddr = *curAddr;",
          "2108:   free_StringFileInfo (stringFileInfo);",
          "2109:   return NULL;",
          "2110:  }",
          "2115:   free_StringFileInfo (stringFileInfo);",
          "2116:   return NULL;",
          "2117:  }",
          "2120:  if (stringFileInfo->wValueLength) {",
          "2122:   free_StringFileInfo (stringFileInfo);",
          "2123:   return NULL;",
          "2124:  }",
          "2128:   free_StringFileInfo (stringFileInfo);",
          "2129:   return NULL;",
          "2130:  }",
          "2133:  if (stringFileInfo->wType && stringFileInfo->wType != 1) {",
          "2135:   free_StringFileInfo (stringFileInfo);",
          "2136:   return NULL;",
          "2137:  }",
          "2139:  stringFileInfo->szKey = (ut16*) malloc (UT16_ALIGN (STRINGFILEINFO_UTF_16_LEN));  //L\"StringFileInfo\"",
          "2140:  if (!stringFileInfo->szKey) {",
          "2142:   free_StringFileInfo (stringFileInfo);",
          "2143:   return NULL;",
          "2144:  }",
          "2148:   free_StringFileInfo (stringFileInfo);",
          "2149:   return NULL;",
          "2150:  }",
          "2153:  if (memcmp (stringFileInfo->szKey, STRINGFILEINFO_UTF_16, STRINGFILEINFO_UTF_16_LEN) != 0) {",
          "2155:   free_StringFileInfo (stringFileInfo);",
          "2156:   return NULL;",
          "2157:  }",
          "",
          "[Removed Lines]",
          "2097: static StringFileInfo* Pe_r_bin_pe_parse_string_file_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord* curAddr) {",
          "2100:   bprintf (\"Warning: calloc (StringFileInfo)\\n\");",
          "2106:  if ((stringFileInfo->wLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "2107:   bprintf (\"Warning: read (StringFileInfo wLength)\\n\");",
          "2113:  if ((stringFileInfo->wValueLength = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "2114:   bprintf (\"Warning: read (StringFileInfo wValueLength)\\n\");",
          "2121:   bprintf (\"Warning: check (StringFileInfo wValueLength)\\n\");",
          "2126:  if ((stringFileInfo->wType = r_buf_read_le16_at (bin->b, *curAddr)) == UT16_MAX) {",
          "2127:   bprintf (\"Warning: read (StringFileInfo wType)\\n\");",
          "2134:   bprintf (\"Warning: check (StringFileInfo wType)\\n\");",
          "2141:   bprintf (\"Warning: malloc (StringFileInfo szKey)\\n\");",
          "2146:  if (r_buf_read_at (bin->b, *curAddr, (ut8*) stringFileInfo->szKey, STRINGFILEINFO_UTF_16_LEN) != STRINGFILEINFO_UTF_16_LEN) {",
          "2147:   bprintf (\"Warning: read (StringFileInfo szKey)\\n\");",
          "2154:   bprintf (\"Warning: check (StringFileInfo szKey)\\n\");",
          "",
          "[Added Lines]",
          "2101: static StringFileInfo* Pe_r_bin_pe_parse_string_file_info(RBinPEObj* pe, PE_DWord* curAddr) {",
          "2104:   pe_printf (\"Warning: calloc (StringFileInfo)\\n\");",
          "2110:  if ((stringFileInfo->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "2111:   pe_printf (\"Warning: read (StringFileInfo wLength)\\n\");",
          "2117:  if ((stringFileInfo->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "2118:   pe_printf (\"Warning: read (StringFileInfo wValueLength)\\n\");",
          "2125:   pe_printf (\"Warning: check (StringFileInfo wValueLength)\\n\");",
          "2130:  if ((stringFileInfo->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) {",
          "2131:   pe_printf (\"Warning: read (StringFileInfo wType)\\n\");",
          "2138:   pe_printf (\"Warning: check (StringFileInfo wType)\\n\");",
          "2145:   pe_printf (\"Warning: malloc (StringFileInfo szKey)\\n\");",
          "2150:  if (r_buf_read_at (pe->b, *curAddr, (ut8*) stringFileInfo->szKey, STRINGFILEINFO_UTF_16_LEN) != STRINGFILEINFO_UTF_16_LEN) {",
          "2151:   pe_printf (\"Warning: read (StringFileInfo szKey)\\n\");",
          "2158:   pe_printf (\"Warning: check (StringFileInfo szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2161:  while (startAddr + stringFileInfo->wLength > *curAddr) {",
          "2162:   StringTable** tmp = (StringTable**) realloc (stringFileInfo->Children, (stringFileInfo->numOfChildren + 1) * sizeof (*stringFileInfo->Children));",
          "2163:   if (!tmp) {",
          "2165:    free_StringFileInfo (stringFileInfo);",
          "2166:    return NULL;",
          "2167:   }",
          "2168:   stringFileInfo->Children = tmp;",
          "2171:    free_StringFileInfo (stringFileInfo);",
          "2172:    return NULL;",
          "2173:   }",
          "",
          "[Removed Lines]",
          "2164:    bprintf (\"Warning: realloc (StringFileInfo Children)\\n\");",
          "2169:   if (!(stringFileInfo->Children[stringFileInfo->numOfChildren] = Pe_r_bin_pe_parse_string_table (bin, curAddr))) {",
          "2170:    bprintf (\"Warning: bad parsing StringTable\\n\");",
          "",
          "[Added Lines]",
          "2168:    pe_printf (\"Warning: realloc (StringFileInfo Children)\\n\");",
          "2173:   if (!(stringFileInfo->Children[stringFileInfo->numOfChildren] = Pe_r_bin_pe_parse_string_table (pe, curAddr))) {",
          "2174:    pe_printf (\"Warning: bad parsing StringTable\\n\");",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2176:  }",
          "2178:  if (!stringFileInfo->numOfChildren) {",
          "2180:   free_StringFileInfo (stringFileInfo);",
          "2181:   return NULL;",
          "2182:  }",
          "",
          "[Removed Lines]",
          "2179:   bprintf (\"Warning: check (StringFileInfo numOfChildren)\\n\");",
          "",
          "[Added Lines]",
          "2183:   pe_printf (\"Warning: check (StringFileInfo numOfChildren)\\n\");",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2185: }",
          "2187: #define EXIT_ON_OVERFLOW(S)\\",
          "2189:   goto out_error; }",
          "2191:  ut32 sz;",
          "2192:  PE_VS_VERSIONINFO* vs_VersionInfo = calloc (1, sizeof (PE_VS_VERSIONINFO));",
          "2193:  if (!vs_VersionInfo) {",
          "",
          "[Removed Lines]",
          "2188:  if (curAddr > bin->size || curAddr + (S) > bin->size) { \\",
          "2190: static PE_VS_VERSIONINFO* Pe_r_bin_pe_parse_version_info(struct PE_(r_bin_pe_obj_t)* bin, PE_DWord version_info_paddr) {",
          "",
          "[Added Lines]",
          "2192:  if (curAddr > pe->size || curAddr + (S) > pe->size) { \\",
          "2194: static PE_VS_VERSIONINFO* Pe_r_bin_pe_parse_version_info(RBinPEObj* pe, PE_DWord version_info_paddr) {",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2203:  sz = sizeof (ut16);",
          "2204:  EXIT_ON_OVERFLOW (sz);",
          "2207:   goto out_error;",
          "2208:  }",
          "2209:  curAddr += sz;",
          "2210:  EXIT_ON_OVERFLOW (sz);",
          "2213:   goto out_error;",
          "2214:  }",
          "2215:  curAddr += sz;",
          "2216:  EXIT_ON_OVERFLOW (sz);",
          "2219:   goto out_error;",
          "2220:  }",
          "2221:  curAddr += sz;",
          "2222:  if (vs_VersionInfo->wType && vs_VersionInfo->wType != 1) {",
          "2224:   goto out_error;",
          "2225:  }",
          "2227:  vs_VersionInfo->szKey = (ut16*) malloc (UT16_ALIGN (VS_VERSION_INFO_UTF_16_LEN));  //L\"VS_VERSION_INFO\"",
          "2228:  if (!vs_VersionInfo->szKey) {",
          "2230:   goto out_error;",
          "2231:  }",
          "2232:  sz = VS_VERSION_INFO_UTF_16_LEN;",
          "2233:  EXIT_ON_OVERFLOW (sz);",
          "2236:   goto out_error;",
          "2237:  }",
          "2238:  curAddr += sz;",
          "",
          "[Removed Lines]",
          "2205:  if ((vs_VersionInfo->wLength = r_buf_read_le16_at (bin->b, curAddr)) == UT16_MAX) {",
          "2206:   bprintf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");",
          "2211:  if ((vs_VersionInfo->wValueLength = r_buf_read_le16_at (bin->b, curAddr)) == UT16_MAX) {",
          "2212:   bprintf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");",
          "2217:  if ((vs_VersionInfo->wType = r_buf_read_le16_at (bin->b, curAddr)) == UT16_MAX) {",
          "2218:   bprintf (\"Warning: read (VS_VERSIONINFO wType)\\n\");",
          "2223:   bprintf (\"Warning: check (VS_VERSIONINFO wType)\\n\");",
          "2229:   bprintf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");",
          "2234:  if (r_buf_read_at (bin->b, curAddr, (ut8*) vs_VersionInfo->szKey, sz) != sz) {",
          "2235:   bprintf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");",
          "",
          "[Added Lines]",
          "2209:  if ((vs_VersionInfo->wLength = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {",
          "2210:   pe_printf (\"Warning: read (VS_VERSIONINFO wLength)\\n\");",
          "2215:  if ((vs_VersionInfo->wValueLength = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {",
          "2216:   pe_printf (\"Warning: read (VS_VERSIONINFO wValueLength)\\n\");",
          "2221:  if ((vs_VersionInfo->wType = r_buf_read_le16_at (pe->b, curAddr)) == UT16_MAX) {",
          "2222:   pe_printf (\"Warning: read (VS_VERSIONINFO wType)\\n\");",
          "2227:   pe_printf (\"Warning: check (VS_VERSIONINFO wType)\\n\");",
          "2233:   pe_printf (\"Warning: malloc (VS_VERSIONINFO szKey)\\n\");",
          "2238:  if (r_buf_read_at (pe->b, curAddr, (ut8*) vs_VersionInfo->szKey, sz) != sz) {",
          "2239:   pe_printf (\"Warning: read (VS_VERSIONINFO szKey)\\n\");",
          "",
          "---------------",
          "--- Hunk 77 ---",
          "[Context before]",
          "2242:  align32 (curAddr);",
          "2243:  if (vs_VersionInfo->wValueLength) {",
          "2244:   if (vs_VersionInfo->wValueLength != sizeof (*vs_VersionInfo->Value)) {",
          "2246:    goto out_error;",
          "2247:   }",
          "2249:   vs_VersionInfo->Value = (PE_VS_FIXEDFILEINFO*) malloc (sizeof (*vs_VersionInfo->Value));",
          "2250:   if (!vs_VersionInfo->Value) {",
          "2252:    goto out_error;",
          "2253:   }",
          "2254:   sz = sizeof (PE_VS_FIXEDFILEINFO);",
          "2255:   EXIT_ON_OVERFLOW (sz);",
          "2258:    goto out_error;",
          "2259:   }",
          "2261:   if (vs_VersionInfo->Value->dwSignature != 0xFEEF04BD) {",
          "2263:    goto out_error;",
          "2264:   }",
          "2265:   curAddr += sz;",
          "",
          "[Removed Lines]",
          "2245:    bprintf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");",
          "2251:    bprintf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");",
          "2256:   if (r_buf_read_at (bin->b, curAddr, (ut8*) vs_VersionInfo->Value, sz) != sz) {",
          "2257:    bprintf (\"Warning: read (VS_VERSIONINFO Value)\\n\");",
          "2262:    bprintf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);",
          "",
          "[Added Lines]",
          "2249:    pe_printf (\"Warning: check (VS_VERSIONINFO wValueLength != sizeof PE_VS_FIXEDFILEINFO)\\n\");",
          "2255:    pe_printf (\"Warning: malloc (VS_VERSIONINFO Value)\\n\");",
          "2260:   if (r_buf_read_at (pe->b, curAddr, (ut8*) vs_VersionInfo->Value, sz) != sz) {",
          "2261:    pe_printf (\"Warning: read (VS_VERSIONINFO Value)\\n\");",
          "2266:    pe_printf (\"Warning: check (PE_VS_FIXEDFILEINFO signature) 0x%08x\\n\", vs_VersionInfo->Value->dwSignature);",
          "",
          "---------------",
          "--- Hunk 78 ---",
          "[Context before]",
          "2269:  if (startAddr + vs_VersionInfo->wLength > curAddr) {",
          "2270:   char t = '\\0';",
          "2272:    goto out_error;",
          "2273:   }",
          "2276:    goto out_error;",
          "2277:   }",
          "2278:   if (!(t == 'S' || t == 'V')) {",
          "2280:    goto out_error;",
          "2281:   }",
          "2282:   if (t == 'S') {",
          "2285:     goto out_error;",
          "2286:    }",
          "2287:   }",
          "2288:   if (t == 'V') {",
          "2291:     goto out_error;",
          "2292:    }",
          "2293:   }",
          "",
          "[Removed Lines]",
          "2271:   if (curAddr + 3 * sizeof (ut16) > bin->size || curAddr + 3 + sizeof (ut64) + 1 > bin->size) {",
          "2274:   if (r_buf_read_at (bin->b, curAddr + 3 * sizeof (ut16), (ut8*) &t, 1) != 1) {",
          "2275:    bprintf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");",
          "2279:    bprintf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");",
          "2283:    if (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (bin, &curAddr))) {",
          "2284:     bprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "2289:    if (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (bin, &curAddr))) {",
          "2290:     bprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "",
          "[Added Lines]",
          "2275:   if (curAddr + 3 * sizeof (ut16) > pe->size || curAddr + 3 + sizeof (ut64) + 1 > pe->size) {",
          "2278:   if (r_buf_read_at (pe->b, curAddr + 3 * sizeof (ut16), (ut8*) &t, 1) != 1) {",
          "2279:    pe_printf (\"Warning: read (VS_VERSIONINFO Children V or S)\\n\");",
          "2283:    pe_printf (\"Warning: bad type (VS_VERSIONINFO Children)\\n\");",
          "2287:    if (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (pe, &curAddr))) {",
          "2288:     pe_printf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "2293:    if (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (pe, &curAddr))) {",
          "2294:     pe_printf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "",
          "---------------",
          "--- Hunk 79 ---",
          "[Context before]",
          "2297:   if (startAddr + vs_VersionInfo->wLength > curAddr) {",
          "2298:    if (t == 'V') {",
          "2301:      goto out_error;",
          "2302:     }",
          "2303:    } else if (t == 'S') {",
          "2306:      goto out_error;",
          "2307:     }",
          "2308:    }",
          "2309:    if (startAddr + vs_VersionInfo->wLength > curAddr) {",
          "2311:     goto out_error;",
          "2312:    }",
          "2313:   }",
          "",
          "[Removed Lines]",
          "2299:     if (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (bin, &curAddr))) {",
          "2300:      bprintf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "2304:     if (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (bin, &curAddr))) {",
          "2305:      bprintf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "2310:     bprintf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");",
          "",
          "[Added Lines]",
          "2303:     if (!(vs_VersionInfo->stringFileInfo = Pe_r_bin_pe_parse_string_file_info (pe, &curAddr))) {",
          "2304:      pe_printf (\"Warning: bad parsing (VS_VERSIONINFO StringFileInfo)\\n\");",
          "2308:     if (!(vs_VersionInfo->varFileInfo = Pe_r_bin_pe_parse_var_file_info (pe, &curAddr))) {",
          "2309:      pe_printf (\"Warning: bad parsing (VS_VERSIONINFO VarFileInfo)\\n\");",
          "2314:     pe_printf (\"Warning: bad parsing (VS_VERSIONINFO wLength left)\\n\");",
          "",
          "---------------",
          "--- Hunk 80 ---",
          "[Context before]",
          "2718:  }",
          "2719: }",
          "2724:  }",
          "2727:  ut32 magic = 0x68636952; // Rich",
          "2728:  if (off % sizeof (ut32)) {",
          "2729:   return;",
          "2730:  }",
          "2732:   off -= sizeof (ut32);",
          "2733:  }",
          "2734:  if (!off) {",
          "2735:   return;",
          "2736:  }",
          "2738:  magic = 0x536E6144; // DanS",
          "2739:  int data;",
          "2740:  off -= sizeof (ut32);",
          "2742:   Pe_image_rich_entry *entry = R_NEW0 (Pe_image_rich_entry);",
          "2743:   if (!entry) {",
          "2744:    return;",
          "2745:   }",
          "2746:   entry->timesUsed = data ^ mask;",
          "2747:   off -= sizeof (ut32);",
          "2749:   entry->productId = data >> 16;",
          "2750:   entry->minVersion = data & 0xFFFF;",
          "2751:   entry->productName = _known_product_ids (entry->productId);",
          "2752:   off -= sizeof (ut32);",
          "2754:  }",
          "2756: }",
          "2758: static char* _resource_lang_str(int id) {",
          "",
          "[Removed Lines]",
          "2721: static void bin_pe_init_rich_info(struct PE_(r_bin_pe_obj_t) *bin) {",
          "2722:  if (!bin->rich_entries) {",
          "2723:   bin->rich_entries = r_list_newf (free);",
          "2725:  bin->rich_header_offset = bin->nt_header_offset;",
          "2726:  ut64 off = bin->nt_header_offset - sizeof (ut32);",
          "2731:  while ((r_buf_read_le32_at (bin->b, off) != magic) && off) {",
          "2737:  ut32 mask = r_buf_read_le32_at (bin->b, off + sizeof (ut32));",
          "2741:  while (((data = r_buf_read_le32_at (bin->b, off)) != magic) && data ^ mask && off > 0x80) {",
          "2748:   data = r_buf_read_le32_at (bin->b, off) ^ mask;",
          "2753:   r_list_append (bin->rich_entries, entry);",
          "2755:  bin->rich_header_offset = off + sizeof (ut32);",
          "",
          "[Added Lines]",
          "2725: static void bin_pe_init_rich_info(RBinPEObj *pe) {",
          "2726:  if (!pe->rich_entries) {",
          "2727:   pe->rich_entries = r_list_newf (free);",
          "2729:  pe->rich_header_offset = pe->nt_header_offset;",
          "2730:  ut64 off = pe->nt_header_offset - sizeof (ut32);",
          "2735:  while ((r_buf_read_le32_at (pe->b, off) != magic) && off) {",
          "2741:  ut32 mask = r_buf_read_le32_at (pe->b, off + sizeof (ut32));",
          "2745:  while (((data = r_buf_read_le32_at (pe->b, off)) != magic) && data ^ mask && off > 0x80) {",
          "2752:   data = r_buf_read_le32_at (pe->b, off) ^ mask;",
          "2757:   r_list_append (pe->rich_entries, entry);",
          "2759:  pe->rich_header_offset = off + sizeof (ut32);",
          "",
          "---------------",
          "--- Hunk 81 ---",
          "[Context before]",
          "2951:  return sizeof (Pe_image_resource_data_entry);",
          "2952: }",
          "2955:  char *resourceEntryName = NULL;",
          "2956:  int index = 0;",
          "2957:  ut32 totalRes = dir->NumberOfNamedEntries + dir->NumberOfIdEntries;",
          "2959:  ut64 off;",
          "2960:  if (totalRes > R_PE_MAX_RESOURCES) {",
          "2961:   return;",
          "",
          "[Removed Lines]",
          "2954: static void _parse_resource_directory(struct PE_(r_bin_pe_obj_t) *bin, Pe_image_resource_directory *dir, ut64 offDir, int type, int id, HtUU *dirs, const char *resource_name) {",
          "2958:  ut64 rsrc_base = bin->resource_directory_offset;",
          "",
          "[Added Lines]",
          "2958: static void _parse_resource_directory(RBinPEObj *pe, Pe_image_resource_directory *dir, ut64 offDir, int type, int id, HtUU *dirs, const char *resource_name) {",
          "2962:  ut64 rsrc_base = pe->resource_directory_offset;",
          "",
          "---------------",
          "--- Hunk 82 ---",
          "[Context before]",
          "2967:    break;",
          "2968:   }",
          "2969:   ht_uu_insert (dirs, off, 1);",
          "2971:    break;",
          "2972:   }",
          "2974:    eprintf (\"Warning: read resource entry\\n\");",
          "2975:    break;",
          "2976:   }",
          "",
          "[Removed Lines]",
          "2970:   if (off > bin->size || off + sizeof (entry) > bin->size) {",
          "2973:   if (read_image_resource_directory_entry (bin->b, off, &entry) < 0) {",
          "",
          "[Added Lines]",
          "2974:   if (off > pe->size || off + sizeof (entry) > pe->size) {",
          "2977:   if (read_image_resource_directory_entry (pe->b, off, &entry) < 0) {",
          "",
          "---------------",
          "--- Hunk 83 ---",
          "[Context before]",
          "2978:    int i;",
          "2979:    ut16 buf;",
          "2980:    ut32 NameOffset = entry.u1.Name & 0x7fffffff;",
          "2982:     break;",
          "2983:    }",
          "2984:    ut16 resourceEntryNameLength = r_read_le16 (&buf);",
          "",
          "[Removed Lines]",
          "2981:    if (r_buf_read_at (bin->b, bin->resource_directory_offset + NameOffset, (ut8*)&buf, sizeof (ut16)) != sizeof (ut16)) {",
          "",
          "[Added Lines]",
          "2985:    if (r_buf_read_at (pe->b, pe->resource_directory_offset + NameOffset, (ut8*)&buf, sizeof (ut16)) != sizeof (ut16)) {",
          "",
          "---------------",
          "--- Hunk 84 ---",
          "[Context before]",
          "2986:    if (resourceEntryName) {",
          "2988:      ut8 byte;",
          "2990:      if (r != sizeof (ut8) || !byte) {",
          "2991:       R_FREE (resourceEntryName);",
          "2992:       break;",
          "",
          "[Removed Lines]",
          "2989:      int r = r_buf_read_at (bin->b, bin->resource_directory_offset + NameOffset + 2 + (i*2), &byte, sizeof (ut8));",
          "",
          "[Added Lines]",
          "2993:      int r = r_buf_read_at (pe->b, pe->resource_directory_offset + NameOffset + 2 + (i*2), &byte, sizeof (ut8));",
          "",
          "---------------",
          "--- Hunk 85 ---",
          "[Context before]",
          "3000:    Pe_image_resource_directory identEntry;",
          "3001:    ut32 OffsetToDirectory = entry.u2.OffsetToData & 0x7fffffff;",
          "3002:    off = rsrc_base + OffsetToDirectory;",
          "3004:    if (len < 1 || len != sizeof (Pe_image_resource_directory)) {",
          "3005:     eprintf (\"Warning: parsing resource directory\\n\");",
          "3006:    }",
          "3008:    R_FREE (resourceEntryName);",
          "3009:    continue;",
          "3010:   }",
          "",
          "[Removed Lines]",
          "3003:    int len = read_image_resource_directory (bin->b, off, &identEntry);",
          "3007:    _parse_resource_directory (bin, &identEntry, OffsetToDirectory, type, entry.u1.Name & 0xffff, dirs, resourceEntryName);",
          "",
          "[Added Lines]",
          "3007:    int len = read_image_resource_directory (pe->b, off, &identEntry);",
          "3011:    _parse_resource_directory (pe, &identEntry, OffsetToDirectory, type, entry.u1.Name & 0xffff, dirs, resourceEntryName);",
          "",
          "---------------",
          "--- Hunk 86 ---",
          "[Context before]",
          "3015:    break;",
          "3016:   }",
          "3017:   off = rsrc_base + entry.u2.OffsetToData;",
          "3019:    free (data);",
          "3020:    break;",
          "3021:   }",
          "3023:    eprintf (\"Warning: read (resource data entry)\\n\");",
          "3024:    free (data);",
          "3025:    break;",
          "",
          "[Removed Lines]",
          "3018:   if (off > bin->size || off + sizeof (*data) > bin->size) {",
          "3022:   if (read_image_resource_data_entry (bin->b, off, data) != sizeof (*data)) {",
          "",
          "[Added Lines]",
          "3022:   if (off > pe->size || off + sizeof (*data) > pe->size) {",
          "3026:   if (read_image_resource_data_entry (pe->b, off, data) != sizeof (*data)) {",
          "",
          "---------------",
          "--- Hunk 87 ---",
          "[Context before]",
          "3033:     sdb_free (sdb);",
          "3034:     continue;",
          "3035:    }",
          "3037:    if (!data_paddr) {",
          "3039:     free (data);",
          "3040:     sdb_free (sdb);",
          "3041:     continue;",
          "3042:    }",
          "3043:    PE_DWord cur_paddr = data_paddr;",
          "3044:    if ((cur_paddr & 0x3) != 0) {",
          "3046:     free (data);",
          "3047:     sdb_free (sdb);",
          "3048:     continue;",
          "3049:    }",
          "3052:     if (!vs_VersionInfo) {",
          "3053:      break;",
          "3054:     }",
          "",
          "[Removed Lines]",
          "3036:    PE_DWord data_paddr = PE_(va2pa) (bin, data->OffsetToData);",
          "3038:     bprintf (\"Warning: bad RVA in resource data entry\\n\");",
          "3045:     bprintf (\"Warning: not aligned version info address\\n\");",
          "3050:    while (cur_paddr < (data_paddr + data->Size) && cur_paddr < bin->size) {",
          "3051:     PE_VS_VERSIONINFO* vs_VersionInfo = Pe_r_bin_pe_parse_version_info (bin, cur_paddr);",
          "",
          "[Added Lines]",
          "3040:    PE_DWord data_paddr = PE_(va2pa) (pe, data->OffsetToData);",
          "3042:     pe_printf (\"Warning: bad RVA in resource data entry\\n\");",
          "3049:     pe_printf (\"Warning: not aligned version info address\\n\");",
          "3054:    while (cur_paddr < (data_paddr + data->Size) && cur_paddr < pe->size) {",
          "3055:     PE_VS_VERSIONINFO* vs_VersionInfo = Pe_r_bin_pe_parse_version_info (pe, cur_paddr);",
          "",
          "---------------",
          "--- Hunk 88 ---",
          "[Context before]",
          "3062:     free_VS_VERSIONINFO (vs_VersionInfo);",
          "3063:     align32 (cur_paddr);",
          "3064:    }",
          "3066:   }",
          "3067:   r_pe_resource *rs = R_NEW0 (r_pe_resource);",
          "3068:   if (!rs) {",
          "",
          "[Removed Lines]",
          "3065:    sdb_ns_set (bin->kv, \"vs_version_info\", sdb);",
          "",
          "[Added Lines]",
          "3069:    sdb_ns_set (pe->kv, \"vs_version_info\", sdb);",
          "",
          "---------------",
          "--- Hunk 89 ---",
          "[Context before]",
          "3070:    break;",
          "3071:   }",
          "3074:    rs->timestr = r_time_stamp_to_str ( r_time_dos_time_stamp_to_posix (dir->TimeDateStamp));",
          "3075:   } else {",
          "3076:    rs->timestr = r_time_stamp_to_str (dir->TimeDateStamp);",
          "",
          "[Removed Lines]",
          "3073:   if (r_time_stamp_is_dos_format ((ut32) sdb_num_get (bin->kv, \"image_file_header.TimeDateStamp\", 0), dir->TimeDateStamp)) {",
          "",
          "[Added Lines]",
          "3077:   if (r_time_stamp_is_dos_format ((ut32) sdb_num_get (pe->kv, \"image_file_header.TimeDateStamp\", 0), dir->TimeDateStamp)) {",
          "",
          "---------------",
          "--- Hunk 90 ---",
          "[Context before]",
          "3083:   } else {",
          "3084:    rs->name = r_str_newf (\"%d\", id);",
          "3085:   }",
          "3087:  }",
          "3088: }",
          "3091:  r_strf_buffer (64);",
          "3092:  RListIter *iter;",
          "3093:  r_pe_resource *rs;",
          "",
          "[Removed Lines]",
          "3086:   r_list_append (bin->resources, rs);",
          "3090: static void _store_resource_sdb(struct PE_(r_bin_pe_obj_t) *bin) {",
          "",
          "[Added Lines]",
          "3090:   r_list_append (pe->resources, rs);",
          "3094: static void _store_resource_sdb(RBinPEObj *pe) {",
          "",
          "---------------",
          "--- Hunk 91 ---",
          "[Context before]",
          "3098:  if (!sdb) {",
          "3099:   return;",
          "3100:  }",
          "3102:   key = r_strf (\"resource.%d.timestr\", index);",
          "3103:   sdb_set (sdb, key, rs->timestr, 0);",
          "3104:   key = r_strf (\"resource.%d.vaddr\", index);",
          "3106:   sdb_num_set (sdb, key, vaddr, 0);",
          "3107:   key = r_strf (\"resource.%d.name\", index);",
          "3108:   sdb_set (sdb, key, rs->name, 0);",
          "",
          "[Removed Lines]",
          "3101:  r_list_foreach (bin->resources, iter, rs) {",
          "3105:   vaddr = bin_pe_rva_to_va (bin, rs->data->OffsetToData);",
          "",
          "[Added Lines]",
          "3105:  r_list_foreach (pe->resources, iter, rs) {",
          "3109:   vaddr = bin_pe_rva_to_va (pe, rs->data->OffsetToData);",
          "",
          "---------------",
          "--- Hunk 92 ---",
          "[Context before]",
          "3114:   sdb_set (sdb, key, rs->language, 0);",
          "3115:   index++;",
          "3116:  }",
          "3118: }",
          "3122:  int index = 0;",
          "3125:  ut32 curRes = 0;",
          "3126:  int totalRes = 0;",
          "3127:  HtUUOptions opt = { 0 };",
          "",
          "[Removed Lines]",
          "3117:  sdb_ns_set (bin->kv, \"pe_resource\", sdb);",
          "3121: R_API void PE_(bin_pe_parse_resource)(struct PE_(r_bin_pe_obj_t) *bin) {",
          "3123:  ut64 off = 0, rsrc_base = bin->resource_directory_offset;",
          "3124:  Pe_image_resource_directory *rs_directory = bin->resource_directory;",
          "",
          "[Added Lines]",
          "3121:  sdb_ns_set (pe->kv, \"pe_resource\", sdb);",
          "3125: R_API void PE_(bin_pe_parse_resource)(RBinPEObj *pe) {",
          "3127:  ut64 off = 0, rsrc_base = pe->resource_directory_offset;",
          "3128:  Pe_image_resource_directory *rs_directory = pe->resource_directory;",
          "",
          "---------------",
          "--- Hunk 93 ---",
          "[Context before]",
          "3144:   Pe_image_resource_directory_entry typeEntry;",
          "3145:   off = rsrc_base + sizeof (*rs_directory) + index * sizeof (typeEntry);",
          "3146:   ht_uu_insert (dirs, off, 1);",
          "3148:    break;",
          "3149:   }",
          "3151:    eprintf (\"Warning: read resource directory entry\\n\");",
          "3152:    break;",
          "3153:   }",
          "",
          "[Removed Lines]",
          "3147:   if (off > bin->size || off + sizeof (typeEntry) > bin->size) {",
          "3150:   if (read_image_resource_directory_entry (bin->b, off, &typeEntry) < 0) {",
          "",
          "[Added Lines]",
          "3151:   if (off > pe->size || off + sizeof (typeEntry) > pe->size) {",
          "3154:   if (read_image_resource_directory_entry (pe->b, off, &typeEntry) < 0) {",
          "",
          "---------------",
          "--- Hunk 94 ---",
          "[Context before]",
          "3155:    Pe_image_resource_directory identEntry;",
          "3156:    ut32 OffsetToDirectory = typeEntry.u2.OffsetToData & 0x7fffffff;",
          "3157:    off = rsrc_base + OffsetToDirectory;",
          "3159:    if (len != sizeof (identEntry)) {",
          "3160:     eprintf (\"Warning: parsing resource directory\\n\");",
          "3161:    }",
          "3163:   }",
          "3164:  }",
          "3165:  ht_uu_free (dirs);",
          "3167: }",
          "3171:   return false;",
          "3172:  }",
          "3174:   return false;",
          "3175:  }",
          "3177:  PE_DWord paddr = data_dir_security->VirtualAddress;",
          "3178:  ut32 size = data_dir_security->Size;",
          "3181:   return false;",
          "3182:  }",
          "",
          "[Removed Lines]",
          "3158:    int len = read_image_resource_directory (bin->b, off, &identEntry);",
          "3162:    (void)_parse_resource_directory (bin, &identEntry, OffsetToDirectory, typeEntry.u1.Name & 0xffff, 0, dirs, NULL);",
          "3166:  _store_resource_sdb (bin);",
          "3169: static int bin_pe_init_security(struct PE_(r_bin_pe_obj_t) *bin) {",
          "3170:  if (!bin || !bin->nt_headers) {",
          "3173:  if (bin->nt_headers->optional_header.NumberOfRvaAndSizes < 5) {",
          "3176:  PE_(image_data_directory) *data_dir_security = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];",
          "3179:  if (size < 8 || paddr > bin->size || paddr + size > bin->size) {",
          "3180:   bprintf (\"Invalid certificate table\");",
          "",
          "[Added Lines]",
          "3162:    int len = read_image_resource_directory (pe->b, off, &identEntry);",
          "3166:    (void)_parse_resource_directory (pe, &identEntry, OffsetToDirectory, typeEntry.u1.Name & 0xffff, 0, dirs, NULL);",
          "3170:  _store_resource_sdb (pe);",
          "3173: static int bin_pe_init_security(RBinPEObj *pe) {",
          "3174:  if (!pe || !pe->nt_headers) {",
          "3177:  if (pe->nt_headers->optional_header.NumberOfRvaAndSizes < 5) {",
          "3180:  PE_(image_data_directory) *data_dir_security = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_SECURITY];",
          "3183:  if (size < 8 || paddr > pe->size || paddr + size > pe->size) {",
          "3184:   pe_printf (\"Invalid certificate table\");",
          "",
          "---------------",
          "--- Hunk 95 ---",
          "[Context before]",
          "3185:  if (!security_directory) {",
          "3186:   return false;",
          "3187:  }",
          "3190:  PE_DWord offset = paddr;",
          "3191:  while (offset < paddr + size) {",
          "",
          "[Removed Lines]",
          "3188:  bin->security_directory = security_directory;",
          "",
          "[Added Lines]",
          "3192:  pe->security_directory = security_directory;",
          "",
          "---------------",
          "--- Hunk 96 ---",
          "[Context before]",
          "3198:   if (!cert) {",
          "3199:    return false;",
          "3200:   }",
          "3202:   cert->dwLength += (8 - (cert->dwLength & 7)) & 7; // align32",
          "3203:   if (offset + cert->dwLength > paddr + size) {",
          "3205:    R_FREE (cert);",
          "3206:    return false;",
          "3207:   }",
          "3210:   if (cert->dwLength < 6) {",
          "3211:    eprintf (\"Cert.dwLength must be > 6\\n\");",
          "3212:    R_FREE (cert);",
          "",
          "[Removed Lines]",
          "3201:   cert->dwLength = r_buf_read_le32_at (bin->b, offset);",
          "3204:    bprintf (\"Invalid certificate entry\");",
          "3208:   cert->wRevision = r_buf_read_le16_at (bin->b, offset + 4);",
          "3209:   cert->wCertificateType = r_buf_read_le16_at (bin->b, offset + 6);",
          "",
          "[Added Lines]",
          "3205:   cert->dwLength = r_buf_read_le32_at (pe->b, offset);",
          "3208:    pe_printf (\"Invalid certificate entry\");",
          "3212:   cert->wRevision = r_buf_read_le16_at (pe->b, offset + 4);",
          "3213:   cert->wCertificateType = r_buf_read_le16_at (pe->b, offset + 6);",
          "",
          "---------------",
          "--- Hunk 97 ---",
          "[Context before]",
          "3216:    R_FREE (cert);",
          "3217:    return false;",
          "3218:   }",
          "3225:    }",
          "3226:   }",
          "",
          "[Removed Lines]",
          "3219:   r_buf_read_at (bin->b, offset + 8, cert->bCertificate, cert->dwLength - 6);",
          "3221:   if (!bin->cms && cert->wCertificateType == PE_WIN_CERT_TYPE_PKCS_SIGNED_DATA) {",
          "3222:    bin->cms = r_pkcs7_parse_cms (cert->bCertificate, cert->dwLength - 6);",
          "3223:    if (bin->cms) {",
          "3224:     bin->spcinfo = r_pkcs7_parse_spcinfo (bin->cms);",
          "",
          "[Added Lines]",
          "3223:   r_buf_read_at (pe->b, offset + 8, cert->bCertificate, cert->dwLength - 6);",
          "3225:   if (!pe->cms && cert->wCertificateType == PE_WIN_CERT_TYPE_PKCS_SIGNED_DATA) {",
          "3226:    pe->cms = r_pkcs7_parse_cms (cert->bCertificate, cert->dwLength - 6);",
          "3227:    if (pe->cms) {",
          "3228:     pe->spcinfo = r_pkcs7_parse_spcinfo (pe->cms);",
          "",
          "---------------",
          "--- Hunk 98 ---",
          "[Context before]",
          "3230:   offset += cert->dwLength;",
          "3231:  }",
          "3236:   if (actual_authentihash && claimed_authentihash) {",
          "3238:   } else {",
          "3240:   }",
          "3241:   if (actual_authentihash) {",
          "3242:    free ((void *)actual_authentihash);",
          "3243:   }",
          "3244:   free ((void *)claimed_authentihash);",
          "3245:  }",
          "3247:  return true;",
          "3248: }",
          "",
          "[Removed Lines]",
          "3233:  if (bin->cms && bin->spcinfo) {",
          "3234:   const char *actual_authentihash = PE_(bin_pe_compute_authentihash) (bin);",
          "3235:   const char *claimed_authentihash = PE_(bin_pe_get_claimed_authentihash) (bin);",
          "3237:    bin->is_authhash_valid = !strcmp (actual_authentihash, claimed_authentihash);",
          "3239:    bin->is_authhash_valid = false;",
          "3246:  bin->is_signed = bin->cms != NULL;",
          "",
          "[Added Lines]",
          "3237:  if (pe->cms && pe->spcinfo) {",
          "3238:   const char *actual_authentihash = PE_(bin_pe_compute_authentihash) (pe);",
          "3239:   const char *claimed_authentihash = PE_(bin_pe_get_claimed_authentihash) (pe);",
          "3241:    pe->is_authhash_valid = !strcmp (actual_authentihash, claimed_authentihash);",
          "3243:    pe->is_authhash_valid = false;",
          "3250:  pe->is_signed = pe->cms != NULL;",
          "",
          "---------------",
          "--- Hunk 99 ---",
          "[Context before]",
          "3259:  free (security_directory);",
          "3260: }",
          "3277:   eprintf (\"Warning: File is not PE\\n\");",
          "3278:   return false;",
          "3279:  }",
          "3281:   eprintf (\"Warning: Cannot initialize sections\\n\");",
          "3282:   return false;",
          "3283:  }",
          "3299:  return true;",
          "3300: }",
          "3303:  char* arch;",
          "3305:   return strdup (\"x86\");",
          "3306:  }",
          "3308:  case PE_IMAGE_FILE_MACHINE_ALPHA:",
          "3309:  case PE_IMAGE_FILE_MACHINE_ALPHA64:",
          "3310:   arch = strdup (\"alpha\");",
          "",
          "[Removed Lines]",
          "3262: static int bin_pe_init(struct PE_(r_bin_pe_obj_t)* bin) {",
          "3263:  bin->dos_header = NULL;",
          "3264:  bin->nt_headers = NULL;",
          "3265:  bin->section_header = NULL;",
          "3266:  bin->export_directory = NULL;",
          "3267:  bin->import_directory = NULL;",
          "3268:  bin->resource_directory = NULL;",
          "3269:  bin->security_directory = NULL;",
          "3270:  bin->delay_import_directory = NULL;",
          "3271:  bin->optional_header = NULL;",
          "3272:  bin->data_directory = NULL;",
          "3273:  bin->big_endian = 0;",
          "3274:  bin->cms = NULL;",
          "3275:  bin->spcinfo = NULL;",
          "3276:  if (!bin_pe_init_hdr (bin)) {",
          "3280:  if (!bin_pe_init_sections (bin)) {",
          "3284:  bin->sections = PE_(r_bin_pe_get_sections) (bin);",
          "3285:  bin_pe_init_imports (bin);",
          "3286:  bin_pe_init_exports (bin);",
          "3287:  bin_pe_init_resource (bin);",
          "3288:  bin_pe_init_security (bin);",
          "3290:  bin->big_endian = PE_(r_bin_pe_is_big_endian) (bin);",
          "3292:  bin_pe_init_rich_info (bin);",
          "3293:  bin_pe_init_tls (bin);",
          "3294:  bin_pe_init_clr_hdr (bin);",
          "3295:  bin_pe_init_metadata_hdr (bin);",
          "3296:  bin_pe_init_overlay (bin);",
          "3297:  PE_(bin_pe_parse_resource) (bin);",
          "3298:  bin->relocs = NULL;",
          "3302: char* PE_(r_bin_pe_get_arch)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "3304:  if (!bin || !bin->nt_headers) {",
          "3307:  switch (bin->nt_headers->file_header.Machine) {",
          "",
          "[Added Lines]",
          "3266: static int bin_pe_init(RBinPEObj* pe) {",
          "3267:  pe->dos_header = NULL;",
          "3268:  pe->nt_headers = NULL;",
          "3269:  pe->section_header = NULL;",
          "3270:  pe->export_directory = NULL;",
          "3271:  pe->import_directory = NULL;",
          "3272:  pe->resource_directory = NULL;",
          "3273:  pe->security_directory = NULL;",
          "3274:  pe->delay_import_directory = NULL;",
          "3275:  pe->optional_header = NULL;",
          "3276:  pe->data_directory = NULL;",
          "3277:  pe->big_endian = 0;",
          "3278:  pe->cms = NULL;",
          "3279:  pe->spcinfo = NULL;",
          "3280:  if (!bin_pe_init_hdr (pe)) {",
          "3284:  if (!bin_pe_init_sections (pe)) {",
          "3288:  pe->sections = PE_(r_bin_pe_get_sections) (pe);",
          "3289:  bin_pe_init_imports (pe);",
          "3290:  bin_pe_init_exports (pe);",
          "3291:  bin_pe_init_resource (pe);",
          "3292:  bin_pe_init_security (pe);",
          "3294:  pe->big_endian = PE_(r_bin_pe_is_big_endian) (pe);",
          "3296:  bin_pe_init_rich_info (pe);",
          "3297:  bin_pe_init_tls (pe);",
          "3298:  bin_pe_init_clr_hdr (pe);",
          "3299:  bin_pe_init_metadata_hdr (pe);",
          "3300:  bin_pe_init_overlay (pe);",
          "3301:  PE_(bin_pe_parse_resource) (pe);",
          "3302:  pe->relocs = NULL;",
          "3306: char* PE_(r_bin_pe_get_arch)(RBinPEObj* pe) {",
          "3308:  if (!pe || !pe->nt_headers) {",
          "3311:  switch (pe->nt_headers->file_header.Machine) {",
          "",
          "---------------",
          "--- Hunk 100 ---",
          "[Context before]",
          "3344:  return arch;",
          "3345: }",
          "3348:  struct r_bin_pe_addr_t* entry = NULL;",
          "3349:  static bool debug = false;",
          "3350:  int i;",
          "3353:   return NULL;",
          "3354:  }",
          "3355:  if (!(entry = malloc (sizeof (struct r_bin_pe_addr_t)))) {",
          "3356:   r_sys_perror (\"malloc (entrypoint)\");",
          "3357:   return NULL;",
          "3358:  }",
          "3367:   ut64 paddr = 0;",
          "3368:   if (!debug) {",
          "3370:     \"trying to fix it but i do not promise nothing\\n\");",
          "3371:   }",
          "3373:    if (sections[i].perm & PE_IMAGE_SCN_MEM_EXECUTE) {",
          "3374:     entry->paddr = sections[i].paddr;",
          "3375:     entry->vaddr = sections[i].vaddr + base_addr;",
          "",
          "[Removed Lines]",
          "3347: struct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "3351:  ut64 base_addr = PE_(r_bin_pe_get_image_base) (bin);",
          "3352:  if (!bin || !bin->optional_header) {",
          "3359:  PE_DWord pe_entry = bin->optional_header->AddressOfEntryPoint;",
          "3360:  entry->vaddr = bin_pe_rva_to_va (bin, pe_entry);",
          "3361:  entry->paddr = PE_(va2pa) (bin, pe_entry);",
          "3363:  entry->haddr = bin->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) + 16;",
          "3365:  if (entry->paddr >= bin->size) {",
          "3366:   struct r_bin_pe_section_t* sections = bin->sections;",
          "3369:    bprintf (\"Warning: Invalid entrypoint ... \"",
          "3372:   for (i = 0; i < bin->num_sections; i++) {",
          "",
          "[Added Lines]",
          "3351: struct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(RBinPEObj* pe) {",
          "3355:  ut64 base_addr = PE_(r_bin_pe_get_image_base) (pe);",
          "3356:  if (!pe || !pe->optional_header) {",
          "3363:  PE_DWord pe_entry = pe->optional_header->AddressOfEntryPoint;",
          "3364:  entry->vaddr = bin_pe_rva_to_va (pe, pe_entry);",
          "3365:  entry->paddr = PE_(va2pa) (pe, pe_entry);",
          "3367:  entry->haddr = pe->dos_header->e_lfanew + 4 + sizeof (PE_(image_file_header)) + 16;",
          "3369:  if (entry->paddr >= pe->size) {",
          "3370:   struct r_bin_pe_section_t* sections = pe->sections;",
          "3373:    pe_printf (\"Warning: Invalid entrypoint ... \"",
          "3376:   for (i = 0; i < pe->num_sections; i++) {",
          "",
          "---------------",
          "--- Hunk 101 ---",
          "[Context before]",
          "3380:   }",
          "3381:   if (!paddr) {",
          "3382:    ut64 min_off = -1;",
          "3385:     if (sections[i].paddr < min_off) {",
          "3386:      entry->paddr = sections[i].paddr;",
          "",
          "[Removed Lines]",
          "3383:    for (i = 0; i < bin->num_sections; i++) {",
          "",
          "[Added Lines]",
          "3387:    for (i = 0; i < pe->num_sections; i++) {",
          "",
          "---------------",
          "--- Hunk 102 ---",
          "[Context before]",
          "3391:    if (min_off == -1) {",
          "3395:     entry->paddr = pe_entry & ((sa << 1) - 1);",
          "3396:     entry->vaddr = entry->paddr + base_addr;",
          "3397:    }",
          "",
          "[Removed Lines]",
          "3394:     int sa = R_MAX (bin->optional_header->SectionAlignment, 0x1000);",
          "",
          "[Added Lines]",
          "3398:     int sa = R_MAX (pe->optional_header->SectionAlignment, 0x1000);",
          "",
          "---------------",
          "--- Hunk 103 ---",
          "[Context before]",
          "3399:  }",
          "3400:  if (!entry->paddr) {",
          "3401:   if (!debug) {",
          "3403:   }",
          "3407:    if (sections[i].perm & PE_IMAGE_SCN_MEM_EXECUTE && !(sections[i].perm & PE_IMAGE_SCN_MEM_WRITE)) {",
          "3408:     entry->paddr = sections[i].paddr;",
          "",
          "[Removed Lines]",
          "3402:    bprintf (\"Warning: NULL entrypoint\\n\");",
          "3404:   struct r_bin_pe_section_t* sections = bin->sections;",
          "3405:   for (i = 0; i < bin->num_sections; i++) {",
          "",
          "[Added Lines]",
          "3406:    pe_printf (\"Warning: NULL entrypoint\\n\");",
          "3408:   struct r_bin_pe_section_t* sections = pe->sections;",
          "3409:   for (i = 0; i < pe->num_sections; i++) {",
          "",
          "---------------",
          "--- Hunk 104 ---",
          "[Context before]",
          "3413:   }",
          "3414:  }",
          "3417:   entry->vaddr--;",
          "3418:   if (entry->paddr & 1) {",
          "3419:    entry->paddr--;",
          "",
          "[Removed Lines]",
          "3416:  if (is_arm (bin) && entry->vaddr & 1) {",
          "",
          "[Added Lines]",
          "3420:  if (is_arm (pe) && entry->vaddr & 1) {",
          "",
          "---------------",
          "--- Hunk 105 ---",
          "[Context before]",
          "3425:  return entry;",
          "3426: }",
          "3430:  struct r_bin_pe_export_t* exp, * exports = NULL;",
          "3431:  PE_Word function_ordinal = 0;",
          "3432:  PE_VWord functions_paddr, names_paddr, ordinals_paddr, function_rva, name_vaddr, name_paddr;",
          "",
          "[Removed Lines]",
          "3428: struct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "3429:  r_return_val_if_fail (bin, NULL);",
          "",
          "[Added Lines]",
          "3432: struct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(RBinPEObj* pe) {",
          "3433:  r_return_val_if_fail (pe, NULL);",
          "",
          "---------------",
          "--- Hunk 106 ---",
          "[Context before]",
          "3437:  int n,i, export_dir_size;",
          "3438:  st64 exports_sz = 0;",
          "3441:   return NULL;",
          "3442:  }",
          "3444:  export_dir_rva = data_dir_export->VirtualAddress;",
          "3445:  export_dir_size = data_dir_export->Size;",
          "3446:  PE_VWord *func_rvas = NULL;",
          "3447:  PE_Word *ordinals = NULL;",
          "3452:    return NULL;",
          "3453:   }",
          "3458:    return NULL;",
          "3459:   }",
          "3460:   if (!(exports = malloc (exports_sz))) {",
          "3461:    return NULL;",
          "3462:   }",
          "3466:    dll_name[0] = '\\0';",
          "3467:   }",
          "3474:   ordinals = malloc (names_sz);",
          "3475:   func_rvas = malloc (funcs_sz);",
          "3476:   if (!ordinals || !func_rvas) {",
          "3477:    goto beach;",
          "3478:   }",
          "3480:   if (r != names_sz) {",
          "3481:    goto beach;",
          "3482:   }",
          "3484:   if (r != funcs_sz) {",
          "3485:    goto beach;",
          "3486:   }",
          "3493:     name_vaddr = 0;",
          "3497:      if (i == fo) {",
          "3498:       function_ordinal = fo;",
          "3501:       break;",
          "3502:      }",
          "3503:     }",
          "3505:     if (name_vaddr) {",
          "3510:       exports[i].last = 1;",
          "3511:       return exports;",
          "3512:      }",
          "3513:     } else { // No name export, get the ordinal",
          "3514:      function_ordinal = i;",
          "3516:     }",
          "3517:    } else { // if export by name dont exist, get the ordinal taking in mind the Base value.",
          "3519:    }",
          "3521:    if (function_rva >= export_dir_rva && function_rva < (export_dir_rva + export_dir_size)) {",
          "3524:      exports[i].last = 1;",
          "3525:      return exports;",
          "3526:     }",
          "",
          "[Removed Lines]",
          "3440:  if (!bin->data_directory) {",
          "3443:  data_dir_export = &bin->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];",
          "3448:  if (bin->export_directory) {",
          "3449:   if (bin->export_directory->NumberOfFunctions + 1 <",
          "3450:   bin->export_directory->NumberOfFunctions) {",
          "3454:   exports_sz = (bin->export_directory->NumberOfFunctions + 1) * sizeof (struct r_bin_pe_export_t);",
          "3457:   if (exports_sz < 0 || bin->export_directory->NumberOfFunctions + 1 > 0xffff) {",
          "3463:   if (r_buf_read_at (bin->b, PE_(va2pa) (bin, bin->export_directory->Name), (ut8*) dll_name, PE_NAME_LENGTH) < 1) {",
          "3465:    bprintf (\"Warning: read (dll name)\\n\");",
          "3468:   functions_paddr = PE_(va2pa) (bin, bin->export_directory->AddressOfFunctions);",
          "3469:   names_paddr = PE_(va2pa) (bin, bin->export_directory->AddressOfNames);",
          "3470:   ordinals_paddr = PE_(va2pa) (bin, bin->export_directory->AddressOfOrdinals);",
          "3472:   const size_t names_sz = bin->export_directory->NumberOfNames * sizeof (PE_Word);",
          "3473:   const size_t funcs_sz = bin->export_directory->NumberOfFunctions * sizeof (PE_VWord);",
          "3479:   int r = r_buf_read_at (bin->b, ordinals_paddr, (ut8 *)ordinals, names_sz);",
          "3483:   r = r_buf_read_at (bin->b, functions_paddr, (ut8 *)func_rvas, funcs_sz);",
          "3487:   for (i = 0; i < bin->export_directory->NumberOfFunctions; i++) {",
          "3489:    function_rva = r_read_at_ble32 ((ut8 *)func_rvas, i * sizeof (PE_VWord), bin->endian);",
          "3491:    if (bin->export_directory->NumberOfNames > 0) {",
          "3494:     for (n = 0; n < bin->export_directory->NumberOfNames; n++) {",
          "3495:      PE_Word fo = r_read_at_ble16 ((ut8 *)ordinals, n * sizeof (PE_Word), bin->endian);",
          "3500:       name_vaddr = r_buf_read_le32_at (bin->b, names_paddr + n * sizeof (PE_VWord));",
          "3507:      name_paddr = PE_(va2pa) (bin, name_vaddr);",
          "3508:      if (r_buf_read_at (bin->b, name_paddr, (ut8*) function_name, PE_NAME_LENGTH) < 1) {",
          "3509:       bprintf (\"Warning: read (function name)\\n\");",
          "3515:      snprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + bin->export_directory->Base);",
          "3518:     snprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + bin->export_directory->Base);",
          "3523:     if (r_buf_read_at (bin->b, PE_(va2pa) (bin, function_rva), (ut8*) forwarder_name, PE_NAME_LENGTH) < 1) {",
          "",
          "[Added Lines]",
          "3444:  if (!pe->data_directory) {",
          "3447:  data_dir_export = &pe->data_directory[PE_IMAGE_DIRECTORY_ENTRY_EXPORT];",
          "3452:  if (pe->export_directory) {",
          "3453:   if (pe->export_directory->NumberOfFunctions + 1 <",
          "3454:   pe->export_directory->NumberOfFunctions) {",
          "3458:   exports_sz = (pe->export_directory->NumberOfFunctions + 1) * sizeof (struct r_bin_pe_export_t);",
          "3461:   if (exports_sz < 0 || pe->export_directory->NumberOfFunctions + 1 > 0xffff) {",
          "3467:   if (r_buf_read_at (pe->b, PE_(va2pa) (pe, pe->export_directory->Name), (ut8*) dll_name, PE_NAME_LENGTH) < 1) {",
          "3469:    pe_printf (\"Warning: read (dll name)\\n\");",
          "3472:   functions_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfFunctions);",
          "3473:   names_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfNames);",
          "3474:   ordinals_paddr = PE_(va2pa) (pe, pe->export_directory->AddressOfOrdinals);",
          "3476:   const size_t names_sz = pe->export_directory->NumberOfNames * sizeof (PE_Word);",
          "3477:   const size_t funcs_sz = pe->export_directory->NumberOfFunctions * sizeof (PE_VWord);",
          "3483:   int r = r_buf_read_at (pe->b, ordinals_paddr, (ut8 *)ordinals, names_sz);",
          "3487:   r = r_buf_read_at (pe->b, functions_paddr, (ut8 *)func_rvas, funcs_sz);",
          "3491:   for (i = 0; i < pe->export_directory->NumberOfFunctions; i++) {",
          "3493:    function_rva = r_read_at_ble32 ((ut8 *)func_rvas, i * sizeof (PE_VWord), pe->endian);",
          "3495:    if (pe->export_directory->NumberOfNames > 0) {",
          "3498:     for (n = 0; n < pe->export_directory->NumberOfNames; n++) {",
          "3499:      PE_Word fo = r_read_at_ble16 ((ut8 *)ordinals, n * sizeof (PE_Word), pe->endian);",
          "3504:       name_vaddr = r_buf_read_le32_at (pe->b, names_paddr + n * sizeof (PE_VWord));",
          "3511:      name_paddr = PE_(va2pa) (pe, name_vaddr);",
          "3512:      if (r_buf_read_at (pe->b, name_paddr, (ut8*) function_name, PE_NAME_LENGTH) < 1) {",
          "3513:       pe_printf (\"Warning: read (function name)\\n\");",
          "3519:      snprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + pe->export_directory->Base);",
          "3522:     snprintf (function_name, PE_NAME_LENGTH, \"Ordinal_%i\", i + pe->export_directory->Base);",
          "3527:     if (r_buf_read_at (pe->b, PE_(va2pa) (pe, function_rva), (ut8*) forwarder_name, PE_NAME_LENGTH) < 1) {",
          "",
          "---------------",
          "--- Hunk 107 ---",
          "[Context before]",
          "3529:    }",
          "3530:    dll_name[PE_NAME_LENGTH] = '\\0';",
          "3531:    function_name[PE_NAME_LENGTH] = '\\0';",
          "3535:    memcpy (exports[i].forwarder, forwarder_name, PE_NAME_LENGTH);",
          "3536:    exports[i].forwarder[PE_NAME_LENGTH] = '\\0';",
          "3537:    memcpy (exports[i].name, function_name, PE_NAME_LENGTH);",
          "",
          "[Removed Lines]",
          "3532:    exports[i].vaddr = bin_pe_rva_to_va (bin, function_rva);",
          "3533:    exports[i].paddr = PE_(va2pa) (bin, function_rva);",
          "3534:    exports[i].ordinal = function_ordinal + bin->export_directory->Base;",
          "",
          "[Added Lines]",
          "3536:    exports[i].vaddr = bin_pe_rva_to_va (pe, function_rva);",
          "3537:    exports[i].paddr = PE_(va2pa) (pe, function_rva);",
          "3538:    exports[i].ordinal = function_ordinal + pe->export_directory->Base;",
          "",
          "---------------",
          "--- Hunk 108 ---",
          "[Context before]",
          "3544:   free (ordinals);",
          "3545:   free (func_rvas);",
          "3546:  }",
          "3548:  if (exp) {",
          "3549:   exports = exp;",
          "3550:  }",
          "",
          "[Removed Lines]",
          "3547:  exp = parse_symbol_table (bin, exports, exports_sz - sizeof (struct r_bin_pe_export_t));",
          "",
          "[Added Lines]",
          "3551:  exp = parse_symbol_table (pe, exports, exports_sz - sizeof (struct r_bin_pe_export_t));",
          "",
          "---------------",
          "--- Hunk 109 ---",
          "[Context before]",
          "3593:  res->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);",
          "3594: }",
          "3597:  #define SIZEOF_FILE_NAME 255",
          "3598:  int i = 0;",
          "3599:  const char* dbgname;",
          "",
          "[Removed Lines]",
          "3596: static int get_debug_info(struct PE_(r_bin_pe_obj_t)* bin, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {",
          "",
          "[Added Lines]",
          "3600: static int get_debug_info(RBinPEObj* pe, PE_(image_debug_directory_entry)* dbg_dir_entry, ut8* dbg_data, int dbg_data_len, SDebugInfo* res) {",
          "",
          "---------------",
          "--- Hunk 110 ---",
          "[Context before]",
          "3606:    SCV_RSDS_HEADER rsds_hdr;",
          "3607:    init_rsdr_hdr (&rsds_hdr);",
          "3608:    if (!get_rsds (dbg_data, dbg_data_len, &rsds_hdr)) {",
          "3610:     return 0;",
          "3611:    }",
          "3612:    snprintf (res->guidstr, GUIDSTR_LEN,",
          "",
          "[Removed Lines]",
          "3609:     bprintf (\"Warning: Cannot read PE debug info\\n\");",
          "",
          "[Added Lines]",
          "3613:     pe_printf (\"Warning: Cannot read PE debug info\\n\");",
          "",
          "---------------",
          "--- Hunk 111 ---",
          "[Context before]",
          "3646:    res->file_name[sizeof (res->file_name) - 1] = 0;",
          "3647:    nb10_hdr.free ((struct SCV_NB10_HEADER*) &nb10_hdr);",
          "3648:   } else {",
          "3650:    return 0;",
          "3651:   }",
          "3652:   break;",
          "3653:  default:",
          "3655:   return 0;",
          "3656:  }",
          "",
          "[Removed Lines]",
          "3649:    bprintf (\"CodeView section not NB10 or RSDS\\n\");",
          "",
          "[Added Lines]",
          "3653:    pe_printf (\"CodeView section not NB10 or RSDS\\n\");",
          "",
          "---------------",
          "--- Hunk 112 ---",
          "[Context before]",
          "3682:  return sizeof (PE_(image_debug_directory_entry));",
          "3683: }",
          "3686:  PE_(image_debug_directory_entry) img_dbg_dir_entry = {0};",
          "3687:  PE_(image_data_directory) *dbg_dir = NULL;",
          "3688:  PE_DWord dbg_dir_offset;",
          "3689:  ut8* dbg_data = 0;",
          "3690:  int result = 0;",
          "3692:   return 0;",
          "3693:  }",
          "3697:   return false;",
          "3698:  }",
          "3700:   return false;",
          "3701:  }",
          "3704:   return false;",
          "3705:  }",
          "3708:  if (dbg_data_len < 1) {",
          "3709:   return false;",
          "3710:  }",
          "3711:  dbg_data = (ut8*) calloc (1, dbg_data_len + 1);",
          "3712:  if (dbg_data) {",
          "3715:   R_FREE (dbg_data);",
          "3716:  }",
          "3717:  return result;",
          "3718: }",
          "3721:  struct r_bin_pe_import_t* imps, * imports = NULL;",
          "3722:  char dll_name[PE_NAME_LENGTH + 1];",
          "3723:  int nimp = 0;",
          "",
          "[Removed Lines]",
          "3685: int PE_(r_bin_pe_get_debug_data)(struct PE_(r_bin_pe_obj_t)* bin, SDebugInfo* res) {",
          "3691:  if (!bin) {",
          "3694:  dbg_dir = &bin->nt_headers->optional_header.DataDirectory[6 /*IMAGE_DIRECTORY_ENTRY_DEBUG*/];",
          "3695:  dbg_dir_offset = PE_(va2pa) (bin, dbg_dir->VirtualAddress);",
          "3696:  if ((int) dbg_dir_offset < 0 || dbg_dir_offset >= bin->size) {",
          "3699:  if (dbg_dir_offset >= r_buf_size (bin->b)) {",
          "3702:  read_image_debug_directory_entry (bin->b, dbg_dir_offset, &img_dbg_dir_entry);",
          "3703:  if ((r_buf_size (bin->b) - dbg_dir_offset) < sizeof (PE_(image_debug_directory_entry))) {",
          "3706:  ut32 dbg_data_poff = R_MIN (img_dbg_dir_entry.PointerToRawData, r_buf_size (bin->b));",
          "3707:  int dbg_data_len = R_MIN (img_dbg_dir_entry.SizeOfData, r_buf_size (bin->b) - dbg_data_poff);",
          "3713:   r_buf_read_at (bin->b, dbg_data_poff, dbg_data, dbg_data_len);",
          "3714:   result = get_debug_info (bin, &img_dbg_dir_entry, dbg_data, dbg_data_len, res);",
          "3720: struct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "",
          "[Added Lines]",
          "3689: int PE_(r_bin_pe_get_debug_data)(RBinPEObj* pe, SDebugInfo* res) {",
          "3695:  if (!pe) {",
          "3698:  dbg_dir = &pe->nt_headers->optional_header.DataDirectory[6 /*IMAGE_DIRECTORY_ENTRY_DEBUG*/];",
          "3699:  dbg_dir_offset = PE_(va2pa) (pe, dbg_dir->VirtualAddress);",
          "3700:  if ((int) dbg_dir_offset < 0 || dbg_dir_offset >= pe->size) {",
          "3703:  if (dbg_dir_offset >= r_buf_size (pe->b)) {",
          "3706:  read_image_debug_directory_entry (pe->b, dbg_dir_offset, &img_dbg_dir_entry);",
          "3707:  if ((r_buf_size (pe->b) - dbg_dir_offset) < sizeof (PE_(image_debug_directory_entry))) {",
          "3710:  ut32 dbg_data_poff = R_MIN (img_dbg_dir_entry.PointerToRawData, r_buf_size (pe->b));",
          "3711:  int dbg_data_len = R_MIN (img_dbg_dir_entry.SizeOfData, r_buf_size (pe->b) - dbg_data_poff);",
          "3717:   r_buf_read_at (pe->b, dbg_data_poff, dbg_data, dbg_data_len);",
          "3718:   result = get_debug_info (pe, &img_dbg_dir_entry, dbg_data, dbg_data_len, res);",
          "3724: struct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(RBinPEObj* pe) {",
          "",
          "---------------",
          "--- Hunk 113 ---",
          "[Context before]",
          "3728:  PE_(image_import_directory) curr_import_dir;",
          "3729:  PE_(image_delay_import_directory) curr_delay_import_dir;",
          "3732:   return NULL;",
          "3733:  }",
          "3735:   return NULL;",
          "3736:  }",
          "3738:   return NULL;",
          "3739:  }",
          "3743:   ut64 last;",
          "3744:   int idi = 0;",
          "3746:    return NULL;",
          "3747:   }",
          "3749:    idi * sizeof (curr_import_dir), &curr_import_dir);",
          "3750:   if (r < 0) {",
          "3751:    return NULL;",
          "3752:   }",
          "3755:    return NULL;",
          "3756:   }",
          "3761:   }",
          "3764:    curr_import_dir.FirstThunk != 0 || curr_import_dir.Name != 0 ||",
          "3765:    curr_import_dir.TimeDateStamp != 0 || curr_import_dir.Characteristics != 0 ||",
          "3766:    curr_import_dir.ForwarderChain != 0)) {",
          "3767:    int rr;",
          "3768:    dll_name_offset = curr_import_dir.Name;",
          "3771:     goto beach;",
          "3772:    }",
          "3776:      goto beach;",
          "3777:     }",
          "3779:    } else {",
          "3781:     if (rr != PE_NAME_LENGTH) {",
          "3782:      goto beach;",
          "3783:     }",
          "3784:     dll_name[PE_NAME_LENGTH] = '\\0';",
          "3785:    }",
          "3787:     curr_import_dir.Characteristics,",
          "3788:     curr_import_dir.FirstThunk)) {",
          "3789:     break;",
          "3790:    }",
          "3791:    idi++;",
          "3793:     idi * sizeof (curr_import_dir), &curr_import_dir);",
          "3794:    if (r < 0) {",
          "3795:     free (imports);",
          "",
          "[Removed Lines]",
          "3731:  if (!bin) {",
          "3734:  if (bin->import_directory_offset >= bin->size) {",
          "3737:  if (bin->import_directory_offset + 20 > bin->size) {",
          "3741:  off = bin->import_directory_offset;",
          "3742:  if (off < bin->size && off > 0) {",
          "3745:   if (off + sizeof (PE_(image_import_directory)) > bin->size) {",
          "3748:   int r = read_image_import_directory (bin->b, bin->import_directory_offset +",
          "3754:   if (bin->import_directory_size < 1) {",
          "3757:   if (off + bin->import_directory_size > bin->size) {",
          "3759:    bprintf (\"Warning: read (import directory too big)\\n\");",
          "3760:    bin->import_directory_size = bin->size - bin->import_directory_offset;",
          "3762:   last = bin->import_directory_offset + bin->import_directory_size;",
          "3763:   while (r == sizeof (curr_import_dir) && bin->import_directory_offset + (idi + 1) * sizeof (curr_import_dir) <= last && (",
          "3769:    paddr = PE_(va2pa) (bin, dll_name_offset);",
          "3770:    if (paddr > bin->size) {",
          "3773:    if (paddr + PE_NAME_LENGTH > bin->size) {",
          "3774:     rr = r_buf_read_at (bin->b, paddr, (ut8*) dll_name, bin->size - paddr);",
          "3775:     if (rr != bin->size - paddr) {",
          "3778:     dll_name[bin->size - paddr] = '\\0';",
          "3780:     rr = r_buf_read_at (bin->b, paddr, (ut8*) dll_name, PE_NAME_LENGTH);",
          "3786:    if (!bin_pe_parse_imports (bin, &imports, &nimp, dll_name,",
          "3792:    r = read_image_import_directory (bin->b, bin->import_directory_offset +",
          "",
          "[Added Lines]",
          "3735:  if (!pe) {",
          "3738:  if (pe->import_directory_offset >= pe->size) {",
          "3741:  if (pe->import_directory_offset + 20 > pe->size) {",
          "3745:  off = pe->import_directory_offset;",
          "3746:  if (off < pe->size && off > 0) {",
          "3749:   if (off + sizeof (PE_(image_import_directory)) > pe->size) {",
          "3752:   int r = read_image_import_directory (pe->b, pe->import_directory_offset +",
          "3758:   if (pe->import_directory_size < 1) {",
          "3761:   if (off + pe->import_directory_size > pe->size) {",
          "3763:    pe_printf (\"Warning: read (import directory too big)\\n\");",
          "3764:    pe->import_directory_size = pe->size - pe->import_directory_offset;",
          "3766:   last = pe->import_directory_offset + pe->import_directory_size;",
          "3767:   while (r == sizeof (curr_import_dir) && pe->import_directory_offset + (idi + 1) * sizeof (curr_import_dir) <= last && (",
          "3773:    paddr = PE_(va2pa) (pe, dll_name_offset);",
          "3774:    if (paddr > pe->size) {",
          "3777:    if (paddr + PE_NAME_LENGTH > pe->size) {",
          "3778:     rr = r_buf_read_at (pe->b, paddr, (ut8*) dll_name, pe->size - paddr);",
          "3779:     if (rr != pe->size - paddr) {",
          "3782:     dll_name[pe->size - paddr] = '\\0';",
          "3784:     rr = r_buf_read_at (pe->b, paddr, (ut8*) dll_name, PE_NAME_LENGTH);",
          "3790:    if (!bin_pe_parse_imports (pe, &imports, &nimp, dll_name,",
          "3796:    r = read_image_import_directory (pe->b, pe->import_directory_offset +",
          "",
          "---------------",
          "--- Hunk 114 ---",
          "[Context before]",
          "3797:    }",
          "3798:   }",
          "3799:  }",
          "3803:    goto beach;",
          "3804:   }",
          "3805:   int didi;",
          "3806:   for (didi = 0;; didi++) {",
          "3808:      &curr_delay_import_dir);",
          "3809:    if (r != sizeof (curr_delay_import_dir)) {",
          "3810:     goto beach;",
          "",
          "[Removed Lines]",
          "3800:  off = bin->delay_import_directory_offset;",
          "3801:  if (off < bin->size && off > 0) {",
          "3802:   if (off + sizeof (PE_(image_delay_import_directory)) > bin->size) {",
          "3807:    int r = read_image_delay_import_directory (bin->b, off + didi * sizeof (curr_delay_import_dir),",
          "",
          "[Added Lines]",
          "3804:  off = pe->delay_import_directory_offset;",
          "3805:  if (off < pe->size && off > 0) {",
          "3806:   if (off + sizeof (PE_(image_delay_import_directory)) > pe->size) {",
          "3811:    int r = read_image_delay_import_directory (pe->b, off + didi * sizeof (curr_delay_import_dir),",
          "",
          "---------------",
          "--- Hunk 115 ---",
          "[Context before]",
          "3813:     break;",
          "3814:    }",
          "3815:    if (!curr_delay_import_dir.Attributes) {",
          "3818:    } else {",
          "3820:     import_func_name_offset = curr_delay_import_dir.DelayImportNameTable;",
          "3821:    }",
          "3823:     goto beach;",
          "3824:    }",
          "3826:    if (rr < 5) {",
          "3827:     goto beach;",
          "3828:    }",
          "3829:    dll_name[PE_NAME_LENGTH] = '\\0';",
          "3831:     curr_delay_import_dir.DelayImportAddressTable)) {",
          "3832:     break;",
          "3833:    }",
          "",
          "[Removed Lines]",
          "3816:     dll_name_offset = PE_(va2pa) (bin, curr_delay_import_dir.Name - PE_(r_bin_pe_get_image_base)(bin));",
          "3817:     import_func_name_offset = curr_delay_import_dir.DelayImportNameTable - PE_(r_bin_pe_get_image_base)(bin);",
          "3819:     dll_name_offset = PE_(va2pa) (bin, curr_delay_import_dir.Name);",
          "3822:    if (dll_name_offset > bin->size || dll_name_offset + PE_NAME_LENGTH > bin->size) {",
          "3825:    int rr = r_buf_read_at (bin->b, dll_name_offset, (ut8*) dll_name, PE_NAME_LENGTH);",
          "3830:    if (!bin_pe_parse_imports (bin, &imports, &nimp, dll_name, import_func_name_offset,",
          "",
          "[Added Lines]",
          "3820:     dll_name_offset = PE_(va2pa) (pe, curr_delay_import_dir.Name - PE_(r_bin_pe_get_image_base)(pe));",
          "3821:     import_func_name_offset = curr_delay_import_dir.DelayImportNameTable - PE_(r_bin_pe_get_image_base)(pe);",
          "3823:     dll_name_offset = PE_(va2pa) (pe, curr_delay_import_dir.Name);",
          "3826:    if (dll_name_offset > pe->size || dll_name_offset + PE_NAME_LENGTH > pe->size) {",
          "3829:    int rr = r_buf_read_at (pe->b, dll_name_offset, (ut8*) dll_name, PE_NAME_LENGTH);",
          "3834:    if (!bin_pe_parse_imports (pe, &imports, &nimp, dll_name, import_func_name_offset,",
          "",
          "---------------",
          "--- Hunk 116 ---",
          "[Context before]",
          "3847:  return imports;",
          "3848: }",
          "3852:   return NULL;",
          "3853:  }",
          "3854:  struct r_bin_pe_lib_t* libs = NULL;",
          "",
          "[Removed Lines]",
          "3850: struct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "3851:  if (!bin) {",
          "",
          "[Added Lines]",
          "3854: struct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(RBinPEObj* pe) {",
          "3855:  if (!pe) {",
          "",
          "---------------",
          "--- Hunk 117 ---",
          "[Context before]",
          "3867:   return NULL;",
          "3868:  }",
          "3872:   goto out_error;",
          "3873:  }",
          "3874:  lib_map = sdb_ht_new ();",
          "3877:   ut64 last;",
          "3878:   int iidi = 0;",
          "3881:    goto out_error;",
          "3882:   }",
          "3884:    &curr_import_dir);",
          "3886:   while (r == sizeof (curr_import_dir) && off + (iidi + 1) * sizeof (curr_import_dir) <= last && (",
          "3887:    curr_import_dir.FirstThunk || curr_import_dir.Name ||",
          "3888:    curr_import_dir.TimeDateStamp || curr_import_dir.Characteristics ||",
          "3889:    curr_import_dir.ForwarderChain)) {",
          "3892:    if (!libs[index].name[0]) { // minimum string length",
          "3893:     goto next;",
          "3894:    }",
          "3895:    if (len < 2 || libs[index].name[0] == 0) { // minimum string length",
          "3897:     break;",
          "3898:    }",
          "3899:    libs[index].name[len - 1] = '\\0';",
          "",
          "[Removed Lines]",
          "3870:  if (bin->import_directory_offset + bin->import_directory_size > bin->size) {",
          "3871:   bprintf (\"import directory offset bigger than file\\n\");",
          "3875:  off = bin->import_directory_offset;",
          "3876:  if (off < bin->size && off > 0) {",
          "3880:   if (off + sizeof (PE_(image_import_directory)) > bin->size) {",
          "3883:   int r = read_image_import_directory (bin->b, off + iidi * sizeof (curr_import_dir),",
          "3885:   last = off + bin->import_directory_size;",
          "3890:    name_off = PE_(va2pa) (bin, curr_import_dir.Name);",
          "3891:    len = r_buf_read_at (bin->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);",
          "3896:     bprintf (\"Warning: read (libs - import dirs) %d\\n\", len);",
          "",
          "[Added Lines]",
          "3874:  if (pe->import_directory_offset + pe->import_directory_size > pe->size) {",
          "3875:   pe_printf (\"import directory offset bigger than file\\n\");",
          "3879:  off = pe->import_directory_offset;",
          "3880:  if (off < pe->size && off > 0) {",
          "3884:   if (off + sizeof (PE_(image_import_directory)) > pe->size) {",
          "3887:   int r = read_image_import_directory (pe->b, off + iidi * sizeof (curr_import_dir),",
          "3889:   last = off + pe->import_directory_size;",
          "3894:    name_off = PE_(va2pa) (pe, curr_import_dir.Name);",
          "3895:    len = r_buf_read_at (pe->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);",
          "3900:     pe_printf (\"Warning: read (libs - import dirs) %d\\n\", len);",
          "",
          "---------------",
          "--- Hunk 118 ---",
          "[Context before]",
          "3914:    }",
          "3915: next:",
          "3916:    iidi++;",
          "3918:     &curr_import_dir);",
          "3919:   }",
          "3920:  }",
          "3923:   ut64 did = 0;",
          "3925:    goto out_error;",
          "3926:   }",
          "3928:   if (r != sizeof (curr_delay_import_dir)) {",
          "3929:    goto out_error;",
          "3930:   }",
          "3931:   while (r == sizeof (curr_delay_import_dir) &&",
          "3932:    curr_delay_import_dir.Name != 0 && curr_delay_import_dir.DelayImportNameTable != 0) {",
          "3935:     goto out_error;",
          "3936:    }",
          "3938:    if (len != PE_STRING_LENGTH) {",
          "3940:     break;",
          "3941:    }",
          "3942:    libs[index].name[len - 1] = '\\0';",
          "",
          "[Removed Lines]",
          "3917:    r = read_image_import_directory (bin->b, off + iidi * sizeof (curr_import_dir),",
          "3921:  off = bin->delay_import_directory_offset;",
          "3922:  if (off < bin->size && off > 0) {",
          "3924:   if (off + sizeof (PE_(image_delay_import_directory)) > bin->size) {",
          "3927:   int r = read_image_delay_import_directory (bin->b, off, &curr_delay_import_dir);",
          "3933:    name_off = PE_(va2pa) (bin, curr_delay_import_dir.Name);",
          "3934:    if (name_off > bin->size || name_off + PE_STRING_LENGTH > bin->size) {",
          "3937:    len = r_buf_read_at (bin->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);",
          "3939:     bprintf (\"Warning: read (libs - delay import dirs)\\n\");",
          "",
          "[Added Lines]",
          "3921:    r = read_image_import_directory (pe->b, off + iidi * sizeof (curr_import_dir),",
          "3925:  off = pe->delay_import_directory_offset;",
          "3926:  if (off < pe->size && off > 0) {",
          "3928:   if (off + sizeof (PE_(image_delay_import_directory)) > pe->size) {",
          "3931:   int r = read_image_delay_import_directory (pe->b, off, &curr_delay_import_dir);",
          "3937:    name_off = PE_(va2pa) (pe, curr_delay_import_dir.Name);",
          "3938:    if (name_off > pe->size || name_off + PE_STRING_LENGTH > pe->size) {",
          "3941:    len = r_buf_read_at (pe->b, name_off, (ut8*) libs[index].name, PE_STRING_LENGTH);",
          "3943:     pe_printf (\"Warning: read (libs - delay import dirs)\\n\");",
          "",
          "---------------",
          "--- Hunk 119 ---",
          "[Context before]",
          "3956:     }",
          "3957:    }",
          "3958:    did++;",
          "3960:     &curr_delay_import_dir);",
          "3961:   }",
          "3962:  }",
          "",
          "[Removed Lines]",
          "3959:    r = read_image_delay_import_directory (bin->b, off + did * sizeof (curr_delay_import_dir),",
          "",
          "[Added Lines]",
          "3963:    r = read_image_delay_import_directory (pe->b, off + did * sizeof (curr_delay_import_dir),",
          "",
          "---------------",
          "--- Hunk 120 ---",
          "[Context before]",
          "3969:  return NULL;",
          "3970: }",
          "3974: }",
          "3978:  char* machine = NULL;",
          "3982:   case PE_IMAGE_FILE_MACHINE_ALPHA: machine = \"Alpha\"; break;",
          "3983:   case PE_IMAGE_FILE_MACHINE_ALPHA64: machine = \"Alpha 64\"; break;",
          "3984:   case PE_IMAGE_FILE_MACHINE_AM33: machine = \"AM33\"; break;",
          "",
          "[Removed Lines]",
          "3972: int PE_(r_bin_pe_get_image_size)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "3973:  return bin->nt_headers->optional_header.SizeOfImage;",
          "3977: char* PE_(r_bin_pe_get_machine)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "3980:  if (bin && bin->nt_headers) {",
          "3981:   switch (bin->nt_headers->file_header.Machine) {",
          "",
          "[Added Lines]",
          "3976: int PE_(r_bin_pe_get_image_size)(RBinPEObj* pe) {",
          "3977:  return pe->nt_headers->optional_header.SizeOfImage;",
          "3981: char* PE_(r_bin_pe_get_machine)(RBinPEObj* pe) {",
          "3984:  if (pe && pe->nt_headers) {",
          "3985:   switch (pe->nt_headers->file_header.Machine) {",
          "",
          "---------------",
          "--- Hunk 121 ---",
          "[Context before]",
          "4017: }",
          "4021:  char* os;",
          "4023:   return NULL;",
          "4024:  }",
          "4026:  case PE_IMAGE_SUBSYSTEM_NATIVE:",
          "4027:   os = strdup (\"native\");",
          "4028:   break;",
          "",
          "[Removed Lines]",
          "4020: char* PE_(r_bin_pe_get_os)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4022:  if (!bin || !bin->nt_headers) {",
          "4025:  switch (bin->nt_headers->optional_header.Subsystem) {",
          "",
          "[Added Lines]",
          "4024: char* PE_(r_bin_pe_get_os)(RBinPEObj* pe) {",
          "4026:  if (!pe || !pe->nt_headers) {",
          "4029:  switch (pe->nt_headers->optional_header.Subsystem) {",
          "",
          "---------------",
          "--- Hunk 122 ---",
          "[Context before]",
          "4051: }",
          "4057:   case PE_IMAGE_FILE_TYPE_PE32: return strdup (\"PE32\");",
          "4058:   case PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"PE32+\");",
          "4059:   default: return strdup (\"Unknown\");",
          "",
          "[Removed Lines]",
          "4054: char* PE_(r_bin_pe_get_class)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4055:  if (bin && bin->nt_headers) {",
          "4056:   switch (bin->nt_headers->optional_header.Magic) {",
          "",
          "[Added Lines]",
          "4058: char* PE_(r_bin_pe_get_class)(RBinPEObj* pe) {",
          "4059:  if (pe && pe->nt_headers) {",
          "4060:   switch (pe->nt_headers->optional_header.Magic) {",
          "",
          "---------------",
          "--- Hunk 123 ---",
          "[Context before]",
          "4062:  return NULL;",
          "4063: }",
          "4066:  int bits = 32;",
          "4070:     bits = 16;",
          "4071:    }",
          "4072:   } else {",
          "4074:    case PE_IMAGE_FILE_TYPE_PE32: bits = 32; break;",
          "4075:    case PE_IMAGE_FILE_TYPE_PE32PLUS: bits = 64; break;",
          "4076:    default: bits = -1;",
          "",
          "[Removed Lines]",
          "4065: int PE_(r_bin_pe_get_bits)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4067:  if (bin && bin->nt_headers) {",
          "4068:   if (is_arm (bin)) {",
          "4069:    if (is_thumb (bin)) {",
          "4073:    switch (bin->nt_headers->optional_header.Magic) {",
          "",
          "[Added Lines]",
          "4069: int PE_(r_bin_pe_get_bits)(RBinPEObj* pe) {",
          "4071:  if (pe && pe->nt_headers) {",
          "4072:   if (is_arm (pe)) {",
          "4073:    if (is_thumb (pe)) {",
          "4077:    switch (pe->nt_headers->optional_header.Magic) {",
          "",
          "---------------",
          "--- Hunk 124 ---",
          "[Context before]",
          "4080:  return bits;",
          "4081: }",
          "4087:     return strdup (\"arm16\");",
          "4088:    }",
          "4090:    case PE_IMAGE_FILE_TYPE_PE32: return strdup (\"arm32\");",
          "4091:    case PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"arm64\");",
          "4092:    }",
          "4093:   } else {",
          "4095:    case PE_IMAGE_FILE_TYPE_PE32: return strdup (\"cdecl\");",
          "4096:    case PE_IMAGE_FILE_TYPE_PE32PLUS: return strdup (\"ms\");",
          "4097:    }",
          "",
          "[Removed Lines]",
          "4083: char *PE_(r_bin_pe_get_cc)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4084:  if (bin && bin->nt_headers) {",
          "4085:   if (is_arm (bin)) {",
          "4086:    if (is_thumb (bin)) {",
          "4089:    switch (bin->nt_headers->optional_header.Magic) {",
          "4094:    switch (bin->nt_headers->optional_header.Magic) {",
          "",
          "[Added Lines]",
          "4087: char *PE_(r_bin_pe_get_cc)(RBinPEObj* pe) {",
          "4088:  if (pe && pe->nt_headers) {",
          "4089:   if (is_arm (pe)) {",
          "4090:    if (is_thumb (pe)) {",
          "4093:    switch (pe->nt_headers->optional_header.Magic) {",
          "4098:    switch (pe->nt_headers->optional_header.Magic) {",
          "",
          "---------------",
          "--- Hunk 125 ---",
          "[Context before]",
          "4106:  int i = 0;",
          "4107:  struct r_bin_pe_section_t* sections = *sects;",
          "4108:  ut64 addr_beg, addr_end, new_section_size, new_perm, base_addr;",
          "4111:  if (!entry) {",
          "4112:   return;",
          "4113:  }",
          "4116:  new_perm = (PE_IMAGE_SCN_MEM_READ | PE_IMAGE_SCN_MEM_WRITE | PE_IMAGE_SCN_MEM_EXECUTE);",
          "4119:  for (i = 0; !sections[i].last; i++) {",
          "",
          "[Removed Lines]",
          "4105: void PE_(r_bin_pe_check_sections)(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_pe_section_t* * sects) {",
          "4109:  struct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (bin);",
          "4114:  new_section_size = bin->size;",
          "4115:  new_section_size -= entry->paddr > bin->size? 0: entry->paddr;",
          "4117:  base_addr = PE_(r_bin_pe_get_image_base) (bin);",
          "",
          "[Added Lines]",
          "4109: void PE_(r_bin_pe_check_sections)(RBinPEObj* pe, struct r_bin_pe_section_t* * sects) {",
          "4113:  struct r_bin_pe_addr_t* entry = PE_(r_bin_pe_get_entrypoint) (pe);",
          "4118:  new_section_size = pe->size;",
          "4119:  new_section_size -= entry->paddr > pe->size? 0: entry->paddr;",
          "4121:  base_addr = PE_(r_bin_pe_get_image_base) (pe);",
          "",
          "---------------",
          "--- Hunk 126 ---",
          "[Context before]",
          "4145:      addr_end = addr_beg + sections[j].vsize;",
          "4146:      if (addr_beg <= entry->vaddr || entry->vaddr < addr_end) {",
          "4147:       if (!(sections[j].perm & PE_IMAGE_SCN_MEM_EXECUTE)) {",
          "4149:         eprintf (\"Warning: Found entrypoint in non-executable section.\\n\");",
          "4150:        }",
          "4151:        sections[j].perm |= PE_IMAGE_SCN_MEM_EXECUTE;",
          "",
          "[Removed Lines]",
          "4148:        if (bin->verbose) {",
          "",
          "[Added Lines]",
          "4152:        if (pe->verbose) {",
          "",
          "---------------",
          "--- Hunk 127 ---",
          "[Context before]",
          "4168:  }",
          "4170:  for (i = 0; !sections[i].last; i++) {",
          "4172:    continue;",
          "4173:   }",
          "4174:   addr_beg = sections[i].paddr;",
          "",
          "[Removed Lines]",
          "4171:   if (sections[i].size > bin->size) {",
          "",
          "[Added Lines]",
          "4175:   if (sections[i].size > pe->size) {",
          "",
          "---------------",
          "--- Hunk 128 ---",
          "[Context before]",
          "4186:   }",
          "4187:  }",
          "4190:  if (!ss) {",
          "4191:   goto out_function;",
          "4192:  }",
          "4195:  sections[i].last = 0;",
          "4196:  strcpy ((char*) sections[i].name, \"blob\");",
          "4197:  sections[i].paddr = entry->paddr;",
          "",
          "[Removed Lines]",
          "4189:  void *ss = realloc (sections, (bin->num_sections + 2) * sizeof (struct r_bin_pe_section_t));",
          "4193:  bin->sections = sections = ss;",
          "4194:  i = bin->num_sections;",
          "",
          "[Added Lines]",
          "4193:  void *ss = realloc (sections, (pe->num_sections + 2) * sizeof (struct r_bin_pe_section_t));",
          "4197:  pe->sections = sections = ss;",
          "4198:  i = pe->num_sections;",
          "",
          "---------------",
          "--- Hunk 129 ---",
          "[Context before]",
          "4207: }",
          "4210:  struct r_bin_pe_section_t* sections = NULL;",
          "4211:  int i, j, section_count = 0;",
          "4214:   return NULL;",
          "4215:  }",
          "4219:   if (shdr[i].SizeOfRawData || shdr[i].Misc.VirtualSize) {",
          "4220:    section_count++;",
          "",
          "[Removed Lines]",
          "4209: static struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4213:  if (!bin || !bin->nt_headers) {",
          "4216:  PE_(image_section_header) * shdr = bin->section_header;",
          "4217:  for (i = 0; i < bin->num_sections; i++) {",
          "",
          "[Added Lines]",
          "4213: static struct r_bin_pe_section_t* PE_(r_bin_pe_get_sections)(RBinPEObj* pe) {",
          "4217:  if (!pe || !pe->nt_headers) {",
          "4220:  PE_(image_section_header) * shdr = pe->section_header;",
          "4221:  for (i = 0; i < pe->num_sections; i++) {",
          "",
          "---------------",
          "--- Hunk 130 ---",
          "[Context before]",
          "4225:   r_sys_perror (\"malloc (sections)\");",
          "4226:   return NULL;",
          "4227:  }",
          "4229:   if (!shdr[i].SizeOfRawData && !shdr[i].Misc.VirtualSize) {",
          "4230:    continue;",
          "4231:   }",
          "",
          "[Removed Lines]",
          "4228:  for (i = 0, j = 0; i < bin->num_sections; i++) {",
          "",
          "[Added Lines]",
          "4232:  for (i = 0, j = 0; i < pe->num_sections; i++) {",
          "",
          "---------------",
          "--- Hunk 131 ---",
          "[Context before]",
          "4238:    char *n = r_str_ndup ((const char *)shdr[i].Name + 1, sizeof (shdr[i].Name) - 1);",
          "4239:    int idx = atoi (n);",
          "4240:    free (n);",
          "4243:    st64 off = num_symbols * COFF_SYMBOL_SIZE;",
          "4244:    if (off > 0 && sym_tbl_off &&",
          "4246:        sym_tbl_off + off + idx > off) {",
          "4247:     int sz = PE_IMAGE_SIZEOF_SHORT_NAME * 3;",
          "4248:     char* buf[64] = {0};",
          "4250:          sym_tbl_off + off + idx,",
          "4251:          (ut8*)buf, 64)) {",
          "4252:      memcpy (sections[j].name, buf, sz);",
          "",
          "[Removed Lines]",
          "4241:    ut64 sym_tbl_off = bin->nt_headers->file_header.PointerToSymbolTable;",
          "4242:    int num_symbols = bin->nt_headers->file_header.NumberOfSymbols;",
          "4245:        sym_tbl_off + off + idx < bin->size &&",
          "4249:     if (r_buf_read_at (bin->b,",
          "",
          "[Added Lines]",
          "4245:    ut64 sym_tbl_off = pe->nt_headers->file_header.PointerToSymbolTable;",
          "4246:    int num_symbols = pe->nt_headers->file_header.NumberOfSymbols;",
          "4249:        sym_tbl_off + off + idx < pe->size &&",
          "4253:     if (r_buf_read_at (pe->b,",
          "",
          "---------------",
          "--- Hunk 132 ---",
          "[Context before]",
          "4265:    sections[j].vsize = shdr[i].SizeOfRawData;",
          "4266:   }",
          "4267:   sections[j].paddr = shdr[i].PointerToRawData;",
          "4270:    if (sa) {",
          "4271:     ut64 diff = sections[j].vsize % sa;",
          "4272:     if (diff) {",
          "4273:      sections[j].vsize += sa - diff;",
          "4274:     }",
          "4275:     if (sections[j].vaddr % sa) {",
          "4277:        sections[j].name);",
          "4278:     }",
          "4279:    }",
          "4281:    if (fa) {",
          "4282:     const ut64 diff = sections[j].paddr % fa;",
          "4283:     if (diff) {",
          "4285:      sections[j].paddr -= diff;",
          "4286:      sections[j].size += diff;",
          "4287:     }",
          "",
          "[Removed Lines]",
          "4268:   if (bin->optional_header) {",
          "4269:    ut32 sa = bin->optional_header->SectionAlignment;",
          "4276:      bprintf (\"Warning: section %s not aligned to SectionAlignment.\\n\",",
          "4280:    const ut32 fa = bin->optional_header->FileAlignment;",
          "4284:      bprintf (\"Warning: section %s not aligned to FileAlignment.\\n\", sections[j].name);",
          "",
          "[Added Lines]",
          "4272:   if (pe->optional_header) {",
          "4273:    ut32 sa = pe->optional_header->SectionAlignment;",
          "4280:      pe_printf (\"Warning: section %s not aligned to SectionAlignment.\\n\",",
          "4284:    const ut32 fa = pe->optional_header->FileAlignment;",
          "4288:      pe_printf (\"Warning: section %s not aligned to FileAlignment.\\n\", sections[j].name);",
          "",
          "---------------",
          "--- Hunk 133 ---",
          "[Context before]",
          "4292:   j++;",
          "4293:  }",
          "4294:  sections[j].last = 1;",
          "4296:  return sections;",
          "4297: }",
          "4300:  char* subsystem = NULL;",
          "4303:   case PE_IMAGE_SUBSYSTEM_NATIVE:",
          "4304:    subsystem = \"Native\"; break;",
          "4305:   case PE_IMAGE_SUBSYSTEM_WINDOWS_GUI:",
          "",
          "[Removed Lines]",
          "4295:  bin->num_sections = section_count;",
          "4299: char* PE_(r_bin_pe_get_subsystem)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4301:  if (bin && bin->nt_headers) {",
          "4302:   switch (bin->nt_headers->optional_header.Subsystem) {",
          "",
          "[Added Lines]",
          "4299:  pe->num_sections = section_count;",
          "4303: char* PE_(r_bin_pe_get_subsystem)(RBinPEObj* pe) {",
          "4305:  if (pe && pe->nt_headers) {",
          "4306:   switch (pe->nt_headers->optional_header.Subsystem) {",
          "",
          "---------------",
          "--- Hunk 134 ---",
          "[Context before]",
          "4327:  return subsystem? strdup (subsystem): NULL;",
          "4328: }",
          "4334:   return false;",
          "4335:  }",
          "4336:  return HASCHR (PE_IMAGE_FILE_DLL);",
          "4337: }",
          "4341:   return false;",
          "4342:  }",
          "4343:  return HASCHR (IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE);",
          "",
          "[Removed Lines]",
          "4330: #define HASCHR(x) (bin->nt_headers->file_header.Characteristics & (x))",
          "4332: int PE_(r_bin_pe_is_dll)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4333:  if (!bin || !bin->nt_headers) {",
          "4339: int PE_(r_bin_pe_is_pie)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4340:  if (!bin || !bin->nt_headers) {",
          "",
          "[Added Lines]",
          "4334: #define HASCHR(x) (pe->nt_headers->file_header.Characteristics & (x))",
          "4336: int PE_(r_bin_pe_is_dll)(RBinPEObj* pe) {",
          "4337:  if (!pe || !pe->nt_headers) {",
          "4343: int PE_(r_bin_pe_is_pie)(RBinPEObj* pe) {",
          "4344:  if (!pe || !pe->nt_headers) {",
          "",
          "---------------",
          "--- Hunk 135 ---",
          "[Context before]",
          "4348: #endif",
          "4349: }",
          "4352:  ut16 arch;",
          "4354:   return false;",
          "4355:  }",
          "4357:  if (arch == PE_IMAGE_FILE_MACHINE_I386 ||",
          "4358:  arch == PE_IMAGE_FILE_MACHINE_AMD64) {",
          "4359:   return false;",
          "",
          "[Removed Lines]",
          "4351: int PE_(r_bin_pe_is_big_endian)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4353:  if (!bin || !bin->nt_headers) {",
          "4356:  arch = bin->nt_headers->file_header.Machine;",
          "",
          "[Added Lines]",
          "4355: int PE_(r_bin_pe_is_big_endian)(RBinPEObj* pe) {",
          "4357:  if (!pe || !pe->nt_headers) {",
          "4360:  arch = pe->nt_headers->file_header.Machine;",
          "",
          "---------------",
          "--- Hunk 136 ---",
          "[Context before]",
          "4361:  return HASCHR (PE_IMAGE_FILE_BYTES_REVERSED_HI);",
          "4362: }",
          "4366:   return false;",
          "4367:  }",
          "4368:  return HASCHR (PE_IMAGE_FILE_RELOCS_STRIPPED);",
          "4369: }",
          "4373:   return false;",
          "4374:  }",
          "4375:  return HASCHR (PE_IMAGE_FILE_LINE_NUMS_STRIPPED);",
          "4376: }",
          "4380:   return false;",
          "4381:  }",
          "4382:  return HASCHR (PE_IMAGE_FILE_LOCAL_SYMS_STRIPPED);",
          "4383: }",
          "4387:   return false;",
          "4388:  }",
          "4389:  return HASCHR (PE_IMAGE_FILE_DEBUG_STRIPPED);",
          "4390: }",
          "4394:   return NULL;",
          "4395:  }",
          "4414:  return NULL;",
          "4415: }",
          "4420:   return NULL;",
          "4421:  }",
          "4423:  size_t binsz;",
          "4424:  ut8 *buf = (ut8*)r_file_slurp (file, &binsz);",
          "4426:  if (!buf) {",
          "4428:  }",
          "4431:   free (buf);",
          "4433:  }",
          "4435:  free (buf);",
          "4438:  }",
          "4440: }",
          "4445:   return NULL;",
          "4446:  }",
          "4453:  }",
          "4455: }",
          "",
          "[Removed Lines]",
          "4364: int PE_(r_bin_pe_is_stripped_relocs)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4365:  if (!bin || !bin->nt_headers) {",
          "4371: int PE_(r_bin_pe_is_stripped_line_nums)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4372:  if (!bin || !bin->nt_headers) {",
          "4378: int PE_(r_bin_pe_is_stripped_local_syms)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4379:  if (!bin || !bin->nt_headers) {",
          "4385: int PE_(r_bin_pe_is_stripped_debug)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4386:  if (!bin || !bin->nt_headers) {",
          "4392: void* PE_(r_bin_pe_free)(struct PE_(r_bin_pe_obj_t)* bin) {",
          "4393:  if (!bin) {",
          "4396:  free (bin->dos_header);",
          "4397:  free (bin->nt_headers);",
          "4398:  free (bin->section_header);",
          "4399:  free (bin->export_directory);",
          "4400:  free (bin->import_directory);",
          "4401:  free (bin->resource_directory);",
          "4402:  free_security_directory (bin->security_directory);",
          "4403:  free (bin->delay_import_directory);",
          "4404:  free (bin->tls_directory);",
          "4405:  free (bin->sections);",
          "4406:  free (bin->authentihash);",
          "4407:  r_list_free (bin->rich_entries);",
          "4408:  r_list_free (bin->resources);",
          "4409:  r_pkcs7_free_cms (bin->cms);",
          "4410:  r_pkcs7_free_spcinfo (bin->spcinfo);",
          "4411:  r_buf_free (bin->b);",
          "4412:  bin->b = NULL;",
          "4413:  free (bin);",
          "4417: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file, bool verbose) {",
          "4418:  struct PE_(r_bin_pe_obj_t)* bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));",
          "4419:  if (!bin) {",
          "4422:  bin->file = file;",
          "4425:  bin->size = binsz;",
          "4427:   return PE_(r_bin_pe_free)(bin);",
          "4429:  bin->b = r_buf_new ();",
          "4430:  if (!r_buf_set_bytes (bin->b, buf, bin->size)) {",
          "4432:   return PE_(r_bin_pe_free)(bin);",
          "4434:  bin->verbose = verbose;",
          "4436:  if (!bin_pe_init (bin)) {",
          "4437:   return PE_(r_bin_pe_free)(bin);",
          "4439:  return bin;",
          "4442: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(RBuffer *buf, bool verbose) {",
          "4443:  struct PE_(r_bin_pe_obj_t)* bin = R_NEW0 (struct PE_(r_bin_pe_obj_t));",
          "4444:  if (!bin) {",
          "4447:  bin->kv = sdb_new0 ();",
          "4448:  bin->b = r_buf_ref (buf);",
          "4449:  bin->verbose = verbose;",
          "4450:  bin->size = r_buf_size (buf);",
          "4451:  if (!bin_pe_init (bin)) {",
          "4452:   return PE_(r_bin_pe_free)(bin);",
          "4454:  return bin;",
          "",
          "[Added Lines]",
          "4368: int PE_(r_bin_pe_is_stripped_relocs)(RBinPEObj* pe) {",
          "4369:  if (!pe || !pe->nt_headers) {",
          "4375: int PE_(r_bin_pe_is_stripped_line_nums)(RBinPEObj* pe) {",
          "4376:  if (!pe || !pe->nt_headers) {",
          "4382: int PE_(r_bin_pe_is_stripped_local_syms)(RBinPEObj* pe) {",
          "4383:  if (!pe || !pe->nt_headers) {",
          "4389: int PE_(r_bin_pe_is_stripped_debug)(RBinPEObj* pe) {",
          "4390:  if (!pe || !pe->nt_headers) {",
          "4396: void* PE_(r_bin_pe_free)(RBinPEObj* pe) {",
          "4397:  if (!pe) {",
          "4400:  free (pe->dos_header);",
          "4401:  free (pe->nt_headers);",
          "4402:  free (pe->section_header);",
          "4403:  free (pe->export_directory);",
          "4404:  free (pe->import_directory);",
          "4405:  free (pe->resource_directory);",
          "4406:  free_security_directory (pe->security_directory);",
          "4407:  free (pe->delay_import_directory);",
          "4408:  free (pe->tls_directory);",
          "4409:  free (pe->sections);",
          "4410:  free (pe->authentihash);",
          "4411:  r_list_free (pe->rich_entries);",
          "4412:  r_list_free (pe->resources);",
          "4413:  r_pkcs7_free_cms (pe->cms);",
          "4414:  r_pkcs7_free_spcinfo (pe->spcinfo);",
          "4415:  r_buf_free (pe->b);",
          "4416:  pe->b = NULL;",
          "4417:  free (pe);",
          "4421: RBinPEObj* PE_(r_bin_pe_new)(const char* file, bool verbose) {",
          "4422:  RBinPEObj* pe = R_NEW0 (RBinPEObj);",
          "4423:  if (!pe) {",
          "4426:  pe->file = file;",
          "4429:  pe->size = binsz;",
          "4431:   return PE_(r_bin_pe_free)(pe);",
          "4433:  pe->b = r_buf_new ();",
          "4434:  if (!r_buf_set_bytes (pe->b, buf, pe->size)) {",
          "4436:   return PE_(r_bin_pe_free)(pe);",
          "4438:  pe->verbose = verbose;",
          "4440:  if (!bin_pe_init (pe)) {",
          "4441:   return PE_(r_bin_pe_free)(pe);",
          "4443:  return pe;",
          "4446: R_API RBinPEObj* PE_(r_bin_pe_new_buf)(RBuffer *buf, bool verbose) {",
          "4447:  RBinPEObj *pe = R_NEW0 (RBinPEObj);",
          "4448:  if (!pe) {",
          "4451:  pe->kv = sdb_new0 ();",
          "4452:  pe->b = r_buf_ref (buf);",
          "4453:  pe->verbose = verbose;",
          "4454:  pe->size = r_buf_size (buf);",
          "4455:  if (!bin_pe_init (pe)) {",
          "4456:   return PE_(r_bin_pe_free)(pe);",
          "4458:  return pe;",
          "",
          "---------------"
        ],
        "libr/bin/format/pe/pe.h||libr/bin/format/pe/pe.h": [
          "File: libr/bin/format/pe/pe.h -> libr/bin/format/pe/pe.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: #include <r_lib.h>",
          "6: #include <r_bin.h>",
          "",
          "[Removed Lines]",
          "3: #include <r_types.h>",
          "4: #include <r_util.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "82:  char file_name[DBG_FILE_NAME_LEN];",
          "83: } SDebugInfo;",
          "87: struct PE_(r_bin_pe_obj_t) {",
          "89:  PE_(image_dos_header) * dos_header;",
          "",
          "[Removed Lines]",
          "85: #endif",
          "",
          "[Added Lines]",
          "83: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "134:  bool is_signed;",
          "135: };",
          "137: #define RBinPEObj struct PE_(r_bin_pe_obj_t)",
          "",
          "[Removed Lines]",
          "138: R_IPI PE_DWord PE_(va2pa)(RBinPEObj* bin, PE_DWord rva);",
          "139: void PE_(r_bin_store_all_resource_version_info)(struct PE_(r_bin_pe_obj_t)* bin);",
          "140: char* PE_(r_bin_pe_get_arch)(struct PE_(r_bin_pe_obj_t)* bin);",
          "141: char *PE_(r_bin_pe_get_cc)(struct PE_(r_bin_pe_obj_t)* bin);",
          "142: struct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(struct PE_(r_bin_pe_obj_t)* bin);",
          "143: struct r_bin_pe_addr_t* PE_(r_bin_pe_get_main_vaddr)(struct PE_(r_bin_pe_obj_t)* bin);",
          "144: struct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(struct PE_(r_bin_pe_obj_t)* bin); // TODO",
          "145: int PE_(r_bin_pe_get_file_alignment)(struct PE_(r_bin_pe_obj_t)* bin);",
          "146: ut64 PE_(r_bin_pe_get_image_base)(struct PE_(r_bin_pe_obj_t)* bin);",
          "147: struct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(struct PE_(r_bin_pe_obj_t)* bin); // TODO",
          "148: struct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(struct PE_(r_bin_pe_obj_t)* bin);",
          "149: int PE_(r_bin_pe_get_image_size)(struct PE_(r_bin_pe_obj_t)* bin);",
          "150: char* PE_(r_bin_pe_get_machine)(struct PE_(r_bin_pe_obj_t)* bin);",
          "151: char* PE_(r_bin_pe_get_os)(struct PE_(r_bin_pe_obj_t)* bin);",
          "152: char* PE_(r_bin_pe_get_class)(struct PE_(r_bin_pe_obj_t)* bin);",
          "153: int PE_(r_bin_pe_get_bits)(struct PE_(r_bin_pe_obj_t)* bin);",
          "154: int PE_(r_bin_pe_get_section_alignment)(struct PE_(r_bin_pe_obj_t)* bin);",
          "155: char* PE_(r_bin_pe_get_subsystem)(struct PE_(r_bin_pe_obj_t)* bin);",
          "156: int PE_(r_bin_pe_is_dll)(struct PE_(r_bin_pe_obj_t)* bin);",
          "157: int PE_(r_bin_pe_is_big_endian)(struct PE_(r_bin_pe_obj_t)* bin);",
          "158: int PE_(r_bin_pe_is_stripped_relocs)(struct PE_(r_bin_pe_obj_t)* bin);",
          "159: int PE_(r_bin_pe_is_stripped_line_nums)(struct PE_(r_bin_pe_obj_t)* bin);",
          "160: int PE_(r_bin_pe_is_stripped_local_syms)(struct PE_(r_bin_pe_obj_t)* bin);",
          "161: int PE_(r_bin_pe_is_stripped_debug)(struct PE_(r_bin_pe_obj_t)* bin);",
          "162: void* PE_(r_bin_pe_free)(struct PE_(r_bin_pe_obj_t)* bin);",
          "163: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new)(const char* file, bool verbose);",
          "164: struct PE_(r_bin_pe_obj_t)* PE_(r_bin_pe_new_buf)(RBuffer* buf, bool verbose);",
          "165: int PE_(r_bin_pe_get_debug_data)(struct PE_(r_bin_pe_obj_t)* bin, struct SDebugInfo* res);",
          "166: int PE_(bin_pe_get_claimed_checksum)(struct PE_(r_bin_pe_obj_t)* bin);",
          "167: int PE_(bin_pe_get_actual_checksum)(struct PE_(r_bin_pe_obj_t)* bin);",
          "168: const char* PE_(bin_pe_compute_authentihash)(struct PE_(r_bin_pe_obj_t)* bin);",
          "169: int PE_(bin_pe_is_authhash_valid)(struct PE_(r_bin_pe_obj_t)* bin);",
          "170: int PE_(bin_pe_get_overlay)(struct PE_(r_bin_pe_obj_t)* bin, ut64* size);",
          "171: void PE_(r_bin_pe_check_sections)(struct PE_(r_bin_pe_obj_t)* bin, struct r_bin_pe_section_t** sects);",
          "172: struct r_bin_pe_addr_t *PE_(check_unknow) (struct PE_(r_bin_pe_obj_t) *bin);",
          "173: struct r_bin_pe_addr_t *PE_(check_msvcseh) (struct PE_(r_bin_pe_obj_t) *bin);",
          "174: struct r_bin_pe_addr_t *PE_(check_mingw) (struct PE_(r_bin_pe_obj_t) *bin);",
          "175: bool PE_(r_bin_pe_section_perms)(RBinFile *bf, const char *name, int perms);",
          "176: R_API void PE_(bin_pe_parse_resource)(struct PE_(r_bin_pe_obj_t) *bin);",
          "",
          "[Added Lines]",
          "134: #undef RBinPEObj",
          "138: R_API PE_DWord PE_(va2pa)(RBinPEObj* bin, PE_DWord rva);",
          "139: R_API void PE_(r_bin_store_all_resource_version_info)(RBinPEObj* bin);",
          "140: R_API char* PE_(r_bin_pe_get_arch)(RBinPEObj* bin);",
          "141: R_API char *PE_(r_bin_pe_get_cc)(RBinPEObj* bin);",
          "142: R_API struct r_bin_pe_addr_t* PE_(r_bin_pe_get_entrypoint)(RBinPEObj* bin);",
          "143: R_API struct r_bin_pe_addr_t* PE_(r_bin_pe_get_main_vaddr)(RBinPEObj* bin);",
          "144: R_API struct r_bin_pe_export_t* PE_(r_bin_pe_get_exports)(RBinPEObj* bin); // TODO",
          "145: R_API int PE_(r_bin_pe_get_file_alignment)(RBinPEObj* bin);",
          "146: R_API ut64 PE_(r_bin_pe_get_image_base)(RBinPEObj* bin);",
          "147: R_API struct r_bin_pe_import_t* PE_(r_bin_pe_get_imports)(RBinPEObj* bin); // TODO",
          "148: R_API struct r_bin_pe_lib_t* PE_(r_bin_pe_get_libs)(RBinPEObj* bin);",
          "149: R_API int PE_(r_bin_pe_get_image_size)(RBinPEObj* bin);",
          "150: R_API char* PE_(r_bin_pe_get_machine)(RBinPEObj* bin);",
          "151: R_API char* PE_(r_bin_pe_get_os)(RBinPEObj* bin);",
          "152: R_API char* PE_(r_bin_pe_get_class)(RBinPEObj* bin);",
          "153: R_API int PE_(r_bin_pe_get_bits)(RBinPEObj* bin);",
          "154: R_API int PE_(r_bin_pe_get_section_alignment)(RBinPEObj* bin);",
          "155: R_API char* PE_(r_bin_pe_get_subsystem)(RBinPEObj* bin);",
          "156: R_API int PE_(r_bin_pe_is_dll)(RBinPEObj* bin);",
          "157: R_API int PE_(r_bin_pe_is_big_endian)(RBinPEObj* bin);",
          "158: R_API int PE_(r_bin_pe_is_stripped_relocs)(RBinPEObj* bin);",
          "159: R_API int PE_(r_bin_pe_is_stripped_line_nums)(RBinPEObj* bin);",
          "160: R_API int PE_(r_bin_pe_is_stripped_local_syms)(RBinPEObj* bin);",
          "161: R_API int PE_(r_bin_pe_is_stripped_debug)(RBinPEObj* bin);",
          "162: R_API void* PE_(r_bin_pe_free)(RBinPEObj* bin);",
          "163: R_API RBinPEObj* PE_(r_bin_pe_new)(const char* file, bool verbose);",
          "164: R_API RBinPEObj* PE_(r_bin_pe_new_buf)(RBuffer* buf, bool verbose);",
          "165: R_API int PE_(r_bin_pe_get_debug_data)(RBinPEObj* bin, struct SDebugInfo* res);",
          "166: R_API int PE_(bin_pe_get_claimed_checksum)(RBinPEObj* bin);",
          "167: R_API int PE_(bin_pe_get_actual_checksum)(RBinPEObj* bin);",
          "168: R_API const char* PE_(bin_pe_compute_authentihash)(RBinPEObj* bin);",
          "169: R_API int PE_(bin_pe_is_authhash_valid)(RBinPEObj* bin);",
          "170: R_API int PE_(bin_pe_get_overlay)(RBinPEObj* bin, ut64* size);",
          "171: R_API void PE_(r_bin_pe_check_sections)(RBinPEObj* bin, struct r_bin_pe_section_t** sects);",
          "172: R_API struct r_bin_pe_addr_t *PE_(check_unknow) (RBinPEObj *bin);",
          "173: R_API struct r_bin_pe_addr_t *PE_(check_msvcseh) (RBinPEObj *bin);",
          "174: R_API struct r_bin_pe_addr_t *PE_(check_mingw) (RBinPEObj *bin);",
          "175: R_API bool PE_(r_bin_pe_section_perms)(RBinFile *bf, const char *name, int perms);",
          "176: R_API void PE_(bin_pe_parse_resource)(RBinPEObj *bin);",
          "177: R_API RBinPEObj* PE_(get)(RBinFile *bf);",
          "",
          "---------------"
        ],
        "libr/bin/format/pe/pe_write.c||libr/bin/format/pe/pe_write.c": [
          "File: libr/bin/format/pe/pe_write.c -> libr/bin/format/pe/pe_write.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include <r_util.h>",
          "5: #include \"pe.h\"",
          "8: bool PE_(r_bin_pe_section_perms)(RBinFile *bf, const char *name, int perms) {",
          "10:  PE_(image_section_header) *shdr = pe->section_header;",
          "13:  if (!shdr) {",
          "14:   return false;",
          "15:  }",
          "17:  for (i = 0; i < pe->num_sections; i++) {",
          "18:   const char *sname = (const char*) shdr[i].Name;",
          "19:   if (!strncmp (name, sname, PE_IMAGE_SIZEOF_SHORT_NAME)) {",
          "",
          "[Removed Lines]",
          "3: #include <r_types.h>",
          "9:  struct PE_(r_bin_pe_obj_t) *pe = bf->o->bin_obj;",
          "11:  int i;",
          "",
          "[Added Lines]",
          "7:  RBinPEObj *pe = PE_(get)(bf);",
          "8:  if (!pe) {",
          "9:   return false;",
          "10:  }",
          "15:  int i;",
          "",
          "---------------"
        ],
        "libr/bin/format/pe/pemixed.c||libr/bin/format/pe/pemixed.c": [
          "File: libr/bin/format/pe/pemixed.c -> libr/bin/format/pe/pemixed.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: #include \"pemixed.h\"",
          "6: static bool check_il_only(ut32 flags);",
          "9:  struct PE_(r_bin_pe_obj_t)* sub_bin_dos;",
          "10:  struct PE_(r_bin_pe_obj_t)* sub_bin_native;",
          "11:  struct PE_(r_bin_pe_obj_t)* sub_bin_net;",
          "14:  if (sub_bin_dos) {",
          "15:   bin->sub_bin_dos = sub_bin_dos;",
          "16:  }",
          "19:  if (sub_bin_native) {",
          "20:   bin->sub_bin_native = sub_bin_native;",
          "21:  }",
          "23:  bin->sub_bin_net = sub_bin_net;",
          "24:  return true;",
          "25: }",
          "30:  ut8 * tmp_buf;",
          "",
          "[Removed Lines]",
          "3: #include <stdio.h>",
          "8: static int r_bin_pemixed_init(struct r_bin_pemixed_obj_t* bin, struct PE_(r_bin_pe_obj_t)* pe_bin) {",
          "13:  sub_bin_dos = r_bin_pemixed_init_dos (pe_bin);",
          "18:  sub_bin_native = r_bin_pemixed_init_native (pe_bin);",
          "22:  sub_bin_net = pe_bin;",
          "29: struct PE_(r_bin_pe_obj_t)* r_bin_pemixed_init_dos(struct PE_(r_bin_pe_obj_t)* pe_bin) {",
          "32:  ut64 pe_hdr_off = pe_bin->dos_header->e_lfanew;",
          "",
          "[Added Lines]",
          "7: static int r_bin_pemixed_init(struct r_bin_pemixed_obj_t* bin, RBinPEObj *pe) {",
          "12:  sub_bin_dos = r_bin_pemixed_init_dos (pe);",
          "17:  sub_bin_native = r_bin_pemixed_init_native (pe);",
          "21:  sub_bin_net = pe;",
          "28: struct PE_(r_bin_pe_obj_t)* r_bin_pemixed_init_dos(RBinPEObj* pe) {",
          "31:  ut64 pe_hdr_off = pe->dos_header->e_lfanew;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37:   return NULL;",
          "38:  }",
          "41:   eprintf (\"Error reading to buffer\\n\");",
          "42:   return NULL;",
          "43:  }",
          "",
          "[Removed Lines]",
          "40:  if ((r_buf_read_at (pe_bin->b, 0, tmp_buf, pe_hdr_off)) == -1) {",
          "",
          "[Added Lines]",
          "39:  if ((r_buf_read_at (pe->b, 0, tmp_buf, pe_hdr_off)) == -1) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "49:  }",
          "51:  sub_bin_dos->size = pe_hdr_off;",
          "54:  free (tmp_buf);",
          "55:  return sub_bin_dos;",
          "56: }",
          "59:  ut8* zero_out;",
          "61:  struct PE_(r_bin_pe_obj_t)* sub_bin_native = R_NEW0 (struct PE_(r_bin_pe_obj_t));",
          "76:   free (sub_bin_native);",
          "77:   eprintf (\"failed\\n\");",
          "78:   return NULL;",
          "79:  }",
          "83:  dotnet_offset += sizeof (PE_(image_nt_headers));",
          "84:  dotnet_offset -= sizeof (PE_(image_data_directory)) * 2;",
          "86:  if (!(zero_out = (ut8*) calloc (2, 4 * sizeof (ut8)))) {",
          "90:   r_buf_free (sub_bin_native->b);",
          "",
          "[Removed Lines]",
          "52:  sub_bin_dos->dos_header = pe_bin->dos_header;",
          "58: struct PE_(r_bin_pe_obj_t)* r_bin_pemixed_init_native(struct PE_(r_bin_pe_obj_t)* pe_bin) {",
          "62:  memcpy (sub_bin_native, pe_bin, sizeof(struct PE_(r_bin_pe_obj_t)));",
          "75:  if (!(sub_bin_native->b = r_buf_new_with_buf(pe_bin->b))) {",
          "82:  int dotnet_offset = pe_bin->dos_header->e_lfanew;",
          "",
          "[Added Lines]",
          "51:  sub_bin_dos->dos_header = pe->dos_header;",
          "57: RBinPEObj *r_bin_pemixed_init_native(RBinPEObj *pe) {",
          "61:  memcpy (sub_bin_native, pe, sizeof(struct PE_(r_bin_pe_obj_t)));",
          "74:  if (!(sub_bin_native->b = r_buf_new_with_buf(pe->b))) {",
          "81:  int dotnet_offset = pe->dos_header->e_lfanew;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156: struct r_bin_pemixed_obj_t * r_bin_pemixed_from_bytes_new(const ut8* buf, ut64 size) {",
          "157:  struct r_bin_pemixed_obj_t* bin = R_NEW0 (struct r_bin_pemixed_obj_t);",
          "159:  if (!bin || !buf) {",
          "160:   return r_bin_pemixed_free (bin);",
          "161:  }",
          "",
          "[Removed Lines]",
          "158:  struct PE_(r_bin_pe_obj_t)* pe_bin;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "164:   return r_bin_pemixed_free (bin);",
          "165:  }",
          "166:  bin->size = size;",
          "170:   return r_bin_pemixed_free (bin);",
          "171:  }",
          "174:   return r_bin_pemixed_free (bin);",
          "175:  }",
          "181:   return r_bin_pemixed_free (bin);",
          "182:  }",
          "185:   return r_bin_pemixed_free (bin);",
          "186:  }",
          "187:  return bin;",
          "",
          "[Removed Lines]",
          "167:  pe_bin = PE_(r_bin_pe_new_buf) (bin->b, true);",
          "168:  if (!pe_bin) {",
          "169:   PE_(r_bin_pe_free)(pe_bin);",
          "172:  if (!pe_bin->clr_hdr) {",
          "173:   PE_(r_bin_pe_free) (pe_bin);",
          "179:  if (check_il_only(pe_bin->clr_hdr->Flags)) {",
          "180:   PE_(r_bin_pe_free) (pe_bin);",
          "183:  if (!r_bin_pemixed_init (bin, pe_bin)) {",
          "184:   PE_(r_bin_pe_free) (pe_bin);",
          "",
          "[Added Lines]",
          "164:  struct PE_(r_bin_pe_obj_t)* pe = PE_(r_bin_pe_new_buf) (bin->b, true);",
          "165:  if (!pe) {",
          "166:   PE_(r_bin_pe_free)(pe);",
          "169:  if (!pe->clr_hdr) {",
          "170:   PE_(r_bin_pe_free) (pe);",
          "176:  if (check_il_only (pe->clr_hdr->Flags)) {",
          "177:   PE_(r_bin_pe_free) (pe);",
          "180:  if (!r_bin_pemixed_init (bin, pe)) {",
          "181:   PE_(r_bin_pe_free) (pe);",
          "",
          "---------------"
        ],
        "libr/bin/format/pe/pemixed.h||libr/bin/format/pe/pemixed.h": [
          "File: libr/bin/format/pe/pemixed.h -> libr/bin/format/pe/pemixed.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include <r_types.h>",
          "2: #include \"pe.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #ifndef _INCLUDE_R_BIN_PEMIXED_H_",
          "2: #define _INCLUDE_R_BIN_PEMIXED_H_",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5: #define SUB_BIN_NATIVE 1",
          "6: #define SUB_BIN_NET 2",
          "12:  const char* file;",
          "13:  int size;",
          "18:  RBuffer* b;",
          "29: #endif",
          "",
          "[Removed Lines]",
          "8: #ifndef _INCLUDE_R_BIN_PEMIXED_H_",
          "9: #define _INCLUDE_R_BIN_PEMIXED_H_",
          "11: struct r_bin_pemixed_obj_t {",
          "14:  struct PE_(r_bin_pe_obj_t)* sub_bin_dos;",
          "15:  struct PE_(r_bin_pe_obj_t)* sub_bin_native;",
          "16:  struct PE_(r_bin_pe_obj_t)* sub_bin_net;",
          "19: };",
          "22: struct PE_(r_bin_pe_obj_t)* r_bin_pemixed_init_dos(struct PE_(r_bin_pe_obj_t)* pe_bin);",
          "23: struct PE_(r_bin_pe_obj_t)* r_bin_pemixed_init_native(struct PE_(r_bin_pe_obj_t)* pe_bin);",
          "24: struct PE_(r_bin_pe_obj_t)* r_bin_pemixed_extract(struct r_bin_pemixed_obj_t* bin, int sub_bin);",
          "26: void* r_bin_pemixed_free(struct r_bin_pemixed_obj_t* bin);",
          "27: struct r_bin_pemixed_obj_t * r_bin_pemixed_from_bytes_new(const ut8* buf, ut64 size);",
          "",
          "[Added Lines]",
          "11: typedef struct r_bin_pemixed_obj_t {",
          "14:  RBinPEObj* sub_bin_dos;",
          "15:  RBinPEObj* sub_bin_native;",
          "16:  RBinPEObj* sub_bin_net;",
          "18: } RBinPEMixed;",
          "20: RBinPEObj *r_bin_pemixed_init_dos(RBinPEObj* pe);",
          "21: RBinPEObj* r_bin_pemixed_init_native(RBinPEObj* pe);",
          "22: RBinPEObj* r_bin_pemixed_extract(RBinPEMixed* pemixed, int sub_bin);",
          "23: void* r_bin_pemixed_free(RBinPEMixed *pemixed);",
          "24: RBinPEMixed *r_bin_pemixed_from_bytes_new(const ut8* buf, ut64 size);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mdmp.c||libr/bin/p/bin_mdmp.c": [
          "File: libr/bin/p/bin_mdmp.c -> libr/bin/p/bin_mdmp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: static Sdb *get_sdb(RBinFile *bf) {",
          "12:  r_return_val_if_fail (bf && bf->o, NULL);",
          "15: }",
          "17: static void destroy(RBinFile *bf) {",
          "19: }",
          "21: static RList* entries(RBinFile *bf) {",
          "23:  struct Pe32_r_bin_mdmp_pe_bin *pe32_bin;",
          "24:  struct Pe64_r_bin_mdmp_pe_bin *pe64_bin;",
          "25:  RListIter *it;",
          "",
          "[Removed Lines]",
          "13:  struct r_bin_mdmp_obj *obj = (struct r_bin_mdmp_obj *)bf->o->bin_obj;",
          "14:  return (obj && obj->kv) ? obj->kv: NULL;",
          "18:  r_bin_mdmp_free ((struct r_bin_mdmp_obj*)bf->o->bin_obj);",
          "22:  struct r_bin_mdmp_obj *obj;",
          "",
          "[Added Lines]",
          "13:  RBinMdmpObj *mdmp = (RBinMdmpObj*)bf->o->bin_obj;",
          "14:  return (mdmp && mdmp->kv) ? mdmp->kv: NULL;",
          "18:  r_bin_mdmp_free ((RBinMdmpObj *)bf->o->bin_obj);",
          "22:  RBinMdmpObj *mdmp = (RBinMdmpObj*)bf->o->bin_obj;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29:   return NULL;",
          "30:  }",
          "35:   list = Pe32_r_bin_mdmp_pe_get_entrypoint (pe32_bin);",
          "36:   r_list_join (ret, list);",
          "37:   r_list_free (list);",
          "38:  }",
          "40:   list = Pe64_r_bin_mdmp_pe_get_entrypoint (pe64_bin);",
          "41:   r_list_join (ret, list);",
          "42:   r_list_free (list);",
          "",
          "[Removed Lines]",
          "32:  obj = (struct r_bin_mdmp_obj *)bf->o->bin_obj;",
          "34:  r_list_foreach (obj->pe32_bins, it, pe32_bin) {",
          "39:  r_list_foreach (obj->pe64_bins, it, pe64_bin) {",
          "",
          "[Added Lines]",
          "32:  r_list_foreach (mdmp->pe32_bins, it, pe32_bin) {",
          "37:  r_list_foreach (mdmp->pe64_bins, it, pe64_bin) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "46: }",
          "48: static RBinInfo *info(RBinFile *bf) {",
          "53:   return NULL;",
          "54:  }",
          "60:  ret->file = bf->file ? strdup (bf->file) : NULL;",
          "61:  ret->has_va = true;",
          "62:  ret->rclass = strdup (\"mdmp\");",
          "",
          "[Removed Lines]",
          "49:  struct r_bin_mdmp_obj *obj;",
          "50:  RBinInfo *ret;",
          "52:  if (!(ret = R_NEW0 (RBinInfo))) {",
          "56:  obj = (struct r_bin_mdmp_obj *)bf->o->bin_obj;",
          "58:  ret->big_endian = obj->endian;",
          "59:  ret->claimed_checksum = r_str_newf (\"0x%08x\", obj->hdr->check_sum);  // FIXME: Leaks",
          "",
          "[Added Lines]",
          "47:  RBinInfo *ret = R_NEW0 (RBinInfo);;",
          "48:  if (!ret) {",
          "51:  RBinMdmpObj *mdmp = bf->o->bin_obj;",
          "52:  if (!mdmp) {",
          "53:   return NULL;",
          "54:  }",
          "55:  ret->big_endian = mdmp->endian;",
          "56:  ret->claimed_checksum = r_str_newf (\"0x%08x\", mdmp->hdr->check_sum);  // FIXME: Leaks",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "67:  ret->has_lit = true;",
          "70:  sdb_set (bf->sdb, \"mdmp.flags\", k, 0);",
          "75:   case MDMP_PROCESSOR_ARCHITECTURE_INTEL:",
          "76:    ret->machine = strdup (\"i386\");",
          "77:    ret->arch = strdup (\"x86\");",
          "",
          "[Removed Lines]",
          "69:  r_strf_var (k, 32, \"0x%08\"PFMT64x, obj->hdr->flags);",
          "71:  sdb_num_set (bf->sdb, \"mdmp.streams\", obj->hdr->number_of_streams, 0);",
          "73:  if (obj->streams.system_info) {",
          "74:   switch (obj->streams.system_info->processor_architecture) {",
          "",
          "[Added Lines]",
          "66:  r_strf_var (k, 32, \"0x%08\"PFMT64x, mdmp->hdr->flags);",
          "68:  sdb_num_set (bf->sdb, \"mdmp.streams\", mdmp->hdr->number_of_streams, 0);",
          "70:  if (mdmp->streams.system_info) {",
          "71:   switch (mdmp->streams.system_info->processor_architecture) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "96:    break;",
          "97:   }",
          "100:   case MDMP_VER_NT_WORKSTATION:",
          "101:    ret->os = r_str_newf (\"Windows NT Workstation %d.%d.%d\",",
          "105:    break;",
          "106:   case MDMP_VER_NT_DOMAIN_CONTROLLER:",
          "107:    ret->os = r_str_newf (\"Windows NT Server Domain Controller %d.%d.%d\",",
          "111:    break;",
          "112:   case MDMP_VER_NT_SERVER:",
          "113:    ret->os = r_str_newf (\"Windows NT Server %d.%d.%d\",",
          "117:    break;",
          "118:   default:",
          "119:    ret->os = strdup (\"Unknown\");",
          "",
          "[Removed Lines]",
          "99:   switch (obj->streams.system_info->product_type) {",
          "102:    obj->streams.system_info->major_version,",
          "103:    obj->streams.system_info->minor_version,",
          "104:    obj->streams.system_info->build_number);",
          "108:    obj->streams.system_info->major_version,",
          "109:    obj->streams.system_info->minor_version,",
          "110:    obj->streams.system_info->build_number);",
          "114:    obj->streams.system_info->major_version,",
          "115:    obj->streams.system_info->minor_version,",
          "116:    obj->streams.system_info->build_number);",
          "",
          "[Added Lines]",
          "96:   switch (mdmp->streams.system_info->product_type) {",
          "99:    mdmp->streams.system_info->major_version,",
          "100:    mdmp->streams.system_info->minor_version,",
          "101:    mdmp->streams.system_info->build_number);",
          "105:    mdmp->streams.system_info->major_version,",
          "106:    mdmp->streams.system_info->minor_version,",
          "107:    mdmp->streams.system_info->build_number);",
          "111:    mdmp->streams.system_info->major_version,",
          "112:    mdmp->streams.system_info->minor_version,",
          "113:    mdmp->streams.system_info->build_number);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "126: static RList* libs(RBinFile *bf) {",
          "127:  char *ptr = NULL;",
          "128:  int i;",
          "130:  struct r_bin_pe_lib_t *libs = NULL;",
          "131:  struct Pe32_r_bin_mdmp_pe_bin *pe32_bin;",
          "132:  struct Pe64_r_bin_mdmp_pe_bin *pe64_bin;",
          "",
          "[Removed Lines]",
          "129:  struct r_bin_mdmp_obj *obj;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "140:   return NULL;",
          "141:  }",
          "148:   if (!(libs = Pe32_r_bin_pe_get_libs (pe32_bin->bin))) {",
          "149:    return ret;",
          "150:   }",
          "",
          "[Removed Lines]",
          "143:  obj = (struct r_bin_mdmp_obj *)bf->o->bin_obj;",
          "147:  r_list_foreach (obj->pe32_bins, it, pe32_bin) {",
          "",
          "[Added Lines]",
          "139:  RBinMdmpObj *mdmp = (RBinMdmpObj*)bf->o->bin_obj;",
          "143:  r_list_foreach (mdmp->pe32_bins, it, pe32_bin) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "154:   }",
          "155:   free (libs);",
          "156:  }",
          "158:   if (!(libs = Pe64_r_bin_pe_get_libs (pe64_bin->bin))) {",
          "159:    return ret;",
          "160:   }",
          "",
          "[Removed Lines]",
          "157:  r_list_foreach (obj->pe64_bins, it, pe64_bin) {",
          "",
          "[Added Lines]",
          "153:  r_list_foreach (mdmp->pe64_bins, it, pe64_bin) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "378:  struct Pe32_r_bin_mdmp_pe_bin *pe32_bin;",
          "379:  struct Pe64_r_bin_mdmp_pe_bin *pe64_bin;",
          "380:  RListIter *it;",
          "384:   return NULL;",
          "385:  }",
          "390:   if (pe32_bin->bin && pe32_bin->bin->relocs) {",
          "391:    r_list_join (ret, pe32_bin->bin->relocs);",
          "392:   }",
          "393:  }",
          "395:   if (pe64_bin->bin && pe64_bin->bin->relocs) {",
          "396:    r_list_join (ret, pe64_bin->bin->relocs);",
          "397:   }",
          "398:  }",
          "400:  return ret;",
          "401: }",
          "403: static RList* imports(RBinFile *bf) {",
          "405:  struct Pe32_r_bin_mdmp_pe_bin *pe32_bin;",
          "406:  struct Pe64_r_bin_mdmp_pe_bin *pe64_bin;",
          "407:  RList *ret = NULL, *list;",
          "",
          "[Removed Lines]",
          "381:  RList* ret;",
          "383:  if (!(ret = r_list_newf (free))) {",
          "387:  struct r_bin_mdmp_obj *obj = (struct r_bin_mdmp_obj *)bf->o->bin_obj;",
          "389:  r_list_foreach (obj->pe32_bins, it, pe32_bin) {",
          "394:  r_list_foreach (obj->pe64_bins, it, pe64_bin) {",
          "404:  struct r_bin_mdmp_obj *obj;",
          "",
          "[Added Lines]",
          "377:  RList* ret = r_list_newf (free);;",
          "378:  if (!ret) {",
          "381:  RBinMdmpObj *mdmp = (RBinMdmpObj*)bf->o->bin_obj;",
          "382:  r_list_foreach (mdmp->pe32_bins, it, pe32_bin) {",
          "387:  r_list_foreach (mdmp->pe64_bins, it, pe64_bin) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "410:  if (!(ret = r_list_newf ((RListFree)r_bin_import_free))) {",
          "411:   return NULL;",
          "412:  }",
          "417:   list = Pe32_r_bin_mdmp_pe_get_imports (pe32_bin);",
          "418:   if (list) {",
          "419:    r_list_join (ret, list);",
          "420:    r_list_free (list);",
          "421:   }",
          "422:  }",
          "424:   list = Pe64_r_bin_mdmp_pe_get_imports (pe64_bin);",
          "425:   if (list) {",
          "426:    r_list_join (ret, list);",
          "",
          "[Removed Lines]",
          "414:  obj = (struct r_bin_mdmp_obj *)bf->o->bin_obj;",
          "416:  r_list_foreach (obj->pe32_bins, it, pe32_bin) {",
          "423:  r_list_foreach (obj->pe64_bins, it, pe64_bin) {",
          "",
          "[Added Lines]",
          "404:  RBinMdmpObj *mdmp = (RBinMdmpObj*)bf->o->bin_obj;",
          "405:  r_list_foreach (mdmp->pe32_bins, it, pe32_bin) {",
          "412:  r_list_foreach (mdmp->pe64_bins, it, pe64_bin) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "431: }",
          "433: static RList* symbols(RBinFile *bf) {",
          "435:  struct Pe32_r_bin_mdmp_pe_bin *pe32_bin;",
          "436:  struct Pe64_r_bin_mdmp_pe_bin *pe64_bin;",
          "437:  RList *ret, *list;",
          "",
          "[Removed Lines]",
          "434:  struct r_bin_mdmp_obj *obj;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "441:   return NULL;",
          "442:  }",
          "447:   list = Pe32_r_bin_mdmp_pe_get_symbols (bf->rbin, pe32_bin);",
          "448:   r_list_join (ret, list);",
          "449:   r_list_free (list);",
          "450:  }",
          "452:   list = Pe64_r_bin_mdmp_pe_get_symbols (bf->rbin, pe64_bin);",
          "453:   r_list_join (ret, list);",
          "454:   r_list_free (list);",
          "",
          "[Removed Lines]",
          "444:  obj = (struct r_bin_mdmp_obj *)bf->o->bin_obj;",
          "446:  r_list_foreach (obj->pe32_bins, it, pe32_bin) {",
          "451:  r_list_foreach (obj->pe64_bins, it, pe64_bin) {",
          "",
          "[Added Lines]",
          "432:  RBinMdmpObj *mdmp = (RBinMdmpObj*)bf->o->bin_obj;",
          "434:  r_list_foreach (mdmp->pe32_bins, it, pe32_bin) {",
          "439:  r_list_foreach (mdmp->pe64_bins, it, pe64_bin) {",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_pe.c||libr/bin/p/bin_pe.c": [
          "File: libr/bin/p/bin_pe.c -> libr/bin/p/bin_pe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "106: static char *signature(RBinFile *bf, bool json) {",
          "107:  r_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);",
          "109:  if (json) {",
          "111:   if (pj) {",
          "112:    return pj_drain (pj);",
          "113:   }",
          "114:   return strdup (\"{}\");",
          "115:  }",
          "117: }",
          "119: static RList *fields(RBinFile *bf) {",
          "",
          "[Removed Lines]",
          "108:  struct PE_ (r_bin_pe_obj_t) * bin = bf->o->bin_obj;",
          "110:   PJ *pj = r_pkcs7_cms_json (bin->cms);",
          "116:  return r_pkcs7_cms_to_string (bin->cms);",
          "",
          "[Added Lines]",
          "106:  RBinPEObj *pe = PE_(get)(bf);",
          "108:   PJ *pj = r_pkcs7_cms_json (pe->cms);",
          "114:  return r_pkcs7_cms_to_string (pe->cms);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "126:  #define ROWL(nam,siz,val,fmt) \\",
          "127:  r_list_append (ret, r_bin_field_new (addr, addr, siz, nam, r_strf (\"0x%08x\", val), fmt, false));",
          "132:  RListIter *it;",
          "133:  Pe_image_rich_entry *rich;",
          "135:   r_list_append (ret, r_bin_field_new (addr, addr, 0, \"RICH_ENTRY_NAME\", strdup (rich->productName), \"s\", false));",
          "136:   ROWL (\"RICH_ENTRY_ID\", 2, rich->productId, \"x\"); addr += 2;",
          "137:   ROWL (\"RICH_ENTRY_VERSION\", 2, rich->minVersion, \"x\"); addr += 2;",
          "138:   ROWL (\"RICH_ENTRY_TIMES\", 4, rich->timesUsed, \"x\"); addr += 4;",
          "139:  }",
          "180:  int i;",
          "181:  ut64 tmp = addr;",
          "182:  for (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES - 1; i++) {",
          "184:    addr = tmp + i*8;",
          "185:    switch (i) {",
          "186:    case PE_IMAGE_DIRECTORY_ENTRY_EXPORT:",
          "187:     ROWL (\"IMAGE_DIRECTORY_ENTRY_EXPORT\", 4, \\",
          "189:     addr += 4;",
          "190:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_EXPORT\", 4, \\",
          "192:     break;",
          "193:    case PE_IMAGE_DIRECTORY_ENTRY_IMPORT:",
          "194:     ROWL (\"IMAGE_DIRECTORY_ENTRY_IMPORT\", 4, \\",
          "196:     addr += 4;",
          "197:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_IMPORT\", 4, \\",
          "199:     break;",
          "200:    case PE_IMAGE_DIRECTORY_ENTRY_RESOURCE:",
          "201:     ROWL (\"IMAGE_DIRECTORY_ENTRY_RESOURCE\", 4, \\",
          "203:     addr += 4;",
          "204:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_RESOURCE\", 4, \\",
          "206:     break;",
          "207:    case PE_IMAGE_DIRECTORY_ENTRY_EXCEPTION:",
          "208:     ROWL (\"IMAGE_DIRECTORY_ENTRY_EXCEPTION\", 4, \\",
          "210:     addr += 4;",
          "211:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_EXCEPTION\", 4, \\",
          "213:     break;",
          "214:    case PE_IMAGE_DIRECTORY_ENTRY_SECURITY:",
          "215:     ROWL (\"IMAGE_DIRECTORY_ENTRY_SECURITY\", 4, \\",
          "217:     addr += 4;",
          "218:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_SECURITY\", 4, \\",
          "220:     break;",
          "221:    case PE_IMAGE_DIRECTORY_ENTRY_BASERELOC:",
          "222:     ROWL (\"IMAGE_DIRECTORY_ENTRY_BASERELOC\", 4, \\",
          "224:     addr += 4;",
          "225:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_BASERELOC\", 4, \\",
          "227:     break;",
          "228:    case PE_IMAGE_DIRECTORY_ENTRY_DEBUG:",
          "229:     ROWL (\"IMAGE_DIRECTORY_ENTRY_DEBUG\", 4, \\",
          "231:     addr += 4;",
          "232:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_DEBUG\", 4, \\",
          "234:     break;",
          "235:    case PE_IMAGE_DIRECTORY_ENTRY_COPYRIGHT:",
          "236:     ROWL (\"IMAGE_DIRECTORY_ENTRY_COPYRIGHT\", 4, \\",
          "238:     addr += 4;",
          "239:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_COPYRIGHT\", 4, \\",
          "241:     break;",
          "242:    case PE_IMAGE_DIRECTORY_ENTRY_GLOBALPTR:",
          "243:     ROWL (\"IMAGE_DIRECTORY_ENTRY_GLOBALPTR\", 4, \\",
          "245:     addr += 4;",
          "246:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_GLOBALPTR\", 4, \\",
          "248:     break;",
          "249:    case PE_IMAGE_DIRECTORY_ENTRY_TLS:",
          "250:     ROWL (\"IMAGE_DIRECTORY_ENTRY_TLS\", 4, \\",
          "252:     addr += 4;",
          "253:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_TLS\", 4, \\",
          "255:     break;",
          "256:    case PE_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG:",
          "257:     ROWL (\"IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\", 4, \\",
          "259:     addr += 4;",
          "260:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\", 4, \\",
          "262:     break;",
          "263:    case PE_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT:",
          "264:     ROWL (\"IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\", 4, \\",
          "266:     addr += 4;",
          "267:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\", 4, \\",
          "269:     break;",
          "270:    case PE_IMAGE_DIRECTORY_ENTRY_IAT:",
          "271:     ROWL (\"IMAGE_DIRECTORY_ENTRY_IAT\", 4, \\",
          "273:     addr += 4;",
          "274:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_IAT\", 4, \\",
          "276:     break;",
          "277:    case PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT:",
          "278:     ROWL (\"IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\", 4, \\",
          "280:     addr += 4;",
          "281:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\", 4, \\",
          "283:     break;",
          "284:    case PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR:",
          "285:     ROWL (\"IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\", 4, \\",
          "287:     addr += 4;",
          "288:     ROWL (\"SIZE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\", 4, \\",
          "290:     break;",
          "291:    }",
          "292:   }",
          "293:  }",
          "295:  return ret;",
          "296: }",
          "298: static void header(RBinFile *bf) {",
          "343:  RListIter *it;",
          "344:  Pe_image_rich_entry *entry;",
          "348:  }",
          "349:  int i;",
          "350:  for (i = 0; i < PE_IMAGE_DIRECTORY_ENTRIES - 1; i++) {",
          "352:    switch (i) {",
          "353:    case PE_IMAGE_DIRECTORY_ENTRY_EXPORT:",
          "355:     break;",
          "356:    case PE_IMAGE_DIRECTORY_ENTRY_IMPORT:",
          "358:     break;",
          "359:    case PE_IMAGE_DIRECTORY_ENTRY_RESOURCE:",
          "361:     break;",
          "362:    case PE_IMAGE_DIRECTORY_ENTRY_EXCEPTION:",
          "364:     break;",
          "365:    case PE_IMAGE_DIRECTORY_ENTRY_SECURITY:",
          "367:     break;",
          "368:    case PE_IMAGE_DIRECTORY_ENTRY_BASERELOC:",
          "370:     break;",
          "371:    case PE_IMAGE_DIRECTORY_ENTRY_DEBUG:",
          "373:     break;",
          "374:    case PE_IMAGE_DIRECTORY_ENTRY_COPYRIGHT:",
          "377:     break;",
          "378:    case PE_IMAGE_DIRECTORY_ENTRY_GLOBALPTR:",
          "380:     break;",
          "381:    case PE_IMAGE_DIRECTORY_ENTRY_TLS:",
          "383:     break;",
          "384:    case PE_IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG:",
          "386:     break;",
          "387:    case PE_IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT:",
          "389:     break;",
          "390:    case PE_IMAGE_DIRECTORY_ENTRY_IAT:",
          "392:     break;",
          "393:    case PE_IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT:",
          "395:     break;",
          "396:    case PE_IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR:",
          "398:     break;",
          "399:    }",
          "402:   }",
          "403:  }",
          "404: }",
          "",
          "[Removed Lines]",
          "129:  struct PE_(r_bin_pe_obj_t) * bin = bf->o->bin_obj;",
          "130:  ut64 addr = bin->rich_header_offset ? bin->rich_header_offset : 128;",
          "134:  r_list_foreach (bin->rich_entries, it, rich) {",
          "141:  ROWL (\"Signature\", 4, bin->nt_headers->Signature, \"x\"); addr += 4;",
          "142:  ROWL (\"Machine\", 2, bin->nt_headers->file_header.Machine, \"x\"); addr += 2;",
          "143:  ROWL (\"NumberOfSections\", 2, bin->nt_headers->file_header.NumberOfSections, \"x\"); addr += 2;",
          "144:  ROWL (\"TimeDateStamp\", 4, bin->nt_headers->file_header.TimeDateStamp, \"x\"); addr += 4;",
          "145:  ROWL (\"PointerToSymbolTable\", 4, bin->nt_headers->file_header.PointerToSymbolTable, \"x\"); addr += 4;",
          "146:  ROWL (\"NumberOfSymbols \", 4, bin->nt_headers->file_header.NumberOfSymbols, \"x\"); addr += 4;",
          "147:  ROWL (\"SizeOfOptionalHeader\", 2, bin->nt_headers->file_header.SizeOfOptionalHeader, \"x\"); addr += 2;",
          "148:  ROWL (\"Characteristics\", 2, bin->nt_headers->file_header.Characteristics, \"x\"); addr += 2;",
          "149:  ROWL (\"Magic\", 2, bin->nt_headers->optional_header.Magic, \"x\"); addr += 2;",
          "150:  ROWL (\"MajorLinkerVersion\", 1, bin->nt_headers->optional_header.MajorLinkerVersion, \"x\"); addr += 1;",
          "151:  ROWL (\"MinorLinkerVersion\", 1, bin->nt_headers->optional_header.MinorLinkerVersion, \"x\"); addr += 1;",
          "152:  ROWL (\"SizeOfCode\", 4, bin->nt_headers->optional_header.SizeOfCode, \"x\"); addr += 4;",
          "153:  ROWL (\"SizeOfInitializedData\", 4, bin->nt_headers->optional_header.SizeOfInitializedData, \"x\"); addr += 4;",
          "154:  ROWL (\"SizeOfUninitializedData\", 4, bin->nt_headers->optional_header.SizeOfUninitializedData, \"x\"); addr += 4;",
          "155:  ROWL (\"AddressOfEntryPoint\", 4, bin->nt_headers->optional_header.AddressOfEntryPoint, \"x\"); addr += 4;",
          "156:  ROWL (\"BaseOfCode\", 4, bin->nt_headers->optional_header.BaseOfCode, \"x\"); addr += 4;",
          "157:  ROWL (\"BaseOfData\", 4, bin->nt_headers->optional_header.BaseOfData, \"x\"); addr += 4;",
          "158:  ROWL (\"ImageBase\", 4, bin->nt_headers->optional_header.ImageBase, \"x\"); addr += 4;",
          "159:  ROWL (\"SectionAlignment\", 4, bin->nt_headers->optional_header.SectionAlignment, \"x\"); addr += 4;",
          "160:  ROWL (\"FileAlignment\", 4, bin->nt_headers->optional_header.FileAlignment, \"x\"); addr += 4;",
          "161:  ROWL (\"MajorOperatingSystemVersion\", 2, bin->nt_headers->optional_header.MajorOperatingSystemVersion, \"x\"); addr += 2;",
          "162:  ROWL (\"MinorOperatingSystemVersion\", 2, bin->nt_headers->optional_header.MinorOperatingSystemVersion, \"x\"); addr += 2;",
          "163:  ROWL (\"MajorImageVersion\", 2, bin->nt_headers->optional_header.MajorImageVersion, \"x\"); addr += 2;",
          "164:  ROWL (\"MinorImageVersion\", 2, bin->nt_headers->optional_header.MinorImageVersion, \"x\"); addr += 2;",
          "165:  ROWL (\"MajorSubsystemVersion\", 2, bin->nt_headers->optional_header.MajorSubsystemVersion, \"x\"); addr += 2;",
          "166:  ROWL (\"MinorSubsystemVersion\", 2, bin->nt_headers->optional_header.MinorSubsystemVersion, \"x\"); addr += 2;",
          "167:  ROWL (\"Win32VersionValue\", 4, bin->nt_headers->optional_header.Win32VersionValue, \"x\"); addr += 4;",
          "168:  ROWL (\"SizeOfImage\", 4, bin->nt_headers->optional_header.SizeOfImage, \"x\"); addr += 4;",
          "169:  ROWL (\"SizeOfHeaders\", 4, bin->nt_headers->optional_header.SizeOfHeaders, \"x\"); addr += 4;",
          "170:  ROWL (\"CheckSum\", 4, bin->nt_headers->optional_header.CheckSum, \"x\"); addr += 4;",
          "171:  ROWL (\"Subsystem\",24, bin->nt_headers->optional_header.Subsystem, \"x\"); addr += 2;",
          "172:  ROWL (\"DllCharacteristics\", 2, bin->nt_headers->optional_header.DllCharacteristics, \"x\"); addr += 2;",
          "173:  ROWL (\"SizeOfStackReserve\", 4, bin->nt_headers->optional_header.SizeOfStackReserve, \"x\"); addr += 4;",
          "174:  ROWL (\"SizeOfStackCommit\", 4, bin->nt_headers->optional_header.SizeOfStackCommit, \"x\"); addr += 4;",
          "175:  ROWL (\"SizeOfHeapReserve\", 4, bin->nt_headers->optional_header.SizeOfHeapReserve, \"x\"); addr += 4;",
          "176:  ROWL (\"SizeOfHeapCommit\", 4, bin->nt_headers->optional_header.SizeOfHeapCommit, \"x\"); addr += 4;",
          "177:  ROWL (\"LoaderFlags\", 4, bin->nt_headers->optional_header.LoaderFlags, \"x\"); addr += 4;",
          "178:  ROWL (\"NumberOfRvaAndSizes\", 4, bin->nt_headers->optional_header.NumberOfRvaAndSizes, \"x\"); addr += 4;",
          "183:   if (bin->nt_headers->optional_header.DataDirectory[i].Size > 0) {",
          "188:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "191:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "195:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "198:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "202:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "205:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "209:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "212:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "216:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "219:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "223:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "226:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "230:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "233:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "237:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "240:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "244:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "247:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "251:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "254:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "258:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "261:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "265:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "268:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "272:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "275:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "279:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "282:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "286:     bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "289:     bin->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "299:  struct PE_(r_bin_pe_obj_t) * bin = bf->o->bin_obj;",
          "300:  struct r_bin_t *rbin = bf->rbin;",
          "301:  rbin->cb_printf (\"PE file header:\\n\");",
          "302:  rbin->cb_printf (\"IMAGE_NT_HEADERS\\n\");",
          "303:  rbin->cb_printf (\"  Signature : 0x%x\\n\", bin->nt_headers->Signature);",
          "304:  rbin->cb_printf (\"IMAGE_FILE_HEADERS\\n\");",
          "305:  rbin->cb_printf (\"  Machine : 0x%x\\n\", bin->nt_headers->file_header.Machine);",
          "306:  rbin->cb_printf (\"  NumberOfSections : 0x%x\\n\", bin->nt_headers->file_header.NumberOfSections);",
          "307:  rbin->cb_printf (\"  TimeDateStamp : 0x%x\\n\", bin->nt_headers->file_header.TimeDateStamp);",
          "308:  rbin->cb_printf (\"  PointerToSymbolTable : 0x%x\\n\", bin->nt_headers->file_header.PointerToSymbolTable);",
          "309:  rbin->cb_printf (\"  NumberOfSymbols : 0x%x\\n\", bin->nt_headers->file_header.NumberOfSymbols);",
          "310:  rbin->cb_printf (\"  SizeOfOptionalHeader : 0x%x\\n\", bin->nt_headers->file_header.SizeOfOptionalHeader);",
          "311:  rbin->cb_printf (\"  Characteristics : 0x%x\\n\", bin->nt_headers->file_header.Characteristics);",
          "312:  rbin->cb_printf (\"IMAGE_OPTIONAL_HEADERS\\n\");",
          "313:  rbin->cb_printf (\"  Magic : 0x%x\\n\", bin->nt_headers->optional_header.Magic);",
          "314:  rbin->cb_printf (\"  MajorLinkerVersion : 0x%x\\n\", bin->nt_headers->optional_header.MajorLinkerVersion);",
          "315:  rbin->cb_printf (\"  MinorLinkerVersion : 0x%x\\n\", bin->nt_headers->optional_header.MinorLinkerVersion);",
          "316:  rbin->cb_printf (\"  SizeOfCode : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfCode);",
          "317:  rbin->cb_printf (\"  SizeOfInitializedData : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfInitializedData);",
          "318:  rbin->cb_printf (\"  SizeOfUninitializedData : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfUninitializedData);",
          "319:  rbin->cb_printf (\"  AddressOfEntryPoint : 0x%x\\n\", bin->nt_headers->optional_header.AddressOfEntryPoint);",
          "320:  rbin->cb_printf (\"  BaseOfCode : 0x%x\\n\", bin->nt_headers->optional_header.BaseOfCode);",
          "321:  rbin->cb_printf (\"  BaseOfData : 0x%x\\n\", bin->nt_headers->optional_header.BaseOfData);",
          "322:  rbin->cb_printf (\"  ImageBase : 0x%x\\n\", bin->nt_headers->optional_header.ImageBase);",
          "323:  rbin->cb_printf (\"  SectionAlignment : 0x%x\\n\", bin->nt_headers->optional_header.SectionAlignment);",
          "324:  rbin->cb_printf (\"  FileAlignment : 0x%x\\n\", bin->nt_headers->optional_header.FileAlignment);",
          "325:  rbin->cb_printf (\"  MajorOperatingSystemVersion : 0x%x\\n\", bin->nt_headers->optional_header.MajorOperatingSystemVersion);",
          "326:  rbin->cb_printf (\"  MinorOperatingSystemVersion : 0x%x\\n\", bin->nt_headers->optional_header.MinorOperatingSystemVersion);",
          "327:  rbin->cb_printf (\"  MajorImageVersion : 0x%x\\n\", bin->nt_headers->optional_header.MajorImageVersion);",
          "328:  rbin->cb_printf (\"  MinorImageVersion : 0x%x\\n\", bin->nt_headers->optional_header.MinorImageVersion);",
          "329:  rbin->cb_printf (\"  MajorSubsystemVersion : 0x%x\\n\", bin->nt_headers->optional_header.MajorSubsystemVersion);",
          "330:  rbin->cb_printf (\"  MinorSubsystemVersion : 0x%x\\n\", bin->nt_headers->optional_header.MinorSubsystemVersion);",
          "331:  rbin->cb_printf (\"  Win32VersionValue : 0x%x\\n\", bin->nt_headers->optional_header.Win32VersionValue);",
          "332:  rbin->cb_printf (\"  SizeOfImage : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfImage);",
          "333:  rbin->cb_printf (\"  SizeOfHeaders : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfHeaders);",
          "334:  rbin->cb_printf (\"  CheckSum : 0x%x\\n\", bin->nt_headers->optional_header.CheckSum);",
          "335:  rbin->cb_printf (\"  Subsystem : 0x%x\\n\", bin->nt_headers->optional_header.Subsystem);",
          "336:  rbin->cb_printf (\"  DllCharacteristics : 0x%x\\n\", bin->nt_headers->optional_header.DllCharacteristics);",
          "337:  rbin->cb_printf (\"  SizeOfStackReserve : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfStackReserve);",
          "338:  rbin->cb_printf (\"  SizeOfStackCommit : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfStackCommit);",
          "339:  rbin->cb_printf (\"  SizeOfHeapReserve : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfHeapReserve);",
          "340:  rbin->cb_printf (\"  SizeOfHeapCommit : 0x%x\\n\", bin->nt_headers->optional_header.SizeOfHeapCommit);",
          "341:  rbin->cb_printf (\"  LoaderFlags : 0x%x\\n\", bin->nt_headers->optional_header.LoaderFlags);",
          "342:  rbin->cb_printf (\"  NumberOfRvaAndSizes : 0x%x\\n\", bin->nt_headers->optional_header.NumberOfRvaAndSizes);",
          "345:  rbin->cb_printf (\"RICH_FIELDS\\n\");",
          "346:  r_list_foreach (bin->rich_entries, it, entry) {",
          "347:   rbin->cb_printf (\"  Product: %d Name: %s Version: %d Times: %d\\n\", entry->productId, entry->productName, entry->minVersion, entry->timesUsed);",
          "351:   if (bin->nt_headers->optional_header.DataDirectory[i].Size > 0) {",
          "354:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_EXPORT\\n\");",
          "357:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_IMPORT\\n\");",
          "360:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_RESOURCE\\n\");",
          "363:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_EXCEPTION\\n\");",
          "366:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_SECURITY\\n\");",
          "369:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_BASERELOC\\n\");",
          "372:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_DEBUG\\n\");",
          "375:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_COPYRIGHT\\n\");",
          "376:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_ARCHITECTURE\\n\");",
          "379:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_GLOBALPTR\\n\");",
          "382:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_TLS\\n\");",
          "385:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\\n\");",
          "388:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\\n\");",
          "391:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_IAT\\n\");",
          "394:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\\n\");",
          "397:     rbin->cb_printf (\"IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\\n\");",
          "400:    rbin->cb_printf (\"  VirtualAddress : 0x%x\\n\", bin->nt_headers->optional_header.DataDirectory[i].VirtualAddress);",
          "401:    rbin->cb_printf (\"  Size : 0x%x\\n\", bin->nt_headers->optional_header.DataDirectory[i].Size);",
          "",
          "[Added Lines]",
          "127:  RBinPEObj *pe = PE_(get)(bf);",
          "128:  ut64 addr = pe->rich_header_offset ? pe->rich_header_offset : 128;",
          "132:  r_list_foreach (pe->rich_entries, it, rich) {",
          "139:  ROWL (\"Signature\", 4, pe->nt_headers->Signature, \"x\"); addr += 4;",
          "140:  ROWL (\"Machine\", 2, pe->nt_headers->file_header.Machine, \"x\"); addr += 2;",
          "141:  ROWL (\"NumberOfSections\", 2, pe->nt_headers->file_header.NumberOfSections, \"x\"); addr += 2;",
          "142:  ROWL (\"TimeDateStamp\", 4, pe->nt_headers->file_header.TimeDateStamp, \"x\"); addr += 4;",
          "143:  ROWL (\"PointerToSymbolTable\", 4, pe->nt_headers->file_header.PointerToSymbolTable, \"x\"); addr += 4;",
          "144:  ROWL (\"NumberOfSymbols \", 4, pe->nt_headers->file_header.NumberOfSymbols, \"x\"); addr += 4;",
          "145:  ROWL (\"SizeOfOptionalHeader\", 2, pe->nt_headers->file_header.SizeOfOptionalHeader, \"x\"); addr += 2;",
          "146:  ROWL (\"Characteristics\", 2, pe->nt_headers->file_header.Characteristics, \"x\"); addr += 2;",
          "147:  ROWL (\"Magic\", 2, pe->nt_headers->optional_header.Magic, \"x\"); addr += 2;",
          "148:  ROWL (\"MajorLinkerVersion\", 1, pe->nt_headers->optional_header.MajorLinkerVersion, \"x\"); addr += 1;",
          "149:  ROWL (\"MinorLinkerVersion\", 1, pe->nt_headers->optional_header.MinorLinkerVersion, \"x\"); addr += 1;",
          "150:  ROWL (\"SizeOfCode\", 4, pe->nt_headers->optional_header.SizeOfCode, \"x\"); addr += 4;",
          "151:  ROWL (\"SizeOfInitializedData\", 4, pe->nt_headers->optional_header.SizeOfInitializedData, \"x\"); addr += 4;",
          "152:  ROWL (\"SizeOfUninitializedData\", 4, pe->nt_headers->optional_header.SizeOfUninitializedData, \"x\"); addr += 4;",
          "153:  ROWL (\"AddressOfEntryPoint\", 4, pe->nt_headers->optional_header.AddressOfEntryPoint, \"x\"); addr += 4;",
          "154:  ROWL (\"BaseOfCode\", 4, pe->nt_headers->optional_header.BaseOfCode, \"x\"); addr += 4;",
          "155:  ROWL (\"BaseOfData\", 4, pe->nt_headers->optional_header.BaseOfData, \"x\"); addr += 4;",
          "156:  ROWL (\"ImageBase\", 4, pe->nt_headers->optional_header.ImageBase, \"x\"); addr += 4;",
          "157:  ROWL (\"SectionAlignment\", 4, pe->nt_headers->optional_header.SectionAlignment, \"x\"); addr += 4;",
          "158:  ROWL (\"FileAlignment\", 4, pe->nt_headers->optional_header.FileAlignment, \"x\"); addr += 4;",
          "159:  ROWL (\"MajorOperatingSystemVersion\", 2, pe->nt_headers->optional_header.MajorOperatingSystemVersion, \"x\"); addr += 2;",
          "160:  ROWL (\"MinorOperatingSystemVersion\", 2, pe->nt_headers->optional_header.MinorOperatingSystemVersion, \"x\"); addr += 2;",
          "161:  ROWL (\"MajorImageVersion\", 2, pe->nt_headers->optional_header.MajorImageVersion, \"x\"); addr += 2;",
          "162:  ROWL (\"MinorImageVersion\", 2, pe->nt_headers->optional_header.MinorImageVersion, \"x\"); addr += 2;",
          "163:  ROWL (\"MajorSubsystemVersion\", 2, pe->nt_headers->optional_header.MajorSubsystemVersion, \"x\"); addr += 2;",
          "164:  ROWL (\"MinorSubsystemVersion\", 2, pe->nt_headers->optional_header.MinorSubsystemVersion, \"x\"); addr += 2;",
          "165:  ROWL (\"Win32VersionValue\", 4, pe->nt_headers->optional_header.Win32VersionValue, \"x\"); addr += 4;",
          "166:  ROWL (\"SizeOfImage\", 4, pe->nt_headers->optional_header.SizeOfImage, \"x\"); addr += 4;",
          "167:  ROWL (\"SizeOfHeaders\", 4, pe->nt_headers->optional_header.SizeOfHeaders, \"x\"); addr += 4;",
          "168:  ROWL (\"CheckSum\", 4, pe->nt_headers->optional_header.CheckSum, \"x\"); addr += 4;",
          "169:  ROWL (\"Subsystem\",24, pe->nt_headers->optional_header.Subsystem, \"x\"); addr += 2;",
          "170:  ROWL (\"DllCharacteristics\", 2, pe->nt_headers->optional_header.DllCharacteristics, \"x\"); addr += 2;",
          "171:  ROWL (\"SizeOfStackReserve\", 4, pe->nt_headers->optional_header.SizeOfStackReserve, \"x\"); addr += 4;",
          "172:  ROWL (\"SizeOfStackCommit\", 4, pe->nt_headers->optional_header.SizeOfStackCommit, \"x\"); addr += 4;",
          "173:  ROWL (\"SizeOfHeapReserve\", 4, pe->nt_headers->optional_header.SizeOfHeapReserve, \"x\"); addr += 4;",
          "174:  ROWL (\"SizeOfHeapCommit\", 4, pe->nt_headers->optional_header.SizeOfHeapCommit, \"x\"); addr += 4;",
          "175:  ROWL (\"LoaderFlags\", 4, pe->nt_headers->optional_header.LoaderFlags, \"x\"); addr += 4;",
          "176:  ROWL (\"NumberOfRvaAndSizes\", 4, pe->nt_headers->optional_header.NumberOfRvaAndSizes, \"x\"); addr += 4;",
          "181:   if (pe->nt_headers->optional_header.DataDirectory[i].Size > 0) {",
          "186:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "189:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "193:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "196:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "200:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "203:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "207:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "210:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "214:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "217:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "221:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "224:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "228:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "231:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "235:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "238:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "242:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "245:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "249:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "252:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "256:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "259:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "263:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "266:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "270:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "273:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "277:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "280:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "284:     pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress, \"x\");",
          "287:     pe->nt_headers->optional_header.DataDirectory[i].Size, \"x\");",
          "296:  RBinPEObj *pe = PE_(get)(bf);",
          "297:  PrintfCallback cb_printf = bf->rbin->cb_printf;",
          "299:  cb_printf (\"PE file header:\\n\");",
          "300:  cb_printf (\"IMAGE_NT_HEADERS\\n\");",
          "301:  cb_printf (\"  Signature : 0x%x\\n\", pe->nt_headers->Signature);",
          "302:  cb_printf (\"IMAGE_FILE_HEADERS\\n\");",
          "303:  cb_printf (\"  Machine : 0x%x\\n\", pe->nt_headers->file_header.Machine);",
          "304:  cb_printf (\"  NumberOfSections : 0x%x\\n\", pe->nt_headers->file_header.NumberOfSections);",
          "305:  cb_printf (\"  TimeDateStamp : 0x%x\\n\", pe->nt_headers->file_header.TimeDateStamp);",
          "306:  cb_printf (\"  PointerToSymbolTable : 0x%x\\n\", pe->nt_headers->file_header.PointerToSymbolTable);",
          "307:  cb_printf (\"  NumberOfSymbols : 0x%x\\n\", pe->nt_headers->file_header.NumberOfSymbols);",
          "308:  cb_printf (\"  SizeOfOptionalHeader : 0x%x\\n\", pe->nt_headers->file_header.SizeOfOptionalHeader);",
          "309:  cb_printf (\"  Characteristics : 0x%x\\n\", pe->nt_headers->file_header.Characteristics);",
          "310:  cb_printf (\"IMAGE_OPTIONAL_HEADERS\\n\");",
          "311:  cb_printf (\"  Magic : 0x%x\\n\", pe->nt_headers->optional_header.Magic);",
          "312:  cb_printf (\"  MajorLinkerVersion : 0x%x\\n\", pe->nt_headers->optional_header.MajorLinkerVersion);",
          "313:  cb_printf (\"  MinorLinkerVersion : 0x%x\\n\", pe->nt_headers->optional_header.MinorLinkerVersion);",
          "314:  cb_printf (\"  SizeOfCode : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfCode);",
          "315:  cb_printf (\"  SizeOfInitializedData : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfInitializedData);",
          "316:  cb_printf (\"  SizeOfUninitializedData : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfUninitializedData);",
          "317:  cb_printf (\"  AddressOfEntryPoint : 0x%x\\n\", pe->nt_headers->optional_header.AddressOfEntryPoint);",
          "318:  cb_printf (\"  BaseOfCode : 0x%x\\n\", pe->nt_headers->optional_header.BaseOfCode);",
          "319:  cb_printf (\"  BaseOfData : 0x%x\\n\", pe->nt_headers->optional_header.BaseOfData);",
          "320:  cb_printf (\"  ImageBase : 0x%x\\n\", pe->nt_headers->optional_header.ImageBase);",
          "321:  cb_printf (\"  SectionAlignment : 0x%x\\n\", pe->nt_headers->optional_header.SectionAlignment);",
          "322:  cb_printf (\"  FileAlignment : 0x%x\\n\", pe->nt_headers->optional_header.FileAlignment);",
          "323:  cb_printf (\"  MajorOperatingSystemVersion : 0x%x\\n\", pe->nt_headers->optional_header.MajorOperatingSystemVersion);",
          "324:  cb_printf (\"  MinorOperatingSystemVersion : 0x%x\\n\", pe->nt_headers->optional_header.MinorOperatingSystemVersion);",
          "325:  cb_printf (\"  MajorImageVersion : 0x%x\\n\", pe->nt_headers->optional_header.MajorImageVersion);",
          "326:  cb_printf (\"  MinorImageVersion : 0x%x\\n\", pe->nt_headers->optional_header.MinorImageVersion);",
          "327:  cb_printf (\"  MajorSubsystemVersion : 0x%x\\n\", pe->nt_headers->optional_header.MajorSubsystemVersion);",
          "328:  cb_printf (\"  MinorSubsystemVersion : 0x%x\\n\", pe->nt_headers->optional_header.MinorSubsystemVersion);",
          "329:  cb_printf (\"  Win32VersionValue : 0x%x\\n\", pe->nt_headers->optional_header.Win32VersionValue);",
          "330:  cb_printf (\"  SizeOfImage : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfImage);",
          "331:  cb_printf (\"  SizeOfHeaders : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfHeaders);",
          "332:  cb_printf (\"  CheckSum : 0x%x\\n\", pe->nt_headers->optional_header.CheckSum);",
          "333:  cb_printf (\"  Subsystem : 0x%x\\n\", pe->nt_headers->optional_header.Subsystem);",
          "334:  cb_printf (\"  DllCharacteristics : 0x%x\\n\", pe->nt_headers->optional_header.DllCharacteristics);",
          "335:  cb_printf (\"  SizeOfStackReserve : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfStackReserve);",
          "336:  cb_printf (\"  SizeOfStackCommit : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfStackCommit);",
          "337:  cb_printf (\"  SizeOfHeapReserve : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfHeapReserve);",
          "338:  cb_printf (\"  SizeOfHeapCommit : 0x%x\\n\", pe->nt_headers->optional_header.SizeOfHeapCommit);",
          "339:  cb_printf (\"  LoaderFlags : 0x%x\\n\", pe->nt_headers->optional_header.LoaderFlags);",
          "340:  cb_printf (\"  NumberOfRvaAndSizes : 0x%x\\n\", pe->nt_headers->optional_header.NumberOfRvaAndSizes);",
          "343:  cb_printf (\"RICH_FIELDS\\n\");",
          "344:  r_list_foreach (pe->rich_entries, it, entry) {",
          "345:   cb_printf (\"  Product: %d Name: %s Version: %d Times: %d\\n\", entry->productId, entry->productName, entry->minVersion, entry->timesUsed);",
          "349:   if (pe->nt_headers->optional_header.DataDirectory[i].Size > 0) {",
          "352:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_EXPORT\\n\");",
          "355:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_IMPORT\\n\");",
          "358:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_RESOURCE\\n\");",
          "361:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_EXCEPTION\\n\");",
          "364:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_SECURITY\\n\");",
          "367:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_BASERELOC\\n\");",
          "370:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_DEBUG\\n\");",
          "373:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_COPYRIGHT\\n\");",
          "374:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_ARCHITECTURE\\n\");",
          "377:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_GLOBALPTR\\n\");",
          "380:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_TLS\\n\");",
          "383:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG\\n\");",
          "386:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT\\n\");",
          "389:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_IAT\\n\");",
          "392:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT\\n\");",
          "395:     cb_printf (\"IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR\\n\");",
          "398:    cb_printf (\"  VirtualAddress : 0x%x\\n\", pe->nt_headers->optional_header.DataDirectory[i].VirtualAddress);",
          "399:    cb_printf (\"  Size : 0x%x\\n\", pe->nt_headers->optional_header.DataDirectory[i].Size);",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_pe.inc||libr/bin/p/bin_pe.inc": [
          "File: libr/bin/p/bin_pe.inc -> libr/bin/p/bin_pe.inc",
          "--- Hunk 1 ---",
          "[Context before]",
          "8: #include \"pe/pe.h\"",
          "10: static Sdb* get_sdb(RBinFile *bf) {",
          "18: }",
          "20: static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {",
          "23:  if (res) {",
          "24:   sdb_ns_set (sdb, \"info\", res->kv);",
          "",
          "[Removed Lines]",
          "11:  RBinObject *o = bf->o;",
          "12:  struct PE_(r_bin_pe_obj_t) *bin;",
          "13:  if (!o || !o->bin_obj) {",
          "14:   return NULL;",
          "15:  }",
          "16:  bin = (struct PE_(r_bin_pe_obj_t) *) o->bin_obj;",
          "17:  return bin? bin->kv: NULL;",
          "21:  r_return_val_if_fail (bf && bin_obj && buf, false);",
          "22:  struct PE_(r_bin_pe_obj_t) *res = PE_(r_bin_pe_new_buf) (buf, bf->rbin->verbose);",
          "",
          "[Added Lines]",
          "11:  RBinPEObj *pe = PE_(get) (bf);",
          "12:  return pe? pe->kv: NULL;",
          "16:  r_return_val_if_fail (bf && bin_obj && buf && sdb, false);",
          "17:  RBinPEObj *res = PE_(r_bin_pe_new_buf) (buf, bf->rbin->verbose);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "29: }",
          "31: static void destroy(RBinFile *bf) {",
          "33: }",
          "35: static ut64 baddr(RBinFile *bf) {",
          "37: }",
          "39: static RBinAddr* binsym(RBinFile *bf, int type) {",
          "",
          "[Removed Lines]",
          "32:  PE_(r_bin_pe_free) ((struct PE_(r_bin_pe_obj_t)*)bf->o->bin_obj);",
          "36:  return PE_(r_bin_pe_get_image_base) (bf->o->bin_obj);",
          "",
          "[Added Lines]",
          "27:  RBinPEObj *pe = PE_(get) (bf);",
          "28:  PE_(r_bin_pe_free) (pe);",
          "32:  RBinPEObj *pe = PE_(get) (bf);",
          "33:  return PE_(r_bin_pe_get_image_base) (pe);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "59:  PE_DWord paddr, vaddr, haddr;",
          "60:  int count = 0;",
          "61:  RBinAddr *ptr = NULL;",
          "65:  do {",
          "66:   key =  r_strf (\"pe.tls_callback%d_paddr\", count);",
          "68:   if (!paddr) {",
          "69:    break;",
          "70:   }",
          "72:   key =  r_strf (\"pe.tls_callback%d_vaddr\", count);",
          "74:   if (!vaddr) {",
          "75:    break;",
          "76:   }",
          "78:   key = r_strf (\"pe.tls_callback%d_haddr\", count);",
          "80:   if (!haddr) {",
          "81:    break;",
          "82:   }",
          "83:   if ((ptr = R_NEW0 (RBinAddr))) {",
          "86:    ptr->hpaddr = haddr;",
          "88:    r_list_append (list, ptr);",
          "89:   }",
          "90:   count++;",
          "",
          "[Removed Lines]",
          "62:  struct PE_(r_bin_pe_obj_t) *bin = (struct PE_(r_bin_pe_obj_t) *) (bf->o->bin_obj);",
          "63:  char *key;",
          "67:   paddr = sdb_num_get (bin->kv, key, 0);",
          "73:   vaddr = sdb_num_get (bin->kv, key, 0);",
          "79:   haddr = sdb_num_get (bin->kv, key, 0);",
          "84:    ptr->paddr  = paddr;",
          "85:    ptr->vaddr  = vaddr;",
          "87:    ptr->type   = R_BIN_ENTRY_TYPE_TLS;",
          "",
          "[Added Lines]",
          "59:  RBinPEObj *pe = PE_(get) (bf);",
          "60:  const char *key;",
          "64:   paddr = sdb_num_get (pe->kv, key, 0);",
          "69:   vaddr = sdb_num_get (pe->kv, key, 0);",
          "74:   haddr = sdb_num_get (pe->kv, key, 0);",
          "79:    ptr->paddr = paddr;",
          "80:    ptr->vaddr = vaddr;",
          "82:    ptr->type = R_BIN_ENTRY_TYPE_TLS;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "99:  if (!(ret = r_list_newf (free))) {",
          "100:   return NULL;",
          "101:  }",
          "103:   return ret;",
          "104:  }",
          "105:  if ((ptr = R_NEW0 (RBinAddr))) {",
          "",
          "[Removed Lines]",
          "102:  if (!(entry = PE_(r_bin_pe_get_entrypoint) (bf->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "97:  RBinPEObj *pe = PE_(get) (bf);",
          "98:  if (!(entry = PE_(r_bin_pe_get_entrypoint) (pe))) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "117: }",
          "119: static RList* sections(RBinFile *bf) {",
          "121:  RBinSection *ptr = NULL;",
          "124:  ut64 ba = baddr (bf);",
          "125:  int i;",
          "127:   return NULL;",
          "128:  }",
          "130:   r_list_free (ret);",
          "131:   return NULL;",
          "132:  }",
          "134:  for (i = 0; !sections[i].last; i++) {",
          "135:   if (!(ptr = R_NEW0 (RBinSection))) {",
          "136:    break;",
          "",
          "[Removed Lines]",
          "120:  RList *ret = NULL;",
          "122:  struct r_bin_pe_section_t *sections = NULL;",
          "123:  struct PE_(r_bin_pe_obj_t) *bin = (struct PE_(r_bin_pe_obj_t)*)bf->o->bin_obj;",
          "126:  if (!(ret = r_list_newf ((RListFree)r_bin_section_free))) {",
          "129:  if (!bin || !(sections = bin->sections)){",
          "133:  PE_(r_bin_pe_check_sections) (bin, &sections);",
          "",
          "[Added Lines]",
          "120:  RList *ret = r_list_newf ((RListFree)r_bin_section_free);",
          "121:  if (!ret) {",
          "125:  RBinPEObj *pe = PE_(get) (bf);",
          "126:  if (!pe || !pe->sections) {",
          "130:  struct r_bin_pe_section_t *sections = pe->sections;",
          "132:  PE_(r_bin_pe_check_sections) (pe, &sections);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "141:    ptr->name = strdup (\"\");",
          "142:   }",
          "143:   ptr->size = sections[i].size;",
          "146:     ptr->size = sections[i].vsize;",
          "147:    } else {",
          "",
          "[Removed Lines]",
          "144:   if (ptr->size > bin->size) {",
          "145:    if (sections[i].vsize < bin->size) {",
          "",
          "[Added Lines]",
          "143:   if (ptr->size > pe->size) {",
          "144:    if (sections[i].vsize < pe->size) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "184: }",
          "186: static void find_pe_overlay(RBinFile *bf) {",
          "187:  ut64 pe_overlay_size;",
          "189:  if (pe_overlay_offset) {",
          "190:   sdb_num_set (bf->sdb, \"pe_overlay.offset\", pe_overlay_offset, 0);",
          "191:   sdb_num_set (bf->sdb, \"pe_overlay.size\", pe_overlay_size, 0);",
          "",
          "[Removed Lines]",
          "188:  ut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (bf->o->bin_obj, &pe_overlay_size);",
          "",
          "[Added Lines]",
          "186:  RBinPEObj *pe = PE_(get) (bf);",
          "188:  ut64 pe_overlay_offset = PE_(bin_pe_get_overlay) (pe, &pe_overlay_size);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "202:  if (!(ret = r_list_newf (free))) {",
          "203:   return NULL;",
          "204:  }",
          "206:   for (i = 0; !symbols[i].last; i++) {",
          "207:    if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "208:     break;",
          "",
          "[Removed Lines]",
          "205:  if ((symbols = PE_(r_bin_pe_get_exports)(bf->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "205:  RBinPEObj *pe = PE_(get) (bf);",
          "206:  if ((symbols = PE_(r_bin_pe_get_exports)(pe))) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "222:   free (symbols);",
          "223:  }",
          "227:   for (i = 0; !imports[i].last; i++) {",
          "228:    if (!(ptr = R_NEW0 (RBinSymbol))) {",
          "229:     break;",
          "",
          "[Removed Lines]",
          "226:  if ((imports = PE_(r_bin_pe_get_imports)(bf->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "226:  if ((imports = PE_(r_bin_pe_get_imports)(pe))) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "243:   }",
          "244:   free (imports);",
          "245:  }",
          "247:  return ret;",
          "248: }",
          "250: static void filter_import(ut8 *n) {",
          "255:    break;",
          "256:   }",
          "257:  }",
          "",
          "[Removed Lines]",
          "246:  find_pe_overlay(bf);",
          "251:  int I;",
          "252:  for (I = 0; n[I]; I++) {",
          "253:   if (n[I] < 30 || n[I] >= 0x7f) {",
          "254:    n[I] = 0;",
          "",
          "[Added Lines]",
          "246:  find_pe_overlay (bf);",
          "251:  size_t i;",
          "252:  for (i = 0; n[i]; i++) {",
          "253:   if (n[i] < 30 || n[i] >= 0x7f) {",
          "254:    n[i] = 0;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "264:  struct r_bin_pe_import_t *imports = NULL;",
          "265:  int i;",
          "268:   return NULL;",
          "269:  }",
          "270:  if (!(ret = r_list_newf ((RListFree)r_bin_import_free))) {",
          "271:   return NULL;",
          "272:  }",
          "277:  }",
          "279:  if (!(relocs = r_list_newf (free))) {",
          "280:   free (ret);",
          "281:   return NULL;",
          "282:  }",
          "286:   return ret;",
          "287:  }",
          "288:  for (i = 0; !imports[i].last; i++) {",
          "",
          "[Removed Lines]",
          "267:  if (!bf || !bf->o || !bf->o->bin_obj) {",
          "275:  if (((struct PE_(r_bin_pe_obj_t)*)bf->o->bin_obj)->relocs) {",
          "276:   r_list_free (((struct PE_(r_bin_pe_obj_t)*)bf->o->bin_obj)->relocs);",
          "283:  ((struct PE_(r_bin_pe_obj_t)*)bf->o->bin_obj)->relocs = relocs;",
          "285:  if (!(imports = PE_(r_bin_pe_get_imports)(bf->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "267:  RBinPEObj *pe = PE_(get) (bf);",
          "268:  if (!pe) {",
          "275:  if (pe->relocs) {",
          "276:   r_list_free (pe->relocs);",
          "282:  pe->relocs = relocs;",
          "284:  if (!(imports = PE_(r_bin_pe_get_imports)(pe))) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "325: }",
          "327: static RList* relocs(RBinFile *bf) {",
          "333: }",
          "335: static RList* libs(RBinFile *bf) {",
          "",
          "[Removed Lines]",
          "328:  struct PE_(r_bin_pe_obj_t)* obj= bf->o->bin_obj;",
          "329:  if (obj) {",
          "330:   return obj->relocs;",
          "331:  }",
          "332:  return NULL;",
          "",
          "[Added Lines]",
          "327:  RBinPEObj *pe = PE_(get) (bf);",
          "328:  return pe? pe->relocs: NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "342:   return NULL;",
          "343:  }",
          "344:  ret->free = free;",
          "346:   return ret;",
          "347:  }",
          "348:  for (i = 0; !libs[i].last; i++) {",
          "",
          "[Removed Lines]",
          "345:  if (!(libs = PE_(r_bin_pe_get_libs)(bf->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "341:  RBinPEObj *pe = PE_(get) (bf);",
          "342:  if (!(libs = PE_(r_bin_pe_get_libs)(pe))) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "353:  return ret;",
          "354: }",
          "360:   return false;",
          "361:  }",
          "362:  for (i = 0; !libs[i].last; i++) {",
          "363:   if (!strcmp (libs[i].name, \"mscoree.dll\")) {",
          "364:    free (libs);",
          "",
          "[Removed Lines]",
          "356: static int is_dot_net(RBinFile *bf) {",
          "357:  struct r_bin_pe_lib_t *libs = NULL;",
          "358:  int i;",
          "359:  if (!(libs = PE_(r_bin_pe_get_libs)(bf->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "353: static bool is_dot_net(RBinFile *bf) {",
          "354:  RBinPEObj *pe = PE_(get) (bf);",
          "355:  struct r_bin_pe_lib_t *libs = PE_(r_bin_pe_get_libs)(pe);",
          "356:  if (!libs) {",
          "360:  size_t i;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "369:  return false;",
          "370: }",
          "374:  int i;",
          "376:   return false;",
          "377:  }",
          "378:  for (i = 0; !libs[i].last; i++) {",
          "",
          "[Removed Lines]",
          "372: static int is_vb6(RBinFile *bf) {",
          "373:  struct r_bin_pe_lib_t *libs = NULL;",
          "375:  if (!(libs = PE_(r_bin_pe_get_libs)(bf->o->bin_obj))) {",
          "",
          "[Added Lines]",
          "371: static bool is_vb6(RBinFile *bf) {",
          "373:  RBinPEObj *pe = PE_(get) (bf);",
          "374:  struct r_bin_pe_lib_t *libs = PE_(r_bin_pe_get_libs)(pe);",
          "375:  if (!libs) {",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "388: static bool check_inlined_canary(RBinFile *bf) {",
          "389:  ut8 buf[64];",
          "391:  if (!entry) {",
          "392:   return false;",
          "393:  }",
          "",
          "[Removed Lines]",
          "390:  struct r_bin_pe_addr_t *entry = PE_(r_bin_pe_get_entrypoint) (bf->o->bin_obj);",
          "",
          "[Added Lines]",
          "390:  RBinPEObj *pe = PE_(get) (bf);",
          "391:  if (!pe) {",
          "392:   return false;",
          "393:  }",
          "394:  struct r_bin_pe_addr_t *entry = PE_(r_bin_pe_get_entrypoint) (pe);",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "466:   }",
          "467:   ut32 canaddr = 0;",
          "468:   r_buf_read_at (bf->buf, calldst + 2, (ut8*)&canaddr, 4);",
          "470:   ut8 can0[4] = {0};",
          "471:   r_buf_read_at (bf->buf, panaddr, can0, 4);",
          "472:   ut8 can1[4] = {0};",
          "",
          "[Removed Lines]",
          "469:   ut32 panaddr = PE_(va2pa)(bf->o->bin_obj, canaddr);",
          "",
          "[Added Lines]",
          "473:   ut32 panaddr = PE_(va2pa)(pe, canaddr);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "497:  RListIter *iter;",
          "501:   RBinReloc *rel;",
          "502:   if (relocs_list) {",
          "503:    r_list_foreach (relocs_list, iter, rel) {",
          "",
          "[Removed Lines]",
          "498:  struct PE_ (r_bin_pe_obj_t) *bin = bf->o->bin_obj;",
          "499:  if (bin) {",
          "500:   const RList* relocs_list = bin->relocs;",
          "",
          "[Added Lines]",
          "502:  RBinPEObj *pe = PE_(get) (bf);",
          "503:  if (pe) {",
          "504:   const RList* relocs_list = pe->relocs;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "520:  return false;",
          "521: }",
          "527:  if (!bf) {",
          "528:   return false;",
          "529:  }",
          "531:  if (!buf) {",
          "532:   return false;",
          "533:  }",
          "535:  if (idx + 0x5E + 1 >= sz ) {",
          "536:   return false;",
          "537:  }",
          "",
          "[Removed Lines]",
          "523: static int haschr(const RBinFile* bf, ut16 dllCharacteristic) {",
          "524:  const ut8 *buf;",
          "525:  unsigned int idx;",
          "526:  ut64 sz;",
          "530:  buf = r_buf_data (bf->buf, &sz);",
          "534:  idx = (buf[0x3c] | (buf[0x3d]<<8));",
          "",
          "[Added Lines]",
          "527: static bool haschr(const RBinFile* bf, ut16 dllCharacteristic) {",
          "531:  ut64 sz;",
          "532:  const ut8 *buf = r_buf_data (bf->buf, &sz);",
          "536:  size_t idx = (buf[0x3c] | (buf[0x3d]<<8));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "541: }",
          "543: static RBinInfo* info(RBinFile *bf) {",
          "546:  RBinInfo *ret = R_NEW0 (RBinInfo);",
          "549:  if (!ret) {",
          "550:   return NULL;",
          "551:  }",
          "553:  ret->file = strdup (bf->file);",
          "555:  ret->rclass = strdup (\"pe\");",
          "561:  if (is_dot_net (bf)) {",
          "562:   ret->lang = \"cil\";",
          "563:  }",
          "564:  if (is_vb6 (bf)) {",
          "565:   ret->lang = \"vb\";",
          "566:  }",
          "577:  ret->dbg_info = 0;",
          "578:  ret->has_lit = true;",
          "579:  ret->has_canary = has_canary (bf);",
          "",
          "[Removed Lines]",
          "544:  struct PE_ (r_bin_pe_obj_t) *bin;",
          "545:  SDebugInfo di = {{0}};",
          "547:  ut32 claimed_checksum, actual_checksum, pe_overlay;",
          "552:  bin = bf->o->bin_obj;",
          "554:  ret->bclass = PE_(r_bin_pe_get_class) (bf->o->bin_obj);",
          "556:  ret->os = PE_(r_bin_pe_get_os) (bf->o->bin_obj);",
          "557:  ret->arch = PE_(r_bin_pe_get_arch) (bf->o->bin_obj);",
          "558:  ret->machine = PE_(r_bin_pe_get_machine) (bf->o->bin_obj);",
          "559:  ret->subsystem = PE_(r_bin_pe_get_subsystem) (bf->o->bin_obj);",
          "560:  ret->default_cc = PE_(r_bin_pe_get_cc) (bf->o->bin_obj);",
          "567:  if (PE_(r_bin_pe_is_dll) (bf->o->bin_obj)) {",
          "568:   ret->type = strdup (\"DLL (Dynamic Link Library)\");",
          "569:  } else {",
          "570:   ret->type = strdup (\"EXEC (Executable file)\");",
          "571:  }",
          "572:  claimed_checksum = PE_(bin_pe_get_claimed_checksum) (bf->o->bin_obj);",
          "573:  actual_checksum  = PE_(bin_pe_get_actual_checksum) (bf->o->bin_obj);",
          "574:  pe_overlay = sdb_num_get (bf->sdb, \"pe_overlay.size\", 0);",
          "575:  ret->bits = PE_(r_bin_pe_get_bits) (bf->o->bin_obj);",
          "576:  ret->big_endian = PE_(r_bin_pe_is_big_endian) (bf->o->bin_obj);",
          "",
          "[Added Lines]",
          "546:  RBinPEObj *pe = PE_(get) (bf);",
          "547:  if (!pe) {",
          "548:   return NULL;",
          "549:  }",
          "555:  ret->bclass = PE_(r_bin_pe_get_class) (pe);",
          "557:  ret->os = PE_(r_bin_pe_get_os) (pe);",
          "558:  ret->arch = PE_(r_bin_pe_get_arch) (pe);",
          "559:  ret->machine = PE_(r_bin_pe_get_machine) (pe);",
          "560:  ret->subsystem = PE_(r_bin_pe_get_subsystem) (pe);",
          "561:  ret->default_cc = PE_(r_bin_pe_get_cc) (pe);",
          "568:  const char *typestr = PE_(r_bin_pe_is_dll) (pe) ? \"DLL (Dynamic Link Library)\": \"EXEC (Executable file)\";",
          "569:  ret->type = strdup (typestr);",
          "571:  ut32 claimed_checksum = PE_(bin_pe_get_claimed_checksum) (pe);",
          "572:  ut32 actual_checksum = PE_(bin_pe_get_actual_checksum) (pe);",
          "574:  ut32 pe_overlay = sdb_num_get (bf->sdb, \"pe_overlay.size\", 0);",
          "575:  ret->bits = PE_(r_bin_pe_get_bits) (pe);",
          "576:  ret->big_endian = PE_(r_bin_pe_is_big_endian) (pe);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "582:  ret->claimed_checksum = r_str_newf (\"0x%08x\", claimed_checksum);",
          "583:  ret->actual_checksum = r_str_newf (\"0x%08x\", actual_checksum);",
          "584:  ret->pe_overlay = pe_overlay > 0;",
          "586:  ret->file_hashes = r_list_newf ((RListFree) r_bin_file_hash_free);",
          "587:  Sdb *db = sdb_ns (bf->sdb, \"pe\", true);",
          "588:  sdb_bool_set (db, \"canary\", has_canary (bf), 0);",
          "",
          "[Removed Lines]",
          "585:  ret->signature = bin ? bin->is_signed : false;",
          "",
          "[Added Lines]",
          "585:  ret->signature = pe ? pe->is_signed : false;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "600:  sdb_num_set (db, \"bits\", ret->bits, 0);",
          "601:  sdb_set (db, \"claimed_checksum\", ret->claimed_checksum, 0);",
          "602:  sdb_set (db, \"actual_checksum\", ret->actual_checksum, 0);",
          "605:  ret->has_va = true;",
          "608:   ret->dbg_info |= R_BIN_DBG_STRIPPED;",
          "609:  }",
          "611:   ret->dbg_info |= R_BIN_DBG_LINENUMS;",
          "612:  }",
          "614:   ret->dbg_info |= R_BIN_DBG_SYMS;",
          "615:  }",
          "617:   ret->dbg_info |= R_BIN_DBG_RELOCS;",
          "618:  }",
          "620:   ret->guid = r_str_ndup (di.guidstr, GUIDSTR_LEN);",
          "621:   if (ret->guid) {",
          "622:    ret->debug_file_name = r_str_ndup (di.file_name, DBG_FILE_NAME_LEN);",
          "",
          "[Removed Lines]",
          "603:  sdb_bool_set (db, \"is_authhash_valid\", PE_(bin_pe_is_authhash_valid) (bf->o->bin_obj), 0);",
          "607:  if (PE_(r_bin_pe_is_stripped_debug) (bf->o->bin_obj)) {",
          "610:  if (PE_(r_bin_pe_is_stripped_line_nums) (bf->o->bin_obj)) {",
          "613:  if (PE_(r_bin_pe_is_stripped_local_syms) (bf->o->bin_obj)) {",
          "616:  if (PE_(r_bin_pe_is_stripped_relocs) (bf->o->bin_obj)) {",
          "619:  if (PE_(r_bin_pe_get_debug_data)(bf->o->bin_obj, &di)) {",
          "",
          "[Added Lines]",
          "603:  sdb_bool_set (db, \"is_authhash_valid\", PE_(bin_pe_is_authhash_valid) (pe), 0);",
          "607:  if (PE_(r_bin_pe_is_stripped_debug) (pe)) {",
          "610:  if (PE_(r_bin_pe_is_stripped_line_nums) (pe)) {",
          "613:  if (PE_(r_bin_pe_is_stripped_local_syms) (pe)) {",
          "616:  if (PE_(r_bin_pe_is_stripped_relocs) (pe)) {",
          "620:  SDebugInfo di = {{0}};",
          "621:  if (PE_(r_bin_pe_get_debug_data)(pe, &di)) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "636: static RList *compute_hashes(RBinFile *bf) {",
          "637:  RList *file_hashes = r_list_newf ((RListFree) r_bin_file_hash_free);",
          "645:   }",
          "646:  }",
          "648:  return file_hashes;",
          "649: }",
          "",
          "[Removed Lines]",
          "638:  const char *authentihash = PE_(bin_pe_compute_authentihash) (bf->o->bin_obj);",
          "639:  if (authentihash) {",
          "640:   RBinFileHash *authhash = R_NEW0 (RBinFileHash);",
          "641:   if (authhash) {",
          "642:    authhash->type = strdup (\"authentihash\");",
          "643:    authhash->hex = authentihash;",
          "644:    r_list_push (file_hashes, authhash);",
          "",
          "[Added Lines]",
          "640:  RBinPEObj *pe = PE_(get) (bf);",
          "641:  if (pe) {",
          "642:   const char *authentihash = PE_(bin_pe_compute_authentihash) (pe);",
          "643:   if (authentihash) {",
          "644:    RBinFileHash *authhash = R_NEW0 (RBinFileHash);",
          "645:    if (authhash) {",
          "646:     authhash->type = strdup (\"authentihash\");",
          "647:     authhash->hex = authentihash;",
          "648:     r_list_push (file_hashes, authhash);",
          "649:    }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19924",
  "cve_desc": "SQLite 3.30.1 mishandles certain parser-tree rewriting, related to expr.c, vdbeaux.c, and window.c. This is caused by incorrect sqlite3WindowRewrite() error handling.",
  "repo": "sqlite/sqlite",
  "patch_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
  "patch_info": {
    "commit_hash": "8654186b0236d556aa85528c2573ee0b6ab71be3",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/8654186b0236d556aa85528c2573ee0b6ab71be3",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/vdbeaux.c",
      "src/window.c"
    ],
    "message": "When an error occurs while rewriting the parser tree for window functions in the sqlite3WindowRewrite() routine, make sure that pParse->nErr is set, and make sure that this shuts down any subsequent code generation that might depend on the transformations that were implemented.  This fixes a problem discovered by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/vdbeaux.c||src/vdbeaux.c",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 4417c5bf0aabb34ed174f01afd981c924ae965a42128719d8d6735536631d12f",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "376:   int addr;",
      "377:   CollSeq *p4;",
      "379:   if( isCommuted ){",
      "380:     p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);",
      "381:   }else{",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "379:   if( pParse->nErr ) return 0;",
      "",
      "---------------"
    ],
    "src/vdbeaux.c||src/vdbeaux.c": [
      "File: src/vdbeaux.c -> src/vdbeaux.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1304: static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){",
      "1305:   assert( p->nOp>0 || p->aOp==0 );",
      "1307:   if( p->nOp ){",
      "1308:     assert( p->aOp );",
      "1309:     sqlite3DbFree(p->db, p->aOp[p->nOp-1].zComment);",
      "",
      "[Removed Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );",
      "",
      "[Added Lines]",
      "1306:   assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed",
      "1307:           || p->pParse->nErr>0 );",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "935:     pTab = sqlite3DbMallocZero(db, sizeof(Table));",
      "936:     if( pTab==0 ){",
      "938:     }",
      "940:     p->pSrc = 0;",
      "",
      "[Removed Lines]",
      "937:       return SQLITE_NOMEM;",
      "",
      "[Added Lines]",
      "937:       return sqlite3ErrorToParser(db, SQLITE_NOMEM);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1039:     sqlite3DbFree(db, pTab);",
      "1040:   }",
      "1042:   return rc;",
      "1043: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1042:   if( rc && pParse->nErr==0 ){",
      "1043:     assert( pParse->db->mallocFailed );",
      "1044:     return sqlite3ErrorToParser(pParse->db, SQLITE_NOMEM);",
      "1045:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "16fd04cdbe01c2cd9f90383592555bae7f4d9927",
      "candidate_info": {
        "commit_hash": "16fd04cdbe01c2cd9f90383592555bae7f4d9927",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/16fd04cdbe01c2cd9f90383592555bae7f4d9927",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/tokenize.c",
          "src/update.c",
          "test/normalize.test"
        ],
        "message": "Enhancements to SQL query normalization for UPDATE statements.\n\nFossilOrigin-Name: bba975c7af3de9aeb5c62fb8b05d61b96e4ecd0b030008442bbdd345e1e5f134",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/tokenize.c||src/tokenize.c",
          "src/update.c||src/update.c",
          "test/normalize.test||test/normalize.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: eea1e7aa57e74c4329003f4550168e2aed9e33d2301a3ba84b10781a9cebbc1b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/tokenize.c||src/tokenize.c": [
          "File: src/tokenize.c -> src/tokenize.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "801:       }",
          "802:       case TK_RP: {",
          "803:         if( iStartIN>0 && nParen==nParenAtIN ){",
          "805:           pStr->nChar = iStartIN+1;",
          "806:           sqlite3_str_append(pStr, \"?,?,?\", 5);",
          "807:           iStartIN = 0;",
          "",
          "[Removed Lines]",
          "804:           assert( pStr->nChar>=iStartIN );",
          "",
          "[Added Lines]",
          "804:           assert( pStr->nChar>=(u32)iStartIN );",
          "",
          "---------------"
        ],
        "src/update.c||src/update.c": [
          "File: src/update.c -> src/update.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "289:   sNC.uNC.pUpsert = pUpsert;",
          "290:   sNC.ncFlags = NC_UUpsert;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "293:   v = sqlite3GetVdbe(pParse);",
          "294:   if( v==0 ) goto update_cleanup;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "386:     memset(aToOpen, 1, nIdx+1);",
          "387:   }",
          "392:   if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);",
          "393:   sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);",
          "",
          "[Removed Lines]",
          "390:   v = sqlite3GetVdbe(pParse);",
          "391:   if( v==0 ) goto update_cleanup;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/normalize.test||test/normalize.test": [
          "File: test/normalize.test -> test/normalize.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "347:   {SELECT x FROM t1 WHERE x IN ([x] IS NOT NULL, NULL, 1, 'a', \"b\", x'00');}",
          "348:   0x2",
          "349:   {0 {SELECT x FROM t1 WHERE x IN(x IS NOT NULL,?,?,?,b,?);}}",
          "350: } {",
          "351:   do_test $tnum {",
          "352:     set code [catch {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:   800",
          "352:   {ATTACH \"normalize800.db\" AS somefile;}",
          "353:   0x2",
          "354:   {0 {ATTACH\"normalize800.db\"AS somefile;}}",
          "356:   810",
          "357:   {ATTACH DATABASE \"normalize810.db\" AS somefile;}",
          "358:   0x2",
          "359:   {0 {ATTACH DATABASE\"normalize810.db\"AS somefile;}}",
          "361:   900",
          "362:   {INSERT INTO t1 (x) VALUES(\"sl1\"), (1), (\"sl2\"), ('i');}",
          "363:   0x2",
          "364:   {0 {INSERT INTO t1(x)VALUES(?),(?),(?),(?);}}",
          "366:   910",
          "367:   {UPDATE t1 SET x = \"sl1\" WHERE x IN (1, \"sl2\", 'i');}",
          "368:   0x2",
          "369:   {0 {UPDATE t1 SET x=?WHERE x IN(?,?,?);}}",
          "371:   920",
          "372:   {UPDATE t1 SET x = \"y\" WHERE x IN (1, \"sl1\", 'i');}",
          "373:   0x2",
          "374:   {0 {UPDATE t1 SET x=y WHERE x IN(?,?,?);}}",
          "376:   930",
          "377:   {DELETE FROM t1 WHERE x IN (1, \"sl1\", 'i');}",
          "378:   0x2",
          "379:   {0 {DELETE FROM t1 WHERE x IN(?,?,?);}}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "04fcef00eed718bcaea0ef6c9172500a27a1052e",
      "candidate_info": {
        "commit_hash": "04fcef00eed718bcaea0ef6c9172500a27a1052e",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/04fcef00eed718bcaea0ef6c9172500a27a1052e",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c",
          "test/insert.test"
        ],
        "message": "Fix a corner-case for the logic that cause an insert of a NULL into an INTEGER PRIMARY KEY column to be converted into a valid integer key, when the NULL results from a CASE expression that lacks an ELSE clause.\n\nFossilOrigin-Name: 9a425051e7ba59e797636f5cf32b5f6efafdb21c8d5300e099b8008b829c1439",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c",
          "test/insert.test||test/insert.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 10ffc1fe006a1766ff2f1ffc6129786afb86b6b1f8d3a17334e8ecb838d37b9c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "953:       }else if( pSelect ){",
          "954:         sqlite3VdbeAddOp2(v, OP_Copy, regFromSelect+ipkColumn, regRowid);",
          "955:       }else{",
          "961:           appendFlag = 1;",
          "966:         }",
          "967:       }",
          "",
          "[Removed Lines]",
          "956:         VdbeOp *pOp;",
          "957:         sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);",
          "958:         pOp = sqlite3VdbeGetOp(v, -1);",
          "959:         assert( pOp!=0 );",
          "960:         if( pOp->opcode==OP_Null && !IsVirtual(pTab) ){",
          "962:           pOp->opcode = OP_NewRowid;",
          "963:           pOp->p1 = iDataCur;",
          "964:           pOp->p2 = regRowid;",
          "965:           pOp->p3 = regAutoinc;",
          "",
          "[Added Lines]",
          "956:         Expr *pIpk = pList->a[ipkColumn].pExpr;",
          "957:         if( pIpk->op==TK_NULL && !IsVirtual(pTab) ){",
          "958:           sqlite3VdbeAddOp3(v, OP_NewRowid, iDataCur, regRowid, regAutoinc);",
          "960:         }else{",
          "961:           sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);",
          "",
          "---------------"
        ],
        "test/insert.test||test/insert.test": [
          "File: test/insert.test -> test/insert.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "449:   SELECT * FROM t13 ORDER BY +b;",
          "450: } {2 0 6 2 1 5}",
          "452: integrity_check insert-99.0",
          "454: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "452: # 2019-01-17.  From the chromium fuzzer.",
          "453: #",
          "454: do_execsql_test insert-14.1 {",
          "455:   DROP TABLE IF EXISTS t14;",
          "456:   CREATE TABLE t14(x INTEGER PRIMARY KEY);",
          "457:   INSERT INTO t14 VALUES(CASE WHEN 1 THEN null END);",
          "458:   SELECT x FROM t14;",
          "459: } {1}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9443dbc493612588608e5cc6d3c46891c1c8025e",
      "candidate_info": {
        "commit_hash": "9443dbc493612588608e5cc6d3c46891c1c8025e",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9443dbc493612588608e5cc6d3c46891c1c8025e",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Improve the \".recover\" command so that it handles intkey pages linked into non-intkey b-trees, and vice-versa, better.\n\nFossilOrigin-Name: 9c458acba5a100a76148a3efb78ea9f57b85751e80788e4532694bd8976608a0",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: becaaa4d29d17ad613f2a120f0b173e53403b3de26f22beaf83f66ebf369bf60",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "6740:   );",
          "6741:   shellPrepare(pState->db, &rc,",
          "6742:       \"SELECT max(field), group_concat(shell_escape_crnl(quote(value)), ', ')\"",
          "6743:       \"FROM sqlite_dbdata WHERE pgno = ? AND field != ?\"",
          "6744:       \"GROUP BY cell\", &pCells",
          "6745:   );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6743:       \", min(field) \"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6758:     int bNoop = 0;",
          "6759:     RecoverTable *pTab;",
          "6761:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6762:     if( bNoop || rc ) continue;",
          "6763:     if( pTab==0 ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6762:     assert( bIntkey==0 || bIntkey==1 );",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6779:       sqlite3_bind_int(pCells, 1, iPgno);",
          "6780:       while( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pCells) ){",
          "6781:         int nField = sqlite3_column_int(pCells, 0);",
          "6782:         const char *zVal = (const char*)sqlite3_column_text(pCells, 1);",
          "6784:         nField = nField+1;",
          "6786:           raw_printf(pState->out,",
          "6787:               \"INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\\n\",",
          "6790:           );",
          "6791:         }else{",
          "6792:           raw_printf(pState->out, \"INSERT INTO %s(%s) VALUES( %s );\\n\",",
          "6794:           );",
          "6795:         }",
          "6796:       }",
          "",
          "[Removed Lines]",
          "6785:         if( pTab==pOrphan ){",
          "6788:               pTab->zQuoted, iRoot, iPgno, nField,",
          "6789:               bIntkey ? \"\" : \"NULL, \", zVal, pTab->azlCol[nField]",
          "6793:               pTab->zQuoted, pTab->azlCol[nField], zVal",
          "",
          "[Added Lines]",
          "6784:         int iMin = sqlite3_column_int(pCells, 2);",
          "6787:         RecoverTable *pTab2 = pTab;",
          "6788:         if( pTab!=pOrphan && (iMin<0)!=bIntkey ){",
          "6789:           if( pOrphan==0 ){",
          "6790:             pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "6791:           }",
          "6792:           pTab2 = pOrphan;",
          "6793:           if( pTab2==0 ) break;",
          "6794:         }",
          "6797:         if( pTab2==pOrphan ){",
          "6800:               pTab2->zQuoted, iRoot, iPgno, nField,",
          "6801:               iMin<0 ? \"\" : \"NULL, \", zVal, pTab2->azlCol[nField]",
          "6805:               pTab2->zQuoted, pTab2->azlCol[nField], zVal",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12fe9a0d2512ebbbcc9c492af187ff76404b913e",
      "candidate_info": {
        "commit_hash": "12fe9a0d2512ebbbcc9c492af187ff76404b913e",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/12fe9a0d2512ebbbcc9c492af187ff76404b913e",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "test/fuzzdata8.db"
        ],
        "message": "Fix an assert() that might not be true if the database file is corrupt.\n\nFossilOrigin-Name: f2d400db4dbfb05e2540178ed3662f97f8c57a95f8129886c7081c35e53adf0d",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 0abace8a7aecca01c8677d07f3ec1bafb289ceffe5bcd60284701a7bf813f415",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8261:   }",
          "8262:   assert( sqlite3PagerIswriteable(pChild->pDbPage) );",
          "8263:   assert( sqlite3PagerIswriteable(pRoot->pDbPage) );",
          "8266:   TRACE((\"BALANCE: copy root %d into %d\\n\", pRoot->pgno, pChild->pgno));",
          "",
          "[Removed Lines]",
          "8264:   assert( pChild->nCell==pRoot->nCell );",
          "",
          "[Added Lines]",
          "8264:   assert( pChild->nCell==pRoot->nCell || CORRUPT_DB );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6214d93993a545b578e7139951f07840e049ee45",
      "candidate_info": {
        "commit_hash": "6214d93993a545b578e7139951f07840e049ee45",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/6214d93993a545b578e7139951f07840e049ee45",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/insert.c"
        ],
        "message": "Fix an off-by-one error on a Goto in the code generator, that only causes problems for a REPLACE on an INTEGER PRIMARY KEY in non-debug builds.  Test case in TH3.\n\nFossilOrigin-Name: e35eb8776ed539afe1d5db099470ab1124d8dd2db73ee5db7c811f8df9a9576e",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/insert.c||src/insert.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 703646b1b5c84d550fe0d74e399c0eeb729da1d263e4693320f69e6509678985",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/insert.c||src/insert.c": [
          "File: src/insert.c -> src/insert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1844:   if( ipkTop ){",
          "1846:     VdbeComment((v, \"Do IPK REPLACE\"));",
          "1847:     sqlite3VdbeJumpHere(v, ipkBottom);",
          "1848:   }",
          "",
          "[Removed Lines]",
          "1845:     sqlite3VdbeGoto(v, ipkTop+1);",
          "",
          "[Added Lines]",
          "1845:     sqlite3VdbeGoto(v, ipkTop);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2012-2330",
  "cve_desc": "The Update method in src/node_http_parser.cc in Node.js before 0.6.17 and 0.7 before 0.7.8 does not properly check the length of a string, which allows remote attackers to obtain sensitive information (request header contents) and possibly spoof HTTP headers via a zero length string.",
  "repo": "joyent/node",
  "patch_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
  "patch_info": {
    "commit_hash": "c9a231db0e59658be419d926b1dfa17b939ba158",
    "repo": "joyent/node",
    "commit_url": "https://github.com/joyent/node/commit/c9a231d",
    "files": [
      "src/node_http_parser.cc"
    ],
    "message": "typo in node_http_parser",
    "before_after_code_files": [
      "src/node_http_parser.cc||src/node_http_parser.cc"
    ]
  },
  "patch_diff": {
    "src/node_http_parser.cc||src/node_http_parser.cc": [
      "File: src/node_http_parser.cc -> src/node_http_parser.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "191:   void Update(const char* str, size_t size) {",
      "192:     if (str_ == NULL)",
      "193:       str_ = str;",
      "197:       char* s = new char[size_ + size];",
      "",
      "[Removed Lines]",
      "194:     else if (on_heap_ || str_ + size != str) {",
      "",
      "[Added Lines]",
      "194:     else if (on_heap_ || str_ + size_ != str) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "105c6ec8d596be2b7cc95339923ca38ea614f54e",
      "candidate_info": {
        "commit_hash": "105c6ec8d596be2b7cc95339923ca38ea614f54e",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/105c6ec8d596be2b7cc95339923ca38ea614f54e",
        "files": [
          "test/simple/test-dgram-pingpong.js"
        ],
        "message": "test: suppress simple/test-dgram-pingpong chatter",
        "before_after_code_files": [
          "test/simple/test-dgram-pingpong.js||test/simple/test-dgram-pingpong.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/simple/test-dgram-pingpong.js||test/simple/test-dgram-pingpong.js": [
          "File: test/simple/test-dgram-pingpong.js -> test/simple/test-dgram-pingpong.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: var Buffer = require('buffer').Buffer;",
          "28: var dgram = require('dgram');",
          "30: var tests_run = 0;",
          "32: function pingPongTest(port, host) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: var debug = false;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:   var sent_final_ping = false;",
          "38:   var server = dgram.createSocket('udp4', function(msg, rinfo) {",
          "42:     if (/PING/.exec(msg)) {",
          "43:       var buf = new Buffer(4);",
          "",
          "[Removed Lines]",
          "39:     console.log('server got: ' + msg +",
          "40:                 ' from ' + rinfo.address + ':' + rinfo.port);",
          "",
          "[Added Lines]",
          "40:     if (debug) console.log('server got: ' + msg +",
          "41:                            ' from ' + rinfo.address + ':' + rinfo.port);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:         client = dgram.createSocket('udp4');",
          "63:     client.on('message', function(msg, rinfo) {",
          "66:       assert.equal('PONG', msg.toString('ascii'));",
          "68:       count += 1;",
          "",
          "[Removed Lines]",
          "64:       console.log('client got: ' + msg +",
          "65:                   ' from ' + rinfo.address + ':' + rinfo.port);",
          "",
          "[Added Lines]",
          "65:       if (debug) console.log('client got: ' + msg +",
          "66:                              ' from ' + rinfo.address + ':' + rinfo.port);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "37d75ba241780c9199f601dd4c70713d190c68e6",
      "candidate_info": {
        "commit_hash": "37d75ba241780c9199f601dd4c70713d190c68e6",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/37d75ba241780c9199f601dd4c70713d190c68e6",
        "files": [
          "deps/uv/include/uv-private/uv-win.h",
          "deps/uv/include/uv.h",
          "deps/uv/src/unix/core.c",
          "deps/uv/src/win/internal.h",
          "deps/uv/src/win/process-stdio.c",
          "deps/uv/src/win/process.c",
          "deps/uv/uv.gyp"
        ],
        "message": "uv: upgrade to 4d7f1e18",
        "before_after_code_files": [
          "deps/uv/include/uv-private/uv-win.h||deps/uv/include/uv-private/uv-win.h",
          "deps/uv/include/uv.h||deps/uv/include/uv.h",
          "deps/uv/src/unix/core.c||deps/uv/src/unix/core.c",
          "deps/uv/src/win/internal.h||deps/uv/src/win/internal.h",
          "deps/uv/src/win/process-stdio.c||deps/uv/src/win/process-stdio.c",
          "deps/uv/src/win/process.c||deps/uv/src/win/process.c",
          "deps/uv/uv.gyp||deps/uv/uv.gyp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/uv/include/uv-private/uv-win.h||deps/uv/include/uv-private/uv-win.h": [
          "File: deps/uv/include/uv-private/uv-win.h -> deps/uv/include/uv-private/uv-win.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "456:   struct uv_process_close_s {             \\",
          "457:     UV_REQ_FIELDS                         \\",
          "458:   } close_req;                            \\",
          "460:   int exit_signal;                        \\",
          "461:   DWORD spawn_errno;                      \\",
          "462:   HANDLE wait_handle;                     \\",
          "",
          "[Removed Lines]",
          "459:   void* child_stdio_buffer;               \\",
          "",
          "[Added Lines]",
          "459:   BYTE* child_stdio_buffer;               \\",
          "",
          "---------------"
        ],
        "deps/uv/include/uv.h||deps/uv/include/uv.h": [
          "File: deps/uv/include/uv.h -> deps/uv/include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1580: UV_EXTERN extern uint64_t uv_hrtime(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1597: UV_EXTERN void uv_disable_stdio_inheritance(void);",
          "",
          "---------------"
        ],
        "deps/uv/src/unix/core.c||deps/uv/src/unix/core.c": [
          "File: deps/uv/src/unix/core.c -> deps/uv/src/unix/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "464: int uv__nonblock(int fd, int set) {",
          "465: #if FIONBIO",
          "467: #else",
          "468:   int flags;",
          "471:     return -1;",
          "485: #endif",
          "486: }",
          "489: int uv__cloexec(int fd, int set) {",
          "490: #if __linux__",
          "495: #else",
          "499:     return -1;",
          "514: }",
          "",
          "[Removed Lines]",
          "466:   return ioctl(fd, FIONBIO, &set);",
          "470:   if ((flags = fcntl(fd, F_GETFL)) == -1) {",
          "472:   }",
          "474:   if (set) {",
          "475:     flags |= O_NONBLOCK;",
          "476:   } else {",
          "477:     flags &= ~O_NONBLOCK;",
          "478:   }",
          "480:   if (fcntl(fd, F_SETFL, flags) == -1) {",
          "481:     return -1;",
          "482:   }",
          "484:   return 0;",
          "494:   return fcntl(fd, F_SETFD, set ? FD_CLOEXEC : 0);",
          "496:   int flags;",
          "498:   if ((flags = fcntl(fd, F_GETFD)) == -1) {",
          "500:   }",
          "502:   if (set) {",
          "503:     flags |= FD_CLOEXEC;",
          "504:   } else {",
          "505:     flags &= ~FD_CLOEXEC;",
          "506:   }",
          "508:   if (fcntl(fd, F_SETFD, flags) == -1) {",
          "509:     return -1;",
          "510:   }",
          "512:   return 0;",
          "513: #endif",
          "",
          "[Added Lines]",
          "465:   int r;",
          "468:   do",
          "469:     r = ioctl(fd, FIONBIO, &set);",
          "470:   while (r == -1 && errno == EINTR);",
          "472:   return r;",
          "476:   do",
          "477:     r = fcntl(fd, F_GETFL);",
          "478:   while (r == -1 && errno == EINTR);",
          "480:   if (r == -1)",
          "483:   if (set)",
          "484:     flags = r | O_NONBLOCK;",
          "485:   else",
          "486:     flags = r & ~O_NONBLOCK;",
          "488:   do",
          "489:     r = fcntl(fd, F_SETFL, flags);",
          "490:   while (r == -1 && errno == EINTR);",
          "492:   return r;",
          "498:   int flags;",
          "499:   int r;",
          "505:   if (set)",
          "506:     flags = FD_CLOEXEC;",
          "507:   else",
          "508:     flags = 0;",
          "510:   do",
          "511:     r = fcntl(fd, F_GETFD);",
          "512:   while (r == -1 && errno == EINTR);",
          "514:   if (r == -1)",
          "517:   if (set)",
          "518:     flags = r | FD_CLOEXEC;",
          "519:   else",
          "520:     flags = r & ~FD_CLOEXEC;",
          "521: #endif",
          "523:   do",
          "524:     r = fcntl(fd, F_SETFD, flags);",
          "525:   while (r == -1 && errno == EINTR);",
          "527:   return r;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "572: }",
          "575: static void uv__io_set_cb(uv__io_t* handle, uv__io_cb cb) {",
          "576:   union { void* data; uv__io_cb cb; } u;",
          "577:   u.cb = cb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "589: void uv_disable_stdio_inheritance(void) {",
          "590:   int fd;",
          "595:   for (fd = 0; ; fd++)",
          "596:     if (uv__cloexec(fd, 1) && fd > 15)",
          "597:       break;",
          "598: }",
          "",
          "---------------"
        ],
        "deps/uv/src/win/internal.h||deps/uv/src/win/internal.h": [
          "File: deps/uv/src/win/internal.h -> deps/uv/src/win/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "279: uv_err_code uv_translate_sys_error(int sys_errno);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285: int uv__stdio_create(uv_loop_t* loop, uv_process_options_t* options,",
          "286:     BYTE** buffer_ptr);",
          "287: void uv__stdio_destroy(BYTE* buffer);",
          "288: void uv__stdio_noinherit(BYTE* buffer);",
          "289: int uv__stdio_verify(BYTE* buffer, WORD size);",
          "290: WORD uv__stdio_size(BYTE* buffer);",
          "291: HANDLE uv__stdio_handle(BYTE* buffer, int fd);",
          "",
          "---------------"
        ],
        "deps/uv/src/win/process-stdio.c||deps/uv/src/win/process-stdio.c": [
          "File: deps/uv/src/win/process-stdio.c -> deps/uv/src/win/process-stdio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: #include <assert.h>",
          "23: #include <io.h>",
          "24: #include <stdio.h>",
          "25: #include <stdlib.h>",
          "27: #include \"uv.h\"",
          "28: #include \"internal.h\"",
          "37: #define CHILD_STDIO_SIZE(count)                     \\",
          "38:     (sizeof(int) +                                  \\",
          "39:      sizeof(unsigned char) * (count) +              \\",
          "40:      sizeof(uintptr_t) * (count))",
          "42: #define CHILD_STDIO_COUNT(buffer)                   \\",
          "45: #define CHILD_STDIO_CRT_FLAGS(buffer, fd)           \\",
          "48: #define CHILD_STDIO_HANDLE(buffer, fd)              \\",
          "50:                  sizeof(int) +                      \\",
          "51:                  sizeof(unsigned char) *            \\",
          "52:                  CHILD_STDIO_COUNT((buffer)) +      \\",
          "53:                  sizeof(HANDLE) * (fd)))",
          "57: #define FOPEN       0x01",
          "58: #define FEOFLAG     0x02",
          "59: #define FCRLF       0x04",
          "60: #define FPIPE       0x08",
          "61: #define FNOINHERIT  0x10",
          "62: #define FAPPEND     0x20",
          "63: #define FDEV        0x40",
          "64: #define FTEXT       0x80",
          "73: void uv_disable_stdio_inheritance(void) {",
          "74:   HANDLE handle;",
          "75:   STARTUPINFOW si;",
          "78:   handle = GetStdHandle(STD_INPUT_HANDLE);",
          "79:   if (handle != NULL && handle != INVALID_HANDLE_VALUE)",
          "80:     SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);",
          "82:   handle = GetStdHandle(STD_OUTPUT_HANDLE);",
          "83:   if (handle != NULL && handle != INVALID_HANDLE_VALUE)",
          "84:     SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);",
          "86:   handle = GetStdHandle(STD_ERROR_HANDLE);",
          "87:   if (handle != NULL && handle != INVALID_HANDLE_VALUE)",
          "88:     SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);",
          "91:   GetStartupInfoW(&si);",
          "92:   if (uv__stdio_verify(si.lpReserved2, si.cbReserved2))",
          "93:     uv__stdio_noinherit(si.lpReserved2);",
          "94: }",
          "97: static int uv__create_stdio_pipe_pair(uv_loop_t* loop, uv_pipe_t* server_pipe,",
          "98:     HANDLE* child_pipe_ptr, unsigned int flags) {",
          "99:   char pipe_name[64];",
          "100:   SECURITY_ATTRIBUTES sa;",
          "101:   DWORD server_access = 0;",
          "102:   DWORD client_access = 0;",
          "103:   HANDLE child_pipe = INVALID_HANDLE_VALUE;",
          "105:   if (flags & UV_READABLE_PIPE) {",
          "106:     server_access |= PIPE_ACCESS_OUTBOUND;",
          "107:     client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;",
          "108:   }",
          "109:   if (flags & UV_WRITABLE_PIPE) {",
          "110:     server_access |= PIPE_ACCESS_INBOUND;",
          "111:     client_access |= GENERIC_WRITE;",
          "112:   }",
          "115:   if (uv_stdio_pipe_server(loop,",
          "116:                            server_pipe,",
          "117:                            server_access,",
          "118:                            pipe_name,",
          "119:                            sizeof(pipe_name)) < 0) {",
          "120:     goto error;",
          "121:   }",
          "124:   sa.nLength = sizeof sa;",
          "125:   sa.lpSecurityDescriptor = NULL;",
          "126:   sa.bInheritHandle = TRUE;",
          "128:   child_pipe = CreateFileA(pipe_name,",
          "129:                            client_access,",
          "130:                            0,",
          "131:                            &sa,",
          "132:                            OPEN_EXISTING,",
          "133:                            server_pipe->ipc ? FILE_FLAG_OVERLAPPED : 0,",
          "134:                            NULL);",
          "135:   if (child_pipe == INVALID_HANDLE_VALUE) {",
          "136:     uv__set_sys_error(loop, GetLastError());",
          "137:     goto error;",
          "138:   }",
          "140: #ifndef NDEBUG",
          "142:   {",
          "143:     DWORD mode;",
          "144:     BOOL r = GetNamedPipeHandleState(child_pipe,",
          "145:                                      &mode,",
          "146:                                      NULL,",
          "147:                                      NULL,",
          "148:                                      NULL,",
          "149:                                      NULL,",
          "150:                                      0);",
          "151:     assert(r == TRUE);",
          "152:     assert(mode == (PIPE_READMODE_BYTE | PIPE_WAIT));",
          "153:   }",
          "154: #endif",
          "158:   if (!ConnectNamedPipe(server_pipe->handle, NULL)) {",
          "159:     if (GetLastError() != ERROR_PIPE_CONNECTED) {",
          "160:       uv__set_sys_error(loop, GetLastError());",
          "161:       goto error;",
          "162:     }",
          "163:   }",
          "166:   return 0;",
          "168:  error:",
          "169:   if (server_pipe->handle != INVALID_HANDLE_VALUE) {",
          "170:     uv_pipe_cleanup(loop, server_pipe);",
          "171:   }",
          "173:   if (child_pipe != INVALID_HANDLE_VALUE) {",
          "174:     CloseHandle(child_pipe);",
          "175:   }",
          "177:   return -1;",
          "178: }",
          "181: static int uv__duplicate_handle(uv_loop_t* loop, HANDLE handle, HANDLE* dup) {",
          "182:   HANDLE current_process;",
          "184:   current_process = GetCurrentProcess();",
          "186:   if (!DuplicateHandle(current_process,",
          "187:                        handle,",
          "188:                        current_process,",
          "189:                        dup,",
          "190:                        0,",
          "191:                        TRUE,",
          "192:                        DUPLICATE_SAME_ACCESS)) {",
          "194:     uv__set_sys_error(loop, GetLastError());",
          "195:     return -1;",
          "196:   }",
          "198:   return 0;",
          "199: }",
          "202: static int uv__duplicate_fd(uv_loop_t* loop, int fd, HANDLE* dup) {",
          "203:   HANDLE handle;",
          "205:   if (fd == -1) {",
          "207:     uv__set_artificial_error(loop, UV_EBADF);",
          "208:     return -1;",
          "209:   }",
          "211:   handle = (HANDLE)_get_osfhandle(fd);",
          "212:   return uv__duplicate_handle(loop, handle, dup);",
          "213: }",
          "216: static int uv__create_nul_handle(uv_loop_t* loop, HANDLE* handle_ptr,",
          "217:     DWORD access) {",
          "218:   HANDLE handle;",
          "219:   SECURITY_ATTRIBUTES sa;",
          "221:   sa.nLength = sizeof sa;",
          "222:   sa.lpSecurityDescriptor = NULL;",
          "223:   sa.bInheritHandle = TRUE;",
          "225:   handle = CreateFileW(L\"NUL\",",
          "226:                        access,",
          "227:                        FILE_SHARE_READ | FILE_SHARE_WRITE,",
          "228:                        &sa,",
          "229:                        OPEN_EXISTING,",
          "230:                        0,",
          "231:                        NULL);",
          "232:   if (handle == INVALID_HANDLE_VALUE) {",
          "233:     uv__set_sys_error(loop, GetLastError());",
          "234:     return -1;",
          "235:   }",
          "238:   return 0;",
          "239: }",
          "242: int uv__stdio_create(uv_loop_t* loop, uv_process_options_t* options,",
          "243:     BYTE** buffer_ptr) {",
          "244:   BYTE* buffer;",
          "245:   int count, i;",
          "247:   count = options->stdio_count;",
          "249:   if (count < 0 || count > 255) {",
          "251:     uv__set_artificial_error(loop, UV_ENOTSUP);",
          "252:     return -1;",
          "253:   } else if (count < 3) {",
          "255:     count = 3;",
          "256:   }",
          "259:   buffer = malloc(CHILD_STDIO_SIZE(count));",
          "260:   if (buffer == NULL) {",
          "261:     uv__set_artificial_error(loop, UV_ENOMEM);",
          "262:     return -1;",
          "263:   }",
          "267:   CHILD_STDIO_COUNT(buffer) = count;",
          "268:   for (i = 0; i < count; i++) {",
          "269:     CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;",
          "270:     CHILD_STDIO_HANDLE(buffer, i) = INVALID_HANDLE_VALUE;",
          "271:   }",
          "273:   for (i = 0; i < count; i++) {",
          "274:     uv_stdio_container_t fdopt;",
          "275:     if (i < options->stdio_count) {",
          "276:       fdopt = options->stdio[i];",
          "277:     } else {",
          "278:       fdopt.flags = UV_IGNORE;",
          "279:     }",
          "281:     switch (fdopt.flags & (UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD |",
          "282:             UV_INHERIT_STREAM)) {",
          "283:       case UV_IGNORE:",
          "290:         if (i <= 2) {",
          "291:           DWORD access = (i == 0) ? FILE_GENERIC_READ :",
          "292:                                     FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES;",
          "293:           if (uv__create_nul_handle(loop,",
          "294:                                 &CHILD_STDIO_HANDLE(buffer, i),",
          "295:                                 access) < 0) {",
          "296:             goto error;",
          "297:           }",
          "298:           CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;",
          "299:         }",
          "300:         break;",
          "302:       case UV_CREATE_PIPE: {",
          "306:         uv_pipe_t* parent_pipe = (uv_pipe_t*) fdopt.data.stream;",
          "307:         HANDLE child_pipe;",
          "311:         assert(fdopt.data.stream->type == UV_NAMED_PIPE);",
          "312:         assert(!(fdopt.data.stream->flags & UV_HANDLE_CONNECTION));",
          "313:         assert(!(fdopt.data.stream->flags & UV_HANDLE_PIPESERVER));",
          "315:         if (uv__create_stdio_pipe_pair(loop,",
          "316:                                       parent_pipe,",
          "317:                                       &child_pipe,",
          "318:                                       fdopt.flags) < 0) {",
          "319:           goto error;",
          "320:         }",
          "322:         CHILD_STDIO_HANDLE(buffer, i) = child_pipe;",
          "323:         CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FPIPE;",
          "324:         break;",
          "325:       }",
          "327:       case UV_INHERIT_FD: {",
          "329:         HANDLE child_handle;",
          "332:         if (uv__duplicate_fd(loop, fdopt.data.fd, &child_handle) < 0) {",
          "333:           goto error;",
          "334:         }",
          "337:         switch (GetFileType(child_handle)) {",
          "338:           case FILE_TYPE_DISK:",
          "339:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN;",
          "340:             break;",
          "342:           case FILE_TYPE_PIPE:",
          "343:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FPIPE;",
          "345:           case FILE_TYPE_CHAR:",
          "346:           case FILE_TYPE_REMOTE:",
          "347:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;",
          "348:             break;",
          "350:           case FILE_TYPE_UNKNOWN:",
          "351:             if (GetLastError != 0) {",
          "352:               uv__set_sys_error(loop, GetLastError());",
          "353:               CloseHandle(child_handle);",
          "354:               goto error;",
          "355:             }",
          "356:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;",
          "357:             break;",
          "359:           default:",
          "360:             assert(0);",
          "361:         }",
          "363:         CHILD_STDIO_HANDLE(buffer, i) = child_handle;",
          "364:         break;",
          "365:       }",
          "367:       case UV_INHERIT_STREAM: {",
          "369:         HANDLE stream_handle, child_handle;",
          "370:         unsigned char crt_flags;",
          "371:         uv_stream_t* stream = fdopt.data.stream;",
          "374:         if (stream->type == UV_TTY) {",
          "375:           stream_handle = ((uv_tty_t*) stream)->handle;",
          "376:           crt_flags = FOPEN | FDEV;",
          "377:         } else if (stream->type == UV_NAMED_PIPE &&",
          "378:                    stream->flags & UV_HANDLE_CONNECTED) {",
          "379:           stream_handle = ((uv_pipe_t*) stream)->handle;",
          "380:           crt_flags = FOPEN | FPIPE;",
          "381:         } else {",
          "382:           stream_handle = INVALID_HANDLE_VALUE;",
          "383:           crt_flags = 0;",
          "384:         }",
          "386:         if (stream_handle == NULL ||",
          "387:             stream_handle == INVALID_HANDLE_VALUE) {",
          "390:           uv__set_artificial_error(loop, UV_ENOTSUP);",
          "391:           goto error;",
          "392:         }",
          "395:         if (uv__duplicate_handle(loop,",
          "396:                              stream_handle,",
          "397:                              &child_handle) < 0) {",
          "398:           goto error;",
          "399:         }",
          "401:         CHILD_STDIO_HANDLE(buffer, i) = child_handle;",
          "402:         CHILD_STDIO_CRT_FLAGS(buffer, i) = crt_flags;",
          "403:         break;",
          "404:       }",
          "406:       default:",
          "407:         assert(0);",
          "408:     }",
          "409:   }",
          "412:   return 0;",
          "414:  error:",
          "415:   uv__stdio_destroy(buffer);",
          "416:   return -1;",
          "417: }",
          "420: void uv__stdio_destroy(BYTE* buffer) {",
          "421:   int i, count;",
          "423:   count = CHILD_STDIO_COUNT(buffer);",
          "424:   for (i = 0; i < count; i++) {",
          "425:     HANDLE handle = CHILD_STDIO_HANDLE(buffer, i);",
          "426:     if (handle != INVALID_HANDLE_VALUE) {",
          "427:       CloseHandle(handle);",
          "428:     }",
          "429:   }",
          "431:   free(buffer);",
          "432: }",
          "435: void uv__stdio_noinherit(BYTE* buffer) {",
          "436:   int i, count;",
          "438:   count = CHILD_STDIO_COUNT(buffer);",
          "439:   for (i = 0; i < count; i++) {",
          "440:     HANDLE handle = CHILD_STDIO_HANDLE(buffer, i);",
          "441:     if (handle != INVALID_HANDLE_VALUE) {",
          "442:       SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);",
          "443:     }",
          "444:   }",
          "445: }",
          "448: int uv__stdio_verify(BYTE* buffer, WORD size) {",
          "449:   unsigned int count;",
          "452:   if (buffer == NULL)",
          "453:     return 0;",
          "456:   if (size < CHILD_STDIO_SIZE(0))",
          "457:     return 0;",
          "460:   count = CHILD_STDIO_COUNT(buffer);",
          "461:   if (count > 256)",
          "462:     return 0;",
          "465:   if (size < CHILD_STDIO_SIZE(count))",
          "466:     return 0;",
          "468:   return 1;",
          "469: }",
          "472: WORD uv__stdio_size(BYTE* buffer) {",
          "473:   return (WORD) CHILD_STDIO_SIZE(CHILD_STDIO_COUNT((buffer)));",
          "474: }",
          "477: HANDLE uv__stdio_handle(BYTE* buffer, int fd) {",
          "478:   return CHILD_STDIO_HANDLE(buffer, fd);",
          "479: }",
          "",
          "---------------"
        ],
        "deps/uv/src/win/process.c||deps/uv/src/win/process.c": [
          "File: deps/uv/src/win/process.c -> deps/uv/src/win/process.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: #define SIGKILL         9",
          "48: typedef struct env_var {",
          "49:   const char* narrow;",
          "50:   const wchar_t* wide;",
          "",
          "[Removed Lines]",
          "38: #define FOPEN       0x01",
          "39: #define FEOFLAG     0x02",
          "40: #define FCRLF       0x04",
          "41: #define FPIPE       0x08",
          "42: #define FNOINHERIT  0x10",
          "43: #define FAPPEND     0x20",
          "44: #define FDEV        0x40",
          "45: #define FTEXT       0x80",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "69:   }",
          "103: static void uv_process_init(uv_loop_t* loop, uv_process_t* handle) {",
          "104:   uv__handle_init(loop, (uv_handle_t*) handle, UV_PROCESS);",
          "105:   handle->exit_cb = NULL;",
          "",
          "[Removed Lines]",
          "78: #define CHILD_STDIO_SIZE(count)                     \\",
          "79:     (sizeof(int) +                                  \\",
          "80:      sizeof(unsigned char) * (count) +              \\",
          "81:      sizeof(uintptr_t) * (count))",
          "83: #define CHILD_STDIO_COUNT(buffer)                   \\",
          "86: #define CHILD_STDIO_LPRESERVED2(buffer)             \\",
          "87:     ((LPBYTE) (buffer))",
          "89: #define CHILD_STDIO_CBRESERVED2(buffer)             \\",
          "90:     ((WORD) CHILD_STDIO_SIZE(CHILD_STDIO_COUNT((buffer))))",
          "92: #define CHILD_STDIO_CRT_FLAGS(buffer, fd)           \\",
          "95: #define CHILD_STDIO_HANDLE(buffer, fd)              \\",
          "97:                  sizeof(int) +                      \\",
          "98:                  sizeof(unsigned char) *            \\",
          "99:                  CHILD_STDIO_COUNT((buffer)) +      \\",
          "100:                  sizeof(HANDLE) * (fd)))",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "637: }",
          "",
          "[Removed Lines]",
          "640: static int uv_create_stdio_pipe_pair(uv_loop_t* loop, uv_pipe_t* server_pipe,",
          "641:     HANDLE* child_pipe_ptr, unsigned int flags) {",
          "642:   char pipe_name[64];",
          "643:   SECURITY_ATTRIBUTES sa;",
          "644:   DWORD server_access = 0;",
          "645:   DWORD client_access = 0;",
          "646:   HANDLE child_pipe = INVALID_HANDLE_VALUE;",
          "648:   if (flags & UV_READABLE_PIPE) {",
          "649:     server_access |= PIPE_ACCESS_OUTBOUND;",
          "650:     client_access |= GENERIC_READ | FILE_WRITE_ATTRIBUTES;",
          "651:   }",
          "652:   if (flags & UV_WRITABLE_PIPE) {",
          "653:     server_access |= PIPE_ACCESS_INBOUND;",
          "654:     client_access |= GENERIC_WRITE;",
          "655:   }",
          "658:   if (uv_stdio_pipe_server(loop,",
          "659:                            server_pipe,",
          "660:                            server_access,",
          "661:                            pipe_name,",
          "662:                            sizeof(pipe_name)) < 0) {",
          "663:     goto error;",
          "664:   }",
          "667:   sa.nLength = sizeof sa;",
          "668:   sa.lpSecurityDescriptor = NULL;",
          "669:   sa.bInheritHandle = TRUE;",
          "671:   child_pipe = CreateFileA(pipe_name,",
          "672:                            client_access,",
          "673:                            0,",
          "674:                            &sa,",
          "675:                            OPEN_EXISTING,",
          "676:                            server_pipe->ipc ? FILE_FLAG_OVERLAPPED : 0,",
          "677:                            NULL);",
          "678:   if (child_pipe == INVALID_HANDLE_VALUE) {",
          "679:     uv__set_sys_error(loop, GetLastError());",
          "680:     goto error;",
          "681:   }",
          "683: #ifndef NDEBUG",
          "685:   {",
          "686:     DWORD mode;",
          "687:     BOOL r = GetNamedPipeHandleState(child_pipe,",
          "688:                                      &mode,",
          "689:                                      NULL,",
          "690:                                      NULL,",
          "691:                                      NULL,",
          "692:                                      NULL,",
          "693:                                      0);",
          "694:     assert(r == TRUE);",
          "695:     assert(mode == (PIPE_READMODE_BYTE | PIPE_WAIT));",
          "696:   }",
          "697: #endif",
          "701:   if (!ConnectNamedPipe(server_pipe->handle, NULL)) {",
          "702:     if (GetLastError() != ERROR_PIPE_CONNECTED) {",
          "703:       uv__set_sys_error(loop, GetLastError());",
          "704:       goto error;",
          "705:     }",
          "706:   }",
          "709:   return 0;",
          "711:  error:",
          "712:   if (server_pipe->handle != INVALID_HANDLE_VALUE) {",
          "713:     uv_pipe_cleanup(loop, server_pipe);",
          "714:   }",
          "716:   if (child_pipe != INVALID_HANDLE_VALUE) {",
          "717:     CloseHandle(child_pipe);",
          "718:   }",
          "720:   return -1;",
          "721: }",
          "724: static int duplicate_handle(uv_loop_t* loop, HANDLE handle, HANDLE* dup) {",
          "725:   HANDLE current_process;",
          "727:   current_process = GetCurrentProcess();",
          "729:   if (!DuplicateHandle(current_process,",
          "730:                        handle,",
          "731:                        current_process,",
          "732:                        dup,",
          "733:                        0,",
          "734:                        TRUE,",
          "735:                        DUPLICATE_SAME_ACCESS)) {",
          "737:     uv__set_sys_error(loop, GetLastError());",
          "738:     return -1;",
          "739:   }",
          "741:   return 0;",
          "742: }",
          "745: static int duplicate_fd(uv_loop_t* loop, int fd, HANDLE* dup) {",
          "746:   HANDLE handle;",
          "748:   if (fd == -1) {",
          "750:     uv__set_artificial_error(loop, UV_EBADF);",
          "751:     return -1;",
          "752:   }",
          "754:   handle = (HANDLE)_get_osfhandle(fd);",
          "755:   return duplicate_handle(loop, handle, dup);",
          "756: }",
          "759: static int create_nul_handle(uv_loop_t* loop, HANDLE* handle_ptr,",
          "760:     DWORD access) {",
          "761:   HANDLE handle;",
          "762:   SECURITY_ATTRIBUTES sa;",
          "764:   sa.nLength = sizeof sa;",
          "765:   sa.lpSecurityDescriptor = NULL;",
          "766:   sa.bInheritHandle = TRUE;",
          "768:   handle = CreateFileW(L\"NUL\",",
          "769:                        access,",
          "770:                        FILE_SHARE_READ | FILE_SHARE_WRITE,",
          "771:                        &sa,",
          "772:                        OPEN_EXISTING,",
          "773:                        0,",
          "774:                        NULL);",
          "775:   if (handle == INVALID_HANDLE_VALUE) {",
          "776:     uv__set_sys_error(loop, GetLastError());",
          "777:     return -1;",
          "778:   }",
          "781:   return 0;",
          "782: }",
          "785: static void set_child_stdio_noinherit(void* buffer) {",
          "786:   int i, count;",
          "788:   count = CHILD_STDIO_COUNT(buffer);",
          "789:   for (i = 0; i < count; i++) {",
          "790:     HANDLE handle = CHILD_STDIO_HANDLE(buffer, i);",
          "791:     if (handle != INVALID_HANDLE_VALUE) {",
          "792:       SetHandleInformation(handle, HANDLE_FLAG_INHERIT, 0);",
          "793:     }",
          "794:   }",
          "795: }",
          "798: static void close_and_free_child_stdio(void* buffer) {",
          "799:   int i, count;",
          "801:   count = CHILD_STDIO_COUNT(buffer);",
          "802:   for (i = 0; i < count; i++) {",
          "803:     HANDLE handle = CHILD_STDIO_HANDLE(buffer, i);",
          "804:     if (handle != INVALID_HANDLE_VALUE) {",
          "805:       CloseHandle(handle);",
          "806:     }",
          "807:   }",
          "809:   free(buffer);",
          "810: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "852:   char unknown[] = \"unknown error\\n\";",
          "853:   uv_process_t* process = (uv_process_t*) data;",
          "854:   uv_loop_t* loop = process->loop;",
          "856:   char* buf = NULL;",
          "857:   DWORD count, written;",
          "",
          "[Removed Lines]",
          "855:   HANDLE child_stderr = CHILD_STDIO_HANDLE(process->child_stdio_buffer, 2);",
          "",
          "[Added Lines]",
          "640:   HANDLE child_stderr = uv__stdio_handle(process->child_stdio_buffer, 2);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "954:     if (handle->child_stdio_buffer != NULL) {",
          "956:     }",
          "958:     uv__handle_close(handle);",
          "",
          "[Removed Lines]",
          "955:       close_and_free_child_stdio(handle->child_stdio_buffer);",
          "",
          "[Added Lines]",
          "740:       uv__stdio_destroy(handle->child_stdio_buffer);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "960: }",
          "1141: int uv_spawn(uv_loop_t* loop, uv_process_t* process,",
          "1142:     uv_process_options_t options) {",
          "1143:   int size, err = 0, keep_child_stdio_open = 0;",
          "",
          "[Removed Lines]",
          "963: static int init_child_stdio(uv_loop_t* loop, uv_process_options_t* options,",
          "964:     void** buffer_ptr) {",
          "965:   void* buffer;",
          "966:   int count, i;",
          "968:   count = options->stdio_count;",
          "970:   if (count < 0 || count > 255) {",
          "972:     uv__set_artificial_error(loop, UV_ENOTSUP);",
          "973:     return -1;",
          "974:   } else if (count < 3) {",
          "976:     count = 3;",
          "977:   }",
          "980:   buffer = malloc(CHILD_STDIO_SIZE(count));",
          "981:   if (buffer == NULL) {",
          "982:     uv__set_artificial_error(loop, UV_ENOMEM);",
          "983:     return -1;",
          "984:   }",
          "988:   CHILD_STDIO_COUNT(buffer) = count;",
          "989:   for (i = 0; i < count; i++) {",
          "990:     CHILD_STDIO_CRT_FLAGS(buffer, i) = 0;",
          "991:     CHILD_STDIO_HANDLE(buffer, i) = INVALID_HANDLE_VALUE;",
          "992:   }",
          "994:   for (i = 0; i < count; i++) {",
          "995:     uv_stdio_container_t fdopt;",
          "996:     if (i < options->stdio_count) {",
          "997:       fdopt = options->stdio[i];",
          "998:     } else {",
          "999:       fdopt.flags = UV_IGNORE;",
          "1000:     }",
          "1002:     switch (fdopt.flags & (UV_IGNORE | UV_CREATE_PIPE | UV_INHERIT_FD |",
          "1003:             UV_INHERIT_STREAM)) {",
          "1004:       case UV_IGNORE:",
          "1011:         if (i <= 2) {",
          "1012:           DWORD access = (i == 0) ? FILE_GENERIC_READ :",
          "1013:                                     FILE_GENERIC_WRITE | FILE_READ_ATTRIBUTES;",
          "1014:           if (create_nul_handle(loop,",
          "1015:                                 &CHILD_STDIO_HANDLE(buffer, i),",
          "1016:                                 access) < 0) {",
          "1017:             goto error;",
          "1018:           }",
          "1019:           CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;",
          "1020:         }",
          "1021:         break;",
          "1023:       case UV_CREATE_PIPE: {",
          "1027:         uv_pipe_t* parent_pipe = (uv_pipe_t*) fdopt.data.stream;",
          "1028:         HANDLE child_pipe;",
          "1032:         assert(fdopt.data.stream->type == UV_NAMED_PIPE);",
          "1033:         assert(!(fdopt.data.stream->flags & UV_HANDLE_CONNECTION));",
          "1034:         assert(!(fdopt.data.stream->flags & UV_HANDLE_PIPESERVER));",
          "1036:         if (uv_create_stdio_pipe_pair(loop,",
          "1037:                                       parent_pipe,",
          "1038:                                       &child_pipe,",
          "1039:                                       fdopt.flags) < 0) {",
          "1040:           goto error;",
          "1041:         }",
          "1043:         CHILD_STDIO_HANDLE(buffer, i) = child_pipe;",
          "1044:         CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FPIPE;",
          "1045:         break;",
          "1046:       }",
          "1048:       case UV_INHERIT_FD: {",
          "1050:         HANDLE child_handle;",
          "1053:         if (duplicate_fd(loop, fdopt.data.fd, &child_handle) < 0) {",
          "1054:           goto error;",
          "1055:         }",
          "1058:         switch (GetFileType(child_handle)) {",
          "1059:           case FILE_TYPE_DISK:",
          "1060:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN;",
          "1061:             break;",
          "1063:           case FILE_TYPE_PIPE:",
          "1064:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FPIPE;",
          "1066:           case FILE_TYPE_CHAR:",
          "1067:           case FILE_TYPE_REMOTE:",
          "1068:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;",
          "1069:             break;",
          "1071:           case FILE_TYPE_UNKNOWN:",
          "1072:             if (GetLastError != 0) {",
          "1073:               uv__set_sys_error(loop, GetLastError());",
          "1074:               CloseHandle(child_handle);",
          "1075:               goto error;",
          "1076:             }",
          "1077:             CHILD_STDIO_CRT_FLAGS(buffer, i) = FOPEN | FDEV;",
          "1078:             break;",
          "1080:           default:",
          "1081:             assert(0);",
          "1082:         }",
          "1084:         CHILD_STDIO_HANDLE(buffer, i) = child_handle;",
          "1085:         break;",
          "1086:       }",
          "1088:       case UV_INHERIT_STREAM: {",
          "1090:         HANDLE stream_handle, child_handle;",
          "1091:         unsigned char crt_flags;",
          "1092:         uv_stream_t* stream = fdopt.data.stream;",
          "1095:         if (stream->type == UV_TTY) {",
          "1096:           stream_handle = ((uv_tty_t*) stream)->handle;",
          "1097:           crt_flags = FOPEN | FDEV;",
          "1098:         } else if (stream->type == UV_NAMED_PIPE &&",
          "1099:                    stream->flags & UV_HANDLE_CONNECTED) {",
          "1100:           stream_handle = ((uv_pipe_t*) stream)->handle;",
          "1101:           crt_flags = FOPEN | FPIPE;",
          "1102:         } else {",
          "1103:           stream_handle = INVALID_HANDLE_VALUE;",
          "1104:           crt_flags = 0;",
          "1105:         }",
          "1107:         if (stream_handle == NULL ||",
          "1108:             stream_handle == INVALID_HANDLE_VALUE) {",
          "1111:           uv__set_artificial_error(loop, UV_ENOTSUP);",
          "1112:           goto error;",
          "1113:         }",
          "1116:         if (duplicate_handle(loop,",
          "1117:                              stream_handle,",
          "1118:                              &child_handle) < 0) {",
          "1119:           goto error;",
          "1120:         }",
          "1122:         CHILD_STDIO_HANDLE(buffer, i) = child_handle;",
          "1123:         CHILD_STDIO_CRT_FLAGS(buffer, i) = crt_flags;",
          "1124:         break;",
          "1125:       }",
          "1127:       default:",
          "1128:         assert(0);",
          "1129:     }",
          "1130:   }",
          "1133:   return 0;",
          "1135:  error:",
          "1136:   close_and_free_child_stdio(buffer);",
          "1137:   return -1;",
          "1138: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1208:   }",
          "1212:      err = -1;",
          "1213:      goto done;",
          "1214:   }",
          "",
          "[Removed Lines]",
          "1211:   if (init_child_stdio(loop, &options, &process->child_stdio_buffer) < 0) {",
          "",
          "[Added Lines]",
          "818:   if (uv__stdio_create(loop, &options, &process->child_stdio_buffer) < 0) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1218:   startup.lpDesktop = NULL;",
          "1219:   startup.lpTitle = NULL;",
          "1220:   startup.dwFlags = STARTF_USESTDHANDLES;",
          "1227:   process_flags = CREATE_UNICODE_ENVIRONMENT;",
          "1228:   if (options.flags & UV_PROCESS_DETACHED) {",
          "",
          "[Removed Lines]",
          "1221:   startup.cbReserved2 = CHILD_STDIO_CBRESERVED2(process->child_stdio_buffer);",
          "1222:   startup.lpReserved2 = CHILD_STDIO_LPRESERVED2(process->child_stdio_buffer);",
          "1223:   startup.hStdInput = CHILD_STDIO_HANDLE(process->child_stdio_buffer, 0);",
          "1224:   startup.hStdOutput = CHILD_STDIO_HANDLE(process->child_stdio_buffer, 1);",
          "1225:   startup.hStdError = CHILD_STDIO_HANDLE(process->child_stdio_buffer, 2);",
          "",
          "[Added Lines]",
          "828:   startup.cbReserved2 = uv__stdio_size(process->child_stdio_buffer);",
          "829:   startup.lpReserved2 = (BYTE*) process->child_stdio_buffer;",
          "830:   startup.hStdInput = uv__stdio_handle(process->child_stdio_buffer, 0);",
          "831:   startup.hStdOutput = uv__stdio_handle(process->child_stdio_buffer, 1);",
          "832:   startup.hStdError = uv__stdio_handle(process->child_stdio_buffer, 2);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1289:   if (process->child_stdio_buffer == NULL) {",
          "1291:   } else if (!keep_child_stdio_open) {",
          "1293:     process->child_stdio_buffer = NULL;",
          "1294:   } else {",
          "1298:   }",
          "1300:   if (err == 0) {",
          "",
          "[Removed Lines]",
          "1292:     close_and_free_child_stdio(process->child_stdio_buffer);",
          "1297:     set_child_stdio_noinherit(process->child_stdio_buffer);",
          "",
          "[Added Lines]",
          "899:     uv__stdio_destroy(process->child_stdio_buffer);",
          "904:     uv__stdio_noinherit(process->child_stdio_buffer);",
          "",
          "---------------"
        ],
        "deps/uv/uv.gyp||deps/uv/uv.gyp": [
          "File: deps/uv/uv.gyp -> deps/uv/uv.gyp",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:             'src/win/thread.c',",
          "150:             'src/win/poll.c',",
          "151:             'src/win/process.c',",
          "152:             'src/win/req.c',",
          "153:             'src/win/req-inl.h',",
          "154:             'src/win/stream.c',",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "152:             'src/win/process-stdio.c',",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "868ffed77c5745a13627d4e083929d014d07c1a6",
      "candidate_info": {
        "commit_hash": "868ffed77c5745a13627d4e083929d014d07c1a6",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/868ffed77c5745a13627d4e083929d014d07c1a6",
        "files": [
          "deps/v8/build/common.gypi"
        ],
        "message": "v8: Reapply floating patches",
        "before_after_code_files": [
          "deps/v8/build/common.gypi||deps/v8/build/common.gypi"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "deps/v8/build/common.gypi||deps/v8/build/common.gypi": [
          "File: deps/v8/build/common.gypi -> deps/v8/build/common.gypi",
          "--- Hunk 1 ---",
          "[Context before]",
          "239:           'WIN32',",
          "240:         ],",
          "241:         'msvs_configuration_attributes': {",
          "243:           'IntermediateDirectory': '$(OutDir)\\\\obj\\\\$(ProjectName)',",
          "244:           'CharacterSet': '1',",
          "245:         },",
          "",
          "[Removed Lines]",
          "242:           'OutputDirectory': '<(DEPTH)\\\\build\\\\$(ConfigurationName)',",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "271:         'target_conditions': [",
          "272:           ['_toolset==\"host\"', {",
          "273:             'variables': {",
          "275:             },",
          "276:             'cflags': [ '<(m32flag)' ],",
          "277:             'ldflags': [ '<(m32flag)' ],",
          "",
          "[Removed Lines]",
          "274:               'm32flag': '<!((echo | $(echo ${CXX_host:-$(which g++)}) -m32 -E - > /dev/null 2>&1) && echo -n \"-m32\" || true)',",
          "",
          "[Added Lines]",
          "273:               'm32flag': '<!((echo | $(echo ${CXX_host:-$(which g++)}) -m32 -E - > /dev/null 2>&1) && echo \"-m32\" || true)',",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "281:           }],",
          "282:           ['_toolset==\"target\"', {",
          "283:             'variables': {",
          "285:             },",
          "286:             'cflags': [ '<(m32flag)' ],",
          "287:             'ldflags': [ '<(m32flag)' ],",
          "",
          "[Removed Lines]",
          "284:               'm32flag': '<!((echo | $(echo ${CXX_target:-${CXX:-$(which g++)}}) -m32 -E - > /dev/null 2>&1) && echo -n \"-m32\" || true)',",
          "",
          "[Added Lines]",
          "283:               'm32flag': '<!((echo | $(echo ${CXX_target:-${CXX:-$(which g++)}}) -m32 -E - > /dev/null 2>&1) && echo \"-m32\" || true)',",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "324:         },",
          "325:         'conditions': [",
          "326:           ['OS==\"linux\" or OS==\"freebsd\" or OS==\"openbsd\" or OS==\"netbsd\"', {",
          "328:                         '-Wnon-virtual-dtor', '-Woverloaded-virtual' ],",
          "329:           }],",
          "330:         ],",
          "",
          "[Removed Lines]",
          "327:             'cflags': [ '-Wall', '<(werror)', '-W', '-Wno-unused-parameter',",
          "",
          "[Added Lines]",
          "326:             'cflags': [ '-Wno-unused-parameter',",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "333:         'conditions': [",
          "334:           ['OS==\"linux\" or OS==\"freebsd\" or OS==\"openbsd\" or OS==\"netbsd\" \\",
          "335:             or OS==\"android\"', {",
          "340:             'cflags': [",
          "341:               '-fdata-sections',",
          "342:               '-ffunction-sections',",
          "",
          "[Removed Lines]",
          "336:             'cflags!': [",
          "337:               '-O2',",
          "338:               '-Os',",
          "339:             ],",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8988af58f4126783eabaacfcaf6d158cf92b8d99",
      "candidate_info": {
        "commit_hash": "8988af58f4126783eabaacfcaf6d158cf92b8d99",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/8988af58f4126783eabaacfcaf6d158cf92b8d99",
        "files": [
          "src/ev-emul.h",
          "src/node.h",
          "src/node_internals.h"
        ],
        "message": "Externalize node::no_deprecation",
        "before_after_code_files": [
          "src/ev-emul.h||src/ev-emul.h",
          "src/node.h||src/node.h",
          "src/node_internals.h||src/node_internals.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/ev-emul.h||src/ev-emul.h": [
          "File: src/ev-emul.h -> src/ev-emul.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "89: #define __uv_warn_of(old_, new_)                                              \\",
          "90:   do {                                                                        \\",
          "92:     __uv_warn_##old_ = 1;                                                     \\",
          "93:     fputs(\"WARNING: \" #old_ \" is deprecated, use \" #new_ \"\\n\", stderr);       \\",
          "94:   }                                                                           \\",
          "",
          "[Removed Lines]",
          "91:     if (__uv_warn_##old_ || no_deprecation) break;                            \\",
          "",
          "[Added Lines]",
          "91:     if (__uv_warn_##old_ || node::no_deprecation) break;                      \\",
          "",
          "---------------"
        ],
        "src/node.h||src/node.h": [
          "File: src/node.h -> src/node.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "86: namespace node {",
          "88: NODE_EXTERN int Start(int argc, char *argv[]);",
          "90: char** Init(int argc, char *argv[]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "88: NODE_EXTERN extern bool no_deprecation;",
          "",
          "---------------"
        ],
        "src/node_internals.h||src/node_internals.h": [
          "File: src/node_internals.h -> src/node_internals.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: namespace node {",
          "33: #ifdef _WIN32",
          "",
          "[Removed Lines]",
          "31: extern bool no_deprecation;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "238e12af221cfefdfa560ac0e6e80b1d266f2870",
      "candidate_info": {
        "commit_hash": "238e12af221cfefdfa560ac0e6e80b1d266f2870",
        "repo": "joyent/node",
        "commit_url": "https://github.com/joyent/node/commit/238e12af221cfefdfa560ac0e6e80b1d266f2870",
        "files": [
          "lib/tty.js"
        ],
        "message": "tty: show deprecated warn of tty.setRawMode()",
        "before_after_code_files": [
          "lib/tty.js||litty.js"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/roamm/node/pull/1",
          "https://github.com/kingzone/node/pull/1",
          "https://github.com/OpenFPGAduino/node/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "lib/tty.js||litty.js": [
          "File: lib/tty.js -> litty.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "37:   }",
          "38:   process.stdin.setRawMode(flag);",
          "39: };",
          "42: function ReadStream(fd) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
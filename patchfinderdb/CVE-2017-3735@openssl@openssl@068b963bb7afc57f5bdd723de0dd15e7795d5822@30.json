{
  "cve_id": "CVE-2017-3735",
  "cve_desc": "While parsing an IPAddressFamily extension in an X.509 certificate, it is possible to do a one-byte overread. This would result in an incorrect text display of the certificate. This bug has been present since 2006 and is present in all versions of OpenSSL before 1.0.2m and 1.1.0g.",
  "repo": "openssl/openssl",
  "patch_hash": "068b963bb7afc57f5bdd723de0dd15e7795d5822",
  "patch_info": {
    "commit_hash": "068b963bb7afc57f5bdd723de0dd15e7795d5822",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/068b963bb7afc57f5bdd723de0dd15e7795d5822",
    "files": [
      "crypto/x509v3/v3_addr.c"
    ],
    "message": "Avoid out-of-bounds read\n\nFixes CVE 2017-3735\n\nReviewed-by: Kurt Roeckx <kurt@roeckx.be>\n(Merged from https://github.com/openssl/openssl/pull/4276)\n\n(cherry picked from commit b23171744b01e473ebbfd6edad70c1c3825ffbcd)",
    "before_after_code_files": [
      "crypto/x509v3/v3_addr.c||crypto/x509v3/v3_addr.c"
    ]
  },
  "patch_diff": {
    "crypto/x509v3/v3_addr.c||crypto/x509v3/v3_addr.c": [
      "File: crypto/x509v3/v3_addr.c -> crypto/x509v3/v3_addr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "85: unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)",
      "86: {",
      "91: }",
      "",
      "[Removed Lines]",
      "87:     return ((f != NULL &&",
      "88:              f->addressFamily != NULL && f->addressFamily->data != NULL)",
      "89:             ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))",
      "90:             : 0);",
      "",
      "[Added Lines]",
      "87:     if (f == NULL",
      "88:             || f->addressFamily == NULL",
      "89:             || f->addressFamily->data == NULL",
      "90:             || f->addressFamily->length < 2)",
      "91:         return 0;",
      "92:     return (f->addressFamily->data[0] << 8) | f->addressFamily->data[1];",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "01b30563b97d01477e2ab577a8a268991696c6e1",
      "candidate_info": {
        "commit_hash": "01b30563b97d01477e2ab577a8a268991696c6e1",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/01b30563b97d01477e2ab577a8a268991696c6e1",
        "files": [
          "crypto/asn1/a_strex.c"
        ],
        "message": "Fix strict-warnings build\n\ncrypto/asn1/a_strex.c: Type of width variable in asn1_valid_host\nfunction  needs to be changed from char to signed char to avoid\nbuild error due to '-Werror=type-limits'.\n\nSigned-off-by: Patrick Steuer <psteuer@mail.de>\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nCLA: trivial\n(cherry picked from commit 34657a8da2ead453460d668771984432cc767044)",
        "before_after_code_files": [
          "crypto/asn1/a_strex.c||crypto/asn1/a_strex.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/asn1/a_strex.c||crypto/asn1/a_strex.c": [
          "File: crypto/asn1/a_strex.c -> crypto/asn1/a_strex.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "601:     const unsigned char *hostptr = host->data;",
          "602:     int type = host->type;",
          "603:     int i;",
          "605:     unsigned short chflags = 0, prevchflags;",
          "607:     if (type > 0 && type < 31)",
          "",
          "[Removed Lines]",
          "604:     char width = -1;",
          "",
          "[Added Lines]",
          "604:     signed char width = -1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a892766934c8e1b9de5645c526716efe4b14a133",
      "candidate_info": {
        "commit_hash": "a892766934c8e1b9de5645c526716efe4b14a133",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/a892766934c8e1b9de5645c526716efe4b14a133",
        "files": [
          "ssl/statem/statem_srvr.c"
        ],
        "message": "fix broken implementations of GOST ciphersuites\n\nremoved the unnecessary upper bracket\nadd !SSL_USE_SIGALGS to check for broken implementations of GOST\nclient signature (signature without length field)\n\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3588)",
        "before_after_code_files": [
          "ssl/statem/statem_srvr.c||ssl/statem/statem_srvr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ssl/statem/statem_srvr.c||ssl/statem/statem_srvr.c": [
          "File: ssl/statem/statem_srvr.c -> ssl/statem/statem_srvr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2692:         goto f_err;",
          "2693:     }",
          "2700: #ifndef OPENSSL_NO_GOST",
          "2704:     } else",
          "2705: #endif",
          "2741:     }",
          "2742:     j = EVP_PKEY_size(pkey);",
          "2743:     if (((int)len > j) || ((int)PACKET_remaining(pkt) > j)",
          "2744:         || (PACKET_remaining(pkt) == 0)) {",
          "",
          "[Removed Lines]",
          "2701:     if (PACKET_remaining(pkt) == 64",
          "2702:         && EVP_PKEY_id(pkey) == NID_id_GostR3410_2001) {",
          "2703:         len = 64;",
          "2706:     {",
          "2707:         if (SSL_USE_SIGALGS(s)) {",
          "2708:             int rv;",
          "2710:             if (!PACKET_get_bytes(pkt, &sig, 2)) {",
          "2711:                 al = SSL_AD_DECODE_ERROR;",
          "2712:                 goto f_err;",
          "2713:             }",
          "2714:             rv = tls12_check_peer_sigalg(&md, s, sig, pkey);",
          "2715:             if (rv == -1) {",
          "2716:                 al = SSL_AD_INTERNAL_ERROR;",
          "2717:                 goto f_err;",
          "2718:             } else if (rv == 0) {",
          "2719:                 al = SSL_AD_DECODE_ERROR;",
          "2720:                 goto f_err;",
          "2721:             }",
          "2722: #ifdef SSL_DEBUG",
          "2723:             fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));",
          "2724: #endif",
          "2725:         } else {",
          "2727:             int idx = ssl_cert_type(NULL, pkey);",
          "2728:             if (idx >= 0)",
          "2729:                 md = s->s3->tmp.md[idx];",
          "2730:             if (md == NULL) {",
          "2731:                 al = SSL_AD_INTERNAL_ERROR;",
          "2732:                 goto f_err;",
          "2733:             }",
          "2734:         }",
          "2736:         if (!PACKET_get_net_2(pkt, &len)) {",
          "2737:             SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_LENGTH_MISMATCH);",
          "2738:             al = SSL_AD_DECODE_ERROR;",
          "2739:             goto f_err;",
          "2740:         }",
          "",
          "[Added Lines]",
          "2695:     if (SSL_USE_SIGALGS(s)) {",
          "2696:         int rv;",
          "2698:         if (!PACKET_get_bytes(pkt, &sig, 2)) {",
          "2699:             al = SSL_AD_DECODE_ERROR;",
          "2700:             goto f_err;",
          "2701:         }",
          "2702:         rv = tls12_check_peer_sigalg(&md, s, sig, pkey);",
          "2703:         if (rv == -1) {",
          "2704:             al = SSL_AD_INTERNAL_ERROR;",
          "2705:             goto f_err;",
          "2706:         } else if (rv == 0) {",
          "2707:             al = SSL_AD_DECODE_ERROR;",
          "2708:             goto f_err;",
          "2709:         }",
          "2710: #ifdef SSL_DEBUG",
          "2711:         fprintf(stderr, \"USING TLSv1.2 HASH %s\\n\", EVP_MD_name(md));",
          "2712: #endif",
          "2713:     } else {",
          "2715:         int idx = ssl_cert_type(NULL, pkey);",
          "2716:         if (idx >= 0)",
          "2717:             md = s->s3->tmp.md[idx];",
          "2718:         if (md == NULL) {",
          "2719:             al = SSL_AD_INTERNAL_ERROR;",
          "2720:             goto f_err;",
          "2721:         }",
          "2722:     }",
          "2730:     if (!SSL_USE_SIGALGS(s)",
          "2731:         && ((PACKET_remaining(pkt) == 64",
          "2732:              && (EVP_PKEY_id(pkey) == NID_id_GostR3410_2001",
          "2733:                  || EVP_PKEY_id(pkey) == NID_id_GostR3410_2012_256))",
          "2734:             || (PACKET_remaining(pkt) == 128",
          "2735:                 && EVP_PKEY_id(pkey) == NID_id_GostR3410_2012_512))) {",
          "2736:         len = PACKET_remaining(pkt);",
          "2739:     if (!PACKET_get_net_2(pkt, &len)) {",
          "2740:         SSLerr(SSL_F_TLS_PROCESS_CERT_VERIFY, SSL_R_LENGTH_MISMATCH);",
          "2741:         al = SSL_AD_DECODE_ERROR;",
          "2742:         goto f_err;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3469f386316cb0e520fa513d45e2b1f73a692449",
      "candidate_info": {
        "commit_hash": "3469f386316cb0e520fa513d45e2b1f73a692449",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/3469f386316cb0e520fa513d45e2b1f73a692449",
        "files": [
          "util/perl/TLSProxy/Proxy.pm"
        ],
        "message": "TLSProxy::Proxy: Don't use ReuseAddr on Windows\n\nOn Windows, we sometimes see a behavior with SO_REUSEADDR where there\nremains lingering listening sockets on the same address and port as a\nnewly created one.\n\nAn easy solution is not to use ReuseAddr on Windows.\n\nThanks Bernd Edlinger for the suggestion.\n\nReviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\n(Merged from https://github.com/openssl/openssl/pull/5103)\n\n(cherry picked from commit e02d5886636095c26a8bff1bf8344bd0bba7ccff)",
        "before_after_code_files": [
          "util/perl/TLSProxy/Proxy.pm||util/perl/TLSProxy/Proxy.pm"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "util/perl/TLSProxy/Proxy.pm||util/perl/TLSProxy/Proxy.pm": [
          "File: util/perl/TLSProxy/Proxy.pm -> util/perl/TLSProxy/Proxy.pm",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:     # Create the Proxy socket",
          "179:     my $proxaddr = $self->proxy_addr;",
          "180:     $proxaddr =~ s/[\\[\\]]//g; # Remove [ and ]",
          "182:         LocalHost   => $proxaddr,",
          "183:         LocalPort   => $self->proxy_port,",
          "184:         Proto       => \"tcp\",",
          "185:         Listen      => SOMAXCONN,",
          "189:     if ($proxy_sock) {",
          "190:         print \"Proxy started on port \".$self->proxy_port.\"\\n\";",
          "",
          "[Removed Lines]",
          "181:     my $proxy_sock = $IP_factory->(",
          "186:         ReuseAddr   => 1",
          "187:     );",
          "",
          "[Added Lines]",
          "181:     my @proxyargs = (",
          "186:        );",
          "187:     push @proxyargs, ReuseAddr => 1",
          "188:         unless $^O eq \"MSWin32\";",
          "189:     my $proxy_sock = $IP_factory->(@proxyargs);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "12492580ffd561764111b5efbafde17125b91e92",
      "candidate_info": {
        "commit_hash": "12492580ffd561764111b5efbafde17125b91e92",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/12492580ffd561764111b5efbafde17125b91e92",
        "files": [
          "ssl/record/rec_layer_d1.c",
          "ssl/record/rec_layer_s3.c"
        ],
        "message": "Make sure we check an incoming reneg ClientHello in DTLS\n\nIn TLS we have a check to make sure an incoming reneg ClientHello is\nacceptable. The equivalent check is missing in the DTLS code. This means\nthat if a client does not signal the ability to handle secure reneg in the\ninitial handshake, then a subsequent reneg handshake should be rejected by\nthe server. In the DTLS case the reneg was being allowed if the the 2nd\nClientHello had a renegotiation_info extension. This is incorrect.\n\nWhile incorrect, this does not represent a security issue because if\nthe renegotiation_info extension is present in the second ClientHello it\nalso has to be *correct*. Therefore this will only work if both the client\nand server believe they are renegotiating, and both know the previous\nFinished result. This is not the case in an insecure rengotiation attack.\n\nI have also tidied up the check in the TLS code and given a better check\nfor determining whether we are renegotiating or not.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5191)",
        "before_after_code_files": [
          "ssl/record/rec_layer_d1.c||ssl/record/rec_layer_d1.c",
          "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ssl/record/rec_layer_d1.c||ssl/record/rec_layer_d1.c": [
          "File: ssl/record/rec_layer_d1.c -> ssl/record/rec_layer_d1.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "686:         goto start;",
          "687:     }",
          "689:     if (s->rlayer.d->alert_fragment_len >= DTLS1_AL_HEADER_LENGTH) {",
          "690:         int alert_level = s->rlayer.d->alert_fragment[0];",
          "691:         int alert_descr = s->rlayer.d->alert_fragment[1];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "693:     if (s->server",
          "694:             && SSL_is_init_finished(s)",
          "695:             && !s->s3->send_connection_binding",
          "696:             && s->rlayer.d->handshake_fragment_len >= DTLS1_HM_HEADER_LENGTH",
          "697:             && s->rlayer.d->handshake_fragment[0] == SSL3_MT_CLIENT_HELLO",
          "698:             && s->s3->previous_client_finished_len != 0",
          "699:             && (s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) == 0) {",
          "700:         s->rlayer.d->handshake_fragment_len = 0;",
          "701:         SSL3_RECORD_set_length(rr, 0);",
          "702:         ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);",
          "703:         goto start;",
          "704:     }",
          "",
          "---------------"
        ],
        "ssl/record/rec_layer_s3.c||ssl/record/rec_layer_s3.c": [
          "File: ssl/record/rec_layer_s3.c -> ssl/record/rec_layer_s3.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1330:     }",
          "1344:         SSL3_RECORD_set_length(rr, 0);",
          "1345:         SSL3_RECORD_set_read(rr);",
          "1346:         ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION);",
          "",
          "[Removed Lines]",
          "1336:     if (s->server &&",
          "1337:         SSL_is_init_finished(s) &&",
          "1338:         !s->s3->send_connection_binding &&",
          "1339:         (s->version > SSL3_VERSION) &&",
          "1340:         (s->rlayer.handshake_fragment_len >= 4) &&",
          "1341:         (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) &&",
          "1342:         (s->session != NULL) && (s->session->cipher != NULL) &&",
          "1343:         !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) {",
          "",
          "[Added Lines]",
          "1335:     if (s->server",
          "1336:             && SSL_is_init_finished(s)",
          "1337:             && !s->s3->send_connection_binding",
          "1338:             && s->version > SSL3_VERSION",
          "1339:             && s->rlayer.handshake_fragment_len >= SSL3_HM_HEADER_LENGTH",
          "1340:             && s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO",
          "1341:             && s->s3->previous_client_finished_len != 0",
          "1342:             && (s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) == 0) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fa9dc509cccbe30b48ad7f4f2e23610a182a23c3",
      "candidate_info": {
        "commit_hash": "fa9dc509cccbe30b48ad7f4f2e23610a182a23c3",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/fa9dc509cccbe30b48ad7f4f2e23610a182a23c3",
        "files": [
          "util/perl/TLSProxy/Proxy.pm"
        ],
        "message": "TLSProxy::Proxy:  If we don't support IPv6, force IPv4\n\nWe use the first we can of the following IO::Socket modules to create\nsockets:\n\n- IO::Socket::INET6\n- IO::Socket::IP\n- IO::Socket::INET\n\nThe last of them doesn't support IPv6, so if that's the one available,\nwe must force the s_client and s_server processes to use IPv4.\n\nReviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\n(Merged from https://github.com/openssl/openssl/pull/5092)\n\n(cherry picked from commit c44bab084ed139b5e5c3f6b318bf1bf65e04cfa5)",
        "before_after_code_files": [
          "util/perl/TLSProxy/Proxy.pm||util/perl/TLSProxy/Proxy.pm"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "util/perl/TLSProxy/Proxy.pm||util/perl/TLSProxy/Proxy.pm": [
          "File: util/perl/TLSProxy/Proxy.pm -> util/perl/TLSProxy/Proxy.pm",
          "--- Hunk 1 ---",
          "[Context before]",
          "156:             .\" s_server -no_comp -rev -engine ossltest -accept \"",
          "157:             .($self->server_port)",
          "158:             .\" -cert \".$self->cert.\" -naccept \".$self->serverconnects;",
          "159:         if ($self->ciphers ne \"\") {",
          "160:             $execcmd .= \" -cipher \".$self->ciphers;",
          "161:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159:         unless ($self->supports_IPv6) {",
          "160:             $execcmd .= \" -4\";",
          "161:         }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "217:             my $execcmd = \"echo \".$echostr.\" | \".$self->execute",
          "218:                  .\" s_client -engine ossltest -connect \"",
          "219:                  .($self->proxy_addr).\":\".($self->proxy_port);",
          "220:             if ($self->cipherc ne \"\") {",
          "221:                 $execcmd .= \" -cipher \".$self->cipherc;",
          "222:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "223:             unless ($self->supports_IPv6) {",
          "224:                 $execcmd .= \" -4\";",
          "225:             }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
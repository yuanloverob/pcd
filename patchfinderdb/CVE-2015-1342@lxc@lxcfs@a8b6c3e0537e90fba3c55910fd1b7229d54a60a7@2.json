{
  "cve_id": "CVE-2015-1342",
  "cve_desc": "LXCFS before 0.12 does not properly enforce directory escapes, which might allow local users to gain privileges by (1) querying or (2) updating a cgroup.",
  "repo": "lxc/lxcfs",
  "patch_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
  "patch_info": {
    "commit_hash": "a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "repo": "lxc/lxcfs",
    "commit_url": "https://github.com/lxc/lxcfs/commit/a8b6c3e0537e90fba3c55910fd1b7229d54a60a7",
    "files": [
      "Makefile.am",
      "lxcfs.c",
      "tests/test_confinement.sh",
      "tests/test_syscalls.c"
    ],
    "message": "Fix checking of parent directories\n\nTaken from the justification in the launchpad bug:\n\nTo a task in freezer cgroup /a/b/c/d, it should appear that there are no\ncgroups other than its descendents. Since this is a filesystem, we must have\nthe parent directories, but each parent cgroup should only contain the child\nwhich the task can see.\n\nSo, when this task looks at /a/b, it should see only directory 'c' and no\nfiles. Attempt to create /a/b/x should result in -EPERM, whether /a/b/x already\nexists or not. Attempts to query /a/b/x should result in -ENOENT whether /a/b/x\nexists or not. Opening /a/b/tasks should result in -ENOENT.\n\nThe caller_may_see_dir checks specifically whether a task may see a cgroup\ndirectory - i.e. /a/b/x if opening /a/b/x/tasks, and /a/b/c/d if doing\nopendir('/a/b/c/d').\n\ncaller_is_in_ancestor() will return true if the caller in /a/b/c/d looks at\n/a/b/c/d/e. If the caller is in a child cgroup of the queried one - i.e. if the\ntask in /a/b/c/d queries /a/b, then *nextcg will container the next (the only)\ndirectory which he can see in the path - 'c'.\n\nBeyond this, regular DAC permissions should apply, with the\nroot-in-user-namespace privilege over its mapped uids being respected. The\nfc_may_access check does this check for both directories and files.\n\nThis is CVE-2015-1342 (LP: #1508481)\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
    "before_after_code_files": [
      "Makefile.am||Makefile.am",
      "lxcfs.c||lxcfs.c",
      "tests/test_confinement.sh||tests/test_confinement.sh",
      "tests/test_syscalls.c||tests/test_syscalls.c"
    ]
  },
  "patch_diff": {
    "Makefile.am||Makefile.am": [
      "File: Makefile.am -> Makefile.am",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: TEST_READ: tests/test-read.c",
      "31:  $(CC) -o tests/test-read tests/test-read.c",
      "33: TEST_CPUSET: tests/cpusetrange.c cpuset.c",
      "34:  $(CC) -o tests/cpusetrange tests/cpusetrange.c cpuset.c",
      "38: distclean:",
      "39:  rm -rf .deps/ \\",
      "",
      "[Removed Lines]",
      "36: tests: TEST_READ TEST_CPUSET",
      "",
      "[Added Lines]",
      "34: TEST_SYSCALLS: tests/test_syscalls.c",
      "35:  $(CC) -o tests/test_syscalls tests/test_syscalls.c",
      "37: tests: TEST_READ TEST_CPUSET TEST_SYSCALLS",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "60:   lxcfs.o \\",
      "61:   m4/ \\",
      "62:   missing \\",
      "",
      "[Removed Lines]",
      "63:   stamp-h1",
      "",
      "[Added Lines]",
      "64:   stamp-h1 \\",
      "65:   tests/test_syscalls",
      "",
      "---------------"
    ],
    "lxcfs.c||lxcfs.c": [
      "File: lxcfs.c -> lxcfs.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "379: static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)",
      "380: {",
      "383:  bool answer = false;",
      "392:   return false;",
      "420:   }",
      "421:   answer = true;",
      "422:   goto out;",
      "423:  }",
      "425: out:",
      "428:  return answer;",
      "429: }",
      "",
      "[Removed Lines]",
      "381:  char fnam[PROCLEN];",
      "382:  FILE *f;",
      "384:  char *line = NULL;",
      "385:  size_t len = 0;",
      "386:  int ret;",
      "388:  ret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);",
      "389:  if (ret < 0 || ret >= PROCLEN)",
      "390:   return false;",
      "391:  if (!(f = fopen(fnam, \"r\")))",
      "394:  while (getline(&line, &len, f) != -1) {",
      "395:   char *c1, *c2, *linecmp;",
      "396:   if (!line[0])",
      "397:    continue;",
      "398:   c1 = strchr(line, ':');",
      "399:   if (!c1)",
      "400:    goto out;",
      "401:   c1++;",
      "402:   c2 = strchr(c1, ':');",
      "403:   if (!c2)",
      "404:    goto out;",
      "406:   if (strcmp(c1, contrl) != 0)",
      "407:    continue;",
      "408:   c2++;",
      "409:   stripnewline(c2);",
      "410:   prune_init_slice(c2);",
      "415:   linecmp = *cg == '/' ? c2 : c2+1;",
      "416:   if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "417:    if (nextcg)",
      "419:    goto out;",
      "426:  fclose(f);",
      "427:  free(line);",
      "",
      "[Added Lines]",
      "388:  char *c2 = get_pid_cgroup(pid, contrl);",
      "389:  char *linecmp;",
      "391:  if (!c2)",
      "393:  prune_init_slice(c2);",
      "399:  linecmp = *cg == '/' ? c2 : c2+1;",
      "400:  if (strncmp(linecmp, cg, strlen(linecmp)) != 0) {",
      "401:   if (nextcg) {",
      "404:   goto out;",
      "405:  }",
      "406:  answer = true;",
      "408: out:",
      "409:  free(c2);",
      "410:  return answer;",
      "411: }",
      "416: static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)",
      "417: {",
      "418:  bool answer = false;",
      "419:  char *c2, *task_cg;",
      "420:  size_t target_len, task_len;",
      "422:  if (strcmp(cg, \"/\") == 0)",
      "423:   return true;",
      "425:  c2 = get_pid_cgroup(pid, contrl);",
      "427:  if (!c2)",
      "428:   return false;",
      "430:  task_cg = c2 + 1;",
      "431:  target_len = strlen(cg);",
      "432:  task_len = strlen(task_cg);",
      "433:  if (strcmp(cg, task_cg) == 0) {",
      "437:  if (target_len < task_len) {",
      "439:   if (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')",
      "440:    answer = true;",
      "441:   goto out;",
      "442:  }",
      "443:  if (target_len > task_len) {",
      "445:   if (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')",
      "446:    answer = true;",
      "447:   goto out;",
      "448:  }",
      "451:  free(c2);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "554:  if (is_child_cgroup(controller, path1, path2)) {",
      "555:   if (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {",
      "557:    sb->st_mode = S_IFDIR | 00555;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "579:   if (!caller_may_see_dir(fc->pid, controller, cgroup)) {",
      "580:    ret = -ENOENT;",
      "581:    goto out;",
      "582:   }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "630:   }",
      "631:  }",
      "635:  }",
      "",
      "[Removed Lines]",
      "633:  if (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {",
      "634:   return -EACCES;",
      "",
      "[Added Lines]",
      "661:  if (cgroup) {",
      "662:   if (!caller_may_see_dir(fc->pid, controller, cgroup))",
      "663:    return -ENOENT;",
      "664:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
      "665:    return -EACCES;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "780:  }",
      "781:  free_key(k);",
      "783:  if (!fc_may_access(fc, controller, path1, path2, fi->flags)) {",
      "785:   ret = -EACCES;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "814:  if (!caller_may_see_dir(fc->pid, controller, path1)) {",
      "815:   ret = -ENOENT;",
      "816:   goto out;",
      "817:  }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1563: int cg_mkdir(const char *path, mode_t mode)",
      "1564: {",
      "1565:  struct fuse_context *fc = fuse_get_context();",
      "1567:  const char *cgroup;",
      "1568:  int ret;",
      "",
      "[Removed Lines]",
      "1566:  char *fpath = NULL, *path1, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1601:  char *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1585:  else",
      "1586:   path1 = cgdir;",
      "1588:  if (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {",
      "1589:   ret = -EACCES;",
      "1590:   goto out;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1623:  if (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {",
      "1624:   if (fpath && strcmp(next, fpath) == 0)",
      "1625:    ret = -EEXIST;",
      "1626:   else",
      "1627:    ret = -ENOENT;",
      "1628:   goto out;",
      "1629:  }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1600: out:",
      "1601:  free(cgdir);",
      "1602:  return ret;",
      "1603: }",
      "1605: static int cg_rmdir(const char *path)",
      "1606: {",
      "1607:  struct fuse_context *fc = fuse_get_context();",
      "1609:  const char *cgroup;",
      "1610:  int ret;",
      "",
      "[Removed Lines]",
      "1608:  char *fpath = NULL, *cgdir = NULL, *controller;",
      "",
      "[Added Lines]",
      "1645:  free(next);",
      "1652:  char *fpath = NULL, *cgdir = NULL, *controller, *next = NULL;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1626:   goto out;",
      "1627:  }",
      "1631:  if (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {",
      "1632:   ret = -EACCES;",
      "1633:   goto out;",
      "",
      "[Removed Lines]",
      "1629:  fprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",",
      "1630:    controller, cgdir, path);",
      "",
      "[Added Lines]",
      "1673:  if (!caller_is_in_ancestor(fc->pid, controller, cgroup, &next)) {",
      "1674:   if (!fpath || strcmp(next, fpath) == 0)",
      "1675:    ret = -EBUSY;",
      "1676:   else",
      "1677:    ret = -ENOENT;",
      "1678:   goto out;",
      "1679:  }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1647: out:",
      "1648:  free(cgdir);",
      "1649:  return ret;",
      "1650: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1699:  free(next);",
      "",
      "---------------"
    ],
    "tests/test_confinement.sh||tests/test_confinement.sh": [
      "File: tests/test_confinement.sh -> tests/test_confinement.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #!/bin/bash",
      "3: set -ex",
      "5: [ $(id -u) -eq 0 ]",
      "7: d=$(mktemp -t -d tmp.XXX)",
      "8: d2=$(mktemp -t -d tmp.XXX)",
      "10: pid=-1",
      "11: cleanup() {",
      "12:  [ $pid -ne -1 ] && kill -9 $pid",
      "13:  umount -l $d || true",
      "14:  umount -l $d2 || true",
      "15:  rm -rf $d $d2",
      "16: }",
      "18: cmdline=$(realpath $0)",
      "19: dirname=$(dirname ${cmdline})",
      "20: topdir=$(dirname ${dirname})",
      "22: trap cleanup EXIT HUP INT TERM",
      "24: ${topdir}/lxcfs $d &",
      "25: pid=$!",
      "27: # put ourselves into x1",
      "28: cgm movepidabs freezer / $$",
      "29: cgm create freezer x1",
      "30: cgm movepid freezer x1 $$",
      "32: mount -t cgroup -o freezer freezer $d2",
      "33: sudo rmdir $d2/lxcfs_test_a1/lxcfs_test_a2 || true",
      "34: sudo rmdir $d2/lxcfs_test_a1 || true",
      "36: echo \"Making sure root cannot mkdir\"",
      "37: bad=0",
      "38: mkdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "39: if [ \"${bad}\" -eq 1 ]; then",
      "40:  false",
      "41: fi",
      "43: echo \"Making sure root cannot rmdir\"",
      "44: mkdir $d2/lxcfs_test_a1",
      "45: mkdir $d2/lxcfs_test_a1/lxcfs_test_a2",
      "46: rmdir $d/cgroup/freezer/lxcfs_test_a1 && bad=1",
      "47: if [ \"${bad}\" -eq 1 ]; then",
      "48:  false",
      "49: fi",
      "50: [ -d $d2/lxcfs_test_a1 ]",
      "51: rmdir $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2 && bad=1",
      "52: if [ \"${bad}\" -eq 1 ]; then",
      "53:  false",
      "54: fi",
      "55: [ -d $d2/lxcfs_test_a1/lxcfs_test_a2 ]",
      "57: echo \"Making sure root cannot read/write\"",
      "58: sleep 200 &",
      "59: p=$!",
      "60: echo $p > $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "61: if [ \"${bad}\" -eq 1 ]; then",
      "62:  false",
      "63: fi",
      "64: cat $d/cgroup/freezer/lxcfs_test_a1/tasks && bad=1",
      "65: if [ \"${bad}\" -eq 1 ]; then",
      "66:  false",
      "67: fi",
      "68: echo $p > $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "69: if [ \"${bad}\" -eq 1 ]; then",
      "70:  false",
      "71: fi",
      "72: cat $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2/tasks && bad=1",
      "73: if [ \"${bad}\" -eq 1 ]; then",
      "74:  false",
      "75: fi",
      "77: # make sure things like truncate and access don't leak info about",
      "78: # the /lxcfs_test_a1 cgroup which we shouldn't be able to reach",
      "79: echo \"Testing other system calls\"",
      "80: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1",
      "81: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2",
      "83: echo \"Making sure root can act on descendents\"",
      "84: mycg=$(cgm getpidcgroupabs freezer $$)",
      "85: newcg=${mycg}/lxcfs_test_a1",
      "86: rmdir $d2/$newcg || true  # cleanup previosu run",
      "87: mkdir $d/cgroup/freezer/$newcg",
      "88: echo $p > $d/cgroup/freezer/$newcg/tasks",
      "89: cat $d/cgroup/freezer/$newcg/tasks",
      "90: kill -9 $p",
      "91: while [ `wc -l $d/cgroup/freezer/$newcg/tasks | awk '{ print $1 }'` -ne 0 ]; do",
      "92:  sleep 1",
      "93: done",
      "94: rmdir $d/cgroup/freezer/$newcg",
      "96: echo \"All tests passed!\"",
      "",
      "---------------"
    ],
    "tests/test_syscalls.c||tests/test_syscalls.c": [
      "File: tests/test_syscalls.c -> tests/test_syscalls.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #define _GNU_SOURCE",
      "2: #include <stdio.h>",
      "3: #include <stdlib.h>",
      "4: #include <string.h>",
      "5: #include <unistd.h>",
      "6: #include <sys/types.h>",
      "7: #include <sys/socket.h>",
      "8: #include <linux/un.h>",
      "9: #include <attr/xattr.h>",
      "10: #include <utime.h>",
      "11: #include <sys/stat.h>",
      "12: #include <sys/mount.h>",
      "13: #include <libgen.h>",
      "14: #include <fcntl.h>",
      "15: #include <errno.h>",
      "18: void test_open(const char *path)",
      "19: {",
      "20:  int fd = open(path, O_RDONLY);",
      "21:  if (fd >= 0) {",
      "22:   fprintf(stderr, \"leak at open of %s\\n\", path);",
      "23:   exit(1);",
      "24:  }",
      "25:  if (errno != ENOENT) {",
      "26:   fprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);",
      "27:   exit(1);",
      "28:  }",
      "29: }",
      "31: void test_stat(const char *path)",
      "32: {",
      "33:  struct stat sb;",
      "34:  if (stat(path, &sb) >= 0) {",
      "35:   fprintf(stderr, \"leak at stat of %s\\n\", path);",
      "36:   exit(1);",
      "37:  }",
      "38:  if (errno != ENOENT) {",
      "39:   fprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);",
      "40:   exit(1);",
      "41:  }",
      "42: }",
      "44: void test_access(const char *path)",
      "45: {",
      "46:  if (access(path, O_RDONLY) >= 0) {",
      "47:   fprintf(stderr, \"leak at access of %s\\n\", path);",
      "48:   exit(1);",
      "49:  }",
      "50:  if (errno != ENOENT) {",
      "51:   fprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);",
      "52:   exit(1);",
      "53:  }",
      "54: }",
      "56: void test_bind(const char *path)",
      "57: {",
      "58:  int sfd;",
      "59:  struct sockaddr_un my_addr, peer_addr;",
      "61:  sfd = socket(AF_UNIX, SOCK_STREAM, 0);",
      "63:  if (sfd < 0) {",
      "64:   fprintf(stderr, \"Failed to open a socket for bind test\\n\");",
      "65:   exit(1);",
      "66:  }",
      "67:  memset(&my_addr, 0, sizeof(struct sockaddr_un));",
      "68:  my_addr.sun_family = AF_UNIX;",
      "69:  strncpy(my_addr.sun_path, path,",
      "70:    sizeof(my_addr.sun_path) - 1);",
      "71:  if (bind(sfd, (struct sockaddr *) &my_addr,",
      "72:     sizeof(struct sockaddr_un)) != -1) {",
      "73:   fprintf(stderr, \"leak at bind of %s\\n\", path);",
      "74:   exit(1);",
      "75:  }",
      "76:  if (errno != ENOENT && errno != ENOSYS) {",
      "77:   fprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));",
      "78:   exit(1);",
      "79:  }",
      "80:  close(sfd);",
      "81: }",
      "83: void test_bindmount(const char *path)",
      "84: {",
      "85:  if (mount(path, path, \"none\", MS_BIND, NULL) == 0) {",
      "86:   fprintf(stderr, \"leak at bind mount of %s\\n\", path);",
      "87:   exit(1);",
      "88:  }",
      "89: }",
      "91: void test_truncate(const char *path)",
      "92: {",
      "93:  if (truncate(path, 0) == 0) {",
      "94:   fprintf(stderr, \"leak at truncate of %s\\n\", path);",
      "95:   exit(1);",
      "96:  }",
      "97: }",
      "99: void test_chdir(const char *path)",
      "100: {",
      "101:  if (chdir(path) == 0) {",
      "102:   fprintf(stderr, \"leak at chdir to %s\\n\", path);",
      "103:   exit(1);",
      "104:  }",
      "105: }",
      "107: void test_rename(const char *path)",
      "108: {",
      "109:  char *d = strdupa(path), *tmpname;",
      "110:  d = dirname(d);",
      "111:  size_t len = strlen(path) + 30;",
      "113:  tmpname = alloca(len);",
      "114:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "115:  if (rename(path, tmpname) == 0 || errno != ENOENT) {",
      "116:   fprintf(stderr, \"leak at rename of %s\\n\", path);",
      "117:   exit(1);",
      "118:  }",
      "119: }",
      "121: void test_mkdir(const char *path)",
      "122: {",
      "123:  size_t len = strlen(path) + 30;",
      "124:  char *tmpname = alloca(len);",
      "125:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "127:  if (mkdir(path, 0755) == 0) {",
      "128:   fprintf(stderr, \"leak at mkdir of %s\\n\", path);",
      "129:   exit(1);",
      "130:  }",
      "131:  if (errno != ENOENT) {",
      "132:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "133:   exit(1);",
      "134:  }",
      "135:  if (mkdir(tmpname, 0755) == 0) {",
      "136:   fprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);",
      "137:   exit(1);",
      "138:  }",
      "139:  if (errno != ENOENT) {",
      "140:   fprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));",
      "141:   exit(1);",
      "142:  }",
      "143: }",
      "145: void test_rmdir(const char *path)",
      "146: {",
      "147:  size_t len = strlen(path) + 30;",
      "148:  char *tmpname = alloca(len);",
      "149:  snprintf(tmpname, len, \"%s/%d\", path, (int)getpid());",
      "151:  if (rmdir(path) == 0 || errno != ENOENT) {",
      "152:   fprintf(stderr, \"leak at rmdir of %s\\n\", path);",
      "153:   exit(1);",
      "154:  }",
      "155:  if (rmdir(tmpname) == 0 || errno != ENOENT) {",
      "156:   fprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);",
      "157:   exit(1);",
      "158:  }",
      "159: }",
      "161: void test_creat(const char *path)",
      "162: {",
      "163:  if (creat(path, 0755) >= 0) {",
      "164:   fprintf(stderr, \"leak at creat of %s\\n\", path);",
      "165:   exit(1);",
      "166:  }",
      "167:  if (errno != ENOENT && errno != ENOSYS) {",
      "168:   fprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));",
      "169:   exit(1);",
      "170:  }",
      "171: }",
      "173: void test_link(const char *path)",
      "174: {",
      "175:  char *d = strdupa(path), *tmpname;",
      "176:  d = dirname(d);",
      "177:  size_t len = strlen(path) + 30;",
      "178:  tmpname = alloca(len);",
      "179:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "181:  if (link(path, tmpname) == 0) {",
      "182:   fprintf(stderr, \"leak at link of %s\\n\", path);",
      "183:   exit(1);",
      "184:  }",
      "185:  if (errno != ENOENT && errno != ENOSYS) {",
      "186:   fprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));",
      "187:   exit(1);",
      "188:  }",
      "190:  if (link(tmpname, path) == 0) {",
      "191:   fprintf(stderr, \"leak at link (2) of %s\\n\", path);",
      "192:   exit(1);",
      "193:  }",
      "194:  if (errno != ENOENT && errno != ENOSYS) {",
      "195:   fprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "196:   exit(1);",
      "197:  }",
      "198: }",
      "200: void test_unlink(const char *path)",
      "201: {",
      "202:  if (unlink(path) == 0) {",
      "203:   fprintf(stderr, \"leak at unlink of %s\\n\", path);",
      "204:   exit(1);",
      "205:  }",
      "206:  if (errno != ENOENT && errno != ENOSYS) {",
      "207:   fprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));",
      "208:   exit(1);",
      "209:  }",
      "210: }",
      "212: void test_symlink(const char *path)",
      "213: {",
      "214:  char *d = strdupa(path), *tmpname;",
      "215:  d = dirname(d);",
      "216:  size_t len = strlen(path) + 30;",
      "217:  tmpname = alloca(len);",
      "218:  snprintf(tmpname, len, \"%s/%d\", d, (int)getpid());",
      "220:  if (symlink(tmpname, path) == 0) {",
      "221:   fprintf(stderr, \"leak at symlink of %s\\n\", path);",
      "222:   exit(1);",
      "223:  }",
      "224:  if (errno != ENOENT && errno != ENOSYS) {",
      "225:   fprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));",
      "226:   exit(1);",
      "227:  }",
      "228:  if (symlink(path, tmpname) == 0) {",
      "229:   fprintf(stderr, \"leak at symlink (2) of %s\\n\", path);",
      "230:   exit(1);",
      "231:  }",
      "232:  if (errno != ENOENT && errno != ENOSYS) {",
      "233:   fprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));",
      "234:   exit(1);",
      "235:  }",
      "236: }",
      "238: void test_readlink(const char *path)",
      "239: {",
      "240:  char *dest = alloca(2 * strlen(path));",
      "242:  if (readlink(path, dest, 2 * strlen(path)) >= 0) {",
      "243:   fprintf(stderr, \"leak at readlink of %s\\n\", path);",
      "244:   exit(1);",
      "245:  }",
      "246:  if (errno != ENOENT && errno != ENOSYS) {",
      "247:   fprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));",
      "248:   exit(1);",
      "249:  }",
      "250: }",
      "252: void test_chmod(const char *path)",
      "253: {",
      "254:  if (chmod(path, 0755) == 0) {",
      "255:   fprintf(stderr, \"leak at chmod of %s\\n\", path);",
      "256:   exit(1);",
      "257:  }",
      "258:  if (errno != ENOENT && errno != ENOSYS) {",
      "259:   fprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));",
      "260:   exit(1);",
      "261:  }",
      "262: }",
      "264: void test_chown(const char *path)",
      "265: {",
      "266:  if (chown(path, 0, 0) == 0) {",
      "267:   fprintf(stderr, \"leak at chown of %s\\n\", path);",
      "268:   exit(1);",
      "269:  }",
      "270:  if (errno != ENOENT && errno != ENOSYS) {",
      "271:   fprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));",
      "272:   exit(1);",
      "273:  }",
      "274: }",
      "276: void test_lchown(const char *path)",
      "277: {",
      "278:  if (lchown(path, 0, 0) == 0) {",
      "279:   fprintf(stderr, \"leak at lchown of %s\\n\", path);",
      "280:   exit(1);",
      "281:  }",
      "282:  if (errno != ENOENT && errno != ENOSYS) {",
      "283:   fprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));",
      "284:   exit(1);",
      "285:  }",
      "286: }",
      "288: void test_mknod(const char *path)",
      "289: {",
      "290:  if (mknod(path, 0755, makedev(0, 0)) == 0) {",
      "291:   fprintf(stderr, \"leak at mknod of %s\\n\", path);",
      "292:   exit(1);",
      "293:  }",
      "294:  if (errno != ENOENT && errno != ENOSYS) {",
      "295:   fprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));",
      "296:   exit(1);",
      "297:  }",
      "298: }",
      "300: void test_chroot(const char *path)",
      "301: {",
      "302:  if (chroot(path) == 0) {",
      "303:   fprintf(stderr, \"leak at chroot of %s\\n\", path);",
      "304:   exit(1);",
      "305:  }",
      "306:  if (errno != ENOENT && errno != ENOSYS) {",
      "307:   fprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));",
      "308:   exit(1);",
      "309:  }",
      "310: }",
      "312: void test_xattrs(const char *path)",
      "313: {",
      "325:   char value[200];",
      "326:   if (getxattr(path, \"security.selinux\", value, 200) >= 0) {",
      "327:   fprintf(stderr, \"leak at getxattr of %s\\n\", path);",
      "328:   exit(1);",
      "329:  }",
      "330:  if (errno != ENOENT && errno != ENOSYS) {",
      "331:   fprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));",
      "332:   exit(1);",
      "333:  }",
      "334: }",
      "336: void test_utimes(const char *path)",
      "337: {",
      "338:  struct utimbuf times;",
      "339:  times.actime = 0;",
      "340:  times.modtime = 0;",
      "342:  if (utime(path, &times) == 0) {",
      "343:   fprintf(stderr, \"leak at utime of %s\\n\", path);",
      "344:   exit(1);",
      "345:  }",
      "346:  if (errno != ENOENT && errno != ENOSYS) {",
      "347:   fprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));",
      "348:   exit(1);",
      "349:  }",
      "350: }",
      "352: void test_openat(const char *path)",
      "353: {",
      "354:  char *d = strdupa(path), *f, *tmpname;",
      "355:  int fd, fd2;",
      "356:  f = basename(d);",
      "357:  d = dirname(d);",
      "358:  fd = open(d, O_RDONLY);",
      "359:  if (fd < 0) {",
      "360:   fprintf(stderr, \"Error in openat test: could not open parent dir\\n\");",
      "361:   fprintf(stderr, \"(this is expected on the second run)\\n\");",
      "362:   return;",
      "363:  }",
      "364:  fd2 = openat(fd, f, O_RDONLY);",
      "365:  if (fd2 >= 0 || errno != ENOENT) {",
      "366:   fprintf(stderr, \"leak at openat of %s\\n\", f);",
      "367:   exit(1);",
      "368:  }",
      "369:  size_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;",
      "370:  tmpname = alloca(len);",
      "371:  snprintf(tmpname, len, \"%s/cgroup.procs\", f);",
      "372:  fd2 = openat(fd, tmpname, O_RDONLY);",
      "373:  if (fd2 >= 0 || errno != ENOENT) {",
      "374:   fprintf(stderr, \"leak at openat of %s\\n\", tmpname);",
      "375:   exit(1);",
      "376:  }",
      "377:  close(fd);",
      "378: }",
      "380: int main(int argc, char *argv[])",
      "381: {",
      "382:  char *procspath;",
      "383:  size_t len;",
      "385:  if (geteuid() != 0) {",
      "386:   fprintf(stderr, \"Run me as root\\n\");",
      "387:   exit(1);",
      "388:  }",
      "390:  if (argc != 2)  {",
      "391:   fprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);",
      "392:   exit(1);",
      "393:  }",
      "396:  len = strlen(argv[1]) + strlen(\"/cgroup.procs\") + 1;",
      "397:  procspath = alloca(len);",
      "398:  snprintf(procspath, len, \"%s/cgroup.procs\", argv[1]);",
      "400:  test_open(argv[1]);",
      "401:  test_open(procspath);",
      "402:  test_stat(argv[1]);",
      "403:  test_stat(procspath);",
      "404:  test_access(argv[1]);",
      "405:  test_access(procspath);",
      "407:  test_bind(argv[1]);",
      "408:  test_bind(procspath);",
      "409:  test_bindmount(argv[1]);",
      "410:  test_bindmount(procspath);",
      "411:  test_truncate(argv[1]);",
      "412:  test_truncate(procspath);",
      "413:  test_chdir(argv[1]);",
      "414:  test_chdir(procspath);",
      "415:  test_rename(argv[1]);",
      "416:  test_rename(procspath);",
      "417:  test_mkdir(argv[1]);",
      "418:  test_mkdir(procspath);",
      "419:  test_rmdir(argv[1]);",
      "420:  test_rmdir(procspath);",
      "421:  test_creat(argv[1]);",
      "422:  test_creat(procspath);",
      "423:  test_link(argv[1]);",
      "424:  test_link(procspath);",
      "425:  test_unlink(argv[1]);",
      "426:  test_unlink(procspath);",
      "427:  test_symlink(argv[1]);",
      "428:  test_symlink(procspath);",
      "429:  test_readlink(argv[1]);",
      "430:  test_readlink(procspath);",
      "431:  test_chmod(argv[1]);",
      "432:  test_chmod(procspath);",
      "433:  test_chown(argv[1]);",
      "434:  test_chown(procspath);",
      "435:  test_lchown(argv[1]);",
      "436:  test_lchown(procspath);",
      "437:  test_mknod(argv[1]);",
      "438:  test_mknod(procspath);",
      "439:  test_chroot(argv[1]);",
      "440:  test_chroot(procspath);",
      "441:  test_xattrs(argv[1]);",
      "442:  test_xattrs(procspath);",
      "443:  test_utimes(argv[1]);",
      "444:  test_utimes(procspath);",
      "446:  test_openat(argv[1]);",
      "449:  printf(\"All tests passed\\n\");",
      "450:  return 0;",
      "451: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "754c2080519422b5f64acd3b32c366f94b6eb3e1",
      "candidate_info": {
        "commit_hash": "754c2080519422b5f64acd3b32c366f94b6eb3e1",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/754c2080519422b5f64acd3b32c366f94b6eb3e1",
        "files": [
          "tests/main.sh",
          "tests/test_cgroup",
          "tests/test_confinement.sh",
          "tests/test_meminfo_hierarchy.sh",
          "tests/test_proc"
        ],
        "message": "tests: update to handle lxcfs virtualizing based on init\n\nlxcfs used to use $current's cgroups to virtualize proc, but\nswitched in 0.17 to using $current's init's cgroups.  The\ntests need to be updated to reflect that.\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "tests/main.sh||tests/main.sh",
          "tests/test_confinement.sh||tests/test_confinement.sh",
          "tests/test_meminfo_hierarchy.sh||tests/test_meminfo_hierarchy.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tests/test_confinement.sh||tests/test_confinement.sh"
          ],
          "candidate": [
            "tests/test_confinement.sh||tests/test_confinement.sh"
          ]
        }
      },
      "candidate_diff": {
        "tests/main.sh||tests/main.sh": [
          "File: tests/main.sh -> tests/main.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:  count=$((count+1))",
          "57: done",
          "59: TESTCASE=\"test_proc\"",
          "61: TESTCASE=\"test_cgroup\"",
          "63: TESTCASE=\"test_read_proc.sh\"",
          "65: TESTCASE=\"cpusetrange\"",
          "67: TESTCASE=\"meminfo hierarchy\"",
          "70: # Check for any defunct processes - children we didn't reap",
          "71: n=`ps -ef | grep lxcfs | grep defunct | wc -l`",
          "",
          "[Removed Lines]",
          "60: ${dirname}/test_proc",
          "62: ${dirname}/test_cgroup",
          "64: ${dirname}/test_read_proc.sh",
          "66: ${dirname}/cpusetrange",
          "68: ${dirname}/test_meminfo_hierarchy.sh",
          "",
          "[Added Lines]",
          "59: RUNTEST() {",
          "60:  unshare -fmp --mount-proc $*",
          "61: }",
          "64: RUNTEST ${dirname}/test_proc",
          "66: RUNTEST ${dirname}/test_cgroup",
          "68: RUNTEST ${dirname}/test_read_proc.sh",
          "70: RUNTEST ${dirname}/cpusetrange",
          "72: RUNTEST ${dirname}/test_meminfo_hierarchy.sh",
          "",
          "---------------"
        ],
        "tests/test_confinement.sh||tests/test_confinement.sh": [
          "File: tests/test_confinement.sh -> tests/test_confinement.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: pid=$!",
          "27: # put ourselves into x1",
          "29: cgm create freezer x1",
          "32: mount -t cgroup -o freezer freezer $d2",
          "33: sudo rmdir $d2/lxcfs_test_a1/lxcfs_test_a2 || true",
          "",
          "[Removed Lines]",
          "28: cgm movepidabs freezer / $$",
          "30: cgm movepid freezer x1 $$",
          "",
          "[Added Lines]",
          "28: cgm movepidabs freezer / 1",
          "30: cgm movepid freezer x1 1",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "81: ${dirname}/test_syscalls $d/cgroup/freezer/lxcfs_test_a1/lxcfs_test_a2",
          "83: echo \"Making sure root can act on descendents\"",
          "85: newcg=${mycg}/lxcfs_test_a1",
          "86: rmdir $d2/$newcg || true  # cleanup previosu run",
          "87: mkdir $d/cgroup/freezer/$newcg",
          "",
          "[Removed Lines]",
          "84: mycg=$(cgm getpidcgroupabs freezer $$)",
          "",
          "[Added Lines]",
          "84: mycg=$(cgm getpidcgroupabs freezer 1)",
          "",
          "---------------"
        ],
        "tests/test_meminfo_hierarchy.sh||tests/test_meminfo_hierarchy.sh": [
          "File: tests/test_meminfo_hierarchy.sh -> tests/test_meminfo_hierarchy.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "7: cg1=x1.$$",
          "8: cg2=x2.$$",
          "11: cleanup() {",
          "14:  if [ $FAILED -eq 1 ]; then",
          "15:   echo \"Failed\"",
          "16:   exit 1",
          "",
          "[Removed Lines]",
          "9: curcg=$(cgm getpidcgroupabs memory $$)",
          "12:  cgm movepidabs memory ${curcg} $$",
          "13:  cgm remove memory ${cg1} 1",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "22: FAILED=1",
          "23: trap cleanup EXIT HUP INT TERM",
          "28: m1=`awk '/^MemTotal:/ { print $2 }' ${LXCFSDIR}/proc/meminfo`",
          "31: m2=`awk '/^MemTotal:/ { print $2 }' ${LXCFSDIR}/proc/meminfo`",
          "32: [ $m1 -eq $m2 ]",
          "",
          "[Removed Lines]",
          "25: cgm create memory ${cg1}",
          "26: cgm setvalue memory ${cg1} memory.limit_in_bytes 500000000",
          "27: cgm movepid memory ${cg1} $$",
          "29: cgm create memory ${cg2}",
          "30: cgm movepid memory ${cg2} $$",
          "",
          "[Added Lines]",
          "22: [ ! -d /sys/fs/cgroup/memory ] && exit 0",
          "23: initmemory=`awk -F: '/memory/ { print $3 }' /proc/1/cgroup`",
          "24: mempath=/sys/fs/cgroup/memory/${initmemory}",
          "25: rmdir ${mempath}/${cg1} || true",
          "26: rmdir ${mempath}/${cg2} || true",
          "27: mkdir ${mempath}/${cg1}",
          "29: echo 500000000 > ${mempath}/${cg1}/memory.limit_in_bytes",
          "30: echo 1 > ${mempath}/${cg1}/tasks",
          "33: mkdir ${mempath}/${cg1}/${cg2}",
          "34: echo 1 > ${mempath}/${cg1}/${cg2}/tasks",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "87dce5f65fa498aa21b1d22eed98f1812c935198",
      "candidate_info": {
        "commit_hash": "87dce5f65fa498aa21b1d22eed98f1812c935198",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/87dce5f65fa498aa21b1d22eed98f1812c935198",
        "files": [
          "cgfs.c",
          "lxcfs.c"
        ],
        "message": "more sanity checking\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "cgfs.c||cgfs.c",
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "cgfs.c||cgfs.c": [
          "File: cgfs.c -> cgfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "698:  if (ret < 0)",
          "699:   return NULL;",
          "703:  do {",
          "704:   newkey = malloc(sizeof(struct cgfs_files));",
          "705:  } while (!newkey);",
          "707:  newkey->uid = sb.st_uid;",
          "708:  newkey->gid = sb.st_gid;",
          "709:  newkey->mode = sb.st_mode;",
          "",
          "[Removed Lines]",
          "701:  if (!S_ISREG(sb.st_mode))",
          "702:   return NULL;",
          "706:  newkey->name = must_copy_string(file);",
          "",
          "[Added Lines]",
          "704:  if (file)",
          "705:   newkey->name = must_copy_string(file);",
          "706:  else if (rindex(cgroup, '/'))",
          "707:   newkey->name = must_copy_string(rindex(cgroup, '/'));",
          "708:  else",
          "709:   newkey->name = must_copy_string(cgroup);",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90: {",
          "91:  int status, ret;",
          "93: again:",
          "94:  ret = waitpid(pid, &status, 0);",
          "95:  if (ret == -1) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "93:  if (pid <= 0)",
          "94:   return -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "565:  }",
          "567:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "571:  if (initpid <= 0)",
          "572:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "653:  }",
          "655:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "656:  if (cgroup) {",
          "657:   if (!caller_may_see_dir(initpid, controller, cgroup))",
          "658:    return -ENOENT;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "661:  if (initpid <= 0)",
          "662:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "708:  }",
          "710:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "711:  if (!caller_is_in_ancestor(initpid, d->controller, d->cgroup, &nextcg)) {",
          "712:   if (nextcg) {",
          "713:    int ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "718:  if (initpid <= 0)",
          "719:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "808:  free_key(k);",
          "810:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "811:  if (!caller_may_see_dir(initpid, controller, path1)) {",
          "812:   ret = -ENOENT;",
          "813:   goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "820:  if (initpid <= 0)",
          "821:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1694:   path1 = cgdir;",
          "1696:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "1697:  if (!caller_is_in_ancestor(initpid, controller, path1, &next)) {",
          "1699:    ret = -EEXIST;",
          "1700:   else",
          "1701:    ret = -ENOENT;",
          "",
          "[Removed Lines]",
          "1698:   if (last && strcmp(next, last) == 0)",
          "",
          "[Added Lines]",
          "1708:  if (initpid <= 0)",
          "1709:   initpid = fc->pid;",
          "1711:   if (!next)",
          "1712:    ret = -EINVAL;",
          "1713:   else if (last && strcmp(next, last) == 0)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1744:  }",
          "1746:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "1747:  if (!caller_is_in_ancestor(initpid, controller, cgroup, &next)) {",
          "1748:   if (!last || strcmp(next, last) == 0)",
          "1749:    ret = -EBUSY;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1762:  if (initpid <= 0)",
          "1763:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1932:  }",
          "1934:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "1935:  cg = get_pid_cgroup(initpid, \"memory\");",
          "1936:  if (!cg)",
          "1937:   return read_file(\"/proc/meminfo\", buf, size, d);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1952:  if (initpid <= 0)",
          "1953:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2112:  }",
          "2114:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "2115:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "2116:  if (!cg)",
          "2117:   return read_file(\"proc/cpuinfo\", buf, size, d);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2134:  if (initpid <= 0)",
          "2135:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2227:  }",
          "2229:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "2230:  cg = get_pid_cgroup(initpid, \"cpuset\");",
          "2231:  if (!cg)",
          "2232:   return read_file(\"/proc/stat\", buf, size, d);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2251:  if (initpid <= 0)",
          "2252:   initpid = fc->pid;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2357:  pid_t qpid;",
          "2359:  qpid = get_init_pid_for_task(pid);",
          "2361:   return 0;",
          "2363:  ret = snprintf(fnam, 100, \"/proc/%d\", qpid);",
          "",
          "[Removed Lines]",
          "2360:  if (qpid < 0)",
          "",
          "[Added Lines]",
          "2383:  if (qpid <= 0)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2401:  if (pid < 0)",
          "2402:   _exit(1);",
          "2403:  if (pid != 0) {",
          "2405:   _exit(0);",
          "2406:  }",
          "",
          "[Removed Lines]",
          "2404:   wait_for_pid(pid);",
          "",
          "[Added Lines]",
          "2427:   if (!wait_for_pid(pid))",
          "2428:    _exit(1);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2410:  cred.gid = 0;",
          "2411:  cred.pid = 1;",
          "2412:  v = '1';",
          "2414:  _exit(0);",
          "2415: }",
          "",
          "[Removed Lines]",
          "2413:  send_creds(sock, &cred, v, true);",
          "",
          "[Added Lines]",
          "2437:  if (send_creds(sock, &cred, v, true) != SEND_CREDS_OK)",
          "2438:   _exit(1);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2433:  if (!pid) {",
          "2434:   close(sock[1]);",
          "2435:   write_task_init_pid_exit(sock[0], task);",
          "2436:  }",
          "2438:  if (!recv_creds(sock[1], &cred, &v))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2461:   _exit(0);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2442: out:",
          "2443:  close(sock[0]);",
          "2444:  close(sock[1]);",
          "2446:  return ret;",
          "2447: }",
          "",
          "[Removed Lines]",
          "2445:  wait_for_pid(pid);",
          "",
          "[Added Lines]",
          "2471:  if (pid > 0)",
          "2472:   wait_for_pid(pid);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2452:  char *cgroup = NULL, *usage_str = NULL;",
          "2453:  unsigned long usage = 0;",
          "2456:   return 0;",
          "2458:  cgroup = get_pid_cgroup(initpid, \"cpuacct\");",
          "",
          "[Removed Lines]",
          "2455:  if (initpid == -1)",
          "",
          "[Added Lines]",
          "2482:  if (initpid <= 0)",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2549:  }",
          "2551:  pid_t initpid = get_init_pid_for_task(fc->pid);",
          "2552:  cg = get_pid_cgroup(initpid, \"blkio\");",
          "2553:  if (!cg)",
          "2554:   return read_file(\"/proc/diskstats\", buf, size, d);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2579:  if (initpid <= 0)",
          "2580:   initpid = fc->pid;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a1bb5ea52000eec98a25329ba39156382fd734d",
      "candidate_info": {
        "commit_hash": "0a1bb5ea52000eec98a25329ba39156382fd734d",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/0a1bb5ea52000eec98a25329ba39156382fd734d",
        "files": [
          "cgmanager.c",
          "cgmanager.h",
          "lxcfs.c"
        ],
        "message": "implement chmod\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "cgmanager.c||cgmanager.c",
          "cgmanager.h||cgmanager.h",
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "cgmanager.c||cgmanager.c": [
          "File: cgmanager.c -> cgmanager.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "319:  return true;",
          "320: }",
          "322: bool cgm_remove(const char *controller, const char *cg)",
          "323: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "322: bool cgm_chmod_file(const char *controller, const char *file, mode_t mode)",
          "323: {",
          "324:  if (!cgm_dbus_connect()) {",
          "325:   return false;",
          "326:  }",
          "328:  if ( cgmanager_chmod_sync(NULL, cgroup_manager, controller, file, \"\", mode) != 0) {",
          "329:   NihError *nerr;",
          "330:   nerr = nih_error_get();",
          "331:   fprintf(stderr, \"call to chmod failed: %s\", nerr->message);",
          "332:   nih_free(nerr);",
          "333:   cgm_dbus_disconnect();",
          "334:   return false;",
          "335:  }",
          "337:  cgm_dbus_disconnect();",
          "338:  return true;",
          "339: }",
          "",
          "---------------"
        ],
        "cgmanager.h||cgmanager.h": [
          "File: cgmanager.h -> cgmanager.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:   const char *value);",
          "15: bool cgm_create(const char *controller, const char *cg, uid_t uid, gid_t gid);",
          "16: bool cgm_chown_file(const char *controller, const char *cg, uid_t uid, gid_t gid);",
          "17: bool cgm_remove(const char *controller, const char *cg);",
          "19: bool cgm_escape_cgroup(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: bool cgm_chmod_file(const char *controller, const char *file, mode_t mode);",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "690: int cg_chmod(const char *path, mode_t mode)",
          "691: {",
          "692: }",
          "694: int cg_mkdir(const char *path, mode_t mode)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "692:  struct fuse_context *fc = fuse_get_context();",
          "693:  nih_local char * cgdir = NULL;",
          "694:  char *fpath = NULL, *path1, *path2;",
          "695:  nih_local struct cgm_keys *k = NULL;",
          "696:  const char *cgroup;",
          "697:  nih_local char *controller = NULL;",
          "699:  if (!fc)",
          "700:   return -EIO;",
          "702:  if (strcmp(path, \"/cgroup\") == 0)",
          "703:   return -EINVAL;",
          "705:  controller = pick_controller_from_path(fc, path);",
          "706:  if (!controller)",
          "707:   return -EIO;",
          "708:  cgroup = find_cgroup_in_path(path);",
          "709:  if (!cgroup)",
          "711:   return -EINVAL;",
          "713:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "715:  if (!fpath) {",
          "716:   path1 = \"/\";",
          "717:   path2 = cgdir;",
          "718:  } else {",
          "719:   path1 = cgdir;",
          "720:   path2 = fpath;",
          "721:  }",
          "723:  if (is_child_cgroup(controller, path1, path2)) {",
          "726:   k = get_cgroup_key(controller, cgroup, \"tasks\");",
          "728:  } else",
          "729:   k = get_cgroup_key(controller, path1, path2);",
          "731:  if (!k)",
          "732:   return -EINVAL;",
          "740:  if (!is_privileged_over(fc->pid, fc->uid, k->uid, NS_ROOT_OPT))",
          "741:   return -EPERM;",
          "743:  if (!cgm_chmod_file(controller, cgroup, mode))",
          "744:   return -EINVAL;",
          "745:  return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "758ad80c2deacf4f6e82d9e8d03e17896aafc6c2",
      "candidate_info": {
        "commit_hash": "758ad80c2deacf4f6e82d9e8d03e17896aafc6c2",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/758ad80c2deacf4f6e82d9e8d03e17896aafc6c2",
        "files": [
          ".gitignore",
          "Makefile.am",
          "README.md",
          "lxcfs.c",
          "lxcfs.man.add"
        ],
        "message": "Add base lxcfs.c\n\nSo far it just does getattr and readdir for /cgroup/*\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "lxcfs.c||lxcfs.c",
          "lxcfs.man.add||lxcfs.man.add"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "Makefile.am||Makefile.am",
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: bin_PROGRAMS = lxcfs",
          "13: lxcfs_SOURCES = lxcfs.c cgmanager.c",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "15: man_MANS = lxcfs.1",
          "17: lxcfs.1: lxcfs lxcfs.man.add",
          "18:  $(HELP2MAN) -n \"Set up cgroup fs for containers\" --no-discard-stderr -s 1 -I lxcfs.man.add -N ./lxcfs > lxcfs.1",
          "20: distclean:",
          "21:  rm -rf .deps/ \\",
          "22:   INSTALL \\",
          "23:   Makefile \\",
          "24:   Makefile.in \\",
          "25:   aclocal.m4 \\",
          "26:   autom4te.cache/ \\",
          "27:   cgmanager.o \\",
          "28:   compile \\",
          "29:   config.guess \\",
          "30:   config.h \\",
          "31:   config.h.in \\",
          "32:   config.log \\",
          "33:   config.status \\",
          "34:   config.sub \\",
          "35:   configure \\",
          "36:   depcomp \\",
          "37:   install-sh \\",
          "38:   libtool \\",
          "39:   ltmain.sh \\",
          "40:   lxcfs \\",
          "41:   lxcfs.1 \\",
          "42:   lxcfs.o \\",
          "43:   m4/ \\",
          "44:   missing \\",
          "45:   stamp-h1",
          "",
          "---------------"
        ],
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #include <stdio.h>",
          "4: {",
          "6: }",
          "",
          "[Removed Lines]",
          "3: int main()",
          "5:  printf(\"hello, world\\n\");",
          "",
          "[Added Lines]",
          "24: #define FUSE_USE_VERSION 26",
          "27: #include <dirent.h>",
          "28: #include <fcntl.h>",
          "29: #include <fuse.h>",
          "30: #include <unistd.h>",
          "31: #include <errno.h>",
          "32: #include <stdbool.h>",
          "33: #include <time.h>",
          "34: #include <string.h>",
          "35: #include <stdlib.h>",
          "36: #include <libgen.h>",
          "38: #include <nih/alloc.h>",
          "39: #include <nih/string.h>",
          "41: #include \"cgmanager.h\"",
          "43: struct lxcfs_state {",
          "48:  char **subsystems;",
          "49: };",
          "50: #define LXCFS_DATA ((struct lxcfs_state *) fuse_get_context()->private_data)",
          "52: static bool is_privileged_over(pid_t pid, uid_t uid, uid_t victim)",
          "53: {",
          "54:  if (uid == victim)",
          "55:   return true;",
          "58:  return false;",
          "59: }",
          "61: static bool perms_include(int fmode, mode_t req_mode)",
          "62: {",
          "63:  fprintf(stderr, \"perms_include: checking whether %d includes %d\\n\",",
          "64:   fmode, req_mode);",
          "65:  return (fmode & req_mode) == req_mode;",
          "66: }",
          "79: static bool fc_may_access(struct fuse_context *fc, const char *contrl, const char *cg, const char *file, mode_t mode)",
          "80: {",
          "81:  nih_local struct cgm_keys **list = NULL;",
          "82:  int i;",
          "84:  if (!file)",
          "85:   file = \"tasks\";",
          "87:  if (*file == '/')",
          "88:   file++;",
          "90:  if (!cgm_list_keys(contrl, cg, &list))",
          "91:   return false;",
          "92:  for (i = 0; list[i]; i++) {",
          "93:   if (strcmp(list[i]->name, file) == 0) {",
          "94:    struct cgm_keys *k = list[i];",
          "95:    fprintf(stderr, \"XXX fc_may_access: found %s\\n\", file);",
          "97:    if (is_privileged_over(fc->pid, fc->uid, k->uid)) {",
          "98:     if (perms_include(k->mode >> 6, mode))",
          "99:      return true;",
          "100:    }",
          "101:    if (fc->gid == k->gid) {",
          "102:     if (perms_include(k->mode >> 3, mode))",
          "103:      return true;",
          "104:    }",
          "105:    return perms_include(k->mode, mode);",
          "106:   }",
          "107:  }",
          "109:  return false;",
          "110: }",
          "116: static char *pick_controller_from_path(struct fuse_context *fc, const char *path)",
          "117: {",
          "118:  const char *p1;",
          "119:  char *ret, *slash;",
          "121:  if (strlen(path) < 9)",
          "122:   return NULL;",
          "123:  p1 = path+8;",
          "124:  ret = nih_strdup(NULL, p1);",
          "125:  if (!ret)",
          "126:   return ret;",
          "127:  slash = strstr(ret, \"/\");",
          "128:  if (slash)",
          "132:  char **list = LXCFS_DATA ? LXCFS_DATA->subsystems : NULL;",
          "133:  int i;",
          "134:  if (!list) {",
          "135:   nih_free(ret);",
          "136:   return NULL;",
          "137:  }",
          "138:  for (i = 0;  list[i];  i++) {",
          "139:   if (strcmp(list[i], ret) == 0)",
          "140:    return ret;",
          "141:  }",
          "142:  nih_free(ret);",
          "143:  return NULL;",
          "144: }",
          "150: static const char *find_cgroup_in_path(const char *path)",
          "151: {",
          "152:  const char *p1;",
          "154:  if (strlen(path) < 9)",
          "155:   return NULL;",
          "156:  p1 = strstr(path+8, \"/\");",
          "157:  if (!p1)",
          "158:   return NULL;",
          "159:  return p1+1;",
          "160: }",
          "162: static bool is_child_cgroup(const char *contr, const char *dir, const char *f)",
          "163: {",
          "164:  nih_local char **list = NULL;",
          "165:  int i;",
          "167:  if (!f)",
          "168:   return false;",
          "169:  if (*f == '/')",
          "170:   f++;",
          "172:  if (!cgm_list_children(contr, dir, &list))",
          "173:   return false;",
          "174:  for (i = 0; list[i]; i++) {",
          "175:   if (strcmp(list[i], f) == 0)",
          "176:    return true;",
          "177:  }",
          "179:  return false;",
          "180: }",
          "182: static struct cgm_keys *get_cgroup_key(const char *contr, const char *dir, const char *f)",
          "183: {",
          "184:  nih_local struct cgm_keys **list = NULL;",
          "185:  struct cgm_keys *k;",
          "186:  int i;",
          "188:  if (!f)",
          "189:   return NULL;",
          "190:  if (*f == '/')",
          "191:   f++;",
          "192:  if (!cgm_list_keys(contr, dir, &list))",
          "193:   return NULL;",
          "194:  for (i = 0; list[i]; i++) {",
          "195:   if (strcmp(list[i]->name, f) == 0) {",
          "196:    k = NIH_MUST( nih_alloc(NULL, (sizeof(*k))) );",
          "197:    k->name = NIH_MUST( nih_strdup(k, list[i]->name) );",
          "198:    k->uid = list[i]->uid;",
          "199:    k->gid = list[i]->gid;",
          "200:    k->mode = list[i]->mode;",
          "201:    return k;",
          "202:   }",
          "203:  }",
          "205:  return NULL;",
          "206: }",
          "208: static void get_cgdir_and_path(const char *cg, char **dir, char **file)",
          "209: {",
          "210: #if 0",
          "211:  nih_local char *cgcopy = NULL;",
          "212:  nih_local struct cgm_keys *k = NULL;",
          "213:  char *cgdir, *fpath = strrchr(cgroup, '/');",
          "214:  cgcopy = NIH_MUST( nih_strdup(NULL, cgroup) );",
          "215:  cgdir = dirname(cgcopy);",
          "216: #endif",
          "217:  char *p;",
          "221:  if (!*file) {",
          "223:   return;",
          "224:  }",
          "225:  p = strrchr(*dir, '/');",
          "227: }",
          "232: static int cg_getattr(const char *path, struct stat *sb)",
          "233: {",
          "234:  struct timespec now;",
          "235:  struct fuse_context *fc = fuse_get_context();",
          "236:  nih_local char * cgdir = NULL;",
          "237:  char *fpath = NULL, *path1, *path2;",
          "238:  nih_local struct cgm_keys *k = NULL;",
          "239:  const char *cgroup;",
          "240:  nih_local char *controller = NULL;",
          "243:  if (!fc)",
          "244:   return -EIO;",
          "246:  memset(sb, 0, sizeof(struct stat));",
          "248:  if (clock_gettime(CLOCK_REALTIME, &now) < 0)",
          "249:   return -EINVAL;",
          "251:  sb->st_uid = sb->st_gid = 0;",
          "252:  sb->st_atim = sb->st_mtim = sb->st_ctim = now;",
          "253:  sb->st_size = 0;",
          "255:  if (strcmp(path, \"/cgroup\") == 0) {",
          "256:   sb->st_mode = S_IFDIR | 00755;",
          "257:   sb->st_nlink = 2;",
          "258:   return 0;",
          "259:  }",
          "261:  controller = pick_controller_from_path(fc, path);",
          "262:  if (!controller)",
          "263:   return -EIO;",
          "264:  fprintf(stderr, \"XXX getattr controller %s\\n\", controller);",
          "265:  cgroup = find_cgroup_in_path(path);",
          "266:  if (!cgroup) {",
          "268:   sb->st_mode = S_IFDIR | 00755;",
          "269:   sb->st_nlink = 2;",
          "270:   return 0;",
          "271:  }",
          "273:  fprintf(stderr, \"XXX getattr controller %s cgroup %s\\n\", controller, cgroup);",
          "275:  get_cgdir_and_path(cgroup, &cgdir, &fpath);",
          "277:  if (!fpath) {",
          "278:   path1 = \"/\";",
          "279:   path2 = cgdir;",
          "280:  } else {",
          "281:   path1 = cgdir;",
          "282:   path2 = fpath;",
          "283:  }",
          "285:  fprintf(stderr, \"XXX gettattr: dir is %s, basename %s\\n\", path1, path2);",
          "291:  if (is_child_cgroup(controller, path1, path2)) {",
          "292:   if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "293:    return -EPERM;",
          "295:   sb->st_mode = S_IFDIR | 00755;   // TODO what to use?",
          "297:   sb->st_uid = sb->st_gid = 0;",
          "298:   sb->st_nlink = 2;",
          "299:   return 0;",
          "300:  }",
          "302:  if ((k = get_cgroup_key(controller, path1, path2)) != NULL) {",
          "303:   if (!fc_may_access(fc, controller, path1, path2, O_RDONLY))",
          "304:    return -EPERM;",
          "306:   fprintf(stderr, \"XXX getattr mode on %s %s %s is %d\\n\", controller, path1, path2, k->mode);",
          "309:   sb->st_mode = S_IFREG | k->mode;",
          "310:   sb->st_uid = k->uid;",
          "311:   sb->st_gid = k->gid;",
          "312:   sb->st_nlink = 1;",
          "313:   return 0;",
          "314:  }",
          "316:  return -EINVAL;",
          "317: }",
          "319: static int cg_opendir(const char *path, struct fuse_file_info *fi)",
          "321:  return 0;",
          "322: }",
          "327: static int cg_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "328:   struct fuse_file_info *fi)",
          "329: {",
          "330:  struct fuse_context *fc = fuse_get_context();",
          "332:  if (!fc)",
          "333:   return -EIO;",
          "335:  if (strcmp(path, \"/cgroup\") == 0) {",
          "337:   char **list = LXCFS_DATA ? LXCFS_DATA->subsystems : NULL;",
          "338:   int i;",
          "340:   if (!list)",
          "341:    return -EIO;",
          "343:   for (i = 0;  list[i]; i++) {",
          "344:    if (filler(buf, list[i], NULL, 0) != 0) {",
          "345:     return -EIO;",
          "346:    }",
          "347:   }",
          "348:   return 0;",
          "349:  }",
          "352:  nih_local struct cgm_keys **list = NULL;",
          "353:  const char *cgroup;",
          "354:  nih_local char *controller = NULL;",
          "355:  int i;",
          "357:  controller = pick_controller_from_path(fc, path);",
          "358:  if (!controller)",
          "359:   return -EIO;",
          "361:  cgroup = find_cgroup_in_path(path);",
          "362:  if (!cgroup) {",
          "364:   cgroup = \"/\";",
          "365:  }",
          "367:  if (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))",
          "368:   return -EPERM;",
          "370:  if (!cgm_list_keys(controller, cgroup, &list))",
          "371:   return -EINVAL;",
          "372:  for (i = 0; list[i]; i++) {",
          "373:   fprintf(stderr, \"adding key %s\\n\", list[i]->name);",
          "374:   if (filler(buf, list[i]->name, NULL, 0) != 0) {",
          "375:    return -EIO;",
          "376:   }",
          "377:  }",
          "380:  nih_local char **clist;",
          "382:  if (!cgm_list_children(controller, cgroup, &clist))",
          "383:   return 0;",
          "384:  for (i = 0; clist[i]; i++) {",
          "385:   fprintf(stderr, \"adding child %s\\n\", clist[i]);",
          "386:   if (filler(buf, clist[i], NULL, 0) != 0) {",
          "387:    return -EIO;",
          "388:   }",
          "389:  }",
          "390:  return 0;",
          "391: }",
          "393: static int cg_releasedir(const char *path, struct fuse_file_info *fi)",
          "394: {",
          "395:  return 0;",
          "396: }",
          "403: const struct fuse_operations cg_ops = {",
          "404:  .getattr = cg_getattr,",
          "405:  .readlink = NULL,",
          "406:  .getdir = NULL,",
          "407:  .mknod = NULL,",
          "408:  .mkdir = NULL,",
          "409:  .unlink = NULL,",
          "410:  .rmdir = NULL,",
          "411:  .symlink = NULL,",
          "412:  .rename = NULL,",
          "413:  .link = NULL,",
          "414:  .chmod = NULL,",
          "415:  .chown = NULL,",
          "416:  .truncate = NULL,",
          "417:  .utime = NULL,",
          "418:  .open = NULL,",
          "419:  .read = NULL,",
          "420:  .write = NULL,",
          "421:  .statfs = NULL,",
          "422:  .flush = NULL,",
          "423:  .release = NULL,",
          "424:  .fsync = NULL,",
          "426:  .setxattr = NULL,",
          "427:  .getxattr = NULL,",
          "428:  .listxattr = NULL,",
          "429:  .removexattr = NULL,",
          "431:  .opendir = cg_opendir,",
          "432:  .readdir = cg_readdir,",
          "433:  .releasedir = cg_releasedir,",
          "435:  .fsyncdir = NULL,",
          "436:  .init = NULL,",
          "437:  .destroy = NULL,",
          "438:  .access = NULL,",
          "439:  .create = NULL,",
          "440:  .ftruncate = NULL,",
          "441:  .fgetattr = NULL,",
          "442: };",
          "444: static int proc_getattr(const char *path, struct stat *sb)",
          "445: {",
          "446:  if (strcmp(path, \"/proc\") != 0)",
          "447:   return -EINVAL;",
          "448:  sb->st_mode = S_IFDIR | 00755;",
          "449:  sb->st_nlink = 2;",
          "450:  return 0;",
          "451: }",
          "453: const struct fuse_operations proc_ops = {",
          "454:  .getattr = proc_getattr,",
          "455:  .readlink = NULL,",
          "456:  .getdir = NULL,",
          "457:  .mknod = NULL,",
          "458:  .mkdir = NULL,",
          "459:  .unlink = NULL,",
          "460:  .rmdir = NULL,",
          "461:  .symlink = NULL,",
          "462:  .rename = NULL,",
          "463:  .link = NULL,",
          "464:  .chmod = NULL,",
          "465:  .chown = NULL,",
          "466:  .truncate = NULL,",
          "467:  .utime = NULL,",
          "468:  .open = NULL,",
          "469:  .read = NULL,",
          "470:  .write = NULL,",
          "471:  .statfs = NULL,",
          "472:  .flush = NULL,",
          "473:  .release = NULL,",
          "474:  .fsync = NULL,",
          "476:  .setxattr = NULL,",
          "477:  .getxattr = NULL,",
          "478:  .listxattr = NULL,",
          "479:  .removexattr = NULL,",
          "481:  .opendir = NULL,",
          "482:  .readdir = NULL,",
          "483:  .releasedir = NULL,",
          "485:  .fsyncdir = NULL,",
          "486:  .init = NULL,",
          "487:  .destroy = NULL,",
          "488:  .access = NULL,",
          "489:  .create = NULL,",
          "490:  .ftruncate = NULL,",
          "491:  .fgetattr = NULL,",
          "492: };",
          "494: static int lxcfs_getattr(const char *path, struct stat *sb)",
          "495: {",
          "496:  if (strcmp(path, \"/\") == 0) {",
          "497:   sb->st_mode = S_IFDIR | 00755;",
          "498:   sb->st_nlink = 2;",
          "499:   return 0;",
          "500:  }",
          "501:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "502:   return cg_getattr(path, sb);",
          "503:  }",
          "504:  if (strncmp(path, \"/proc\", 7) == 0) {",
          "505:   return proc_getattr(path, sb);",
          "506:  }",
          "507:  return -EINVAL;",
          "508: }",
          "510: static int lxcfs_opendir(const char *path, struct fuse_file_info *fi)",
          "511: {",
          "512:  if (strcmp(path, \"/\") == 0)",
          "513:   return 0;",
          "515:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "516:   return cg_opendir(path, fi);",
          "517:  }",
          "518:  return -EINVAL;",
          "519: }",
          "521: static int lxcfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,",
          "522:   struct fuse_file_info *fi)",
          "523: {",
          "524:  if (strcmp(path, \"/\") == 0) {",
          "525:   if (filler(buf, \"proc\", NULL, 0) != 0 ||",
          "526:     filler(buf, \"cgroup\", NULL, 0) != 0)",
          "527:    return -EINVAL;",
          "528:   return 0;",
          "529:  }",
          "530:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "531:   return cg_readdir(path, buf, filler, offset, fi);",
          "532:  }",
          "533:  return -EINVAL;",
          "534: }",
          "536: static int lxcfs_releasedir(const char *path, struct fuse_file_info *fi)",
          "537: {",
          "538:  if (strcmp(path, \"/\") == 0)",
          "539:   return 0;",
          "540:  if (strncmp(path, \"/cgroup\", 7) == 0) {",
          "541:   return cg_releasedir(path, fi);",
          "542:  }",
          "543:  return -EINVAL;",
          "544: }",
          "546: void *bb_init(struct fuse_conn_info *conn)",
          "547: {",
          "548:  return LXCFS_DATA;",
          "549: }",
          "551: const struct fuse_operations lxcfs_ops = {",
          "552:  .getattr = lxcfs_getattr,",
          "553:  .readlink = NULL,",
          "554:  .getdir = NULL,",
          "555:  .mknod = NULL,",
          "556:  .mkdir = NULL,",
          "557:  .unlink = NULL,",
          "558:  .rmdir = NULL,",
          "559:  .symlink = NULL,",
          "560:  .rename = NULL,",
          "561:  .link = NULL,",
          "562:  .chmod = NULL,",
          "563:  .chown = NULL,",
          "564:  .truncate = NULL,",
          "565:  .utime = NULL,",
          "566:  .open = NULL,",
          "567:  .read = NULL,",
          "568:  .write = NULL,",
          "569:  .statfs = NULL,",
          "570:  .flush = NULL,",
          "571:  .release = NULL,",
          "572:  .fsync = NULL,",
          "574:  .setxattr = NULL,",
          "575:  .getxattr = NULL,",
          "576:  .listxattr = NULL,",
          "577:  .removexattr = NULL,",
          "579:  .opendir = lxcfs_opendir,",
          "580:  .readdir = lxcfs_readdir,",
          "581:  .releasedir = lxcfs_releasedir,",
          "583:  .fsyncdir = NULL,",
          "584:  .init = NULL,",
          "585:  .destroy = NULL,",
          "586:  .access = NULL,",
          "587:  .create = NULL,",
          "588:  .ftruncate = NULL,",
          "589:  .fgetattr = NULL,",
          "590: };",
          "592: void usage(const char *me)",
          "593: {",
          "594:  fprintf(stderr, \"Usage:\\n\");",
          "595:  fprintf(stderr, \"\\n\");",
          "596:  fprintf(stderr, \"%s [FUSE and mount options] mountpoint\\n\", me);",
          "597:  exit(1);",
          "598: }",
          "600: bool is_help(char *w)",
          "601: {",
          "602:  if (strcmp(w, \"-h\") == 0 ||",
          "603:    strcmp(w, \"--help\") == 0 ||",
          "604:    strcmp(w, \"-help\") == 0 ||",
          "605:    strcmp(w, \"help\") == 0)",
          "606:   return true;",
          "607:  return false;",
          "608: }",
          "610: int main(int argc, char *argv[])",
          "611: {",
          "612:  int ret;",
          "613:  struct lxcfs_state *d;",
          "615:  if (argc < 2 || is_help(argv[1]))",
          "616:   usage(argv[0]);",
          "618:  d = malloc(sizeof(*d));",
          "619:  if (!d)",
          "620:   return -1;",
          "622:  if (!cgm_escape_cgroup())",
          "623:   fprintf(stderr, \"WARNING: failed to escape to root cgroup\\n\");",
          "625:  if (!cgm_get_controllers(&d->subsystems))",
          "626:   return -1;",
          "628:  ret = fuse_main(argc, argv, &lxcfs_ops, d);",
          "630:  return ret;",
          "",
          "---------------"
        ],
        "lxcfs.man.add||lxcfs.man.add": [
          "File: lxcfs.man.add -> lxcfs.man.add",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: [DESCRIPTION]",
          "3: lxcfs implements a FUSE fs which allows containers to have virtualized",
          "4: cgroup filesystems and virtualized views of /proc/cpuinfo and /proc/meminfo.",
          "6: [SEE ALSO]",
          "7: cgmanager(1),",
          "8: lxc(1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "04b5cbdc5c41efd308f8d64e80f9d423284656ee",
      "candidate_info": {
        "commit_hash": "04b5cbdc5c41efd308f8d64e80f9d423284656ee",
        "repo": "lxc/lxcfs",
        "commit_url": "https://github.com/lxc/lxcfs/commit/04b5cbdc5c41efd308f8d64e80f9d423284656ee",
        "files": [
          "lxcfs.c"
        ],
        "message": "allow systemd to escape its init.scope cgroup\n\nSigned-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>",
        "before_after_code_files": [
          "lxcfs.c||lxcfs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "lxcfs.c||lxcfs.c"
          ],
          "candidate": [
            "lxcfs.c||lxcfs.c"
          ]
        }
      },
      "candidate_diff": {
        "lxcfs.c||lxcfs.c": [
          "File: lxcfs.c -> lxcfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "277:   x[l-1] = '\\0';",
          "278: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "280: #define INITSCOPE \"/init.scope\"",
          "281: static void prune_init_slice(char *cg)",
          "282: {",
          "283:  char *point;",
          "284:  point = cg + strlen(cg) - strlen(INITSCOPE);",
          "285:  if (point < cg)",
          "286:    return;",
          "287:  if (strcmp(point, INITSCOPE) == 0) {",
          "288:   if (point == cg)",
          "290:   else",
          "292:  }",
          "293: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "311:    continue;",
          "312:   c2++;",
          "313:   stripnewline(c2);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329:   prune_init_slice(c2);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
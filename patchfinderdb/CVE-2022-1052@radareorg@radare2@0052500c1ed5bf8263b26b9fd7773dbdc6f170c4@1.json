{
  "cve_id": "CVE-2022-1052",
  "cve_desc": "Heap Buffer Overflow in iterate_chained_fixups in GitHub repository radareorg/radare2 prior to 5.6.6.",
  "repo": "radareorg/radare2",
  "patch_hash": "0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
  "patch_info": {
    "commit_hash": "0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
    "repo": "radareorg/radare2",
    "commit_url": "https://github.com/radareorg/radare2/commit/0052500c1ed5bf8263b26b9fd7773dbdc6f170c4",
    "files": [
      "libr/bin/format/mach0/mach0.c",
      "libr/bin/format/mach0/mach0.h",
      "libr/core/cmd_api.c"
    ],
    "message": "Fix heap OOB read in macho.iterate_chained_fixups ##crash\n\n* Reported by peacock-doris via huntr.dev\n* Reproducer 'tests_65305'\n\nmrmacete:\n* Return early if segs_count is 0\n* Initialize segs_count also for reconstructed fixups\n\nCo-authored-by: pancake <pancake@nopcode.org>\nCo-authored-by: Francesco Tamagni <mrmacete@protonmail.ch>",
    "before_after_code_files": [
      "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
      "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
      "libr/core/cmd_api.c||libr/core/cmd_api.c"
    ]
  },
  "patch_diff": {
    "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
      "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1510:  if (header.starts_offset > size) {",
      "1511:   return false;",
      "1512:  }",
      "1515:   return false;",
      "1516:  }",
      "1517:  bin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);",
      "1518:  if (!bin->chained_starts) {",
      "1519:   return false;",
      "",
      "[Removed Lines]",
      "1513:  ut32 segs_count;",
      "1514:  if ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {",
      "",
      "[Added Lines]",
      "1513:  ut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);",
      "1514:  if (segs_count == UT32_MAX || segs_count == 0) {",
      "1517:  bin->segs_count = segs_count;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1699:  }",
      "1700:  R_FREE (opcodes);",
      "1702:  return true;",
      "1703: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1703:  bin->segs_count = bin->nsegs;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2124:  free (mo->intrp);",
      "2125:  free (mo->compiler);",
      "2126:  if (mo->chained_starts) {",
      "2128:    if (mo->chained_starts[i]) {",
      "2129:     free (mo->chained_starts[i]->page_start);",
      "2130:     free (mo->chained_starts[i]);",
      "",
      "[Removed Lines]",
      "2127:   for (i = 0; i < mo->nsegs; i++) {",
      "",
      "[Added Lines]",
      "2129:   for (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4559: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {",
      "4560:  int i = 0;",
      "4562:   if (!bin->chained_starts[i]) {",
      "4563:    continue;",
      "4564:   }",
      "",
      "[Removed Lines]",
      "4561:  for (; i < bin->nsegs; i++) {",
      "",
      "[Added Lines]",
      "4563:  for (; i < bin->nsegs && i < bin->segs_count; i++) {",
      "",
      "---------------"
    ],
    "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
      "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "130:  char *intrp;",
      "131:  char *compiler;",
      "132:  int nsegs;",
      "133:  struct r_dyld_chained_starts_in_segment **chained_starts;",
      "134:  struct dyld_chained_fixups_header fixups_header;",
      "135:  ut64 fixups_offset;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:  int segs_count;",
      "",
      "---------------"
    ],
    "libr/core/cmd_api.c||libr/core/cmd_api.c": [
      "File: libr/core/cmd_api.c -> libr/core/cmd_api.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "392: R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {",
      "393:  r_return_val_if_fail (cmd && cmd->aliases && k, NULL);",
      "395: }",
      "397: static ut8 *alias_append_internal(int *out_szp, const RCmdAliasVal *first, const ut8 *second, int second_sz) {",
      "",
      "[Removed Lines]",
      "394:  return ht_pp_find(cmd->aliases, k, NULL);",
      "",
      "[Added Lines]",
      "394:  return ht_pp_find (cmd->aliases, k, NULL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bae21844d0caceb9e9d0187a5b70e63aa6b7c62f",
      "candidate_info": {
        "commit_hash": "bae21844d0caceb9e9d0187a5b70e63aa6b7c62f",
        "repo": "radareorg/radare2",
        "commit_url": "https://github.com/radareorg/radare2/commit/bae21844d0caceb9e9d0187a5b70e63aa6b7c62f",
        "files": [
          "libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c",
          "test/db/anal/classes",
          "test/db/cmd/cmd_tc",
          "test/db/formats/mach0/fatmach0",
          "test/db/formats/mach0/objc"
        ],
        "message": "Parse relocs from Mach-O chained binds if no opcodes ##bin",
        "before_after_code_files": [
          "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
          "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h",
          "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h",
          "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
            "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h"
          ],
          "candidate": [
            "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c",
            "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h"
          ]
        }
      },
      "candidate_diff": {
        "libr/bin/format/mach0/mach0.c||libr/bin/format/mach0/mach0.c": [
          "File: libr/bin/format/mach0/mach0.c -> libr/bin/format/mach0/mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #define bprintf if (bin->verbose) eprintf",
          "11: #define Eprintf if (mo->verbose) eprintf",
          "13: typedef struct {",
          "14:  struct symbol_t *symbols;",
          "15:  int j;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)",
          "14: #define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26:  ut8 *next_child;",
          "27: } RTrieState;",
          "31: #define mach0_endian 1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: typedef struct {",
          "33:  ut8 * imports;",
          "34:  RSkipList *relocs;",
          "35: } RWalkBindChainsContext;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1510:  if (!bin->chained_starts) {",
          "1511:   return false;",
          "1512:  }",
          "1513:  size_t i;",
          "1514:  ut64 cursor = starts_at + sizeof (ut32);",
          "1515:  for (i = 0; i < segs_count; i++) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1521:  bin->fixups_header = header;",
          "1522:  bin->fixups_offset = offset;",
          "1523:  bin->fixups_size = size;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3187:  free (info);",
          "3188: }",
          "3190: static bool is_valid_ordinal_table_size(ut64 size) {",
          "3191:  return size > 0 && size <= UT16_MAX;",
          "3192: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3201: static bool walk_bind_chains_callback(void * context, RFixupEventDetails * event_details) {",
          "3202:  r_return_val_if_fail (event_details->type == R_FIXUP_EVENT_BIND || event_details->type == R_FIXUP_EVENT_BIND_AUTH, false);",
          "3203:  RWalkBindChainsContext *ctx = context;",
          "3204:  ut8 *imports = ctx->imports;",
          "3205:  struct MACH0_(obj_t) *bin = event_details->bin;",
          "3206:  ut32 imports_count = bin->fixups_header.imports_count;",
          "3207:  ut32 fixups_offset = bin->fixups_offset;",
          "3208:  ut32 fixups_size = bin->fixups_size;",
          "3209:  ut32 imports_format = bin->fixups_header.imports_format;",
          "3210:  ut32 import_index = ((RFixupBindEventDetails *) event_details)->ordinal;",
          "3211:  ut64 addend = 0;",
          "3212:  if (event_details->type != R_FIXUP_EVENT_BIND_AUTH) {",
          "3213:   addend = ((RFixupBindEventDetails *) event_details)->addend;",
          "3214:  }",
          "3216:  if (import_index < imports_count) {",
          "3217:   ut64 name_offset;",
          "3218:   switch (imports_format) {",
          "3219:    case DYLD_CHAINED_IMPORT: {",
          "3220:     struct dyld_chained_import * item = &((struct dyld_chained_import *) imports)[import_index];",
          "3221:     name_offset = item->name_offset;",
          "3222:     break;",
          "3223:    }",
          "3224:    case DYLD_CHAINED_IMPORT_ADDEND: {",
          "3225:     struct dyld_chained_import_addend * item = &((struct dyld_chained_import_addend *) imports)[import_index];",
          "3226:     name_offset = item->name_offset;",
          "3227:     addend += item->addend;",
          "3228:     break;",
          "3229:    }",
          "3230:    case DYLD_CHAINED_IMPORT_ADDEND64: {",
          "3231:     struct dyld_chained_import_addend64 * item = &((struct dyld_chained_import_addend64 *) imports)[import_index];",
          "3232:     name_offset = item->name_offset;",
          "3233:     addend += item->addend;",
          "3234:     break;",
          "3235:    }",
          "3236:    default:",
          "3237:     bprintf (\"Unsupported imports format\\n\");",
          "3238:     return false;",
          "3239:   }",
          "3241:   ut64 symbols_offset = bin->fixups_header.symbols_offset + fixups_offset;",
          "3243:   if (symbols_offset + name_offset + 1 < fixups_offset + fixups_size) {",
          "3244:    char *name = r_buf_get_string (bin->b, symbols_offset + name_offset);",
          "3245:    if (name) {",
          "3246:     struct reloc_t *reloc = R_NEW0 (struct reloc_t);",
          "3247:     if (!reloc) {",
          "3248:      free (name);",
          "3249:      return false;",
          "3250:     }",
          "3251:     reloc->addr = offset_to_vaddr (bin, event_details->offset);",
          "3252:     reloc->offset = event_details->offset;",
          "3253:     reloc->ord = import_index;",
          "3254:     reloc->type = R_BIN_RELOC_64;",
          "3255:     reloc->size = 8;",
          "3256:     reloc->addend = addend;",
          "3257:     r_str_ncpy (reloc->name, name, sizeof (reloc->name) - 1);",
          "3258:     r_skiplist_insert (ctx->relocs, reloc);",
          "3259:     free (name);",
          "3260:    } else if (bin->verbose) {",
          "3261:     eprintf (\"Malformed chained bind: failed to read name\\n\");",
          "3262:    }",
          "3263:   } else if (bin->verbose) {",
          "3264:    eprintf (\"Malformed chained bind: name_offset out of bounds\\n\");",
          "3265:   }",
          "3266:  } else if (bin->verbose) {",
          "3267:   eprintf (\"Malformed chained bind: import out of length\\n\");",
          "3268:  }",
          "3270:  return true;",
          "3271: }",
          "3273: static void walk_bind_chains(struct MACH0_(obj_t) *bin, RSkipList *relocs) {",
          "3274:  r_return_if_fail (bin && bin->fixups_offset);",
          "3276:  ut8 *imports = NULL;",
          "3278:  ut32 imports_count = bin->fixups_header.imports_count;",
          "3279:  ut32 fixups_offset = bin->fixups_offset;",
          "3280:  ut32 imports_offset = bin->fixups_header.imports_offset;",
          "3281:  if (!imports_count || !imports_offset) {",
          "3282:   return;",
          "3283:  }",
          "3284:  if (bin->fixups_header.symbols_format != 0) {",
          "3285:   eprintf (\"Compressed fixups symbols not supported yet, please file a bug with a sample attached.\\n\");",
          "3286:   return;",
          "3287:  }",
          "3289:  ut32 imports_format = bin->fixups_header.imports_format;",
          "3290:  ut64 imports_size;",
          "3291:  switch (imports_format) {",
          "3292:   case DYLD_CHAINED_IMPORT:",
          "3293:    imports_size = sizeof (struct dyld_chained_import) * imports_count;",
          "3294:    break;",
          "3295:   case DYLD_CHAINED_IMPORT_ADDEND:",
          "3296:    imports_size = sizeof (struct dyld_chained_import_addend) * imports_count;",
          "3297:    break;",
          "3298:   case DYLD_CHAINED_IMPORT_ADDEND64:",
          "3299:    imports_size = sizeof (struct dyld_chained_import_addend64) * imports_count;",
          "3300:    break;",
          "3301:   default:",
          "3302:    eprintf (\"Unsupported chained imports format: %d\\n\", imports_format);",
          "3303:    goto beach;",
          "3304:  }",
          "3306:  imports = malloc (imports_size);",
          "3307:  if (!imports) {",
          "3308:   goto beach;",
          "3309:  }",
          "3311:  switch (imports_format) {",
          "3312:   case DYLD_CHAINED_IMPORT:",
          "3313:    if (r_buf_fread_at (bin->b, fixups_offset + imports_offset,",
          "3314:      imports, \"i\", imports_count) != imports_size) {",
          "3315:     goto beach;",
          "3316:    }",
          "3317:    break;",
          "3318:   case DYLD_CHAINED_IMPORT_ADDEND:",
          "3319:    if (r_buf_fread_at (bin->b, fixups_offset + imports_offset,",
          "3320:      imports, \"ii\", imports_count) != imports_size) {",
          "3321:     goto beach;",
          "3322:    }",
          "3323:    break;",
          "3324:   case DYLD_CHAINED_IMPORT_ADDEND64:",
          "3325:    if (r_buf_fread_at (bin->b, fixups_offset + imports_offset,",
          "3326:      imports, \"il\", imports_count) != imports_size) {",
          "3327:     goto beach;",
          "3328:    }",
          "3329:    break;",
          "3330:  }",
          "3332:  RWalkBindChainsContext ctx;",
          "3333:  ctx.imports = imports;",
          "3334:  ctx.relocs = relocs;",
          "3336:  MACH0_(iterate_chained_fixups) (bin, 0, UT64_MAX, R_FIXUP_EVENT_MASK_BIND_ALL, &walk_bind_chains_callback, &ctx);",
          "3338: beach:",
          "3339:  free (imports);",
          "3340: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3536:   if (!relocs) {",
          "3537:    relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);",
          "3538:    if (!relocs) {",
          "3540:    }",
          "3541:   }",
          "3542:   for (j = 0; j < amount; j++) {",
          "",
          "[Removed Lines]",
          "3539:     return NULL;",
          "",
          "[Added Lines]",
          "3691:     goto beach;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3557:   if (!relocs) {",
          "3558:    relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);",
          "3559:    if (!relocs) {",
          "3561:    }",
          "3562:   }",
          "3563:   parse_relocation_info (bin, relocs, bin->dysymtab.extreloff, bin->dysymtab.nextrel);",
          "3564:  }",
          "3565: beach:",
          "3566:  r_pvector_free (threaded_binds);",
          "3567:  return relocs;",
          "",
          "[Removed Lines]",
          "3560:     return NULL;",
          "",
          "[Added Lines]",
          "3712:     goto beach;",
          "3718:  if (!bin->dyld_info && bin->chained_starts && bin->nsegs && bin->fixups_offset) {",
          "3719:   if (!relocs) {",
          "3720:    relocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);",
          "3721:    if (!relocs) {",
          "3722:     goto beach;",
          "3723:    }",
          "3724:   }",
          "3725:   walk_bind_chains (bin, relocs);",
          "3726:  }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4379: #endif",
          "4380:  return macho_hdr;",
          "4381: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4545: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {",
          "4546:  int i = 0;",
          "4547:  for (; i < bin->nsegs; i++) {",
          "4548:   if (!bin->chained_starts[i]) {",
          "4549:    continue;",
          "4550:   }",
          "4551:   int page_size = bin->chained_starts[i]->page_size;",
          "4552:   if (page_size < 1) {",
          "4553:    page_size = 4096;",
          "4554:   }",
          "4555:   ut64 start = bin->segs[i].fileoff;",
          "4556:   ut64 end = start + bin->segs[i].filesize;",
          "4557:   if (end >= limit_start && start <= limit_end) {",
          "4558:    ut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;",
          "4559:    ut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;",
          "4560:    for (; page_idx <= page_end_idx; page_idx++) {",
          "4561:     if (page_idx >= bin->chained_starts[i]->page_count) {",
          "4562:      break;",
          "4563:     }",
          "4564:     ut16 page_start = bin->chained_starts[i]->page_start[page_idx];",
          "4565:     if (page_start == DYLD_CHAINED_PTR_START_NONE) {",
          "4566:      continue;",
          "4567:     }",
          "4568:     ut64 cursor = start + page_idx * page_size + page_start;",
          "4569:     while (cursor < limit_end && cursor < end) {",
          "4570:      ut8 tmp[8];",
          "4571:      bool previous_rebasing = bin->rebasing_buffer;",
          "4572:      bin->rebasing_buffer = true;",
          "4573:      if (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {",
          "4574:       bin->rebasing_buffer = previous_rebasing;",
          "4575:       break;",
          "4576:      }",
          "4577:      bin->rebasing_buffer = previous_rebasing;",
          "4578:      ut64 raw_ptr = r_read_le64 (tmp);",
          "4579:      ut64 ptr_value = raw_ptr;",
          "4580:      ut64 delta, stride, addend;",
          "4581:      ut16 pointer_format = bin->chained_starts[i]->pointer_format;",
          "4582:      RFixupEvent event = R_FIXUP_EVENT_NONE;",
          "4583:      ut8 key = 0, addr_div = 0;",
          "4584:      ut16 diversity = 0;",
          "4585:      ut32 ordinal = UT32_MAX;",
          "4586:      if (pointer_format == DYLD_CHAINED_PTR_ARM64E) {",
          "4587:       stride = 8;",
          "4588:       bool is_auth = IS_PTR_AUTH (raw_ptr);",
          "4589:       bool is_bind = IS_PTR_BIND (raw_ptr);",
          "4590:       if (is_auth && is_bind) {",
          "4591:        struct dyld_chained_ptr_arm64e_auth_bind *p =",
          "4592:          (struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;",
          "4593:        event = R_FIXUP_EVENT_BIND_AUTH;",
          "4594:        delta = p->next;",
          "4595:        ordinal = p->ordinal;",
          "4596:        key = p->key;",
          "4597:        addr_div = p->addrDiv;",
          "4598:        diversity = p->diversity;",
          "4599:       } else if (!is_auth && is_bind) {",
          "4600:        struct dyld_chained_ptr_arm64e_bind *p =",
          "4601:          (struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;",
          "4602:        event = R_FIXUP_EVENT_BIND;",
          "4603:        delta = p->next;",
          "4604:        ordinal = p->ordinal;",
          "4605:        addend = p->addend;",
          "4606:       } else if (is_auth && !is_bind) {",
          "4607:        struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "4608:          (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "4609:        event = R_FIXUP_EVENT_REBASE_AUTH;",
          "4610:        delta = p->next;",
          "4611:        ptr_value = p->target + bin->baddr;",
          "4612:        key = p->key;",
          "4613:        addr_div = p->addrDiv;",
          "4614:        diversity = p->diversity;",
          "4615:       } else {",
          "4616:        struct dyld_chained_ptr_arm64e_rebase *p =",
          "4617:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "4618:        event = R_FIXUP_EVENT_REBASE;",
          "4619:        delta = p->next;",
          "4620:        ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "4621:       }",
          "4622:      } else if (pointer_format == DYLD_CHAINED_PTR_ARM64E_USERLAND24) {",
          "4623:       stride = 8;",
          "4624:       struct dyld_chained_ptr_arm64e_bind24 *bind =",
          "4625:         (struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;",
          "4626:       if (bind->bind) {",
          "4627:        delta = bind->next;",
          "4628:        if (bind->auth) {",
          "4629:         struct dyld_chained_ptr_arm64e_auth_bind24 *p =",
          "4630:           (struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;",
          "4631:         event = R_FIXUP_EVENT_BIND_AUTH;",
          "4632:         ordinal = p->ordinal;",
          "4633:         key = p->key;",
          "4634:         addr_div = p->addrDiv;",
          "4635:         diversity = p->diversity;",
          "4636:        } else {",
          "4637:         event = R_FIXUP_EVENT_BIND;",
          "4638:         ordinal = bind->ordinal;",
          "4639:         addend = bind->addend;",
          "4640:        }",
          "4641:       } else {",
          "4642:        if (bind->auth) {",
          "4643:         struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "4644:           (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "4645:         event = R_FIXUP_EVENT_REBASE_AUTH;",
          "4646:         delta = p->next;",
          "4647:         ptr_value = p->target + bin->baddr;",
          "4648:         key = p->key;",
          "4649:         addr_div = p->addrDiv;",
          "4650:         diversity = p->diversity;",
          "4651:        } else {",
          "4652:         struct dyld_chained_ptr_arm64e_rebase *p =",
          "4653:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "4654:         event = R_FIXUP_EVENT_REBASE;",
          "4655:         delta = p->next;",
          "4656:         ptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);",
          "4657:        }",
          "4658:       }",
          "4659:      } else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {",
          "4660:       stride = 4;",
          "4661:       struct dyld_chained_ptr_64_bind *bind =",
          "4662:         (struct dyld_chained_ptr_64_bind *) &raw_ptr;",
          "4663:       if (bind->bind) {",
          "4664:        event = R_FIXUP_EVENT_BIND;",
          "4665:        delta = bind->next;",
          "4666:        ordinal = bind->ordinal;",
          "4667:        addend = bind->addend;",
          "4668:       } else {",
          "4669:        struct dyld_chained_ptr_64_rebase *p =",
          "4670:         (struct dyld_chained_ptr_64_rebase *) &raw_ptr;",
          "4671:        event = R_FIXUP_EVENT_REBASE;",
          "4672:        delta = p->next;",
          "4673:        ptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);",
          "4674:       }",
          "4675:      } else {",
          "4676:       eprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);",
          "4677:       return;",
          "4678:      }",
          "4679:      if (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {",
          "4680:       bool carry_on;",
          "4681:       switch (event) {",
          "4682:        case R_FIXUP_EVENT_BIND: {",
          "4683:         RFixupBindEventDetails event_details;",
          "4685:         event_details.type = event;",
          "4686:         event_details.bin = bin;",
          "4687:         event_details.offset = cursor;",
          "4688:         event_details.raw_ptr = raw_ptr;",
          "4689:         event_details.ordinal = ordinal;",
          "4690:         event_details.addend = addend;",
          "4692:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4693:         break;",
          "4694:        }",
          "4695:        case R_FIXUP_EVENT_BIND_AUTH: {",
          "4696:         RFixupBindAuthEventDetails event_details;",
          "4698:         event_details.type = event;",
          "4699:         event_details.bin = bin;",
          "4700:         event_details.offset = cursor;",
          "4701:         event_details.raw_ptr = raw_ptr;",
          "4702:         event_details.ordinal = ordinal;",
          "4703:         event_details.key = key;",
          "4704:         event_details.addr_div = addr_div;",
          "4705:         event_details.diversity = diversity;",
          "4707:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4708:         break;",
          "4709:        }",
          "4710:        case R_FIXUP_EVENT_REBASE: {",
          "4711:         RFixupRebaseEventDetails event_details;",
          "4713:         event_details.type = event;",
          "4714:         event_details.bin = bin;",
          "4715:         event_details.offset = cursor;",
          "4716:         event_details.raw_ptr = raw_ptr;",
          "4717:         event_details.ptr_value = ptr_value;",
          "4719:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4720:         break;",
          "4721:        }",
          "4722:        case R_FIXUP_EVENT_REBASE_AUTH: {",
          "4723:         RFixupRebaseAuthEventDetails event_details;",
          "4725:         event_details.type = event;",
          "4726:         event_details.bin = bin;",
          "4727:         event_details.offset = cursor;",
          "4728:         event_details.raw_ptr = raw_ptr;",
          "4729:         event_details.ptr_value = ptr_value;",
          "4730:         event_details.key = key;",
          "4731:         event_details.addr_div = addr_div;",
          "4732:         event_details.diversity = diversity;",
          "4734:         carry_on = callback (context, (RFixupEventDetails *) &event_details);",
          "4735:         break;",
          "4736:        }",
          "4737:        default:",
          "4738:         eprintf (\"Unexpected event while iterating chained fixups\\n\");",
          "4739:         carry_on = false;",
          "4740:       }",
          "4741:       if (!carry_on) {",
          "4742:        return;",
          "4743:       }",
          "4744:      }",
          "4745:      cursor += delta * stride;",
          "4746:      if (!delta) {",
          "4747:       break;",
          "4748:      }",
          "4749:     }",
          "4750:    }",
          "4751:   }",
          "4752:  }",
          "4753: }",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0.h||libr/bin/format/mach0/mach0.h": [
          "File: libr/bin/format/mach0/mach0.h -> libr/bin/format/mach0/mach0.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #define CSSLOT_ENTITLEMENTS  5",
          "37: #define CSSLOT_CMS_SIGNATURE 0x10000",
          "39: struct section_t {",
          "40:  ut64 offset;",
          "41:  ut64 addr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: typedef enum {",
          "40:  R_FIXUP_EVENT_NONE = 0,",
          "41:  R_FIXUP_EVENT_REBASE = 1,",
          "42:  R_FIXUP_EVENT_REBASE_AUTH = 2,",
          "43:  R_FIXUP_EVENT_BIND = 4,",
          "44:  R_FIXUP_EVENT_BIND_AUTH = 8,",
          "45: } RFixupEvent;",
          "47: #define R_FIXUP_EVENT_MASK_BIND_ALL (R_FIXUP_EVENT_BIND | R_FIXUP_EVENT_BIND_AUTH)",
          "48: #define R_FIXUP_EVENT_MASK_REBASE_ALL (R_FIXUP_EVENT_REBASE | R_FIXUP_EVENT_REBASE_AUTH)",
          "49: #define R_FIXUP_EVENT_MASK_ALL (R_FIXUP_EVENT_MASK_BIND_ALL | R_FIXUP_EVENT_MASK_REBASE_ALL)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:  char *compiler;",
          "120:  int nsegs;",
          "121:  struct r_dyld_chained_starts_in_segment **chained_starts;",
          "122:  struct MACH0_(section) *sects;",
          "123:  int nsects;",
          "124:  struct MACH0_(nlist) *symtab;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "134:  struct dyld_chained_fixups_header fixups_header;",
          "135:  ut64 fixups_offset;",
          "136:  ut64 fixups_size;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "180:  bool rebasing_buffer;",
          "181: };",
          "183: void MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf);",
          "184: struct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options);",
          "185: struct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "198: typedef struct {",
          "199:  RFixupEvent type;",
          "200:  struct MACH0_(obj_t) *bin;",
          "201:  ut64 offset;",
          "202:  ut64 raw_ptr;",
          "203: } RFixupEventDetails;",
          "205: typedef struct {",
          "206:  RFixupEvent type;",
          "207:  struct MACH0_(obj_t) *bin;",
          "208:  ut64 offset;",
          "209:  ut64 raw_ptr;",
          "210:  ut64 ordinal;",
          "211:  ut64 addend;",
          "212: } RFixupBindEventDetails;",
          "214: typedef struct {",
          "215:  RFixupEvent type;",
          "216:  struct MACH0_(obj_t) *bin;",
          "217:  ut64 offset;",
          "218:  ut64 raw_ptr;",
          "219:  ut32 ordinal;",
          "220:  ut8 key;",
          "221:  ut8 addr_div;",
          "222:  ut16 diversity;",
          "223: } RFixupBindAuthEventDetails;",
          "225: typedef struct {",
          "226:  RFixupEvent type;",
          "227:  struct MACH0_(obj_t) *bin;",
          "228:  ut64 offset;",
          "229:  ut64 raw_ptr;",
          "230:  ut64 ptr_value;",
          "231: } RFixupRebaseEventDetails;",
          "233: typedef struct {",
          "234:  RFixupEvent type;",
          "235:  struct MACH0_(obj_t) *bin;",
          "236:  ut64 offset;",
          "237:  ut64 raw_ptr;",
          "238:  ut64 ptr_value;",
          "239:  ut8 key;",
          "240:  ut8 addr_div;",
          "241:  ut16 diversity;",
          "242: } RFixupRebaseAuthEventDetails;",
          "244: typedef bool (*RFixupCallback)(void * context, RFixupEventDetails * event_details);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "213: struct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf);",
          "214: void MACH0_(mach_headerfields)(RBinFile *bf);",
          "215: RList *MACH0_(mach_fields)(RBinFile *bf);",
          "216: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "279: void MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *obj, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void *context);",
          "",
          "---------------"
        ],
        "libr/bin/format/mach0/mach0_defines.h||libr/bin/format/mach0/mach0_defines.h": [
          "File: libr/bin/format/mach0/mach0_defines.h -> libr/bin/format/mach0/mach0_defines.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1582:   auth : 1; // == 1",
          "1583: };",
          "1585: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1585: enum {",
          "1586:  DYLD_CHAINED_IMPORT          = 1,",
          "1587:  DYLD_CHAINED_IMPORT_ADDEND   = 2,",
          "1588:  DYLD_CHAINED_IMPORT_ADDEND64 = 3,",
          "1589: };",
          "1591: struct dyld_chained_import {",
          "1592:  uint32_t lib_ordinal : 8,",
          "1593:   weak_import : 1,",
          "1594:   name_offset : 23;",
          "1595: };",
          "1597: struct dyld_chained_import_addend {",
          "1598:  uint32_t lib_ordinal : 8,",
          "1599:   weak_import : 1,",
          "1600:   name_offset : 23;",
          "1601:  int32_t addend;",
          "1602: };",
          "1604: struct dyld_chained_import_addend64 {",
          "1605:  uint64_t lib_ordinal : 16,",
          "1606:   weak_import : 1,",
          "1607:   reserved : 15,",
          "1608:   name_offset : 32;",
          "1609:  uint64_t addend;",
          "1610: };",
          "",
          "---------------"
        ],
        "libr/bin/p/bin_mach0.c||libr/bin/p/bin_mach0.c": [
          "File: libr/bin/p/bin_mach0.c -> libr/bin/p/bin_mach0.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "10: #include \"objc/mach0_classes.h\"",
          "11: #include <ht_uu.h>",
          "15: extern RBinWrite r_bin_write_mach0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: typedef struct {",
          "14:  ut8 *buf;",
          "15:  int count;",
          "16:  ut64 off;",
          "17: } RFixupRebaseContext;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "764:  return result;",
          "765: }",
          "767: static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {",
          "768:  if (obj->rebasing_buffer) {",
          "769:   return;",
          "770:  }",
          "771:  obj->rebasing_buffer = true;",
          "876:  obj->rebasing_buffer = false;",
          "877: }",
          "",
          "[Removed Lines]",
          "772:  ut64 eob = off + count;",
          "773:  int i = 0;",
          "774:  for (; i < obj->nsegs; i++) {",
          "775:   if (!obj->chained_starts[i]) {",
          "776:    continue;",
          "777:   }",
          "778:   int page_size = obj->chained_starts[i]->page_size;",
          "779:   if (page_size < 1) {",
          "780:    page_size = 4096;",
          "781:   }",
          "782:   ut64 start = obj->segs[i].fileoff;",
          "783:   ut64 end = start + obj->segs[i].filesize;",
          "784:   if (end >= off && start <= eob) {",
          "785:    ut64 page_idx = (R_MAX (start, off) - start) / page_size;",
          "786:    ut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;",
          "787:    for (; page_idx <= page_end_idx; page_idx++) {",
          "788:     if (page_idx >= obj->chained_starts[i]->page_count) {",
          "789:      break;",
          "790:     }",
          "791:     ut16 page_start = obj->chained_starts[i]->page_start[page_idx];",
          "792:     if (page_start == DYLD_CHAINED_PTR_START_NONE) {",
          "793:      continue;",
          "794:     }",
          "795:     ut64 cursor = start + page_idx * page_size + page_start;",
          "796:     while (cursor < eob && cursor < end) {",
          "797:      ut8 tmp[8];",
          "798:      if (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {",
          "799:       break;",
          "800:      }",
          "801:      ut64 raw_ptr = r_read_le64 (tmp);",
          "802:      ut64 ptr_value = raw_ptr;",
          "803:      ut64 delta, stride;",
          "804:      ut16 pointer_format = obj->chained_starts[i]->pointer_format;",
          "805:      if (pointer_format == DYLD_CHAINED_PTR_ARM64E) {",
          "806:       stride = 8;",
          "807:       bool is_auth = IS_PTR_AUTH (raw_ptr);",
          "808:       bool is_bind = IS_PTR_BIND (raw_ptr);",
          "809:       if (is_auth && is_bind) {",
          "810:        struct dyld_chained_ptr_arm64e_auth_bind *p =",
          "811:          (struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;",
          "812:        delta = p->next;",
          "813:       } else if (!is_auth && is_bind) {",
          "814:        struct dyld_chained_ptr_arm64e_bind *p =",
          "815:          (struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;",
          "816:        delta = p->next;",
          "817:       } else if (is_auth && !is_bind) {",
          "818:        struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "819:          (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "820:        delta = p->next;",
          "821:        ptr_value = p->target + obj->baddr;",
          "822:       } else {",
          "823:        struct dyld_chained_ptr_arm64e_rebase *p =",
          "824:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "825:        delta = p->next;",
          "826:        ptr_value = ((ut64)p->high8 << 56) | p->target;",
          "827:       }",
          "828:      } else if (pointer_format == DYLD_CHAINED_PTR_ARM64E_USERLAND24) {",
          "829:       stride = 8;",
          "830:       struct dyld_chained_ptr_arm64e_bind24 *bind =",
          "831:         (struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;",
          "832:       if (bind->bind) {",
          "833:        delta = bind->next;",
          "834:       } else {",
          "835:        if (bind->auth) {",
          "836:         struct dyld_chained_ptr_arm64e_auth_rebase *p =",
          "837:           (struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;",
          "838:         delta = p->next;",
          "839:         ptr_value = p->target + obj->baddr;",
          "840:        } else {",
          "841:         struct dyld_chained_ptr_arm64e_rebase *p =",
          "842:          (struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;",
          "843:         delta = p->next;",
          "844:         ptr_value = obj->baddr + (((ut64)p->high8 << 56) | p->target);",
          "845:        }",
          "846:       }",
          "847:      } else if (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {",
          "848:       stride = 4;",
          "849:       struct dyld_chained_ptr_64_bind *bind =",
          "850:         (struct dyld_chained_ptr_64_bind *) &raw_ptr;",
          "851:       if (bind->bind) {",
          "852:        delta = bind->next;",
          "853:       } else {",
          "854:        struct dyld_chained_ptr_64_rebase *p =",
          "855:         (struct dyld_chained_ptr_64_rebase *)&raw_ptr;",
          "856:        delta = p->next;",
          "857:        ptr_value = obj->baddr + (((ut64)p->high8 << 56) | p->target);",
          "858:       }",
          "859:      } else {",
          "860:       eprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);",
          "861:       goto beach;",
          "862:      }",
          "863:      ut64 in_buf = cursor - off;",
          "864:      if (cursor >= off && cursor <= eob - 8) {",
          "865:       r_write_le64 (&buf[in_buf], ptr_value);",
          "866:      }",
          "867:      cursor += delta * stride;",
          "868:      if (!delta) {",
          "869:       break;",
          "870:      }",
          "871:     }",
          "872:    }",
          "873:   }",
          "874:  }",
          "875: beach:",
          "",
          "[Added Lines]",
          "773: static bool rebase_buffer_callback(void * context, RFixupEventDetails * event_details) {",
          "774:  RFixupRebaseContext *ctx = context;",
          "776:  ut64 in_buf = event_details->offset - ctx->off;",
          "777:  switch (event_details->type) {",
          "778:   case R_FIXUP_EVENT_BIND:",
          "779:   case R_FIXUP_EVENT_BIND_AUTH:",
          "780:    r_write_le64 (&ctx->buf[in_buf], 0);",
          "781:    break;",
          "782:   case R_FIXUP_EVENT_REBASE:",
          "783:   case R_FIXUP_EVENT_REBASE_AUTH:",
          "784:    r_write_le64 (&ctx->buf[in_buf], ((RFixupRebaseEventDetails *) event_details)->ptr_value);",
          "785:    break;",
          "786:   default:",
          "787:    eprintf (\"Unexpected event while rebasing buffer\\n\");",
          "788:    return false;",
          "789:  }",
          "791:  return true;",
          "792: }",
          "800:  RFixupRebaseContext ctx;",
          "802:  ctx.buf = buf;",
          "803:  ctx.count = count;",
          "804:  ctx.off = off;",
          "806:  MACH0_(iterate_chained_fixups) (obj, off, off + count, R_FIXUP_EVENT_MASK_ALL, &rebase_buffer_callback, &ctx);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2017-3730",
  "cve_desc": "In OpenSSL 1.1.0 before 1.1.0d, if a malicious server supplies bad parameters for a DHE or ECDHE key exchange then this can result in the client attempting to dereference a NULL pointer leading to a client crash. This could be exploited in a Denial of Service attack.",
  "repo": "openssl/openssl",
  "patch_hash": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
  "patch_info": {
    "commit_hash": "efbe126e3ebb9123ac9d058aa2bb044261342aaa",
    "repo": "openssl/openssl",
    "commit_url": "https://github.com/openssl/openssl/commit/efbe126e3ebb9123ac9d058aa2bb044261342aaa",
    "files": [
      "ssl/statem/statem_clnt.c"
    ],
    "message": "Fix missing NULL checks in CKE processing\n\nReviewed-by: Rich Salz <rsalz@openssl.org>",
    "before_after_code_files": [
      "ssl/statem/statem_clnt.c||ssl/statem/statem_clnt.c"
    ]
  },
  "patch_diff": {
    "ssl/statem/statem_clnt.c||ssl/statem/statem_clnt.c": [
      "File: ssl/statem/statem_clnt.c -> ssl/statem/statem_clnt.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2258:         return 0;",
      "2259:     }",
      "2260:     ckey = ssl_generate_pkey(skey);",
      "2261:     dh_clnt = EVP_PKEY_get0_DH(ckey);",
      "2263:     if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2261:     if (ckey == NULL) {",
      "2262:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);",
      "2263:         return 0;",
      "2264:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2296:     }",
      "2298:     ckey = ssl_generate_pkey(skey);",
      "2300:     if (ssl_derive(s, ckey, skey) == 0) {",
      "2301:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2304:     if (ckey == NULL) {",
      "2305:         SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);",
      "2306:         goto err;",
      "2307:     }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c6720f816f4c9373890939d6ec63a7dc29835fdd",
      "candidate_info": {
        "commit_hash": "c6720f816f4c9373890939d6ec63a7dc29835fdd",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/c6720f816f4c9373890939d6ec63a7dc29835fdd",
        "files": [
          "test/evp_test.c",
          "test/evptests.txt"
        ],
        "message": "Additional error tests in evp_test.c\n\nSupport checking for errors during test initialisation and parsing.\n\nAdd errors and tests for key operation initalisation and ctrl errors.\n\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(cherry picked from commit cce65266299e2e89303a90c131e8171225a1bf88)",
        "before_after_code_files": [
          "test/evp_test.c||test/evp_test.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/evp_test.c||test/evp_test.c": [
          "File: test/evp_test.c -> test/evp_test.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "354:             t->nskip++;",
          "355:         } else {",
          "359:                 fprintf(stderr, \"%s test error line %d\\n\",",
          "360:                         t->meth->name, t->start_line);",
          "361:                 return 0;",
          "",
          "[Removed Lines]",
          "357:             t->err = NULL;",
          "358:             if (t->meth->run_test(t) != 1) {",
          "",
          "[Added Lines]",
          "357:             if (t->err == NULL && t->meth->run_test(t) != 1) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "567:         return 1;",
          "568:     }",
          "569:     t.in = in;",
          "570:     while (BIO_gets(in, buf, sizeof(buf))) {",
          "571:         t.line++;",
          "572:         if (!process_test(&t, buf, 0))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "569:     t.err = NULL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1234:     if (!kdata->ctx)",
          "1235:         return 0;",
          "1236:     if (keyopinit(kdata->ctx) <= 0)",
          "1238:     return 1;",
          "1239: }",
          "",
          "[Removed Lines]",
          "1237:         return 0;",
          "",
          "[Added Lines]",
          "1237:         t->err = \"KEYOP_INIT_ERROR\";",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1260:     if (p != NULL)",
          "1262:     rv = EVP_PKEY_CTX_ctrl_str(pctx, tmpval, p);",
          "1266:             t->skip = 1;",
          "1267:             rv = 1;",
          "1268:         }",
          "1269:     }",
          "1270:     OPENSSL_free(tmpval);",
          "",
          "[Removed Lines]",
          "1263:     if (p != NULL && rv <= 0 && rv != -2) {",
          "1265:         if (OBJ_sn2nid(p) != NID_undef || OBJ_ln2nid(p) != NID_undef) {",
          "",
          "[Added Lines]",
          "1263:     if (rv == -2) {",
          "1264:         t->err = \"PKEY_CTRL_INVALID\";",
          "1265:         rv = 1;",
          "1266:     } else if (p != NULL && rv <= 0) {",
          "1268:         int nid = OBJ_sn2nid(p);",
          "1269:         if (nid == NID_undef)",
          "1270:              nid = OBJ_ln2nid(p);",
          "1271:         if ((nid != NID_undef) && EVP_get_digestbynid(nid) == NULL &&",
          "1272:             EVP_get_cipherbynid(nid) == NULL) {",
          "1275:         } else {",
          "1276:             t->err = \"PKEY_CTRL_ERROR\";",
          "1277:             rv = 1;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e",
      "candidate_info": {
        "commit_hash": "df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/df6b5e29ffea2d5a3e08de92fb765fdb21c7a21e",
        "files": [
          "ssl/statem/statem_dtls.c"
        ],
        "message": "Excessive allocation of memory in dtls1_preprocess_fragment()\n\nThis issue is very similar to CVE-2016-6307 described in the previous\ncommit. The underlying defect is different but the security analysis and\nimpacts are the same except that it impacts DTLS.\n\nA DTLS message includes 3 bytes for its length in the header for the\nmessage.\nThis would allow for messages up to 16Mb in length. Messages of this length\nare excessive and OpenSSL includes a check to ensure that a peer is sending\nreasonably sized messages in order to avoid too much memory being consumed\nto service a connection. A flaw in the logic of version 1.1.0 means that\nmemory for the message is allocated too early, prior to the excessive\nmessage length check. Due to way memory is allocated in OpenSSL this could\nmean an attacker could force up to 21Mb to be allocated to service a\nconnection. This could lead to a Denial of Service through memory\nexhaustion. However, the excessive message length check still takes place,\nand this would cause the connection to immediately fail. Assuming that the\napplication calls SSL_free() on the failed conneciton in a timely manner\nthen the 21Mb of allocated memory will then be immediately freed again.\nTherefore the excessive memory allocation will be transitory in nature.\nThis then means that there is only a security impact if:\n\n1) The application does not call SSL_free() in a timely manner in the\nevent that the connection fails\nor\n2) The application is working in a constrained environment where there\nis very little free memory\nor\n3) The attacker initiates multiple connection attempts such that there\nare multiple connections in a state where memory has been allocated for\nthe connection; SSL_free() has not yet been called; and there is\ninsufficient memory to service the multiple requests.\n\nExcept in the instance of (1) above any Denial Of Service is likely to\nbe transitory because as soon as the connection fails the memory is\nsubsequently freed again in the SSL_free() call. However there is an\nincreased risk during this period of application crashes due to the lack\nof memory - which would then mean a more serious Denial of Service.\n\nThis issue does not affect TLS users.\n\nIssue was reported by Shi Lei (Gear Team, Qihoo 360 Inc.).\n\nCVE-2016-6308\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(cherry picked from commit 48c054fec3506417b2598837b8062aae7114c200)",
        "before_after_code_files": [
          "ssl/statem/statem_dtls.c||ssl/statem/statem_dtls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "ssl/statem/statem_dtls.c||ssl/statem/statem_dtls.c": [
          "File: ssl/statem/statem_dtls.c -> ssl/statem/statem_dtls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "388:     return 1;",
          "389: }",
          "391: static int dtls1_preprocess_fragment(SSL *s, struct hm_header_st *msg_hdr)",
          "392: {",
          "393:     size_t frag_off, frag_len, msg_len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "396: static unsigned long dtls1_max_handshake_message_len(const SSL *s)",
          "397: {",
          "398:     unsigned long max_len =",
          "399:         DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;",
          "400:     if (max_len < (unsigned long)s->max_cert_list)",
          "401:         return s->max_cert_list;",
          "402:     return max_len;",
          "403: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "397:     frag_len = msg_hdr->frag_len;",
          "401:         SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, SSL_R_EXCESSIVE_MESSAGE_SIZE);",
          "402:         return SSL_AD_ILLEGAL_PARAMETER;",
          "403:     }",
          "410:         if (!BUF_MEM_grow_clean(s->init_buf, msg_len + DTLS1_HM_HEADER_LENGTH)) {",
          "411:             SSLerr(SSL_F_DTLS1_PREPROCESS_FRAGMENT, ERR_R_BUF_LIB);",
          "",
          "[Removed Lines]",
          "400:     if ((frag_off + frag_len) > msg_len) {",
          "",
          "[Added Lines]",
          "414:     if ((frag_off + frag_len) > msg_len",
          "415:             || msg_len > dtls1_max_handshake_message_len(s)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "493:         return 0;",
          "494: }",
          "510: static int",
          "511: dtls1_reassemble_fragment(SSL *s, const struct hm_header_st *msg_hdr, int *ok)",
          "512: {",
          "",
          "[Removed Lines]",
          "501: static unsigned long dtls1_max_handshake_message_len(const SSL *s)",
          "502: {",
          "503:     unsigned long max_len =",
          "504:         DTLS1_HM_HEADER_LENGTH + SSL3_RT_MAX_ENCRYPTED_LENGTH;",
          "505:     if (max_len < (unsigned long)s->max_cert_list)",
          "506:         return s->max_cert_list;",
          "507:     return max_len;",
          "508: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6212179e39d5b59092b21d31b45203e6d3aacdaa",
      "candidate_info": {
        "commit_hash": "6212179e39d5b59092b21d31b45203e6d3aacdaa",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/6212179e39d5b59092b21d31b45203e6d3aacdaa",
        "files": [
          "crypto/x509/x509_lcl.h",
          "crypto/x509/x509_vpm.c",
          "doc/crypto/X509_VERIFY_PARAM_set_flags.pod",
          "include/openssl/x509_vfy.h",
          "util/libcrypto.num"
        ],
        "message": "Add X509_VERIFY_PARAM inheritance flag set/get\n\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2079)",
        "before_after_code_files": [
          "crypto/x509/x509_lcl.h||crypto/x509/x509_lcl.h",
          "crypto/x509/x509_vpm.c||crypto/x509/x509_vpm.c",
          "include/openssl/x509_vfy.h||include/openssl/x509_vfy.h",
          "util/libcrypto.num||util/libcrypto.num"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/x509/x509_lcl.h||crypto/x509/x509_lcl.h": [
          "File: crypto/x509/x509_lcl.h -> crypto/x509/x509_lcl.h"
        ],
        "crypto/x509/x509_vpm.c||crypto/x509/x509_vpm.c": [
          "File: crypto/x509/x509_vpm.c -> crypto/x509/x509_vpm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "306:     return param->flags;",
          "307: }",
          "309: int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose)",
          "310: {",
          "311:     return X509_PURPOSE_set(&param->purpose, purpose);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "309: uint32_t X509_VERIFY_PARAM_get_inh_flags(const X509_VERIFY_PARAM *param)",
          "310: {",
          "311:     return param->inh_flags;",
          "312: }",
          "314: int X509_VERIFY_PARAM_set_inh_flags(X509_VERIFY_PARAM *param, uint32_t flags)",
          "315: {",
          "316:     param->inh_flags = flags;",
          "317:     return 1;",
          "318: }",
          "",
          "---------------"
        ],
        "include/openssl/x509_vfy.h||include/openssl/x509_vfy.h": [
          "File: include/openssl/x509_vfy.h -> include/openssl/x509_vfy.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "272: int X509_STORE_set_trust(X509_STORE *ctx, int trust);",
          "273: int X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *pm);",
          "274: X509_VERIFY_PARAM *X509_STORE_get0_param(X509_STORE *ctx);",
          "276: void X509_STORE_set_verify(X509_STORE *ctx, X509_STORE_CTX_verify_fn verify);",
          "277: #define X509_STORE_set_verify_func(ctx, func) \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "275: int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "464: int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param,",
          "465:                                     STACK_OF(ASN1_OBJECT) *policies);",
          "467: int X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,",
          "468:                                 const char *name, size_t namelen);",
          "469: int X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "468: int X509_VERIFY_PARAM_set_inh_flags(X509_VERIFY_PARAM *param,",
          "469:                                     uint32_t flags);",
          "470: uint32_t X509_VERIFY_PARAM_get_inh_flags(const X509_VERIFY_PARAM *param);",
          "",
          "---------------"
        ],
        "util/libcrypto.num||util/libcrypto.num": [
          "File: util/libcrypto.num -> util/libcrypto.num",
          "--- Hunk 1 ---",
          "[Context before]",
          "4210: DSO_dsobyaddr                           4171 1_1_0c EXIST::FUNCTION:",
          "4211: CT_POLICY_EVAL_CTX_get_time             4172 1_1_0d EXIST::FUNCTION:CT",
          "4212: CT_POLICY_EVAL_CTX_set_time             4173 1_1_0d EXIST::FUNCTION:CT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4213: X509_VERIFY_PARAM_set_inh_flags         4174 1_1_0d EXIST::FUNCTION:",
          "4214: X509_VERIFY_PARAM_get_inh_flags         4175 1_1_0d EXIST::FUNCTION:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "90078aa018ca13cf80d7ccaaa15a8360631b5110",
      "candidate_info": {
        "commit_hash": "90078aa018ca13cf80d7ccaaa15a8360631b5110",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/90078aa018ca13cf80d7ccaaa15a8360631b5110",
        "files": [
          "crypto/threads_pthread.c"
        ],
        "message": "Compile fix on platforms with missing pthread_rwlock_t.\n\nFix compilation on platforms with missing pthread_rwlock_t implementation by replacing it with pthread_mutex_t. An example of such platform can be Android OS 2.0 - 2.1, API level 5 (Eclair), Android NDK platform - android-5 where pthread_rwlock_t is not implemented and is missing in pthread.h.\n\nIn case of missing pthread_rwlock_t implementation CRYPTO_RWLOCK will work as exclusive lock in write-only mode of pthread_rwlock_t lock.\n\nThe implementation based on pthread_mutex_t must be using PTHREAD_MUTEX_RECURSIVE mode to be compatible with recursive behavior of pthread_rwlock_rdlock.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1981)\n(cherry picked from commit 2accf3f7e013c3d02312afc27cc2edbd1f149db3)",
        "before_after_code_files": [
          "crypto/threads_pthread.c||crypto/threads_pthread.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "crypto/threads_pthread.c||crypto/threads_pthread.c": [
          "File: crypto/threads_pthread.c -> crypto/threads_pthread.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "12: #if defined(OPENSSL_THREADS) && !defined(CRYPTO_TDEBUG) && !defined(OPENSSL_SYS_WINDOWS)",
          "14: CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void)",
          "15: {",
          "16:     CRYPTO_RWLOCK *lock = OPENSSL_zalloc(sizeof(pthread_rwlock_t));",
          "17:     if (lock == NULL)",
          "18:         return NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: #ifdef PTHREAD_RWLOCK_INITIALIZER",
          "15:     #define OPENSSL_THREADS_HAVE_PTHREAD_RWLOCK",
          "16: #endif",
          "20: #ifdef OPENSSL_THREADS_HAVE_PTHREAD_RWLOCK",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "21:         OPENSSL_free(lock);",
          "22:         return NULL;",
          "23:     }",
          "25:     return lock;",
          "26: }",
          "28: int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock)",
          "29: {",
          "30:     if (pthread_rwlock_rdlock(lock) != 0)",
          "31:         return 0;",
          "33:     return 1;",
          "34: }",
          "36: int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock)",
          "37: {",
          "38:     if (pthread_rwlock_wrlock(lock) != 0)",
          "39:         return 0;",
          "41:     return 1;",
          "42: }",
          "44: int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock)",
          "45: {",
          "46:     if (pthread_rwlock_unlock(lock) != 0)",
          "47:         return 0;",
          "49:     return 1;",
          "50: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #else",
          "30:     CRYPTO_RWLOCK *lock = OPENSSL_zalloc(sizeof(pthread_mutex_t));",
          "31:     if (lock == NULL)",
          "32:         return NULL;",
          "34:     pthread_mutexattr_t attr;",
          "35:     pthread_mutexattr_init(&attr);",
          "36:     pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);",
          "38:     if (pthread_mutex_init(lock, &attr) != 0) {",
          "39:         pthread_mutexattr_destroy(&attr);",
          "40:         OPENSSL_free(lock);",
          "41:         return NULL;",
          "42:     }",
          "44:     pthread_mutexattr_destroy(&attr);",
          "45: #endif",
          "52: #ifdef OPENSSL_THREADS_HAVE_PTHREAD_RWLOCK",
          "55: #else",
          "56:     if (pthread_mutex_lock(lock) != 0)",
          "57:         return 0;",
          "58: #endif",
          "65: #ifdef OPENSSL_THREADS_HAVE_PTHREAD_RWLOCK",
          "68: #else",
          "69:     if (pthread_mutex_lock(lock) != 0)",
          "70:         return 0;",
          "71: #endif",
          "78: #ifdef OPENSSL_THREADS_HAVE_PTHREAD_RWLOCK",
          "81: #else",
          "82:     if (pthread_mutex_unlock(lock) != 0)",
          "83:         return 0;",
          "84: #endif",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:     if (lock == NULL)",
          "55:         return;",
          "57:     pthread_rwlock_destroy(lock);",
          "58:     OPENSSL_free(lock);",
          "60:     return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94: #ifdef OPENSSL_THREADS_HAVE_PTHREAD_RWLOCK",
          "96: #else",
          "97:     pthread_mutex_destroy(lock);",
          "98: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1ee297e52f5df6673742130a20bcef1814f85db4",
      "candidate_info": {
        "commit_hash": "1ee297e52f5df6673742130a20bcef1814f85db4",
        "repo": "openssl/openssl",
        "commit_url": "https://github.com/openssl/openssl/commit/1ee297e52f5df6673742130a20bcef1814f85db4",
        "files": [
          "NOTES.WIN"
        ],
        "message": "Fix typo\n\nI think the second \"VC-WIN32\" should be \"VC-WIN64\".\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nCLA: trivial",
        "before_after_code_files": [
          "NOTES.WIN||NOTES.WIN"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/EktapopaT/openssl/pull/1"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "NOTES.WIN||NOTES.WIN": [
          "File: NOTES.WIN -> NOTES.WIN",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:      PREFIX:      %ProgramFiles(86)%\\OpenSSL",
          "37:      OPENSSLDIR:  %CommonProgramFiles(86)%\\SSL",
          "41:      PREFIX:      %ProgramW6432%\\OpenSSL",
          "42:      OPENSSLDIR:  %CommonProgramW6432%\\SSL",
          "",
          "[Removed Lines]",
          "39:  For VC-WIN32, the following defaults are use:",
          "",
          "[Added Lines]",
          "39:  For VC-WIN64, the following defaults are use:",
          "",
          "---------------"
        ]
      }
    }
  ]
}
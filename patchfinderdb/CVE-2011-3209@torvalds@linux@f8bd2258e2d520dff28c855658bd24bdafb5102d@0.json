{
  "cve_id": "CVE-2011-3209",
  "cve_desc": "The div_long_long_rem implementation in include/asm-x86/div64.h in the Linux kernel before 2.6.26 on the x86 platform allows local users to cause a denial of service (Divide Error Fault and panic) via a clock_gettime system call.",
  "repo": "torvalds/linux",
  "patch_hash": "f8bd2258e2d520dff28c855658bd24bdafb5102d",
  "patch_info": {
    "commit_hash": "f8bd2258e2d520dff28c855658bd24bdafb5102d",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f8bd2258e2d520dff28c855658bd24bdafb5102d",
    "files": [
      "arch/mips/kernel/binfmt_elfn32.c",
      "arch/mips/kernel/binfmt_elfo32.c",
      "drivers/char/mmtimer.c",
      "include/asm-x86/div64.h",
      "include/linux/calc64.h",
      "include/linux/jiffies.h",
      "kernel/posix-cpu-timers.c",
      "kernel/time.c",
      "kernel/time/ntp.c",
      "mm/slub.c"
    ],
    "message": "remove div_long_long_rem\n\nx86 is the only arch right now, which provides an optimized for\ndiv_long_long_rem and it has the downside that one has to be very careful that\nthe divide doesn't overflow.\n\nThe API is a little akward, as the arguments for the unsigned divide are\nsigned.  The signed version also doesn't handle a negative divisor and\nproduces worse code on 64bit archs.\n\nThere is little incentive to keep this API alive, so this converts the few\nusers to the new API.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: Ralf Baechle <ralf@linux-mips.org>\nCc: Ingo Molnar <mingo@elte.hu>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "arch/mips/kernel/binfmt_elfn32.c||arch/mips/kernel/binfmt_elfn32.c",
      "arch/mips/kernel/binfmt_elfo32.c||arch/mips/kernel/binfmt_elfo32.c",
      "drivers/char/mmtimer.c||drivers/char/mmtimer.c",
      "include/asm-x86/div64.h||include/asm-x86/div64.h",
      "include/linux/calc64.h||include/linux/calc64.h",
      "include/linux/jiffies.h||include/linux/jiffies.h",
      "kernel/posix-cpu-timers.c||kernel/posix-cpu-timers.c",
      "kernel/time.c||kernel/time.c",
      "kernel/time/ntp.c||kernel/time/ntp.c",
      "mm/slub.c||mm/slub.c"
    ]
  },
  "patch_diff": {
    "arch/mips/kernel/binfmt_elfn32.c||arch/mips/kernel/binfmt_elfn32.c": [
      "File: arch/mips/kernel/binfmt_elfn32.c -> arch/mips/kernel/binfmt_elfn32.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "54: #include <linux/module.h>",
      "55: #include <linux/elfcore.h>",
      "56: #include <linux/compat.h>",
      "58: #define elf_prstatus elf_prstatus32",
      "59: struct elf_prstatus32",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "57: #include <linux/math64.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "104:  u64 nsec = (u64)jiffies * TICK_NSEC;",
      "107:  value->tv_usec = rem / NSEC_PER_USEC;",
      "108: }",
      "",
      "[Removed Lines]",
      "105:  long rem;",
      "106:  value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);",
      "",
      "[Added Lines]",
      "106:  u32 rem;",
      "107:  value->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);",
      "",
      "---------------"
    ],
    "arch/mips/kernel/binfmt_elfo32.c||arch/mips/kernel/binfmt_elfo32.c": [
      "File: arch/mips/kernel/binfmt_elfo32.c -> arch/mips/kernel/binfmt_elfo32.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "56: #include <linux/module.h>",
      "57: #include <linux/elfcore.h>",
      "58: #include <linux/compat.h>",
      "60: #define elf_prstatus elf_prstatus32",
      "61: struct elf_prstatus32",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "59: #include <linux/math64.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "106:  u64 nsec = (u64)jiffies * TICK_NSEC;",
      "109:  value->tv_usec = rem / NSEC_PER_USEC;",
      "110: }",
      "",
      "[Removed Lines]",
      "107:  long rem;",
      "108:  value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);",
      "",
      "[Added Lines]",
      "108:  u32 rem;",
      "109:  value->tv_sec = div_u64_rem(nsec, NSEC_PER_SEC, &rem);",
      "",
      "---------------"
    ],
    "drivers/char/mmtimer.c||drivers/char/mmtimer.c": [
      "File: drivers/char/mmtimer.c -> drivers/char/mmtimer.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: #include <linux/miscdevice.h>",
      "31: #include <linux/posix-timers.h>",
      "32: #include <linux/interrupt.h>",
      "34: #include <asm/uaccess.h>",
      "35: #include <asm/sn/addrs.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "33: #include <linux/time.h>",
      "34: #include <linux/math64.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "473:  nsec = rtc_time() * sgi_clock_period",
      "474:    + sgi_clock_offset.tv_nsec;",
      "477:  return 0;",
      "478: };",
      "",
      "[Removed Lines]",
      "475:  tp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)",
      "476:    + sgi_clock_offset.tv_sec;",
      "",
      "[Added Lines]",
      "478:  tp->tv_sec += sgi_clock_offset.tv_sec;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "481: {",
      "483:  u64 nsec;",
      "486:  nsec = rtc_time() * sgi_clock_period;",
      "490:  if (rem <= tp->tv_nsec)",
      "491:   sgi_clock_offset.tv_nsec = tp->tv_sec - rem;",
      "",
      "[Removed Lines]",
      "484:  u64 rem;",
      "488:  sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);",
      "",
      "[Added Lines]",
      "486:  u32 rem;",
      "490:  sgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "644:  return 0;",
      "645: }",
      "651: static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)",
      "652: {",
      "",
      "[Removed Lines]",
      "647: #define timespec_to_ns(x) ((x).tv_nsec + (x).tv_sec * NSEC_PER_SEC)",
      "648: #define ns_to_timespec(ts, nsec) (ts).tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &(ts).tv_nsec)",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "659:   return;",
      "660:  }",
      "665: }",
      "",
      "[Removed Lines]",
      "662:  ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);",
      "663:  ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);",
      "664:  return;",
      "",
      "[Added Lines]",
      "661:  cur_setting->it_interval = ns_to_timespec(timr->it.mmtimer.incr * sgi_clock_period);",
      "662:  cur_setting->it_value = ns_to_timespec((timr->it.mmtimer.expires - rtc_time()) * sgi_clock_period);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "679:   sgi_timer_get(timr, old_setting);",
      "681:  sgi_timer_del(timr);",
      "685:  if (when == 0)",
      "",
      "[Removed Lines]",
      "682:  when = timespec_to_ns(new_setting->it_value);",
      "683:  period = timespec_to_ns(new_setting->it_interval);",
      "",
      "[Added Lines]",
      "680:  when = timespec_to_ns(&new_setting->it_value);",
      "681:  period = timespec_to_ns(&new_setting->it_interval);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "695:   unsigned long now;",
      "697:   getnstimeofday(&n);",
      "699:   if (when > now)",
      "700:    when -= now;",
      "701:   else",
      "",
      "[Removed Lines]",
      "698:   now = timespec_to_ns(n);",
      "",
      "[Added Lines]",
      "696:   now = timespec_to_ns(&n);",
      "",
      "---------------"
    ],
    "include/asm-x86/div64.h||include/asm-x86/div64.h": [
      "File: include/asm-x86/div64.h -> include/asm-x86/div64.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "33:  __mod;       \\",
      "34: })",
      "54: static inline u64 div_u64_rem(u64 dividend, u32 divisor, u32 *remainder)",
      "55: {",
      "56:  union {",
      "",
      "[Removed Lines]",
      "42: #define div_long_long_rem(a, b, c) div_ll_X_l_rem(a, b, c)",
      "44: static inline long div_ll_X_l_rem(long long divs, long div, long *rem)",
      "45: {",
      "46:  long dum2;",
      "47:  asm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)",
      "48:      : \"rm\"(div), \"A\"(divs));",
      "50:  return dum2;",
      "52: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "include/linux/calc64.h||include/linux/calc64.h": [
      "File: include/linux/calc64.h -> include/linux/calc64.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "include/linux/jiffies.h||include/linux/jiffies.h": [
      "File: include/linux/jiffies.h -> include/linux/jiffies.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: #ifndef _LINUX_JIFFIES_H",
      "2: #define _LINUX_JIFFIES_H",
      "5: #include <linux/kernel.h>",
      "6: #include <linux/types.h>",
      "7: #include <linux/time.h>",
      "",
      "[Removed Lines]",
      "4: #include <linux/calc64.h>",
      "",
      "[Added Lines]",
      "4: #include <linux/math64.h>",
      "",
      "---------------"
    ],
    "kernel/posix-cpu-timers.c||kernel/posix-cpu-timers.c": [
      "File: kernel/posix-cpu-timers.c -> kernel/posix-cpu-timers.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5: #include <linux/sched.h>",
      "6: #include <linux/posix-timers.h>",
      "8: #include <linux/errno.h>",
      "10: static int check_clock(const clockid_t which_clock)",
      "11: {",
      "",
      "[Removed Lines]",
      "7: #include <asm/uaccess.h>",
      "",
      "[Added Lines]",
      "8: #include <linux/math64.h>",
      "9: #include <asm/uaccess.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "47:           union cpu_time_count cpu,",
      "48:           struct timespec *tp)",
      "49: {",
      "54:   cputime_to_timespec(cpu.cpu, tp);",
      "56: }",
      "58: static inline int cpu_time_before(const clockid_t which_clock,",
      "",
      "[Removed Lines]",
      "50:  if (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {",
      "51:   tp->tv_sec = div_long_long_rem(cpu.sched,",
      "52:             NSEC_PER_SEC, &tp->tv_nsec);",
      "53:  } else {",
      "55:  }",
      "",
      "[Added Lines]",
      "51:  if (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED)",
      "53:  else",
      "",
      "---------------"
    ],
    "kernel/time.c||kernel/time.c": [
      "File: kernel/time.c -> kernel/time.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "392: struct timespec ns_to_timespec(const s64 nsec)",
      "393: {",
      "394:  struct timespec ts;",
      "396:  if (!nsec)",
      "397:   return (struct timespec) {0, 0};",
      "403:  return ts;",
      "404: }",
      "",
      "[Removed Lines]",
      "399:  ts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);",
      "400:  if (unlikely(nsec < 0))",
      "401:   set_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);",
      "",
      "[Added Lines]",
      "395:  s32 rem;",
      "400:  ts.tv_sec = div_s64_rem(nsec, NSEC_PER_SEC, &rem);",
      "401:  if (unlikely(rem < 0)) {",
      "402:   ts.tv_sec--;",
      "403:   rem += NSEC_PER_SEC;",
      "404:  }",
      "405:  ts.tv_nsec = rem;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "533: }",
      "534: EXPORT_SYMBOL(jiffies_to_timespec);",
      "",
      "[Removed Lines]",
      "531:  u64 nsec = (u64)jiffies * TICK_NSEC;",
      "532:  value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);",
      "",
      "[Added Lines]",
      "535:  u32 rem;",
      "536:  value->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
      "537:         NSEC_PER_SEC, &rem);",
      "538:  value->tv_nsec = rem;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "576: }",
      "577: EXPORT_SYMBOL(jiffies_to_timeval);",
      "",
      "[Removed Lines]",
      "570:  u64 nsec = (u64)jiffies * TICK_NSEC;",
      "571:  long tv_usec;",
      "573:  value->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);",
      "574:  tv_usec /= NSEC_PER_USEC;",
      "575:  value->tv_usec = tv_usec;",
      "",
      "[Added Lines]",
      "576:  u32 rem;",
      "578:  value->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,",
      "579:         NSEC_PER_SEC, &rem);",
      "580:  value->tv_usec = rem / NSEC_PER_USEC;",
      "",
      "---------------"
    ],
    "kernel/time/ntp.c||kernel/time/ntp.c": [
      "File: kernel/time/ntp.c -> kernel/time/ntp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "235: int do_adjtimex(struct timex *txc)",
      "236: {",
      "238:  s64 freq_adj;",
      "239:  int result;",
      "",
      "[Removed Lines]",
      "237:  long mtemp, save_adjust, rem;",
      "",
      "[Added Lines]",
      "237:  long mtemp, save_adjust;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "345:       freq_adj += time_freq;",
      "346:       freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);",
      "347:       time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);",
      "351:       time_offset <<= SHIFT_UPDATE;",
      "",
      "[Removed Lines]",
      "348:       time_offset = div_long_long_rem_signed(time_offset,",
      "349:           NTP_INTERVAL_FREQ,",
      "350:           &rem);",
      "",
      "[Added Lines]",
      "348:       time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);",
      "",
      "---------------"
    ],
    "mm/slub.c||mm/slub.c": [
      "File: mm/slub.c -> mm/slub.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "22: #include <linux/debugobjects.h>",
      "23: #include <linux/kallsyms.h>",
      "24: #include <linux/memory.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "25: #include <linux/math64.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3621:    len += sprintf(buf + len, \"<not-available>\");",
      "3623:   if (l->sum_time != l->min_time) {",
      "3626:    len += sprintf(buf + len, \" age=%ld/%ld/%ld\",",
      "3630:   } else",
      "3631:    len += sprintf(buf + len, \" age=%ld\",",
      "3632:     l->min_time);",
      "",
      "[Removed Lines]",
      "3624:    unsigned long remainder;",
      "3627:    l->min_time,",
      "3628:    div_long_long_rem(l->sum_time, l->count, &remainder),",
      "3629:    l->max_time);",
      "",
      "[Added Lines]",
      "3626:     l->min_time,",
      "3627:     (long)div_u64(l->sum_time, l->count),",
      "3628:     l->max_time);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "7dffa3c673fbcf835cd7be80bb4aec8ad3f51168",
      "candidate_info": {
        "commit_hash": "7dffa3c673fbcf835cd7be80bb4aec8ad3f51168",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7dffa3c673fbcf835cd7be80bb4aec8ad3f51168",
        "files": [
          "include/linux/clocksource.h",
          "include/linux/timex.h",
          "kernel/time/ntp.c",
          "kernel/time/timekeeping.c"
        ],
        "message": "ntp: handle leap second via timer\n\nRemove the leap second handling from second_overflow(), which doesn't have to\ncheck for it every second anymore.  With CONFIG_NO_HZ this also makes sure the\nleap second is handled close to the full second.  Additionally this makes it\npossible to abort a leap second properly by resetting the STA_INS/STA_DEL\nstatus bits.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "include/linux/clocksource.h||include/linux/clocksource.h",
          "include/linux/timex.h||include/linux/timex.h",
          "kernel/time/ntp.c||kernel/time/ntp.c",
          "kernel/time/timekeeping.c||kernel/time/timekeeping.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ],
          "candidate": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/clocksource.h||include/linux/clocksource.h": [
          "File: include/linux/clocksource.h -> include/linux/clocksource.h"
        ],
        "include/linux/timex.h||include/linux/timex.h": [
          "File: include/linux/timex.h -> include/linux/timex.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "215: extern void ntp_clear(void);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "215: extern void ntp_init(void);",
          "",
          "---------------"
        ],
        "kernel/time/ntp.c||kernel/time/ntp.c": [
          "File: kernel/time/ntp.c -> kernel/time/ntp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: #include <linux/hrtimer.h>",
          "17: #include <linux/capability.h>",
          "18: #include <linux/math64.h>",
          "19: #include <asm/timex.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: #include <linux/clocksource.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26: u64 tick_length;",
          "27: static u64 tick_length_base;",
          "30: #define MAX_TICKADJ_SCALED (((u64)(MAX_TICKADJ * NSEC_PER_USEC) << \\",
          "31:       NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: static struct hrtimer leap_timer;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "120: }",
          "131: {",
          "148:  switch (time_state) {",
          "149:  case TIME_OK:",
          "154:   break;",
          "155:  case TIME_INS:",
          "163:   break;",
          "164:  case TIME_DEL:",
          "173:   break;",
          "174:  case TIME_OOP:",
          "175:   time_tai++;",
          "176:   time_state = TIME_WAIT;",
          "178:  case TIME_WAIT:",
          "179:   if (!(time_status & (STA_INS | STA_DEL)))",
          "180:    time_state = TIME_OK;",
          "181:  }",
          "",
          "[Removed Lines]",
          "130: void second_overflow(void)",
          "132:  s64 time_adj;",
          "135:  time_maxerror += MAXFREQ / NSEC_PER_USEC;",
          "136:  if (time_maxerror > NTP_PHASE_LIMIT) {",
          "137:   time_maxerror = NTP_PHASE_LIMIT;",
          "138:   time_status |= STA_UNSYNC;",
          "139:  }",
          "150:   if (time_status & STA_INS)",
          "151:    time_state = TIME_INS;",
          "152:   else if (time_status & STA_DEL)",
          "153:    time_state = TIME_DEL;",
          "156:   if (xtime.tv_sec % 86400 == 0) {",
          "157:    xtime.tv_sec--;",
          "158:    wall_to_monotonic.tv_sec++;",
          "159:    time_state = TIME_OOP;",
          "160:    printk(KERN_NOTICE \"Clock: inserting leap second \"",
          "161:      \"23:59:60 UTC\\n\");",
          "162:   }",
          "165:   if ((xtime.tv_sec + 1) % 86400 == 0) {",
          "166:    xtime.tv_sec++;",
          "167:    time_tai--;",
          "168:    wall_to_monotonic.tv_sec--;",
          "169:    time_state = TIME_WAIT;",
          "170:    printk(KERN_NOTICE \"Clock: deleting leap second \"",
          "171:      \"23:59:59 UTC\\n\");",
          "172:   }",
          "177:   break;",
          "",
          "[Added Lines]",
          "130: static enum hrtimer_restart ntp_leap_second(struct hrtimer *timer)",
          "132:  enum hrtimer_restart res = HRTIMER_NORESTART;",
          "134:  write_seqlock_irq(&xtime_lock);",
          "140:   xtime.tv_sec--;",
          "141:   wall_to_monotonic.tv_sec++;",
          "142:   time_state = TIME_OOP;",
          "143:   printk(KERN_NOTICE \"Clock: \"",
          "144:          \"inserting leap second 23:59:60 UTC\\n\");",
          "145:   leap_timer.expires = ktime_add_ns(leap_timer.expires,",
          "146:         NSEC_PER_SEC);",
          "147:   res = HRTIMER_RESTART;",
          "150:   xtime.tv_sec++;",
          "151:   time_tai--;",
          "152:   wall_to_monotonic.tv_sec--;",
          "153:   time_state = TIME_WAIT;",
          "154:   printk(KERN_NOTICE \"Clock: \"",
          "155:          \"deleting leap second 23:59:59 UTC\\n\");",
          "164:   break;",
          "165:  }",
          "166:  update_vsyscall(&xtime, clock);",
          "168:  write_sequnlock_irq(&xtime_lock);",
          "170:  return res;",
          "171: }",
          "181: void second_overflow(void)",
          "182: {",
          "183:  s64 time_adj;",
          "186:  time_maxerror += MAXFREQ / NSEC_PER_USEC;",
          "187:  if (time_maxerror > NTP_PHASE_LIMIT) {",
          "188:   time_maxerror = NTP_PHASE_LIMIT;",
          "189:   time_status |= STA_UNSYNC;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "268: int do_adjtimex(struct timex *txc)",
          "269: {",
          "270:  struct timespec ts;",
          "272:  int result;",
          "",
          "[Removed Lines]",
          "271:  long save_adjust;",
          "",
          "[Added Lines]",
          "280:  long save_adjust, sec;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "289:       txc->tick > 1100000/USER_HZ)",
          "290:    return -EINVAL;",
          "292:  write_seqlock_irq(&xtime_lock);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "301:  if (time_state != TIME_OK && txc->modes & ADJ_STATUS)",
          "302:   hrtimer_cancel(&leap_timer);",
          "303:  getnstimeofday(&ts);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "306:    time_status &= STA_RONLY;",
          "307:    time_status |= txc->status & ~STA_RONLY;",
          "308:   }",
          "310:   if (txc->modes & ADJ_NANO)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "322:    switch (time_state) {",
          "323:    case TIME_OK:",
          "324:    start_timer:",
          "325:     sec = ts.tv_sec;",
          "326:     if (time_status & STA_INS) {",
          "327:      time_state = TIME_INS;",
          "328:      sec += 86400 - sec % 86400;",
          "329:      hrtimer_start(&leap_timer, ktime_set(sec, 0), HRTIMER_MODE_ABS);",
          "330:     } else if (time_status & STA_DEL) {",
          "331:      time_state = TIME_DEL;",
          "332:      sec += 86400 - (sec + 1) % 86400;",
          "333:      hrtimer_start(&leap_timer, ktime_set(sec, 0), HRTIMER_MODE_ABS);",
          "334:     }",
          "335:     break;",
          "336:    case TIME_INS:",
          "337:    case TIME_DEL:",
          "338:     time_state = TIME_OK;",
          "339:     goto start_timer;",
          "340:     break;",
          "341:    case TIME_WAIT:",
          "342:     if (!(time_status & (STA_INS | STA_DEL)))",
          "343:      time_state = TIME_OK;",
          "344:     break;",
          "345:    case TIME_OOP:",
          "346:     hrtimer_restart(&leap_timer);",
          "347:     break;",
          "348:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "384:  txc->stbcnt    = 0;",
          "385:  write_sequnlock_irq(&xtime_lock);",
          "388:  txc->time.tv_sec = ts.tv_sec;",
          "389:  txc->time.tv_usec = ts.tv_nsec;",
          "390:  if (!(time_status & STA_NANO))",
          "",
          "[Removed Lines]",
          "387:  getnstimeofday(&ts);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "402: }",
          "404: __setup(\"ntp_tick_adj=\", ntp_tick_adj_setup);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "446: void __init ntp_init(void)",
          "447: {",
          "448:  ntp_clear();",
          "449:  hrtimer_init(&leap_timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);",
          "450:  leap_timer.function = ntp_leap_second;",
          "451: }",
          "",
          "---------------"
        ],
        "kernel/time/timekeeping.c||kernel/time/timekeeping.c": [
          "File: kernel/time/timekeeping.c -> kernel/time/timekeeping.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:  timespec_add_ns(&xtime_cache, nsec);",
          "54: }",
          "59: #ifdef CONFIG_GENERIC_TIME",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56: struct clocksource *clock;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "247:  write_seqlock_irqsave(&xtime_lock, flags);",
          "251:  clock = clocksource_get_next();",
          "252:  clocksource_calculate_interval(clock, NTP_INTERVAL_LENGTH);",
          "",
          "[Removed Lines]",
          "249:  ntp_clear();",
          "",
          "[Added Lines]",
          "249:  ntp_init();",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "45edfa580b8e638c44ec26872bfe75b307ba12d1",
      "candidate_info": {
        "commit_hash": "45edfa580b8e638c44ec26872bfe75b307ba12d1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/45edfa580b8e638c44ec26872bfe75b307ba12d1",
        "files": [
          "mm/slub.c"
        ],
        "message": "SLUB: include lifetime stats and sets of cpus / nodes in tracking output\n\nWe have information about how long an object existed and about the nodes and\ncpus where the allocations and frees took place.  Add that information to the\ntracking output in /sys/slab/xx/alloc_calls and /sys/slab/free_calls\n\nThis will then enable slabinfo to output nice reports like this:\n\n  christoph@qirst:~/slub$ ./slabinfo kmalloc-128\n\n  Slabcache: kmalloc-128           Aliases:  0 Order :  0\n\n  Sizes (bytes)     Slabs              Debug                Memory\n  ------------------------------------------------------------------------\n  Object :     128  Total  :      12   Sanity Checks : On   Total:   49152\n  SlabObj:     200  Full   :       7   Redzoning     : On   Used :   24832\n  SlabSiz:    4096  Partial:       4   Poisoning     : On   Loss :   24320\n  Loss   :      72  CpuSlab:       1   Tracking      : On   Lalig:   13968\n  Align  :       8  Objects:      20   Tracing       : Off  Lpadd:    1152\n\n  kmalloc-128 has no kmem_cache operations\n\n  kmalloc-128: Kernel object allocation\n  -----------------------------------------------------------------------\n        6 param_sysfs_setup+0x71/0x130 age=284512/284512/284512 pid=1 nodes=0-1,3\n       11 percpu_populate+0x39/0x80 age=283914/284428/284512 pid=1 nodes=0\n       21 __register_chrdev_region+0x31/0x170 age=282896/284347/284473 pid=1-1705 nodes=0-2\n        1 sys_inotify_init+0x76/0x1c0 age=283423 pid=1004 nodes=0\n       19 as_get_io_context+0x32/0xd0 age=6/247567/283988 pid=1-11782 nodes=0,2\n       10 ida_pre_get+0x4a/0x80 age=277666/283773/284526 pid=0-2177 nodes=0,2\n       24 kobject_kset_add_dir+0x37/0xb0 age=282727/283860/284472 pid=1-1723 nodes=0-2\n        1 acpi_ds_build_internal_buffer_obj+0xd3/0x11d age=284508 pid=1 nodes=0\n       24 con_insert_unipair+0xd7/0x110 age=284438/284438/284438 pid=1 nodes=0,2\n        1 uart_open+0x2d2/0x4b0 age=283896 pid=1 nodes=0\n       26 dma_pool_create+0x73/0x1a0 age=282762/282833/282916 pid=1705-1723 nodes=0\n        1 neigh_table_init_no_netlink+0xd2/0x210 age=284461 pid=1 nodes=0\n        2 neigh_parms_alloc+0x2b/0xe0 age=284410/284411/284412 pid=1 nodes=2\n        2 neigh_resolve_output+0x1e1/0x280 age=276289/276291/276293 pid=0-2443 nodes=0\n        1 netlink_kernel_create+0x90/0x170 age=284472 pid=1 nodes=0\n        4 xt_alloc_table_info+0x39/0xf0 age=283958/283958/283959 pid=1 nodes=1\n        3 fn_hash_insert+0x473/0x720 age=277653/277661/277666 pid=2177-2185 nodes=0\n        1 get_mtrr_state+0x285/0x2a0 age=284526 pid=0 nodes=0\n        1 cacheinfo_cpu_callback+0x26d/0x3e0 age=284458 pid=1 nodes=0\n       29 kernel_param_sysfs_setup+0x25/0x90 age=284511/284511/284512 pid=1 nodes=0-1,3\n        5 process_zones+0x5e/0x170 age=284546/284546/284546 pid=0 nodes=0\n        1 drm_core_init+0x48/0x160 age=284421 pid=1 nodes=2\n\n  kmalloc-128: Kernel object freeing\n  ------------------------------------------------------------------------\n      163 <not-available> age=4295176847 pid=0 nodes=0-3\n        1 __vunmap+0x6e/0xf0 age=282907 pid=1723 nodes=0\n       28 free_as_io_context+0x12/0x90 age=9243/262197/283474 pid=42-11754 nodes=0\n        1 acpi_get_object_info+0x1b7/0x1d4 age=284475 pid=1 nodes=0\n        1 do_acpi_find_child+0x45/0x4e age=284475 pid=1 nodes=0\n\n  NUMA nodes           :    0    1    2    3\n  ------------------------------------------\n  All slabs                 7    2    2    1\n  Partial slabs             2    2    0    0\n\nSigned-off-by: Christoph Lameter <clameter@sgi.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/slub.c||mm/slub.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "mm/slub.c||mm/slub.c"
          ],
          "candidate": [
            "mm/slub.c||mm/slub.c"
          ]
        }
      },
      "candidate_diff": {
        "mm/slub.c||mm/slub.c": [
          "File: mm/slub.c -> mm/slub.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1586:    order < MAX_ORDER; order++) {",
          "1587:   unsigned long slab_size = PAGE_SIZE << order;",
          "1590:     slab_size < slub_min_objects * size)",
          "1591:    continue;",
          "1593:   if (slab_size < size)",
          "1594:    continue;",
          "1596:   rem = slab_size % size;",
          "1598:   if (rem <= slab_size / 8)",
          "",
          "[Removed Lines]",
          "1589:   if (slub_max_order > order &&",
          "",
          "[Added Lines]",
          "1589:   if (order < slub_max_order &&",
          "1596:   if (order >= slub_max_order)",
          "1597:    break;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2751: struct location {",
          "2752:  unsigned long count;",
          "2753:  void *addr;",
          "2754: };",
          "2756: struct loc_track {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2757:  long long sum_time;",
          "2758:  long min_time;",
          "2759:  long max_time;",
          "2760:  long min_pid;",
          "2761:  long max_pid;",
          "2762:  cpumask_t cpus;",
          "2763:  nodemask_t nodes;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2791: }",
          "2793: static int add_location(struct loc_track *t, struct kmem_cache *s,",
          "2795: {",
          "2796:  long start, end, pos;",
          "2797:  struct location *l;",
          "2798:  void *caddr;",
          "2800:  start = -1;",
          "2801:  end = t->count;",
          "",
          "[Removed Lines]",
          "2794:       void *addr)",
          "",
          "[Added Lines]",
          "2804:     const struct track *track)",
          "2809:  unsigned long age = jiffies - track->when;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2811:    break;",
          "2813:   caddr = t->loc[pos].addr;",
          "2816:    return 1;",
          "2817:   }",
          "2820:    end = pos;",
          "2821:   else",
          "2822:    start = pos;",
          "",
          "[Removed Lines]",
          "2814:   if (addr == caddr) {",
          "2815:    t->loc[pos].count++;",
          "2819:   if (addr < caddr)",
          "",
          "[Added Lines]",
          "2825:   if (track->addr == caddr) {",
          "2827:    l = &t->loc[pos];",
          "2828:    l->count++;",
          "2829:    if (track->when) {",
          "2830:     l->sum_time += age;",
          "2831:     if (age < l->min_time)",
          "2832:      l->min_time = age;",
          "2833:     if (age > l->max_time)",
          "2834:      l->max_time = age;",
          "2836:     if (track->pid < l->min_pid)",
          "2837:      l->min_pid = track->pid;",
          "2838:     if (track->pid > l->max_pid)",
          "2839:      l->max_pid = track->pid;",
          "2841:     cpu_set(track->cpu, l->cpus);",
          "2842:    }",
          "2843:    node_set(page_to_nid(virt_to_page(track)), l->nodes);",
          "2847:   if (track->addr < caddr)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2834:    (t->count - pos) * sizeof(struct location));",
          "2835:  t->count++;",
          "2836:  l->count = 1;",
          "2838:  return 1;",
          "2839: }",
          "",
          "[Removed Lines]",
          "2837:  l->addr = addr;",
          "",
          "[Added Lines]",
          "2865:  l->addr = track->addr;",
          "2866:  l->sum_time = age;",
          "2867:  l->min_time = age;",
          "2868:  l->max_time = age;",
          "2869:  l->min_pid = track->pid;",
          "2870:  l->max_pid = track->pid;",
          "2871:  cpus_clear(l->cpus);",
          "2872:  cpu_set(track->cpu, l->cpus);",
          "2873:  nodes_clear(l->nodes);",
          "2874:  node_set(page_to_nid(virt_to_page(track)), l->nodes);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2850:   set_bit(slab_index(p, s, addr), map);",
          "2852:  for_each_object(p, s, addr)",
          "2858: }",
          "2860: static int list_locations(struct kmem_cache *s, char *buf,",
          "",
          "[Removed Lines]",
          "2853:   if (!test_bit(slab_index(p, s, addr), map)) {",
          "2854:    void *addr = get_track(s, p, alloc)->addr;",
          "2856:    add_location(t, s, addr);",
          "2857:   }",
          "",
          "[Added Lines]",
          "2890:   if (!test_bit(slab_index(p, s, addr), map))",
          "2891:    add_location(t, s, get_track(s, p, alloc));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2888:  }",
          "2890:  for (i = 0; i < t.count; i++) {",
          "2893:   if (n > PAGE_SIZE - 100)",
          "2894:    break;",
          "2898:   else",
          "2899:    n += sprintf(buf + n, \"<not-available>\");",
          "2900:   n += sprintf(buf + n, \"\\n\");",
          "2901:  }",
          "",
          "[Removed Lines]",
          "2891:   void *addr = t.loc[i].addr;",
          "2895:   n += sprintf(buf + n, \"%7ld \", t.loc[i].count);",
          "2896:   if (addr)",
          "2897:    n += sprint_symbol(buf + n, (unsigned long)t.loc[i].addr);",
          "",
          "[Added Lines]",
          "2925:   struct location *l = &t.loc[i];",
          "2929:   n += sprintf(buf + n, \"%7ld \", l->count);",
          "2931:   if (l->addr)",
          "2932:    n += sprint_symbol(buf + n, (unsigned long)l->addr);",
          "2936:   if (l->sum_time != l->min_time) {",
          "2937:    unsigned long remainder;",
          "2939:    n += sprintf(buf + n, \" age=%ld/%ld/%ld\",",
          "2940:    l->min_time,",
          "2941:    div_long_long_rem(l->sum_time, l->count, &remainder),",
          "2942:    l->max_time);",
          "2943:   } else",
          "2944:    n += sprintf(buf + n, \" age=%ld\",",
          "2945:     l->min_time);",
          "2947:   if (l->min_pid != l->max_pid)",
          "2948:    n += sprintf(buf + n, \" pid=%ld-%ld\",",
          "2949:     l->min_pid, l->max_pid);",
          "2950:   else",
          "2951:    n += sprintf(buf + n, \" pid=%ld\",",
          "2952:     l->min_pid);",
          "2954:   if (num_online_cpus() > 1 && !cpus_empty(l->cpus)) {",
          "2955:    n += sprintf(buf + n, \" cpus=\");",
          "2956:    n += cpulist_scnprintf(buf + n, PAGE_SIZE - n - 50,",
          "2957:      l->cpus);",
          "2958:   }",
          "2960:   if (num_online_nodes() > 1 && !nodes_empty(l->nodes)) {",
          "2961:    n += sprintf(buf + n, \" nodes=\");",
          "2962:    n += nodelist_scnprintf(buf + n, PAGE_SIZE - n - 50,",
          "2963:      l->nodes);",
          "2964:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80f2257116474ceed5fccab510b4f7245c0f49d7",
      "candidate_info": {
        "commit_hash": "80f2257116474ceed5fccab510b4f7245c0f49d7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/80f2257116474ceed5fccab510b4f7245c0f49d7",
        "files": [
          "kernel/time/ntp.c"
        ],
        "message": "time: ntp: refactor do_adjtimex()\n\nImpact: cleanup, no functionality changed\n\ndo_adjtimex() is currently a monster function with a maze of\nbranches. Refactor the txc->modes setting aspects of it into\ntwo new helper functions:\n\n\tprocess_adj_status()\n\tprocess_adjtimex_modes()\n\nkernel/time/ntp.o:\n\n   text\t   data\t    bss\t    dec\t    hex\tfilename\n   2512\t    114\t    136\t   2762\t    aca\tntp.o.before\n   2512\t    114\t    136\t   2762\t    aca\tntp.o.after\n\nSigned-off-by: Ingo Molnar <mingo@elte.hu>",
        "before_after_code_files": [
          "kernel/time/ntp.c||kernel/time/ntp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ],
          "candidate": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/time/ntp.c||kernel/time/ntp.c": [
          "File: kernel/time/ntp.c -> kernel/time/ntp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "332: static inline void notify_cmos_timer(void) { }",
          "333: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "339: static inline void process_adj_status(struct timex *txc, struct timespec *ts)",
          "340: {",
          "341:  long now;",
          "343:  if ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {",
          "344:   time_state = TIME_OK;",
          "345:   time_status = STA_UNSYNC;",
          "346:  }",
          "348:  time_status &= STA_RONLY;",
          "354:  if (!(time_status & STA_PLL) && (txc->status & STA_PLL))",
          "355:   time_reftime = xtime.tv_sec;",
          "357:  time_status |= txc->status & ~STA_RONLY;",
          "359:  switch (time_state) {",
          "360:  case TIME_OK:",
          "361:  start_timer:",
          "362:   now = ts->tv_sec;",
          "363:   if (time_status & STA_INS) {",
          "364:    time_state = TIME_INS;",
          "365:    now += 86400 - now % 86400;",
          "366:    hrtimer_start(&leap_timer, ktime_set(now, 0), HRTIMER_MODE_ABS);",
          "367:   } else if (time_status & STA_DEL) {",
          "368:    time_state = TIME_DEL;",
          "369:    now += 86400 - (now + 1) % 86400;",
          "370:    hrtimer_start(&leap_timer, ktime_set(now, 0), HRTIMER_MODE_ABS);",
          "371:   }",
          "372:   break;",
          "373:  case TIME_INS:",
          "374:  case TIME_DEL:",
          "375:   time_state = TIME_OK;",
          "376:   goto start_timer;",
          "377:  case TIME_WAIT:",
          "378:   if (!(time_status & (STA_INS | STA_DEL)))",
          "379:    time_state = TIME_OK;",
          "380:   break;",
          "381:  case TIME_OOP:",
          "382:   hrtimer_restart(&leap_timer);",
          "383:   break;",
          "384:  }",
          "385: }",
          "390: static inline void process_adjtimex_modes(struct timex *txc, struct timespec *ts)",
          "391: {",
          "392:  if (txc->modes & ADJ_STATUS)",
          "393:   process_adj_status(txc, ts);",
          "395:  if (txc->modes & ADJ_NANO)",
          "396:   time_status |= STA_NANO;",
          "397:  if (txc->modes & ADJ_MICRO)",
          "398:   time_status &= ~STA_NANO;",
          "400:  if (txc->modes & ADJ_FREQUENCY) {",
          "401:   time_freq = (s64)txc->freq * PPM_SCALE;",
          "402:   time_freq = min(time_freq, MAXFREQ_SCALED);",
          "403:   time_freq = max(time_freq, -MAXFREQ_SCALED);",
          "404:  }",
          "406:  if (txc->modes & ADJ_MAXERROR)",
          "407:   time_maxerror = txc->maxerror;",
          "408:  if (txc->modes & ADJ_ESTERROR)",
          "409:   time_esterror = txc->esterror;",
          "411:  if (txc->modes & ADJ_TIMECONST) {",
          "412:   time_constant = txc->constant;",
          "413:   if (!(time_status & STA_NANO))",
          "414:    time_constant += 4;",
          "415:   time_constant = min(time_constant, (long)MAXTC);",
          "416:   time_constant = max(time_constant, 0l);",
          "417:  }",
          "419:  if (txc->modes & ADJ_TAI && txc->constant > 0)",
          "420:   time_tai = txc->constant;",
          "422:  if (txc->modes & ADJ_OFFSET)",
          "423:   ntp_update_offset(txc->offset);",
          "424:  if (txc->modes & ADJ_TICK)",
          "425:   tick_usec = txc->tick;",
          "427:  if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))",
          "428:   ntp_update_frequency();",
          "429: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "383:   txc->offset = save_adjust;",
          "384:   goto adj_done;",
          "385:  }",
          "471:  txc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,",
          "472:       NTP_SCALE_SHIFT);",
          "",
          "[Removed Lines]",
          "386:  if (txc->modes) {",
          "387:   long sec;",
          "389:   if (txc->modes & ADJ_STATUS) {",
          "390:    if ((time_status & STA_PLL) &&",
          "391:        !(txc->status & STA_PLL)) {",
          "392:     time_state = TIME_OK;",
          "393:     time_status = STA_UNSYNC;",
          "394:    }",
          "396:    time_status &= STA_RONLY;",
          "401:    if (!(time_status & STA_PLL) && (txc->status & STA_PLL))",
          "402:     time_reftime = xtime.tv_sec;",
          "404:    time_status |= txc->status & ~STA_RONLY;",
          "406:    switch (time_state) {",
          "407:    case TIME_OK:",
          "408:    start_timer:",
          "409:     sec = ts.tv_sec;",
          "410:     if (time_status & STA_INS) {",
          "411:      time_state = TIME_INS;",
          "412:      sec += 86400 - sec % 86400;",
          "413:      hrtimer_start(&leap_timer, ktime_set(sec, 0), HRTIMER_MODE_ABS);",
          "414:     } else if (time_status & STA_DEL) {",
          "415:      time_state = TIME_DEL;",
          "416:      sec += 86400 - (sec + 1) % 86400;",
          "417:      hrtimer_start(&leap_timer, ktime_set(sec, 0), HRTIMER_MODE_ABS);",
          "418:     }",
          "419:     break;",
          "420:    case TIME_INS:",
          "421:    case TIME_DEL:",
          "422:     time_state = TIME_OK;",
          "423:     goto start_timer;",
          "424:     break;",
          "425:    case TIME_WAIT:",
          "426:     if (!(time_status & (STA_INS | STA_DEL)))",
          "427:      time_state = TIME_OK;",
          "428:     break;",
          "429:    case TIME_OOP:",
          "430:     hrtimer_restart(&leap_timer);",
          "431:     break;",
          "432:    }",
          "433:   }",
          "435:   if (txc->modes & ADJ_NANO)",
          "436:    time_status |= STA_NANO;",
          "437:   if (txc->modes & ADJ_MICRO)",
          "438:    time_status &= ~STA_NANO;",
          "440:   if (txc->modes & ADJ_FREQUENCY) {",
          "441:    time_freq = (s64)txc->freq * PPM_SCALE;",
          "442:    time_freq = min(time_freq, MAXFREQ_SCALED);",
          "443:    time_freq = max(time_freq, -MAXFREQ_SCALED);",
          "444:   }",
          "446:   if (txc->modes & ADJ_MAXERROR)",
          "447:    time_maxerror = txc->maxerror;",
          "448:   if (txc->modes & ADJ_ESTERROR)",
          "449:    time_esterror = txc->esterror;",
          "451:   if (txc->modes & ADJ_TIMECONST) {",
          "452:    time_constant = txc->constant;",
          "453:    if (!(time_status & STA_NANO))",
          "454:     time_constant += 4;",
          "455:    time_constant = min(time_constant, (long)MAXTC);",
          "456:    time_constant = max(time_constant, 0l);",
          "457:   }",
          "459:   if (txc->modes & ADJ_TAI && txc->constant > 0)",
          "460:    time_tai = txc->constant;",
          "462:   if (txc->modes & ADJ_OFFSET)",
          "463:    ntp_update_offset(txc->offset);",
          "464:   if (txc->modes & ADJ_TICK)",
          "465:    tick_usec = txc->tick;",
          "467:   if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))",
          "468:    ntp_update_frequency();",
          "469:  }",
          "",
          "[Added Lines]",
          "484:  if (txc->modes)",
          "485:   process_adjtimex_modes(txc, &ts);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "074b3b87941c99bc0ce35385b5817924b1ed0c23",
      "candidate_info": {
        "commit_hash": "074b3b87941c99bc0ce35385b5817924b1ed0c23",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/074b3b87941c99bc0ce35385b5817924b1ed0c23",
        "files": [
          "arch/powerpc/kernel/time.c",
          "include/linux/timex.h",
          "kernel/time/ntp.c"
        ],
        "message": "ntp: increase time_freq resolution\n\nThis changes time_freq to a 64bit value and makes it static (the only outside\nuser had no real need to modify it).  Intermediate values were already 64bit,\nso the change isn't that big, but it saves a little in shifts by replacing\nSHIFT_NSEC with TICK_LENGTH_SHIFT.  PPM_SCALE is then used to convert between\nuser space and kernel space representation.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "arch/powerpc/kernel/time.c||arch/powerpc/kernel/time.c",
          "include/linux/timex.h||include/linux/timex.h",
          "kernel/time/ntp.c||kernel/time/ntp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ],
          "candidate": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/powerpc/kernel/time.c||arch/powerpc/kernel/time.c": [
          "File: arch/powerpc/kernel/time.c -> arch/powerpc/kernel/time.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1007:  vdso_data->stamp_xsec = (u64) xtime.tv_sec * XSEC_PER_SEC;",
          "1008:  vdso_data->tb_to_xs = tb_to_xs;",
          "1012:  write_sequnlock_irqrestore(&xtime_lock, flags);",
          "",
          "[Removed Lines]",
          "1010:  time_freq = 0;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "include/linux/timex.h||include/linux/timex.h": [
          "File: include/linux/timex.h -> include/linux/timex.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "89: #define PPM_SCALE (NSEC_PER_USEC << (TICK_LENGTH_SHIFT - SHIFT_USEC))",
          "90: #define PPM_SCALE_INV_SHIFT 20",
          "91: #define PPM_SCALE_INV ((1ll << (PPM_SCALE_INV_SHIFT + TICK_LENGTH_SHIFT)) / \\",
          "92:          PPM_SCALE + 1)",
          "96: #define MAXFREQ_SCALED ((s64)MAXFREQ << TICK_LENGTH_SHIFT)",
          "",
          "---------------"
        ],
        "kernel/time/ntp.c||kernel/time/ntp.c": [
          "File: kernel/time/ntp.c -> kernel/time/ntp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "49:  u64 second_length = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)",
          "50:     << TICK_LENGTH_SHIFT;",
          "51:  second_length += (s64)ntp_tick_adj << TICK_LENGTH_SHIFT;",
          "54:  tick_length_base = second_length;",
          "",
          "[Removed Lines]",
          "52:  second_length += (s64)time_freq << (TICK_LENGTH_SHIFT - SHIFT_NSEC);",
          "",
          "[Added Lines]",
          "52:  second_length += time_freq;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "86:  time_reftime = xtime.tv_sec;",
          "88:  freq_adj = time_offset * mtemp;",
          "91:  time_status &= ~STA_MODE;",
          "92:  if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC)) {",
          "94:   time_status |= STA_MODE;",
          "95:  }",
          "96:  freq_adj += time_freq;",
          "99:  time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);",
          "100:  time_offset <<= SHIFT_UPDATE;",
          "101: }",
          "",
          "[Removed Lines]",
          "89:  freq_adj = shift_right(freq_adj, time_constant * 2 +",
          "90:       (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);",
          "93:   freq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);",
          "97:  freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);",
          "98:  time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);",
          "",
          "[Added Lines]",
          "89:  freq_adj <<= TICK_LENGTH_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant);",
          "92:   freq_adj += div_s64(time_offset << (TICK_LENGTH_SHIFT - SHIFT_FLL),",
          "93:         mtemp);",
          "97:  freq_adj = min(freq_adj, MAXFREQ_SCALED);",
          "98:  time_freq = max(freq_adj, -MAXFREQ_SCALED);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "131:  long time_adj;",
          "135:  if (time_maxerror > NTP_PHASE_LIMIT) {",
          "136:   time_maxerror = NTP_PHASE_LIMIT;",
          "137:   time_status |= STA_UNSYNC;",
          "",
          "[Removed Lines]",
          "134:  time_maxerror += MAXFREQ >> SHIFT_USEC;",
          "",
          "[Added Lines]",
          "134:  time_maxerror += MAXFREQ / NSEC_PER_USEC;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "323:    time_status &= ~STA_NANO;",
          "325:   if (txc->modes & ADJ_FREQUENCY) {",
          "330:   }",
          "332:   if (txc->modes & ADJ_MAXERROR)",
          "",
          "[Removed Lines]",
          "326:    time_freq = min(txc->freq, MAXFREQ);",
          "327:    time_freq = min(time_freq, -MAXFREQ);",
          "328:    time_freq = ((s64)time_freq * NSEC_PER_USEC)",
          "329:      >> (SHIFT_USEC - SHIFT_NSEC);",
          "",
          "[Added Lines]",
          "326:    time_freq = (s64)txc->freq * PPM_SCALE;",
          "327:    time_freq = min(time_freq, MAXFREQ_SCALED);",
          "328:    time_freq = max(time_freq, -MAXFREQ_SCALED);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "369:   if (!(time_status & STA_NANO))",
          "370:    txc->offset /= NSEC_PER_USEC;",
          "371:  }",
          "374:  txc->maxerror    = time_maxerror;",
          "375:  txc->esterror    = time_esterror;",
          "376:  txc->status    = time_status;",
          "377:  txc->constant    = time_constant;",
          "378:  txc->precision    = 1;",
          "380:  txc->tick    = tick_usec;",
          "",
          "[Removed Lines]",
          "372:  txc->freq    = (time_freq / NSEC_PER_USEC) <<",
          "373:     (SHIFT_USEC - SHIFT_NSEC);",
          "379:  txc->tolerance    = MAXFREQ;",
          "",
          "[Added Lines]",
          "371:  txc->freq    = shift_right((s32)(time_freq >> PPM_SCALE_INV_SHIFT) *",
          "372:       (s64)PPM_SCALE_INV,",
          "373:       TICK_LENGTH_SHIFT);",
          "379:  txc->tolerance    = MAXFREQ_SCALED / PPM_SCALE;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ee9851b218b8bafa22942b5404505ff3d2d34324",
      "candidate_info": {
        "commit_hash": "ee9851b218b8bafa22942b5404505ff3d2d34324",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ee9851b218b8bafa22942b5404505ff3d2d34324",
        "files": [
          "kernel/time/ntp.c"
        ],
        "message": "ntp: cleanup ntp.c\n\nThis is mostly a style cleanup of ntp.c and extracts part of do_adjtimex as\nntp_update_offset().  Otherwise the functionality is still the same as before.\n\nSigned-off-by: Roman Zippel <zippel@linux-m68k.org>\nCc: john stultz <johnstul@us.ibm.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "kernel/time/ntp.c||kernel/time/ntp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ],
          "candidate": [
            "kernel/time/ntp.c||kernel/time/ntp.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/time/ntp.c||kernel/time/ntp.c": [
          "File: kernel/time/ntp.c -> kernel/time/ntp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:  tick_length_base = div_u64(tick_length_base, NTP_INTERVAL_FREQ);",
          "58: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "60: static void ntp_update_offset(long offset)",
          "61: {",
          "62:  long mtemp;",
          "63:  s64 freq_adj;",
          "65:  if (!(time_status & STA_PLL))",
          "66:   return;",
          "68:  time_offset = offset * NSEC_PER_USEC;",
          "74:  time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);",
          "75:  time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);",
          "81:  if (time_status & STA_FREQHOLD || time_reftime == 0)",
          "82:   time_reftime = xtime.tv_sec;",
          "83:  mtemp = xtime.tv_sec - time_reftime;",
          "84:  time_reftime = xtime.tv_sec;",
          "86:  freq_adj = time_offset * mtemp;",
          "87:  freq_adj = shift_right(freq_adj, time_constant * 2 +",
          "88:       (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);",
          "89:  if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))",
          "90:   freq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);",
          "91:  freq_adj += time_freq;",
          "92:  freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);",
          "93:  time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);",
          "94:  time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);",
          "95:  time_offset <<= SHIFT_UPDATE;",
          "96: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "131:   break;",
          "132:  case TIME_WAIT:",
          "133:   if (!(time_status & (STA_INS | STA_DEL)))",
          "135:  }",
          "",
          "[Removed Lines]",
          "134:   time_state = TIME_OK;",
          "",
          "[Added Lines]",
          "172:    time_state = TIME_OK;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "235: int do_adjtimex(struct timex *txc)",
          "236: {",
          "239:  int result;",
          "",
          "[Removed Lines]",
          "237:  long mtemp, save_adjust;",
          "238:  s64 freq_adj;",
          "",
          "[Added Lines]",
          "275:  long save_adjust;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "273: #endif",
          "285:   }",
          "294:   }",
          "302:   }",
          "310:   }",
          "318:   }",
          "359:   result = TIME_ERROR;",
          "361:  if ((txc->modes == ADJ_OFFSET_SINGLESHOT) ||",
          "363:   txc->offset = save_adjust;",
          "364:  else",
          "365:   txc->offset = ((long)shift_right(time_offset, SHIFT_UPDATE)) *",
          "",
          "[Removed Lines]",
          "275:  if (txc->modes)",
          "276:  {",
          "278:   time_status =  (txc->status & ~STA_RONLY) |",
          "279:          (time_status & STA_RONLY);",
          "282:   if (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {",
          "283:       result = -EINVAL;",
          "284:       goto leave;",
          "286:   time_freq = ((s64)txc->freq * NSEC_PER_USEC)",
          "287:     >> (SHIFT_USEC - SHIFT_NSEC);",
          "288:      }",
          "290:      if (txc->modes & ADJ_MAXERROR) {",
          "291:   if (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {",
          "292:       result = -EINVAL;",
          "293:       goto leave;",
          "295:   time_maxerror = txc->maxerror;",
          "296:      }",
          "298:      if (txc->modes & ADJ_ESTERROR) {",
          "299:   if (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {",
          "300:       result = -EINVAL;",
          "301:       goto leave;",
          "303:   time_esterror = txc->esterror;",
          "304:      }",
          "308:       result = -EINVAL;",
          "309:       goto leave;",
          "311:   time_constant = min(txc->constant + 4, (long)MAXTC);",
          "312:      }",
          "315:   if (txc->modes == ADJ_OFFSET_SINGLESHOT) {",
          "317:       time_adjust = txc->offset;",
          "319:   else if (time_status & STA_PLL) {",
          "320:       time_offset = txc->offset * NSEC_PER_USEC;",
          "326:       time_offset = min(time_offset, (s64)MAXPHASE * NSEC_PER_USEC);",
          "327:       time_offset = max(time_offset, (s64)-MAXPHASE * NSEC_PER_USEC);",
          "335:       if (time_status & STA_FREQHOLD || time_reftime == 0)",
          "336:           time_reftime = xtime.tv_sec;",
          "337:       mtemp = xtime.tv_sec - time_reftime;",
          "338:       time_reftime = xtime.tv_sec;",
          "340:       freq_adj = time_offset * mtemp;",
          "341:       freq_adj = shift_right(freq_adj, time_constant * 2 +",
          "342:         (SHIFT_PLL + 2) * 2 - SHIFT_NSEC);",
          "343:       if (mtemp >= MINSEC && (time_status & STA_FLL || mtemp > MAXSEC))",
          "344:    freq_adj += div_s64(time_offset << (SHIFT_NSEC - SHIFT_FLL), mtemp);",
          "345:       freq_adj += time_freq;",
          "346:       freq_adj = min(freq_adj, (s64)MAXFREQ_NSEC);",
          "347:       time_freq = max(freq_adj, (s64)-MAXFREQ_NSEC);",
          "348:       time_offset = div_s64(time_offset, NTP_INTERVAL_FREQ);",
          "349:       time_offset <<= SHIFT_UPDATE;",
          "352:      if (txc->modes & ADJ_TICK)",
          "353:   tick_usec = txc->tick;",
          "355:      if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))",
          "356:       ntp_update_frequency();",
          "358: leave: if ((time_status & (STA_UNSYNC|STA_CLOCKERR)) != 0)",
          "362:    (txc->modes == ADJ_OFFSET_SS_READ))",
          "",
          "[Added Lines]",
          "312:  if (txc->modes) {",
          "314:    time_status = (txc->status & ~STA_RONLY) |",
          "315:           (time_status & STA_RONLY);",
          "317:   if (txc->modes & ADJ_FREQUENCY) {",
          "318:    if (txc->freq > MAXFREQ || txc->freq < -MAXFREQ) {",
          "319:     result = -EINVAL;",
          "320:     goto leave;",
          "321:    }",
          "322:    time_freq = ((s64)txc->freq * NSEC_PER_USEC)",
          "323:      >> (SHIFT_USEC - SHIFT_NSEC);",
          "326:   if (txc->modes & ADJ_MAXERROR) {",
          "327:    if (txc->maxerror < 0 || txc->maxerror >= NTP_PHASE_LIMIT) {",
          "328:     result = -EINVAL;",
          "329:     goto leave;",
          "330:    }",
          "331:    time_maxerror = txc->maxerror;",
          "334:   if (txc->modes & ADJ_ESTERROR) {",
          "335:    if (txc->esterror < 0 || txc->esterror >= NTP_PHASE_LIMIT) {",
          "336:     result = -EINVAL;",
          "337:     goto leave;",
          "338:    }",
          "339:    time_esterror = txc->esterror;",
          "342:   if (txc->modes & ADJ_TIMECONST) {",
          "344:     result = -EINVAL;",
          "345:     goto leave;",
          "346:    }",
          "347:    time_constant = min(txc->constant + 4, (long)MAXTC);",
          "350:   if (txc->modes & ADJ_OFFSET) {",
          "351:    if (txc->modes == ADJ_OFFSET_SINGLESHOT)",
          "353:     time_adjust = txc->offset;",
          "354:    else",
          "355:     ntp_update_offset(txc->offset);",
          "357:   if (txc->modes & ADJ_TICK)",
          "358:    tick_usec = txc->tick;",
          "360:   if (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))",
          "361:    ntp_update_frequency();",
          "362:  }",
          "363: leave:",
          "364:  if (time_status & (STA_UNSYNC|STA_CLOCKERR))",
          "368:      (txc->modes == ADJ_OFFSET_SS_READ))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "384:  txc->errcnt    = 0;",
          "385:  txc->stbcnt    = 0;",
          "386:  write_sequnlock_irq(&xtime_lock);",
          "387:  do_gettimeofday(&txc->time);",
          "388:  notify_cmos_timer();",
          "390: }",
          "392: static int __init ntp_tick_adj_setup(char *str)",
          "",
          "[Removed Lines]",
          "389:  return(result);",
          "",
          "[Added Lines]",
          "398:  return result;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-29519",
  "cve_desc": "TensorFlow is an end-to-end open source platform for machine learning. The API of `tf.raw_ops.SparseCross` allows combinations which would result in a `CHECK`-failure and denial of service. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/3d782b7d47b1bf2ed32bd4a246d6d6cadc4c903d/tensorflow/core/kernels/sparse_cross_op.cc#L114-L116) is tricked to consider a tensor of type `tstring` which in fact contains integral elements. Fixing the type confusion by preventing mixing `DT_STRING` and `DT_INT64` types solves this issue. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "b1cc5e5a50e7cee09f2c6eb48eb40ee9c4125025",
  "patch_info": {
    "commit_hash": "b1cc5e5a50e7cee09f2c6eb48eb40ee9c4125025",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/b1cc5e5a50e7cee09f2c6eb48eb40ee9c4125025",
    "files": [
      "tensorflow/core/kernels/sparse_cross_op.cc"
    ],
    "message": "Fix `tf.raw_ops.SparseCross` failing CHECK.\n\nPiperOrigin-RevId: 368701671\nChange-Id: Id805729dd9ba0bda36e4bb309408129b55fb649d",
    "before_after_code_files": [
      "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc": [
      "File: tensorflow/core/kernels/sparse_cross_op.cc -> tensorflow/core/kernels/sparse_cross_op.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "27: #include \"tensorflow/core/framework/tensor.h\"",
      "28: #include \"tensorflow/core/framework/tensor_shape.h\"",
      "29: #include \"tensorflow/core/framework/types.h\"",
      "30: #include \"tensorflow/core/lib/core/stringpiece.h\"",
      "31: #include \"tensorflow/core/lib/strings/str_util.h\"",
      "32: #include \"tensorflow/core/platform/fingerprint.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "30: #include \"tensorflow/core/framework/types.pb.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "460: Status ValidateInput(const OpInputList& indices_list_in,",
      "461:                      const OpInputList& values_list_in,",
      "462:                      const OpInputList& shapes_list_in,",
      "464:   const auto size = indices_list_in.size();",
      "466:   for (int i = 0; i < size; i++) {",
      "467:     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {",
      "468:       return errors::InvalidArgument(",
      "469:           \"Input indices should be a matrix but received shape \",",
      "",
      "[Removed Lines]",
      "463:                      const OpInputList& dense_list_in) {",
      "",
      "[Added Lines]",
      "464:                      const OpInputList& dense_list_in,",
      "465:                      const DataType& internal_type) {",
      "469:   bool check_type = internal_type != DT_INVALID;",
      "472:     if (check_type && indices_list_in[i].dtype() != DT_INT64) {",
      "473:       return errors::InvalidArgument(\"Input indices should be of type \",",
      "474:                                      DT_INT64, \" but received \",",
      "475:                                      indices_list_in[i].dtype());",
      "476:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "482:                                    values_list_in.size());",
      "483:   }",
      "484:   for (int i = 0; i < size; i++) {",
      "485:     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {",
      "486:       return errors::InvalidArgument(",
      "487:           \"Input values should be a vector but received shape \",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "497:     if (check_type && internal_type == DT_STRING &&",
      "498:         values_list_in[i].dtype() == DT_INT64) {",
      "499:       return errors::InvalidArgument(\"Input values should be of internal type \",",
      "500:                                      internal_type, \" but received \",",
      "501:                                      values_list_in[i].dtype());",
      "502:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "502:                                    shapes_list_in.size());",
      "503:   }",
      "504:   for (int i = 0; i < size; i++) {",
      "505:     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {",
      "506:       return errors::InvalidArgument(",
      "507:           \"Input shapes should be a vector but received shape \",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "523:     if (check_type && shapes_list_in[i].dtype() != DT_INT64) {",
      "524:       return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,",
      "525:                                      \" but received \",",
      "526:                                      shapes_list_in[i].dtype());",
      "527:     }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "519:   for (int i = 0; i < dense_list_in.size(); ++i) {",
      "520:     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {",
      "521:       return errors::InvalidArgument(",
      "522:           \"Dense inputs should be a matrix but received shape \",",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "545:     if (check_type && internal_type == DT_STRING &&",
      "546:         dense_list_in[i].dtype() == DT_INT64) {",
      "547:       return errors::InvalidArgument(\"Dense inputs should be of internal type \",",
      "548:                                      internal_type, \" but received \",",
      "549:                                      dense_list_in[i].dtype());",
      "550:     }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "698:     int64 signed_hash_key_;",
      "699:     OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));",
      "700:     hash_key_ = static_cast<uint64>(signed_hash_key_);",
      "701:   }",
      "703:   void Compute(OpKernelContext* context) override {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "732:     OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "711:     OP_REQUIRES_OK(context,",
      "712:                    context->input_list(\"dense_inputs\", &dense_list_in));",
      "717:     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =",
      "718:         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,",
      "",
      "[Removed Lines]",
      "714:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
      "715:                                           shapes_list_in, dense_list_in));",
      "",
      "[Added Lines]",
      "746:     DataType internal_type = internal_type_;",
      "747:     OP_REQUIRES_OK(",
      "748:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
      "749:                                dense_list_in, internal_type));",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "756:  private:",
      "757:   int64 num_buckets_;",
      "758:   uint64 hash_key_;",
      "759: };",
      "761: class SparseCrossV2Op : public OpKernel {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "793:   DataType internal_type_;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "773:     OP_REQUIRES_OK(context,",
      "774:                    context->input_list(\"dense_inputs\", &dense_list_in));",
      "779:     const Tensor* sep_t;",
      "780:     OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));",
      "",
      "[Removed Lines]",
      "776:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
      "777:                                           shapes_list_in, dense_list_in));",
      "",
      "[Added Lines]",
      "812:     DataType internal_type = DT_INVALID;",
      "813:     OP_REQUIRES_OK(",
      "814:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
      "815:                                dense_list_in, internal_type));",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "832:     OP_REQUIRES_OK(context,",
      "833:                    context->input_list(\"dense_inputs\", &dense_list_in));",
      "838:     const Tensor* num_buckets_t;",
      "839:     OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));",
      "",
      "[Removed Lines]",
      "835:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
      "836:                                           shapes_list_in, dense_list_in));",
      "",
      "[Added Lines]",
      "874:     DataType internal_type = DT_INVALID;",
      "875:     OP_REQUIRES_OK(",
      "876:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
      "877:                                dense_list_in, internal_type));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "637c14abf840d83e0f6177694030455d6af35937",
      "candidate_info": {
        "commit_hash": "637c14abf840d83e0f6177694030455d6af35937",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/637c14abf840d83e0f6177694030455d6af35937",
        "files": [
          "tensorflow/core/api_def/base_api/api_def_SparseCrossHashed.pbtxt",
          "tensorflow/core/api_def/base_api/api_def_SparseCrossV2.pbtxt",
          "tensorflow/core/api_def/python_api/api_def_SparseCrossHashed.pbtxt",
          "tensorflow/core/api_def/python_api/api_def_SparseCrossV2.pbtxt",
          "tensorflow/core/kernels/sparse_cross_op.cc",
          "tensorflow/core/ops/sparse_ops.cc",
          "tensorflow/python/kernel_tests/sparse_cross_op_test.py",
          "tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt",
          "tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt"
        ],
        "message": "Add SparseCrossV2 which supports strong_hash with salt, and fingerprint doens't take `hash_key`. hash function will be run before FingerprintCat.\n\nPiperOrigin-RevId: 312186543\nChange-Id: I67a51645250b9d0714b757c85dabf1137e64b167",
        "before_after_code_files": [
          "tensorflow/core/api_def/base_api/api_def_SparseCrossHashed.pbtxt||tensorflow/core/api_def/base_api/api_def_SparseCrossHashed.pbtxt",
          "tensorflow/core/api_def/base_api/api_def_SparseCrossV2.pbtxt||tensorflow/core/api_def/base_api/api_def_SparseCrossV2.pbtxt",
          "tensorflow/core/api_def/python_api/api_def_SparseCrossHashed.pbtxt||tensorflow/core/api_def/python_api/api_def_SparseCrossHashed.pbtxt",
          "tensorflow/core/api_def/python_api/api_def_SparseCrossV2.pbtxt||tensorflow/core/api_def/python_api/api_def_SparseCrossV2.pbtxt",
          "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc",
          "tensorflow/core/ops/sparse_ops.cc||tensorflow/core/ops/sparse_ops.cc",
          "tensorflow/python/kernel_tests/sparse_cross_op_test.py||tensorflow/python/kernel_tests/sparse_cross_op_test.py",
          "tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt",
          "tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/api_def/base_api/api_def_SparseCrossHashed.pbtxt||tensorflow/core/api_def/base_api/api_def_SparseCrossHashed.pbtxt": [
          "File: tensorflow/core/api_def/base_api/api_def_SparseCrossHashed.pbtxt -> tensorflow/core/api_def/base_api/api_def_SparseCrossHashed.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: op {",
          "2:   graph_op_name: \"SparseCrossHashed\"",
          "3:   in_arg {",
          "4:     name: \"indices\"",
          "5:     description: <<END",
          "6: 2-D.  Indices of each input `SparseTensor`.",
          "7: END",
          "8:   }",
          "9:   in_arg {",
          "10:     name: \"values\"",
          "11:     description: <<END",
          "12: 1-D.   values of each `SparseTensor`.",
          "13: END",
          "14:   }",
          "15:   in_arg {",
          "16:     name: \"shapes\"",
          "17:     description: <<END",
          "18: 1-D.   Shapes of each `SparseTensor`.",
          "19: END",
          "20:   }",
          "21:   in_arg {",
          "22:     name: \"dense_inputs\"",
          "23:     description: <<END",
          "24: 2-D.    Columns represented by dense `Tensor`.",
          "25: END",
          "26:   }",
          "27:   in_arg {",
          "28:     name: \"num_buckets\"",
          "29:     description: <<END",
          "30: It is used if hashed_output is true.",
          "31: output = hashed_value%num_buckets if num_buckets > 0 else hashed_value.",
          "32: END",
          "33:   }",
          "34:   in_arg {",
          "35:     name: \"strong_hash\"",
          "36:     description: <<END",
          "37: boolean, if true, siphash with salt will be used instead of farmhash.",
          "38: END",
          "39:   }",
          "40:   in_arg {",
          "41:     name: \"salt\"",
          "42:     description: <<END",
          "43: Specify the salt that will be used by the siphash function.",
          "44: END",
          "45:   }",
          "46:   out_arg {",
          "47:     name: \"output_indices\"",
          "48:     description: <<END",
          "49: 2-D.  Indices of the concatenated `SparseTensor`.",
          "50: END",
          "51:   }",
          "52:   out_arg {",
          "53:     name: \"output_values\"",
          "54:     description: <<END",
          "55: 1-D.  Non-empty values of the concatenated or hashed",
          "56: `SparseTensor`.",
          "57: END",
          "58:   }",
          "59:   out_arg {",
          "60:     name: \"output_shape\"",
          "61:     description: <<END",
          "62: 1-D.  Shape of the concatenated `SparseTensor`.",
          "63: END",
          "64:   }",
          "65:   summary: \"Generates sparse cross from a list of sparse and dense tensors.\"",
          "66:   description: <<END",
          "67: The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each",
          "68: representing features of one feature column. It outputs a 2D `SparseTensor` with",
          "69: the batchwise crosses of these features.",
          "71: For example, if the inputs are",
          "73:     inputs[0]: SparseTensor with shape = [2, 2]",
          "74:     [0, 0]: \"a\"",
          "75:     [1, 0]: \"b\"",
          "76:     [1, 1]: \"c\"",
          "78:     inputs[1]: SparseTensor with shape = [2, 1]",
          "79:     [0, 0]: \"d\"",
          "80:     [1, 0]: \"e\"",
          "82:     inputs[2]: Tensor [[\"f\"], [\"g\"]]",
          "84: then the output will be",
          "86:     shape = [2, 2]",
          "87:     [0, 0]: \"a_X_d_X_f\"",
          "88:     [1, 0]: \"b_X_e_X_g\"",
          "89:     [1, 1]: \"c_X_e_X_g\"",
          "91: if hashed_output=true then the output will be",
          "93:     shape = [2, 2]",
          "94:     [0, 0]: FingerprintCat64(",
          "95:                 Fingerprint64(\"f\"), FingerprintCat64(",
          "96:                     Fingerprint64(\"d\"), Fingerprint64(\"a\")))",
          "97:     [1, 0]: FingerprintCat64(",
          "98:                 Fingerprint64(\"g\"), FingerprintCat64(",
          "99:                     Fingerprint64(\"e\"), Fingerprint64(\"b\")))",
          "100:     [1, 1]: FingerprintCat64(",
          "101:                 Fingerprint64(\"g\"), FingerprintCat64(",
          "102:                     Fingerprint64(\"e\"), Fingerprint64(\"c\")))",
          "103: END",
          "104: }",
          "",
          "---------------"
        ],
        "tensorflow/core/api_def/base_api/api_def_SparseCrossV2.pbtxt||tensorflow/core/api_def/base_api/api_def_SparseCrossV2.pbtxt": [
          "File: tensorflow/core/api_def/base_api/api_def_SparseCrossV2.pbtxt -> tensorflow/core/api_def/base_api/api_def_SparseCrossV2.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: op {",
          "2:   graph_op_name: \"SparseCrossV2\"",
          "3:   in_arg {",
          "4:     name: \"indices\"",
          "5:     description: <<END",
          "6: 2-D.  Indices of each input `SparseTensor`.",
          "7: END",
          "8:   }",
          "9:   in_arg {",
          "10:     name: \"values\"",
          "11:     description: <<END",
          "12: 1-D.   values of each `SparseTensor`.",
          "13: END",
          "14:   }",
          "15:   in_arg {",
          "16:     name: \"shapes\"",
          "17:     description: <<END",
          "18: 1-D.   Shapes of each `SparseTensor`.",
          "19: END",
          "20:   }",
          "21:   in_arg {",
          "22:     name: \"dense_inputs\"",
          "23:     description: <<END",
          "24: 2-D.    Columns represented by dense `Tensor`.",
          "25: END",
          "26:   }",
          "27:   in_arg {",
          "28:     name: \"sep\"",
          "29:     description: <<END",
          "30: string used when joining a list of string inputs, can be used as separator later.",
          "31: END",
          "32:   }",
          "33:   out_arg {",
          "34:     name: \"output_indices\"",
          "35:     description: <<END",
          "36: 2-D.  Indices of the concatenated `SparseTensor`.",
          "37: END",
          "38:   }",
          "39:   out_arg {",
          "40:     name: \"output_values\"",
          "41:     description: <<END",
          "42: 1-D.  Non-empty values of the concatenated or hashed",
          "43: `SparseTensor`.",
          "44: END",
          "45:   }",
          "46:   out_arg {",
          "47:     name: \"output_shape\"",
          "48:     description: <<END",
          "49: 1-D.  Shape of the concatenated `SparseTensor`.",
          "50: END",
          "51:   }",
          "52:   summary: \"Generates sparse cross from a list of sparse and dense tensors.\"",
          "53:   description: <<END",
          "54: The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each",
          "55: representing features of one feature column. It outputs a 2D `SparseTensor` with",
          "56: the batchwise crosses of these features.",
          "58: For example, if the inputs are",
          "60:     inputs[0]: SparseTensor with shape = [2, 2]",
          "61:     [0, 0]: \"a\"",
          "62:     [1, 0]: \"b\"",
          "63:     [1, 1]: \"c\"",
          "65:     inputs[1]: SparseTensor with shape = [2, 1]",
          "66:     [0, 0]: \"d\"",
          "67:     [1, 0]: \"e\"",
          "69:     inputs[2]: Tensor [[\"f\"], [\"g\"]]",
          "71: then the output will be",
          "73:     shape = [2, 2]",
          "74:     [0, 0]: \"a_X_d_X_f\"",
          "75:     [1, 0]: \"b_X_e_X_g\"",
          "76:     [1, 1]: \"c_X_e_X_g\"",
          "78: if hashed_output=true then the output will be",
          "80:     shape = [2, 2]",
          "81:     [0, 0]: FingerprintCat64(",
          "82:                 Fingerprint64(\"f\"), FingerprintCat64(",
          "83:                     Fingerprint64(\"d\"), Fingerprint64(\"a\")))",
          "84:     [1, 0]: FingerprintCat64(",
          "85:                 Fingerprint64(\"g\"), FingerprintCat64(",
          "86:                     Fingerprint64(\"e\"), Fingerprint64(\"b\")))",
          "87:     [1, 1]: FingerprintCat64(",
          "88:                 Fingerprint64(\"g\"), FingerprintCat64(",
          "89:                     Fingerprint64(\"e\"), Fingerprint64(\"c\")))",
          "90: END",
          "91: }",
          "",
          "---------------"
        ],
        "tensorflow/core/api_def/python_api/api_def_SparseCrossHashed.pbtxt||tensorflow/core/api_def/python_api/api_def_SparseCrossHashed.pbtxt": [
          "File: tensorflow/core/api_def/python_api/api_def_SparseCrossHashed.pbtxt -> tensorflow/core/api_def/python_api/api_def_SparseCrossHashed.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: op {",
          "2:   graph_op_name: \"SparseCrossHashed\"",
          "3:   visibility: HIDDEN",
          "4: }",
          "",
          "---------------"
        ],
        "tensorflow/core/api_def/python_api/api_def_SparseCrossV2.pbtxt||tensorflow/core/api_def/python_api/api_def_SparseCrossV2.pbtxt": [
          "File: tensorflow/core/api_def/python_api/api_def_SparseCrossV2.pbtxt -> tensorflow/core/api_def/python_api/api_def_SparseCrossV2.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: op {",
          "2:   graph_op_name: \"SparseCrossV2\"",
          "3:   visibility: HIDDEN",
          "4: }",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc": [
          "File: tensorflow/core/kernels/sparse_cross_op.cc -> tensorflow/core/kernels/sparse_cross_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include \"tensorflow/core/lib/core/stringpiece.h\"",
          "30: #include \"tensorflow/core/lib/strings/str_util.h\"",
          "31: #include \"tensorflow/core/platform/fingerprint.h\"",
          "32: #include \"tensorflow/core/util/work_sharder.h\"",
          "34: namespace tensorflow {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "33: #include \"tensorflow/core/platform/strong_hash.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "42:   virtual int64 FeatureCount(int64 batch) const = 0;",
          "47:   virtual ~ColumnInterface() {}",
          "48: };",
          "",
          "[Removed Lines]",
          "45:   virtual InternalType Feature(int64 batch, int64 n) const = 0;",
          "",
          "[Added Lines]",
          "47:   virtual InternalType Feature(int64 batch, int64 n,",
          "48:                                bool strong_hash) const = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "63:     return feature_counts_[batch];",
          "64:   }",
          "68:   ~SparseTensorColumn() override {}",
          "",
          "[Removed Lines]",
          "66:   InternalType Feature(int64 batch, int64 n) const override;",
          "",
          "[Added Lines]",
          "69:   InternalType Feature(int64 batch, int64 n, bool strong_hash) const override;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "73:   std::vector<int64> feature_start_indices_;",
          "74: };",
          "77: template <>",
          "79:   const int64 start = feature_start_indices_[batch];",
          "80:   if (DT_STRING == values_.dtype())",
          "81:     return Fingerprint64(values_.vec<tstring>().data()[start + n]);",
          "82:   return values_.vec<int64>().data()[start + n];",
          "83: }",
          "86: template <>",
          "88:   const int64 start = feature_start_indices_[batch];",
          "89:   if (DT_STRING == values_.dtype())",
          "90:     return values_.vec<tstring>().data()[start + n];",
          "",
          "[Removed Lines]",
          "78: int64 SparseTensorColumn<int64>::Feature(int64 batch, int64 n) const {",
          "87: tstring SparseTensorColumn<tstring>::Feature(int64 batch, int64 n) const {",
          "",
          "[Added Lines]",
          "80: template <typename InternalType>",
          "81: class KeyedSparseTensorColumn : public ColumnInterface<InternalType> {",
          "82:  public:",
          "83:   KeyedSparseTensorColumn(const Tensor& values,",
          "84:                           std::vector<int64> feature_counts,",
          "85:                           std::vector<int64> feature_start_indices,",
          "86:                           std::vector<int64> key)",
          "87:       : values_(values),",
          "88:         feature_counts_(std::move(feature_counts)),",
          "89:         feature_start_indices_(std::move(feature_start_indices)) {",
          "90:     DCHECK_EQ(feature_counts_.size(), feature_start_indices_.size());",
          "91:     std::memcpy(key_, key.data(), sizeof(key_));",
          "92:   }",
          "94:   int64 FeatureCount(int64 batch) const override {",
          "95:     return feature_counts_[batch];",
          "96:   }",
          "98:   InternalType Feature(int64 batch, int64 n, bool strong_hash) const override;",
          "100:   ~KeyedSparseTensorColumn() override {}",
          "102:  private:",
          "103:   const Tensor& values_;",
          "104:   uint64 key_[2];",
          "105:   std::vector<int64> feature_counts_;",
          "106:   std::vector<int64> feature_start_indices_;",
          "107: };",
          "111: int64 SparseTensorColumn<int64>::Feature(int64 batch, int64 n,",
          "112:                                          bool strong_hash) const {",
          "119: template <>",
          "120: int64 KeyedSparseTensorColumn<int64>::Feature(int64 batch, int64 n,",
          "121:                                               bool strong_hash) const {",
          "122:   const int64 start = feature_start_indices_[batch];",
          "123:   if (strong_hash) {",
          "124:     if (DT_STRING == values_.dtype()) {",
          "125:       return StrongKeyedHash(key_, values_.vec<tstring>()(start + n));",
          "126:     }",
          "127:     return StrongKeyedHash(",
          "128:         key_, {reinterpret_cast<const char*>(&values_.vec<int64>()(start + n)),",
          "129:                sizeof(values_.dtype())});",
          "130:   }",
          "131:   if (DT_STRING == values_.dtype())",
          "132:     return Fingerprint64(values_.vec<tstring>()(start + n));",
          "133:   return Fingerprint64(",
          "134:       {reinterpret_cast<const char*>(&values_.vec<int64>()(start + n)),",
          "135:        sizeof(values_.dtype())});",
          "136: }",
          "140: tstring SparseTensorColumn<tstring>::Feature(int64 batch, int64 n,",
          "141:                                              bool strong_hash) const {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "92: }",
          "94: template <>",
          "97:   const int64 start = feature_start_indices_[batch];",
          "98:   return values_.vec<tstring>().data()[start + n];",
          "99: }",
          "",
          "[Removed Lines]",
          "95: StringPiece SparseTensorColumn<StringPiece>::Feature(int64 batch,",
          "96:                                                      int64 n) const {",
          "",
          "[Added Lines]",
          "149: tstring KeyedSparseTensorColumn<tstring>::Feature(int64 batch, int64 n,",
          "150:                                                   bool strong_hash) const {",
          "151:   const int64 start = feature_start_indices_[batch];",
          "152:   if (DT_STRING == values_.dtype())",
          "153:     return values_.vec<tstring>().data()[start + n];",
          "154:   return std::to_string(values_.vec<int64>().data()[start + n]);",
          "155: }",
          "157: template <>",
          "158: StringPiece SparseTensorColumn<StringPiece>::Feature(int64 batch, int64 n,",
          "159:                                                      bool strong_hash) const {",
          "160:   const int64 start = feature_start_indices_[batch];",
          "161:   return values_.vec<tstring>().data()[start + n];",
          "162: }",
          "164: template <>",
          "165: StringPiece KeyedSparseTensorColumn<StringPiece>::Feature(",
          "166:     int64 batch, int64 n, bool strong_hash) const {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "107:   int64 FeatureCount(int64 batch) const override { return tensor_.dim_size(1); }",
          "111:   ~DenseTensorColumn() override {}",
          "",
          "[Removed Lines]",
          "109:   InternalType Feature(int64 batch, int64 n) const override;",
          "",
          "[Added Lines]",
          "179:   InternalType Feature(int64 batch, int64 n, bool strong_hash) const override;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "114:   const Tensor& tensor_;",
          "115: };",
          "118: template <>",
          "120:   if (DT_STRING == tensor_.dtype())",
          "121:     return Fingerprint64(tensor_.matrix<tstring>()(batch, n));",
          "122:   return tensor_.matrix<int64>()(batch, n);",
          "",
          "[Removed Lines]",
          "119: int64 DenseTensorColumn<int64>::Feature(int64 batch, int64 n) const {",
          "",
          "[Added Lines]",
          "188: template <typename InternalType>",
          "189: class KeyedDenseTensorColumn : public ColumnInterface<InternalType> {",
          "190:  public:",
          "191:   explicit KeyedDenseTensorColumn(const Tensor& tensor, std::vector<int64> key)",
          "192:       : tensor_(tensor) {",
          "193:     std::memcpy(key_, key.data(), sizeof(key_));",
          "194:   }",
          "196:   int64 FeatureCount(int64 batch) const override { return tensor_.dim_size(1); }",
          "198:   InternalType Feature(int64 batch, int64 n, bool strong_hash) const override;",
          "200:   ~KeyedDenseTensorColumn() override {}",
          "202:  private:",
          "203:   const Tensor& tensor_;",
          "204:   uint64 key_[2];",
          "205: };",
          "209: int64 DenseTensorColumn<int64>::Feature(int64 batch, int64 n,",
          "210:                                         bool strong_hash) const {",
          "211:   if (DT_STRING == tensor_.dtype())",
          "212:     return Fingerprint64(tensor_.matrix<tstring>()(batch, n));",
          "213:   return tensor_.matrix<int64>()(batch, n);",
          "214: }",
          "216: template <>",
          "217: int64 KeyedDenseTensorColumn<int64>::Feature(int64 batch, int64 n,",
          "218:                                              bool strong_hash) const {",
          "219:   if (strong_hash) {",
          "220:     if (DT_STRING == tensor_.dtype()) {",
          "221:       return StrongKeyedHash(key_, tensor_.matrix<tstring>()(batch, n));",
          "222:     }",
          "223:     return StrongKeyedHash(",
          "224:         key_, {reinterpret_cast<const char*>(tensor_.matrix<int64>()(batch, n)),",
          "225:                sizeof(tensor_.dtype())});",
          "226:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "126: template <>",
          "128:   if (DT_STRING == tensor_.dtype()) return tensor_.matrix<tstring>()(batch, n);",
          "129:   return std::to_string(tensor_.matrix<int64>()(batch, n));",
          "130: }",
          "132: template <>",
          "135:   return tensor_.matrix<tstring>()(batch, n);",
          "136: }",
          "",
          "[Removed Lines]",
          "127: tstring DenseTensorColumn<tstring>::Feature(int64 batch, int64 n) const {",
          "133: StringPiece DenseTensorColumn<StringPiece>::Feature(int64 batch,",
          "134:                                                     int64 n) const {",
          "",
          "[Added Lines]",
          "234: tstring DenseTensorColumn<tstring>::Feature(int64 batch, int64 n,",
          "235:                                             bool strong_hash) const {",
          "236:   if (DT_STRING == tensor_.dtype()) return tensor_.matrix<tstring>()(batch, n);",
          "237:   return std::to_string(tensor_.matrix<int64>()(batch, n));",
          "238: }",
          "240: template <>",
          "241: tstring KeyedDenseTensorColumn<tstring>::Feature(int64 batch, int64 n,",
          "242:                                                  bool strong_hash) const {",
          "248: StringPiece DenseTensorColumn<StringPiece>::Feature(int64 batch, int64 n,",
          "249:                                                     bool strong_hash) const {",
          "250:   return tensor_.matrix<tstring>()(batch, n);",
          "251: }",
          "253: template <>",
          "254: StringPiece KeyedDenseTensorColumn<StringPiece>::Feature(",
          "255:     int64 batch, int64 n, bool strong_hash) const {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "169:  public:",
          "170:   StringCrosser(const std::vector<",
          "171:                     std::unique_ptr<ColumnInterface<InternalType>>>& columns,",
          "179:     gtl::InlinedVector<InternalType, 6> cross_vec(columns_.size());",
          "180:     for (int i = 0; i < permutation.size(); i++) {",
          "182:     }",
          "186:   }",
          "188:  private:",
          "189:   const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns_;",
          "190: };",
          "",
          "[Removed Lines]",
          "172:                 const int64 num_buckets_unused, const uint64 hash_key_unused)",
          "173:       : columns_(columns) {}",
          "175:   string Generate(const int64 batch_index,",
          "176:                   const std::vector<int>& permutation) const {",
          "177:     static const auto k_feature_separator = \"_X_\";",
          "181:       cross_vec[i] = columns_[i]->Feature(batch_index, permutation[i]);",
          "185:     return absl::StrJoin(cross_vec, k_feature_separator);",
          "",
          "[Added Lines]",
          "293:                 const int64 num_buckets_unused, const uint64 hash_key_unused,",
          "294:                 const tstring k_feature_separator)",
          "295:       : columns_(columns), k_feature_separator_(k_feature_separator) {}",
          "297:   string Generate(const int64 batch_index, const std::vector<int>& permutation,",
          "298:                   bool unused_strong_hash) const {",
          "301:       cross_vec[i] = columns_[i]->Feature(batch_index, permutation[i], false);",
          "305:     return absl::StrJoin(cross_vec, k_feature_separator_);",
          "310:   const tstring k_feature_separator_;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "194:  public:",
          "195:   HashCrosser(",
          "196:       const std::vector<std::unique_ptr<ColumnInterface<int64>>>& columns,",
          "198:       : columns_(columns), num_buckets_(num_buckets), hash_key_(hash_key) {}",
          "203:     uint64 hashed_output = hash_key_;",
          "204:     for (size_t i = 0; i < permutation.size(); ++i) {",
          "206:       hashed_output = FingerprintCat64(hashed_output, hash_i);",
          "207:     }",
          "",
          "[Removed Lines]",
          "197:       const int64 num_buckets, const uint64 hash_key)",
          "200:   int64 Generate(const int64 batch_index,",
          "201:                  const std::vector<int>& permutation) const {",
          "205:       uint64 hash_i = columns_[i]->Feature(batch_index, permutation[i]);",
          "",
          "[Added Lines]",
          "318:       const int64 num_buckets, const uint64 hash_key,",
          "319:       const tstring k_feature_separator_unused)",
          "322:   int64 Generate(const int64 batch_index, const std::vector<int>& permutation,",
          "323:                  bool unused_strong_hash) const {",
          "327:       uint64 hash_i = columns_[i]->Feature(batch_index, permutation[i], false);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "220:   const uint64 hash_key_;",
          "221: };",
          "224: template <typename InternalType>",
          "225: class ProductIterator {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "346: class HashCrosserV2 {",
          "347:  public:",
          "348:   HashCrosserV2(",
          "349:       const std::vector<std::unique_ptr<ColumnInterface<int64>>>& columns,",
          "350:       const int64 num_buckets, const uint64 hash_key_unused,",
          "351:       const tstring k_feature_separator_unused)",
          "352:       : columns_(columns), num_buckets_(num_buckets) {}",
          "354:   int64 Generate(const int64 batch_index, const std::vector<int>& permutation,",
          "355:                  bool strong_hash) const {",
          "357:     uint64 hashed_output =",
          "358:         columns_[0]->Feature(batch_index, permutation[0], strong_hash);",
          "359:     for (size_t i = 1; i < permutation.size(); ++i) {",
          "360:       uint64 hash_i =",
          "361:           columns_[i]->Feature(batch_index, permutation[i], strong_hash);",
          "362:       hashed_output = FingerprintCat64(hashed_output, hash_i);",
          "363:     }",
          "365:     if (num_buckets_ > 0) {",
          "366:       return hashed_output % num_buckets_;",
          "367:     } else {",
          "369:       return hashed_output % std::numeric_limits<int64>::max();",
          "370:     }",
          "371:   }",
          "373:  private:",
          "374:   const std::vector<std::unique_ptr<ColumnInterface<int64>>>& columns_;",
          "375:   const int64 num_buckets_;",
          "376: };",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "275: template <typename InternalType>",
          "276: struct CrossTraits<false, InternalType> {",
          "277:   typedef StringCrosser<InternalType> Crosser;",
          "278:   typedef OutputUpdater<tstring> Updater;",
          "279: };",
          "281: template <>",
          "282: struct CrossTraits<true, int64> {",
          "283:   typedef HashCrosser Crosser;",
          "284:   typedef OutputUpdater<int64> Updater;",
          "285: };",
          "286: }  // namespace",
          "288: template <bool HASHED_OUTPUT, typename InternalType>",
          "289: class SparseCrossOp : public OpKernel {",
          "290:  public:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "433:   typedef StringCrosser<InternalType> CrosserV2;",
          "440:   typedef HashCrosserV2 CrosserV2;",
          "446: int64 CalculateBatchSize(const OpInputList& shapes_list_in,",
          "447:                          const OpInputList& dense_list_in) {",
          "448:   if (shapes_list_in.size() > 0) {",
          "449:     return shapes_list_in[0].vec<int64>()(0);",
          "450:   }",
          "452:   if (dense_list_in.size() > 0) {",
          "453:     return dense_list_in[0].dim_size(0);",
          "454:   }",
          "456:   return 0;",
          "457: }",
          "460: Status ValidateInput(const OpInputList& indices_list_in,",
          "461:                      const OpInputList& values_list_in,",
          "462:                      const OpInputList& shapes_list_in,",
          "463:                      const OpInputList& dense_list_in) {",
          "464:   const auto size = indices_list_in.size();",
          "466:   for (int i = 0; i < size; i++) {",
          "467:     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {",
          "468:       return errors::InvalidArgument(",
          "469:           \"Input indices should be a matrix but received shape \",",
          "470:           indices_list_in[i].shape().DebugString(), \" at position \", i);",
          "471:     }",
          "472:     if (indices_list_in[i].shape().dim_size(1) != 2) {",
          "473:       return errors::InvalidArgument(\"Expected D2 of index to be 2 got \",",
          "474:                                      indices_list_in[i].shape().dim_size(1),",
          "475:                                      \" at position \", i);",
          "476:     }",
          "477:   }",
          "480:   if (values_list_in.size() != size) {",
          "481:     return errors::InvalidArgument(\"Expected \", size, \" input values, got \",",
          "482:                                    values_list_in.size());",
          "483:   }",
          "484:   for (int i = 0; i < size; i++) {",
          "485:     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {",
          "486:       return errors::InvalidArgument(",
          "487:           \"Input values should be a vector but received shape \",",
          "488:           values_list_in[i].shape().DebugString(), \" at position \", i);",
          "489:     }",
          "490:     if (indices_list_in[i].shape().dim_size(0) !=",
          "491:         values_list_in[i].shape().dim_size(0)) {",
          "492:       return errors::InvalidArgument(",
          "493:           \"Expected size of values to be \",",
          "494:           indices_list_in[i].shape().dim_size(0), \" got \",",
          "495:           values_list_in[i].shape().dim_size(0), \" at position \", i);",
          "496:     }",
          "497:   }",
          "500:   if (shapes_list_in.size() != size) {",
          "501:     return errors::InvalidArgument(\"Expected \", size, \" input shapes, got \",",
          "502:                                    shapes_list_in.size());",
          "503:   }",
          "504:   for (int i = 0; i < size; i++) {",
          "505:     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {",
          "506:       return errors::InvalidArgument(",
          "507:           \"Input shapes should be a vector but received shape \",",
          "508:           shapes_list_in[i].shape().DebugString(), \" at position \", i);",
          "509:     }",
          "511:     if (shapes_list_in[i].vec<int64>().size() != 2) {",
          "512:       return errors::InvalidArgument(\"shape should imply a 2D tensor, but got \",",
          "513:                                      shapes_list_in[i].shape().DebugString(),",
          "514:                                      \" at position \", i);",
          "515:     }",
          "516:   }",
          "519:   for (int i = 0; i < dense_list_in.size(); ++i) {",
          "520:     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {",
          "521:       return errors::InvalidArgument(",
          "522:           \"Dense inputs should be a matrix but received shape \",",
          "523:           dense_list_in[i].shape().DebugString(), \" at position \", i);",
          "524:     }",
          "525:   }",
          "530:   const auto batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "531:   for (int i = 0; i < size; i++) {",
          "532:     if (shapes_list_in[i].vec<int64>()(0) != batch_size) {",
          "533:       return errors::InvalidArgument(\"Expected batch size \", batch_size,",
          "534:                                      \" got \", shapes_list_in[i].vec<int64>()(0),",
          "535:                                      \" at position \", i);",
          "536:     }",
          "537:   }",
          "538:   for (int i = 0; i < dense_list_in.size(); ++i) {",
          "539:     if (dense_list_in[i].dim_size(0) != batch_size) {",
          "540:       return errors::InvalidArgument(\"Expected batch size \", batch_size,",
          "541:                                      \" got \", dense_list_in[i].dim_size(0),",
          "542:                                      \" at dense tensor \", i);",
          "543:     }",
          "544:   }",
          "546:   return Status::OK();",
          "547: }",
          "550: void ExtractFeatureData(",
          "551:     const OpInputList& indices_list_in, int64 batch_size,",
          "552:     std::vector<std::vector<int64>>* feature_counts,",
          "553:     std::vector<std::vector<int64>>* feature_start_indices) {",
          "554:   gtl::InlinedVector<int64, 8> current_row(indices_list_in.size(), 0);",
          "555:   for (int b = 0; b < batch_size; b++) {",
          "556:     for (int i = 0; i < indices_list_in.size(); i++) {",
          "557:       const auto indices = indices_list_in[i].matrix<int64>();",
          "558:       int64 feature_count = 0;",
          "559:       int64 start_index = current_row[i];",
          "561:       while (current_row[i] < indices_list_in[i].dim_size(0) &&",
          "562:              indices(current_row[i], 0) == b) {",
          "563:         feature_count++;",
          "564:         current_row[i]++;",
          "565:       }",
          "566:       (*feature_counts)[i].push_back(feature_count);",
          "567:       (*feature_start_indices)[i].push_back(start_index);",
          "568:     }",
          "569:   }",
          "570: }",
          "573: template <typename InternalType>",
          "574: int64 CrossCountByBatchIndex(",
          "575:     const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns,",
          "576:     int batch_index) {",
          "577:   int64 cross_count = 1;",
          "578:   for (int i = 0; i < columns.size(); i++) {",
          "579:     const auto feature_count = columns[i]->FeatureCount(batch_index);",
          "581:     if (feature_count == 0) {",
          "582:       return 0;",
          "583:     }",
          "584:     cross_count *= feature_count;",
          "585:   }",
          "586:   return cross_count;",
          "587: }",
          "590: template <typename InternalType>",
          "591: std::vector<std::unique_ptr<ColumnInterface<InternalType>>>",
          "592: GenerateColumnsFromInput(const OpInputList& indices_list_in,",
          "593:                          const OpInputList& values_list_in,",
          "594:                          const OpInputList& shapes_list_in,",
          "595:                          const OpInputList& dense_list_in) {",
          "596:   std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns;",
          "597:   const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "598:   const int64 number_of_columns = shapes_list_in.size();",
          "600:   std::vector<std::vector<int64>> feature_counts(number_of_columns,",
          "601:                                                  std::vector<int64>());",
          "602:   std::vector<std::vector<int64>> feature_start_indices(number_of_columns,",
          "603:                                                         std::vector<int64>());",
          "605:   ExtractFeatureData(indices_list_in, batch_size, &feature_counts,",
          "606:                      &feature_start_indices);",
          "608:   columns.reserve(values_list_in.size());",
          "609:   for (int i = 0; i < values_list_in.size(); ++i) {",
          "610:     columns.emplace_back(new SparseTensorColumn<InternalType>(",
          "611:         values_list_in[i], std::move(feature_counts[i]),",
          "612:         std::move(feature_start_indices[i])));",
          "613:   }",
          "614:   for (int i = 0; i < dense_list_in.size(); ++i) {",
          "615:     columns.emplace_back(new DenseTensorColumn<InternalType>(dense_list_in[i]));",
          "616:   }",
          "618:   return columns;",
          "619: }",
          "622: template <typename InternalType>",
          "623: std::vector<std::unique_ptr<ColumnInterface<InternalType>>>",
          "624: GenerateKeyedColumnsFromInput(const OpInputList& indices_list_in,",
          "625:                               const OpInputList& values_list_in,",
          "626:                               const OpInputList& shapes_list_in,",
          "627:                               const OpInputList& dense_list_in,",
          "628:                               std::vector<int64> keys) {",
          "629:   std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns;",
          "630:   const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "631:   const int64 number_of_columns = shapes_list_in.size();",
          "633:   std::vector<std::vector<int64>> feature_counts(number_of_columns,",
          "634:                                                  std::vector<int64>());",
          "635:   std::vector<std::vector<int64>> feature_start_indices(number_of_columns,",
          "636:                                                         std::vector<int64>());",
          "638:   ExtractFeatureData(indices_list_in, batch_size, &feature_counts,",
          "639:                      &feature_start_indices);",
          "641:   columns.reserve(values_list_in.size());",
          "642:   for (int i = 0; i < values_list_in.size(); ++i) {",
          "643:     columns.emplace_back(new KeyedSparseTensorColumn<InternalType>(",
          "644:         values_list_in[i], std::move(feature_counts[i]),",
          "645:         std::move(feature_start_indices[i]), keys));",
          "646:   }",
          "647:   for (int i = 0; i < dense_list_in.size(); ++i) {",
          "648:     columns.emplace_back(",
          "649:         new KeyedDenseTensorColumn<InternalType>(dense_list_in[i], keys));",
          "650:   }",
          "652:   return columns;",
          "653: }",
          "659: template <typename InternalType>",
          "660: Status CreateOutputTensors(",
          "661:     const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns,",
          "662:     int64 batch_size, OpKernelContext* context, Tensor** indices_out,",
          "663:     Tensor** values_out, Tensor** shape_out,",
          "664:     std::vector<int64>* output_start_indices) {",
          "666:   int64 cross_count_total = 0;",
          "667:   int64 max_cross_count = 0;",
          "668:   for (int64 b = 0; b < batch_size; b++) {",
          "670:     (*output_start_indices)[b] = cross_count_total;",
          "671:     const auto cross_count = CrossCountByBatchIndex(columns, b);",
          "672:     max_cross_count = std::max(max_cross_count, cross_count);",
          "673:     cross_count_total += cross_count;",
          "674:   }",
          "677:   TF_RETURN_IF_ERROR(context->allocate_output(",
          "678:       0, TensorShape({cross_count_total, 2}), indices_out));",
          "679:   TF_RETURN_IF_ERROR(context->allocate_output(",
          "680:       1, TensorShape({cross_count_total}), values_out));",
          "681:   TF_RETURN_IF_ERROR(context->allocate_output(2, TensorShape({2}), shape_out));",
          "684:   auto shape_vec = (*shape_out)->vec<int64>();",
          "685:   shape_vec(0) = batch_size;",
          "686:   shape_vec(1) = max_cross_count;",
          "688:   return Status::OK();",
          "689: }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "312:                                           shapes_list_in, dense_list_in));",
          "314:     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =",
          "318:     typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(",
          "320:     Tensor* indices_out;",
          "321:     Tensor* values_out;",
          "322:     Tensor* shape_out;",
          "",
          "[Removed Lines]",
          "315:         GenerateColumnsFromInput(indices_list_in, values_list_in,",
          "316:                                  shapes_list_in, dense_list_in);",
          "319:         columns, num_buckets_, hash_key_);",
          "",
          "[Added Lines]",
          "718:         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,",
          "719:                                                shapes_list_in, dense_list_in);",
          "721:     const tstring k_feature_separator = \"_X_\";",
          "723:         columns, num_buckets_, hash_key_, k_feature_separator);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "335:         int64 cross_count = 0;",
          "336:         while (product_iterator.HasNext()) {",
          "337:           const auto permutation = product_iterator.Next();",
          "339:           cross_count++;",
          "340:         }",
          "341:       }",
          "",
          "[Removed Lines]",
          "338:           updater.Update(b, cross_count, crosser.Generate(b, permutation));",
          "",
          "[Added Lines]",
          "742:           updater.Update(b, cross_count,",
          "743:                          crosser.Generate(b, permutation, false));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "349:   }",
          "351:  private:",
          "436:       }",
          "440:   }",
          "504:         }",
          "507:       }",
          "563:   }",
          "566: };",
          "568: REGISTER_KERNEL_BUILDER(Name(\"SparseCross\")",
          "",
          "[Removed Lines]",
          "353:   Status ValidateInput(const OpInputList& indices_list_in,",
          "354:                        const OpInputList& values_list_in,",
          "355:                        const OpInputList& shapes_list_in,",
          "356:                        const OpInputList& dense_list_in) {",
          "357:     const auto size = indices_list_in.size();",
          "359:     for (int i = 0; i < size; i++) {",
          "360:       if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {",
          "361:         return errors::InvalidArgument(",
          "362:             \"Input indices should be a matrix but received shape \",",
          "363:             indices_list_in[i].shape().DebugString(), \" at position \", i);",
          "364:       }",
          "365:       if (indices_list_in[i].shape().dim_size(1) != 2) {",
          "366:         return errors::InvalidArgument(\"Expected D2 of index to be 2 got \",",
          "367:                                        indices_list_in[i].shape().dim_size(1),",
          "368:                                        \" at position \", i);",
          "369:       }",
          "370:     }",
          "373:     if (values_list_in.size() != size) {",
          "374:       return errors::InvalidArgument(\"Expected \", size, \" input values, got \",",
          "375:                                      values_list_in.size());",
          "376:     }",
          "377:     for (int i = 0; i < size; i++) {",
          "378:       if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {",
          "379:         return errors::InvalidArgument(",
          "380:             \"Input values should be a vector but received shape \",",
          "381:             values_list_in[i].shape().DebugString(), \" at position \", i);",
          "382:       }",
          "383:       if (indices_list_in[i].shape().dim_size(0) !=",
          "384:           values_list_in[i].shape().dim_size(0)) {",
          "385:         return errors::InvalidArgument(",
          "386:             \"Expected size of values to be \",",
          "387:             indices_list_in[i].shape().dim_size(0), \" got \",",
          "388:             values_list_in[i].shape().dim_size(0), \" at position \", i);",
          "389:       }",
          "390:     }",
          "393:     if (shapes_list_in.size() != size) {",
          "394:       return errors::InvalidArgument(\"Expected \", size, \" input shapes, got \",",
          "395:                                      shapes_list_in.size());",
          "396:     }",
          "397:     for (int i = 0; i < size; i++) {",
          "398:       if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {",
          "399:         return errors::InvalidArgument(",
          "400:             \"Input shapes should be a vector but received shape \",",
          "401:             shapes_list_in[i].shape().DebugString(), \" at position \", i);",
          "402:       }",
          "404:       if (shapes_list_in[i].vec<int64>().size() != 2) {",
          "405:         return errors::InvalidArgument(",
          "406:             \"shape should imply a 2D tensor, but got \",",
          "407:             shapes_list_in[i].shape().DebugString(), \" at position \", i);",
          "408:       }",
          "409:     }",
          "412:     for (int i = 0; i < dense_list_in.size(); ++i) {",
          "413:       if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {",
          "414:         return errors::InvalidArgument(",
          "415:             \"Dense inputs should be a matrix but received shape \",",
          "416:             dense_list_in[i].shape().DebugString(), \" at position \", i);",
          "417:       }",
          "418:     }",
          "423:     const auto batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "424:     for (int i = 0; i < size; i++) {",
          "425:       if (shapes_list_in[i].vec<int64>()(0) != batch_size) {",
          "426:         return errors::InvalidArgument(",
          "427:             \"Expected batch size \", batch_size, \" got \",",
          "428:             shapes_list_in[i].vec<int64>()(0), \" at position \", i);",
          "429:       }",
          "430:     }",
          "431:     for (int i = 0; i < dense_list_in.size(); ++i) {",
          "432:       if (dense_list_in[i].dim_size(0) != batch_size) {",
          "433:         return errors::InvalidArgument(\"Expected batch size \", batch_size,",
          "434:                                        \" got \", dense_list_in[i].dim_size(0),",
          "435:                                        \" at dense tensor \", i);",
          "437:     }",
          "439:     return Status::OK();",
          "443:   int64 CalculateBatchSize(const OpInputList& shapes_list_in,",
          "444:                            const OpInputList& dense_list_in) {",
          "445:     if (shapes_list_in.size() > 0) {",
          "446:       return shapes_list_in[0].vec<int64>()(0);",
          "447:     }",
          "449:     if (dense_list_in.size() > 0) {",
          "450:       return dense_list_in[0].dim_size(0);",
          "451:     }",
          "453:     return 0;",
          "454:   }",
          "457:   std::vector<std::unique_ptr<ColumnInterface<InternalType>>>",
          "458:   GenerateColumnsFromInput(const OpInputList& indices_list_in,",
          "459:                            const OpInputList& values_list_in,",
          "460:                            const OpInputList& shapes_list_in,",
          "461:                            const OpInputList& dense_list_in) {",
          "462:     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns;",
          "463:     const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "464:     const int64 number_of_columns = shapes_list_in.size();",
          "466:     std::vector<std::vector<int64>> feature_counts(number_of_columns,",
          "467:                                                    std::vector<int64>());",
          "468:     std::vector<std::vector<int64>> feature_start_indices(number_of_columns,",
          "469:                                                           std::vector<int64>());",
          "471:     ExtractFeatureData(indices_list_in, batch_size, &feature_counts,",
          "472:                        &feature_start_indices);",
          "474:     columns.reserve(values_list_in.size());",
          "475:     for (int i = 0; i < values_list_in.size(); ++i) {",
          "476:       columns.emplace_back(new SparseTensorColumn<InternalType>(",
          "477:           values_list_in[i], std::move(feature_counts[i]),",
          "478:           std::move(feature_start_indices[i])));",
          "479:     }",
          "480:     for (int i = 0; i < dense_list_in.size(); ++i) {",
          "481:       columns.emplace_back(",
          "482:           new DenseTensorColumn<InternalType>(dense_list_in[i]));",
          "483:     }",
          "485:     return columns;",
          "486:   }",
          "489:   void ExtractFeatureData(",
          "490:       const OpInputList& indices_list_in, int64 batch_size,",
          "491:       std::vector<std::vector<int64>>* feature_counts,",
          "492:       std::vector<std::vector<int64>>* feature_start_indices) {",
          "493:     gtl::InlinedVector<int64, 8> current_row(indices_list_in.size(), 0);",
          "494:     for (int b = 0; b < batch_size; b++) {",
          "495:       for (int i = 0; i < indices_list_in.size(); i++) {",
          "496:         const auto indices = indices_list_in[i].matrix<int64>();",
          "497:         int64 feature_count = 0;",
          "498:         int64 start_index = current_row[i];",
          "500:         while (current_row[i] < indices_list_in[i].dim_size(0) &&",
          "501:                indices(current_row[i], 0) == b) {",
          "502:           feature_count++;",
          "503:           current_row[i]++;",
          "505:         (*feature_counts)[i].push_back(feature_count);",
          "506:         (*feature_start_indices)[i].push_back(start_index);",
          "508:     }",
          "509:   }",
          "515:   Status CreateOutputTensors(",
          "516:       const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>&",
          "517:           columns,",
          "518:       int64 batch_size, OpKernelContext* context, Tensor** indices_out,",
          "519:       Tensor** values_out, Tensor** shape_out,",
          "520:       std::vector<int64>* output_start_indices) {",
          "522:     int64 cross_count_total = 0;",
          "523:     int64 max_cross_count = 0;",
          "524:     for (int64 b = 0; b < batch_size; b++) {",
          "526:       (*output_start_indices)[b] = cross_count_total;",
          "527:       const auto cross_count = CrossCountByBatchIndex(columns, b);",
          "528:       max_cross_count = std::max(max_cross_count, cross_count);",
          "529:       cross_count_total += cross_count;",
          "530:     }",
          "533:     TF_RETURN_IF_ERROR(context->allocate_output(",
          "534:         0, TensorShape({cross_count_total, 2}), indices_out));",
          "535:     TF_RETURN_IF_ERROR(context->allocate_output(",
          "536:         1, TensorShape({cross_count_total}), values_out));",
          "537:     TF_RETURN_IF_ERROR(",
          "538:         context->allocate_output(2, TensorShape({2}), shape_out));",
          "541:     auto shape_vec = (*shape_out)->vec<int64>();",
          "542:     shape_vec(0) = batch_size;",
          "543:     shape_vec(1) = max_cross_count;",
          "545:     return Status::OK();",
          "546:   }",
          "549:   int64 CrossCountByBatchIndex(",
          "550:       const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>&",
          "551:           columns,",
          "552:       int batch_index) {",
          "553:     int64 cross_count = 1;",
          "554:     for (int i = 0; i < columns.size(); i++) {",
          "555:       const auto feature_count = columns[i]->FeatureCount(batch_index);",
          "557:       if (feature_count == 0) {",
          "558:         return 0;",
          "559:       }",
          "560:       cross_count *= feature_count;",
          "561:     }",
          "562:     return cross_count;",
          "564:   int64 num_buckets_;",
          "565:   uint64 hash_key_;",
          "",
          "[Added Lines]",
          "757:   int64 num_buckets_;",
          "758:   uint64 hash_key_;",
          "759: };",
          "761: class SparseCrossV2Op : public OpKernel {",
          "762:  public:",
          "763:   explicit SparseCrossV2Op(OpKernelConstruction* context) : OpKernel(context) {}",
          "765:   void Compute(OpKernelContext* context) override {",
          "766:     OpInputList indices_list_in;",
          "767:     OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));",
          "768:     OpInputList values_list_in;",
          "769:     OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));",
          "770:     OpInputList shapes_list_in;",
          "771:     OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));",
          "772:     OpInputList dense_list_in;",
          "773:     OP_REQUIRES_OK(context,",
          "774:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "776:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "777:                                           shapes_list_in, dense_list_in));",
          "779:     const Tensor* sep_t;",
          "780:     OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));",
          "781:     const tstring separator = sep_t->scalar<tstring>()();",
          "783:     std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =",
          "784:         GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,",
          "785:                                           shapes_list_in, dense_list_in);",
          "786:     Tensor* indices_out;",
          "787:     Tensor* values_out;",
          "788:     Tensor* shape_out;",
          "789:     const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "790:     std::vector<int64> output_start_indices(batch_size);",
          "791:     OP_REQUIRES_OK(",
          "792:         context,",
          "793:         CreateOutputTensors(columns, batch_size, context, &indices_out,",
          "794:                             &values_out, &shape_out, &output_start_indices));",
          "795:     StringCrosser<tstring> crosser(columns, 0, 0, separator);",
          "796:     OutputUpdater<tstring> updater(output_start_indices, indices_out,",
          "797:                                    values_out);",
          "798:     auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {",
          "799:       for (int b = begin; b < end; b++) {",
          "800:         ProductIterator<tstring> product_iterator(columns, b);",
          "801:         int64 cross_count = 0;",
          "802:         while (product_iterator.HasNext()) {",
          "803:           const auto permutation = product_iterator.Next();",
          "804:           updater.Update(b, cross_count,",
          "805:                          crosser.Generate(b, permutation, false));",
          "806:           cross_count++;",
          "807:         }",
          "809:     };",
          "811:     auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();",
          "813:     const int kCostPerUnit = 5000 * indices_list_in.size();",
          "814:     Shard(worker_threads->num_threads, worker_threads->workers, batch_size,",
          "815:           kCostPerUnit, do_work);",
          "817: };",
          "819: class SparseCrossHashedOp : public OpKernel {",
          "820:  public:",
          "821:   explicit SparseCrossHashedOp(OpKernelConstruction* context)",
          "822:       : OpKernel(context) {}",
          "824:   void Compute(OpKernelContext* context) override {",
          "825:     OpInputList indices_list_in;",
          "826:     OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));",
          "827:     OpInputList values_list_in;",
          "828:     OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));",
          "829:     OpInputList shapes_list_in;",
          "830:     OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));",
          "831:     OpInputList dense_list_in;",
          "832:     OP_REQUIRES_OK(context,",
          "833:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "835:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "836:                                           shapes_list_in, dense_list_in));",
          "838:     const Tensor* num_buckets_t;",
          "839:     OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));",
          "840:     const int64 num_buckets = num_buckets_t->scalar<int64>()();",
          "842:     const Tensor* strong_hash_t;",
          "843:     OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));",
          "844:     const bool strong_hash = strong_hash_t->scalar<bool>()();",
          "846:     const Tensor* salt_t;",
          "847:     OP_REQUIRES_OK(context, context->input(\"salt\", &salt_t));",
          "848:     const auto salt = salt_t->flat<int64>();",
          "849:     std::vector<int64> key_{salt(0), salt(1)};",
          "851:     std::vector<std::unique_ptr<ColumnInterface<int64>>> columns =",
          "852:         GenerateKeyedColumnsFromInput<int64>(indices_list_in, values_list_in,",
          "853:                                              shapes_list_in, dense_list_in,",
          "854:                                              key_);",
          "855:     Tensor* indices_out;",
          "856:     Tensor* values_out;",
          "857:     Tensor* shape_out;",
          "858:     const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "859:     std::vector<int64> output_start_indices(batch_size);",
          "860:     OP_REQUIRES_OK(",
          "861:         context,",
          "862:         CreateOutputTensors(columns, batch_size, context, &indices_out,",
          "863:                             &values_out, &shape_out, &output_start_indices));",
          "864:     const tstring unused_sep;",
          "865:     HashCrosserV2 crosser(columns, num_buckets, 0, unused_sep);",
          "866:     OutputUpdater<int64> updater(output_start_indices, indices_out, values_out);",
          "867:     auto do_work = [&columns, crosser, updater, strong_hash](int64 begin,",
          "868:                                                              int64 end) {",
          "869:       for (int b = begin; b < end; b++) {",
          "870:         ProductIterator<int64> product_iterator(columns, b);",
          "871:         int64 cross_count = 0;",
          "872:         while (product_iterator.HasNext()) {",
          "873:           const auto permutation = product_iterator.Next();",
          "874:           updater.Update(b, cross_count,",
          "875:                          crosser.Generate(b, permutation, strong_hash));",
          "876:           cross_count++;",
          "879:     };",
          "881:     auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();",
          "883:     const int kCostPerUnit = 5000 * indices_list_in.size();",
          "884:     Shard(worker_threads->num_threads, worker_threads->workers, batch_size,",
          "885:           kCostPerUnit, do_work);",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "589:                             .TypeConstraint<int64>(\"internal_type\"),",
          "590:                         SparseCrossOp<true, int64>);",
          "592: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "913: REGISTER_KERNEL_BUILDER(Name(\"SparseCrossV2\").Device(DEVICE_CPU),",
          "914:                         SparseCrossV2Op);",
          "916: REGISTER_KERNEL_BUILDER(Name(\"SparseCrossHashed\").Device(DEVICE_CPU),",
          "917:                         SparseCrossHashedOp);",
          "",
          "---------------"
        ],
        "tensorflow/core/ops/sparse_ops.cc||tensorflow/core/ops/sparse_ops.cc": [
          "File: tensorflow/core/ops/sparse_ops.cc -> tensorflow/core/ops/sparse_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:       return Status::OK();",
          "273:     });",
          "275: REGISTER_OP(\"SparseSplit\")",
          "276:     .Input(\"split_dim: int64\")",
          "277:     .Input(\"indices: int64\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272:       return Status::OK();",
          "273:     });",
          "275: REGISTER_OP(\"SparseCrossV2\")",
          "276:     .Input(\"indices: N * int64\")",
          "277:     .Input(\"values: sparse_types\")",
          "278:     .Input(\"shapes: N * int64\")",
          "279:     .Input(\"dense_inputs: dense_types\")",
          "280:     .Input(\"sep: string\")",
          "281:     .Output(\"output_indices: int64\")",
          "282:     .Output(\"output_values: string\")",
          "283:     .Output(\"output_shape: int64\")",
          "284:     .Attr(\"N: int >= 0\")",
          "285:     .Attr(\"sparse_types: list({int64, string}) >= 0\")",
          "286:     .Attr(\"dense_types: list({int64, string}) >= 0\")",
          "287:     .SetShapeFn([](shape_inference::InferenceContext* c) {",
          "288:       c->set_output(0, c->Matrix(c->UnknownDim(), 2));",
          "289:       c->set_output(1, c->Vector(c->UnknownDim()));",
          "290:       c->set_output(2, c->Vector(2));",
          "291:       return Status::OK();",
          "292:     });",
          "294: REGISTER_OP(\"SparseCrossHashed\")",
          "295:     .Input(\"indices: N * int64\")",
          "296:     .Input(\"values: sparse_types\")",
          "297:     .Input(\"shapes: N * int64\")",
          "298:     .Input(\"dense_inputs: dense_types\")",
          "299:     .Input(\"num_buckets: int64\")",
          "300:     .Input(\"strong_hash: bool\")",
          "301:     .Input(\"salt: int64\")",
          "302:     .Output(\"output_indices: int64\")",
          "303:     .Output(\"output_values: int64\")",
          "304:     .Output(\"output_shape: int64\")",
          "305:     .Attr(\"N: int >= 0\")",
          "306:     .Attr(\"sparse_types: list({int64, string}) >= 0\")",
          "307:     .Attr(\"dense_types: list({int64, string}) >= 0\")",
          "308:     .SetShapeFn([](shape_inference::InferenceContext* c) {",
          "309:       c->set_output(0, c->Matrix(c->UnknownDim(), 2));",
          "310:       c->set_output(1, c->Vector(c->UnknownDim()));",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/sparse_cross_op_test.py||tensorflow/python/kernel_tests/sparse_cross_op_test.py": [
          "File: tensorflow/python/kernel_tests/sparse_cross_op_test.py -> tensorflow/python/kernel_tests/sparse_cross_op_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: from tensorflow.python.framework import sparse_tensor",
          "28: from tensorflow.python.framework import test_util",
          "29: from tensorflow.python.ops import array_ops",
          "30: from tensorflow.python.ops import sparse_ops",
          "31: from tensorflow.python.platform import test",
          "34: class SparseCrossOpTest(test.TestCase):",
          "36:   @test_util.run_deprecated_v1",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: from tensorflow.python.ops import gen_sparse_ops",
          "35: class BaseSparseCrossOpTest(test.TestCase):",
          "37:   def _sparse_tensor(self, data, batch_size=-1):",
          "38:     \"\"\"Generates a SparseTensor.",
          "40:     Args:",
          "41:       data: Should be a list of list of strings or int64. Each item of the outer",
          "42:         list represents a batch. Each item of the batch is a feature of a",
          "43:         specific feature column.",
          "44:       batch_size: optional batch size, especially for cases when data has no",
          "45:         entry for some batches.",
          "47:     Returns:",
          "48:      A SparseTensor.",
          "49:     \"\"\"",
          "50:     indices = []",
          "51:     values = []",
          "52:     max_col_count = 0",
          "53:     for batch, batch_ix in zip(data, range(len(data))):",
          "54:       for column, column_ix in zip(batch, range(len(batch))):",
          "55:         indices.append([batch_ix, column_ix])",
          "56:         values.append(column)",
          "57:         max_col_count = max(max_col_count, column_ix + 1)",
          "58:     shape = [batch_size if batch_size != -1 else len(data), max_col_count]",
          "59:     value_type = (",
          "60:         dtypes.string",
          "61:         if not values or isinstance(values[0], str) else dtypes.int64)",
          "62:     return sparse_tensor.SparseTensor(",
          "63:         constant_op.constant(indices, dtypes.int64, [len(indices), 2]),",
          "64:         constant_op.constant(values, value_type, [len(indices)]),",
          "65:         constant_op.constant(shape, dtypes.int64))",
          "67:   def _assert_sparse_tensor_equals(self, sp1, sp2):",
          "68:     self.assertAllEqual(sp1.indices.eval(), sp2.indices)",
          "69:     self.assertAllEqual(sp1.values.eval(), sp2.values)",
          "70:     self.assertAllEqual(sp1.dense_shape.eval(), sp2.dense_shape)",
          "72:   def _assert_sparse_tensor_empty(self, sp):",
          "73:     self.assertEqual(0, sp.indices.size)",
          "74:     self.assertEqual(0, sp.values.size)",
          "75:     # TODO(zakaria): check if we can ignore the first dim of the shape.",
          "76:     self.assertEqual(0, sp.dense_shape[1])",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "459:       self.evaluate(sparse_ops.sparse_cross([st1, st2]))",
          "462: if __name__ == '__main__':",
          "463:   test.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "507: class SparseCrossV2OpTest(BaseSparseCrossOpTest):",
          "509:   @test_util.run_deprecated_v1",
          "510:   def test_sparse(self):",
          "511:     \"\"\"Tests a simple scenario.\"\"\"",
          "512:     sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],",
          "513:                                     ['batch2-FC1-F1', 'batch2-FC1-F2']])",
          "514:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],",
          "515:                                     ['batch2-FC2-F1', 'batch2-FC2-F2']])",
          "516:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "517:         indices=[sp_inp_1.indices, sp_inp_2.indices],",
          "518:         values=[sp_inp_1.values, sp_inp_2.values],",
          "519:         shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],",
          "520:         dense_inputs=[],",
          "521:         sep='_X_')",
          "522:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "523:     # pyformat: disable",
          "524:     expected_out = self._sparse_tensor([",
          "525:         ['batch1-FC1-F1_X_batch1-FC2-F1'],",
          "526:         ['batch2-FC1-F1_X_batch2-FC2-F1',",
          "527:          'batch2-FC1-F1_X_batch2-FC2-F2',",
          "528:          'batch2-FC1-F2_X_batch2-FC2-F1',",
          "529:          'batch2-FC1-F2_X_batch2-FC2-F2'",
          "530:         ]])",
          "531:     # pyformat: enable",
          "532:     with self.cached_session():",
          "533:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "535:   @test_util.run_deprecated_v1",
          "536:   def test_sparse_sep(self):",
          "537:     \"\"\"Tests a simple scenario.\"\"\"",
          "538:     sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],",
          "539:                                     ['batch2-FC1-F1', 'batch2-FC1-F2']])",
          "540:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],",
          "541:                                     ['batch2-FC2-F1', 'batch2-FC2-F2']])",
          "542:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "543:         indices=[sp_inp_1.indices, sp_inp_2.indices],",
          "544:         values=[sp_inp_1.values, sp_inp_2.values],",
          "545:         shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],",
          "546:         dense_inputs=[],",
          "547:         sep='_Y_')",
          "548:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "549:     # pyformat: disable",
          "550:     expected_out = self._sparse_tensor([",
          "551:         ['batch1-FC1-F1_Y_batch1-FC2-F1'],",
          "552:         ['batch2-FC1-F1_Y_batch2-FC2-F1',",
          "553:          'batch2-FC1-F1_Y_batch2-FC2-F2',",
          "554:          'batch2-FC1-F2_Y_batch2-FC2-F1',",
          "555:          'batch2-FC1-F2_Y_batch2-FC2-F2'",
          "556:         ]])",
          "557:     # pyformat: enable",
          "558:     with self.cached_session():",
          "559:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "561:   @test_util.run_deprecated_v1",
          "562:   def test_dense(self):",
          "563:     \"\"\"Tests only dense inputs.\"\"\"",
          "564:     dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],",
          "565:                                         ['batch2-FC1-F1', 'batch2-FC1-F2']],",
          "566:                                        dtypes.string)",
          "567:     dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],",
          "568:                                         ['batch2-FC2-F1', 'batch2-FC2-F2']],",
          "569:                                        dtypes.string)",
          "570:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "571:         indices=[],",
          "572:         values=[],",
          "573:         shapes=[],",
          "574:         dense_inputs=[dense_inp_1, dense_inp_2],",
          "575:         sep='_X_')",
          "576:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "577:     # pyformat: disable",
          "578:     expected_out = self._sparse_tensor([",
          "579:         ['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2',",
          "580:          'batch1-FC1-F2_X_batch1-FC2-F1', 'batch1-FC1-F2_X_batch1-FC2-F2'",
          "581:         ],",
          "582:         ['batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',",
          "583:          'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'",
          "584:         ]])",
          "585:     # pyformat: enable",
          "586:     with self.cached_session():",
          "587:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "589:   @test_util.run_deprecated_v1",
          "590:   def test_dense_sep(self):",
          "591:     \"\"\"Tests only dense inputs.\"\"\"",
          "592:     dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],",
          "593:                                         ['batch2-FC1-F1', 'batch2-FC1-F2']],",
          "594:                                        dtypes.string)",
          "595:     dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],",
          "596:                                         ['batch2-FC2-F1', 'batch2-FC2-F2']],",
          "597:                                        dtypes.string)",
          "598:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "599:         indices=[],",
          "600:         values=[],",
          "601:         shapes=[],",
          "602:         dense_inputs=[dense_inp_1, dense_inp_2],",
          "603:         sep='_')",
          "604:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "605:     # pyformat: disable",
          "606:     expected_out = self._sparse_tensor([",
          "607:         ['batch1-FC1-F1_batch1-FC2-F1', 'batch1-FC1-F1_batch1-FC2-F2',",
          "608:          'batch1-FC1-F2_batch1-FC2-F1', 'batch1-FC1-F2_batch1-FC2-F2'",
          "609:         ],",
          "610:         ['batch2-FC1-F1_batch2-FC2-F1', 'batch2-FC1-F1_batch2-FC2-F2',",
          "611:          'batch2-FC1-F2_batch2-FC2-F1', 'batch2-FC1-F2_batch2-FC2-F2'",
          "612:         ]])",
          "613:     # pyformat: enable",
          "614:     with self.cached_session():",
          "615:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "617:   @test_util.run_deprecated_v1",
          "618:   def test_integer_mixed_string_sparse(self):",
          "619:     \"\"\"Tests mixed type.\"\"\"",
          "620:     sp_inp_1 = self._sparse_tensor([[11], [333, 55555]])",
          "621:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],",
          "622:                                     ['batch2-FC2-F1', 'batch2-FC2-F2']])",
          "623:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "624:         indices=[sp_inp_1.indices, sp_inp_2.indices],",
          "625:         values=[sp_inp_1.values, sp_inp_2.values],",
          "626:         shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],",
          "627:         dense_inputs=[],",
          "628:         sep='_X_')",
          "629:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "630:     # pyformat: disable",
          "631:     expected_out = self._sparse_tensor([",
          "632:         ['11_X_batch1-FC2-F1'],",
          "633:         ['333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2',",
          "634:          '55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2'",
          "635:         ]])",
          "636:     # pyformat: enable",
          "637:     with self.cached_session():",
          "638:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "640:   @test_util.run_deprecated_v1",
          "641:   def test_integer_mixed_string_dense(self):",
          "642:     \"\"\"Tests mixed dense inputs.\"\"\"",
          "643:     dense_inp_1 = constant_op.constant([[11, 333], [55555, 999999]],",
          "644:                                        dtypes.int64)",
          "645:     dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],",
          "646:                                         ['batch2-FC2-F1', 'batch2-FC2-F2']],",
          "647:                                        dtypes.string)",
          "648:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "649:         indices=[],",
          "650:         values=[],",
          "651:         shapes=[],",
          "652:         dense_inputs=[dense_inp_1, dense_inp_2],",
          "653:         sep='_X_')",
          "654:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "655:     # pyformat: disable",
          "656:     expected_out = self._sparse_tensor([",
          "657:         ['11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2',",
          "658:          '333_X_batch1-FC2-F1', '333_X_batch1-FC2-F2'",
          "659:         ],",
          "660:         ['55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2',",
          "661:          '999999_X_batch2-FC2-F1', '999999_X_batch2-FC2-F2'",
          "662:         ]])",
          "663:     # pyformat: enable",
          "664:     with self.cached_session():",
          "665:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "667:   @test_util.run_deprecated_v1",
          "668:   def test_sparse_cross_dense(self):",
          "669:     \"\"\"Tests sparse and dense inputs.\"\"\"",
          "670:     sp_inp = self._sparse_tensor([['batch1-FC1-F1'],",
          "671:                                   ['batch2-FC1-F1', 'batch2-FC1-F2']])",
          "672:     dense_inp = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],",
          "673:                                       ['batch2-FC2-F1', 'batch2-FC2-F2']],",
          "674:                                      dtypes.string)",
          "675:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "676:         indices=[sp_inp.indices],",
          "677:         values=[sp_inp.values],",
          "678:         shapes=[sp_inp.dense_shape],",
          "679:         dense_inputs=[dense_inp],",
          "680:         sep='_X_')",
          "681:     expected_out = self._sparse_tensor(",
          "682:         [['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2'],",
          "683:          [",
          "684:              'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',",
          "685:              'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'",
          "686:          ]])",
          "687:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "688:     with self.cached_session():",
          "689:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "691:   @test_util.run_deprecated_v1",
          "692:   def test_permutation_3x3x3(self):",
          "693:     \"\"\"Tests 3x3x3 permutation.\"\"\"",
          "694:     sp_inp_1 = self._sparse_tensor(",
          "695:         [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])",
          "696:     sp_inp_2 = self._sparse_tensor(",
          "697:         [['batch1-FC2-F1', 'batch1-FC2-F2', 'batch1-FC2-F3']])",
          "698:     sp_inp_3 = self._sparse_tensor(",
          "699:         [['batch1-FC3-F1', 'batch1-FC3-F2', 'batch1-FC3-F3']])",
          "700:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "701:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "702:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "703:         shapes=[",
          "704:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "705:         ],",
          "706:         dense_inputs=[],",
          "707:         sep='_X_')",
          "708:     expected_out = self._sparse_tensor([[",
          "709:         'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "710:         'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',",
          "711:         'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F3',",
          "712:         'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F1',",
          "713:         'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F2',",
          "714:         'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F3',",
          "715:         'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F1',",
          "716:         'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F2',",
          "717:         'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F3',",
          "718:         'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "719:         'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',",
          "720:         'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F3',",
          "721:         'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F1',",
          "722:         'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F2',",
          "723:         'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F3',",
          "724:         'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F1',",
          "725:         'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F2',",
          "726:         'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F3',",
          "727:         'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "728:         'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2',",
          "729:         'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F3',",
          "730:         'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F1',",
          "731:         'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F2',",
          "732:         'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F3',",
          "733:         'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F1',",
          "734:         'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F2',",
          "735:         'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F3'",
          "736:     ]])",
          "737:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "738:     with self.cached_session():",
          "739:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "741:   @test_util.run_deprecated_v1",
          "742:   def test_permutation_3x1x2(self):",
          "743:     \"\"\"Tests 3x1x2 permutation.\"\"\"",
          "744:     sp_inp_1 = self._sparse_tensor(",
          "745:         [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])",
          "746:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])",
          "747:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])",
          "748:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "749:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "750:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "751:         shapes=[",
          "752:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "753:         ],",
          "754:         dense_inputs=[],",
          "755:         sep='_X_')",
          "756:     expected_out = self._sparse_tensor([[",
          "757:         'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "758:         'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',",
          "759:         'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "760:         'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',",
          "761:         'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "762:         'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2'",
          "763:     ]])",
          "764:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "765:     with self.cached_session():",
          "766:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "768:   @test_util.run_deprecated_v1",
          "769:   def test_large_batch(self):",
          "770:     \"\"\"Tests with large batch size to force multithreading.\"\"\"",
          "771:     batch_size = 5000",
          "772:     col1 = []",
          "773:     col2 = []",
          "774:     col3 = []",
          "775:     for b in range(batch_size):",
          "776:       col1.append(",
          "777:           ['batch%d-FC1-F1' % b,",
          "778:            'batch%d-FC1-F2' % b,",
          "779:            'batch%d-FC1-F3' % b])",
          "780:       col2.append(['batch%d-FC2-F1' % b])",
          "781:       col3.append(['batch%d-FC3-F1' % b, 'batch%d-FC3-F2' % b])",
          "782:     sp_inp_1 = self._sparse_tensor(col1)",
          "783:     sp_inp_2 = self._sparse_tensor(col2)",
          "784:     sp_inp_3 = self._sparse_tensor(col3)",
          "786:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "787:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "788:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "789:         shapes=[",
          "790:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "791:         ],",
          "792:         dense_inputs=[],",
          "793:         sep='_X_')",
          "795:     col_out = []",
          "796:     for b in range(batch_size):",
          "797:       col_out.append([",
          "798:           'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),",
          "799:           'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),",
          "800:           'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),",
          "801:           'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),",
          "802:           'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),",
          "803:           'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b)",
          "804:       ])",
          "806:     expected_out = self._sparse_tensor(col_out)",
          "807:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "808:     with self.cached_session():",
          "809:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "811:   @test_util.run_deprecated_v1",
          "812:   def test_one_column_empty(self):",
          "813:     \"\"\"Tests when one column is empty.",
          "815:     The crossed tensor should be empty.",
          "816:     \"\"\"",
          "817:     sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']])",
          "818:     sp_inp_2 = self._sparse_tensor([], 1)",
          "819:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])",
          "820:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "821:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "822:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "823:         shapes=[",
          "824:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "825:         ],",
          "826:         dense_inputs=[],",
          "827:         sep='_X_')",
          "828:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "829:     with self.cached_session():",
          "830:       self._assert_sparse_tensor_empty(self.evaluate(out))",
          "832:   @test_util.run_deprecated_v1",
          "833:   def test_some_columns_empty(self):",
          "834:     \"\"\"Tests when more than one columns are empty.",
          "836:     Cross for the corresponding batch should be empty.",
          "837:     \"\"\"",
          "838:     sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']], 2)",
          "839:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'], ['batch2-FC2-F1']], 2)",
          "840:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']], 2)",
          "841:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "842:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "843:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "844:         shapes=[",
          "845:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "846:         ],",
          "847:         dense_inputs=[],",
          "848:         sep='_X_')",
          "849:     expected_out = self._sparse_tensor([[",
          "850:         'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "851:         'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',",
          "852:         'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',",
          "853:         'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2'",
          "854:     ]], 2)",
          "855:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "856:     with self.cached_session():",
          "857:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "859:   @test_util.run_deprecated_v1",
          "860:   def test_all_columns_empty(self):",
          "861:     \"\"\"Tests when all columns are empty.",
          "863:     The crossed tensor should be empty.",
          "864:     \"\"\"",
          "865:     sp_inp_1 = self._sparse_tensor([])",
          "866:     sp_inp_2 = self._sparse_tensor([])",
          "867:     sp_inp_3 = self._sparse_tensor([])",
          "868:     inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(",
          "869:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "870:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "871:         shapes=[",
          "872:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "873:         ],",
          "874:         dense_inputs=[],",
          "875:         sep='_X_')",
          "876:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "877:     with self.cached_session():",
          "878:       self._assert_sparse_tensor_empty(self.evaluate(out))",
          "881: class SparseCrossHashedOpTest(BaseSparseCrossOpTest):",
          "883:   @test_util.run_deprecated_v1",
          "884:   def test_hashed_zero_bucket_no_hash_key(self):",
          "885:     sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])",
          "886:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])",
          "887:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])",
          "888:     inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(",
          "889:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "890:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "891:         shapes=[",
          "892:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "893:         ],",
          "894:         dense_inputs=[],",
          "895:         num_buckets=0,",
          "896:         salt=[1, 1],",
          "897:         strong_hash=False)",
          "898:     # Check actual hashed output to prevent unintentional hashing changes.",
          "899:     expected_out = self._sparse_tensor([[9186962005966787372]])",
          "900:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "901:     with self.cached_session():",
          "902:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "904:     # salt is not being used when `strong_hash` is False.",
          "905:     inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(",
          "906:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "907:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "908:         shapes=[",
          "909:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "910:         ],",
          "911:         dense_inputs=[],",
          "912:         num_buckets=0,",
          "913:         salt=[137, 173],",
          "914:         strong_hash=False)",
          "915:     out_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)",
          "916:     with self.cached_session():",
          "917:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out_2))",
          "919:   @test_util.run_deprecated_v1",
          "920:   def test_hashed_output(self):",
          "921:     sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])",
          "922:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])",
          "923:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])",
          "924:     inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(",
          "925:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "926:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "927:         shapes=[",
          "928:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "929:         ],",
          "930:         dense_inputs=[],",
          "931:         num_buckets=100,",
          "932:         salt=[137, 173],",
          "933:         strong_hash=False)",
          "934:     # Check actual hashed output to prevent unintentional hashing changes.",
          "935:     expected_out = self._sparse_tensor([[79]])",
          "936:     out = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "937:     with self.cached_session():",
          "938:       self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))",
          "940:   @test_util.run_deprecated_v1",
          "941:   def test_hashed_has_no_collision(self):",
          "942:     \"\"\"Tests that fingerprint concatenation has no collisions.\"\"\"",
          "943:     # Although the last 10 bits of 359 and 1024+359 are identical.",
          "944:     # As a result, all the crosses shouldn't collide.",
          "945:     t1 = constant_op.constant([[359], [359 + 1024]], dtype=dtypes.int64)",
          "946:     t2 = constant_op.constant(",
          "947:         [list(range(10)), list(range(10))], dtype=dtypes.int64)",
          "948:     inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(",
          "949:         indices=[],",
          "950:         values=[],",
          "951:         shapes=[],",
          "952:         dense_inputs=[t2, t1],",
          "953:         num_buckets=1024,",
          "954:         salt=[137, 173],",
          "955:         strong_hash=False)",
          "956:     cross = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "957:     cross_dense = sparse_ops.sparse_tensor_to_dense(cross)",
          "958:     with session.Session():",
          "959:       values = self.evaluate(cross_dense)",
          "960:       self.assertTrue(numpy.not_equal(values[0], values[1]).all())",
          "962:   def test_hashed_3x1x2(self):",
          "963:     \"\"\"Tests 3x1x2 permutation with hashed output.\"\"\"",
          "964:     sp_inp_1 = self._sparse_tensor(",
          "965:         [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])",
          "966:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])",
          "967:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])",
          "968:     inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(",
          "969:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "970:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "971:         shapes=[",
          "972:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "973:         ],",
          "974:         dense_inputs=[],",
          "975:         num_buckets=1000,",
          "976:         salt=[137, 173],",
          "977:         strong_hash=False)",
          "978:     output = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "979:     with self.cached_session():",
          "980:       out = self.evaluate(output)",
          "981:       self.assertEqual(6, len(out.values))",
          "982:       self.assertAllEqual([[0, i] for i in range(6)], out.indices)",
          "983:       self.assertTrue(all(x < 1000 and x >= 0 for x in out.values))",
          "984:       all_values_are_different = len(out.values) == len(set(out.values))",
          "985:       self.assertTrue(all_values_are_different)",
          "987:   def test_hashed_different_salt(self):",
          "988:     sp_inp_1 = self._sparse_tensor(",
          "989:         [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])",
          "990:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])",
          "991:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])",
          "992:     inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(",
          "993:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "994:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "995:         shapes=[",
          "996:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "997:         ],",
          "998:         dense_inputs=[],",
          "999:         strong_hash=False,",
          "1000:         num_buckets=1000,",
          "1001:         salt=[137, 173])",
          "1002:     output = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "1003:     inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(",
          "1004:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "1005:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "1006:         shapes=[",
          "1007:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "1008:         ],",
          "1009:         dense_inputs=[],",
          "1010:         strong_hash=True,",
          "1011:         num_buckets=1000,",
          "1012:         salt=[137, 1])",
          "1013:     output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)",
          "1014:     with self.cached_session():",
          "1015:       out = self.evaluate(output)",
          "1016:       out_2 = self.evaluate(output_2)",
          "1017:       self.assertAllEqual(out.indices, out_2.indices)",
          "1018:       self.assertNotAllEqual(out.values, out_2.values)",
          "1020:   def test_sep_ignored_in_hashed_out(self):",
          "1021:     sp_inp_1 = self._sparse_tensor(",
          "1022:         [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])",
          "1023:     sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])",
          "1024:     sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])",
          "1025:     inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(",
          "1026:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "1027:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "1028:         shapes=[",
          "1029:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "1030:         ],",
          "1031:         dense_inputs=[],",
          "1032:         strong_hash=True,",
          "1033:         num_buckets=1000,",
          "1034:         salt=[137, 173])",
          "1035:     output = sparse_tensor.SparseTensor(inds, vals, shapes)",
          "1036:     inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(",
          "1037:         indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],",
          "1038:         values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],",
          "1039:         shapes=[",
          "1040:             sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape",
          "1041:         ],",
          "1042:         dense_inputs=[],",
          "1043:         strong_hash=True,",
          "1044:         num_buckets=1000,",
          "1045:         salt=[137, 173])",
          "1046:     output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)",
          "1047:     with self.cached_session():",
          "1048:       out = self.evaluate(output)",
          "1049:       out_2 = self.evaluate(output_2)",
          "1050:       self.assertAllEqual(out.indices, out_2.indices)",
          "1051:       self.assertAllEqual(out.values, out_2.values)",
          "",
          "---------------"
        ],
        "tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt": [
          "File: tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt -> tensorflow/tools/api/golden/v1/tensorflow.raw_ops.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "4100:     name: \"SparseCross\"",
          "4101:     argspec: \"args=[\\'indices\\', \\'values\\', \\'shapes\\', \\'dense_inputs\\', \\'hashed_output\\', \\'num_buckets\\', \\'hash_key\\', \\'out_type\\', \\'internal_type\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "4102:   }",
          "4103:   member_method {",
          "4104:     name: \"SparseDenseCwiseAdd\"",
          "4105:     argspec: \"args=[\\'sp_indices\\', \\'sp_values\\', \\'sp_shape\\', \\'dense\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4103:   member_method {",
          "4104:     name: \"SparseCrossHashed\"",
          "4105:     argspec: \"args=[\\'indices\\', \\'values\\', \\'shapes\\', \\'dense_inputs\\', \\'num_buckets\\', \\'strong_hash\\', \\'salt\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "4106:   }",
          "4107:   member_method {",
          "4108:     name: \"SparseCrossV2\"",
          "4109:     argspec: \"args=[\\'indices\\', \\'values\\', \\'shapes\\', \\'dense_inputs\\', \\'sep\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "4110:   }",
          "",
          "---------------"
        ],
        "tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt||tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt": [
          "File: tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt -> tensorflow/tools/api/golden/v2/tensorflow.raw_ops.pbtxt",
          "--- Hunk 1 ---",
          "[Context before]",
          "4100:     name: \"SparseCross\"",
          "4101:     argspec: \"args=[\\'indices\\', \\'values\\', \\'shapes\\', \\'dense_inputs\\', \\'hashed_output\\', \\'num_buckets\\', \\'hash_key\\', \\'out_type\\', \\'internal_type\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "4102:   }",
          "4103:   member_method {",
          "4104:     name: \"SparseDenseCwiseAdd\"",
          "4105:     argspec: \"args=[\\'sp_indices\\', \\'sp_values\\', \\'sp_shape\\', \\'dense\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4103:   member_method {",
          "4104:     name: \"SparseCrossHashed\"",
          "4105:     argspec: \"args=[\\'indices\\', \\'values\\', \\'shapes\\', \\'dense_inputs\\', \\'num_buckets\\', \\'strong_hash\\', \\'salt\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "4106:   }",
          "4107:   member_method {",
          "4108:     name: \"SparseCrossV2\"",
          "4109:     argspec: \"args=[\\'indices\\', \\'values\\', \\'shapes\\', \\'dense_inputs\\', \\'sep\\', \\'name\\'], varargs=None, keywords=None, defaults=[\\'None\\'], \"",
          "4110:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3d73571f03aad57af7a16b897093c6dbda98793a",
      "candidate_info": {
        "commit_hash": "3d73571f03aad57af7a16b897093c6dbda98793a",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/3d73571f03aad57af7a16b897093c6dbda98793a",
        "files": [
          "tensorflow/core/kernels/sparse_cross_op.cc"
        ],
        "message": "Fix `tf.raw_ops.SparseCross` failing CHECK.\n\nPiperOrigin-RevId: 368701671\nChange-Id: Id805729dd9ba0bda36e4bb309408129b55fb649d",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc": [
          "File: tensorflow/core/kernels/sparse_cross_op.cc -> tensorflow/core/kernels/sparse_cross_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"tensorflow/core/framework/tensor.h\"",
          "28: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "29: #include \"tensorflow/core/framework/types.h\"",
          "30: #include \"tensorflow/core/lib/core/stringpiece.h\"",
          "31: #include \"tensorflow/core/lib/strings/str_util.h\"",
          "32: #include \"tensorflow/core/platform/fingerprint.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"tensorflow/core/framework/types.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "460: Status ValidateInput(const OpInputList& indices_list_in,",
          "461:                      const OpInputList& values_list_in,",
          "462:                      const OpInputList& shapes_list_in,",
          "464:   const auto size = indices_list_in.size();",
          "466:   for (int i = 0; i < size; i++) {",
          "467:     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {",
          "468:       return errors::InvalidArgument(",
          "469:           \"Input indices should be a matrix but received shape \",",
          "",
          "[Removed Lines]",
          "463:                      const OpInputList& dense_list_in) {",
          "",
          "[Added Lines]",
          "464:                      const OpInputList& dense_list_in,",
          "465:                      const DataType& internal_type) {",
          "469:   bool check_type = internal_type != DT_INVALID;",
          "472:     if (check_type && indices_list_in[i].dtype() != DT_INT64) {",
          "473:       return errors::InvalidArgument(\"Input indices should be of type \",",
          "474:                                      DT_INT64, \" but received \",",
          "475:                                      indices_list_in[i].dtype());",
          "476:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "482:                                    values_list_in.size());",
          "483:   }",
          "484:   for (int i = 0; i < size; i++) {",
          "485:     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {",
          "486:       return errors::InvalidArgument(",
          "487:           \"Input values should be a vector but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "497:     if (check_type && internal_type == DT_STRING &&",
          "498:         values_list_in[i].dtype() == DT_INT64) {",
          "499:       return errors::InvalidArgument(\"Input values should be of internal type \",",
          "500:                                      internal_type, \" but received \",",
          "501:                                      values_list_in[i].dtype());",
          "502:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "502:                                    shapes_list_in.size());",
          "503:   }",
          "504:   for (int i = 0; i < size; i++) {",
          "505:     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {",
          "506:       return errors::InvalidArgument(",
          "507:           \"Input shapes should be a vector but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "523:     if (check_type && shapes_list_in[i].dtype() != DT_INT64) {",
          "524:       return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,",
          "525:                                      \" but received \",",
          "526:                                      shapes_list_in[i].dtype());",
          "527:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "519:   for (int i = 0; i < dense_list_in.size(); ++i) {",
          "520:     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {",
          "521:       return errors::InvalidArgument(",
          "522:           \"Dense inputs should be a matrix but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "545:     if (check_type && internal_type == DT_STRING &&",
          "546:         dense_list_in[i].dtype() == DT_INT64) {",
          "547:       return errors::InvalidArgument(\"Dense inputs should be of internal type \",",
          "548:                                      internal_type, \" but received \",",
          "549:                                      dense_list_in[i].dtype());",
          "550:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "698:     int64 signed_hash_key_;",
          "699:     OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));",
          "700:     hash_key_ = static_cast<uint64>(signed_hash_key_);",
          "701:   }",
          "703:   void Compute(OpKernelContext* context) override {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "732:     OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "711:     OP_REQUIRES_OK(context,",
          "712:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "717:     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =",
          "718:         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,",
          "",
          "[Removed Lines]",
          "714:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "715:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "746:     DataType internal_type = internal_type_;",
          "747:     OP_REQUIRES_OK(",
          "748:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "749:                                dense_list_in, internal_type));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "756:  private:",
          "757:   int64 num_buckets_;",
          "758:   uint64 hash_key_;",
          "759: };",
          "761: class SparseCrossV2Op : public OpKernel {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "793:   DataType internal_type_;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "773:     OP_REQUIRES_OK(context,",
          "774:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "779:     const Tensor* sep_t;",
          "780:     OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));",
          "",
          "[Removed Lines]",
          "776:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "777:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "812:     DataType internal_type = DT_INVALID;",
          "813:     OP_REQUIRES_OK(",
          "814:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "815:                                dense_list_in, internal_type));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "832:     OP_REQUIRES_OK(context,",
          "833:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "838:     const Tensor* num_buckets_t;",
          "839:     OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));",
          "",
          "[Removed Lines]",
          "835:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "836:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "874:     DataType internal_type = DT_INVALID;",
          "875:     OP_REQUIRES_OK(",
          "876:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "877:                                dense_list_in, internal_type));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c25df2b556793ab229221dc9e1ad27e3cbb18582",
      "candidate_info": {
        "commit_hash": "c25df2b556793ab229221dc9e1ad27e3cbb18582",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/c25df2b556793ab229221dc9e1ad27e3cbb18582",
        "files": [
          "tensorflow/core/kernels/sparse_cross_op.cc"
        ],
        "message": "Fix `tf.raw_ops.SparseCross` failing CHECK.\n\nPiperOrigin-RevId: 368701671\nChange-Id: Id805729dd9ba0bda36e4bb309408129b55fb649d",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc": [
          "File: tensorflow/core/kernels/sparse_cross_op.cc -> tensorflow/core/kernels/sparse_cross_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"tensorflow/core/framework/tensor.h\"",
          "28: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "29: #include \"tensorflow/core/framework/types.h\"",
          "30: #include \"tensorflow/core/lib/core/stringpiece.h\"",
          "31: #include \"tensorflow/core/lib/strings/str_util.h\"",
          "32: #include \"tensorflow/core/platform/fingerprint.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"tensorflow/core/framework/types.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "460: Status ValidateInput(const OpInputList& indices_list_in,",
          "461:                      const OpInputList& values_list_in,",
          "462:                      const OpInputList& shapes_list_in,",
          "464:   const auto size = indices_list_in.size();",
          "466:   for (int i = 0; i < size; i++) {",
          "467:     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {",
          "468:       return errors::InvalidArgument(",
          "469:           \"Input indices should be a matrix but received shape \",",
          "",
          "[Removed Lines]",
          "463:                      const OpInputList& dense_list_in) {",
          "",
          "[Added Lines]",
          "464:                      const OpInputList& dense_list_in,",
          "465:                      const DataType& internal_type) {",
          "469:   bool check_type = internal_type != DT_INVALID;",
          "472:     if (check_type && indices_list_in[i].dtype() != DT_INT64) {",
          "473:       return errors::InvalidArgument(\"Input indices should be of type \",",
          "474:                                      DT_INT64, \" but received \",",
          "475:                                      indices_list_in[i].dtype());",
          "476:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "482:                                    values_list_in.size());",
          "483:   }",
          "484:   for (int i = 0; i < size; i++) {",
          "485:     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {",
          "486:       return errors::InvalidArgument(",
          "487:           \"Input values should be a vector but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "497:     if (check_type && internal_type == DT_STRING &&",
          "498:         values_list_in[i].dtype() == DT_INT64) {",
          "499:       return errors::InvalidArgument(\"Input values should be of internal type \",",
          "500:                                      internal_type, \" but received \",",
          "501:                                      values_list_in[i].dtype());",
          "502:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "502:                                    shapes_list_in.size());",
          "503:   }",
          "504:   for (int i = 0; i < size; i++) {",
          "505:     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {",
          "506:       return errors::InvalidArgument(",
          "507:           \"Input shapes should be a vector but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "523:     if (check_type && shapes_list_in[i].dtype() != DT_INT64) {",
          "524:       return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,",
          "525:                                      \" but received \",",
          "526:                                      shapes_list_in[i].dtype());",
          "527:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "519:   for (int i = 0; i < dense_list_in.size(); ++i) {",
          "520:     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {",
          "521:       return errors::InvalidArgument(",
          "522:           \"Dense inputs should be a matrix but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "545:     if (check_type && internal_type == DT_STRING &&",
          "546:         dense_list_in[i].dtype() == DT_INT64) {",
          "547:       return errors::InvalidArgument(\"Dense inputs should be of internal type \",",
          "548:                                      internal_type, \" but received \",",
          "549:                                      dense_list_in[i].dtype());",
          "550:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "698:     int64 signed_hash_key_;",
          "699:     OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));",
          "700:     hash_key_ = static_cast<uint64>(signed_hash_key_);",
          "701:   }",
          "703:   void Compute(OpKernelContext* context) override {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "732:     OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "711:     OP_REQUIRES_OK(context,",
          "712:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "717:     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =",
          "718:         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,",
          "",
          "[Removed Lines]",
          "714:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "715:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "746:     DataType internal_type = internal_type_;",
          "747:     OP_REQUIRES_OK(",
          "748:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "749:                                dense_list_in, internal_type));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "756:  private:",
          "757:   int64 num_buckets_;",
          "758:   uint64 hash_key_;",
          "759: };",
          "761: class SparseCrossV2Op : public OpKernel {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "793:   DataType internal_type_;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "773:     OP_REQUIRES_OK(context,",
          "774:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "779:     const Tensor* sep_t;",
          "780:     OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));",
          "",
          "[Removed Lines]",
          "776:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "777:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "812:     DataType internal_type = DT_INVALID;",
          "813:     OP_REQUIRES_OK(",
          "814:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "815:                                dense_list_in, internal_type));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "832:     OP_REQUIRES_OK(context,",
          "833:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "838:     const Tensor* num_buckets_t;",
          "839:     OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));",
          "",
          "[Removed Lines]",
          "835:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "836:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "874:     DataType internal_type = DT_INVALID;",
          "875:     OP_REQUIRES_OK(",
          "876:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "877:                                dense_list_in, internal_type));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c664ac88cdf1523f4beb84834afc574e6d49cbbf",
      "candidate_info": {
        "commit_hash": "c664ac88cdf1523f4beb84834afc574e6d49cbbf",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/c664ac88cdf1523f4beb84834afc574e6d49cbbf",
        "files": [
          "tensorflow/core/kernels/sparse_cross_op.cc"
        ],
        "message": "Fix `tf.raw_ops.SparseCross` failing CHECK.\n\nPiperOrigin-RevId: 368701671\nChange-Id: Id805729dd9ba0bda36e4bb309408129b55fb649d",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc": [
          "File: tensorflow/core/kernels/sparse_cross_op.cc -> tensorflow/core/kernels/sparse_cross_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: #include \"tensorflow/core/framework/tensor.h\"",
          "28: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "29: #include \"tensorflow/core/framework/types.h\"",
          "30: #include \"tensorflow/core/lib/core/stringpiece.h\"",
          "31: #include \"tensorflow/core/lib/strings/str_util.h\"",
          "32: #include \"tensorflow/core/platform/fingerprint.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "30: #include \"tensorflow/core/framework/types.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "460: Status ValidateInput(const OpInputList& indices_list_in,",
          "461:                      const OpInputList& values_list_in,",
          "462:                      const OpInputList& shapes_list_in,",
          "464:   const auto size = indices_list_in.size();",
          "466:   for (int i = 0; i < size; i++) {",
          "467:     if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {",
          "468:       return errors::InvalidArgument(",
          "469:           \"Input indices should be a matrix but received shape \",",
          "",
          "[Removed Lines]",
          "463:                      const OpInputList& dense_list_in) {",
          "",
          "[Added Lines]",
          "464:                      const OpInputList& dense_list_in,",
          "465:                      const DataType& internal_type) {",
          "469:   bool check_type = internal_type != DT_INVALID;",
          "472:     if (check_type && indices_list_in[i].dtype() != DT_INT64) {",
          "473:       return errors::InvalidArgument(\"Input indices should be of type \",",
          "474:                                      DT_INT64, \" but received \",",
          "475:                                      indices_list_in[i].dtype());",
          "476:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "482:                                    values_list_in.size());",
          "483:   }",
          "484:   for (int i = 0; i < size; i++) {",
          "485:     if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {",
          "486:       return errors::InvalidArgument(",
          "487:           \"Input values should be a vector but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "497:     if (check_type && internal_type == DT_STRING &&",
          "498:         values_list_in[i].dtype() == DT_INT64) {",
          "499:       return errors::InvalidArgument(\"Input values should be of internal type \",",
          "500:                                      internal_type, \" but received \",",
          "501:                                      values_list_in[i].dtype());",
          "502:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "502:                                    shapes_list_in.size());",
          "503:   }",
          "504:   for (int i = 0; i < size; i++) {",
          "505:     if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {",
          "506:       return errors::InvalidArgument(",
          "507:           \"Input shapes should be a vector but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "523:     if (check_type && shapes_list_in[i].dtype() != DT_INT64) {",
          "524:       return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,",
          "525:                                      \" but received \",",
          "526:                                      shapes_list_in[i].dtype());",
          "527:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "519:   for (int i = 0; i < dense_list_in.size(); ++i) {",
          "520:     if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {",
          "521:       return errors::InvalidArgument(",
          "522:           \"Dense inputs should be a matrix but received shape \",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "545:     if (check_type && internal_type == DT_STRING &&",
          "546:         dense_list_in[i].dtype() == DT_INT64) {",
          "547:       return errors::InvalidArgument(\"Dense inputs should be of internal type \",",
          "548:                                      internal_type, \" but received \",",
          "549:                                      dense_list_in[i].dtype());",
          "550:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "698:     int64 signed_hash_key_;",
          "699:     OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));",
          "700:     hash_key_ = static_cast<uint64>(signed_hash_key_);",
          "701:   }",
          "703:   void Compute(OpKernelContext* context) override {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "732:     OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "711:     OP_REQUIRES_OK(context,",
          "712:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "717:     std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =",
          "718:         GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,",
          "",
          "[Removed Lines]",
          "714:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "715:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "746:     DataType internal_type = internal_type_;",
          "747:     OP_REQUIRES_OK(",
          "748:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "749:                                dense_list_in, internal_type));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "756:  private:",
          "757:   int64 num_buckets_;",
          "758:   uint64 hash_key_;",
          "759: };",
          "761: class SparseCrossV2Op : public OpKernel {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "793:   DataType internal_type_;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "773:     OP_REQUIRES_OK(context,",
          "774:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "779:     const Tensor* sep_t;",
          "780:     OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));",
          "",
          "[Removed Lines]",
          "776:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "777:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "812:     DataType internal_type = DT_INVALID;",
          "813:     OP_REQUIRES_OK(",
          "814:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "815:                                dense_list_in, internal_type));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "832:     OP_REQUIRES_OK(context,",
          "833:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "838:     const Tensor* num_buckets_t;",
          "839:     OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));",
          "",
          "[Removed Lines]",
          "835:     OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,",
          "836:                                           shapes_list_in, dense_list_in));",
          "",
          "[Added Lines]",
          "874:     DataType internal_type = DT_INVALID;",
          "875:     OP_REQUIRES_OK(",
          "876:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "877:                                dense_list_in, internal_type));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "89d9c336b7d0f5031a4e15488a6f1ede918c6df3",
      "candidate_info": {
        "commit_hash": "89d9c336b7d0f5031a4e15488a6f1ede918c6df3",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/89d9c336b7d0f5031a4e15488a6f1ede918c6df3",
        "files": [
          "tensorflow/core/kernels/sparse_cross_op.cc"
        ],
        "message": "Fix  failing CHECK.",
        "before_after_code_files": [
          "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/sparse_cross_op.cc||tensorflow/core/kernels/sparse_cross_op.cc": [
          "File: tensorflow/core/kernels/sparse_cross_op.cc -> tensorflow/core/kernels/sparse_cross_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include \"tensorflow/core/framework/tensor.h\"",
          "27: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "28: #include \"tensorflow/core/framework/types.h\"",
          "29: #include \"tensorflow/core/lib/core/stringpiece.h\"",
          "30: #include \"tensorflow/core/lib/strings/str_util.h\"",
          "31: #include \"tensorflow/core/platform/fingerprint.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29: #include \"tensorflow/core/framework/types.pb.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "295:     int64 signed_hash_key_;",
          "296:     OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));",
          "297:     hash_key_ = static_cast<uint64>(signed_hash_key_);",
          "298:   }",
          "300:   void Compute(OpKernelContext* context) override {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "299:     OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "307:     OpInputList dense_list_in;",
          "308:     OP_REQUIRES_OK(context,",
          "309:                    context->input_list(\"dense_inputs\", &dense_list_in));",
          "311:     ValidateInput(context, indices_list_in, values_list_in, shapes_list_in,",
          "312:                   dense_list_in);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312:     DataType internal_type = internal_type_;",
          "313:     OP_REQUIRES_OK(",
          "314:         context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,",
          "315:                                dense_list_in, internal_type));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "352:                      const OpInputList& indices_list_in,",
          "353:                      const OpInputList& values_list_in,",
          "354:                      const OpInputList& shapes_list_in,",
          "356:     const auto size = indices_list_in.size();",
          "358:     for (int i = 0; i < size; i++) {",
          "359:       OP_REQUIRES(",
          "360:           context, TensorShapeUtils::IsMatrix(indices_list_in[i].shape()),",
          "361:           errors::InvalidArgument(",
          "",
          "[Removed Lines]",
          "355:                      const OpInputList& dense_list_in) {",
          "",
          "[Added Lines]",
          "361:                      const OpInputList& dense_list_in,",
          "362:                      const DataType& internal_type) {",
          "366:     bool check_type = internal_type != DT_INVALID;",
          "369:       if (check_type && indices_list_in[i].dtype() != DT_INT64) {",
          "370:       return errors::InvalidArgument(\"Input indices should be of type \",",
          "371:                                      DT_INT64, \" but received \",",
          "372:                                      indices_list_in[i].dtype());",
          "373:       }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "374:         errors::InvalidArgument(\"Expected \", size, \" input values, got \",",
          "375:                                 values_list_in.size()));",
          "376:     for (int i = 0; i < size; i++) {",
          "377:       OP_REQUIRES(",
          "378:           context, TensorShapeUtils::IsVector(values_list_in[i].shape()),",
          "379:           errors::InvalidArgument(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "394:       if (check_type && internal_type == DT_STRING &&",
          "395:           values_list_in[i].dtype() == DT_INT64) {",
          "396:         return errors::InvalidArgument(\"Input values should be of internal type \",",
          "397:                                        internal_type, \" but received \",",
          "398:                                        values_list_in[i].dtype());",
          "399:       }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "396:                                 shapes_list_in.size()));",
          "397:     const auto batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);",
          "398:     for (int i = 0; i < size; i++) {",
          "399:       OP_REQUIRES(",
          "400:           context, TensorShapeUtils::IsVector(shapes_list_in[i].shape()),",
          "401:           errors::InvalidArgument(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "422:       if (check_type && shapes_list_in[i].dtype() != DT_INT64) {",
          "423:         return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,",
          "424:                                        \" but received \",",
          "425:                                        shapes_list_in[i].dtype());",
          "426:       }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "417:     for (int i = 0; i < dense_list_in.size(); ++i) {",
          "418:       OP_REQUIRES(",
          "419:           context, TensorShapeUtils::IsMatrix(dense_list_in[i].shape()),",
          "420:           errors::InvalidArgument(",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "448:       if (check_type && internal_type == DT_STRING &&",
          "449:           dense_list_in[i].dtype() == DT_INT64) {",
          "450:         return errors::InvalidArgument(\"Dense inputs should be of internal type \",",
          "451:                                        internal_type, \" but received \",",
          "452:                                        dense_list_in[i].dtype());",
          "453:       }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
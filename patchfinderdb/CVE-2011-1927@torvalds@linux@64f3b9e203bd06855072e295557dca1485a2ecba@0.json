{
  "cve_id": "CVE-2011-1927",
  "cve_desc": "The ip_expire function in net/ipv4/ip_fragment.c in the Linux kernel before 2.6.39 does not properly construct ICMP_TIME_EXCEEDED packets after a timeout, which allows remote attackers to cause a denial of service (invalid pointer dereference) via crafted fragmented packets.",
  "repo": "torvalds/linux",
  "patch_hash": "64f3b9e203bd06855072e295557dca1485a2ecba",
  "patch_info": {
    "commit_hash": "64f3b9e203bd06855072e295557dca1485a2ecba",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/64f3b9e203bd06855072e295557dca1485a2ecba",
    "files": [
      "net/ipv4/ip_fragment.c"
    ],
    "message": "net: ip_expire() must revalidate route\n\nCommit 4a94445c9a5c (net: Use ip_route_input_noref() in input path)\nadded a bug in IP defragmentation handling, in case timeout is fired.\n\nWhen a frame is defragmented, we use last skb dst field when building\nfinal skb. Its dst is valid, since we are in rcu read section.\n\nBut if a timeout occurs, we take first queued fragment to build one ICMP\nTIME EXCEEDED message. Problem is all queued skb have weak dst pointers,\nsince we escaped RCU critical section after their queueing. icmp_send()\nmight dereference a now freed (and possibly reused) part of memory.\n\nCalling skb_dst_drop() and ip_route_input_noref() to revalidate route is\nthe only possible choice.\n\nReported-by: Denys Fedoryshchenko <denys@visp.net.lb>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c"
    ]
  },
  "patch_diff": {
    "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c": [
      "File: net/ipv4/ip_fragment.c -> net/ipv4/ip_fragment.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "224:  if ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {",
      "225:   struct sk_buff *head = qp->q.fragments;",
      "227:   rcu_read_lock();",
      "228:   head->dev = dev_get_by_index_rcu(net, qp->iif);",
      "229:   if (!head->dev)",
      "230:    goto out_rcu_unlock;",
      "253:   icmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);",
      "",
      "[Removed Lines]",
      "236:   if (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {",
      "237:    const struct iphdr *iph = ip_hdr(head);",
      "238:    int err = ip_route_input(head, iph->daddr, iph->saddr,",
      "239:        iph->tos, head->dev);",
      "240:    if (unlikely(err))",
      "241:     goto out_rcu_unlock;",
      "247:    if (skb_rtable(head)->rt_type != RTN_LOCAL)",
      "248:     goto out_rcu_unlock;",
      "250:   }",
      "",
      "[Added Lines]",
      "226:   const struct iphdr *iph;",
      "227:   int err;",
      "235:   skb_dst_drop(head);",
      "236:   iph = ip_hdr(head);",
      "237:   err = ip_route_input_noref(head, iph->daddr, iph->saddr,",
      "238:         iph->tos, head->dev);",
      "239:   if (err)",
      "240:    goto out_rcu_unlock;",
      "246:   if (qp->user == IP_DEFRAG_CONNTRACK_IN &&",
      "247:       skb_rtable(head)->rt_type != RTN_LOCAL)",
      "248:    goto out_rcu_unlock;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "595fc71baa1e80420fe89a400ff2d9cc099d22fc",
      "candidate_info": {
        "commit_hash": "595fc71baa1e80420fe89a400ff2d9cc099d22fc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/595fc71baa1e80420fe89a400ff2d9cc099d22fc",
        "files": [
          "include/net/ip.h",
          "net/ipv4/ip_fragment.c"
        ],
        "message": "ipv4: Add ip_defrag() agent IP_DEFRAG_AF_PACKET.\n\nElide the ICMP on frag queue timeouts unconditionally for\nthis user.\n\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/net/ip.h||include/net/ip.h",
          "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c"
          ],
          "candidate": [
            "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/ip.h||include/net/ip.h": [
          "File: include/net/ip.h -> include/net/ip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "404:  __IP_DEFRAG_CONNTRACK_BRIDGE_IN = IP_DEFRAG_CONNTRACK_BRIDGE_IN + USHRT_MAX,",
          "405:  IP_DEFRAG_VS_IN,",
          "406:  IP_DEFRAG_VS_OUT,",
          "408: };",
          "410: int ip_defrag(struct sk_buff *skb, u32 user);",
          "",
          "[Removed Lines]",
          "407:  IP_DEFRAG_VS_FWD",
          "",
          "[Added Lines]",
          "407:  IP_DEFRAG_VS_FWD,",
          "408:  IP_DEFRAG_AF_PACKET,",
          "",
          "---------------"
        ],
        "net/ipv4/ip_fragment.c||net/ipv4/ip_fragment.c": [
          "File: net/ipv4/ip_fragment.c -> net/ipv4/ip_fragment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "266:    goto out_rcu_unlock;",
          "",
          "[Removed Lines]",
          "264:   if (qp->user == IP_DEFRAG_CONNTRACK_IN &&",
          "265:       skb_rtable(head)->rt_type != RTN_LOCAL)",
          "",
          "[Added Lines]",
          "264:   if (qp->user == IP_DEFRAG_AF_PACKET ||",
          "265:       (qp->user == IP_DEFRAG_CONNTRACK_IN &&",
          "266:        skb_rtable(head)->rt_type != RTN_LOCAL))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
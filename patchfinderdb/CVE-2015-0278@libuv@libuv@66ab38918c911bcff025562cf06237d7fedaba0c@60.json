{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "06c4fa67ed2c2b023d6fbc0708d3188b10c43a18",
      "candidate_info": {
        "commit_hash": "06c4fa67ed2c2b023d6fbc0708d3188b10c43a18",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/06c4fa67ed2c2b023d6fbc0708d3188b10c43a18",
        "files": [
          "src/unix/darwin.c",
          "src/unix/fsevents.c",
          "src/unix/internal.h"
        ],
        "message": "darwin: create fsevents thread on demand\n\n* Move CF run loop code to fsevents.c.\n\n* Create the fsevents thread on demand rather than at startup.\n\n* Remove use of ACCESS_ONCE. All accesses to loop->cf_loop are\n  protected by full memory barriers so no reordering can take place.\n\nFixes #872.",
        "before_after_code_files": [
          "src/unix/darwin.c||src/unix/darwin.c",
          "src/unix/fsevents.c||src/unix/fsevents.c",
          "src/unix/internal.h||src/unix/internal.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/darwin.c||src/unix/darwin.c": [
          "File: src/unix/darwin.c -> src/unix/darwin.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #include <net/if.h>",
          "30: #include <net/if_dl.h>",
          "34: #include <mach/mach.h>",
          "35: #include <mach/mach_time.h>",
          "",
          "[Removed Lines]",
          "32: #include <CoreFoundation/CFRunLoop.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: #include <sys/sysctl.h>",
          "53: int uv__platform_loop_init(uv_loop_t* loop, int default_loop) {",
          "57:   if (uv__kqueue_init(loop))",
          "58:     return -errno;",
          "79:   return 0;",
          "80: }",
          "83: void uv__platform_loop_delete(uv_loop_t* loop) {",
          "179: }",
          "",
          "[Removed Lines]",
          "42: static void uv__cf_loop_runner(void* arg);",
          "43: static void uv__cf_loop_cb(void* arg);",
          "45: typedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;",
          "46: struct uv__cf_loop_signal_s {",
          "47:   void* arg;",
          "48:   cf_loop_signal_cb cb;",
          "49:   QUEUE member;",
          "50: };",
          "54:   CFRunLoopSourceContext ctx;",
          "55:   int r;",
          "60:   loop->cf_loop = NULL;",
          "61:   if ((r = uv_mutex_init(&loop->cf_mutex)))",
          "62:     return r;",
          "63:   if ((r = uv_sem_init(&loop->cf_sem, 0)))",
          "64:     return r;",
          "65:   QUEUE_INIT(&loop->cf_signals);",
          "67:   memset(&ctx, 0, sizeof(ctx));",
          "68:   ctx.info = loop;",
          "69:   ctx.perform = uv__cf_loop_cb;",
          "70:   loop->cf_cb = CFRunLoopSourceCreate(NULL, 0, &ctx);",
          "72:   if ((r = uv_thread_create(&loop->cf_thread, uv__cf_loop_runner, loop)))",
          "73:     return r;",
          "76:   uv_sem_wait(&loop->cf_sem);",
          "77:   assert(ACCESS_ONCE(CFRunLoopRef, loop->cf_loop) != NULL);",
          "84:   QUEUE* item;",
          "85:   uv__cf_loop_signal_t* s;",
          "87:   assert(loop->cf_loop != NULL);",
          "88:   uv__cf_loop_signal(loop, NULL, NULL);",
          "89:   uv_thread_join(&loop->cf_thread);",
          "91:   uv_sem_destroy(&loop->cf_sem);",
          "92:   uv_mutex_destroy(&loop->cf_mutex);",
          "95:   while (!QUEUE_EMPTY(&loop->cf_signals)) {",
          "96:     item = QUEUE_HEAD(&loop->cf_signals);",
          "98:     s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);",
          "100:     QUEUE_REMOVE(item);",
          "101:     free(s);",
          "102:   }",
          "103: }",
          "106: static void uv__cf_loop_runner(void* arg) {",
          "107:   uv_loop_t* loop;",
          "109:   loop = arg;",
          "112:   ACCESS_ONCE(CFRunLoopRef, loop->cf_loop) = CFRunLoopGetCurrent();",
          "114:   CFRunLoopAddSource(loop->cf_loop,",
          "115:                      loop->cf_cb,",
          "116:                      kCFRunLoopDefaultMode);",
          "118:   uv_sem_post(&loop->cf_sem);",
          "120:   CFRunLoopRun();",
          "122:   CFRunLoopRemoveSource(loop->cf_loop,",
          "123:                         loop->cf_cb,",
          "124:                         kCFRunLoopDefaultMode);",
          "125: }",
          "128: static void uv__cf_loop_cb(void* arg) {",
          "129:   uv_loop_t* loop;",
          "130:   QUEUE* item;",
          "131:   QUEUE split_head;",
          "132:   uv__cf_loop_signal_t* s;",
          "134:   loop = arg;",
          "136:   uv_mutex_lock(&loop->cf_mutex);",
          "137:   QUEUE_INIT(&split_head);",
          "138:   if (!QUEUE_EMPTY(&loop->cf_signals)) {",
          "139:     QUEUE* split_pos = QUEUE_HEAD(&loop->cf_signals);",
          "140:     QUEUE_SPLIT(&loop->cf_signals, split_pos, &split_head);",
          "141:   }",
          "142:   uv_mutex_unlock(&loop->cf_mutex);",
          "144:   while (!QUEUE_EMPTY(&split_head)) {",
          "145:     item = QUEUE_HEAD(&split_head);",
          "147:     s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);",
          "150:     if (s->cb == NULL)",
          "151:       CFRunLoopStop(loop->cf_loop);",
          "152:     else",
          "153:       s->cb(s->arg);",
          "155:     QUEUE_REMOVE(item);",
          "156:     free(s);",
          "157:   }",
          "158: }",
          "161: void uv__cf_loop_signal(uv_loop_t* loop, cf_loop_signal_cb cb, void* arg) {",
          "162:   uv__cf_loop_signal_t* item;",
          "164:   item = malloc(sizeof(*item));",
          "166:   if (item == NULL)",
          "167:     abort();",
          "169:   item->arg = arg;",
          "170:   item->cb = cb;",
          "172:   uv_mutex_lock(&loop->cf_mutex);",
          "173:   QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);",
          "174:   uv_mutex_unlock(&loop->cf_mutex);",
          "176:   assert(loop->cf_loop != NULL);",
          "177:   CFRunLoopSourceSignal(loop->cf_cb);",
          "178:   CFRunLoopWakeUp(loop->cf_loop);",
          "",
          "[Added Lines]",
          "41:   loop->cf_loop = NULL;",
          "51:   uv__fsevents_loop_delete(loop);",
          "",
          "---------------"
        ],
        "src/unix/fsevents.c||src/unix/fsevents.c": [
          "File: src/unix/fsevents.c -> src/unix/fsevents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   return 0;",
          "35: }",
          "39: #include <assert.h>",
          "40: #include <stdlib.h>",
          "41: #include <CoreServices/CoreServices.h>",
          "43: typedef struct uv__fsevents_event_s uv__fsevents_event_t;",
          "45: struct uv__fsevents_event_s {",
          "46:   int events;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "38: void uv__fsevents_loop_delete(uv_loop_t* loop) {",
          "39:   return 0;",
          "40: }",
          "46: #include <CoreFoundation/CFRunLoop.h>",
          "50: typedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;",
          "51: typedef void (*cf_loop_signal_cb)(void* arg);",
          "53: struct uv__cf_loop_signal_s {",
          "54:   cf_loop_signal_cb cb;",
          "55:   QUEUE member;",
          "56:   void* arg;",
          "57: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:   char path[1];",
          "49: };",
          "52: #define UV__FSEVENTS_WALK(handle, block)                                      \\",
          "53:     {                                                                         \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: static void uv__cf_loop_cb(void* arg);",
          "67: static void uv__cf_loop_runner(void* arg);",
          "68: static void uv__cf_loop_signal(uv_loop_t* loop,",
          "69:                                cf_loop_signal_cb cb,",
          "70:                                void* arg);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "75:     }",
          "79:   uv_fs_event_t* handle;",
          "81:   handle = cb->data;",
          "",
          "[Removed Lines]",
          "78: void uv__fsevents_cb(uv_async_t* cb, int status) {",
          "",
          "[Added Lines]",
          "98: static void uv__fsevents_cb(uv_async_t* cb, int status) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "92: }",
          "101:   size_t i;",
          "102:   int len;",
          "103:   char** paths;",
          "",
          "[Removed Lines]",
          "95: void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,",
          "96:                            void* info,",
          "97:                            size_t numEvents,",
          "98:                            void* eventPaths,",
          "99:                            const FSEventStreamEventFlags eventFlags[],",
          "100:                            const FSEventStreamEventId eventIds[]) {",
          "",
          "[Added Lines]",
          "115: static void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,",
          "116:                                   void* info,",
          "117:                                   size_t numEvents,",
          "118:                                   void* eventPaths,",
          "119:                                   const FSEventStreamEventFlags eventFlags[],",
          "120:                                   const FSEventStreamEventId eventIds[]) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "190: }",
          "194:   uv_fs_event_t* handle;",
          "196:   handle = arg;",
          "",
          "[Removed Lines]",
          "193: void uv__fsevents_schedule(void* arg) {",
          "",
          "[Added Lines]",
          "213: static void uv__fsevents_schedule(void* arg) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "202: }",
          "205: int uv__fsevents_init(uv_fs_event_t* handle) {",
          "206:   FSEventStreamContext ctx;",
          "207:   FSEventStreamRef ref;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225: static int uv__fsevents_loop_init(uv_loop_t* loop) {",
          "226:   CFRunLoopSourceContext ctx;",
          "227:   int err;",
          "229:   if (loop->cf_loop != NULL)",
          "230:     return 0;",
          "232:   err = uv_mutex_init(&loop->cf_mutex);",
          "233:   if (err)",
          "234:     return err;",
          "236:   err = uv_sem_init(&loop->cf_sem, 0);",
          "237:   if (err)",
          "238:     goto fail_sem_init;",
          "240:   QUEUE_INIT(&loop->cf_signals);",
          "241:   memset(&ctx, 0, sizeof(ctx));",
          "242:   ctx.info = loop;",
          "243:   ctx.perform = uv__cf_loop_cb;",
          "244:   loop->cf_cb = CFRunLoopSourceCreate(NULL, 0, &ctx);",
          "246:   err = uv_thread_create(&loop->cf_thread, uv__cf_loop_runner, loop);",
          "247:   if (err)",
          "248:     goto fail_thread_create;",
          "251:   uv_sem_wait(&loop->cf_sem);",
          "252:   assert(loop->cf_loop != NULL);",
          "253:   return 0;",
          "255: fail_thread_create:",
          "256:   uv_sem_destroy(&loop->cf_sem);",
          "258: fail_sem_init:",
          "259:   uv_mutex_destroy(&loop->cf_mutex);",
          "260:   return err;",
          "261: }",
          "264: void uv__fsevents_loop_delete(uv_loop_t* loop) {",
          "265:   uv__cf_loop_signal_t* s;",
          "266:   QUEUE* q;",
          "268:   if (loop->cf_loop == NULL)",
          "269:     return;",
          "271:   uv__cf_loop_signal(loop, NULL, NULL);",
          "272:   uv_thread_join(&loop->cf_thread);",
          "273:   uv_sem_destroy(&loop->cf_sem);",
          "274:   uv_mutex_destroy(&loop->cf_mutex);",
          "277:   while (!QUEUE_EMPTY(&loop->cf_signals)) {",
          "278:     q = QUEUE_HEAD(&loop->cf_signals);",
          "279:     s = QUEUE_DATA(q, uv__cf_loop_signal_t, member);",
          "280:     QUEUE_REMOVE(q);",
          "281:     free(s);",
          "282:   }",
          "283: }",
          "286: static void uv__cf_loop_runner(void* arg) {",
          "287:   uv_loop_t* loop;",
          "289:   loop = arg;",
          "290:   loop->cf_loop = CFRunLoopGetCurrent();",
          "292:   CFRunLoopAddSource(loop->cf_loop,",
          "293:                      loop->cf_cb,",
          "294:                      kCFRunLoopDefaultMode);",
          "296:   uv_sem_post(&loop->cf_sem);",
          "298:   CFRunLoopRun();",
          "299:   CFRunLoopRemoveSource(loop->cf_loop,",
          "300:                         loop->cf_cb,",
          "301:                         kCFRunLoopDefaultMode);",
          "302: }",
          "305: static void uv__cf_loop_cb(void* arg) {",
          "306:   uv_loop_t* loop;",
          "307:   QUEUE* item;",
          "308:   QUEUE split_head;",
          "309:   uv__cf_loop_signal_t* s;",
          "311:   loop = arg;",
          "313:   uv_mutex_lock(&loop->cf_mutex);",
          "314:   QUEUE_INIT(&split_head);",
          "315:   if (!QUEUE_EMPTY(&loop->cf_signals)) {",
          "316:     QUEUE* split_pos = QUEUE_HEAD(&loop->cf_signals);",
          "317:     QUEUE_SPLIT(&loop->cf_signals, split_pos, &split_head);",
          "318:   }",
          "319:   uv_mutex_unlock(&loop->cf_mutex);",
          "321:   while (!QUEUE_EMPTY(&split_head)) {",
          "322:     item = QUEUE_HEAD(&split_head);",
          "324:     s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);",
          "327:     if (s->cb == NULL)",
          "328:       CFRunLoopStop(loop->cf_loop);",
          "329:     else",
          "330:       s->cb(s->arg);",
          "332:     QUEUE_REMOVE(item);",
          "333:     free(s);",
          "334:   }",
          "335: }",
          "338: void uv__cf_loop_signal(uv_loop_t* loop, cf_loop_signal_cb cb, void* arg) {",
          "339:   uv__cf_loop_signal_t* item;",
          "341:   item = malloc(sizeof(*item));",
          "343:   if (item == NULL)",
          "344:     abort();",
          "346:   item->arg = arg;",
          "347:   item->cb = cb;",
          "349:   uv_mutex_lock(&loop->cf_mutex);",
          "350:   QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);",
          "351:   uv_mutex_unlock(&loop->cf_mutex);",
          "353:   assert(loop->cf_loop != NULL);",
          "354:   CFRunLoopSourceSignal(loop->cf_cb);",
          "355:   CFRunLoopWakeUp(loop->cf_loop);",
          "356: }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "209:   CFArrayRef paths;",
          "210:   CFAbsoluteTime latency;",
          "211:   FSEventStreamCreateFlags flags;",
          "214:   ctx.version = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "366:   int err;",
          "368:   err = uv__fsevents_loop_init(handle->loop);",
          "369:   if (err)",
          "370:     return err;",
          "",
          "---------------"
        ],
        "src/unix/internal.h||src/unix/internal.h": [
          "File: src/unix/internal.h -> src/unix/internal.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "229: int uv__make_pipe(int fds[2], int flags);",
          "231: #if defined(__APPLE__)",
          "236: int uv__fsevents_init(uv_fs_event_t* handle);",
          "237: int uv__fsevents_close(uv_fs_event_t* handle);",
          "240: #ifndef MAC_OS_X_VERSION_10_7",
          "",
          "[Removed Lines]",
          "232: typedef void (*cf_loop_signal_cb)(void*);",
          "234: void uv__cf_loop_signal(uv_loop_t* loop, cf_loop_signal_cb cb, void* arg);",
          "",
          "[Added Lines]",
          "235: void uv__fsevents_loop_delete(uv_loop_t* loop);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e72d48ddab87a4168834b9f3449c998ce3600842",
      "candidate_info": {
        "commit_hash": "e72d48ddab87a4168834b9f3449c998ce3600842",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/e72d48ddab87a4168834b9f3449c998ce3600842",
        "files": [
          "include/uv.h",
          "src/unix/udp.c",
          "src/win/udp.c"
        ],
        "message": "unix, windows: const-ify handle in uv_udp_getsockname",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/unix/udp.c||src/unix/udp.c",
          "src/win/udp.c||src/win/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "976:                           const struct sockaddr* addr,",
          "977:                           unsigned int flags);",
          "980:                                  struct sockaddr* name,",
          "981:                                  int* namelen);",
          "",
          "[Removed Lines]",
          "979: UV_EXTERN int uv_udp_getsockname(uv_udp_t* handle,",
          "",
          "[Added Lines]",
          "979: UV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,",
          "",
          "---------------"
        ],
        "src/unix/udp.c||src/unix/udp.c": [
          "File: src/unix/udp.c -> src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "703: }",
          "707:   socklen_t socklen;",
          "709:   if (handle->io_watcher.fd == -1)",
          "",
          "[Removed Lines]",
          "706: int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name, int* namelen) {",
          "",
          "[Added Lines]",
          "706: int uv_udp_getsockname(const uv_udp_t* handle,",
          "707:                        struct sockaddr* name,",
          "708:                        int* namelen) {",
          "",
          "---------------"
        ],
        "src/win/udp.c||src/win/udp.c": [
          "File: src/win/udp.c -> src/win/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: static char uv_zero_[] = \"\";",
          "42:   int result;",
          "44:   if (!(handle->flags & UV_HANDLE_BOUND)) {",
          "",
          "[Removed Lines]",
          "40: int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,",
          "41:     int* namelen) {",
          "",
          "[Added Lines]",
          "40: int uv_udp_getsockname(const uv_udp_t* handle,",
          "41:                        struct sockaddr* name,",
          "42:                        int* namelen) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d47962e9d93d4a55a9984623feaf546406c9cdbb",
      "candidate_info": {
        "commit_hash": "d47962e9d93d4a55a9984623feaf546406c9cdbb",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/d47962e9d93d4a55a9984623feaf546406c9cdbb",
        "files": [
          "AUTHORS",
          "ChangeLog",
          "src/version.c"
        ],
        "message": "2014.01.23, Version 0.11.18 (Unstable)\n\nChanges since version 0.11.17:\n\n* osx: Fix a possible segfault in uv__io_poll (Alex Crichton)\n\n* windows: improved handling of invalid FDs (Alexis Campailla)\n\n* doc: adding ARCHS flag to OS X build command (Nathan Sweet)\n\n* tcp: reveal bind-time errors before listen (Alexis Campailla)\n\n* tcp: uv_tcp_dualstack() (Fedor Indutny)\n\n* linux: relax assumption on /proc/stat parsing (Luca Bruno)\n\n* openbsd: fix obvious bug in uv_cpu_info (Fedor Indutny)\n\n* process: close stdio after dup2'ing it (Fedor Indutny)\n\n* linux: move sscanf() out of the assert() (Trevor Norris)",
        "before_after_code_files": [
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #define UV_VERSION_MAJOR 0",
          "33: #define UV_VERSION_MINOR 11",
          "34: #define UV_VERSION_PATCH 18",
          "38: #define UV_VERSION  ((UV_VERSION_MAJOR << 16) | \\",
          "",
          "[Removed Lines]",
          "35: #define UV_VERSION_IS_RELEASE 0",
          "",
          "[Added Lines]",
          "35: #define UV_VERSION_IS_RELEASE 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e68e6d895a9007736e53b592192fd9620a34ac6",
      "candidate_info": {
        "commit_hash": "7e68e6d895a9007736e53b592192fd9620a34ac6",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/7e68e6d895a9007736e53b592192fd9620a34ac6",
        "files": [
          "ChangeLog",
          "src/version.c"
        ],
        "message": "Now working on v0.11.7",
        "before_after_code_files": [
          "src/version.c||src/version.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/version.c||src/version.c": [
          "File: src/version.c -> src/version.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #define UV_VERSION_MAJOR 0",
          "33: #define UV_VERSION_MINOR 11",
          "38: #define UV_VERSION  ((UV_VERSION_MAJOR << 16) | \\",
          "",
          "[Removed Lines]",
          "34: #define UV_VERSION_PATCH 6",
          "35: #define UV_VERSION_IS_RELEASE 1",
          "",
          "[Added Lines]",
          "34: #define UV_VERSION_PATCH 7",
          "35: #define UV_VERSION_IS_RELEASE 0",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2cfb96e9e2652b295b3b60a0a3f0bb7f2cb50eb7",
      "candidate_info": {
        "commit_hash": "2cfb96e9e2652b295b3b60a0a3f0bb7f2cb50eb7",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/2cfb96e9e2652b295b3b60a0a3f0bb7f2cb50eb7",
        "files": [
          "include/uv-version.h"
        ],
        "message": "src: bump the version number\n\nThere was a bug in the libuv release tool where it didn't properly\nupdate the proper version file.",
        "before_after_code_files": [
          "include/uv-version.h||include/uv-version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv-version.h||include/uv-version.h": [
          "File: include/uv-version.h -> include/uv-version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #define UV_VERSION_MAJOR 0",
          "34: #define UV_VERSION_MINOR 11",
          "36: #define UV_VERSION_IS_RELEASE 0",
          "",
          "[Removed Lines]",
          "35: #define UV_VERSION_PATCH 20",
          "",
          "[Added Lines]",
          "35: #define UV_VERSION_PATCH 21",
          "",
          "---------------"
        ]
      }
    }
  ]
}
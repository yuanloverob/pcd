{
  "cve_id": "CVE-2019-7308",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel before 4.20.6 performs undesirable out-of-bounds speculation on pointer arithmetic in various cases, including cases of different branches with different state or limits to sanitize, leading to side-channel attacks.",
  "repo": "torvalds/linux",
  "patch_hash": "d3bd7413e0ca40b60cf60d4003246d067cafdeda",
  "patch_info": {
    "commit_hash": "d3bd7413e0ca40b60cf60d4003246d067cafdeda",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/d3bd7413e0ca40b60cf60d4003246d067cafdeda",
    "files": [
      "include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: fix sanitation of alu op with pointer / scalar type from different paths\n\nWhile 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer\narithmetic\") took care of rejecting alu op on pointer when e.g. pointer\ncame from two different map values with different map properties such as\nvalue size, Jann reported that a case was not covered yet when a given\nalu op is used in both \"ptr_reg += reg\" and \"numeric_reg += reg\" from\ndifferent branches where we would incorrectly try to sanitize based\non the pointer's limit. Catch this corner case and reject the program\ninstead.\n\nFixes: 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
    "before_after_code_files": [
      "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
      "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "172: #define BPF_ALU_SANITIZE_SRC  1U",
      "173: #define BPF_ALU_SANITIZE_DST  2U",
      "174: #define BPF_ALU_NEG_VALUE  (1U << 2)",
      "175: #define BPF_ALU_SANITIZE  (BPF_ALU_SANITIZE_SRC | \\",
      "176:       BPF_ALU_SANITIZE_DST)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "175: #define BPF_ALU_NON_POINTER  (1U << 3)",
      "",
      "---------------"
    ],
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3103:  }",
      "3104: }",
      "3106: static int sanitize_ptr_alu(struct bpf_verifier_env *env,",
      "3107:        struct bpf_insn *insn,",
      "3108:        const struct bpf_reg_state *ptr_reg,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3106: static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,",
      "3107:         const struct bpf_insn *insn)",
      "3108: {",
      "3109:  return env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;",
      "3110: }",
      "3112: static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,",
      "3113:            u32 alu_state, u32 alu_limit)",
      "3114: {",
      "3118:  if (aux->alu_state &&",
      "3119:      (aux->alu_state != alu_state ||",
      "3120:       aux->alu_limit != alu_limit))",
      "3121:   return -EACCES;",
      "3124:  aux->alu_state = alu_state;",
      "3125:  aux->alu_limit = alu_limit;",
      "3126:  return 0;",
      "3127: }",
      "3129: static int sanitize_val_alu(struct bpf_verifier_env *env,",
      "3130:        struct bpf_insn *insn)",
      "3131: {",
      "3132:  struct bpf_insn_aux_data *aux = cur_aux(env);",
      "3134:  if (can_skip_alu_sanitation(env, insn))",
      "3135:   return 0;",
      "3137:  return update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);",
      "3138: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3117:  struct bpf_reg_state tmp;",
      "3118:  bool ret;",
      "3121:   return 0;",
      "",
      "[Removed Lines]",
      "3120:  if (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)",
      "",
      "[Added Lines]",
      "3154:  if (can_skip_alu_sanitation(env, insn))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "3134:  if (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))",
      "3135:   return 0;",
      "3143:   return -EACCES;",
      "3149: do_sim:",
      "",
      "[Removed Lines]",
      "3140:  if (aux->alu_state &&",
      "3141:      (aux->alu_state != alu_state ||",
      "3142:       aux->alu_limit != alu_limit))",
      "3146:  aux->alu_state = alu_state;",
      "3147:  aux->alu_limit = alu_limit;",
      "",
      "[Added Lines]",
      "3170:  if (update_alu_sanitation_state(aux, alu_state, alu_limit))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "3418:  s64 smin_val, smax_val;",
      "3419:  u64 umin_val, umax_val;",
      "3420:  u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;",
      "3422:  if (insn_bitness == 32) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3444:  u32 dst = insn->dst_reg;",
      "3445:  int ret;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "3453:  switch (opcode) {",
      "3454:  case BPF_ADD:",
      "3455:   if (signed_add_overflows(dst_reg->smin_value, smin_val) ||",
      "3456:       signed_add_overflows(dst_reg->smax_value, smax_val)) {",
      "3457:    dst_reg->smin_value = S64_MIN;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3480:   ret = sanitize_val_alu(env, insn);",
      "3481:   if (ret < 0) {",
      "3482:    verbose(env, \"R%d tried to add from different pointers or scalars\\n\", dst);",
      "3483:    return ret;",
      "3484:   }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "3471:   dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);",
      "3472:   break;",
      "3473:  case BPF_SUB:",
      "3474:   if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||",
      "3475:       signed_sub_overflows(dst_reg->smax_value, smin_val)) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3504:   ret = sanitize_val_alu(env, insn);",
      "3505:   if (ret < 0) {",
      "3506:    verbose(env, \"R%d tried to sub from different pointers or scalars\\n\", dst);",
      "3507:    return ret;",
      "3508:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
      "candidate_info": {
        "commit_hash": "979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/979d63d50c0c0f7bc537bf821e056cc9fe5abd38",
        "files": [
          "include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: prevent out of bounds speculation on pointer arithmetic\n\nJann reported that the original commit back in b2157399cc98\n(\"bpf: prevent out-of-bounds speculation\") was not sufficient\nto stop CPU from speculating out of bounds memory access:\nWhile b2157399cc98 only focussed on masking array map access\nfor unprivileged users for tail calls and data access such\nthat the user provided index gets sanitized from BPF program\nand syscall side, there is still a more generic form affected\nfrom BPF programs that applies to most maps that hold user\ndata in relation to dynamic map access when dealing with\nunknown scalars or \"slow\" known scalars as access offset, for\nexample:\n\n  - Load a map value pointer into R6\n  - Load an index into R7\n  - Do a slow computation (e.g. with a memory dependency) that\n    loads a limit into R8 (e.g. load the limit from a map for\n    high latency, then mask it to make the verifier happy)\n  - Exit if R7 >= R8 (mispredicted branch)\n  - Load R0 = R6[R7]\n  - Load R0 = R6[R0]\n\nFor unknown scalars there are two options in the BPF verifier\nwhere we could derive knowledge from in order to guarantee\nsafe access to the memory: i) While </>/<=/>= variants won't\nallow to derive any lower or upper bounds from the unknown\nscalar where it would be safe to add it to the map value\npointer, it is possible through ==/!= test however. ii) another\noption is to transform the unknown scalar into a known scalar,\nfor example, through ALU ops combination such as R &= <imm>\nfollowed by R |= <imm> or any similar combination where the\noriginal information from the unknown scalar would be destroyed\nentirely leaving R with a constant. The initial slow load still\nprecedes the latter ALU ops on that register, so the CPU\nexecutes speculatively from that point. Once we have the known\nscalar, any compare operation would work then. A third option\nonly involving registers with known scalars could be crafted\nas described in [0] where a CPU port (e.g. Slow Int unit)\nwould be filled with many dependent computations such that\nthe subsequent condition depending on its outcome has to wait\nfor evaluation on its execution port and thereby executing\nspeculatively if the speculated code can be scheduled on a\ndifferent execution port, or any other form of mistraining\nas described in [1], for example. Given this is not limited\nto only unknown scalars, not only map but also stack access\nis affected since both is accessible for unprivileged users\nand could potentially be used for out of bounds access under\nspeculation.\n\nIn order to prevent any of these cases, the verifier is now\nsanitizing pointer arithmetic on the offset such that any\nout of bounds speculation would be masked in a way where the\npointer arithmetic result in the destination register will\nstay unchanged, meaning offset masked into zero similar as\nin array_index_nospec() case. With regards to implementation,\nthere are three options that were considered: i) new insn\nfor sanitation, ii) push/pop insn and sanitation as inlined\nBPF, iii) reuse of ax register and sanitation as inlined BPF.\n\nOption i) has the downside that we end up using from reserved\nbits in the opcode space, but also that we would require\neach JIT to emit masking as native arch opcodes meaning\nmitigation would have slow adoption till everyone implements\nit eventually which is counter-productive. Option ii) and iii)\nhave both in common that a temporary register is needed in\norder to implement the sanitation as inlined BPF since we\nare not allowed to modify the source register. While a push /\npop insn in ii) would be useful to have in any case, it\nrequires once again that every JIT needs to implement it\nfirst. While possible, amount of changes needed would also\nbe unsuitable for a -stable patch. Therefore, the path which\nhas fewer changes, less BPF instructions for the mitigation\nand does not require anything to be changed in the JITs is\noption iii) which this work is pursuing. The ax register is\nalready mapped to a register in all JITs (modulo arm32 where\nit's mapped to stack as various other BPF registers there)\nand used in constant blinding for JITs-only so far. It can\nbe reused for verifier rewrites under certain constraints.\nThe interpreter's tmp \"register\" has therefore been remapped\ninto extending the register set with hidden ax register and\nreusing that for a number of instructions that needed the\nprior temporary variable internally (e.g. div, mod). This\nallows for zero increase in stack space usage in the interpreter,\nand enables (restricted) generic use in rewrites otherwise as\nlong as such a patchlet does not make use of these instructions.\nThe sanitation mask is dynamic and relative to the offset the\nmap value or stack pointer currently holds.\n\nThere are various cases that need to be taken under consideration\nfor the masking, e.g. such operation could look as follows:\nptr += val or val += ptr or ptr -= val. Thus, the value to be\nsanitized could reside either in source or in destination\nregister, and the limit is different depending on whether\nthe ALU op is addition or subtraction and depending on the\ncurrent known and bounded offset. The limit is derived as\nfollows: limit := max_value_size - (smin_value + off). For\nsubtraction: limit := umax_value + off. This holds because\nwe do not allow any pointer arithmetic that would\ntemporarily go out of bounds or would have an unknown\nvalue with mixed signed bounds where it is unclear at\nverification time whether the actual runtime value would\nbe either negative or positive. For example, we have a\nderived map pointer value with constant offset and bounded\none, so limit based on smin_value works because the verifier\nrequires that statically analyzed arithmetic on the pointer\nmust be in bounds, and thus it checks if resulting\nsmin_value + off and umax_value + off is still within map\nvalue bounds at time of arithmetic in addition to time of\naccess. Similarly, for the case of stack access we derive\nthe limit as follows: MAX_BPF_STACK + off for subtraction\nand -off for the case of addition where off := ptr_reg->off +\nptr_reg->var_off.value. Subtraction is a special case for\nthe masking which can be in form of ptr += -val, ptr -= -val,\nor ptr -= val. In the first two cases where we know that\nthe value is negative, we need to temporarily negate the\nvalue in order to do the sanitation on a positive value\nwhere we later swap the ALU op, and restore original source\nregister if the value was in source.\n\nThe sanitation of pointer arithmetic alone is still not fully\nsufficient as is, since a scenario like the following could\nhappen ...\n\n  PTR += 0x1000 (e.g. K-based imm)\n  PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON\n  PTR += 0x1000\n  PTR -= BIG_NUMBER_WITH_SLOW_COMPARISON\n  [...]\n\n... which under speculation could end up as ...\n\n  PTR += 0x1000\n  PTR -= 0 [ truncated by mitigation ]\n  PTR += 0x1000\n  PTR -= 0 [ truncated by mitigation ]\n  [...]\n\n... and therefore still access out of bounds. To prevent such\ncase, the verifier is also analyzing safety for potential out\nof bounds access under speculative execution. Meaning, it is\nalso simulating pointer access under truncation. We therefore\n\"branch off\" and push the current verification state after the\nALU operation with known 0 to the verification stack for later\nanalysis. Given the current path analysis succeeded it is\nlikely that the one under speculation can be pruned. In any\ncase, it is also subject to existing complexity limits and\ntherefore anything beyond this point will be rejected. In\nterms of pruning, it needs to be ensured that the verification\nstate from speculative execution simulation must never prune\na non-speculative execution path, therefore, we mark verifier\nstate accordingly at the time of push_stack(). If verifier\ndetects out of bounds access under speculative execution from\none of the possible paths that includes a truncation, it will\nreject such program.\n\nGiven we mask every reg-based pointer arithmetic for\nunprivileged programs, we've been looking into how it could\naffect real-world programs in terms of size increase. As the\nmajority of programs are targeted for privileged-only use\ncase, we've unconditionally enabled masking (with its alu\nrestrictions on top of it) for privileged programs for the\nsake of testing in order to check i) whether they get rejected\nin its current form, and ii) by how much the number of\ninstructions and size will increase. We've tested this by\nusing Katran, Cilium and test_l4lb from the kernel selftests.\nFor Katran we've evaluated balancer_kern.o, Cilium bpf_lxc.o\nand an older test object bpf_lxc_opt_-DUNKNOWN.o and l4lb\nwe've used test_l4lb.o as well as test_l4lb_noinline.o. We\nfound that none of the programs got rejected by the verifier\nwith this change, and that impact is rather minimal to none.\nbalancer_kern.o had 13,904 bytes (1,738 insns) xlated and\n7,797 bytes JITed before and after the change. Most complex\nprogram in bpf_lxc.o had 30,544 bytes (3,817 insns) xlated\nand 18,538 bytes JITed before and after and none of the other\ntail call programs in bpf_lxc.o had any changes either. For\nthe older bpf_lxc_opt_-DUNKNOWN.o object we found a small\nincrease from 20,616 bytes (2,576 insns) and 12,536 bytes JITed\nbefore to 20,664 bytes (2,582 insns) and 12,558 bytes JITed\nafter the change. Other programs from that object file had\nsimilar small increase. Both test_l4lb.o had no change and\nremained at 6,544 bytes (817 insns) xlated and 3,401 bytes\nJITed and for test_l4lb_noinline.o constant at 5,080 bytes\n(634 insns) xlated and 3,313 bytes JITed. This can be explained\nin that LLVM typically optimizes stack based pointer arithmetic\nby using K-based operations and that use of dynamic map access\nis not overly frequent. However, in future we may decide to\noptimize the algorithm further under known guarantees from\nbranch and value speculation. Latter seems also unclear in\nterms of prediction heuristics that today's CPUs apply as well\nas whether there could be collisions in e.g. the predictor's\nValue History/Pattern Table for triggering out of bounds access,\nthus masking is performed unconditionally at this point but could\nbe subject to relaxation later on. We were generally also\nbrainstorming various other approaches for mitigation, but the\nblocker was always lack of available registers at runtime and/or\noverhead for runtime tracking of limits belonging to a specific\npointer. Thus, we found this to be minimally intrusive under\ngiven constraints.\n\nWith that in place, a simple example with sanitized access on\nunprivileged load at post-verification time looks as follows:\n\n  # bpftool prog dump xlated id 282\n  [...]\n  28: (79) r1 = *(u64 *)(r7 +0)\n  29: (79) r2 = *(u64 *)(r7 +8)\n  30: (57) r1 &= 15\n  31: (79) r3 = *(u64 *)(r0 +4608)\n  32: (57) r3 &= 1\n  33: (47) r3 |= 1\n  34: (2d) if r2 > r3 goto pc+19\n  35: (b4) (u32) r11 = (u32) 20479  |\n  36: (1f) r11 -= r2                | Dynamic sanitation for pointer\n  37: (4f) r11 |= r2                | arithmetic with registers\n  38: (87) r11 = -r11               | containing bounded or known\n  39: (c7) r11 s>>= 63              | scalars in order to prevent\n  40: (5f) r11 &= r2                | out of bounds speculation.\n  41: (0f) r4 += r11                |\n  42: (71) r4 = *(u8 *)(r4 +0)\n  43: (6f) r4 <<= r1\n  [...]\n\nFor the case where the scalar sits in the destination register\nas opposed to the source register, the following code is emitted\nfor the above example:\n\n  [...]\n  16: (b4) (u32) r11 = (u32) 20479\n  17: (1f) r11 -= r2\n  18: (4f) r11 |= r2\n  19: (87) r11 = -r11\n  20: (c7) r11 s>>= 63\n  21: (5f) r2 &= r11\n  22: (0f) r2 += r0\n  23: (61) r0 = *(u32 *)(r2 +0)\n  [...]\n\nJIT blinding example with non-conflicting use of r10:\n\n  [...]\n   d5:\tje     0x0000000000000106    _\n   d7:\tmov    0x0(%rax),%edi       |\n   da:\tmov    $0xf153246,%r10d     | Index load from map value and\n   e0:\txor    $0xf153259,%r10      | (const blinded) mask with 0x1f.\n   e7:\tand    %r10,%rdi            |_\n   ea:\tmov    $0x2f,%r10d          |\n   f0:\tsub    %rdi,%r10            | Sanitized addition. Both use r10\n   f3:\tor     %rdi,%r10            | but do not interfere with each\n   f6:\tneg    %r10                 | other. (Neither do these instructions\n   f9:\tsar    $0x3f,%r10           | interfere with the use of ax as temp\n   fd:\tand    %r10,%rdi            | in interpreter.)\n  100:\tadd    %rax,%rdi            |_\n  103:\tmov    0x0(%rdi),%eax\n [...]\n\nTested that it fixes Jann's reproducer, and also checked that test_verifier\nand test_progs suite with interpreter, JIT and JIT with hardening enabled\non x86-64 and arm64 runs successfully.\n\n  [0] Speculose: Analyzing the Security Implications of Speculative\n      Execution in CPUs, Giorgi Maisuradze and Christian Rossow,\n      https://arxiv.org/pdf/1801.04084.pdf\n\n  [1] A Systematic Evaluation of Transient Execution Attacks and\n      Defenses, Claudio Canella, Jo Van Bulck, Michael Schwarz,\n      Moritz Lipp, Benjamin von Berg, Philipp Ortner, Frank Piessens,\n      Dmitry Evtyushkin, Daniel Gruss,\n      https://arxiv.org/pdf/1811.05441.pdf\n\nFixes: b2157399cc98 (\"bpf: prevent out-of-bounds speculation\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "149:  struct bpf_func_state *frame[MAX_CALL_FRAMES];",
          "150:  u32 curframe;",
          "151: };",
          "153: #define bpf_get_spilled_reg(slot, frame)    \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "151:  bool speculative;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:  struct bpf_verifier_state_list *next;",
          "168: };",
          "170: struct bpf_insn_aux_data {",
          "171:  union {",
          "175:  };",
          "179: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172: #define BPF_ALU_SANITIZE_SRC  1U",
          "173: #define BPF_ALU_SANITIZE_DST  2U",
          "174: #define BPF_ALU_NEG_VALUE  (1U << 2)",
          "175: #define BPF_ALU_SANITIZE  (BPF_ALU_SANITIZE_SRC | \\",
          "176:       BPF_ALU_SANITIZE_DST)",
          "",
          "---------------"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "710:   free_func_state(dst_state->frame[i]);",
          "711:   dst_state->frame[i] = NULL;",
          "712:  }",
          "713:  dst_state->curframe = src->curframe;",
          "714:  for (i = 0; i <= src->curframe; i++) {",
          "715:   dst = dst_state->frame[i];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "713:  dst_state->speculative = src->speculative;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "754: }",
          "756: static struct bpf_verifier_state *push_stack(struct bpf_verifier_env *env,",
          "758: {",
          "759:  struct bpf_verifier_state *cur = env->cur_state;",
          "760:  struct bpf_verifier_stack_elem *elem;",
          "",
          "[Removed Lines]",
          "757:           int insn_idx, int prev_insn_idx)",
          "",
          "[Added Lines]",
          "758:           int insn_idx, int prev_insn_idx,",
          "759:           bool speculative)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "772:  err = copy_verifier_state(&elem->st, cur);",
          "773:  if (err)",
          "774:   goto err;",
          "775:  if (env->stack_size > BPF_COMPLEXITY_LIMIT_STACK) {",
          "776:   verbose(env, \"BPF program is too complex\\n\");",
          "777:   goto err;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "777:  elem->st.speculative |= speculative;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3067:  return true;",
          "3068: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3073: static struct bpf_insn_aux_data *cur_aux(struct bpf_verifier_env *env)",
          "3074: {",
          "3075:  return &env->insn_aux_data[env->insn_idx];",
          "3076: }",
          "3078: static int retrieve_ptr_limit(const struct bpf_reg_state *ptr_reg,",
          "3079:          u32 *ptr_limit, u8 opcode, bool off_is_neg)",
          "3080: {",
          "3081:  bool mask_to_left = (opcode == BPF_ADD &&  off_is_neg) ||",
          "3082:        (opcode == BPF_SUB && !off_is_neg);",
          "3083:  u32 off;",
          "3085:  switch (ptr_reg->type) {",
          "3086:  case PTR_TO_STACK:",
          "3087:   off = ptr_reg->off + ptr_reg->var_off.value;",
          "3088:   if (mask_to_left)",
          "3090:   else",
          "3092:   return 0;",
          "3093:  case PTR_TO_MAP_VALUE:",
          "3094:   if (mask_to_left) {",
          "3096:   } else {",
          "3097:    off = ptr_reg->smin_value + ptr_reg->off;",
          "3099:   }",
          "3100:   return 0;",
          "3101:  default:",
          "3102:   return -EINVAL;",
          "3103:  }",
          "3104: }",
          "3106: static int sanitize_ptr_alu(struct bpf_verifier_env *env,",
          "3107:        struct bpf_insn *insn,",
          "3108:        const struct bpf_reg_state *ptr_reg,",
          "3109:        struct bpf_reg_state *dst_reg,",
          "3110:        bool off_is_neg)",
          "3111: {",
          "3112:  struct bpf_verifier_state *vstate = env->cur_state;",
          "3113:  struct bpf_insn_aux_data *aux = cur_aux(env);",
          "3114:  bool ptr_is_dst_reg = ptr_reg == dst_reg;",
          "3115:  u8 opcode = BPF_OP(insn->code);",
          "3116:  u32 alu_state, alu_limit;",
          "3117:  struct bpf_reg_state tmp;",
          "3118:  bool ret;",
          "3120:  if (env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K)",
          "3121:   return 0;",
          "3127:  if (vstate->speculative)",
          "3128:   goto do_sim;",
          "3130:  alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;",
          "3131:  alu_state |= ptr_is_dst_reg ?",
          "3132:        BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;",
          "3134:  if (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))",
          "3135:   return 0;",
          "3140:  if (aux->alu_state &&",
          "3141:      (aux->alu_state != alu_state ||",
          "3142:       aux->alu_limit != alu_limit))",
          "3143:   return -EACCES;",
          "3146:  aux->alu_state = alu_state;",
          "3147:  aux->alu_limit = alu_limit;",
          "3149: do_sim:",
          "3159:  if (!ptr_is_dst_reg) {",
          "3160:   tmp = *dst_reg;",
          "3162:  }",
          "3163:  ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);",
          "3164:  if (!ptr_is_dst_reg)",
          "3166:  return !ret ? -EFAULT : 0;",
          "3167: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3087:      umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value;",
          "3088:  u32 dst = insn->dst_reg, src = insn->src_reg;",
          "3089:  u8 opcode = BPF_OP(insn->code);",
          "3091:  dst_reg = &regs[dst];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3189:  int ret;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3143:  switch (opcode) {",
          "3144:  case BPF_ADD:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3245:   ret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);",
          "3246:   if (ret < 0) {",
          "3247:    verbose(env, \"R%d tried to add from different maps or paths\\n\", dst);",
          "3248:    return ret;",
          "3249:   }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3192:   }",
          "3193:   break;",
          "3194:  case BPF_SUB:",
          "3195:   if (dst_reg == off_reg) {",
          "3197:    verbose(env, \"R%d tried to subtract pointer from scalar\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3300:   ret = sanitize_ptr_alu(env, insn, ptr_reg, dst_reg, smin_val < 0);",
          "3301:   if (ret < 0) {",
          "3302:    verbose(env, \"R%d tried to sub from different maps or paths\\n\", dst);",
          "3303:    return ret;",
          "3304:   }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4389:   }",
          "4390:  }",
          "4393:  if (!other_branch)",
          "4394:   return -EFAULT;",
          "4395:  other_branch_regs = other_branch->frame[other_branch->curframe]->regs;",
          "",
          "[Removed Lines]",
          "4392:  other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx);",
          "",
          "[Added Lines]",
          "4502:  other_branch = push_stack(env, *insn_idx + insn->off + 1, *insn_idx,",
          "4503:       false);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5499:  if (old->curframe != cur->curframe)",
          "5500:   return false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5616:  if (old->speculative && !cur->speculative)",
          "5617:   return false;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "5700:  if (!state)",
          "5701:   return -ENOMEM;",
          "5702:  state->curframe = 0;",
          "5703:  state->frame[0] = kzalloc(sizeof(struct bpf_func_state), GFP_KERNEL);",
          "5704:  if (!state->frame[0]) {",
          "5705:   kfree(state);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5820:  state->speculative = false;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "5740:    if (env->log.level) {",
          "5741:     if (do_print_state)",
          "5744:     else",
          "5745:      verbose(env, \"%d: safe\\n\", env->insn_idx);",
          "5746:    }",
          "",
          "[Removed Lines]",
          "5742:      verbose(env, \"\\nfrom %d to %d: safe\\n\",",
          "5743:       env->prev_insn_idx, env->insn_idx);",
          "",
          "[Added Lines]",
          "5860:      verbose(env, \"\\nfrom %d to %d%s: safe\\n\",",
          "5861:       env->prev_insn_idx, env->insn_idx,",
          "5862:       env->cur_state->speculative ?",
          "5863:       \" (speculative execution)\" : \"\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "5757:    if (env->log.level > 1)",
          "5758:     verbose(env, \"%d:\", env->insn_idx);",
          "5759:    else",
          "5762:    print_verifier_state(env, state->frame[state->curframe]);",
          "5763:    do_print_state = false;",
          "5764:   }",
          "",
          "[Removed Lines]",
          "5760:     verbose(env, \"\\nfrom %d to %d:\",",
          "5761:      env->prev_insn_idx, env->insn_idx);",
          "",
          "[Added Lines]",
          "5880:     verbose(env, \"\\nfrom %d to %d%s:\",",
          "5881:      env->prev_insn_idx, env->insn_idx,",
          "5882:      env->cur_state->speculative ?",
          "5883:      \" (speculative execution)\" : \"\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "6750:    continue;",
          "6751:   }",
          "6753:   if (insn->code != (BPF_JMP | BPF_CALL))",
          "6754:    continue;",
          "6755:   if (insn->src_reg == BPF_PSEUDO_CALL)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6875:   if (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) ||",
          "6876:       insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) {",
          "6877:    const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X;",
          "6878:    const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X;",
          "6879:    struct bpf_insn insn_buf[16];",
          "6880:    struct bpf_insn *patch = &insn_buf[0];",
          "6881:    bool issrc, isneg;",
          "6882:    u32 off_reg;",
          "6884:    aux = &env->insn_aux_data[i + delta];",
          "6885:    if (!aux->alu_state)",
          "6886:     continue;",
          "6888:    isneg = aux->alu_state & BPF_ALU_NEG_VALUE;",
          "6889:    issrc = (aux->alu_state & BPF_ALU_SANITIZE) ==",
          "6890:     BPF_ALU_SANITIZE_SRC;",
          "6892:    off_reg = issrc ? insn->src_reg : insn->dst_reg;",
          "6893:    if (isneg)",
          "6900:    if (issrc) {",
          "6902:         off_reg);",
          "6903:     insn->src_reg = BPF_REG_AX;",
          "6904:    } else {",
          "6906:         BPF_REG_AX);",
          "6907:    }",
          "6908:    if (isneg)",
          "6909:     insn->code = insn->code == code_add ?",
          "6910:           code_sub : code_add;",
          "6912:    if (issrc && isneg)",
          "6914:    cnt = patch - insn_buf;",
          "6916:    new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);",
          "6917:    if (!new_prog)",
          "6918:     return -ENOMEM;",
          "6920:    delta    += cnt - 1;",
          "6921:    env->prog = prog = new_prog;",
          "6922:    insn      = new_prog->insnsi + i + delta;",
          "6923:    continue;",
          "6924:   }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
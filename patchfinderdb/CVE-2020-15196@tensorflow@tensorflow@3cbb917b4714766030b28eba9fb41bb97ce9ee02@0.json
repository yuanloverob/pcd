{
  "cve_id": "CVE-2020-15196",
  "cve_desc": "In Tensorflow version 2.3.0, the `SparseCountSparseOutput` and `RaggedCountSparseOutput` implementations don't validate that the `weights` tensor has the same shape as the data. The check exists for `DenseCountSparseOutput`, where both tensors are fully specified. In the sparse and ragged count weights are still accessed in parallel with the data. But, since there is no validation, a user passing fewer weights than the values for the tensors can generate a read from outside the bounds of the heap buffer allocated for the weights. The issue is patched in commit 3cbb917b4714766030b28eba9fb41bb97ce9ee02 and is released in TensorFlow version 2.3.1.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "3cbb917b4714766030b28eba9fb41bb97ce9ee02",
  "patch_info": {
    "commit_hash": "3cbb917b4714766030b28eba9fb41bb97ce9ee02",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/3cbb917b4714766030b28eba9fb41bb97ce9ee02",
    "files": [
      "tensorflow/core/kernels/count_ops.cc",
      "tensorflow/python/ops/bincount_ops_test.py"
    ],
    "message": "Fix multiple vulnerabilities in `tf.raw_ops.*CountSparseOutput`.\n\nAlso add tests for these API points, both for the happy paths and for the vulnerable ones.\n\nPiperOrigin-RevId: 332563222\nChange-Id: Ib3b52116a83a134c2e742a7c66e5e956db8fba05",
    "before_after_code_files": [
      "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc",
      "tensorflow/python/ops/bincount_ops_test.py||tensorflow/python/ops/bincount_ops_test.py"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc": [
      "File: tensorflow/core/kernels/count_ops.cc -> tensorflow/core/kernels/count_ops.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "178:     const Tensor& weights = context->input(3);",
      "179:     bool use_weights = weights.NumElements() > 0;",
      "181:     bool is_1d = shape.NumElements() == 1;",
      "182:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
      "183:     int num_values = values.NumElements();",
      "185:     const auto indices_values = indices.matrix<int64>();",
      "186:     const auto values_values = values.flat<T>();",
      "187:     const auto weight_values = weights.flat<W>();",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "181:     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),",
      "182:                 errors::InvalidArgument(",
      "183:                     \"Input indices must be a 2-dimensional tensor. Got: \",",
      "184:                     indices.shape().DebugString()));",
      "186:     if (use_weights) {",
      "187:       OP_REQUIRES(",
      "188:           context, weights.shape() == values.shape(),",
      "189:           errors::InvalidArgument(",
      "190:               \"Weights and values must have the same shape. Weight shape: \",",
      "191:               weights.shape().DebugString(),",
      "192:               \"; values shape: \", values.shape().DebugString()));",
      "193:     }",
      "199:     OP_REQUIRES(context, num_values == indices.shape().dim_size(0),",
      "200:                 errors::InvalidArgument(",
      "201:                     \"Number of values must match first dimension of indices.\",",
      "202:                     \"Got \", num_values,",
      "203:                     \" values, indices shape: \", indices.shape().DebugString()));",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "235:     bool use_weights = weights.NumElements() > 0;",
      "236:     bool is_1d = false;",
      "238:     const auto splits_values = splits.flat<int64>();",
      "239:     const auto values_values = values.flat<T>();",
      "240:     const auto weight_values = weights.flat<W>();",
      "241:     int num_batches = splits.NumElements() - 1;",
      "242:     int num_values = values.NumElements();",
      "244:     auto per_batch_counts = BatchedMap<W>(num_batches);",
      "245:     T max_value = 0;",
      "246:     int batch_idx = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "258:     if (use_weights) {",
      "259:       OP_REQUIRES(",
      "260:           context, weights.shape() == values.shape(),",
      "261:           errors::InvalidArgument(",
      "262:               \"Weights and values must have the same shape. Weight shape: \",",
      "263:               weights.shape().DebugString(),",
      "264:               \"; values shape: \", values.shape().DebugString()));",
      "265:     }",
      "273:     OP_REQUIRES(",
      "274:         context, num_batches > 0,",
      "275:         errors::InvalidArgument(",
      "276:             \"Must provide at least 2 elements for the splits argument\"));",
      "277:     OP_REQUIRES(context, splits_values(0) == 0,",
      "278:                 errors::InvalidArgument(\"Splits must start with 0, not with \",",
      "279:                                         splits_values(0)));",
      "280:     OP_REQUIRES(context, splits_values(num_batches) == num_values,",
      "281:                 errors::InvalidArgument(",
      "282:                     \"Splits must end with the number of values, got \",",
      "283:                     splits_values(num_batches), \" instead of \", num_values));",
      "",
      "---------------"
    ],
    "tensorflow/python/ops/bincount_ops_test.py||tensorflow/python/ops/bincount_ops_test.py": [
      "File: tensorflow/python/ops/bincount_ops_test.py -> tensorflow/python/ops/bincount_ops_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "25: from tensorflow.python.framework import errors",
      "26: from tensorflow.python.framework import ops",
      "27: from tensorflow.python.framework import sparse_tensor",
      "28: from tensorflow.python.ops import bincount_ops",
      "29: from tensorflow.python.ops import sparse_ops",
      "30: from tensorflow.python.ops.ragged import ragged_factory_ops",
      "31: from tensorflow.python.ops.ragged import ragged_tensor",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "28: from tensorflow.python.framework import test_util",
      "30: from tensorflow.python.ops import gen_count_ops",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "834:       self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
      "837: if __name__ == \"__main__\":",
      "838:   test.main()",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "839: @test_util.run_all_in_graph_and_eager_modes",
      "840: @test_util.disable_tfrt",
      "841: class RawOpsTest(test.TestCase, parameterized.TestCase):",
      "843:   def testSparseCountSparseOutputBadIndicesShape(self):",
      "844:     indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]",
      "845:     values = [1, 1, 1, 10]",
      "846:     weights = [1, 2, 4, 6]",
      "847:     dense_shape = [2, 3]",
      "848:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
      "849:                                 \"Input indices must be a 2-dimensional tensor\"):",
      "850:       self.evaluate(",
      "851:           gen_count_ops.SparseCountSparseOutput(",
      "852:               indices=indices,",
      "853:               values=values,",
      "854:               dense_shape=dense_shape,",
      "855:               weights=weights,",
      "856:               binary_output=False))",
      "858:   def testSparseCountSparseOutputBadWeightsShape(self):",
      "859:     indices = [[0, 0], [0, 1], [1, 0], [1, 2]]",
      "860:     values = [1, 1, 1, 10]",
      "861:     weights = [1, 2, 4]",
      "862:     dense_shape = [2, 3]",
      "863:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
      "864:                                 \"Weights and values must have the same shape\"):",
      "865:       self.evaluate(",
      "866:           gen_count_ops.SparseCountSparseOutput(",
      "867:               indices=indices,",
      "868:               values=values,",
      "869:               dense_shape=dense_shape,",
      "870:               weights=weights,",
      "871:               binary_output=False))",
      "873:   def testSparseCountSparseOutputBadNumberOfValues(self):",
      "874:     indices = [[0, 0], [0, 1], [1, 0]]",
      "875:     values = [1, 1, 1, 10]",
      "876:     weights = [1, 2, 4, 6]",
      "877:     dense_shape = [2, 3]",
      "878:     with self.assertRaisesRegex(",
      "879:         errors.InvalidArgumentError,",
      "880:         \"Number of values must match first dimension of indices\"):",
      "881:       self.evaluate(",
      "882:           gen_count_ops.SparseCountSparseOutput(",
      "883:               indices=indices,",
      "884:               values=values,",
      "885:               dense_shape=dense_shape,",
      "886:               weights=weights,",
      "887:               binary_output=False))",
      "889:   def testRaggedCountSparseOutput(self):",
      "890:     splits = [0, 4, 7]",
      "891:     values = [1, 1, 2, 1, 2, 10, 5]",
      "892:     weights = [1, 2, 3, 4, 5, 6, 7]",
      "893:     output_indices, output_values, output_shape = self.evaluate(",
      "894:         gen_count_ops.RaggedCountSparseOutput(",
      "895:             splits=splits, values=values, weights=weights, binary_output=False))",
      "896:     self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],",
      "897:                         output_indices)",
      "898:     self.assertAllEqual([7, 3, 5, 7, 6], output_values)",
      "899:     self.assertAllEqual([2, 11], output_shape)",
      "901:   def testRaggedCountSparseOutputBadWeightsShape(self):",
      "902:     splits = [0, 4, 7]",
      "903:     values = [1, 1, 2, 1, 2, 10, 5]",
      "904:     weights = [1, 2, 3, 4, 5, 6]",
      "905:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
      "906:                                 \"Weights and values must have the same shape\"):",
      "907:       self.evaluate(",
      "908:           gen_count_ops.RaggedCountSparseOutput(",
      "909:               splits=splits,",
      "910:               values=values,",
      "911:               weights=weights,",
      "912:               binary_output=False))",
      "914:   def testRaggedCountSparseOutputEmptySplits(self):",
      "915:     splits = []",
      "916:     values = [1, 1, 2, 1, 2, 10, 5]",
      "917:     weights = [1, 2, 3, 4, 5, 6, 7]",
      "918:     with self.assertRaisesRegex(",
      "919:         errors.InvalidArgumentError,",
      "920:         \"Must provide at least 2 elements for the splits argument\"):",
      "921:       self.evaluate(",
      "922:           gen_count_ops.RaggedCountSparseOutput(",
      "923:               splits=splits,",
      "924:               values=values,",
      "925:               weights=weights,",
      "926:               binary_output=False))",
      "928:   def testRaggedCountSparseOutputBadSplitsStart(self):",
      "929:     splits = [1, 7]",
      "930:     values = [1, 1, 2, 1, 2, 10, 5]",
      "931:     weights = [1, 2, 3, 4, 5, 6, 7]",
      "932:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
      "933:                                 \"Splits must start with 0\"):",
      "934:       self.evaluate(",
      "935:           gen_count_ops.RaggedCountSparseOutput(",
      "936:               splits=splits,",
      "937:               values=values,",
      "938:               weights=weights,",
      "939:               binary_output=False))",
      "941:   def testRaggedCountSparseOutputBadSplitsEnd(self):",
      "942:     splits = [0, 5]",
      "943:     values = [1, 1, 2, 1, 2, 10, 5]",
      "944:     weights = [1, 2, 3, 4, 5, 6, 7]",
      "945:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
      "946:                                 \"Splits must end with the number of values\"):",
      "947:       self.evaluate(",
      "948:           gen_count_ops.RaggedCountSparseOutput(",
      "949:               splits=splits,",
      "950:               values=values,",
      "951:               weights=weights,",
      "952:               binary_output=False))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b3075637e9583740e903e56ed8eee227f7abbbf0",
      "candidate_info": {
        "commit_hash": "b3075637e9583740e903e56ed8eee227f7abbbf0",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/b3075637e9583740e903e56ed8eee227f7abbbf0",
        "files": [
          "tensorflow/core/kernels/count_ops.cc",
          "tensorflow/python/ops/bincount_ops_test.py"
        ],
        "message": "Fix multiple vulnerabilities in `tf.raw_ops.*CountSparseOutput`.\n\nAlso add tests for these API points, both for the happy paths and for the vulnerable ones.\n\nPiperOrigin-RevId: 332563222\nChange-Id: Ib3b52116a83a134c2e742a7c66e5e956db8fba05",
        "before_after_code_files": [
          "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc",
          "tensorflow/python/ops/bincount_ops_test.py||tensorflow/python/ops/bincount_ops_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc",
            "tensorflow/python/ops/bincount_ops_test.py||tensorflow/python/ops/bincount_ops_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc",
            "tensorflow/python/ops/bincount_ops_test.py||tensorflow/python/ops/bincount_ops_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/count_ops.cc||tensorflow/core/kernels/count_ops.cc": [
          "File: tensorflow/core/kernels/count_ops.cc -> tensorflow/core/kernels/count_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:     const Tensor& weights = context->input(3);",
          "179:     bool use_weights = weights.NumElements() > 0;",
          "181:     bool is_1d = shape.NumElements() == 1;",
          "182:     int num_batches = is_1d ? 1 : shape.flat<int64>()(0);",
          "183:     int num_values = values.NumElements();",
          "185:     const auto indices_values = indices.matrix<int64>();",
          "186:     const auto values_values = values.flat<T>();",
          "187:     const auto weight_values = weights.flat<W>();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181:     OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),",
          "182:                 errors::InvalidArgument(",
          "183:                     \"Input indices must be a 2-dimensional tensor. Got: \",",
          "184:                     indices.shape().DebugString()));",
          "186:     if (use_weights) {",
          "187:       OP_REQUIRES(",
          "188:           context, weights.shape() == values.shape(),",
          "189:           errors::InvalidArgument(",
          "190:               \"Weights and values must have the same shape. Weight shape: \",",
          "191:               weights.shape().DebugString(),",
          "192:               \"; values shape: \", values.shape().DebugString()));",
          "193:     }",
          "199:     OP_REQUIRES(context, num_values == indices.shape().dim_size(0),",
          "200:                 errors::InvalidArgument(",
          "201:                     \"Number of values must match first dimension of indices.\",",
          "202:                     \"Got \", num_values,",
          "203:                     \" values, indices shape: \", indices.shape().DebugString()));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "235:     bool use_weights = weights.NumElements() > 0;",
          "236:     bool is_1d = false;",
          "238:     const auto splits_values = splits.flat<int64>();",
          "239:     const auto values_values = values.flat<T>();",
          "240:     const auto weight_values = weights.flat<W>();",
          "241:     int num_batches = splits.NumElements() - 1;",
          "242:     int num_values = values.NumElements();",
          "244:     auto per_batch_counts = BatchedMap<W>(num_batches);",
          "245:     T max_value = 0;",
          "246:     int batch_idx = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "258:     if (use_weights) {",
          "259:       OP_REQUIRES(",
          "260:           context, weights.shape() == values.shape(),",
          "261:           errors::InvalidArgument(",
          "262:               \"Weights and values must have the same shape. Weight shape: \",",
          "263:               weights.shape().DebugString(),",
          "264:               \"; values shape: \", values.shape().DebugString()));",
          "265:     }",
          "273:     OP_REQUIRES(",
          "274:         context, num_batches > 0,",
          "275:         errors::InvalidArgument(",
          "276:             \"Must provide at least 2 elements for the splits argument\"));",
          "277:     OP_REQUIRES(context, splits_values(0) == 0,",
          "278:                 errors::InvalidArgument(\"Splits must start with 0, not with \",",
          "279:                                         splits_values(0)));",
          "280:     OP_REQUIRES(context, splits_values(num_batches) == num_values,",
          "281:                 errors::InvalidArgument(",
          "282:                     \"Splits must end with the number of values, got \",",
          "283:                     splits_values(num_batches), \" instead of \", num_values));",
          "",
          "---------------"
        ],
        "tensorflow/python/ops/bincount_ops_test.py||tensorflow/python/ops/bincount_ops_test.py": [
          "File: tensorflow/python/ops/bincount_ops_test.py -> tensorflow/python/ops/bincount_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "25: from tensorflow.python.framework import errors",
          "26: from tensorflow.python.framework import ops",
          "27: from tensorflow.python.framework import sparse_tensor",
          "28: from tensorflow.python.ops import bincount_ops",
          "29: from tensorflow.python.ops import sparse_ops",
          "30: from tensorflow.python.ops.ragged import ragged_factory_ops",
          "31: from tensorflow.python.ops.ragged import ragged_tensor",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28: from tensorflow.python.framework import test_util",
          "30: from tensorflow.python.ops import gen_count_ops",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "834:       self.evaluate(bincount_ops.sparse_bincount(x, weights=weights, axis=-1))",
          "837: if __name__ == \"__main__\":",
          "838:   test.main()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "839: @test_util.run_all_in_graph_and_eager_modes",
          "840: @test_util.disable_tfrt",
          "841: class RawOpsTest(test.TestCase, parameterized.TestCase):",
          "843:   def testSparseCountSparseOutputBadIndicesShape(self):",
          "844:     indices = [[[0], [0]], [[0], [1]], [[1], [0]], [[1], [2]]]",
          "845:     values = [1, 1, 1, 10]",
          "846:     weights = [1, 2, 4, 6]",
          "847:     dense_shape = [2, 3]",
          "848:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "849:                                 \"Input indices must be a 2-dimensional tensor\"):",
          "850:       self.evaluate(",
          "851:           gen_count_ops.SparseCountSparseOutput(",
          "852:               indices=indices,",
          "853:               values=values,",
          "854:               dense_shape=dense_shape,",
          "855:               weights=weights,",
          "856:               binary_output=False))",
          "858:   def testSparseCountSparseOutputBadWeightsShape(self):",
          "859:     indices = [[0, 0], [0, 1], [1, 0], [1, 2]]",
          "860:     values = [1, 1, 1, 10]",
          "861:     weights = [1, 2, 4]",
          "862:     dense_shape = [2, 3]",
          "863:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "864:                                 \"Weights and values must have the same shape\"):",
          "865:       self.evaluate(",
          "866:           gen_count_ops.SparseCountSparseOutput(",
          "867:               indices=indices,",
          "868:               values=values,",
          "869:               dense_shape=dense_shape,",
          "870:               weights=weights,",
          "871:               binary_output=False))",
          "873:   def testSparseCountSparseOutputBadNumberOfValues(self):",
          "874:     indices = [[0, 0], [0, 1], [1, 0]]",
          "875:     values = [1, 1, 1, 10]",
          "876:     weights = [1, 2, 4, 6]",
          "877:     dense_shape = [2, 3]",
          "878:     with self.assertRaisesRegex(",
          "879:         errors.InvalidArgumentError,",
          "880:         \"Number of values must match first dimension of indices\"):",
          "881:       self.evaluate(",
          "882:           gen_count_ops.SparseCountSparseOutput(",
          "883:               indices=indices,",
          "884:               values=values,",
          "885:               dense_shape=dense_shape,",
          "886:               weights=weights,",
          "887:               binary_output=False))",
          "889:   def testRaggedCountSparseOutput(self):",
          "890:     splits = [0, 4, 7]",
          "891:     values = [1, 1, 2, 1, 2, 10, 5]",
          "892:     weights = [1, 2, 3, 4, 5, 6, 7]",
          "893:     output_indices, output_values, output_shape = self.evaluate(",
          "894:         gen_count_ops.RaggedCountSparseOutput(",
          "895:             splits=splits, values=values, weights=weights, binary_output=False))",
          "896:     self.assertAllEqual([[0, 1], [0, 2], [1, 2], [1, 5], [1, 10]],",
          "897:                         output_indices)",
          "898:     self.assertAllEqual([7, 3, 5, 7, 6], output_values)",
          "899:     self.assertAllEqual([2, 11], output_shape)",
          "901:   def testRaggedCountSparseOutputBadWeightsShape(self):",
          "902:     splits = [0, 4, 7]",
          "903:     values = [1, 1, 2, 1, 2, 10, 5]",
          "904:     weights = [1, 2, 3, 4, 5, 6]",
          "905:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "906:                                 \"Weights and values must have the same shape\"):",
          "907:       self.evaluate(",
          "908:           gen_count_ops.RaggedCountSparseOutput(",
          "909:               splits=splits,",
          "910:               values=values,",
          "911:               weights=weights,",
          "912:               binary_output=False))",
          "914:   def testRaggedCountSparseOutputEmptySplits(self):",
          "915:     splits = []",
          "916:     values = [1, 1, 2, 1, 2, 10, 5]",
          "917:     weights = [1, 2, 3, 4, 5, 6, 7]",
          "918:     with self.assertRaisesRegex(",
          "919:         errors.InvalidArgumentError,",
          "920:         \"Must provide at least 2 elements for the splits argument\"):",
          "921:       self.evaluate(",
          "922:           gen_count_ops.RaggedCountSparseOutput(",
          "923:               splits=splits,",
          "924:               values=values,",
          "925:               weights=weights,",
          "926:               binary_output=False))",
          "928:   def testRaggedCountSparseOutputBadSplitsStart(self):",
          "929:     splits = [1, 7]",
          "930:     values = [1, 1, 2, 1, 2, 10, 5]",
          "931:     weights = [1, 2, 3, 4, 5, 6, 7]",
          "932:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "933:                                 \"Splits must start with 0\"):",
          "934:       self.evaluate(",
          "935:           gen_count_ops.RaggedCountSparseOutput(",
          "936:               splits=splits,",
          "937:               values=values,",
          "938:               weights=weights,",
          "939:               binary_output=False))",
          "941:   def testRaggedCountSparseOutputBadSplitsEnd(self):",
          "942:     splits = [0, 5]",
          "943:     values = [1, 1, 2, 1, 2, 10, 5]",
          "944:     weights = [1, 2, 3, 4, 5, 6, 7]",
          "945:     with self.assertRaisesRegex(errors.InvalidArgumentError,",
          "946:                                 \"Splits must end with the number of values\"):",
          "947:       self.evaluate(",
          "948:           gen_count_ops.RaggedCountSparseOutput(",
          "949:               splits=splits,",
          "950:               values=values,",
          "951:               weights=weights,",
          "952:               binary_output=False))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
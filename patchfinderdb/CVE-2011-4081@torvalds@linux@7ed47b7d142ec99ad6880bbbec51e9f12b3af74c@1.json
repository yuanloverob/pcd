{
  "cve_id": "CVE-2011-4081",
  "cve_desc": "crypto/ghash-generic.c in the Linux kernel before 3.1 allows local users to cause a denial of service (NULL pointer dereference and OOPS) or possibly have unspecified other impact by triggering a failed or missing ghash_setkey function call, followed by a (1) ghash_update function call or (2) ghash_final function call, as demonstrated by a write operation on an AF_ALG socket.",
  "repo": "torvalds/linux",
  "patch_hash": "7ed47b7d142ec99ad6880bbbec51e9f12b3af74c",
  "patch_info": {
    "commit_hash": "7ed47b7d142ec99ad6880bbbec51e9f12b3af74c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/7ed47b7d142ec99ad6880bbbec51e9f12b3af74c",
    "files": [
      "crypto/ghash-generic.c"
    ],
    "message": "crypto: ghash - Avoid null pointer dereference if no key is set\n\nThe ghash_update function passes a pointer to gf128mul_4k_lle which will\nbe NULL if ghash_setkey is not called or if the most recent call to\nghash_setkey failed to allocate memory.  This causes an oops.  Fix this\nup by returning an error code in the null case.\n\nThis is trivially triggered from unprivileged userspace through the\nAF_ALG interface by simply writing to the socket without setting a key.\n\nThe ghash_final function has a similar issue, but triggering it requires\na memory allocation failure in ghash_setkey _after_ at least one\nsuccessful call to ghash_update.\n\n  BUG: unable to handle kernel NULL pointer dereference at 00000670\n  IP: [<d88c92d4>] gf128mul_4k_lle+0x23/0x60 [gf128mul]\n  *pde = 00000000\n  Oops: 0000 [#1] PREEMPT SMP\n  Modules linked in: ghash_generic gf128mul algif_hash af_alg nfs lockd nfs_acl sunrpc bridge ipv6 stp llc\n\n  Pid: 1502, comm: hashatron Tainted: G        W   3.1.0-rc9-00085-ge9308cf #32 Bochs Bochs\n  EIP: 0060:[<d88c92d4>] EFLAGS: 00000202 CPU: 0\n  EIP is at gf128mul_4k_lle+0x23/0x60 [gf128mul]\n  EAX: d69db1f0 EBX: d6b8ddac ECX: 00000004 EDX: 00000000\n  ESI: 00000670 EDI: d6b8ddac EBP: d6b8ddc8 ESP: d6b8dda4\n   DS: 007b ES: 007b FS: 00d8 GS: 0033 SS: 0068\n  Process hashatron (pid: 1502, ti=d6b8c000 task=d6810000 task.ti=d6b8c000)\n  Stack:\n   00000000 d69db1f0 00000163 00000000 d6b8ddc8 c101a520 d69db1f0 d52aa000\n   00000ff0 d6b8dde8 d88d310f d6b8a3f8 d52aa000 00001000 d88d502c d6b8ddfc\n   00001000 d6b8ddf4 c11676ed d69db1e8 d6b8de24 c11679ad d52aa000 00000000\n  Call Trace:\n   [<c101a520>] ? kmap_atomic_prot+0x37/0xa6\n   [<d88d310f>] ghash_update+0x85/0xbe [ghash_generic]\n   [<c11676ed>] crypto_shash_update+0x18/0x1b\n   [<c11679ad>] shash_ahash_update+0x22/0x36\n   [<c11679cc>] shash_async_update+0xb/0xd\n   [<d88ce0ba>] hash_sendpage+0xba/0xf2 [algif_hash]\n   [<c121b24c>] kernel_sendpage+0x39/0x4e\n   [<d88ce000>] ? 0xd88cdfff\n   [<c121b298>] sock_sendpage+0x37/0x3e\n   [<c121b261>] ? kernel_sendpage+0x4e/0x4e\n   [<c10b4dbc>] pipe_to_sendpage+0x56/0x61\n   [<c10b4e1f>] splice_from_pipe_feed+0x58/0xcd\n   [<c10b4d66>] ? splice_from_pipe_begin+0x10/0x10\n   [<c10b51f5>] __splice_from_pipe+0x36/0x55\n   [<c10b4d66>] ? splice_from_pipe_begin+0x10/0x10\n   [<c10b6383>] splice_from_pipe+0x51/0x64\n   [<c10b63c2>] ? default_file_splice_write+0x2c/0x2c\n   [<c10b63d5>] generic_splice_sendpage+0x13/0x15\n   [<c10b4d66>] ? splice_from_pipe_begin+0x10/0x10\n   [<c10b527f>] do_splice_from+0x5d/0x67\n   [<c10b6865>] sys_splice+0x2bf/0x363\n   [<c129373b>] ? sysenter_exit+0xf/0x16\n   [<c104dc1e>] ? trace_hardirqs_on_caller+0x10e/0x13f\n   [<c129370c>] sysenter_do_call+0x12/0x32\n  Code: 83 c4 0c 5b 5e 5f c9 c3 55 b9 04 00 00 00 89 e5 57 8d 7d e4 56 53 8d 5d e4 83 ec 18 89 45 e0 89 55 dc 0f b6 70 0f c1 e6 04 01 d6 <f3> a5 be 0f 00 00 00 4e 89 d8 e8 48 ff ff ff 8b 45 e0 89 da 0f\n  EIP: [<d88c92d4>] gf128mul_4k_lle+0x23/0x60 [gf128mul] SS:ESP 0068:d6b8dda4\n  CR2: 0000000000000670\n  ---[ end trace 4eaa2a86a8e2da24 ]---\n  note: hashatron[1502] exited with preempt_count 1\n  BUG: scheduling while atomic: hashatron/1502/0x10000002\n  INFO: lockdep is turned off.\n  [...]\n\nSigned-off-by: Nick Bowler <nbowler@elliptictech.com>\nCc: stable@kernel.org [2.6.37+]\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>",
    "before_after_code_files": [
      "crypto/ghash-generic.c||crypto/ghash-generic.c"
    ]
  },
  "patch_diff": {
    "crypto/ghash-generic.c||crypto/ghash-generic.c": [
      "File: crypto/ghash-generic.c -> crypto/ghash-generic.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "67:  struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);",
      "68:  u8 *dst = dctx->buffer;",
      "70:  if (dctx->bytes) {",
      "71:   int n = min(srclen, dctx->bytes);",
      "72:   u8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "70:  if (!ctx->gf128)",
      "71:   return -ENOKEY;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "119:  struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);",
      "120:  u8 *buf = dctx->buffer;",
      "122:  ghash_flush(ctx, dctx);",
      "123:  memcpy(dst, buf, GHASH_BLOCK_SIZE);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "125:  if (!ctx->gf128)",
      "126:   return -ENOKEY;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c9a929dde3913780b5c416f4bb9d9ed804f509ce",
      "candidate_info": {
        "commit_hash": "c9a929dde3913780b5c416f4bb9d9ed804f509ce",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c9a929dde3913780b5c416f4bb9d9ed804f509ce",
        "files": [
          "block/blk-core.c",
          "block/blk-sysfs.c",
          "block/blk-throttle.c",
          "block/blk.h",
          "block/elevator.c"
        ],
        "message": "block: fix request_queue lifetime handling by making blk_queue_cleanup() properly shutdown\n\nrequest_queue is refcounted but actually depdends on lifetime\nmanagement from the queue owner - on blk_cleanup_queue(), block layer\nexpects that there's no request passing through request_queue and no\nnew one will.\n\nThis is fundamentally broken.  The queue owner (e.g. SCSI layer)\ndoesn't have a way to know whether there are other active users before\ncalling blk_cleanup_queue() and other users (e.g. bsg) don't have any\nguarantee that the queue is and would stay valid while it's holding a\nreference.\n\nWith delay added in blk_queue_bio() before queue_lock is grabbed, the\nfollowing oops can be easily triggered when a device is removed with\nin-flight IOs.\n\n sd 0:0:1:0: [sdb] Stopping disk\n ata1.01: disabled\n general protection fault: 0000 [#1] PREEMPT SMP\n CPU 2\n Modules linked in:\n\n Pid: 648, comm: test_rawio Not tainted 3.1.0-rc3-work+ #56 Bochs Bochs\n RIP: 0010:[<ffffffff8137d651>]  [<ffffffff8137d651>] elv_rqhash_find+0x61/0x100\n ...\n Process test_rawio (pid: 648, threadinfo ffff880019efa000, task ffff880019ef8a80)\n ...\n Call Trace:\n  [<ffffffff8137d774>] elv_merge+0x84/0xe0\n  [<ffffffff81385b54>] blk_queue_bio+0xf4/0x400\n  [<ffffffff813838ea>] generic_make_request+0xca/0x100\n  [<ffffffff81383994>] submit_bio+0x74/0x100\n  [<ffffffff811c53ec>] dio_bio_submit+0xbc/0xc0\n  [<ffffffff811c610e>] __blockdev_direct_IO+0x92e/0xb40\n  [<ffffffff811c39f7>] blkdev_direct_IO+0x57/0x60\n  [<ffffffff8113b1c5>] generic_file_aio_read+0x6d5/0x760\n  [<ffffffff8118c1ca>] do_sync_read+0xda/0x120\n  [<ffffffff8118ce55>] vfs_read+0xc5/0x180\n  [<ffffffff8118cfaa>] sys_pread64+0x9a/0xb0\n  [<ffffffff81afaf6b>] system_call_fastpath+0x16/0x1b\n\nThis happens because blk_queue_cleanup() destroys the queue and\nelevator whether IOs are in progress or not and DEAD tests are\nsprinkled in the request processing path without proper\nsynchronization.\n\nSimilar problem exists for blk-throtl.  On queue cleanup, blk-throtl\nis shutdown whether it has requests in it or not.  Depending on\ntiming, it either oopses or throttled bios are lost putting tasks\nwhich are waiting for bio completion into eternal D state.\n\nThe way it should work is having the usual clear distinction between\nshutdown and release.  Shutdown drains all currently pending requests,\nmarks the queue dead, and performs partial teardown of the now\nunnecessary part of the queue.  Even after shutdown is complete,\nreference holders are still allowed to issue requests to the queue\nalthough they will be immmediately failed.  The rest of teardown\nhappens on release.\n\nThis patch makes the following changes to make blk_queue_cleanup()\nbehave as proper shutdown.\n\n* QUEUE_FLAG_DEAD is now set while holding both q->exit_mutex and\n  queue_lock.\n\n* Unsynchronized DEAD check in generic_make_request_checks() removed.\n  This couldn't make any meaningful difference as the queue could die\n  after the check.\n\n* blk_drain_queue() updated such that it can drain all requests and is\n  now called during cleanup.\n\n* blk_throtl updated such that it checks DEAD on grabbing queue_lock,\n  drains all throttled bios during cleanup and free td when queue is\n  released.\n\nSigned-off-by: Tejun Heo <tj@kernel.org>\nCc: Vivek Goyal <vgoyal@redhat.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "before_after_code_files": [
          "block/blk-core.c||block/blk-core.c",
          "block/blk-sysfs.c||block/blk-sysfs.c",
          "block/blk-throttle.c||block/blk-throttle.c",
          "block/blk.h||block/blk.h",
          "block/elevator.c||block/elevator.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "block/blk-core.c||block/blk-core.c": [
          "File: block/blk-core.c -> block/blk-core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "357: {",
          "358:  while (true) {",
          "359:   int nr_rqs;",
          "",
          "[Removed Lines]",
          "356: void blk_drain_queue(struct request_queue *q)",
          "",
          "[Added Lines]",
          "358: void blk_drain_queue(struct request_queue *q, bool drain_all)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "361:   spin_lock_irq(q->queue_lock);",
          "363:   elv_drain_elevator(q);",
          "365:   __blk_run_queue(q);",
          "368:   spin_unlock_irq(q->queue_lock);",
          "",
          "[Removed Lines]",
          "366:   nr_rqs = q->rq.elvpriv;",
          "",
          "[Added Lines]",
          "366:   if (drain_all)",
          "367:    blk_throtl_drain(q);",
          "371:   if (drain_all)",
          "372:    nr_rqs = q->rq.count[0] + q->rq.count[1];",
          "373:   else",
          "374:    nr_rqs = q->rq.elvpriv;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "373:  }",
          "374: }",
          "382: void blk_cleanup_queue(struct request_queue *q)",
          "383: {",
          "393:  mutex_lock(&q->sysfs_lock);",
          "394:  queue_flag_set_unlocked(QUEUE_FLAG_DEAD, q);",
          "397:  if (q->queue_lock != &q->__queue_lock)",
          "398:   q->queue_lock = &q->__queue_lock;",
          "400:  blk_put_queue(q);",
          "401: }",
          "402: EXPORT_SYMBOL(blk_cleanup_queue);",
          "",
          "[Removed Lines]",
          "390:  blk_sync_queue(q);",
          "392:  del_timer_sync(&q->backing_dev_info.laptop_mode_wb_timer);",
          "395:  mutex_unlock(&q->sysfs_lock);",
          "",
          "[Added Lines]",
          "393:  spinlock_t *lock = q->queue_lock;",
          "399:  spin_lock_irq(lock);",
          "400:  queue_flag_set(QUEUE_FLAG_NOMERGES, q);",
          "401:  queue_flag_set(QUEUE_FLAG_NOXMERGES, q);",
          "402:  queue_flag_set(QUEUE_FLAG_DEAD, q);",
          "407:  spin_unlock_irq(lock);",
          "408:  mutex_unlock(&q->sysfs_lock);",
          "411:  blk_drain_queue(q, true);",
          "414:  del_timer_sync(&q->backing_dev_info.laptop_mode_wb_timer);",
          "415:  blk_sync_queue(q);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1509:   goto end_io;",
          "1510:  }",
          "1515:  part = bio->bi_bdev->bd_part;",
          "1516:  if (should_fail_request(part, bio->bi_size) ||",
          "1517:      should_fail_request(&part_to_disk(part)->part0,",
          "",
          "[Removed Lines]",
          "1512:  if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))",
          "1513:   goto end_io;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "block/blk-sysfs.c||block/blk-sysfs.c": [
          "File: block/blk-sysfs.c -> block/blk-sysfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "490:  if (q->queue_tags)",
          "491:   __blk_queue_free_tags(q);",
          "493:  blk_trace_shutdown(q);",
          "495:  bdi_destroy(&q->backing_dev_info);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "493:  blk_throtl_release(q);",
          "",
          "---------------"
        ],
        "block/blk-throttle.c||block/blk-throttle.c": [
          "File: block/blk-throttle.c -> block/blk-throttle.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "309:  struct blkio_cgroup *blkcg;",
          "310:  struct request_queue *q = td->queue;",
          "312:  rcu_read_lock();",
          "313:  blkcg = task_blkio_cgroup(current);",
          "314:  tg = throtl_find_tg(td, blkcg);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "313:  if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))",
          "314:   return NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1001:  }",
          "1002: }",
          "",
          "[Removed Lines]",
          "1004: static void throtl_td_free(struct throtl_data *td)",
          "1005: {",
          "1006:  kfree(td);",
          "1007: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1204:  return throttled;",
          "1205: }",
          "1207: int blk_throtl_init(struct request_queue *q)",
          "1208: {",
          "1209:  struct throtl_data *td;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1212: void blk_throtl_drain(struct request_queue *q)",
          "1213:  __releases(q->queue_lock) __acquires(q->queue_lock)",
          "1214: {",
          "1215:  struct throtl_data *td = q->td;",
          "1216:  struct throtl_rb_root *st = &td->tg_service_tree;",
          "1217:  struct throtl_grp *tg;",
          "1218:  struct bio_list bl;",
          "1219:  struct bio *bio;",
          "1221:  lockdep_is_held(q->queue_lock);",
          "1223:  bio_list_init(&bl);",
          "1225:  while ((tg = throtl_rb_first(st))) {",
          "1226:   throtl_dequeue_tg(td, tg);",
          "1228:   while ((bio = bio_list_peek(&tg->bio_lists[READ])))",
          "1229:    tg_dispatch_one_bio(td, tg, bio_data_dir(bio), &bl);",
          "1230:   while ((bio = bio_list_peek(&tg->bio_lists[WRITE])))",
          "1231:    tg_dispatch_one_bio(td, tg, bio_data_dir(bio), &bl);",
          "1232:  }",
          "1233:  spin_unlock_irq(q->queue_lock);",
          "1235:  while ((bio = bio_list_pop(&bl)))",
          "1236:   generic_make_request(bio);",
          "1238:  spin_lock_irq(q->queue_lock);",
          "1239: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1278:  throtl_shutdown_wq(q);",
          "1280: }",
          "1282: static int __init throtl_init(void)",
          "",
          "[Removed Lines]",
          "1279:  throtl_td_free(td);",
          "",
          "[Added Lines]",
          "1313: }",
          "1315: void blk_throtl_release(struct request_queue *q)",
          "1316: {",
          "1317:  kfree(q->td);",
          "",
          "---------------"
        ],
        "block/blk.h||block/blk.h": [
          "File: block/blk.h -> block/blk.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:    struct bio *bio);",
          "16: int blk_rq_append_bio(struct request_queue *q, struct request *rq,",
          "17:         struct bio *bio);",
          "19: void blk_dequeue_request(struct request *rq);",
          "20: void __blk_queue_free_tags(struct request_queue *q);",
          "21: bool __blk_end_bidi_request(struct request *rq, int error,",
          "",
          "[Removed Lines]",
          "18: void blk_drain_queue(struct request_queue *q);",
          "",
          "[Added Lines]",
          "18: void blk_drain_queue(struct request_queue *q, bool drain_all);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192: #ifdef CONFIG_BLK_DEV_THROTTLING",
          "193: extern bool blk_throtl_bio(struct request_queue *q, struct bio *bio);",
          "194: extern int blk_throtl_init(struct request_queue *q);",
          "195: extern void blk_throtl_exit(struct request_queue *q);",
          "197: static inline bool blk_throtl_bio(struct request_queue *q, struct bio *bio)",
          "198: {",
          "199:  return false;",
          "200: }",
          "201: static inline int blk_throtl_init(struct request_queue *q) { return 0; }",
          "202: static inline void blk_throtl_exit(struct request_queue *q) { }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "194: extern void blk_throtl_drain(struct request_queue *q);",
          "197: extern void blk_throtl_release(struct request_queue *q);",
          "203: static inline void blk_throtl_drain(struct request_queue *q) { }",
          "206: static inline void blk_throtl_release(struct request_queue *q) { }",
          "",
          "---------------"
        ],
        "block/elevator.c||block/elevator.c": [
          "File: block/elevator.c -> block/elevator.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "626:  queue_flag_set(QUEUE_FLAG_ELVSWITCH, q);",
          "627:  spin_unlock_irq(q->queue_lock);",
          "630: }",
          "632: void elv_quiesce_end(struct request_queue *q)",
          "",
          "[Removed Lines]",
          "629:  blk_drain_queue(q);",
          "",
          "[Added Lines]",
          "629:  blk_drain_queue(q, false);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
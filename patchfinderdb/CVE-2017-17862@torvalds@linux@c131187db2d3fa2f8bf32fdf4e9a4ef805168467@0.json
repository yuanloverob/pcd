{
  "cve_id": "CVE-2017-17862",
  "cve_desc": "kernel/bpf/verifier.c in the Linux kernel through 4.14.8 ignores unreachable code, even though it would still be processed by JIT compilers. This behavior, also considered an improper branch-pruning logic issue, could possibly be used by local users for denial of service.",
  "repo": "torvalds/linux",
  "patch_hash": "c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
  "patch_info": {
    "commit_hash": "c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/c131187db2d3fa2f8bf32fdf4e9a4ef805168467",
    "files": [
      "include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c"
    ],
    "message": "bpf: fix branch pruning logic\n\nwhen the verifier detects that register contains a runtime constant\nand it's compared with another constant it will prune exploration\nof the branch that is guaranteed not to be taken at runtime.\nThis is all correct, but malicious program may be constructed\nin such a way that it always has a constant comparison and\nthe other branch is never taken under any conditions.\nIn this case such path through the program will not be explored\nby the verifier. It won't be taken at run-time either, but since\nall instructions are JITed the malicious program may cause JITs\nto complain about using reserved fields, etc.\nTo fix the issue we have to track the instructions explored by\nthe verifier and sanitize instructions that are dead at run time\nwith NOPs. We cannot reject such dead code, since llvm generates\nit for valid C code, since it doesn't do as much data flow\nanalysis as the verifier does.\n\nFixes: 17a5267067f3 (\"bpf: verifier (add verifier core)\")\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nAcked-by: Daniel Borkmann <daniel@iogearbox.net>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
    "before_after_code_files": [
      "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
      "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
    ]
  },
  "patch_diff": {
    "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
      "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h"
    ],
    "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
      "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3827:    return err;",
      "3829:   regs = cur_regs(env);",
      "3830:   if (class == BPF_ALU || class == BPF_ALU64) {",
      "3831:    err = check_alu_op(env, insn);",
      "3832:    if (err)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3830:   env->insn_aux_data[insn_idx].seen = true;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4022:      return err;",
      "4024:     insn_idx++;",
      "4025:    } else {",
      "4026:     verbose(env, \"invalid BPF_LD mode\\n\");",
      "4027:     return -EINVAL;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4026:     env->insn_aux_data[insn_idx].seen = true;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "4204:     u32 off, u32 cnt)",
      "4205: {",
      "4206:  struct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;",
      "4208:  if (cnt == 1)",
      "4209:   return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4209:  int i;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "4213:  memcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);",
      "4214:  memcpy(new_data + off + cnt - 1, old_data + off,",
      "4215:         sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));",
      "4216:  env->insn_aux_data = new_data;",
      "4217:  vfree(old_data);",
      "4218:  return 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4219:  for (i = off; i < off + cnt - 1; i++)",
      "4220:   new_data[i].seen = true;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "4231:  return new_prog;",
      "4232: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4243: static void sanitize_dead_code(struct bpf_verifier_env *env)",
      "4244: {",
      "4245:  struct bpf_insn_aux_data *aux_data = env->insn_aux_data;",
      "4246:  struct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);",
      "4247:  struct bpf_insn *insn = env->prog->insnsi;",
      "4248:  const int insn_cnt = env->prog->len;",
      "4249:  int i;",
      "4251:  for (i = 0; i < insn_cnt; i++) {",
      "4252:   if (aux_data[i].seen)",
      "4253:    continue;",
      "4254:   memcpy(insn + i, &nop, sizeof(nop));",
      "4255:  }",
      "4256: }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "4557:  while (!pop_stack(env, NULL, NULL));",
      "4558:  free_states(env);",
      "4560:  if (ret == 0)",
      "4562:   ret = convert_ctx_accesses(env);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4584:  if (ret == 0)",
      "4585:   sanitize_dead_code(env);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "70a87ffea8acc390ae315fa1930e849f656bdb88",
      "candidate_info": {
        "commit_hash": "70a87ffea8acc390ae315fa1930e849f656bdb88",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/70a87ffea8acc390ae315fa1930e849f656bdb88",
        "files": [
          "include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: fix maximum stack depth tracking logic\n\nInstead of computing max stack depth for current call chain\nduring the main verifier pass track stack depth of each\nfunction independently and after do_check() is done do\nanother pass over all instructions analyzing depth\nof all possible call stacks.\n\nFixes: f4d7e40a5b71 (\"bpf: introduce function calls (verification)\")\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>",
        "before_after_code_files": [
          "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h",
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/bpf_verifier.h||include/linux/bpf_verifier.h": [
          "File: include/linux/bpf_verifier.h -> include/linux/bpf_verifier.h"
        ],
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1430:          const struct bpf_func_state *func,",
          "1431:          int off)",
          "1432: {",
          "1437:  if (stack >= -off)",
          "1438:   return 0;",
          "1441:  env->subprog_stack_depth[func->subprogno] = -off;",
          "1455:   verbose(env, \"combined stack size of %d calls is %d. Too large\\n\",",
          "1457:   return -EACCES;",
          "1458:  }",
          "1460: }",
          "1462: static int get_callee_stack_depth(struct bpf_verifier_env *env,",
          "",
          "[Removed Lines]",
          "1433:  u16 stack = env->subprog_stack_depth[func->subprogno], total = 0;",
          "1434:  struct bpf_verifier_state *cur = env->cur_state;",
          "1435:  int i;",
          "1444:  for (i = 0; i <= cur->curframe; i++) {",
          "1445:   u32 depth = env->subprog_stack_depth[cur->frame[i]->subprogno];",
          "1450:   depth = round_up(depth, 32);",
          "1451:   total += depth;",
          "1452:  }",
          "1454:  if (total > MAX_BPF_STACK) {",
          "1456:    cur->curframe, total);",
          "1459:  return 0;",
          "",
          "[Added Lines]",
          "1433:  u16 stack = env->subprog_stack_depth[func->subprogno];",
          "1440:  return 0;",
          "1441: }",
          "1449: static int check_max_stack_depth(struct bpf_verifier_env *env)",
          "1450: {",
          "1451:  int depth = 0, frame = 0, subprog = 0, i = 0, subprog_end;",
          "1452:  struct bpf_insn *insn = env->prog->insnsi;",
          "1453:  int insn_cnt = env->prog->len;",
          "1454:  int ret_insn[MAX_CALL_FRAMES];",
          "1455:  int ret_prog[MAX_CALL_FRAMES];",
          "1457: process_func:",
          "1461:  depth += round_up(max_t(u32, env->subprog_stack_depth[subprog], 1), 32);",
          "1462:  if (depth > MAX_BPF_STACK) {",
          "1464:    frame + 1, depth);",
          "1467: continue_func:",
          "1468:  if (env->subprog_cnt == subprog)",
          "1469:   subprog_end = insn_cnt;",
          "1470:  else",
          "1471:   subprog_end = env->subprog_starts[subprog];",
          "1472:  for (; i < subprog_end; i++) {",
          "1473:   if (insn[i].code != (BPF_JMP | BPF_CALL))",
          "1474:    continue;",
          "1475:   if (insn[i].src_reg != BPF_PSEUDO_CALL)",
          "1476:    continue;",
          "1478:   ret_insn[frame] = i + 1;",
          "1479:   ret_prog[frame] = subprog;",
          "1482:   i = i + insn[i].imm + 1;",
          "1483:   subprog = find_subprog(env, i);",
          "1484:   if (subprog < 0) {",
          "1485:    WARN_ONCE(1, \"verifier bug. No program starts at insn %d\\n\",",
          "1486:       i);",
          "1487:    return -EFAULT;",
          "1488:   }",
          "1489:   subprog++;",
          "1490:   frame++;",
          "1491:   if (frame >= MAX_CALL_FRAMES) {",
          "1492:    WARN_ONCE(1, \"verifier bug. Call stack is too deep\\n\");",
          "1493:    return -EFAULT;",
          "1494:   }",
          "1495:   goto process_func;",
          "1496:  }",
          "1500:  if (frame == 0)",
          "1501:   return 0;",
          "1502:  depth -= round_up(max_t(u32, env->subprog_stack_depth[subprog], 1), 32);",
          "1503:  frame--;",
          "1504:  i = ret_insn[frame];",
          "1505:  subprog = ret_prog[frame];",
          "1506:  goto continue_func;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5403:  if (ret == 0)",
          "5404:   sanitize_dead_code(env);",
          "5406:  if (ret == 0)",
          "5408:   ret = convert_ctx_accesses(env);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5453:  if (ret == 0)",
          "5454:   ret = check_max_stack_depth(env);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2a5418a13fcfbb1f13a847eedb9a8e30a9ead765",
      "candidate_info": {
        "commit_hash": "2a5418a13fcfbb1f13a847eedb9a8e30a9ead765",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2a5418a13fcfbb1f13a847eedb9a8e30a9ead765",
        "files": [
          "kernel/bpf/verifier.c"
        ],
        "message": "bpf: improve dead code sanitizing\n\nGiven we recently had c131187db2d3 (\"bpf: fix branch pruning\nlogic\") and 95a762e2c8c9 (\"bpf: fix incorrect sign extension in\ncheck_alu_op()\") in particular where before verifier skipped\nverification of the wrongly assumed dead branch, we should not\njust replace the dead code parts with nops (mov r0,r0). If there\nis a bug such as fixed in 95a762e2c8c9 in future again, where\nruntime could execute those insns, then one of the potential\nissues with the current setting would be that given the nops\nwould be at the end of the program, we could execute out of\nbounds at some point.\n\nThe best in such case would be to just exit the BPF program\naltogether and return an exception code. However, given this\nwould require two instructions, and such a dead code gap could\njust be a single insn long, we would need to place 'r0 = X; ret'\nsnippet at the very end after the user program or at the start\nbefore the program (where we'd skip that region on prog entry),\nand then place unconditional ja's into the dead code gap.\n\nWhile more complex but possible, there's still another block\nin the road that currently prevents from this, namely BPF to\nBPF calls. The issue here is that such exception could be\nreturned from a callee, but the caller would not know that\nit's an exception that needs to be propagated further down.\nAlternative that has little complexity is to just use a ja-1\ncode for now which will trap the execution here instead of\nsilently doing bad things if we ever get there due to bugs.\n\nSigned-off-by: Daniel Borkmann <daniel@iogearbox.net>\nAcked-by: Alexei Starovoitov <ast@kernel.org>\nSigned-off-by: Alexei Starovoitov <ast@kernel.org>",
        "before_after_code_files": [
          "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ],
          "candidate": [
            "kernel/bpf/verifier.c||kernel/bpf/verifier.c"
          ]
        }
      },
      "candidate_diff": {
        "kernel/bpf/verifier.c||kernel/bpf/verifier.c": [
          "File: kernel/bpf/verifier.c -> kernel/bpf/verifier.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5064:  return new_prog;",
          "5065: }",
          "5071: static void sanitize_dead_code(struct bpf_verifier_env *env)",
          "5072: {",
          "5073:  struct bpf_insn_aux_data *aux_data = env->insn_aux_data;",
          "5075:  struct bpf_insn *insn = env->prog->insnsi;",
          "5076:  const int insn_cnt = env->prog->len;",
          "5077:  int i;",
          "",
          "[Removed Lines]",
          "5074:  struct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);",
          "",
          "[Added Lines]",
          "5081:  struct bpf_insn trap = BPF_JMP_IMM(BPF_JA, 0, 0, -1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5079:  for (i = 0; i < insn_cnt; i++) {",
          "5080:   if (aux_data[i].seen)",
          "5081:    continue;",
          "5083:  }",
          "5084: }",
          "",
          "[Removed Lines]",
          "5082:   memcpy(insn + i, &nop, sizeof(nop));",
          "",
          "[Added Lines]",
          "5089:   memcpy(insn + i, &trap, sizeof(trap));",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19880",
  "cve_desc": "exprListAppendList in window.c in SQLite 3.30.1 allows attackers to trigger an invalid pointer dereference because constant integer values in ORDER BY clauses of window definitions are mishandled.",
  "repo": "sqlite/sqlite",
  "patch_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
  "patch_info": {
    "commit_hash": "75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/75e95e1fcd52d3ec8282edb75ac8cd0814095d54",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/window.c"
    ],
    "message": "When processing constant integer values in ORDER BY clauses of window definitions (see check-in [7e4809eadfe99ebf]) be sure to fully disable the constant value to avoid an invalid pointer dereference if the expression is ever duplicated. This fixes a crash report from Yongheng and Rui.\n\nFossilOrigin-Name: 1ca0bd982ab1183bbafce0d260e4dceda5eb766ed2e7793374a88d1ae0bdd2ca",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/window.c||src/window.c"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 8223e79f987feda5c8e51ec52cec6798cca16d070b10558939e2888ca1a25b8e",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/window.c||src/window.c": [
      "File: src/window.c -> src/window.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "895:     int nInit = pList ? pList->nExpr : 0;",
      "896:     for(i=0; i<pAppend->nExpr; i++){",
      "897:       Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);",
      "898:       if( bIntToNull && pDup && pDup->op==TK_INTEGER ){",
      "899:         pDup->op = TK_NULL;",
      "900:         pDup->flags &= ~(EP_IntValue|EP_IsTrue|EP_IsFalse);",
      "901:       }",
      "902:       pList = sqlite3ExprListAppend(pParse, pList, pDup);",
      "903:       if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "898:       assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );",
      "902:         pDup->u.zToken = 0;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f4f86f3fcaa6110aaf64cd2f5b9f878dac17974c",
      "candidate_info": {
        "commit_hash": "f4f86f3fcaa6110aaf64cd2f5b9f878dac17974c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/f4f86f3fcaa6110aaf64cd2f5b9f878dac17974c",
        "files": [
          "ext/rbu/rbu_common.tcl",
          "ext/rbu/rbupartial.test",
          "ext/rbu/rbuvacuum4.test",
          "ext/rbu/sqlite3rbu.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Optimize the restarting of an RBU vacuum.\n\nFossilOrigin-Name: 82062351a62f4ccc438a2b47a22ee581bd030dec952fecd610f360a25002a5ea",
        "before_after_code_files": [
          "ext/rbu/rbu_common.tcl||ext/rbu/rbu_common.tcl",
          "ext/rbu/rbupartial.test||ext/rbu/rbupartial.test",
          "ext/rbu/rbuvacuum4.test||ext/rbu/rbuvacuum4.test",
          "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/rbu/rbu_common.tcl||ext/rbu/rbu_common.tcl": [
          "File: ext/rbu/rbu_common.tcl -> ext/rbu/rbu_common.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "89: proc do_rbu_vacuum_test {tn step {statedb state.db}} {",
          "90:   forcedelete $statedb",
          "91:   if {$statedb==\"\" && $step==1} breakpoint",
          "94:     while 1 {",
          "96:       set state [rbu state]",
          "97:       check_prestep_state test.db $state",
          "98:       set rc [rbu step]",
          "99:       check_poststep_state $rc test.db $state",
          "100:       if {$rc!=\"SQLITE_OK\"} break",
          "102:     }",
          "103:     rbu close",
          "104:   }] {SQLITE_DONE}]",
          "",
          "[Removed Lines]",
          "92:   uplevel [list do_test $tn.1 [string map [list %state% $statedb] {",
          "93:     if {$step==0} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "95:       if {$step==1} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "101:       if {$step==1} { rbu close }",
          "",
          "[Added Lines]",
          "92:   uplevel [list do_test $tn.1 [string map [list %state% $statedb %step% $step] {",
          "93:     if {%step%==0} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "95:       if {%step%==1} { sqlite3rbu_vacuum rbu test.db {%state%}}",
          "101:       if {%step%==1} { rbu close }",
          "",
          "---------------"
        ],
        "ext/rbu/rbupartial.test||ext/rbu/rbupartial.test": [
          "File: ext/rbu/rbupartial.test -> ext/rbu/rbupartial.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "81:   set step 0",
          "82:   do_rbu_vacuum_test $tn.1.5 0",
          "83:   }]",
          "84: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "84:   do_test $tn.1.6 {",
          "85:     execsql { PRAGMA integrity_check }",
          "86:   } {ok}",
          "",
          "---------------"
        ],
        "ext/rbu/rbuvacuum4.test||ext/rbu/rbuvacuum4.test": [
          "File: ext/rbu/rbuvacuum4.test -> ext/rbu/rbuvacuum4.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # 2019 Jan 3",
          "2: #",
          "3: # The author disclaims copyright to this source code.  In place of",
          "4: # a legal notice, here is a blessing:",
          "5: #",
          "6: #    May you do good and not evil.",
          "7: #    May you find forgiveness for yourself and forgive others.",
          "8: #    May you share freely, never taking more than you give.",
          "9: #",
          "10: #***********************************************************************",
          "11: #",
          "12: # This file contains tests for the RBU module. More specifically, it",
          "13: # contains tests to ensure that the sqlite3rbu_vacuum() API works as",
          "14: # expected.",
          "15: #",
          "17: source [file join [file dirname [info script]] rbu_common.tcl]",
          "18: set testprefix rbuvacuum4",
          "20: set step 1",
          "22: do_execsql_test 1.0 {",
          "23:   CREATE TABLE t1(a PRIMARY KEY, b, c) WITHOUT ROWID;",
          "24:   INSERT INTO t1 VALUES(1, 2, 3);",
          "25:   INSERT INTO t1 VALUES(4, 5, 6);",
          "26:   INSERT INTO t1 VALUES(7, 8, 9);",
          "27: }",
          "28: do_rbu_vacuum_test 1.1 1",
          "30: #-------------------------------------------------------------------------",
          "31: reset_db",
          "33: do_execsql_test 2.0 {",
          "34:   CREATE TABLE t1(a, b, c, PRIMARY KEY(a, b, c)) WITHOUT ROWID;",
          "35:   INSERT INTO t1 VALUES(1, 2, 3);",
          "36:   INSERT INTO t1 VALUES(4, 5, 6);",
          "37:   INSERT INTO t1 VALUES(7, 8, 9);",
          "38: }",
          "39: do_rbu_vacuum_test 2.1 1",
          "40: do_execsql_test 2.2 {",
          "41:   SELECT * FROM t1;",
          "42: } {1 2 3 4 5 6 7 8 9}",
          "44: #-------------------------------------------------------------------------",
          "45: reset_db",
          "47: do_execsql_test 3.0 {",
          "48:   CREATE TABLE t1(a INTEGER PRIMARY KEY, b, c);",
          "49:   CREATE INDEX i1 oN t1(b, c);",
          "50:   INSERT INTO t1 VALUES(1, 2, 3);",
          "51:   INSERT INTO t1 VALUES(4, 5, 6);",
          "52:   INSERT INTO t1 VALUES(7, 8, 9);",
          "53: }",
          "55: do_rbu_vacuum_test 3.1 1",
          "57: do_execsql_test 3.2 {",
          "58:   SELECT * FROM t1;",
          "59: } {1 2 3 4 5 6 7 8 9}",
          "61: #-------------------------------------------------------------------------",
          "62: reset_db",
          "63: do_execsql_test 4.0 {",
          "64:   CREATE TABLE x1(a, b, c, d, PRIMARY KEY(c, b)) WITHOUT ROWID;",
          "65:   INSERT INTO x1 VALUES(1, 1, 1, 1);",
          "66:   INSERT INTO x1 VALUES(1, 1, 2, 1);",
          "67:   INSERT INTO x1 VALUES(1, 2, 2, 1);",
          "69:   INSERT INTO x1 VALUES(NULL, 2, 3, NULL);",
          "70:   INSERT INTO x1 VALUES(NULL, 2, 4, NULL);",
          "71:   INSERT INTO x1 VALUES(NULL, 2, 5, NULL);",
          "73:   CREATE INDEX x1ad ON x1(d, a);",
          "74:   CREATE INDEX x1null ON x1(d, a) WHERE d>15;",
          "75: }",
          "77: do_rbu_vacuum_test 4.1.1 1",
          "79: do_execsql_test 4.2 {",
          "80:   SELECT count(*) fROM x1",
          "81: } 6",
          "83: do_rbu_vacuum_test 4.1.2 0",
          "85: #-------------------------------------------------------------------------",
          "86: reset_db",
          "87: do_execsql_test 5.0 {",
          "88:   CREATE TABLE \"a b c\"(a, \"b b\" PRIMARY KEY, \"c c\");",
          "89:   CREATE INDEX abc1 ON \"a b c\"(a, \"c c\");",
          "91:   INSERT INTO \"a b c\" VALUES(NULL, 'a', NULL);",
          "92:   INSERT INTO \"a b c\" VALUES(NULL, 'b', NULL);",
          "93:   INSERT INTO \"a b c\" VALUES(NULL, 'c', NULL);",
          "95:   INSERT INTO \"a b c\" VALUES(1, 2, 3);",
          "96:   INSERT INTO \"a b c\" VALUES(3, 9, 1);",
          "97:   INSERT INTO \"a b c\" VALUES('aaa', 'bbb', 'ccc');",
          "99:   CREATE TABLE x(a);",
          "100:   INSERT INTO x VALUES('a'), ('b'), ('d');",
          "101:   CREATE UNIQUE INDEX y ON x(a);",
          "102: }",
          "104: do_rbu_vacuum_test 5.1 1",
          "106: finish_test",
          "",
          "---------------"
        ],
        "ext/rbu/sqlite3rbu.c||ext/rbu/sqlite3rbu.c": [
          "File: ext/rbu/sqlite3rbu.c -> ext/rbu/sqlite3rbu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "930:   zIn = (const char*)sqlite3_value_text(argv[0]);",
          "931:   if( zIn ){",
          "932:     if( rbuIsVacuum(p) ){",
          "934:         sqlite3_result_text(pCtx, zIn, -1, SQLITE_STATIC);",
          "935:       }",
          "936:     }else{",
          "",
          "[Removed Lines]",
          "933:       if( argc==1 || 0==sqlite3_value_int(argv[1]) ){",
          "",
          "[Added Lines]",
          "933:       assert( argc==2 );",
          "934:       if( 0==sqlite3_value_int(argv[1]) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1381:         }",
          "1383:         pIter->azTblType[iOrder] = rbuStrndup(zType, &p->rc);",
          "1385:         pIter->abNotNull[iOrder] = (u8)bNotNull || (iPk!=0);",
          "1386:         iOrder++;",
          "1387:       }",
          "",
          "[Removed Lines]",
          "1384:         pIter->abTblPk[iOrder] = (iPk!=0);",
          "",
          "[Added Lines]",
          "1385:         assert( iPk>=0 );",
          "1386:         pIter->abTblPk[iOrder] = (u8)iPk;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1416:   return zList;",
          "1417: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1427: static char *rbuObjIterGetPkList(",
          "1433: ){",
          "1434:   int iPk = 1;",
          "1435:   char *zRet = 0;",
          "1436:   const char *zSep = \"\";",
          "1437:   while( 1 ){",
          "1438:     int i;",
          "1439:     for(i=0; i<pIter->nTblCol; i++){",
          "1440:       if( (int)pIter->abTblPk[i]==iPk ){",
          "1441:         const char *zCol = pIter->azTblCol[i];",
          "1442:         zRet = rbuMPrintf(p, \"%z%s%s\\\"%w\\\"%s\", zRet, zSep, zPre, zCol, zPost);",
          "1443:         zSep = zSeparator;",
          "1444:         break;",
          "1445:       }",
          "1446:     }",
          "1447:     if( i==pIter->nTblCol ) break;",
          "1448:     iPk++;",
          "1449:   }",
          "1450:   return zRet;",
          "1451: }",
          "1472: static char *rbuVacuumTableStart(",
          "1477: ){",
          "1478:   sqlite3_stmt *pMax = 0;",
          "1479:   char *zRet = 0;",
          "1480:   if( bRowid ){",
          "1481:     p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,",
          "1482:         sqlite3_mprintf(",
          "1483:           \"SELECT max(_rowid_) FROM \\\"%s%w\\\"\", zWrite, pIter->zTbl",
          "1484:         )",
          "1485:     );",
          "1486:     if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){",
          "1487:       sqlite3_int64 iMax = sqlite3_column_int64(pMax, 0);",
          "1488:       zRet = rbuMPrintf(p, \" WHERE _rowid_ > %lld \", iMax);",
          "1489:     }",
          "1490:     rbuFinalize(p, pMax);",
          "1491:   }else{",
          "1492:     char *zOrder = rbuObjIterGetPkList(p, pIter, \"\", \", \", \" DESC\");",
          "1493:     char *zSelect = rbuObjIterGetPkList(p, pIter, \"quote(\", \"||','||\", \")\");",
          "1494:     char *zList = rbuObjIterGetPkList(p, pIter, \"\", \", \", \"\");",
          "1496:     if( p->rc==SQLITE_OK ){",
          "1497:       p->rc = prepareFreeAndCollectError(p->dbMain, &pMax, &p->zErrmsg,",
          "1498:           sqlite3_mprintf(",
          "1499:             \"SELECT %s FROM \\\"%s%w\\\" ORDER BY %s LIMIT 1\",",
          "1500:                 zSelect, zWrite, pIter->zTbl, zOrder",
          "1501:           )",
          "1502:       );",
          "1503:       if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pMax) ){",
          "1504:         const char *zVal = (const char*)sqlite3_column_text(pMax, 0);",
          "1505:         zRet = rbuMPrintf(p, \" WHERE (%s) > (%s) \", zList, zVal);",
          "1506:       }",
          "1507:       rbuFinalize(p, pMax);",
          "1508:     }",
          "1510:     sqlite3_free(zOrder);",
          "1511:     sqlite3_free(zSelect);",
          "1512:     sqlite3_free(zList);",
          "1513:   }",
          "1514:   return zRet;",
          "1515: }",
          "1539: char *rbuVacuumIndexStart(",
          "1542: ){",
          "1543:   char *zOrder = 0;",
          "1544:   char *zLhs = 0;",
          "1545:   char *zSelect = 0;",
          "1546:   char *zVector = 0;",
          "1547:   char *zRet = 0;",
          "1548:   int bFailed = 0;",
          "1550:   if( p->rc==SQLITE_OK ){",
          "1551:     const char *zSep = \"\";",
          "1552:     int iCol = 0;",
          "1553:     sqlite3_stmt *pXInfo = 0;",
          "1554:     p->rc = prepareFreeAndCollectError(p->dbMain, &pXInfo, &p->zErrmsg,",
          "1555:         sqlite3_mprintf(\"PRAGMA main.index_xinfo = %Q\", pIter->zIdx)",
          "1556:     );",
          "1557:     while( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pXInfo) ){",
          "1558:       int iCid = sqlite3_column_int(pXInfo, 1);",
          "1559:       const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);",
          "1560:       const char *zCol;",
          "1561:       if( sqlite3_column_int(pXInfo, 3) ){",
          "1562:         bFailed = 1;",
          "1563:         break;",
          "1564:       }",
          "1566:       if( iCid<0 ){",
          "1567:         if( pIter->eType==RBU_PK_IPK ){",
          "1568:           int i;",
          "1569:           for(i=0; pIter->abTblPk[i]==0; i++);",
          "1570:           assert( i<pIter->nTblCol );",
          "1571:           zCol = pIter->azTblCol[i];",
          "1572:         }else{",
          "1573:           zCol = \"_rowid_\";",
          "1574:         }",
          "1575:       }else{",
          "1576:         zCol = pIter->azTblCol[iCid];",
          "1577:       }",
          "1579:       zLhs = rbuMPrintf(p, \"%z%s \\\"%w\\\" COLLATE %Q\",",
          "1580:           zLhs, zSep, zCol, zCollate",
          "1581:       );",
          "1582:       zOrder = rbuMPrintf(p, \"%z%s \\\"rbu_imp_%d%w\\\" COLLATE %Q DESC\",",
          "1583:           zOrder, zSep, iCol, zCol, zCollate",
          "1584:       );",
          "1585:       zSelect = rbuMPrintf(p, \"%z%s quote(\\\"rbu_imp_%d%w\\\")\",",
          "1586:           zSelect, zSep, iCol, zCol",
          "1587:       );",
          "1588:       zSep = \", \";",
          "1589:       iCol++;",
          "1590:     }",
          "1591:     rbuFinalize(p, pXInfo);",
          "1592:   }",
          "1593:   if( bFailed ) goto index_start_out;",
          "1595:   if( p->rc==SQLITE_OK ){",
          "1596:     int iCol;",
          "1597:     sqlite3_stmt *pSel = 0;",
          "1599:     if( p->rc==SQLITE_OK ){",
          "1600:       p->rc = prepareFreeAndCollectError(p->dbMain, &pSel, &p->zErrmsg,",
          "1601:           sqlite3_mprintf(\"SELECT %s FROM \\\"rbu_imp_%w\\\" ORDER BY %s LIMIT 1\",",
          "1602:             zSelect, pIter->zTbl, zOrder",
          "1603:           )",
          "1604:       );",
          "1605:     }",
          "1606:     if( p->rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pSel) ){",
          "1607:       const char *zSep = \"\";",
          "1608:       for(iCol=0; iCol<pIter->nCol; iCol++){",
          "1609:         const char *zQuoted = (const char*)sqlite3_column_text(pSel, iCol);",
          "1610:         if( zQuoted[0]=='N' ){",
          "1611:           bFailed = 1;",
          "1612:           break;",
          "1613:         }",
          "1614:         zVector = rbuMPrintf(p, \"%z%s%s\", zVector, zSep, zQuoted);",
          "1615:         zSep = \", \";",
          "1616:       }",
          "1618:       if( !bFailed ){",
          "1619:         zRet = rbuMPrintf(p, \"(%s) > (%s)\", zLhs, zVector);",
          "1620:       }",
          "1621:     }",
          "1622:     rbuFinalize(p, pSel);",
          "1623:   }",
          "1625:  index_start_out:",
          "1626:   sqlite3_free(zOrder);",
          "1627:   sqlite3_free(zSelect);",
          "1628:   sqlite3_free(zVector);",
          "1629:   sqlite3_free(zLhs);",
          "1630:   return zRet;",
          "1631: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2092:       if( p->rc==SQLITE_OK ){",
          "2093:         char *zSql;",
          "2094:         if( rbuIsVacuum(p) ){",
          "2095:           zSql = sqlite3_mprintf(",
          "2097:               zCollist,",
          "2098:               pIter->zDataTbl,",
          "2100:           );",
          "2101:         }else",
          "2103:         if( pIter->eType==RBU_PK_EXTERNAL || pIter->eType==RBU_PK_NONE ){",
          "",
          "[Removed Lines]",
          "2096:               \"SELECT %s, 0 AS rbu_control FROM '%q' %s ORDER BY %s%s\",",
          "2099:               zPart, zCollist, zLimit",
          "",
          "[Added Lines]",
          "2309:           char *zStart = 0;",
          "2310:           if( nOffset ){",
          "2311:             zStart = rbuVacuumIndexStart(p, pIter);",
          "2312:             if( zStart ){",
          "2313:               sqlite3_free(zLimit);",
          "2314:               zLimit = 0;",
          "2315:             }",
          "2316:           }",
          "2319:               \"SELECT %s, 0 AS rbu_control FROM '%q' %s %s %s ORDER BY %s%s\",",
          "2322:               zPart,",
          "2323:               (zStart ? (zPart ? \"AND\" : \"WHERE\") : \"\"), zStart,",
          "2324:               zCollist, zLimit",
          "2326:           sqlite3_free(zStart);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2120:               zCollist, zLimit",
          "2121:           );",
          "2122:         }",
          "2124:       }",
          "2126:       sqlite3_free(zImposterCols);",
          "",
          "[Removed Lines]",
          "2123:         p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz, zSql);",
          "",
          "[Added Lines]",
          "2349:         if( p->rc==SQLITE_OK ){",
          "2350:           p->rc = prepareFreeAndCollectError(p->dbRbu,&pIter->pSelect,pz,zSql);",
          "2351:         }else{",
          "2352:           sqlite3_free(zSql);",
          "2353:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2221:       if( p->rc==SQLITE_OK ){",
          "2222:         const char *zRbuRowid = \"\";",
          "2223:         if( bRbuRowid ){",
          "2224:           zRbuRowid = rbuIsVacuum(p) ? \",_rowid_ \" : \",rbu_rowid\";",
          "2225:         }",
          "2235:       }",
          "2237:       sqlite3_free(zWhere);",
          "",
          "[Removed Lines]",
          "2226:         p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,",
          "2227:             sqlite3_mprintf(",
          "2228:               \"SELECT %s,%s rbu_control%s FROM '%q'%s\",",
          "2229:               zCollist,",
          "2230:               (rbuIsVacuum(p) ? \"0 AS \" : \"\"),",
          "2231:               zRbuRowid,",
          "2232:               pIter->zDataTbl, zLimit",
          "2233:             )",
          "2234:         );",
          "",
          "[Added Lines]",
          "2453:         char *zStart = 0;",
          "2454:         char *zOrder = 0;",
          "2459:         if( rbuIsVacuum(p) ){",
          "2460:           if( nOffset ){",
          "2461:             zStart = rbuVacuumTableStart(p, pIter, bRbuRowid, zWrite);",
          "2462:             if( zStart ){",
          "2463:               sqlite3_free(zLimit);",
          "2464:               zLimit = 0;",
          "2465:             }",
          "2466:           }",
          "2467:           if( bRbuRowid ){",
          "2468:             zOrder = rbuMPrintf(p, \"_rowid_\");",
          "2469:           }else{",
          "2470:             zOrder = rbuObjIterGetPkList(p, pIter, \"\", \", \", \"\");",
          "2471:           }",
          "2472:         }",
          "2474:         if( p->rc==SQLITE_OK ){",
          "2475:           p->rc = prepareFreeAndCollectError(p->dbRbu, &pIter->pSelect, pz,",
          "2476:               sqlite3_mprintf(",
          "2477:                 \"SELECT %s,%s rbu_control%s FROM '%q'%s %s %s %s\",",
          "2478:                 zCollist,",
          "2479:                 (rbuIsVacuum(p) ? \"0 AS \" : \"\"),",
          "2480:                 zRbuRowid,",
          "2481:                 pIter->zDataTbl, (zStart ? zStart : \"\"),",
          "2482:                 (zOrder ? \"ORDER BY\" : \"\"), zOrder,",
          "2483:                 zLimit",
          "2484:               )",
          "2485:           );",
          "2486:         }",
          "2487:         sqlite3_free(zStart);",
          "2488:         sqlite3_free(zOrder);",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 91f701d39852ef1ddb29d1527d1520867c5efea110333315c55d8b08084384e7",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "bcf1f41a62808f74a318f921aae28b2ff4f03712",
      "candidate_info": {
        "commit_hash": "bcf1f41a62808f74a318f921aae28b2ff4f03712",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/bcf1f41a62808f74a318f921aae28b2ff4f03712",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/fuzzdata8.db"
        ],
        "message": "Add new test cases in test/fuzzdata8.db\n\nFossilOrigin-Name: 97bdc090f30610cc5dd29101452d1647550387f9c6f742e50f1e07c3cf68a147",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 174da3c32c9caebd642c31cb594597ccd5bb2a7fc501b1f49aef0b7b4765bfca",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ddc28c23d5e07c2540b7bcef51be97434be3e531",
      "candidate_info": {
        "commit_hash": "ddc28c23d5e07c2540b7bcef51be97434be3e531",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/ddc28c23d5e07c2540b7bcef51be97434be3e531",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/dbfuzz2.c"
        ],
        "message": "Minor change to dbfuzz2 that allows it to be compiled against older versions of SQLite.\n\nFossilOrigin-Name: 6d39d6a68bf09e0b4f6706218373e74fc03148fd8bdba5031c3de2f750d87cf2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/dbfuzz2.c||test/dbfuzz2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 61fdfc57b9539cb6da5fc24653da2c8fb7c041a7409df911df11b987ed479a3a",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/dbfuzz2.c||test/dbfuzz2.c": [
          "File: test/dbfuzz2.c -> test/dbfuzz2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "183:         SQLITE_DESERIALIZE_RESIZEABLE |",
          "184:         SQLITE_DESERIALIZE_FREEONCLOSE);",
          "185:   x = szMax;",
          "186:   sqlite3_file_control(db, \"main\", SQLITE_FCNTL_SIZE_LIMIT, &x);",
          "187:   if( bVdbeDebug ){",
          "188:     sqlite3_exec(db, \"PRAGMA vdbe_debug=ON\", 0, 0, 0);",
          "189:   }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "186: #ifdef SQLITE_FCNTL_SIZE_LIMIT",
          "188: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1641f11f4c365aa17e2415d1f8018e3b66df0628",
      "candidate_info": {
        "commit_hash": "1641f11f4c365aa17e2415d1f8018e3b66df0628",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/1641f11f4c365aa17e2415d1f8018e3b66df0628",
        "files": [
          "Makefile.in",
          "Makefile.msc",
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "test/dbfuzz001.test"
        ],
        "message": "Fix a problem in sqlite3BtreeDelete() in which deleting an entry from a corrupt database can leave a btree page with zero cells.\n\nFossilOrigin-Name: 682053d1e603c21b8085c39db618a39b23ec8d2c4d822fd19634db0e03038ea2",
        "before_after_code_files": [
          "Makefile.in||Makefile.in",
          "Makefile.msc||Makefile.msc",
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "test/dbfuzz001.test||test/dbfuzz001.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.in||Makefile.in": [
          "File: Makefile.in -> Makefile.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "1190: TESTFIXTURE_FLAGS += -DSQLITE_DEFAULT_PAGE_SIZE=1024",
          "1191: TESTFIXTURE_FLAGS += -DSQLITE_ENABLE_STMTVTAB",
          "1192: TESTFIXTURE_FLAGS += -DSQLITE_ENABLE_DBPAGE_VTAB",
          "1194: TESTFIXTURE_SRC0 = $(TESTSRC2) libsqlite3.la",
          "1195: TESTFIXTURE_SRC1 = sqlite3.c",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1193: TESTFIXTURE_FLAGS += -DSQLITE_ENABLE_DESERIALIZE",
          "",
          "---------------"
        ],
        "Makefile.msc||Makefile.msc": [
          "File: Makefile.msc -> Makefile.msc",
          "--- Hunk 1 ---",
          "[Context before]",
          "2298: TESTFIXTURE_FLAGS = $(TESTFIXTURE_FLAGS) -DSQLITE_ENABLE_STMTVTAB=1",
          "2299: TESTFIXTURE_FLAGS = $(TESTFIXTURE_FLAGS) -DSQLITE_ENABLE_DBPAGE_VTAB=1",
          "2300: TESTFIXTURE_FLAGS = $(TESTFIXTURE_FLAGS) -DSQLITE_ENABLE_JSON1=1",
          "2301: TESTFIXTURE_FLAGS = $(TESTFIXTURE_FLAGS) $(TEST_CCONV_OPTS)",
          "2303: TESTFIXTURE_SRC0 = $(TESTEXT) $(TESTSRC2)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2301: TESTFIXTURE_FLAGS = $(TESTFIXTURE_FLAGS) -DSQLITE_ENABLE_DESERIALIZE=1",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 1f583c53f3b7318c69f6e235934d97ef9493278feeab0837217076d7d071c35b",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c"
        ],
        "test/dbfuzz001.test||test/dbfuzz001.test": [
          "File: test/dbfuzz001.test -> test/dbfuzz001.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "19:   return",
          "20: }",
          "22: do_test dbfuzz001-100 {",
          "23:   sqlite3 db {}",
          "24:   db deserialize [decode_hexdb {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "22: # In the following database file, there is 384 bytes of free space",
          "23: # on page 8 that does not appear on the freeblock list.",
          "24: #",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "167:   db eval {PRAGMA integrity_check}",
          "168: } {/Fragmentation of 384 bytes reported as 0 on page 8/}",
          "170: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "173: # The DELETE query below deletes the very last cell from page 8.",
          "174: # Prior to a certain fix to sqlite3BtreeDelete() and because of the",
          "175: # corruption to the freeblock list on page 8, this would fail to",
          "176: # cause a rebalance operation, which would leave the btree in a weird",
          "177: # state that would lead to segfaults and or assertion faults.",
          "178: #",
          "179: do_execsql_test dbfuzz001-110 {",
          "180:   DELETE FROM t3 WHERE x IS NOT NULL AND +rowid=6;",
          "181: } {}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9877965f56dd0391242dab7617f2d8f06f3b4549",
      "candidate_info": {
        "commit_hash": "9877965f56dd0391242dab7617f2d8f06f3b4549",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/9877965f56dd0391242dab7617f2d8f06f3b4549",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/shell.c.in"
        ],
        "message": "Have \".recover\" handle cases where the sqlite_master table contains malformed SQL statements.\n\nFossilOrigin-Name: e736da9c18fad138c5502d354c3553373cba15358b69e44b257f60def59422e2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/shell.c.in||src/shell.c.in"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 47fa65343e46c7782a173174952c637c5621e16229ece258dc7e7a556683ca0c",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/shell.c.in||src/shell.c.in": [
          "File: src/shell.c.in -> src/shell.c.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "6388:  finished:",
          "6389:   sqlite3_close(dbtmp);",
          "6392:     recoverFreeTable(pTab);",
          "6393:     pTab = 0;",
          "6394:   }",
          "",
          "[Removed Lines]",
          "6391:   if( rc!=SQLITE_OK ){",
          "",
          "[Added Lines]",
          "6391:   if( rc!=SQLITE_OK || (pTab && pTab->zQuoted==0) ){",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6682:   shellPrepare(pState->db, &rc,",
          "6685:       , &pLoop",
          "6686:   );",
          "6687:   if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pLoop) ){",
          "",
          "[Removed Lines]",
          "6683:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map\"",
          "6684:       \"  WHERE root>1 AND root NOT IN (SELECT rootpage FROM recovery.schema)\"",
          "",
          "[Added Lines]",
          "6683:       \"SELECT coalesce(max(maxlen), -2) FROM recovery.map WHERE root>1\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6689:   }",
          "6690:   shellFinalize(&rc, pLoop);",
          "6691:   pLoop = 0;",
          "6694:   shellPrepare(pState->db, &rc,",
          "6695:       \"SELECT pgno FROM recovery.map WHERE root=?\", &pPages",
          "",
          "[Removed Lines]",
          "6692:   pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6717:     pTab = recoverFindTable(pState, &rc, iRoot, bIntkey, nCol, &bNoop);",
          "6718:     if( bNoop || rc ) continue;",
          "6721:     if( 0==sqlite3_stricmp(pTab->zQuoted, \"'sqlite_sequence'\") ){",
          "6722:       raw_printf(pState->out, \"DELETE FROM sqlite_sequence;\\n\");",
          "",
          "[Removed Lines]",
          "6719:     if( pTab==0 ) pTab = pOrphan;",
          "",
          "[Added Lines]",
          "6717:     if( pTab==0 ){",
          "6718:       if( pOrphan==0 ){",
          "6719:         pOrphan = recoverOrphanTable(pState, &rc, zLostAndFound, nOrphan);",
          "6720:       }",
          "6721:       pTab = pOrphan;",
          "6722:       if( pTab==0 ) break;",
          "6723:     }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
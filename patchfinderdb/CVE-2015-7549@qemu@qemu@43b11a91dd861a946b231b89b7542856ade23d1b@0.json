{
  "cve_id": "CVE-2015-7549",
  "cve_desc": "The MSI-X MMIO support in hw/pci/msix.c in QEMU (aka Quick Emulator) allows local guest OS privileged users to cause a denial of service (NULL pointer dereference and QEMU process crash) by leveraging failure to define the .write method.",
  "repo": "qemu/qemu",
  "patch_hash": "43b11a91dd861a946b231b89b7542856ade23d1b",
  "patch_info": {
    "commit_hash": "43b11a91dd861a946b231b89b7542856ade23d1b",
    "repo": "qemu/qemu",
    "commit_url": "https://github.com/qemu/qemu/commit/43b11a91dd861a946b231b89b7542856ade23d1b",
    "files": [
      "hw/pci/msix.c"
    ],
    "message": "msix: implement pba write (but read-only)\n\nqpci_msix_pending() writes on pba region, causing qemu to SEGV:\n\n  Program received signal SIGSEGV, Segmentation fault.\n  [Switching to Thread 0x7ffff7fba8c0 (LWP 25882)]\n  0x0000000000000000 in ?? ()\n  (gdb) bt\n  #0  0x0000000000000000 in  ()\n  #1  0x00005555556556c5 in memory_region_oldmmio_write_accessor (mr=0x5555579f3f80, addr=0, value=0x7fffffffbf68, size=4, shift=0, mask=4294967295, attrs=...) at /home/elmarco/src/qemu/memory.c:434\n  #2  0x00005555556558e1 in access_with_adjusted_size (addr=0, value=0x7fffffffbf68, size=4, access_size_min=1, access_size_max=4, access=0x55555565563e <memory_region_oldmmio_write_accessor>, mr=0x5555579f3f80, attrs=...) at /home/elmarco/src/qemu/memory.c:506\n  #3  0x00005555556581eb in memory_region_dispatch_write (mr=0x5555579f3f80, addr=0, data=0, size=4, attrs=...) at /home/elmarco/src/qemu/memory.c:1176\n  #4  0x000055555560b6f9 in address_space_rw (as=0x555555eff4e0 <address_space_memory>, addr=3759147008, attrs=..., buf=0x7fffffffc1b0 \"\", len=4, is_write=true) at /home/elmarco/src/qemu/exec.c:2439\n  #5  0x000055555560baa2 in cpu_physical_memory_rw (addr=3759147008, buf=0x7fffffffc1b0 \"\", len=4, is_write=1) at /home/elmarco/src/qemu/exec.c:2534\n  #6  0x000055555564c005 in cpu_physical_memory_write (addr=3759147008, buf=0x7fffffffc1b0, len=4) at /home/elmarco/src/qemu/include/exec/cpu-common.h:80\n  #7  0x000055555564cd9c in qtest_process_command (chr=0x55555642b890, words=0x5555578de4b0) at /home/elmarco/src/qemu/qtest.c:378\n  #8  0x000055555564db77 in qtest_process_inbuf (chr=0x55555642b890, inbuf=0x55555641b340) at /home/elmarco/src/qemu/qtest.c:569\n  #9  0x000055555564dc07 in qtest_read (opaque=0x55555642b890, buf=0x7fffffffc2e0 \"writel 0xe0100800 0x0\\n\", size=22) at /home/elmarco/src/qemu/qtest.c:581\n  #10 0x000055555574ce3e in qemu_chr_be_write (s=0x55555642b890, buf=0x7fffffffc2e0 \"writel 0xe0100800 0x0\\n\", len=22) at qemu-char.c:306\n  #11 0x0000555555751263 in tcp_chr_read (chan=0x55555642bcf0, cond=G_IO_IN, opaque=0x55555642b890) at qemu-char.c:2876\n  #12 0x00007ffff64c9a8a in g_main_context_dispatch (context=0x55555641c400) at gmain.c:3122\n\n(without this patch, this can be reproduced with the ivshmem qtest)\n\nImplement an empty mmio write to avoid the crash.\n\nSigned-off-by: Marc-Andr\u00e9 Lureau <marcandre.lureau@redhat.com>\nReviewed-by: Paolo Bonzini <pbonzini@redhat.com>",
    "before_after_code_files": [
      "hw/pci/msix.c||hw/pci/msix.c"
    ]
  },
  "patch_diff": {
    "hw/pci/msix.c||hw/pci/msix.c": [
      "File: hw/pci/msix.c -> hw/pci/msix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "200:     return pci_get_long(dev->msix_pba + addr);",
      "201: }",
      "203: static const MemoryRegionOps msix_pba_mmio_ops = {",
      "204:     .read = msix_pba_mmio_read,",
      "205:     .endianness = DEVICE_LITTLE_ENDIAN,",
      "206:     .valid = {",
      "207:         .min_access_size = 4,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "203: static void msix_pba_mmio_write(void *opaque, hwaddr addr,",
      "204:                                 uint64_t val, unsigned size)",
      "205: {",
      "206: }",
      "210:     .write = msix_pba_mmio_write,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "c900ef86c5e30e1adec0f79350edc3f30ebee285",
      "candidate_info": {
        "commit_hash": "c900ef86c5e30e1adec0f79350edc3f30ebee285",
        "repo": "qemu/qemu",
        "commit_url": "https://github.com/qemu/qemu/commit/c900ef86c5e30e1adec0f79350edc3f30ebee285",
        "files": [
          "scripts/qemu-gdb.py",
          "scripts/qemugdb/aio.py"
        ],
        "message": "gdb command: qemu handlers\n\nA new gdb commands are added:\n\n  qemu handlers\n\n     That dumps an AioContext list (by default qemu_aio_context)\n     possibly including a backtrace for cases it knows about\n     (with the verbose option).  Intended to help find why something\n     is hanging waiting for IO.\n\n  Use 'qemu handlers --verbose iohandler_ctx'  to find out why\nyour incoming migration is stuck.\n\nSigned-off-by: Dr. David Alan Gilbert <dgilbert@redhat.com>\nMessage-id: 1445951385-11924-1-git-send-email-dgilbert@redhat.com\n\nV2:\n  Merge into one command with optional handlers arg, and only do\n    backtrace in verbose mode\n\n (gdb) qemu handlers\n ----\n {pfd = {fd = 6, events = 25, revents = 0}, io_read = 0x55869656ffd0\n <event_notifier_dummy_cb>, io_write = 0x0, deleted = 0, opaque =\n 0x558698c4ce08, node = {le_next = 0x0, le_prev = 0x558698c4cdc0}}\n\n (gdb) qemu handlers iohandler_ctx\n ----\n {pfd = {fd = 9, events = 25, revents = 0}, io_read = 0x558696581380\n <fd_coroutine_enter>, io_write = 0x0, deleted = 0, opaque =\n 0x558698dc99d0, node = {le_next = 0x558698c4cca0, le_prev =\n 0x558698c4c1d0}}\n ----\n {pfd = {fd = 4, events = 25, revents = 0}, io_read = 0x55869657b330\n <sigfd_handler>, io_write = 0x0, deleted = 0, opaque = 0x4, node =\n {le_next = 0x558698c4c260, le_prev = 0x558699f72508}}\n ----\n {pfd = {fd = 5, events = 25, revents = 0}, io_read = 0x55869656ffd0\n <event_notifier_dummy_cb>, io_write = 0x0, deleted = 0, opaque =\n 0x558698c4c218, node = {le_next = 0x0, le_prev = 0x558698c4ccc8}}\n ----\n (gdb) qemu handlers --verbose iohandler_ctx\n ----\n {pfd = {fd = 9, events = 25, revents = 0}, io_read = 0x558696581380\n <fd_coroutine_enter>, io_write = 0x0, deleted = 0, opaque =\n 0x558698dc99d0, node = {le_next = 0x558698c4cca0, le_prev =\n 0x558698c4c1d0}}\n #0  0x0000558696581820 in qemu_coroutine_switch\n (from_=from_@entry=0x558698cb3cf0, to_=to_@entry=0x7f421c37eac8,\n action=action@entry=COROUTINE_YIELD) at\n /home/dgilbert/git/qemu/coroutine-ucontext.c:177\n #1  0x0000558696580c00 in qemu_coroutine_yield () at\n /home/dgilbert/git/qemu/qemu-coroutine.c:145\n #2  0x00005586965814f5 in yield_until_fd_readable (fd=9) at\n /home/dgilbert/git/qemu/qemu-coroutine-io.c:90\n #3  0x0000558696523937 in socket_get_buffer (opaque=0x55869a3dc620,\n buf=0x558698c505a0 \"\", pos=<optimized out>, size=32768) at\n /home/dgilbert/git/qemu/migration/qemu-file-unix.c:101\n #4  0x0000558696521fac in qemu_fill_buffer (f=0x558698c50570) at\n /home/dgilbert/git/qemu/migration/qemu-file.c:227\n #5  0x0000558696522989 in qemu_peek_byte (f=0x558698c50570, offset=0)\n     at /home/dgilbert/git/qemu/migration/qemu-file.c:507\n #6  0x0000558696522bf4 in qemu_get_be32 (f=0x558698c50570) at\n /home/dgilbert/git/qemu/migration/qemu-file.c:520\n #7  0x0000558696522bf4 in qemu_get_be32 (f=f@entry=0x558698c50570)\n     at /home/dgilbert/git/qemu/migration/qemu-file.c:604\n #8  0x0000558696347e5c in qemu_loadvm_state (f=f@entry=0x558698c50570)\n     at /home/dgilbert/git/qemu/migration/savevm.c:1821\n #9  0x000055869651de8c in process_incoming_migration_co\n (opaque=0x558698c50570)\n     at /home/dgilbert/git/qemu/migration/migration.c:336\n #10 0x000055869658188a in coroutine_trampoline (i0=<optimized out>,\n i1=<optimized out>)\n     at /home/dgilbert/git/qemu/coroutine-ucontext.c:80\n #11 0x00007f420f05df10 in __start_context () at /lib64/libc.so.6\n #12 0x00007ffc40815f50 in  ()\n #13 0x0000000000000000 in  ()\n\n  ----\nSigned-off-by: Stefan Hajnoczi <stefanha@redhat.com>",
        "before_after_code_files": [
          "scripts/qemu-gdb.py||scripts/qemu-gdb.py",
          "scripts/qemugdb/aio.py||scripts/qemugdb/aio.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "scripts/qemu-gdb.py||scripts/qemu-gdb.py": [
          "File: scripts/qemu-gdb.py -> scripts/qemu-gdb.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: sys.path.append(os.path.dirname(__file__))",
          "31: class QemuCommand(gdb.Command):",
          "32:     '''Prefix for QEMU debug support commands'''",
          "",
          "[Removed Lines]",
          "29: from qemugdb import mtree, coroutine",
          "",
          "[Added Lines]",
          "29: from qemugdb import aio, mtree, coroutine",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "37: QemuCommand()",
          "38: coroutine.CoroutineCommand()",
          "39: mtree.MtreeCommand()",
          "41: coroutine.CoroutineSPFunction()",
          "42: coroutine.CoroutinePCFunction()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: aio.HandlersCommand()",
          "",
          "---------------"
        ],
        "scripts/qemugdb/aio.py||scripts/qemugdb/aio.py": [
          "File: scripts/qemugdb/aio.py -> scripts/qemugdb/aio.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: #!/usr/bin/python",
          "3: # GDB debugging support: aio/iohandler debug",
          "4: #",
          "5: # Copyright (c) 2015 Red Hat, Inc.",
          "6: #",
          "7: # Author: Dr. David Alan Gilbert <dgilbert@redhat.com>",
          "8: #",
          "9: # This work is licensed under the terms of the GNU GPL, version 2 or",
          "10: # later.  See the COPYING file in the top-level directory.",
          "11: #",
          "13: import gdb",
          "14: from qemugdb import coroutine",
          "16: def isnull(ptr):",
          "17:     return ptr == gdb.Value(0).cast(ptr.type)",
          "19: def dump_aiocontext(context, verbose):",
          "20:     '''Display a dump and backtrace for an aiocontext'''",
          "21:     cur = context['aio_handlers']['lh_first']",
          "22:     # Get pointers to functions we're going to process specially",
          "23:     sym_fd_coroutine_enter = gdb.parse_and_eval('fd_coroutine_enter')",
          "25:     while not isnull(cur):",
          "26:         entry = cur.dereference()",
          "27:         gdb.write('----\\n%s\\n' % entry)",
          "28:         if verbose and cur['io_read'] == sym_fd_coroutine_enter:",
          "29:             coptr = (cur['opaque'].cast(gdb.lookup_type('FDYieldUntilData').pointer()))['co']",
          "30:             coptr = coptr.cast(gdb.lookup_type('CoroutineUContext').pointer())",
          "31:             coroutine.bt_jmpbuf(coptr['env']['__jmpbuf'])",
          "32:         cur = cur['node']['le_next'];",
          "34:     gdb.write('----\\n')",
          "36: class HandlersCommand(gdb.Command):",
          "37:     '''Display aio handlers'''",
          "38:     def __init__(self):",
          "39:         gdb.Command.__init__(self, 'qemu handlers', gdb.COMMAND_DATA,",
          "40:                              gdb.COMPLETE_NONE)",
          "42:     def invoke(self, arg, from_tty):",
          "43:         verbose = False",
          "44:         argv = gdb.string_to_argv(arg)",
          "46:         if len(argv) > 0 and argv[0] == '--verbose':",
          "47:             verbose = True",
          "48:             argv.pop(0)",
          "50:         if len(argv) > 1:",
          "51:             gdb.write('usage: qemu handlers [--verbose] [handler]\\n')",
          "52:             return",
          "54:         if len(argv) == 1:",
          "55:             handlers_name = argv[0]",
          "56:         else:",
          "57:             handlers_name = 'qemu_aio_context'",
          "58:         dump_aiocontext(gdb.parse_and_eval(handlers_name), verbose)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
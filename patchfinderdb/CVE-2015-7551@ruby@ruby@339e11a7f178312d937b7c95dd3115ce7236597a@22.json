{
  "cve_id": "CVE-2015-7551",
  "cve_desc": "The Fiddle::Handle implementation in ext/fiddle/handle.c in Ruby before 2.0.0-p648, 2.1 before 2.1.8, and 2.2 before 2.2.4, as distributed in Apple OS X before 10.11.4 and other products, mishandles tainting, which allows context-dependent attackers to execute arbitrary code or cause a denial of service (application crash) via a crafted string, related to the DL module and the libffi library.  NOTE: this vulnerability exists because of a CVE-2009-5147 regression.",
  "repo": "ruby/ruby",
  "patch_hash": "339e11a7f178312d937b7c95dd3115ce7236597a",
  "patch_info": {
    "commit_hash": "339e11a7f178312d937b7c95dd3115ce7236597a",
    "repo": "ruby/ruby",
    "commit_url": "https://github.com/ruby/ruby/commit/339e11a7f178312d937b7c95dd3115ce7236597a",
    "files": [
      "ChangeLog",
      "ext/fiddle/handle.c",
      "test/fiddle/test_handle.rb",
      "version.h"
    ],
    "message": "merge revision(s): 53153 and 23405@ruby_1_9_1\n\n\t* ext/fiddle/handle.c: check tainted string arguments.\n\t  Patch provided by tenderlove and nobu.\n\n\t* test/fiddle/test_handle.rb (class TestHandle): add test for above.\n\n\t* ext/dl/handle.c (rb_dlhandle_initialize): prohibits DL::dlopen\n\t  with a tainted name of library.\n\t  Patch by sheepman <sheepman AT sheepman.sakura.ne.jp>.\n\n\t* ext/dl/handle.c (rb_dlhandle_sym): ditto\n\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@53156 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
    "before_after_code_files": [
      "ext/fiddle/handle.c||ext/fiddle/handle.c",
      "test/fiddle/test_handle.rb||test/fiddle/test_handle.rb",
      "version.h||version.h"
    ]
  },
  "patch_diff": {
    "ext/fiddle/handle.c||ext/fiddle/handle.c": [
      "File: ext/fiddle/handle.c -> ext/fiddle/handle.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: #include <ruby.h>",
      "2: #include <fiddle.h>",
      "4: VALUE rb_cHandle;",
      "6: struct dl_handle {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "4: #define SafeStringValueCStr(v) (rb_check_safe_obj(rb_string_value(&v)), StringValueCStr(v))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "143:  cflag = RTLD_LAZY | RTLD_GLOBAL;",
      "144:  break;",
      "145:       case 1:",
      "147:  cflag = RTLD_LAZY | RTLD_GLOBAL;",
      "148:  break;",
      "149:       case 2:",
      "151:  cflag = NUM2INT(flag);",
      "152:  break;",
      "153:       default:",
      "",
      "[Removed Lines]",
      "146:  clib = NIL_P(lib) ? NULL : StringValuePtr(lib);",
      "150:  clib = NIL_P(lib) ? NULL : StringValuePtr(lib);",
      "",
      "[Added Lines]",
      "148:  clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);",
      "152:  clib = NIL_P(lib) ? NULL : SafeStringValueCStr(lib);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "263:     return PTR2NUM(fiddle_handle);",
      "264: }",
      "",
      "[Removed Lines]",
      "266: static VALUE fiddle_handle_sym(void *handle, const char *symbol);",
      "",
      "[Added Lines]",
      "268: static VALUE fiddle_handle_sym(void *handle, VALUE symbol);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "282:  rb_raise(rb_eFiddleError, \"closed handle\");",
      "283:     }",
      "286: }",
      "288: #ifndef RTLD_NEXT",
      "",
      "[Removed Lines]",
      "285:     return fiddle_handle_sym(fiddle_handle->ptr, StringValueCStr(sym));",
      "",
      "[Added Lines]",
      "287:     return fiddle_handle_sym(fiddle_handle->ptr, sym);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "305: static VALUE",
      "306: rb_fiddle_handle_s_sym(VALUE self, VALUE sym)",
      "307: {",
      "309: }",
      "311: static VALUE",
      "313: {",
      "314: #if defined(HAVE_DLERROR)",
      "315:     const char *err;",
      "",
      "[Removed Lines]",
      "308:     return fiddle_handle_sym(RTLD_NEXT, StringValueCStr(sym));",
      "312: fiddle_handle_sym(void *handle, const char *name)",
      "",
      "[Added Lines]",
      "310:     return fiddle_handle_sym(RTLD_NEXT, sym);",
      "314: fiddle_handle_sym(void *handle, VALUE symbol)",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "318: # define CHECK_DLERROR",
      "319: #endif",
      "320:     void (*func)();",
      "322:     rb_secure(2);",
      "323: #ifdef HAVE_DLERROR",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "323:     const char *name = SafeStringValueCStr(symbol);",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "367:     }",
      "368: #endif",
      "369:     if( !func ){",
      "371:     }",
      "373:     return PTR2NUM(func);",
      "",
      "[Removed Lines]",
      "370:  rb_raise(rb_eFiddleError, \"unknown symbol \\\"%s\\\"\", name);",
      "",
      "[Added Lines]",
      "373:  rb_raise(rb_eFiddleError, \"unknown symbol \\\"%\"PRIsVALUE\"\\\"\", symbol);",
      "",
      "---------------"
    ],
    "test/fiddle/test_handle.rb||test/fiddle/test_handle.rb": [
      "File: test/fiddle/test_handle.rb -> test/fiddle/test_handle.rb",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:     include Test::Unit::Assertions",
      "13:     def test_to_i",
      "14:       handle = Fiddle::Handle.new(LIBC_SO)",
      "15:       assert_kind_of Integer, handle.to_i",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13:     def test_safe_handle_open",
      "14:       t = Thread.new do",
      "15:         $SAFE = 1",
      "16:         Fiddle::Handle.new(LIBC_SO.taint)",
      "17:       end",
      "18:       assert_raise(SecurityError) { t.value }",
      "19:     end",
      "21:     def test_safe_function_lookup",
      "22:       t = Thread.new do",
      "23:         h = Fiddle::Handle.new(LIBC_SO)",
      "24:         $SAFE = 1",
      "25:         h[\"qsort\".taint]",
      "26:       end",
      "27:       assert_raise(SecurityError) { t.value }",
      "28:     end",
      "",
      "---------------"
    ],
    "version.h||version.h": [
      "File: version.h -> version.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1: #define RUBY_VERSION \"2.1.8\"",
      "2: #define RUBY_RELEASE_DATE \"2015-12-16\"",
      "5: #define RUBY_RELEASE_YEAR 2015",
      "6: #define RUBY_RELEASE_MONTH 12",
      "",
      "[Removed Lines]",
      "3: #define RUBY_PATCHLEVEL 438",
      "",
      "[Added Lines]",
      "3: #define RUBY_PATCHLEVEL 439",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "32299d987b69d02cdd3ca4a8c33c68233cfad4cd",
      "candidate_info": {
        "commit_hash": "32299d987b69d02cdd3ca4a8c33c68233cfad4cd",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/32299d987b69d02cdd3ca4a8c33c68233cfad4cd",
        "files": [
          "ChangeLog",
          "ext/openssl/ossl_ssl.c",
          "version.h"
        ],
        "message": "merge revision(s) 54097: [Backport #12069]\n\n\t* ext/openssl/ossl_ssl.c (ossl_sslctx_setup): document as MT-unsafe\n\t  [ruby-core:73803] [Bug #12069]\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@54282 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "ext/openssl/ossl_ssl.c||ext/openssl/ossl_ssl.c",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "ext/openssl/ossl_ssl.c||ext/openssl/ossl_ssl.c": [
          "File: ext/openssl/ossl_ssl.c -> ext/openssl/ossl_ssl.c"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.9\"",
          "2: #define RUBY_RELEASE_DATE \"2016-03-25\"",
          "5: #define RUBY_RELEASE_YEAR 2016",
          "6: #define RUBY_RELEASE_MONTH 3",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 479",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 480",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c4b21f736ebb339fc46760f800851a7eed444c47",
      "candidate_info": {
        "commit_hash": "c4b21f736ebb339fc46760f800851a7eed444c47",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/c4b21f736ebb339fc46760f800851a7eed444c47",
        "files": [
          "ChangeLog",
          "class.c",
          "method.h",
          "test/ruby/test_refinement.rb",
          "version.h",
          "vm_method.c"
        ],
        "message": "merge revision(s) r49222,r49480,r49493: [Backport #10765]\n\n\tmethod.h: UNDEFINED_REFINED_METHOD_P\n\n\t* method.h (UNDEFINED_REFINED_METHOD_P): macro to tell if refined\n  original method is defined.\n\t* vm_method.c (remove_method): When remove refined\n\t  method, raise a NameError if the method is not\n\t  defined in refined class.\n\t\n\t  But if the method is defined in refined class,\n\t  it should keep refined method and remove original\n\t  method.\n\t  \n\t  Patch by Seiei Higa. [ruby-core:67722] [Bug #10765]\n\n\t* class.c (method_entry_i, class_instance_method_list,\n\t  rb_obj_singleton_methods): should not include methods of\n\t  superclasses if recur is false. [ruby-dev:48854] [Bug #10826]\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@49992 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "class.c||class.c",
          "method.h||method.h",
          "test/ruby/test_refinement.rb||test/ruby/test_refinement.rb",
          "version.h||version.h",
          "vm_method.c||vm_method.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "class.c||class.c": [
          "File: class.c -> class.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1116:     return ins_methods_push((ID)name, (long)type, (VALUE)ary, NOEX_PUBLIC);",
          "1117: }",
          "1119: static int",
          "1120: method_entry_i(st_data_t key, st_data_t value, st_data_t data)",
          "1121: {",
          "1122:     const rb_method_entry_t *me = (const rb_method_entry_t *)value;",
          "1124:     long type;",
          "1126:     if (me && me->def->type == VM_METHOD_TYPE_REFINED) {",
          "1127:  me = rb_resolve_refined_method(Qnil, me, NULL);",
          "1128:  if (!me) return ST_CONTINUE;",
          "1129:     }",
          "1131:  if (UNDEFINED_METHOD_ENTRY_P(me)) {",
          "1133:  }",
          "1134:  else {",
          "1135:      type = VISI(me->flag);",
          "1136:  }",
          "1138:     }",
          "1139:     return ST_CONTINUE;",
          "1140: }",
          "",
          "[Removed Lines]",
          "1123:     st_table *list = (st_table *)data;",
          "1130:     if (!st_lookup(list, key, 0)) {",
          "1137:  st_add_direct(list, key, type);",
          "",
          "[Added Lines]",
          "1119: struct method_entry_arg {",
          "1120:     st_table *list;",
          "1121:     int recur;",
          "1122: };",
          "1128:     struct method_entry_arg *arg = (struct method_entry_arg *)data;",
          "1132:  VALUE klass = me->klass;",
          "1135:  if (!arg->recur && me->klass != klass) return ST_CONTINUE;",
          "1137:     if (!st_lookup(arg->list, key, 0)) {",
          "1144:  st_add_direct(arg->list, key, type);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1144: {",
          "1145:     VALUE ary;",
          "1146:     int recur, prepended = 0;",
          "1149:     if (argc == 0) {",
          "1150:  recur = TRUE;",
          "",
          "[Removed Lines]",
          "1147:     st_table *list;",
          "",
          "[Added Lines]",
          "1154:     struct method_entry_arg me_arg;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1160:  prepended = 1;",
          "1161:     }",
          "1164:     for (; mod; mod = RCLASS_SUPER(mod)) {",
          "1166:  if (BUILTIN_TYPE(mod) == T_ICLASS && !prepended) continue;",
          "1167:  if (obj && FL_TEST(mod, FL_SINGLETON)) continue;",
          "1168:  if (!recur) break;",
          "1169:     }",
          "1170:     ary = rb_ary_new();",
          "1174:     return ary;",
          "1175: }",
          "",
          "[Removed Lines]",
          "1163:     list = st_init_numtable();",
          "1165:  if (RCLASS_M_TBL(mod)) st_foreach(RCLASS_M_TBL(mod), method_entry_i, (st_data_t)list);",
          "1171:     st_foreach(list, func, ary);",
          "1172:     st_free_table(list);",
          "",
          "[Added Lines]",
          "1170:     me_arg.list = st_init_numtable();",
          "1171:     me_arg.recur = recur;",
          "1173:  if (RCLASS_M_TBL(mod)) st_foreach(RCLASS_M_TBL(mod), method_entry_i, (st_data_t)&me_arg);",
          "1179:     st_foreach(me_arg.list, func, ary);",
          "1180:     st_free_table(me_arg.list);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1391: rb_obj_singleton_methods(int argc, VALUE *argv, VALUE obj)",
          "1392: {",
          "1393:     VALUE recur, ary, klass, origin;",
          "1396:     if (argc == 0) {",
          "1397:  recur = Qtrue;",
          "",
          "[Removed Lines]",
          "1394:     st_table *list, *mtbl;",
          "",
          "[Added Lines]",
          "1402:     struct method_entry_arg me_arg;",
          "1403:     st_table *mtbl;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1401:     }",
          "1402:     klass = CLASS_OF(obj);",
          "1403:     origin = RCLASS_ORIGIN(klass);",
          "1405:     if (klass && FL_TEST(klass, FL_SINGLETON)) {",
          "1406:  if ((mtbl = RCLASS_M_TBL(origin)) != 0)",
          "1408:  klass = RCLASS_SUPER(klass);",
          "1409:     }",
          "1410:     if (RTEST(recur)) {",
          "1411:  while (klass && (FL_TEST(klass, FL_SINGLETON) || RB_TYPE_P(klass, T_ICLASS))) {",
          "1412:      if (klass != origin && (mtbl = RCLASS_M_TBL(klass)) != 0)",
          "1414:      klass = RCLASS_SUPER(klass);",
          "1415:  }",
          "1416:     }",
          "1417:     ary = rb_ary_new();",
          "1421:     return ary;",
          "1422: }",
          "",
          "[Removed Lines]",
          "1404:     list = st_init_numtable();",
          "1407:      st_foreach(mtbl, method_entry_i, (st_data_t)list);",
          "1413:   st_foreach(mtbl, method_entry_i, (st_data_t)list);",
          "1418:     st_foreach(list, ins_methods_i, ary);",
          "1419:     st_free_table(list);",
          "",
          "[Added Lines]",
          "1413:     me_arg.list = st_init_numtable();",
          "1414:     me_arg.recur = recur;",
          "1417:      st_foreach(mtbl, method_entry_i, (st_data_t)&me_arg);",
          "1423:   st_foreach(mtbl, method_entry_i, (st_data_t)&me_arg);",
          "1428:     st_foreach(me_arg.list, ins_methods_i, ary);",
          "1429:     st_free_table(me_arg.list);",
          "",
          "---------------"
        ],
        "method.h||method.h": [
          "File: method.h -> method.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "108: };",
          "110: #define UNDEFINED_METHOD_ENTRY_P(me) (!(me) || !(me)->def || (me)->def->type == VM_METHOD_TYPE_UNDEF)",
          "112: void rb_add_method_cfunc(VALUE klass, ID mid, VALUE (*func)(ANYARGS), int argc, rb_method_flag_t noex);",
          "113: rb_method_entry_t *rb_add_method(VALUE klass, ID mid, rb_method_type_t type, void *option, rb_method_flag_t noex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "111: #define UNDEFINED_REFINED_METHOD_P(def) \\",
          "112:     ((def)->type == VM_METHOD_TYPE_REFINED && \\",
          "113:      UNDEFINED_METHOD_ENTRY_P((def)->body.orig_me))",
          "",
          "---------------"
        ],
        "test/ruby/test_refinement.rb||test/ruby/test_refinement.rb": [
          "File: test/ruby/test_refinement.rb -> test/ruby/test_refinement.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "1281:     end;",
          "1282:   end",
          "1284:   private",
          "1286:   def eval_using(mod, s)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1284:   def test_remove_refined_method",
          "1285:     assert_separately([], <<-\"end;\")",
          "1286:     bug10765 = '[ruby-core:67722] [Bug #10765]'",
          "1288:     class C",
          "1289:       def foo",
          "1290:         \"C#foo\"",
          "1291:       end",
          "1292:     end",
          "1294:     module RefinementBug",
          "1295:       refine C do",
          "1296:         def foo",
          "1297:           \"RefinementBug#foo\"",
          "1298:         end",
          "1299:       end",
          "1300:     end",
          "1302:     using RefinementBug",
          "1304:     class C",
          "1305:       remove_method :foo",
          "1306:     end",
          "1308:     assert_equal(\"RefinementBug#foo\", C.new.foo, bug10765)",
          "1309:     end;",
          "1310:   end",
          "1312:   def test_remove_undefined_refined_method",
          "1313:     assert_separately([], <<-\"end;\")",
          "1314:     bug10765 = '[ruby-core:67722] [Bug #10765]'",
          "1316:     class C",
          "1317:     end",
          "1319:     module RefinementBug",
          "1320:       refine C do",
          "1321:         def foo",
          "1322:         end",
          "1323:       end",
          "1324:     end",
          "1326:     using RefinementBug",
          "1328:     assert_raise(NameError, bug10765) {",
          "1329:       class C",
          "1330:         remove_method :foo",
          "1331:       end",
          "1332:     }",
          "1333:     end;",
          "1334:   end",
          "1336:   module NotIncludeSuperclassMethod",
          "1337:     class X",
          "1338:       def foo",
          "1339:       end",
          "1340:     end",
          "1342:     class Y < X",
          "1343:     end",
          "1345:     module Bar",
          "1346:       refine Y do",
          "1347:         def foo",
          "1348:         end",
          "1349:       end",
          "1350:     end",
          "1351:   end",
          "1353:   def test_instance_methods_not_include_superclass_method",
          "1354:     bug10826 = '[ruby-dev:48854] [Bug #10826]'",
          "1355:     assert_not_include(NotIncludeSuperclassMethod::Y.instance_methods(false),",
          "1356:                        :foo, bug10826)",
          "1357:     assert_include(NotIncludeSuperclassMethod::Y.instance_methods(true),",
          "1358:                    :foo, bug10826)",
          "1359:   end",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.5\"",
          "2: #define RUBY_RELEASE_DATE \"2015-03-18\"",
          "5: #define RUBY_RELEASE_YEAR 2015",
          "6: #define RUBY_RELEASE_MONTH 3",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 313",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 314",
          "",
          "---------------"
        ],
        "vm_method.c||vm_method.c": [
          "File: vm_method.c -> vm_method.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "733:     if (!st_lookup(RCLASS_M_TBL(klass), mid, &data) ||",
          "734:  !(me = (rb_method_entry_t *)data) ||",
          "736:  rb_name_error(mid, \"method `%s' not defined in %s\",",
          "737:         rb_id2name(mid), rb_class2name(klass));",
          "738:     }",
          "739:     key = (st_data_t)mid;",
          "740:     st_delete(RCLASS_M_TBL(klass), &key, &data);",
          "",
          "[Removed Lines]",
          "735:  (!me->def || me->def->type == VM_METHOD_TYPE_UNDEF)) {",
          "",
          "[Added Lines]",
          "735:  (!me->def || me->def->type == VM_METHOD_TYPE_UNDEF) ||",
          "736:         UNDEFINED_REFINED_METHOD_P(me->def)) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "743:     rb_clear_method_cache_by_class(klass);",
          "744:     rb_unlink_method_entry(me);",
          "746:     CALL_METHOD_HOOK(self, removed, mid);",
          "747: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "748:     if (me->def->type == VM_METHOD_TYPE_REFINED) {",
          "749:  rb_add_refined_method_entry(klass, mid);",
          "750:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "812:     }",
          "814:     if (UNDEFINED_METHOD_ENTRY_P(me) ||",
          "817:  rb_print_undef(klass, name, 0);",
          "818:     }",
          "",
          "[Removed Lines]",
          "815:  (me->def->type == VM_METHOD_TYPE_REFINED &&",
          "816:   UNDEFINED_METHOD_ENTRY_P(me->def->body.orig_me))) {",
          "",
          "[Added Lines]",
          "821:  UNDEFINED_REFINED_METHOD_P(me->def)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "912:     me = search_method(klass, id, 0);",
          "914:     if (UNDEFINED_METHOD_ENTRY_P(me) ||",
          "917:  const char *s0 = \" class\";",
          "918:  VALUE c = klass;",
          "",
          "[Removed Lines]",
          "915:  (me->def->type == VM_METHOD_TYPE_REFINED &&",
          "916:   UNDEFINED_METHOD_ENTRY_P(me->def->body.orig_me))) {",
          "",
          "[Added Lines]",
          "920:  UNDEFINED_REFINED_METHOD_P(me->def)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1260:     orig_me = search_method(klass, def, &defined_class);",
          "1262:     if (UNDEFINED_METHOD_ENTRY_P(orig_me) ||",
          "1265:  if ((!RB_TYPE_P(klass, T_MODULE)) ||",
          "1266:      (orig_me = search_method(rb_cObject, def, 0),",
          "1267:       UNDEFINED_METHOD_ENTRY_P(orig_me))) {",
          "",
          "[Removed Lines]",
          "1263:  (orig_me->def->type == VM_METHOD_TYPE_REFINED &&",
          "1264:   UNDEFINED_METHOD_ENTRY_P(orig_me->def->body.orig_me))) {",
          "",
          "[Added Lines]",
          "1267:  UNDEFINED_REFINED_METHOD_P(orig_me->def)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1237e7a50b1b24e069caff5e7fd53628a9444d12",
      "candidate_info": {
        "commit_hash": "1237e7a50b1b24e069caff5e7fd53628a9444d12",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/1237e7a50b1b24e069caff5e7fd53628a9444d12",
        "files": [
          "ChangeLog",
          "transcode.c",
          "version.h"
        ],
        "message": "merge revision(s) 51488,51489: [Backport #11416]\n\n\t* transcode.c (rb_econv_open0): rb_econv_t::source_encoding_name\n\t  and rb_econv_t::destination_encoding_name should refer static\n\t  strings always or NULL.  [ruby-core:70247] [Bug #11416]\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@52798 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "transcode.c||transcode.c",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "transcode.c||transcode.c": [
          "File: transcode.c -> transcode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "995:     if (*sname == '\\0' && *dname == '\\0') {",
          "996:         num_trans = 0;",
          "997:         entries = NULL;",
          "998:     }",
          "999:     else {",
          "1000:         struct trans_open_t toarg;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "998:  sname = dname = \"\";",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3392:     }",
          "3394:     if (!ec) {",
          "3396:     }",
          "3398:     if (!DECORATOR_P(sname, dname)) {",
          "",
          "[Removed Lines]",
          "3395:         rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));",
          "",
          "[Added Lines]",
          "3396:  VALUE exc = rb_econv_open_exc(sname, dname, ecflags);",
          "3397:  RB_GC_GUARD(snamev);",
          "3398:  RB_GC_GUARD(dnamev);",
          "3399:  rb_exc_raise(exc);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3400:             senc = make_dummy_encoding(sname);",
          "3401:         if (!denc)",
          "3402:             denc = make_dummy_encoding(dname);",
          "3403:     }",
          "3405:     ec->source_encoding = senc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3407:  RB_GC_GUARD(snamev);",
          "3408:  RB_GC_GUARD(dnamev);",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.8\"",
          "2: #define RUBY_RELEASE_DATE \"2015-11-30\"",
          "5: #define RUBY_RELEASE_YEAR 2015",
          "6: #define RUBY_RELEASE_MONTH 11",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 423",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 424",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "39301197fa26de773d2b489e6a0fffc7dba55c1e",
      "candidate_info": {
        "commit_hash": "39301197fa26de773d2b489e6a0fffc7dba55c1e",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/39301197fa26de773d2b489e6a0fffc7dba55c1e",
        "files": [
          "ChangeLog",
          "test/socket/test_addrinfo.rb",
          "version.h"
        ],
        "message": "merge revision(s) 54005: [Backport #12150]\n\n\t* test/socket/test_addrinfo.rb (test_ipv6_address_predicates):\n\t  IN6_IS_ADDR_V4COMPAT and IN6_IS_ADDR_V4MAPPED are broken\n\t  on AIX, so skip related tests.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@54266 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "test/socket/test_addrinfo.rb||test/socket/test_addrinfo.rb",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "test/socket/test_addrinfo.rb||test/socket/test_addrinfo.rb": [
          "File: test/socket/test_addrinfo.rb -> test/socket/test_addrinfo.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "543:      # MacOS X returns IPv4 address for ::ffff:1.2.3.4 and ::1.2.3.4.",
          "544:             # Solaris returns IPv4 address for ::ffff:1.2.3.4.",
          "545:      ai = ipv6(addr)",
          "547:    else",
          "548:      assert(ipv6(addr).send(meth), \"#{addr_exp}.#{meth}\")",
          "549:             assert_equal(addr, ipv6(addr).ip_address)",
          "",
          "[Removed Lines]",
          "546:      assert(ai.ipv4? || ai.send(meth), \"ai=#{addr_exp}; ai.ipv4? || .#{meth}\")",
          "",
          "[Added Lines]",
          "546:             begin",
          "547:        assert(ai.ipv4? || ai.send(meth), \"ai=#{addr_exp}; ai.ipv4? || .#{meth}\")",
          "548:             rescue Minitest::Assertion",
          "549:               if /aix/ =~ RUBY_PLATFORM",
          "550:                 skip \"Known bug in IN6_IS_ADDR_V4COMPAT and IN6_IS_ADDR_V4MAPPED on AIX\"",
          "551:               end",
          "552:               raise $!",
          "553:             end",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.9\"",
          "2: #define RUBY_RELEASE_DATE \"2016-03-25\"",
          "5: #define RUBY_RELEASE_YEAR 2016",
          "6: #define RUBY_RELEASE_MONTH 3",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 463",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 464",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d82440ff9cb17b8a32a5eeb7dd838588468b39f4",
      "candidate_info": {
        "commit_hash": "d82440ff9cb17b8a32a5eeb7dd838588468b39f4",
        "repo": "ruby/ruby",
        "commit_url": "https://github.com/ruby/ruby/commit/d82440ff9cb17b8a32a5eeb7dd838588468b39f4",
        "files": [
          "ChangeLog",
          "ext/openssl/lib/openssl/ssl.rb",
          "ext/openssl/ossl_ssl.c",
          "test/openssl/test_pair.rb",
          "test/openssl/test_ssl.rb",
          "test/openssl/utils.rb",
          "test/ruby/envutil.rb",
          "test/ruby/test_io.rb",
          "version.h"
        ],
        "message": "merge revision(s) 46108,46209,46223,46297,48223,48224: [Backport #12168]\n\n\t* test/openssl: Join threads.\n\n\t* ext/openssl/ossl_ssl.c (ossl_ssl_close): Fix sync_close to work\n\t  when SSL is not started.\n\t  This fix the fd leak by test_https_proxy_authentication in\n\t  test/net/http/test_https_proxy.rb.\n\n\t* ext/openssl/lib/openssl/ssl.rb (SSLServer#accept): Close a socket\n\t  if any exception occur. \n\n\t* test/ruby/envutil.rb (assert_join_threads): New assertion to\n\t  join multiple threads without exceptions.\n\n\t* test/openssl/utils.rb (start_server, server_loop): Use a\n\t  pipe to stop server instead of shutdown/close a listening socket.\n\n\ngit-svn-id: svn+ssh://ci.ruby-lang.org/ruby/branches/ruby_2_1@54272 b2dd03c8-39d4-4d8f-98ff-823fe69b080e",
        "before_after_code_files": [
          "ext/openssl/lib/openssl/ssl.rb||ext/openssl/lib/openssl/ssl.rb",
          "ext/openssl/ossl_ssl.c||ext/openssl/ossl_ssl.c",
          "test/openssl/test_pair.rb||test/openssl/test_pair.rb",
          "test/openssl/test_ssl.rb||test/openssl/test_ssl.rb",
          "test/openssl/utils.rb||test/openssl/utils.rb",
          "test/ruby/envutil.rb||test/ruby/envutil.rb",
          "test/ruby/test_io.rb||test/ruby/test_io.rb",
          "version.h||version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "version.h||version.h"
          ],
          "candidate": [
            "version.h||version.h"
          ]
        }
      },
      "candidate_diff": {
        "ext/openssl/lib/openssl/ssl.rb||ext/openssl/lib/openssl/ssl.rb": [
          "File: ext/openssl/lib/openssl/ssl.rb -> ext/openssl/lib/openssl/ssl.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "305:           ssl.sync_close = true",
          "306:           ssl.accept if @start_immediately",
          "307:           ssl",
          "310:           raise ex",
          "311:         end",
          "312:       end",
          "",
          "[Removed Lines]",
          "308:         rescue SSLError => ex",
          "309:           sock.close",
          "",
          "[Added Lines]",
          "308:         rescue Exception => ex",
          "309:           if ssl",
          "310:             ssl.close",
          "311:           else",
          "312:             sock.close",
          "313:           end",
          "",
          "---------------"
        ],
        "ext/openssl/ossl_ssl.c||ext/openssl/ossl_ssl.c": [
          "File: ext/openssl/ossl_ssl.c -> ext/openssl/ossl_ssl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1583: ossl_ssl_close(VALUE self)",
          "1584: {",
          "1585:     SSL *ssl;",
          "1598:     }",
          "1600:     return Qnil;",
          "",
          "[Removed Lines]",
          "1587:     ossl_ssl_data_get_struct(self, ssl);",
          "1589:     if (ssl) {",
          "1590:  VALUE io = ossl_ssl_get_io(self);",
          "1591:  if (!RTEST(rb_funcall(io, rb_intern(\"closed?\"), 0))) {",
          "1592:      ossl_ssl_shutdown(ssl);",
          "1593:      SSL_free(ssl);",
          "1594:      DATA_PTR(self) = NULL;",
          "1595:      if (RTEST(ossl_ssl_get_sync_close(self)))",
          "1596:   rb_funcall(io, rb_intern(\"close\"), 0);",
          "1597:  }",
          "",
          "[Added Lines]",
          "1586:     VALUE io;",
          "1591:     Data_Get_Struct(self, SSL, ssl);",
          "1593:     io = ossl_ssl_get_io(self);",
          "1594:     if (!RTEST(rb_funcall(io, rb_intern(\"closed?\"), 0))) {",
          "1595:         if (ssl) {",
          "1596:             ossl_ssl_shutdown(ssl);",
          "1597:             SSL_free(ssl);",
          "1598:         }",
          "1599:         DATA_PTR(self) = NULL;",
          "1600:         if (RTEST(ossl_ssl_get_sync_close(self)))",
          "1601:             rb_funcall(io, rb_intern(\"close\"), 0);",
          "",
          "---------------"
        ],
        "test/openssl/test_pair.rb||test/openssl/test_pair.rb": [
          "File: test/openssl/test_pair.rb -> test/openssl/test_pair.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "83: module OpenSSL::TestEOF1M",
          "84:   def open_file(content)",
          "85:     s1, s2 = ssl_pair",
          "87:     yield s1",
          "88:   end",
          "89: end",
          "91: module OpenSSL::TestEOF2M",
          "92:   def open_file(content)",
          "93:     s1, s2 = ssl_pair",
          "95:     yield s2",
          "96:   end",
          "97: end",
          "",
          "[Removed Lines]",
          "86:     Thread.new { s2 << content; s2.close }",
          "94:     Thread.new { s1 << content; s1.close }",
          "",
          "[Added Lines]",
          "86:     th = Thread.new { s2 << content; s2.close }",
          "88:   ensure",
          "89:     th.join",
          "96:     th = Thread.new { s1 << content; s1.close }",
          "98:   ensure",
          "99:     th.join",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "312:     s1.print \"a\\ndef\"",
          "313:     assert_equal(\"a\\n\", s2.gets)",
          "314:   ensure",
          "315:     s1.close if s1 && !s1.closed?",
          "316:     s2.close if s2 && !s2.closed?",
          "317:     serv.close if serv && !serv.closed?",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "319:     th.join",
          "",
          "---------------"
        ],
        "test/openssl/test_ssl.rb||test/openssl/test_ssl.rb": [
          "File: test/openssl/test_ssl.rb -> test/openssl/test_ssl.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "121:       assert_raise(OpenSSL::SSL::SSLError, Errno::ECONNRESET){",
          "122:         sock = TCPSocket.new(\"127.0.0.1\", port)",
          "123:         ssl = OpenSSL::SSL::SSLSocket.new(sock)",
          "125:       }",
          "127:       ctx = OpenSSL::SSL::SSLContext.new",
          "",
          "[Removed Lines]",
          "124:         ssl.connect",
          "",
          "[Added Lines]",
          "124:         ssl.sync_close = true",
          "125:         begin",
          "126:           ssl.connect",
          "127:         ensure",
          "128:           ssl.close",
          "129:         end",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "166:   end",
          "168:   def test_starttls",
          "176:         ITERATIONS.times{",
          "177:           ssl.puts(str)",
          "178:           assert_equal(str, ssl.gets)",
          "179:         }",
          "180:         starttls(ssl)",
          "190:   end",
          "192:   def test_parallel",
          "",
          "[Removed Lines]",
          "169:     start_server(PORT, OpenSSL::SSL::VERIFY_NONE, false){|server, port|",
          "170:       sock = TCPSocket.new(\"127.0.0.1\", port)",
          "171:       ssl = OpenSSL::SSL::SSLSocket.new(sock)",
          "172:       ssl.sync_close = true",
          "173:       str = \"x\" * 1000 + \"\\n\"",
          "175:       OpenSSL::TestUtils.silent do",
          "181:       end",
          "183:       ITERATIONS.times{",
          "184:         ssl.puts(str)",
          "185:         assert_equal(str, ssl.gets)",
          "186:       }",
          "188:       ssl.close",
          "189:     }",
          "",
          "[Added Lines]",
          "174:     OpenSSL::TestUtils.silent do",
          "175:       start_server(PORT, OpenSSL::SSL::VERIFY_NONE, false){|server, port|",
          "176:         sock = TCPSocket.new(\"127.0.0.1\", port)",
          "177:         ssl = OpenSSL::SSL::SSLSocket.new(sock)",
          "178:         ssl.sync_close = true",
          "179:         str = \"x\" * 1000 + \"\\n\"",
          "187:         ITERATIONS.times{",
          "188:           ssl.puts(str)",
          "189:           assert_equal(str, ssl.gets)",
          "190:         }",
          "192:         ssl.close",
          "193:       }",
          "194:     end",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "217:       ctx = OpenSSL::SSL::SSLContext.new",
          "218:       ctx.set_params",
          "219:       ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)",
          "223:       sock = TCPSocket.new(\"127.0.0.1\", port)",
          "224:       ctx = OpenSSL::SSL::SSLContext.new",
          "225:       ctx.set_params(",
          "",
          "[Removed Lines]",
          "220:       assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }",
          "221:       assert_equal(OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN, ssl.verify_result)",
          "",
          "[Added Lines]",
          "225:       ssl.sync_close = true",
          "226:       begin",
          "227:         assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }",
          "228:         assert_equal(OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN, ssl.verify_result)",
          "229:       ensure",
          "230:         ssl.close",
          "231:       end",
          "232:     }",
          "234:     start_server(PORT, OpenSSL::SSL::VERIFY_NONE, true){|server, port|",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "229:         end",
          "230:       )",
          "231:       ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)",
          "235:       sock = TCPSocket.new(\"127.0.0.1\", port)",
          "236:       ctx = OpenSSL::SSL::SSLContext.new",
          "237:       ctx.set_params(",
          "",
          "[Removed Lines]",
          "232:       ssl.connect",
          "233:       assert_equal(OpenSSL::X509::V_OK, ssl.verify_result)",
          "",
          "[Added Lines]",
          "244:       ssl.sync_close = true",
          "245:       begin",
          "246:         ssl.connect",
          "247:         assert_equal(OpenSSL::X509::V_OK, ssl.verify_result)",
          "248:       ensure",
          "249:         ssl.close",
          "250:       end",
          "251:     }",
          "253:     start_server(PORT, OpenSSL::SSL::VERIFY_NONE, true){|server, port|",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "241:         end",
          "242:       )",
          "243:       ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)",
          "246:     }",
          "247:   end",
          "",
          "[Removed Lines]",
          "244:       assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }",
          "245:       assert_equal(OpenSSL::X509::V_ERR_APPLICATION_VERIFICATION, ssl.verify_result)",
          "",
          "[Added Lines]",
          "263:       ssl.sync_close = true",
          "264:       begin",
          "265:         assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }",
          "266:         assert_equal(OpenSSL::X509::V_ERR_APPLICATION_VERIFICATION, ssl.verify_result)",
          "267:       ensure",
          "268:         ssl.close",
          "269:       end",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "257:         end",
          "258:       )",
          "259:       ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)",
          "263:       end",
          "266:     }",
          "267:   end",
          "",
          "[Removed Lines]",
          "260:       OpenSSL::TestUtils.silent do",
          "261:         # SSLError, not RuntimeError",
          "262:         assert_raise(OpenSSL::SSL::SSLError) { ssl.connect }",
          "264:       assert_equal(OpenSSL::X509::V_ERR_CERT_REJECTED, ssl.verify_result)",
          "265:       ssl.close",
          "",
          "[Added Lines]",
          "284:       ssl.sync_close = true",
          "285:       begin",
          "286:         OpenSSL::TestUtils.silent do",
          "287:           # SSLError, not RuntimeError",
          "288:           assert_raise(OpenSSL::SSL::SSLError) { ssl.connect }",
          "289:         end",
          "290:         assert_equal(OpenSSL::X509::V_ERR_CERT_REJECTED, ssl.verify_result)",
          "291:       ensure",
          "292:         ssl.close",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "279:       assert(ciphers_names.all?{|v| /ADH/ !~ v })",
          "280:       assert(ciphers_versions.all?{|v| /SSLv2/ !~ v })",
          "281:       ssl = OpenSSL::SSL::SSLSocket.new(sock, ctx)",
          "284:     }",
          "285:   end",
          "",
          "[Removed Lines]",
          "282:       assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }",
          "283:       assert_equal(OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN, ssl.verify_result)",
          "",
          "[Added Lines]",
          "310:       ssl.sync_close = true",
          "311:       begin",
          "312:         assert_raise(OpenSSL::SSL::SSLError){ ssl.connect }",
          "313:         assert_equal(OpenSSL::X509::V_ERR_SELF_SIGNED_CERT_IN_CHAIN, ssl.verify_result)",
          "314:       ensure",
          "315:         ssl.close",
          "316:       end",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "822:     }",
          "823:   end",
          "825:   private",
          "827:   def start_server_version(version, ctx_proc=nil, server_proc=nil, &blk)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "858:   def test_sync_close_without_connect",
          "859:     Socket.open(:INET, :STREAM) {|s|",
          "860:       ssl = OpenSSL::SSL::SSLSocket.new(s)",
          "861:       ssl.sync_close = true",
          "862:       ssl.close",
          "863:       assert(s.closed?)",
          "864:     }",
          "865:   end",
          "",
          "---------------"
        ],
        "test/openssl/utils.rb||test/openssl/utils.rb": [
          "File: test/openssl/utils.rb -> test/openssl/utils.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "240:       ssl.close rescue nil",
          "241:     end",
          "244:       loop do",
          "245:         ssl = nil",
          "246:         begin",
          "247:           ssl = ssls.accept",
          "248:         rescue OpenSSL::SSL::SSLError",
          "249:           retry",
          "250:         end",
          "253:           Thread.current.abort_on_exception = true",
          "254:           server_proc.call(ctx, ssl)",
          "255:         end",
          "256:       end",
          "257:     rescue Errno::EBADF, IOError, Errno::EINVAL, Errno::ECONNABORTED, Errno::ENOTSOCK, Errno::ECONNRESET",
          "258:     end",
          "",
          "[Removed Lines]",
          "243:     def server_loop(ctx, ssls, server_proc)",
          "252:         Thread.start do",
          "",
          "[Added Lines]",
          "243:     def server_loop(ctx, ssls, stop_pipe_r, server_proc, threads)",
          "247:           readable, = IO.select([ssls, stop_pipe_r])",
          "248:           if readable.include? stop_pipe_r",
          "249:             return",
          "250:           end",
          "256:         th = Thread.start do",
          "260:         threads << th",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "262:       use_anon_cipher = args.fetch(:use_anon_cipher, false)",
          "263:       server_proc = args[:server_proc]",
          "264:       server_proc ||= method(:readwrite_loop)",
          "266:       store = OpenSSL::X509::Store.new",
          "267:       store.add_cert(@ca_cert)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270:       threads = []",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "286:         retry",
          "287:       end",
          "289:       ssls = OpenSSL::SSL::SSLServer.new(tcps, ctx)",
          "290:       ssls.start_immediately = start_immediately",
          "292:       begin",
          "293:         server = Thread.new do",
          "294:           Thread.current.abort_on_exception = true",
          "296:         end",
          "298:         $stderr.printf(\"%s started: pid=%d port=%d\\n\", SSL_SERVER, $$, port) if $DEBUG",
          "",
          "[Removed Lines]",
          "295:           server_loop(ctx, ssls, server_proc)",
          "",
          "[Added Lines]",
          "295:       stop_pipe_r, stop_pipe_w = IO.pipe",
          "303:           server_loop(ctx, ssls, stop_pipe_r, server_proc, threads)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "300:         block.call(server, port.to_i)",
          "301:       ensure",
          "302:         begin",
          "311:           if (server)",
          "312:             server.join(5)",
          "313:             if server.alive?",
          "315:               server.join",
          "316:               flunk(\"TCPServer was closed and SSLServer is still alive\") unless $!",
          "317:             end",
          "",
          "[Removed Lines]",
          "303:           begin",
          "304:             tcps.shutdown",
          "305:           rescue Errno::ENOTCONN",
          "306:             # when `Errno::ENOTCONN: Socket is not connected' on some platforms,",
          "307:             # call #close instead of #shutdown.",
          "308:             tcps.close",
          "309:             tcps = nil",
          "310:           end if (tcps)",
          "314:               server.kill",
          "",
          "[Added Lines]",
          "311:           stop_pipe_w.close",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "320:           tcps.close if (tcps)",
          "321:         end",
          "322:       end",
          "323:     end",
          "325:     def starttls(ssl)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "323:     ensure",
          "324:       stop_pipe_r.close if !stop_pipe_r.closed?",
          "325:       stop_pipe_w.close if !stop_pipe_w.closed?",
          "326:       assert_join_threads(threads)",
          "",
          "---------------"
        ],
        "test/ruby/envutil.rb||test/ruby/envutil.rb": [
          "File: test/ruby/envutil.rb -> test/ruby/envutil.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "434:         AssertFile",
          "435:       end",
          "437:       class << (AssertFile = Struct.new(:failure_message).new)",
          "438:         include Assertions",
          "439:         def assert_file_predicate(predicate, *args)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "437:       # threads should respond to shift method.",
          "438:       # Array and Queue can be used.",
          "439:       def assert_join_threads(threads, message = nil)",
          "440:         errs = []",
          "441:         values = []",
          "442:         while th = threads.shift",
          "443:           begin",
          "444:             values << th.value",
          "445:           rescue Exception",
          "446:             errs << $!",
          "447:           end",
          "448:         end",
          "449:         if !errs.empty?",
          "450:           msg = errs.map {|err|",
          "451:             err.backtrace.map.with_index {|line, i|",
          "452:               if i == 0",
          "453:                 \"#{line}: #{err.message} (#{err.class})\"",
          "454:               else",
          "455:                 \"\\tfrom #{line}\"",
          "456:               end",
          "457:             }.join(\"\\n\")",
          "458:           }.join(\"\\n---\\n\")",
          "459:           if message",
          "460:             msg = \"#{message}\\n#{msg}\"",
          "461:           end",
          "462:           raise MiniTest::Assertion, msg",
          "463:         end",
          "464:         values",
          "465:       end",
          "",
          "---------------"
        ],
        "test/ruby/test_io.rb||test/ruby/test_io.rb": [
          "File: test/ruby/test_io.rb -> test/ruby/test_io.rb",
          "--- Hunk 1 ---",
          "[Context before]",
          "584:             end",
          "585:             t1 = Thread.new { w1 << megacontent; w1.close }",
          "586:             t2 = Thread.new { r2.read }",
          "592:           }",
          "593:         }",
          "594:       }",
          "",
          "[Removed Lines]",
          "587:             ret = IO.copy_stream(r1, w2)",
          "588:             assert_equal(megacontent.bytesize, ret)",
          "589:             w2.close",
          "590:             t1.join",
          "591:             assert_equal(megacontent, t2.value)",
          "",
          "[Added Lines]",
          "587:             t3 = Thread.new {",
          "588:               ret = IO.copy_stream(r1, w2)",
          "589:               assert_equal(megacontent.bytesize, ret)",
          "590:               w2.close",
          "591:             }",
          "592:             _, t2_value, _ = assert_join_threads([t1, t2, t3])",
          "593:             assert_equal(megacontent, t2_value)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "601:         with_pipe {|r2, w2|",
          "602:           t1 = Thread.new { w1 << megacontent; w1.close }",
          "603:           t2 = Thread.new { r2.read }",
          "609:         }",
          "610:       }",
          "611:     }",
          "",
          "[Removed Lines]",
          "604:           ret = IO.copy_stream(r1, w2)",
          "605:           assert_equal(megacontent.bytesize, ret)",
          "606:           w2.close",
          "607:           t1.join",
          "608:           assert_equal(megacontent, t2.value)",
          "",
          "[Added Lines]",
          "606:           t3 = Thread.new {",
          "607:             ret = IO.copy_stream(r1, w2)",
          "608:             assert_equal(megacontent.bytesize, ret)",
          "609:             w2.close",
          "610:           }",
          "611:           _, t2_value, _ = assert_join_threads([t1, t2, t3])",
          "612:           assert_equal(megacontent, t2_value)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "614:   def test_copy_stream_megacontent_file_to_pipe",
          "615:     with_megasrc {|megasrc, megacontent|",
          "616:       with_pipe {|r, w|",
          "622:       }",
          "623:     }",
          "624:   end",
          "",
          "[Removed Lines]",
          "617:         t = Thread.new { r.read }",
          "618:         ret = IO.copy_stream(megasrc, w)",
          "619:         assert_equal(megacontent.bytesize, ret)",
          "620:         w.close",
          "621:         assert_equal(megacontent, t.value)",
          "",
          "[Added Lines]",
          "621:         t1 = Thread.new { r.read }",
          "622:         t2 = Thread.new {",
          "623:           ret = IO.copy_stream(megasrc, w)",
          "624:           assert_equal(megacontent.bytesize, ret)",
          "625:           w.close",
          "626:         }",
          "627:         t1_value, _ = assert_join_threads([t1, t2])",
          "628:         assert_equal(megacontent, t1_value)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "666:   def test_copy_stream_socket2",
          "667:     with_bigsrc {|bigsrc, bigcontent|",
          "668:       with_socketpair {|s1, s2|",
          "674:         assert_equal(bigcontent, result)",
          "675:       }",
          "676:     }",
          "",
          "[Removed Lines]",
          "669:         t = Thread.new { s2.read }",
          "670:         ret = IO.copy_stream(bigsrc, s1)",
          "671:         assert_equal(bigcontent.bytesize, ret)",
          "672:         s1.close",
          "673:         result = t.value",
          "",
          "[Added Lines]",
          "676:         t1 = Thread.new { s2.read }",
          "677:         t2 = Thread.new {",
          "678:           ret = IO.copy_stream(bigsrc, s1)",
          "679:           assert_equal(bigcontent.bytesize, ret)",
          "680:           s1.close",
          "681:         }",
          "682:         result, _ = assert_join_threads([t1, t2])",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "679:   def test_copy_stream_socket3",
          "680:     with_bigsrc {|bigsrc, bigcontent|",
          "681:       with_socketpair {|s1, s2|",
          "687:         assert_equal(bigcontent[0,10000], result)",
          "688:       }",
          "689:     }",
          "",
          "[Removed Lines]",
          "682:         t = Thread.new { s2.read }",
          "683:         ret = IO.copy_stream(bigsrc, s1, 10000)",
          "684:         assert_equal(10000, ret)",
          "685:         s1.close",
          "686:         result = t.value",
          "",
          "[Added Lines]",
          "691:         t1 = Thread.new { s2.read }",
          "692:         t2 = Thread.new {",
          "693:           ret = IO.copy_stream(bigsrc, s1, 10000)",
          "694:           assert_equal(10000, ret)",
          "695:           s1.close",
          "696:         }",
          "697:         result, _ = assert_join_threads([t1, t2])",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "694:       File.open(bigsrc) {|f|",
          "695:         assert_equal(0, f.pos)",
          "696:         with_socketpair {|s1, s2|",
          "703:           assert_equal(bigcontent[100..-1], result)",
          "704:         }",
          "705:       }",
          "",
          "[Removed Lines]",
          "697:           t = Thread.new { s2.read }",
          "698:           ret = IO.copy_stream(f, s1, nil, 100)",
          "699:           assert_equal(bigcontent.bytesize-100, ret)",
          "700:           assert_equal(0, f.pos)",
          "701:           s1.close",
          "702:           result = t.value",
          "",
          "[Added Lines]",
          "708:           t1 = Thread.new { s2.read }",
          "709:           t2 = Thread.new {",
          "710:             ret = IO.copy_stream(f, s1, nil, 100)",
          "711:             assert_equal(bigcontent.bytesize-100, ret)",
          "712:             assert_equal(0, f.pos)",
          "713:             s1.close",
          "714:           }",
          "715:           result, _ = assert_join_threads([t1, t2])",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "712:         assert_equal(bigcontent[0,100], f.read(100))",
          "713:         assert_equal(100, f.pos)",
          "714:         with_socketpair {|s1, s2|",
          "721:           assert_equal(bigcontent[100..-1], result)",
          "722:         }",
          "723:       }",
          "",
          "[Removed Lines]",
          "715:           t = Thread.new { s2.read }",
          "716:           ret = IO.copy_stream(f, s1)",
          "717:           assert_equal(bigcontent.bytesize-100, ret)",
          "718:           assert_equal(bigcontent.length, f.pos)",
          "719:           s1.close",
          "720:           result = t.value",
          "",
          "[Added Lines]",
          "728:           t1 = Thread.new { s2.read }",
          "729:           t2 = Thread.new {",
          "730:             ret = IO.copy_stream(f, s1)",
          "731:             assert_equal(bigcontent.bytesize-100, ret)",
          "732:             assert_equal(bigcontent.length, f.pos)",
          "733:             s1.close",
          "734:           }",
          "735:           result, _ = assert_join_threads([t1, t2])",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "735:         rescue Errno::EBADF",
          "736:           skip \"nonblocking IO for pipe is not implemented\"",
          "737:         end",
          "743:         assert_equal(megacontent, result)",
          "744:       }",
          "745:     }",
          "",
          "[Removed Lines]",
          "738:         t = Thread.new { s2.read }",
          "739:         ret = IO.copy_stream(\"megasrc\", s1)",
          "740:         assert_equal(megacontent.bytesize, ret)",
          "741:         s1.close",
          "742:         result = t.value",
          "",
          "[Added Lines]",
          "753:         t1 = Thread.new { s2.read }",
          "754:         t2 = Thread.new {",
          "755:           ret = IO.copy_stream(\"megasrc\", s1)",
          "756:           assert_equal(megacontent.bytesize, ret)",
          "757:           s1.close",
          "758:         }",
          "759:         result, _ = assert_join_threads([t1, t2])",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "967:       w.write \"zz\"",
          "968:       src = StringIO.new(\"abcd\")",
          "969:       IO.copy_stream(src, w)",
          "971:         w.close",
          "972:       }",
          "975:     }",
          "976:   end",
          "",
          "[Removed Lines]",
          "970:       t = Thread.new {",
          "973:       assert_equal(\"zzabcd\", r.read)",
          "974:       t.join",
          "",
          "[Added Lines]",
          "987:       t1 = Thread.new {",
          "990:       t2 = Thread.new { r.read }",
          "991:       _, result = assert_join_threads([t1, t2])",
          "992:       assert_equal(\"zzabcd\", result)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2633:           threads << Thread.new {write_file.print(i)}",
          "2634:           threads << Thread.new {read_file.read}",
          "2635:         end",
          "2637:         assert(true, \"[ruby-core:37197]\")",
          "2638:       ensure",
          "2639:         read_file.close",
          "",
          "[Removed Lines]",
          "2636:         threads.each {|t| t.join}",
          "",
          "[Added Lines]",
          "2654:         assert_join_threads(threads)",
          "",
          "---------------"
        ],
        "version.h||version.h": [
          "File: version.h -> version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: #define RUBY_VERSION \"2.1.9\"",
          "2: #define RUBY_RELEASE_DATE \"2016-03-25\"",
          "5: #define RUBY_RELEASE_YEAR 2016",
          "6: #define RUBY_RELEASE_MONTH 3",
          "",
          "[Removed Lines]",
          "3: #define RUBY_PATCHLEVEL 469",
          "",
          "[Added Lines]",
          "3: #define RUBY_PATCHLEVEL 470",
          "",
          "---------------"
        ]
      }
    }
  ]
}
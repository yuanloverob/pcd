{
  "cve_id": "CVE-2022-33105",
  "cve_desc": "Redis v7.0 was discovered to contain a memory leak via the component streamGetEdgeID.",
  "repo": "redis/redis",
  "patch_hash": "4a7a4e42db8ff757cdf3f4a824f66426036034ef",
  "patch_info": {
    "commit_hash": "4a7a4e42db8ff757cdf3f4a824f66426036034ef",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/4a7a4e42db8ff757cdf3f4a824f66426036034ef",
    "files": [
      "src/t_stream.c"
    ],
    "message": "Fix memory leak in streamGetEdgeID (#10753)\n\nsi is initialized by streamIteratorStart(), we should call\nstreamIteratorStop() on it when done.\n\nregression introduced in #9127 (redis 7.0)",
    "before_after_code_files": [
      "src/t_stream.c||src/t_stream.c"
    ]
  },
  "patch_diff": {
    "src/t_stream.c||src/t_stream.c": [
      "File: src/t_stream.c -> src/t_stream.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "401:         streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};",
      "403:     }",
      "405: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "404:     streamIteratorStop(&si);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b4079abed4bc012d96eb2c2bb776f6be8cd246f8",
      "candidate_info": {
        "commit_hash": "b4079abed4bc012d96eb2c2bb776f6be8cd246f8",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/b4079abed4bc012d96eb2c2bb776f6be8cd246f8",
        "files": [
          "src/t_stream.c"
        ],
        "message": "Fix XGROUP HELP message missing a newline (#10339)\n\nAdd a comma, this would have resulted in missing newline in the message.\nForgot to add in #9127",
        "before_after_code_files": [
          "src/t_stream.c||src/t_stream.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "src/t_stream.c||src/t_stream.c"
          ],
          "candidate": [
            "src/t_stream.c||src/t_stream.c"
          ]
        }
      },
      "candidate_diff": {
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2630: \"    * MKSTREAM\",",
          "2631: \"      Create the empty stream if it does not exist.\",",
          "2632: \"    * ENTRIESREAD entries_read\",",
          "2634: \"CREATECONSUMER <key> <groupname> <consumer>\",",
          "2635: \"    Create a new consumer in the specified group.\",",
          "2636: \"DELCONSUMER <key> <groupname> <consumer>\",",
          "",
          "[Removed Lines]",
          "2633: \"      Set the group's entries_read counter (internal use).\"",
          "",
          "[Added Lines]",
          "2633: \"      Set the group's entries_read counter (internal use).\",",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c81c7f51c38de6dff5ffc55b5184061b84c7ea5f",
      "candidate_info": {
        "commit_hash": "c81c7f51c38de6dff5ffc55b5184061b84c7ea5f",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/c81c7f51c38de6dff5ffc55b5184061b84c7ea5f",
        "files": [
          "src/aof.c",
          "src/cluster.c",
          "src/commands.c",
          "src/commands/xgroup-create.json",
          "src/commands/xgroup-setid.json",
          "src/commands/xinfo-groups.json",
          "src/commands/xinfo-stream.json",
          "src/commands/xsetid.json",
          "src/rdb.c",
          "src/rdb.h",
          "src/server.c",
          "src/server.h",
          "src/stream.h",
          "src/t_stream.c",
          "tests/integration/corrupt-dump.tcl",
          "tests/unit/type/stream-cgroups.tcl",
          "tests/unit/type/stream.tcl"
        ],
        "message": "Add stream consumer group lag tracking and reporting (#9127)\n\nAdds the ability to track the lag of a consumer group (CG), that is, the number\nof entries yet-to-be-delivered from the stream.\n\nThe proposed constant-time solution is in the spirit of \"best-effort.\"\n\nPartially addresses #8737.\n\n## Description of approach\n\nWe add a new \"entries_added\" property to the stream. This starts at 0 for a new\nstream and is incremented by 1 with every `XADD`.  It is essentially an all-time\ncounter of the entries added to the stream.\n\nGiven the stream's length and this counter value, we can trivially find the logical\n\"entries_added\" counter of the first ID if and only if the stream is contiguous.\nA fragmented stream contains one or more tombstones generated by `XDEL`s.\nThe new \"xdel_max_id\" stream property tracks the latest tombstone.\n\nThe CG also tracks its last delivered ID's as an \"entries_read\" counter and\nincrements it independently when delivering new messages, unless the this\nread counter is invalid (-1 means invalid offset). When the CG's counter is\navailable, the reported lag is the difference between added and read counters.\n\nLastly, this also adds a \"first_id\" field to the stream structure in order to make\nlooking it up cheaper in most cases.\n\n## Limitations\n\nThere are two cases in which the mechanism isn't able to track the lag.\nIn these cases, `XINFO` replies with `null` in the \"lag\" field.\n\nThe first case is when a CG is created with an arbitrary last delivered ID,\nthat isn't \"0-0\", nor the first or the last entries of the stream. In this case,\nit is impossible to obtain a valid read counter (short of an O(N) operation).\nThe second case is when there are one or more tombstones fragmenting\nthe stream's entries range.\n\nIn both cases, given enough time and assuming that the consumers are\nactive (reading and lacking) and advancing, the CG should be able to\ncatch up with the tip of the stream and report zero lag.\nOnce that's achieved, lag tracking would resume as normal (until the\nnext tombstone is set).\n\n## API changes\n\n* `XGROUP CREATE` added with the optional named argument `[ENTRIESREAD entries-read]`\n  for explicitly specifying the new CG's counter.\n* `XGROUP SETID` added with an optional positional argument `[ENTRIESREAD entries-read]`\n  for specifying the CG's counter.\n* `XINFO` reports the maximal tombstone ID, the recorded first entry ID, and total\n  number of entries added to the stream.\n* `XINFO` reports the current lag and logical read counter of CGs.\n* `XSETID` is an internal command that's used in replication/aof. It has been added with\n  the optional positional arguments `[ENTRIESADDED entries-added] [MAXDELETEDID max-deleted-entry-id]`\n  for propagating the CG's offset and maximal tombstone ID of the stream.\n\n## The generic unsolved problem\n\nThe current stream implementation doesn't provide an efficient way to obtain the\napproximate/exact size of a range of entries. While it could've been nice to have\nthat ability (#5813) in general, let alone specifically in the context of CGs, the risk\nand complexities involved in such implementation are in all likelihood prohibitive.\n\n## A refactoring note\n\nThe `streamGetEdgeID` has been refactored to accommodate both the existing seek\nof any entry as well as seeking non-deleted entries (the addition of the `skip_tombstones`\nargument). Furthermore, this refactoring also migrated the seek logic to use the\n`streamIterator` (rather than `raxIterator`) that was, in turn, extended with the\n`skip_tombstones` Boolean struct field to control the emission of these.\n\nCo-authored-by: Guy Benoish <guy.benoish@redislabs.com>\nCo-authored-by: Oran Agra <oran@redislabs.com>",
        "before_after_code_files": [
          "src/aof.c||src/aof.c",
          "src/cluster.c||src/cluster.c",
          "src/commands.c||src/commands.c",
          "src/rdb.c||src/rdb.c",
          "src/rdb.h||src/rdb.h",
          "src/server.c||src/server.c",
          "src/server.h||src/server.h",
          "src/stream.h||src/stream.h",
          "src/t_stream.c||src/t_stream.c",
          "tests/integration/corrupt-dump.tcl||tests/integration/corrupt-dump.tcl",
          "tests/unit/type/stream-cgroups.tcl||tests/unit/type/stream-cgroups.tcl",
          "tests/unit/type/stream.tcl||tests/unit/type/stream.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [
            "src/t_stream.c||src/t_stream.c"
          ],
          "candidate": [
            "src/t_stream.c||src/t_stream.c"
          ]
        }
      },
      "candidate_diff": {
        "src/aof.c||src/aof.c": [
          "File: src/aof.c -> src/aof.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2039:         !rioWriteBulkString(r,\"XSETID\",6) ||",
          "2040:         !rioWriteBulkObject(r,key) ||",
          "2042:     {",
          "2043:         streamIteratorStop(&si);",
          "2044:         return 0;",
          "",
          "[Removed Lines]",
          "2038:     if (!rioWriteBulkCount(r,'*',3) ||",
          "2041:         !rioWriteBulkStreamID(r,&s->last_id))",
          "",
          "[Added Lines]",
          "2038:     if (!rioWriteBulkCount(r,'*',7) ||",
          "2041:         !rioWriteBulkStreamID(r,&s->last_id) ||",
          "2042:         !rioWriteBulkString(r,\"ENTRIESADDED\",12) ||",
          "2043:         !rioWriteBulkLongLong(r,s->entries_added) ||",
          "2044:         !rioWriteBulkString(r,\"MAXDELETEDID\",12) ||",
          "2045:         !rioWriteBulkStreamID(r,&s->max_deleted_entry_id))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2053:         while(raxNext(&ri)) {",
          "2054:             streamCG *group = ri.data;",
          "2057:                 !rioWriteBulkString(r,\"XGROUP\",6) ||",
          "2058:                 !rioWriteBulkString(r,\"CREATE\",6) ||",
          "2059:                 !rioWriteBulkObject(r,key) ||",
          "2060:                 !rioWriteBulkString(r,(char*)ri.key,ri.key_len) ||",
          "2062:             {",
          "2063:                 raxStop(&ri);",
          "2064:                 streamIteratorStop(&si);",
          "",
          "[Removed Lines]",
          "2056:             if (!rioWriteBulkCount(r,'*',5) ||",
          "2061:                 !rioWriteBulkStreamID(r,&group->last_id))",
          "",
          "[Added Lines]",
          "2060:             if (!rioWriteBulkCount(r,'*',7) ||",
          "2065:                 !rioWriteBulkStreamID(r,&group->last_id) ||",
          "2066:                 !rioWriteBulkString(r,\"ENTRIESREAD\",11) ||",
          "2067:                 !rioWriteBulkLongLong(r,group->entries_read))",
          "",
          "---------------"
        ],
        "src/cluster.c||src/cluster.c": [
          "File: src/cluster.c -> src/cluster.c"
        ],
        "src/commands.c||src/commands.c": [
          "File: src/commands.c -> src/commands.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6004: #define XGROUP_CREATE_tips NULL",
          "",
          "[Removed Lines]",
          "6001: #define XGROUP_CREATE_History NULL",
          "",
          "[Added Lines]",
          "6001: commandHistory XGROUP_CREATE_History[] = {",
          "6002: {\"7.0.0\",\"Added the `entries_read` named argument.\"},",
          "6003: {0}",
          "6004: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6016: {\"groupname\",ARG_TYPE_STRING,-1,NULL,NULL,NULL,CMD_ARG_NONE},",
          "6017: {\"id\",ARG_TYPE_ONEOF,-1,NULL,NULL,NULL,CMD_ARG_NONE,.subargs=XGROUP_CREATE_id_Subargs},",
          "6018: {\"mkstream\",ARG_TYPE_PURE_TOKEN,-1,\"MKSTREAM\",NULL,NULL,CMD_ARG_OPTIONAL},",
          "6019: {0}",
          "6020: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6022: {\"entries_read\",ARG_TYPE_INTEGER,-1,\"ENTRIESREAD\",NULL,NULL,CMD_ARG_OPTIONAL},",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6083: #define XGROUP_SETID_tips NULL",
          "",
          "[Removed Lines]",
          "6080: #define XGROUP_SETID_History NULL",
          "",
          "[Added Lines]",
          "6084: commandHistory XGROUP_SETID_History[] = {",
          "6085: {\"7.0.0\",\"Added the optional `entries_read` argument.\"},",
          "6086: {0}",
          "6087: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "6094: {\"key\",ARG_TYPE_KEY,0,NULL,NULL,NULL,CMD_ARG_NONE},",
          "6095: {\"groupname\",ARG_TYPE_STRING,-1,NULL,NULL,NULL,CMD_ARG_NONE},",
          "6096: {\"id\",ARG_TYPE_ONEOF,-1,NULL,NULL,NULL,CMD_ARG_NONE,.subargs=XGROUP_SETID_id_Subargs},",
          "6097: {0}",
          "6098: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6104: {\"entries_read\",ARG_TYPE_INTEGER,-1,\"ENTRIESREAD\",NULL,NULL,CMD_ARG_OPTIONAL},",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "6104: {\"delconsumer\",\"Delete a consumer from a consumer group.\",\"O(1)\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XGROUP_DELCONSUMER_History,XGROUP_DELCONSUMER_tips,xgroupCommand,5,CMD_WRITE,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RW|CMD_KEY_DELETE,KSPEC_BS_INDEX,.bs.index={2},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XGROUP_DELCONSUMER_Args},",
          "6105: {\"destroy\",\"Destroy a consumer group.\",\"O(N) where N is the number of entries in the group's pending entries list (PEL).\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XGROUP_DESTROY_History,XGROUP_DESTROY_tips,xgroupCommand,4,CMD_WRITE,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RW|CMD_KEY_DELETE,KSPEC_BS_INDEX,.bs.index={2},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XGROUP_DESTROY_Args},",
          "6106: {\"help\",\"Show helpful text about the different subcommands\",\"O(1)\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XGROUP_HELP_History,XGROUP_HELP_tips,xgroupCommand,2,CMD_LOADING|CMD_STALE,ACL_CATEGORY_STREAM},",
          "6108: {0}",
          "6109: };",
          "",
          "[Removed Lines]",
          "6107: {\"setid\",\"Set a consumer group to an arbitrary last delivered ID value.\",\"O(1)\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XGROUP_SETID_History,XGROUP_SETID_tips,xgroupCommand,5,CMD_WRITE,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RW|CMD_KEY_UPDATE,KSPEC_BS_INDEX,.bs.index={2},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XGROUP_SETID_Args},",
          "",
          "[Added Lines]",
          "6115: {\"setid\",\"Set a consumer group to an arbitrary last delivered ID value.\",\"O(1)\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XGROUP_SETID_History,XGROUP_SETID_tips,xgroupCommand,-5,CMD_WRITE,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RW|CMD_KEY_UPDATE,KSPEC_BS_INDEX,.bs.index={2},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XGROUP_SETID_Args},",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "6143: #define XINFO_GROUPS_tips NULL",
          "",
          "[Removed Lines]",
          "6140: #define XINFO_GROUPS_History NULL",
          "",
          "[Added Lines]",
          "6148: commandHistory XINFO_GROUPS_History[] = {",
          "6149: {\"7.0.0\",\"Added the `entries-read` and `lag` fields\"},",
          "6150: {0}",
          "6151: };",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6165: #define XINFO_STREAM_tips NULL",
          "",
          "[Removed Lines]",
          "6162: #define XINFO_STREAM_History NULL",
          "",
          "[Added Lines]",
          "6173: commandHistory XINFO_STREAM_History[] = {",
          "6174: {\"7.0.0\",\"Added the `max-deleted-entry-id`, `entries-added`, `recorded-first-entry-id`, `entries-read` and `lag` fields\"},",
          "6175: {0}",
          "6176: };",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6344: #define XSETID_tips NULL",
          "",
          "[Removed Lines]",
          "6341: #define XSETID_History NULL",
          "",
          "[Added Lines]",
          "6355: commandHistory XSETID_History[] = {",
          "6356: {\"7.0.0\",\"Added the `entries_added` and `max_deleted_entry_id` arguments.\"},",
          "6357: {0}",
          "6358: };",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6347: struct redisCommandArg XSETID_Args[] = {",
          "6348: {\"key\",ARG_TYPE_KEY,0,NULL,NULL,NULL,CMD_ARG_NONE},",
          "6349: {\"last-id\",ARG_TYPE_STRING,-1,NULL,NULL,NULL,CMD_ARG_NONE},",
          "6350: {0}",
          "6351: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6367: {\"entries_added\",ARG_TYPE_INTEGER,-1,\"ENTRIESADDED\",NULL,NULL,CMD_ARG_OPTIONAL},",
          "6368: {\"max_deleted_entry_id\",ARG_TYPE_STRING,-1,\"MAXDELETEDID\",NULL,NULL,CMD_ARG_OPTIONAL},",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "7057: {\"xread\",\"Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.\",\"For each stream mentioned: O(N) with N being the number of elements being returned, it means that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK option is used, XADD will pay O(M) time in order to serve the M clients blocked on the stream getting new data.\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XREAD_History,XREAD_tips,xreadCommand,-4,CMD_BLOCKING|CMD_READONLY|CMD_BLOCKING,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_KEYWORD,.bs.keyword={\"STREAMS\",1},KSPEC_FK_RANGE,.fk.range={-1,1,2}}},xreadGetKeys,.args=XREAD_Args},",
          "7058: {\"xreadgroup\",\"Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.\",\"For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XREADGROUP_History,XREADGROUP_tips,xreadCommand,-7,CMD_BLOCKING|CMD_WRITE,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_KEYWORD,.bs.keyword={\"STREAMS\",4},KSPEC_FK_RANGE,.fk.range={-1,1,2}}},xreadGetKeys,.args=XREADGROUP_Args},",
          "7059: {\"xrevrange\",\"Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE\",\"O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XREVRANGE_History,XREVRANGE_tips,xrevrangeCommand,-4,CMD_READONLY,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RO|CMD_KEY_ACCESS,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XREVRANGE_Args},",
          "7061: {\"xtrim\",\"Trims the stream to (approximately if '~' is passed) a certain size\",\"O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XTRIM_History,XTRIM_tips,xtrimCommand,-4,CMD_WRITE,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RW|CMD_KEY_DELETE,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XTRIM_Args},",
          "7063: {\"append\",\"Append a value to a key\",\"O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.\",\"2.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STRING,APPEND_History,APPEND_tips,appendCommand,3,CMD_WRITE|CMD_DENYOOM|CMD_FAST,ACL_CATEGORY_STRING,{{NULL,CMD_KEY_RW|CMD_KEY_INSERT,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=APPEND_Args},",
          "",
          "[Removed Lines]",
          "7060: {\"xsetid\",\"An internal command for replicating stream values\",\"O(1)\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XSETID_History,XSETID_tips,xsetidCommand,3,CMD_WRITE|CMD_DENYOOM|CMD_FAST,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RW|CMD_KEY_UPDATE,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XSETID_Args},",
          "",
          "[Added Lines]",
          "7079: {\"xsetid\",\"An internal command for replicating stream values\",\"O(1)\",\"5.0.0\",CMD_DOC_NONE,NULL,NULL,COMMAND_GROUP_STREAM,XSETID_History,XSETID_tips,xsetidCommand,-3,CMD_WRITE|CMD_DENYOOM|CMD_FAST,ACL_CATEGORY_STREAM,{{NULL,CMD_KEY_RW|CMD_KEY_UPDATE,KSPEC_BS_INDEX,.bs.index={1},KSPEC_FK_RANGE,.fk.range={0,1,0}}},.args=XSETID_Args},",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "692:         else",
          "693:             serverPanic(\"Unknown hash encoding\");",
          "694:     case OBJ_STREAM:",
          "696:     case OBJ_MODULE:",
          "697:         return rdbSaveType(rdb,RDB_TYPE_MODULE_2);",
          "698:     default:",
          "",
          "[Removed Lines]",
          "695:         return rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS);",
          "",
          "[Added Lines]",
          "695:         return rdbSaveType(rdb,RDB_TYPE_STREAM_LISTPACKS_2);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "986:         nwritten += n;",
          "987:         if ((n = rdbSaveLen(rdb,s->last_id.seq)) == -1) return -1;",
          "988:         nwritten += n;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "990:         if ((n = rdbSaveLen(rdb,s->first_id.ms)) == -1) return -1;",
          "991:         nwritten += n;",
          "992:         if ((n = rdbSaveLen(rdb,s->first_id.seq)) == -1) return -1;",
          "993:         nwritten += n;",
          "995:         if ((n = rdbSaveLen(rdb,s->max_deleted_entry_id.ms)) == -1) return -1;",
          "996:         nwritten += n;",
          "997:         if ((n = rdbSaveLen(rdb,s->max_deleted_entry_id.seq)) == -1) return -1;",
          "998:         nwritten += n;",
          "1000:         if ((n = rdbSaveLen(rdb,s->entries_added)) == -1) return -1;",
          "1001:         nwritten += n;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1020:                     return -1;",
          "1021:                 }",
          "1022:                 nwritten += n;",
          "1025:                 if ((n = rdbSaveStreamPEL(rdb,cg->pel,1)) == -1) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1038:                 if ((n = rdbSaveLen(rdb,cg->entries_read)) == -1) {",
          "1039:                     raxStop(&ri);",
          "1040:                     return -1;",
          "1041:                 }",
          "1042:                 nwritten += n;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2321:                 rdbReportCorruptRDB(\"Unknown RDB encoding type %d\",rdbtype);",
          "2322:                 break;",
          "2323:         }",
          "2325:         o = createStreamObject();",
          "2326:         stream *s = o->ptr;",
          "2327:         uint64_t listpacks = rdbLoadLen(rdb,NULL);",
          "",
          "[Removed Lines]",
          "2324:     } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS) {",
          "",
          "[Added Lines]",
          "2344:     } else if (rdbtype == RDB_TYPE_STREAM_LISTPACKS || rdbtype == RDB_TYPE_STREAM_LISTPACKS_2) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2398:         s->last_id.ms = rdbLoadLen(rdb,NULL);",
          "2399:         s->last_id.seq = rdbLoadLen(rdb,NULL);",
          "2401:         if (rioGetReadError(rdb)) {",
          "2402:             rdbReportReadError(\"Stream object metadata loading failed.\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2421:         if (rdbtype == RDB_TYPE_STREAM_LISTPACKS_2) {",
          "2423:             s->first_id.ms = rdbLoadLen(rdb,NULL);",
          "2424:             s->first_id.seq = rdbLoadLen(rdb,NULL);",
          "2427:             s->max_deleted_entry_id.ms = rdbLoadLen(rdb,NULL);",
          "2428:             s->max_deleted_entry_id.seq = rdbLoadLen(rdb,NULL);",
          "2431:             s->entries_added = rdbLoadLen(rdb,NULL);",
          "2432:         } else {",
          "2436:             s->max_deleted_entry_id.ms = 0;",
          "2437:             s->max_deleted_entry_id.seq = 0;",
          "2438:             s->entries_added = s->length;",
          "2442:             streamGetEdgeID(s,1,1,&s->first_id);",
          "2443:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2432:                 decrRefCount(o);",
          "2433:                 return NULL;",
          "2434:             }",
          "2437:             if (cgroup == NULL) {",
          "2438:                 rdbReportCorruptRDB(\"Duplicated consumer group name %s\",",
          "2439:                                          cgname);",
          "",
          "[Removed Lines]",
          "2436:             streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id);",
          "",
          "[Added Lines]",
          "2481:             uint64_t cg_offset;",
          "2482:             if (rdbtype == RDB_TYPE_STREAM_LISTPACKS_2) {",
          "2483:                 cg_offset = rdbLoadLen(rdb,NULL);",
          "2484:                 if (rioGetReadError(rdb)) {",
          "2485:                     rdbReportReadError(\"Stream cgroup offset loading failed.\");",
          "2486:                     sdsfree(cgname);",
          "2487:                     decrRefCount(o);",
          "2488:                     return NULL;",
          "2489:                 }",
          "2490:             } else {",
          "2491:                 cg_offset = streamEstimateDistanceFromFirstEverEntry(s,&cg_id);",
          "2492:             }",
          "2494:             streamCG *cgroup = streamCreateCG(s,cgname,sdslen(cgname),&cg_id,cg_offset);",
          "",
          "---------------"
        ],
        "src/rdb.h||src/rdb.h": [
          "File: src/rdb.h -> src/rdb.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "94: #define RDB_TYPE_HASH_LISTPACK 16",
          "95: #define RDB_TYPE_ZSET_LISTPACK 17",
          "96: #define RDB_TYPE_LIST_QUICKLIST_2   18",
          "",
          "[Removed Lines]",
          "100: #define rdbIsObjectType(t) ((t >= 0 && t <= 7) || (t >= 9 && t <= 18))",
          "",
          "[Added Lines]",
          "97: #define RDB_TYPE_STREAM_LISTPACKS_2 19",
          "101: #define rdbIsObjectType(t) ((t >= 0 && t <= 7) || (t >= 9 && t <= 19))",
          "",
          "---------------"
        ],
        "src/server.c||src/server.c": [
          "File: src/server.c -> src/server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1767:     shared.retrycount = createStringObject(\"RETRYCOUNT\",10);",
          "1768:     shared.force = createStringObject(\"FORCE\",5);",
          "1769:     shared.justid = createStringObject(\"JUSTID\",6);",
          "1770:     shared.lastid = createStringObject(\"LASTID\",6);",
          "1771:     shared.default_username = createStringObject(\"default\",7);",
          "1772:     shared.ping = createStringObject(\"ping\",4);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1770:     shared.entriesread = createStringObject(\"ENTRIESREAD\",11);",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h"
        ],
        "src/stream.h||src/stream.h": [
          "File: src/stream.h -> src/stream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "52:     streamID last_id;       /* Last delivered (not acknowledged) ID for this",
          "53:                                group. Consumers that will just ask for more",
          "55:     rax *pel;               /* Pending entries list. This is a radix tree that",
          "56:                                has every message delivered to consumers (without",
          "57:                                the NOACK option) that was yet not acknowledged",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:     long long entries_read; /* In a perfect world (CG starts at 0-0, no dels, no",
          "60:                                XGROUP SETID, ...), this is the total number of",
          "61:                                group reads. In the real world, the reasoning behind",
          "62:                                this value is detailed at the top comment of",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108: stream *streamNew(void);",
          "109: void freeStream(stream *s);",
          "110: unsigned long streamLength(const robj *subject);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "117: #define SCG_INVALID_ENTRIES_READ -1",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "117: streamCG *streamLookupCG(stream *s, sds groupname);",
          "118: streamConsumer *streamLookupConsumer(streamCG *cg, sds name, int flags);",
          "119: streamConsumer *streamCreateConsumer(streamCG *cg, sds name, robj *key, int dbid, int flags);",
          "121: streamNACK *streamCreateNACK(streamConsumer *consumer);",
          "122: void streamDecodeID(void *buf, streamID *id);",
          "123: int streamCompareID(streamID *a, streamID *b);",
          "",
          "[Removed Lines]",
          "120: streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id);",
          "",
          "[Added Lines]",
          "131: streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "131: robj *createObjectFromStreamID(streamID *id);",
          "132: int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id, int seq_given);",
          "133: int streamDeleteItem(stream *s, streamID *id);",
          "134: int64_t streamTrimByLength(stream *s, long long maxlen, int approx);",
          "135: int64_t streamTrimByID(stream *s, streamID minid, int approx);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145: void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id);",
          "146: long long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id);",
          "",
          "---------------"
        ],
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "68:     stream *s = zmalloc(sizeof(*s));",
          "69:     s->rax = raxNew();",
          "70:     s->length = 0;",
          "71:     s->last_id.ms = 0;",
          "72:     s->last_id.seq = 0;",
          "74:     return s;",
          "75: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71:     s->first_id.ms = 0;",
          "72:     s->first_id.seq = 0;",
          "75:     s->max_deleted_entry_id.seq = 0;",
          "76:     s->max_deleted_entry_id.ms = 0;",
          "77:     s->entries_added = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:                   new_lp, NULL);",
          "185:     }",
          "186:     new_s->length = s->length;",
          "187:     new_s->last_id = s->last_id;",
          "188:     raxStop(&ri);",
          "190:     if (s->cgroups == NULL) return sobj;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "192:     new_s->first_id = s->first_id;",
          "194:     new_s->max_deleted_entry_id = s->max_deleted_entry_id;",
          "195:     new_s->entries_added = s->entries_added;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "196:     while (raxNext(&ri_cgroups)) {",
          "197:         streamCG *cg = ri_cgroups.data;",
          "198:         streamCG *new_cg = streamCreateCG(new_s, (char *)ri_cgroups.key,",
          "201:         serverAssert(new_cg != NULL);",
          "",
          "[Removed Lines]",
          "199:                                           ri_cgroups.key_len, &cg->last_id);",
          "",
          "[Added Lines]",
          "207:                                           ri_cgroups.key_len, &cg->last_id,",
          "208:                                           cg->entries_read);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "378:     return 0;",
          "379: }",
          "382: {",
          "400:     }",
          "412: }",
          "",
          "[Removed Lines]",
          "381: void streamGetEdgeID(stream *s, int first, streamID *edge_id)",
          "383:     raxIterator ri;",
          "384:     raxStart(&ri, s->rax);",
          "385:     int empty;",
          "386:     if (first) {",
          "387:         raxSeek(&ri, \"^\", NULL, 0);",
          "388:         empty = !raxNext(&ri);",
          "389:     } else {",
          "390:         raxSeek(&ri, \"$\", NULL, 0);",
          "391:         empty = !raxPrev(&ri);",
          "392:     }",
          "394:     if (empty) {",
          "396:         edge_id->ms = first ? UINT64_MAX : 0;",
          "397:         edge_id->seq = first ? UINT64_MAX : 0;",
          "398:         raxStop(&ri);",
          "399:         return;",
          "402:     unsigned char *lp = ri.data;",
          "405:     streamID master_id;",
          "406:     streamDecodeID(ri.key, &master_id);",
          "409:     lpGetEdgeStreamID(lp, first, &master_id, edge_id);",
          "411:     raxStop(&ri);",
          "",
          "[Added Lines]",
          "393: void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)",
          "395:     streamIterator si;",
          "396:     int64_t numfields;",
          "397:     streamIteratorStart(&si,s,NULL,NULL,!first);",
          "398:     si.skip_tombstones = skip_tombstones;",
          "399:     int found = streamIteratorGetID(&si,edge_id,&numfields);",
          "400:     if (!found) {",
          "401:         streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "664:     if (ri.data != lp)",
          "665:         raxInsert(s->rax,(unsigned char*)&rax_key,sizeof(rax_key),lp,NULL);",
          "666:     s->length++;",
          "667:     s->last_id = id;",
          "668:     if (added_id) *added_id = id;",
          "669:     return C_OK;",
          "670: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "660:     s->entries_added++;",
          "662:     if (s->length == 1) s->first_id = id;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "864:         break; /* If we are here, there was enough to delete in the current",
          "866:     }",
          "868:     raxStop(&ri);",
          "869:     return deleted;",
          "870: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "865:     if (s->length == 0) {",
          "866:         s->first_id.ms = 0;",
          "867:         s->first_id.seq = 0;",
          "868:     } else if (deleted) {",
          "869:         streamGetEdgeID(s,1,1,&s->first_id);",
          "870:     }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1189:             serverAssert(*numfields>=0);",
          "1193:             if (!si->rev) {",
          "1194:                 if (memcmp(buf,si->start_key,sizeof(streamID)) >= 0 &&",
          "1196:                 {",
          "1197:                     if (memcmp(buf,si->end_key,sizeof(streamID)) > 0)",
          "",
          "[Removed Lines]",
          "1195:                     !(flags & STREAM_ITEM_FLAG_DELETED))",
          "",
          "[Added Lines]",
          "1199:                     (!si->skip_tombstones || !(flags & STREAM_ITEM_FLAG_DELETED)))",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1203:                 }",
          "1204:             } else {",
          "1205:                 if (memcmp(buf,si->end_key,sizeof(streamID)) <= 0 &&",
          "1207:                 {",
          "1208:                     if (memcmp(buf,si->start_key,sizeof(streamID)) < 0)",
          "",
          "[Removed Lines]",
          "1206:                     !(flags & STREAM_ITEM_FLAG_DELETED))",
          "",
          "[Added Lines]",
          "1210:                     (!si->skip_tombstones || !(flags & STREAM_ITEM_FLAG_DELETED)))",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1386:                         id->ms,id->seq));",
          "1387: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1394: int streamIDEqZero(streamID *id) {",
          "1395:     return !(id->ms || id->seq);",
          "1396: }",
          "1403: int streamRangeHasTombstones(stream *s, streamID *start, streamID *end) {",
          "1404:     streamID start_id, end_id;",
          "1406:     if (!s->length || streamIDEqZero(&s->max_deleted_entry_id)) {",
          "1408:         return 0;",
          "1409:     }",
          "1411:     if (streamCompareID(&s->first_id,&s->max_deleted_entry_id) > 0) {",
          "1413:         return 0;",
          "1414:     }",
          "1416:     if (start) {",
          "1417:         start_id = *start;",
          "1418:     } else {",
          "1419:         start_id.ms = 0;",
          "1420:         start_id.seq = 0;",
          "1421:     }",
          "1423:     if (end) {",
          "1424:         end_id = *end;",
          "1425:     } else {",
          "1426:         end_id.ms = UINT64_MAX;",
          "1427:         end_id.seq = UINT64_MAX;",
          "1428:     }",
          "1430:     if (streamCompareID(&start_id,&s->max_deleted_entry_id) <= 0 &&",
          "1431:         streamCompareID(&s->max_deleted_entry_id,&end_id) <= 0)",
          "1432:     {",
          "1434:         return 1;",
          "1435:     }",
          "1438:     return 0;",
          "1439: }",
          "1444: void streamReplyWithCGLag(client *c, stream *s, streamCG *cg) {",
          "1445:     int valid = 0;",
          "1446:     long long lag = 0;",
          "1448:     if (!s->entries_added) {",
          "1450:         lag = 0;",
          "1451:         valid = 1;",
          "1452:     } else if (cg->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&cg->last_id,NULL)) {",
          "1455:         lag = (long long)s->entries_added - cg->entries_read;",
          "1456:         valid = 1;",
          "1457:     } else {",
          "1459:         long long entries_read = streamEstimateDistanceFromFirstEverEntry(s,&cg->last_id);",
          "1460:         if (entries_read != SCG_INVALID_ENTRIES_READ) {",
          "1462:             lag = (long long)s->entries_added - entries_read;",
          "1463:             valid = 1;",
          "1464:         }",
          "1465:     }",
          "1467:     if (valid) {",
          "1468:         addReplyLongLong(c,lag);",
          "1469:     } else {",
          "1470:         addReplyNull(c);",
          "1471:     }",
          "1472: }",
          "1496: long long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id) {",
          "1498:     if (!s->entries_added) {",
          "1499:         return 0;",
          "1500:     }",
          "1504:     if (!s->length && streamCompareID(id,&s->last_id) < 1) {",
          "1505:         return s->entries_added;",
          "1506:     }",
          "1508:     int cmp_last = streamCompareID(id,&s->last_id);",
          "1509:     if (cmp_last == 0) {",
          "1511:         return s->entries_added;",
          "1512:     } else if (cmp_last > 0) {",
          "1514:         return SCG_INVALID_ENTRIES_READ;",
          "1515:     }",
          "1517:     int cmp_id_first = streamCompareID(id,&s->first_id);",
          "1518:     int cmp_xdel_first = streamCompareID(&s->max_deleted_entry_id,&s->first_id);",
          "1519:     if (streamIDEqZero(&s->max_deleted_entry_id) || cmp_xdel_first < 0) {",
          "1521:         if (cmp_id_first < 0) {",
          "1523:             return s->entries_added - s->length;",
          "1524:         } else if (cmp_id_first == 0) {",
          "1526:             return s->entries_added - s->length + 1;",
          "1527:         }",
          "1528:     }",
          "1532:     return SCG_INVALID_ENTRIES_READ;",
          "1533: }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1430: void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {",
          "1432:     argv[0] = shared.xgroup;",
          "1433:     argv[1] = shared.setid;",
          "1434:     argv[2] = key;",
          "1435:     argv[3] = groupname;",
          "1436:     argv[4] = createObjectFromStreamID(&group->last_id);",
          "1440:     decrRefCount(argv[4]);",
          "1441: }",
          "",
          "[Removed Lines]",
          "1431:     robj *argv[5];",
          "1438:     alsoPropagate(c->db->id,argv,5,PROPAGATE_AOF|PROPAGATE_REPL);",
          "",
          "[Added Lines]",
          "1577:     robj *argv[7];",
          "1583:     argv[5] = shared.entriesread;",
          "1584:     argv[6] = createStringObjectFromLongLong(group->entries_read);",
          "1586:     alsoPropagate(c->db->id,argv,7,PROPAGATE_AOF|PROPAGATE_REPL);",
          "1589:     decrRefCount(argv[6]);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1532:     while(streamIteratorGetID(&si,&id,&numfields)) {",
          "1534:         if (group && streamCompareID(&id,&group->last_id) > 0) {",
          "1535:             group->last_id = id;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1688:             if (group->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&id,NULL)) {",
          "1692:                 group->entries_read++;",
          "1693:             } else if (s->entries_added) {",
          "1695:                 group->entries_read = streamEstimateDistanceFromFirstEverEntry(s,&id);",
          "1696:             }",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1805:         arg = createStringObjectFromLongLong(s->length);",
          "1806:     } else {",
          "1807:         streamID first_id;",
          "1809:         arg = createObjectFromStreamID(&first_id);",
          "1810:     }",
          "",
          "[Removed Lines]",
          "1808:         streamGetEdgeID(s, 1, &first_id);",
          "",
          "[Added Lines]",
          "1970:         streamGetEdgeID(s,1,0,&first_id);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2298: }",
          "2305:     if (s->cgroups == NULL) s->cgroups = raxNew();",
          "2306:     if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)",
          "2307:         return NULL;",
          "",
          "[Removed Lines]",
          "2304: streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id) {",
          "",
          "[Added Lines]",
          "2466: streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2310:     cg->pel = raxNew();",
          "2311:     cg->consumers = raxNew();",
          "2312:     cg->last_id = *id;",
          "2313:     raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);",
          "2314:     return cg;",
          "2315: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2475:     cg->entries_read = entries_read;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2400:     streamCG *cg = NULL;",
          "2402:     int mkstream = 0;",
          "2403:     robj *o;",
          "2417:     if (c->argc >= 4) {",
          "2418:         o = lookupKeyWrite(c->db,c->argv[2]);",
          "2419:         if (o) {",
          "2420:             if (checkType(c,o,OBJ_STREAM)) return;",
          "",
          "[Removed Lines]",
          "2407:     if (c->argc == 6 && !strcasecmp(opt,\"CREATE\")) {",
          "2408:         if (strcasecmp(c->argv[5]->ptr,\"MKSTREAM\")) {",
          "2409:             addReplySubcommandSyntaxError(c);",
          "2410:             return;",
          "2411:         }",
          "2412:         mkstream = 1;",
          "2413:         grpname = c->argv[3]->ptr;",
          "2414:     }",
          "",
          "[Added Lines]",
          "2566:     long long entries_read = SCG_INVALID_ENTRIES_READ;",
          "2572:         int i = 5;",
          "2573:         int create_subcmd = !strcasecmp(opt,\"CREATE\");",
          "2574:         int setid_subcmd = !strcasecmp(opt,\"SETID\");",
          "2575:         while (i < c->argc) {",
          "2576:             if (create_subcmd && !strcasecmp(c->argv[i]->ptr,\"MKSTREAM\")) {",
          "2577:                 mkstream = 1;",
          "2578:                 i++;",
          "2579:             } else if ((create_subcmd || setid_subcmd) && !strcasecmp(c->argv[i]->ptr,\"ENTRIESREAD\") && i + 1 < c->argc) {",
          "2580:                 if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_read,NULL) != C_OK)",
          "2581:                     return;",
          "2582:                 if (entries_read < 0 && entries_read != SCG_INVALID_ENTRIES_READ) {",
          "2583:                     addReplyError(c,\"value for ENTRIESREAD must be positive or -1\");",
          "2584:                     return;",
          "2585:                 }",
          "2586:                 i += 2;",
          "2587:             } else {",
          "2588:                 addReplySubcommandSyntaxError(c);",
          "2589:                 return;",
          "2590:             }",
          "2591:         }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2454: \"    Create a new consumer group. Options are:\",",
          "2455: \"    * MKSTREAM\",",
          "2456: \"      Create the empty stream if it does not exist.\",",
          "2457: \"CREATECONSUMER <key> <groupname> <consumer>\",",
          "2458: \"    Create a new consumer in the specified group.\",",
          "2459: \"DELCONSUMER <key> <groupname> <consumer>\",",
          "2460: \"    Remove the specified consumer.\",",
          "2461: \"DESTROY <key> <groupname>\",",
          "2462: \"    Remove the specified group.\",",
          "2465: NULL",
          "2466:         };",
          "2467:         addReplyHelp(c, help);",
          "2469:         streamID id;",
          "2470:         if (!strcmp(c->argv[4]->ptr,\"$\")) {",
          "2471:             if (s) {",
          "",
          "[Removed Lines]",
          "2463: \"SETID <key> <groupname> <id|$>\",",
          "2464: \"    Set the current group ID.\",",
          "2468:     } else if (!strcasecmp(opt,\"CREATE\") && (c->argc == 5 || c->argc == 6)) {",
          "",
          "[Added Lines]",
          "2632: \"    * ENTRIESREAD entries_read\",",
          "2633: \"      Set the group's entries_read counter (internal use).\"",
          "2640: \"SETID <key> <groupname> <id|$> [ENTRIESREAD entries_read]\",",
          "2641: \"    Set the current group ID and entries_read counter.\",",
          "2645:     } else if (!strcasecmp(opt,\"CREATE\") && (c->argc >= 5 && c->argc <= 8)) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2487:             signalModifiedKey(c,c->db,c->argv[2]);",
          "2488:         }",
          "2491:         if (cg) {",
          "2492:             addReply(c,shared.ok);",
          "2493:             server.dirty++;",
          "",
          "[Removed Lines]",
          "2490:         streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id);",
          "",
          "[Added Lines]",
          "2667:         streamCG *cg = streamCreateCG(s,grpname,sdslen(grpname),&id,entries_read);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2496:         } else {",
          "2497:             addReplyError(c,\"-BUSYGROUP Consumer Group name already exists\");",
          "2498:         }",
          "2500:         streamID id;",
          "2501:         if (!strcmp(c->argv[4]->ptr,\"$\")) {",
          "2502:             id = s->last_id;",
          "",
          "[Removed Lines]",
          "2499:     } else if (!strcasecmp(opt,\"SETID\") && c->argc == 5) {",
          "",
          "[Added Lines]",
          "2676:     } else if (!strcasecmp(opt,\"SETID\") && (c->argc == 5 || c->argc == 7)) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2504:             return;",
          "2505:         }",
          "2506:         cg->last_id = id;",
          "2507:         addReply(c,shared.ok);",
          "2508:         server.dirty++;",
          "2509:         notifyKeyspaceEvent(NOTIFY_STREAM,\"xgroup-setid\",c->argv[2],c->db->id);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2684:         cg->entries_read = entries_read;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2542:     }",
          "2543: }",
          "2548: void xsetidCommand(client *c) {",
          "2549:     robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);",
          "2550:     if (o == NULL || checkType(c,o,OBJ_STREAM)) return;",
          "2552:     stream *s = o->ptr;",
          "",
          "[Removed Lines]",
          "2553:     streamID id;",
          "2554:     if (streamParseStrictIDOrReply(c,c->argv[2],&id,0,NULL) != C_OK) return;",
          "",
          "[Added Lines]",
          "2728:     streamID id, max_xdel_id = {0, 0};",
          "2729:     long long entries_added = -1;",
          "2731:     if (streamParseStrictIDOrReply(c,c->argv[2],&id,0,NULL) != C_OK)",
          "2732:         return;",
          "2734:     int i = 3;",
          "2735:     while (i < c->argc) {",
          "2737:         char *opt = c->argv[i]->ptr;",
          "2738:         if (!strcasecmp(opt,\"ENTRIESADDED\") && moreargs) {",
          "2739:             if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_added,NULL) != C_OK) {",
          "2740:                 return;",
          "2741:             } else if (entries_added < 0) {",
          "2742:                 addReplyError(c,\"entries_added must be positive\");",
          "2743:                 return;",
          "2744:             }",
          "2745:             i += 2;",
          "2746:         } else if (!strcasecmp(opt,\"MAXDELETEDID\") && moreargs) {",
          "2747:             if (streamParseStrictIDOrReply(c,c->argv[i+1],&max_xdel_id,0,NULL) != C_OK) {",
          "2748:                 return;",
          "2749:             } else if (streamCompareID(&id,&max_xdel_id) < 0) {",
          "2750:                 addReplyError(c,\"The ID specified in XSETID is smaller than the provided max_deleted_entry_id\");",
          "2751:                 return;",
          "2752:             }",
          "2753:             i += 2;",
          "2754:         } else {",
          "2755:             addReplyErrorObject(c,shared.syntaxerr);",
          "2756:             return;",
          "2757:         }",
          "2758:     }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2561:         streamLastValidID(s,&maxid);",
          "2563:         if (streamCompareID(&id,&maxid) < 0) {",
          "2566:             return;",
          "2567:         }",
          "2568:     }",
          "2569:     s->last_id = id;",
          "2570:     addReply(c,shared.ok);",
          "2571:     server.dirty++;",
          "2572:     notifyKeyspaceEvent(NOTIFY_STREAM,\"xsetid\",c->argv[1],c->db->id);",
          "",
          "[Removed Lines]",
          "2564:             addReplyError(c,\"The ID specified in XSETID is smaller than the \"",
          "2565:                             \"target stream top item\");",
          "",
          "[Added Lines]",
          "2772:             addReplyError(c,\"The ID specified in XSETID is smaller than the target stream top item\");",
          "2773:             return;",
          "2774:         }",
          "2777:         if (entries_added != -1 && s->length > (uint64_t)entries_added) {",
          "2778:             addReplyError(c,\"The entries_added specified in XSETID is smaller than the target stream length\");",
          "2784:     if (entries_added != -1)",
          "2785:         s->entries_added = entries_added;",
          "2786:     if (!streamIDEqZero(&max_xdel_id))",
          "2787:         s->max_deleted_entry_id = max_xdel_id;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "3291:     int deleted = 0;",
          "3292:     for (int j = 2; j < c->argc; j++) {",
          "3294:     }",
          "",
          "[Removed Lines]",
          "3293:         deleted += streamDeleteItem(s,&ids[j-2]);",
          "",
          "[Added Lines]",
          "3510:     int first_entry = 0;",
          "3512:         streamID *id = &ids[j-2];",
          "3513:         if (streamDeleteItem(s,id)) {",
          "3516:             if (streamCompareID(id,&s->first_id) == 0) {",
          "3517:                 first_entry = 1;",
          "3518:             }",
          "3520:             if (streamCompareID(id,&s->max_deleted_entry_id) > 0) {",
          "3521:                 s->max_deleted_entry_id = *id;",
          "3522:             }",
          "3523:             deleted++;",
          "3524:         };",
          "3525:     }",
          "3528:     if (deleted) {",
          "3529:         if (s->length == 0) {",
          "3530:             s->first_id.ms = 0;",
          "3531:             s->first_id.seq = 0;",
          "3532:         } else if (first_entry) {",
          "3533:             streamGetEdgeID(s,1,1,&s->first_id);",
          "3534:         }",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "3398:         }",
          "3399:     }",
          "3402:     addReplyBulkCString(c,\"length\");",
          "3403:     addReplyLongLong(c,s->length);",
          "3404:     addReplyBulkCString(c,\"radix-tree-keys\");",
          "",
          "[Removed Lines]",
          "3401:     addReplyMapLen(c,full ? 6 : 7);",
          "",
          "[Added Lines]",
          "3642:     addReplyMapLen(c,full ? 9 : 10);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "3407:     addReplyLongLong(c,s->rax->numnodes);",
          "3408:     addReplyBulkCString(c,\"last-generated-id\");",
          "3409:     addReplyStreamID(c,&s->last_id);",
          "3411:     if (!full) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3651:     addReplyBulkCString(c,\"max-deleted-entry-id\");",
          "3652:     addReplyStreamID(c,&s->max_deleted_entry_id);",
          "3653:     addReplyBulkCString(c,\"entries-added\");",
          "3654:     addReplyLongLong(c,s->entries_added);",
          "3655:     addReplyBulkCString(c,\"recorded-first-entry-id\");",
          "3656:     addReplyStreamID(c,&s->first_id);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3445:             raxSeek(&ri_cgroups,\"^\",NULL,0);",
          "3446:             while(raxNext(&ri_cgroups)) {",
          "3447:                 streamCG *cg = ri_cgroups.data;",
          "3451:                 addReplyBulkCString(c,\"name\");",
          "",
          "[Removed Lines]",
          "3448:                 addReplyMapLen(c,5);",
          "",
          "[Added Lines]",
          "3695:                 addReplyMapLen(c,7);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3455:                 addReplyBulkCString(c,\"last-delivered-id\");",
          "3456:                 addReplyStreamID(c,&cg->last_id);",
          "3459:                 addReplyBulkCString(c,\"pel-count\");",
          "3460:                 addReplyLongLong(c,raxSize(cg->pel));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3706:                 addReplyBulkCString(c,\"entries-read\");",
          "3707:                 if (cg->entries_read != SCG_INVALID_ENTRIES_READ) {",
          "3708:                     addReplyLongLong(c,cg->entries_read);",
          "3709:                 } else {",
          "3710:                     addReplyNull(c);",
          "3711:                 }",
          "3714:                 addReplyBulkCString(c,\"lag\");",
          "3715:                 streamReplyWithCGLag(c,s,cg);",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3632:         raxSeek(&ri,\"^\",NULL,0);",
          "3633:         while(raxNext(&ri)) {",
          "3634:             streamCG *cg = ri.data;",
          "3636:             addReplyBulkCString(c,\"name\");",
          "3637:             addReplyBulkCBuffer(c,ri.key,ri.key_len);",
          "3638:             addReplyBulkCString(c,\"consumers\");",
          "",
          "[Removed Lines]",
          "3635:             addReplyMapLen(c,4);",
          "",
          "[Added Lines]",
          "3894:             addReplyMapLen(c,6);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3641:             addReplyLongLong(c,raxSize(cg->pel));",
          "3642:             addReplyBulkCString(c,\"last-delivered-id\");",
          "3643:             addReplyStreamID(c,&cg->last_id);",
          "3644:         }",
          "3645:         raxStop(&ri);",
          "3646:     } else if (!strcasecmp(opt,\"STREAM\")) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3903:             addReplyBulkCString(c,\"entries-read\");",
          "3904:             if (cg->entries_read != SCG_INVALID_ENTRIES_READ) {",
          "3905:                 addReplyLongLong(c,cg->entries_read);",
          "3906:             } else {",
          "3907:                 addReplyNull(c);",
          "3908:             }",
          "3909:             addReplyBulkCString(c,\"lag\");",
          "3910:             streamReplyWithCGLag(c,s,cg);",
          "",
          "---------------"
        ],
        "tests/integration/corrupt-dump.tcl||tests/integration/corrupt-dump.tcl": [
          "File: tests/integration/corrupt-dump.tcl -> tests/integration/corrupt-dump.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "193: test {corrupt payload: listpack too long entry len} {",
          "194:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "195:         r config set sanitize-dump-payload no",
          "197:         catch {",
          "199:         } err",
          "200:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "201:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "",
          "[Removed Lines]",
          "196:         r restore key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x40\\x55\\x55\\x00\\x00\\x00\\x0F\\x00\\x01\\x01\\x00\\x01\\x02\\x01\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\\x02\\x02\\x89\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x62\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x08\\x01\\xFF\\x0A\\x01\\x00\\x00\\x09\\x00\\x40\\x63\\xC9\\x37\\x03\\xA2\\xE5\\x68\"",
          "198:             r xinfo stream key full",
          "",
          "[Added Lines]",
          "197:             r restore key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x40\\x55\\x55\\x00\\x00\\x00\\x0F\\x00\\x01\\x01\\x00\\x01\\x02\\x01\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\\x02\\x02\\x89\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x62\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x08\\x01\\xFF\\x0A\\x01\\x00\\x00\\x09\\x00\\x40\\x63\\xC9\\x37\\x03\\xA2\\xE5\\x68\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "205: test {corrupt payload: listpack very long entry len} {",
          "206:     start_server [list overrides [list loglevel verbose use-exit-on-panic yes crash-memcheck-enabled no] ] {",
          "207:         r config set sanitize-dump-payload no",
          "209:         catch {",
          "211:         } err",
          "212:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "213:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "",
          "[Removed Lines]",
          "208:         r restore key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x40\\x55\\x55\\x00\\x00\\x00\\x0F\\x00\\x01\\x01\\x00\\x01\\x02\\x01\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\\x02\\x02\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x9C\\x62\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x08\\x01\\xFF\\x0A\\x01\\x00\\x00\\x09\\x00\\x63\\x6F\\x42\\x8E\\x7C\\xB5\\xA2\\x9D\"",
          "210:             r xinfo stream key full",
          "",
          "[Added Lines]",
          "208:             # This will catch migrated payloads from v6.2.x",
          "209:             r restore key 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x40\\x55\\x55\\x00\\x00\\x00\\x0F\\x00\\x01\\x01\\x00\\x01\\x02\\x01\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x00\\x01\\x00\\x01\\x00\\x01\\x00\\x01\\x02\\x02\\x88\\x31\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x61\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x88\\x32\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x9C\\x62\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x08\\x01\\xFF\\x0A\\x01\\x00\\x00\\x09\\x00\\x63\\x6F\\x42\\x8E\\x7C\\xB5\\xA2\\x9D\"",
          "",
          "---------------"
        ],
        "tests/unit/type/stream-cgroups.tcl||tests/unit/type/stream-cgroups.tcl": [
          "File: tests/unit/type/stream-cgroups.tcl -> tests/unit/type/stream-cgroups.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "623:         r XDEL x 103",
          "625:         set reply [r XINFO STREAM x FULL]",
          "638:         set reply [r XINFO STREAM x FULL COUNT 1]",
          "642:     }",
          "644:     test {XGROUP CREATECONSUMER: create consumer if does not exist} {",
          "",
          "[Removed Lines]",
          "626:         assert_equal [llength $reply] 12",
          "627:         assert_equal [lindex $reply 1] 4 ;# stream length",
          "628:         assert_equal [lindex $reply 9] \"{100-0 {a 1}} {101-0 {b 1}} {102-0 {c 1}} {104-0 {f 1}}\" ;# entries",
          "629:         assert_equal [lindex $reply 11 0 1] \"g1\" ;# first group name",
          "630:         assert_equal [lindex $reply 11 0 7 0 0] \"100-0\" ;# first entry in group's PEL",
          "631:         assert_equal [lindex $reply 11 0 9 0 1] \"Alice\" ;# first consumer",
          "632:         assert_equal [lindex $reply 11 0 9 0 7 0 0] \"100-0\" ;# first entry in first consumer's PEL",
          "633:         assert_equal [lindex $reply 11 1 1] \"g2\" ;# second group name",
          "634:         assert_equal [lindex $reply 11 1 9 0 1] \"Charlie\" ;# first consumer",
          "635:         assert_equal [lindex $reply 11 1 9 0 7 0 0] \"100-0\" ;# first entry in first consumer's PEL",
          "636:         assert_equal [lindex $reply 11 1 9 0 7 1 0] \"101-0\" ;# second entry in first consumer's PEL",
          "639:         assert_equal [llength $reply] 12",
          "640:         assert_equal [lindex $reply 1] 4",
          "641:         assert_equal [lindex $reply 9] \"{100-0 {a 1}}\"",
          "",
          "[Added Lines]",
          "626:         assert_equal [llength $reply] 18",
          "627:         assert_equal [dict get $reply length] 4",
          "628:         assert_equal [dict get $reply entries] \"{100-0 {a 1}} {101-0 {b 1}} {102-0 {c 1}} {104-0 {f 1}}\"",
          "630:         # First consumer group",
          "631:         set group [lindex [dict get $reply groups] 0]",
          "632:         assert_equal [dict get $group name] \"g1\"",
          "633:         assert_equal [lindex [dict get $group pending] 0 0] \"100-0\"",
          "634:         set consumer [lindex [dict get $group consumers] 0]",
          "635:         assert_equal [dict get $consumer name] \"Alice\"",
          "636:         assert_equal [lindex [dict get $consumer pending] 0 0] \"100-0\" ;# first entry in first consumer's PEL",
          "638:         # Second consumer group",
          "639:         set group [lindex [dict get $reply groups] 1]",
          "640:         assert_equal [dict get $group name] \"g2\"",
          "641:         set consumer [lindex [dict get $group consumers] 0]",
          "642:         assert_equal [dict get $consumer name] \"Charlie\"",
          "643:         assert_equal [lindex [dict get $consumer pending] 0 0] \"100-0\" ;# first entry in first consumer's PEL",
          "644:         assert_equal [lindex [dict get $consumer pending] 1 0] \"101-0\" ;# second entry in first consumer's PEL",
          "647:         assert_equal [llength $reply] 18",
          "648:         assert_equal [dict get $reply length] 4",
          "649:         assert_equal [dict get $reply entries] \"{100-0 {a 1}}\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "702:             set grpinfo [r xinfo groups mystream]",
          "704:             r debug loadaof",
          "706:             set reply [r xinfo consumers mystream mygroup]",
          "707:             set consumer_info [lindex $reply 0]",
          "708:             assert_equal [lindex $consumer_info 1] \"Alice\" ;# consumer name",
          "",
          "[Removed Lines]",
          "705:             assert {[r xinfo groups mystream] == $grpinfo}",
          "",
          "[Added Lines]",
          "713:             assert_equal [r xinfo groups mystream] $grpinfo",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "741:         }",
          "742:     }",
          "744:     start_server {tags {\"external:skip\"}} {",
          "745:         set master [srv -1 client]",
          "746:         set master_host [srv -1 host]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "752:     test {Consumer group read counter and lag in empty streams} {",
          "753:         r DEL x",
          "754:         r XGROUP CREATE x g1 0 MKSTREAM",
          "756:         set reply [r XINFO STREAM x FULL]",
          "757:         set group [lindex [dict get $reply groups] 0]",
          "758:         assert_equal [dict get $reply max-deleted-entry-id] \"0-0\"",
          "759:         assert_equal [dict get $reply entries-added] 0",
          "760:         assert_equal [dict get $group entries-read] {}",
          "761:         assert_equal [dict get $group lag] 0",
          "763:         r XADD x 1-0 data a",
          "764:         r XDEL x 1-0",
          "766:         set reply [r XINFO STREAM x FULL]",
          "767:         set group [lindex [dict get $reply groups] 0]",
          "768:         assert_equal [dict get $reply max-deleted-entry-id] \"1-0\"",
          "769:         assert_equal [dict get $reply entries-added] 1",
          "770:         assert_equal [dict get $group entries-read] {}",
          "771:         assert_equal [dict get $group lag] 0",
          "772:     }",
          "774:     test {Consumer group read counter and lag sanity} {",
          "775:         r DEL x",
          "776:         r XADD x 1-0 data a",
          "777:         r XADD x 2-0 data b",
          "778:         r XADD x 3-0 data c",
          "779:         r XADD x 4-0 data d",
          "780:         r XADD x 5-0 data e",
          "781:         r XGROUP CREATE x g1 0",
          "783:         set reply [r XINFO STREAM x FULL]",
          "784:         set group [lindex [dict get $reply groups] 0]",
          "785:         assert_equal [dict get $group entries-read] {}",
          "786:         assert_equal [dict get $group lag] 5",
          "788:         r XREADGROUP GROUP g1 c11 COUNT 1 STREAMS x >",
          "789:         set reply [r XINFO STREAM x FULL]",
          "790:         set group [lindex [dict get $reply groups] 0]",
          "791:         assert_equal [dict get $group entries-read] 1",
          "792:         assert_equal [dict get $group lag] 4",
          "794:         r XREADGROUP GROUP g1 c12 COUNT 10 STREAMS x >",
          "795:         set reply [r XINFO STREAM x FULL]",
          "796:         set group [lindex [dict get $reply groups] 0]",
          "797:         assert_equal [dict get $group entries-read] 5",
          "798:         assert_equal [dict get $group lag] 0",
          "800:         r XADD x 6-0 data f",
          "801:         set reply [r XINFO STREAM x FULL]",
          "802:         set group [lindex [dict get $reply groups] 0]",
          "803:         assert_equal [dict get $group entries-read] 5",
          "804:         assert_equal [dict get $group lag] 1",
          "805:     }",
          "807:     test {Consumer group lag with XDELs} {",
          "808:         r DEL x",
          "809:         r XADD x 1-0 data a",
          "810:         r XADD x 2-0 data b",
          "811:         r XADD x 3-0 data c",
          "812:         r XADD x 4-0 data d",
          "813:         r XADD x 5-0 data e",
          "814:         r XDEL x 3-0",
          "815:         r XGROUP CREATE x g1 0",
          "816:         r XGROUP CREATE x g2 0",
          "818:         set reply [r XINFO STREAM x FULL]",
          "819:         set group [lindex [dict get $reply groups] 0]",
          "820:         assert_equal [dict get $group entries-read] {}",
          "821:         assert_equal [dict get $group lag] {}",
          "823:         r XREADGROUP GROUP g1 c11 COUNT 1 STREAMS x >",
          "824:         set reply [r XINFO STREAM x FULL]",
          "825:         set group [lindex [dict get $reply groups] 0]",
          "826:         assert_equal [dict get $group entries-read] {}",
          "827:         assert_equal [dict get $group lag] {}",
          "829:         r XREADGROUP GROUP g1 c11 COUNT 1 STREAMS x >",
          "830:         set reply [r XINFO STREAM x FULL]",
          "831:         set group [lindex [dict get $reply groups] 0]",
          "832:         assert_equal [dict get $group entries-read] {}",
          "833:         assert_equal [dict get $group lag] {}",
          "835:         r XREADGROUP GROUP g1 c11 COUNT 1 STREAMS x >",
          "836:         set reply [r XINFO STREAM x FULL]",
          "837:         set group [lindex [dict get $reply groups] 0]",
          "838:         assert_equal [dict get $group entries-read] {}",
          "839:         assert_equal [dict get $group lag] {}",
          "841:         r XREADGROUP GROUP g1 c11 COUNT 1 STREAMS x >",
          "842:         set reply [r XINFO STREAM x FULL]",
          "843:         set group [lindex [dict get $reply groups] 0]",
          "844:         assert_equal [dict get $group entries-read] 5",
          "845:         assert_equal [dict get $group lag] 0",
          "847:         r XADD x 6-0 data f",
          "848:         set reply [r XINFO STREAM x FULL]",
          "849:         set group [lindex [dict get $reply groups] 0]",
          "850:         assert_equal [dict get $group entries-read] 5",
          "851:         assert_equal [dict get $group lag] 1",
          "853:         r XTRIM x MINID = 3-0",
          "854:         set reply [r XINFO STREAM x FULL]",
          "855:         set group [lindex [dict get $reply groups] 0]",
          "856:         assert_equal [dict get $group entries-read] 5",
          "857:         assert_equal [dict get $group lag] 1",
          "858:         set group [lindex [dict get $reply groups] 1]",
          "859:         assert_equal [dict get $group entries-read] {}",
          "860:         assert_equal [dict get $group lag] 3",
          "862:         r XTRIM x MINID = 5-0",
          "863:         set reply [r XINFO STREAM x FULL]",
          "864:         set group [lindex [dict get $reply groups] 0]",
          "865:         assert_equal [dict get $group entries-read] 5",
          "866:         assert_equal [dict get $group lag] 1",
          "867:         set group [lindex [dict get $reply groups] 1]",
          "868:         assert_equal [dict get $group entries-read] {}",
          "869:         assert_equal [dict get $group lag] 2",
          "870:     }",
          "872:     test {Loading from legacy (Redis <= v6.2.x, rdb_ver < 10) persistence} {",
          "873:         # The payload was DUMPed from a v5 instance after:",
          "874:         # XADD x 1-0 data a",
          "875:         # XADD x 2-0 data b",
          "876:         # XADD x 3-0 data c",
          "877:         # XADD x 4-0 data d",
          "878:         # XADD x 5-0 data e",
          "879:         # XADD x 6-0 data f",
          "880:         # XDEL x 3-0",
          "881:         # XGROUP CREATE x g1 0",
          "882:         # XGROUP CREATE x g2 0",
          "883:         # XREADGROUP GROUP g1 c11 COUNT 4 STREAMS x >",
          "884:         # XTRIM x MAXLEN = 2",
          "886:         r DEL x",
          "887:         r RESTORE x 0 \"\\x0F\\x01\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xC3\\x40\\x4A\\x40\\x57\\x16\\x57\\x00\\x00\\x00\\x23\\x00\\x02\\x01\\x04\\x01\\x01\\x01\\x84\\x64\\x61\\x74\\x61\\x05\\x00\\x01\\x03\\x01\\x00\\x20\\x01\\x03\\x81\\x61\\x02\\x04\\x20\\x0A\\x00\\x01\\x40\\x0A\\x00\\x62\\x60\\x0A\\x00\\x02\\x40\\x0A\\x00\\x63\\x60\\x0A\\x40\\x22\\x01\\x81\\x64\\x20\\x0A\\x40\\x39\\x20\\x0A\\x00\\x65\\x60\\x0A\\x00\\x05\\x40\\x0A\\x00\\x66\\x20\\x0A\\x00\\xFF\\x02\\x06\\x00\\x02\\x02\\x67\\x31\\x05\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x3E\\xF7\\x83\\x43\\x7A\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x3E\\xF7\\x83\\x43\\x7A\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x3E\\xF7\\x83\\x43\\x7A\\x01\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x3E\\xF7\\x83\\x43\\x7A\\x01\\x00\\x00\\x01\\x01\\x03\\x63\\x31\\x31\\x3E\\xF7\\x83\\x43\\x7A\\x01\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x67\\x32\\x00\\x00\\x00\\x00\\x09\\x00\\x3D\\x52\\xEF\\x68\\x67\\x52\\x1D\\xFA\"",
          "889:         set reply [r XINFO STREAM x FULL]",
          "890:         assert_equal [dict get $reply max-deleted-entry-id] \"0-0\"",
          "891:         assert_equal [dict get $reply entries-added] 2",
          "892:         set group [lindex [dict get $reply groups] 0]",
          "893:         assert_equal [dict get $group entries-read] 1",
          "894:         assert_equal [dict get $group lag] 1",
          "895:         set group [lindex [dict get $reply groups] 1]",
          "896:         assert_equal [dict get $group entries-read] 0",
          "897:         assert_equal [dict get $group lag] 2",
          "898:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "841:             waitForBgrewriteaof r",
          "842:             r debug loadaof",
          "843:             assert {[dict get [r xinfo stream mystream] length] == 0}",
          "845:         }",
          "846:     }",
          "847: }",
          "",
          "[Removed Lines]",
          "844:             assert {[r xinfo groups mystream] == $grpinfo}",
          "",
          "[Added Lines]",
          "1000:             assert_equal [r xinfo groups mystream] $grpinfo",
          "",
          "---------------"
        ],
        "tests/unit/type/stream.tcl||tests/unit/type/stream.tcl": [
          "File: tests/unit/type/stream.tcl -> tests/unit/type/stream.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "761:     test {XSETID can set a specific ID} {",
          "762:         r XSETID mystream \"200-0\"",
          "764:     }",
          "766:     test {XSETID cannot SETID with smaller ID} {",
          "",
          "[Removed Lines]",
          "763:         assert {[dict get [r xinfo stream mystream] last-generated-id] == \"200-0\"}",
          "",
          "[Added Lines]",
          "763:         set reply [r XINFO stream mystream]",
          "764:         assert_equal [dict get $reply last-generated-id] \"200-0\"",
          "765:         assert_equal [dict get $reply entries-added] 1",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "774:         catch {r XSETID stream 1-1} err",
          "775:         set _ $err",
          "776:     } {ERR no such key}",
          "777: }",
          "779: start_server {tags {\"stream needs:debug\"} overrides {appendonly yes aof-use-rdb-preamble no}} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "780:     test {XSETID cannot run with an offset but without a maximal tombstone} {",
          "781:         catch {r XSETID stream 1-1 0} err",
          "782:         set _ $err",
          "783:     } {ERR syntax error}",
          "785:     test {XSETID cannot run with a maximal tombstone but without an offset} {",
          "786:         catch {r XSETID stream 1-1 0-0} err",
          "787:         set _ $err",
          "788:     } {ERR syntax error}",
          "790:     test {XSETID errors on negstive offset} {",
          "791:         catch {r XSETID stream 1-1 ENTRIESADDED -1 MAXDELETEDID 0-0} err",
          "792:         set _ $err",
          "793:     } {ERR*must be positive}",
          "795:     test {XSETID cannot set the maximal tombstone with larger ID} {",
          "796:         r DEL x",
          "797:         r XADD x 1-0 a b",
          "799:         catch {r XSETID x \"1-0\" ENTRIESADDED 1 MAXDELETEDID \"2-0\" } err",
          "800:         r XADD mystream MAXLEN 0 * a b",
          "801:         set err",
          "802:     } {ERR*smaller*}",
          "804:     test {XSETID cannot set the offset to less than the length} {",
          "805:         r DEL x",
          "806:         r XADD x 1-0 a b",
          "808:         catch {r XSETID x \"1-0\" ENTRIESADDED 0 MAXDELETEDID \"0-0\" } err",
          "809:         r XADD mystream MAXLEN 0 * a b",
          "810:         set err",
          "811:     } {ERR*smaller*}",
          "812: }",
          "814: start_server {tags {\"stream offset\"}} {",
          "815:     test {XADD advances the entries-added counter and sets the recorded-first-entry-id} {",
          "816:         r DEL x",
          "817:         r XADD x 1-0 data a",
          "819:         set reply [r XINFO STREAM x FULL]",
          "820:         assert_equal [dict get $reply entries-added] 1",
          "821:         assert_equal [dict get $reply recorded-first-entry-id] \"1-0\"",
          "823:         r XADD x 2-0 data a",
          "824:         set reply [r XINFO STREAM x FULL]",
          "825:         assert_equal [dict get $reply entries-added] 2",
          "826:         assert_equal [dict get $reply recorded-first-entry-id] \"1-0\"",
          "827:     }",
          "829:     test {XDEL/TRIM are reflected by recorded first entry} {",
          "830:         r DEL x",
          "831:         r XADD x 1-0 data a",
          "832:         r XADD x 2-0 data a",
          "833:         r XADD x 3-0 data a",
          "834:         r XADD x 4-0 data a",
          "835:         r XADD x 5-0 data a",
          "837:         set reply [r XINFO STREAM x FULL]",
          "838:         assert_equal [dict get $reply entries-added] 5",
          "839:         assert_equal [dict get $reply recorded-first-entry-id] \"1-0\"",
          "841:         r XDEL x 2-0",
          "842:         set reply [r XINFO STREAM x FULL]",
          "843:         assert_equal [dict get $reply recorded-first-entry-id] \"1-0\"",
          "845:         r XDEL x 1-0",
          "846:         set reply [r XINFO STREAM x FULL]",
          "847:         assert_equal [dict get $reply recorded-first-entry-id] \"3-0\"",
          "849:         r XTRIM x MAXLEN = 2",
          "850:         set reply [r XINFO STREAM x FULL]",
          "851:         assert_equal [dict get $reply recorded-first-entry-id] \"4-0\"",
          "852:     }",
          "854:     test {Maxmimum XDEL ID behaves correctly} {",
          "855:         r DEL x",
          "856:         r XADD x 1-0 data a",
          "857:         r XADD x 2-0 data b",
          "858:         r XADD x 3-0 data c",
          "860:         set reply [r XINFO STREAM x FULL]",
          "861:         assert_equal [dict get $reply max-deleted-entry-id] \"0-0\"",
          "863:         r XDEL x 2-0",
          "864:         set reply [r XINFO STREAM x FULL]",
          "865:         assert_equal [dict get $reply max-deleted-entry-id] \"2-0\"",
          "867:         r XDEL x 1-0",
          "868:         set reply [r XINFO STREAM x FULL]",
          "869:         assert_equal [dict get $reply max-deleted-entry-id] \"2-0\"",
          "870:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "796:         waitForBgrewriteaof r",
          "797:         r debug loadaof",
          "798:         assert {[dict get [r xinfo stream mystream] length] == 1}",
          "800:     }",
          "801: }",
          "",
          "[Removed Lines]",
          "799:         assert {[dict get [r xinfo stream mystream] last-generated-id] == \"2-2\"}",
          "",
          "[Added Lines]",
          "893:         assert_equal [dict get [r xinfo stream mystream] last-generated-id] \"2-2\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
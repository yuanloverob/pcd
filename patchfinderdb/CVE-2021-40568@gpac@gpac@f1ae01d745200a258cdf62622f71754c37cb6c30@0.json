{
  "cve_id": "CVE-2021-40568",
  "cve_desc": "A buffer overflow vulnerability exists in Gpac through 1.0.1 via a malformed MP4 file in the svc_parse_slice function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",
  "repo": "gpac/gpac",
  "patch_hash": "f1ae01d745200a258cdf62622f71754c37cb6c30",
  "patch_info": {
    "commit_hash": "f1ae01d745200a258cdf62622f71754c37cb6c30",
    "repo": "gpac/gpac",
    "commit_url": "https://github.com/gpac/gpac/commit/f1ae01d745200a258cdf62622f71754c37cb6c30",
    "files": [
      "src/media_tools/av_parsers.c"
    ],
    "message": "fixed #1900",
    "before_after_code_files": [
      "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c"
    ]
  },
  "patch_diff": {
    "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c": [
      "File: src/media_tools/av_parsers.c -> src/media_tools/av_parsers.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4690:  u32 bits = 0;",
      "4691:  for (code=0; !code; nb_lead++) {",
      "4692:   if (nb_lead>=32) {",
      "4701:   }",
      "4703:   code = gf_bs_read_int(bs, 1);",
      "4704:   bits++;",
      "4705:  }",
      "4707:  if (nb_lead) {",
      "4708:   u32 leads=1;",
      "4709:   val = gf_bs_read_int(bs, nb_lead);",
      "",
      "[Removed Lines]",
      "4695:    if (!gf_bs_available(bs)) {",
      "4696:     GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));",
      "4697:    } else {",
      "4698:     GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));",
      "4699:    }",
      "4700:    return 0;",
      "",
      "[Added Lines]",
      "4693:    break;",
      "4699:  if (nb_lead>=32) {",
      "4702:   if (!gf_bs_available(bs)) {",
      "4703:    GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));",
      "4704:   } else {",
      "4705:    GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));",
      "4706:   }",
      "4707:   return 0;",
      "4708:  }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "5785:  if (si->slice_type > 9) return -1;",
      "5787:  pps_id = gf_bs_read_ue_log(bs, \"pps_id\");",
      "5789:   return -1;",
      "5790:  si->pps = &avc->pps[pps_id];",
      "5791:  si->pps->id = pps_id;",
      "",
      "[Removed Lines]",
      "5788:  if (pps_id > 255)",
      "",
      "[Added Lines]",
      "5791:  if ((pps_id<0) || (pps_id > 255))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "020ca151321a9692a28e63c88f1dbbe9deca9813",
      "candidate_info": {
        "commit_hash": "020ca151321a9692a28e63c88f1dbbe9deca9813",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/020ca151321a9692a28e63c88f1dbbe9deca9813",
        "files": [
          "src/media_tools/av_parsers.c",
          "testsuite"
        ],
        "message": "cleanup of exp-golomb read for safer eos detection",
        "before_after_code_files": [
          "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c"
          ],
          "candidate": [
            "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c"
          ]
        }
      },
      "candidate_diff": {
        "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c": [
          "File: src/media_tools/av_parsers.c -> src/media_tools/av_parsers.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4680: #ifndef GPAC_DISABLE_AV_PARSERS",
          "4702: u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3)",
          "4703: {",
          "4717:    return 0;",
          "4718:   }",
          "4721:  }",
          "4726:  if (fname) {",
          "4728:  }",
          "4729:  return val;",
          "4730: }",
          "4731: #define gf_bs_read_ue_log_idx2(_bs, _fname, _idx1, _idx2) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx1, (s32) _idx2, -1)",
          "4732: #define gf_bs_read_ue_log_idx(_bs, _fname, _idx) gf_bs_read_ue_log_idx3(_bs, _fname, (s32) _idx, -1, -1)",
          "4733: #define gf_bs_read_ue_log(_bs, _fname) gf_bs_read_ue_log_idx3(_bs, _fname, -1, -1, -1)",
          "",
          "[Removed Lines]",
          "4683: static u8 avc_golomb_bits[256] = {",
          "4684:  8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3,",
          "4685:  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2,",
          "4686:  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,",
          "4687:  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1,",
          "4688:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
          "4689:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
          "4690:  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,",
          "4691:  1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4692:  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4693:  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4694:  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4695:  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4696:  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4697:  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4698:  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
          "4699:  0",
          "4700: };",
          "4704:  u8 coded;",
          "4705:  u32 val;",
          "4706:  u32 bits = 0, read = 0;",
          "4707:  while (1) {",
          "4708:   u32 nb_bits = gf_bs_bits_available(bs);",
          "4709:   if (nb_bits>8) nb_bits = 8;",
          "4711:   read = gf_bs_peek_bits(bs, 8, 0);",
          "4712:   if (read) break;",
          "4714:   if (!gf_bs_available(bs)) {",
          "4716:    GF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (\"[AVC/HEVC] Not enough bits in bitstream !!\\n\"));",
          "4719:   gf_bs_read_int(bs, 8);",
          "4720:   bits += 8;",
          "4722:  coded = avc_golomb_bits[read];",
          "4723:  gf_bs_read_int(bs, coded);",
          "4724:  bits += coded;",
          "4725:  val = gf_bs_read_int(bs, bits + 1) - 1;",
          "4727:   gf_bs_log_idx(bs, bits+1, fname, val, idx1, idx2, idx3);",
          "",
          "[Added Lines]",
          "4684:  u32 val=0, code;",
          "4685:  s32 nb_lead = -1;",
          "4686:  u32 bits = 0;",
          "4687:  for (code=0; !code; nb_lead++) {",
          "4688:   if (nb_lead>=32) {",
          "4691:    if (!gf_bs_available(bs)) {",
          "4692:     GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));",
          "4693:    } else {",
          "4694:     GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));",
          "4695:    }",
          "4699:   code = gf_bs_read_int(bs, 1);",
          "4700:   bits++;",
          "4701:  }",
          "4703:  if (nb_lead) {",
          "4704:   val = gf_bs_read_int(bs, nb_lead);",
          "4705:   val += (1 << nb_lead) - 1;",
          "4706:   bits += nb_lead;",
          "4710:   gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9c74581c7827a6e1aea0f0a6f787ae22b4331a12",
      "candidate_info": {
        "commit_hash": "9c74581c7827a6e1aea0f0a6f787ae22b4331a12",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/9c74581c7827a6e1aea0f0a6f787ae22b4331a12",
        "files": [
          "include/gpac/bitstream.h",
          "include/gpac/internal/media_dev.h",
          "src/filters/bs_agg.c",
          "src/filters/bs_split.c",
          "src/filters/inspect.c",
          "src/filters/reframe_nalu.c",
          "src/isomedia/avc_ext.c",
          "src/media_tools/av_parsers.c",
          "src/odf/descriptors.c",
          "src/utils/bitstream.c"
        ],
        "message": "fixed #2064",
        "before_after_code_files": [
          "include/gpac/bitstream.h||include/gpac/bitstream.h",
          "include/gpac/internal/media_dev.h||include/gpac/internal/media_dev.h",
          "src/filters/bs_agg.c||src/filters/bs_agg.c",
          "src/filters/bs_split.c||src/filters/bs_split.c",
          "src/filters/inspect.c||src/filters/inspect.c",
          "src/filters/reframe_nalu.c||src/filters/reframe_nalu.c",
          "src/isomedia/avc_ext.c||src/isomedia/avc_ext.c",
          "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c",
          "src/odf/descriptors.c||src/odf/descriptors.c",
          "src/utils/bitstream.c||src/utils/bitstream.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c"
          ],
          "candidate": [
            "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c"
          ]
        }
      },
      "candidate_diff": {
        "include/gpac/bitstream.h||include/gpac/bitstream.h": [
          "File: include/gpac/bitstream.h -> include/gpac/bitstream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "625: u64 gf_bs_get_cookie(GF_BitStream *bs);",
          "629: #ifdef __cplusplus",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "629: \\brief Marks overflow access",
          "631: Marks the bitstream as overflown (reading outside of buffer range). Marking is done automatically when reading but can be forced using this function.",
          "633: \\param bs the target bitstream",
          "634: \\param reset if GF_TRUE, reset overflown state, otherwise mark as overflown",
          "636: void gf_bs_mark_overflow(GF_BitStream *bs, Bool reset);",
          "639: \\brief Gets overflow state",
          "641: Gets overflow state of the bitstream",
          "642: \\param bs the target bitstream",
          "643: \\return 2 if an overflow was marked by user using \\ref gf_bs_mark_overflow, 1 if an overflow occured, 0 otherwise",
          "645: u32 gf_bs_is_overflow(GF_BitStream *bs);",
          "",
          "---------------"
        ],
        "include/gpac/internal/media_dev.h||include/gpac/internal/media_dev.h": [
          "File: include/gpac/internal/media_dev.h -> include/gpac/internal/media_dev.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "897:  Bool mem_mode;",
          "899:  GF_BitStream *bs;",
          "901:  u8 *frame_obus;",
          "902:  u32 frame_obus_alloc;",
          "",
          "[Removed Lines]",
          "900:  Bool bs_overread, unframed;",
          "",
          "[Added Lines]",
          "900:  Bool unframed;",
          "",
          "---------------"
        ],
        "src/filters/bs_agg.c||src/filters/bs_agg.c": [
          "File: src/filters/bs_agg.c -> src/filters/bs_agg.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "440: {",
          "441:  u32 size, pck_size, i, count, tot_size=0, nb_done=0;",
          "442:  u64 min_dts = GF_FILTER_NO_TS;",
          "444:  GF_Err process_error = GF_OK;",
          "445:  Bool has_svc_prefix = GF_FALSE;",
          "447:  count = gf_list_count(pctx->ipids);",
          "448:  for (i=0; i<count; i++) {",
          "449:   u64 ts;",
          "",
          "[Removed Lines]",
          "443:  u32 min_timescale;",
          "",
          "[Added Lines]",
          "443:  u32 min_timescale, min_nal_size;",
          "447:  min_nal_size = codec_type ? 2 : 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "517:     e = GF_NON_COMPLIANT_BITSTREAM;",
          "518:     break;",
          "519:    }",
          "522:    if (codec_type==0) {",
          "523:     nal_type = data[size] & 0x1F;",
          "524:     if ((nal_type == GF_AVC_NALU_SVC_PREFIX_NALU) || (nal_type==GF_AVC_NALU_SVC_SLICE)) {",
          "525:      has_svc_prefix = GF_TRUE;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "522:    if (nal_size < min_nal_size) {",
          "523:     GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[BSAgg] Invalid NAL size %d but mn size %d\\n\", nal_size, min_nal_size));",
          "524:     e = GF_NON_COMPLIANT_BITSTREAM;",
          "525:     break;",
          "526:    }",
          "532:      if (nal_size < 4) {",
          "533:       GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[BSAgg] Invalid NAL size %d but mn size 4\\n\", nal_size));",
          "534:       e = GF_NON_COMPLIANT_BITSTREAM;",
          "535:       break;",
          "536:      }",
          "",
          "---------------"
        ],
        "src/filters/bs_split.c||src/filters/bs_split.c": [
          "File: src/filters/bs_split.c -> src/filters/bs_split.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1015: static GF_Err nalu_split_packet(BSSplitCtx *ctx, BSSplitIn *pctx, GF_FilterPacket *pck, u32 codec_type)",
          "1016: {",
          "1018:  GF_Err e;",
          "1019:  u64 pck_ts;",
          "1020:  Bool has_svc_prefix = GF_FALSE;",
          "",
          "[Removed Lines]",
          "1017:  u32 size, pck_size;",
          "",
          "[Added Lines]",
          "1017:  u32 size, pck_size, min_nal_size;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1034:  if (!pctx->first_ts_plus_one) {",
          "1035:   pctx->first_ts_plus_one = pck_ts+1;",
          "1036:  }",
          "1038:  size=0;",
          "1039:  while (size<pck_size) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1037:  min_nal_size = codec_type ? 2 : 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1055:    e = GF_NON_COMPLIANT_BITSTREAM;",
          "1056:    break;",
          "1057:   }",
          "1060:   if (codec_type==0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1059:   if (nal_size < min_nal_size) {",
          "1060:    GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[BSSplit] Invalid NAL size %d but mn size %d\\n\", nal_size, min_nal_size));",
          "1061:    e = GF_NON_COMPLIANT_BITSTREAM;",
          "1062:    break;",
          "1063:   }",
          "",
          "---------------"
        ],
        "src/filters/inspect.c||src/filters/inspect.c": [
          "File: src/filters/inspect.c -> src/filters/inspect.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "575:  if (hevc) {",
          "576: #ifndef GPAC_DISABLE_HEVC",
          "579:    gf_fprintf(dump, \"error=\\\"invalid nal size 1\\\"/>\\n\");",
          "580:    return;",
          "581:   }",
          "",
          "[Removed Lines]",
          "578:   if (ptr_size==1) {",
          "",
          "[Added Lines]",
          "578:   if (ptr_size<=1) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "863:  if (vvc) {",
          "864:   u8 lid, tid;",
          "866:   if (full_bs_dump) {",
          "867:    vvc->parse_mode = 2;",
          "868:    if (pctx) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "866:   if (ptr_size<=1) {",
          "867:    gf_fprintf(dump, \"error=\\\"invalid nal size 1\\\"/>\\n\");",
          "868:    return;",
          "869:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1015:  }",
          "1018:  type = ptr[0] & 0x1F;",
          "1019:  nal_ref_idc = ptr[0] & 0x60;",
          "1020:  nal_ref_idc>>=5;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1023:  if (!ptr_size) {",
          "1024:   gf_fprintf(dump, \"error=\\\"invalid nal size 1\\\"/>\\n\");",
          "1025:   return;",
          "1026:  }",
          "",
          "---------------"
        ],
        "src/filters/reframe_nalu.c||src/filters/reframe_nalu.c": [
          "File: src/filters/reframe_nalu.c -> src/filters/reframe_nalu.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2159:  u8 nal_unit_type, temporal_id, layer_id;",
          "2162:  gf_bs_reassign_buffer(ctx->bs_r, data, size);",
          "2163:  res = gf_hevc_parse_nalu_bs(ctx->bs_r, ctx->hevc_state, &nal_unit_type, &temporal_id, &layer_id);",
          "2164:  ctx->nb_nalus++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2162:  if (size<2) return -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2333:  u8 nal_unit_type, temporal_id, layer_id;",
          "2336:  gf_bs_reassign_buffer(ctx->bs_r, data, size);",
          "2337:  res = gf_vvc_parse_nalu_bs(ctx->bs_r, ctx->vvc_state, &nal_unit_type, &temporal_id, &layer_id);",
          "2338:  ctx->nb_nalus++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2338:  if (size<2) return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2510:  s32 ps_idx = 0;",
          "2511:  s32 res = 0;",
          "2513:  gf_bs_reassign_buffer(ctx->bs_r, data, size);",
          "2515:  res = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2516:  if (!size) return -1;",
          "",
          "---------------"
        ],
        "src/isomedia/avc_ext.c||src/isomedia/avc_ext.c": [
          "File: src/isomedia/avc_ext.c -> src/isomedia/avc_ext.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2820:    }",
          "2821:   }",
          "2822: #endif",
          "2824:   return GF_OK;",
          "2825:  }",
          "2826:  ISOM_DECREASE_SIZE(ptr, 4)",
          "",
          "[Removed Lines]",
          "2823:   GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"AVCC: invalid syntax for REXT profile, patching.\\n\"));",
          "",
          "[Added Lines]",
          "2824:   GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[isom/avcc] Missing REXT profile signaling, patching.\\n\"));",
          "",
          "---------------"
        ],
        "src/media_tools/av_parsers.c||src/media_tools/av_parsers.c": [
          "File: src/media_tools/av_parsers.c -> src/media_tools/av_parsers.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1921:  e = gf_bs_seek(bs, pos + ivf_frame_size - 1);",
          "1922:  if (e) return e;",
          "1924:  byte = gf_bs_read_u8(bs);",
          "1925:  if ((byte & 0xe0) != 0xc0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1924:  gf_bs_mark_overflow(bs, GF_TRUE);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1944: exit:",
          "1945:  gf_bs_seek(bs, pos);",
          "1946:  return e;",
          "1947: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1949:  if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2690:  u64 tusize, sz;",
          "2691:  if (!bs || !state) return GF_BAD_PARAM;",
          "2694:  tusize = sz = gf_av1_leb128_read(bs, NULL);",
          "2695:  tupos = gf_bs_get_position(bs);",
          "2696:  if (!sz) {",
          "",
          "[Removed Lines]",
          "2693:  state->bs_overread = GF_FALSE;",
          "",
          "[Added Lines]",
          "2698:  gf_bs_mark_overflow(bs, GF_TRUE);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2703:   u8 Leb128Bytes = 0;",
          "2704:   u64 frame_unit_size = gf_av1_leb128_read(bs, &Leb128Bytes);",
          "2707:    return GF_BUFFER_TOO_SMALL;",
          "2708:   }",
          "2709:   if (sz < Leb128Bytes + frame_unit_size) {",
          "",
          "[Removed Lines]",
          "2706:   if (state->bs_overread) {",
          "",
          "[Added Lines]",
          "2711:   if (gf_bs_is_overflow(bs)) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2716:   while (frame_unit_size > 0) {",
          "2717:    u64 pos, obu_size = gf_av1_leb128_read(bs, &Leb128Bytes);",
          "2720:     return GF_BUFFER_TOO_SMALL;",
          "2721:    }",
          "2722:    if (frame_unit_size < Leb128Bytes + obu_size) {",
          "",
          "[Removed Lines]",
          "2719:    if (state->bs_overread) {",
          "",
          "[Added Lines]",
          "2724:    if (gf_bs_is_overflow(bs)) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "4120:  return av1_parse_tile_group(bs, state, obu_start, obu_size);",
          "4121: }",
          "4129: static void av1_parse_obu_metadata(AV1State *state, GF_BitStream *bs)",
          "4130: {",
          "4131:  u32 metadata_type = (u32)gf_av1_leb128_read(bs, NULL);",
          "",
          "[Removed Lines]",
          "4123: static void on_aom_av1_eos(void *_state)",
          "4124: {",
          "4125:  AV1State *state = (AV1State *)_state;",
          "4126:  state->bs_overread = GF_TRUE;",
          "4127: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "4156:  if (!bs || !obu_type || !state)",
          "4157:   return GF_BAD_PARAM;",
          "4162:  state->obu_extension_flag = state->obu_has_size_field = 0;",
          "4163:  state->temporal_id = state->spatial_id = 0;",
          "4164:  state->frame_state.uncompressed_header_bytes = 0;",
          "4165:  e = gf_av1_parse_obu_header(bs, obu_type, &state->obu_extension_flag, &state->obu_has_size_field, &state->temporal_id, &state->spatial_id);",
          "4166:  if (e)",
          "4167:   return e;",
          "",
          "[Removed Lines]",
          "4159:  state->bs_overread = GF_FALSE;",
          "4160:  gf_bs_set_eos_callback(bs, on_aom_av1_eos, state);",
          "",
          "[Added Lines]",
          "4158:  gf_bs_mark_overflow(bs, GF_TRUE);",
          "4164:  if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4180:   }",
          "4181:  }",
          "4182:  hdr_size = (u32)(gf_bs_get_position(bs) - pos);",
          "4184:   gf_bs_seek(bs, pos);",
          "4185:   return GF_BUFFER_TOO_SMALL;",
          "4186:  }",
          "",
          "[Removed Lines]",
          "4183:  if ((gf_bs_available(bs) < *obu_size) || state->bs_overread) {",
          "",
          "[Added Lines]",
          "4182:  if (gf_bs_is_overflow(bs) || (gf_bs_available(bs) < *obu_size) ) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4210:  switch (*obu_type) {",
          "4211:  case OBU_SEQUENCE_HEADER:",
          "4212:   av1_parse_sequence_header_obu(bs, state);",
          "4214:    GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Sequence header parsing consumed too many bytes !\\n\"));",
          "4215:    e = GF_NON_COMPLIANT_BITSTREAM;",
          "4216:   }",
          "",
          "[Removed Lines]",
          "4213:   if (gf_bs_get_position(bs) > pos + *obu_size) {",
          "",
          "[Added Lines]",
          "4212:   if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) > pos + *obu_size)) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4220:  case OBU_METADATA:",
          "4221:   av1_parse_obu_metadata(state, bs);",
          "4222:   gf_bs_seek(bs, pos + *obu_size);",
          "4223:   break;",
          "4225:  case OBU_FRAME_HEADER:",
          "4226:  case OBU_REDUNDANT_FRAME_HEADER:",
          "4227:   if (state->config) {",
          "4228:    av1_parse_frame_header(bs, state);",
          "4230:     GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Frame header parsing consumed too many bytes !\\n\"));",
          "4231:     e = GF_NON_COMPLIANT_BITSTREAM;",
          "4232:    }",
          "",
          "[Removed Lines]",
          "4229:    if (gf_bs_get_position(bs) > pos + *obu_size) {",
          "",
          "[Added Lines]",
          "4222:   if (gf_bs_is_overflow(bs)) e = GF_NON_COMPLIANT_BITSTREAM;",
          "4229:    if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) > pos + *obu_size)) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "4235:   break;",
          "4236:  case OBU_FRAME:",
          "4237:   e = av1_parse_frame(bs, state, pos, *obu_size);",
          "4239:    GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Frame parsing did not consume the right number of bytes !\\n\"));",
          "4240:    e = GF_NON_COMPLIANT_BITSTREAM;",
          "4241:   }",
          "",
          "[Removed Lines]",
          "4238:   if (gf_bs_get_position(bs) != pos + *obu_size) {",
          "",
          "[Added Lines]",
          "4238:   if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) != pos + *obu_size)) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4244:  case OBU_TILE_GROUP:",
          "4245:   if (state->config) {",
          "4246:    e = av1_parse_tile_group(bs, state, pos, *obu_size);",
          "4248:     GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[AV1] Tile group parsing did not consume the right number of bytes !\\n\"));",
          "4249:     e = GF_NON_COMPLIANT_BITSTREAM;",
          "4250:    }",
          "",
          "[Removed Lines]",
          "4247:    if (gf_bs_get_position(bs) != pos + *obu_size) {",
          "",
          "[Added Lines]",
          "4247:    if (gf_bs_is_overflow(bs) || (gf_bs_get_position(bs) != pos + *obu_size)) {",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4733:  }",
          "4735:  if (nb_lead>=32) {",
          "4742:   }",
          "4743:   return 0;",
          "4744:  }",
          "",
          "[Removed Lines]",
          "4738:   if (!gf_bs_available(bs)) {",
          "4739:    GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));",
          "4740:   } else {",
          "4741:    GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));",
          "",
          "[Added Lines]",
          "4736:   if (gf_bs_is_overflow(bs)<2) {",
          "4739:    if (!gf_bs_available(bs)) {",
          "4740:     GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] exp-golomb read failed, not enough bits in bitstream !\\n\"));",
          "4741:    } else {",
          "4742:     GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\\n\", nb_lead));",
          "4743:    }",
          "4744:    gf_bs_mark_overflow(bs, GF_FALSE);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "6095:  AVCSliceInfo n_state;",
          "6097:  gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);",
          "6099:  nal_hdr = gf_bs_read_u8(bs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6101:  if (!gf_bs_available(bs)) return -1;",
          "6102:  gf_bs_mark_overflow(bs, GF_TRUE);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "6115:  case GF_AVC_NALU_SVC_SLICE:",
          "6116:   SVC_ReadNal_header_extension(bs, &n_state.svc_nalhdr);",
          "6119:   if (avc->s_info.nal_ref_idc) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6122:   if (gf_bs_is_overflow(bs)) return -1;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "6132:  case GF_AVC_NALU_SVC_PREFIX_NALU:",
          "6133:   SVC_ReadNal_header_extension(bs, &avc->s_info.svc_nalhdr);",
          "6134:   return 0;",
          "6136:  case GF_AVC_NALU_IDR_SLICE:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6141:   if (gf_bs_is_overflow(bs)) return -1;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "6141:   slice = 1;",
          "6143:   ret = avc_parse_slice(bs, avc, idr_flag, &n_state);",
          "6144:   if (ret < 0) return ret;",
          "6145:   ret = 0;",
          "6146:   if (",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6152:   if (gf_bs_is_overflow(bs)) ret = -1;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "6202:   break;",
          "6203:  case GF_AVC_NALU_SEQ_PARAM:",
          "6204:   avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 0, NULL, nal_hdr);",
          "6205:   if (avc->last_ps_idx < 0) return -1;",
          "6206:   return 0;",
          "6208:  case GF_AVC_NALU_PIC_PARAM:",
          "6209:   avc->last_ps_idx = gf_avc_read_pps_bs_internal(bs, avc, nal_hdr);",
          "6210:   if (avc->last_ps_idx < 0) return -1;",
          "6211:   return 0;",
          "6212:  case GF_AVC_NALU_SVC_SUBSEQ_PARAM:",
          "6213:   avc->last_ps_idx = gf_avc_read_sps_bs_internal(bs, avc, 1, NULL, nal_hdr);",
          "6214:   if (avc->last_ps_idx < 0) return -1;",
          "6215:   return 0;",
          "6216:  case GF_AVC_NALU_SEQ_PARAM_EXT:",
          "6217:   avc->last_ps_idx = (s32) gf_bs_read_ue(bs);",
          "6218:   if (avc->last_ps_idx < 0) return -1;",
          "6219:   return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6214:   if (gf_bs_is_overflow(bs)) return -1;",
          "6220:   if (gf_bs_is_overflow(bs)) return -1;",
          "6225:   if (gf_bs_is_overflow(bs)) return -1;",
          "6230:   if (gf_bs_is_overflow(bs)) return -1;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "8562:  HEVCSliceInfo n_state;",
          "8564:  gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);",
          "8566:  memcpy(&n_state, &hevc->s_info, sizeof(HEVCSliceInfo));",
          "8567:  if (!hevc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8578:  if (gf_bs_available(bs)<2) return -1;",
          "8580:  gf_bs_mark_overflow(bs, GF_TRUE);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "8629:   break;",
          "8630:  }",
          "8633:  if ((ret>0) && hevc->s_info.sps) {",
          "8634:   n_state.frame_num_offset_prev = hevc->s_info.frame_num_offset;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8648:  if (gf_bs_is_overflow(bs))",
          "8649:   ret = -1;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "8651:  GF_BitStream *bs = NULL;",
          "8652:  s32 ret = -1;",
          "8654:  if (!hevc) {",
          "8655:   if (nal_unit_type) (*nal_unit_type) = (data[0] & 0x7E) >> 1;",
          "8656:   if (layer_id) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8673:  if (size<2) return -1;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "11236:  VVCSliceInfo n_state;",
          "11238:  gf_bs_enable_emulation_byte_removal(bs, GF_TRUE);",
          "11240:  memcpy(&n_state, &vvc->s_info, sizeof(VVCSliceInfo));",
          "11241:  if (!vvc_parse_nal_header(bs, nal_unit_type, temporal_id, layer_id)) return -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11260:  if (gf_bs_available(bs)<2) return -1;",
          "11261:  gf_bs_mark_overflow(bs, GF_TRUE);",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "11322:   ret = 0;",
          "11323:   break;",
          "11324:  }",
          "11327:  if ((ret>0) && vvc->s_info.sps) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11348:  if (gf_bs_is_overflow(bs)) ret = -1;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "11344:  GF_BitStream *bs = NULL;",
          "11345:  s32 ret;",
          "11347:  if (!vvc) {",
          "11348:   if (nal_unit_type) (*nal_unit_type) = data[1] >> 3;",
          "11349:   if (layer_id) (*layer_id) = data[0] & 0x3f;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "11371:  if (size<2) return -1;",
          "",
          "---------------"
        ],
        "src/odf/descriptors.c||src/odf/descriptors.c": [
          "File: src/odf/descriptors.c -> src/odf/descriptors.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "601:  gf_bs_read_int(bs, 3);",
          "602:  count = gf_bs_read_int(bs, 5);",
          "603:  for (i=0; i<count; i++) {",
          "606:   sl->data = (char*)gf_malloc(sizeof(char)*sl->size);",
          "607:   gf_bs_read_data(bs, sl->data, sl->size);",
          "608:   gf_list_add(avcc->sequenceParameterSets, sl);",
          "609:  }",
          "610:  count = gf_bs_read_int(bs, 8);",
          "611:  for (i=0; i<count; i++) {",
          "614:   sl->data = (char*)gf_malloc(sizeof(char)*sl->size);",
          "615:   gf_bs_read_data(bs, sl->data, sl->size);",
          "616:   gf_list_add(avcc->pictureParameterSets, sl);",
          "617:  }",
          "",
          "[Removed Lines]",
          "604:   GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));",
          "605:   sl->size = gf_bs_read_int(bs, 16);",
          "612:   GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));",
          "613:   sl->size = gf_bs_read_int(bs, 16);",
          "",
          "[Added Lines]",
          "604:   GF_NALUFFParam *sl;",
          "605:   u32 size = gf_bs_read_int(bs, 16);",
          "606:   if ((size>gf_bs_available(bs)) || (size<2)) {",
          "607:    GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AVC] Wrong param set size %d\\n\", size));",
          "608:    gf_odf_avc_cfg_del(avcc);",
          "609:    return NULL;",
          "610:   }",
          "611:   GF_SAFEALLOC(sl, GF_NALUFFParam );",
          "612:   if (!sl) {",
          "613:    gf_odf_avc_cfg_del(avcc);",
          "614:    return NULL;",
          "615:   }",
          "616:   sl->size = size;",
          "618:   if (!sl->data) {",
          "619:    gf_odf_avc_cfg_del(avcc);",
          "620:    return NULL;",
          "621:   }",
          "627:   GF_NALUFFParam *sl;",
          "628:   u32 size = gf_bs_read_int(bs, 16);",
          "629:   if ((size>gf_bs_available(bs)) || (size<2)) {",
          "630:    GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AVC] Wrong param set size %d\\n\", size));",
          "631:    gf_odf_avc_cfg_del(avcc);",
          "632:    return NULL;",
          "633:   }",
          "634:   GF_SAFEALLOC(sl, GF_NALUFFParam );",
          "635:   if (!sl) {",
          "636:    gf_odf_avc_cfg_del(avcc);",
          "637:    return NULL;",
          "638:   }",
          "639:   sl->size = size;",
          "641:   if (!sl->data) {",
          "642:    gf_odf_avc_cfg_del(avcc);",
          "643:    return NULL;",
          "644:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "627:   if (count) {",
          "628:    avcc->sequenceParameterSetExtensions = gf_list_new();",
          "629:    for (i=0; i<count; i++) {",
          "633:     gf_bs_read_data(bs, sl->data, sl->size);",
          "634:     gf_list_add(avcc->sequenceParameterSetExtensions, sl);",
          "635:    }",
          "",
          "[Removed Lines]",
          "630:     GF_NALUFFParam *sl = (GF_NALUFFParam *)gf_malloc(sizeof(GF_NALUFFParam));",
          "631:     sl->size = gf_bs_read_u16(bs);",
          "632:     sl->data = (char *)gf_malloc(sizeof(char) * sl->size);",
          "",
          "[Added Lines]",
          "660:     GF_NALUFFParam *sl;",
          "661:     u32 size = gf_bs_read_int(bs, 16);",
          "662:     if ((size>gf_bs_available(bs)) || (size<2)) {",
          "663:      GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AVC] Wrong param set size %d\\n\", size));",
          "664:      gf_odf_avc_cfg_del(avcc);",
          "665:      return NULL;",
          "666:     }",
          "667:     GF_SAFEALLOC(sl, GF_NALUFFParam );",
          "668:     if (!sl) {",
          "669:      gf_odf_avc_cfg_del(avcc);",
          "670:      return NULL;",
          "671:     }",
          "672:     sl->size = size;",
          "673:     sl->data = (char*)gf_malloc(sizeof(char)*sl->size);",
          "674:     if (!sl->data) {",
          "675:      gf_odf_avc_cfg_del(avcc);",
          "676:      return NULL;",
          "677:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1050:   for (j=0; j<nalucount; j++) {",
          "1051:    GF_NALUFFParam *sl;",
          "1052:    u32 size = gf_bs_read_int(bs, 16);",
          "1054:     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[HEVC] Wrong param set size %d\\n\", size));",
          "1055:     gf_odf_hevc_cfg_del(cfg);",
          "1056:     return NULL;",
          "",
          "[Removed Lines]",
          "1053:    if (size>gf_bs_available(bs)) {",
          "",
          "[Added Lines]",
          "1098:    if ((size>gf_bs_available(bs)) || (size<2)) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1330:   for (j=0; j<nalucount; j++) {",
          "1331:    GF_NALUFFParam *sl;",
          "1332:    u32 size = gf_bs_read_int(bs, 16);",
          "1334:     GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[VVC] Wrong param set size %d\\n\", size));",
          "1335:     gf_odf_vvc_cfg_del(cfg);",
          "1336:     return NULL;",
          "",
          "[Removed Lines]",
          "1333:    if (size>gf_bs_available(bs)) {",
          "",
          "[Added Lines]",
          "1378:    if ((size>gf_bs_available(bs)) || (size<2)) {",
          "",
          "---------------"
        ],
        "src/utils/bitstream.c||src/utils/bitstream.c": [
          "File: src/utils/bitstream.c -> src/utils/bitstream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "77:  void *log_udta;",
          "79:  u32 total_bits_read;",
          "80: };",
          "82: GF_Err gf_bs_reassign_buffer(GF_BitStream *bs, const u8 *buffer, u64 BufferSize)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "80:  u32 overflow_state;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "355:   u8 res;",
          "356:   if (bs->position >= bs->size) {",
          "357:    if (bs->EndOfStream) bs->EndOfStream(bs->par);",
          "358:    return 0;",
          "359:   }",
          "360:   res = bs->original[bs->position++];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "359:    if (!bs->overflow_state) bs->overflow_state = 1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "404: bs_eof:",
          "405:  if (bs->EndOfStream) {",
          "406:   bs->EndOfStream(bs->par);",
          "407:  } else {",
          "408:   GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));",
          "409:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "409:   if (!bs->overflow_state) bs->overflow_state = 1;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "613:   if (gf_bs_available(bs) * 8 < nBits-8) {",
          "614:    if (bs->EndOfStream) bs->EndOfStream(bs->par);",
          "615:    bs->position = bs->size;",
          "616:    return 0;",
          "617:   }",
          "618:   GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"Reading %d bits but max should be 64, skipping %d most significants bits\\n\", nBits, nBits-64));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "619:    if (!bs->overflow_state) bs->overflow_state = 1;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1324: GF_EXPORT",
          "1325: GF_Err gf_bs_seek(GF_BitStream *bs, u64 offset)",
          "1326: {",
          "1327:  if (bs->on_block_out) {",
          "1328:   GF_Err e;",
          "1329:   if (offset < bs->bytes_out) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1331:  bs->overflow_state = 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1706: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1714: void gf_bs_mark_overflow(GF_BitStream *bs, Bool reset)",
          "1715: {",
          "1716:  bs->overflow_state = reset ? 0 : 2;",
          "1717: }",
          "1718: u32 gf_bs_is_overflow(GF_BitStream *bs)",
          "1719: {",
          "1720:  return bs->overflow_state;",
          "1721: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
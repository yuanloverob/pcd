{
  "cve_id": "CVE-2020-27675",
  "cve_desc": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.",
  "repo": "torvalds/linux",
  "patch_hash": "073d0552ead5bfc7a3a9c01de590e924f11b5dd2",
  "patch_info": {
    "commit_hash": "073d0552ead5bfc7a3a9c01de590e924f11b5dd2",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2",
    "files": [
      "drivers/xen/events/events_base.c"
    ],
    "message": "xen/events: avoid removing an event channel while handling it\n\nToday it can happen that an event channel is being removed from the\nsystem while the event handling loop is active. This can lead to a\nrace resulting in crashes or WARN() splats when trying to access the\nirq_info structure related to the event channel.\n\nFix this problem by using a rwlock taken as reader in the event\nhandling loop and as writer when deallocating the irq_info structure.\n\nAs the observed problem was a NULL dereference in evtchn_from_irq()\nmake this function more robust against races by testing the irq_info\npointer to be not NULL before dereferencing it.\n\nAnd finally make all accesses to evtchn_to_irq[row][col] atomic ones\nin order to avoid seeing partial updates of an array element in irq\nhandling. Note that irq handling can be entered only for event channels\nwhich have been valid before, so any not populated row isn't a problem\nin this regard, as rows are only ever added and never removed.\n\nThis is XSA-331.\n\nCc: stable@vger.kernel.org\nReported-by: Marek Marczykowski-G\u00f3recki <marmarek@invisiblethingslab.com>\nReported-by: Jinoh Kang <luke1337@theori.io>\nSigned-off-by: Juergen Gross <jgross@suse.com>\nReviewed-by: Stefano Stabellini <sstabellini@kernel.org>\nReviewed-by: Wei Liu <wl@xen.org>",
    "before_after_code_files": [
      "drivers/xen/events/events_base.c||drivers/xen/events/events_base.c"
    ]
  },
  "patch_diff": {
    "drivers/xen/events/events_base.c||drivers/xen/events/events_base.c": [
      "File: drivers/xen/events/events_base.c -> drivers/xen/events/events_base.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "33: #include <linux/slab.h>",
      "34: #include <linux/irqnr.h>",
      "35: #include <linux/pci.h>",
      "37: #ifdef CONFIG_X86",
      "38: #include <asm/desc.h>",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "36: #include <linux/spinlock.h>",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "72: static DEFINE_MUTEX(irq_mapping_update_lock);",
      "74: static LIST_HEAD(xen_irq_list_head);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "82: static DEFINE_RWLOCK(evtchn_rwlock);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "105:  unsigned col;",
      "107:  for (col = 0; col < EVTCHN_PER_ROW; col++)",
      "109: }",
      "111: static void clear_evtchn_to_irq_all(void)",
      "",
      "[Removed Lines]",
      "108:   evtchn_to_irq[row][col] = -1;",
      "",
      "[Added Lines]",
      "126:   WRITE_ONCE(evtchn_to_irq[row][col], -1);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "142:   clear_evtchn_to_irq_row(row);",
      "143:  }",
      "146:  return 0;",
      "147: }",
      "",
      "[Removed Lines]",
      "145:  evtchn_to_irq[row][col] = irq;",
      "",
      "[Added Lines]",
      "163:  WRITE_ONCE(evtchn_to_irq[row][col], irq);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "152:   return -1;",
      "153:  if (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)",
      "154:   return -1;",
      "156: }",
      "",
      "[Removed Lines]",
      "155:  return evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];",
      "",
      "[Added Lines]",
      "173:  return READ_ONCE(evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)]);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "262: evtchn_port_t evtchn_from_irq(unsigned irq)",
      "263: {",
      "265:   return 0;",
      "268: }",
      "270: unsigned int irq_from_evtchn(evtchn_port_t evtchn)",
      "",
      "[Removed Lines]",
      "264:  if (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))",
      "267:  return info_for_irq(irq)->evtchn;",
      "",
      "[Added Lines]",
      "282:  const struct irq_info *info = NULL;",
      "284:  if (likely(irq < nr_irqs))",
      "285:   info = info_for_irq(irq);",
      "286:  if (!info)",
      "289:  return info->evtchn;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "440: static void xen_free_irq(unsigned irq)",
      "441: {",
      "442:  struct irq_info *info = info_for_irq(irq);",
      "444:  if (WARN_ON(!info))",
      "445:   return;",
      "447:  list_del(&info->list);",
      "449:  set_info_for_irq(irq, NULL);",
      "451:  WARN_ON(info->refcnt > 0);",
      "453:  kfree(info);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "465:  unsigned long flags;",
      "470:  write_lock_irqsave(&evtchn_rwlock, flags);",
      "478:  write_unlock_irqrestore(&evtchn_rwlock, flags);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "1233:  struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);",
      "1234:  int cpu = smp_processor_id();",
      "1236:  do {",
      "1237:   vcpu_info->evtchn_upcall_pending = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1263:  read_lock(&evtchn_rwlock);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "1245:  } while (vcpu_info->evtchn_upcall_pending);",
      "1246: }",
      "1248: void xen_evtchn_do_upcall(struct pt_regs *regs)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1276:  read_unlock(&evtchn_rwlock);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "88ca2521bd5b4e8b83743c01a2d4cb09325b51e9",
      "candidate_info": {
        "commit_hash": "88ca2521bd5b4e8b83743c01a2d4cb09325b51e9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/88ca2521bd5b4e8b83743c01a2d4cb09325b51e9",
        "files": [
          "drivers/xen/events/events_base.c"
        ],
        "message": "xen/events: Fix race in set_evtchn_to_irq\n\nThere is a TOCTOU issue in set_evtchn_to_irq. Rows in the evtchn_to_irq\nmapping are lazily allocated in this function. The check whether the row\nis already present and the row initialization is not synchronized. Two\nthreads can at the same time allocate a new row for evtchn_to_irq and\nadd the irq mapping to the their newly allocated row. One thread will\noverwrite what the other has set for evtchn_to_irq[row] and therefore\nthe irq mapping is lost. This will trigger a BUG_ON later in\nbind_evtchn_to_cpu:\n\n  INFO: pci 0000:1a:15.4: [1d0f:8061] type 00 class 0x010802\n  INFO: nvme 0000:1a:12.1: enabling device (0000 -> 0002)\n  INFO: nvme nvme77: 1/0/0 default/read/poll queues\n  CRIT: kernel BUG at drivers/xen/events/events_base.c:427!\n  WARN: invalid opcode: 0000 [#1] SMP NOPTI\n  WARN: Workqueue: nvme-reset-wq nvme_reset_work [nvme]\n  WARN: RIP: e030:bind_evtchn_to_cpu+0xc2/0xd0\n  WARN: Call Trace:\n  WARN:  set_affinity_irq+0x121/0x150\n  WARN:  irq_do_set_affinity+0x37/0xe0\n  WARN:  irq_setup_affinity+0xf6/0x170\n  WARN:  irq_startup+0x64/0xe0\n  WARN:  __setup_irq+0x69e/0x740\n  WARN:  ? request_threaded_irq+0xad/0x160\n  WARN:  request_threaded_irq+0xf5/0x160\n  WARN:  ? nvme_timeout+0x2f0/0x2f0 [nvme]\n  WARN:  pci_request_irq+0xa9/0xf0\n  WARN:  ? pci_alloc_irq_vectors_affinity+0xbb/0x130\n  WARN:  queue_request_irq+0x4c/0x70 [nvme]\n  WARN:  nvme_reset_work+0x82d/0x1550 [nvme]\n  WARN:  ? check_preempt_wakeup+0x14f/0x230\n  WARN:  ? check_preempt_curr+0x29/0x80\n  WARN:  ? nvme_irq_check+0x30/0x30 [nvme]\n  WARN:  process_one_work+0x18e/0x3c0\n  WARN:  worker_thread+0x30/0x3a0\n  WARN:  ? process_one_work+0x3c0/0x3c0\n  WARN:  kthread+0x113/0x130\n  WARN:  ? kthread_park+0x90/0x90\n  WARN:  ret_from_fork+0x3a/0x50\n\nThis patch sets evtchn_to_irq rows via a cmpxchg operation so that they\nwill be set only once. The row is now cleared before writing it to\nevtchn_to_irq in order to not create a race once the row is visible for\nother threads.\n\nWhile at it, do not require the page to be zeroed, because it will be\noverwritten with -1's in clear_evtchn_to_irq_row anyway.\n\nSigned-off-by: Maximilian Heyne <mheyne@amazon.de>\nFixes: d0b075ffeede (\"xen/events: Refactor evtchn_to_irq array to be dynamically allocated\")\nLink: https://lore.kernel.org/r/20210812130930.127134-1-mheyne@amazon.de\nReviewed-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>\nSigned-off-by: Boris Ostrovsky <boris.ostrovsky@oracle.com>",
        "before_after_code_files": [
          "drivers/xen/events/events_base.c||drivers/xen/events/events_base.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/xen/events/events_base.c||drivers/xen/events/events_base.c"
          ],
          "candidate": [
            "drivers/xen/events/events_base.c||drivers/xen/events/events_base.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/xen/events/events_base.c||drivers/xen/events/events_base.c": [
          "File: drivers/xen/events/events_base.c -> drivers/xen/events/events_base.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199: static DEFINE_PER_CPU(unsigned int, irq_epoch);",
          "202: {",
          "203:  unsigned col;",
          "205:  for (col = 0; col < EVTCHN_PER_ROW; col++)",
          "207: }",
          "209: static void clear_evtchn_to_irq_all(void)",
          "",
          "[Removed Lines]",
          "201: static void clear_evtchn_to_irq_row(unsigned row)",
          "206:   WRITE_ONCE(evtchn_to_irq[row][col], -1);",
          "",
          "[Added Lines]",
          "201: static void clear_evtchn_to_irq_row(int *evtchn_row)",
          "206:   WRITE_ONCE(evtchn_row[col], -1);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "213:  for (row = 0; row < EVTCHN_ROW(xen_evtchn_max_channels()); row++) {",
          "214:   if (evtchn_to_irq[row] == NULL)",
          "215:    continue;",
          "217:  }",
          "218: }",
          "",
          "[Removed Lines]",
          "216:   clear_evtchn_to_irq_row(row);",
          "",
          "[Added Lines]",
          "216:   clear_evtchn_to_irq_row(evtchn_to_irq[row]);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "221: {",
          "222:  unsigned row;",
          "223:  unsigned col;",
          "225:  if (evtchn >= xen_evtchn_max_channels())",
          "226:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224:  int *evtchn_row;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "233:   if (irq == -1)",
          "234:    return 0;",
          "238:    return -ENOMEM;",
          "241:  }",
          "243:  WRITE_ONCE(evtchn_to_irq[row][col], irq);",
          "",
          "[Removed Lines]",
          "236:   evtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);",
          "237:   if (evtchn_to_irq[row] == NULL)",
          "240:   clear_evtchn_to_irq_row(row);",
          "",
          "[Added Lines]",
          "237:   evtchn_row = (int *) __get_free_pages(GFP_KERNEL, 0);",
          "238:   if (evtchn_row == NULL)",
          "241:   clear_evtchn_to_irq_row(evtchn_row);",
          "247:   if (cmpxchg(&evtchn_to_irq[row], NULL, evtchn_row) != NULL)",
          "248:    free_page((unsigned long) evtchn_row);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
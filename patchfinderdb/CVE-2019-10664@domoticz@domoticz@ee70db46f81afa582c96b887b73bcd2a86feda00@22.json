{
  "cve_id": "CVE-2019-10664",
  "cve_desc": "Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.",
  "repo": "domoticz/domoticz",
  "patch_hash": "ee70db46f81afa582c96b887b73bcd2a86feda00",
  "patch_info": {
    "commit_hash": "ee70db46f81afa582c96b887b73bcd2a86feda00",
    "repo": "domoticz/domoticz",
    "commit_url": "https://github.com/domoticz/domoticz/commit/ee70db46f81afa582c96b887b73bcd2a86feda00",
    "files": [
      "main/WebServer.cpp"
    ],
    "message": "Fixed possible SQL Injection Vulnerability (Thanks to Fabio Carretto!)",
    "before_after_code_files": [
      "main/WebServer.cpp||main/WebServer.cpp"
    ]
  },
  "patch_diff": {
    "main/WebServer.cpp||main/WebServer.cpp": [
      "File: main/WebServer.cpp -> main/WebServer.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "10772:     return;",
      "10773:    }",
      "10774:    std::vector<std::vector<std::string> > result;",
      "10776:    if (result.empty())",
      "10777:     return;",
      "10778:    reply::set_content(&rep, result[0][0].begin(), result[0][0].end());",
      "",
      "[Removed Lines]",
      "10775:    result = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());",
      "",
      "[Added Lines]",
      "10775:    result = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1cfba8b4a57acef11719ac2e5e16ba5ae78def59",
      "candidate_info": {
        "commit_hash": "1cfba8b4a57acef11719ac2e5e16ba5ae78def59",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/1cfba8b4a57acef11719ac2e5e16ba5ae78def59",
        "files": [
          "hardware/I2C.cpp",
          "hardware/I2C.h"
        ],
        "message": "Corrected oversampling for I2C/BME280",
        "before_after_code_files": [
          "hardware/I2C.cpp||hardware/I2C.cpp",
          "hardware/I2C.h||hardware/I2C.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/I2C.cpp||hardware/I2C.cpp": [
          "File: hardware/I2C.cpp -> hardware/I2C.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "68: #define BMEx8x_CtrlMeas    0xF4",
          "69: #define BMEx8x_Config    0xF5",
          "71: #define BMEx8x_Hum_MSB    0xFD",
          "72: #define BMEx8x_Hum_LSB    0xFE",
          "74: #define BMEx8x_OverSampling_Temp 2",
          "76: #define BMEx8x_OverSampling_Mode 1",
          "80: const unsigned char BMPx8x_OverSampling = 3;",
          "",
          "[Removed Lines]",
          "75: #define BMEx8x_OverSampling_hum  3",
          "77: #define BMEx8x_OverSampling_Control BMEx8x_OverSampling_Temp<<5 | BMEx8x_OverSampling_hum<<2 | BMEx8x_OverSampling_Mode",
          "",
          "[Added Lines]",
          "71: #define BMEx8x_Control_Hum   0xF2",
          "77: #define BMEx8x_OverSampling_Hum  2",
          "78: #define BMEx8x_OverSampling_Pres 2",
          "80: #define BMEx8x_OverSampling_Control BMEx8x_OverSampling_Temp<<5 | BMEx8x_OverSampling_Pres<<2 | BMEx8x_OverSampling_Mode",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "582: #endif",
          "583: }",
          "585: int I2C::WriteCmd(int fd, uint8_t devAction)",
          "586: {",
          "587: #ifndef HAVE_LINUX_I2C",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "588: int I2C::WriteCmdAddr(const int fd, const uint8_t CmdAddr, const uint8_t devAction)",
          "589: {",
          "590: #ifndef HAVE_LINUX_I2C",
          "591:  return -1;",
          "592: #else",
          "593:  int rc;",
          "594:  struct i2c_rdwr_ioctl_data messagebuffer;",
          "595:  uint8_t datatosend[2];",
          "596:  struct i2c_msg bme_write_reg[1] = {",
          "597:   { BMEx8x_I2CADDR, 0, 2, datatosend }",
          "598:  };",
          "599:  datatosend[0] = CmdAddr;",
          "600:  datatosend[1] = devAction;",
          "603:  messagebuffer.msgs = bme_write_reg;           //load the 'write__reg' message into the buffer",
          "604:  messagebuffer.nmsgs = 1;                  //One message/action",
          "605:  rc = ioctl(fd, I2C_RDWR, &messagebuffer); //Send the buffer to the bus and returns a send status",
          "606:  if (rc < 0) {",
          "607:   return rc;",
          "608:  }",
          "609:  return 0;",
          "610: #endif",
          "611: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1314: bool I2C::readBME280All(const int fd, float &temp, float &pressure, int &humidity)",
          "1315: {",
          "1316:  if (WriteCmd(fd, BMEx8x_OverSampling_Control) != 0) {",
          "1317:   _log.Log(LOG_ERROR, \"%s: Error Writing to I2C register\", szI2CTypeNames[m_dev_type]);",
          "1318:   return false;",
          "1319:  }",
          "1321:  uint8_t cal1[24] = { 0 };",
          "1322:  uint8_t cal2[1] = { 0 };",
          "1323:  uint8_t cal3[7] = { 0 };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1345:  WriteCmdAddr(fd, BMEx8x_Control_Hum, BMEx8x_OverSampling_Hum);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1364:  int8_t dig_H6 = getChar(cal3, 6);",
          "1367:  uint8_t data[8] = { 0 };",
          "1368:  if (ReadInt(fd, data, BMEx8x_Data, 8) != 0) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1399:  double wait_time = 1.25 + (2.3 * BMEx8x_OverSampling_Temp) + ((2.3 * BMEx8x_OverSampling_Pres) + 0.575) + ((2.3 * BMEx8x_OverSampling_Hum) + 0.575);",
          "1400:  int wait_time_ms = (int)rint(wait_time) + 1;",
          "1401:  sleep_milliseconds(wait_time_ms);",
          "",
          "---------------"
        ],
        "hardware/I2C.h||hardware/I2C.h": [
          "File: hardware/I2C.h -> hardware/I2C.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:  int ReadInt(int fd, uint8_t *devValues, uint8_t startReg, uint8_t bytesToRead);",
          "43:  int WriteCmd(int fd, uint8_t devAction);",
          "45: private:",
          "46:  std::shared_ptr<std::thread> m_thread;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "44:  int WriteCmdAddr(const int fd, const uint8_t CmdAddr, const uint8_t devAction);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ddcd3f350d016ec338fcfd6254ec653a4cf388f0",
      "candidate_info": {
        "commit_hash": "ddcd3f350d016ec338fcfd6254ec653a4cf388f0",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/ddcd3f350d016ec338fcfd6254ec653a4cf388f0",
        "files": [
          "main/SQLHelper.cpp"
        ],
        "message": "Fixed incorrect P1 usage report in notifications",
        "before_after_code_files": [
          "main/SQLHelper.cpp||main/SQLHelper.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "main/SQLHelper.cpp||main/SQLHelper.cpp": [
          "File: main/SQLHelper.cpp -> main/SQLHelper.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "6336:    if (devType == pTypeP1Power)",
          "6337:    {",
          "6339:     m_notifications.CheckAndHandleNotification(ID, devname, devType, subType, NTYPE_TODAYENERGY, musage);",
          "6340:    }",
          "",
          "[Removed Lines]",
          "6338:     float musage = (total_real[0] + total_real[2]) / EnergyDivider;",
          "",
          "[Added Lines]",
          "6338:     float musage = (total_real[0] + total_real[4]) / EnergyDivider;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "3ab8387797255e16d9477377c4e906210067ea1c",
      "candidate_info": {
        "commit_hash": "3ab8387797255e16d9477377c4e906210067ea1c",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/3ab8387797255e16d9477377c4e906210067ea1c",
        "files": [
          "hardware/EcoDevices.cpp",
          "hardware/EvohomeBase.h",
          "hardware/Honeywell.cpp",
          "hardware/I2C.cpp",
          "hardware/OpenZWave.cpp",
          "hardware/eHouse/EhouseUdpListener.cpp",
          "hardware/eHouseTCP.cpp",
          "hardware/plugins/PluginTransports.cpp",
          "hardware/plugins/PythonObjects.cpp"
        ],
        "message": "Some code refactoring, initialization and fixing possible crash and subtype check fix",
        "before_after_code_files": [
          "hardware/EcoDevices.cpp||hardware/EcoDevices.cpp",
          "hardware/EvohomeBase.h||hardware/EvohomeBase.h",
          "hardware/Honeywell.cpp||hardware/Honeywell.cpp",
          "hardware/I2C.cpp||hardware/I2C.cpp",
          "hardware/OpenZWave.cpp||hardware/OpenZWave.cpp",
          "hardware/eHouse/EhouseUdpListener.cpp||hardware/eHouse/EhouseUdpListener.cpp",
          "hardware/eHouseTCP.cpp||hardware/eHouseTCP.cpp",
          "hardware/plugins/PluginTransports.cpp||hardware/plugins/PluginTransports.cpp",
          "hardware/plugins/PythonObjects.cpp||hardware/plugins/PythonObjects.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/EcoDevices.cpp||hardware/EcoDevices.cpp": [
          "File: hardware/EcoDevices.cpp -> hardware/EcoDevices.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "53: #define RELEASE_RT2 29",
          "55: CEcoDevices::CEcoDevices(const int ID, const std::string &IPAddress, const unsigned short usIPPort,",
          "60: {",
          "61:  m_HwdID = ID;",
          "62:  m_usIPPort = usIPPort;",
          "63:  m_iModel = model;",
          "66:  m_iDataTimeout = (datatimeout >= 300 || datatimeout == 0) ? 300 : datatimeout;",
          "69:  m_iRateLimit = (ratelimit < 2) ? 2 : ratelimit;",
          "75:  Init();",
          "76: }",
          "",
          "[Removed Lines]",
          "56:  const std::string &username, const std::string &password, const int datatimeout, const int model, const int ratelimit):",
          "57: m_szIPAddress(IPAddress),",
          "58: m_username(username),",
          "59: m_password(password)",
          "73:         if (m_iRateLimit > m_iDataTimeout)   m_iRateLimit = m_iDataTimeout;",
          "",
          "[Added Lines]",
          "56:  const std::string &username, const std::string &password, const int datatimeout, const int model, const int ratelimit) :",
          "57:  m_szIPAddress(IPAddress),",
          "58:  m_username(username),",
          "59:  m_password(password)",
          "73:  if (m_iRateLimit > m_iDataTimeout)   m_iRateLimit = m_iDataTimeout;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:  m_ssURL.str(\"\");",
          "90:  if ((m_username.size() > 0) && (m_password.size() > 0))",
          "97: }",
          "",
          "[Removed Lines]",
          "91:          m_ssURL << \"http://\" << m_username << \":\" << m_password << \"@\";",
          "92:         else",
          "93:                 m_ssURL <<\"http://\";",
          "95:         m_ssURL << m_szIPAddress << \":\" << m_usIPPort;",
          "",
          "[Added Lines]",
          "91:   m_ssURL << \"http://\" << m_username << \":\" << m_password << \"@\";",
          "92:  else",
          "93:   m_ssURL << \"http://\";",
          "95:  m_ssURL << m_szIPAddress << \":\" << m_usIPPort;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "285:  else",
          "286:  {",
          "287:   message = \"EcoDevices firmware needs to be at least version \";",
          "289:   message = message + \", current version is \" + m_status.version;",
          "290:   _log.Log(LOG_ERROR, \"(%s) %s\", m_Name.c_str(), message.c_str());",
          "291:   return;",
          "",
          "[Removed Lines]",
          "288:   message = message + std::to_string(min_major) + \".\" + std::to_string(min_minor) +  \".\" + std::to_string(min_release);",
          "",
          "[Added Lines]",
          "288:   message = message + std::to_string(min_major) + \".\" + std::to_string(min_minor) + \".\" + std::to_string(min_release);",
          "",
          "---------------"
        ],
        "hardware/EvohomeBase.h||hardware/EvohomeBase.h": [
          "File: hardware/EvohomeBase.h -> hardware/EvohomeBase.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "43:   uint32_t val : 24;",
          "44:  };",
          "63: };",
          "",
          "[Removed Lines]",
          "46:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs)=0;",
          "47:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const=0;",
          "48:  virtual std::string Encode() const=0;",
          "50:  static void Add(const uint24_t &in, unsigned char* msg, unsigned char &nOfs){msg[nOfs++]=(in.val>>16)&0xFF;msg[nOfs++]=(in.val>>8)&0xFF;msg[nOfs++]=in.val&0xFF;}",
          "51:  static void Add(const uint16_t &in, unsigned char* msg, unsigned char &nOfs){msg[nOfs++]=(in>>8)&0xFF;msg[nOfs++]=in&0xFF;}",
          "52:  static void Add(const int16_t &in, unsigned char* msg, unsigned char &nOfs){msg[nOfs++]=(in>>8)&0xFF;msg[nOfs++]=in&0xFF;}",
          "53:  static void Add(const uint8_t &in, unsigned char* msg, unsigned char &nOfs){msg[nOfs++]=in;}",
          "54:  static void Add(const CEvohomeDataType &in, unsigned char* msg, unsigned char &nOfs){in.Add(msg,nOfs);}",
          "55:  void Add(unsigned char* msg, unsigned char &nOfs) const{nOfs=Encode(msg,nOfs);}",
          "57:  static void Get(uint24_t &out, const unsigned char* msg, unsigned char &nOfs){out.val=msg[nOfs++]<<16;out.val|=msg[nOfs++]<<8;out.val|=msg[nOfs++];}",
          "58:  static void Get(uint16_t &out, const unsigned char* msg, unsigned char &nOfs){out=msg[nOfs++]<<8;out|=msg[nOfs++];}",
          "59:  static void Get(int16_t &out, const unsigned char* msg, unsigned char &nOfs){out=msg[nOfs++]<<8;out|=msg[nOfs++];}",
          "60:  static void Get(uint8_t &out, const unsigned char* msg, unsigned char &nOfs){out=msg[nOfs++];}",
          "61:  static void Get(CEvohomeDataType &out, const unsigned char* msg, unsigned char &nOfs){out.Get(msg,nOfs);}",
          "62:  void Get(const unsigned char* msg, unsigned char &nOfs) {nOfs=Decode(msg,nOfs);}",
          "",
          "[Added Lines]",
          "46:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs) = 0;",
          "47:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const = 0;",
          "48:  virtual std::string Encode() const = 0;",
          "50:  static void Add(const uint24_t &in, unsigned char* msg, unsigned char &nOfs) { msg[nOfs++] = (in.val >> 16) & 0xFF; msg[nOfs++] = (in.val >> 8) & 0xFF; msg[nOfs++] = in.val & 0xFF; }",
          "51:  static void Add(const uint16_t &in, unsigned char* msg, unsigned char &nOfs) { msg[nOfs++] = (in >> 8) & 0xFF; msg[nOfs++] = in & 0xFF; }",
          "52:  static void Add(const int16_t &in, unsigned char* msg, unsigned char &nOfs) { msg[nOfs++] = (in >> 8) & 0xFF; msg[nOfs++] = in & 0xFF; }",
          "53:  static void Add(const uint8_t &in, unsigned char* msg, unsigned char &nOfs) { msg[nOfs++] = in; }",
          "54:  static void Add(const CEvohomeDataType &in, unsigned char* msg, unsigned char &nOfs) { in.Add(msg, nOfs); }",
          "55:  void Add(unsigned char* msg, unsigned char &nOfs) const { nOfs = Encode(msg, nOfs); }",
          "57:  static void Get(uint24_t &out, const unsigned char* msg, unsigned char &nOfs) { out.val = msg[nOfs++] << 16; out.val |= msg[nOfs++] << 8; out.val |= msg[nOfs++]; }",
          "58:  static void Get(uint16_t &out, const unsigned char* msg, unsigned char &nOfs) { out = msg[nOfs++] << 8; out |= msg[nOfs++]; }",
          "59:  static void Get(int16_t &out, const unsigned char* msg, unsigned char &nOfs) { out = msg[nOfs++] << 8; out |= msg[nOfs++]; }",
          "60:  static void Get(uint8_t &out, const unsigned char* msg, unsigned char &nOfs) { out = msg[nOfs++]; }",
          "61:  static void Get(CEvohomeDataType &out, const unsigned char* msg, unsigned char &nOfs) { out.Get(msg, nOfs); }",
          "62:  void Get(const unsigned char* msg, unsigned char &nOfs) { nOfs = Decode(msg, nOfs); }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "73:  friend class CEvohomeWeb;",
          "75: public:",
          "82:  static std::string GetHexTemp(int16_t nTemp)",
          "83:  {",
          "84:   char szTmp[256];",
          "86:   return szTmp;",
          "87:  }",
          "97:  int16_t m_nTemp;//all except DHW set point which is unsigned",
          "98: };",
          "",
          "[Removed Lines]",
          "76:  CEvohomeTemp():m_nTemp(0){}",
          "77:  CEvohomeTemp(int16_t nTemp):m_nTemp(nTemp){}",
          "78:  CEvohomeTemp(const unsigned char* msg, unsigned char nOfs){Decode(msg,nOfs);}",
          "79:  ~CEvohomeTemp(){}",
          "81:  static unsigned char DecodeTemp(int16_t &out, const unsigned char* msg, unsigned char nOfs){Get(out,msg,nOfs);return nOfs;}",
          "85:   sprintf(szTmp,\"%04x\",nTemp);",
          "89:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs){return DecodeTemp(m_nTemp,msg,nOfs);}",
          "90:  virtual std::string Encode() const{return GetHexTemp(m_nTemp);}",
          "91:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const{Add(m_nTemp,msg,nOfs);return nOfs;}",
          "93:  operator int16_t() const{return m_nTemp;}",
          "94:  double GetTemp(){return m_nTemp/100.0;}",
          "95:  bool IsValid(){return m_nTemp!=0x7FFF;}",
          "",
          "[Added Lines]",
          "76:  CEvohomeTemp() :m_nTemp(0) {}",
          "77:  CEvohomeTemp(int16_t nTemp) :m_nTemp(nTemp) {}",
          "78:  CEvohomeTemp(const unsigned char* msg, unsigned char nOfs) :m_nTemp(0) { Decode(msg, nOfs); }",
          "79:  ~CEvohomeTemp() {}",
          "81:  static unsigned char DecodeTemp(int16_t &out, const unsigned char* msg, unsigned char nOfs) { Get(out, msg, nOfs); return nOfs; }",
          "85:   sprintf(szTmp, \"%04x\", nTemp);",
          "89:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs) { return DecodeTemp(m_nTemp, msg, nOfs); }",
          "90:  virtual std::string Encode() const { return GetHexTemp(m_nTemp); }",
          "91:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const { Add(m_nTemp, msg, nOfs); return nOfs; }",
          "93:  operator int16_t() const { return m_nTemp; }",
          "94:  double GetTemp() { return m_nTemp / 100.0; }",
          "95:  bool IsValid() { return m_nTemp != 0x7FFF; }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "110: public:",
          "111:  enum devType {",
          "119:  };",
          "128:  static unsigned char DecodeID(unsigned int &out, const unsigned char* msg, unsigned char nOfs)",
          "129:  {",
          "133:   return nOfs;",
          "134:  }",
          "141:  static unsigned int GetID(const std::string &szID)",
          "142:  {",
          "143:   unsigned int idType;",
          "144:   unsigned int idAddr;",
          "147:  }",
          "148:  static std::string GetStrID(unsigned int nID)",
          "149:  {",
          "151:    return \"-:-\";",
          "152:   char szTmp[256];",
          "154:   return szTmp;",
          "155:  }",
          "156:  static std::string GetHexID(unsigned int nID)",
          "157:  {",
          "158:   char szTmp[256];",
          "160:   return szTmp;",
          "161:  }",
          "178:  unsigned int m_nID;",
          "179: };",
          "",
          "[Removed Lines]",
          "112:   devController=1,",
          "113:   devZone=4,",
          "114:   devSensor=7, //includes DHW and outdoor sensor",
          "115:   devBridge=10, // OT Bridge",
          "116:   devRelay=13,",
          "117:   devGateway=18,",
          "118:   devRemote=30,",
          "121:  CEvohomeID():m_nID(0){}",
          "122:  CEvohomeID(unsigned int nID) {SetID(nID); }",
          "123:  CEvohomeID(unsigned char idType, unsigned int idAddr){SetID(idType,idAddr);}",
          "124:  CEvohomeID(const std::string &szID){SetID(szID);}",
          "125:  CEvohomeID(const unsigned char* msg, unsigned char nOfs){Decode(msg,nOfs);}",
          "126:  ~CEvohomeID(){}",
          "130:   out=msg[nOfs++] << 16;//operator ++ may run after eval of entire expression",
          "131:   out|=msg[nOfs++] << 8;",
          "132:   out|=msg[nOfs++];",
          "136:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs){return DecodeID(m_nID,msg,nOfs);}",
          "138:  static unsigned char GetIDType(unsigned int nID){return ((nID>>18)&0x3F);}",
          "139:  static unsigned int GetIDAddr(unsigned int nID){return (nID&0x3FFFF);}",
          "140:  static unsigned int GetID(unsigned char idType, unsigned int idAddr){return idType<<18|idAddr;}",
          "145:   sscanf(szID.c_str(),\"%u:%u\",&idType,&idAddr);",
          "146:   return GetID(static_cast<unsigned char>(idType),idAddr);",
          "150:   if(!nID)",
          "153:   sprintf(szTmp,\"%hhu:%u\",GetIDType(nID),GetIDAddr(nID));",
          "159:   sprintf(szTmp,\"%06x\",nID);",
          "163:  bool IsValid(){return (m_nID!=0);}",
          "165:  unsigned char GetIDType() const{return GetIDType(GetID());}",
          "166:  unsigned int GetIDAddr() const{return GetIDAddr(GetID());}",
          "167:  unsigned int GetID() const {return m_nID;}",
          "168:  std::string GetStrID() const {return GetStrID(GetID());}",
          "169:  operator unsigned int() const{return GetID();}",
          "171:  virtual std::string Encode() const{return GetHexID(GetID());}",
          "172:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const{msg[nOfs++]=(GetID()>>16)&0xFF;msg[nOfs++]=(GetID()>>8)&0xFF;msg[nOfs++]=GetID()&0xFF;return nOfs;}",
          "174:  void SetID(unsigned int nID){m_nID=nID;}",
          "175:  void SetID(unsigned char idType, unsigned int idAddr){SetID(GetID(idType,idAddr));}",
          "176:  void SetID(const std::string &szID){SetID(GetID(szID));}",
          "",
          "[Added Lines]",
          "112:   devController = 1,",
          "113:   devZone = 4,",
          "114:   devSensor = 7, //includes DHW and outdoor sensor",
          "115:   devBridge = 10, // OT Bridge",
          "116:   devRelay = 13,",
          "117:   devGateway = 18,",
          "118:   devRemote = 30,",
          "121:  CEvohomeID() :m_nID(0) {}",
          "122:  CEvohomeID(unsigned int nID) { SetID(nID); }",
          "123:  CEvohomeID(unsigned char idType, unsigned int idAddr) { SetID(idType, idAddr); }",
          "124:  CEvohomeID(const std::string &szID) { SetID(szID); }",
          "125:  CEvohomeID(const unsigned char* msg, unsigned char nOfs) { Decode(msg, nOfs); }",
          "126:  ~CEvohomeID() {}",
          "130:   out = msg[nOfs++] << 16;//operator ++ may run after eval of entire expression",
          "131:   out |= msg[nOfs++] << 8;",
          "132:   out |= msg[nOfs++];",
          "136:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs) { return DecodeID(m_nID, msg, nOfs); }",
          "138:  static unsigned char GetIDType(unsigned int nID) { return ((nID >> 18) & 0x3F); }",
          "139:  static unsigned int GetIDAddr(unsigned int nID) { return (nID & 0x3FFFF); }",
          "140:  static unsigned int GetID(unsigned char idType, unsigned int idAddr) { return idType << 18 | idAddr; }",
          "145:   sscanf(szID.c_str(), \"%u:%u\", &idType, &idAddr);",
          "146:   return GetID(static_cast<unsigned char>(idType), idAddr);",
          "150:   if (!nID)",
          "153:   sprintf(szTmp, \"%hhu:%u\", GetIDType(nID), GetIDAddr(nID));",
          "159:   sprintf(szTmp, \"%06x\", nID);",
          "163:  bool IsValid() { return (m_nID != 0); }",
          "165:  unsigned char GetIDType() const { return GetIDType(GetID()); }",
          "166:  unsigned int GetIDAddr() const { return GetIDAddr(GetID()); }",
          "167:  unsigned int GetID() const { return m_nID; }",
          "168:  std::string GetStrID() const { return GetStrID(GetID()); }",
          "169:  operator unsigned int() const { return GetID(); }",
          "171:  virtual std::string Encode() const { return GetHexID(GetID()); }",
          "172:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const { msg[nOfs++] = (GetID() >> 16) & 0xFF; msg[nOfs++] = (GetID() >> 8) & 0xFF; msg[nOfs++] = GetID() & 0xFF; return nOfs; }",
          "174:  void SetID(unsigned int nID) { m_nID = nID; }",
          "175:  void SetID(unsigned char idType, unsigned int idAddr) { SetID(GetID(idType, idAddr)); }",
          "176:  void SetID(const std::string &szID) { SetID(GetID(szID)); }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "189:  friend class CEvohomeWeb;",
          "191: public:",
          "199:  template <class T> static unsigned char DecodeTime(T &out, const unsigned char* msg, unsigned char nOfs)",
          "200:  {",
          "203:   return nOfs;",
          "204:  }",
          "206:  template <class T> static unsigned char DecodeDate(T &out, const unsigned char* msg, unsigned char nOfs)",
          "207:  {",
          "212:   return nOfs;",
          "213:  }",
          "215:  template <class T> static unsigned char DecodeDateTime(T &out, const unsigned char* msg, unsigned char nOfs)",
          "216:  {",
          "218:   return nOfs;",
          "219:  }",
          "221:  template <class T> static std::string GetStrDate(const T &in)",
          "222:  {",
          "224:    return \"\";",
          "225:   char szTmp[256];",
          "227:   return szTmp;",
          "228:  }",
          "230:  template <class T> static std::string GetISODate(const T &in)",
          "231:  {",
          "233:    return \"\";",
          "234:   char szTmp[256];",
          "236:   return szTmp;",
          "237:  }",
          "239:  template <class T> static void DecodeISODate(T &out, const char* str)",
          "240:  {",
          "248:  }",
          "256:  virtual std::string Encode() const",
          "257:  {",
          "258:   char szTmp[256];",
          "260:   return szTmp;",
          "261:  }",
          "264:  uint8_t mins;",
          "265:  uint8_t hrs;",
          "",
          "[Removed Lines]",
          "192:  CEvohomeDateTime():mins(0xFF),hrs(0xFF),day(0xFF),month(0xFF),year(0xFFFF){}",
          "193:  template <class T> CEvohomeDateTime(const T &in){*this=in;}",
          "194:  CEvohomeDateTime(const unsigned char* msg, unsigned char nOfs){Decode(msg,nOfs);}",
          "195:  ~CEvohomeDateTime(){}",
          "197:  template <class T> CEvohomeDateTime& operator = (const T &in){year=in->year;month=in->month;day=in->day;hrs=in->hrs;mins=in->mins;return *this;}",
          "201:   out.mins=msg[nOfs++];",
          "202:   out.hrs=msg[nOfs++];",
          "208:   out.day=msg[nOfs++];",
          "209:   out.month=msg[nOfs++];",
          "210:   out.year=msg[nOfs++] << 8;//operator ++ may run after eval of entire expression",
          "211:   out.year|=msg[nOfs++];",
          "217:   DecodeDate(out,msg,DecodeTime(out,msg,nOfs));",
          "223:   if(in.year==0xFFFF)",
          "226:   sprintf(szTmp,std::string(\"%d-%02d-%02d\").append((in.hrs!=0xFF)?\" %02d:%02d\":\"\").c_str(),in.year,in.month,in.day,in.hrs,in.mins);",
          "232:   if(in->year==0xFFFF)",
          "235:   sprintf(szTmp,std::string(\"%d-%02d-%02d\").append((in->hrs!=0xFF)?\"T%02d:%02d:00\":\"T00:00:00\").c_str(),in->year,in->month,in->day,in->hrs,in->mins);",
          "241:   unsigned int y,m,d,h,n;",
          "242:   sscanf(str,\"%04u-%02u-%02uT%02u:%02u:\",&y,&m,&d,&h,&n);",
          "243:   out.year=static_cast<uint16_t>(y);",
          "244:   out.month=static_cast<uint8_t>(m);",
          "245:   out.day=static_cast<uint8_t>(d);",
          "246:   out.hrs=static_cast<uint8_t>(h);",
          "247:   out.mins=static_cast<uint8_t>(n);",
          "250:  unsigned char DecodeTime(const unsigned char* msg, unsigned char nOfs){return DecodeTime(*this,msg,nOfs);}",
          "251:  unsigned char DecodeDate(const unsigned char* msg, unsigned char nOfs){return DecodeDate(*this,msg,nOfs);}",
          "252:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs){return DecodeDateTime(*this,msg,nOfs);}",
          "254:  std::string GetStrDate() const{return GetStrDate(*this);}",
          "259:   sprintf(szTmp,\"%02hhx%02hhx%02hhx%02hhx%04hx\",mins,hrs,day,month,year);",
          "262:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const{Add(mins,msg,nOfs);Add(hrs,msg,nOfs);Add(day,msg,nOfs);Add(month,msg,nOfs);Add(year,msg,nOfs);return nOfs;}",
          "",
          "[Added Lines]",
          "192:  CEvohomeDateTime() :mins(0xFF), hrs(0xFF), day(0xFF), month(0xFF), year(0xFFFF) {}",
          "193:  template <class T> CEvohomeDateTime(const T &in) { *this = in; }",
          "194:  CEvohomeDateTime(const unsigned char* msg, unsigned char nOfs) { Decode(msg, nOfs); }",
          "195:  ~CEvohomeDateTime() {}",
          "197:  template <class T> CEvohomeDateTime& operator = (const T &in) { year = in->year; month = in->month; day = in->day; hrs = in->hrs; mins = in->mins; return *this; }",
          "201:   out.mins = msg[nOfs++];",
          "202:   out.hrs = msg[nOfs++];",
          "208:   out.day = msg[nOfs++];",
          "209:   out.month = msg[nOfs++];",
          "210:   out.year = msg[nOfs++] << 8;//operator ++ may run after eval of entire expression",
          "211:   out.year |= msg[nOfs++];",
          "217:   DecodeDate(out, msg, DecodeTime(out, msg, nOfs));",
          "223:   if (in.year == 0xFFFF)",
          "226:   sprintf(szTmp, std::string(\"%d-%02d-%02d\").append((in.hrs != 0xFF) ? \" %02d:%02d\" : \"\").c_str(), in.year, in.month, in.day, in.hrs, in.mins);",
          "232:   if (in->year == 0xFFFF)",
          "235:   sprintf(szTmp, std::string(\"%d-%02d-%02d\").append((in->hrs != 0xFF) ? \"T%02d:%02d:00\" : \"T00:00:00\").c_str(), in->year, in->month, in->day, in->hrs, in->mins);",
          "241:   unsigned int y, m, d, h, n;",
          "242:   sscanf(str, \"%04u-%02u-%02uT%02u:%02u:\", &y, &m, &d, &h, &n);",
          "243:   out.year = static_cast<uint16_t>(y);",
          "244:   out.month = static_cast<uint8_t>(m);",
          "245:   out.day = static_cast<uint8_t>(d);",
          "246:   out.hrs = static_cast<uint8_t>(h);",
          "247:   out.mins = static_cast<uint8_t>(n);",
          "250:  unsigned char DecodeTime(const unsigned char* msg, unsigned char nOfs) { return DecodeTime(*this, msg, nOfs); }",
          "251:  unsigned char DecodeDate(const unsigned char* msg, unsigned char nOfs) { return DecodeDate(*this, msg, nOfs); }",
          "252:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs) { return DecodeDateTime(*this, msg, nOfs); }",
          "254:  std::string GetStrDate() const { return GetStrDate(*this); }",
          "259:   sprintf(szTmp, \"%02hhx%02hhx%02hhx%02hhx%04hx\", mins, hrs, day, month, year);",
          "262:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const { Add(mins, msg, nOfs); Add(hrs, msg, nOfs); Add(day, msg, nOfs); Add(month, msg, nOfs); Add(year, msg, nOfs); return nOfs; }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "279:  friend class CEvohomeWeb;",
          "281: public:",
          "287:  virtual std::string Encode() const",
          "288:  {",
          "289:   char szTmp[256];",
          "291:   return szTmp;",
          "292:  }",
          "294: };",
          "",
          "[Removed Lines]",
          "282:  CEvohomeDate(){}",
          "283:  CEvohomeDate(const unsigned char* msg, unsigned char nOfs){Decode(msg,nOfs);}",
          "284:  ~CEvohomeDate(){}",
          "286:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs){return DecodeDate(*this,msg,nOfs);}",
          "290:   sprintf(szTmp,\"%02hhx%02hhx%04hx\",day,month,year);",
          "293:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const{Add(day,msg,nOfs);Add(month,msg,nOfs);Add(year,msg,nOfs);return nOfs;}",
          "",
          "[Added Lines]",
          "282:  CEvohomeDate() {}",
          "283:  CEvohomeDate(const unsigned char* msg, unsigned char nOfs) { Decode(msg, nOfs); }",
          "284:  ~CEvohomeDate() {}",
          "286:  virtual unsigned char Decode(const unsigned char* msg, unsigned char nOfs) { return DecodeDate(*this, msg, nOfs); }",
          "290:   sprintf(szTmp, \"%02hhx%02hhx%04hx\", day, month, year);",
          "293:  virtual unsigned char Encode(unsigned char* msg, unsigned char nOfs) const { Add(day, msg, nOfs); Add(month, msg, nOfs); Add(year, msg, nOfs); return nOfs; }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "306: public:",
          "307:  enum evoZoneFlags {",
          "311:  };",
          "312:  static std::string GetFlags(int nFlags)",
          "313:  {",
          "314:   std::string szRet;",
          "319:   return szRet;",
          "320:  }",
          "321: };",
          "",
          "[Removed Lines]",
          "308:   flgLocalOverrideDisabled=1,",
          "309:   flgWindowFunctionDisabled=2,",
          "310:   flgSingleRoomZone=16,",
          "316:   szRet+=std::string(\"[Local Override \").append((nFlags&flgLocalOverrideDisabled)?\"Disabled] \":\"Enabled] \");",
          "317:   szRet+=std::string(\"[Window Function \").append((nFlags&flgWindowFunctionDisabled)?\"Disabled] \":\"Enabled] \");",
          "318:   szRet+=std::string((nFlags&flgSingleRoomZone)?\"[Single\":\"[Multi\").append(\" Room Zone] \");",
          "",
          "[Added Lines]",
          "308:   flgLocalOverrideDisabled = 1,",
          "309:   flgWindowFunctionDisabled = 2,",
          "310:   flgSingleRoomZone = 16,",
          "316:   szRet += std::string(\"[Local Override \").append((nFlags&flgLocalOverrideDisabled) ? \"Disabled] \" : \"Enabled] \");",
          "317:   szRet += std::string(\"[Window Function \").append((nFlags&flgWindowFunctionDisabled) ? \"Disabled] \" : \"Enabled] \");",
          "318:   szRet += std::string((nFlags&flgSingleRoomZone) ? \"[Single\" : \"[Multi\").append(\" Room Zone] \");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "331:  friend class CEvohomeWeb;",
          "333: public:",
          "344:  };",
          "346:   pktunk,",
          "347:   pktinf,",
          "348:   pktreq,",
          "",
          "[Removed Lines]",
          "334:  enum flagtypes{",
          "335:   flgid1=1,",
          "336:   flgid2=flgid1<<1,",
          "337:   flgid3=flgid2<<1,",
          "338:   flgpkt=flgid3<<1,",
          "339:   flgts=flgpkt<<1,",
          "340:   flgcmd=flgts<<1,//not optional but we can signal if we read it at least",
          "341:   flgps=flgcmd<<1,//not optional but we can signal if we read it at least",
          "342:   flgpay=flgps<<1,//not optional but we can signal if we read it at least",
          "343:   flgvalid=flgid1|flgpkt|flgcmd|flgps|flgpay,",
          "345:  enum packettype{",
          "",
          "[Added Lines]",
          "334:  enum flagtypes {",
          "335:   flgid1 = 1,",
          "336:   flgid2 = flgid1 << 1,",
          "337:   flgid3 = flgid2 << 1,",
          "338:   flgpkt = flgid3 << 1,",
          "339:   flgts = flgpkt << 1,",
          "340:   flgcmd = flgts << 1,//not optional but we can signal if we read it at least",
          "341:   flgps = flgcmd << 1,//not optional but we can signal if we read it at least",
          "342:   flgpay = flgps << 1,//not optional but we can signal if we read it at least",
          "343:   flgvalid = flgid1 | flgpkt | flgcmd | flgps | flgpay,",
          "345:  enum packettype {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "350:   pktwrt,",
          "351:  };",
          "360:  CEvohomeMsg& operator = (const CEvohomeMsg& src)",
          "361:  {",
          "371:   return *this;",
          "372:  }",
          "",
          "[Removed Lines]",
          "353:  CEvohomeMsg():flags(0),type(pktunk),timestamp(0),command(0),payloadsize(0),readofs(0),enccount(0){}",
          "354:  CEvohomeMsg(const char * rawmsg):flags(0),type(pktunk),timestamp(0),command(0),payloadsize(0),readofs(0),enccount(0){DecodePacket(rawmsg);}",
          "355:  CEvohomeMsg(packettype nType, int nAddr, int nCommand):flags(0),type(nType),timestamp(0),command(nCommand),payloadsize(0),readofs(0),enccount(0){SetID(1,nAddr);SetFlag(flgpkt|flgcmd);}",
          "356:  CEvohomeMsg(packettype nType, int nAddr1, int nAddr2, int nCommand):flags(0),type(nType),timestamp(0),command(nCommand),payloadsize(0),readofs(0),enccount(0){SetID(1,nAddr1);SetID(2,nAddr2);SetFlag(flgpkt|flgcmd);}",
          "357:  CEvohomeMsg(const CEvohomeMsg& src):readofs(0),enccount(0){*this=src;}",
          "358:  ~CEvohomeMsg(){}",
          "362:   flags=src.flags;",
          "363:   type=src.type;",
          "364:   for(int i=0;i<3;i++)",
          "365:    id[i]=src.id[i];//maintain flags",
          "366:   timestamp=src.timestamp;",
          "367:   command=src.command;",
          "368:   payloadsize=src.payloadsize;",
          "369:   memcpy(payload,src.payload,payloadsize);",
          "",
          "[Added Lines]",
          "353:  CEvohomeMsg() :flags(0), type(pktunk), timestamp(0), command(0), payloadsize(0), readofs(0), enccount(0) {}",
          "354:  CEvohomeMsg(const char * rawmsg) :flags(0), type(pktunk), timestamp(0), command(0), payloadsize(0), readofs(0), enccount(0) { DecodePacket(rawmsg); }",
          "355:  CEvohomeMsg(packettype nType, int nAddr, int nCommand) :flags(0), type(nType), timestamp(0), command(nCommand), payloadsize(0), readofs(0), enccount(0) { SetID(1, nAddr); SetFlag(flgpkt | flgcmd); }",
          "356:  CEvohomeMsg(packettype nType, int nAddr1, int nAddr2, int nCommand) :flags(0), type(nType), timestamp(0), command(nCommand), payloadsize(0), readofs(0), enccount(0) { SetID(1, nAddr1); SetID(2, nAddr2); SetFlag(flgpkt | flgcmd); }",
          "357:  CEvohomeMsg(const CEvohomeMsg& src) :readofs(0), enccount(0) { *this = src; }",
          "358:  ~CEvohomeMsg() {}",
          "362:   flags = src.flags;",
          "363:   type = src.type;",
          "364:   for (int i = 0; i < 3; i++)",
          "365:    id[i] = src.id[i];//maintain flags",
          "366:   timestamp = src.timestamp;",
          "367:   command = src.command;",
          "368:   payloadsize = src.payloadsize;",
          "369:   memcpy(payload, src.payload, payloadsize);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "375:  {",
          "379:    return false;",
          "382:     return false;",
          "384:    return false;",
          "386:    return false;",
          "388:    return false;",
          "389:   return true;",
          "390:  }",
          "393:  bool DecodePacket(const char * rawmsg);",
          "404:  std::string Encode();",
          "409:  packettype SetPacketType(const std::string &szPkt)",
          "410:  {",
          "412:   for (int i = pktinf; i <= pktwrt; i++)",
          "413:   {",
          "414:    if (szPkt == szPacketType[i])",
          "415:    {",
          "417:     break;",
          "418:    }",
          "419:   }",
          "",
          "[Removed Lines]",
          "378:   if(type!=other.type)",
          "380:   for(int i=1;i<3;i++)//ignore the source address as the special 18:730 addr used for sending will not match the one read back in",
          "381:    if(id[i]!=other.id[i])",
          "383:   if(command!=other.command)",
          "385:   if(payloadsize!=other.payloadsize)",
          "387:   if(memcmp(payload,other.payload,payloadsize))",
          "392:  bool IsValid() const {return ((flags&flgvalid)==flgvalid)&&(flags&(flgid2|flgid3));}",
          "395:  template<typename T> CEvohomeMsg& Add(const T &in){CEvohomeDataType::Add(in,payload,payloadsize);return *this;}",
          "396:  template<typename T> CEvohomeMsg& Add_if(const T &in, bool p){if(p)Add(in);return *this;}",
          "397:  template<typename T> CEvohomeMsg& Get(T &out){CEvohomeDataType::Get(out,payload,readofs);return *this;}",
          "398:  template<typename T> CEvohomeMsg& Get(T &out, int nOfs){SetPos(nOfs);CEvohomeDataType::Get(out,payload,readofs);return *this;}",
          "399:  template<typename T> CEvohomeMsg& Get_if(T &out, bool p){if(p)Get(out);return *this;}",
          "401:  void SetPos(unsigned char nPos){readofs=nPos;}",
          "402:  unsigned char GetPos(){return readofs;}",
          "406:  void SetFlag(int nFlag){flags|=nFlag;}",
          "407:  bool GetFlag(int nFlag){return ((flags&nFlag)!=0);}",
          "411:   type=pktunk;",
          "416:     type=static_cast<packettype>(i);",
          "",
          "[Added Lines]",
          "378:   if (type != other.type)",
          "380:   for (int i = 1; i < 3; i++)//ignore the source address as the special 18:730 addr used for sending will not match the one read back in",
          "381:    if (id[i] != other.id[i])",
          "383:   if (command != other.command)",
          "385:   if (payloadsize != other.payloadsize)",
          "387:   if (memcmp(payload, other.payload, payloadsize))",
          "392:  bool IsValid() const { return ((flags&flgvalid) == flgvalid) && (flags&(flgid2 | flgid3)); }",
          "395:  template<typename T> CEvohomeMsg& Add(const T &in) { CEvohomeDataType::Add(in, payload, payloadsize); return *this; }",
          "396:  template<typename T> CEvohomeMsg& Add_if(const T &in, bool p) { if (p)Add(in); return *this; }",
          "397:  template<typename T> CEvohomeMsg& Get(T &out) { CEvohomeDataType::Get(out, payload, readofs); return *this; }",
          "398:  template<typename T> CEvohomeMsg& Get(T &out, int nOfs) { SetPos(nOfs); CEvohomeDataType::Get(out, payload, readofs); return *this; }",
          "399:  template<typename T> CEvohomeMsg& Get_if(T &out, bool p) { if (p)Get(out); return *this; }",
          "401:  void SetPos(unsigned char nPos) { readofs = nPos; }",
          "402:  unsigned char GetPos() { return readofs; }",
          "406:  void SetFlag(int nFlag) { flags |= nFlag; }",
          "407:  bool GetFlag(int nFlag) { return ((flags&nFlag) != 0); }",
          "411:   type = pktunk;",
          "416:     type = static_cast<packettype>(i);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "423:  std::string GetStrID(int idx) const",
          "424:  {",
          "426:    return \"\";",
          "427:   return id[idx].GetStrID();",
          "428:  }",
          "429:  unsigned int GetID(int idx) const",
          "430:  {",
          "432:    return 0;",
          "433:   return id[idx];",
          "434:  }",
          "435:  void SetID(int idx, int nID)",
          "436:  {",
          "438:    return;",
          "441:  }",
          "444:  static char const szPacketType[5][8];",
          "",
          "[Removed Lines]",
          "425:   if(idx>=3)",
          "431:   if(idx>=3)",
          "437:   if(idx>=3)",
          "439:   id[idx]=nID;",
          "440:   SetFlag(flgid1<<idx);",
          "442:  bool BadMsg(){return (enccount>30);}",
          "",
          "[Added Lines]",
          "425:   if (idx >= 3)",
          "431:   if (idx >= 3)",
          "437:   if (idx >= 3)",
          "439:   id[idx] = nID;",
          "440:   SetFlag(flgid1 << idx);",
          "442:  bool BadMsg() { return (enccount > 30); }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "450:  unsigned int command;",
          "451:  unsigned char payloadsize;",
          "452:  unsigned char readofs;",
          "454:  unsigned char payload[m_nBufSize];",
          "455:  unsigned int enccount;",
          "456: };",
          "",
          "[Removed Lines]",
          "453:  static int const m_nBufSize=256;",
          "",
          "[Added Lines]",
          "453:  static int const m_nBufSize = 256;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "469:  ~CEvohomeBase(void);",
          "474:   zmPerm,",
          "475:   zmTmp,",
          "476:   zmWind,//window func",
          "",
          "[Removed Lines]",
          "472:  enum zoneModeType{",
          "473:   zmAuto=0,",
          "",
          "[Added Lines]",
          "472:  enum zoneModeType {",
          "473:   zmAuto = 0,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "480:  };",
          "485:   cmEvoAutoWithEco,//  0x01",
          "486:   cmEvoAway,//  0x02",
          "487:   cmEvoDayOff,//  0x03",
          "",
          "[Removed Lines]",
          "483:  enum controllerMode{",
          "484:   cmEvoAuto=0,// 0x00",
          "",
          "[Added Lines]",
          "483:  enum controllerMode {",
          "484:   cmEvoAuto = 0,// 0x00",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "489:   cmEvoHeatingOff,//  0x05",
          "490:  };",
          "494:   cmTmp",
          "495:  };",
          "499:   updSetPoint,",
          "500:   updOverride,",
          "501:   updBattery,",
          "502:   updDemand,",
          "503:  };",
          "507:  int GetControllerID();",
          "508:  int GetGatewayID();",
          "",
          "[Removed Lines]",
          "492:  enum controllerModeType{",
          "493:   cmPerm=0,",
          "497:  enum msgUpdate{",
          "498:   updTemp=0,",
          "505:  static const uint8_t m_nMaxZones=12;",
          "",
          "[Added Lines]",
          "492:  enum controllerModeType {",
          "493:   cmPerm = 0,",
          "497:  enum msgUpdate {",
          "498:   updTemp = 0,",
          "505:  static const uint8_t m_nMaxZones = 12;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "516:  static const char* GetZoneModeName(uint8_t nZoneMode);",
          "518:  static void LogDate();",
          "520: #ifdef __GNUC__",
          "522: #endif",
          "523:   ;",
          "524:  static void Log(const char *szMsg, CEvohomeMsg &msg);",
          "",
          "[Removed Lines]",
          "519:  static void Log(bool bDebug, int nLogLevel, const char* format, ... )",
          "521:   __attribute__ ((format (printf, 3, 4)))",
          "",
          "[Added Lines]",
          "519:  static void Log(bool bDebug, int nLogLevel, const char* format, ...)",
          "521:   __attribute__((format(printf, 3, 4)))",
          "",
          "---------------"
        ],
        "hardware/Honeywell.cpp||hardware/Honeywell.cpp": [
          "File: hardware/Honeywell.cpp -> hardware/Honeywell.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "53:  if (Username.empty() || Password.empty()) {",
          "54:   _log.Log(LOG_ERROR, \"Honeywell: Please update your access token/request token!...\");",
          "55:  }",
          "57:  Init();",
          "58: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "56:  mLastMinute = -1;",
          "",
          "---------------"
        ],
        "hardware/I2C.cpp||hardware/I2C.cpp": [
          "File: hardware/I2C.cpp -> hardware/I2C.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "148:  \"I2C_MCP23017\",",
          "149: };",
          "156: {",
          "157:  _log.Log(LOG_STATUS, \"I2C  Start HW witf ID: %d Name: %s Address: %d Port: %s Invert:%d \", ID, szI2CTypeNames[m_dev_type], m_i2c_addr, m_ActI2CBus.c_str(), m_invert_data);",
          "158:  m_HwdID = ID;",
          "160:   m_ActI2CBus = \"/dev/i2c-1\";",
          "161:   if (!i2c_test(m_ActI2CBus.c_str()))",
          "162:   {",
          "",
          "[Removed Lines]",
          "151: I2C::I2C(const int ID, const _eI2CType DevType, const std::string &Address, const std::string &SerialPort, const int Mode1):",
          "152: m_dev_type(DevType),",
          "153: m_i2c_addr((uint8_t)atoi(Address.c_str())),",
          "154: m_ActI2CBus(SerialPort),",
          "155: m_invert_data((bool) Mode1)",
          "159:  if ( m_ActI2CBus==\"\" ){ // if empty option then autodetect i2c bus",
          "",
          "[Added Lines]",
          "151: I2C::I2C(const int ID, const _eI2CType DevType, const std::string &Address, const std::string &SerialPort, const int Mode1) :",
          "152:  m_dev_type(DevType),",
          "153:  m_i2c_addr((uint8_t)atoi(Address.c_str())),",
          "154:  m_ActI2CBus(SerialPort),",
          "155:  m_invert_data((bool)Mode1)",
          "159:  if (m_ActI2CBus == \"\") { // if empty option then autodetect i2c bus",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "173: {",
          "174:  RequestStart();",
          "177:  {",
          "178:   m_minuteCount = 0;",
          "179:   m_firstRound = true;",
          "",
          "[Removed Lines]",
          "176:  if ((m_dev_type == I2CTYPE_BMP085)|| (m_dev_type == I2CTYPE_BME280))",
          "",
          "[Added Lines]",
          "176:  if ((m_dev_type == I2CTYPE_BMP085) || (m_dev_type == I2CTYPE_BME280))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "340:  uint8_t buf = 0;",
          "341:  int fd = i2c_Open(m_ActI2CBus.c_str()); // open i2c",
          "342:  if (fd < 0) return; // Error opening i2c device!",
          "347:  }",
          "350:   int DeviceID = (m_i2c_addr << 8) + pin_number; // DeviceID from i2c_address and pin_number",
          "351:   unsigned char Unit = pin_number;",
          "354:   SendSwitch(DeviceID, Unit, 255, value, 0, \"\"); // create or update switch",
          "355:  }",
          "356:  close(fd);",
          "",
          "[Removed Lines]",
          "343:  if ( readByteI2C(fd, &buf, m_i2c_addr) < 0 ) return; //read from i2c",
          "345:  if (m_invert_data==true) {",
          "346:   buf=~buf; // Invert Status",
          "349:  for (uint8_t pin_number=0; pin_number<8; pin_number++){",
          "352:   uint8_t pin_mask=0x01<<pin_number;",
          "353:   bool value=(buf & pin_mask);",
          "",
          "[Added Lines]",
          "343:  if (readByteI2C(fd, &buf, m_i2c_addr) < 0) return; //read from i2c",
          "345:  if (m_invert_data == true) {",
          "346:   buf = ~buf; // Invert Status",
          "349:  for (uint8_t pin_number = 0; pin_number < 8; pin_number++) {",
          "352:   uint8_t pin_mask = 0x01 << pin_number;",
          "353:   bool value = (buf & pin_mask);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "358: }",
          "362: {",
          "363: #ifndef HAVE_LINUX_I2C",
          "364:  return -1;",
          "365: #else",
          "366:  _log.Log(LOG_NORM, \"GPIO: WRITE TO PCF8574 pin:%d, value: %d, i2c_address:%d\", pin_number, value, m_i2c_addr);",
          "368:  uint8_t buf_act = 0;",
          "369:  uint8_t buf_new = 0;",
          "370:  int fd = i2c_Open(m_ActI2CBus.c_str());",
          "371:  if (fd < 0) return -1; // Error opening i2c device!",
          "375:  else buf_new = buf_act & ~pin_mask;",
          "378:    _log.Log(LOG_ERROR, \"GPIO: %s: Error write to device!...\", szI2CTypeNames[m_dev_type]);",
          "379:    return -3;",
          "380:   }",
          "",
          "[Removed Lines]",
          "361: int I2C::PCF8574_WritePin(uint8_t pin_number,uint8_t  value)",
          "367:  uint8_t pin_mask=0x01<<pin_number; // create pin mask from pin number",
          "372:  if ( readByteI2C(fd, &buf_act, m_i2c_addr) < 0 ) return -2;",
          "373:  lseek(fd,0,SEEK_SET); // after read back file cursor to begin (prepare to write new value on begin)",
          "374:  if (value==1) buf_new = buf_act | pin_mask; //prepare new value by combinate current value, mask and new value",
          "376:  if (buf_new!=buf_act) { // if value change write new value",
          "377:   if (writeByteI2C(fd, buf_new, m_i2c_addr) < 0 ) {",
          "",
          "[Added Lines]",
          "361: int I2C::PCF8574_WritePin(uint8_t pin_number, uint8_t  value)",
          "367:  uint8_t pin_mask = 0x01 << pin_number; // create pin mask from pin number",
          "372:  if (readByteI2C(fd, &buf_act, m_i2c_addr) < 0) return -2;",
          "373:  lseek(fd, 0, SEEK_SET); // after read back file cursor to begin (prepare to write new value on begin)",
          "374:  if (value == 1) buf_new = buf_act | pin_mask; //prepare new value by combinate current value, mask and new value",
          "376:  if (buf_new != buf_act) { // if value change write new value",
          "377:   if (writeByteI2C(fd, buf_new, m_i2c_addr) < 0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "404:  {",
          "405:   for (const auto & itt : results)",
          "406:   {",
          "408:    unit = atoi(sd[0].c_str());",
          "409:    nvalue = atoi(sd[1].c_str());",
          "",
          "[Removed Lines]",
          "407:    std::vector<std::string> sd=itt;",
          "",
          "[Added Lines]",
          "407:    std::vector<std::string> sd = itt;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "412:     nvalue ^= 1;",
          "413:    }",
          "416:     GPIO_reg |= (0x01 << unit);",
          "417:     value = false;",
          "418:    }",
          "420:     GPIO_reg &= ~(0x01 << unit);",
          "421:     value = true;",
          "422:    }",
          "",
          "[Removed Lines]",
          "415:    if (nvalue==1) {",
          "419:    else if (nvalue==0) {",
          "",
          "[Added Lines]",
          "415:    if (nvalue == 1) {",
          "419:    else if (nvalue == 0) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "427:   }",
          "428:  }",
          "429:  else {",
          "431:    int DeviceID = (m_i2c_addr << 8) + pin_number;    // DeviceID from i2c_address and pin_number",
          "432:    SendSwitch(DeviceID, pin_number, 255, value, 0, \"\");    // create switch",
          "433:   }",
          "434:  }",
          "436:   _log.Log(LOG_NORM, \"I2C::MCP23017_Init. %s. Failed to write to I2C device at address: 0x%x\", szI2CTypeNames[m_dev_type], m_i2c_addr);",
          "437:   return;            // write to i2c failed",
          "438:  }",
          "440:   _log.Log(LOG_NORM, \"I2C::MCP23017_Init. %s. Failed to write to I2C device at address: 0x%x\", szI2CTypeNames[m_dev_type], m_i2c_addr);",
          "441:   return;            // write to i2c failed",
          "442:  }",
          "",
          "[Removed Lines]",
          "430:   for (char pin_number=0; pin_number<16; pin_number++){",
          "435:  if (I2CWriteReg16(fd, MCP23x17_GPIOA, GPIO_reg) < 0 ) { // write values from domoticz db to gpio register",
          "439:  if (I2CWriteReg16(fd, MCP23x17_IODIRA, 0x0000) < 0 ){ // set all gpio pins on the port as output",
          "",
          "[Added Lines]",
          "430:   for (char pin_number = 0; pin_number < 16; pin_number++) {",
          "435:  if (I2CWriteReg16(fd, MCP23x17_GPIOA, GPIO_reg) < 0) { // write values from domoticz db to gpio register",
          "439:  if (I2CWriteReg16(fd, MCP23x17_IODIRA, 0x0000) < 0) { // set all gpio pins on the port as output",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "465:   _log.Log(LOG_NORM, \"I2C::MCP23017_ReadChipDetails. %s. Failed to read from I2C device at address: 0x%x\", szI2CTypeNames[m_dev_type], m_i2c_addr);",
          "466:   return; //read from i2c failed",
          "467:  }",
          "469:   _log.Log(LOG_NORM, \"I2C::MCP23017_ReadChipDetails, Cur_iodir: 0xFFFF, call MCP23017_Init\");",
          "470:   MCP23017_Init();          // initialize gpio pins with switch status from db",
          "471:  }",
          "472: #endif",
          "473: }",
          "476: {",
          "477: #ifndef HAVE_LINUX_I2C",
          "478:  return -1;",
          "479: #else",
          "480:  _log.Log(LOG_NORM, \"GPIO: WRITE TO MCP23017 pin:%d, value: %d, i2c_address:%d\", pin_number, value, m_i2c_addr);",
          "482:  unsigned char gpio_port, iodir_port;",
          "483:  uint16_t new_data = 0;",
          "484:  i2c_data cur_data, cur_iodir;",
          "485:  int rc;",
          "488:  iodir_mask &= ~(0x01 << (pin_number));",
          "",
          "[Removed Lines]",
          "468:  if ((data.word == 0xFFFF)){         // if oidir port is 0xFFFF means the chip has been reset",
          "475: int I2C::MCP23017_WritePin(uint8_t pin_number,uint8_t  value)",
          "481:  uint16_t pin_mask=0, iodir_mask=0;",
          "487:  pin_mask=0x01<<(pin_number);",
          "",
          "[Added Lines]",
          "468:  if ((data.word == 0xFFFF)) {         // if oidir port is 0xFFFF means the chip has been reset",
          "475: int I2C::MCP23017_WritePin(uint8_t pin_number, uint8_t  value)",
          "481:  uint16_t pin_mask = 0, iodir_mask = 0;",
          "487:  pin_mask = 0x01 << (pin_number);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "505:  }",
          "506:  cur_iodir.word &= iodir_mask;        // create mask for iodir register to set pin as output.",
          "509:  else new_data = cur_data.word & ~pin_mask;",
          "513:    _log.Log(LOG_ERROR, \"I2C::MCP23017_WritePin. %s: Failed to write to I2C device at address: 0x%x\", szI2CTypeNames[m_dev_type], m_i2c_addr);",
          "514:    close(fd);",
          "515:    return -3;",
          "516:   }",
          "518:    _log.Log(LOG_ERROR, \"I2C::MCP23017_WritePin. %s: Failed to write to I2C device at address: 0x%x\", szI2CTypeNames[m_dev_type], m_i2c_addr);",
          "519:    close(fd);",
          "520:    return -3;             // write to i2c failed",
          "",
          "[Removed Lines]",
          "508:  if (value==1) new_data = cur_data.word | pin_mask;  //prepare new value by combinating current value, mask and new value",
          "511:  if (new_data!=cur_data.word) {        // if value change write new value",
          "512:   if (I2CWriteReg16(fd, MCP23x17_GPIOA, new_data) < 0 ) {",
          "517:   if (I2CWriteReg16(fd, MCP23x17_IODIRA, cur_iodir.word) < 0 ) {  // write to iodir register, set gpio pin as output",
          "",
          "[Added Lines]",
          "508:  if (value == 1) new_data = cur_data.word | pin_mask;  //prepare new value by combinating current value, mask and new value",
          "511:  if (new_data != cur_data.word) {        // if value change write new value",
          "512:   if (I2CWriteReg16(fd, MCP23x17_GPIOA, new_data) < 0) {",
          "517:   if (I2CWriteReg16(fd, MCP23x17_IODIRA, cur_iodir.word) < 0) {  // write to iodir register, set gpio pin as output",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "680:   return -1;",
          "681:  }",
          "684:   _log.Log(LOG_ERROR, \"%s: Failed to read from the i2c bus with address %d\", szI2CTypeNames[m_dev_type], i2c_addr);",
          "685:   return -2;",
          "686:  }",
          "",
          "[Removed Lines]",
          "683:  if (read(fd,byte,1) != 1) {",
          "",
          "[Added Lines]",
          "683:  if (read(fd, byte, 1) != 1) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "699:   return -1;",
          "700:  }",
          "703:   _log.Log(LOG_ERROR, \"%s: Failed write to the i2c bus with address %d\", szI2CTypeNames[m_dev_type], i2c_addr);",
          "704:   return -2;",
          "705:  }",
          "",
          "[Removed Lines]",
          "702:  if (write(fd,&byte,1) != 1) {",
          "",
          "[Added Lines]",
          "702:  if (write(fd, &byte, 1) != 1) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "710: int I2C::I2CWriteReg16(int fd, uint8_t reg, uint16_t value)",
          "711: {",
          "735: }",
          "738: {",
          "739: #ifndef HAVE_LINUX_I2C",
          "740:  return -1;",
          "",
          "[Removed Lines]",
          "712:  #ifndef HAVE_LINUX_I2C",
          "713:   return -1;",
          "714:  #else",
          "715:   int rc;",
          "716:   struct i2c_rdwr_ioctl_data messagebuffer;",
          "717:   uint8_t datatosend[3];",
          "718:   i2c_data bytes;",
          "719:   bytes.word = value;",
          "720:   struct i2c_msg write_reg[1] = {",
          "721:    { m_i2c_addr, 0, 3, datatosend } // flag absent == write, two registers, one for register address and one for the value to write",
          "722:   };",
          "723:   datatosend[0] = reg;      // address of register to write",
          "724:   datatosend[1] = bytes.byte[0];      // value to write",
          "725:   datatosend[2] = bytes.byte[1];      // value to write",
          "726:   messagebuffer.msgs = write_reg;    //load the 'write_reg' message into the buffer",
          "727:   messagebuffer.nmsgs = 1;",
          "728:   rc = ioctl(fd, I2C_RDWR, &messagebuffer); //Send the buffer to the bus and returns a send status",
          "729:   if (rc < 0) {",
          "731:    return rc;",
          "732:   }",
          "733:   return 0;",
          "734:  #endif",
          "737: int I2C::I2CReadReg16(int fd, unsigned char reg, i2c_data *data )",
          "",
          "[Added Lines]",
          "712: #ifndef HAVE_LINUX_I2C",
          "713:  return -1;",
          "714: #else",
          "715:  int rc;",
          "716:  struct i2c_rdwr_ioctl_data messagebuffer;",
          "717:  uint8_t datatosend[3];",
          "718:  i2c_data bytes;",
          "719:  bytes.word = value;",
          "720:  struct i2c_msg write_reg[1] = {",
          "721:   { m_i2c_addr, 0, 3, datatosend } // flag absent == write, two registers, one for register address and one for the value to write",
          "722:  };",
          "723:  datatosend[0] = reg;      // address of register to write",
          "724:  datatosend[1] = bytes.byte[0];      // value to write",
          "725:  datatosend[2] = bytes.byte[1];      // value to write",
          "726:  messagebuffer.msgs = write_reg;    //load the 'write_reg' message into the buffer",
          "727:  messagebuffer.nmsgs = 1;",
          "728:  rc = ioctl(fd, I2C_RDWR, &messagebuffer); //Send the buffer to the bus and returns a send status",
          "729:  if (rc < 0) {",
          "731:   return rc;",
          "732:  }",
          "733:  return 0;",
          "734: #endif",
          "737: int I2C::I2CReadReg16(int fd, unsigned char reg, i2c_data *data)",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "891:  float lux;",
          "892: #ifndef HAVE_LINUX_I2C",
          "893:  lux = 1984;",
          "900: #else",
          "901:  uint8_t rValues[2];",
          "902:  int fd = i2c_Open(m_ActI2CBus.c_str());",
          "",
          "[Removed Lines]",
          "894:  #ifndef _DEBUG",
          "895:   _log.Log(LOG_ERROR, \"%s: I2C is unsupported on this architecture!...\", szI2CTypeNames[m_dev_type]);",
          "896:   return;",
          "897:  #else",
          "898:   _log.Log(LOG_ERROR, \"%s: I2C is unsupported on this architecture!... Debug: just adding a value\", szI2CTypeNames[m_dev_type]);",
          "899:  #endif",
          "",
          "[Added Lines]",
          "894: #ifndef _DEBUG",
          "895:  _log.Log(LOG_ERROR, \"%s: I2C is unsupported on this architecture!...\", szI2CTypeNames[m_dev_type]);",
          "896:  return;",
          "897: #else",
          "898:  _log.Log(LOG_ERROR, \"%s: I2C is unsupported on this architecture!... Debug: just adding a value\", szI2CTypeNames[m_dev_type]);",
          "899: #endif",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "922:  float ratio = 0;",
          "924:  if (ratio >= 0 && ratio < 0.50)",
          "925:   lux = ch0 * (0.0304 - 0.062 * pow(ch1 / ch0, 1.4));",
          "926:  else if (ratio >= 0.5 && ratio < 0.61)",
          "",
          "[Removed Lines]",
          "923:  if (ch0 != 0) ratio = ch1/ch0;",
          "",
          "[Added Lines]",
          "923:  if (ch0 != 0) ratio = ch1 / ch0;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1106:  if (m_minuteCount > 180)",
          "1107:   m_minuteCount = 6;",
          "1110:  m_minuteCount++;",
          "1112:  if (m_minuteCount == 5) {",
          "",
          "[Removed Lines]",
          "1109:  m_pressureSamples[m_minuteCount] = pressure;",
          "",
          "[Added Lines]",
          "1109:  m_pressureSamples[m_minuteCount % 180] = pressure;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1190:   return FC_BMP085_THUNDERSTORM; // Quickly falling LP, Thunderstorm, not stable",
          "1191:  else if (dP_dt > 0.25)",
          "1192:   return FC_BMP085_UNSTABLE; // Quickly rising HP, not stable weather",
          "1194:   return FC_BMP085_CLOUDY_RAIN; // Slowly falling Low Pressure System, stable rainy weather",
          "1195:  else if ((dP_dt > 0.05) && (dP_dt < 0.25))",
          "1196:   return FC_BMP085_SUNNY; // Slowly rising HP stable good weather",
          "1198:   return FC_BMP085_STABLE; // Stable weather",
          "1199:  else",
          "1200:   return FC_BMP085_UNKNOWN; // Unknown",
          "",
          "[Removed Lines]",
          "1193:  else if ((dP_dt >(-0.25)) && (dP_dt < (-0.05)))",
          "1197:  else if ((dP_dt >(-0.05)) && (dP_dt < 0.05))",
          "",
          "[Added Lines]",
          "1193:  else if ((dP_dt > (-0.25)) && (dP_dt < (-0.05)))",
          "1197:  else if ((dP_dt > (-0.05)) && (dP_dt < 0.05))",
          "",
          "---------------"
        ],
        "hardware/OpenZWave.cpp||hardware/OpenZWave.cpp": [
          "File: hardware/OpenZWave.cpp -> hardware/OpenZWave.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "347:  m_HwdID = ID;",
          "348:  m_controllerID = 0;",
          "349:  m_controllerNodeId = 0;",
          "350:  m_bIsShuttingDown = false;",
          "351:  m_initFailed = false;",
          "352:  m_allNodesQueried = false;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "350:  m_LastControllerConfigWrite = 0;",
          "",
          "---------------"
        ],
        "hardware/eHouse/EhouseUdpListener.cpp||hardware/eHouse/EhouseUdpListener.cpp": [
          "File: hardware/eHouse/EhouseUdpListener.cpp -> hardware/eHouse/EhouseUdpListener.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:  {",
          "48:   LOG(LOG_STATUS, \"Allocating CommManager LAN Controller (192.168.%d.%d)\", devaddrh, devaddrl);",
          "49:   m_ECMn = (struct CommManagerNamesT *) malloc(sizeof(struct CommManagerNamesT));",
          "51:   m_ECMn->INITIALIZED = 'a'; //first byte of structure for detection of allocated memory",
          "52:   m_ECMn->AddrH = devaddrh;",
          "53:   m_ECMn->AddrL = devaddrl;",
          "",
          "[Removed Lines]",
          "50:   if (m_ECMn == NULL) LOG(LOG_ERROR, \"CAN'T Allocate ECM Names Memory\");",
          "",
          "[Added Lines]",
          "50:   if (m_ECMn == NULL) {",
          "51:    LOG(LOG_ERROR, \"CAN'T Allocate ECM Names Memory\");",
          "52:    return;",
          "53:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "66:  if (m_eHouseProN == NULL)",
          "67:  {",
          "68:   LOG(LOG_STATUS, \"Allocating eHouse PRO Controller (192.168.%d.%d)\", devaddrh, devaddrl);",
          "71:   m_eHouseProN->INITIALIZED = 'a'; //first byte of structure for detection of allocated memory",
          "72:   m_eHouseProN->AddrH[0] = devaddrh;",
          "73:   m_eHouseProN->AddrL[0] = devaddrl;",
          "",
          "[Removed Lines]",
          "69:   m_eHouseProN = (struct eHouseProNamesT *) malloc(sizeof(struct eHouseProNamesT));",
          "70:   if (m_eHouseProN == NULL) LOG(LOG_ERROR, \"CAN'T Allocate PRO Names Memory\");",
          "",
          "[Added Lines]",
          "72:   m_eHouseProN = (struct eHouseProNamesT *) malloc(sizeof(struct eHouseProNamesT)); //Giz: ?? why use mallocs ?",
          "73:   if (m_eHouseProN == NULL) {",
          "74:    LOG(LOG_ERROR, \"CAN'T Allocate PRO Names Memory\");",
          "75:    return;",
          "76:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "92:   {",
          "93:    LOG(LOG_STATUS, \"Allocating Aura Thermostat (%d.%d)\", devaddrh, i + 1);",
          "94:    m_AuraN[i] = (struct AuraNamesT *) malloc(sizeof(struct AuraNamesT));",
          "96:    m_AuraN[i]->INITIALIZED = 'a'; //first byte of structure for detection of allocated memory",
          "97:    m_AuraN[i]->AddrH = devaddrh;",
          "98:    m_AuraN[i]->AddrL = i + 1;",
          "",
          "[Removed Lines]",
          "95:    if (m_AuraN[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate AURA Names Memory\");",
          "",
          "[Added Lines]",
          "101:    if (m_AuraN[i] == NULL) {",
          "102:     LOG(LOG_ERROR, \"CAN'T Allocate AURA Names Memory\");",
          "103:     return;",
          "104:    }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "101:    m_adcs[i] = (struct CtrlADCT *) malloc(sizeof(struct CtrlADCT));",
          "102:    if (m_adcs[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate ADCs Memory\");",
          "103:    if (m_AuraDev[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate AURA Stat Memory\");",
          "105:    m_AuraN[i]->BinaryStatus[0] = 0; //modified flag",
          "106:    m_AuraDevPrv[i]->Addr = 0;  //modified flag",
          "107:   }",
          "",
          "[Removed Lines]",
          "104:    if (m_AuraDevPrv[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate AURA Stat Prv Memory\");",
          "",
          "[Added Lines]",
          "113:    if (m_AuraDevPrv[i] == NULL) {",
          "114:     LOG(LOG_ERROR, \"CAN'T Allocate AURA Stat Prv Memory\");",
          "115:     return;",
          "116:    }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "123:   {",
          "124:    LOG(LOG_STATUS, \"Allocating eHouse LAN controller (192.168.%d.%d)\", devaddrh, i + m_INITIAL_ADDRESS_LAN);",
          "125:    m_eHEn[i] = (struct EtherneteHouseNamesT *) malloc(sizeof(struct EtherneteHouseNamesT));",
          "127:    m_eHEn[i]->INITIALIZED = 'a'; //first byte of structure for detection of allocated memory",
          "128:    m_eHEn[i]->AddrH = devaddrh;",
          "129:    m_eHEn[i]->AddrL = i + m_INITIAL_ADDRESS_LAN;",
          "130:    m_eHERMs[i] = (union ERMFullStatT *) malloc(sizeof(union ERMFullStatT));",
          "131:    m_eHERMPrev[i] = (union ERMFullStatT *) malloc(sizeof(union ERMFullStatT));",
          "132:    if (m_eHERMs[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate LAN Stat Memory\");",
          "134:    m_eHEn[i]->BinaryStatus[0] = 0; //modification flags",
          "135:    m_eHERMPrev[i]->data[0] = 0;",
          "136:   }",
          "",
          "[Removed Lines]",
          "126:    if (m_eHEn[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate LAN Names Memory\");",
          "133:    if (m_eHERMPrev[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate LAN Stat Prv Memory\");",
          "",
          "[Added Lines]",
          "138:    if (m_eHEn[i] == NULL) {",
          "139:     LOG(LOG_ERROR, \"CAN'T Allocate LAN Names Memory\");",
          "140:     return;",
          "141:    }",
          "148:    if (m_eHERMPrev[i] == NULL) {",
          "149:     LOG(LOG_ERROR, \"CAN'T Allocate LAN Stat Prv Memory\");",
          "150:     return;",
          "151:    }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "150:   if (m_eHn[i] == NULL)",
          "151:   {",
          "152:    m_eHn[i] = (struct eHouse1NamesT *) malloc(sizeof(struct eHouse1NamesT));",
          "154:    m_eHn[i]->INITIALIZED = 'a'; //first byte of structure for detection of allocated memory",
          "155:    if (i == 0)",
          "156:    {",
          "",
          "[Removed Lines]",
          "153:    if (m_eHn[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate RS-485 Names Memory\");",
          "",
          "[Added Lines]",
          "171:    if (m_eHn[i] == NULL) {",
          "172:     LOG(LOG_ERROR, \"CAN'T Allocate RS-485 Names Memory\");",
          "173:     return;",
          "174:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "172:    m_eHRMs[i] = (union ERMFullStatT *) malloc(sizeof(union ERMFullStatT));",
          "173:    m_eHRMPrev[i] = (union ERMFullStatT *) malloc(sizeof(union ERMFullStatT));",
          "174:    if (m_eHRMs[i] == NULL) LOG(LOG_ERROR, \"CANT Allocate RS-485 Stat Memory\");",
          "176:    m_eHn[i]->BinaryStatus[0] = 0;  //modification flags",
          "177:    m_eHRMPrev[i]->data[0] = 0;",
          "178:   }",
          "",
          "[Removed Lines]",
          "175:    if (m_eHRMPrev[i] == NULL) LOG(LOG_ERROR, \"CANT Allocate RS-485 Stat Prev Memory\");",
          "",
          "[Added Lines]",
          "196:    if (m_eHRMPrev[i] == NULL) {",
          "197:     LOG(LOG_ERROR, \"CANT Allocate RS-485 Stat Prev Memory\");",
          "198:     return;",
          "199:    }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "193:   {",
          "194:    LOG(LOG_STATUS, \"Allocating eHouse WiFi Controller (192.168.%d.%d)\", devaddrh, m_INITIAL_ADDRESS_WIFI + i);",
          "195:    m_eHWIFIn[i] = (struct WiFieHouseNamesT *) malloc(sizeof(struct WiFieHouseNamesT));",
          "197:    m_eHWIFIn[i]->INITIALIZED = 'a'; //first byte of structure for detection of allocated memory",
          "198:    m_eHWIFIn[i]->AddrH = devaddrh;",
          "199:    m_eHWIFIn[i]->AddrL = devaddrl;",
          "",
          "[Removed Lines]",
          "196:    if (m_eHWIFIn[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate WiFi Names Memory\");",
          "",
          "[Added Lines]",
          "220:    if (m_eHWIFIn[i] == NULL) {",
          "221:     LOG(LOG_ERROR, \"CAN'T Allocate WiFi Names Memory\");",
          "222:     return;",
          "223:    }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "201:    m_eHWIFIs[i] = (union WIFIFullStatT *) malloc(sizeof(union WIFIFullStatT));",
          "202:    m_eHWIFIPrev[i] = (union WIFIFullStatT *) malloc(sizeof(union WIFIFullStatT));",
          "203:    if (m_eHWIFIs[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate WiFi Stat Memory\");",
          "205:    m_eHWIFIn[i]->BinaryStatus[0] = 0;",
          "206:    m_eHWIFIPrev[i]->data[0] = 0;",
          "207:   }",
          "",
          "[Removed Lines]",
          "204:    if (m_eHWIFIPrev[i] == NULL) LOG(LOG_ERROR, \"CAN'T Allocate WiFi Stat Memory\");",
          "",
          "[Added Lines]",
          "231:    if (m_eHWIFIPrev[i] == NULL) {",
          "232:     LOG(LOG_ERROR, \"CAN'T Allocate WiFi Stat Memory\");",
          "233:     return;",
          "234:    }",
          "",
          "---------------"
        ],
        "hardware/eHouseTCP.cpp||hardware/eHouseTCP.cpp": [
          "File: hardware/eHouseTCP.cpp -> hardware/eHouseTCP.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "270:  {",
          "276:  result = m_sql.safe_query(\"SELECT ID FROM DeviceStatus WHERE (HardwareID==%d) AND (DeviceID=='%q') AND (Unit==%d)\",m_HwdID,                IDX,           devl );",
          "",
          "[Removed Lines]",
          "273:  m_sql.safe_query(\"INSERT INTO DeviceStatus (HardwareID, DeviceID, Unit, Type, SubType, SignalLevel, BatteryLevel, nValue, sValue, Name,     Used, SwitchType ) VALUES ('%d',      '%q',       '%d','%d',  '%d',   '%d',       '%d',           '%d',   '%q', '%q',     1, %d)\",",
          "274:                                             m_HwdID,    IDX,        devl,type,subtype,  signal,     battery,      nValue, sValue,devname.c_str(), swtype);",
          "",
          "[Added Lines]",
          "273:   m_sql.safe_query(\"INSERT INTO DeviceStatus (HardwareID, DeviceID, Unit, Type, SubType, SignalLevel, BatteryLevel, nValue, sValue, Name, Used, SwitchType ) VALUES ('%d', '%q', '%d','%d', '%d', '%d', '%d', '%d', '%q', '%q', 1, %d)\",",
          "274:    m_HwdID, IDX, devl, type, subtype, signal, battery, nValue, sValue, devname.c_str(), swtype);",
          "",
          "---------------"
        ],
        "hardware/plugins/PluginTransports.cpp||hardware/plugins/PluginTransports.cpp": [
          "File: hardware/plugins/PluginTransports.cpp -> hardware/plugins/PluginTransports.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "416:  {",
          "417:   std::lock_guard<std::mutex> l(PythonMutex); // Take mutex to guard access to CPluginTransport::m_pConnection",
          "418:   CPlugin* pPlugin = ((CConnection*)m_pConnection)->pPlugin;",
          "419:   if (!e)",
          "420:   {",
          "421:    pPlugin->MessagePlugin(new ReadEvent(pPlugin, m_pConnection, bytes_transferred, m_Buffer));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "419:   if (!pPlugin)",
          "420:    return;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "433:   }",
          "434:   else",
          "435:   {",
          "437:     ((e == boost::asio::error::operation_aborted) || (e == boost::asio::error::eof)))",
          "438:     _log.Log(LOG_NORM, \"(%s) Queued asyncronous secure read aborted.\", pPlugin->m_Name.c_str());",
          "439:    else",
          "440:    {",
          "441:     if ((e.value() != boost::asio::error::eof) &&",
          "",
          "[Removed Lines]",
          "436:    if (pPlugin && (pPlugin->m_bDebug & PDM_CONNECTION) &&",
          "",
          "[Added Lines]",
          "438:    if ((pPlugin->m_bDebug & PDM_CONNECTION) &&",
          "440:    {",
          "442:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "582:      (ec.value() != 125) && // Operation canceled",
          "583:      (ec.value() != boost::asio::error::operation_aborted) && // Abort due to shutdown during disconnect",
          "584:      (ec.value() != 1236)) // local disconnect cause by hardware reload",
          "586:    }",
          "588:    pPlugin->MessagePlugin(new DisconnectedEvent(pPlugin, m_pConnection, false));",
          "",
          "[Removed Lines]",
          "585:      _log.Log(LOG_ERROR, \"(%s): Async UDP Read Exception: %d, %s\", ((CConnection*)m_pConnection)->pPlugin->m_Name.c_str(), ec.value(), ec.message().c_str());",
          "",
          "[Added Lines]",
          "590:      _log.Log(LOG_ERROR, \"(%s): Async UDP Read Exception: %d, %s\", pPlugin->m_Name.c_str(), ec.value(), ec.message().c_str());",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "764:  {",
          "765:   std::lock_guard<std::mutex> l(PythonMutex); // Take mutex to guard access to CPluginTransport::m_pConnection",
          "766:   CPlugin* pPlugin = ((CConnection*)m_pConnection)->pPlugin;",
          "768:   if (!ec)",
          "769:   {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "772:   if (!pPlugin)",
          "773:    return;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "804:   }",
          "805:   else",
          "806:   {",
          "808:     ((ec == boost::asio::error::operation_aborted) || (ec == boost::asio::error::eof)))",
          "809:     _log.Log(LOG_NORM, \"(%s) Queued asyncronous ICMP read aborted (%s).\", pPlugin->m_Name.c_str(), m_IP.c_str());",
          "810:    else",
          "",
          "[Removed Lines]",
          "807:    if (pPlugin && (pPlugin->m_bDebug & PDM_CONNECTION) &&",
          "",
          "[Added Lines]",
          "814:    if ((pPlugin->m_bDebug & PDM_CONNECTION) &&",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "814:      (ec.value() != 125) && // Operation canceled",
          "815:      (ec.value() != boost::asio::error::operation_aborted) && // Abort due to shutdown during disconnect",
          "816:      (ec.value() != 1236)) // local disconnect cause by hardware reload",
          "818:    }",
          "820:    pPlugin->MessagePlugin(new DisconnectedEvent(pPlugin, m_pConnection, false));",
          "",
          "[Removed Lines]",
          "817:       _log.Log(LOG_ERROR, \"(%s): Async Receive From Exception: %d, %s\", ((CConnection*)m_pConnection)->pPlugin->m_Name.c_str(), ec.value(), ec.message().c_str());",
          "",
          "[Added Lines]",
          "824:       _log.Log(LOG_ERROR, \"(%s): Async Receive From Exception: %d, %s\", pPlugin->m_Name.c_str(), ec.value(), ec.message().c_str());",
          "",
          "---------------"
        ],
        "hardware/plugins/PythonObjects.cpp||hardware/plugins/PythonObjects.cpp": [
          "File: hardware/plugins/PythonObjects.cpp -> hardware/plugins/PythonObjects.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "841:     DevRowIdx = m_sql.UpdateValue(self->HwdID, sDeviceID.c_str(), (const unsigned char)self->Unit, (const unsigned char)self->Type, (const unsigned char)self->SubType, iSignalLevel, iBatteryLevel, nValue, sValue, sName, true);",
          "845:     {",
          "846:      switch (nValue)",
          "847:      {",
          "",
          "[Removed Lines]",
          "844:     if ((self->Type == pTypeSecurity1) && (self->SubType = sTypeDomoticzSecurity) && (self->nValue != nValue))",
          "",
          "[Added Lines]",
          "844:     if ((self->Type == pTypeSecurity1) && (self->SubType == sTypeDomoticzSecurity) && (self->nValue != nValue))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1090:   }",
          "1091:   else",
          "1092:   {",
          "1094:   }",
          "1096:   try",
          "",
          "[Removed Lines]",
          "1093:    _log.Log(LOG_ERROR, \"(%s) CConnection Type is not ready.\", self->pPlugin->m_Name.c_str());",
          "",
          "[Added Lines]",
          "1095:    _log.Log(LOG_ERROR, \"(Python plugin) CConnection Type is not ready!\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "78ed6e28af2a21bf11327efce220980776ad4bec",
      "candidate_info": {
        "commit_hash": "78ed6e28af2a21bf11327efce220980776ad4bec",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/78ed6e28af2a21bf11327efce220980776ad4bec",
        "files": [
          "main/SQLHelper.cpp"
        ],
        "message": "Trying to fix possible crash (''std::invalid_argument' what():  stoll)",
        "before_after_code_files": [
          "main/SQLHelper.cpp||main/SQLHelper.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "main/SQLHelper.cpp||main/SQLHelper.cpp": [
          "File: main/SQLHelper.cpp -> main/SQLHelper.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "5590:     sValue = szTmp;",
          "5591:    }",
          "5594:    long long MeterUsage = std::stoll(susage);",
          "",
          "[Removed Lines]",
          "5593:    long long MeterValue = std::stoll(sValue);",
          "",
          "[Added Lines]",
          "5593:    long long MeterValue = (!sValue.empty()) ? std::stoll(sValue) : 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f5fb220c7d8aed08f016ced39dd9c83eea9e92d6",
      "candidate_info": {
        "commit_hash": "f5fb220c7d8aed08f016ced39dd9c83eea9e92d6",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/f5fb220c7d8aed08f016ced39dd9c83eea9e92d6",
        "files": [
          "History.txt",
          "main/Scheduler.cpp",
          "main/WebServer.cpp",
          "main/WebServer.h",
          "www/app/TimerplanController.js",
          "www/i18n/domoticz-ar.json.gz",
          "www/i18n/domoticz-bg.json.gz",
          "www/i18n/domoticz-bs.json.gz",
          "www/i18n/domoticz-ca.json.gz",
          "www/i18n/domoticz-cs.json.gz",
          "www/i18n/domoticz-da.json.gz",
          "www/i18n/domoticz-de.json.gz",
          "www/i18n/domoticz-el.json.gz",
          "www/i18n/domoticz-en.json.gz",
          "www/i18n/domoticz-es.json.gz",
          "www/i18n/domoticz-et.json.gz",
          "www/i18n/domoticz-fa.json.gz",
          "www/i18n/domoticz-fi.json.gz",
          "www/i18n/domoticz-fr.json.gz",
          "www/i18n/domoticz-he.json.gz",
          "www/i18n/domoticz-hu.json.gz",
          "www/i18n/domoticz-is.json.gz",
          "www/i18n/domoticz-it.json.gz",
          "www/i18n/domoticz-lt.json.gz",
          "www/i18n/domoticz-lv.json.gz",
          "www/i18n/domoticz-mk.json.gz",
          "www/i18n/domoticz-nl.json.gz",
          "www/i18n/domoticz-no.json.gz",
          "www/i18n/domoticz-pl.json.gz",
          "www/i18n/domoticz-pt.json.gz",
          "www/i18n/domoticz-ro.json.gz",
          "www/i18n/domoticz-ru.json.gz",
          "www/i18n/domoticz-sk.json.gz",
          "www/i18n/domoticz-sl.json.gz",
          "www/i18n/domoticz-sq.json.gz",
          "www/i18n/domoticz-sr.json.gz",
          "www/i18n/domoticz-sv.json.gz",
          "www/i18n/domoticz-th.json.gz",
          "www/i18n/domoticz-tr.json.gz",
          "www/i18n/domoticz-uk.json.gz",
          "www/i18n/domoticz-zh.json.gz",
          "www/views/timerplan.html"
        ],
        "message": "Implemented: Timer Plan, duplicate option",
        "before_after_code_files": [
          "main/Scheduler.cpp||main/Scheduler.cpp",
          "main/WebServer.cpp||main/WebServer.cpp",
          "main/WebServer.h||main/WebServer.h",
          "www/app/TimerplanController.js||www/app/TimerplanController.js",
          "www/views/timerplan.html||www/views/timerplan.html"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "main/Scheduler.cpp||main/Scheduler.cpp": [
          "File: main/Scheduler.cpp -> main/Scheduler.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "2152:     );",
          "2153:    m_mainworker.m_scheduler.ReloadSchedules();",
          "2154:   }",
          "2155:  }",
          "2156: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2156:   void CWebServer::Cmd_GetTimerPlans(WebEmSession & session, const request& req, Json::Value &root)",
          "2157:   {",
          "2158:    if (session.rights != 2)",
          "2159:    {",
          "2160:     session.reply_status = reply::forbidden;",
          "2161:     return; //Only admin user allowed",
          "2162:    }",
          "2163:    root[\"status\"] = \"OK\";",
          "2164:    root[\"title\"] = \"GetTimerPlans\";",
          "2165:    std::vector<std::vector<std::string> > result;",
          "2166:    result = m_sql.safe_query(\"SELECT ID, Name FROM TimerPlans ORDER BY Name COLLATE NOCASE ASC\");",
          "2167:    if (!result.empty())",
          "2168:    {",
          "2169:     int ii = 0;",
          "2170:     for (const auto & itt : result)",
          "2171:     {",
          "2172:      std::vector<std::string> sd = itt;",
          "2173:      root[\"result\"][ii][\"idx\"] = sd[0];",
          "2174:      root[\"result\"][ii][\"Name\"] = sd[1];",
          "2175:      ii++;",
          "2176:     }",
          "2177:    }",
          "2178:   }",
          "2180:   void CWebServer::Cmd_AddTimerPlan(WebEmSession & session, const request& req, Json::Value &root)",
          "2181:   {",
          "2182:    if (session.rights != 2)",
          "2183:    {",
          "2184:     session.reply_status = reply::forbidden;",
          "2185:     return; //Only admin user allowed",
          "2186:    }",
          "2188:    std::string name = request::findValue(&req, \"name\");",
          "2189:    root[\"status\"] = \"OK\";",
          "2190:    root[\"title\"] = \"AddTimerPlan\";",
          "2191:    m_sql.safe_query(\"INSERT INTO TimerPlans (Name) VALUES ('%q')\", name.c_str());",
          "2192:   }",
          "2194:   void CWebServer::Cmd_UpdateTimerPlan(WebEmSession & session, const request& req, Json::Value &root)",
          "2195:   {",
          "2196:    if (session.rights != 2)",
          "2197:    {",
          "2198:     session.reply_status = reply::forbidden;",
          "2199:     return; //Only admin user allowed",
          "2200:    }",
          "2202:    std::string idx = request::findValue(&req, \"idx\");",
          "2203:    if (idx.empty())",
          "2204:     return;",
          "2205:    std::string name = request::findValue(&req, \"name\");",
          "2206:    if (",
          "2207:     (name.empty())",
          "2208:     )",
          "2209:     return;",
          "2211:    root[\"status\"] = \"OK\";",
          "2212:    root[\"title\"] = \"UpdateTimerPlan\";",
          "2214:    m_sql.safe_query(\"UPDATE TimerPlans SET Name='%q' WHERE (ID == '%q')\", name.c_str(), idx.c_str());",
          "2215:   }",
          "2217:   void CWebServer::Cmd_DeleteTimerPlan(WebEmSession & session, const request& req, Json::Value &root)",
          "2218:   {",
          "2219:    if (session.rights != 2)",
          "2220:    {",
          "2221:     session.reply_status = reply::forbidden;",
          "2222:     return; //Only admin user allowed",
          "2223:    }",
          "2225:    std::string idx = request::findValue(&req, \"idx\");",
          "2226:    if (idx.empty())",
          "2227:     return;",
          "2228:    int iPlan = atoi(idx.c_str());",
          "2229:    if (iPlan < 1)",
          "2230:     return;",
          "2232:    root[\"status\"] = \"OK\";",
          "2233:    root[\"title\"] = \"DeletePlan\";",
          "2235:    m_sql.safe_query(\"DELETE FROM Timers WHERE (TimerPlan == '%q')\", idx.c_str());",
          "2236:    m_sql.safe_query(\"DELETE FROM SceneTimers WHERE (TimerPlan == '%q')\", idx.c_str());",
          "2237:    m_sql.safe_query(\"DELETE FROM SetpointTimers WHERE (TimerPlan == '%q')\", idx.c_str());",
          "2239:    m_sql.safe_query(\"DELETE FROM TimerPlans WHERE (ID == '%q')\", idx.c_str());",
          "2241:    if (m_sql.m_ActiveTimerPlan == iPlan)",
          "2242:    {",
          "2244:     m_sql.UpdatePreferencesVar(\"ActiveTimerPlan\", 0);",
          "2245:     m_sql.m_ActiveTimerPlan = 0;",
          "2246:     m_mainworker.m_scheduler.ReloadSchedules();",
          "2247:    }",
          "2248:   }",
          "2250:   void CWebServer::Cmd_DuplicateTimerPlan(WebEmSession & session, const request& req, Json::Value &root)",
          "2251:   {",
          "2252:    if (session.rights != 2)",
          "2253:    {",
          "2254:     session.reply_status = reply::forbidden;",
          "2255:     return; //Only admin user allowed",
          "2256:    }",
          "2258:    std::string idx = request::findValue(&req, \"idx\");",
          "2259:    if (idx.empty())",
          "2260:     return;",
          "2261:    std::string name = request::findValue(&req, \"name\");",
          "2262:    if (",
          "2263:     (name.empty())",
          "2264:     )",
          "2265:     return;",
          "2267:    root[\"status\"] = \"OK\";",
          "2268:    root[\"title\"] = \"DuplicateTimerPlan\";",
          "2270:    m_sql.safe_query(\"INSERT INTO TimerPlans (Name) VALUES ('%q')\", name.c_str());",
          "2272:    std::vector<std::vector<std::string> > result;",
          "2274:    result = m_sql.safe_query(\"SELECT MAX(ID) FROM TimerPlans WHERE (Name=='%q')\", name.c_str());",
          "2275:    if (!result.empty())",
          "2276:    {",
          "2277:     std::string nID = result[0][0];",
          "2280:     result = m_sql.safe_query(\"SELECT Active, DeviceRowID, Time, Type, Cmd, Level, Days, UseRandomness, Hue, [Date], MDay, Month, Occurence, Color FROM Timers WHERE (TimerPlan==%q) ORDER BY ID\", idx.c_str());",
          "2281:     for (const auto & itt : result)",
          "2282:     {",
          "2283:      std::vector<std::string> sd = itt;",
          "2284:      m_sql.safe_query(",
          "2285:       \"INSERT INTO Timers (Active, DeviceRowID, Time, Type, Cmd, Level, Days, UseRandomness, Hue, [Date], MDay, Month, Occurence, Color, TimerPlan) VALUES (%q, %q, '%q', %q, %q, %q, %q, %q, %q, '%q', %q, %q, %q, '%q', %q)\",",
          "2286:       sd[0].c_str(),",
          "2287:       sd[1].c_str(),",
          "2288:       sd[2].c_str(),",
          "2289:       sd[3].c_str(),",
          "2290:       sd[4].c_str(),",
          "2291:       sd[5].c_str(),",
          "2292:       sd[6].c_str(),",
          "2293:       sd[7].c_str(),",
          "2294:       sd[8].c_str(),",
          "2295:       sd[9].c_str(),",
          "2296:       sd[10].c_str(),",
          "2297:       sd[11].c_str(),",
          "2298:       sd[12].c_str(),",
          "2299:       sd[13].c_str(),",
          "2300:       nID.c_str()",
          "2301:      );",
          "2302:     }",
          "2304:     result = m_sql.safe_query(\"SELECT Active, SceneRowID, Time, Type, Cmd, Level, Days, UseRandomness, Hue, [Date], Month, MDay, Occurence FROM SceneTimers WHERE (TimerPlan==%q) ORDER BY ID\", idx.c_str());",
          "2305:     for (const auto & itt : result)",
          "2306:     {",
          "2307:      std::vector<std::string> sd = itt;",
          "2308:      m_sql.safe_query(",
          "2309:       \"INSERT INTO SceneTimers (Active, SceneRowID, Time, Type, Cmd, Level, Days, UseRandomness, Hue, [Date], Month, MDay, Occurence, TimerPlan) VALUES (%q, %q, '%q', %q, %q, %q, %q, %q, %q, '%q', %q, %q, %q, %q)\",",
          "2310:       sd[0].c_str(),",
          "2311:       sd[1].c_str(),",
          "2312:       sd[2].c_str(),",
          "2313:       sd[3].c_str(),",
          "2314:       sd[4].c_str(),",
          "2315:       sd[5].c_str(),",
          "2316:       sd[6].c_str(),",
          "2317:       sd[7].c_str(),",
          "2318:       sd[8].c_str(),",
          "2319:       sd[9].c_str(),",
          "2320:       sd[10].c_str(),",
          "2321:       sd[11].c_str(),",
          "2322:       sd[12].c_str(),",
          "2323:       nID.c_str()",
          "2324:      );",
          "2325:     }",
          "2327:     result = m_sql.safe_query(\"SELECT Active, DeviceRowID, [Date], Time, Type, Temperature, Days, Month, MDay, Occurence FROM SetpointTimers WHERE (TimerPlan==%q) ORDER BY ID\", idx.c_str());",
          "2328:     for (const auto & itt : result)",
          "2329:     {",
          "2330:      std::vector<std::string> sd = itt;",
          "2331:      m_sql.safe_query(",
          "2332:       \"INSERT INTO SetpointTimers (Active, DeviceRowID, [Date], Time, Type, Temperature, Days, Month, MDay, Occurence, TimerPlan) VALUES (%q, %q, '%q', '%q', %q, %q, %q, %q, %q, %q, %q)\",",
          "2333:       sd[0].c_str(),",
          "2334:       sd[1].c_str(),",
          "2335:       sd[2].c_str(),",
          "2336:       sd[3].c_str(),",
          "2337:       sd[4].c_str(),",
          "2338:       sd[5].c_str(),",
          "2339:       sd[6].c_str(),",
          "2340:       sd[7].c_str(),",
          "2341:       sd[8].c_str(),",
          "2342:       sd[9].c_str(),",
          "2343:       nID.c_str()",
          "2344:      );",
          "2345:     }",
          "2346:    }",
          "2347:   }",
          "",
          "---------------"
        ],
        "main/WebServer.cpp||main/WebServer.cpp": [
          "File: main/WebServer.cpp -> main/WebServer.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "500:    RegisterCommandCode(\"addtimerplan\", boost::bind(&CWebServer::Cmd_AddTimerPlan, this, _1, _2, _3));",
          "501:    RegisterCommandCode(\"updatetimerplan\", boost::bind(&CWebServer::Cmd_UpdateTimerPlan, this, _1, _2, _3));",
          "502:    RegisterCommandCode(\"deletetimerplan\", boost::bind(&CWebServer::Cmd_DeleteTimerPlan, this, _1, _2, _3));",
          "504:    RegisterCommandCode(\"getactualhistory\", boost::bind(&CWebServer::Cmd_GetActualHistory, this, _1, _2, _3));",
          "505:    RegisterCommandCode(\"getnewhistory\", boost::bind(&CWebServer::Cmd_GetNewHistory, this, _1, _2, _3));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "503:    RegisterCommandCode(\"duplicatetimerplan\", boost::bind(&CWebServer::Cmd_DuplicateTimerPlan, this, _1, _2, _3));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2416:     aOrder.c_str(), oID.c_str());",
          "2417:   }",
          "2509:   void CWebServer::Cmd_GetVersion(WebEmSession & session, const request& req, Json::Value &root)",
          "2510:   {",
          "2511:    root[\"status\"] = \"OK\";",
          "",
          "[Removed Lines]",
          "2419:   void CWebServer::Cmd_GetTimerPlans(WebEmSession & session, const request& req, Json::Value &root)",
          "2420:   {",
          "2421:    if (session.rights != 2)",
          "2422:    {",
          "2423:     session.reply_status = reply::forbidden;",
          "2424:     return; //Only admin user allowed",
          "2425:    }",
          "2426:    root[\"status\"] = \"OK\";",
          "2427:    root[\"title\"] = \"GetTimerPlans\";",
          "2428:    std::vector<std::vector<std::string> > result;",
          "2429:    result = m_sql.safe_query(\"SELECT ID, Name FROM TimerPlans ORDER BY Name COLLATE NOCASE ASC\");",
          "2430:    if (!result.empty())",
          "2431:    {",
          "2432:     int ii = 0;",
          "2433:     for (const auto & itt : result)",
          "2434:     {",
          "2435:      std::vector<std::string> sd = itt;",
          "2436:      root[\"result\"][ii][\"idx\"] = sd[0];",
          "2437:      root[\"result\"][ii][\"Name\"] = sd[1];",
          "2438:      ii++;",
          "2439:     }",
          "2440:    }",
          "2441:   }",
          "2443:   void CWebServer::Cmd_AddTimerPlan(WebEmSession & session, const request& req, Json::Value &root)",
          "2444:   {",
          "2445:    if (session.rights != 2)",
          "2446:    {",
          "2447:     session.reply_status = reply::forbidden;",
          "2448:     return; //Only admin user allowed",
          "2449:    }",
          "2451:    std::string name = request::findValue(&req, \"name\");",
          "2452:    root[\"status\"] = \"OK\";",
          "2453:    root[\"title\"] = \"AddTimerPlan\";",
          "2454:    m_sql.safe_query(\"INSERT INTO TimerPlans (Name) VALUES ('%q')\", name.c_str());",
          "2455:   }",
          "2457:   void CWebServer::Cmd_UpdateTimerPlan(WebEmSession & session, const request& req, Json::Value &root)",
          "2458:   {",
          "2459:    if (session.rights != 2)",
          "2460:    {",
          "2461:     session.reply_status = reply::forbidden;",
          "2462:     return; //Only admin user allowed",
          "2463:    }",
          "2465:    std::string idx = request::findValue(&req, \"idx\");",
          "2466:    if (idx.empty())",
          "2467:     return;",
          "2468:    std::string name = request::findValue(&req, \"name\");",
          "2469:    if (",
          "2470:     (name.empty())",
          "2471:     )",
          "2472:     return;",
          "2474:    root[\"status\"] = \"OK\";",
          "2475:    root[\"title\"] = \"UpdateTimerPlan\";",
          "2477:    m_sql.safe_query(\"UPDATE TimerPlans SET Name='%q' WHERE (ID == '%q')\", name.c_str(), idx.c_str());",
          "2478:   }",
          "2480:   void CWebServer::Cmd_DeleteTimerPlan(WebEmSession & session, const request& req, Json::Value &root)",
          "2481:   {",
          "2482:    if (session.rights != 2)",
          "2483:    {",
          "2484:     session.reply_status = reply::forbidden;",
          "2485:     return; //Only admin user allowed",
          "2486:    }",
          "2488:    std::string idx = request::findValue(&req, \"idx\");",
          "2489:    if (idx.empty())",
          "2490:     return;",
          "2491:    int iPlan = atoi(idx.c_str());",
          "2492:    if (iPlan < 1)",
          "2493:     return;",
          "2495:    root[\"status\"] = \"OK\";",
          "2496:    root[\"title\"] = \"DeletePlan\";",
          "2497:    m_sql.safe_query(\"DELETE FROM Timers WHERE (TimerPlan == '%q')\", idx.c_str());",
          "2498:    m_sql.safe_query(\"DELETE FROM TimerPlans WHERE (ID == '%q')\", idx.c_str());",
          "2500:    if (m_sql.m_ActiveTimerPlan == iPlan)",
          "2501:    {",
          "2503:     m_sql.UpdatePreferencesVar(\"ActiveTimerPlan\", 0);",
          "2504:     m_sql.m_ActiveTimerPlan = 0;",
          "2505:     m_mainworker.m_scheduler.ReloadSchedules();",
          "2506:    }",
          "2507:   }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "main/WebServer.h||main/WebServer.h": [
          "File: main/WebServer.h -> main/WebServer.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "280:  void Cmd_AddTimerPlan(WebEmSession & session, const request& req, Json::Value &root);",
          "281:  void Cmd_UpdateTimerPlan(WebEmSession & session, const request& req, Json::Value &root);",
          "282:  void Cmd_DeleteTimerPlan(WebEmSession & session, const request& req, Json::Value &root);",
          "284:  void Cmd_AddCamera(WebEmSession & session, const request& req, Json::Value &root);",
          "285:  void Cmd_UpdateCamera(WebEmSession & session, const request& req, Json::Value &root);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "283:  void Cmd_DuplicateTimerPlan(WebEmSession & session, const request& req, Json::Value &root);",
          "",
          "---------------"
        ],
        "www/app/TimerplanController.js||www/app/TimerplanController.js": [
          "File: www/app/TimerplanController.js -> www/app/TimerplanController.js",
          "--- Hunk 1 ---",
          "[Context before]",
          "55:    });",
          "56:   }",
          "58:   DeleteTimerPlan = function(idx)",
          "59:   {",
          "60:    bootbox.confirm($.t(\"Are you sure you want to delete this Plan?\"), function(result) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "58:   CopyTimerPlan = function(idx)",
          "59:   {",
          "60:    $( \"#dialog-add-edit-timerplan\" ).dialog({",
          "61:     resizable: false,",
          "62:     width: 390,",
          "63:     height:200,",
          "64:     modal: true,",
          "65:     title: 'Duplicate Plan',",
          "66:     buttons: {",
          "67:      \"Cancel\": function() {",
          "68:       $( this ).dialog( \"close\" );",
          "69:      },",
          "70:      \"Duplicate\": function() {",
          "71:       var csettings=GetTimerPlanSettings();",
          "72:       if (typeof csettings == 'undefined') {",
          "73:        return;",
          "74:       }",
          "75:       $( this ).dialog( \"close\" );",
          "76:       DuplicateTimerPlan(idx);",
          "77:      }",
          "78:     },",
          "79:     close: function() {",
          "80:      $( this ).dialog( \"close\" );",
          "81:     }",
          "82:    });",
          "83:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:    });",
          "109:   }",
          "111:   AddTimerPlan = function()",
          "112:   {",
          "113:    var csettings=GetTimerPlanSettings();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:   DuplicateTimerPlan = function(idx)",
          "139:   {",
          "140:    var csettings=GetTimerPlanSettings();",
          "141:    if (typeof csettings == 'undefined') {",
          "142:     return;",
          "143:    }",
          "145:    $.ajax({",
          "146:      url: \"json.htm?type=command&param=duplicatetimerplan&idx=\" + idx +\"&name=\" + csettings.name,",
          "147:      async: false,",
          "148:      dataType: 'json',",
          "149:      success: function(data) {",
          "150:      RefreshTimerPlanTable();",
          "151:      },",
          "152:      error: function(){",
          "153:      ShowNotify('Problem duplicating Plan!', 2500, true);",
          "154:      }",
          "155:    });",
          "156:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135:    $.devIdx=-1;",
          "137:    $('#updelclr #timerplanedit').attr(\"class\", \"btnstyle3-dis\");",
          "138:    $('#updelclr #timerplandelete').attr(\"class\", \"btnstyle3-dis\");",
          "140:    var oTable = $('#timerplantable').dataTable();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "185:    $('#updelclr #timerplancopy').attr(\"class\", \"btnstyle3-dis\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "170:     if ( $(this).hasClass('row_selected') ) {",
          "171:      $(this).removeClass('row_selected');",
          "172:      $('#updelclr #timerplanedit').attr(\"class\", \"btnstyle3-dis\");",
          "173:      $('#updelclr #timerplandelete').attr(\"class\", \"btnstyle3-dis\");",
          "174:      $(\"#dialog-add-edit-plan #planname\").val(\"\");",
          "175:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221:      $('#updelclr #timerplancopy').attr(\"class\", \"btnstyle3-dis\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "178:      oTable.$('tr.row_selected').removeClass('row_selected');",
          "179:      $(this).addClass('row_selected');",
          "180:      $('#updelclr #timerplanedit').attr(\"class\", \"btnstyle3-dis\");",
          "181:      $('#updelclr #timerplandelete').attr(\"class\", \"btnstyle3-dis\");",
          "183:      var anSelected = fnGetSelected( oTable );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230:      $('#updelclr #timerplancopy').attr(\"class\", \"btnstyle3-dis\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "187:       $.devIdx=idx;",
          "188:       $('#updelclr #timerplanedit').attr(\"class\", \"btnstyle3\");",
          "189:       $(\"#updelclr #timerplanedit\").attr(\"href\", \"javascript:EditTimerPlan(\" + idx + \")\");",
          "190:       if (idx!=0) {",
          "192:        $('#updelclr #timerplandelete').attr(\"class\", \"btnstyle3\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:       $('#updelclr #timerplancopy').attr(\"class\", \"btnstyle3\");",
          "241:       $(\"#updelclr #timerplancopy\").attr(\"href\", \"javascript:CopyTimerPlan(\" + idx + \")\");",
          "",
          "---------------"
        ],
        "www/views/timerplan.html||www/views/timerplan.html": [
          "File: www/views/timerplan.html -> www/views/timerplan.html",
          "--- Hunk 1 ---",
          "[Context before]",
          "29:   <tr>",
          "30:    <td>",
          "31:     <a class=\"btnstyle3-dis\" id=\"timerplanedit\" data-i18n=\"Edit\">Edit</a>&nbsp;&nbsp;&nbsp;",
          "32:     <a class=\"btnstyle3-dis\" id=\"timerplandelete\" data-i18n=\"Delete\">Delete</a>",
          "33:    </td>",
          "34:   </tr>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32:     <a class=\"btnstyle3-dis\" id=\"timerplancopy\" data-i18n=\"Duplicate\">Duplicate</a>&nbsp;&nbsp;&nbsp;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
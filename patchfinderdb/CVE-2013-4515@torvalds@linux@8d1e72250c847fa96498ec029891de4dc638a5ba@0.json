{
  "cve_id": "CVE-2013-4515",
  "cve_desc": "The bcm_char_ioctl function in drivers/staging/bcm/Bcmchar.c in the Linux kernel before 3.12 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel memory via an IOCTL_BCM_GET_DEVICE_DRIVER_INFO ioctl call.",
  "repo": "torvalds/linux",
  "patch_hash": "8d1e72250c847fa96498ec029891de4dc638a5ba",
  "patch_info": {
    "commit_hash": "8d1e72250c847fa96498ec029891de4dc638a5ba",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/8d1e72250c847fa96498ec029891de4dc638a5ba",
    "files": [
      "drivers/staging/bcm/Bcmchar.c"
    ],
    "message": "Staging: bcm: info leak in ioctl\n\nThe DevInfo.u32Reserved[] array isn't initialized so it leaks kernel\ninformation to user space.\n\nReported-by: Nico Golde <nico@ngolde.de>\nReported-by: Fabian Yamaguchi <fabs@goesec.de>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
    ]
  },
  "patch_diff": {
    "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c": [
      "File: drivers/staging/bcm/Bcmchar.c -> drivers/staging/bcm/Bcmchar.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1961:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\");",
      "1963:   DevInfo.MaxRDMBufferSize = BUFFER_4K;",
      "1964:   DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;",
      "1965:   DevInfo.u32RxAlignmentCorrection = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1963:   memset(&DevInfo, 0, sizeof(DevInfo));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "11d37b1f36c83e80267630c9856eb205b7426e0b",
      "candidate_info": {
        "commit_hash": "11d37b1f36c83e80267630c9856eb205b7426e0b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/11d37b1f36c83e80267630c9856eb205b7426e0b",
        "files": [
          "drivers/staging/bcm/Bcmchar.c"
        ],
        "message": "Staging: bcm: Bcmchar.c: Renamed variable: \"Adapter\" -> \"ad\"\n\nSigned-off-by: Matthias Beyer <mail@beyermatthias.de>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
          ],
          "candidate": [
            "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c": [
          "File: drivers/staging/bcm/Bcmchar.c -> drivers/staging/bcm/Bcmchar.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "587: }",
          "589: static int bcm_char_ioctl_led_thread_state_change_req(void __user *argp,",
          "591: {",
          "592:  struct bcm_user_thread_req threadReq = {0};",
          "593:  struct bcm_ioctl_buffer IoBuffer;",
          "596:    \"User made LED thread InActive\");",
          "603:     DBG_LVL_ALL,",
          "604:     \"GPIO Can't be set/clear in Low power Mode\");",
          "605:   return -EACCES;",
          "",
          "[Removed Lines]",
          "590:   struct bcm_mini_adapter *Adapter)",
          "595:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "598:  if ((Adapter->IdleMode == TRUE) ||",
          "599:   (Adapter->bShutStatus == TRUE) ||",
          "600:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "602:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,",
          "",
          "[Added Lines]",
          "590:   struct bcm_mini_adapter *ad)",
          "595:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "598:  if ((ad->IdleMode == TRUE) ||",
          "599:   (ad->bShutStatus == TRUE) ||",
          "600:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "602:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "622:   if (threadReq.ThreadState == LED_THREAD_ACTIVATION_REQ) {",
          "624:      OSAL_DBG, DBG_LVL_ALL,",
          "625:      \"Activating thread req\");",
          "627:   } else {",
          "629:      OSAL_DBG, DBG_LVL_ALL,",
          "630:      \"DeActivating Thread req.....\");",
          "632:   }",
          "636:  }",
          "637:  return STATUS_SUCCESS;",
          "638: }",
          "640: static int bcm_char_ioctl_gpio_status_request(void __user *argp,",
          "642: {",
          "643:  struct bcm_gpio_info gpio_info = {0};",
          "644:  struct bcm_ioctl_buffer IoBuffer;",
          "",
          "[Removed Lines]",
          "621:  if (Adapter->LEDInfo.led_thread_running) {",
          "623:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,",
          "626:    Adapter->DriverState = LED_THREAD_ACTIVE;",
          "628:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS,",
          "631:    Adapter->DriverState = LED_THREAD_INACTIVE;",
          "635:   wake_up(&Adapter->LEDInfo.notify_led_event);",
          "641:            struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "621:  if (ad->LEDInfo.led_thread_running) {",
          "623:    BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS,",
          "626:    ad->DriverState = LED_THREAD_ACTIVE;",
          "628:    BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS,",
          "631:    ad->DriverState = LED_THREAD_INACTIVE;",
          "635:   wake_up(&ad->LEDInfo.notify_led_event);",
          "641:            struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "647:  INT Status;",
          "648:  int bytes;",
          "653:   return -EACCES;",
          "655:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "650:  if ((Adapter->IdleMode == TRUE) ||",
          "651:   (Adapter->bShutStatus == TRUE) ||",
          "652:   (Adapter->bPreparingForLowPowerMode == TRUE))",
          "",
          "[Added Lines]",
          "650:  if ((ad->IdleMode == TRUE) ||",
          "651:   (ad->bShutStatus == TRUE) ||",
          "652:   (ad->bPreparingForLowPowerMode == TRUE))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "665:  uiBit = gpio_info.uiGpioNumber;",
          "669:     (PUINT)ucRead, sizeof(UINT));",
          "671:  if (bytes < 0) {",
          "672:   Status = bytes;",
          "674:     \"RDM Failed\\n\");",
          "675:   return Status;",
          "676:  } else {",
          "",
          "[Removed Lines]",
          "668:  bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,",
          "673:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "668:  bytes = rdmaltWithLock(ad, (UINT)GPIO_PIN_STATE_REGISTER,",
          "673:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "680: }",
          "682: static int bcm_char_ioctl_gpio_multi_request(void __user *argp,",
          "684: {",
          "685:  struct bcm_gpio_multi_info gpio_multi_info[MAX_IDX];",
          "686:  struct bcm_gpio_multi_info *pgpio_multi_info =",
          "",
          "[Removed Lines]",
          "683:           struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "683:           struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "693:  memset(pgpio_multi_info, 0,",
          "694:         MAX_IDX * sizeof(struct bcm_gpio_multi_info));",
          "699:   return -EINVAL;",
          "701:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "696:  if ((Adapter->IdleMode == TRUE) ||",
          "697:   (Adapter->bShutStatus == TRUE) ||",
          "698:   (Adapter->bPreparingForLowPowerMode == TRUE))",
          "",
          "[Added Lines]",
          "696:  if ((ad->IdleMode == TRUE) ||",
          "697:   (ad->bShutStatus == TRUE) ||",
          "698:   (ad->bPreparingForLowPowerMode == TRUE))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "710:       IoBuffer.InputLength))",
          "711:   return -EFAULT;",
          "714:    == false) {",
          "716:     DBG_LVL_ALL,",
          "717:     \"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",",
          "718:     pgpio_multi_info[WIMAX_IDX].uiGPIOMask,",
          "720:   return -EINVAL;",
          "721:  }",
          "",
          "[Removed Lines]",
          "713:  if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_info[WIMAX_IDX].uiGPIOMask)",
          "715:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,",
          "719:     Adapter->gpioBitMap);",
          "",
          "[Added Lines]",
          "713:  if (IsReqGpioIsLedInNVM(ad, pgpio_multi_info[WIMAX_IDX].uiGPIOMask)",
          "715:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "719:     ad->gpioBitMap);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "729:    pgpio_multi_info[WIMAX_IDX].uiGPIOValue;",
          "731:   if (*(UINT *) ucResetValue)",
          "733:     BCM_GPIO_OUTPUT_SET_REG,",
          "734:     (PUINT)ucResetValue, sizeof(ULONG));",
          "736:   if (Status != STATUS_SUCCESS) {",
          "738:     \"WRM to BCM_GPIO_OUTPUT_SET_REG Failed.\");",
          "739:    return Status;",
          "740:   }",
          "",
          "[Removed Lines]",
          "732:    Status = wrmaltWithLock(Adapter,",
          "737:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "732:    Status = wrmaltWithLock(ad,",
          "737:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "746:    (~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));",
          "748:   if (*(UINT *) ucResetValue)",
          "750:     BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue,",
          "751:     sizeof(ULONG));",
          "753:   if (Status != STATUS_SUCCESS) {",
          "755:      \"WRM to BCM_GPIO_OUTPUT_CLR_REG Failed.\");",
          "756:    return Status;",
          "757:   }",
          "758:  }",
          "760:  if (pgpio_multi_info[WIMAX_IDX].uiGPIOMask) {",
          "762:            (PUINT)ucResetValue, sizeof(UINT));",
          "764:   if (bytes < 0) {",
          "765:    Status = bytes;",
          "767:      \"RDM to GPIO_PIN_STATE_REGISTER Failed.\");",
          "768:    return Status;",
          "769:   } else {",
          "",
          "[Removed Lines]",
          "749:    Status = wrmaltWithLock(Adapter,",
          "754:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "761:   bytes = rdmaltWithLock(Adapter, (UINT)GPIO_PIN_STATE_REGISTER,",
          "766:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "749:    Status = wrmaltWithLock(ad,",
          "754:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "761:   bytes = rdmaltWithLock(ad, (UINT)GPIO_PIN_STATE_REGISTER,",
          "766:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "778:  Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_info,",
          "779:   IoBuffer.OutputLength);",
          "780:  if (Status) {",
          "782:    \"Failed while copying Content to IOBufer for user space err:%d\",",
          "783:    Status);",
          "784:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "781:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "781:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "787: }",
          "789: static int bcm_char_ioctl_gpio_mode_request(void __user *argp,",
          "791: {",
          "792:  struct bcm_gpio_multi_mode gpio_multi_mode[MAX_IDX];",
          "793:  struct bcm_gpio_multi_mode *pgpio_multi_mode =",
          "",
          "[Removed Lines]",
          "790:          struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "790:          struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "797:  INT Status;",
          "798:  int bytes;",
          "803:   return -EINVAL;",
          "805:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "800:  if ((Adapter->IdleMode == TRUE) ||",
          "801:   (Adapter->bShutStatus == TRUE) ||",
          "802:   (Adapter->bPreparingForLowPowerMode == TRUE))",
          "",
          "[Added Lines]",
          "800:  if ((ad->IdleMode == TRUE) ||",
          "801:   (ad->bShutStatus == TRUE) ||",
          "802:   (ad->bPreparingForLowPowerMode == TRUE))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "814:   IoBuffer.InputLength))",
          "815:   return -EFAULT;",
          "818:   (PUINT)ucResetValue, sizeof(UINT));",
          "820:  if (bytes < 0) {",
          "821:   Status = bytes;",
          "823:    \"Read of GPIO_MODE_REGISTER failed\");",
          "824:   return Status;",
          "825:  } else {",
          "",
          "[Removed Lines]",
          "817:  bytes = rdmaltWithLock(Adapter, (UINT)GPIO_MODE_REGISTER,",
          "822:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "817:  bytes = rdmaltWithLock(ad, (UINT)GPIO_MODE_REGISTER,",
          "822:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "827:  }",
          "831:    == false) {",
          "833:     \"Sorry, Requested GPIO<0x%X> is not correspond to NVM LED bit map<0x%X>!!!\",",
          "834:     pgpio_multi_mode[WIMAX_IDX].uiGPIOMask,",
          "836:   return -EINVAL;",
          "837:  }",
          "",
          "[Removed Lines]",
          "830:  if (IsReqGpioIsLedInNVM(Adapter, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask)",
          "832:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "835:     Adapter->gpioBitMap);",
          "",
          "[Added Lines]",
          "830:  if (IsReqGpioIsLedInNVM(ad, pgpio_multi_mode[WIMAX_IDX].uiGPIOMask)",
          "832:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "835:     ad->gpioBitMap);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "853:   pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;",
          "856:    (PUINT)ucResetValue, sizeof(ULONG));",
          "857:   if (Status == STATUS_SUCCESS) {",
          "859:     DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "860:     \"WRM to GPIO_MODE_REGISTER Done\");",
          "861:   } else {",
          "863:      \"WRM to GPIO_MODE_REGISTER Failed\");",
          "864:    return -EFAULT;",
          "865:   }",
          "",
          "[Removed Lines]",
          "855:   Status = wrmaltWithLock(Adapter, GPIO_MODE_REGISTER,",
          "858:    BCM_DEBUG_PRINT(Adapter,",
          "862:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "855:   Status = wrmaltWithLock(ad, GPIO_MODE_REGISTER,",
          "858:    BCM_DEBUG_PRINT(ad,",
          "862:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "871:  Status = copy_to_user(IoBuffer.OutputBuffer, &gpio_multi_mode,",
          "872:   IoBuffer.OutputLength);",
          "873:  if (Status) {",
          "875:    \"Failed while copying Content to IOBufer for user space err:%d\",",
          "876:    Status);",
          "877:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "874:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "874:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "880: }",
          "882: static int bcm_char_ioctl_misc_request(void __user *argp,",
          "884: {",
          "885:  struct bcm_ioctl_buffer IoBuffer;",
          "886:  PVOID pvBuffer = NULL;",
          "",
          "[Removed Lines]",
          "883:            struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "883:            struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "901:  if (IS_ERR(pvBuffer))",
          "902:   return PTR_ERR(pvBuffer);",
          "905:  Status = wait_event_interruptible_timeout(",
          "908:    (1 * HZ));",
          "910:  if (Status == -ERESTARTSYS)",
          "911:   goto cntrlEnd;",
          "915:     \"Preparing Idle Mode is still True - Hence Rejecting control message\\n\");",
          "916:   Status = STATUS_FAILURE;",
          "917:   goto cntrlEnd;",
          "918:  }",
          "921: cntrlEnd:",
          "923:  kfree(pvBuffer);",
          "924:  return Status;",
          "925: }",
          "927: static int bcm_char_ioctl_buffer_download_start(",
          "929: {",
          "930:  INT Status;",
          "934:     \"IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");",
          "935:   return -EACCES;",
          "936:  }",
          "939:    \"Starting the firmware download PID =0x%x!!!!\\n\",",
          "940:    current->pid);",
          "943:   return -EBUSY;",
          "952:  if (Status) {",
          "956:   return Status;",
          "957:  }",
          "958:  mdelay(10);",
          "961:  return Status;",
          "962: }",
          "964: static int bcm_char_ioctl_buffer_download(void __user *argp,",
          "966: {",
          "967:  struct bcm_firmware_info *psFwInfo = NULL;",
          "968:  struct bcm_ioctl_buffer IoBuffer;",
          "969:  INT Status;",
          "972:   \"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);",
          "976:     \"Invalid way to download buffer. Use Start and then call this!!!\\n\");",
          "978:   return -EINVAL;",
          "979:  }",
          "982:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {",
          "984:   return -EFAULT;",
          "985:  }",
          "988:    \"Length for FW DLD is : %lx\\n\", IoBuffer.InputLength);",
          "990:  if (IoBuffer.InputLength > sizeof(struct bcm_firmware_info)) {",
          "992:   return -EINVAL;",
          "993:  }",
          "995:  psFwInfo = kmalloc(sizeof(*psFwInfo), GFP_KERNEL);",
          "996:  if (!psFwInfo) {",
          "998:   return -ENOMEM;",
          "999:  }",
          "1001:  if (copy_from_user(psFwInfo, IoBuffer.InputBuffer,",
          "1002:   IoBuffer.InputLength)) {",
          "1004:   kfree(psFwInfo);",
          "1005:   return -EFAULT;",
          "1006:  }",
          "",
          "[Removed Lines]",
          "904:  down(&Adapter->LowPowerModeSync);",
          "906:    Adapter->lowpower_mode_wait_queue,",
          "907:    !Adapter->bPreparingForLowPowerMode,",
          "913:  if (Adapter->bPreparingForLowPowerMode) {",
          "914:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "919:  Status = CopyBufferToControlPacket(Adapter, (PVOID)pvBuffer);",
          "922:  up(&Adapter->LowPowerModeSync);",
          "928:   struct bcm_mini_adapter *Adapter)",
          "932:  if (down_trylock(&Adapter->NVMRdmWrmLock)) {",
          "933:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "938:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "942:  if (down_trylock(&Adapter->fw_download_sema))",
          "945:  Adapter->bBinDownloaded = false;",
          "946:  Adapter->fw_download_process_pid = current->pid;",
          "947:  Adapter->bCfgDownloaded = false;",
          "948:  Adapter->fw_download_done = false;",
          "949:  netif_carrier_off(Adapter->dev);",
          "950:  netif_stop_queue(Adapter->dev);",
          "951:  Status = reset_card_proc(Adapter);",
          "953:   pr_err(PFX \"%s: reset_card_proc Failed!\\n\", Adapter->dev->name);",
          "954:   up(&Adapter->fw_download_sema);",
          "955:   up(&Adapter->NVMRdmWrmLock);",
          "960:  up(&Adapter->NVMRdmWrmLock);",
          "965:        struct bcm_mini_adapter *Adapter)",
          "971:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "974:  if (!down_trylock(&Adapter->fw_download_sema)) {",
          "975:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "977:   up(&Adapter->fw_download_sema);",
          "983:   up(&Adapter->fw_download_sema);",
          "987:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "991:   up(&Adapter->fw_download_sema);",
          "997:   up(&Adapter->fw_download_sema);",
          "1003:   up(&Adapter->fw_download_sema);",
          "",
          "[Added Lines]",
          "904:  down(&ad->LowPowerModeSync);",
          "906:    ad->lowpower_mode_wait_queue,",
          "907:    !ad->bPreparingForLowPowerMode,",
          "913:  if (ad->bPreparingForLowPowerMode) {",
          "914:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "919:  Status = CopyBufferToControlPacket(ad, (PVOID)pvBuffer);",
          "922:  up(&ad->LowPowerModeSync);",
          "928:   struct bcm_mini_adapter *ad)",
          "932:  if (down_trylock(&ad->NVMRdmWrmLock)) {",
          "933:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "938:  BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "942:  if (down_trylock(&ad->fw_download_sema))",
          "945:  ad->bBinDownloaded = false;",
          "946:  ad->fw_download_process_pid = current->pid;",
          "947:  ad->bCfgDownloaded = false;",
          "948:  ad->fw_download_done = false;",
          "949:  netif_carrier_off(ad->dev);",
          "950:  netif_stop_queue(ad->dev);",
          "951:  Status = reset_card_proc(ad);",
          "953:   pr_err(PFX \"%s: reset_card_proc Failed!\\n\", ad->dev->name);",
          "954:   up(&ad->fw_download_sema);",
          "955:   up(&ad->NVMRdmWrmLock);",
          "960:  up(&ad->NVMRdmWrmLock);",
          "965:        struct bcm_mini_adapter *ad)",
          "971:  BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "974:  if (!down_trylock(&ad->fw_download_sema)) {",
          "975:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "977:   up(&ad->fw_download_sema);",
          "983:   up(&ad->fw_download_sema);",
          "987:  BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "991:   up(&ad->fw_download_sema);",
          "997:   up(&ad->fw_download_sema);",
          "1003:   up(&ad->fw_download_sema);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1008:  if (!psFwInfo->pvMappedFirmwareAddress ||",
          "1009:   (psFwInfo->u32FirmwareLength == 0)) {",
          "1012:     \"Something else is wrong %lu\\n\",",
          "1013:     psFwInfo->u32FirmwareLength);",
          "1015:   kfree(psFwInfo);",
          "1016:   Status = -EINVAL;",
          "1017:   return Status;",
          "1018:  }",
          "1022:  if (Status != STATUS_SUCCESS) {",
          "1023:   if (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)",
          "1025:     \"IOCTL: Configuration File Upload Failed\\n\");",
          "1026:   else",
          "1028:     \"IOCTL: Firmware File Upload Failed\\n\");",
          "1033:    BCM_LED_THREAD_RUNNING_ACTIVELY) {",
          "1037:   }",
          "1038:  }",
          "1040:  if (Status != STATUS_SUCCESS)",
          "1044:   \"IOCTL: Firmware File Uploaded\\n\");",
          "1045:  kfree(psFwInfo);",
          "1046:  return Status;",
          "1047: }",
          "1049: static int bcm_char_ioctl_buffer_download_stop(void __user *argp,",
          "1051: {",
          "1052:  INT Status;",
          "1053:  int timeout = 0;",
          "1057:   return -EINVAL;",
          "1058:  }",
          "1062:     \"FW download blocked as EEPROM Read/Write is in progress\\n\");",
          "1064:   return -EACCES;",
          "1065:  }",
          "1076:  if (Status) {",
          "1078:    \"Firm Download Failed\\n\");",
          "1081:   return Status;",
          "1082:  } else {",
          "1084:     DBG_LVL_ALL, \"Firm Download Over...\\n\");",
          "1085:  }",
          "1087:  mdelay(10);",
          "1092:    \"Unable to send interrupt...\\n\");",
          "1094:  timeout = 5*HZ;",
          "1108:   BCM_LED_THREAD_RUNNING_ACTIVELY) {",
          "1111:  }",
          "1113:  if (!timeout)",
          "1114:   Status = -ENODEV;",
          "1118:  return Status;",
          "1119: }",
          "1122: {",
          "1123:  INT Status;",
          "1124:  INT NVMAccess;",
          "1127:  if (NVMAccess) {",
          "1129:    \" IOCTL_BCM_CHIP_RESET not allowed as EEPROM Read/Write is in progress\\n\");",
          "1130:   return -EACCES;",
          "1131:  }",
          "1135:  flushAllAppQ();",
          "1139:  return Status;",
          "1140: }",
          "1142: static int bcm_char_ioctl_qos_threshold(ULONG arg,",
          "1144: {",
          "1145:  USHORT uiLoopIndex;",
          "1147:  for (uiLoopIndex = 0; uiLoopIndex < NO_OF_QUEUES; uiLoopIndex++) {",
          "1149:     (unsigned long __user *)arg)) {",
          "1150:    return -EFAULT;",
          "1151:   }",
          "",
          "[Removed Lines]",
          "1011:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1014:   up(&Adapter->fw_download_sema);",
          "1020:  Status = bcm_ioctl_fw_download(Adapter, psFwInfo);",
          "1024:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1027:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1032:   if (Adapter->LEDInfo.led_thread_running &",
          "1034:    Adapter->DriverState = DRIVER_INIT;",
          "1035:    Adapter->LEDInfo.bLedInitDone = false;",
          "1036:    wake_up(&Adapter->LEDInfo.notify_led_event);",
          "1041:   up(&Adapter->fw_download_sema);",
          "1043:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL,",
          "1050:             struct bcm_mini_adapter *Adapter)",
          "1055:  if (!down_trylock(&Adapter->fw_download_sema)) {",
          "1056:   up(&Adapter->fw_download_sema);",
          "1060:  if (down_trylock(&Adapter->NVMRdmWrmLock)) {",
          "1061:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1063:   up(&Adapter->fw_download_sema);",
          "1067:  Adapter->bBinDownloaded = TRUE;",
          "1068:  Adapter->bCfgDownloaded = TRUE;",
          "1069:  atomic_set(&Adapter->CurrNumFreeTxDesc, 0);",
          "1070:  Adapter->CurrNumRecvDescs = 0;",
          "1071:  Adapter->downloadDDR = 0;",
          "1074:  Status = run_card_proc(Adapter);",
          "1077:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1079:   up(&Adapter->fw_download_sema);",
          "1080:   up(&Adapter->NVMRdmWrmLock);",
          "1083:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1090:  if (StartInterruptUrb((struct bcm_interface_adapter *)Adapter->pvInterfaceAdapter))",
          "1091:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1095:  Adapter->waiting_to_fw_download_done = false;",
          "1096:  wait_event_timeout(Adapter->ioctl_fw_dnld_wait_queue,",
          "1097:    Adapter->waiting_to_fw_download_done, timeout);",
          "1098:  Adapter->fw_download_process_pid = INVALID_PID;",
          "1099:  Adapter->fw_download_done = TRUE;",
          "1100:  atomic_set(&Adapter->CurrNumFreeTxDesc, 0);",
          "1101:  Adapter->CurrNumRecvDescs = 0;",
          "1102:  Adapter->PrevNumRecvDescs = 0;",
          "1103:  atomic_set(&Adapter->cntrlpktCnt, 0);",
          "1104:  Adapter->LinkUpStatus = 0;",
          "1105:  Adapter->LinkStatus = 0;",
          "1107:  if (Adapter->LEDInfo.led_thread_running &",
          "1109:   Adapter->DriverState = FW_DOWNLOAD_DONE;",
          "1110:   wake_up(&Adapter->LEDInfo.notify_led_event);",
          "1116:  up(&Adapter->fw_download_sema);",
          "1117:  up(&Adapter->NVMRdmWrmLock);",
          "1121: static int bcm_char_ioctl_chip_reset(struct bcm_mini_adapter *Adapter)",
          "1126:  NVMAccess = down_trylock(&Adapter->NVMRdmWrmLock);",
          "1128:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1133:  down(&Adapter->RxAppControlQueuelock);",
          "1134:  Status = reset_card_proc(Adapter);",
          "1136:  up(&Adapter->RxAppControlQueuelock);",
          "1137:  up(&Adapter->NVMRdmWrmLock);",
          "1138:  ResetCounters(Adapter);",
          "1143:      struct bcm_mini_adapter *Adapter)",
          "1148:   if (get_user(Adapter->PackInfo[uiLoopIndex].uiThreshold,",
          "",
          "[Added Lines]",
          "1011:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1014:   up(&ad->fw_download_sema);",
          "1020:  Status = bcm_ioctl_fw_download(ad, psFwInfo);",
          "1024:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1027:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1032:   if (ad->LEDInfo.led_thread_running &",
          "1034:    ad->DriverState = DRIVER_INIT;",
          "1035:    ad->LEDInfo.bLedInitDone = false;",
          "1036:    wake_up(&ad->LEDInfo.notify_led_event);",
          "1041:   up(&ad->fw_download_sema);",
          "1043:  BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL,",
          "1050:             struct bcm_mini_adapter *ad)",
          "1055:  if (!down_trylock(&ad->fw_download_sema)) {",
          "1056:   up(&ad->fw_download_sema);",
          "1060:  if (down_trylock(&ad->NVMRdmWrmLock)) {",
          "1061:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1063:   up(&ad->fw_download_sema);",
          "1067:  ad->bBinDownloaded = TRUE;",
          "1068:  ad->bCfgDownloaded = TRUE;",
          "1069:  atomic_set(&ad->CurrNumFreeTxDesc, 0);",
          "1070:  ad->CurrNumRecvDescs = 0;",
          "1071:  ad->downloadDDR = 0;",
          "1074:  Status = run_card_proc(ad);",
          "1077:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1079:   up(&ad->fw_download_sema);",
          "1080:   up(&ad->NVMRdmWrmLock);",
          "1083:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1090:  if (StartInterruptUrb((struct bcm_interface_adapter *)ad->pvInterfaceAdapter))",
          "1091:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1095:  ad->waiting_to_fw_download_done = false;",
          "1096:  wait_event_timeout(ad->ioctl_fw_dnld_wait_queue,",
          "1097:    ad->waiting_to_fw_download_done, timeout);",
          "1098:  ad->fw_download_process_pid = INVALID_PID;",
          "1099:  ad->fw_download_done = TRUE;",
          "1100:  atomic_set(&ad->CurrNumFreeTxDesc, 0);",
          "1101:  ad->CurrNumRecvDescs = 0;",
          "1102:  ad->PrevNumRecvDescs = 0;",
          "1103:  atomic_set(&ad->cntrlpktCnt, 0);",
          "1104:  ad->LinkUpStatus = 0;",
          "1105:  ad->LinkStatus = 0;",
          "1107:  if (ad->LEDInfo.led_thread_running &",
          "1109:   ad->DriverState = FW_DOWNLOAD_DONE;",
          "1110:   wake_up(&ad->LEDInfo.notify_led_event);",
          "1116:  up(&ad->fw_download_sema);",
          "1117:  up(&ad->NVMRdmWrmLock);",
          "1121: static int bcm_char_ioctl_chip_reset(struct bcm_mini_adapter *ad)",
          "1126:  NVMAccess = down_trylock(&ad->NVMRdmWrmLock);",
          "1128:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1133:  down(&ad->RxAppControlQueuelock);",
          "1134:  Status = reset_card_proc(ad);",
          "1136:  up(&ad->RxAppControlQueuelock);",
          "1137:  up(&ad->NVMRdmWrmLock);",
          "1138:  ResetCounters(ad);",
          "1143:      struct bcm_mini_adapter *ad)",
          "1148:   if (get_user(ad->PackInfo[uiLoopIndex].uiThreshold,",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1154: }",
          "1156: static int bcm_char_ioctl_switch_transfer_mode(void __user *argp,",
          "1158: {",
          "1159:  UINT uiData = 0;",
          "",
          "[Removed Lines]",
          "1157:             struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "1157:             struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1164:  if (uiData) {",
          "1167:    \"IOCTL_BCM_SWITCH_TRANSFER_MODE: ETH_PACKET_TUNNELING_MODE\\n\");",
          "1169:  } else {",
          "1172:    \"IOCTL_BCM_SWITCH_TRANSFER_MODE: IP_PACKET_ONLY_MODE\\n\");",
          "1174:  }",
          "1175:  return STATUS_SUCCESS;",
          "1176: }",
          "",
          "[Removed Lines]",
          "1166:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1168:    Adapter->TransferMode = ETH_PACKET_TUNNELING_MODE;",
          "1171:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1173:   Adapter->TransferMode = IP_PACKET_ONLY_MODE;",
          "",
          "[Added Lines]",
          "1166:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1168:    ad->TransferMode = ETH_PACKET_TUNNELING_MODE;",
          "1171:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1173:   ad->TransferMode = IP_PACKET_ONLY_MODE;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1193: }",
          "1195: static int bcm_char_ioctl_get_current_status(void __user *argp,",
          "1197: {",
          "1198:  struct bcm_link_state link_state;",
          "1199:  struct bcm_ioctl_buffer IoBuffer;",
          "1202:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {",
          "1204:    \"copy_from_user failed..\\n\");",
          "1205:   return -EFAULT;",
          "1206:  }",
          "",
          "[Removed Lines]",
          "1196:           struct bcm_mini_adapter *Adapter)",
          "1203:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1196:           struct bcm_mini_adapter *ad)",
          "1203:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1209:   return -EINVAL;",
          "1211:  memset(&link_state, 0, sizeof(link_state));",
          "1216:  if (copy_to_user(IoBuffer.OutputBuffer, &link_state, min_t(size_t,",
          "1217:   sizeof(link_state), IoBuffer.OutputLength))) {",
          "1219:    \"Copy_to_user Failed..\\n\");",
          "1220:   return -EFAULT;",
          "1221:  }",
          "",
          "[Removed Lines]",
          "1212:  link_state.bIdleMode = Adapter->IdleMode;",
          "1213:  link_state.bShutdownMode = Adapter->bShutStatus;",
          "1214:  link_state.ucLinkStatus = Adapter->LinkStatus;",
          "1218:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1212:  link_state.bIdleMode = ad->IdleMode;",
          "1213:  link_state.bShutdownMode = ad->bShutStatus;",
          "1214:  link_state.ucLinkStatus = ad->LinkStatus;",
          "1218:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1226: static int bcm_char_ioctl_set_mac_tracing(void __user *argp,",
          "1228: {",
          "1229:  struct bcm_ioctl_buffer IoBuffer;",
          "1230:  UINT tracing_flag;",
          "",
          "[Removed Lines]",
          "1227:        struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "1227:        struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1237:   return -EFAULT;",
          "1239:  if (tracing_flag)",
          "1241:  else",
          "1244:  return STATUS_SUCCESS;",
          "1245: }",
          "1247: static int bcm_char_ioctl_get_dsx_indication(void __user *argp,",
          "1249: {",
          "1250:  struct bcm_ioctl_buffer IoBuffer;",
          "1251:  ULONG ulSFId = 0;",
          "",
          "[Removed Lines]",
          "1240:   Adapter->pTarangs->MacTracingEnabled = TRUE;",
          "1242:   Adapter->pTarangs->MacTracingEnabled = false;",
          "1248:           struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "1240:   ad->pTarangs->MacTracingEnabled = TRUE;",
          "1242:   ad->pTarangs->MacTracingEnabled = false;",
          "1248:           struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1254:   return -EFAULT;",
          "1256:  if (IoBuffer.OutputLength < sizeof(struct bcm_add_indication_alt)) {",
          "1258:    \"Mismatch req: %lx needed is =0x%zx!!!\",",
          "1259:    IoBuffer.OutputLength,",
          "1260:    sizeof(struct bcm_add_indication_alt));",
          "",
          "[Removed Lines]",
          "1257:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1257:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1264:  if (copy_from_user(&ulSFId, IoBuffer.InputBuffer, sizeof(ulSFId)))",
          "1265:   return -EFAULT;",
          "1268:   \"Get DSX Data SF ID is =%lx\\n\", ulSFId);",
          "1270:  return STATUS_SUCCESS;",
          "1271: }",
          "1273: static int bcm_char_ioctl_get_host_mibs(void __user *argp,",
          "1275:      struct bcm_tarang_data *pTarang)",
          "1276: {",
          "1277:  struct bcm_ioctl_buffer IoBuffer;",
          "",
          "[Removed Lines]",
          "1267:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1269:  get_dsx_sf_data_to_application(Adapter, ulSFId, IoBuffer.OutputBuffer);",
          "1274:      struct bcm_mini_adapter *Adapter,",
          "",
          "[Added Lines]",
          "1267:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1269:  get_dsx_sf_data_to_application(ad, ulSFId, IoBuffer.OutputBuffer);",
          "1274:      struct bcm_mini_adapter *ad,",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1282:   return -EFAULT;",
          "1284:  if (IoBuffer.OutputLength != sizeof(struct bcm_host_stats_mibs)) {",
          "1286:    \"Length Check failed %lu %zd\\n\", IoBuffer.OutputLength,",
          "1287:    sizeof(struct bcm_host_stats_mibs));",
          "1288:   return -EINVAL;",
          "",
          "[Removed Lines]",
          "1285:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1285:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1293:  if (!temp_buff)",
          "1294:   return STATUS_FAILURE;",
          "1297:  GetDroppedAppCntrlPktMibs(temp_buff, pTarang);",
          "1299:  if (Status != STATUS_FAILURE) {",
          "",
          "[Removed Lines]",
          "1296:  Status = ProcessGetHostMibs(Adapter, temp_buff);",
          "",
          "[Added Lines]",
          "1296:  Status = ProcessGetHostMibs(ad, temp_buff);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1309: }",
          "1311: static int bcm_char_ioctl_bulk_wrm(void __user *argp,",
          "1313: {",
          "1314:  struct bcm_bulk_wrm_buffer *pBulkBuffer;",
          "1315:  struct bcm_ioctl_buffer IoBuffer;",
          "",
          "[Removed Lines]",
          "1312:        struct bcm_mini_adapter *Adapter, UINT cmd)",
          "",
          "[Added Lines]",
          "1312:        struct bcm_mini_adapter *ad, UINT cmd)",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1317:  INT Status = STATUS_FAILURE;",
          "1318:  PCHAR pvBuffer = NULL;",
          "1325:    \"Device in Idle/Shutdown Mode, Blocking Wrms\\n\");",
          "1326:   return -EACCES;",
          "1327:  }",
          "",
          "[Removed Lines]",
          "1320:  if ((Adapter->IdleMode == TRUE) ||",
          "1321:   (Adapter->bShutStatus == TRUE) ||",
          "1322:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "1324:   BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1320:  if ((ad->IdleMode == TRUE) ||",
          "1321:   (ad->bShutStatus == TRUE) ||",
          "1322:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "1324:   BCM_DEBUG_PRINT (ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1343:  if (((ULONG)pBulkBuffer->Register & 0x0F000000) != 0x0F000000 ||",
          "1344:   ((ULONG)pBulkBuffer->Register & 0x3)) {",
          "1346:    \"WRM Done On invalid Address : %x Access Denied.\\n\",",
          "1347:    (int)pBulkBuffer->Register);",
          "1348:   kfree(pvBuffer);",
          "",
          "[Removed Lines]",
          "1345:   BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1345:   BCM_DEBUG_PRINT (ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1350:  }",
          "1352:  uiTempVar = pBulkBuffer->Register & EEPROM_REJECT_MASK;",
          "1354:   ((uiTempVar == EEPROM_REJECT_REG_1) ||",
          "1355:    (uiTempVar == EEPROM_REJECT_REG_2) ||",
          "1356:    (uiTempVar == EEPROM_REJECT_REG_3) ||",
          "",
          "[Removed Lines]",
          "1353:  if (!((Adapter->pstargetparams->m_u32Customize)&VSG_MODE) &&",
          "",
          "[Added Lines]",
          "1353:  if (!((ad->pstargetparams->m_u32Customize)&VSG_MODE) &&",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1358:   (cmd == IOCTL_BCM_REGISTER_WRITE)) {",
          "1360:   kfree(pvBuffer);",
          "1362:    \"EEPROM Access Denied, not in VSG Mode\\n\");",
          "1363:   return -EFAULT;",
          "1364:  }",
          "1366:  if (pBulkBuffer->SwapEndian == false)",
          "1368:    (PCHAR)pBulkBuffer->Values,",
          "1369:    IoBuffer.InputLength - 2*sizeof(ULONG));",
          "1370:  else",
          "1372:    (PUINT)pBulkBuffer->Values,",
          "1373:    IoBuffer.InputLength - 2*sizeof(ULONG));",
          "1375:  if (Status != STATUS_SUCCESS)",
          "1378:  kfree(pvBuffer);",
          "1379:  return Status;",
          "1380: }",
          "1382: static int bcm_char_ioctl_get_nvm_size(void __user *argp,",
          "1384: {",
          "1385:  struct bcm_ioctl_buffer IoBuffer;",
          "1387:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "1388:   return -EFAULT;",
          "1392:    sizeof(UINT)))",
          "1393:    return -EFAULT;",
          "1394:  }",
          "",
          "[Removed Lines]",
          "1361:   BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1367:   Status = wrmWithLock(Adapter, (UINT)pBulkBuffer->Register,",
          "1371:   Status = wrmaltWithLock(Adapter, (UINT)pBulkBuffer->Register,",
          "1376:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0, \"WRM Failed\\n\");",
          "1383:            struct bcm_mini_adapter *Adapter)",
          "1390:  if (Adapter->eNVMType == NVM_EEPROM || Adapter->eNVMType == NVM_FLASH) {",
          "1391:   if (copy_to_user(IoBuffer.OutputBuffer, &Adapter->uiNVMDSDSize,",
          "",
          "[Added Lines]",
          "1361:   BCM_DEBUG_PRINT (ad, DBG_TYPE_PRINTK, 0, 0,",
          "1367:   Status = wrmWithLock(ad, (UINT)pBulkBuffer->Register,",
          "1371:   Status = wrmaltWithLock(ad, (UINT)pBulkBuffer->Register,",
          "1376:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0, \"WRM Failed\\n\");",
          "1383:            struct bcm_mini_adapter *ad)",
          "1390:  if (ad->eNVMType == NVM_EEPROM || ad->eNVMType == NVM_FLASH) {",
          "1391:   if (copy_to_user(IoBuffer.OutputBuffer, &ad->uiNVMDSDSize,",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1397: }",
          "1399: static int bcm_char_ioctl_cal_init(void __user *argp,",
          "1401: {",
          "1402:  struct bcm_ioctl_buffer IoBuffer;",
          "1403:  UINT uiSectorSize = 0;",
          "1404:  INT Status = STATUS_FAILURE;",
          "1407:   if (copy_from_user(&IoBuffer, argp,",
          "1408:    sizeof(struct bcm_ioctl_buffer)))",
          "1409:    return -EFAULT;",
          "",
          "[Removed Lines]",
          "1400:        struct bcm_mini_adapter *Adapter)",
          "1406:  if (Adapter->eNVMType == NVM_FLASH) {",
          "",
          "[Added Lines]",
          "1400:        struct bcm_mini_adapter *ad)",
          "1406:  if (ad->eNVMType == NVM_FLASH) {",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1415:   if ((uiSectorSize < MIN_SECTOR_SIZE) ||",
          "1416:    (uiSectorSize > MAX_SECTOR_SIZE)) {",
          "1417:    if (copy_to_user(IoBuffer.OutputBuffer,",
          "1419:     return -EFAULT;",
          "1420:   } else {",
          "1422:     if (copy_to_user(IoBuffer.OutputBuffer,",
          "1424:      return -EFAULT;",
          "1425:    } else {",
          "1429:       DBG_TYPE_PRINTK, 0, 0,",
          "1430:       \"Device is in Idle/Shutdown Mode\\n\");",
          "1431:      return -EACCES;",
          "1432:     }",
          "1437:    }",
          "1438:   }",
          "1439:   Status = STATUS_SUCCESS;",
          "",
          "[Removed Lines]",
          "1418:     &Adapter->uiSectorSize, sizeof(UINT)))",
          "1421:    if (IsFlash2x(Adapter)) {",
          "1423:      &Adapter->uiSectorSize, sizeof(UINT)))",
          "1426:     if ((TRUE == Adapter->bShutStatus) ||",
          "1427:      (TRUE == Adapter->IdleMode)) {",
          "1428:      BCM_DEBUG_PRINT(Adapter,",
          "1434:     Adapter->uiSectorSize = uiSectorSize;",
          "1435:     BcmUpdateSectorSize(Adapter,",
          "1436:      Adapter->uiSectorSize);",
          "",
          "[Added Lines]",
          "1418:     &ad->uiSectorSize, sizeof(UINT)))",
          "1421:    if (IsFlash2x(ad)) {",
          "1423:      &ad->uiSectorSize, sizeof(UINT)))",
          "1426:     if ((TRUE == ad->bShutStatus) ||",
          "1427:      (TRUE == ad->IdleMode)) {",
          "1428:      BCM_DEBUG_PRINT(ad,",
          "1434:     ad->uiSectorSize = uiSectorSize;",
          "1435:     BcmUpdateSectorSize(ad,",
          "1436:      ad->uiSectorSize);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1444: }",
          "1446: static int bcm_char_ioctl_set_debug(void __user *argp,",
          "1448: {",
          "1449: #ifdef DEBUG",
          "1450:  struct bcm_ioctl_buffer IoBuffer;",
          "1451:  struct bcm_user_debug_state sUserDebugState;",
          "1454:   \"In SET_DEBUG ioctl\\n\");",
          "1455:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "1456:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "1447:         struct bcm_mini_adapter *Adapter)",
          "1453:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "1447:         struct bcm_mini_adapter *ad)",
          "1453:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1459:   sizeof(struct bcm_user_debug_state)))",
          "1460:   return -EFAULT;",
          "1463:    \"IOCTL_BCM_SET_DEBUG: OnOff=%d Type = 0x%x \",",
          "1464:    sUserDebugState.OnOff, sUserDebugState.Type);",
          "1466:  sUserDebugState.Subtype = 1 << sUserDebugState.Subtype;",
          "1468:   \"actual Subtype=0x%x\\n\", sUserDebugState.Subtype);",
          "1477:  if (sUserDebugState.OnOff)",
          "1479:    sUserDebugState.Subtype;",
          "1480:  else",
          "1482:    ~sUserDebugState.Subtype;",
          "1485: #endif",
          "1486:  return STATUS_SUCCESS;",
          "1487: }",
          "1489: static int bcm_char_ioctl_nvm_rw(void __user *argp,",
          "1491: {",
          "1492:  struct bcm_nvm_readwrite stNVMReadWrite;",
          "1493:  struct timeval tv0, tv1;",
          "",
          "[Removed Lines]",
          "1462:  BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1467:  BCM_DEBUG_PRINT (Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1471:  Adapter->stDebugState.type |= sUserDebugState.Type;",
          "1478:   Adapter->stDebugState.subtype[sUserDebugState.Type] |=",
          "1481:   Adapter->stDebugState.subtype[sUserDebugState.Type] &=",
          "1484:  BCM_SHOW_DEBUG_BITMAP(Adapter);",
          "1490:      struct bcm_mini_adapter *Adapter, UINT cmd)",
          "",
          "[Added Lines]",
          "1462:  BCM_DEBUG_PRINT (ad, DBG_TYPE_PRINTK, 0, 0,",
          "1467:  BCM_DEBUG_PRINT (ad, DBG_TYPE_PRINTK, 0, 0,",
          "1471:  ad->stDebugState.type |= sUserDebugState.Type;",
          "1478:   ad->stDebugState.subtype[sUserDebugState.Type] |=",
          "1481:   ad->stDebugState.subtype[sUserDebugState.Type] &=",
          "1484:  BCM_SHOW_DEBUG_BITMAP(ad);",
          "1490:      struct bcm_mini_adapter *ad, UINT cmd)",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1498:  memset(&tv0, 0, sizeof(struct timeval));",
          "1499:  memset(&tv1, 0, sizeof(struct timeval));",
          "1503:    \"The Flash Control Section is Corrupted. Hence Rejection on NVM Read/Write\\n\");",
          "1504:   return -EFAULT;",
          "1505:  }",
          "1513:     \"No DSD is active..hence NVM Command is blocked\");",
          "1514:    return STATUS_FAILURE;",
          "1515:   }",
          "",
          "[Removed Lines]",
          "1500:  if ((Adapter->eNVMType == NVM_FLASH) &&",
          "1501:   (Adapter->uiFlashLayoutMajorVersion == 0)) {",
          "1502:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1507:  if (IsFlash2x(Adapter)) {",
          "1508:   if ((Adapter->eActiveDSD != DSD0) &&",
          "1509:    (Adapter->eActiveDSD != DSD1) &&",
          "1510:    (Adapter->eActiveDSD != DSD2)) {",
          "1512:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1500:  if ((ad->eNVMType == NVM_FLASH) &&",
          "1501:   (ad->uiFlashLayoutMajorVersion == 0)) {",
          "1502:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1507:  if (IsFlash2x(ad)) {",
          "1508:   if ((ad->eActiveDSD != DSD0) &&",
          "1509:    (ad->eActiveDSD != DSD1) &&",
          "1510:    (ad->eActiveDSD != DSD2)) {",
          "1512:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1532:   return STATUS_FAILURE;",
          "1534:  if (stNVMReadWrite.uiOffset >",
          "1536:   return STATUS_FAILURE;",
          "1538:  pReadData = memdup_user(stNVMReadWrite.pBuffer,",
          "",
          "[Removed Lines]",
          "1531:  if (stNVMReadWrite.uiNumBytes > Adapter->uiNVMDSDSize)",
          "1535:   Adapter->uiNVMDSDSize - stNVMReadWrite.uiNumBytes)",
          "",
          "[Added Lines]",
          "1531:  if (stNVMReadWrite.uiNumBytes > ad->uiNVMDSDSize)",
          "1535:   ad->uiNVMDSDSize - stNVMReadWrite.uiNumBytes)",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1543:  do_gettimeofday(&tv0);",
          "1544:  if (IOCTL_BCM_NVM_READ == cmd) {",
          "1546:     &stNVMReadWrite);",
          "1547:   if (ret != STATUS_SUCCESS)",
          "1548:    return ret;",
          "1549:  } else {",
          "1557:     DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1558:     \"Device is in Idle/Shutdown Mode\\n\");",
          "1560:    kfree(pReadData);",
          "1561:    return -EACCES;",
          "1562:   }",
          "1567:        pReadData,",
          "1568:        &stNVMReadWrite);",
          "1569:    if (ret != STATUS_SUCCESS)",
          "1570:     return ret;",
          "1571:   }",
          "1574:    stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes,",
          "1575:    stNVMReadWrite.bVerify);",
          "1583:   if (Status != STATUS_SUCCESS) {",
          "1584:    kfree(pReadData);",
          "",
          "[Removed Lines]",
          "1545:   int ret = bcm_handle_nvm_read_cmd(Adapter, pReadData,",
          "1550:   down(&Adapter->NVMRdmWrmLock);",
          "1552:   if ((Adapter->IdleMode == TRUE) ||",
          "1553:    (Adapter->bShutStatus == TRUE) ||",
          "1554:    (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "1556:    BCM_DEBUG_PRINT(Adapter,",
          "1559:    up(&Adapter->NVMRdmWrmLock);",
          "1564:   Adapter->bHeaderChangeAllowed = TRUE;",
          "1565:   if (IsFlash2x(Adapter)) {",
          "1566:    int ret = handle_flash2x_adapter(Adapter,",
          "1573:   Status = BeceemNVMWrite(Adapter, (PUINT)pReadData,",
          "1576:   if (IsFlash2x(Adapter))",
          "1577:    BcmFlash2xWriteSig(Adapter, Adapter->eActiveDSD);",
          "1579:   Adapter->bHeaderChangeAllowed = false;",
          "1581:   up(&Adapter->NVMRdmWrmLock);",
          "",
          "[Added Lines]",
          "1545:   int ret = bcm_handle_nvm_read_cmd(ad, pReadData,",
          "1550:   down(&ad->NVMRdmWrmLock);",
          "1552:   if ((ad->IdleMode == TRUE) ||",
          "1553:    (ad->bShutStatus == TRUE) ||",
          "1554:    (ad->bPreparingForLowPowerMode == TRUE)) {",
          "1556:    BCM_DEBUG_PRINT(ad,",
          "1559:    up(&ad->NVMRdmWrmLock);",
          "1564:   ad->bHeaderChangeAllowed = TRUE;",
          "1565:   if (IsFlash2x(ad)) {",
          "1566:    int ret = handle_flash2x_adapter(ad,",
          "1573:   Status = BeceemNVMWrite(ad, (PUINT)pReadData,",
          "1576:   if (IsFlash2x(ad))",
          "1577:    BcmFlash2xWriteSig(ad, ad->eActiveDSD);",
          "1579:   ad->bHeaderChangeAllowed = false;",
          "1581:   up(&ad->NVMRdmWrmLock);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1587:  }",
          "1589:  do_gettimeofday(&tv1);",
          "1591:   \" timetaken by Write/read :%ld msec\\n\",",
          "1592:   (tv1.tv_sec - tv0.tv_sec)*1000 +",
          "1593:   (tv1.tv_usec - tv0.tv_usec)/1000);",
          "",
          "[Removed Lines]",
          "1590:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "1590:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1597: }",
          "1599: static int bcm_char_ioctl_flash2x_section_read(void __user *argp,",
          "1601: {",
          "1602:  struct bcm_flash2x_readwrite sFlash2xRead = {0};",
          "1603:  struct bcm_ioctl_buffer IoBuffer;",
          "",
          "[Removed Lines]",
          "1600:  struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "1600:  struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1609:  INT Status = STATUS_FAILURE;",
          "1610:  void __user *OutPutBuff;",
          "1614:    \"Flash Does not have 2.x map\");",
          "1615:   return -EINVAL;",
          "1616:  }",
          "1619:   DBG_LVL_ALL, \"IOCTL_BCM_FLASH2X_SECTION_READ Called\");",
          "1620:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "1621:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "1612:  if (IsFlash2x(Adapter) != TRUE) {",
          "1613:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1618:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,",
          "",
          "[Added Lines]",
          "1612:  if (IsFlash2x(ad) != TRUE) {",
          "1613:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1618:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1625:   sizeof(struct bcm_flash2x_readwrite)))",
          "1626:   return -EFAULT;",
          "1629:    \"\\nsFlash2xRead.Section :%x\",",
          "1630:    sFlash2xRead.Section);",
          "1632:    \"\\nsFlash2xRead.offset :%x\",",
          "1633:    sFlash2xRead.offset);",
          "1635:    \"\\nsFlash2xRead.numOfBytes :%x\",",
          "1636:    sFlash2xRead.numOfBytes);",
          "1638:    \"\\nsFlash2xRead.bVerify :%x\\n\",",
          "1639:    sFlash2xRead.bVerify);",
          "1645:   return STATUS_FAILURE;",
          "1647:  NOB = sFlash2xRead.numOfBytes;",
          "1650:  else",
          "1651:   BuffSize = NOB;",
          "",
          "[Removed Lines]",
          "1628:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1631:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1634:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1637:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1644:  if (validateFlash2xReadWrite(Adapter, &sFlash2xRead) == false)",
          "1648:  if (NOB > Adapter->uiSectorSize)",
          "1649:   BuffSize = Adapter->uiSectorSize;",
          "",
          "[Added Lines]",
          "1628:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1631:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1634:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1637:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1644:  if (validateFlash2xReadWrite(ad, &sFlash2xRead) == false)",
          "1648:  if (NOB > ad->uiSectorSize)",
          "1649:   BuffSize = ad->uiSectorSize;",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1655:  pReadBuff = kzalloc(BuffSize , GFP_KERNEL);",
          "1657:  if (pReadBuff == NULL) {",
          "1659:     \"Memory allocation failed for Flash 2.x Read Structure\");",
          "1660:   return -ENOMEM;",
          "1661:  }",
          "1669:     DBG_LVL_ALL,",
          "1670:     \"Device is in Idle/Shutdown Mode\\n\");",
          "1672:   kfree(pReadBuff);",
          "1673:   return -EACCES;",
          "1674:  }",
          "1676:  while (NOB) {",
          "1679:   else",
          "1680:    ReadBytes = NOB;",
          "1684:    sFlash2xRead.Section, ReadOffset, ReadBytes);",
          "1685:   if (Status) {",
          "1687:     DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1688:     \"Flash 2x read err with Status :%d\",",
          "1689:     Status);",
          "1690:    break;",
          "1691:   }",
          "1694:    DBG_LVL_ALL, pReadBuff, ReadBytes);",
          "1696:   Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);",
          "1697:   if (Status) {",
          "1699:     DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1700:     \"Copy to use failed with status :%d\", Status);",
          "1702:    kfree(pReadBuff);",
          "1703:    return -EFAULT;",
          "1704:   }",
          "",
          "[Removed Lines]",
          "1658:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1662:  down(&Adapter->NVMRdmWrmLock);",
          "1664:  if ((Adapter->IdleMode == TRUE) ||",
          "1665:   (Adapter->bShutStatus == TRUE) ||",
          "1666:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "1668:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1671:   up(&Adapter->NVMRdmWrmLock);",
          "1677:   if (NOB > Adapter->uiSectorSize)",
          "1678:    ReadBytes = Adapter->uiSectorSize;",
          "1683:   Status = BcmFlash2xBulkRead(Adapter, (PUINT)pReadBuff,",
          "1686:    BCM_DEBUG_PRINT(Adapter,",
          "1693:   BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1698:    BCM_DEBUG_PRINT(Adapter,",
          "1701:    up(&Adapter->NVMRdmWrmLock);",
          "",
          "[Added Lines]",
          "1658:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1662:  down(&ad->NVMRdmWrmLock);",
          "1664:  if ((ad->IdleMode == TRUE) ||",
          "1665:   (ad->bShutStatus == TRUE) ||",
          "1666:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "1668:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1671:   up(&ad->NVMRdmWrmLock);",
          "1677:   if (NOB > ad->uiSectorSize)",
          "1678:    ReadBytes = ad->uiSectorSize;",
          "1683:   Status = BcmFlash2xBulkRead(ad, (PUINT)pReadBuff,",
          "1686:    BCM_DEBUG_PRINT(ad,",
          "1693:   BCM_DEBUG_PRINT_BUFFER(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1698:    BCM_DEBUG_PRINT(ad,",
          "1701:    up(&ad->NVMRdmWrmLock);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1709:   }",
          "1710:  }",
          "1713:  kfree(pReadBuff);",
          "1714:  return Status;",
          "1715: }",
          "1717: static int bcm_char_ioctl_flash2x_section_write(void __user *argp,",
          "1719: {",
          "1720:  struct bcm_flash2x_readwrite sFlash2xWrite = {0};",
          "1721:  struct bcm_ioctl_buffer IoBuffer;",
          "",
          "[Removed Lines]",
          "1712:  up(&Adapter->NVMRdmWrmLock);",
          "1718:  struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "1712:  up(&ad->NVMRdmWrmLock);",
          "1718:  struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1727:  UINT WriteBytes = 0;",
          "1728:  INT Status = STATUS_FAILURE;",
          "1732:    \"Flash Does not have 2.x map\");",
          "1733:   return -EINVAL;",
          "1734:  }",
          "",
          "[Removed Lines]",
          "1730:  if (IsFlash2x(Adapter) != TRUE) {",
          "1731:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1730:  if (IsFlash2x(ad) != TRUE) {",
          "1731:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1742:   \"IOCTL_BCM_FLASH2X_SECTION_WRITE Called\");",
          "1744:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "1739:  Adapter->bAllDSDWriteAllow = false;",
          "1741:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "1739:  ad->bAllDSDWriteAllow = false;",
          "1741:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "1749:   sizeof(struct bcm_flash2x_readwrite)))",
          "1750:   return -EFAULT;",
          "1753:   \"\\nsFlash2xWrite.Section :%x\", sFlash2xWrite.Section);",
          "1755:   \"\\nsFlash2xWrite.offset :%d\", sFlash2xWrite.offset);",
          "1757:   \"\\nsFlash2xWrite.numOfBytes :%x\", sFlash2xWrite.numOfBytes);",
          "1759:   \"\\nsFlash2xWrite.bVerify :%x\\n\", sFlash2xWrite.bVerify);",
          "1761:  if ((sFlash2xWrite.Section != VSA0) && (sFlash2xWrite.Section != VSA1)",
          "1762:   && (sFlash2xWrite.Section != VSA2)) {",
          "1764:    \"Only VSA write is allowed\");",
          "1765:   return -EINVAL;",
          "1766:  }",
          "1769:   return STATUS_FAILURE;",
          "1771:  InputAddr = sFlash2xWrite.pDataBuff;",
          "1772:  WriteOffset = sFlash2xWrite.offset;",
          "1773:  NOB = sFlash2xWrite.numOfBytes;",
          "1777:  else",
          "1778:   BuffSize = NOB;",
          "",
          "[Removed Lines]",
          "1752:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1754:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1756:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1758:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1763:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1768:  if (validateFlash2xReadWrite(Adapter, &sFlash2xWrite) == false)",
          "1775:  if (NOB > Adapter->uiSectorSize)",
          "1776:   BuffSize = Adapter->uiSectorSize;",
          "",
          "[Added Lines]",
          "1752:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1754:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1756:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1758:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1763:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1768:  if (validateFlash2xReadWrite(ad, &sFlash2xWrite) == false)",
          "1775:  if (NOB > ad->uiSectorSize)",
          "1776:   BuffSize = ad->uiSectorSize;",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "1783:   return -ENOMEM;",
          "1790:  }",
          "1792:  if (NOB < WriteBytes)",
          "1793:   WriteBytes = NOB;",
          "1802:    \"Device is in Idle/Shutdown Mode\\n\");",
          "1804:   kfree(pWriteBuff);",
          "1805:   return -EACCES;",
          "1806:  }",
          "1809:  do {",
          "1810:   Status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);",
          "1811:   if (Status) {",
          "1813:     \"Copy to user failed with status :%d\", Status);",
          "1815:    kfree(pWriteBuff);",
          "1816:    return -EFAULT;",
          "1817:   }",
          "1819:    OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);",
          "1823:           sFlash2xWrite.Section,",
          "1824:           WriteOffset,",
          "1825:           WriteBytes,",
          "1826:           sFlash2xWrite.bVerify);",
          "1828:   if (Status) {",
          "1830:     \"Flash 2x read err with Status :%d\", Status);",
          "1831:    break;",
          "1832:   }",
          "",
          "[Removed Lines]",
          "1786:  WriteBytes = Adapter->uiSectorSize;",
          "1787:  if (WriteOffset % Adapter->uiSectorSize) {",
          "1788:   WriteBytes = Adapter->uiSectorSize -",
          "1789:    (WriteOffset % Adapter->uiSectorSize);",
          "1795:  down(&Adapter->NVMRdmWrmLock);",
          "1797:  if ((Adapter->IdleMode == TRUE) ||",
          "1798:   (Adapter->bShutStatus == TRUE) ||",
          "1799:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "1801:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1803:   up(&Adapter->NVMRdmWrmLock);",
          "1808:  BcmFlash2xCorruptSig(Adapter, sFlash2xWrite.Section);",
          "1812:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1814:    up(&Adapter->NVMRdmWrmLock);",
          "1818:   BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS,",
          "1822:   Status = BcmFlash2xBulkWrite(Adapter, (PUINT)pWriteBuff,",
          "1829:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1786:  WriteBytes = ad->uiSectorSize;",
          "1787:  if (WriteOffset % ad->uiSectorSize) {",
          "1788:   WriteBytes = ad->uiSectorSize -",
          "1789:    (WriteOffset % ad->uiSectorSize);",
          "1795:  down(&ad->NVMRdmWrmLock);",
          "1797:  if ((ad->IdleMode == TRUE) ||",
          "1798:   (ad->bShutStatus == TRUE) ||",
          "1799:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "1801:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1803:   up(&ad->NVMRdmWrmLock);",
          "1808:  BcmFlash2xCorruptSig(ad, sFlash2xWrite.Section);",
          "1812:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1814:    up(&ad->NVMRdmWrmLock);",
          "1818:   BCM_DEBUG_PRINT_BUFFER(ad, DBG_TYPE_OTHERS,",
          "1822:   Status = BcmFlash2xBulkWrite(ad, (PUINT)pWriteBuff,",
          "1829:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "1835:   if (NOB) {",
          "1836:    WriteOffset = WriteOffset + WriteBytes;",
          "1837:    InputAddr = InputAddr + WriteBytes;",
          "1840:    else",
          "1841:     WriteBytes = NOB;",
          "1842:   }",
          "1843:  } while (NOB > 0);",
          "1847:  kfree(pWriteBuff);",
          "1848:  return Status;",
          "1849: }",
          "1851: static int bcm_char_ioctl_flash2x_section_bitmap(void __user *argp,",
          "1853: {",
          "1854:  struct bcm_flash2x_bitmap *psFlash2xBitMap;",
          "1855:  struct bcm_ioctl_buffer IoBuffer;",
          "1858:  \"IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP Called\");",
          "1860:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "1838:    if (NOB > Adapter->uiSectorSize)",
          "1839:     WriteBytes = Adapter->uiSectorSize;",
          "1845:  BcmFlash2xWriteSig(Adapter, sFlash2xWrite.Section);",
          "1846:  up(&Adapter->NVMRdmWrmLock);",
          "1852:  struct bcm_mini_adapter *Adapter)",
          "1857: BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "1838:    if (NOB > ad->uiSectorSize)",
          "1839:     WriteBytes = ad->uiSectorSize;",
          "1845:  BcmFlash2xWriteSig(ad, sFlash2xWrite.Section);",
          "1846:  up(&ad->NVMRdmWrmLock);",
          "1852:  struct bcm_mini_adapter *ad)",
          "1857: BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "1867:    GFP_KERNEL);",
          "1869:  if (psFlash2xBitMap == NULL) {",
          "1871:    \"Memory is not available\");",
          "1872:   return -ENOMEM;",
          "1873:  }",
          "1883:    \"Device is in Idle/Shutdown Mode\\n\");",
          "1885:   kfree(psFlash2xBitMap);",
          "1886:   return -EACCES;",
          "1887:  }",
          "1891:  if (copy_to_user(IoBuffer.OutputBuffer, psFlash2xBitMap,",
          "1892:   sizeof(struct bcm_flash2x_bitmap))) {",
          "1893:   kfree(psFlash2xBitMap);",
          "",
          "[Removed Lines]",
          "1870:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1876:  down(&Adapter->NVMRdmWrmLock);",
          "1878:  if ((Adapter->IdleMode == TRUE) ||",
          "1879:   (Adapter->bShutStatus == TRUE) ||",
          "1880:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "1882:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1884:   up(&Adapter->NVMRdmWrmLock);",
          "1889:  BcmGetFlash2xSectionalBitMap(Adapter, psFlash2xBitMap);",
          "1890:  up(&Adapter->NVMRdmWrmLock);",
          "",
          "[Added Lines]",
          "1870:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1876:  down(&ad->NVMRdmWrmLock);",
          "1878:  if ((ad->IdleMode == TRUE) ||",
          "1879:   (ad->bShutStatus == TRUE) ||",
          "1880:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "1882:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1884:   up(&ad->NVMRdmWrmLock);",
          "1889:  BcmGetFlash2xSectionalBitMap(ad, psFlash2xBitMap);",
          "1890:  up(&ad->NVMRdmWrmLock);",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "1899: }",
          "1901: static int bcm_char_ioctl_set_active_section(void __user *argp,",
          "1903: {",
          "1904:  enum bcm_flash2x_section_val eFlash2xSectionVal = 0;",
          "1905:  INT Status = STATUS_FAILURE;",
          "1906:  struct bcm_ioctl_buffer IoBuffer;",
          "1909:    \"IOCTL_BCM_SET_ACTIVE_SECTION Called\");",
          "1913:     \"Flash Does not have 2.x map\");",
          "1914:   return -EINVAL;",
          "1915:  }",
          "",
          "[Removed Lines]",
          "1902:           struct bcm_mini_adapter *Adapter)",
          "1908:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1911:  if (IsFlash2x(Adapter) != TRUE) {",
          "1912:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1902:           struct bcm_mini_adapter *ad)",
          "1908:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1911:  if (IsFlash2x(ad) != TRUE) {",
          "1912:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "1917:  Status = copy_from_user(&IoBuffer, argp,",
          "1918:     sizeof(struct bcm_ioctl_buffer));",
          "1919:  if (Status) {",
          "1921:     \"Copy of IOCTL BUFFER failed\");",
          "1922:   return -EFAULT;",
          "1923:  }",
          "",
          "[Removed Lines]",
          "1920:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1920:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "1925:  Status = copy_from_user(&eFlash2xSectionVal,",
          "1926:     IoBuffer.InputBuffer, sizeof(INT));",
          "1927:  if (Status) {",
          "1929:    \"Copy of flash section val failed\");",
          "1930:   return -EFAULT;",
          "1931:  }",
          "1940:     \"Device is in Idle/Shutdown Mode\\n\");",
          "1942:   return -EACCES;",
          "1943:  }",
          "1946:  if (Status)",
          "1948:     \"Failed to make it's priority Highest. Status %d\",",
          "1949:     Status);",
          "1953:  return Status;",
          "1954: }",
          "1956: static int bcm_char_ioctl_copy_section(void __user *argp,",
          "1958: {",
          "1959:  struct bcm_flash2x_copy_section sCopySectStrut = {0};",
          "1960:  struct bcm_ioctl_buffer IoBuffer;",
          "1961:  INT Status = STATUS_SUCCESS;",
          "1964:    \"IOCTL_BCM_COPY_SECTION  Called\");",
          "1969:     \"Flash Does not have 2.x map\");",
          "1970:   return -EINVAL;",
          "1971:  }",
          "",
          "[Removed Lines]",
          "1928:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1933:  down(&Adapter->NVMRdmWrmLock);",
          "1935:  if ((Adapter->IdleMode == TRUE) ||",
          "1936:   (Adapter->bShutStatus == TRUE) ||",
          "1937:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "1939:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1941:   up(&Adapter->NVMRdmWrmLock);",
          "1945:  Status = BcmSetActiveSection(Adapter, eFlash2xSectionVal);",
          "1947:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1951:  up(&Adapter->NVMRdmWrmLock);",
          "1957:            struct bcm_mini_adapter *Adapter)",
          "1963:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1966:  Adapter->bAllDSDWriteAllow = false;",
          "1967:  if (IsFlash2x(Adapter) != TRUE) {",
          "1968:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1928:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1933:  down(&ad->NVMRdmWrmLock);",
          "1935:  if ((ad->IdleMode == TRUE) ||",
          "1936:   (ad->bShutStatus == TRUE) ||",
          "1937:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "1939:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1941:   up(&ad->NVMRdmWrmLock);",
          "1945:  Status = BcmSetActiveSection(ad, eFlash2xSectionVal);",
          "1947:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1951:  up(&ad->NVMRdmWrmLock);",
          "1957:            struct bcm_mini_adapter *ad)",
          "1963:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1966:  ad->bAllDSDWriteAllow = false;",
          "1967:  if (IsFlash2x(ad) != TRUE) {",
          "1968:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "1973:  Status = copy_from_user(&IoBuffer, argp,",
          "1974:     sizeof(struct bcm_ioctl_buffer));",
          "1975:  if (Status) {",
          "1977:     \"Copy of IOCTL BUFFER failed Status :%d\",",
          "1978:     Status);",
          "1979:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "1976:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "1976:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "1982:  Status = copy_from_user(&sCopySectStrut, IoBuffer.InputBuffer,",
          "1983:     sizeof(struct bcm_flash2x_copy_section));",
          "1984:  if (Status) {",
          "1986:     \"Copy of Copy_Section_Struct failed with Status :%d\",",
          "1987:     Status);",
          "1988:   return -EFAULT;",
          "1989:  }",
          "1992:    \"Source SEction :%x\", sCopySectStrut.SrcSection);",
          "1994:    \"Destination SEction :%x\", sCopySectStrut.DstSection);",
          "1996:    \"offset :%x\", sCopySectStrut.offset);",
          "1998:    \"NOB :%x\", sCopySectStrut.numOfBytes);",
          "2002:     \"Source Section<%x> does not exist in Flash \",",
          "2003:     sCopySectStrut.SrcSection);",
          "2004:   return -EINVAL;",
          "2005:  }",
          "2009:     \"Destinatio Section<%x> does not exist in Flash \",",
          "2010:     sCopySectStrut.DstSection);",
          "2011:   return -EINVAL;",
          "2012:  }",
          "2014:  if (sCopySectStrut.SrcSection == sCopySectStrut.DstSection) {",
          "2016:     \"Source and Destination section should be different\");",
          "2017:   return -EINVAL;",
          "2018:  }",
          "2027:     \"Device is in Idle/Shutdown Mode\\n\");",
          "2029:   return -EACCES;",
          "2030:  }",
          "2032:  if (sCopySectStrut.SrcSection == ISO_IMAGE1 ||",
          "2033:   sCopySectStrut.SrcSection == ISO_IMAGE2) {",
          "2036:      \"Device is Non-CDLess hence won't have ISO !!\");",
          "2037:    Status = -EINVAL;",
          "2038:   } else if (sCopySectStrut.numOfBytes == 0) {",
          "2040:   } else {",
          "2042:      \"Partial Copy of ISO section is not Allowed..\");",
          "2043:    Status = STATUS_FAILURE;",
          "2044:   }",
          "2046:   return Status;",
          "2047:  }",
          "2050:     sCopySectStrut.DstSection,",
          "2051:     sCopySectStrut.offset,",
          "2052:     sCopySectStrut.numOfBytes);",
          "2054:  return Status;",
          "2055: }",
          "2057: static int bcm_char_ioctl_get_flash_cs_info(void __user *argp,",
          "2059: {",
          "2060:  struct bcm_ioctl_buffer IoBuffer;",
          "2061:  INT Status = STATUS_SUCCESS;",
          "2064:    \" IOCTL_BCM_GET_FLASH_CS_INFO Called\");",
          "2066:  Status = copy_from_user(&IoBuffer, argp,",
          "2067:    sizeof(struct bcm_ioctl_buffer));",
          "2068:  if (Status) {",
          "2070:     \"Copy of IOCTL BUFFER failed\");",
          "2071:   return -EFAULT;",
          "2072:  }",
          "2076:     \"Connected device does not have flash\");",
          "2077:   return -EINVAL;",
          "2078:  }",
          "2081:   if (IoBuffer.OutputLength < sizeof(struct bcm_flash2x_cs_info))",
          "2082:    return -EINVAL;",
          "2084:   if (copy_to_user(IoBuffer.OutputBuffer,",
          "2086:      sizeof(struct bcm_flash2x_cs_info)))",
          "2087:    return -EFAULT;",
          "2088:  } else {",
          "2089:   if (IoBuffer.OutputLength < sizeof(struct bcm_flash_cs_info))",
          "2090:    return -EINVAL;",
          "2093:      sizeof(struct bcm_flash_cs_info)))",
          "2094:    return -EFAULT;",
          "2095:  }",
          "",
          "[Removed Lines]",
          "1985:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "1991:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1993:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1995:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1997:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2000:  if (IsSectionExistInFlash(Adapter, sCopySectStrut.SrcSection) == false) {",
          "2001:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2007:  if (IsSectionExistInFlash(Adapter, sCopySectStrut.DstSection) == false) {",
          "2008:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2015:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2020:  down(&Adapter->NVMRdmWrmLock);",
          "2022:  if ((Adapter->IdleMode == TRUE) ||",
          "2023:   (Adapter->bShutStatus == TRUE) ||",
          "2024:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "2026:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2028:   up(&Adapter->NVMRdmWrmLock);",
          "2034:   if (IsNonCDLessDevice(Adapter)) {",
          "2035:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2039:    Status = BcmCopyISO(Adapter, sCopySectStrut);",
          "2041:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2045:   up(&Adapter->NVMRdmWrmLock);",
          "2049:  Status = BcmCopySection(Adapter, sCopySectStrut.SrcSection,",
          "2053:  up(&Adapter->NVMRdmWrmLock);",
          "2058:          struct bcm_mini_adapter *Adapter)",
          "2063:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2069:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2074:  if (Adapter->eNVMType != NVM_FLASH) {",
          "2075:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2080:  if (IsFlash2x(Adapter) == TRUE) {",
          "2085:      Adapter->psFlash2xCSInfo,",
          "2092:   if (copy_to_user(IoBuffer.OutputBuffer, Adapter->psFlashCSInfo,",
          "",
          "[Added Lines]",
          "1985:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1991:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1993:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1995:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1997:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2000:  if (IsSectionExistInFlash(ad, sCopySectStrut.SrcSection) == false) {",
          "2001:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2007:  if (IsSectionExistInFlash(ad, sCopySectStrut.DstSection) == false) {",
          "2008:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2015:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2020:  down(&ad->NVMRdmWrmLock);",
          "2022:  if ((ad->IdleMode == TRUE) ||",
          "2023:   (ad->bShutStatus == TRUE) ||",
          "2024:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "2026:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2028:   up(&ad->NVMRdmWrmLock);",
          "2034:   if (IsNonCDLessDevice(ad)) {",
          "2035:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2039:    Status = BcmCopyISO(ad, sCopySectStrut);",
          "2041:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2045:   up(&ad->NVMRdmWrmLock);",
          "2049:  Status = BcmCopySection(ad, sCopySectStrut.SrcSection,",
          "2053:  up(&ad->NVMRdmWrmLock);",
          "2058:          struct bcm_mini_adapter *ad)",
          "2063:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2069:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2074:  if (ad->eNVMType != NVM_FLASH) {",
          "2075:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2080:  if (IsFlash2x(ad) == TRUE) {",
          "2085:      ad->psFlash2xCSInfo,",
          "2092:   if (copy_to_user(IoBuffer.OutputBuffer, ad->psFlashCSInfo,",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "2097: }",
          "2099: static int bcm_char_ioctl_select_dsd(void __user *argp,",
          "2101: {",
          "2102:  struct bcm_ioctl_buffer IoBuffer;",
          "2103:  INT Status = STATUS_FAILURE;",
          "",
          "[Removed Lines]",
          "2100:          struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "2100:          struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "2105:  enum bcm_flash2x_section_val eFlash2xSectionVal;",
          "2107:  eFlash2xSectionVal = NO_SECTION_VAL;",
          "2109:    \"IOCTL_BCM_SELECT_DSD Called\");",
          "2113:     \"Flash Does not have 2.x map\");",
          "2114:   return -EINVAL;",
          "2115:  }",
          "",
          "[Removed Lines]",
          "2108:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2111:  if (IsFlash2x(Adapter) != TRUE) {",
          "2112:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "2108:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2111:  if (IsFlash2x(ad) != TRUE) {",
          "2112:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "2117:  Status = copy_from_user(&IoBuffer, argp,",
          "2118:     sizeof(struct bcm_ioctl_buffer));",
          "2119:  if (Status) {",
          "2121:     \"Copy of IOCTL BUFFER failed\");",
          "2122:   return -EFAULT;",
          "2123:  }",
          "2124:  Status = copy_from_user(&eFlash2xSectionVal, IoBuffer.InputBuffer,",
          "2125:   sizeof(INT));",
          "2126:  if (Status) {",
          "2128:     \"Copy of flash section val failed\");",
          "2129:   return -EFAULT;",
          "2130:  }",
          "2133:    \"Read Section :%d\", eFlash2xSectionVal);",
          "2134:  if ((eFlash2xSectionVal != DSD0) &&",
          "2135:   (eFlash2xSectionVal != DSD1) &&",
          "2136:   (eFlash2xSectionVal != DSD2)) {",
          "2139:     \"Passed section<%x> is not DSD section\",",
          "2140:     eFlash2xSectionVal);",
          "2141:   return STATUS_FAILURE;",
          "2142:  }",
          "2145:  if (SectOfset == INVALID_OFFSET) {",
          "2147:     \"Provided Section val <%d> does not exist in Flash 2.x\",",
          "2148:     eFlash2xSectionVal);",
          "2149:   return -EINVAL;",
          "2150:  }",
          "2156:  return STATUS_SUCCESS;",
          "2157: }",
          "2159: static int bcm_char_ioctl_nvm_raw_read(void __user *argp,",
          "2161: {",
          "2162:  struct bcm_nvm_readwrite stNVMRead;",
          "2163:  struct bcm_ioctl_buffer IoBuffer;",
          "",
          "[Removed Lines]",
          "2120:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2127:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2132:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2138:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2144:  SectOfset = BcmGetSectionValStartOffset(Adapter, eFlash2xSectionVal);",
          "2146:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2152:  Adapter->bAllDSDWriteAllow = TRUE;",
          "2153:  Adapter->ulFlashCalStart = SectOfset;",
          "2154:  Adapter->eActiveDSD = eFlash2xSectionVal;",
          "2160:            struct bcm_mini_adapter *Adapter)",
          "",
          "[Added Lines]",
          "2120:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2127:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2132:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2138:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2144:  SectOfset = BcmGetSectionValStartOffset(ad, eFlash2xSectionVal);",
          "2146:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2152:  ad->bAllDSDWriteAllow = TRUE;",
          "2153:  ad->ulFlashCalStart = SectOfset;",
          "2154:  ad->eActiveDSD = eFlash2xSectionVal;",
          "2160:            struct bcm_mini_adapter *ad)",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "2169:  void __user *OutPutBuff;",
          "2170:  INT Status = STATUS_FAILURE;",
          "2174:     \"NVM TYPE is not Flash\");",
          "2175:   return -EINVAL;",
          "2176:  }",
          "2179:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer))) {",
          "2181:     \"copy_from_user 1 failed\\n\");",
          "2182:   return -EFAULT;",
          "2183:  }",
          "",
          "[Removed Lines]",
          "2172:  if (Adapter->eNVMType != NVM_FLASH) {",
          "2173:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2180:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Added Lines]",
          "2172:  if (ad->eNVMType != NVM_FLASH) {",
          "2173:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2180:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "2200:  pReadBuff = kzalloc(BuffSize , GFP_KERNEL);",
          "2201:  if (pReadBuff == NULL) {",
          "2203:     \"Memory allocation failed for Flash 2.x Read Structure\");",
          "2204:   return -ENOMEM;",
          "2205:  }",
          "2213:     \"Device is in Idle/Shutdown Mode\\n\");",
          "2214:   kfree(pReadBuff);",
          "2216:   return -EACCES;",
          "2217:  }",
          "2221:  while (NOB) {",
          "2222:   if (NOB > DEFAULT_BUFF_SIZE)",
          "",
          "[Removed Lines]",
          "2202:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2206:  down(&Adapter->NVMRdmWrmLock);",
          "2208:  if ((Adapter->IdleMode == TRUE) ||",
          "2209:   (Adapter->bShutStatus == TRUE) ||",
          "2210:   (Adapter->bPreparingForLowPowerMode == TRUE)) {",
          "2212:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2215:   up(&Adapter->NVMRdmWrmLock);",
          "2219:  Adapter->bFlashRawRead = TRUE;",
          "",
          "[Added Lines]",
          "2202:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2206:  down(&ad->NVMRdmWrmLock);",
          "2208:  if ((ad->IdleMode == TRUE) ||",
          "2209:   (ad->bShutStatus == TRUE) ||",
          "2210:   (ad->bPreparingForLowPowerMode == TRUE)) {",
          "2212:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2215:   up(&ad->NVMRdmWrmLock);",
          "2219:  ad->bFlashRawRead = TRUE;",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "2225:    ReadBytes = NOB;",
          "2229:    ReadOffset, ReadBytes);",
          "2230:   if (Status) {",
          "2232:      \"Flash 2x read err with Status :%d\",",
          "2233:      Status);",
          "2234:    break;",
          "2235:   }",
          "2238:            DBG_LVL_ALL, pReadBuff, ReadBytes);",
          "2240:   Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);",
          "2241:   if (Status) {",
          "2243:      \"Copy to use failed with status :%d\",",
          "2244:      Status);",
          "2246:    kfree(pReadBuff);",
          "2247:    return -EFAULT;",
          "2248:   }",
          "",
          "[Removed Lines]",
          "2228:   Status = BeceemNVMRead(Adapter, (PUINT)pReadBuff,",
          "2231:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2237:   BCM_DEBUG_PRINT_BUFFER(Adapter, DBG_TYPE_OTHERS, OSAL_DBG,",
          "2242:    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,",
          "2245:    up(&Adapter->NVMRdmWrmLock);",
          "",
          "[Added Lines]",
          "2228:   Status = BeceemNVMRead(ad, (PUINT)pReadBuff,",
          "2231:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2237:   BCM_DEBUG_PRINT_BUFFER(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "2242:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2245:    up(&ad->NVMRdmWrmLock);",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "2252:    OutPutBuff = OutPutBuff + ReadBytes;",
          "2253:   }",
          "2254:  }",
          "2257:  kfree(pReadBuff);",
          "2258:  return Status;",
          "2259: }",
          "2261: static int bcm_char_ioctl_cntrlmsg_mask(void __user *argp,",
          "2263:      struct bcm_tarang_data *pTarang)",
          "2264: {",
          "2265:  struct bcm_ioctl_buffer IoBuffer;",
          "",
          "[Removed Lines]",
          "2255:  Adapter->bFlashRawRead = false;",
          "2256:  up(&Adapter->NVMRdmWrmLock);",
          "2262:      struct bcm_mini_adapter *Adapter,",
          "",
          "[Added Lines]",
          "2255:  ad->bFlashRawRead = false;",
          "2256:  up(&ad->NVMRdmWrmLock);",
          "2262:      struct bcm_mini_adapter *ad,",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "2270:  Status = copy_from_user(&IoBuffer, argp,",
          "2271:    sizeof(struct bcm_ioctl_buffer));",
          "2272:  if (Status) {",
          "2274:     \"copy of Ioctl buffer is failed from user space\");",
          "2275:   return -EFAULT;",
          "2276:  }",
          "",
          "[Removed Lines]",
          "2273:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "2273:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "2281:  Status = copy_from_user(&RxCntrlMsgBitMask, IoBuffer.InputBuffer,",
          "2282:     IoBuffer.InputLength);",
          "2283:  if (Status) {",
          "2285:     \"copy of control bit mask failed from user space\");",
          "2286:   return -EFAULT;",
          "2287:  }",
          "2289:    \"\\n Got user defined cntrl msg bit mask :%lx\",",
          "2290:    RxCntrlMsgBitMask);",
          "2291:  pTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;",
          "",
          "[Removed Lines]",
          "2284:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2288:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "2284:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2288:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "2294: }",
          "2296: static int bcm_char_ioctl_get_device_driver_info(void __user *argp,",
          "2298: {",
          "2299:  struct bcm_driver_info DevInfo;",
          "2300:  struct bcm_ioctl_buffer IoBuffer;",
          "2303:    \"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\");",
          "2305:  memset(&DevInfo, 0, sizeof(DevInfo));",
          "2306:  DevInfo.MaxRDMBufferSize = BUFFER_4K;",
          "2307:  DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;",
          "2308:  DevInfo.u32RxAlignmentCorrection = 0;",
          "2310:  DevInfo.u32InterfaceType = BCM_USB;",
          "2312:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "2297:  struct bcm_mini_adapter *Adapter)",
          "2302:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2309:  DevInfo.u32NVMType = Adapter->eNVMType;",
          "",
          "[Added Lines]",
          "2297:  struct bcm_mini_adapter *ad)",
          "2302:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2309:  DevInfo.u32NVMType = ad->eNVMType;",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "2322: }",
          "2324: static int bcm_char_ioctl_time_since_net_entry(void __user *argp,",
          "2326: {",
          "2327:  struct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};",
          "2328:  struct bcm_ioctl_buffer IoBuffer;",
          "2331:    \"IOCTL_BCM_TIME_SINCE_NET_ENTRY called\");",
          "2333:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "2325:  struct bcm_mini_adapter *Adapter)",
          "2330:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "2325:  struct bcm_mini_adapter *ad)",
          "2330:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 70 ---",
          "[Context before]",
          "2337:   return -EINVAL;",
          "2339:  stTimeElapsedSinceNetEntry.ul64TimeElapsedSinceNetEntry =",
          "2342:  if (copy_to_user(IoBuffer.OutputBuffer, &stTimeElapsedSinceNetEntry,",
          "2343:     sizeof(struct bcm_time_elapsed)))",
          "",
          "[Removed Lines]",
          "2340:   get_seconds() - Adapter->liTimeSinceLastNetEntry;",
          "",
          "[Added Lines]",
          "2340:   get_seconds() - ad->liTimeSinceLastNetEntry;",
          "",
          "---------------",
          "--- Hunk 71 ---",
          "[Context before]",
          "2351: {",
          "2352:  struct bcm_tarang_data *pTarang = filp->private_data;",
          "2353:  void __user *argp = (void __user *)arg;",
          "2355:  INT Status = STATUS_FAILURE;",
          "2358:    \"Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX\",",
          "2359:    cmd, arg);",
          "",
          "[Removed Lines]",
          "2354:  struct bcm_mini_adapter *Adapter = pTarang->Adapter;",
          "2357:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "2354:  struct bcm_mini_adapter *ad = pTarang->Adapter;",
          "2357:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 72 ---",
          "[Context before]",
          "2370:  if (Status)",
          "2371:   return -EFAULT;",
          "2374:   return -EFAULT;",
          "2377:   switch (cmd) {",
          "2378:   case IOCTL_MAC_ADDR_REQ:",
          "2379:   case IOCTL_LINK_REQ:",
          "",
          "[Removed Lines]",
          "2373:  if (Adapter->device_removed)",
          "2376:  if (false == Adapter->fw_download_done) {",
          "",
          "[Added Lines]",
          "2373:  if (ad->device_removed)",
          "2376:  if (false == ad->fw_download_done) {",
          "",
          "---------------",
          "--- Hunk 73 ---",
          "[Context before]",
          "2389:   }",
          "2390:  }",
          "2393:  if (Status != CONTINUE_COMMON_PATH)",
          "2394:   return Status;",
          "2396:  switch (cmd) {",
          "2398:  case IOCTL_BCM_REGISTER_READ_PRIVATE:",
          "2400:   return Status;",
          "2402:  case IOCTL_BCM_REGISTER_WRITE_PRIVATE:",
          "2404:   return Status;",
          "2406:  case IOCTL_BCM_REGISTER_READ:",
          "2407:  case IOCTL_BCM_EEPROM_REGISTER_READ:",
          "2409:   return Status;",
          "2411:  case IOCTL_BCM_REGISTER_WRITE:",
          "2412:  case IOCTL_BCM_EEPROM_REGISTER_WRITE:",
          "2414:   return Status;",
          "2416:  case IOCTL_BCM_GPIO_SET_REQUEST:",
          "2418:   return Status;",
          "2420:  case BCM_LED_THREAD_STATE_CHANGE_REQ:",
          "2421:   Status = bcm_char_ioctl_led_thread_state_change_req(argp,",
          "2423:   return Status;",
          "2425:  case IOCTL_BCM_GPIO_STATUS_REQUEST:",
          "2427:   return Status;",
          "2429:  case IOCTL_BCM_GPIO_MULTI_REQUEST:",
          "2431:   return Status;",
          "2433:  case IOCTL_BCM_GPIO_MODE_REQUEST:",
          "2435:   return Status;",
          "2437:  case IOCTL_MAC_ADDR_REQ:",
          "",
          "[Removed Lines]",
          "2392:  Status = vendorextnIoctl(Adapter, cmd, arg);",
          "2399:   Status = bcm_char_ioctl_reg_read_private(argp, Adapter);",
          "2403:   Status = bcm_char_ioctl_reg_write_private(argp, Adapter);",
          "2408:   Status = bcm_char_ioctl_eeprom_reg_read(argp, Adapter);",
          "2413:   Status = bcm_char_ioctl_eeprom_reg_write(argp, Adapter, cmd);",
          "2417:   Status = bcm_char_ioctl_gpio_set_request(argp, Adapter);",
          "2422:             Adapter);",
          "2426:   Status = bcm_char_ioctl_gpio_status_request(argp, Adapter);",
          "2430:   Status = bcm_char_ioctl_gpio_multi_request(argp, Adapter);",
          "2434:   Status = bcm_char_ioctl_gpio_mode_request(argp, Adapter);",
          "",
          "[Added Lines]",
          "2392:  Status = vendorextnIoctl(ad, cmd, arg);",
          "2399:   Status = bcm_char_ioctl_reg_read_private(argp, ad);",
          "2403:   Status = bcm_char_ioctl_reg_write_private(argp, ad);",
          "2408:   Status = bcm_char_ioctl_eeprom_reg_read(argp, ad);",
          "2413:   Status = bcm_char_ioctl_eeprom_reg_write(argp, ad, cmd);",
          "2417:   Status = bcm_char_ioctl_gpio_set_request(argp, ad);",
          "2422:             ad);",
          "2426:   Status = bcm_char_ioctl_gpio_status_request(argp, ad);",
          "2430:   Status = bcm_char_ioctl_gpio_multi_request(argp, ad);",
          "2434:   Status = bcm_char_ioctl_gpio_mode_request(argp, ad);",
          "",
          "---------------",
          "--- Hunk 74 ---",
          "[Context before]",
          "2440:  case IOCTL_SS_INFO_REQ:",
          "2441:  case IOCTL_SEND_CONTROL_MESSAGE:",
          "2442:  case IOCTL_IDLE_REQ:",
          "2444:   return Status;",
          "2446:  case IOCTL_BCM_BUFFER_DOWNLOAD_START:",
          "2448:   return Status;",
          "2450:  case IOCTL_BCM_BUFFER_DOWNLOAD:",
          "2452:   return Status;",
          "2454:  case IOCTL_BCM_BUFFER_DOWNLOAD_STOP:",
          "2456:   return Status;",
          "2459:  case IOCTL_BE_BUCKET_SIZE:",
          "2460:   Status = 0;",
          "2462:         (unsigned long __user *)arg))",
          "2463:    Status = -EFAULT;",
          "2464:   break;",
          "2466:  case IOCTL_RTPS_BUCKET_SIZE:",
          "2467:   Status = 0;",
          "2469:         (unsigned long __user *)arg))",
          "2470:    Status = -EFAULT;",
          "2471:   break;",
          "2473:  case IOCTL_CHIP_RESET:",
          "2475:   return Status;",
          "2477:  case IOCTL_QOS_THRESHOLD:",
          "2479:   return Status;",
          "2481:  case IOCTL_DUMP_PACKET_INFO:",
          "2484:   Status = STATUS_SUCCESS;",
          "2485:   break;",
          "2487:  case IOCTL_GET_PACK_INFO:",
          "2489:      sizeof(struct bcm_packet_info)*NO_OF_QUEUES))",
          "2490:    return -EFAULT;",
          "2491:   Status = STATUS_SUCCESS;",
          "2492:   break;",
          "2494:  case IOCTL_BCM_SWITCH_TRANSFER_MODE:",
          "2496:   return Status;",
          "2498:  case IOCTL_BCM_GET_DRIVER_VERSION:",
          "",
          "[Removed Lines]",
          "2443:   Status = bcm_char_ioctl_misc_request(argp, Adapter);",
          "2447:   Status = bcm_char_ioctl_buffer_download_start(Adapter);",
          "2451:   Status = bcm_char_ioctl_buffer_download(argp, Adapter);",
          "2455:   Status = bcm_char_ioctl_buffer_download_stop(argp, Adapter);",
          "2461:   if (get_user(Adapter->BEBucketSize,",
          "2468:   if (get_user(Adapter->rtPSBucketSize,",
          "2474:   Status = bcm_char_ioctl_chip_reset(Adapter);",
          "2478:   Status = bcm_char_ioctl_qos_threshold(arg, Adapter);",
          "2482:   DumpPackInfo(Adapter);",
          "2483:   DumpPhsRules(&Adapter->stBCMPhsContext);",
          "2488:   if (copy_to_user(argp, &Adapter->PackInfo,",
          "2495:   Status = bcm_char_ioctl_switch_transfer_mode(argp, Adapter);",
          "",
          "[Added Lines]",
          "2443:   Status = bcm_char_ioctl_misc_request(argp, ad);",
          "2447:   Status = bcm_char_ioctl_buffer_download_start(ad);",
          "2451:   Status = bcm_char_ioctl_buffer_download(argp, ad);",
          "2455:   Status = bcm_char_ioctl_buffer_download_stop(argp, ad);",
          "2461:   if (get_user(ad->BEBucketSize,",
          "2468:   if (get_user(ad->rtPSBucketSize,",
          "2474:   Status = bcm_char_ioctl_chip_reset(ad);",
          "2478:   Status = bcm_char_ioctl_qos_threshold(arg, ad);",
          "2482:   DumpPackInfo(ad);",
          "2483:   DumpPhsRules(&ad->stBCMPhsContext);",
          "2488:   if (copy_to_user(argp, &ad->PackInfo,",
          "2495:   Status = bcm_char_ioctl_switch_transfer_mode(argp, ad);",
          "",
          "---------------",
          "--- Hunk 75 ---",
          "[Context before]",
          "2500:   return Status;",
          "2502:  case IOCTL_BCM_GET_CURRENT_STATUS:",
          "2504:   return Status;",
          "2506:  case IOCTL_BCM_SET_MAC_TRACING:",
          "2508:   return Status;",
          "2510:  case IOCTL_BCM_GET_DSX_INDICATION:",
          "2512:   return Status;",
          "2514:  case IOCTL_BCM_GET_HOST_MIBS:",
          "2516:   return Status;",
          "2518:  case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:",
          "2524:   }",
          "2526:   Status = STATUS_SUCCESS;",
          "2527:   break;",
          "2529:  case IOCTL_BCM_BULK_WRM:",
          "2531:   return Status;",
          "2533:  case IOCTL_BCM_GET_NVM_SIZE:",
          "2535:   return Status;",
          "2537:  case IOCTL_BCM_CAL_INIT:",
          "2539:   return Status;",
          "2541:  case IOCTL_BCM_SET_DEBUG:",
          "2543:   return Status;",
          "2545:  case IOCTL_BCM_NVM_READ:",
          "2546:  case IOCTL_BCM_NVM_WRITE:",
          "2548:   return Status;",
          "2550:  case IOCTL_BCM_FLASH2X_SECTION_READ:",
          "2552:   return Status;",
          "2554:  case IOCTL_BCM_FLASH2X_SECTION_WRITE:",
          "2556:   return Status;",
          "2558:  case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP:",
          "2560:   return Status;",
          "2562:  case IOCTL_BCM_SET_ACTIVE_SECTION:",
          "2564:   return Status;",
          "2566:  case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION:",
          "2570:     \"IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called\");",
          "2571:   Status = STATUS_SUCCESS;",
          "2572:   break;",
          "2574:  case IOCTL_BCM_COPY_SECTION:",
          "2576:   return Status;",
          "2578:  case IOCTL_BCM_GET_FLASH_CS_INFO:",
          "2580:   return Status;",
          "2582:  case IOCTL_BCM_SELECT_DSD:",
          "2584:   return Status;",
          "2586:  case IOCTL_BCM_NVM_RAW_READ:",
          "2588:   return Status;",
          "2590:  case IOCTL_BCM_CNTRLMSG_MASK:",
          "2592:   return Status;",
          "2594:  case IOCTL_BCM_GET_DEVICE_DRIVER_INFO:",
          "2596:   return Status;",
          "2598:  case IOCTL_BCM_TIME_SINCE_NET_ENTRY:",
          "2600:   return Status;",
          "2602:  case IOCTL_CLOSE_NOTIFICATION:",
          "2604:     \"IOCTL_CLOSE_NOTIFICATION\");",
          "2605:   break;",
          "",
          "[Removed Lines]",
          "2503:   Status = bcm_char_ioctl_get_current_status(argp, Adapter);",
          "2507:   Status = bcm_char_ioctl_set_mac_tracing(argp, Adapter);",
          "2511:   Status = bcm_char_ioctl_get_dsx_indication(argp, Adapter);",
          "2515:   Status = bcm_char_ioctl_get_host_mibs(argp, Adapter, pTarang);",
          "2519:   if ((false == Adapter->bTriedToWakeUpFromlowPowerMode) &&",
          "2520:     (TRUE == Adapter->IdleMode)) {",
          "2521:    Adapter->usIdleModePattern = ABORT_IDLE_MODE;",
          "2522:    Adapter->bWakeUpDevice = TRUE;",
          "2523:    wake_up(&Adapter->process_rx_cntrlpkt);",
          "2530:   Status = bcm_char_ioctl_bulk_wrm(argp, Adapter, cmd);",
          "2534:   Status = bcm_char_ioctl_get_nvm_size(argp, Adapter);",
          "2538:   Status = bcm_char_ioctl_cal_init(argp, Adapter);",
          "2542:   Status = bcm_char_ioctl_set_debug(argp, Adapter);",
          "2547:   Status = bcm_char_ioctl_nvm_rw(argp, Adapter, cmd);",
          "2551:   Status = bcm_char_ioctl_flash2x_section_read(argp, Adapter);",
          "2555:   Status = bcm_char_ioctl_flash2x_section_write(argp, Adapter);",
          "2559:   Status = bcm_char_ioctl_flash2x_section_bitmap(argp, Adapter);",
          "2563:   Status = bcm_char_ioctl_set_active_section(argp, Adapter);",
          "2568:   Adapter->bAllDSDWriteAllow = false;",
          "2569:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2575:   Status = bcm_char_ioctl_copy_section(argp, Adapter);",
          "2579:   Status = bcm_char_ioctl_get_flash_cs_info(argp, Adapter);",
          "2583:   Status = bcm_char_ioctl_select_dsd(argp, Adapter);",
          "2587:   Status = bcm_char_ioctl_nvm_raw_read(argp, Adapter);",
          "2591:   Status = bcm_char_ioctl_cntrlmsg_mask(argp, Adapter, pTarang);",
          "2595:   Status = bcm_char_ioctl_get_device_driver_info(argp, Adapter);",
          "2599:   Status = bcm_char_ioctl_time_since_net_entry(argp, Adapter);",
          "2603:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Added Lines]",
          "2503:   Status = bcm_char_ioctl_get_current_status(argp, ad);",
          "2507:   Status = bcm_char_ioctl_set_mac_tracing(argp, ad);",
          "2511:   Status = bcm_char_ioctl_get_dsx_indication(argp, ad);",
          "2515:   Status = bcm_char_ioctl_get_host_mibs(argp, ad, pTarang);",
          "2519:   if ((false == ad->bTriedToWakeUpFromlowPowerMode) &&",
          "2520:     (TRUE == ad->IdleMode)) {",
          "2521:    ad->usIdleModePattern = ABORT_IDLE_MODE;",
          "2522:    ad->bWakeUpDevice = TRUE;",
          "2523:    wake_up(&ad->process_rx_cntrlpkt);",
          "2530:   Status = bcm_char_ioctl_bulk_wrm(argp, ad, cmd);",
          "2534:   Status = bcm_char_ioctl_get_nvm_size(argp, ad);",
          "2538:   Status = bcm_char_ioctl_cal_init(argp, ad);",
          "2542:   Status = bcm_char_ioctl_set_debug(argp, ad);",
          "2547:   Status = bcm_char_ioctl_nvm_rw(argp, ad, cmd);",
          "2551:   Status = bcm_char_ioctl_flash2x_section_read(argp, ad);",
          "2555:   Status = bcm_char_ioctl_flash2x_section_write(argp, ad);",
          "2559:   Status = bcm_char_ioctl_flash2x_section_bitmap(argp, ad);",
          "2563:   Status = bcm_char_ioctl_set_active_section(argp, ad);",
          "2568:   ad->bAllDSDWriteAllow = false;",
          "2569:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2575:   Status = bcm_char_ioctl_copy_section(argp, ad);",
          "2579:   Status = bcm_char_ioctl_get_flash_cs_info(argp, ad);",
          "2583:   Status = bcm_char_ioctl_select_dsd(argp, ad);",
          "2587:   Status = bcm_char_ioctl_nvm_raw_read(argp, ad);",
          "2591:   Status = bcm_char_ioctl_cntrlmsg_mask(argp, ad, pTarang);",
          "2595:   Status = bcm_char_ioctl_get_device_driver_info(argp, ad);",
          "2599:   Status = bcm_char_ioctl_time_since_net_entry(argp, ad);",
          "2603:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "---------------",
          "--- Hunk 76 ---",
          "[Context before]",
          "2622:  .llseek = no_llseek,",
          "2623: };",
          "2626: {",
          "2633:   pr_err(DRV_NAME \": could not created character device\\n\");",
          "2635:  }",
          "2642:   pr_err(DRV_NAME \": class device create failed\\n\");",
          "2645:  }",
          "2647:  return 0;",
          "2648: }",
          "2651: {",
          "2655:  }",
          "2656: }",
          "",
          "[Removed Lines]",
          "2625: int register_control_device_interface(struct bcm_mini_adapter *Adapter)",
          "2628:  if (Adapter->major > 0)",
          "2629:   return Adapter->major;",
          "2631:  Adapter->major = register_chrdev(0, DEV_NAME, &bcm_fops);",
          "2632:  if (Adapter->major < 0) {",
          "2634:   return Adapter->major;",
          "2637:  Adapter->pstCreatedClassDevice = device_create(bcm_class, NULL,",
          "2638:              MKDEV(Adapter->major, 0),",
          "2639:              Adapter, DEV_NAME);",
          "2641:  if (IS_ERR(Adapter->pstCreatedClassDevice)) {",
          "2643:   unregister_chrdev(Adapter->major, DEV_NAME);",
          "2644:   return PTR_ERR(Adapter->pstCreatedClassDevice);",
          "2650: void unregister_control_device_interface(struct bcm_mini_adapter *Adapter)",
          "2652:  if (Adapter->major > 0) {",
          "2653:   device_destroy(bcm_class, MKDEV(Adapter->major, 0));",
          "2654:   unregister_chrdev(Adapter->major, DEV_NAME);",
          "",
          "[Added Lines]",
          "2625: int register_control_device_interface(struct bcm_mini_adapter *ad)",
          "2628:  if (ad->major > 0)",
          "2629:   return ad->major;",
          "2631:  ad->major = register_chrdev(0, DEV_NAME, &bcm_fops);",
          "2632:  if (ad->major < 0) {",
          "2634:   return ad->major;",
          "2637:  ad->pstCreatedClassDevice = device_create(bcm_class, NULL,",
          "2638:              MKDEV(ad->major, 0),",
          "2639:              ad, DEV_NAME);",
          "2641:  if (IS_ERR(ad->pstCreatedClassDevice)) {",
          "2643:   unregister_chrdev(ad->major, DEV_NAME);",
          "2644:   return PTR_ERR(ad->pstCreatedClassDevice);",
          "2650: void unregister_control_device_interface(struct bcm_mini_adapter *ad)",
          "2652:  if (ad->major > 0) {",
          "2653:   device_destroy(bcm_class, MKDEV(ad->major, 0));",
          "2654:   unregister_chrdev(ad->major, DEV_NAME);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5ab1b7f2ae07bb0505c9f8e56ce79da87ed8c2b1",
      "candidate_info": {
        "commit_hash": "5ab1b7f2ae07bb0505c9f8e56ce79da87ed8c2b1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5ab1b7f2ae07bb0505c9f8e56ce79da87ed8c2b1",
        "files": [
          "drivers/staging/bcm/Bcmchar.c"
        ],
        "message": "Staging: bcm: Bcmchar.c: Renamed variable: \"Status\" -> \"status\"\n\nSigned-off-by: Matthias Beyer <mail@beyermatthias.de>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
          ],
          "candidate": [
            "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c": [
          "File: drivers/staging/bcm/Bcmchar.c -> drivers/staging/bcm/Bcmchar.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "644:  struct bcm_ioctl_buffer io_buff;",
          "645:  ULONG bit = 0;",
          "646:  UCHAR read[4];",
          "648:  int bytes;",
          "650:  if ((ad->IdleMode == TRUE) ||",
          "",
          "[Removed Lines]",
          "647:  INT Status;",
          "",
          "[Added Lines]",
          "647:  INT status;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "669:     (PUINT)read, sizeof(UINT));",
          "671:  if (bytes < 0) {",
          "673:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "674:     \"RDM Failed\\n\");",
          "676:  } else {",
          "678:  }",
          "680: }",
          "682: static int bcm_char_ioctl_gpio_multi_request(void __user *argp,",
          "",
          "[Removed Lines]",
          "672:   Status = bytes;",
          "675:   return Status;",
          "677:   Status = STATUS_SUCCESS;",
          "679:  return Status;",
          "",
          "[Added Lines]",
          "672:   status = bytes;",
          "675:   return status;",
          "677:   status = STATUS_SUCCESS;",
          "679:  return status;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "687:   (struct bcm_gpio_multi_info *)gpio_multi_info;",
          "688:  struct bcm_ioctl_buffer io_buff;",
          "689:  UCHAR ucResetValue[4];",
          "691:  int bytes;",
          "693:  memset(pgpio_multi_info, 0,",
          "",
          "[Removed Lines]",
          "690:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "690:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "729:    pgpio_multi_info[WIMAX_IDX].uiGPIOValue;",
          "731:   if (*(UINT *) ucResetValue)",
          "733:     BCM_GPIO_OUTPUT_SET_REG,",
          "734:     (PUINT)ucResetValue, sizeof(ULONG));",
          "737:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "738:     \"WRM to BCM_GPIO_OUTPUT_SET_REG Failed.\");",
          "740:   }",
          "",
          "[Removed Lines]",
          "732:    Status = wrmaltWithLock(ad,",
          "736:   if (Status != STATUS_SUCCESS) {",
          "739:    return Status;",
          "",
          "[Added Lines]",
          "732:    status = wrmaltWithLock(ad,",
          "736:   if (status != STATUS_SUCCESS) {",
          "739:    return status;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "746:    (~(pgpio_multi_info[WIMAX_IDX].uiGPIOValue)));",
          "748:   if (*(UINT *) ucResetValue)",
          "750:     BCM_GPIO_OUTPUT_CLR_REG, (PUINT)ucResetValue,",
          "751:     sizeof(ULONG));",
          "754:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "755:      \"WRM to BCM_GPIO_OUTPUT_CLR_REG Failed.\");",
          "757:   }",
          "758:  }",
          "",
          "[Removed Lines]",
          "749:    Status = wrmaltWithLock(ad,",
          "753:   if (Status != STATUS_SUCCESS) {",
          "756:    return Status;",
          "",
          "[Added Lines]",
          "749:    status = wrmaltWithLock(ad,",
          "753:   if (status != STATUS_SUCCESS) {",
          "756:    return status;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "762:            (PUINT)ucResetValue, sizeof(UINT));",
          "764:   if (bytes < 0) {",
          "766:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "767:      \"RDM to GPIO_PIN_STATE_REGISTER Failed.\");",
          "769:   } else {",
          "771:   }",
          "773:   pgpio_multi_info[WIMAX_IDX].uiGPIOValue =",
          "",
          "[Removed Lines]",
          "765:    Status = bytes;",
          "768:    return Status;",
          "770:    Status = STATUS_SUCCESS;",
          "",
          "[Added Lines]",
          "765:    status = bytes;",
          "768:    return status;",
          "770:    status = STATUS_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "775:    pgpio_multi_info[WIMAX_IDX].uiGPIOMask);",
          "776:  }",
          "779:   io_buff.OutputLength);",
          "781:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "782:    \"Failed while copying Content to IOBufer for user space err:%d\",",
          "784:   return -EFAULT;",
          "785:  }",
          "787: }",
          "789: static int bcm_char_ioctl_gpio_mode_request(void __user *argp,",
          "",
          "[Removed Lines]",
          "778:  Status = copy_to_user(io_buff.OutputBuffer, &gpio_multi_info,",
          "780:  if (Status) {",
          "783:    Status);",
          "786:  return Status;",
          "",
          "[Added Lines]",
          "778:  status = copy_to_user(io_buff.OutputBuffer, &gpio_multi_info,",
          "780:  if (status) {",
          "783:    status);",
          "786:  return status;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "794:   (struct bcm_gpio_multi_mode *)gpio_multi_mode;",
          "795:  struct bcm_ioctl_buffer io_buff;",
          "796:  UCHAR ucResetValue[4];",
          "798:  int bytes;",
          "800:  if ((ad->IdleMode == TRUE) ||",
          "",
          "[Removed Lines]",
          "797:  INT Status;",
          "",
          "[Added Lines]",
          "797:  INT status;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "818:   (PUINT)ucResetValue, sizeof(UINT));",
          "820:  if (bytes < 0) {",
          "822:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "823:    \"Read of GPIO_MODE_REGISTER failed\");",
          "825:  } else {",
          "827:  }",
          "",
          "[Removed Lines]",
          "821:   Status = bytes;",
          "824:   return Status;",
          "826:   Status = STATUS_SUCCESS;",
          "",
          "[Added Lines]",
          "821:   status = bytes;",
          "824:   return status;",
          "826:   status = STATUS_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "853:   pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;",
          "856:    (PUINT)ucResetValue, sizeof(ULONG));",
          "858:    BCM_DEBUG_PRINT(ad,",
          "859:     DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "860:     \"WRM to GPIO_MODE_REGISTER Done\");",
          "",
          "[Removed Lines]",
          "855:   Status = wrmaltWithLock(ad, GPIO_MODE_REGISTER,",
          "857:   if (Status == STATUS_SUCCESS) {",
          "",
          "[Added Lines]",
          "855:   status = wrmaltWithLock(ad, GPIO_MODE_REGISTER,",
          "857:   if (status == STATUS_SUCCESS) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "868:   pgpio_multi_mode[WIMAX_IDX].uiGPIOMode = *(UINT *)ucResetValue;",
          "869:  }",
          "872:   io_buff.OutputLength);",
          "874:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "875:    \"Failed while copying Content to IOBufer for user space err:%d\",",
          "877:   return -EFAULT;",
          "878:  }",
          "880: }",
          "882: static int bcm_char_ioctl_misc_request(void __user *argp,",
          "",
          "[Removed Lines]",
          "871:  Status = copy_to_user(io_buff.OutputBuffer, &gpio_multi_mode,",
          "873:  if (Status) {",
          "876:    Status);",
          "879:  return Status;",
          "",
          "[Added Lines]",
          "871:  status = copy_to_user(io_buff.OutputBuffer, &gpio_multi_mode,",
          "873:  if (status) {",
          "876:    status);",
          "879:  return status;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "884: {",
          "885:  struct bcm_ioctl_buffer io_buff;",
          "886:  PVOID pvBuffer = NULL;",
          "890:  if (copy_from_user(&io_buff, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "887:  INT Status;",
          "",
          "[Added Lines]",
          "887:  INT status;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "902:   return PTR_ERR(pvBuffer);",
          "904:  down(&ad->LowPowerModeSync);",
          "906:    ad->lowpower_mode_wait_queue,",
          "907:    !ad->bPreparingForLowPowerMode,",
          "908:    (1 * HZ));",
          "911:   goto cntrlEnd;",
          "913:  if (ad->bPreparingForLowPowerMode) {",
          "914:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "915:     \"Preparing Idle Mode is still True - Hence Rejecting control message\\n\");",
          "917:   goto cntrlEnd;",
          "918:  }",
          "921: cntrlEnd:",
          "922:  up(&ad->LowPowerModeSync);",
          "923:  kfree(pvBuffer);",
          "925: }",
          "927: static int bcm_char_ioctl_buffer_download_start(",
          "928:   struct bcm_mini_adapter *ad)",
          "929: {",
          "932:  if (down_trylock(&ad->NVMRdmWrmLock)) {",
          "933:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Removed Lines]",
          "905:  Status = wait_event_interruptible_timeout(",
          "910:  if (Status == -ERESTARTSYS)",
          "916:   Status = STATUS_FAILURE;",
          "919:  Status = CopyBufferToControlPacket(ad, (PVOID)pvBuffer);",
          "924:  return Status;",
          "930:  INT Status;",
          "",
          "[Added Lines]",
          "905:  status = wait_event_interruptible_timeout(",
          "910:  if (status == -ERESTARTSYS)",
          "916:   status = STATUS_FAILURE;",
          "919:  status = CopyBufferToControlPacket(ad, (PVOID)pvBuffer);",
          "924:  return status;",
          "930:  INT status;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "948:  ad->fw_download_done = false;",
          "949:  netif_carrier_off(ad->dev);",
          "950:  netif_stop_queue(ad->dev);",
          "953:   pr_err(PFX \"%s: reset_card_proc Failed!\\n\", ad->dev->name);",
          "954:   up(&ad->fw_download_sema);",
          "955:   up(&ad->NVMRdmWrmLock);",
          "957:  }",
          "958:  mdelay(10);",
          "960:  up(&ad->NVMRdmWrmLock);",
          "962: }",
          "964: static int bcm_char_ioctl_buffer_download(void __user *argp,",
          "",
          "[Removed Lines]",
          "951:  Status = reset_card_proc(ad);",
          "952:  if (Status) {",
          "956:   return Status;",
          "961:  return Status;",
          "",
          "[Added Lines]",
          "951:  status = reset_card_proc(ad);",
          "952:  if (status) {",
          "956:   return status;",
          "961:  return status;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "966: {",
          "967:  struct bcm_firmware_info *psFwInfo = NULL;",
          "968:  struct bcm_ioctl_buffer io_buff;",
          "971:  BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "972:   \"Starting the firmware download PID =0x%x!!!!\\n\", current->pid);",
          "",
          "[Removed Lines]",
          "969:  INT Status;",
          "",
          "[Added Lines]",
          "969:  INT status;",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1013:     psFwInfo->u32FirmwareLength);",
          "1014:   up(&ad->fw_download_sema);",
          "1015:   kfree(psFwInfo);",
          "1018:  }",
          "1023:   if (psFwInfo->u32StartingAddress == CONFIG_BEGIN_ADDR)",
          "1024:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1025:     \"IOCTL: Configuration File Upload Failed\\n\");",
          "",
          "[Removed Lines]",
          "1016:   Status = -EINVAL;",
          "1017:   return Status;",
          "1020:  Status = bcm_ioctl_fw_download(ad, psFwInfo);",
          "1022:  if (Status != STATUS_SUCCESS) {",
          "",
          "[Added Lines]",
          "1016:   status = -EINVAL;",
          "1017:   return status;",
          "1020:  status = bcm_ioctl_fw_download(ad, psFwInfo);",
          "1022:  if (status != STATUS_SUCCESS) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1037:   }",
          "1038:  }",
          "1041:   up(&ad->fw_download_sema);",
          "1043:  BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, OSAL_DBG, DBG_LVL_ALL,",
          "1044:   \"IOCTL: Firmware File Uploaded\\n\");",
          "1045:  kfree(psFwInfo);",
          "1047: }",
          "1049: static int bcm_char_ioctl_buffer_download_stop(void __user *argp,",
          "1050:             struct bcm_mini_adapter *ad)",
          "1051: {",
          "1053:  int timeout = 0;",
          "1055:  if (!down_trylock(&ad->fw_download_sema)) {",
          "",
          "[Removed Lines]",
          "1040:  if (Status != STATUS_SUCCESS)",
          "1046:  return Status;",
          "1052:  INT Status;",
          "",
          "[Added Lines]",
          "1040:  if (status != STATUS_SUCCESS)",
          "1046:  return status;",
          "1052:  INT status;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1071:  ad->downloadDDR = 0;",
          "1077:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1078:    \"Firm Download Failed\\n\");",
          "1079:   up(&ad->fw_download_sema);",
          "1080:   up(&ad->NVMRdmWrmLock);",
          "1082:  } else {",
          "1083:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1084:     DBG_LVL_ALL, \"Firm Download Over...\\n\");",
          "",
          "[Removed Lines]",
          "1074:  Status = run_card_proc(ad);",
          "1076:  if (Status) {",
          "1081:   return Status;",
          "",
          "[Added Lines]",
          "1074:  status = run_card_proc(ad);",
          "1076:  if (status) {",
          "1081:   return status;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1111:  }",
          "1113:  if (!timeout)",
          "1116:  up(&ad->fw_download_sema);",
          "1117:  up(&ad->NVMRdmWrmLock);",
          "1119: }",
          "1121: static int bcm_char_ioctl_chip_reset(struct bcm_mini_adapter *ad)",
          "1122: {",
          "1124:  INT NVMAccess;",
          "1126:  NVMAccess = down_trylock(&ad->NVMRdmWrmLock);",
          "",
          "[Removed Lines]",
          "1114:   Status = -ENODEV;",
          "1118:  return Status;",
          "1123:  INT Status;",
          "",
          "[Added Lines]",
          "1114:   status = -ENODEV;",
          "1118:  return status;",
          "1123:  INT status;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1131:  }",
          "1133:  down(&ad->RxAppControlQueuelock);",
          "1135:  flushAllAppQ();",
          "1136:  up(&ad->RxAppControlQueuelock);",
          "1137:  up(&ad->NVMRdmWrmLock);",
          "1138:  ResetCounters(ad);",
          "1140: }",
          "1142: static int bcm_char_ioctl_qos_threshold(ULONG arg,",
          "",
          "[Removed Lines]",
          "1134:  Status = reset_card_proc(ad);",
          "1139:  return Status;",
          "",
          "[Added Lines]",
          "1134:  status = reset_card_proc(ad);",
          "1139:  return status;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1275:      struct bcm_tarang_data *pTarang)",
          "1276: {",
          "1277:  struct bcm_ioctl_buffer io_buff;",
          "1279:  PVOID temp_buff;",
          "1281:  if (copy_from_user(&io_buff, argp, sizeof(struct bcm_ioctl_buffer)))",
          "",
          "[Removed Lines]",
          "1278:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "1278:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1293:  if (!temp_buff)",
          "1294:   return STATUS_FAILURE;",
          "1297:  GetDroppedAppCntrlPktMibs(temp_buff, pTarang);",
          "1300:   if (copy_to_user(io_buff.OutputBuffer, temp_buff,",
          "1301:    sizeof(struct bcm_host_stats_mibs))) {",
          "1302:    kfree(temp_buff);",
          "",
          "[Removed Lines]",
          "1296:  Status = ProcessGetHostMibs(ad, temp_buff);",
          "1299:  if (Status != STATUS_FAILURE) {",
          "",
          "[Added Lines]",
          "1296:  status = ProcessGetHostMibs(ad, temp_buff);",
          "1299:  if (status != STATUS_FAILURE) {",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1305:  }",
          "1307:  kfree(temp_buff);",
          "1309: }",
          "1311: static int bcm_char_ioctl_bulk_wrm(void __user *argp,",
          "",
          "[Removed Lines]",
          "1308:  return Status;",
          "",
          "[Added Lines]",
          "1308:  return status;",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1314:  struct bcm_bulk_wrm_buffer *pBulkBuffer;",
          "1315:  struct bcm_ioctl_buffer io_buff;",
          "1316:  UINT uiTempVar = 0;",
          "1318:  PCHAR pvBuffer = NULL;",
          "1320:  if ((ad->IdleMode == TRUE) ||",
          "",
          "[Removed Lines]",
          "1317:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "1317:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1364:  }",
          "1366:  if (pBulkBuffer->SwapEndian == false)",
          "1368:    (PCHAR)pBulkBuffer->Values,",
          "1369:    io_buff.InputLength - 2*sizeof(ULONG));",
          "1370:  else",
          "1372:    (PUINT)pBulkBuffer->Values,",
          "1373:    io_buff.InputLength - 2*sizeof(ULONG));",
          "1376:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0, \"WRM Failed\\n\");",
          "1378:  kfree(pvBuffer);",
          "1380: }",
          "1382: static int bcm_char_ioctl_get_nvm_size(void __user *argp,",
          "",
          "[Removed Lines]",
          "1367:   Status = wrmWithLock(ad, (UINT)pBulkBuffer->Register,",
          "1371:   Status = wrmaltWithLock(ad, (UINT)pBulkBuffer->Register,",
          "1375:  if (Status != STATUS_SUCCESS)",
          "1379:  return Status;",
          "",
          "[Added Lines]",
          "1367:   status = wrmWithLock(ad, (UINT)pBulkBuffer->Register,",
          "1371:   status = wrmaltWithLock(ad, (UINT)pBulkBuffer->Register,",
          "1375:  if (status != STATUS_SUCCESS)",
          "1379:  return status;",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1401: {",
          "1402:  struct bcm_ioctl_buffer io_buff;",
          "1403:  UINT uiSectorSize = 0;",
          "1406:  if (ad->eNVMType == NVM_FLASH) {",
          "1407:   if (copy_from_user(&io_buff, argp,",
          "",
          "[Removed Lines]",
          "1404:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "1404:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1436:      ad->uiSectorSize);",
          "1437:    }",
          "1438:   }",
          "1440:  } else {",
          "1442:  }",
          "1444: }",
          "1446: static int bcm_char_ioctl_set_debug(void __user *argp,",
          "",
          "[Removed Lines]",
          "1439:   Status = STATUS_SUCCESS;",
          "1441:   Status = STATUS_FAILURE;",
          "1443:  return Status;",
          "",
          "[Added Lines]",
          "1439:   status = STATUS_SUCCESS;",
          "1441:   status = STATUS_FAILURE;",
          "1443:  return status;",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1493:  struct timeval tv0, tv1;",
          "1494:  struct bcm_ioctl_buffer io_buff;",
          "1495:  PUCHAR pReadData = NULL;",
          "1498:  memset(&tv0, 0, sizeof(struct timeval));",
          "1499:  memset(&tv1, 0, sizeof(struct timeval));",
          "",
          "[Removed Lines]",
          "1496:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "1496:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1570:     return ret;",
          "1571:   }",
          "1574:    stNVMReadWrite.uiOffset, stNVMReadWrite.uiNumBytes,",
          "1575:    stNVMReadWrite.bVerify);",
          "1576:   if (IsFlash2x(ad))",
          "",
          "[Removed Lines]",
          "1573:   Status = BeceemNVMWrite(ad, (PUINT)pReadData,",
          "",
          "[Added Lines]",
          "1573:   status = BeceemNVMWrite(ad, (PUINT)pReadData,",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1581:   up(&ad->NVMRdmWrmLock);",
          "1584:    kfree(pReadData);",
          "1586:   }",
          "1587:  }",
          "",
          "[Removed Lines]",
          "1583:   if (Status != STATUS_SUCCESS) {",
          "1585:    return Status;",
          "",
          "[Added Lines]",
          "1583:   if (status != STATUS_SUCCESS) {",
          "1585:    return status;",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1606:  UINT BuffSize = 0;",
          "1607:  UINT ReadBytes = 0;",
          "1608:  UINT ReadOffset = 0;",
          "1610:  void __user *OutPutBuff;",
          "1612:  if (IsFlash2x(ad) != TRUE) {",
          "",
          "[Removed Lines]",
          "1609:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "1609:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1680:    ReadBytes = NOB;",
          "1684:    sFlash2xRead.Section, ReadOffset, ReadBytes);",
          "1686:    BCM_DEBUG_PRINT(ad,",
          "1687:     DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1690:    break;",
          "1691:   }",
          "1693:   BCM_DEBUG_PRINT_BUFFER(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "1694:    DBG_LVL_ALL, pReadBuff, ReadBytes);",
          "1698:    BCM_DEBUG_PRINT(ad,",
          "1699:     DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1701:    up(&ad->NVMRdmWrmLock);",
          "1702:    kfree(pReadBuff);",
          "1703:    return -EFAULT;",
          "",
          "[Removed Lines]",
          "1683:   Status = BcmFlash2xBulkRead(ad, (PUINT)pReadBuff,",
          "1685:   if (Status) {",
          "1688:     \"Flash 2x read err with Status :%d\",",
          "1689:     Status);",
          "1696:   Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);",
          "1697:   if (Status) {",
          "1700:     \"Copy to use failed with status :%d\", Status);",
          "",
          "[Added Lines]",
          "1683:   status = BcmFlash2xBulkRead(ad, (PUINT)pReadBuff,",
          "1685:   if (status) {",
          "1688:     \"Flash 2x read err with status :%d\",",
          "1689:     status);",
          "1696:   status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);",
          "1697:   if (status) {",
          "1700:     \"Copy to use failed with status :%d\", status);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1712:  up(&ad->NVMRdmWrmLock);",
          "1713:  kfree(pReadBuff);",
          "1715: }",
          "1717: static int bcm_char_ioctl_flash2x_section_write(void __user *argp,",
          "",
          "[Removed Lines]",
          "1714:  return Status;",
          "",
          "[Added Lines]",
          "1714:  return status;",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1725:  UINT BuffSize = 0;",
          "1726:  UINT WriteOffset = 0;",
          "1727:  UINT WriteBytes = 0;",
          "1730:  if (IsFlash2x(ad) != TRUE) {",
          "1731:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Removed Lines]",
          "1728:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "1728:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1808:  BcmFlash2xCorruptSig(ad, sFlash2xWrite.Section);",
          "1809:  do {",
          "1812:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1814:    up(&ad->NVMRdmWrmLock);",
          "1815:    kfree(pWriteBuff);",
          "1816:    return -EFAULT;",
          "",
          "[Removed Lines]",
          "1810:   Status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);",
          "1811:   if (Status) {",
          "1813:     \"Copy to user failed with status :%d\", Status);",
          "",
          "[Added Lines]",
          "1810:   status = copy_from_user(pWriteBuff, InputAddr, WriteBytes);",
          "1811:   if (status) {",
          "1813:     \"Copy to user failed with status :%d\", status);",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1819:    OSAL_DBG, DBG_LVL_ALL, pWriteBuff, WriteBytes);",
          "1823:           sFlash2xWrite.Section,",
          "1824:           WriteOffset,",
          "1825:           WriteBytes,",
          "1826:           sFlash2xWrite.bVerify);",
          "1829:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1831:    break;",
          "1832:   }",
          "",
          "[Removed Lines]",
          "1822:   Status = BcmFlash2xBulkWrite(ad, (PUINT)pWriteBuff,",
          "1828:   if (Status) {",
          "1830:     \"Flash 2x read err with Status :%d\", Status);",
          "",
          "[Added Lines]",
          "1822:   status = BcmFlash2xBulkWrite(ad, (PUINT)pWriteBuff,",
          "1828:   if (status) {",
          "1830:     \"Flash 2x read err with status :%d\", status);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1845:  BcmFlash2xWriteSig(ad, sFlash2xWrite.Section);",
          "1846:  up(&ad->NVMRdmWrmLock);",
          "1847:  kfree(pWriteBuff);",
          "1849: }",
          "1851: static int bcm_char_ioctl_flash2x_section_bitmap(void __user *argp,",
          "",
          "[Removed Lines]",
          "1848:  return Status;",
          "",
          "[Added Lines]",
          "1848:  return status;",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1902:           struct bcm_mini_adapter *ad)",
          "1903: {",
          "1904:  enum bcm_flash2x_section_val eFlash2xSectionVal = 0;",
          "1906:  struct bcm_ioctl_buffer io_buff;",
          "1908:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Removed Lines]",
          "1905:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "1905:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1914:   return -EINVAL;",
          "1915:  }",
          "1918:     sizeof(struct bcm_ioctl_buffer));",
          "1920:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1921:     \"Copy of IOCTL BUFFER failed\");",
          "1922:   return -EFAULT;",
          "1923:  }",
          "1926:     io_buff.InputBuffer, sizeof(INT));",
          "1928:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1929:    \"Copy of flash section val failed\");",
          "1930:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "1917:  Status = copy_from_user(&io_buff, argp,",
          "1919:  if (Status) {",
          "1925:  Status = copy_from_user(&eFlash2xSectionVal,",
          "1927:  if (Status) {",
          "",
          "[Added Lines]",
          "1917:  status = copy_from_user(&io_buff, argp,",
          "1919:  if (status) {",
          "1925:  status = copy_from_user(&eFlash2xSectionVal,",
          "1927:  if (status) {",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1942:   return -EACCES;",
          "1943:  }",
          "1947:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1951:  up(&ad->NVMRdmWrmLock);",
          "1954: }",
          "1956: static int bcm_char_ioctl_copy_section(void __user *argp,",
          "",
          "[Removed Lines]",
          "1945:  Status = BcmSetActiveSection(ad, eFlash2xSectionVal);",
          "1946:  if (Status)",
          "1948:     \"Failed to make it's priority Highest. Status %d\",",
          "1949:     Status);",
          "1953:  return Status;",
          "",
          "[Added Lines]",
          "1945:  status = BcmSetActiveSection(ad, eFlash2xSectionVal);",
          "1946:  if (status)",
          "1948:     \"Failed to make it's priority Highest. status %d\",",
          "1949:     status);",
          "1953:  return status;",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1958: {",
          "1959:  struct bcm_flash2x_copy_section sCopySectStrut = {0};",
          "1960:  struct bcm_ioctl_buffer io_buff;",
          "1963:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "1964:    \"IOCTL_BCM_COPY_SECTION  Called\");",
          "",
          "[Removed Lines]",
          "1961:  INT Status = STATUS_SUCCESS;",
          "",
          "[Added Lines]",
          "1961:  INT status = STATUS_SUCCESS;",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1970:   return -EINVAL;",
          "1971:  }",
          "1974:     sizeof(struct bcm_ioctl_buffer));",
          "1976:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1979:   return -EFAULT;",
          "1980:  }",
          "1983:     sizeof(struct bcm_flash2x_copy_section));",
          "1985:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "1988:   return -EFAULT;",
          "1989:  }",
          "",
          "[Removed Lines]",
          "1973:  Status = copy_from_user(&io_buff, argp,",
          "1975:  if (Status) {",
          "1977:     \"Copy of IOCTL BUFFER failed Status :%d\",",
          "1978:     Status);",
          "1982:  Status = copy_from_user(&sCopySectStrut, io_buff.InputBuffer,",
          "1984:  if (Status) {",
          "1986:     \"Copy of Copy_Section_Struct failed with Status :%d\",",
          "1987:     Status);",
          "",
          "[Added Lines]",
          "1973:  status = copy_from_user(&io_buff, argp,",
          "1975:  if (status) {",
          "1977:     \"Copy of IOCTL BUFFER failed status :%d\",",
          "1978:     status);",
          "1982:  status = copy_from_user(&sCopySectStrut, io_buff.InputBuffer,",
          "1984:  if (status) {",
          "1986:     \"Copy of Copy_Section_Struct failed with status :%d\",",
          "1987:     status);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2034:   if (IsNonCDLessDevice(ad)) {",
          "2035:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2036:      \"Device is Non-CDLess hence won't have ISO !!\");",
          "2038:   } else if (sCopySectStrut.numOfBytes == 0) {",
          "2040:   } else {",
          "2041:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2042:      \"Partial Copy of ISO section is not Allowed..\");",
          "2044:   }",
          "2045:   up(&ad->NVMRdmWrmLock);",
          "2047:  }",
          "2050:     sCopySectStrut.DstSection,",
          "2051:     sCopySectStrut.offset,",
          "2052:     sCopySectStrut.numOfBytes);",
          "2053:  up(&ad->NVMRdmWrmLock);",
          "2055: }",
          "2057: static int bcm_char_ioctl_get_flash_cs_info(void __user *argp,",
          "2058:          struct bcm_mini_adapter *ad)",
          "2059: {",
          "2060:  struct bcm_ioctl_buffer io_buff;",
          "2063:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2064:    \" IOCTL_BCM_GET_FLASH_CS_INFO Called\");",
          "2067:    sizeof(struct bcm_ioctl_buffer));",
          "2069:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2070:     \"Copy of IOCTL BUFFER failed\");",
          "2071:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "2037:    Status = -EINVAL;",
          "2039:    Status = BcmCopyISO(ad, sCopySectStrut);",
          "2043:    Status = STATUS_FAILURE;",
          "2046:   return Status;",
          "2049:  Status = BcmCopySection(ad, sCopySectStrut.SrcSection,",
          "2054:  return Status;",
          "2061:  INT Status = STATUS_SUCCESS;",
          "2066:  Status = copy_from_user(&io_buff, argp,",
          "2068:  if (Status) {",
          "",
          "[Added Lines]",
          "2037:    status = -EINVAL;",
          "2039:    status = BcmCopyISO(ad, sCopySectStrut);",
          "2043:    status = STATUS_FAILURE;",
          "2046:   return status;",
          "2049:  status = BcmCopySection(ad, sCopySectStrut.SrcSection,",
          "2054:  return status;",
          "2061:  INT status = STATUS_SUCCESS;",
          "2066:  status = copy_from_user(&io_buff, argp,",
          "2068:  if (status) {",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2093:      sizeof(struct bcm_flash_cs_info)))",
          "2094:    return -EFAULT;",
          "2095:  }",
          "2097: }",
          "2099: static int bcm_char_ioctl_select_dsd(void __user *argp,",
          "2100:          struct bcm_mini_adapter *ad)",
          "2101: {",
          "2102:  struct bcm_ioctl_buffer io_buff;",
          "2104:  UINT SectOfset = 0;",
          "2105:  enum bcm_flash2x_section_val eFlash2xSectionVal;",
          "",
          "[Removed Lines]",
          "2096:  return Status;",
          "2103:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "2096:  return status;",
          "2103:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2114:   return -EINVAL;",
          "2115:  }",
          "2118:     sizeof(struct bcm_ioctl_buffer));",
          "2120:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2121:     \"Copy of IOCTL BUFFER failed\");",
          "2122:   return -EFAULT;",
          "2123:  }",
          "2125:   sizeof(INT));",
          "2127:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2128:     \"Copy of flash section val failed\");",
          "2129:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "2117:  Status = copy_from_user(&io_buff, argp,",
          "2119:  if (Status) {",
          "2124:  Status = copy_from_user(&eFlash2xSectionVal, io_buff.InputBuffer,",
          "2126:  if (Status) {",
          "",
          "[Added Lines]",
          "2117:  status = copy_from_user(&io_buff, argp,",
          "2119:  if (status) {",
          "2124:  status = copy_from_user(&eFlash2xSectionVal, io_buff.InputBuffer,",
          "2126:  if (status) {",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2167:  UINT ReadBytes = 0;",
          "2168:  PUCHAR pReadBuff;",
          "2169:  void __user *OutPutBuff;",
          "2172:  if (ad->eNVMType != NVM_FLASH) {",
          "2173:   BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "",
          "[Removed Lines]",
          "2170:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "2170:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2225:    ReadBytes = NOB;",
          "2229:    ReadOffset, ReadBytes);",
          "2231:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2234:    break;",
          "2235:   }",
          "2237:   BCM_DEBUG_PRINT_BUFFER(ad, DBG_TYPE_OTHERS, OSAL_DBG,",
          "2238:            DBG_LVL_ALL, pReadBuff, ReadBytes);",
          "2242:    BCM_DEBUG_PRINT(ad, DBG_TYPE_PRINTK, 0, 0,",
          "2243:      \"Copy to use failed with status :%d\",",
          "2245:    up(&ad->NVMRdmWrmLock);",
          "2246:    kfree(pReadBuff);",
          "2247:    return -EFAULT;",
          "",
          "[Removed Lines]",
          "2228:   Status = BeceemNVMRead(ad, (PUINT)pReadBuff,",
          "2230:   if (Status) {",
          "2232:      \"Flash 2x read err with Status :%d\",",
          "2233:      Status);",
          "2240:   Status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);",
          "2241:   if (Status) {",
          "2244:      Status);",
          "",
          "[Added Lines]",
          "2228:   status = BeceemNVMRead(ad, (PUINT)pReadBuff,",
          "2230:   if (status) {",
          "2232:      \"Flash 2x read err with status :%d\",",
          "2233:      status);",
          "2240:   status = copy_to_user(OutPutBuff, pReadBuff, ReadBytes);",
          "2241:   if (status) {",
          "2244:      status);",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2255:  ad->bFlashRawRead = false;",
          "2256:  up(&ad->NVMRdmWrmLock);",
          "2257:  kfree(pReadBuff);",
          "2259: }",
          "2261: static int bcm_char_ioctl_cntrlmsg_mask(void __user *argp,",
          "",
          "[Removed Lines]",
          "2258:  return Status;",
          "",
          "[Added Lines]",
          "2258:  return status;",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2263:      struct bcm_tarang_data *pTarang)",
          "2264: {",
          "2265:  struct bcm_ioctl_buffer io_buff;",
          "2267:  ULONG RxCntrlMsgBitMask = 0;",
          "2271:    sizeof(struct bcm_ioctl_buffer));",
          "2273:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2274:     \"copy of Ioctl buffer is failed from user space\");",
          "2275:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "2266:  INT Status = STATUS_FAILURE;",
          "2270:  Status = copy_from_user(&io_buff, argp,",
          "2272:  if (Status) {",
          "",
          "[Added Lines]",
          "2266:  INT status = STATUS_FAILURE;",
          "2270:  status = copy_from_user(&io_buff, argp,",
          "2272:  if (status) {",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "2278:  if (io_buff.InputLength != sizeof(unsigned long))",
          "2279:   return -EINVAL;",
          "2282:     io_buff.InputLength);",
          "2284:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2285:     \"copy of control bit mask failed from user space\");",
          "2286:   return -EFAULT;",
          "",
          "[Removed Lines]",
          "2281:  Status = copy_from_user(&RxCntrlMsgBitMask, io_buff.InputBuffer,",
          "2283:  if (Status) {",
          "",
          "[Added Lines]",
          "2281:  status = copy_from_user(&RxCntrlMsgBitMask, io_buff.InputBuffer,",
          "2283:  if (status) {",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "2290:    RxCntrlMsgBitMask);",
          "2291:  pTarang->RxCntrlMsgBitMask = RxCntrlMsgBitMask;",
          "2294: }",
          "2296: static int bcm_char_ioctl_get_device_driver_info(void __user *argp,",
          "",
          "[Removed Lines]",
          "2293:  return Status;",
          "",
          "[Added Lines]",
          "2293:  return status;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "2352:  struct bcm_tarang_data *pTarang = filp->private_data;",
          "2353:  void __user *argp = (void __user *)arg;",
          "2354:  struct bcm_mini_adapter *ad = pTarang->Adapter;",
          "2357:  BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2358:    \"Parameters Passed to control IOCTL cmd=0x%X arg=0x%lX\",",
          "",
          "[Removed Lines]",
          "2355:  INT Status = STATUS_FAILURE;",
          "",
          "[Added Lines]",
          "2355:  INT status = STATUS_FAILURE;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "2361:  if (_IOC_TYPE(cmd) != BCM_IOCTL)",
          "2362:   return -EFAULT;",
          "2363:  if (_IOC_DIR(cmd) & _IOC_READ)",
          "2365:  else if (_IOC_DIR(cmd) & _IOC_WRITE)",
          "2367:  else if (_IOC_NONE == (_IOC_DIR(cmd) & _IOC_NONE))",
          "2371:   return -EFAULT;",
          "2373:  if (ad->device_removed)",
          "",
          "[Removed Lines]",
          "2364:   Status = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));",
          "2366:   Status = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));",
          "2368:   Status = STATUS_SUCCESS;",
          "2370:  if (Status)",
          "",
          "[Added Lines]",
          "2364:   status = !access_ok(VERIFY_WRITE, argp, _IOC_SIZE(cmd));",
          "2366:   status = !access_ok(VERIFY_READ, argp, _IOC_SIZE(cmd));",
          "2368:   status = STATUS_SUCCESS;",
          "2370:  if (status)",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "2389:   }",
          "2390:  }",
          "2396:  switch (cmd) {",
          "2398:  case IOCTL_BCM_REGISTER_READ_PRIVATE:",
          "2402:  case IOCTL_BCM_REGISTER_WRITE_PRIVATE:",
          "2406:  case IOCTL_BCM_REGISTER_READ:",
          "2407:  case IOCTL_BCM_EEPROM_REGISTER_READ:",
          "2411:  case IOCTL_BCM_REGISTER_WRITE:",
          "2412:  case IOCTL_BCM_EEPROM_REGISTER_WRITE:",
          "2416:  case IOCTL_BCM_GPIO_SET_REQUEST:",
          "2420:  case BCM_LED_THREAD_STATE_CHANGE_REQ:",
          "2422:             ad);",
          "2425:  case IOCTL_BCM_GPIO_STATUS_REQUEST:",
          "2429:  case IOCTL_BCM_GPIO_MULTI_REQUEST:",
          "2433:  case IOCTL_BCM_GPIO_MODE_REQUEST:",
          "2437:  case IOCTL_MAC_ADDR_REQ:",
          "2438:  case IOCTL_LINK_REQ:",
          "",
          "[Removed Lines]",
          "2392:  Status = vendorextnIoctl(ad, cmd, arg);",
          "2393:  if (Status != CONTINUE_COMMON_PATH)",
          "2394:   return Status;",
          "2399:   Status = bcm_char_ioctl_reg_read_private(argp, ad);",
          "2400:   return Status;",
          "2403:   Status = bcm_char_ioctl_reg_write_private(argp, ad);",
          "2404:   return Status;",
          "2408:   Status = bcm_char_ioctl_eeprom_reg_read(argp, ad);",
          "2409:   return Status;",
          "2413:   Status = bcm_char_ioctl_eeprom_reg_write(argp, ad, cmd);",
          "2414:   return Status;",
          "2417:   Status = bcm_char_ioctl_gpio_set_request(argp, ad);",
          "2418:   return Status;",
          "2421:   Status = bcm_char_ioctl_led_thread_state_change_req(argp,",
          "2423:   return Status;",
          "2426:   Status = bcm_char_ioctl_gpio_status_request(argp, ad);",
          "2427:   return Status;",
          "2430:   Status = bcm_char_ioctl_gpio_multi_request(argp, ad);",
          "2431:   return Status;",
          "2434:   Status = bcm_char_ioctl_gpio_mode_request(argp, ad);",
          "2435:   return Status;",
          "",
          "[Added Lines]",
          "2392:  status = vendorextnIoctl(ad, cmd, arg);",
          "2393:  if (status != CONTINUE_COMMON_PATH)",
          "2394:   return status;",
          "2399:   status = bcm_char_ioctl_reg_read_private(argp, ad);",
          "2400:   return status;",
          "2403:   status = bcm_char_ioctl_reg_write_private(argp, ad);",
          "2404:   return status;",
          "2408:   status = bcm_char_ioctl_eeprom_reg_read(argp, ad);",
          "2409:   return status;",
          "2413:   status = bcm_char_ioctl_eeprom_reg_write(argp, ad, cmd);",
          "2414:   return status;",
          "2417:   status = bcm_char_ioctl_gpio_set_request(argp, ad);",
          "2418:   return status;",
          "2421:   status = bcm_char_ioctl_led_thread_state_change_req(argp,",
          "2423:   return status;",
          "2426:   status = bcm_char_ioctl_gpio_status_request(argp, ad);",
          "2427:   return status;",
          "2430:   status = bcm_char_ioctl_gpio_multi_request(argp, ad);",
          "2431:   return status;",
          "2434:   status = bcm_char_ioctl_gpio_mode_request(argp, ad);",
          "2435:   return status;",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "2440:  case IOCTL_SS_INFO_REQ:",
          "2441:  case IOCTL_SEND_CONTROL_MESSAGE:",
          "2442:  case IOCTL_IDLE_REQ:",
          "2446:  case IOCTL_BCM_BUFFER_DOWNLOAD_START:",
          "2450:  case IOCTL_BCM_BUFFER_DOWNLOAD:",
          "2454:  case IOCTL_BCM_BUFFER_DOWNLOAD_STOP:",
          "2459:  case IOCTL_BE_BUCKET_SIZE:",
          "2461:   if (get_user(ad->BEBucketSize,",
          "2462:         (unsigned long __user *)arg))",
          "2464:   break;",
          "2466:  case IOCTL_RTPS_BUCKET_SIZE:",
          "2468:   if (get_user(ad->rtPSBucketSize,",
          "2469:         (unsigned long __user *)arg))",
          "2471:   break;",
          "2473:  case IOCTL_CHIP_RESET:",
          "2477:  case IOCTL_QOS_THRESHOLD:",
          "2481:  case IOCTL_DUMP_PACKET_INFO:",
          "2482:   DumpPackInfo(ad);",
          "2483:   DumpPhsRules(&ad->stBCMPhsContext);",
          "2485:   break;",
          "2487:  case IOCTL_GET_PACK_INFO:",
          "2488:   if (copy_to_user(argp, &ad->PackInfo,",
          "2489:      sizeof(struct bcm_packet_info)*NO_OF_QUEUES))",
          "2490:    return -EFAULT;",
          "2492:   break;",
          "2494:  case IOCTL_BCM_SWITCH_TRANSFER_MODE:",
          "2498:  case IOCTL_BCM_GET_DRIVER_VERSION:",
          "2502:  case IOCTL_BCM_GET_CURRENT_STATUS:",
          "2506:  case IOCTL_BCM_SET_MAC_TRACING:",
          "2510:  case IOCTL_BCM_GET_DSX_INDICATION:",
          "2514:  case IOCTL_BCM_GET_HOST_MIBS:",
          "2518:  case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE:",
          "2519:   if ((false == ad->bTriedToWakeUpFromlowPowerMode) &&",
          "",
          "[Removed Lines]",
          "2443:   Status = bcm_char_ioctl_misc_request(argp, ad);",
          "2444:   return Status;",
          "2447:   Status = bcm_char_ioctl_buffer_download_start(ad);",
          "2448:   return Status;",
          "2451:   Status = bcm_char_ioctl_buffer_download(argp, ad);",
          "2452:   return Status;",
          "2455:   Status = bcm_char_ioctl_buffer_download_stop(argp, ad);",
          "2456:   return Status;",
          "2460:   Status = 0;",
          "2463:    Status = -EFAULT;",
          "2467:   Status = 0;",
          "2470:    Status = -EFAULT;",
          "2474:   Status = bcm_char_ioctl_chip_reset(ad);",
          "2475:   return Status;",
          "2478:   Status = bcm_char_ioctl_qos_threshold(arg, ad);",
          "2479:   return Status;",
          "2484:   Status = STATUS_SUCCESS;",
          "2491:   Status = STATUS_SUCCESS;",
          "2495:   Status = bcm_char_ioctl_switch_transfer_mode(argp, ad);",
          "2496:   return Status;",
          "2499:   Status = bcm_char_ioctl_get_driver_version(argp);",
          "2500:   return Status;",
          "2503:   Status = bcm_char_ioctl_get_current_status(argp, ad);",
          "2504:   return Status;",
          "2507:   Status = bcm_char_ioctl_set_mac_tracing(argp, ad);",
          "2508:   return Status;",
          "2511:   Status = bcm_char_ioctl_get_dsx_indication(argp, ad);",
          "2512:   return Status;",
          "2515:   Status = bcm_char_ioctl_get_host_mibs(argp, ad, pTarang);",
          "2516:   return Status;",
          "",
          "[Added Lines]",
          "2443:   status = bcm_char_ioctl_misc_request(argp, ad);",
          "2444:   return status;",
          "2447:   status = bcm_char_ioctl_buffer_download_start(ad);",
          "2448:   return status;",
          "2451:   status = bcm_char_ioctl_buffer_download(argp, ad);",
          "2452:   return status;",
          "2455:   status = bcm_char_ioctl_buffer_download_stop(argp, ad);",
          "2456:   return status;",
          "2460:   status = 0;",
          "2463:    status = -EFAULT;",
          "2467:   status = 0;",
          "2470:    status = -EFAULT;",
          "2474:   status = bcm_char_ioctl_chip_reset(ad);",
          "2475:   return status;",
          "2478:   status = bcm_char_ioctl_qos_threshold(arg, ad);",
          "2479:   return status;",
          "2484:   status = STATUS_SUCCESS;",
          "2491:   status = STATUS_SUCCESS;",
          "2495:   status = bcm_char_ioctl_switch_transfer_mode(argp, ad);",
          "2496:   return status;",
          "2499:   status = bcm_char_ioctl_get_driver_version(argp);",
          "2500:   return status;",
          "2503:   status = bcm_char_ioctl_get_current_status(argp, ad);",
          "2504:   return status;",
          "2507:   status = bcm_char_ioctl_set_mac_tracing(argp, ad);",
          "2508:   return status;",
          "2511:   status = bcm_char_ioctl_get_dsx_indication(argp, ad);",
          "2512:   return status;",
          "2515:   status = bcm_char_ioctl_get_host_mibs(argp, ad, pTarang);",
          "2516:   return status;",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "2523:    wake_up(&ad->process_rx_cntrlpkt);",
          "2524:   }",
          "2527:   break;",
          "2529:  case IOCTL_BCM_BULK_WRM:",
          "2533:  case IOCTL_BCM_GET_NVM_SIZE:",
          "2537:  case IOCTL_BCM_CAL_INIT:",
          "2541:  case IOCTL_BCM_SET_DEBUG:",
          "2545:  case IOCTL_BCM_NVM_READ:",
          "2546:  case IOCTL_BCM_NVM_WRITE:",
          "2550:  case IOCTL_BCM_FLASH2X_SECTION_READ:",
          "2554:  case IOCTL_BCM_FLASH2X_SECTION_WRITE:",
          "2558:  case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP:",
          "2562:  case IOCTL_BCM_SET_ACTIVE_SECTION:",
          "2566:  case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION:",
          "2568:   ad->bAllDSDWriteAllow = false;",
          "2569:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "2570:     \"IOCTL_BCM_IDENTIFY_ACTIVE_SECTION called\");",
          "2572:   break;",
          "2574:  case IOCTL_BCM_COPY_SECTION:",
          "2578:  case IOCTL_BCM_GET_FLASH_CS_INFO:",
          "2582:  case IOCTL_BCM_SELECT_DSD:",
          "2586:  case IOCTL_BCM_NVM_RAW_READ:",
          "2590:  case IOCTL_BCM_CNTRLMSG_MASK:",
          "2594:  case IOCTL_BCM_GET_DEVICE_DRIVER_INFO:",
          "2598:  case IOCTL_BCM_TIME_SINCE_NET_ENTRY:",
          "2602:  case IOCTL_CLOSE_NOTIFICATION:",
          "2603:   BCM_DEBUG_PRINT(ad, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,",
          "",
          "[Removed Lines]",
          "2526:   Status = STATUS_SUCCESS;",
          "2530:   Status = bcm_char_ioctl_bulk_wrm(argp, ad, cmd);",
          "2531:   return Status;",
          "2534:   Status = bcm_char_ioctl_get_nvm_size(argp, ad);",
          "2535:   return Status;",
          "2538:   Status = bcm_char_ioctl_cal_init(argp, ad);",
          "2539:   return Status;",
          "2542:   Status = bcm_char_ioctl_set_debug(argp, ad);",
          "2543:   return Status;",
          "2547:   Status = bcm_char_ioctl_nvm_rw(argp, ad, cmd);",
          "2548:   return Status;",
          "2551:   Status = bcm_char_ioctl_flash2x_section_read(argp, ad);",
          "2552:   return Status;",
          "2555:   Status = bcm_char_ioctl_flash2x_section_write(argp, ad);",
          "2556:   return Status;",
          "2559:   Status = bcm_char_ioctl_flash2x_section_bitmap(argp, ad);",
          "2560:   return Status;",
          "2563:   Status = bcm_char_ioctl_set_active_section(argp, ad);",
          "2564:   return Status;",
          "2571:   Status = STATUS_SUCCESS;",
          "2575:   Status = bcm_char_ioctl_copy_section(argp, ad);",
          "2576:   return Status;",
          "2579:   Status = bcm_char_ioctl_get_flash_cs_info(argp, ad);",
          "2580:   return Status;",
          "2583:   Status = bcm_char_ioctl_select_dsd(argp, ad);",
          "2584:   return Status;",
          "2587:   Status = bcm_char_ioctl_nvm_raw_read(argp, ad);",
          "2588:   return Status;",
          "2591:   Status = bcm_char_ioctl_cntrlmsg_mask(argp, ad, pTarang);",
          "2592:   return Status;",
          "2595:   Status = bcm_char_ioctl_get_device_driver_info(argp, ad);",
          "2596:   return Status;",
          "2599:   Status = bcm_char_ioctl_time_since_net_entry(argp, ad);",
          "2600:   return Status;",
          "",
          "[Added Lines]",
          "2526:   status = STATUS_SUCCESS;",
          "2530:   status = bcm_char_ioctl_bulk_wrm(argp, ad, cmd);",
          "2531:   return status;",
          "2534:   status = bcm_char_ioctl_get_nvm_size(argp, ad);",
          "2535:   return status;",
          "2538:   status = bcm_char_ioctl_cal_init(argp, ad);",
          "2539:   return status;",
          "2542:   status = bcm_char_ioctl_set_debug(argp, ad);",
          "2543:   return status;",
          "2547:   status = bcm_char_ioctl_nvm_rw(argp, ad, cmd);",
          "2548:   return status;",
          "2551:   status = bcm_char_ioctl_flash2x_section_read(argp, ad);",
          "2552:   return status;",
          "2555:   status = bcm_char_ioctl_flash2x_section_write(argp, ad);",
          "2556:   return status;",
          "2559:   status = bcm_char_ioctl_flash2x_section_bitmap(argp, ad);",
          "2560:   return status;",
          "2563:   status = bcm_char_ioctl_set_active_section(argp, ad);",
          "2564:   return status;",
          "2571:   status = STATUS_SUCCESS;",
          "2575:   status = bcm_char_ioctl_copy_section(argp, ad);",
          "2576:   return status;",
          "2579:   status = bcm_char_ioctl_get_flash_cs_info(argp, ad);",
          "2580:   return status;",
          "2583:   status = bcm_char_ioctl_select_dsd(argp, ad);",
          "2584:   return status;",
          "2587:   status = bcm_char_ioctl_nvm_raw_read(argp, ad);",
          "2588:   return status;",
          "2591:   status = bcm_char_ioctl_cntrlmsg_mask(argp, ad, pTarang);",
          "2592:   return status;",
          "2595:   status = bcm_char_ioctl_get_device_driver_info(argp, ad);",
          "2596:   return status;",
          "2599:   status = bcm_char_ioctl_time_since_net_entry(argp, ad);",
          "2600:   return status;",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "2607:  default:",
          "2608:   pr_info(DRV_NAME \": unknown ioctl cmd=%#x\\n\", cmd);",
          "2610:   break;",
          "2611:  }",
          "2613: }",
          "",
          "[Removed Lines]",
          "2609:   Status = STATUS_FAILURE;",
          "2612:  return Status;",
          "",
          "[Added Lines]",
          "2609:   status = STATUS_FAILURE;",
          "2612:  return status;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "fe59cefb6971ded0f130bbdd3dfeb1fcc9446c31",
      "candidate_info": {
        "commit_hash": "fe59cefb6971ded0f130bbdd3dfeb1fcc9446c31",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fe59cefb6971ded0f130bbdd3dfeb1fcc9446c31",
        "files": [
          "drivers/staging/bcm/Bcmchar.c"
        ],
        "message": "staging/bcm: move IOCTL_BCM_GET_DEVICE_DRIVER_INFO case out to its own function.\n\nbcm_char_ioctl is one of the longest non-generated functions in the kernel,\nat 1906 lines.  Splitting it up into multiple functions should simplify\nthis a lot.\n\nSigned-off-by: Dave Jones <davej@fedoraproject.org>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
          ],
          "candidate": [
            "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/staging/bcm/Bcmchar.c||drivers/staging/bcm/Bcmchar.c": [
          "File: drivers/staging/bcm/Bcmchar.c -> drivers/staging/bcm/Bcmchar.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2003:  return Status;",
          "2004: }",
          "2007: static long bcm_char_ioctl(struct file *filp, UINT cmd, ULONG arg)",
          "2008: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2006: static int bcm_char_ioctl_get_device_driver_info(void __user *argp, struct bcm_mini_adapter *Adapter)",
          "2007: {",
          "2008:  struct bcm_driver_info DevInfo;",
          "2009:  struct bcm_ioctl_buffer IoBuffer;",
          "2011:  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\");",
          "2013:  memset(&DevInfo, 0, sizeof(DevInfo));",
          "2014:  DevInfo.MaxRDMBufferSize = BUFFER_4K;",
          "2015:  DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;",
          "2016:  DevInfo.u32RxAlignmentCorrection = 0;",
          "2017:  DevInfo.u32NVMType = Adapter->eNVMType;",
          "2018:  DevInfo.u32InterfaceType = BCM_USB;",
          "2020:  if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "2021:   return -EFAULT;",
          "2023:  if (IoBuffer.OutputLength < sizeof(DevInfo))",
          "2024:   return -EINVAL;",
          "2026:  if (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))",
          "2027:   return -EFAULT;",
          "2029:  return STATUS_SUCCESS;",
          "2030: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2243:   Status = bcm_char_ioctl_cntrlmsg_mask(argp, Adapter, pTarang);",
          "2244:   return Status;",
          "2269:  case IOCTL_BCM_TIME_SINCE_NET_ENTRY: {",
          "2270:   struct bcm_time_elapsed stTimeElapsedSinceNetEntry = {0};",
          "",
          "[Removed Lines]",
          "2246:  case IOCTL_BCM_GET_DEVICE_DRIVER_INFO: {",
          "2247:   struct bcm_driver_info DevInfo;",
          "2249:   BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"Called IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n\");",
          "2251:   memset(&DevInfo, 0, sizeof(DevInfo));",
          "2252:   DevInfo.MaxRDMBufferSize = BUFFER_4K;",
          "2253:   DevInfo.u32DSDStartOffset = EEPROM_CALPARAM_START;",
          "2254:   DevInfo.u32RxAlignmentCorrection = 0;",
          "2255:   DevInfo.u32NVMType = Adapter->eNVMType;",
          "2256:   DevInfo.u32InterfaceType = BCM_USB;",
          "2258:   if (copy_from_user(&IoBuffer, argp, sizeof(struct bcm_ioctl_buffer)))",
          "2259:    return -EFAULT;",
          "2261:   if (IoBuffer.OutputLength < sizeof(DevInfo))",
          "2262:    return -EINVAL;",
          "2264:   if (copy_to_user(IoBuffer.OutputBuffer, &DevInfo, sizeof(DevInfo)))",
          "2265:    return -EFAULT;",
          "2266:  }",
          "2267:  break;",
          "",
          "[Added Lines]",
          "2272:  case IOCTL_BCM_GET_DEVICE_DRIVER_INFO:",
          "2273:   Status = bcm_char_ioctl_get_device_driver_info(argp, Adapter);",
          "2274:   return Status;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-13396",
  "cve_desc": "An issue was discovered in FreeRDP before 2.1.1. An out-of-bounds (OOB) read vulnerability has been detected in ntlm_read_ChallengeMessage in winpr/libwinpr/sspi/NTLM/ntlm_message.c.",
  "repo": "FreeRDP/FreeRDP",
  "patch_hash": "48361c411e50826cb602c7aab773a8a20e1da6bc",
  "patch_info": {
    "commit_hash": "48361c411e50826cb602c7aab773a8a20e1da6bc",
    "repo": "FreeRDP/FreeRDP",
    "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/48361c411e50826cb602c7aab773a8a20e1da6bc",
    "files": [
      "winpr/libwinpr/sspi/NTLM/ntlm_message.c"
    ],
    "message": "Fixed GHSL-2020-100: oob read in ntlm_read_ChallengeMessage\n\n* Added length checks for data read from stream\n* Unified function resource cleanup\n\n(cherry picked from commit 8357dedbbf7213b7d0d18f1026145b9a5b92235a)",
    "before_after_code_files": [
      "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c"
    ]
  },
  "patch_diff": {
    "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c": [
      "File: winpr/libwinpr/sspi/NTLM/ntlm_message.c -> winpr/libwinpr/sspi/NTLM/ntlm_message.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "368: SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)",
      "369: {",
      "370:  wStream* s;",
      "374:  NTLM_AV_PAIR* AvTimestamp;",
      "375:  NTLM_CHALLENGE_MESSAGE* message;",
      "376:  ntlm_generate_client_challenge(context);",
      "377:  message = &context->CHALLENGE_MESSAGE;",
      "378:  ZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));",
      "",
      "[Removed Lines]",
      "371:  int length;",
      "372:  PBYTE StartOffset;",
      "373:  PBYTE PayloadOffset;",
      "",
      "[Added Lines]",
      "370:  SECURITY_STATUS status = SEC_E_INVALID_TOKEN;",
      "372:  size_t length;",
      "373:  size_t StartOffset;",
      "374:  size_t PayloadOffset;",
      "377:  if (!context || !buffer)",
      "378:   return SEC_E_INTERNAL_ERROR;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "381:  if (!s)",
      "382:   return SEC_E_INTERNAL_ERROR;",
      "386:  if (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)",
      "392:  if (message->MessageType != MESSAGE_TYPE_CHALLENGE)",
      "404:  if (Stream_GetRemainingLength(s) < 4)",
      "411:  context->NegotiateFlags = message->NegotiateFlags;",
      "413:  if (Stream_GetRemainingLength(s) < 8)",
      "420:  CopyMemory(context->ServerChallenge, message->ServerChallenge, 8);",
      "422:  if (Stream_GetRemainingLength(s) < 8)",
      "436:  if (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)",
      "437:  {",
      "443:  }",
      "448:  if (message->TargetName.Len > 0)",
      "449:  {",
      "450:   if (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)",
      "455:  }",
      "457:  if (message->TargetInfo.Len > 0)",
      "",
      "[Removed Lines]",
      "384:  StartOffset = Stream_Pointer(s);",
      "387:  {",
      "388:   Stream_Free(s, FALSE);",
      "389:   return SEC_E_INVALID_TOKEN;",
      "390:  }",
      "393:  {",
      "394:   Stream_Free(s, FALSE);",
      "395:   return SEC_E_INVALID_TOKEN;",
      "396:  }",
      "399:  {",
      "400:   Stream_Free(s, FALSE);",
      "401:   return SEC_E_INVALID_TOKEN;",
      "402:  }",
      "405:  {",
      "406:   Stream_Free(s, FALSE);",
      "407:   return SEC_E_INVALID_TOKEN;",
      "408:  }",
      "414:  {",
      "415:   Stream_Free(s, FALSE);",
      "416:   return SEC_E_INVALID_TOKEN;",
      "417:  }",
      "423:  {",
      "424:   Stream_Free(s, FALSE);",
      "425:   return SEC_E_INVALID_TOKEN;",
      "426:  }",
      "431:  {",
      "432:   Stream_Free(s, FALSE);",
      "433:   return SEC_E_INVALID_TOKEN;",
      "434:  }",
      "439:   {",
      "440:    Stream_Free(s, FALSE);",
      "441:    return SEC_E_INVALID_TOKEN;",
      "442:   }",
      "446:  PayloadOffset = Stream_Pointer(s);",
      "451:   {",
      "452:    Stream_Free(s, FALSE);",
      "453:    return SEC_E_INTERNAL_ERROR;",
      "454:   }",
      "",
      "[Added Lines]",
      "388:  StartOffset = Stream_GetPosition(s);",
      "391:   goto fail;",
      "394:   goto fail;",
      "397:   goto fail;",
      "400:   goto fail;",
      "406:   goto fail;",
      "412:   goto fail;",
      "417:   goto fail;",
      "422:    goto fail;",
      "426:  PayloadOffset = Stream_GetPosition(s);",
      "428:  status = SEC_E_INTERNAL_ERROR;",
      "432:    goto fail;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "459:   size_t cbAvTimestamp;",
      "461:   if (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)",
      "467:   context->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;",
      "468:   context->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;",
      "",
      "[Removed Lines]",
      "462:   {",
      "463:    Stream_Free(s, FALSE);",
      "464:    return SEC_E_INTERNAL_ERROR;",
      "465:   }",
      "",
      "[Added Lines]",
      "440:    goto fail;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "474:    PBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp);",
      "476:    if (!ptr)",
      "479:    if (context->NTLMv2)",
      "480:     context->UseMIC = TRUE;",
      "",
      "[Removed Lines]",
      "477:     return SEC_E_INTERNAL_ERROR;",
      "",
      "[Added Lines]",
      "452:     goto fail;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "484:  }",
      "486:  length = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;",
      "488:  if (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))",
      "495: #ifdef WITH_DEBUG_NTLM",
      "496:  WLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);",
      "497:  winpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,",
      "",
      "[Removed Lines]",
      "489:  {",
      "490:   Stream_Free(s, FALSE);",
      "491:   return SEC_E_INTERNAL_ERROR;",
      "492:  }",
      "494:  CopyMemory(context->ChallengeMessage.pvBuffer, StartOffset, length);",
      "",
      "[Added Lines]",
      "462:  if (length > buffer->cbBuffer)",
      "463:   goto fail;",
      "466:   goto fail;",
      "468:  if (context->ChallengeMessage.pvBuffer)",
      "469:   CopyMemory(context->ChallengeMessage.pvBuffer, Stream_Buffer(s) + StartOffset, length);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "517:  if (context->NTLMv2)",
      "518:  {",
      "519:   if (ntlm_construct_authenticate_target_info(context) < 0)",
      "525:   sspi_SecBufferFree(&context->ChallengeTargetInfo);",
      "526:   context->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;",
      "",
      "[Removed Lines]",
      "520:   {",
      "521:    Stream_Free(s, FALSE);",
      "522:    return SEC_E_INTERNAL_ERROR;",
      "523:   }",
      "",
      "[Added Lines]",
      "495:    goto fail;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "533:  {",
      "534:   Stream_Free(s, FALSE);",
      "535:   return SEC_E_INTERNAL_ERROR;",
      "536:  }",
      "539:  {",
      "540:   Stream_Free(s, FALSE);",
      "541:   return SEC_E_INTERNAL_ERROR;",
      "542:  }",
      "",
      "[Added Lines]",
      "505:   goto fail;",
      "508:   goto fail;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "579: #endif",
      "580:  context->state = NTLM_STATE_AUTHENTICATE;",
      "581:  ntlm_free_message_fields_buffer(&(message->TargetName));",
      "582:  Stream_Free(s, FALSE);",
      "584: }",
      "586: SECURITY_STATUS ntlm_write_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)",
      "",
      "[Removed Lines]",
      "583:  return SEC_I_CONTINUE_NEEDED;",
      "",
      "[Added Lines]",
      "548:  status = SEC_I_CONTINUE_NEEDED;",
      "549: fail:",
      "551:  return status;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "96621d4f459dd2b3f8b5dbe812c7aa2f1a5859f3",
      "candidate_info": {
        "commit_hash": "96621d4f459dd2b3f8b5dbe812c7aa2f1a5859f3",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/96621d4f459dd2b3f8b5dbe812c7aa2f1a5859f3",
        "files": [
          "CMakeLists.txt",
          "config.h.in",
          "libfreerdp/codec/interleaved.c"
        ],
        "message": "Always require aligned memory for interleaved codec.\n\n(cherry picked from commit 20c11fb7178462a8ba36b4fdbfb3e2a03197356f)",
        "before_after_code_files": [
          "config.h.in||config.h.in",
          "libfreerdp/codec/interleaved.c||libfreerdp/codec/interleaved.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6212"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "config.h.in||config.h.in": [
          "File: config.h.in -> config.h.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #cmakedefine HAVE_EXECINFO_H",
          "30: #cmakedefine SWRESAMPLE_FOUND",
          "31: #cmakedefine AVRESAMPLE_FOUND",
          "",
          "[Removed Lines]",
          "29: #cmakedefine HAVE_ALIGNED_REQUIRED",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "libfreerdp/codec/interleaved.c||libfreerdp/codec/interleaved.c": [
          "File: libfreerdp/codec/interleaved.c -> libfreerdp/codec/interleaved.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "272: #define WHITE_PIXEL 0xFFFF",
          "273: #define DESTWRITEPIXEL(_buf, _pix) write_pixel_16(_buf, _pix)",
          "274: #define DESTREADPIXEL(_pix, _buf) _pix = ((UINT16*)(_buf))[0]",
          "276: #define SRCREADPIXEL(_pix, _buf) _pix = (_buf)[0] | ((_buf)[1] << 8)",
          "280: #define DESTNEXTPIXEL(_buf) _buf += 2",
          "281: #define SRCNEXTPIXEL(_buf) _buf += 2",
          "282: #define WRITEFGBGIMAGE WriteFgBgImage16to16",
          "",
          "[Removed Lines]",
          "275: #ifdef HAVE_ALIGNED_REQUIRED",
          "277: #else",
          "278: #define SRCREADPIXEL(_pix, _buf) _pix = ((UINT16*)(_buf))[0]",
          "279: #endif",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "11c6ed0fb7446914c961f195b7dcf6256bf91098",
      "candidate_info": {
        "commit_hash": "11c6ed0fb7446914c961f195b7dcf6256bf91098",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/11c6ed0fb7446914c961f195b7dcf6256bf91098",
        "files": [
          "libfreerdp/codec/ncrush.c"
        ],
        "message": "Fixed undefined behaviour in ncrush\n\n(cherry picked from commit 83137d2a1bb732fbea2f20778924a50a79f63fef)",
        "before_after_code_files": [
          "libfreerdp/codec/ncrush.c||libfreerdp/codec/ncrush.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/FreeRDP/FreeRDP/pull/6212"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "libfreerdp/codec/ncrush.c||libfreerdp/codec/ncrush.c": [
          "File: libfreerdp/codec/ncrush.c -> libfreerdp/codec/ncrush.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1926: static INLINE UINT32 get_dword(const BYTE* data)",
          "1927: {",
          "1928:  UINT32 tmp = *data++;",
          "1932:  return tmp;",
          "1933: }",
          "",
          "[Removed Lines]",
          "1929:  tmp |= *data++ << 8U;",
          "1930:  tmp |= *data++ << 16U;",
          "1931:  tmp |= *data++ << 24U;",
          "",
          "[Added Lines]",
          "1929:  tmp |= (UINT32)*data++ << 8U;",
          "1930:  tmp |= (UINT32)*data++ << 16U;",
          "1931:  tmp |= (UINT32)*data++ << 24U;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b37d8c9be1f03072d77923e3b48df24a63b21a79",
      "candidate_info": {
        "commit_hash": "b37d8c9be1f03072d77923e3b48df24a63b21a79",
        "repo": "FreeRDP/FreeRDP",
        "commit_url": "https://github.com/FreeRDP/FreeRDP/commit/b37d8c9be1f03072d77923e3b48df24a63b21a79",
        "files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_message.c"
        ],
        "message": "Fixed GHSL-2020-100: oob read in ntlm_read_ChallengeMessage\n\n* Added length checks for data read from stream\n* Unified function resource cleanup",
        "before_after_code_files": [
          "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c"
          ],
          "candidate": [
            "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c"
          ]
        }
      },
      "candidate_diff": {
        "winpr/libwinpr/sspi/NTLM/ntlm_message.c||winpr/libwinpr/sspi/NTLM/ntlm_message.c": [
          "File: winpr/libwinpr/sspi/NTLM/ntlm_message.c -> winpr/libwinpr/sspi/NTLM/ntlm_message.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "368: SECURITY_STATUS ntlm_read_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)",
          "369: {",
          "370:  wStream* s;",
          "374:  NTLM_AV_PAIR* AvTimestamp;",
          "375:  NTLM_CHALLENGE_MESSAGE* message;",
          "376:  ntlm_generate_client_challenge(context);",
          "377:  message = &context->CHALLENGE_MESSAGE;",
          "378:  ZeroMemory(message, sizeof(NTLM_CHALLENGE_MESSAGE));",
          "",
          "[Removed Lines]",
          "371:  int length;",
          "372:  PBYTE StartOffset;",
          "373:  PBYTE PayloadOffset;",
          "",
          "[Added Lines]",
          "370:  SECURITY_STATUS status = SEC_E_INVALID_TOKEN;",
          "372:  size_t length;",
          "373:  size_t StartOffset;",
          "374:  size_t PayloadOffset;",
          "377:  if (!context || !buffer)",
          "378:   return SEC_E_INTERNAL_ERROR;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "381:  if (!s)",
          "382:   return SEC_E_INTERNAL_ERROR;",
          "386:  if (ntlm_read_message_header(s, (NTLM_MESSAGE_HEADER*)message) < 0)",
          "392:  if (message->MessageType != MESSAGE_TYPE_CHALLENGE)",
          "404:  if (Stream_GetRemainingLength(s) < 4)",
          "411:  context->NegotiateFlags = message->NegotiateFlags;",
          "413:  if (Stream_GetRemainingLength(s) < 8)",
          "420:  CopyMemory(context->ServerChallenge, message->ServerChallenge, 8);",
          "422:  if (Stream_GetRemainingLength(s) < 8)",
          "436:  if (context->NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION)",
          "437:  {",
          "443:  }",
          "448:  if (message->TargetName.Len > 0)",
          "449:  {",
          "450:   if (ntlm_read_message_fields_buffer(s, &(message->TargetName)) < 0)",
          "455:  }",
          "457:  if (message->TargetInfo.Len > 0)",
          "",
          "[Removed Lines]",
          "384:  StartOffset = Stream_Pointer(s);",
          "387:  {",
          "388:   Stream_Free(s, FALSE);",
          "389:   return SEC_E_INVALID_TOKEN;",
          "390:  }",
          "393:  {",
          "394:   Stream_Free(s, FALSE);",
          "395:   return SEC_E_INVALID_TOKEN;",
          "396:  }",
          "399:  {",
          "400:   Stream_Free(s, FALSE);",
          "401:   return SEC_E_INVALID_TOKEN;",
          "402:  }",
          "405:  {",
          "406:   Stream_Free(s, FALSE);",
          "407:   return SEC_E_INVALID_TOKEN;",
          "408:  }",
          "414:  {",
          "415:   Stream_Free(s, FALSE);",
          "416:   return SEC_E_INVALID_TOKEN;",
          "417:  }",
          "423:  {",
          "424:   Stream_Free(s, FALSE);",
          "425:   return SEC_E_INVALID_TOKEN;",
          "426:  }",
          "431:  {",
          "432:   Stream_Free(s, FALSE);",
          "433:   return SEC_E_INVALID_TOKEN;",
          "434:  }",
          "439:   {",
          "440:    Stream_Free(s, FALSE);",
          "441:    return SEC_E_INVALID_TOKEN;",
          "442:   }",
          "446:  PayloadOffset = Stream_Pointer(s);",
          "451:   {",
          "452:    Stream_Free(s, FALSE);",
          "453:    return SEC_E_INTERNAL_ERROR;",
          "454:   }",
          "",
          "[Added Lines]",
          "388:  StartOffset = Stream_GetPosition(s);",
          "391:   goto fail;",
          "394:   goto fail;",
          "397:   goto fail;",
          "400:   goto fail;",
          "406:   goto fail;",
          "412:   goto fail;",
          "417:   goto fail;",
          "422:    goto fail;",
          "426:  PayloadOffset = Stream_GetPosition(s);",
          "428:  status = SEC_E_INTERNAL_ERROR;",
          "432:    goto fail;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "459:   size_t cbAvTimestamp;",
          "461:   if (ntlm_read_message_fields_buffer(s, &(message->TargetInfo)) < 0)",
          "467:   context->ChallengeTargetInfo.pvBuffer = message->TargetInfo.Buffer;",
          "468:   context->ChallengeTargetInfo.cbBuffer = message->TargetInfo.Len;",
          "",
          "[Removed Lines]",
          "462:   {",
          "463:    Stream_Free(s, FALSE);",
          "464:    return SEC_E_INTERNAL_ERROR;",
          "465:   }",
          "",
          "[Added Lines]",
          "440:    goto fail;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "474:    PBYTE ptr = ntlm_av_pair_get_value_pointer(AvTimestamp);",
          "476:    if (!ptr)",
          "479:    if (context->NTLMv2)",
          "480:     context->UseMIC = TRUE;",
          "",
          "[Removed Lines]",
          "477:     return SEC_E_INTERNAL_ERROR;",
          "",
          "[Added Lines]",
          "452:     goto fail;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "484:  }",
          "486:  length = (PayloadOffset - StartOffset) + message->TargetName.Len + message->TargetInfo.Len;",
          "488:  if (!sspi_SecBufferAlloc(&context->ChallengeMessage, length))",
          "495: #ifdef WITH_DEBUG_NTLM",
          "496:  WLog_DBG(TAG, \"CHALLENGE_MESSAGE (length = %d)\", length);",
          "497:  winpr_HexDump(TAG, WLOG_DEBUG, context->ChallengeMessage.pvBuffer,",
          "",
          "[Removed Lines]",
          "489:  {",
          "490:   Stream_Free(s, FALSE);",
          "491:   return SEC_E_INTERNAL_ERROR;",
          "492:  }",
          "494:  CopyMemory(context->ChallengeMessage.pvBuffer, StartOffset, length);",
          "",
          "[Added Lines]",
          "462:  if (length > buffer->cbBuffer)",
          "463:   goto fail;",
          "466:   goto fail;",
          "468:  if (context->ChallengeMessage.pvBuffer)",
          "469:   CopyMemory(context->ChallengeMessage.pvBuffer, Stream_Buffer(s) + StartOffset, length);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "517:  if (context->NTLMv2)",
          "518:  {",
          "519:   if (ntlm_construct_authenticate_target_info(context) < 0)",
          "525:   sspi_SecBufferFree(&context->ChallengeTargetInfo);",
          "526:   context->ChallengeTargetInfo.pvBuffer = context->AuthenticateTargetInfo.pvBuffer;",
          "",
          "[Removed Lines]",
          "520:   {",
          "521:    Stream_Free(s, FALSE);",
          "522:    return SEC_E_INTERNAL_ERROR;",
          "523:   }",
          "",
          "[Added Lines]",
          "495:    goto fail;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "533:  {",
          "534:   Stream_Free(s, FALSE);",
          "535:   return SEC_E_INTERNAL_ERROR;",
          "536:  }",
          "539:  {",
          "540:   Stream_Free(s, FALSE);",
          "541:   return SEC_E_INTERNAL_ERROR;",
          "542:  }",
          "",
          "[Added Lines]",
          "505:   goto fail;",
          "508:   goto fail;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "579: #endif",
          "580:  context->state = NTLM_STATE_AUTHENTICATE;",
          "581:  ntlm_free_message_fields_buffer(&(message->TargetName));",
          "582:  Stream_Free(s, FALSE);",
          "584: }",
          "586: SECURITY_STATUS ntlm_write_ChallengeMessage(NTLM_CONTEXT* context, PSecBuffer buffer)",
          "",
          "[Removed Lines]",
          "583:  return SEC_I_CONTINUE_NEEDED;",
          "",
          "[Added Lines]",
          "548:  status = SEC_I_CONTINUE_NEEDED;",
          "549: fail:",
          "551:  return status;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
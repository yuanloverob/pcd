{
  "cve_id": "CVE-2013-7267",
  "cve_desc": "The atalk_recvmsg function in net/appletalk/ddp.c in the Linux kernel before 3.12.4 updates a certain length value without ensuring that an associated data structure has been initialized, which allows local users to obtain sensitive information from kernel memory via a (1) recvfrom, (2) recvmmsg, or (3) recvmsg system call.",
  "repo": "torvalds/linux",
  "patch_hash": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
  "patch_info": {
    "commit_hash": "f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/f3d3342602f8bcbf37d7c46641cb9bca7618eb1c",
    "files": [
      "crypto/algif_hash.c",
      "crypto/algif_skcipher.c",
      "drivers/isdn/mISDN/socket.c",
      "drivers/net/ppp/pppoe.c",
      "include/linux/net.h",
      "net/appletalk/ddp.c",
      "net/atm/common.c",
      "net/ax25/af_ax25.c",
      "net/bluetooth/af_bluetooth.c",
      "net/bluetooth/hci_sock.c",
      "net/bluetooth/rfcomm/sock.c",
      "net/bluetooth/sco.c",
      "net/caif/caif_socket.c",
      "net/compat.c",
      "net/core/iovec.c",
      "net/ipx/af_ipx.c",
      "net/irda/af_irda.c",
      "net/iucv/af_iucv.c",
      "net/key/af_key.c",
      "net/l2tp/l2tp_ppp.c",
      "net/llc/af_llc.c",
      "net/netlink/af_netlink.c",
      "net/netrom/af_netrom.c",
      "net/nfc/llcp_sock.c",
      "net/nfc/rawsock.c",
      "net/packet/af_packet.c",
      "net/rds/recv.c",
      "net/rose/af_rose.c",
      "net/rxrpc/ar-recvmsg.c",
      "net/socket.c",
      "net/tipc/socket.c",
      "net/unix/af_unix.c",
      "net/vmw_vsock/af_vsock.c",
      "net/vmw_vsock/vmci_transport.c",
      "net/x25/af_x25.c"
    ],
    "message": "net: rework recvmsg handler msg_name and msg_namelen logic\n\nThis patch now always passes msg->msg_namelen as 0. recvmsg handlers must\nset msg_namelen to the proper size <= sizeof(struct sockaddr_storage)\nto return msg_name to the user.\n\nThis prevents numerous uninitialized memory leaks we had in the\nrecvmsg handlers and makes it harder for new code to accidentally leak\nuninitialized memory.\n\nOptimize for the case recvfrom is called with NULL as address. We don't\nneed to copy the address at all, so set it to NULL before invoking the\nrecvmsg handler. We can do so, because all the recvmsg handlers must\ncope with the case a plain read() is called on them. read() also sets\nmsg_name to NULL.\n\nAlso document these changes in include/linux/net.h as suggested by David\nMiller.\n\nChanges since RFC:\n\nSet msg->msg_name = NULL if user specified a NULL in msg_name but had a\nnon-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't\naffect sendto as it would bail out earlier while trying to copy-in the\naddress. It also more naturally reflects the logic by the callers of\nverify_iovec.\n\nWith this change in place I could remove \"\nif (!uaddr || msg_sys->msg_namelen == 0)\n\tmsg->msg_name = NULL\n\".\n\nThis change does not alter the user visible error logic as we ignore\nmsg_namelen as long as msg_name is NULL.\n\nAlso remove two unnecessary curly brackets in ___sys_recvmsg and change\ncomments to netdev style.\n\nCc: David Miller <davem@davemloft.net>\nSuggested-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "crypto/algif_hash.c||crypto/algif_hash.c",
      "crypto/algif_skcipher.c||crypto/algif_skcipher.c",
      "drivers/isdn/mISDN/socket.c||drivers/isdn/mISDN/socket.c",
      "drivers/net/ppp/pppoe.c||drivers/net/ppp/pppoe.c",
      "include/linux/net.h||include/linux/net.h",
      "net/appletalk/ddp.c||net/appletalk/ddp.c",
      "net/atm/common.c||net/atm/common.c",
      "net/ax25/af_ax25.c||net/ax25/af_ax25.c",
      "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c",
      "net/bluetooth/hci_sock.c||net/bluetooth/hci_sock.c",
      "net/bluetooth/rfcomm/sock.c||net/bluetooth/rfcomm/sock.c",
      "net/bluetooth/sco.c||net/bluetooth/sco.c",
      "net/caif/caif_socket.c||net/caif/caif_socket.c",
      "net/compat.c||net/compat.c",
      "net/core/iovec.c||net/core/iovec.c",
      "net/ipx/af_ipx.c||net/ipx/af_ipx.c",
      "net/irda/af_irda.c||net/irda/af_irda.c",
      "net/iucv/af_iucv.c||net/iucv/af_iucv.c",
      "net/key/af_key.c||net/key/af_key.c",
      "net/l2tp/l2tp_ppp.c||net/l2tp/l2tp_ppp.c",
      "net/llc/af_llc.c||net/llc/af_llc.c",
      "net/netlink/af_netlink.c||net/netlink/af_netlink.c",
      "net/netrom/af_netrom.c||net/netrom/af_netrom.c",
      "net/nfc/llcp_sock.c||net/nfc/llcp_sock.c",
      "net/nfc/rawsock.c||net/nfc/rawsock.c",
      "net/packet/af_packet.c||net/packet/af_packet.c",
      "net/rds/recv.c||net/rds/recv.c",
      "net/rose/af_rose.c||net/rose/af_rose.c",
      "net/rxrpc/ar-recvmsg.c||net/rxrpc/ar-recvmsg.c",
      "net/socket.c||net/socket.c",
      "net/tipc/socket.c||net/tipc/socket.c",
      "net/unix/af_unix.c||net/unix/af_unix.c",
      "net/vmw_vsock/af_vsock.c||net/vmw_vsock/af_vsock.c",
      "net/vmw_vsock/vmci_transport.c||net/vmw_vsock/vmci_transport.c",
      "net/x25/af_x25.c||net/x25/af_x25.c"
    ]
  },
  "patch_diff": {
    "crypto/algif_hash.c||crypto/algif_hash.c": [
      "File: crypto/algif_hash.c -> crypto/algif_hash.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "161:  else if (len < ds)",
      "162:   msg->msg_flags |= MSG_TRUNC;",
      "166:  lock_sock(sk);",
      "167:  if (ctx->more) {",
      "168:   ctx->more = 0;",
      "",
      "[Removed Lines]",
      "164:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "crypto/algif_skcipher.c||crypto/algif_skcipher.c": [
      "File: crypto/algif_skcipher.c -> crypto/algif_skcipher.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "432:  long copied = 0;",
      "434:  lock_sock(sk);",
      "436:  for (iov = msg->msg_iov, iovlen = msg->msg_iovlen; iovlen > 0;",
      "437:       iovlen--, iov++) {",
      "438:   unsigned long seglen = iov->iov_len;",
      "",
      "[Removed Lines]",
      "435:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "drivers/isdn/mISDN/socket.c||drivers/isdn/mISDN/socket.c": [
      "File: drivers/isdn/mISDN/socket.c -> drivers/isdn/mISDN/socket.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "117: {",
      "118:  struct sk_buff  *skb;",
      "119:  struct sock  *sk = sock->sk;",
      "122:  int  copied, err;",
      "",
      "[Removed Lines]",
      "120:  struct sockaddr_mISDN *maddr;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "135:  if (!skb)",
      "136:   return err;",
      "141:   maddr->family = AF_ISDN;",
      "142:   maddr->dev = _pms(sk)->dev->id;",
      "143:   if ((sk->sk_protocol == ISDN_P_LAPD_TE) ||",
      "",
      "[Removed Lines]",
      "138:  if (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {",
      "139:   msg->msg_namelen = sizeof(struct sockaddr_mISDN);",
      "140:   maddr = (struct sockaddr_mISDN *)msg->msg_name;",
      "",
      "[Added Lines]",
      "137:  if (msg->msg_name) {",
      "138:   struct sockaddr_mISDN *maddr = msg->msg_name;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "150:    maddr->sapi = _pms(sk)->ch.addr & 0xFF;",
      "151:    maddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;",
      "152:   }",
      "158:  }",
      "160:  copied = skb->len + MISDN_HEADER_LEN;",
      "",
      "[Removed Lines]",
      "153:  } else {",
      "154:   if (msg->msg_namelen)",
      "155:    printk(KERN_WARNING \"%s: too small namelen %d\\n\",",
      "156:           __func__, msg->msg_namelen);",
      "157:   msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "152:   msg->msg_namelen = sizeof(*maddr);",
      "",
      "---------------"
    ],
    "drivers/net/ppp/pppoe.c||drivers/net/ppp/pppoe.c": [
      "File: drivers/net/ppp/pppoe.c -> drivers/net/ppp/pppoe.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "979:  if (error < 0)",
      "980:   goto end;",
      "984:  if (skb) {",
      "985:   total_len = min_t(size_t, total_len, skb->len);",
      "986:   error = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);",
      "",
      "[Removed Lines]",
      "982:  m->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "include/linux/net.h||include/linux/net.h": [
      "File: include/linux/net.h -> include/linux/net.h"
    ],
    "net/appletalk/ddp.c||net/appletalk/ddp.c": [
      "File: net/appletalk/ddp.c -> net/appletalk/ddp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1735:     size_t size, int flags)",
      "1736: {",
      "1737:  struct sock *sk = sock->sk;",
      "1739:  struct ddpehdr *ddp;",
      "1740:  int copied = 0;",
      "1741:  int offset = 0;",
      "",
      "[Removed Lines]",
      "1738:  struct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1764:  }",
      "1765:  err = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);",
      "1775:  }",
      "",
      "[Removed Lines]",
      "1767:  if (!err) {",
      "1768:   if (sat) {",
      "1769:    sat->sat_family      = AF_APPLETALK;",
      "1770:    sat->sat_port        = ddp->deh_sport;",
      "1771:    sat->sat_addr.s_node = ddp->deh_snode;",
      "1772:    sat->sat_addr.s_net  = ddp->deh_snet;",
      "1773:   }",
      "1774:   msg->msg_namelen = sizeof(*sat);",
      "",
      "[Added Lines]",
      "1766:  if (!err && msg->msg_name) {",
      "1767:   struct sockaddr_at *sat = msg->msg_name;",
      "1768:   sat->sat_family      = AF_APPLETALK;",
      "1769:   sat->sat_port        = ddp->deh_sport;",
      "1770:   sat->sat_addr.s_node = ddp->deh_snode;",
      "1771:   sat->sat_addr.s_net  = ddp->deh_snet;",
      "1772:   msg->msg_namelen     = sizeof(*sat);",
      "",
      "---------------"
    ],
    "net/atm/common.c||net/atm/common.c": [
      "File: net/atm/common.c -> net/atm/common.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "531:  struct sk_buff *skb;",
      "532:  int copied, error = -EINVAL;",
      "536:  if (sock->state != SS_CONNECTED)",
      "537:   return -ENOTCONN;",
      "",
      "[Removed Lines]",
      "534:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/ax25/af_ax25.c||net/ax25/af_ax25.c": [
      "File: net/ax25/af_ax25.c -> net/ax25/af_ax25.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1637:  skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);",
      "1641:   ax25_digi digi;",
      "1642:   ax25_address src;",
      "1643:   const unsigned char *mac = skb_mac_header(skb);",
      "1645:   memset(sax, 0, sizeof(struct full_sockaddr_ax25));",
      "1646:   ax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,",
      "",
      "[Removed Lines]",
      "1639:  if (msg->msg_namelen != 0) {",
      "1640:   struct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;",
      "",
      "[Added Lines]",
      "1639:  if (msg->msg_name) {",
      "1643:   struct sockaddr_ax25 *sax = msg->msg_name;",
      "",
      "---------------"
    ],
    "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c": [
      "File: net/bluetooth/af_bluetooth.c -> net/bluetooth/af_bluetooth.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "225:  skb = skb_recv_datagram(sk, flags, noblock, &err);",
      "226:  if (!skb) {",
      "229:    return 0;",
      "231:   return err;",
      "232:  }",
      "",
      "[Removed Lines]",
      "227:   if (sk->sk_shutdown & RCV_SHUTDOWN) {",
      "228:    msg->msg_namelen = 0;",
      "230:   }",
      "",
      "[Added Lines]",
      "227:   if (sk->sk_shutdown & RCV_SHUTDOWN)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "245:   if (bt_sk(sk)->skb_msg_name)",
      "246:    bt_sk(sk)->skb_msg_name(skb, msg->msg_name,",
      "247:       &msg->msg_namelen);",
      "250:  }",
      "252:  skb_free_datagram(sk, skb);",
      "",
      "[Removed Lines]",
      "248:   else",
      "249:    msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "295:  if (flags & MSG_OOB)",
      "296:   return -EOPNOTSUPP;",
      "300:  BT_DBG(\"sk %p size %zu\", sk, size);",
      "302:  lock_sock(sk);",
      "",
      "[Removed Lines]",
      "298:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/bluetooth/hci_sock.c||net/bluetooth/hci_sock.c": [
      "File: net/bluetooth/hci_sock.c -> net/bluetooth/hci_sock.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "856:  if (!skb)",
      "857:   return err;",
      "861:  copied = skb->len;",
      "862:  if (len < copied) {",
      "863:   msg->msg_flags |= MSG_TRUNC;",
      "",
      "[Removed Lines]",
      "859:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/bluetooth/rfcomm/sock.c||net/bluetooth/rfcomm/sock.c": [
      "File: net/bluetooth/rfcomm/sock.c -> net/bluetooth/rfcomm/sock.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "616:  if (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {",
      "617:   rfcomm_dlc_accept(d);",
      "619:   return 0;",
      "620:  }",
      "",
      "[Removed Lines]",
      "618:   msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/bluetooth/sco.c||net/bluetooth/sco.c": [
      "File: net/bluetooth/sco.c -> net/bluetooth/sco.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "711:      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {",
      "712:   sco_conn_defer_accept(pi->conn->hcon, pi->setting);",
      "713:   sk->sk_state = BT_CONFIG;",
      "716:   release_sock(sk);",
      "717:   return 0;",
      "",
      "[Removed Lines]",
      "714:   msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/caif/caif_socket.c||net/caif/caif_socket.c": [
      "File: net/caif/caif_socket.c -> net/caif/caif_socket.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "286:  if (m->msg_flags&MSG_OOB)",
      "287:   goto read_error;",
      "291:  skb = skb_recv_datagram(sk, flags, 0 , &ret);",
      "292:  if (!skb)",
      "293:   goto read_error;",
      "",
      "[Removed Lines]",
      "289:  m->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "361:  if (flags&MSG_OOB)",
      "362:   goto out;",
      "",
      "[Removed Lines]",
      "364:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/compat.c||net/compat.c": [
      "File: net/compat.c -> net/compat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "93:    if (err < 0)",
      "94:     return err;",
      "95:   }",
      "97:  } else",
      "98:   kern_msg->msg_name = NULL;",
      "",
      "[Removed Lines]",
      "96:   kern_msg->msg_name = kern_address;",
      "",
      "[Added Lines]",
      "96:   if (kern_msg->msg_name)",
      "97:    kern_msg->msg_name = kern_address;",
      "",
      "---------------"
    ],
    "net/core/iovec.c||net/core/iovec.c": [
      "File: net/core/iovec.c -> net/core/iovec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "48:    if (err < 0)",
      "49:     return err;",
      "50:   }",
      "52:  } else {",
      "53:   m->msg_name = NULL;",
      "54:  }",
      "",
      "[Removed Lines]",
      "51:   m->msg_name = address;",
      "",
      "[Added Lines]",
      "51:   if (m->msg_name)",
      "52:    m->msg_name = address;",
      "",
      "---------------"
    ],
    "net/ipx/af_ipx.c||net/ipx/af_ipx.c": [
      "File: net/ipx/af_ipx.c -> net/ipx/af_ipx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1823:  if (skb->tstamp.tv64)",
      "1824:   sk->sk_stamp = skb->tstamp;",
      "1828:  if (sipx) {",
      "1829:   sipx->sipx_family = AF_IPX;",
      "1830:   sipx->sipx_port  = ipx->ipx_source.sock;",
      "",
      "[Removed Lines]",
      "1826:  msg->msg_namelen = sizeof(*sipx);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1832:   sipx->sipx_network = IPX_SKB_CB(skb)->ipx_source_net;",
      "1833:   sipx->sipx_type  = ipx->ipx_type;",
      "1834:   sipx->sipx_zero  = 0;",
      "1835:  }",
      "1836:  rc = copied;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1833:   msg->msg_namelen = sizeof(*sipx);",
      "",
      "---------------"
    ],
    "net/irda/af_irda.c||net/irda/af_irda.c": [
      "File: net/irda/af_irda.c -> net/irda/af_irda.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1386:  IRDA_DEBUG(4, \"%s()\\n\", __func__);",
      "1390:  skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,",
      "1391:     flags & MSG_DONTWAIT, &err);",
      "1392:  if (!skb)",
      "",
      "[Removed Lines]",
      "1388:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1451:  target = sock_rcvlowat(sk, flags & MSG_WAITALL, size);",
      "1452:  timeo = sock_rcvtimeo(sk, noblock);",
      "1456:  do {",
      "1457:   int chunk;",
      "1458:   struct sk_buff *skb = skb_dequeue(&sk->sk_receive_queue);",
      "",
      "[Removed Lines]",
      "1454:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/iucv/af_iucv.c||net/iucv/af_iucv.c": [
      "File: net/iucv/af_iucv.c -> net/iucv/af_iucv.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1324:  int err = 0;",
      "1325:  u32 offset;",
      "1329:  if ((sk->sk_state == IUCV_DISCONN) &&",
      "1330:      skb_queue_empty(&iucv->backlog_skb_q) &&",
      "1331:      skb_queue_empty(&sk->sk_receive_queue) &&",
      "",
      "[Removed Lines]",
      "1327:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/key/af_key.c||net/key/af_key.c": [
      "File: net/key/af_key.c -> net/key/af_key.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3616:  if (flags & ~(MSG_PEEK|MSG_DONTWAIT|MSG_TRUNC|MSG_CMSG_COMPAT))",
      "3617:   goto out;",
      "3620:  skb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);",
      "3621:  if (skb == NULL)",
      "3622:   goto out;",
      "",
      "[Removed Lines]",
      "3619:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/l2tp/l2tp_ppp.c||net/l2tp/l2tp_ppp.c": [
      "File: net/l2tp/l2tp_ppp.c -> net/l2tp/l2tp_ppp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "197:  if (sk->sk_state & PPPOX_BOUND)",
      "198:   goto end;",
      "202:  err = 0;",
      "203:  skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,",
      "204:     flags & MSG_DONTWAIT, &err);",
      "",
      "[Removed Lines]",
      "200:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/llc/af_llc.c||net/llc/af_llc.c": [
      "File: net/llc/af_llc.c -> net/llc/af_llc.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "721:  long timeo;",
      "725:  lock_sock(sk);",
      "726:  copied = -ENOTCONN;",
      "727:  if (unlikely(sk->sk_type == SOCK_STREAM && sk->sk_state == TCP_LISTEN))",
      "",
      "[Removed Lines]",
      "723:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/netlink/af_netlink.c||net/netlink/af_netlink.c": [
      "File: net/netlink/af_netlink.c -> net/netlink/af_netlink.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2335:  }",
      "2336: #endif",
      "2340:  copied = data_skb->len;",
      "2341:  if (len < copied) {",
      "2342:   msg->msg_flags |= MSG_TRUNC;",
      "",
      "[Removed Lines]",
      "2338:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/netrom/af_netrom.c||net/netrom/af_netrom.c": [
      "File: net/netrom/af_netrom.c -> net/netrom/af_netrom.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1179:   sax->sax25_family = AF_NETROM;",
      "1180:   skb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,",
      "1181:          AX25_ADDR_LEN);",
      "1182:  }",
      "1186:  skb_free_datagram(sk, skb);",
      "1188:  release_sock(sk);",
      "",
      "[Removed Lines]",
      "1184:  msg->msg_namelen = sizeof(*sax);",
      "",
      "[Added Lines]",
      "1182:   msg->msg_namelen = sizeof(*sax);",
      "",
      "---------------"
    ],
    "net/nfc/llcp_sock.c||net/nfc/llcp_sock.c": [
      "File: net/nfc/llcp_sock.c -> net/nfc/llcp_sock.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "808:  pr_debug(\"%p %zu\\n\", sk, len);",
      "812:  lock_sock(sk);",
      "814:  if (sk->sk_state == LLCP_CLOSED &&",
      "",
      "[Removed Lines]",
      "810:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/nfc/rawsock.c||net/nfc/rawsock.c": [
      "File: net/nfc/rawsock.c -> net/nfc/rawsock.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "244:  if (!skb)",
      "245:   return rc;",
      "249:  copied = skb->len;",
      "250:  if (len < copied) {",
      "251:   msg->msg_flags |= MSG_TRUNC;",
      "",
      "[Removed Lines]",
      "247:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/packet/af_packet.c||net/packet/af_packet.c": [
      "File: net/packet/af_packet.c -> net/packet/af_packet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2660:  struct sock *sk = sock->sk;",
      "2661:  struct sk_buff *skb;",
      "2662:  int copied, err;",
      "2664:  int vnet_hdr_len = 0;",
      "2666:  err = -EINVAL;",
      "",
      "[Removed Lines]",
      "2663:  struct sockaddr_ll *sll;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2744:    goto out_free;",
      "2745:  }",
      "2763:  copied = skb->len;",
      "2764:  if (copied > len) {",
      "2765:   copied = len;",
      "",
      "[Removed Lines]",
      "2752:  sll = &PACKET_SKB_CB(skb)->sa.ll;",
      "2753:  if (sock->type == SOCK_PACKET)",
      "2754:   msg->msg_namelen = sizeof(struct sockaddr_pkt);",
      "2755:  else",
      "2756:   msg->msg_namelen = sll->sll_halen + offsetof(struct sockaddr_ll, sll_addr);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2773:  sock_recv_ts_and_drops(msg, sk, skb);",
      "2776:   memcpy(msg->msg_name, &PACKET_SKB_CB(skb)->sa,",
      "2777:          msg->msg_namelen);",
      "2779:  if (pkt_sk(sk)->auxdata) {",
      "2780:   struct tpacket_auxdata aux;",
      "",
      "[Removed Lines]",
      "2775:  if (msg->msg_name)",
      "",
      "[Added Lines]",
      "2762:  if (msg->msg_name) {",
      "2766:   if (sock->type == SOCK_PACKET) {",
      "2767:    msg->msg_namelen = sizeof(struct sockaddr_pkt);",
      "2768:   } else {",
      "2769:    struct sockaddr_ll *sll = &PACKET_SKB_CB(skb)->sa.ll;",
      "2770:    msg->msg_namelen = sll->sll_halen +",
      "2771:     offsetof(struct sockaddr_ll, sll_addr);",
      "2772:   }",
      "2775:  }",
      "",
      "---------------"
    ],
    "net/rds/recv.c||net/rds/recv.c": [
      "File: net/rds/recv.c -> net/rds/recv.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "411:  rdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);",
      "415:  if (msg_flags & MSG_OOB)",
      "416:   goto out;",
      "",
      "[Removed Lines]",
      "413:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/rose/af_rose.c||net/rose/af_rose.c": [
      "File: net/rose/af_rose.c -> net/rose/af_rose.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1216: {",
      "1217:  struct sock *sk = sock->sk;",
      "1218:  struct rose_sock *rose = rose_sk(sk);",
      "1220:  size_t copied;",
      "1221:  unsigned char *asmptr;",
      "1222:  struct sk_buff *skb;",
      "",
      "[Removed Lines]",
      "1219:  struct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1253:  skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);",
      "1257:   srose->srose_family = AF_ROSE;",
      "1258:   srose->srose_addr   = rose->dest_addr;",
      "1259:   srose->srose_call   = rose->dest_call;",
      "",
      "[Removed Lines]",
      "1255:  if (srose != NULL) {",
      "1256:   memset(srose, 0, msg->msg_namelen);",
      "",
      "[Added Lines]",
      "1254:  if (msg->msg_name) {",
      "1255:   struct sockaddr_rose *srose;",
      "1257:   memset(msg->msg_name, 0, sizeof(struct full_sockaddr_rose));",
      "1258:   srose = msg->msg_name;",
      "",
      "---------------"
    ],
    "net/rxrpc/ar-recvmsg.c||net/rxrpc/ar-recvmsg.c": [
      "File: net/rxrpc/ar-recvmsg.c -> net/rxrpc/ar-recvmsg.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "145:   if (!continue_call) {",
      "147:     memcpy(msg->msg_name,",
      "150:    sock_recv_ts_and_drops(msg, &rx->sk, skb);",
      "151:   }",
      "",
      "[Removed Lines]",
      "146:    if (msg->msg_name && msg->msg_namelen > 0)",
      "148:            &call->conn->trans->peer->srx,",
      "149:            sizeof(call->conn->trans->peer->srx));",
      "",
      "[Added Lines]",
      "146:    if (msg->msg_name) {",
      "147:     size_t len =",
      "148:      sizeof(call->conn->trans->peer->srx);",
      "150:            &call->conn->trans->peer->srx, len);",
      "151:     msg->msg_namelen = len;",
      "152:    }",
      "",
      "---------------"
    ],
    "net/socket.c||net/socket.c": [
      "File: net/socket.c -> net/socket.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1840:  msg.msg_iov = &iov;",
      "1841:  iov.iov_len = size;",
      "1842:  iov.iov_base = ubuf;",
      "1845:  if (sock->file->f_flags & O_NONBLOCK)",
      "1846:   flags |= MSG_DONTWAIT;",
      "1847:  err = sock_recvmsg(sock, &msg, size, flags);",
      "",
      "[Removed Lines]",
      "1843:  msg.msg_name = (struct sockaddr *)&address;",
      "1844:  msg.msg_namelen = sizeof(address);",
      "",
      "[Added Lines]",
      "1844:  msg.msg_name = addr ? (struct sockaddr *)&address : NULL;",
      "1846:  msg.msg_namelen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2221:    goto out;",
      "2222:  }",
      "2229:  uaddr = (__force void __user *)msg_sys->msg_name;",
      "2230:  uaddr_len = COMPAT_NAMELEN(msg);",
      "2232:   err = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);",
      "2234:   err = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);",
      "2235:  if (err < 0)",
      "2236:   goto out_freeiov;",
      "",
      "[Removed Lines]",
      "2231:  if (MSG_CMSG_COMPAT & flags) {",
      "2233:  } else",
      "",
      "[Added Lines]",
      "2231:  if (MSG_CMSG_COMPAT & flags)",
      "2233:  else",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2239:  cmsg_ptr = (unsigned long)msg_sys->msg_control;",
      "2240:  msg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);",
      "2242:  if (sock->file->f_flags & O_NONBLOCK)",
      "2243:   flags |= MSG_DONTWAIT;",
      "2244:  err = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2243:  msg_sys->msg_namelen = 0;",
      "",
      "---------------"
    ],
    "net/tipc/socket.c||net/tipc/socket.c": [
      "File: net/tipc/socket.c -> net/tipc/socket.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "980:   goto exit;",
      "981:  }",
      "986:  timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);",
      "987: restart:",
      "",
      "[Removed Lines]",
      "984:  m->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1091:   goto exit;",
      "1092:  }",
      "1097:  target = sock_rcvlowat(sk, flags & MSG_WAITALL, buf_len);",
      "1098:  timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);",
      "",
      "[Removed Lines]",
      "1095:  m->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/unix/af_unix.c||net/unix/af_unix.c": [
      "File: net/unix/af_unix.c -> net/unix/af_unix.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1754: {",
      "1755:  struct unix_sock *u = unix_sk(sk);",
      "1758:  if (u->addr) {",
      "1759:   msg->msg_namelen = u->addr->len;",
      "1760:   memcpy(msg->msg_name, u->addr->name, u->addr->len);",
      "",
      "[Removed Lines]",
      "1757:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1778:  if (flags&MSG_OOB)",
      "1779:   goto out;",
      "1783:  err = mutex_lock_interruptible(&u->readlock);",
      "1784:  if (err) {",
      "1785:   err = sock_intr_errno(sock_rcvtimeo(sk, noblock));",
      "",
      "[Removed Lines]",
      "1781:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1924:  target = sock_rcvlowat(sk, flags&MSG_WAITALL, size);",
      "1925:  timeo = sock_rcvtimeo(sk, flags&MSG_DONTWAIT);",
      "",
      "[Removed Lines]",
      "1927:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/vmw_vsock/af_vsock.c||net/vmw_vsock/af_vsock.c": [
      "File: net/vmw_vsock/af_vsock.c -> net/vmw_vsock/af_vsock.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1662:  vsk = vsock_sk(sk);",
      "1663:  err = 0;",
      "1667:  lock_sock(sk);",
      "1669:  if (sk->sk_state != SS_CONNECTED) {",
      "",
      "[Removed Lines]",
      "1665:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/vmw_vsock/vmci_transport.c||net/vmw_vsock/vmci_transport.c": [
      "File: net/vmw_vsock/vmci_transport.c -> net/vmw_vsock/vmci_transport.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1746:  if (flags & MSG_OOB || flags & MSG_ERRQUEUE)",
      "1747:   return -EOPNOTSUPP;",
      "1752:  err = 0;",
      "1753:  skb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);",
      "",
      "[Removed Lines]",
      "1749:  msg->msg_namelen = 0;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "net/x25/af_x25.c||net/x25/af_x25.c": [
      "File: net/x25/af_x25.c -> net/x25/af_x25.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1340:  if (sx25) {",
      "1341:   sx25->sx25_family = AF_X25;",
      "1342:   sx25->sx25_addr   = x25->dest_addr;",
      "1343:  }",
      "1347:  x25_check_rbuf(sk);",
      "1348:  rc = copied;",
      "1349: out_free_dgram:",
      "",
      "[Removed Lines]",
      "1345:  msg->msg_namelen = sizeof(struct sockaddr_x25);",
      "",
      "[Added Lines]",
      "1343:   msg->msg_namelen = sizeof(*sx25);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d97636980f6ba7344c8aa6fa349b9059c60ee478",
      "candidate_info": {
        "commit_hash": "d97636980f6ba7344c8aa6fa349b9059c60ee478",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d97636980f6ba7344c8aa6fa349b9059c60ee478",
        "files": [
          "include/net/bluetooth/bluetooth.h",
          "net/bluetooth/af_bluetooth.c"
        ],
        "message": "Bluetooth: Add support for per socket msg_name callback\n\nThis allows to add a per socket msg_name callback that can be used\nfor updating the msg_name information for recvmsg() system calls.\n\nThis feature is used by another patch to support address information\non L2CAP connectionless channels.\n\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>\nSigned-off-by: Johan Hedberg <johan.hedberg@intel.com>",
        "before_after_code_files": [
          "include/net/bluetooth/bluetooth.h||include/net/bluetooth/bluetooth.h",
          "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c"
          ],
          "candidate": [
            "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/bluetooth.h||include/net/bluetooth/bluetooth.h": [
          "File: include/net/bluetooth/bluetooth.h -> include/net/bluetooth/bluetooth.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "221:  struct list_head accept_q;",
          "222:  struct sock *parent;",
          "223:  unsigned long flags;",
          "224: };",
          "226: enum {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "224:  void (*skb_msg_name)(struct sk_buff *, void *, int *);",
          "",
          "---------------"
        ],
        "net/bluetooth/af_bluetooth.c||net/bluetooth/af_bluetooth.c": [
          "File: net/bluetooth/af_bluetooth.c -> net/bluetooth/af_bluetooth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "221:  if (flags & (MSG_OOB))",
          "222:   return -EOPNOTSUPP;",
          "226:  skb = skb_recv_datagram(sk, flags, noblock, &err);",
          "227:  if (!skb) {",
          "229:    return 0;",
          "230:   return err;",
          "231:  }",
          "",
          "[Removed Lines]",
          "224:  msg->msg_namelen = 0;",
          "228:   if (sk->sk_shutdown & RCV_SHUTDOWN)",
          "",
          "[Added Lines]",
          "226:   if (sk->sk_shutdown & RCV_SHUTDOWN) {",
          "227:    msg->msg_namelen = 0;",
          "229:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "239:  skb_reset_transport_header(skb);",
          "240:  err = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);",
          "242:   sock_recv_ts_and_drops(msg, sk, skb);",
          "244:  skb_free_datagram(sk, skb);",
          "246:  return err ? : copied;",
          "",
          "[Removed Lines]",
          "241:  if (err == 0)",
          "",
          "[Added Lines]",
          "241:  if (err == 0) {",
          "244:   if (bt_sk(sk)->skb_msg_name)",
          "245:    bt_sk(sk)->skb_msg_name(skb, msg->msg_name,",
          "246:       &msg->msg_namelen);",
          "247:   else",
          "248:    msg->msg_namelen = 0;",
          "249:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "20714bfef84d3e690c9c6f8e9cd46543b5ae1eed",
      "candidate_info": {
        "commit_hash": "20714bfef84d3e690c9c6f8e9cd46543b5ae1eed",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/20714bfef84d3e690c9c6f8e9cd46543b5ae1eed",
        "files": [
          "include/net/bluetooth/hci_core.h",
          "net/bluetooth/hci_event.c",
          "net/bluetooth/sco.c"
        ],
        "message": "Bluetooth: Implement deferred sco socket setup\n\nIn order to authenticate and configure an incoming SCO connection, the\nBT_DEFER_SETUP option was added. This option is intended to defer reply\nto Connect Request on SCO sockets.\nWhen a connection is requested, the listening socket is unblocked but\nthe effective connection setup happens only on first recv. Any send\nbetween accept and recv fails with -ENOTCONN.\n\nSigned-off-by: Fr\u00e9d\u00e9ric Dalleau <frederic.dalleau@linux.intel.com>\nSigned-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>",
        "before_after_code_files": [
          "include/net/bluetooth/hci_core.h||include/net/bluetooth/hci_core.h",
          "net/bluetooth/hci_event.c||net/bluetooth/hci_event.c",
          "net/bluetooth/sco.c||net/bluetooth/sco.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/bluetooth/sco.c||net/bluetooth/sco.c"
          ],
          "candidate": [
            "net/bluetooth/sco.c||net/bluetooth/sco.c"
          ]
        }
      },
      "candidate_diff": {
        "include/net/bluetooth/hci_core.h||include/net/bluetooth/hci_core.h": [
          "File: include/net/bluetooth/hci_core.h -> include/net/bluetooth/hci_core.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "376: extern int l2cap_recv_acldata(struct hci_conn *hcon, struct sk_buff *skb,",
          "377:          u16 flags);",
          "380: extern void sco_connect_cfm(struct hci_conn *hcon, __u8 status);",
          "381: extern void sco_disconn_cfm(struct hci_conn *hcon, __u8 reason);",
          "382: extern int sco_recv_scodata(struct hci_conn *hcon, struct sk_buff *skb);",
          "",
          "[Removed Lines]",
          "379: extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr);",
          "",
          "[Added Lines]",
          "379: extern int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "577: int hci_conn_del(struct hci_conn *conn);",
          "578: void hci_conn_hash_flush(struct hci_dev *hdev);",
          "579: void hci_conn_check_pending(struct hci_dev *hdev);",
          "581: struct hci_chan *hci_chan_create(struct hci_conn *conn);",
          "582: void hci_chan_del(struct hci_chan *chan);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "580: void hci_conn_accept(struct hci_conn *conn, int mask);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "779: #define lmp_host_le_br_capable(dev) ((dev)->host_features[0] & LMP_HOST_LE_BREDR)",
          "782: static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,",
          "784: {",
          "785:  switch (type) {",
          "786:  case ACL_LINK:",
          "",
          "[Removed Lines]",
          "783:         __u8 type)",
          "",
          "[Added Lines]",
          "783: #define HCI_PROTO_DEFER             0x01",
          "786:      __u8 type, __u8 *flags)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "789:  case SCO_LINK:",
          "790:  case ESCO_LINK:",
          "793:  default:",
          "794:   BT_ERR(\"unknown link type %d\", type);",
          "",
          "[Removed Lines]",
          "791:   return sco_connect_ind(hdev, bdaddr);",
          "",
          "[Added Lines]",
          "794:   return sco_connect_ind(hdev, bdaddr, flags);",
          "",
          "---------------"
        ],
        "net/bluetooth/hci_event.c||net/bluetooth/hci_event.c": [
          "File: net/bluetooth/hci_event.c -> net/bluetooth/hci_event.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2047:  hci_conn_check_pending(hdev);",
          "2048: }",
          "2050: static void hci_conn_request_evt(struct hci_dev *hdev, struct sk_buff *skb)",
          "2051: {",
          "2052:  struct hci_ev_conn_request *ev = (void *) skb->data;",
          "2053:  int mask = hdev->link_mode;",
          "2055:  BT_DBG(\"%s bdaddr %pMR type 0x%x\", hdev->name, &ev->bdaddr,",
          "2056:         ev->link_type);",
          "2060:  if ((mask & HCI_LM_ACCEPT) &&",
          "2061:      !hci_blacklist_lookup(hdev, &ev->bdaddr)) {",
          "",
          "[Removed Lines]",
          "2058:  mask |= hci_proto_connect_ind(hdev, &ev->bdaddr, ev->link_type);",
          "",
          "[Added Lines]",
          "2050: void hci_conn_accept(struct hci_conn *conn, int mask)",
          "2051: {",
          "2052:  struct hci_dev *hdev = conn->hdev;",
          "2054:  BT_DBG(\"conn %p\", conn);",
          "2056:  conn->state = BT_CONFIG;",
          "2058:  if (!lmp_esco_capable(hdev)) {",
          "2059:   struct hci_cp_accept_conn_req cp;",
          "2061:   bacpy(&cp.bdaddr, &conn->dst);",
          "2063:   if (lmp_rswitch_capable(hdev) && (mask & HCI_LM_MASTER))",
          "2065:   else",
          "2068:   hci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp), &cp);",
          "2069:  } else /* lmp_esco_capable(hdev)) */ {",
          "2070:   struct hci_cp_accept_sync_conn_req cp;",
          "2072:   bacpy(&cp.bdaddr, &conn->dst);",
          "2073:   cp.pkt_type = cpu_to_le16(conn->pkt_type);",
          "2075:   cp.tx_bandwidth   = __constant_cpu_to_le32(0x00001f40);",
          "2076:   cp.rx_bandwidth   = __constant_cpu_to_le32(0x00001f40);",
          "2077:   cp.max_latency    = __constant_cpu_to_le16(0xffff);",
          "2078:   cp.content_format = cpu_to_le16(hdev->voice_setting);",
          "2079:   cp.retrans_effort = 0xff;",
          "2081:   hci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,",
          "2082:         sizeof(cp), &cp);",
          "2083:  }",
          "2084: }",
          "2090:  __u8 flags = 0;",
          "2095:  mask |= hci_proto_connect_ind(hdev, &ev->bdaddr, ev->link_type,",
          "2096:           &flags);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2081:   }",
          "2083:   memcpy(conn->dev_class, ev->dev_class, 3);",
          "2086:   hci_dev_unlock(hdev);",
          "2089:    struct hci_cp_accept_conn_req cp;",
          "2091:    bacpy(&cp.bdaddr, &ev->bdaddr);",
          "",
          "[Removed Lines]",
          "2084:   conn->state = BT_CONNECT;",
          "2088:   if (ev->link_type == ACL_LINK || !lmp_esco_capable(hdev)) {",
          "",
          "[Added Lines]",
          "2125:   if (ev->link_type == ACL_LINK ||",
          "2126:       (!(flags & HCI_PROTO_DEFER) && !lmp_esco_capable(hdev))) {",
          "2128:    conn->state = BT_CONNECT;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2098:    hci_send_cmd(hdev, HCI_OP_ACCEPT_CONN_REQ, sizeof(cp),",
          "2099:          &cp);",
          "2101:    struct hci_cp_accept_sync_conn_req cp;",
          "2103:    bacpy(&cp.bdaddr, &ev->bdaddr);",
          "2104:    cp.pkt_type = cpu_to_le16(conn->pkt_type);",
          "",
          "[Removed Lines]",
          "2100:   } else {",
          "",
          "[Added Lines]",
          "2139:   } else if (!(flags & HCI_PROTO_DEFER)) {",
          "2141:    conn->state = BT_CONNECT;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2112:    hci_send_cmd(hdev, HCI_OP_ACCEPT_SYNC_CONN_REQ,",
          "2113:          sizeof(cp), &cp);",
          "2114:   }",
          "2115:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2154:   } else {",
          "2155:    conn->state = BT_CONNECT2;",
          "2156:    hci_proto_connect_cfm(conn, 0);",
          "2157:    hci_conn_put(conn);",
          "",
          "---------------"
        ],
        "net/bluetooth/sco.c||net/bluetooth/sco.c": [
          "File: net/bluetooth/sco.c -> net/bluetooth/sco.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "398:  if (parent) {",
          "399:   sk->sk_type = parent->sk_type;",
          "400:   security_sk_clone(parent, sk);",
          "401:  }",
          "402: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "400:   bt_sk(sk)->flags = bt_sk(parent)->flags;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "662:  return err;",
          "663: }",
          "665: static int sco_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)",
          "666: {",
          "667:  struct sock *sk = sock->sk;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "666: static int sco_sock_recvmsg(struct kiocb *iocb, struct socket *sock,",
          "667:        struct msghdr *msg, size_t len, int flags)",
          "668: {",
          "669:  struct sock *sk = sock->sk;",
          "670:  struct sco_pinfo *pi = sco_pi(sk);",
          "672:  lock_sock(sk);",
          "674:  if (sk->sk_state == BT_CONNECT2 &&",
          "675:      test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags)) {",
          "676:   hci_conn_accept(pi->conn->hcon, 0);",
          "677:   sk->sk_state = BT_CONFIG;",
          "679:   release_sock(sk);",
          "680:   return 0;",
          "681:  }",
          "683:  release_sock(sk);",
          "685:  return bt_sock_recvmsg(iocb, sock, msg, len, flags);",
          "686: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "906:   hci_conn_hold(conn->hcon);",
          "907:   __sco_chan_add(conn, sk, parent);",
          "912:   parent->sk_data_ready(parent, 1);",
          "",
          "[Removed Lines]",
          "909:   sk->sk_state = BT_CONNECTED;",
          "",
          "[Added Lines]",
          "932:   if (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))",
          "933:    sk->sk_state = BT_CONNECT2;",
          "934:   else",
          "935:    sk->sk_state = BT_CONNECTED;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "919: }",
          "923: {",
          "924:  struct sock *sk;",
          "925:  struct hlist_node *node;",
          "",
          "[Removed Lines]",
          "922: int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr)",
          "",
          "[Added Lines]",
          "948: int sco_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 *flags)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "936:   if (!bacmp(&bt_sk(sk)->src, &hdev->bdaddr) ||",
          "937:       !bacmp(&bt_sk(sk)->src, BDADDR_ANY)) {",
          "938:    lm |= HCI_LM_ACCEPT;",
          "939:    break;",
          "940:   }",
          "941:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "966:    if (test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1024:  .accept  = sco_sock_accept,",
          "1025:  .getname = sco_sock_getname,",
          "1026:  .sendmsg = sco_sock_sendmsg,",
          "1028:  .poll  = bt_sock_poll,",
          "1029:  .ioctl  = bt_sock_ioctl,",
          "1030:  .mmap  = sock_no_mmap,",
          "",
          "[Removed Lines]",
          "1027:  .recvmsg = bt_sock_recvmsg,",
          "",
          "[Added Lines]",
          "1056:  .recvmsg = sco_sock_recvmsg,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d021c344051af91f42c5ba9fdedc176740cbd238",
      "candidate_info": {
        "commit_hash": "d021c344051af91f42c5ba9fdedc176740cbd238",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d021c344051af91f42c5ba9fdedc176740cbd238",
        "files": [
          "include/linux/socket.h",
          "include/uapi/linux/vm_sockets.h",
          "net/Kconfig",
          "net/Makefile",
          "net/vmw_vsock/Kconfig",
          "net/vmw_vsock/Makefile",
          "net/vmw_vsock/af_vsock.c",
          "net/vmw_vsock/af_vsock.h",
          "net/vmw_vsock/vmci_transport.c",
          "net/vmw_vsock/vmci_transport.h",
          "net/vmw_vsock/vmci_transport_notify.c",
          "net/vmw_vsock/vmci_transport_notify.h",
          "net/vmw_vsock/vmci_transport_notify_qstate.c",
          "net/vmw_vsock/vsock_addr.c",
          "net/vmw_vsock/vsock_addr.h",
          "net/vmw_vsock/vsock_version.h"
        ],
        "message": "VSOCK: Introduce VM Sockets\n\nVM Sockets allows communication between virtual machines and the hypervisor.\nUser level applications both in a virtual machine and on the host can use the\nVM Sockets API, which facilitates fast and efficient communication between\nguest virtual machines and their host.  A socket address family, designed to be\ncompatible with UDP and TCP at the interface level, is provided.\n\nToday, VM Sockets is used by various VMware Tools components inside the guest\nfor zero-config, network-less access to VMware host services.  In addition to\nthis, VMware's users are using VM Sockets for various applications, where\nnetwork access of the virtual machine is restricted or non-existent.  Examples\nof this are VMs communicating with device proxies for proprietary hardware\nrunning as host applications and automated testing of applications running\nwithin virtual machines.\n\nThe VMware VM Sockets are similar to other socket types, like Berkeley UNIX\nsocket interface.  The VM Sockets module supports both connection-oriented\nstream sockets like TCP, and connectionless datagram sockets like UDP. The VM\nSockets protocol family is defined as \"AF_VSOCK\" and the socket operations\nsplit for SOCK_DGRAM and SOCK_STREAM.\n\nFor additional information about the use of VM Sockets, please refer to the\nVM Sockets Programming Guide available at:\n\nhttps://www.vmware.com/support/developer/vmci-sdk/\n\nSigned-off-by: George Zhang <georgezhang@vmware.com>\nSigned-off-by: Dmitry Torokhov <dtor@vmware.com>\nSigned-off-by: Andy king <acking@vmware.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/socket.h||include/linux/socket.h",
          "include/uapi/linux/vm_sockets.h||include/uapi/linux/vm_sockets.h",
          "net/vmw_vsock/af_vsock.c||net/vmw_vsock/af_vsock.c",
          "net/vmw_vsock/af_vsock.h||net/vmw_vsock/af_vsock.h",
          "net/vmw_vsock/vmci_transport.c||net/vmw_vsock/vmci_transport.c",
          "net/vmw_vsock/vmci_transport.h||net/vmw_vsock/vmci_transport.h",
          "net/vmw_vsock/vmci_transport_notify.c||net/vmw_vsock/vmci_transport_notify.c",
          "net/vmw_vsock/vmci_transport_notify.h||net/vmw_vsock/vmci_transport_notify.h",
          "net/vmw_vsock/vmci_transport_notify_qstate.c||net/vmw_vsock/vmci_transport_notify_qstate.c",
          "net/vmw_vsock/vsock_addr.c||net/vmw_vsock/vsock_addr.c",
          "net/vmw_vsock/vsock_addr.h||net/vmw_vsock/vsock_addr.h",
          "net/vmw_vsock/vsock_version.h||net/vmw_vsock/vsock_version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/vmw_vsock/af_vsock.c||net/vmw_vsock/af_vsock.c",
            "net/vmw_vsock/vmci_transport.c||net/vmw_vsock/vmci_transport.c"
          ],
          "candidate": [
            "net/vmw_vsock/af_vsock.c||net/vmw_vsock/af_vsock.c",
            "net/vmw_vsock/vmci_transport.c||net/vmw_vsock/vmci_transport.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/socket.h||include/linux/socket.h": [
          "File: include/linux/socket.h -> include/linux/socket.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "221: #define PF_CAIF  AF_CAIF",
          "222: #define PF_ALG  AF_ALG",
          "223: #define PF_NFC  AF_NFC",
          "224: #define PF_MAX  AF_MAX",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "225: #define PF_VSOCK AF_VSOCK",
          "",
          "---------------"
        ],
        "include/uapi/linux/vm_sockets.h||include/uapi/linux/vm_sockets.h": [
          "File: include/uapi/linux/vm_sockets.h -> include/uapi/linux/vm_sockets.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #ifndef _VM_SOCKETS_H_",
          "17: #define _VM_SOCKETS_H_",
          "19: #if !defined(__KERNEL__)",
          "20: #include <sys/socket.h>",
          "21: #endif",
          "29: #define SO_VM_SOCKETS_BUFFER_SIZE 0",
          "37: #define SO_VM_SOCKETS_BUFFER_MIN_SIZE 1",
          "45: #define SO_VM_SOCKETS_BUFFER_MAX_SIZE 2",
          "53: #define SO_VM_SOCKETS_PEER_HOST_VM_ID 3",
          "61: #define SO_VM_SOCKETS_SERVICE_LABEL 4",
          "68: #define SO_VM_SOCKETS_TRUSTED 5",
          "75: #define SO_VM_SOCKETS_CONNECT_TIMEOUT 6",
          "90: #define SO_VM_SOCKETS_NONBLOCK_TXRX 7",
          "96: #define VMADDR_CID_ANY -1U",
          "102: #define VMADDR_PORT_ANY -1U",
          "109: #define VMADDR_CID_HYPERVISOR 0",
          "115: #define VMADDR_CID_RESERVED 1",
          "122: #define VMADDR_CID_HOST 2",
          "126: #define VM_SOCKETS_INVALID_VERSION -1U",
          "132: #define VM_SOCKETS_VERSION_EPOCH(_v) (((_v) & 0xFF000000) >> 24)",
          "139: #define VM_SOCKETS_VERSION_MAJOR(_v) (((_v) & 0x00FF0000) >> 16)",
          "145: #define VM_SOCKETS_VERSION_MINOR(_v) (((_v) & 0x0000FFFF))",
          "154: struct sockaddr_vm {",
          "155:  sa_family_t svm_family;",
          "156:  unsigned short svm_reserved1;",
          "157:  unsigned int svm_port;",
          "158:  unsigned int svm_cid;",
          "159:  unsigned char svm_zero[sizeof(struct sockaddr) -",
          "160:           sizeof(sa_family_t) -",
          "161:           sizeof(unsigned short) -",
          "162:           sizeof(unsigned int) - sizeof(unsigned int)];",
          "163: };",
          "165: #define IOCTL_VM_SOCKETS_GET_LOCAL_CID  _IO(7, 0xb9)",
          "167: #if defined(__KERNEL__)",
          "168: int vm_sockets_get_local_cid(void);",
          "169: #endif",
          "171: #endif",
          "",
          "---------------"
        ],
        "net/vmw_vsock/af_vsock.c||net/vmw_vsock/af_vsock.c": [
          "File: net/vmw_vsock/af_vsock.c -> net/vmw_vsock/af_vsock.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "78: #include <linux/types.h>",
          "80: #define EXPORT_SYMTAB",
          "81: #include <linux/bitops.h>",
          "82: #include <linux/cred.h>",
          "83: #include <linux/init.h>",
          "84: #include <linux/io.h>",
          "85: #include <linux/kernel.h>",
          "86: #include <linux/kmod.h>",
          "87: #include <linux/list.h>",
          "88: #include <linux/miscdevice.h>",
          "89: #include <linux/module.h>",
          "90: #include <linux/mutex.h>",
          "91: #include <linux/net.h>",
          "92: #include <linux/poll.h>",
          "93: #include <linux/skbuff.h>",
          "94: #include <linux/smp.h>",
          "95: #include <linux/socket.h>",
          "96: #include <linux/stddef.h>",
          "97: #include <linux/unistd.h>",
          "98: #include <linux/wait.h>",
          "99: #include <linux/workqueue.h>",
          "100: #include <net/sock.h>",
          "102: #include \"af_vsock.h\"",
          "103: #include \"vsock_version.h\"",
          "105: static int __vsock_bind(struct sock *sk, struct sockaddr_vm *addr);",
          "106: static void vsock_sk_destruct(struct sock *sk);",
          "107: static int vsock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);",
          "110: static struct proto vsock_proto = {",
          "111:  .name = \"AF_VSOCK\",",
          "112:  .owner = THIS_MODULE,",
          "113:  .obj_size = sizeof(struct vsock_sock),",
          "114: };",
          "119: #define VSOCK_DEFAULT_CONNECT_TIMEOUT (2 * HZ)",
          "121: #define SS_LISTEN 255",
          "123: static const struct vsock_transport *transport;",
          "124: static DEFINE_MUTEX(vsock_register_mutex);",
          "130: int vm_sockets_get_local_cid(void)",
          "131: {",
          "132:  return transport->get_local_cid();",
          "133: }",
          "134: EXPORT_SYMBOL_GPL(vm_sockets_get_local_cid);",
          "152: #define VSOCK_HASH_SIZE         251",
          "153: #define MAX_PORT_RETRIES        24",
          "155: #define VSOCK_HASH(addr)        ((addr)->svm_port % (VSOCK_HASH_SIZE - 1))",
          "156: #define vsock_bound_sockets(addr) (&vsock_bind_table[VSOCK_HASH(addr)])",
          "157: #define vsock_unbound_sockets     (&vsock_bind_table[VSOCK_HASH_SIZE])",
          "160: #define VSOCK_CONN_HASH(src, dst)    \\",
          "161:  (((src)->svm_cid ^ (dst)->svm_port) % (VSOCK_HASH_SIZE - 1))",
          "162: #define vsock_connected_sockets(src, dst)  \\",
          "163:  (&vsock_connected_table[VSOCK_CONN_HASH(src, dst)])",
          "164: #define vsock_connected_sockets_vsk(vsk)    \\",
          "165:  vsock_connected_sockets(&(vsk)->remote_addr, &(vsk)->local_addr)",
          "167: static struct list_head vsock_bind_table[VSOCK_HASH_SIZE + 1];",
          "168: static struct list_head vsock_connected_table[VSOCK_HASH_SIZE];",
          "169: static DEFINE_SPINLOCK(vsock_table_lock);",
          "171: static __init void vsock_init_tables(void)",
          "172: {",
          "173:  int i;",
          "175:  for (i = 0; i < ARRAY_SIZE(vsock_bind_table); i++)",
          "176:   INIT_LIST_HEAD(&vsock_bind_table[i]);",
          "178:  for (i = 0; i < ARRAY_SIZE(vsock_connected_table); i++)",
          "179:   INIT_LIST_HEAD(&vsock_connected_table[i]);",
          "180: }",
          "182: static void __vsock_insert_bound(struct list_head *list,",
          "183:      struct vsock_sock *vsk)",
          "184: {",
          "185:  sock_hold(&vsk->sk);",
          "186:  list_add(&vsk->bound_table, list);",
          "187: }",
          "189: static void __vsock_insert_connected(struct list_head *list,",
          "190:          struct vsock_sock *vsk)",
          "191: {",
          "192:  sock_hold(&vsk->sk);",
          "193:  list_add(&vsk->connected_table, list);",
          "194: }",
          "196: static void __vsock_remove_bound(struct vsock_sock *vsk)",
          "197: {",
          "198:  list_del_init(&vsk->bound_table);",
          "199:  sock_put(&vsk->sk);",
          "200: }",
          "202: static void __vsock_remove_connected(struct vsock_sock *vsk)",
          "203: {",
          "204:  list_del_init(&vsk->connected_table);",
          "205:  sock_put(&vsk->sk);",
          "206: }",
          "208: static struct sock *__vsock_find_bound_socket(struct sockaddr_vm *addr)",
          "209: {",
          "210:  struct vsock_sock *vsk;",
          "212:  list_for_each_entry(vsk, vsock_bound_sockets(addr), bound_table)",
          "213:   if (vsock_addr_equals_addr_any(addr, &vsk->local_addr))",
          "214:    return sk_vsock(vsk);",
          "216:  return NULL;",
          "217: }",
          "219: static struct sock *__vsock_find_connected_socket(struct sockaddr_vm *src,",
          "220:         struct sockaddr_vm *dst)",
          "221: {",
          "222:  struct vsock_sock *vsk;",
          "224:  list_for_each_entry(vsk, vsock_connected_sockets(src, dst),",
          "225:        connected_table) {",
          "226:   if (vsock_addr_equals_addr(src, &vsk->remote_addr)",
          "227:       && vsock_addr_equals_addr(dst, &vsk->local_addr)) {",
          "228:    return sk_vsock(vsk);",
          "229:   }",
          "230:  }",
          "232:  return NULL;",
          "233: }",
          "235: static bool __vsock_in_bound_table(struct vsock_sock *vsk)",
          "236: {",
          "237:  return !list_empty(&vsk->bound_table);",
          "238: }",
          "240: static bool __vsock_in_connected_table(struct vsock_sock *vsk)",
          "241: {",
          "242:  return !list_empty(&vsk->connected_table);",
          "243: }",
          "245: static void vsock_insert_unbound(struct vsock_sock *vsk)",
          "246: {",
          "247:  spin_lock_bh(&vsock_table_lock);",
          "248:  __vsock_insert_bound(vsock_unbound_sockets, vsk);",
          "249:  spin_unlock_bh(&vsock_table_lock);",
          "250: }",
          "252: void vsock_insert_connected(struct vsock_sock *vsk)",
          "253: {",
          "254:  struct list_head *list = vsock_connected_sockets(",
          "255:   &vsk->remote_addr, &vsk->local_addr);",
          "257:  spin_lock_bh(&vsock_table_lock);",
          "258:  __vsock_insert_connected(list, vsk);",
          "259:  spin_unlock_bh(&vsock_table_lock);",
          "260: }",
          "261: EXPORT_SYMBOL_GPL(vsock_insert_connected);",
          "263: void vsock_remove_bound(struct vsock_sock *vsk)",
          "264: {",
          "265:  spin_lock_bh(&vsock_table_lock);",
          "266:  __vsock_remove_bound(vsk);",
          "267:  spin_unlock_bh(&vsock_table_lock);",
          "268: }",
          "269: EXPORT_SYMBOL_GPL(vsock_remove_bound);",
          "271: void vsock_remove_connected(struct vsock_sock *vsk)",
          "272: {",
          "273:  spin_lock_bh(&vsock_table_lock);",
          "274:  __vsock_remove_connected(vsk);",
          "275:  spin_unlock_bh(&vsock_table_lock);",
          "276: }",
          "277: EXPORT_SYMBOL_GPL(vsock_remove_connected);",
          "279: struct sock *vsock_find_bound_socket(struct sockaddr_vm *addr)",
          "280: {",
          "281:  struct sock *sk;",
          "283:  spin_lock_bh(&vsock_table_lock);",
          "284:  sk = __vsock_find_bound_socket(addr);",
          "285:  if (sk)",
          "286:   sock_hold(sk);",
          "288:  spin_unlock_bh(&vsock_table_lock);",
          "290:  return sk;",
          "291: }",
          "292: EXPORT_SYMBOL_GPL(vsock_find_bound_socket);",
          "294: struct sock *vsock_find_connected_socket(struct sockaddr_vm *src,",
          "295:       struct sockaddr_vm *dst)",
          "296: {",
          "297:  struct sock *sk;",
          "299:  spin_lock_bh(&vsock_table_lock);",
          "300:  sk = __vsock_find_connected_socket(src, dst);",
          "301:  if (sk)",
          "302:   sock_hold(sk);",
          "304:  spin_unlock_bh(&vsock_table_lock);",
          "306:  return sk;",
          "307: }",
          "308: EXPORT_SYMBOL_GPL(vsock_find_connected_socket);",
          "310: static bool vsock_in_bound_table(struct vsock_sock *vsk)",
          "311: {",
          "312:  bool ret;",
          "314:  spin_lock_bh(&vsock_table_lock);",
          "315:  ret = __vsock_in_bound_table(vsk);",
          "316:  spin_unlock_bh(&vsock_table_lock);",
          "318:  return ret;",
          "319: }",
          "321: static bool vsock_in_connected_table(struct vsock_sock *vsk)",
          "322: {",
          "323:  bool ret;",
          "325:  spin_lock_bh(&vsock_table_lock);",
          "326:  ret = __vsock_in_connected_table(vsk);",
          "327:  spin_unlock_bh(&vsock_table_lock);",
          "329:  return ret;",
          "330: }",
          "332: void vsock_for_each_connected_socket(void (*fn)(struct sock *sk))",
          "333: {",
          "334:  int i;",
          "336:  spin_lock_bh(&vsock_table_lock);",
          "338:  for (i = 0; i < ARRAY_SIZE(vsock_connected_table); i++) {",
          "339:   struct vsock_sock *vsk;",
          "340:   list_for_each_entry(vsk, &vsock_connected_table[i],",
          "341:         connected_table);",
          "342:    fn(sk_vsock(vsk));",
          "343:  }",
          "345:  spin_unlock_bh(&vsock_table_lock);",
          "346: }",
          "347: EXPORT_SYMBOL_GPL(vsock_for_each_connected_socket);",
          "349: void vsock_add_pending(struct sock *listener, struct sock *pending)",
          "350: {",
          "351:  struct vsock_sock *vlistener;",
          "352:  struct vsock_sock *vpending;",
          "354:  vlistener = vsock_sk(listener);",
          "355:  vpending = vsock_sk(pending);",
          "357:  sock_hold(pending);",
          "358:  sock_hold(listener);",
          "359:  list_add_tail(&vpending->pending_links, &vlistener->pending_links);",
          "360: }",
          "361: EXPORT_SYMBOL_GPL(vsock_add_pending);",
          "363: void vsock_remove_pending(struct sock *listener, struct sock *pending)",
          "364: {",
          "365:  struct vsock_sock *vpending = vsock_sk(pending);",
          "367:  list_del_init(&vpending->pending_links);",
          "368:  sock_put(listener);",
          "369:  sock_put(pending);",
          "370: }",
          "371: EXPORT_SYMBOL_GPL(vsock_remove_pending);",
          "373: void vsock_enqueue_accept(struct sock *listener, struct sock *connected)",
          "374: {",
          "375:  struct vsock_sock *vlistener;",
          "376:  struct vsock_sock *vconnected;",
          "378:  vlistener = vsock_sk(listener);",
          "379:  vconnected = vsock_sk(connected);",
          "381:  sock_hold(connected);",
          "382:  sock_hold(listener);",
          "383:  list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);",
          "384: }",
          "385: EXPORT_SYMBOL_GPL(vsock_enqueue_accept);",
          "387: static struct sock *vsock_dequeue_accept(struct sock *listener)",
          "388: {",
          "389:  struct vsock_sock *vlistener;",
          "390:  struct vsock_sock *vconnected;",
          "392:  vlistener = vsock_sk(listener);",
          "394:  if (list_empty(&vlistener->accept_queue))",
          "395:   return NULL;",
          "397:  vconnected = list_entry(vlistener->accept_queue.next,",
          "398:     struct vsock_sock, accept_queue);",
          "400:  list_del_init(&vconnected->accept_queue);",
          "401:  sock_put(listener);",
          "406:  return sk_vsock(vconnected);",
          "407: }",
          "409: static bool vsock_is_accept_queue_empty(struct sock *sk)",
          "410: {",
          "411:  struct vsock_sock *vsk = vsock_sk(sk);",
          "412:  return list_empty(&vsk->accept_queue);",
          "413: }",
          "415: static bool vsock_is_pending(struct sock *sk)",
          "416: {",
          "417:  struct vsock_sock *vsk = vsock_sk(sk);",
          "418:  return !list_empty(&vsk->pending_links);",
          "419: }",
          "421: static int vsock_send_shutdown(struct sock *sk, int mode)",
          "422: {",
          "423:  return transport->shutdown(vsock_sk(sk), mode);",
          "424: }",
          "426: void vsock_pending_work(struct work_struct *work)",
          "427: {",
          "428:  struct sock *sk;",
          "429:  struct sock *listener;",
          "430:  struct vsock_sock *vsk;",
          "431:  bool cleanup;",
          "433:  vsk = container_of(work, struct vsock_sock, dwork.work);",
          "434:  sk = sk_vsock(vsk);",
          "435:  listener = vsk->listener;",
          "436:  cleanup = true;",
          "438:  lock_sock(listener);",
          "439:  lock_sock(sk);",
          "441:  if (vsock_is_pending(sk)) {",
          "442:   vsock_remove_pending(listener, sk);",
          "443:  } else if (!vsk->rejected) {",
          "449:   cleanup = false;",
          "450:   goto out;",
          "451:  }",
          "453:  listener->sk_ack_backlog--;",
          "459:  if (vsock_in_connected_table(vsk))",
          "460:   vsock_remove_connected(vsk);",
          "462:  sk->sk_state = SS_FREE;",
          "464: out:",
          "465:  release_sock(sk);",
          "466:  release_sock(listener);",
          "467:  if (cleanup)",
          "468:   sock_put(sk);",
          "470:  sock_put(sk);",
          "471:  sock_put(listener);",
          "472: }",
          "473: EXPORT_SYMBOL_GPL(vsock_pending_work);",
          "477: static int __vsock_bind_stream(struct vsock_sock *vsk,",
          "478:           struct sockaddr_vm *addr)",
          "479: {",
          "480:  static u32 port = LAST_RESERVED_PORT + 1;",
          "481:  struct sockaddr_vm new_addr;",
          "483:  vsock_addr_init(&new_addr, addr->svm_cid, addr->svm_port);",
          "485:  if (addr->svm_port == VMADDR_PORT_ANY) {",
          "486:   bool found = false;",
          "487:   unsigned int i;",
          "489:   for (i = 0; i < MAX_PORT_RETRIES; i++) {",
          "490:    if (port <= LAST_RESERVED_PORT)",
          "491:     port = LAST_RESERVED_PORT + 1;",
          "493:    new_addr.svm_port = port++;",
          "495:    if (!__vsock_find_bound_socket(&new_addr)) {",
          "496:     found = true;",
          "497:     break;",
          "498:    }",
          "499:   }",
          "501:   if (!found)",
          "502:    return -EADDRNOTAVAIL;",
          "503:  } else {",
          "507:   if (addr->svm_port <= LAST_RESERVED_PORT &&",
          "508:       !capable(CAP_NET_BIND_SERVICE)) {",
          "509:    return -EACCES;",
          "510:   }",
          "512:   if (__vsock_find_bound_socket(&new_addr))",
          "513:    return -EADDRINUSE;",
          "514:  }",
          "516:  vsock_addr_init(&vsk->local_addr, new_addr.svm_cid, new_addr.svm_port);",
          "522:  __vsock_remove_bound(vsk);",
          "523:  __vsock_insert_bound(vsock_bound_sockets(&vsk->local_addr), vsk);",
          "525:  return 0;",
          "526: }",
          "528: static int __vsock_bind_dgram(struct vsock_sock *vsk,",
          "529:          struct sockaddr_vm *addr)",
          "530: {",
          "531:  return transport->dgram_bind(vsk, addr);",
          "532: }",
          "534: static int __vsock_bind(struct sock *sk, struct sockaddr_vm *addr)",
          "535: {",
          "536:  struct vsock_sock *vsk = vsock_sk(sk);",
          "537:  u32 cid;",
          "538:  int retval;",
          "541:  if (vsock_addr_bound(&vsk->local_addr))",
          "542:   return -EINVAL;",
          "549:  cid = transport->get_local_cid();",
          "550:  if (addr->svm_cid != cid && addr->svm_cid != VMADDR_CID_ANY)",
          "551:   return -EADDRNOTAVAIL;",
          "553:  switch (sk->sk_socket->type) {",
          "554:  case SOCK_STREAM:",
          "555:   spin_lock_bh(&vsock_table_lock);",
          "556:   retval = __vsock_bind_stream(vsk, addr);",
          "557:   spin_unlock_bh(&vsock_table_lock);",
          "558:   break;",
          "560:  case SOCK_DGRAM:",
          "561:   retval = __vsock_bind_dgram(vsk, addr);",
          "562:   break;",
          "564:  default:",
          "565:   retval = -EINVAL;",
          "566:   break;",
          "567:  }",
          "569:  return retval;",
          "570: }",
          "572: struct sock *__vsock_create(struct net *net,",
          "573:        struct socket *sock,",
          "574:        struct sock *parent,",
          "575:        gfp_t priority,",
          "576:        unsigned short type)",
          "577: {",
          "578:  struct sock *sk;",
          "579:  struct vsock_sock *psk;",
          "580:  struct vsock_sock *vsk;",
          "582:  sk = sk_alloc(net, AF_VSOCK, priority, &vsock_proto);",
          "583:  if (!sk)",
          "584:   return NULL;",
          "586:  sock_init_data(sock, sk);",
          "592:  if (!sock)",
          "593:   sk->sk_type = type;",
          "595:  vsk = vsock_sk(sk);",
          "596:  vsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);",
          "597:  vsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);",
          "599:  sk->sk_destruct = vsock_sk_destruct;",
          "600:  sk->sk_backlog_rcv = vsock_queue_rcv_skb;",
          "601:  sk->sk_state = 0;",
          "602:  sock_reset_flag(sk, SOCK_DONE);",
          "604:  INIT_LIST_HEAD(&vsk->bound_table);",
          "605:  INIT_LIST_HEAD(&vsk->connected_table);",
          "606:  vsk->listener = NULL;",
          "607:  INIT_LIST_HEAD(&vsk->pending_links);",
          "608:  INIT_LIST_HEAD(&vsk->accept_queue);",
          "609:  vsk->rejected = false;",
          "610:  vsk->sent_request = false;",
          "611:  vsk->ignore_connecting_rst = false;",
          "612:  vsk->peer_shutdown = 0;",
          "614:  psk = parent ? vsock_sk(parent) : NULL;",
          "615:  if (parent) {",
          "616:   vsk->trusted = psk->trusted;",
          "617:   vsk->owner = get_cred(psk->owner);",
          "618:   vsk->connect_timeout = psk->connect_timeout;",
          "619:  } else {",
          "620:   vsk->trusted = capable(CAP_NET_ADMIN);",
          "621:   vsk->owner = get_current_cred();",
          "622:   vsk->connect_timeout = VSOCK_DEFAULT_CONNECT_TIMEOUT;",
          "623:  }",
          "625:  if (transport->init(vsk, psk) < 0) {",
          "626:   sk_free(sk);",
          "627:   return NULL;",
          "628:  }",
          "630:  if (sock)",
          "631:   vsock_insert_unbound(vsk);",
          "633:  return sk;",
          "634: }",
          "635: EXPORT_SYMBOL_GPL(__vsock_create);",
          "637: static void __vsock_release(struct sock *sk)",
          "638: {",
          "639:  if (sk) {",
          "640:   struct sk_buff *skb;",
          "641:   struct sock *pending;",
          "642:   struct vsock_sock *vsk;",
          "644:   vsk = vsock_sk(sk);",
          "647:   if (vsock_in_bound_table(vsk))",
          "648:    vsock_remove_bound(vsk);",
          "650:   if (vsock_in_connected_table(vsk))",
          "651:    vsock_remove_connected(vsk);",
          "653:   transport->release(vsk);",
          "655:   lock_sock(sk);",
          "656:   sock_orphan(sk);",
          "657:   sk->sk_shutdown = SHUTDOWN_MASK;",
          "659:   while ((skb = skb_dequeue(&sk->sk_receive_queue)))",
          "660:    kfree_skb(skb);",
          "663:   while ((pending = vsock_dequeue_accept(sk)) != NULL) {",
          "664:    __vsock_release(pending);",
          "665:    sock_put(pending);",
          "666:   }",
          "668:   release_sock(sk);",
          "669:   sock_put(sk);",
          "670:  }",
          "671: }",
          "673: static void vsock_sk_destruct(struct sock *sk)",
          "674: {",
          "675:  struct vsock_sock *vsk = vsock_sk(sk);",
          "677:  transport->destruct(vsk);",
          "682:  vsock_addr_init(&vsk->local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);",
          "683:  vsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);",
          "685:  put_cred(vsk->owner);",
          "686: }",
          "688: static int vsock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)",
          "689: {",
          "690:  int err;",
          "692:  err = sock_queue_rcv_skb(sk, skb);",
          "693:  if (err)",
          "694:   kfree_skb(skb);",
          "696:  return err;",
          "697: }",
          "699: s64 vsock_stream_has_data(struct vsock_sock *vsk)",
          "700: {",
          "701:  return transport->stream_has_data(vsk);",
          "702: }",
          "703: EXPORT_SYMBOL_GPL(vsock_stream_has_data);",
          "705: s64 vsock_stream_has_space(struct vsock_sock *vsk)",
          "706: {",
          "707:  return transport->stream_has_space(vsk);",
          "708: }",
          "709: EXPORT_SYMBOL_GPL(vsock_stream_has_space);",
          "711: static int vsock_release(struct socket *sock)",
          "712: {",
          "713:  __vsock_release(sock->sk);",
          "714:  sock->sk = NULL;",
          "715:  sock->state = SS_FREE;",
          "717:  return 0;",
          "718: }",
          "720: static int",
          "721: vsock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)",
          "722: {",
          "723:  int err;",
          "724:  struct sock *sk;",
          "725:  struct sockaddr_vm *vm_addr;",
          "727:  sk = sock->sk;",
          "729:  if (vsock_addr_cast(addr, addr_len, &vm_addr) != 0)",
          "730:   return -EINVAL;",
          "732:  lock_sock(sk);",
          "733:  err = __vsock_bind(sk, vm_addr);",
          "734:  release_sock(sk);",
          "736:  return err;",
          "737: }",
          "739: static int vsock_getname(struct socket *sock,",
          "740:     struct sockaddr *addr, int *addr_len, int peer)",
          "741: {",
          "742:  int err;",
          "743:  struct sock *sk;",
          "744:  struct vsock_sock *vsk;",
          "745:  struct sockaddr_vm *vm_addr;",
          "747:  sk = sock->sk;",
          "748:  vsk = vsock_sk(sk);",
          "749:  err = 0;",
          "751:  lock_sock(sk);",
          "753:  if (peer) {",
          "754:   if (sock->state != SS_CONNECTED) {",
          "755:    err = -ENOTCONN;",
          "756:    goto out;",
          "757:   }",
          "758:   vm_addr = &vsk->remote_addr;",
          "759:  } else {",
          "760:   vm_addr = &vsk->local_addr;",
          "761:  }",
          "763:  if (!vm_addr) {",
          "764:   err = -EINVAL;",
          "765:   goto out;",
          "766:  }",
          "773:  BUILD_BUG_ON(sizeof(*vm_addr) > 128);",
          "774:  memcpy(addr, vm_addr, sizeof(*vm_addr));",
          "777: out:",
          "778:  release_sock(sk);",
          "779:  return err;",
          "780: }",
          "782: static int vsock_shutdown(struct socket *sock, int mode)",
          "783: {",
          "784:  int err;",
          "785:  struct sock *sk;",
          "793:  mode++;",
          "795:  if ((mode & ~SHUTDOWN_MASK) || !mode)",
          "796:   return -EINVAL;",
          "804:  sk = sock->sk;",
          "805:  if (sock->state == SS_UNCONNECTED) {",
          "806:   err = -ENOTCONN;",
          "807:   if (sk->sk_type == SOCK_STREAM)",
          "808:    return err;",
          "809:  } else {",
          "810:   sock->state = SS_DISCONNECTING;",
          "811:   err = 0;",
          "812:  }",
          "815:  mode = mode & (RCV_SHUTDOWN | SEND_SHUTDOWN);",
          "816:  if (mode) {",
          "817:   lock_sock(sk);",
          "818:   sk->sk_shutdown |= mode;",
          "819:   sk->sk_state_change(sk);",
          "820:   release_sock(sk);",
          "822:   if (sk->sk_type == SOCK_STREAM) {",
          "823:    sock_reset_flag(sk, SOCK_DONE);",
          "824:    vsock_send_shutdown(sk, mode);",
          "825:   }",
          "826:  }",
          "828:  return err;",
          "829: }",
          "831: static unsigned int vsock_poll(struct file *file, struct socket *sock,",
          "832:           poll_table *wait)",
          "833: {",
          "834:  struct sock *sk;",
          "835:  unsigned int mask;",
          "836:  struct vsock_sock *vsk;",
          "838:  sk = sock->sk;",
          "839:  vsk = vsock_sk(sk);",
          "841:  poll_wait(file, sk_sleep(sk), wait);",
          "842:  mask = 0;",
          "844:  if (sk->sk_err)",
          "846:   mask |= POLLERR;",
          "851:  if ((sk->sk_shutdown == SHUTDOWN_MASK) ||",
          "852:      ((sk->sk_shutdown & SEND_SHUTDOWN) &&",
          "853:       (vsk->peer_shutdown & SEND_SHUTDOWN))) {",
          "854:   mask |= POLLHUP;",
          "855:  }",
          "857:  if (sk->sk_shutdown & RCV_SHUTDOWN ||",
          "858:      vsk->peer_shutdown & SEND_SHUTDOWN) {",
          "859:   mask |= POLLRDHUP;",
          "860:  }",
          "862:  if (sock->type == SOCK_DGRAM) {",
          "867:   if (!skb_queue_empty(&sk->sk_receive_queue) ||",
          "868:       (sk->sk_shutdown & RCV_SHUTDOWN)) {",
          "869:    mask |= POLLIN | POLLRDNORM;",
          "870:   }",
          "872:   if (!(sk->sk_shutdown & SEND_SHUTDOWN))",
          "873:    mask |= POLLOUT | POLLWRNORM | POLLWRBAND;",
          "875:  } else if (sock->type == SOCK_STREAM) {",
          "876:   lock_sock(sk);",
          "881:   if (sk->sk_state == SS_LISTEN",
          "882:       && !vsock_is_accept_queue_empty(sk))",
          "883:    mask |= POLLIN | POLLRDNORM;",
          "886:   if (transport->stream_is_active(vsk) &&",
          "887:       !(sk->sk_shutdown & RCV_SHUTDOWN)) {",
          "888:    bool data_ready_now = false;",
          "889:    int ret = transport->notify_poll_in(",
          "890:      vsk, 1, &data_ready_now);",
          "891:    if (ret < 0) {",
          "892:     mask |= POLLERR;",
          "893:    } else {",
          "894:     if (data_ready_now)",
          "895:      mask |= POLLIN | POLLRDNORM;",
          "897:    }",
          "898:   }",
          "904:   if (sk->sk_shutdown & RCV_SHUTDOWN ||",
          "905:       vsk->peer_shutdown & SEND_SHUTDOWN) {",
          "906:    mask |= POLLIN | POLLRDNORM;",
          "907:   }",
          "910:   if (sk->sk_state == SS_CONNECTED) {",
          "911:    if (!(sk->sk_shutdown & SEND_SHUTDOWN)) {",
          "912:     bool space_avail_now = false;",
          "913:     int ret = transport->notify_poll_out(",
          "914:       vsk, 1, &space_avail_now);",
          "915:     if (ret < 0) {",
          "916:      mask |= POLLERR;",
          "917:     } else {",
          "918:      if (space_avail_now)",
          "922:       mask |= POLLOUT | POLLWRNORM;",
          "924:     }",
          "925:    }",
          "926:   }",
          "932:   if (sk->sk_state == SS_UNCONNECTED) {",
          "933:    if (!(sk->sk_shutdown & SEND_SHUTDOWN))",
          "934:     mask |= POLLOUT | POLLWRNORM;",
          "936:   }",
          "938:   release_sock(sk);",
          "939:  }",
          "941:  return mask;",
          "942: }",
          "944: static int vsock_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,",
          "945:           struct msghdr *msg, size_t len)",
          "946: {",
          "947:  int err;",
          "948:  struct sock *sk;",
          "949:  struct vsock_sock *vsk;",
          "950:  struct sockaddr_vm *remote_addr;",
          "952:  if (msg->msg_flags & MSG_OOB)",
          "953:   return -EOPNOTSUPP;",
          "956:  err = 0;",
          "957:  sk = sock->sk;",
          "958:  vsk = vsock_sk(sk);",
          "960:  lock_sock(sk);",
          "962:  if (!vsock_addr_bound(&vsk->local_addr)) {",
          "963:   struct sockaddr_vm local_addr;",
          "965:   vsock_addr_init(&local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);",
          "966:   err = __vsock_bind(sk, &local_addr);",
          "967:   if (err != 0)",
          "968:    goto out;",
          "970:  }",
          "975:  if (msg->msg_name &&",
          "976:      vsock_addr_cast(msg->msg_name, msg->msg_namelen,",
          "977:        &remote_addr) == 0) {",
          "982:   if (remote_addr->svm_cid == VMADDR_CID_ANY)",
          "983:    remote_addr->svm_cid = transport->get_local_cid();",
          "985:   if (!vsock_addr_bound(remote_addr)) {",
          "986:    err = -EINVAL;",
          "987:    goto out;",
          "988:   }",
          "989:  } else if (sock->state == SS_CONNECTED) {",
          "990:   remote_addr = &vsk->remote_addr;",
          "992:   if (remote_addr->svm_cid == VMADDR_CID_ANY)",
          "993:    remote_addr->svm_cid = transport->get_local_cid();",
          "998:   if (!vsock_addr_bound(&vsk->remote_addr)) {",
          "999:    err = -EINVAL;",
          "1000:    goto out;",
          "1001:   }",
          "1002:  } else {",
          "1003:   err = -EINVAL;",
          "1004:   goto out;",
          "1005:  }",
          "1007:  if (!transport->dgram_allow(remote_addr->svm_cid,",
          "1008:         remote_addr->svm_port)) {",
          "1009:   err = -EINVAL;",
          "1010:   goto out;",
          "1011:  }",
          "1013:  err = transport->dgram_enqueue(vsk, remote_addr, msg->msg_iov, len);",
          "1015: out:",
          "1016:  release_sock(sk);",
          "1017:  return err;",
          "1018: }",
          "1020: static int vsock_dgram_connect(struct socket *sock,",
          "1021:           struct sockaddr *addr, int addr_len, int flags)",
          "1022: {",
          "1023:  int err;",
          "1024:  struct sock *sk;",
          "1025:  struct vsock_sock *vsk;",
          "1026:  struct sockaddr_vm *remote_addr;",
          "1028:  sk = sock->sk;",
          "1029:  vsk = vsock_sk(sk);",
          "1031:  err = vsock_addr_cast(addr, addr_len, &remote_addr);",
          "1032:  if (err == -EAFNOSUPPORT && remote_addr->svm_family == AF_UNSPEC) {",
          "1033:   lock_sock(sk);",
          "1034:   vsock_addr_init(&vsk->remote_addr, VMADDR_CID_ANY,",
          "1035:     VMADDR_PORT_ANY);",
          "1036:   sock->state = SS_UNCONNECTED;",
          "1037:   release_sock(sk);",
          "1038:   return 0;",
          "1039:  } else if (err != 0)",
          "1040:   return -EINVAL;",
          "1042:  lock_sock(sk);",
          "1044:  if (!vsock_addr_bound(&vsk->local_addr)) {",
          "1045:   struct sockaddr_vm local_addr;",
          "1047:   vsock_addr_init(&local_addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);",
          "1048:   err = __vsock_bind(sk, &local_addr);",
          "1049:   if (err != 0)",
          "1050:    goto out;",
          "1052:  }",
          "1054:  if (!transport->dgram_allow(remote_addr->svm_cid,",
          "1055:         remote_addr->svm_port)) {",
          "1056:   err = -EINVAL;",
          "1057:   goto out;",
          "1058:  }",
          "1060:  memcpy(&vsk->remote_addr, remote_addr, sizeof(vsk->remote_addr));",
          "1061:  sock->state = SS_CONNECTED;",
          "1063: out:",
          "1064:  release_sock(sk);",
          "1065:  return err;",
          "1066: }",
          "1068: static int vsock_dgram_recvmsg(struct kiocb *kiocb, struct socket *sock,",
          "1069:           struct msghdr *msg, size_t len, int flags)",
          "1070: {",
          "1071:  return transport->dgram_dequeue(kiocb, vsock_sk(sock->sk), msg, len,",
          "1072:      flags);",
          "1073: }",
          "1075: static const struct proto_ops vsock_dgram_ops = {",
          "1076:  .family = PF_VSOCK,",
          "1077:  .owner = THIS_MODULE,",
          "1078:  .release = vsock_release,",
          "1079:  .bind = vsock_bind,",
          "1080:  .connect = vsock_dgram_connect,",
          "1081:  .socketpair = sock_no_socketpair,",
          "1082:  .accept = sock_no_accept,",
          "1083:  .getname = vsock_getname,",
          "1084:  .poll = vsock_poll,",
          "1085:  .ioctl = sock_no_ioctl,",
          "1086:  .listen = sock_no_listen,",
          "1087:  .shutdown = vsock_shutdown,",
          "1088:  .setsockopt = sock_no_setsockopt,",
          "1089:  .getsockopt = sock_no_getsockopt,",
          "1090:  .sendmsg = vsock_dgram_sendmsg,",
          "1091:  .recvmsg = vsock_dgram_recvmsg,",
          "1092:  .mmap = sock_no_mmap,",
          "1093:  .sendpage = sock_no_sendpage,",
          "1094: };",
          "1096: static void vsock_connect_timeout(struct work_struct *work)",
          "1097: {",
          "1098:  struct sock *sk;",
          "1099:  struct vsock_sock *vsk;",
          "1101:  vsk = container_of(work, struct vsock_sock, dwork.work);",
          "1102:  sk = sk_vsock(vsk);",
          "1104:  lock_sock(sk);",
          "1105:  if (sk->sk_state == SS_CONNECTING &&",
          "1106:      (sk->sk_shutdown != SHUTDOWN_MASK)) {",
          "1107:   sk->sk_state = SS_UNCONNECTED;",
          "1108:   sk->sk_err = ETIMEDOUT;",
          "1109:   sk->sk_error_report(sk);",
          "1110:  }",
          "1111:  release_sock(sk);",
          "1113:  sock_put(sk);",
          "1114: }",
          "1116: static int vsock_stream_connect(struct socket *sock, struct sockaddr *addr,",
          "1117:     int addr_len, int flags)",
          "1118: {",
          "1119:  int err;",
          "1120:  struct sock *sk;",
          "1121:  struct vsock_sock *vsk;",
          "1122:  struct sockaddr_vm *remote_addr;",
          "1123:  long timeout;",
          "1124:  DEFINE_WAIT(wait);",
          "1126:  err = 0;",
          "1127:  sk = sock->sk;",
          "1128:  vsk = vsock_sk(sk);",
          "1130:  lock_sock(sk);",
          "1133:  switch (sock->state) {",
          "1134:  case SS_CONNECTED:",
          "1135:   err = -EISCONN;",
          "1136:   goto out;",
          "1137:  case SS_DISCONNECTING:",
          "1138:   err = -EINVAL;",
          "1139:   goto out;",
          "1140:  case SS_CONNECTING:",
          "1147:   err = -EALREADY;",
          "1148:   break;",
          "1149:  default:",
          "1150:   if ((sk->sk_state == SS_LISTEN) ||",
          "1151:       vsock_addr_cast(addr, addr_len, &remote_addr) != 0) {",
          "1152:    err = -EINVAL;",
          "1153:    goto out;",
          "1154:   }",
          "1159:   if (!transport->stream_allow(remote_addr->svm_cid,",
          "1160:           remote_addr->svm_port)) {",
          "1161:    err = -ENETUNREACH;",
          "1162:    goto out;",
          "1163:   }",
          "1166:   memcpy(&vsk->remote_addr, remote_addr,",
          "1167:          sizeof(vsk->remote_addr));",
          "1170:   if (!vsock_addr_bound(&vsk->local_addr)) {",
          "1171:    struct sockaddr_vm local_addr;",
          "1173:    vsock_addr_init(&local_addr, VMADDR_CID_ANY,",
          "1174:      VMADDR_PORT_ANY);",
          "1175:    err = __vsock_bind(sk, &local_addr);",
          "1176:    if (err != 0)",
          "1177:     goto out;",
          "1179:   }",
          "1181:   sk->sk_state = SS_CONNECTING;",
          "1183:   err = transport->connect(vsk);",
          "1184:   if (err < 0)",
          "1185:    goto out;",
          "1190:   sock->state = SS_CONNECTING;",
          "1191:   err = -EINPROGRESS;",
          "1192:  }",
          "1198:  timeout = vsk->connect_timeout;",
          "1199:  prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);",
          "1201:  while (sk->sk_state != SS_CONNECTED && sk->sk_err == 0) {",
          "1202:   if (flags & O_NONBLOCK) {",
          "1209:    sock_hold(sk);",
          "1210:    INIT_DELAYED_WORK(&vsk->dwork,",
          "1211:        vsock_connect_timeout);",
          "1212:    schedule_delayed_work(&vsk->dwork, timeout);",
          "1215:    goto out_wait;",
          "1216:   }",
          "1218:   release_sock(sk);",
          "1219:   timeout = schedule_timeout(timeout);",
          "1220:   lock_sock(sk);",
          "1222:   if (signal_pending(current)) {",
          "1223:    err = sock_intr_errno(timeout);",
          "1224:    goto out_wait_error;",
          "1225:   } else if (timeout == 0) {",
          "1226:    err = -ETIMEDOUT;",
          "1227:    goto out_wait_error;",
          "1228:   }",
          "1230:   prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);",
          "1231:  }",
          "1233:  if (sk->sk_err) {",
          "1234:   err = -sk->sk_err;",
          "1235:   goto out_wait_error;",
          "1236:  } else",
          "1237:   err = 0;",
          "1239: out_wait:",
          "1240:  finish_wait(sk_sleep(sk), &wait);",
          "1241: out:",
          "1242:  release_sock(sk);",
          "1243:  return err;",
          "1245: out_wait_error:",
          "1246:  sk->sk_state = SS_UNCONNECTED;",
          "1247:  sock->state = SS_UNCONNECTED;",
          "1248:  goto out_wait;",
          "1249: }",
          "1251: static int vsock_accept(struct socket *sock, struct socket *newsock, int flags)",
          "1252: {",
          "1253:  struct sock *listener;",
          "1254:  int err;",
          "1255:  struct sock *connected;",
          "1256:  struct vsock_sock *vconnected;",
          "1257:  long timeout;",
          "1258:  DEFINE_WAIT(wait);",
          "1260:  err = 0;",
          "1261:  listener = sock->sk;",
          "1263:  lock_sock(listener);",
          "1265:  if (sock->type != SOCK_STREAM) {",
          "1266:   err = -EOPNOTSUPP;",
          "1267:   goto out;",
          "1268:  }",
          "1270:  if (listener->sk_state != SS_LISTEN) {",
          "1271:   err = -EINVAL;",
          "1272:   goto out;",
          "1273:  }",
          "1278:  timeout = sock_sndtimeo(listener, flags & O_NONBLOCK);",
          "1279:  prepare_to_wait(sk_sleep(listener), &wait, TASK_INTERRUPTIBLE);",
          "1281:  while ((connected = vsock_dequeue_accept(listener)) == NULL &&",
          "1282:         listener->sk_err == 0) {",
          "1283:   release_sock(listener);",
          "1284:   timeout = schedule_timeout(timeout);",
          "1285:   lock_sock(listener);",
          "1287:   if (signal_pending(current)) {",
          "1288:    err = sock_intr_errno(timeout);",
          "1289:    goto out_wait;",
          "1290:   } else if (timeout == 0) {",
          "1291:    err = -EAGAIN;",
          "1292:    goto out_wait;",
          "1293:   }",
          "1295:   prepare_to_wait(sk_sleep(listener), &wait, TASK_INTERRUPTIBLE);",
          "1296:  }",
          "1298:  if (listener->sk_err)",
          "1299:   err = -listener->sk_err;",
          "1301:  if (connected) {",
          "1302:   listener->sk_ack_backlog--;",
          "1304:   lock_sock(connected);",
          "1305:   vconnected = vsock_sk(connected);",
          "1314:   if (err) {",
          "1315:    vconnected->rejected = true;",
          "1316:    release_sock(connected);",
          "1317:    sock_put(connected);",
          "1318:    goto out_wait;",
          "1319:   }",
          "1321:   newsock->state = SS_CONNECTED;",
          "1322:   sock_graft(connected, newsock);",
          "1323:   release_sock(connected);",
          "1324:   sock_put(connected);",
          "1325:  }",
          "1327: out_wait:",
          "1328:  finish_wait(sk_sleep(listener), &wait);",
          "1329: out:",
          "1330:  release_sock(listener);",
          "1331:  return err;",
          "1332: }",
          "1334: static int vsock_listen(struct socket *sock, int backlog)",
          "1335: {",
          "1336:  int err;",
          "1337:  struct sock *sk;",
          "1338:  struct vsock_sock *vsk;",
          "1340:  sk = sock->sk;",
          "1342:  lock_sock(sk);",
          "1344:  if (sock->type != SOCK_STREAM) {",
          "1345:   err = -EOPNOTSUPP;",
          "1346:   goto out;",
          "1347:  }",
          "1349:  if (sock->state != SS_UNCONNECTED) {",
          "1350:   err = -EINVAL;",
          "1351:   goto out;",
          "1352:  }",
          "1354:  vsk = vsock_sk(sk);",
          "1356:  if (!vsock_addr_bound(&vsk->local_addr)) {",
          "1357:   err = -EINVAL;",
          "1358:   goto out;",
          "1359:  }",
          "1361:  sk->sk_max_ack_backlog = backlog;",
          "1362:  sk->sk_state = SS_LISTEN;",
          "1364:  err = 0;",
          "1366: out:",
          "1367:  release_sock(sk);",
          "1368:  return err;",
          "1369: }",
          "1371: static int vsock_stream_setsockopt(struct socket *sock,",
          "1372:        int level,",
          "1373:        int optname,",
          "1374:        char __user *optval,",
          "1375:        unsigned int optlen)",
          "1376: {",
          "1377:  int err;",
          "1378:  struct sock *sk;",
          "1379:  struct vsock_sock *vsk;",
          "1380:  u64 val;",
          "1382:  if (level != AF_VSOCK)",
          "1383:   return -ENOPROTOOPT;",
          "1385: #define COPY_IN(_v)                                       \\",
          "1386:  do {        \\",
          "1387:   if (optlen < sizeof(_v)) {    \\",
          "1388:    err = -EINVAL;     \\",
          "1389:    goto exit;     \\",
          "1390:   }       \\",
          "1391:   if (copy_from_user(&_v, optval, sizeof(_v)) != 0) { \\",
          "1392:    err = -EFAULT;     \\",
          "1393:    goto exit;     \\",
          "1394:   }       \\",
          "1395:  } while (0)",
          "1397:  err = 0;",
          "1398:  sk = sock->sk;",
          "1399:  vsk = vsock_sk(sk);",
          "1401:  lock_sock(sk);",
          "1403:  switch (optname) {",
          "1404:  case SO_VM_SOCKETS_BUFFER_SIZE:",
          "1405:   COPY_IN(val);",
          "1406:   transport->set_buffer_size(vsk, val);",
          "1407:   break;",
          "1409:  case SO_VM_SOCKETS_BUFFER_MAX_SIZE:",
          "1410:   COPY_IN(val);",
          "1411:   transport->set_max_buffer_size(vsk, val);",
          "1412:   break;",
          "1414:  case SO_VM_SOCKETS_BUFFER_MIN_SIZE:",
          "1415:   COPY_IN(val);",
          "1416:   transport->set_min_buffer_size(vsk, val);",
          "1417:   break;",
          "1419:  case SO_VM_SOCKETS_CONNECT_TIMEOUT: {",
          "1420:   struct timeval tv;",
          "1421:   COPY_IN(tv);",
          "1422:   if (tv.tv_sec >= 0 && tv.tv_usec < USEC_PER_SEC &&",
          "1423:       tv.tv_sec < (MAX_SCHEDULE_TIMEOUT / HZ - 1)) {",
          "1424:    vsk->connect_timeout = tv.tv_sec * HZ +",
          "1425:        DIV_ROUND_UP(tv.tv_usec, (1000000 / HZ));",
          "1426:    if (vsk->connect_timeout == 0)",
          "1427:     vsk->connect_timeout =",
          "1428:         VSOCK_DEFAULT_CONNECT_TIMEOUT;",
          "1430:   } else {",
          "1431:    err = -ERANGE;",
          "1432:   }",
          "1433:   break;",
          "1434:  }",
          "1436:  default:",
          "1437:   err = -ENOPROTOOPT;",
          "1438:   break;",
          "1439:  }",
          "1441: #undef COPY_IN",
          "1443: exit:",
          "1444:  release_sock(sk);",
          "1445:  return err;",
          "1446: }",
          "1448: static int vsock_stream_getsockopt(struct socket *sock,",
          "1449:        int level, int optname,",
          "1450:        char __user *optval,",
          "1451:        int __user *optlen)",
          "1452: {",
          "1453:  int err;",
          "1454:  int len;",
          "1455:  struct sock *sk;",
          "1456:  struct vsock_sock *vsk;",
          "1457:  u64 val;",
          "1459:  if (level != AF_VSOCK)",
          "1460:   return -ENOPROTOOPT;",
          "1462:  err = get_user(len, optlen);",
          "1463:  if (err != 0)",
          "1464:   return err;",
          "1466: #define COPY_OUT(_v)                            \\",
          "1467:  do {     \\",
          "1468:   if (len < sizeof(_v))  \\",
          "1469:    return -EINVAL;  \\",
          "1470:       \\",
          "1471:   len = sizeof(_v);  \\",
          "1472:   if (copy_to_user(optval, &_v, len) != 0) \\",
          "1473:    return -EFAULT;    \\",
          "1474:         \\",
          "1475:  } while (0)",
          "1477:  err = 0;",
          "1478:  sk = sock->sk;",
          "1479:  vsk = vsock_sk(sk);",
          "1481:  switch (optname) {",
          "1482:  case SO_VM_SOCKETS_BUFFER_SIZE:",
          "1483:   val = transport->get_buffer_size(vsk);",
          "1484:   COPY_OUT(val);",
          "1485:   break;",
          "1487:  case SO_VM_SOCKETS_BUFFER_MAX_SIZE:",
          "1488:   val = transport->get_max_buffer_size(vsk);",
          "1489:   COPY_OUT(val);",
          "1490:   break;",
          "1492:  case SO_VM_SOCKETS_BUFFER_MIN_SIZE:",
          "1493:   val = transport->get_min_buffer_size(vsk);",
          "1494:   COPY_OUT(val);",
          "1495:   break;",
          "1497:  case SO_VM_SOCKETS_CONNECT_TIMEOUT: {",
          "1498:   struct timeval tv;",
          "1499:   tv.tv_sec = vsk->connect_timeout / HZ;",
          "1500:   tv.tv_usec =",
          "1501:       (vsk->connect_timeout -",
          "1502:        tv.tv_sec * HZ) * (1000000 / HZ);",
          "1503:   COPY_OUT(tv);",
          "1504:   break;",
          "1505:  }",
          "1506:  default:",
          "1507:   return -ENOPROTOOPT;",
          "1508:  }",
          "1510:  err = put_user(len, optlen);",
          "1511:  if (err != 0)",
          "1512:   return -EFAULT;",
          "1514: #undef COPY_OUT",
          "1516:  return 0;",
          "1517: }",
          "1519: static int vsock_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,",
          "1520:     struct msghdr *msg, size_t len)",
          "1521: {",
          "1522:  struct sock *sk;",
          "1523:  struct vsock_sock *vsk;",
          "1524:  ssize_t total_written;",
          "1525:  long timeout;",
          "1526:  int err;",
          "1527:  struct vsock_transport_send_notify_data send_data;",
          "1529:  DEFINE_WAIT(wait);",
          "1531:  sk = sock->sk;",
          "1532:  vsk = vsock_sk(sk);",
          "1533:  total_written = 0;",
          "1534:  err = 0;",
          "1536:  if (msg->msg_flags & MSG_OOB)",
          "1537:   return -EOPNOTSUPP;",
          "1539:  lock_sock(sk);",
          "1542:  if (msg->msg_namelen) {",
          "1543:   err = sk->sk_state == SS_CONNECTED ? -EISCONN : -EOPNOTSUPP;",
          "1544:   goto out;",
          "1545:  }",
          "1548:  if (sk->sk_shutdown & SEND_SHUTDOWN ||",
          "1549:      vsk->peer_shutdown & RCV_SHUTDOWN) {",
          "1550:   err = -EPIPE;",
          "1551:   goto out;",
          "1552:  }",
          "1554:  if (sk->sk_state != SS_CONNECTED ||",
          "1555:      !vsock_addr_bound(&vsk->local_addr)) {",
          "1556:   err = -ENOTCONN;",
          "1557:   goto out;",
          "1558:  }",
          "1560:  if (!vsock_addr_bound(&vsk->remote_addr)) {",
          "1561:   err = -EDESTADDRREQ;",
          "1562:   goto out;",
          "1563:  }",
          "1566:  timeout = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);",
          "1568:  err = transport->notify_send_init(vsk, &send_data);",
          "1569:  if (err < 0)",
          "1570:   goto out;",
          "1572:  prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);",
          "1574:  while (total_written < len) {",
          "1575:   ssize_t written;",
          "1577:   while (vsock_stream_has_space(vsk) == 0 &&",
          "1578:          sk->sk_err == 0 &&",
          "1579:          !(sk->sk_shutdown & SEND_SHUTDOWN) &&",
          "1580:          !(vsk->peer_shutdown & RCV_SHUTDOWN)) {",
          "1583:    if (timeout == 0) {",
          "1584:     err = -EAGAIN;",
          "1585:     goto out_wait;",
          "1586:    }",
          "1588:    err = transport->notify_send_pre_block(vsk, &send_data);",
          "1589:    if (err < 0)",
          "1590:     goto out_wait;",
          "1592:    release_sock(sk);",
          "1593:    timeout = schedule_timeout(timeout);",
          "1594:    lock_sock(sk);",
          "1595:    if (signal_pending(current)) {",
          "1596:     err = sock_intr_errno(timeout);",
          "1597:     goto out_wait;",
          "1598:    } else if (timeout == 0) {",
          "1599:     err = -EAGAIN;",
          "1600:     goto out_wait;",
          "1601:    }",
          "1603:    prepare_to_wait(sk_sleep(sk), &wait,",
          "1604:      TASK_INTERRUPTIBLE);",
          "1605:   }",
          "1611:   if (sk->sk_err) {",
          "1612:    err = -sk->sk_err;",
          "1613:    goto out_wait;",
          "1614:   } else if ((sk->sk_shutdown & SEND_SHUTDOWN) ||",
          "1615:       (vsk->peer_shutdown & RCV_SHUTDOWN)) {",
          "1616:    err = -EPIPE;",
          "1617:    goto out_wait;",
          "1618:   }",
          "1620:   err = transport->notify_send_pre_enqueue(vsk, &send_data);",
          "1621:   if (err < 0)",
          "1622:    goto out_wait;",
          "1630:   written = transport->stream_enqueue(",
          "1631:     vsk, msg->msg_iov,",
          "1632:     len - total_written);",
          "1633:   if (written < 0) {",
          "1634:    err = -ENOMEM;",
          "1635:    goto out_wait;",
          "1636:   }",
          "1638:   total_written += written;",
          "1640:   err = transport->notify_send_post_enqueue(",
          "1641:     vsk, written, &send_data);",
          "1642:   if (err < 0)",
          "1643:    goto out_wait;",
          "1645:  }",
          "1647: out_wait:",
          "1648:  if (total_written > 0)",
          "1649:   err = total_written;",
          "1650:  finish_wait(sk_sleep(sk), &wait);",
          "1651: out:",
          "1652:  release_sock(sk);",
          "1653:  return err;",
          "1654: }",
          "1657: static int",
          "1658: vsock_stream_recvmsg(struct kiocb *kiocb,",
          "1659:        struct socket *sock,",
          "1660:        struct msghdr *msg, size_t len, int flags)",
          "1661: {",
          "1662:  struct sock *sk;",
          "1663:  struct vsock_sock *vsk;",
          "1664:  int err;",
          "1665:  size_t target;",
          "1666:  ssize_t copied;",
          "1667:  long timeout;",
          "1668:  struct vsock_transport_recv_notify_data recv_data;",
          "1670:  DEFINE_WAIT(wait);",
          "1672:  sk = sock->sk;",
          "1673:  vsk = vsock_sk(sk);",
          "1674:  err = 0;",
          "1676:  lock_sock(sk);",
          "1678:  if (sk->sk_state != SS_CONNECTED) {",
          "1684:   if (sock_flag(sk, SOCK_DONE))",
          "1685:    err = 0;",
          "1686:   else",
          "1687:    err = -ENOTCONN;",
          "1689:   goto out;",
          "1690:  }",
          "1692:  if (flags & MSG_OOB) {",
          "1693:   err = -EOPNOTSUPP;",
          "1694:   goto out;",
          "1695:  }",
          "1701:  if (sk->sk_shutdown & RCV_SHUTDOWN) {",
          "1702:   err = 0;",
          "1703:   goto out;",
          "1704:  }",
          "1709:  if (!len) {",
          "1710:   err = 0;",
          "1711:   goto out;",
          "1712:  }",
          "1720:  target = sock_rcvlowat(sk, flags & MSG_WAITALL, len);",
          "1721:  if (target >= transport->stream_rcvhiwat(vsk)) {",
          "1722:   err = -ENOMEM;",
          "1723:   goto out;",
          "1724:  }",
          "1725:  timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);",
          "1726:  copied = 0;",
          "1728:  err = transport->notify_recv_init(vsk, target, &recv_data);",
          "1729:  if (err < 0)",
          "1730:   goto out;",
          "1732:  prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);",
          "1734:  while (1) {",
          "1735:   s64 ready = vsock_stream_has_data(vsk);",
          "1737:   if (ready < 0) {",
          "1742:    err = -ENOMEM;",
          "1743:    goto out_wait;",
          "1744:   } else if (ready > 0) {",
          "1745:    ssize_t read;",
          "1747:    err = transport->notify_recv_pre_dequeue(",
          "1748:      vsk, target, &recv_data);",
          "1749:    if (err < 0)",
          "1750:     break;",
          "1752:    read = transport->stream_dequeue(",
          "1753:      vsk, msg->msg_iov,",
          "1754:      len - copied, flags);",
          "1755:    if (read < 0) {",
          "1756:     err = -ENOMEM;",
          "1757:     break;",
          "1758:    }",
          "1760:    copied += read;",
          "1762:    err = transport->notify_recv_post_dequeue(",
          "1763:      vsk, target, read,",
          "1764:      !(flags & MSG_PEEK), &recv_data);",
          "1765:    if (err < 0)",
          "1766:     goto out_wait;",
          "1768:    if (read >= target || flags & MSG_PEEK)",
          "1769:     break;",
          "1771:    target -= read;",
          "1772:   } else {",
          "1773:    if (sk->sk_err != 0 || (sk->sk_shutdown & RCV_SHUTDOWN)",
          "1774:        || (vsk->peer_shutdown & SEND_SHUTDOWN)) {",
          "1775:     break;",
          "1776:    }",
          "1778:    if (timeout == 0) {",
          "1779:     err = -EAGAIN;",
          "1780:     break;",
          "1781:    }",
          "1783:    err = transport->notify_recv_pre_block(",
          "1784:      vsk, target, &recv_data);",
          "1785:    if (err < 0)",
          "1786:     break;",
          "1788:    release_sock(sk);",
          "1789:    timeout = schedule_timeout(timeout);",
          "1790:    lock_sock(sk);",
          "1792:    if (signal_pending(current)) {",
          "1793:     err = sock_intr_errno(timeout);",
          "1794:     break;",
          "1795:    } else if (timeout == 0) {",
          "1796:     err = -EAGAIN;",
          "1797:     break;",
          "1798:    }",
          "1800:    prepare_to_wait(sk_sleep(sk), &wait,",
          "1801:      TASK_INTERRUPTIBLE);",
          "1802:   }",
          "1803:  }",
          "1805:  if (sk->sk_err)",
          "1806:   err = -sk->sk_err;",
          "1807:  else if (sk->sk_shutdown & RCV_SHUTDOWN)",
          "1808:   err = 0;",
          "1810:  if (copied > 0) {",
          "1816:   if (!(flags & MSG_PEEK)) {",
          "1821:    if (vsk->peer_shutdown & SEND_SHUTDOWN) {",
          "1822:     if (vsock_stream_has_data(vsk) <= 0) {",
          "1823:      sk->sk_state = SS_UNCONNECTED;",
          "1824:      sock_set_flag(sk, SOCK_DONE);",
          "1825:      sk->sk_state_change(sk);",
          "1826:     }",
          "1827:    }",
          "1828:   }",
          "1829:   err = copied;",
          "1830:  }",
          "1832: out_wait:",
          "1833:  finish_wait(sk_sleep(sk), &wait);",
          "1834: out:",
          "1835:  release_sock(sk);",
          "1836:  return err;",
          "1837: }",
          "1839: static const struct proto_ops vsock_stream_ops = {",
          "1840:  .family = PF_VSOCK,",
          "1841:  .owner = THIS_MODULE,",
          "1842:  .release = vsock_release,",
          "1843:  .bind = vsock_bind,",
          "1844:  .connect = vsock_stream_connect,",
          "1845:  .socketpair = sock_no_socketpair,",
          "1846:  .accept = vsock_accept,",
          "1847:  .getname = vsock_getname,",
          "1848:  .poll = vsock_poll,",
          "1849:  .ioctl = sock_no_ioctl,",
          "1850:  .listen = vsock_listen,",
          "1851:  .shutdown = vsock_shutdown,",
          "1852:  .setsockopt = vsock_stream_setsockopt,",
          "1853:  .getsockopt = vsock_stream_getsockopt,",
          "1854:  .sendmsg = vsock_stream_sendmsg,",
          "1855:  .recvmsg = vsock_stream_recvmsg,",
          "1856:  .mmap = sock_no_mmap,",
          "1857:  .sendpage = sock_no_sendpage,",
          "1858: };",
          "1860: static int vsock_create(struct net *net, struct socket *sock,",
          "1861:    int protocol, int kern)",
          "1862: {",
          "1863:  if (!sock)",
          "1864:   return -EINVAL;",
          "1866:  if (protocol)",
          "1867:   return -EPROTONOSUPPORT;",
          "1869:  switch (sock->type) {",
          "1870:  case SOCK_DGRAM:",
          "1871:   sock->ops = &vsock_dgram_ops;",
          "1872:   break;",
          "1873:  case SOCK_STREAM:",
          "1874:   sock->ops = &vsock_stream_ops;",
          "1875:   break;",
          "1876:  default:",
          "1877:   return -ESOCKTNOSUPPORT;",
          "1878:  }",
          "1880:  sock->state = SS_UNCONNECTED;",
          "1882:  return __vsock_create(net, sock, NULL, GFP_KERNEL, 0) ? 0 : -ENOMEM;",
          "1883: }",
          "1885: static const struct net_proto_family vsock_family_ops = {",
          "1886:  .family = AF_VSOCK,",
          "1887:  .create = vsock_create,",
          "1888:  .owner = THIS_MODULE,",
          "1889: };",
          "1891: static long vsock_dev_do_ioctl(struct file *filp,",
          "1892:           unsigned int cmd, void __user *ptr)",
          "1893: {",
          "1894:  u32 __user *p = ptr;",
          "1895:  int retval = 0;",
          "1897:  switch (cmd) {",
          "1898:  case IOCTL_VM_SOCKETS_GET_LOCAL_CID:",
          "1899:   if (put_user(transport->get_local_cid(), p) != 0)",
          "1900:    retval = -EFAULT;",
          "1901:   break;",
          "1903:  default:",
          "1904:   pr_err(\"Unknown ioctl %d\\n\", cmd);",
          "1905:   retval = -EINVAL;",
          "1906:  }",
          "1908:  return retval;",
          "1909: }",
          "1911: static long vsock_dev_ioctl(struct file *filp,",
          "1912:        unsigned int cmd, unsigned long arg)",
          "1913: {",
          "1914:  return vsock_dev_do_ioctl(filp, cmd, (void __user *)arg);",
          "1915: }",
          "1917: #ifdef CONFIG_COMPAT",
          "1918: static long vsock_dev_compat_ioctl(struct file *filp,",
          "1919:        unsigned int cmd, unsigned long arg)",
          "1920: {",
          "1921:  return vsock_dev_do_ioctl(filp, cmd, compat_ptr(arg));",
          "1922: }",
          "1923: #endif",
          "1925: static const struct file_operations vsock_device_ops = {",
          "1926:  .owner  = THIS_MODULE,",
          "1927:  .unlocked_ioctl = vsock_dev_ioctl,",
          "1928: #ifdef CONFIG_COMPAT",
          "1929:  .compat_ioctl = vsock_dev_compat_ioctl,",
          "1930: #endif",
          "1931:  .open  = nonseekable_open,",
          "1932: };",
          "1934: static struct miscdevice vsock_device = {",
          "1935:  .name  = \"vsock\",",
          "1936:  .minor  = MISC_DYNAMIC_MINOR,",
          "1937:  .fops  = &vsock_device_ops,",
          "1938: };",
          "1940: static int __vsock_core_init(void)",
          "1941: {",
          "1942:  int err;",
          "1944:  vsock_init_tables();",
          "1946:  err = misc_register(&vsock_device);",
          "1947:  if (err) {",
          "1948:   pr_err(\"Failed to register misc device\\n\");",
          "1949:   return -ENOENT;",
          "1950:  }",
          "1953:  if (err) {",
          "1954:   pr_err(\"Cannot register vsock protocol\\n\");",
          "1955:   goto err_misc_deregister;",
          "1956:  }",
          "1958:  err = sock_register(&vsock_family_ops);",
          "1959:  if (err) {",
          "1960:   pr_err(\"could not register af_vsock (%d) address family: %d\\n\",",
          "1961:          AF_VSOCK, err);",
          "1962:   goto err_unregister_proto;",
          "1963:  }",
          "1965:  return 0;",
          "1967: err_unregister_proto:",
          "1968:  proto_unregister(&vsock_proto);",
          "1969: err_misc_deregister:",
          "1970:  misc_deregister(&vsock_device);",
          "1971:  return err;",
          "1972: }",
          "1974: int vsock_core_init(const struct vsock_transport *t)",
          "1975: {",
          "1976:  int retval = mutex_lock_interruptible(&vsock_register_mutex);",
          "1977:  if (retval)",
          "1978:   return retval;",
          "1980:  if (transport) {",
          "1981:   retval = -EBUSY;",
          "1982:   goto out;",
          "1983:  }",
          "1985:  transport = t;",
          "1986:  retval = __vsock_core_init();",
          "1987:  if (retval)",
          "1988:   transport = NULL;",
          "1990: out:",
          "1991:  mutex_unlock(&vsock_register_mutex);",
          "1992:  return retval;",
          "1993: }",
          "1994: EXPORT_SYMBOL_GPL(vsock_core_init);",
          "1996: void vsock_core_exit(void)",
          "1997: {",
          "1998:  mutex_lock(&vsock_register_mutex);",
          "2000:  misc_deregister(&vsock_device);",
          "2001:  sock_unregister(AF_VSOCK);",
          "2002:  proto_unregister(&vsock_proto);",
          "2005:  mb();",
          "2006:  transport = NULL;",
          "2008:  mutex_unlock(&vsock_register_mutex);",
          "2009: }",
          "2010: EXPORT_SYMBOL_GPL(vsock_core_exit);",
          "2012: MODULE_AUTHOR(\"VMware, Inc.\");",
          "2013: MODULE_DESCRIPTION(\"VMware Virtual Socket Family\");",
          "2014: MODULE_VERSION(VSOCK_DRIVER_VERSION_STRING);",
          "2015: MODULE_LICENSE(\"GPL v2\");",
          "",
          "---------------"
        ],
        "net/vmw_vsock/af_vsock.h||net/vmw_vsock/af_vsock.h": [
          "File: net/vmw_vsock/af_vsock.h -> net/vmw_vsock/af_vsock.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #ifndef __AF_VSOCK_H__",
          "17: #define __AF_VSOCK_H__",
          "19: #include <linux/kernel.h>",
          "20: #include <linux/workqueue.h>",
          "21: #include <linux/vm_sockets.h>",
          "23: #include \"vsock_addr.h\"",
          "25: #define LAST_RESERVED_PORT 1023",
          "27: #define vsock_sk(__sk)    ((struct vsock_sock *)__sk)",
          "28: #define sk_vsock(__vsk)   (&(__vsk)->sk)",
          "30: struct vsock_sock {",
          "32:  struct sock sk;",
          "33:  struct sockaddr_vm local_addr;",
          "34:  struct sockaddr_vm remote_addr;",
          "36:  struct list_head bound_table;",
          "37:  struct list_head connected_table;",
          "41:  bool trusted;",
          "42:  bool cached_peer_allow_dgram; /* Dgram communication allowed to",
          "46:  const struct cred *owner;",
          "48:  long connect_timeout;",
          "50:  struct sock *listener;",
          "59:  struct list_head pending_links;",
          "60:  struct list_head accept_queue;",
          "61:  bool rejected;",
          "62:  struct delayed_work dwork;",
          "63:  u32 peer_shutdown;",
          "64:  bool sent_request;",
          "65:  bool ignore_connecting_rst;",
          "68:  void *trans;",
          "69: };",
          "71: s64 vsock_stream_has_data(struct vsock_sock *vsk);",
          "72: s64 vsock_stream_has_space(struct vsock_sock *vsk);",
          "73: void vsock_pending_work(struct work_struct *work);",
          "74: struct sock *__vsock_create(struct net *net,",
          "75:        struct socket *sock,",
          "76:        struct sock *parent,",
          "77:        gfp_t priority, unsigned short type);",
          "81: struct vsock_transport_recv_notify_data {",
          "84:  bool notify_on_block;",
          "85: };",
          "87: struct vsock_transport_send_notify_data {",
          "90: };",
          "92: struct vsock_transport {",
          "94:  int (*init)(struct vsock_sock *, struct vsock_sock *);",
          "95:  void (*destruct)(struct vsock_sock *);",
          "96:  void (*release)(struct vsock_sock *);",
          "99:  int (*connect)(struct vsock_sock *);",
          "102:  int (*dgram_bind)(struct vsock_sock *, struct sockaddr_vm *);",
          "103:  int (*dgram_dequeue)(struct kiocb *kiocb, struct vsock_sock *vsk,",
          "104:         struct msghdr *msg, size_t len, int flags);",
          "105:  int (*dgram_enqueue)(struct vsock_sock *, struct sockaddr_vm *,",
          "106:         struct iovec *, size_t len);",
          "107:  bool (*dgram_allow)(u32 cid, u32 port);",
          "111:  ssize_t (*stream_dequeue)(struct vsock_sock *, struct iovec *,",
          "112:       size_t len, int flags);",
          "113:  ssize_t (*stream_enqueue)(struct vsock_sock *, struct iovec *,",
          "114:       size_t len);",
          "115:  s64 (*stream_has_data)(struct vsock_sock *);",
          "116:  s64 (*stream_has_space)(struct vsock_sock *);",
          "117:  u64 (*stream_rcvhiwat)(struct vsock_sock *);",
          "118:  bool (*stream_is_active)(struct vsock_sock *);",
          "119:  bool (*stream_allow)(u32 cid, u32 port);",
          "122:  int (*notify_poll_in)(struct vsock_sock *, size_t, bool *);",
          "123:  int (*notify_poll_out)(struct vsock_sock *, size_t, bool *);",
          "124:  int (*notify_recv_init)(struct vsock_sock *, size_t,",
          "125:   struct vsock_transport_recv_notify_data *);",
          "126:  int (*notify_recv_pre_block)(struct vsock_sock *, size_t,",
          "127:   struct vsock_transport_recv_notify_data *);",
          "128:  int (*notify_recv_pre_dequeue)(struct vsock_sock *, size_t,",
          "129:   struct vsock_transport_recv_notify_data *);",
          "130:  int (*notify_recv_post_dequeue)(struct vsock_sock *, size_t,",
          "131:   ssize_t, bool, struct vsock_transport_recv_notify_data *);",
          "132:  int (*notify_send_init)(struct vsock_sock *,",
          "133:   struct vsock_transport_send_notify_data *);",
          "134:  int (*notify_send_pre_block)(struct vsock_sock *,",
          "135:   struct vsock_transport_send_notify_data *);",
          "136:  int (*notify_send_pre_enqueue)(struct vsock_sock *,",
          "137:   struct vsock_transport_send_notify_data *);",
          "138:  int (*notify_send_post_enqueue)(struct vsock_sock *, ssize_t,",
          "139:   struct vsock_transport_send_notify_data *);",
          "142:  int (*shutdown)(struct vsock_sock *, int);",
          "145:  void (*set_buffer_size)(struct vsock_sock *, u64);",
          "146:  void (*set_min_buffer_size)(struct vsock_sock *, u64);",
          "147:  void (*set_max_buffer_size)(struct vsock_sock *, u64);",
          "148:  u64 (*get_buffer_size)(struct vsock_sock *);",
          "149:  u64 (*get_min_buffer_size)(struct vsock_sock *);",
          "150:  u64 (*get_max_buffer_size)(struct vsock_sock *);",
          "153:  u32 (*get_local_cid)(void);",
          "154: };",
          "158: int vsock_core_init(const struct vsock_transport *t);",
          "159: void vsock_core_exit(void);",
          "163: void vsock_release_pending(struct sock *pending);",
          "164: void vsock_add_pending(struct sock *listener, struct sock *pending);",
          "165: void vsock_remove_pending(struct sock *listener, struct sock *pending);",
          "166: void vsock_enqueue_accept(struct sock *listener, struct sock *connected);",
          "167: void vsock_insert_connected(struct vsock_sock *vsk);",
          "168: void vsock_remove_bound(struct vsock_sock *vsk);",
          "169: void vsock_remove_connected(struct vsock_sock *vsk);",
          "170: struct sock *vsock_find_bound_socket(struct sockaddr_vm *addr);",
          "171: struct sock *vsock_find_connected_socket(struct sockaddr_vm *src,",
          "172:       struct sockaddr_vm *dst);",
          "173: void vsock_for_each_connected_socket(void (*fn)(struct sock *sk));",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vmci_transport.c||net/vmw_vsock/vmci_transport.c": [
          "File: net/vmw_vsock/vmci_transport.c -> net/vmw_vsock/vmci_transport.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <linux/types.h>",
          "18: #define EXPORT_SYMTAB",
          "19: #include <linux/bitops.h>",
          "20: #include <linux/cred.h>",
          "21: #include <linux/init.h>",
          "22: #include <linux/io.h>",
          "23: #include <linux/kernel.h>",
          "24: #include <linux/kmod.h>",
          "25: #include <linux/list.h>",
          "26: #include <linux/miscdevice.h>",
          "27: #include <linux/module.h>",
          "28: #include <linux/mutex.h>",
          "29: #include <linux/net.h>",
          "30: #include <linux/poll.h>",
          "31: #include <linux/skbuff.h>",
          "32: #include <linux/smp.h>",
          "33: #include <linux/socket.h>",
          "34: #include <linux/stddef.h>",
          "35: #include <linux/unistd.h>",
          "36: #include <linux/wait.h>",
          "37: #include <linux/workqueue.h>",
          "38: #include <net/sock.h>",
          "40: #include \"af_vsock.h\"",
          "41: #include \"vmci_transport_notify.h\"",
          "43: static int vmci_transport_recv_dgram_cb(void *data, struct vmci_datagram *dg);",
          "44: static int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg);",
          "45: static void vmci_transport_peer_attach_cb(u32 sub_id,",
          "46:        const struct vmci_event_data *ed,",
          "47:        void *client_data);",
          "48: static void vmci_transport_peer_detach_cb(u32 sub_id,",
          "49:        const struct vmci_event_data *ed,",
          "50:        void *client_data);",
          "51: static void vmci_transport_recv_pkt_work(struct work_struct *work);",
          "52: static int vmci_transport_recv_listen(struct sock *sk,",
          "53:           struct vmci_transport_packet *pkt);",
          "54: static int vmci_transport_recv_connecting_server(",
          "55:      struct sock *sk,",
          "56:      struct sock *pending,",
          "57:      struct vmci_transport_packet *pkt);",
          "58: static int vmci_transport_recv_connecting_client(",
          "59:      struct sock *sk,",
          "60:      struct vmci_transport_packet *pkt);",
          "61: static int vmci_transport_recv_connecting_client_negotiate(",
          "62:      struct sock *sk,",
          "63:      struct vmci_transport_packet *pkt);",
          "64: static int vmci_transport_recv_connecting_client_invalid(",
          "65:      struct sock *sk,",
          "66:      struct vmci_transport_packet *pkt);",
          "67: static int vmci_transport_recv_connected(struct sock *sk,",
          "68:       struct vmci_transport_packet *pkt);",
          "69: static bool vmci_transport_old_proto_override(bool *old_pkt_proto);",
          "70: static u16 vmci_transport_new_proto_supported_versions(void);",
          "71: static bool vmci_transport_proto_to_notify_struct(struct sock *sk, u16 *proto,",
          "72:         bool old_pkt_proto);",
          "74: struct vmci_transport_recv_pkt_info {",
          "75:  struct work_struct work;",
          "76:  struct sock *sk;",
          "77:  struct vmci_transport_packet pkt;",
          "78: };",
          "80: static struct vmci_handle vmci_transport_stream_handle = { VMCI_INVALID_ID,",
          "81:           VMCI_INVALID_ID };",
          "82: static u32 vmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;",
          "84: static int PROTOCOL_OVERRIDE = -1;",
          "86: #define VMCI_TRANSPORT_DEFAULT_QP_SIZE_MIN   128",
          "87: #define VMCI_TRANSPORT_DEFAULT_QP_SIZE       262144",
          "88: #define VMCI_TRANSPORT_DEFAULT_QP_SIZE_MAX   262144",
          "93: #define VSOCK_DEFAULT_CONNECT_TIMEOUT (2 * HZ)",
          "95: #define SS_LISTEN 255",
          "99: static s32 vmci_transport_error_to_vsock_error(s32 vmci_error)",
          "100: {",
          "101:  int err;",
          "103:  switch (vmci_error) {",
          "104:  case VMCI_ERROR_NO_MEM:",
          "105:   err = ENOMEM;",
          "106:   break;",
          "107:  case VMCI_ERROR_DUPLICATE_ENTRY:",
          "108:  case VMCI_ERROR_ALREADY_EXISTS:",
          "109:   err = EADDRINUSE;",
          "110:   break;",
          "111:  case VMCI_ERROR_NO_ACCESS:",
          "112:   err = EPERM;",
          "113:   break;",
          "114:  case VMCI_ERROR_NO_RESOURCES:",
          "115:   err = ENOBUFS;",
          "116:   break;",
          "117:  case VMCI_ERROR_INVALID_RESOURCE:",
          "118:   err = EHOSTUNREACH;",
          "119:   break;",
          "120:  case VMCI_ERROR_INVALID_ARGS:",
          "121:  default:",
          "122:   err = EINVAL;",
          "123:  }",
          "125:  return err > 0 ? -err : err;",
          "126: }",
          "128: static inline void",
          "129: vmci_transport_packet_init(struct vmci_transport_packet *pkt,",
          "130:       struct sockaddr_vm *src,",
          "131:       struct sockaddr_vm *dst,",
          "132:       u8 type,",
          "133:       u64 size,",
          "134:       u64 mode,",
          "135:       struct vmci_transport_waiting_info *wait,",
          "136:       u16 proto,",
          "137:       struct vmci_handle handle)",
          "138: {",
          "142:  pkt->dg.src = vmci_make_handle(VMADDR_CID_ANY,",
          "143:            VMCI_TRANSPORT_PACKET_RID);",
          "144:  pkt->dg.dst = vmci_make_handle(dst->svm_cid,",
          "145:            VMCI_TRANSPORT_PACKET_RID);",
          "146:  pkt->dg.payload_size = sizeof(*pkt) - sizeof(pkt->dg);",
          "147:  pkt->version = VMCI_TRANSPORT_PACKET_VERSION;",
          "148:  pkt->type = type;",
          "149:  pkt->src_port = src->svm_port;",
          "150:  pkt->dst_port = dst->svm_port;",
          "151:  memset(&pkt->proto, 0, sizeof(pkt->proto));",
          "152:  memset(&pkt->_reserved2, 0, sizeof(pkt->_reserved2));",
          "154:  switch (pkt->type) {",
          "155:  case VMCI_TRANSPORT_PACKET_TYPE_INVALID:",
          "156:   pkt->u.size = 0;",
          "157:   break;",
          "159:  case VMCI_TRANSPORT_PACKET_TYPE_REQUEST:",
          "160:  case VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE:",
          "161:   pkt->u.size = size;",
          "162:   break;",
          "164:  case VMCI_TRANSPORT_PACKET_TYPE_OFFER:",
          "165:  case VMCI_TRANSPORT_PACKET_TYPE_ATTACH:",
          "166:   pkt->u.handle = handle;",
          "167:   break;",
          "169:  case VMCI_TRANSPORT_PACKET_TYPE_WROTE:",
          "170:  case VMCI_TRANSPORT_PACKET_TYPE_READ:",
          "171:  case VMCI_TRANSPORT_PACKET_TYPE_RST:",
          "172:   pkt->u.size = 0;",
          "173:   break;",
          "175:  case VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN:",
          "176:   pkt->u.mode = mode;",
          "177:   break;",
          "179:  case VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ:",
          "180:  case VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE:",
          "181:   memcpy(&pkt->u.wait, wait, sizeof(pkt->u.wait));",
          "182:   break;",
          "184:  case VMCI_TRANSPORT_PACKET_TYPE_REQUEST2:",
          "185:  case VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2:",
          "186:   pkt->u.size = size;",
          "187:   pkt->proto = proto;",
          "188:   break;",
          "189:  }",
          "190: }",
          "192: static inline void",
          "193: vmci_transport_packet_get_addresses(struct vmci_transport_packet *pkt,",
          "194:         struct sockaddr_vm *local,",
          "195:         struct sockaddr_vm *remote)",
          "196: {",
          "197:  vsock_addr_init(local, pkt->dg.dst.context, pkt->dst_port);",
          "198:  vsock_addr_init(remote, pkt->dg.src.context, pkt->src_port);",
          "199: }",
          "201: static int",
          "202: __vmci_transport_send_control_pkt(struct vmci_transport_packet *pkt,",
          "203:       struct sockaddr_vm *src,",
          "204:       struct sockaddr_vm *dst,",
          "205:       enum vmci_transport_packet_type type,",
          "206:       u64 size,",
          "207:       u64 mode,",
          "208:       struct vmci_transport_waiting_info *wait,",
          "209:       u16 proto,",
          "210:       struct vmci_handle handle,",
          "211:       bool convert_error)",
          "212: {",
          "213:  int err;",
          "215:  vmci_transport_packet_init(pkt, src, dst, type, size, mode, wait,",
          "216:        proto, handle);",
          "217:  err = vmci_datagram_send(&pkt->dg);",
          "218:  if (convert_error && (err < 0))",
          "219:   return vmci_transport_error_to_vsock_error(err);",
          "221:  return err;",
          "222: }",
          "224: static int",
          "225: vmci_transport_reply_control_pkt_fast(struct vmci_transport_packet *pkt,",
          "226:           enum vmci_transport_packet_type type,",
          "227:           u64 size,",
          "228:           u64 mode,",
          "229:           struct vmci_transport_waiting_info *wait,",
          "230:           struct vmci_handle handle)",
          "231: {",
          "232:  struct vmci_transport_packet reply;",
          "233:  struct sockaddr_vm src, dst;",
          "235:  if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST) {",
          "236:   return 0;",
          "237:  } else {",
          "238:   vmci_transport_packet_get_addresses(pkt, &src, &dst);",
          "239:   return __vmci_transport_send_control_pkt(&reply, &src, &dst,",
          "240:         type,",
          "241:         size, mode, wait,",
          "242:         VSOCK_PROTO_INVALID,",
          "243:         handle, true);",
          "244:  }",
          "245: }",
          "247: static int",
          "248: vmci_transport_send_control_pkt_bh(struct sockaddr_vm *src,",
          "249:        struct sockaddr_vm *dst,",
          "250:        enum vmci_transport_packet_type type,",
          "251:        u64 size,",
          "252:        u64 mode,",
          "253:        struct vmci_transport_waiting_info *wait,",
          "254:        struct vmci_handle handle)",
          "255: {",
          "261:  static struct vmci_transport_packet pkt;",
          "263:  return __vmci_transport_send_control_pkt(&pkt, src, dst, type,",
          "264:        size, mode, wait,",
          "265:        VSOCK_PROTO_INVALID, handle,",
          "266:        false);",
          "267: }",
          "269: static int",
          "270: vmci_transport_send_control_pkt(struct sock *sk,",
          "271:     enum vmci_transport_packet_type type,",
          "272:     u64 size,",
          "273:     u64 mode,",
          "274:     struct vmci_transport_waiting_info *wait,",
          "275:     u16 proto,",
          "276:     struct vmci_handle handle)",
          "277: {",
          "278:  struct vmci_transport_packet *pkt;",
          "279:  struct vsock_sock *vsk;",
          "280:  int err;",
          "282:  vsk = vsock_sk(sk);",
          "284:  if (!vsock_addr_bound(&vsk->local_addr))",
          "285:   return -EINVAL;",
          "287:  if (!vsock_addr_bound(&vsk->remote_addr))",
          "288:   return -EINVAL;",
          "290:  pkt = kmalloc(sizeof(*pkt), GFP_KERNEL);",
          "291:  if (!pkt)",
          "292:   return -ENOMEM;",
          "294:  err = __vmci_transport_send_control_pkt(pkt, &vsk->local_addr,",
          "295:       &vsk->remote_addr, type, size,",
          "296:       mode, wait, proto, handle,",
          "297:       true);",
          "298:  kfree(pkt);",
          "300:  return err;",
          "301: }",
          "303: static int vmci_transport_send_reset_bh(struct sockaddr_vm *dst,",
          "304:      struct sockaddr_vm *src,",
          "305:      struct vmci_transport_packet *pkt)",
          "306: {",
          "307:  if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST)",
          "308:   return 0;",
          "309:  return vmci_transport_send_control_pkt_bh(",
          "310:      dst, src,",
          "311:      VMCI_TRANSPORT_PACKET_TYPE_RST, 0,",
          "312:      0, NULL, VMCI_INVALID_HANDLE);",
          "313: }",
          "315: static int vmci_transport_send_reset(struct sock *sk,",
          "316:          struct vmci_transport_packet *pkt)",
          "317: {",
          "318:  if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST)",
          "319:   return 0;",
          "320:  return vmci_transport_send_control_pkt(sk,",
          "321:      VMCI_TRANSPORT_PACKET_TYPE_RST,",
          "322:      0, 0, NULL, VSOCK_PROTO_INVALID,",
          "323:      VMCI_INVALID_HANDLE);",
          "324: }",
          "326: static int vmci_transport_send_negotiate(struct sock *sk, size_t size)",
          "327: {",
          "328:  return vmci_transport_send_control_pkt(",
          "329:      sk,",
          "330:      VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE,",
          "331:      size, 0, NULL,",
          "332:      VSOCK_PROTO_INVALID,",
          "333:      VMCI_INVALID_HANDLE);",
          "334: }",
          "336: static int vmci_transport_send_negotiate2(struct sock *sk, size_t size,",
          "337:        u16 version)",
          "338: {",
          "339:  return vmci_transport_send_control_pkt(",
          "340:      sk,",
          "341:      VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2,",
          "342:      size, 0, NULL, version,",
          "343:      VMCI_INVALID_HANDLE);",
          "344: }",
          "346: static int vmci_transport_send_qp_offer(struct sock *sk,",
          "347:      struct vmci_handle handle)",
          "348: {",
          "349:  return vmci_transport_send_control_pkt(",
          "350:      sk, VMCI_TRANSPORT_PACKET_TYPE_OFFER, 0,",
          "351:      0, NULL,",
          "352:      VSOCK_PROTO_INVALID, handle);",
          "353: }",
          "355: static int vmci_transport_send_attach(struct sock *sk,",
          "356:           struct vmci_handle handle)",
          "357: {",
          "358:  return vmci_transport_send_control_pkt(",
          "359:      sk, VMCI_TRANSPORT_PACKET_TYPE_ATTACH,",
          "360:      0, 0, NULL, VSOCK_PROTO_INVALID,",
          "361:      handle);",
          "362: }",
          "364: static int vmci_transport_reply_reset(struct vmci_transport_packet *pkt)",
          "365: {",
          "366:  return vmci_transport_reply_control_pkt_fast(",
          "367:       pkt,",
          "368:       VMCI_TRANSPORT_PACKET_TYPE_RST,",
          "369:       0, 0, NULL,",
          "370:       VMCI_INVALID_HANDLE);",
          "371: }",
          "373: static int vmci_transport_send_invalid_bh(struct sockaddr_vm *dst,",
          "374:        struct sockaddr_vm *src)",
          "375: {",
          "376:  return vmci_transport_send_control_pkt_bh(",
          "377:      dst, src,",
          "378:      VMCI_TRANSPORT_PACKET_TYPE_INVALID,",
          "379:      0, 0, NULL, VMCI_INVALID_HANDLE);",
          "380: }",
          "382: int vmci_transport_send_wrote_bh(struct sockaddr_vm *dst,",
          "383:      struct sockaddr_vm *src)",
          "384: {",
          "385:  return vmci_transport_send_control_pkt_bh(",
          "386:      dst, src,",
          "387:      VMCI_TRANSPORT_PACKET_TYPE_WROTE, 0,",
          "388:      0, NULL, VMCI_INVALID_HANDLE);",
          "389: }",
          "391: int vmci_transport_send_read_bh(struct sockaddr_vm *dst,",
          "392:     struct sockaddr_vm *src)",
          "393: {",
          "394:  return vmci_transport_send_control_pkt_bh(",
          "395:      dst, src,",
          "396:      VMCI_TRANSPORT_PACKET_TYPE_READ, 0,",
          "397:      0, NULL, VMCI_INVALID_HANDLE);",
          "398: }",
          "400: int vmci_transport_send_wrote(struct sock *sk)",
          "401: {",
          "402:  return vmci_transport_send_control_pkt(",
          "403:      sk, VMCI_TRANSPORT_PACKET_TYPE_WROTE, 0,",
          "404:      0, NULL, VSOCK_PROTO_INVALID,",
          "405:      VMCI_INVALID_HANDLE);",
          "406: }",
          "408: int vmci_transport_send_read(struct sock *sk)",
          "409: {",
          "410:  return vmci_transport_send_control_pkt(",
          "411:      sk, VMCI_TRANSPORT_PACKET_TYPE_READ, 0,",
          "412:      0, NULL, VSOCK_PROTO_INVALID,",
          "413:      VMCI_INVALID_HANDLE);",
          "414: }",
          "416: int vmci_transport_send_waiting_write(struct sock *sk,",
          "417:           struct vmci_transport_waiting_info *wait)",
          "418: {",
          "419:  return vmci_transport_send_control_pkt(",
          "420:     sk, VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE,",
          "421:     0, 0, wait, VSOCK_PROTO_INVALID,",
          "422:     VMCI_INVALID_HANDLE);",
          "423: }",
          "425: int vmci_transport_send_waiting_read(struct sock *sk,",
          "426:          struct vmci_transport_waiting_info *wait)",
          "427: {",
          "428:  return vmci_transport_send_control_pkt(",
          "429:     sk, VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ,",
          "430:     0, 0, wait, VSOCK_PROTO_INVALID,",
          "431:     VMCI_INVALID_HANDLE);",
          "432: }",
          "434: static int vmci_transport_shutdown(struct vsock_sock *vsk, int mode)",
          "435: {",
          "436:  return vmci_transport_send_control_pkt(",
          "437:      &vsk->sk,",
          "438:      VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN,",
          "439:      0, mode, NULL,",
          "440:      VSOCK_PROTO_INVALID,",
          "441:      VMCI_INVALID_HANDLE);",
          "442: }",
          "444: static int vmci_transport_send_conn_request(struct sock *sk, size_t size)",
          "445: {",
          "446:  return vmci_transport_send_control_pkt(sk,",
          "447:      VMCI_TRANSPORT_PACKET_TYPE_REQUEST,",
          "448:      size, 0, NULL,",
          "449:      VSOCK_PROTO_INVALID,",
          "450:      VMCI_INVALID_HANDLE);",
          "451: }",
          "453: static int vmci_transport_send_conn_request2(struct sock *sk, size_t size,",
          "454:           u16 version)",
          "455: {",
          "456:  return vmci_transport_send_control_pkt(",
          "457:      sk, VMCI_TRANSPORT_PACKET_TYPE_REQUEST2,",
          "458:      size, 0, NULL, version,",
          "459:      VMCI_INVALID_HANDLE);",
          "460: }",
          "462: static struct sock *vmci_transport_get_pending(",
          "463:      struct sock *listener,",
          "464:      struct vmci_transport_packet *pkt)",
          "465: {",
          "466:  struct vsock_sock *vlistener;",
          "467:  struct vsock_sock *vpending;",
          "468:  struct sock *pending;",
          "470:  vlistener = vsock_sk(listener);",
          "472:  list_for_each_entry(vpending, &vlistener->pending_links,",
          "473:        pending_links) {",
          "474:   struct sockaddr_vm src;",
          "475:   struct sockaddr_vm dst;",
          "477:   vsock_addr_init(&src, pkt->dg.src.context, pkt->src_port);",
          "478:   vsock_addr_init(&dst, pkt->dg.dst.context, pkt->dst_port);",
          "480:   if (vsock_addr_equals_addr(&src, &vpending->remote_addr) &&",
          "481:       vsock_addr_equals_addr(&dst, &vpending->local_addr)) {",
          "482:    pending = sk_vsock(vpending);",
          "483:    sock_hold(pending);",
          "484:    goto found;",
          "485:   }",
          "486:  }",
          "488:  pending = NULL;",
          "489: found:",
          "490:  return pending;",
          "492: }",
          "494: static void vmci_transport_release_pending(struct sock *pending)",
          "495: {",
          "496:  sock_put(pending);",
          "497: }",
          "504: static bool vmci_transport_is_trusted(struct vsock_sock *vsock, u32 peer_cid)",
          "505: {",
          "506:  return vsock->trusted ||",
          "507:         vmci_is_context_owner(peer_cid, vsock->owner->uid);",
          "508: }",
          "514: static bool vmci_transport_allow_dgram(struct vsock_sock *vsock, u32 peer_cid)",
          "515: {",
          "516:  if (vsock->cached_peer != peer_cid) {",
          "517:   vsock->cached_peer = peer_cid;",
          "518:   if (!vmci_transport_is_trusted(vsock, peer_cid) &&",
          "519:       (vmci_context_get_priv_flags(peer_cid) &",
          "520:        VMCI_PRIVILEGE_FLAG_RESTRICTED)) {",
          "521:    vsock->cached_peer_allow_dgram = false;",
          "522:   } else {",
          "523:    vsock->cached_peer_allow_dgram = true;",
          "524:   }",
          "525:  }",
          "527:  return vsock->cached_peer_allow_dgram;",
          "528: }",
          "530: static int",
          "531: vmci_transport_queue_pair_alloc(struct vmci_qp **qpair,",
          "532:     struct vmci_handle *handle,",
          "533:     u64 produce_size,",
          "534:     u64 consume_size,",
          "535:     u32 peer, u32 flags, bool trusted)",
          "536: {",
          "537:  int err = 0;",
          "539:  if (trusted) {",
          "544:   err = vmci_qpair_alloc(qpair, handle, produce_size,",
          "545:            consume_size,",
          "546:            peer, flags,",
          "547:            VMCI_PRIVILEGE_FLAG_TRUSTED);",
          "548:   if (err != VMCI_ERROR_NO_ACCESS)",
          "549:    goto out;",
          "551:  }",
          "553:  err = vmci_qpair_alloc(qpair, handle, produce_size, consume_size,",
          "554:           peer, flags, VMCI_NO_PRIVILEGE_FLAGS);",
          "555: out:",
          "556:  if (err < 0) {",
          "557:   pr_err(\"Could not attach to queue pair with %d\\n\",",
          "558:          err);",
          "559:   err = vmci_transport_error_to_vsock_error(err);",
          "560:  }",
          "562:  return err;",
          "563: }",
          "565: static int",
          "566: vmci_transport_datagram_create_hnd(u32 resource_id,",
          "567:        u32 flags,",
          "568:        vmci_datagram_recv_cb recv_cb,",
          "569:        void *client_data,",
          "570:        struct vmci_handle *out_handle)",
          "571: {",
          "572:  int err = 0;",
          "578:  err = vmci_datagram_create_handle_priv(resource_id, flags,",
          "579:             VMCI_PRIVILEGE_FLAG_TRUSTED,",
          "580:             recv_cb,",
          "581:             client_data, out_handle);",
          "583:  if (err == VMCI_ERROR_NO_ACCESS)",
          "584:   err = vmci_datagram_create_handle(resource_id, flags,",
          "585:         recv_cb, client_data,",
          "586:         out_handle);",
          "588:  return err;",
          "589: }",
          "596: static int vmci_transport_recv_dgram_cb(void *data, struct vmci_datagram *dg)",
          "597: {",
          "598:  struct sock *sk;",
          "599:  size_t size;",
          "600:  struct sk_buff *skb;",
          "601:  struct vsock_sock *vsk;",
          "603:  sk = (struct sock *)data;",
          "614:  vsk = vsock_sk(sk);",
          "615:  if (!vmci_transport_allow_dgram(vsk, dg->src.context))",
          "616:   return VMCI_ERROR_NO_ACCESS;",
          "618:  size = VMCI_DG_SIZE(dg);",
          "621:  skb = alloc_skb(size, GFP_ATOMIC);",
          "622:  if (skb) {",
          "624:   sock_hold(sk);",
          "625:   skb_put(skb, size);",
          "626:   memcpy(skb->data, dg, size);",
          "627:   sk_receive_skb(sk, skb, 0);",
          "628:  }",
          "630:  return VMCI_SUCCESS;",
          "631: }",
          "633: static bool vmci_transport_stream_allow(u32 cid, u32 port)",
          "634: {",
          "635:  static const u32 non_socket_contexts[] = {",
          "636:   VMADDR_CID_HYPERVISOR,",
          "637:   VMADDR_CID_RESERVED,",
          "638:  };",
          "639:  int i;",
          "641:  BUILD_BUG_ON(sizeof(cid) != sizeof(*non_socket_contexts));",
          "643:  for (i = 0; i < ARRAY_SIZE(non_socket_contexts); i++) {",
          "644:   if (cid == non_socket_contexts[i])",
          "645:    return false;",
          "646:  }",
          "648:  return true;",
          "649: }",
          "656: static int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg)",
          "657: {",
          "658:  struct sock *sk;",
          "659:  struct sockaddr_vm dst;",
          "660:  struct sockaddr_vm src;",
          "661:  struct vmci_transport_packet *pkt;",
          "662:  struct vsock_sock *vsk;",
          "663:  bool bh_process_pkt;",
          "664:  int err;",
          "666:  sk = NULL;",
          "667:  err = VMCI_SUCCESS;",
          "668:  bh_process_pkt = false;",
          "674:  if (!vmci_transport_stream_allow(dg->src.context, -1)",
          "675:      || VMCI_TRANSPORT_PACKET_RID != dg->src.resource)",
          "676:   return VMCI_ERROR_NO_ACCESS;",
          "678:  if (VMCI_DG_SIZE(dg) < sizeof(*pkt))",
          "680:   return VMCI_ERROR_INVALID_ARGS;",
          "682:  pkt = (struct vmci_transport_packet *)dg;",
          "688:  vsock_addr_init(&src, pkt->dg.src.context, pkt->src_port);",
          "689:  vsock_addr_init(&dst, pkt->dg.dst.context, pkt->dst_port);",
          "691:  sk = vsock_find_connected_socket(&src, &dst);",
          "692:  if (!sk) {",
          "693:   sk = vsock_find_bound_socket(&dst);",
          "694:   if (!sk) {",
          "704:    if (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)",
          "705:     pr_err(\"unable to send reset\\n\");",
          "707:    err = VMCI_ERROR_NOT_FOUND;",
          "708:    goto out;",
          "709:   }",
          "710:  }",
          "716:  if (pkt->type >= VMCI_TRANSPORT_PACKET_TYPE_MAX) {",
          "717:   vmci_transport_send_invalid_bh(&dst, &src);",
          "718:   err = VMCI_ERROR_INVALID_ARGS;",
          "719:   goto out;",
          "720:  }",
          "731:  vsk = vsock_sk(sk);",
          "732:  if (!vmci_transport_allow_dgram(vsk, pkt->dg.src.context)) {",
          "733:   err = VMCI_ERROR_NO_ACCESS;",
          "734:   goto out;",
          "735:  }",
          "742:  bh_lock_sock(sk);",
          "744:  if (!sock_owned_by_user(sk) && sk->sk_state == SS_CONNECTED)",
          "745:   vmci_trans(vsk)->notify_ops->handle_notify_pkt(",
          "746:     sk, pkt, true, &dst, &src,",
          "747:     &bh_process_pkt);",
          "749:  bh_unlock_sock(sk);",
          "751:  if (!bh_process_pkt) {",
          "752:   struct vmci_transport_recv_pkt_info *recv_pkt_info;",
          "754:   recv_pkt_info = kmalloc(sizeof(*recv_pkt_info), GFP_ATOMIC);",
          "755:   if (!recv_pkt_info) {",
          "756:    if (vmci_transport_send_reset_bh(&dst, &src, pkt) < 0)",
          "757:     pr_err(\"unable to send reset\\n\");",
          "759:    err = VMCI_ERROR_NO_MEM;",
          "760:    goto out;",
          "761:   }",
          "763:   recv_pkt_info->sk = sk;",
          "764:   memcpy(&recv_pkt_info->pkt, pkt, sizeof(recv_pkt_info->pkt));",
          "765:   INIT_WORK(&recv_pkt_info->work, vmci_transport_recv_pkt_work);",
          "767:   schedule_work(&recv_pkt_info->work);",
          "773:   sk = NULL;",
          "774:  }",
          "776: out:",
          "777:  if (sk)",
          "778:   sock_put(sk);",
          "780:  return err;",
          "781: }",
          "783: static void vmci_transport_peer_attach_cb(u32 sub_id,",
          "784:        const struct vmci_event_data *e_data,",
          "785:        void *client_data)",
          "786: {",
          "787:  struct sock *sk = client_data;",
          "788:  const struct vmci_event_payload_qp *e_payload;",
          "789:  struct vsock_sock *vsk;",
          "791:  e_payload = vmci_event_data_const_payload(e_data);",
          "793:  vsk = vsock_sk(sk);",
          "801:  local_bh_disable();",
          "802:  bh_lock_sock(sk);",
          "807:  if (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,",
          "808:      e_payload->handle)) {",
          "813:   goto out;",
          "814:  }",
          "816: out:",
          "817:  bh_unlock_sock(sk);",
          "818:  local_bh_enable();",
          "819: }",
          "821: static void vmci_transport_handle_detach(struct sock *sk)",
          "822: {",
          "823:  struct vsock_sock *vsk;",
          "825:  vsk = vsock_sk(sk);",
          "826:  if (!vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)) {",
          "827:   sock_set_flag(sk, SOCK_DONE);",
          "832:   vsk->peer_shutdown = SHUTDOWN_MASK;",
          "838:   if (vsock_stream_has_data(vsk) <= 0) {",
          "839:    if (sk->sk_state == SS_CONNECTING) {",
          "848:     sk->sk_state = SS_UNCONNECTED;",
          "849:     sk->sk_err = ECONNRESET;",
          "850:     sk->sk_error_report(sk);",
          "851:     return;",
          "852:    }",
          "853:    sk->sk_state = SS_UNCONNECTED;",
          "854:   }",
          "855:   sk->sk_state_change(sk);",
          "856:  }",
          "857: }",
          "859: static void vmci_transport_peer_detach_cb(u32 sub_id,",
          "860:        const struct vmci_event_data *e_data,",
          "861:        void *client_data)",
          "862: {",
          "863:  struct sock *sk = client_data;",
          "864:  const struct vmci_event_payload_qp *e_payload;",
          "865:  struct vsock_sock *vsk;",
          "867:  e_payload = vmci_event_data_const_payload(e_data);",
          "868:  vsk = vsock_sk(sk);",
          "869:  if (vmci_handle_is_invalid(e_payload->handle))",
          "870:   return;",
          "873:  local_bh_disable();",
          "874:  bh_lock_sock(sk);",
          "879:  if (vmci_handle_is_equal(vmci_trans(vsk)->qp_handle,",
          "880:      e_payload->handle))",
          "881:   vmci_transport_handle_detach(sk);",
          "883:  bh_unlock_sock(sk);",
          "884:  local_bh_enable();",
          "885: }",
          "887: static void vmci_transport_qp_resumed_cb(u32 sub_id,",
          "888:       const struct vmci_event_data *e_data,",
          "889:       void *client_data)",
          "890: {",
          "891:  vsock_for_each_connected_socket(vmci_transport_handle_detach);",
          "892: }",
          "894: static void vmci_transport_recv_pkt_work(struct work_struct *work)",
          "895: {",
          "896:  struct vmci_transport_recv_pkt_info *recv_pkt_info;",
          "897:  struct vmci_transport_packet *pkt;",
          "898:  struct sock *sk;",
          "900:  recv_pkt_info =",
          "901:   container_of(work, struct vmci_transport_recv_pkt_info, work);",
          "902:  sk = recv_pkt_info->sk;",
          "903:  pkt = &recv_pkt_info->pkt;",
          "905:  lock_sock(sk);",
          "907:  switch (sk->sk_state) {",
          "908:  case SS_LISTEN:",
          "909:   vmci_transport_recv_listen(sk, pkt);",
          "910:   break;",
          "911:  case SS_CONNECTING:",
          "916:   vmci_transport_recv_connecting_client(sk, pkt);",
          "917:   break;",
          "918:  case SS_CONNECTED:",
          "919:   vmci_transport_recv_connected(sk, pkt);",
          "920:   break;",
          "921:  default:",
          "928:   vmci_transport_send_reset(sk, pkt);",
          "929:   goto out;",
          "930:  }",
          "932: out:",
          "933:  release_sock(sk);",
          "934:  kfree(recv_pkt_info);",
          "938:  sock_put(sk);",
          "939: }",
          "941: static int vmci_transport_recv_listen(struct sock *sk,",
          "942:           struct vmci_transport_packet *pkt)",
          "943: {",
          "944:  struct sock *pending;",
          "945:  struct vsock_sock *vpending;",
          "946:  int err;",
          "947:  u64 qp_size;",
          "948:  bool old_request = false;",
          "949:  bool old_pkt_proto = false;",
          "951:  err = 0;",
          "960:  pending = vmci_transport_get_pending(sk, pkt);",
          "961:  if (pending) {",
          "962:   lock_sock(pending);",
          "963:   switch (pending->sk_state) {",
          "964:   case SS_CONNECTING:",
          "965:    err = vmci_transport_recv_connecting_server(sk,",
          "966:             pending,",
          "967:             pkt);",
          "968:    break;",
          "969:   default:",
          "970:    vmci_transport_send_reset(pending, pkt);",
          "971:    err = -EINVAL;",
          "972:   }",
          "974:   if (err < 0)",
          "975:    vsock_remove_pending(sk, pending);",
          "977:   release_sock(pending);",
          "978:   vmci_transport_release_pending(pending);",
          "980:   return err;",
          "981:  }",
          "987:  if (!(pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST ||",
          "988:        pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST2)) {",
          "989:   vmci_transport_reply_reset(pkt);",
          "990:   return -EINVAL;",
          "991:  }",
          "993:  if (pkt->u.size == 0) {",
          "994:   vmci_transport_reply_reset(pkt);",
          "995:   return -EINVAL;",
          "996:  }",
          "1002:  if (sk->sk_ack_backlog >= sk->sk_max_ack_backlog) {",
          "1003:   vmci_transport_reply_reset(pkt);",
          "1004:   return -ECONNREFUSED;",
          "1005:  }",
          "1007:  pending = __vsock_create(sock_net(sk), NULL, sk, GFP_KERNEL,",
          "1008:      sk->sk_type);",
          "1009:  if (!pending) {",
          "1010:   vmci_transport_send_reset(sk, pkt);",
          "1011:   return -ENOMEM;",
          "1012:  }",
          "1014:  vpending = vsock_sk(pending);",
          "1016:  vsock_addr_init(&vpending->local_addr, pkt->dg.dst.context,",
          "1017:    pkt->dst_port);",
          "1018:  vsock_addr_init(&vpending->remote_addr, pkt->dg.src.context,",
          "1019:    pkt->src_port);",
          "1024:  if (pkt->u.size >= vmci_trans(vpending)->queue_pair_min_size &&",
          "1025:      pkt->u.size <= vmci_trans(vpending)->queue_pair_max_size) {",
          "1026:   qp_size = pkt->u.size;",
          "1027:  } else {",
          "1028:   qp_size = vmci_trans(vpending)->queue_pair_size;",
          "1029:  }",
          "1034:  if (vmci_transport_old_proto_override(&old_pkt_proto)) {",
          "1035:   old_request = old_pkt_proto;",
          "1036:  } else {",
          "1037:   if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST)",
          "1038:    old_request = true;",
          "1039:   else if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_REQUEST2)",
          "1040:    old_request = false;",
          "1042:  }",
          "1044:  if (old_request) {",
          "1046:   u16 version = VSOCK_PROTO_INVALID;",
          "1047:   if (vmci_transport_proto_to_notify_struct(",
          "1048:    pending, &version, true))",
          "1049:    err = vmci_transport_send_negotiate(pending, qp_size);",
          "1050:   else",
          "1051:    err = -EINVAL;",
          "1053:  } else {",
          "1055:   int proto_int = pkt->proto;",
          "1056:   int pos;",
          "1057:   u16 active_proto_version = 0;",
          "1063:   proto_int &= vmci_transport_new_proto_supported_versions();",
          "1068:   pos = fls(proto_int);",
          "1069:   if (pos) {",
          "1070:    active_proto_version = (1 << (pos - 1));",
          "1071:    if (vmci_transport_proto_to_notify_struct(",
          "1072:     pending, &active_proto_version, false))",
          "1073:     err = vmci_transport_send_negotiate2(pending,",
          "1074:        qp_size,",
          "1075:        active_proto_version);",
          "1076:    else",
          "1077:     err = -EINVAL;",
          "1079:   } else {",
          "1080:    err = -EINVAL;",
          "1081:   }",
          "1082:  }",
          "1084:  if (err < 0) {",
          "1085:   vmci_transport_send_reset(sk, pkt);",
          "1086:   sock_put(pending);",
          "1087:   err = vmci_transport_error_to_vsock_error(err);",
          "1088:   goto out;",
          "1089:  }",
          "1091:  vsock_add_pending(sk, pending);",
          "1092:  sk->sk_ack_backlog++;",
          "1094:  pending->sk_state = SS_CONNECTING;",
          "1095:  vmci_trans(vpending)->produce_size =",
          "1096:   vmci_trans(vpending)->consume_size = qp_size;",
          "1097:  vmci_trans(vpending)->queue_pair_size = qp_size;",
          "1099:  vmci_trans(vpending)->notify_ops->process_request(pending);",
          "1110:  vpending->listener = sk;",
          "1111:  sock_hold(sk);",
          "1112:  sock_hold(pending);",
          "1113:  INIT_DELAYED_WORK(&vpending->dwork, vsock_pending_work);",
          "1114:  schedule_delayed_work(&vpending->dwork, HZ);",
          "1116: out:",
          "1117:  return err;",
          "1118: }",
          "1120: static int",
          "1121: vmci_transport_recv_connecting_server(struct sock *listener,",
          "1122:           struct sock *pending,",
          "1123:           struct vmci_transport_packet *pkt)",
          "1124: {",
          "1125:  struct vsock_sock *vpending;",
          "1126:  struct vmci_handle handle;",
          "1127:  struct vmci_qp *qpair;",
          "1128:  bool is_local;",
          "1129:  u32 flags;",
          "1130:  u32 detach_sub_id;",
          "1131:  int err;",
          "1132:  int skerr;",
          "1134:  vpending = vsock_sk(pending);",
          "1135:  detach_sub_id = VMCI_INVALID_ID;",
          "1137:  switch (pkt->type) {",
          "1138:  case VMCI_TRANSPORT_PACKET_TYPE_OFFER:",
          "1139:   if (vmci_handle_is_invalid(pkt->u.handle)) {",
          "1140:    vmci_transport_send_reset(pending, pkt);",
          "1141:    skerr = EPROTO;",
          "1142:    err = -EINVAL;",
          "1143:    goto destroy;",
          "1144:   }",
          "1145:   break;",
          "1146:  default:",
          "1148:   vmci_transport_send_reset(pending, pkt);",
          "1149:   skerr = EPROTO;",
          "1150:   err = pkt->type == VMCI_TRANSPORT_PACKET_TYPE_RST ? 0 : -EINVAL;",
          "1151:   goto destroy;",
          "1152:  }",
          "1165:  err = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,",
          "1166:        vmci_transport_peer_detach_cb,",
          "1167:        pending, &detach_sub_id);",
          "1168:  if (err < VMCI_SUCCESS) {",
          "1169:   vmci_transport_send_reset(pending, pkt);",
          "1170:   err = vmci_transport_error_to_vsock_error(err);",
          "1171:   skerr = -err;",
          "1172:   goto destroy;",
          "1173:  }",
          "1175:  vmci_trans(vpending)->detach_sub_id = detach_sub_id;",
          "1178:  handle = pkt->u.handle;",
          "1183:  is_local =",
          "1184:      vpending->remote_addr.svm_cid == vpending->local_addr.svm_cid;",
          "1185:  flags = VMCI_QPFLAG_ATTACH_ONLY;",
          "1186:  flags |= is_local ? VMCI_QPFLAG_LOCAL : 0;",
          "1188:  err = vmci_transport_queue_pair_alloc(",
          "1189:      &qpair,",
          "1190:      &handle,",
          "1191:      vmci_trans(vpending)->produce_size,",
          "1192:      vmci_trans(vpending)->consume_size,",
          "1193:      pkt->dg.src.context,",
          "1194:      flags,",
          "1195:      vmci_transport_is_trusted(",
          "1196:       vpending,",
          "1197:       vpending->remote_addr.svm_cid));",
          "1198:  if (err < 0) {",
          "1199:   vmci_transport_send_reset(pending, pkt);",
          "1200:   skerr = -err;",
          "1201:   goto destroy;",
          "1202:  }",
          "1204:  vmci_trans(vpending)->qp_handle = handle;",
          "1205:  vmci_trans(vpending)->qpair = qpair;",
          "1223:  pending->sk_state = SS_CONNECTED;",
          "1225:  vsock_insert_connected(vpending);",
          "1228:  err = vmci_transport_send_attach(pending, handle);",
          "1229:  if (err < 0) {",
          "1230:   vsock_remove_connected(vpending);",
          "1231:   pr_err(\"Could not send attach\\n\");",
          "1232:   vmci_transport_send_reset(pending, pkt);",
          "1233:   err = vmci_transport_error_to_vsock_error(err);",
          "1234:   skerr = -err;",
          "1235:   goto destroy;",
          "1236:  }",
          "1242:  vsock_remove_pending(listener, pending);",
          "1243:  vsock_enqueue_accept(listener, pending);",
          "1248:  listener->sk_state_change(listener);",
          "1250:  return 0;",
          "1252: destroy:",
          "1253:  pending->sk_err = skerr;",
          "1254:  pending->sk_state = SS_UNCONNECTED;",
          "1262:  sock_put(pending);",
          "1264:  return err;",
          "1265: }",
          "1267: static int",
          "1268: vmci_transport_recv_connecting_client(struct sock *sk,",
          "1269:           struct vmci_transport_packet *pkt)",
          "1270: {",
          "1271:  struct vsock_sock *vsk;",
          "1272:  int err;",
          "1273:  int skerr;",
          "1275:  vsk = vsock_sk(sk);",
          "1277:  switch (pkt->type) {",
          "1278:  case VMCI_TRANSPORT_PACKET_TYPE_ATTACH:",
          "1279:   if (vmci_handle_is_invalid(pkt->u.handle) ||",
          "1280:       !vmci_handle_is_equal(pkt->u.handle,",
          "1281:        vmci_trans(vsk)->qp_handle)) {",
          "1282:    skerr = EPROTO;",
          "1283:    err = -EINVAL;",
          "1284:    goto destroy;",
          "1285:   }",
          "1292:   sk->sk_state = SS_CONNECTED;",
          "1293:   sk->sk_socket->state = SS_CONNECTED;",
          "1294:   vsock_insert_connected(vsk);",
          "1295:   sk->sk_state_change(sk);",
          "1297:   break;",
          "1298:  case VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE:",
          "1299:  case VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2:",
          "1300:   if (pkt->u.size == 0",
          "1301:       || pkt->dg.src.context != vsk->remote_addr.svm_cid",
          "1302:       || pkt->src_port != vsk->remote_addr.svm_port",
          "1303:       || !vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)",
          "1304:       || vmci_trans(vsk)->qpair",
          "1305:       || vmci_trans(vsk)->produce_size != 0",
          "1306:       || vmci_trans(vsk)->consume_size != 0",
          "1307:       || vmci_trans(vsk)->attach_sub_id != VMCI_INVALID_ID",
          "1308:       || vmci_trans(vsk)->detach_sub_id != VMCI_INVALID_ID) {",
          "1309:    skerr = EPROTO;",
          "1310:    err = -EINVAL;",
          "1312:    goto destroy;",
          "1313:   }",
          "1315:   err = vmci_transport_recv_connecting_client_negotiate(sk, pkt);",
          "1316:   if (err) {",
          "1317:    skerr = -err;",
          "1318:    goto destroy;",
          "1319:   }",
          "1321:   break;",
          "1322:  case VMCI_TRANSPORT_PACKET_TYPE_INVALID:",
          "1323:   err = vmci_transport_recv_connecting_client_invalid(sk, pkt);",
          "1324:   if (err) {",
          "1325:    skerr = -err;",
          "1326:    goto destroy;",
          "1327:   }",
          "1329:   break;",
          "1330:  case VMCI_TRANSPORT_PACKET_TYPE_RST:",
          "1340:   if (vsk->ignore_connecting_rst) {",
          "1341:    vsk->ignore_connecting_rst = false;",
          "1342:   } else {",
          "1343:    skerr = ECONNRESET;",
          "1344:    err = 0;",
          "1345:    goto destroy;",
          "1346:   }",
          "1348:   break;",
          "1349:  default:",
          "1351:   skerr = EPROTO;",
          "1352:   err = -EINVAL;",
          "1353:   goto destroy;",
          "1354:  }",
          "1356:  return 0;",
          "1358: destroy:",
          "1359:  vmci_transport_send_reset(sk, pkt);",
          "1361:  sk->sk_state = SS_UNCONNECTED;",
          "1362:  sk->sk_err = skerr;",
          "1363:  sk->sk_error_report(sk);",
          "1364:  return err;",
          "1365: }",
          "1367: static int vmci_transport_recv_connecting_client_negotiate(",
          "1368:      struct sock *sk,",
          "1369:      struct vmci_transport_packet *pkt)",
          "1370: {",
          "1371:  int err;",
          "1372:  struct vsock_sock *vsk;",
          "1373:  struct vmci_handle handle;",
          "1374:  struct vmci_qp *qpair;",
          "1375:  u32 attach_sub_id;",
          "1376:  u32 detach_sub_id;",
          "1377:  bool is_local;",
          "1378:  u32 flags;",
          "1379:  bool old_proto = true;",
          "1380:  bool old_pkt_proto;",
          "1381:  u16 version;",
          "1383:  vsk = vsock_sk(sk);",
          "1384:  handle = VMCI_INVALID_HANDLE;",
          "1385:  attach_sub_id = VMCI_INVALID_ID;",
          "1386:  detach_sub_id = VMCI_INVALID_ID;",
          "1391:  vsk->sent_request = false;",
          "1392:  vsk->ignore_connecting_rst = false;",
          "1395:  if (pkt->u.size < vmci_trans(vsk)->queue_pair_min_size ||",
          "1396:      pkt->u.size > vmci_trans(vsk)->queue_pair_max_size) {",
          "1397:   err = -EINVAL;",
          "1398:   goto destroy;",
          "1399:  }",
          "1403:  if (vsk->local_addr.svm_cid == VMADDR_CID_ANY)",
          "1404:   vsk->local_addr.svm_cid = pkt->dg.dst.context;",
          "1410:  if (vmci_transport_old_proto_override(&old_pkt_proto)) {",
          "1411:   old_proto = old_pkt_proto;",
          "1412:  } else {",
          "1413:   if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE)",
          "1414:    old_proto = true;",
          "1415:   else if (pkt->type == VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2)",
          "1416:    old_proto = false;",
          "1418:  }",
          "1420:  if (old_proto)",
          "1421:   version = VSOCK_PROTO_INVALID;",
          "1422:  else",
          "1423:   version = pkt->proto;",
          "1425:  if (!vmci_transport_proto_to_notify_struct(sk, &version, old_proto)) {",
          "1426:   err = -EINVAL;",
          "1427:   goto destroy;",
          "1428:  }",
          "1436:  err = vmci_event_subscribe(VMCI_EVENT_QP_PEER_ATTACH,",
          "1437:        vmci_transport_peer_attach_cb,",
          "1438:        sk, &attach_sub_id);",
          "1439:  if (err < VMCI_SUCCESS) {",
          "1440:   err = vmci_transport_error_to_vsock_error(err);",
          "1441:   goto destroy;",
          "1442:  }",
          "1444:  err = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,",
          "1445:        vmci_transport_peer_detach_cb,",
          "1446:        sk, &detach_sub_id);",
          "1447:  if (err < VMCI_SUCCESS) {",
          "1448:   err = vmci_transport_error_to_vsock_error(err);",
          "1449:   goto destroy;",
          "1450:  }",
          "1453:  handle = VMCI_INVALID_HANDLE;",
          "1454:  is_local = vsk->remote_addr.svm_cid == vsk->local_addr.svm_cid;",
          "1455:  flags = is_local ? VMCI_QPFLAG_LOCAL : 0;",
          "1457:  err = vmci_transport_queue_pair_alloc(&qpair,",
          "1458:            &handle,",
          "1459:            pkt->u.size,",
          "1460:            pkt->u.size,",
          "1461:            vsk->remote_addr.svm_cid,",
          "1462:            flags,",
          "1463:            vmci_transport_is_trusted(",
          "1464:         vsk,",
          "1465:         vsk->",
          "1466:         remote_addr.svm_cid));",
          "1467:  if (err < 0)",
          "1468:   goto destroy;",
          "1470:  err = vmci_transport_send_qp_offer(sk, handle);",
          "1471:  if (err < 0) {",
          "1472:   err = vmci_transport_error_to_vsock_error(err);",
          "1473:   goto destroy;",
          "1474:  }",
          "1476:  vmci_trans(vsk)->qp_handle = handle;",
          "1477:  vmci_trans(vsk)->qpair = qpair;",
          "1479:  vmci_trans(vsk)->produce_size = vmci_trans(vsk)->consume_size =",
          "1480:   pkt->u.size;",
          "1482:  vmci_trans(vsk)->attach_sub_id = attach_sub_id;",
          "1483:  vmci_trans(vsk)->detach_sub_id = detach_sub_id;",
          "1485:  vmci_trans(vsk)->notify_ops->process_negotiate(sk);",
          "1487:  return 0;",
          "1489: destroy:",
          "1490:  if (attach_sub_id != VMCI_INVALID_ID)",
          "1491:   vmci_event_unsubscribe(attach_sub_id);",
          "1493:  if (detach_sub_id != VMCI_INVALID_ID)",
          "1494:   vmci_event_unsubscribe(detach_sub_id);",
          "1496:  if (!vmci_handle_is_invalid(handle))",
          "1497:   vmci_qpair_detach(&qpair);",
          "1499:  return err;",
          "1500: }",
          "1502: static int",
          "1503: vmci_transport_recv_connecting_client_invalid(struct sock *sk,",
          "1504:            struct vmci_transport_packet *pkt)",
          "1505: {",
          "1506:  int err = 0;",
          "1507:  struct vsock_sock *vsk = vsock_sk(sk);",
          "1509:  if (vsk->sent_request) {",
          "1510:   vsk->sent_request = false;",
          "1511:   vsk->ignore_connecting_rst = true;",
          "1513:   err = vmci_transport_send_conn_request(",
          "1514:    sk, vmci_trans(vsk)->queue_pair_size);",
          "1515:   if (err < 0)",
          "1516:    err = vmci_transport_error_to_vsock_error(err);",
          "1517:   else",
          "1518:    err = 0;",
          "1520:  }",
          "1522:  return err;",
          "1523: }",
          "1525: static int vmci_transport_recv_connected(struct sock *sk,",
          "1526:       struct vmci_transport_packet *pkt)",
          "1527: {",
          "1528:  struct vsock_sock *vsk;",
          "1529:  bool pkt_processed = false;",
          "1539:  switch (pkt->type) {",
          "1540:  case VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN:",
          "1541:   if (pkt->u.mode) {",
          "1542:    vsk = vsock_sk(sk);",
          "1544:    vsk->peer_shutdown |= pkt->u.mode;",
          "1545:    sk->sk_state_change(sk);",
          "1546:   }",
          "1547:   break;",
          "1549:  case VMCI_TRANSPORT_PACKET_TYPE_RST:",
          "1550:   vsk = vsock_sk(sk);",
          "1560:   sock_set_flag(sk, SOCK_DONE);",
          "1561:   vsk->peer_shutdown = SHUTDOWN_MASK;",
          "1562:   if (vsock_stream_has_data(vsk) <= 0)",
          "1563:    sk->sk_state = SS_DISCONNECTING;",
          "1565:   sk->sk_state_change(sk);",
          "1566:   break;",
          "1568:  default:",
          "1569:   vsk = vsock_sk(sk);",
          "1570:   vmci_trans(vsk)->notify_ops->handle_notify_pkt(",
          "1571:     sk, pkt, false, NULL, NULL,",
          "1572:     &pkt_processed);",
          "1573:   if (!pkt_processed)",
          "1574:    return -EINVAL;",
          "1576:   break;",
          "1577:  }",
          "1579:  return 0;",
          "1580: }",
          "1582: static int vmci_transport_socket_init(struct vsock_sock *vsk,",
          "1583:           struct vsock_sock *psk)",
          "1584: {",
          "1585:  vsk->trans = kmalloc(sizeof(struct vmci_transport), GFP_KERNEL);",
          "1586:  if (!vsk->trans)",
          "1587:   return -ENOMEM;",
          "1589:  vmci_trans(vsk)->dg_handle = VMCI_INVALID_HANDLE;",
          "1590:  vmci_trans(vsk)->qp_handle = VMCI_INVALID_HANDLE;",
          "1591:  vmci_trans(vsk)->qpair = NULL;",
          "1592:  vmci_trans(vsk)->produce_size = vmci_trans(vsk)->consume_size = 0;",
          "1593:  vmci_trans(vsk)->attach_sub_id = vmci_trans(vsk)->detach_sub_id =",
          "1594:   VMCI_INVALID_ID;",
          "1595:  vmci_trans(vsk)->notify_ops = NULL;",
          "1596:  if (psk) {",
          "1597:   vmci_trans(vsk)->queue_pair_size =",
          "1598:    vmci_trans(psk)->queue_pair_size;",
          "1599:   vmci_trans(vsk)->queue_pair_min_size =",
          "1600:    vmci_trans(psk)->queue_pair_min_size;",
          "1601:   vmci_trans(vsk)->queue_pair_max_size =",
          "1602:    vmci_trans(psk)->queue_pair_max_size;",
          "1603:  } else {",
          "1604:   vmci_trans(vsk)->queue_pair_size =",
          "1605:    VMCI_TRANSPORT_DEFAULT_QP_SIZE;",
          "1606:   vmci_trans(vsk)->queue_pair_min_size =",
          "1607:     VMCI_TRANSPORT_DEFAULT_QP_SIZE_MIN;",
          "1608:   vmci_trans(vsk)->queue_pair_max_size =",
          "1609:    VMCI_TRANSPORT_DEFAULT_QP_SIZE_MAX;",
          "1610:  }",
          "1612:  return 0;",
          "1613: }",
          "1615: static void vmci_transport_destruct(struct vsock_sock *vsk)",
          "1616: {",
          "1617:  if (vmci_trans(vsk)->attach_sub_id != VMCI_INVALID_ID) {",
          "1618:   vmci_event_unsubscribe(vmci_trans(vsk)->attach_sub_id);",
          "1619:   vmci_trans(vsk)->attach_sub_id = VMCI_INVALID_ID;",
          "1620:  }",
          "1622:  if (vmci_trans(vsk)->detach_sub_id != VMCI_INVALID_ID) {",
          "1623:   vmci_event_unsubscribe(vmci_trans(vsk)->detach_sub_id);",
          "1624:   vmci_trans(vsk)->detach_sub_id = VMCI_INVALID_ID;",
          "1625:  }",
          "1627:  if (!vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle)) {",
          "1628:   vmci_qpair_detach(&vmci_trans(vsk)->qpair);",
          "1629:   vmci_trans(vsk)->qp_handle = VMCI_INVALID_HANDLE;",
          "1630:   vmci_trans(vsk)->produce_size = 0;",
          "1631:   vmci_trans(vsk)->consume_size = 0;",
          "1632:  }",
          "1634:  if (vmci_trans(vsk)->notify_ops)",
          "1635:   vmci_trans(vsk)->notify_ops->socket_destruct(vsk);",
          "1637:  kfree(vsk->trans);",
          "1638:  vsk->trans = NULL;",
          "1639: }",
          "1641: static void vmci_transport_release(struct vsock_sock *vsk)",
          "1642: {",
          "1643:  if (!vmci_handle_is_invalid(vmci_trans(vsk)->dg_handle)) {",
          "1644:   vmci_datagram_destroy_handle(vmci_trans(vsk)->dg_handle);",
          "1645:   vmci_trans(vsk)->dg_handle = VMCI_INVALID_HANDLE;",
          "1646:  }",
          "1647: }",
          "1649: static int vmci_transport_dgram_bind(struct vsock_sock *vsk,",
          "1650:          struct sockaddr_vm *addr)",
          "1651: {",
          "1652:  u32 port;",
          "1653:  u32 flags;",
          "1654:  int err;",
          "1659:  port = addr->svm_port == VMADDR_PORT_ANY ?",
          "1660:    VMCI_INVALID_ID : addr->svm_port;",
          "1662:  if (port <= LAST_RESERVED_PORT && !capable(CAP_NET_BIND_SERVICE))",
          "1663:   return -EACCES;",
          "1665:  flags = addr->svm_cid == VMADDR_CID_ANY ?",
          "1666:     VMCI_FLAG_ANYCID_DG_HND : 0;",
          "1668:  err = vmci_transport_datagram_create_hnd(port, flags,",
          "1669:        vmci_transport_recv_dgram_cb,",
          "1670:        &vsk->sk,",
          "1671:        &vmci_trans(vsk)->dg_handle);",
          "1672:  if (err < VMCI_SUCCESS)",
          "1673:   return vmci_transport_error_to_vsock_error(err);",
          "1674:  vsock_addr_init(&vsk->local_addr, addr->svm_cid,",
          "1675:    vmci_trans(vsk)->dg_handle.resource);",
          "1677:  return 0;",
          "1678: }",
          "1680: static int vmci_transport_dgram_enqueue(",
          "1681:  struct vsock_sock *vsk,",
          "1682:  struct sockaddr_vm *remote_addr,",
          "1683:  struct iovec *iov,",
          "1684:  size_t len)",
          "1685: {",
          "1686:  int err;",
          "1687:  struct vmci_datagram *dg;",
          "1689:  if (len > VMCI_MAX_DG_PAYLOAD_SIZE)",
          "1690:   return -EMSGSIZE;",
          "1692:  if (!vmci_transport_allow_dgram(vsk, remote_addr->svm_cid))",
          "1693:   return -EPERM;",
          "1696:  dg = kmalloc(len + sizeof(*dg), GFP_KERNEL);",
          "1697:  if (!dg)",
          "1698:   return -ENOMEM;",
          "1700:  memcpy_fromiovec(VMCI_DG_PAYLOAD(dg), iov, len);",
          "1702:  dg->dst = vmci_make_handle(remote_addr->svm_cid,",
          "1703:        remote_addr->svm_port);",
          "1704:  dg->src = vmci_make_handle(vsk->local_addr.svm_cid,",
          "1705:        vsk->local_addr.svm_port);",
          "1706:  dg->payload_size = len;",
          "1708:  err = vmci_datagram_send(dg);",
          "1709:  kfree(dg);",
          "1710:  if (err < 0)",
          "1711:   return vmci_transport_error_to_vsock_error(err);",
          "1713:  return err - sizeof(*dg);",
          "1714: }",
          "1716: static int vmci_transport_dgram_dequeue(struct kiocb *kiocb,",
          "1717:      struct vsock_sock *vsk,",
          "1718:      struct msghdr *msg, size_t len,",
          "1719:      int flags)",
          "1720: {",
          "1721:  int err;",
          "1722:  int noblock;",
          "1723:  struct vmci_datagram *dg;",
          "1724:  size_t payload_len;",
          "1725:  struct sk_buff *skb;",
          "1727:  noblock = flags & MSG_DONTWAIT;",
          "1729:  if (flags & MSG_OOB || flags & MSG_ERRQUEUE)",
          "1730:   return -EOPNOTSUPP;",
          "1733:  err = 0;",
          "1734:  skb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);",
          "1735:  if (err)",
          "1736:   return err;",
          "1738:  if (!skb)",
          "1739:   return -EAGAIN;",
          "1741:  dg = (struct vmci_datagram *)skb->data;",
          "1742:  if (!dg)",
          "1744:   goto out;",
          "1746:  payload_len = dg->payload_size;",
          "1748:  if (payload_len != skb->len - sizeof(*dg)) {",
          "1749:   err = -EINVAL;",
          "1750:   goto out;",
          "1751:  }",
          "1753:  if (payload_len > len) {",
          "1754:   payload_len = len;",
          "1755:   msg->msg_flags |= MSG_TRUNC;",
          "1756:  }",
          "1759:  err = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,",
          "1760:   payload_len);",
          "1761:  if (err)",
          "1762:   goto out;",
          "1764:  msg->msg_namelen = 0;",
          "1765:  if (msg->msg_name) {",
          "1766:   struct sockaddr_vm *vm_addr;",
          "1769:   vm_addr = (struct sockaddr_vm *)msg->msg_name;",
          "1770:   vsock_addr_init(vm_addr, dg->src.context, dg->src.resource);",
          "1771:   msg->msg_namelen = sizeof(*vm_addr);",
          "1772:  }",
          "1773:  err = payload_len;",
          "1775: out:",
          "1776:  skb_free_datagram(&vsk->sk, skb);",
          "1777:  return err;",
          "1778: }",
          "1780: static bool vmci_transport_dgram_allow(u32 cid, u32 port)",
          "1781: {",
          "1782:  if (cid == VMADDR_CID_HYPERVISOR) {",
          "1786:   return port == VMCI_UNITY_PBRPC_REGISTER;",
          "1787:  }",
          "1789:  return true;",
          "1790: }",
          "1792: static int vmci_transport_connect(struct vsock_sock *vsk)",
          "1793: {",
          "1794:  int err;",
          "1795:  bool old_pkt_proto = false;",
          "1796:  struct sock *sk = &vsk->sk;",
          "1798:  if (vmci_transport_old_proto_override(&old_pkt_proto) &&",
          "1799:   old_pkt_proto) {",
          "1800:   err = vmci_transport_send_conn_request(",
          "1801:    sk, vmci_trans(vsk)->queue_pair_size);",
          "1802:   if (err < 0) {",
          "1803:    sk->sk_state = SS_UNCONNECTED;",
          "1804:    return err;",
          "1805:   }",
          "1806:  } else {",
          "1807:   int supported_proto_versions =",
          "1808:    vmci_transport_new_proto_supported_versions();",
          "1809:   err = vmci_transport_send_conn_request2(",
          "1810:     sk, vmci_trans(vsk)->queue_pair_size,",
          "1811:     supported_proto_versions);",
          "1812:   if (err < 0) {",
          "1813:    sk->sk_state = SS_UNCONNECTED;",
          "1814:    return err;",
          "1815:   }",
          "1817:   vsk->sent_request = true;",
          "1818:  }",
          "1820:  return err;",
          "1821: }",
          "1823: static ssize_t vmci_transport_stream_dequeue(",
          "1824:  struct vsock_sock *vsk,",
          "1825:  struct iovec *iov,",
          "1826:  size_t len,",
          "1827:  int flags)",
          "1828: {",
          "1829:  if (flags & MSG_PEEK)",
          "1830:   return vmci_qpair_peekv(vmci_trans(vsk)->qpair, iov, len, 0);",
          "1831:  else",
          "1832:   return vmci_qpair_dequev(vmci_trans(vsk)->qpair, iov, len, 0);",
          "1833: }",
          "1835: static ssize_t vmci_transport_stream_enqueue(",
          "1836:  struct vsock_sock *vsk,",
          "1837:  struct iovec *iov,",
          "1838:  size_t len)",
          "1839: {",
          "1840:  return vmci_qpair_enquev(vmci_trans(vsk)->qpair, iov, len, 0);",
          "1841: }",
          "1843: static s64 vmci_transport_stream_has_data(struct vsock_sock *vsk)",
          "1844: {",
          "1845:  return vmci_qpair_consume_buf_ready(vmci_trans(vsk)->qpair);",
          "1846: }",
          "1848: static s64 vmci_transport_stream_has_space(struct vsock_sock *vsk)",
          "1849: {",
          "1850:  return vmci_qpair_produce_free_space(vmci_trans(vsk)->qpair);",
          "1851: }",
          "1853: static u64 vmci_transport_stream_rcvhiwat(struct vsock_sock *vsk)",
          "1854: {",
          "1855:  return vmci_trans(vsk)->consume_size;",
          "1856: }",
          "1858: static bool vmci_transport_stream_is_active(struct vsock_sock *vsk)",
          "1859: {",
          "1860:  return !vmci_handle_is_invalid(vmci_trans(vsk)->qp_handle);",
          "1861: }",
          "1863: static u64 vmci_transport_get_buffer_size(struct vsock_sock *vsk)",
          "1864: {",
          "1865:  return vmci_trans(vsk)->queue_pair_size;",
          "1866: }",
          "1868: static u64 vmci_transport_get_min_buffer_size(struct vsock_sock *vsk)",
          "1869: {",
          "1870:  return vmci_trans(vsk)->queue_pair_min_size;",
          "1871: }",
          "1873: static u64 vmci_transport_get_max_buffer_size(struct vsock_sock *vsk)",
          "1874: {",
          "1875:  return vmci_trans(vsk)->queue_pair_max_size;",
          "1876: }",
          "1878: static void vmci_transport_set_buffer_size(struct vsock_sock *vsk, u64 val)",
          "1879: {",
          "1880:  if (val < vmci_trans(vsk)->queue_pair_min_size)",
          "1881:   vmci_trans(vsk)->queue_pair_min_size = val;",
          "1882:  if (val > vmci_trans(vsk)->queue_pair_max_size)",
          "1883:   vmci_trans(vsk)->queue_pair_max_size = val;",
          "1884:  vmci_trans(vsk)->queue_pair_size = val;",
          "1885: }",
          "1887: static void vmci_transport_set_min_buffer_size(struct vsock_sock *vsk,",
          "1888:             u64 val)",
          "1889: {",
          "1890:  if (val > vmci_trans(vsk)->queue_pair_size)",
          "1891:   vmci_trans(vsk)->queue_pair_size = val;",
          "1892:  vmci_trans(vsk)->queue_pair_min_size = val;",
          "1893: }",
          "1895: static void vmci_transport_set_max_buffer_size(struct vsock_sock *vsk,",
          "1896:             u64 val)",
          "1897: {",
          "1898:  if (val < vmci_trans(vsk)->queue_pair_size)",
          "1899:   vmci_trans(vsk)->queue_pair_size = val;",
          "1900:  vmci_trans(vsk)->queue_pair_max_size = val;",
          "1901: }",
          "1903: static int vmci_transport_notify_poll_in(",
          "1904:  struct vsock_sock *vsk,",
          "1905:  size_t target,",
          "1906:  bool *data_ready_now)",
          "1907: {",
          "1908:  return vmci_trans(vsk)->notify_ops->poll_in(",
          "1909:    &vsk->sk, target, data_ready_now);",
          "1910: }",
          "1912: static int vmci_transport_notify_poll_out(",
          "1913:  struct vsock_sock *vsk,",
          "1914:  size_t target,",
          "1915:  bool *space_available_now)",
          "1916: {",
          "1917:  return vmci_trans(vsk)->notify_ops->poll_out(",
          "1918:    &vsk->sk, target, space_available_now);",
          "1919: }",
          "1921: static int vmci_transport_notify_recv_init(",
          "1922:  struct vsock_sock *vsk,",
          "1923:  size_t target,",
          "1924:  struct vsock_transport_recv_notify_data *data)",
          "1925: {",
          "1926:  return vmci_trans(vsk)->notify_ops->recv_init(",
          "1927:    &vsk->sk, target,",
          "1928:    (struct vmci_transport_recv_notify_data *)data);",
          "1929: }",
          "1931: static int vmci_transport_notify_recv_pre_block(",
          "1932:  struct vsock_sock *vsk,",
          "1933:  size_t target,",
          "1934:  struct vsock_transport_recv_notify_data *data)",
          "1935: {",
          "1936:  return vmci_trans(vsk)->notify_ops->recv_pre_block(",
          "1937:    &vsk->sk, target,",
          "1938:    (struct vmci_transport_recv_notify_data *)data);",
          "1939: }",
          "1941: static int vmci_transport_notify_recv_pre_dequeue(",
          "1942:  struct vsock_sock *vsk,",
          "1943:  size_t target,",
          "1944:  struct vsock_transport_recv_notify_data *data)",
          "1945: {",
          "1946:  return vmci_trans(vsk)->notify_ops->recv_pre_dequeue(",
          "1947:    &vsk->sk, target,",
          "1948:    (struct vmci_transport_recv_notify_data *)data);",
          "1949: }",
          "1951: static int vmci_transport_notify_recv_post_dequeue(",
          "1952:  struct vsock_sock *vsk,",
          "1953:  size_t target,",
          "1954:  ssize_t copied,",
          "1955:  bool data_read,",
          "1956:  struct vsock_transport_recv_notify_data *data)",
          "1957: {",
          "1958:  return vmci_trans(vsk)->notify_ops->recv_post_dequeue(",
          "1959:    &vsk->sk, target, copied, data_read,",
          "1960:    (struct vmci_transport_recv_notify_data *)data);",
          "1961: }",
          "1963: static int vmci_transport_notify_send_init(",
          "1964:  struct vsock_sock *vsk,",
          "1965:  struct vsock_transport_send_notify_data *data)",
          "1966: {",
          "1967:  return vmci_trans(vsk)->notify_ops->send_init(",
          "1968:    &vsk->sk,",
          "1969:    (struct vmci_transport_send_notify_data *)data);",
          "1970: }",
          "1972: static int vmci_transport_notify_send_pre_block(",
          "1973:  struct vsock_sock *vsk,",
          "1974:  struct vsock_transport_send_notify_data *data)",
          "1975: {",
          "1976:  return vmci_trans(vsk)->notify_ops->send_pre_block(",
          "1977:    &vsk->sk,",
          "1978:    (struct vmci_transport_send_notify_data *)data);",
          "1979: }",
          "1981: static int vmci_transport_notify_send_pre_enqueue(",
          "1982:  struct vsock_sock *vsk,",
          "1983:  struct vsock_transport_send_notify_data *data)",
          "1984: {",
          "1985:  return vmci_trans(vsk)->notify_ops->send_pre_enqueue(",
          "1986:    &vsk->sk,",
          "1987:    (struct vmci_transport_send_notify_data *)data);",
          "1988: }",
          "1990: static int vmci_transport_notify_send_post_enqueue(",
          "1991:  struct vsock_sock *vsk,",
          "1992:  ssize_t written,",
          "1993:  struct vsock_transport_send_notify_data *data)",
          "1994: {",
          "1995:  return vmci_trans(vsk)->notify_ops->send_post_enqueue(",
          "1996:    &vsk->sk, written,",
          "1997:    (struct vmci_transport_send_notify_data *)data);",
          "1998: }",
          "2000: static bool vmci_transport_old_proto_override(bool *old_pkt_proto)",
          "2001: {",
          "2002:  if (PROTOCOL_OVERRIDE != -1) {",
          "2003:   if (PROTOCOL_OVERRIDE == 0)",
          "2005:   else",
          "2008:   pr_info(\"Proto override in use\\n\");",
          "2009:   return true;",
          "2010:  }",
          "2012:  return false;",
          "2013: }",
          "2015: static bool vmci_transport_proto_to_notify_struct(struct sock *sk,",
          "2016:         u16 *proto,",
          "2017:         bool old_pkt_proto)",
          "2018: {",
          "2019:  struct vsock_sock *vsk = vsock_sk(sk);",
          "2021:  if (old_pkt_proto) {",
          "2022:   if (*proto != VSOCK_PROTO_INVALID) {",
          "2023:    pr_err(\"Can't set both an old and new protocol\\n\");",
          "2024:    return false;",
          "2025:   }",
          "2026:   vmci_trans(vsk)->notify_ops = &vmci_transport_notify_pkt_ops;",
          "2027:   goto exit;",
          "2028:  }",
          "2030:  switch (*proto) {",
          "2031:  case VSOCK_PROTO_PKT_ON_NOTIFY:",
          "2032:   vmci_trans(vsk)->notify_ops =",
          "2033:    &vmci_transport_notify_pkt_q_state_ops;",
          "2034:   break;",
          "2035:  default:",
          "2036:   pr_err(\"Unknown notify protocol version\\n\");",
          "2037:   return false;",
          "2038:  }",
          "2040: exit:",
          "2041:  vmci_trans(vsk)->notify_ops->socket_init(sk);",
          "2042:  return true;",
          "2043: }",
          "2045: static u16 vmci_transport_new_proto_supported_versions(void)",
          "2046: {",
          "2047:  if (PROTOCOL_OVERRIDE != -1)",
          "2048:   return PROTOCOL_OVERRIDE;",
          "2050:  return VSOCK_PROTO_ALL_SUPPORTED;",
          "2051: }",
          "2053: static u32 vmci_transport_get_local_cid(void)",
          "2054: {",
          "2055:  return vmci_get_context_id();",
          "2056: }",
          "2058: static struct vsock_transport vmci_transport = {",
          "2059:  .init = vmci_transport_socket_init,",
          "2060:  .destruct = vmci_transport_destruct,",
          "2061:  .release = vmci_transport_release,",
          "2062:  .connect = vmci_transport_connect,",
          "2063:  .dgram_bind = vmci_transport_dgram_bind,",
          "2064:  .dgram_dequeue = vmci_transport_dgram_dequeue,",
          "2065:  .dgram_enqueue = vmci_transport_dgram_enqueue,",
          "2066:  .dgram_allow = vmci_transport_dgram_allow,",
          "2067:  .stream_dequeue = vmci_transport_stream_dequeue,",
          "2068:  .stream_enqueue = vmci_transport_stream_enqueue,",
          "2069:  .stream_has_data = vmci_transport_stream_has_data,",
          "2070:  .stream_has_space = vmci_transport_stream_has_space,",
          "2071:  .stream_rcvhiwat = vmci_transport_stream_rcvhiwat,",
          "2072:  .stream_is_active = vmci_transport_stream_is_active,",
          "2073:  .stream_allow = vmci_transport_stream_allow,",
          "2074:  .notify_poll_in = vmci_transport_notify_poll_in,",
          "2075:  .notify_poll_out = vmci_transport_notify_poll_out,",
          "2076:  .notify_recv_init = vmci_transport_notify_recv_init,",
          "2077:  .notify_recv_pre_block = vmci_transport_notify_recv_pre_block,",
          "2078:  .notify_recv_pre_dequeue = vmci_transport_notify_recv_pre_dequeue,",
          "2079:  .notify_recv_post_dequeue = vmci_transport_notify_recv_post_dequeue,",
          "2080:  .notify_send_init = vmci_transport_notify_send_init,",
          "2081:  .notify_send_pre_block = vmci_transport_notify_send_pre_block,",
          "2082:  .notify_send_pre_enqueue = vmci_transport_notify_send_pre_enqueue,",
          "2083:  .notify_send_post_enqueue = vmci_transport_notify_send_post_enqueue,",
          "2084:  .shutdown = vmci_transport_shutdown,",
          "2085:  .set_buffer_size = vmci_transport_set_buffer_size,",
          "2086:  .set_min_buffer_size = vmci_transport_set_min_buffer_size,",
          "2087:  .set_max_buffer_size = vmci_transport_set_max_buffer_size,",
          "2088:  .get_buffer_size = vmci_transport_get_buffer_size,",
          "2089:  .get_min_buffer_size = vmci_transport_get_min_buffer_size,",
          "2090:  .get_max_buffer_size = vmci_transport_get_max_buffer_size,",
          "2091:  .get_local_cid = vmci_transport_get_local_cid,",
          "2092: };",
          "2094: static int __init vmci_transport_init(void)",
          "2095: {",
          "2096:  int err;",
          "2101:  err = vmci_transport_datagram_create_hnd(VMCI_TRANSPORT_PACKET_RID,",
          "2102:        VMCI_FLAG_ANYCID_DG_HND,",
          "2103:        vmci_transport_recv_stream_cb,",
          "2104:        NULL,",
          "2105:        &vmci_transport_stream_handle);",
          "2106:  if (err < VMCI_SUCCESS) {",
          "2107:   pr_err(\"Unable to create datagram handle. (%d)\\n\", err);",
          "2108:   return vmci_transport_error_to_vsock_error(err);",
          "2109:  }",
          "2111:  err = vmci_event_subscribe(VMCI_EVENT_QP_RESUMED,",
          "2112:        vmci_transport_qp_resumed_cb,",
          "2113:        NULL, &vmci_transport_qp_resumed_sub_id);",
          "2114:  if (err < VMCI_SUCCESS) {",
          "2115:   pr_err(\"Unable to subscribe to resumed event. (%d)\\n\", err);",
          "2116:   err = vmci_transport_error_to_vsock_error(err);",
          "2117:   vmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;",
          "2118:   goto err_destroy_stream_handle;",
          "2119:  }",
          "2121:  err = vsock_core_init(&vmci_transport);",
          "2122:  if (err < 0)",
          "2123:   goto err_unsubscribe;",
          "2125:  return 0;",
          "2127: err_unsubscribe:",
          "2128:  vmci_event_unsubscribe(vmci_transport_qp_resumed_sub_id);",
          "2129: err_destroy_stream_handle:",
          "2130:  vmci_datagram_destroy_handle(vmci_transport_stream_handle);",
          "2131:  return err;",
          "2132: }",
          "2133: module_init(vmci_transport_init);",
          "2135: static void __exit vmci_transport_exit(void)",
          "2136: {",
          "2137:  if (!vmci_handle_is_invalid(vmci_transport_stream_handle)) {",
          "2138:   if (vmci_datagram_destroy_handle(",
          "2139:    vmci_transport_stream_handle) != VMCI_SUCCESS)",
          "2140:    pr_err(\"Couldn't destroy datagram handle\\n\");",
          "2141:   vmci_transport_stream_handle = VMCI_INVALID_HANDLE;",
          "2142:  }",
          "2144:  if (vmci_transport_qp_resumed_sub_id != VMCI_INVALID_ID) {",
          "2145:   vmci_event_unsubscribe(vmci_transport_qp_resumed_sub_id);",
          "2146:   vmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;",
          "2147:  }",
          "2149:  vsock_core_exit();",
          "2150: }",
          "2151: module_exit(vmci_transport_exit);",
          "2153: MODULE_AUTHOR(\"VMware, Inc.\");",
          "2154: MODULE_DESCRIPTION(\"VMCI transport for Virtual Sockets\");",
          "2155: MODULE_LICENSE(\"GPL v2\");",
          "2156: MODULE_ALIAS(\"vmware_vsock\");",
          "2157: MODULE_ALIAS_NETPROTO(PF_VSOCK);",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vmci_transport.h||net/vmw_vsock/vmci_transport.h": [
          "File: net/vmw_vsock/vmci_transport.h -> net/vmw_vsock/vmci_transport.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #ifndef _VMCI_TRANSPORT_H_",
          "17: #define _VMCI_TRANSPORT_H_",
          "19: #include <linux/vmw_vmci_defs.h>",
          "20: #include <linux/vmw_vmci_api.h>",
          "22: #include \"vsock_addr.h\"",
          "23: #include \"af_vsock.h\"",
          "26: #define VMCI_TRANSPORT_PACKET_VERSION 1",
          "29: #define VMCI_TRANSPORT_PACKET_RID 1",
          "31: #define VSOCK_PROTO_INVALID        0",
          "32: #define VSOCK_PROTO_PKT_ON_NOTIFY (1 << 0)",
          "33: #define VSOCK_PROTO_ALL_SUPPORTED (VSOCK_PROTO_PKT_ON_NOTIFY)",
          "35: #define vmci_trans(_vsk) ((struct vmci_transport *)((_vsk)->trans))",
          "37: enum vmci_transport_packet_type {",
          "38:  VMCI_TRANSPORT_PACKET_TYPE_INVALID = 0,",
          "39:  VMCI_TRANSPORT_PACKET_TYPE_REQUEST,",
          "40:  VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE,",
          "41:  VMCI_TRANSPORT_PACKET_TYPE_OFFER,",
          "42:  VMCI_TRANSPORT_PACKET_TYPE_ATTACH,",
          "43:  VMCI_TRANSPORT_PACKET_TYPE_WROTE,",
          "44:  VMCI_TRANSPORT_PACKET_TYPE_READ,",
          "45:  VMCI_TRANSPORT_PACKET_TYPE_RST,",
          "46:  VMCI_TRANSPORT_PACKET_TYPE_SHUTDOWN,",
          "47:  VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE,",
          "48:  VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ,",
          "49:  VMCI_TRANSPORT_PACKET_TYPE_REQUEST2,",
          "50:  VMCI_TRANSPORT_PACKET_TYPE_NEGOTIATE2,",
          "51:  VMCI_TRANSPORT_PACKET_TYPE_MAX",
          "52: };",
          "54: struct vmci_transport_waiting_info {",
          "55:  u64 generation;",
          "56:  u64 offset;",
          "57: };",
          "65: struct vmci_transport_packet {",
          "66:  struct vmci_datagram dg;",
          "67:  u8 version;",
          "68:  u8 type;",
          "69:  u16 proto;",
          "70:  u32 src_port;",
          "71:  u32 dst_port;",
          "72:  u32 _reserved2;",
          "73:  union {",
          "74:   u64 size;",
          "75:   u64 mode;",
          "76:   struct vmci_handle handle;",
          "77:   struct vmci_transport_waiting_info wait;",
          "78:  } u;",
          "79: };",
          "81: struct vmci_transport_notify_pkt {",
          "82:  u64 write_notify_window;",
          "83:  u64 write_notify_min_window;",
          "84:  bool peer_waiting_read;",
          "85:  bool peer_waiting_write;",
          "86:  bool peer_waiting_write_detected;",
          "87:  bool sent_waiting_read;",
          "88:  bool sent_waiting_write;",
          "89:  struct vmci_transport_waiting_info peer_waiting_read_info;",
          "90:  struct vmci_transport_waiting_info peer_waiting_write_info;",
          "91:  u64 produce_q_generation;",
          "92:  u64 consume_q_generation;",
          "93: };",
          "95: struct vmci_transport_notify_pkt_q_state {",
          "96:  u64 write_notify_window;",
          "97:  u64 write_notify_min_window;",
          "98:  bool peer_waiting_write;",
          "99:  bool peer_waiting_write_detected;",
          "100: };",
          "102: union vmci_transport_notify {",
          "103:  struct vmci_transport_notify_pkt pkt;",
          "104:  struct vmci_transport_notify_pkt_q_state pkt_q_state;",
          "105: };",
          "108: struct vmci_transport {",
          "110:  struct vmci_handle dg_handle;",
          "112:  struct vmci_handle qp_handle;",
          "113:  struct vmci_qp *qpair;",
          "114:  u64 produce_size;",
          "115:  u64 consume_size;",
          "116:  u64 queue_pair_size;",
          "117:  u64 queue_pair_min_size;",
          "118:  u64 queue_pair_max_size;",
          "119:  u32 attach_sub_id;",
          "120:  u32 detach_sub_id;",
          "121:  union vmci_transport_notify notify;",
          "122:  struct vmci_transport_notify_ops *notify_ops;",
          "123: };",
          "125: int vmci_transport_register(void);",
          "126: void vmci_transport_unregister(void);",
          "128: int vmci_transport_send_wrote_bh(struct sockaddr_vm *dst,",
          "129:      struct sockaddr_vm *src);",
          "130: int vmci_transport_send_read_bh(struct sockaddr_vm *dst,",
          "131:     struct sockaddr_vm *src);",
          "132: int vmci_transport_send_wrote(struct sock *sk);",
          "133: int vmci_transport_send_read(struct sock *sk);",
          "134: int vmci_transport_send_waiting_write(struct sock *sk,",
          "135:           struct vmci_transport_waiting_info *wait);",
          "136: int vmci_transport_send_waiting_read(struct sock *sk,",
          "137:          struct vmci_transport_waiting_info *wait);",
          "139: #endif",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vmci_transport_notify.c||net/vmw_vsock/vmci_transport_notify.c": [
          "File: net/vmw_vsock/vmci_transport_notify.c -> net/vmw_vsock/vmci_transport_notify.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <linux/types.h>",
          "17: #include <linux/socket.h>",
          "18: #include <linux/stddef.h>",
          "19: #include <net/sock.h>",
          "21: #include \"vmci_transport_notify.h\"",
          "23: #define PKT_FIELD(vsk, field_name) (vmci_trans(vsk)->notify.pkt.field_name)",
          "25: static bool vmci_transport_notify_waiting_write(struct vsock_sock *vsk)",
          "26: {",
          "27: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "28:  bool retval;",
          "29:  u64 notify_limit;",
          "31:  if (!PKT_FIELD(vsk, peer_waiting_write))",
          "32:   return false;",
          "34: #ifdef VSOCK_OPTIMIZATION_FLOW_CONTROL",
          "42:  if (!PKT_FIELD(vsk, peer_waiting_write_detected)) {",
          "43:   PKT_FIELD(vsk, peer_waiting_write_detected) = true;",
          "44:   if (PKT_FIELD(vsk, write_notify_window) < PAGE_SIZE) {",
          "45:    PKT_FIELD(vsk, write_notify_window) =",
          "46:        PKT_FIELD(vsk, write_notify_min_window);",
          "47:   } else {",
          "48:    PKT_FIELD(vsk, write_notify_window) -= PAGE_SIZE;",
          "49:    if (PKT_FIELD(vsk, write_notify_window) <",
          "50:        PKT_FIELD(vsk, write_notify_min_window))",
          "51:     PKT_FIELD(vsk, write_notify_window) =",
          "52:         PKT_FIELD(vsk, write_notify_min_window);",
          "54:   }",
          "55:  }",
          "56:  notify_limit = vmci_trans(vsk)->consume_size -",
          "57:   PKT_FIELD(vsk, write_notify_window);",
          "58: #else",
          "59:  notify_limit = 0;",
          "60: #endif",
          "76:  retval = vmci_qpair_consume_free_space(vmci_trans(vsk)->qpair) >",
          "77:   notify_limit;",
          "78: #ifdef VSOCK_OPTIMIZATION_FLOW_CONTROL",
          "79:  if (retval) {",
          "85:   PKT_FIELD(vsk, peer_waiting_write_detected) = false;",
          "86:  }",
          "87: #endif",
          "88:  return retval;",
          "89: #else",
          "90:  return true;",
          "91: #endif",
          "92: }",
          "94: static bool vmci_transport_notify_waiting_read(struct vsock_sock *vsk)",
          "95: {",
          "96: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "97:  if (!PKT_FIELD(vsk, peer_waiting_read))",
          "98:   return false;",
          "106:  return vmci_qpair_produce_buf_ready(vmci_trans(vsk)->qpair) > 0;",
          "107: #else",
          "108:  return true;",
          "109: #endif",
          "110: }",
          "112: static void",
          "113: vmci_transport_handle_waiting_read(struct sock *sk,",
          "114:        struct vmci_transport_packet *pkt,",
          "115:        bool bottom_half,",
          "116:        struct sockaddr_vm *dst,",
          "117:        struct sockaddr_vm *src)",
          "118: {",
          "119: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "120:  struct vsock_sock *vsk;",
          "122:  vsk = vsock_sk(sk);",
          "124:  PKT_FIELD(vsk, peer_waiting_read) = true;",
          "125:  memcpy(&PKT_FIELD(vsk, peer_waiting_read_info), &pkt->u.wait,",
          "126:         sizeof(PKT_FIELD(vsk, peer_waiting_read_info)));",
          "128:  if (vmci_transport_notify_waiting_read(vsk)) {",
          "129:   bool sent;",
          "131:   if (bottom_half)",
          "132:    sent = vmci_transport_send_wrote_bh(dst, src) > 0;",
          "133:   else",
          "134:    sent = vmci_transport_send_wrote(sk) > 0;",
          "136:   if (sent)",
          "137:    PKT_FIELD(vsk, peer_waiting_read) = false;",
          "138:  }",
          "139: #endif",
          "140: }",
          "142: static void",
          "143: vmci_transport_handle_waiting_write(struct sock *sk,",
          "144:         struct vmci_transport_packet *pkt,",
          "145:         bool bottom_half,",
          "146:         struct sockaddr_vm *dst,",
          "147:         struct sockaddr_vm *src)",
          "148: {",
          "149: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "150:  struct vsock_sock *vsk;",
          "152:  vsk = vsock_sk(sk);",
          "154:  PKT_FIELD(vsk, peer_waiting_write) = true;",
          "155:  memcpy(&PKT_FIELD(vsk, peer_waiting_write_info), &pkt->u.wait,",
          "156:         sizeof(PKT_FIELD(vsk, peer_waiting_write_info)));",
          "158:  if (vmci_transport_notify_waiting_write(vsk)) {",
          "159:   bool sent;",
          "161:   if (bottom_half)",
          "162:    sent = vmci_transport_send_read_bh(dst, src) > 0;",
          "163:   else",
          "164:    sent = vmci_transport_send_read(sk) > 0;",
          "166:   if (sent)",
          "167:    PKT_FIELD(vsk, peer_waiting_write) = false;",
          "168:  }",
          "169: #endif",
          "170: }",
          "172: static void",
          "173: vmci_transport_handle_read(struct sock *sk,",
          "174:       struct vmci_transport_packet *pkt,",
          "175:       bool bottom_half,",
          "176:       struct sockaddr_vm *dst, struct sockaddr_vm *src)",
          "177: {",
          "178: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "179:  struct vsock_sock *vsk;",
          "181:  vsk = vsock_sk(sk);",
          "182:  PKT_FIELD(vsk, sent_waiting_write) = false;",
          "183: #endif",
          "185:  sk->sk_write_space(sk);",
          "186: }",
          "188: static bool send_waiting_read(struct sock *sk, u64 room_needed)",
          "189: {",
          "190: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "191:  struct vsock_sock *vsk;",
          "192:  struct vmci_transport_waiting_info waiting_info;",
          "193:  u64 tail;",
          "194:  u64 head;",
          "195:  u64 room_left;",
          "196:  bool ret;",
          "198:  vsk = vsock_sk(sk);",
          "200:  if (PKT_FIELD(vsk, sent_waiting_read))",
          "201:   return true;",
          "203:  if (PKT_FIELD(vsk, write_notify_window) <",
          "204:    vmci_trans(vsk)->consume_size)",
          "205:   PKT_FIELD(vsk, write_notify_window) =",
          "206:       min(PKT_FIELD(vsk, write_notify_window) + PAGE_SIZE,",
          "207:    vmci_trans(vsk)->consume_size);",
          "209:  vmci_qpair_get_consume_indexes(vmci_trans(vsk)->qpair, &tail, &head);",
          "210:  room_left = vmci_trans(vsk)->consume_size - head;",
          "211:  if (room_needed >= room_left) {",
          "212:   waiting_info.offset = room_needed - room_left;",
          "213:   waiting_info.generation =",
          "214:       PKT_FIELD(vsk, consume_q_generation) + 1;",
          "215:  } else {",
          "216:   waiting_info.offset = head + room_needed;",
          "217:   waiting_info.generation = PKT_FIELD(vsk, consume_q_generation);",
          "218:  }",
          "220:  ret = vmci_transport_send_waiting_read(sk, &waiting_info) > 0;",
          "221:  if (ret)",
          "222:   PKT_FIELD(vsk, sent_waiting_read) = true;",
          "224:  return ret;",
          "225: #else",
          "226:  return true;",
          "227: #endif",
          "228: }",
          "230: static bool send_waiting_write(struct sock *sk, u64 room_needed)",
          "231: {",
          "232: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "233:  struct vsock_sock *vsk;",
          "234:  struct vmci_transport_waiting_info waiting_info;",
          "235:  u64 tail;",
          "236:  u64 head;",
          "237:  u64 room_left;",
          "238:  bool ret;",
          "240:  vsk = vsock_sk(sk);",
          "242:  if (PKT_FIELD(vsk, sent_waiting_write))",
          "243:   return true;",
          "245:  vmci_qpair_get_produce_indexes(vmci_trans(vsk)->qpair, &tail, &head);",
          "246:  room_left = vmci_trans(vsk)->produce_size - tail;",
          "247:  if (room_needed + 1 >= room_left) {",
          "249:   waiting_info.offset = room_needed + 1 - room_left;",
          "250:   waiting_info.generation = PKT_FIELD(vsk, produce_q_generation);",
          "251:  } else {",
          "252:   waiting_info.offset = tail + room_needed + 1;",
          "253:   waiting_info.generation =",
          "254:       PKT_FIELD(vsk, produce_q_generation) - 1;",
          "255:  }",
          "257:  ret = vmci_transport_send_waiting_write(sk, &waiting_info) > 0;",
          "258:  if (ret)",
          "259:   PKT_FIELD(vsk, sent_waiting_write) = true;",
          "261:  return ret;",
          "262: #else",
          "263:  return true;",
          "264: #endif",
          "265: }",
          "267: static int vmci_transport_send_read_notification(struct sock *sk)",
          "268: {",
          "269:  struct vsock_sock *vsk;",
          "270:  bool sent_read;",
          "271:  unsigned int retries;",
          "272:  int err;",
          "274:  vsk = vsock_sk(sk);",
          "275:  sent_read = false;",
          "276:  retries = 0;",
          "277:  err = 0;",
          "279:  if (vmci_transport_notify_waiting_write(vsk)) {",
          "287:   while (!(vsk->peer_shutdown & RCV_SHUTDOWN) &&",
          "288:          !sent_read &&",
          "289:          retries < VMCI_TRANSPORT_MAX_DGRAM_RESENDS) {",
          "290:    err = vmci_transport_send_read(sk);",
          "291:    if (err >= 0)",
          "292:     sent_read = true;",
          "294:    retries++;",
          "295:   }",
          "297:   if (retries >= VMCI_TRANSPORT_MAX_DGRAM_RESENDS)",
          "298:    pr_err(\"%p unable to send read notify to peer\\n\", sk);",
          "299:   else",
          "300: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "301:    PKT_FIELD(vsk, peer_waiting_write) = false;",
          "302: #endif",
          "304:  }",
          "305:  return err;",
          "306: }",
          "308: static void",
          "309: vmci_transport_handle_wrote(struct sock *sk,",
          "310:        struct vmci_transport_packet *pkt,",
          "311:        bool bottom_half,",
          "312:        struct sockaddr_vm *dst, struct sockaddr_vm *src)",
          "313: {",
          "314: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "315:  struct vsock_sock *vsk = vsock_sk(sk);",
          "316:  PKT_FIELD(vsk, sent_waiting_read) = false;",
          "317: #endif",
          "318:  sk->sk_data_ready(sk, 0);",
          "319: }",
          "321: static void vmci_transport_notify_pkt_socket_init(struct sock *sk)",
          "322: {",
          "323:  struct vsock_sock *vsk = vsock_sk(sk);",
          "325:  PKT_FIELD(vsk, write_notify_window) = PAGE_SIZE;",
          "326:  PKT_FIELD(vsk, write_notify_min_window) = PAGE_SIZE;",
          "327:  PKT_FIELD(vsk, peer_waiting_read) = false;",
          "328:  PKT_FIELD(vsk, peer_waiting_write) = false;",
          "329:  PKT_FIELD(vsk, peer_waiting_write_detected) = false;",
          "330:  PKT_FIELD(vsk, sent_waiting_read) = false;",
          "331:  PKT_FIELD(vsk, sent_waiting_write) = false;",
          "332:  PKT_FIELD(vsk, produce_q_generation) = 0;",
          "333:  PKT_FIELD(vsk, consume_q_generation) = 0;",
          "335:  memset(&PKT_FIELD(vsk, peer_waiting_read_info), 0,",
          "336:         sizeof(PKT_FIELD(vsk, peer_waiting_read_info)));",
          "337:  memset(&PKT_FIELD(vsk, peer_waiting_write_info), 0,",
          "338:         sizeof(PKT_FIELD(vsk, peer_waiting_write_info)));",
          "339: }",
          "341: static void vmci_transport_notify_pkt_socket_destruct(struct vsock_sock *vsk)",
          "342: {",
          "343: }",
          "345: static int",
          "346: vmci_transport_notify_pkt_poll_in(struct sock *sk,",
          "347:       size_t target, bool *data_ready_now)",
          "348: {",
          "349:  struct vsock_sock *vsk = vsock_sk(sk);",
          "351:  if (vsock_stream_has_data(vsk)) {",
          "353:  } else {",
          "358:   if (sk->sk_state == SS_CONNECTED) {",
          "359:    if (!send_waiting_read(sk, 1))",
          "360:     return -1;",
          "362:   }",
          "364:  }",
          "366:  return 0;",
          "367: }",
          "369: static int",
          "370: vmci_transport_notify_pkt_poll_out(struct sock *sk,",
          "371:        size_t target, bool *space_avail_now)",
          "372: {",
          "373:  s64 produce_q_free_space;",
          "374:  struct vsock_sock *vsk = vsock_sk(sk);",
          "376:  produce_q_free_space = vsock_stream_has_space(vsk);",
          "377:  if (produce_q_free_space > 0) {",
          "379:   return 0;",
          "380:  } else if (produce_q_free_space == 0) {",
          "389:   if (!send_waiting_write(sk, 1))",
          "390:    return -1;",
          "393:  }",
          "395:  return 0;",
          "396: }",
          "398: static int",
          "399: vmci_transport_notify_pkt_recv_init(",
          "400:    struct sock *sk,",
          "401:    size_t target,",
          "402:    struct vmci_transport_recv_notify_data *data)",
          "403: {",
          "404:  struct vsock_sock *vsk = vsock_sk(sk);",
          "406: #ifdef VSOCK_OPTIMIZATION_WAITING_NOTIFY",
          "407:  data->consume_head = 0;",
          "408:  data->produce_tail = 0;",
          "409: #ifdef VSOCK_OPTIMIZATION_FLOW_CONTROL",
          "410:  data->notify_on_block = false;",
          "412:  if (PKT_FIELD(vsk, write_notify_min_window) < target + 1) {",
          "413:   PKT_FIELD(vsk, write_notify_min_window) = target + 1;",
          "414:   if (PKT_FIELD(vsk, write_notify_window) <",
          "415:       PKT_FIELD(vsk, write_notify_min_window)) {",
          "423:    PKT_FIELD(vsk, write_notify_window) =",
          "424:        PKT_FIELD(vsk, write_notify_min_window);",
          "425:    data->notify_on_block = true;",
          "426:   }",
          "427:  }",
          "428: #endif",
          "429: #endif",
          "431:  return 0;",
          "432: }",
          "434: static int",
          "435: vmci_transport_notify_pkt_recv_pre_block(",
          "436:     struct sock *sk,",
          "437:     size_t target,",
          "438:     struct vmci_transport_recv_notify_data *data)",
          "439: {",
          "440:  int err = 0;",
          "443:  if (!send_waiting_read(sk, target)) {",
          "444:   err = -EHOSTUNREACH;",
          "445:   return err;",
          "446:  }",
          "447: #ifdef VSOCK_OPTIMIZATION_FLOW_CONTROL",
          "448:  if (data->notify_on_block) {",
          "449:   err = vmci_transport_send_read_notification(sk);",
          "450:   if (err < 0)",
          "451:    return err;",
          "453:   data->notify_on_block = false;",
          "454:  }",
          "455: #endif",
          "457:  return err;",
          "458: }",
          "460: static int",
          "461: vmci_transport_notify_pkt_recv_pre_dequeue(",
          "462:     struct sock *sk,",
          "463:     size_t target,",
          "464:     struct vmci_transport_recv_notify_data *data)",
          "465: {",
          "466:  struct vsock_sock *vsk = vsock_sk(sk);",
          "471: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "472:  vmci_qpair_get_consume_indexes(vmci_trans(vsk)->qpair,",
          "473:            &data->produce_tail,",
          "474:            &data->consume_head);",
          "475: #endif",
          "477:  return 0;",
          "478: }",
          "480: static int",
          "481: vmci_transport_notify_pkt_recv_post_dequeue(",
          "482:     struct sock *sk,",
          "483:     size_t target,",
          "484:     ssize_t copied,",
          "485:     bool data_read,",
          "486:     struct vmci_transport_recv_notify_data *data)",
          "487: {",
          "488:  struct vsock_sock *vsk;",
          "489:  int err;",
          "491:  vsk = vsock_sk(sk);",
          "492:  err = 0;",
          "494:  if (data_read) {",
          "495: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "500:   if (copied >=",
          "501:    vmci_trans(vsk)->consume_size - data->consume_head)",
          "502:    PKT_FIELD(vsk, consume_q_generation)++;",
          "503: #endif",
          "505:   err = vmci_transport_send_read_notification(sk);",
          "506:   if (err < 0)",
          "507:    return err;",
          "509:  }",
          "510:  return err;",
          "511: }",
          "513: static int",
          "514: vmci_transport_notify_pkt_send_init(",
          "515:    struct sock *sk,",
          "516:    struct vmci_transport_send_notify_data *data)",
          "517: {",
          "518: #ifdef VSOCK_OPTIMIZATION_WAITING_NOTIFY",
          "519:  data->consume_head = 0;",
          "520:  data->produce_tail = 0;",
          "521: #endif",
          "523:  return 0;",
          "524: }",
          "526: static int",
          "527: vmci_transport_notify_pkt_send_pre_block(",
          "528:     struct sock *sk,",
          "529:     struct vmci_transport_send_notify_data *data)",
          "530: {",
          "532:  if (!send_waiting_write(sk, 1))",
          "533:   return -EHOSTUNREACH;",
          "535:  return 0;",
          "536: }",
          "538: static int",
          "539: vmci_transport_notify_pkt_send_pre_enqueue(",
          "540:     struct sock *sk,",
          "541:     struct vmci_transport_send_notify_data *data)",
          "542: {",
          "543:  struct vsock_sock *vsk = vsock_sk(sk);",
          "545: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "546:  vmci_qpair_get_produce_indexes(vmci_trans(vsk)->qpair,",
          "547:            &data->produce_tail,",
          "548:            &data->consume_head);",
          "549: #endif",
          "551:  return 0;",
          "552: }",
          "554: static int",
          "555: vmci_transport_notify_pkt_send_post_enqueue(",
          "556:     struct sock *sk,",
          "557:     ssize_t written,",
          "558:     struct vmci_transport_send_notify_data *data)",
          "559: {",
          "560:  int err = 0;",
          "561:  struct vsock_sock *vsk;",
          "562:  bool sent_wrote = false;",
          "563:  int retries = 0;",
          "565:  vsk = vsock_sk(sk);",
          "567: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "572:  if (written >= vmci_trans(vsk)->produce_size - data->produce_tail)",
          "573:   PKT_FIELD(vsk, produce_q_generation)++;",
          "575: #endif",
          "577:  if (vmci_transport_notify_waiting_read(vsk)) {",
          "583:   while (!(vsk->peer_shutdown & RCV_SHUTDOWN) &&",
          "584:          !sent_wrote &&",
          "585:          retries < VMCI_TRANSPORT_MAX_DGRAM_RESENDS) {",
          "586:    err = vmci_transport_send_wrote(sk);",
          "587:    if (err >= 0)",
          "588:     sent_wrote = true;",
          "590:    retries++;",
          "591:   }",
          "593:   if (retries >= VMCI_TRANSPORT_MAX_DGRAM_RESENDS) {",
          "594:    pr_err(\"%p unable to send wrote notify to peer\\n\", sk);",
          "595:    return err;",
          "596:   } else {",
          "597: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "598:    PKT_FIELD(vsk, peer_waiting_read) = false;",
          "599: #endif",
          "600:   }",
          "601:  }",
          "602:  return err;",
          "603: }",
          "605: static void",
          "606: vmci_transport_notify_pkt_handle_pkt(",
          "607:    struct sock *sk,",
          "608:    struct vmci_transport_packet *pkt,",
          "609:    bool bottom_half,",
          "610:    struct sockaddr_vm *dst,",
          "611:    struct sockaddr_vm *src, bool *pkt_processed)",
          "612: {",
          "613:  bool processed = false;",
          "615:  switch (pkt->type) {",
          "616:  case VMCI_TRANSPORT_PACKET_TYPE_WROTE:",
          "617:   vmci_transport_handle_wrote(sk, pkt, bottom_half, dst, src);",
          "618:   processed = true;",
          "619:   break;",
          "620:  case VMCI_TRANSPORT_PACKET_TYPE_READ:",
          "621:   vmci_transport_handle_read(sk, pkt, bottom_half, dst, src);",
          "622:   processed = true;",
          "623:   break;",
          "624:  case VMCI_TRANSPORT_PACKET_TYPE_WAITING_WRITE:",
          "625:   vmci_transport_handle_waiting_write(sk, pkt, bottom_half,",
          "626:           dst, src);",
          "627:   processed = true;",
          "628:   break;",
          "630:  case VMCI_TRANSPORT_PACKET_TYPE_WAITING_READ:",
          "631:   vmci_transport_handle_waiting_read(sk, pkt, bottom_half,",
          "632:          dst, src);",
          "633:   processed = true;",
          "634:   break;",
          "635:  }",
          "637:  if (pkt_processed)",
          "639: }",
          "641: static void vmci_transport_notify_pkt_process_request(struct sock *sk)",
          "642: {",
          "643:  struct vsock_sock *vsk = vsock_sk(sk);",
          "645:  PKT_FIELD(vsk, write_notify_window) = vmci_trans(vsk)->consume_size;",
          "646:  if (vmci_trans(vsk)->consume_size <",
          "647:   PKT_FIELD(vsk, write_notify_min_window))",
          "648:   PKT_FIELD(vsk, write_notify_min_window) =",
          "649:    vmci_trans(vsk)->consume_size;",
          "650: }",
          "652: static void vmci_transport_notify_pkt_process_negotiate(struct sock *sk)",
          "653: {",
          "654:  struct vsock_sock *vsk = vsock_sk(sk);",
          "656:  PKT_FIELD(vsk, write_notify_window) = vmci_trans(vsk)->consume_size;",
          "657:  if (vmci_trans(vsk)->consume_size <",
          "658:   PKT_FIELD(vsk, write_notify_min_window))",
          "659:   PKT_FIELD(vsk, write_notify_min_window) =",
          "660:    vmci_trans(vsk)->consume_size;",
          "661: }",
          "664: struct vmci_transport_notify_ops vmci_transport_notify_pkt_ops = {",
          "665:  vmci_transport_notify_pkt_socket_init,",
          "666:  vmci_transport_notify_pkt_socket_destruct,",
          "667:  vmci_transport_notify_pkt_poll_in,",
          "668:  vmci_transport_notify_pkt_poll_out,",
          "669:  vmci_transport_notify_pkt_handle_pkt,",
          "670:  vmci_transport_notify_pkt_recv_init,",
          "671:  vmci_transport_notify_pkt_recv_pre_block,",
          "672:  vmci_transport_notify_pkt_recv_pre_dequeue,",
          "673:  vmci_transport_notify_pkt_recv_post_dequeue,",
          "674:  vmci_transport_notify_pkt_send_init,",
          "675:  vmci_transport_notify_pkt_send_pre_block,",
          "676:  vmci_transport_notify_pkt_send_pre_enqueue,",
          "677:  vmci_transport_notify_pkt_send_post_enqueue,",
          "678:  vmci_transport_notify_pkt_process_request,",
          "679:  vmci_transport_notify_pkt_process_negotiate,",
          "680: };",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vmci_transport_notify.h||net/vmw_vsock/vmci_transport_notify.h": [
          "File: net/vmw_vsock/vmci_transport_notify.h -> net/vmw_vsock/vmci_transport_notify.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #ifndef __VMCI_TRANSPORT_NOTIFY_H__",
          "17: #define __VMCI_TRANSPORT_NOTIFY_H__",
          "19: #include <linux/types.h>",
          "20: #include <linux/vmw_vmci_defs.h>",
          "21: #include <linux/vmw_vmci_api.h>",
          "22: #include <linux/vm_sockets.h>",
          "24: #include \"vmci_transport.h\"",
          "27: #define VSOCK_OPTIMIZATION_WAITING_NOTIFY 1",
          "28: #if defined(VSOCK_OPTIMIZATION_WAITING_NOTIFY)",
          "30: #define VSOCK_OPTIMIZATION_FLOW_CONTROL 1",
          "31: #endif",
          "33: #define VMCI_TRANSPORT_MAX_DGRAM_RESENDS       10",
          "35: struct vmci_transport_recv_notify_data {",
          "36:  u64 consume_head;",
          "37:  u64 produce_tail;",
          "38:  bool notify_on_block;",
          "39: };",
          "41: struct vmci_transport_send_notify_data {",
          "42:  u64 consume_head;",
          "43:  u64 produce_tail;",
          "44: };",
          "47: struct vmci_transport_notify_ops {",
          "48:  void (*socket_init) (struct sock *sk);",
          "49:  void (*socket_destruct) (struct vsock_sock *vsk);",
          "50:  int (*poll_in) (struct sock *sk, size_t target,",
          "51:      bool *data_ready_now);",
          "52:  int (*poll_out) (struct sock *sk, size_t target,",
          "53:       bool *space_avail_now);",
          "54:  void (*handle_notify_pkt) (struct sock *sk,",
          "55:        struct vmci_transport_packet *pkt,",
          "56:        bool bottom_half, struct sockaddr_vm *dst,",
          "57:        struct sockaddr_vm *src,",
          "58:        bool *pkt_processed);",
          "59:  int (*recv_init) (struct sock *sk, size_t target,",
          "60:      struct vmci_transport_recv_notify_data *data);",
          "61:  int (*recv_pre_block) (struct sock *sk, size_t target,",
          "62:           struct vmci_transport_recv_notify_data *data);",
          "63:  int (*recv_pre_dequeue) (struct sock *sk, size_t target,",
          "64:      struct vmci_transport_recv_notify_data *data);",
          "65:  int (*recv_post_dequeue) (struct sock *sk, size_t target,",
          "66:       ssize_t copied, bool data_read,",
          "67:       struct vmci_transport_recv_notify_data *data);",
          "68:  int (*send_init) (struct sock *sk,",
          "69:      struct vmci_transport_send_notify_data *data);",
          "70:  int (*send_pre_block) (struct sock *sk,",
          "71:           struct vmci_transport_send_notify_data *data);",
          "72:  int (*send_pre_enqueue) (struct sock *sk,",
          "73:      struct vmci_transport_send_notify_data *data);",
          "74:  int (*send_post_enqueue) (struct sock *sk, ssize_t written,",
          "75:       struct vmci_transport_send_notify_data *data);",
          "76:  void (*process_request) (struct sock *sk);",
          "77:  void (*process_negotiate) (struct sock *sk);",
          "78: };",
          "80: extern struct vmci_transport_notify_ops vmci_transport_notify_pkt_ops;",
          "81: extern struct vmci_transport_notify_ops vmci_transport_notify_pkt_q_state_ops;",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vmci_transport_notify_qstate.c||net/vmw_vsock/vmci_transport_notify_qstate.c": [
          "File: net/vmw_vsock/vmci_transport_notify_qstate.c -> net/vmw_vsock/vmci_transport_notify_qstate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <linux/types.h>",
          "17: #include <linux/socket.h>",
          "18: #include <linux/stddef.h>",
          "19: #include <net/sock.h>",
          "21: #include \"vmci_transport_notify.h\"",
          "23: #define PKT_FIELD(vsk, field_name) \\",
          "24:  (vmci_trans(vsk)->notify.pkt_q_state.field_name)",
          "26: static bool vmci_transport_notify_waiting_write(struct vsock_sock *vsk)",
          "27: {",
          "28:  bool retval;",
          "29:  u64 notify_limit;",
          "31:  if (!PKT_FIELD(vsk, peer_waiting_write))",
          "32:   return false;",
          "41:  if (!PKT_FIELD(vsk, peer_waiting_write_detected)) {",
          "42:   PKT_FIELD(vsk, peer_waiting_write_detected) = true;",
          "43:   if (PKT_FIELD(vsk, write_notify_window) < PAGE_SIZE) {",
          "44:    PKT_FIELD(vsk, write_notify_window) =",
          "45:        PKT_FIELD(vsk, write_notify_min_window);",
          "46:   } else {",
          "47:    PKT_FIELD(vsk, write_notify_window) -= PAGE_SIZE;",
          "48:    if (PKT_FIELD(vsk, write_notify_window) <",
          "49:        PKT_FIELD(vsk, write_notify_min_window))",
          "50:     PKT_FIELD(vsk, write_notify_window) =",
          "51:         PKT_FIELD(vsk, write_notify_min_window);",
          "53:   }",
          "54:  }",
          "55:  notify_limit = vmci_trans(vsk)->consume_size -",
          "56:   PKT_FIELD(vsk, write_notify_window);",
          "67:  retval = vmci_qpair_consume_free_space(vmci_trans(vsk)->qpair) >",
          "68:   notify_limit;",
          "70:  if (retval) {",
          "75:   PKT_FIELD(vsk, peer_waiting_write_detected) = false;",
          "76:  }",
          "77:  return retval;",
          "78: }",
          "80: static void",
          "81: vmci_transport_handle_read(struct sock *sk,",
          "82:       struct vmci_transport_packet *pkt,",
          "83:       bool bottom_half,",
          "84:       struct sockaddr_vm *dst, struct sockaddr_vm *src)",
          "85: {",
          "86:  sk->sk_write_space(sk);",
          "87: }",
          "89: static void",
          "90: vmci_transport_handle_wrote(struct sock *sk,",
          "91:        struct vmci_transport_packet *pkt,",
          "92:        bool bottom_half,",
          "93:        struct sockaddr_vm *dst, struct sockaddr_vm *src)",
          "94: {",
          "95:  sk->sk_data_ready(sk, 0);",
          "96: }",
          "98: static void vsock_block_update_write_window(struct sock *sk)",
          "99: {",
          "100:  struct vsock_sock *vsk = vsock_sk(sk);",
          "102:  if (PKT_FIELD(vsk, write_notify_window) < vmci_trans(vsk)->consume_size)",
          "103:   PKT_FIELD(vsk, write_notify_window) =",
          "104:       min(PKT_FIELD(vsk, write_notify_window) + PAGE_SIZE,",
          "105:    vmci_trans(vsk)->consume_size);",
          "106: }",
          "108: static int vmci_transport_send_read_notification(struct sock *sk)",
          "109: {",
          "110:  struct vsock_sock *vsk;",
          "111:  bool sent_read;",
          "112:  unsigned int retries;",
          "113:  int err;",
          "115:  vsk = vsock_sk(sk);",
          "116:  sent_read = false;",
          "117:  retries = 0;",
          "118:  err = 0;",
          "120:  if (vmci_transport_notify_waiting_write(vsk)) {",
          "128:   while (!(vsk->peer_shutdown & RCV_SHUTDOWN) &&",
          "129:          !sent_read &&",
          "130:          retries < VMCI_TRANSPORT_MAX_DGRAM_RESENDS) {",
          "131:    err = vmci_transport_send_read(sk);",
          "132:    if (err >= 0)",
          "133:     sent_read = true;",
          "135:    retries++;",
          "136:   }",
          "138:   if (retries >= VMCI_TRANSPORT_MAX_DGRAM_RESENDS && !sent_read)",
          "139:    pr_err(\"%p unable to send read notification to peer\\n\",",
          "140:           sk);",
          "141:   else",
          "142:    PKT_FIELD(vsk, peer_waiting_write) = false;",
          "144:  }",
          "145:  return err;",
          "146: }",
          "148: static void vmci_transport_notify_pkt_socket_init(struct sock *sk)",
          "149: {",
          "150:  struct vsock_sock *vsk = vsock_sk(sk);",
          "152:  PKT_FIELD(vsk, write_notify_window) = PAGE_SIZE;",
          "153:  PKT_FIELD(vsk, write_notify_min_window) = PAGE_SIZE;",
          "154:  PKT_FIELD(vsk, peer_waiting_write) = false;",
          "155:  PKT_FIELD(vsk, peer_waiting_write_detected) = false;",
          "156: }",
          "158: static void vmci_transport_notify_pkt_socket_destruct(struct vsock_sock *vsk)",
          "159: {",
          "160:  PKT_FIELD(vsk, write_notify_window) = PAGE_SIZE;",
          "161:  PKT_FIELD(vsk, write_notify_min_window) = PAGE_SIZE;",
          "162:  PKT_FIELD(vsk, peer_waiting_write) = false;",
          "163:  PKT_FIELD(vsk, peer_waiting_write_detected) = false;",
          "164: }",
          "166: static int",
          "167: vmci_transport_notify_pkt_poll_in(struct sock *sk,",
          "168:       size_t target, bool *data_ready_now)",
          "169: {",
          "170:  struct vsock_sock *vsk = vsock_sk(sk);",
          "172:  if (vsock_stream_has_data(vsk)) {",
          "174:  } else {",
          "179:   if (sk->sk_state == SS_CONNECTED)",
          "180:    vsock_block_update_write_window(sk);",
          "182:  }",
          "184:  return 0;",
          "185: }",
          "187: static int",
          "188: vmci_transport_notify_pkt_poll_out(struct sock *sk,",
          "189:        size_t target, bool *space_avail_now)",
          "190: {",
          "191:  s64 produce_q_free_space;",
          "192:  struct vsock_sock *vsk = vsock_sk(sk);",
          "194:  produce_q_free_space = vsock_stream_has_space(vsk);",
          "195:  if (produce_q_free_space > 0) {",
          "197:   return 0;",
          "198:  } else if (produce_q_free_space == 0) {",
          "203:  }",
          "205:  return 0;",
          "206: }",
          "208: static int",
          "209: vmci_transport_notify_pkt_recv_init(",
          "210:     struct sock *sk,",
          "211:     size_t target,",
          "212:     struct vmci_transport_recv_notify_data *data)",
          "213: {",
          "214:  struct vsock_sock *vsk = vsock_sk(sk);",
          "216:  data->consume_head = 0;",
          "217:  data->produce_tail = 0;",
          "218:  data->notify_on_block = false;",
          "220:  if (PKT_FIELD(vsk, write_notify_min_window) < target + 1) {",
          "221:   PKT_FIELD(vsk, write_notify_min_window) = target + 1;",
          "222:   if (PKT_FIELD(vsk, write_notify_window) <",
          "223:       PKT_FIELD(vsk, write_notify_min_window)) {",
          "231:    PKT_FIELD(vsk, write_notify_window) =",
          "232:        PKT_FIELD(vsk, write_notify_min_window);",
          "233:    data->notify_on_block = true;",
          "234:   }",
          "235:  }",
          "237:  return 0;",
          "238: }",
          "240: static int",
          "241: vmci_transport_notify_pkt_recv_pre_block(",
          "242:     struct sock *sk,",
          "243:     size_t target,",
          "244:     struct vmci_transport_recv_notify_data *data)",
          "245: {",
          "246:  int err = 0;",
          "248:  vsock_block_update_write_window(sk);",
          "250:  if (data->notify_on_block) {",
          "251:   err = vmci_transport_send_read_notification(sk);",
          "252:   if (err < 0)",
          "253:    return err;",
          "254:   data->notify_on_block = false;",
          "255:  }",
          "257:  return err;",
          "258: }",
          "260: static int",
          "261: vmci_transport_notify_pkt_recv_post_dequeue(",
          "262:     struct sock *sk,",
          "263:     size_t target,",
          "264:     ssize_t copied,",
          "265:     bool data_read,",
          "266:     struct vmci_transport_recv_notify_data *data)",
          "267: {",
          "268:  struct vsock_sock *vsk;",
          "269:  int err;",
          "270:  bool was_full = false;",
          "271:  u64 free_space;",
          "273:  vsk = vsock_sk(sk);",
          "274:  err = 0;",
          "276:  if (data_read) {",
          "277:   smp_mb();",
          "279:   free_space =",
          "280:    vmci_qpair_consume_free_space(vmci_trans(vsk)->qpair);",
          "281:   was_full = free_space == copied;",
          "283:   if (was_full)",
          "284:    PKT_FIELD(vsk, peer_waiting_write) = true;",
          "286:   err = vmci_transport_send_read_notification(sk);",
          "287:   if (err < 0)",
          "288:    return err;",
          "293:   sk->sk_data_ready(sk, 0);",
          "294:  }",
          "296:  return err;",
          "297: }",
          "299: static int",
          "300: vmci_transport_notify_pkt_send_init(",
          "301:     struct sock *sk,",
          "302:     struct vmci_transport_send_notify_data *data)",
          "303: {",
          "304:  data->consume_head = 0;",
          "305:  data->produce_tail = 0;",
          "307:  return 0;",
          "308: }",
          "310: static int",
          "311: vmci_transport_notify_pkt_send_post_enqueue(",
          "312:     struct sock *sk,",
          "313:     ssize_t written,",
          "314:     struct vmci_transport_send_notify_data *data)",
          "315: {",
          "316:  int err = 0;",
          "317:  struct vsock_sock *vsk;",
          "318:  bool sent_wrote = false;",
          "319:  bool was_empty;",
          "320:  int retries = 0;",
          "322:  vsk = vsock_sk(sk);",
          "324:  smp_mb();",
          "326:  was_empty =",
          "327:   vmci_qpair_produce_buf_ready(vmci_trans(vsk)->qpair) == written;",
          "328:  if (was_empty) {",
          "329:   while (!(vsk->peer_shutdown & RCV_SHUTDOWN) &&",
          "330:          !sent_wrote &&",
          "331:          retries < VMCI_TRANSPORT_MAX_DGRAM_RESENDS) {",
          "332:    err = vmci_transport_send_wrote(sk);",
          "333:    if (err >= 0)",
          "334:     sent_wrote = true;",
          "336:    retries++;",
          "337:   }",
          "338:  }",
          "340:  if (retries >= VMCI_TRANSPORT_MAX_DGRAM_RESENDS && !sent_wrote) {",
          "341:   pr_err(\"%p unable to send wrote notification to peer\\n\",",
          "342:          sk);",
          "343:   return err;",
          "344:  }",
          "346:  return err;",
          "347: }",
          "349: static void",
          "350: vmci_transport_notify_pkt_handle_pkt(",
          "351:     struct sock *sk,",
          "352:     struct vmci_transport_packet *pkt,",
          "353:     bool bottom_half,",
          "354:     struct sockaddr_vm *dst,",
          "355:     struct sockaddr_vm *src, bool *pkt_processed)",
          "356: {",
          "357:  bool processed = false;",
          "359:  switch (pkt->type) {",
          "360:  case VMCI_TRANSPORT_PACKET_TYPE_WROTE:",
          "361:   vmci_transport_handle_wrote(sk, pkt, bottom_half, dst, src);",
          "362:   processed = true;",
          "363:   break;",
          "364:  case VMCI_TRANSPORT_PACKET_TYPE_READ:",
          "365:   vmci_transport_handle_read(sk, pkt, bottom_half, dst, src);",
          "366:   processed = true;",
          "367:   break;",
          "368:  }",
          "370:  if (pkt_processed)",
          "372: }",
          "374: static void vmci_transport_notify_pkt_process_request(struct sock *sk)",
          "375: {",
          "376:  struct vsock_sock *vsk = vsock_sk(sk);",
          "378:  PKT_FIELD(vsk, write_notify_window) = vmci_trans(vsk)->consume_size;",
          "379:  if (vmci_trans(vsk)->consume_size <",
          "380:   PKT_FIELD(vsk, write_notify_min_window))",
          "381:   PKT_FIELD(vsk, write_notify_min_window) =",
          "382:    vmci_trans(vsk)->consume_size;",
          "383: }",
          "385: static void vmci_transport_notify_pkt_process_negotiate(struct sock *sk)",
          "386: {",
          "387:  struct vsock_sock *vsk = vsock_sk(sk);",
          "389:  PKT_FIELD(vsk, write_notify_window) = vmci_trans(vsk)->consume_size;",
          "390:  if (vmci_trans(vsk)->consume_size <",
          "391:   PKT_FIELD(vsk, write_notify_min_window))",
          "392:   PKT_FIELD(vsk, write_notify_min_window) =",
          "393:    vmci_trans(vsk)->consume_size;",
          "394: }",
          "396: static int",
          "397: vmci_transport_notify_pkt_recv_pre_dequeue(",
          "398:     struct sock *sk,",
          "399:     size_t target,",
          "400:     struct vmci_transport_recv_notify_data *data)",
          "401: {",
          "403: }",
          "405: static int",
          "406: vmci_transport_notify_pkt_send_pre_block(",
          "407:     struct sock *sk,",
          "408:     struct vmci_transport_send_notify_data *data)",
          "409: {",
          "411: }",
          "413: static int",
          "414: vmci_transport_notify_pkt_send_pre_enqueue(",
          "415:     struct sock *sk,",
          "416:     struct vmci_transport_send_notify_data *data)",
          "417: {",
          "419: }",
          "422: struct vmci_transport_notify_ops vmci_transport_notify_pkt_q_state_ops = {",
          "423:  vmci_transport_notify_pkt_socket_init,",
          "424:  vmci_transport_notify_pkt_socket_destruct,",
          "425:  vmci_transport_notify_pkt_poll_in,",
          "426:  vmci_transport_notify_pkt_poll_out,",
          "427:  vmci_transport_notify_pkt_handle_pkt,",
          "428:  vmci_transport_notify_pkt_recv_init,",
          "429:  vmci_transport_notify_pkt_recv_pre_block,",
          "430:  vmci_transport_notify_pkt_recv_pre_dequeue,",
          "431:  vmci_transport_notify_pkt_recv_post_dequeue,",
          "432:  vmci_transport_notify_pkt_send_init,",
          "433:  vmci_transport_notify_pkt_send_pre_block,",
          "434:  vmci_transport_notify_pkt_send_pre_enqueue,",
          "435:  vmci_transport_notify_pkt_send_post_enqueue,",
          "436:  vmci_transport_notify_pkt_process_request,",
          "437:  vmci_transport_notify_pkt_process_negotiate,",
          "438: };",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vsock_addr.c||net/vmw_vsock/vsock_addr.c": [
          "File: net/vmw_vsock/vsock_addr.c -> net/vmw_vsock/vsock_addr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <linux/types.h>",
          "17: #include <linux/socket.h>",
          "18: #include <linux/stddef.h>",
          "19: #include <net/sock.h>",
          "21: #include \"vsock_addr.h\"",
          "23: void vsock_addr_init(struct sockaddr_vm *addr, u32 cid, u32 port)",
          "24: {",
          "25:  memset(addr, 0, sizeof(*addr));",
          "26:  addr->svm_family = AF_VSOCK;",
          "27:  addr->svm_cid = cid;",
          "28:  addr->svm_port = port;",
          "29: }",
          "30: EXPORT_SYMBOL_GPL(vsock_addr_init);",
          "32: int vsock_addr_validate(const struct sockaddr_vm *addr)",
          "33: {",
          "34:  if (!addr)",
          "35:   return -EFAULT;",
          "37:  if (addr->svm_family != AF_VSOCK)",
          "38:   return -EAFNOSUPPORT;",
          "40:  if (addr->svm_zero[0] != 0)",
          "41:   return -EINVAL;",
          "43:  return 0;",
          "44: }",
          "45: EXPORT_SYMBOL_GPL(vsock_addr_validate);",
          "47: bool vsock_addr_bound(const struct sockaddr_vm *addr)",
          "48: {",
          "49:  return addr->svm_port != VMADDR_PORT_ANY;",
          "50: }",
          "51: EXPORT_SYMBOL_GPL(vsock_addr_bound);",
          "53: void vsock_addr_unbind(struct sockaddr_vm *addr)",
          "54: {",
          "55:  vsock_addr_init(addr, VMADDR_CID_ANY, VMADDR_PORT_ANY);",
          "56: }",
          "57: EXPORT_SYMBOL_GPL(vsock_addr_unbind);",
          "59: bool vsock_addr_equals_addr(const struct sockaddr_vm *addr,",
          "60:        const struct sockaddr_vm *other)",
          "61: {",
          "62:  return addr->svm_cid == other->svm_cid &&",
          "63:   addr->svm_port == other->svm_port;",
          "64: }",
          "65: EXPORT_SYMBOL_GPL(vsock_addr_equals_addr);",
          "67: bool vsock_addr_equals_addr_any(const struct sockaddr_vm *addr,",
          "68:     const struct sockaddr_vm *other)",
          "69: {",
          "70:  return (addr->svm_cid == VMADDR_CID_ANY ||",
          "71:   other->svm_cid == VMADDR_CID_ANY ||",
          "72:   addr->svm_cid == other->svm_cid) &&",
          "73:         addr->svm_port == other->svm_port;",
          "74: }",
          "75: EXPORT_SYMBOL_GPL(vsock_addr_equals_addr_any);",
          "77: int vsock_addr_cast(const struct sockaddr *addr,",
          "78:       size_t len, struct sockaddr_vm **out_addr)",
          "79: {",
          "80:  if (len < sizeof(**out_addr))",
          "81:   return -EFAULT;",
          "84:  return vsock_addr_validate(*out_addr);",
          "85: }",
          "86: EXPORT_SYMBOL_GPL(vsock_addr_cast);",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vsock_addr.h||net/vmw_vsock/vsock_addr.h": [
          "File: net/vmw_vsock/vsock_addr.h -> net/vmw_vsock/vsock_addr.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #ifndef _VSOCK_ADDR_H_",
          "17: #define _VSOCK_ADDR_H_",
          "19: #include <linux/vm_sockets.h>",
          "21: void vsock_addr_init(struct sockaddr_vm *addr, u32 cid, u32 port);",
          "22: int vsock_addr_validate(const struct sockaddr_vm *addr);",
          "23: bool vsock_addr_bound(const struct sockaddr_vm *addr);",
          "24: void vsock_addr_unbind(struct sockaddr_vm *addr);",
          "25: bool vsock_addr_equals_addr(const struct sockaddr_vm *addr,",
          "26:        const struct sockaddr_vm *other);",
          "27: bool vsock_addr_equals_addr_any(const struct sockaddr_vm *addr,",
          "28:     const struct sockaddr_vm *other);",
          "29: int vsock_addr_cast(const struct sockaddr *addr, size_t len,",
          "30:       struct sockaddr_vm **out_addr);",
          "32: #endif",
          "",
          "---------------"
        ],
        "net/vmw_vsock/vsock_version.h||net/vmw_vsock/vsock_version.h": [
          "File: net/vmw_vsock/vsock_version.h -> net/vmw_vsock/vsock_version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #ifndef _VSOCK_VERSION_H_",
          "17: #define _VSOCK_VERSION_H_",
          "19: #define VSOCK_DRIVER_VERSION_PARTS { 1, 0, 0, 0 }",
          "20: #define VSOCK_DRIVER_VERSION_STRING \"1.0.0.0-k\"",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "40eea803c6b2cfaab092f053248cbeab3f368412",
      "candidate_info": {
        "commit_hash": "40eea803c6b2cfaab092f053248cbeab3f368412",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/40eea803c6b2cfaab092f053248cbeab3f368412",
        "files": [
          "net/compat.c",
          "net/core/iovec.c"
        ],
        "message": "net: sendmsg: fix NULL pointer dereference\n\nSasha's report:\n\t> While fuzzing with trinity inside a KVM tools guest running the latest -next\n\t> kernel with the KASAN patchset, I've stumbled on the following spew:\n\t>\n\t> [ 4448.949424] ==================================================================\n\t> [ 4448.951737] AddressSanitizer: user-memory-access on address 0\n\t> [ 4448.952988] Read of size 2 by thread T19638:\n\t> [ 4448.954510] CPU: 28 PID: 19638 Comm: trinity-c76 Not tainted 3.16.0-rc4-next-20140711-sasha-00046-g07d3099-dirty #813\n\t> [ 4448.956823]  ffff88046d86ca40 0000000000000000 ffff880082f37e78 ffff880082f37a40\n\t> [ 4448.958233]  ffffffffb6e47068 ffff880082f37a68 ffff880082f37a58 ffffffffb242708d\n\t> [ 4448.959552]  0000000000000000 ffff880082f37a88 ffffffffb24255b1 0000000000000000\n\t> [ 4448.961266] Call Trace:\n\t> [ 4448.963158] dump_stack (lib/dump_stack.c:52)\n\t> [ 4448.964244] kasan_report_user_access (mm/kasan/report.c:184)\n\t> [ 4448.965507] __asan_load2 (mm/kasan/kasan.c:352)\n\t> [ 4448.966482] ? netlink_sendmsg (net/netlink/af_netlink.c:2339)\n\t> [ 4448.967541] netlink_sendmsg (net/netlink/af_netlink.c:2339)\n\t> [ 4448.968537] ? get_parent_ip (kernel/sched/core.c:2555)\n\t> [ 4448.970103] sock_sendmsg (net/socket.c:654)\n\t> [ 4448.971584] ? might_fault (mm/memory.c:3741)\n\t> [ 4448.972526] ? might_fault (./arch/x86/include/asm/current.h:14 mm/memory.c:3740)\n\t> [ 4448.973596] ? verify_iovec (net/core/iovec.c:64)\n\t> [ 4448.974522] ___sys_sendmsg (net/socket.c:2096)\n\t> [ 4448.975797] ? put_lock_stats.isra.13 (./arch/x86/include/asm/preempt.h:98 kernel/locking/lockdep.c:254)\n\t> [ 4448.977030] ? lock_release_holdtime (kernel/locking/lockdep.c:273)\n\t> [ 4448.978197] ? lock_release_non_nested (kernel/locking/lockdep.c:3434 (discriminator 1))\n\t> [ 4448.979346] ? check_chain_key (kernel/locking/lockdep.c:2188)\n\t> [ 4448.980535] __sys_sendmmsg (net/socket.c:2181)\n\t> [ 4448.981592] ? trace_hardirqs_on_caller (kernel/locking/lockdep.c:2600)\n\t> [ 4448.982773] ? trace_hardirqs_on (kernel/locking/lockdep.c:2607)\n\t> [ 4448.984458] ? syscall_trace_enter (arch/x86/kernel/ptrace.c:1500 (discriminator 2))\n\t> [ 4448.985621] ? trace_hardirqs_on_caller (kernel/locking/lockdep.c:2600)\n\t> [ 4448.986754] SyS_sendmmsg (net/socket.c:2201)\n\t> [ 4448.987708] tracesys (arch/x86/kernel/entry_64.S:542)\n\t> [ 4448.988929] ==================================================================\n\nThis reports means that we've come to netlink_sendmsg() with msg->msg_name == NULL and msg->msg_namelen > 0.\n\nAfter this report there was no usual \"Unable to handle kernel NULL pointer dereference\"\nand this gave me a clue that address 0 is mapped and contains valid socket address structure in it.\n\nThis bug was introduced in f3d3342602f8bcbf37d7c46641cb9bca7618eb1c\n(net: rework recvmsg handler msg_name and msg_namelen logic).\nCommit message states that:\n\t\"Set msg->msg_name = NULL if user specified a NULL in msg_name but had a\n\t non-null msg_namelen in verify_iovec/verify_compat_iovec. This doesn't\n\t affect sendto as it would bail out earlier while trying to copy-in the\n\t address.\"\nBut in fact this affects sendto when address 0 is mapped and contains\nsocket address structure in it. In such case copy-in address will succeed,\nverify_iovec() function will successfully exit with msg->msg_namelen > 0\nand msg->msg_name == NULL.\n\nThis patch fixes it by setting msg_namelen to 0 if msg_name == NULL.\n\nCc: Hannes Frederic Sowa <hannes@stressinduktion.org>\nCc: Eric Dumazet <edumazet@google.com>\nCc: <stable@vger.kernel.org>\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Andrey Ryabinin <a.ryabinin@samsung.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/compat.c||net/compat.c",
          "net/core/iovec.c||net/core/iovec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/compat.c||net/compat.c",
            "net/core/iovec.c||net/core/iovec.c"
          ],
          "candidate": [
            "net/compat.c||net/compat.c",
            "net/core/iovec.c||net/core/iovec.c"
          ]
        }
      },
      "candidate_diff": {
        "net/compat.c||net/compat.c": [
          "File: net/compat.c -> net/compat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "85: {",
          "86:  int tot_len;",
          "89:   if (mode == VERIFY_READ) {",
          "90:    int err = move_addr_to_kernel(kern_msg->msg_name,",
          "91:             kern_msg->msg_namelen,",
          "",
          "[Removed Lines]",
          "88:  if (kern_msg->msg_namelen) {",
          "",
          "[Added Lines]",
          "88:  if (kern_msg->msg_name && kern_msg->msg_namelen) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "93:    if (err < 0)",
          "94:     return err;",
          "95:   }",
          "99:   kern_msg->msg_name = NULL;",
          "101:  tot_len = iov_from_user_compat_to_kern(kern_iov,",
          "102:        (struct compat_iovec __user *)kern_msg->msg_iov,",
          "",
          "[Removed Lines]",
          "96:   if (kern_msg->msg_name)",
          "97:    kern_msg->msg_name = kern_address;",
          "98:  } else",
          "",
          "[Added Lines]",
          "96:   kern_msg->msg_name = kern_address;",
          "97:  } else {",
          "99:   kern_msg->msg_namelen = 0;",
          "100:  }",
          "",
          "---------------"
        ],
        "net/core/iovec.c||net/core/iovec.c": [
          "File: net/core/iovec.c -> net/core/iovec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: {",
          "40:  int size, ct, err;",
          "43:   if (mode == VERIFY_READ) {",
          "44:    void __user *namep;",
          "45:    namep = (void __user __force *) m->msg_name;",
          "",
          "[Removed Lines]",
          "42:  if (m->msg_namelen) {",
          "",
          "[Added Lines]",
          "42:  if (m->msg_name && m->msg_namelen) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48:    if (err < 0)",
          "49:     return err;",
          "50:   }",
          "53:  } else {",
          "54:   m->msg_name = NULL;",
          "55:  }",
          "57:  size = m->msg_iovlen * sizeof(struct iovec);",
          "",
          "[Removed Lines]",
          "51:   if (m->msg_name)",
          "52:    m->msg_name = address;",
          "",
          "[Added Lines]",
          "51:   m->msg_name = address;",
          "54:   m->msg_namelen = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4a184233f21645cf0b719366210ed445d1024d72",
      "candidate_info": {
        "commit_hash": "4a184233f21645cf0b719366210ed445d1024d72",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/4a184233f21645cf0b719366210ed445d1024d72",
        "files": [
          "net/rose/af_rose.c"
        ],
        "message": "rose: fix info leak via msg_name in rose_recvmsg()\n\nThe code in rose_recvmsg() does not initialize all of the members of\nstruct sockaddr_rose/full_sockaddr_rose when filling the sockaddr info.\nNor does it initialize the padding bytes of the structure inserted by\nthe compiler for alignment. This will lead to leaking uninitialized\nkernel stack bytes in net/socket.c.\n\nFix the issue by initializing the memory used for sockaddr info with\nmemset(0).\n\nCc: Ralf Baechle <ralf@linux-mips.org>\nSigned-off-by: Mathias Krause <minipli@googlemail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/rose/af_rose.c||net/rose/af_rose.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/rose/af_rose.c||net/rose/af_rose.c"
          ],
          "candidate": [
            "net/rose/af_rose.c||net/rose/af_rose.c"
          ]
        }
      },
      "candidate_diff": {
        "net/rose/af_rose.c||net/rose/af_rose.c": [
          "File: net/rose/af_rose.c -> net/rose/af_rose.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1253:  skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);",
          "1255:  if (srose != NULL) {",
          "1256:   srose->srose_family = AF_ROSE;",
          "1257:   srose->srose_addr   = rose->dest_addr;",
          "1258:   srose->srose_call   = rose->dest_call;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1256:   memset(srose, 0, msg->msg_namelen);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
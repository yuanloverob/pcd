{
  "cve_id": "CVE-2020-23930",
  "cve_desc": "An issue was discovered in gpac through 20200801. A NULL pointer dereference exists in the function nhmldump_send_header located in write_nhml.c. It allows an attacker to cause Denial of Service.",
  "repo": "gpac/gpac",
  "patch_hash": "9eeac00b38348c664dfeae2525bba0cf1bc32349",
  "patch_info": {
    "commit_hash": "9eeac00b38348c664dfeae2525bba0cf1bc32349",
    "repo": "gpac/gpac",
    "commit_url": "https://github.com/gpac/gpac/commit/9eeac00b38348c664dfeae2525bba0cf1bc32349",
    "files": [
      "applications/mp4box/main.c",
      "src/filters/write_nhml.c"
    ],
    "message": "fixed #1565",
    "before_after_code_files": [
      "applications/mp4box/main.c||applications/mp4box/main.c",
      "src/filters/write_nhml.c||src/filters/write_nhml.c"
    ]
  },
  "patch_diff": {
    "applications/mp4box/main.c||applications/mp4box/main.c": [
      "File: applications/mp4box/main.c -> applications/mp4box/main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5595:  if (dump_iod) {",
      "5596:   GF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);",
      "5597:   if (!iod) {",
      "5599:   } else {",
      "5600:    char szName[GF_MAX_PATH+10];",
      "5601:    FILE *iodf;",
      "",
      "[Removed Lines]",
      "5598:    fprintf(stderr, \"File %s has no IOD\", inName);",
      "",
      "[Added Lines]",
      "5598:    fprintf(stderr, \"File %s has no IOD\\n\", inName);",
      "",
      "---------------"
    ],
    "src/filters/write_nhml.c||src/filters/write_nhml.c": [
      "File: src/filters/write_nhml.c -> src/filters/write_nhml.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "398:   sprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);",
      "399:   gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));",
      "400:   p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);",
      "402:   gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));",
      "403:  }",
      "",
      "[Removed Lines]",
      "401:   sprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));",
      "",
      "[Added Lines]",
      "401:   if (p)",
      "402:    sprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0971919b43219045e611ea17279bbaadaefcd927",
      "candidate_info": {
        "commit_hash": "0971919b43219045e611ea17279bbaadaefcd927",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/0971919b43219045e611ea17279bbaadaefcd927",
        "files": [
          "applications/mp4box/filedump.c",
          "applications/mp4box/fileimport.c",
          "applications/mp4box/live.c",
          "applications/mp4box/main.c",
          "applications/mp4box/mp4box.h",
          "configure",
          "src/compositor/hardcoded_protos.c",
          "src/filters/load_text.c",
          "src/filters/reframe_mhas.c",
          "src/jsmods/core.c",
          "src/utils/error.c",
          "src/utils/os_divers.c",
          "testsuite"
        ],
        "message": "more mp4box cleanup",
        "before_after_code_files": [
          "applications/mp4box/filedump.c||applications/mp4box/filedump.c",
          "applications/mp4box/fileimport.c||applications/mp4box/fileimport.c",
          "applications/mp4box/live.c||applications/mp4box/live.c",
          "applications/mp4box/main.c||applications/mp4box/main.c",
          "applications/mp4box/mp4box.h||applications/mp4box/mp4box.h",
          "src/compositor/hardcoded_protos.c||src/compositor/hardcoded_protos.c",
          "src/filters/load_text.c||src/filters/load_text.c",
          "src/filters/reframe_mhas.c||src/filters/reframe_mhas.c",
          "src/jsmods/core.c||src/jsmods/core.c",
          "src/utils/error.c||src/utils/error.c",
          "src/utils/os_divers.c||src/utils/os_divers.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "applications/mp4box/main.c||applications/mp4box/main.c"
          ],
          "candidate": [
            "applications/mp4box/main.c||applications/mp4box/main.c"
          ]
        }
      },
      "candidate_diff": {
        "applications/mp4box/filedump.c||applications/mp4box/filedump.c": [
          "File: applications/mp4box/filedump.c -> applications/mp4box/filedump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63: void scene_coding_log(void *cbk, GF_LOG_Level log_level, GF_LOG_Tool log_tool, const char *fmt, va_list vlist);",
          "65: u32 PrintLanguages(char *val, u32 opt)",
          "66: {",
          "67:  u32 i=0, count = gf_lang_get_count();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66: #ifdef GPAC_DISABLE_LOG",
          "67: void mp4box_log(const char *fmt, ...)",
          "68: {",
          "69:  va_list vl;",
          "70:  va_start(vl, fmt);",
          "71:  vfprintf(stderr, fmt, vlist);",
          "72:  fflush(stderr);",
          "73:  va_end(vl);",
          "74: }",
          "75: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "89:  GF_Err e = gf_isom_apple_get_tag(file, GF_ISOM_ITUNE_COVER_ART, &tag, &tag_len);",
          "90:  if (e!=GF_OK) {",
          "91:   if (e==GF_URL_ERROR) {",
          "93:    return GF_OK;",
          "94:   }",
          "95:   return e;",
          "",
          "[Removed Lines]",
          "92:    fprintf(stderr, \"No cover art found\\n\");",
          "",
          "[Added Lines]",
          "105:    M4_LOG(GF_LOG_WARNING, (\"No cover art found\\n\"));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "104:   }",
          "105:   t = gf_fopen(szName, \"wb\");",
          "106:   if (!t) {",
          "108:    return GF_IO_ERR;",
          "109:   }",
          "110:  } else {",
          "",
          "[Removed Lines]",
          "107:    fprintf(stderr, \"Failed to open %s for dumping\\n\", szName);",
          "",
          "[Added Lines]",
          "120:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szName));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "145:   load.isom = gf_isom_open(file, GF_ISOM_OPEN_READ, NULL);",
          "146:   if (!load.isom) {",
          "147:    e = gf_isom_last_error(NULL);",
          "149:    gf_sm_del(ctx);",
          "150:    gf_sg_del(sg);",
          "151:    return e;",
          "",
          "[Removed Lines]",
          "148:    fprintf(stderr, \"Error opening file: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "161:    M4_LOG(GF_LOG_ERROR, (\"Error opening file: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "161:    e = import_file(load.isom, file, 0, _frac, 0, NULL, NULL, 0);",
          "162:   } else",
          "163: #else",
          "165: #endif",
          "166:    e = gf_isom_last_error(NULL);",
          "168:   if (e) {",
          "170:    gf_sm_del(ctx);",
          "171:    gf_sg_del(sg);",
          "172:    if (load.isom) gf_isom_delete(load.isom);",
          "",
          "[Removed Lines]",
          "164:   fprintf(stderr, \"Warning: GPAC was compiled without Media Import support\\n\");",
          "169:    fprintf(stderr, \"Error importing file: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "177:   M4_LOG(GF_LOG_WARNING, (\"Warning: GPAC was compiled without Media Import support\\n\"));",
          "182:    M4_LOG(GF_LOG_ERROR, (\"Error importing file: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "203:  gf_sm_del(ctx);",
          "204:  gf_sg_del(sg);",
          "206:  if (load.isom) gf_isom_delete(load.isom);",
          "207:  return e;",
          "208: }",
          "",
          "[Removed Lines]",
          "205:  if (e) fprintf(stderr, \"Error loading scene: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "218:  if (e) M4_LOG(GF_LOG_ERROR, (\"Error loading scene: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "360:  if (get_file_type_by_ext(file) == 1) {",
          "361:   load.isom = gf_isom_open(file, GF_ISOM_OPEN_READ, NULL);",
          "362:   if (!load.isom) {",
          "364:    gf_sm_del(ctx);",
          "365:    gf_sg_del(scene_graph);",
          "366:    return;",
          "",
          "[Removed Lines]",
          "363:    fprintf(stderr, \"Cannot open file: %s\\n\", gf_error_to_string(gf_isom_last_error(NULL)));",
          "",
          "[Added Lines]",
          "376:    M4_LOG(GF_LOG_ERROR, (\"Cannot open file: %s\\n\", gf_error_to_string(gf_isom_last_error(NULL))));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "377:   if (!is_final_name) strcat(szBuf, \"_stat.xml\");",
          "378:   dump = gf_fopen(szBuf, \"wt\");",
          "379:   if (!dump) {",
          "381:    return;",
          "382:   }",
          "383:   close = 1;",
          "",
          "[Removed Lines]",
          "380:    fprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);",
          "",
          "[Added Lines]",
          "393:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "461:  gf_sg_del(scene_graph);",
          "462:  if (load.isom) gf_isom_delete(load.isom);",
          "463:  if (e) {",
          "465:  } else {",
          "466:   fprintf(dump, \"</SceneStatistics>\\n\");",
          "467:  }",
          "",
          "[Removed Lines]",
          "464:   fprintf(stderr, \"%s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "477:   M4_LOG(GF_LOG_ERROR, (\"Stats error: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "545:   char szField[1024];",
          "546:   u32 tfirst, tlast;",
          "547:   if (gf_node_get_field_by_name(node, szField, &f) != GF_OK) {",
          "549:    return;",
          "550:   }",
          "551:   fprintf(stderr, \"Allowed nodes in %s.%s:\\n\", name, szField);",
          "",
          "[Removed Lines]",
          "548:    fprintf(stderr, \"Field %s is not a member of node %s\\n\", szField, name);",
          "",
          "[Added Lines]",
          "561:    M4_LOG(GF_LOG_ERROR, (\"Field %s is not a member of node %s\\n\", szField, name));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "649: u32 PrintNode(const char *name, u32 graph_type)",
          "650: {",
          "651: #ifdef GPAC_DISABLE_VRML",
          "653:  return 2;",
          "654: #else",
          "655:  const char *std_name;",
          "",
          "[Removed Lines]",
          "652:  fprintf(stderr, \"VRML/MPEG-4/X3D scene graph is disabled in this build of GPAC\\n\");",
          "",
          "[Added Lines]",
          "665:  M4_LOG(GF_LOG_ERROR, (\"VRML/MPEG-4/X3D scene graph is disabled in this build of GPAC\\n\"));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "671:   tag = gf_node_x3d_type_by_class_name(name);",
          "672:   std_name = \"X3D\";",
          "673: #else",
          "675:   return 2;",
          "676: #endif",
          "677:  } else {",
          "",
          "[Removed Lines]",
          "674:   fprintf(stderr, \"X3D node printing is not supported (X3D support disabled)\\n\");",
          "",
          "[Added Lines]",
          "687:   M4_LOG(GF_LOG_ERROR, (\"X3D node printing is not supported (X3D support disabled)\\n\"));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "679:   std_name = \"MPEG4\";",
          "680:  }",
          "681:  if (!tag) {",
          "683:   return 2;",
          "684:  }",
          "",
          "[Removed Lines]",
          "682:   fprintf(stderr, \"Unknown %s node %s\\n\", std_name, name);",
          "",
          "[Added Lines]",
          "695:   M4_LOG(GF_LOG_ERROR, (\"Unknown %s node %s\\n\", std_name, name));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "688:  gf_node_register(node, NULL);",
          "689:  name = gf_node_get_class_name(node);",
          "690:  if (!node) {",
          "692:   return 2;",
          "693:  }",
          "694:  do_print_node(node, sg, name, graph_type, is_nodefield, GF_FALSE);",
          "",
          "[Removed Lines]",
          "691:   fprintf(stderr, \"Node %s not supported in current built\\n\", name);",
          "",
          "[Added Lines]",
          "704:   M4_LOG(GF_LOG_ERROR, (\"Node %s not supported in current built\\n\", name));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "716:   start_tag = GF_NODE_RANGE_FIRST_X3D;",
          "717:   end_tag = TAG_LastImplementedX3D;",
          "718: #else",
          "720:   return 2;",
          "721: #endif",
          "722:  } else if (graph_type==2) {",
          "723: #ifdef GPAC_DISABLE_SVG",
          "725:   return 2;",
          "726: #else",
          "727:   start_tag = GF_NODE_RANGE_FIRST_SVG;",
          "",
          "[Removed Lines]",
          "719:   fprintf(stderr, \"X3D scene graph disabled in this build of GPAC\\n\");",
          "724:   fprintf(stderr, \"SVG scene graph disabled in this build of GPAC\\n\");",
          "",
          "[Added Lines]",
          "732:   M4_LOG(GF_LOG_ERROR, (\"X3D scene graph disabled in this build of GPAC\\n\"));",
          "737:   M4_LOG(GF_LOG_ERROR, (\"SVG scene graph disabled in this build of GPAC\\n\"));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "729: #endif",
          "730:  } else {",
          "731: #ifdef GPAC_DISABLE_VRML",
          "733:   return 2;",
          "734: #else",
          "735:   start_tag = GF_NODE_RANGE_FIRST_MPEG4;",
          "",
          "[Removed Lines]",
          "732:   fprintf(stderr, \"VRML/MPEG-4 scene graph disabled in this build of GPAC\\n\");",
          "",
          "[Added Lines]",
          "745:   M4_LOG(GF_LOG_ERROR, (\"VRML/MPEG-4 scene graph disabled in this build of GPAC\\n\"));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "782:  }",
          "783: #else",
          "785: #endif",
          "786:  return 1;",
          "787: }",
          "",
          "[Removed Lines]",
          "784:  fprintf(stderr, \"\\nNo scene graph enabled in this MP4Box build\\n\");",
          "",
          "[Added Lines]",
          "797:  M4_LOG(GF_LOG_ERROR, (\"No scene graph enabled in this MP4Box build\\n\"));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "824:   if (!is_final_name) strcat(szBuf, \"_rtp.xml\");",
          "825:   dump = gf_fopen(szBuf, \"wt\");",
          "826:   if (!dump) {",
          "828:    return;",
          "829:   }",
          "830:  } else {",
          "",
          "[Removed Lines]",
          "827:    fprintf(stderr, \"Failed to open %s\\n\", szBuf);",
          "",
          "[Added Lines]",
          "840:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "876:   if (!is_final_name) strcat(szBuf, \"_ts.txt\");",
          "877:   dump = gf_fopen(szBuf, \"wt\");",
          "878:   if (!dump) {",
          "880:    return;",
          "881:   }",
          "882:  } else {",
          "",
          "[Removed Lines]",
          "879:    fprintf(stderr, \"Failed to open %s\\n\", szBuf);",
          "",
          "[Added Lines]",
          "892:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "975:  if (timings) gf_free(timings);",
          "977:  if (inName) gf_fclose(dump);",
          "979: }",
          "",
          "[Removed Lines]",
          "978:  if (has_ctts_error) fprintf(stderr, \"\\tFile has CTTS table errors\\n\");",
          "",
          "[Added Lines]",
          "991:  if (has_ctts_error) {",
          "992:   M4_LOG(GF_LOG_ERROR, (\"\\tFile has CTTS table errors\\n\"));",
          "993:  }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1028:  nb_descs = gf_isom_get_sample_description_count(file, track);",
          "1029:  if (!nb_descs) {",
          "1031:   return;",
          "1032:  }",
          "",
          "[Removed Lines]",
          "1030:   fprintf(stderr, \"Error: Track #%d has no sample description so is likely not NALU-based!\\n\", trackID);",
          "",
          "[Added Lines]",
          "1045:   M4_LOG(GF_LOG_ERROR, (\"Error: Track #%d has no sample description so is likely not NALU-based!\\n\", trackID));",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1103:   fprintf(dump, \" <NALUConfig>\\n\");",
          "1105:   if (!avccfg && !svccfg && !hevccfg && !lhvccfg && !vvccfg) {",
          "1107:    return;",
          "1108:   }",
          "",
          "[Removed Lines]",
          "1106:    fprintf(stderr, \"Error: Track #%d is not NALU-based!\\n\", trackID);",
          "",
          "[Added Lines]",
          "1121:    M4_LOG(GF_LOG_ERROR, (\"Error: Track #%d is not NALU or OBU based!\\n\", trackID));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1333:   if (!is_final_name) sprintf(szBuf, \"%s_%d_%s.xml\", inName, trackID, is_av1 ? \"obu\" : \"nalu\");",
          "1334:   dump = gf_fopen(szBuf, \"wt\");",
          "1335:   if (!dump) {",
          "1337:    return;",
          "1338:   }",
          "1339:  } else {",
          "",
          "[Removed Lines]",
          "1336:    fprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);",
          "",
          "[Added Lines]",
          "1351:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1370:  gf_av1_init_state(&av1);",
          "1371:  av1.config = gf_isom_av1_config_get(file, track, 1);",
          "1372:  if (!av1.config) {",
          "1374:   return;",
          "1375:  }",
          "",
          "[Removed Lines]",
          "1373:   fprintf(stderr, \"Error: Track #%d is not AV1!\\n\", trackID);",
          "",
          "[Added Lines]",
          "1388:   M4_LOG(GF_LOG_ERROR, (\"Error: Track #%d is not AV1!\\n\", trackID));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1491:   if (!is_final_name) sprintf(szBuf, \"%s_%d_cues.xml\", inName, trackID);",
          "1492:   dump = gf_fopen(szBuf, \"wt\");",
          "1493:   if (!dump) {",
          "1495:    return;",
          "1496:   }",
          "1497:  } else {",
          "",
          "[Removed Lines]",
          "1494:    fprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);",
          "",
          "[Added Lines]",
          "1509:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1571:   if (!is_final_name) strcat(szBuf, \"_ismacryp.xml\");",
          "1572:   dump = gf_fopen(szBuf, \"wt\");",
          "1573:   if (!dump) {",
          "1575:    return;",
          "1576:   }",
          "1577:  } else {",
          "",
          "[Removed Lines]",
          "1574:    fprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);",
          "",
          "[Added Lines]",
          "1589:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1608:  track = gf_isom_get_track_by_id(file, trackID);",
          "1609:  if (!track) {",
          "1611:   return;",
          "1612:  }",
          "",
          "[Removed Lines]",
          "1610:   fprintf(stderr, \"Cannot find track ID %d\\n\", trackID);",
          "",
          "[Added Lines]",
          "1625:   M4_LOG(GF_LOG_ERROR, (\"Cannot find track ID %d\\n\", trackID));",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1616:  case GF_ISOM_MEDIA_SUBT:",
          "1617:   break;",
          "1618:  default:",
          "1620:   return;",
          "1621:  }",
          "",
          "[Removed Lines]",
          "1619:   fprintf(stderr, \"Track ID %d is not a 3GPP text track\\n\", trackID);",
          "",
          "[Added Lines]",
          "1634:   M4_LOG(GF_LOG_ERROR, (\"Track ID %d is not a 3GPP text track\\n\", trackID));",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1634:   dump = gf_fopen(szBuf, \"wt\");",
          "1635:   if (!dump) {",
          "1637:    return;",
          "1638:   }",
          "1639:  } else {",
          "",
          "[Removed Lines]",
          "1636:    fprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);",
          "",
          "[Added Lines]",
          "1651:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1642:  e = gf_isom_text_dump(file, track, dump, dump_type);",
          "1643:  if (inName) gf_fclose(dump);",
          "1647: }",
          "",
          "[Removed Lines]",
          "1645:  if (e) fprintf(stderr, \"Conversion failed (%s)\\n\", gf_error_to_string(e));",
          "1646:  else fprintf(stderr, \"Conversion done\\n\");",
          "",
          "[Added Lines]",
          "1660:  if (e) {",
          "1661:   M4_LOG(GF_LOG_ERROR, (\"Conversion failed (%s)\\n\", gf_error_to_string(e)));",
          "1662:  } else {",
          "1663:   fprintf(stderr, \"Conversion done\\n\");",
          "1664:  }",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1666:   }",
          "1667:   dump = gf_fopen(szBuf, \"wt\");",
          "1668:   if (!dump) {",
          "1670:    return;",
          "1671:   }",
          "1672:  } else {",
          "",
          "[Removed Lines]",
          "1669:    fprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);",
          "",
          "[Added Lines]",
          "1687:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s for dumping\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1709:   }",
          "1710:   dump = gf_fopen(szBuf, \"wt\");",
          "1711:   if (!dump) {",
          "1713:    return GF_IO_ERR;",
          "1714:   }",
          "1715:   do_close=GF_TRUE;",
          "",
          "[Removed Lines]",
          "1712:    fprintf(stderr, \"Failed to open %s\\n\", szBuf);",
          "",
          "[Added Lines]",
          "1730:    M4_LOG(GF_LOG_ERROR, (\"Failed to open %s\\n\", szBuf));",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1721:  }",
          "1722:  e = gf_isom_dump(file, dump, skip_init, skip_samples);",
          "1723:  if (e) {",
          "1725:  }",
          "1727:  if (do_track_dump) {",
          "",
          "[Removed Lines]",
          "1724:   fprintf(stderr, \"Error dumping ISO structure\\n\");",
          "",
          "[Added Lines]",
          "1742:   M4_LOG(GF_LOG_ERROR, (\"Error dumping ISO structure\\n\"));",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1901:  memset(uuid, 0, 16);",
          "1902:  count = gf_isom_get_user_data_count(file, dump_udta_track, dump_udta_type, uuid);",
          "1903:  if (!count) {",
          "1906:  }",
          "1908:  data = NULL;",
          "1909:  count = 0;",
          "1910:  e = gf_isom_get_user_data(file, dump_udta_track, dump_udta_type, uuid, 0, &data, &count);",
          "1911:  if (e) {",
          "1913:   return e;",
          "1914:  }",
          "1915:  if (inName) {",
          "",
          "[Removed Lines]",
          "1904:   fprintf(stderr, \"No UDTA for type %s found\\n\", gf_4cc_to_str(dump_udta_type) );",
          "1905:   return GF_OK;",
          "1912:   fprintf(stderr, \"Error dumping UDTA %s: %s\\n\", gf_4cc_to_str(dump_udta_type), gf_error_to_string(e) );",
          "",
          "[Added Lines]",
          "1922:   M4_LOG(GF_LOG_ERROR, (\"No UDTA for type %s found\\n\", gf_4cc_to_str(dump_udta_type) ));",
          "1923:   return GF_NOT_FOUND;",
          "1930:   M4_LOG(GF_LOG_ERROR, (\"Error dumping UDTA %s: %s\\n\", gf_4cc_to_str(dump_udta_type), gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1922:   t = gf_fopen(szName, \"wb\");",
          "1923:   if (!t) {",
          "1924:    gf_free(data);",
          "1926:    return GF_IO_ERR;",
          "1927:   }",
          "1928:  } else {",
          "",
          "[Removed Lines]",
          "1925:    fprintf(stderr, \"Cannot open file %s\\n\", szName );",
          "",
          "[Added Lines]",
          "1943:    M4_LOG(GF_LOG_ERROR, (\"Cannot open file %s\\n\", szName ));",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1932:  if (inName) gf_fclose(t);",
          "1933:  gf_free(data);",
          "1934:  if (count-8 != res) {",
          "1936:   return GF_IO_ERR;",
          "1937:  }",
          "1938:  return GF_OK;",
          "",
          "[Removed Lines]",
          "1935:   fprintf(stderr, \"Error writing udta to file\\n\");",
          "",
          "[Added Lines]",
          "1953:   M4_LOG(GF_LOG_ERROR, (\"Error writing udta to file\\n\"));",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1958:    }",
          "1959:   }",
          "1960:   if (!chap_tk) {",
          "1962:    return GF_OK;",
          "1963:   }",
          "1966:   dump_isom_timed_text(file, gf_isom_get_track_id(file, chap_tk), inName, is_final_name, GF_FALSE, dump_mode);",
          "1967:   return GF_OK;",
          "",
          "[Removed Lines]",
          "1961:    fprintf(stderr, \"No chapters or chapters track found in file\\n\");",
          "1965:   fprintf(stderr, \"Chapter track found, dumping\\n\");",
          "",
          "[Added Lines]",
          "1979:    M4_LOG(GF_LOG_WARNING, (\"No chapters or chapters track found in file\\n\"));",
          "1983:   fprintf(stderr, \"Dumping chapter track %d\\n\", chap_tk);",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2182:     }",
          "2183:     fprintf(stderr, \"\\n\");",
          "2184:    } else {",
          "2186:    }",
          "2187:   }",
          "2188:  }",
          "",
          "[Removed Lines]",
          "2185:     fprintf(stderr, \"\\nFailed to read SPS: %s\\n\\n\", gf_error_to_string((e) ));",
          "",
          "[Added Lines]",
          "2203:     M4_LOG(GF_LOG_ERROR, (\"Failed to read SPS: %s\\n\\n\", gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2272:     }",
          "2273:     fprintf(stderr, \"\\n\");",
          "2274:    } else {",
          "2276:    }",
          "2277:   }",
          "2278:  }",
          "",
          "[Removed Lines]",
          "2275:     fprintf(stderr, \"\\nFailed to read SPS: %s\\n\\n\", gf_error_to_string((e) ));",
          "",
          "[Added Lines]",
          "2293:     M4_LOG(GF_LOG_ERROR, (\"\\nFailed to read SPS: %s\\n\\n\", gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "2307:   trackID = gf_isom_get_track_id(file, trackNum);",
          "2308:  }",
          "2309:  if (!trackNum) {",
          "2311:   return;",
          "2312:  }",
          "",
          "[Removed Lines]",
          "2310:   fprintf(stderr, \"No track with ID %d found\\n\", trackID);",
          "",
          "[Added Lines]",
          "2328:   M4_LOG(GF_LOG_ERROR, (\"No track with ID %d found\\n\", trackID));",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2322:  fprintf(stderr, \"\\n\");",
          "2324:  if (gf_isom_check_data_reference(file, trackNum, 1) != GF_OK) {",
          "2326:  }",
          "2328:  nb_edits = gf_isom_get_edits_count(file, trackNum);",
          "",
          "[Removed Lines]",
          "2325:   fprintf(stderr, \"Track uses external data reference not supported by GPAC!\\n\");",
          "",
          "[Added Lines]",
          "2343:   M4_LOG(GF_LOG_WARNING, (\"Track uses external data reference not supported by GPAC!\\n\"));",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2425:     )  {",
          "2426:   esd = gf_isom_get_esd(file, trackNum, 1);",
          "2427:   if (!esd || !esd->decoderConfig) {",
          "2429:    if (esd) gf_odf_desc_del((GF_Descriptor *)esd);",
          "2430:   } else {",
          "2431:    const char *st = gf_stream_type_name(esd->decoderConfig->streamType);",
          "",
          "[Removed Lines]",
          "2428:    fprintf(stderr, \"WARNING: Broken MPEG-4 Track\\n\");",
          "",
          "[Added Lines]",
          "2446:    M4_LOG(GF_LOG_WARNING, (\"WARNING: Broken MPEG-4 Track\\n\"));",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2453:      gf_isom_get_visual_info(file, trackNum, 1, &w, &h);",
          "2454:      fprintf(stderr, \"MPEG-4 Visual Size %d x %d\\n\", w, h);",
          "2455: #endif",
          "2457: #ifndef GPAC_DISABLE_AV_PARSERS",
          "2458:      } else {",
          "2459:       GF_M4VDecSpecInfo dsi;",
          "",
          "[Removed Lines]",
          "2456:       fprintf(stderr, \"\\tNon-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\");",
          "",
          "[Added Lines]",
          "2474:       M4_LOG(GF_LOG_WARNING, (\"Non-compliant MPEG-4 Visual track: video_object_layer infos not found in sample description\\n\"));",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2480:      svccfg = gf_isom_svc_config_get(file, trackNum, 1);",
          "2481:      mvccfg = gf_isom_mvc_config_get(file, trackNum, 1);",
          "2482:      if (!avccfg && !svccfg && !mvccfg) {",
          "2484:      } else if (avccfg) {",
          "2485:       fprintf(stderr, \"\\tAVC Info: %d SPS - %d PPS\", gf_list_count(avccfg->sequenceParameterSets) , gf_list_count(avccfg->pictureParameterSets) );",
          "2486:       fprintf(stderr, \" - Profile %s @ Level %g\\n\", gf_avc_get_profile_name(avccfg->AVCProfileIndication), ((Double)avccfg->AVCLevelIndication)/10.0 );",
          "",
          "[Removed Lines]",
          "2483:       fprintf(stderr, \"\\n\\n\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\");",
          "",
          "[Added Lines]",
          "2501:       M4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant AVC track: SPS/PPS not found in sample description\\n\"));",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2589:        fprintf(stderr, \"\\tHEVC Tile track without tiling info\\n\");",
          "2590:       }",
          "2591:      } else if (!hevccfg && !lhvccfg) {",
          "2593:      }",
          "2595:      if (gf_isom_get_reference_count(file, trackNum, GF_ISOM_REF_SABT)) {",
          "",
          "[Removed Lines]",
          "2592:       fprintf(stderr, \"\\n\\n\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\");",
          "",
          "[Added Lines]",
          "2610:       M4_LOG(GF_LOG_ERROR, (\"\\tNon-compliant HEVC track: No hvcC or shcC found in sample description\\n\"));",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2681:      else",
          "2682:       e = gf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);",
          "2683:      if (full_dump) fprintf(stderr, \"\\t\");",
          "2686:       char *signaling = \"implicit\";",
          "2687:       char *heaac = \"\";",
          "2688:       if (!is_mp2 && a_cfg.has_sbr) {",
          "",
          "[Removed Lines]",
          "2684:      if (e) fprintf(stderr, \"Corrupted AAC Config\\n\");",
          "2685:      else {",
          "",
          "[Added Lines]",
          "2702:      if (e) {",
          "2703:       M4_LOG(GF_LOG_ERROR, (\"Corrupted AAC Config\\n\"));",
          "2704:      } else {",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2723:               );",
          "2724:        gf_isom_sample_del(&samp);",
          "2725:       } else {",
          "2727:       }",
          "2728: #else",
          "2729:       fprintf(stderr, \"MPEG-1/2 Audio - %d Channels - SampleRate %d\\n\", nb_ch, sr);",
          "",
          "[Removed Lines]",
          "2726:        fprintf(stderr, \"\\n\\tError fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) );",
          "",
          "[Added Lines]",
          "2745:        M4_LOG(GF_LOG_ERROR, (\"Error fetching sample: %s\\n\", gf_error_to_string(gf_isom_last_error(file)) ));",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2778:     } else if (esd->decoderConfig->objectTypeIndication==GF_CODECID_SYNTHESIZED_TEXTURE) {",
          "2779:      fprintf(stderr, \"Synthetized Texture stream stream\\n\");",
          "2780:     } else {",
          "2782:     }",
          "2783:    }",
          "",
          "[Removed Lines]",
          "2781:      fprintf(stderr, \"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication);",
          "",
          "[Added Lines]",
          "2800:      M4_LOG(GF_LOG_WARNING, (\"Unknown Systems stream OTI %d\\n\", esd->decoderConfig->objectTypeIndication));",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "2989:   vvccfg = gf_isom_vvc_config_get(file, trackNum, 1);",
          "2991:   if (!vvccfg) {",
          "2993:   } else {",
          "2994:    dump_vvc_track_info(file, trackNum, vvccfg",
          "2995: #if !defined(GPAC_DISABLE_AV_PARSERS)",
          "",
          "[Removed Lines]",
          "2992:    fprintf(stderr, \"\\n\\n\\tNon-compliant VVC track: No vvcC found in sample description\\n\");",
          "",
          "[Added Lines]",
          "3011:    M4_LOG(GF_LOG_ERROR, (\"Non-compliant VVC track: No vvcC found in sample description\\n\"));",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3040:    valid = GF_TRUE;",
          "3041:   }",
          "3042:   if (!valid) {",
          "3044:   }",
          "3045:   if (esd) gf_odf_desc_del((GF_Descriptor *)esd);",
          "3046:   compat_profiles = gf_isom_get_mpegh_compatible_profiles(file, trackNum, 1, &nb_compat_profiles);",
          "",
          "[Removed Lines]",
          "3043:    fprintf(stderr, \"\\tInvalid MPEG-H audio config\\n\");",
          "",
          "[Added Lines]",
          "3062:    M4_LOG(GF_LOG_ERROR, (\"Invalid MPEG-H audio config\\n\"));",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3247:     samp = gf_isom_get_sample_info(file, trackNum, j+1, NULL, NULL);",
          "3248:    }",
          "3249:    if (!samp) {",
          "3251:     return;",
          "3252:    }",
          "3253:    dur = samp->DTS+samp->CTS_Offset;",
          "",
          "[Removed Lines]",
          "3250:     fprintf(stderr, \"Failed to fetch sample %d\\n\", j+1);",
          "",
          "[Added Lines]",
          "3269:     M4_LOG(GF_LOG_ERROR, (\"Failed to fetch sample %d\\n\", j+1));",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3660:      diff = (pck->DTS ? pck->DTS : pck->PTS) / 90000.0;",
          "3661:      diff -= pes->last_pcr_value / (300.0 * 90000);",
          "3662:      fprintf(dumper->timestamps_info_file, \"\\t%f\\n\", diff);",
          "3664:     } else {",
          "3665:      fprintf(dumper->timestamps_info_file, \"\\t\\n\");",
          "3666:     }",
          "",
          "[Removed Lines]",
          "3663:      if (diff<0) fprintf(stderr, \"Warning: detected PTS/DTS value less than current PCR of %g sec\\n\", diff);",
          "",
          "[Added Lines]",
          "3682:      if (diff<0) {",
          "3683:       M4_LOG(GF_LOG_WARNING, (\"Warning: detected PTS/DTS value less than current PCR of %g sec\\n\", diff));",
          "3684:      }",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3727:  src = gf_fopen(mpeg2ts_file, \"rb\");",
          "3728:  if (!src) {",
          "3730:   return;",
          "3731:  }",
          "3732:  ts = gf_m2ts_demux_new();",
          "",
          "[Removed Lines]",
          "3729:   fprintf(stderr, \"Cannot open %s: no such file\\n\", mpeg2ts_file);",
          "",
          "[Added Lines]",
          "3750:   M4_LOG(GF_LOG_ERROR, (\"Cannot open %s: no such file\\n\", mpeg2ts_file));",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3782:   sprintf(dumper.timestamps_info_name, \"%s_prog_%d_timestamps.txt\", mpeg2ts_file, prog_num/*, mpeg2ts_file*/);",
          "3783:   dumper.timestamps_info_file = gf_fopen(dumper.timestamps_info_name, \"wt\");",
          "3784:   if (!dumper.timestamps_info_file) {",
          "3786:    return;",
          "3787:   }",
          "3788:   fprintf(dumper.timestamps_info_file, \"PCK#\\tPID\\tPCR\\tDTS\\tPTS\\tRAP\\tDiscontinuity\\tDTS-PCR Diff\\n\");",
          "",
          "[Removed Lines]",
          "3785:    fprintf(stderr, \"Cannot open file %s\\n\", dumper.timestamps_info_name);",
          "",
          "[Added Lines]",
          "3806:    M4_LOG(GF_LOG_ERROR, (\"Cannot open file %s\\n\", dumper.timestamps_info_name));",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "3901:   gf_free(dst_name);",
          "3902:  } else {",
          "3904:  }",
          "3905:  gf_cfg_del(cached);",
          "3906:  gf_file_delete(szPATH);",
          "",
          "[Removed Lines]",
          "3903:   fprintf(stderr, \"Failed to reverse %s cache file\\n\", item_path);",
          "",
          "[Added Lines]",
          "3924:   M4_LOG(GF_LOG_ERROR, (\"Failed to reverse %s cache file\\n\", item_path));",
          "",
          "---------------"
        ],
        "applications/mp4box/fileimport.c||applications/mp4box/fileimport.c": [
          "File: applications/mp4box/fileimport.c -> applications/mp4box/fileimport.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:   GF_Err e = gf_isom_remove_user_data(dest, tracknum, udta_type, uuid);",
          "71:   if (e==GF_EOS) {",
          "72:    e = GF_OK;",
          "74:   }",
          "75:   return e;",
          "76:  }",
          "",
          "[Removed Lines]",
          "73:    fprintf(stderr, \"No track.udta found, ignoring\\n\");",
          "",
          "[Added Lines]",
          "73:    M4_LOG(GF_LOG_WARNING, (\"No track.udta found, ignoring\\n\"));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "128:  e = gf_media_import(&import);",
          "129:  if (e) {",
          "131:   return;",
          "132:  }",
          "133:  if (trackID) {",
          "",
          "[Removed Lines]",
          "130:   fprintf(stderr, \"Error probing file %s: %s\\n\", inName, gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "130:   M4_LOG(GF_LOG_ERROR, (\"Error probing file %s: %s\\n\", inName, gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135:  } else {",
          "136:   fprintf(stderr, \"Import probing results for %s:\\n\", inName);",
          "137:   if (!import.nb_tracks) {",
          "139:    return;",
          "140:   }",
          "141:   fprintf(stderr, \"File has %d tracks\\n\", import.nb_tracks);",
          "",
          "[Removed Lines]",
          "138:    fprintf(stderr, \"File has no selectable tracks\\n\");",
          "",
          "[Added Lines]",
          "138:    M4_LOG(GF_LOG_WARNING, (\"File has no selectable tracks\\n\"));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "215:   }",
          "216:  }",
          "217:  fprintf(stderr, \"\\n\");",
          "220: }",
          "222: static GF_Err set_chapter_track(GF_ISOFile *file, u32 track, u32 chapter_ref_trak)",
          "",
          "[Removed Lines]",
          "218:  fprintf(stderr, \"For more details, use `gpac -i %s inspect[:deep][:analyze=on|bs]`\\n\", gf_file_basename(inName));",
          "219:  if (!found && trackID) fprintf(stderr, \"Cannot find track %d in file\\n\", trackID);",
          "",
          "[Added Lines]",
          "218:  M4_LOG(GF_LOG_INFO, (\"For more details, use `gpac -i %s inspect[:deep][:analyze=on|bs]`\\n\", gf_file_basename(inName)));",
          "219:  if (!found && trackID) {",
          "220:   M4_LOG(GF_LOG_ERROR, (\"Cannot find track %d in file\\n\", trackID));",
          "221:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "655:   else if (!strnicmp(ext+1, \"fps=\", 4)) {",
          "656:    u32 ticks, dts_inc;",
          "657:    if (!strcmp(ext+5, \"auto\")) {",
          "659:    } else if ((sscanf(ext+5, \"%u-%u\", &ticks, &dts_inc) == 2) || (sscanf(ext+5, \"%u/%u\", &ticks, &dts_inc) == 2)) {",
          "660:     if (!dts_inc) dts_inc=1;",
          "661:     force_fps.num = ticks;",
          "",
          "[Removed Lines]",
          "658:     fprintf(stderr, \"Warning, fps=auto option is deprecated\\n\");",
          "",
          "[Added Lines]",
          "660:     M4_LOG(GF_LOG_ERROR, (\"Warning, fps=auto option is deprecated\\n\"));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "709:    else if (!stricmp(mode, \"splitbase\"))",
          "710:     temporal_mode = 1;",
          "711:    else {",
          "713:     temporal_mode = 0;",
          "714:    }",
          "715:   }",
          "",
          "[Removed Lines]",
          "712:     fprintf(stderr, \"Unrecognized temporal mode %s, ignoring\\n\", mode);",
          "",
          "[Added Lines]",
          "714:     M4_LOG(GF_LOG_ERROR, (\"Unrecognized temporal mode %s, ignoring\\n\", mode));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "724:   else if (!strnicmp(ext+1, \"max_lid=\", 8) || !strnicmp(ext+1, \"max_tid=\", 8)) {",
          "725:    s32 val = atoi(ext+9);",
          "726:    if (val < 0) {",
          "728:    } else {",
          "729:     if (!strnicmp(ext+1, \"max_lid=\", 8))",
          "730:      max_layer_id_plus_one = 1 + (u8) val;",
          "",
          "[Removed Lines]",
          "727:     fprintf(stderr, \"Warning: request max layer/temporal id is negative - ignoring\\n\");",
          "",
          "[Added Lines]",
          "729:     M4_LOG(GF_LOG_ERROR, (\"Warning: request max layer/temporal id is negative - ignoring\\n\"));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "901:    else if (!stricmp(mode, \"v1-qt\"))",
          "902:     import.asemode = GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF;",
          "903:    else",
          "905:   }",
          "907:   else if (!strnicmp(ext+1, \"audio_roll=\", 11)) {",
          "",
          "[Removed Lines]",
          "904:     fprintf(stderr, \"Unrecognized audio sample entry mode %s, ignoring\\n\", mode);",
          "",
          "[Added Lines]",
          "906:     M4_LOG(GF_LOG_ERROR, (\"Unrecognized audio sample entry mode %s, ignoring\\n\", mode));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "929:     else if ((clr_type==GF_ISOM_SUBTYPE_RICC) || (clr_type==GF_ISOM_SUBTYPE_PROF)) {",
          "930:      FILE *f = gf_fopen(cval+1, \"rb\");",
          "931:      if (!f) {",
          "933:       e = GF_BAD_PARAM;",
          "934:       goto exit;",
          "935:      } else {",
          "",
          "[Removed Lines]",
          "932:       fprintf(stderr, \"Failed to open file %s\\n\", cval+1);",
          "",
          "[Added Lines]",
          "934:       M4_LOG(GF_LOG_ERROR, (\"Failed to open file %s\\n\", cval+1));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "941:       gf_fclose(f);",
          "942:      }",
          "943:     } else {",
          "945:      e = GF_BAD_PARAM;",
          "946:      goto exit;",
          "947:     }",
          "",
          "[Removed Lines]",
          "944:      fprintf(stderr, \"Unrecognized colr profile %s\\n\", gf_4cc_to_str(clr_type) );",
          "",
          "[Added Lines]",
          "946:      M4_LOG(GF_LOG_ERROR, (\"Unrecognized colr profile %s\\n\", gf_4cc_to_str(clr_type) ));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1023:     tc_h = tc_m = tc_s = 0;",
          "1024:     tc_fps_den = 1;",
          "1025:    } else {",
          "1027:    }",
          "1028:   }",
          "1029:   else if (!strnicmp(ext+1, \"edits=\", 6)) {",
          "",
          "[Removed Lines]",
          "1026:     fprintf(stderr, \"Bad format %s for timecode, ignoring\\n\", ext+1);",
          "",
          "[Added Lines]",
          "1028:     M4_LOG(GF_LOG_ERROR, (\"Bad format %s for timecode, ignoring\\n\", ext+1));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1041:   }",
          "1043:   else {",
          "1045:    if (ext2) ext2[0] = ':';",
          "1046:    ext = ext2;",
          "1047:    continue;",
          "",
          "[Removed Lines]",
          "1044:    fprintf(stderr, \"Unrecognized import option %s, ignoring\\n\", ext+1);",
          "",
          "[Added Lines]",
          "1046:    M4_LOG(GF_LOG_ERROR, (\"Unrecognized import option %s, ignoring\\n\", ext+1));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "1132:     }",
          "1133:    }",
          "1134:    if (!track_id || !found) {",
          "1136:     if (sep) sep[0] = ':';",
          "1137:     e = GF_NOT_FOUND;",
          "1138:     goto exit;",
          "",
          "[Removed Lines]",
          "1135:     fprintf(stderr, \"Cannot find track ID matching fragment #%s\\n\", ext);",
          "",
          "[Added Lines]",
          "1137:     M4_LOG(GF_LOG_ERROR, (\"Cannot find track ID matching fragment #%s\\n\", ext));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "1277:      u64 media_time = ((s64) -delay.num) * gf_isom_get_media_timescale(dest, track) / delay.den;",
          "1278:      e |= gf_isom_append_edit(dest, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);",
          "1279:     } else {",
          "1281:     }",
          "1282:    }",
          "1283:    GOTO_EXIT(\"assigning delay\")",
          "",
          "[Removed Lines]",
          "1280:      fprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");",
          "",
          "[Added Lines]",
          "1282:      M4_LOG(GF_LOG_ERROR, (\"Warning: request negative delay longer than track duration - ignoring\\n\"));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "1389:    switch (gf_isom_get_media_type(dest, track)) {",
          "1390:    case GF_ISOM_MEDIA_AUDIO:",
          "1391:     if (!rescale_override) {",
          "1393:      break;",
          "1394:     }",
          "1395:    default:",
          "1396:     e = gf_isom_set_media_timescale(dest, track, rescale_num, rescale_den, rescale_override ? 2 : 1);",
          "1397:                 if (e==GF_EOS) {",
          "1399:      e = GF_OK;",
          "1400:     }",
          "1401:     GOTO_EXIT(\"rescaling media track\")",
          "",
          "[Removed Lines]",
          "1392:      fprintf(stderr, \"Cannot force media timescale for audio media types - ignoring\\n\");",
          "1398:      fprintf(stderr, \"Rescale ignored, same config in source file\\n\");",
          "",
          "[Added Lines]",
          "1394:      M4_LOG(GF_LOG_ERROR, (\"Cannot force media timescale for audio media types - ignoring\\n\"));",
          "1400:      M4_LOG(GF_LOG_ERROR, (\"Rescale ignored, same config in source file\\n\"));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "1409:   }",
          "1410:   if (rvc_config) {",
          "1411: #ifdef GPAC_DISABLE_ZLIB",
          "1413:    e = GF_NOT_SUPPORTED;",
          "1414:    goto exit;",
          "1415: #else",
          "",
          "[Removed Lines]",
          "1412:    fprintf(stderr, \"Error: no zlib support - RVC not available\\n\");",
          "",
          "[Added Lines]",
          "1414:    M4_LOG(GF_LOG_ERROR, (\"Error: no zlib support - RVC not available\\n\"));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "1517:   {",
          "1518:    e = gf_media_filter_hevc(dest, i, max_temporal_id_plus_one, max_layer_id_plus_one);",
          "1519:    if (e) {",
          "1521:     e = GF_OK;",
          "1522:    }",
          "1523:   }",
          "",
          "[Removed Lines]",
          "1520:     fprintf(stderr, \"Warning: track ID %d: error while filtering LHVC layers\\n\", gf_isom_get_track_id(dest, i));",
          "",
          "[Added Lines]",
          "1522:     M4_LOG(GF_LOG_ERROR, (\"Warning: track ID %d: error while filtering LHVC layers\\n\", gf_isom_get_track_id(dest, i)));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "1645:  if (!e) return GF_OK;",
          "1646:  if (fail_msg) {",
          "1648:  }",
          "1649:  return e;",
          "1650: }",
          "",
          "[Removed Lines]",
          "1647:   fprintf(stderr, \"Failure while %s: %s\\n\", fail_msg, gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "1649:   M4_LOG(GF_LOG_ERROR, (\"Failure while %s: %s\\n\", fail_msg, gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "1704:  fs = gf_fs_new_defaults(0);",
          "1705:  if (!fs) {",
          "1707:   return GF_IO_ERR;",
          "1708:  }",
          "",
          "[Removed Lines]",
          "1706:   fprintf(stderr, \"Failed to load filter session, aborting\\n\");",
          "",
          "[Added Lines]",
          "1708:   M4_LOG(GF_LOG_ERROR, (\"Failed to load filter session, aborting\\n\"));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "1712:  src = gf_fs_load_filter(fs, szArgs, &e);",
          "1714:  if (!src) {",
          "1716:   gf_fs_del(fs);",
          "1717:   return e;",
          "1718:  }",
          "",
          "[Removed Lines]",
          "1715:   fprintf(stderr, \"Failed to load source filter: %s\\n\", gf_error_to_string(e) );",
          "",
          "[Added Lines]",
          "1717:   M4_LOG(GF_LOG_ERROR, (\"Failed to load source filter: %s\\n\", gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "1773:  } else {",
          "1774:   gf_fs_del(fs);",
          "1775:   gf_free(filter_args);",
          "1777:   return GF_BAD_PARAM;",
          "1778:  }",
          "1780:  reframe = gf_fs_load_filter(fs, filter_args, &e);",
          "1781:  gf_free(filter_args);",
          "1782:  if (!reframe) {",
          "1784:   gf_fs_del(fs);",
          "1785:   return e;",
          "1786:  }",
          "",
          "[Removed Lines]",
          "1776:   fprintf(stderr, \"Unrecognized split syntax\\n\");",
          "1783:   fprintf(stderr, \"Failed to load reframer filter: %s\\n\", gf_error_to_string(e) );",
          "",
          "[Added Lines]",
          "1778:   M4_LOG(GF_LOG_ERROR, (\"Unrecognized split syntax\\n\"));",
          "1785:   M4_LOG(GF_LOG_ERROR, (\"Failed to load reframer filter: %s\\n\", gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1792:  }",
          "1793:  dst = gf_fs_load_destination(fs, szFile, NULL, NULL, &e);",
          "1794:  if (!dst) {",
          "1796:   gf_fs_del(fs);",
          "1797:   return e;",
          "1798:  }",
          "",
          "[Removed Lines]",
          "1795:   fprintf(stderr, \"Failed to load destination filter: %s\\n\", gf_error_to_string(e) );",
          "",
          "[Added Lines]",
          "1797:   M4_LOG(GF_LOG_ERROR, (\"Failed to load destination filter: %s\\n\", gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1828:  gf_fs_del(fs);",
          "1830:  if (e<GF_OK)",
          "1832:  return e;",
          "1833: }",
          "",
          "[Removed Lines]",
          "1831:   fprintf(stderr, \"Split failed: %s\\n\", gf_error_to_string(e) );",
          "",
          "[Added Lines]",
          "1833:   M4_LOG(GF_LOG_ERROR, (\"Split failed: %s\\n\", gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1896:   if (!force_cat) {",
          "1897:    gf_isom_avc_set_inband_config(dest, dst_tk, 1, GF_FALSE);",
          "1898:   } else {",
          "1900:   }",
          "1901:  }",
          "1902:  return dst_tk;",
          "",
          "[Removed Lines]",
          "1899:    fprintf(stderr, \"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id);",
          "",
          "[Added Lines]",
          "1901:    M4_LOG(GF_LOG_WARNING, (\"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1952:   if (!force_cat) {",
          "1953:    gf_isom_hevc_set_inband_config(dest, dst_tk, 1, GF_FALSE);",
          "1954:   } else {",
          "1956:   }",
          "1957:  }",
          "1958:  return dst_tk;",
          "",
          "[Removed Lines]",
          "1955:    fprintf(stderr, \"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id);",
          "",
          "[Added Lines]",
          "1957:    M4_LOG(GF_LOG_WARNING, (\"WARNING: Concatenating track ID %d even though sample descriptions do not match\\n\", tk_id));",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "2073:   case GF_ISOM_MEDIA_HINT:",
          "2074:   case GF_ISOM_MEDIA_OD:",
          "2075:   case GF_ISOM_MEDIA_FLASH:",
          "2077:    continue;",
          "2078:   case GF_ISOM_MEDIA_AUDIO:",
          "2079:   case GF_ISOM_MEDIA_TEXT:",
          "",
          "[Removed Lines]",
          "2076:    fprintf(stderr, \"WARNING: Track ID %d (type %s) not handled by concatenation - removing from destination\\n\", gf_isom_get_track_id(orig, i+1), gf_4cc_to_str(mtype));",
          "",
          "[Added Lines]",
          "2078:    M4_LOG(GF_LOG_WARNING, (\"WARNING: Track ID %d (type %s) not handled by concatenation - removing from destination\\n\", gf_isom_get_track_id(orig, i+1), gf_4cc_to_str(mtype)));",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "2098:   }",
          "2099:  }",
          "2100:  if (!nb_samp) {",
          "2102:   goto err_exit;",
          "2103:  }",
          "",
          "[Removed Lines]",
          "2101:   fprintf(stderr, \"No suitable media tracks to cat in %s - skipping\\n\", fileName);",
          "",
          "[Added Lines]",
          "2103:   M4_LOG(GF_LOG_ERROR, (\"No suitable media tracks to cat in %s - skipping\\n\", fileName));",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "2119:   }",
          "2120:  }",
          "2123:  nb_done = 0;",
          "2124:  for (i=0; i<nb_tracks; i++) {",
          "2125:   u64 last_DTS, dest_track_dur_before_cat;",
          "",
          "[Removed Lines]",
          "2122:  fprintf(stderr, \"Appending file %s\\n\", fileName);",
          "",
          "[Added Lines]",
          "2124:  M4_LOG(GF_LOG_INFO, (\"Appending file %s\\n\", fileName));",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "2290:   if (dst_tk_sample_entry && !dst_tk) {",
          "2291:    u32 k, nb_sample_desc = gf_isom_get_sample_description_count(orig, i+1);",
          "2292:    dst_tk = dst_tk_sample_entry;",
          "2294:    for (k=0; k<nb_sample_desc; k++) {",
          "2295:     u32 sdesc_idx;",
          "2296:     e = gf_isom_clone_sample_description(dest, dst_tk, orig, i+1, k+1, NULL, NULL, &sdesc_idx);",
          "",
          "[Removed Lines]",
          "2293:    fprintf(stderr, \"Multiple sample entry required, merging\\n\");",
          "",
          "[Added Lines]",
          "2295:    M4_LOG(GF_LOG_INFO, (\"Multiple sample entry required, merging\\n\"));",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "2307:   if (!dst_tk) {",
          "2309:    e = gf_isom_clone_track(orig, i+1, dest, 0, &dst_tk);",
          "2310:    if (e) goto err_exit;",
          "2311:    gf_isom_clone_pl_indications(orig, dest);",
          "",
          "[Removed Lines]",
          "2308:    fprintf(stderr, \"No suitable destination track found - creating new one (type %s)\\n\", gf_4cc_to_str(mtype));",
          "",
          "[Added Lines]",
          "2310:    M4_LOG(GF_LOG_INFO, (\"No suitable destination track found - creating new one (type %s)\\n\", gf_4cc_to_str(mtype)));",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "2455:      if (prev_dur * movts_dst < segmentDuration * trackts_dst) {",
          "2457:       segmentDuration = (dest_track_dur_before_cat - mediaTime) * movts_dst;",
          "2458:       segmentDuration /= trackts_dst;",
          "2459:      }",
          "",
          "[Removed Lines]",
          "2456:       fprintf(stderr, \"Warning: suspicious edit list entry found: duration %g sec but longest track duration before cat is %g - fixing it\\n\", (Double) (s64) segmentDuration/movts_dst, prev_dur/trackts_dst);",
          "",
          "[Added Lines]",
          "2458:       M4_LOG(GF_LOG_WARNING, (\"Warning: suspicious edit list entry found: duration %g sec but longest track duration before cat is %g - fixing it\\n\", (Double) (s64) segmentDuration/movts_dst, prev_dur/trackts_dst));",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2476:    if (count) {",
          "2477:     e = gf_isom_get_edit(dest, dst_tk, count, &editTime, &segmentDuration, &mediaTime, &editMode);",
          "2478:     if (e) {",
          "2480:      goto err_exit;",
          "2481:     }",
          "2482:    } else if (gf_isom_get_edits_count(orig, i+1)) {",
          "",
          "[Removed Lines]",
          "2479:      fprintf(stderr, \"Error: edit segment error on destination track %u could not be retrieved.\\n\", dst_tk);",
          "",
          "[Added Lines]",
          "2481:      M4_LOG(GF_LOG_ERROR, (\"Error: edit segment error on destination track %u could not be retrieved.\\n\", dst_tk));",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2739:  e = gf_sm_load_init(&load);",
          "2740:  if (e<0) {",
          "2741:   gf_sm_load_done(&load);",
          "2743:   goto err_exit;",
          "2744:  }",
          "2745:  e = gf_sm_load_run(&load);",
          "",
          "[Removed Lines]",
          "2742:   fprintf(stderr, \"Cannot load context %s - %s\\n\", in, gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "2744:   M4_LOG(GF_LOG_ERROR, (\"Cannot load context %s - %s\\n\", in, gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2824:  if (e<0) {",
          "2826:   goto err_exit;",
          "2827:  } else {",
          "2828:   gf_log_cbk prev_logs = NULL;",
          "",
          "[Removed Lines]",
          "2825:   fprintf(stderr, \"Error loading file %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "2827:   M4_LOG(GF_LOG_ERROR, (\"Error loading file %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2959:   nbb = GetNbBits(ctx->max_node_id);",
          "2960:   if (!bcfg->nodeIDbits) bcfg->nodeIDbits=nbb;",
          "2963:   nbb = GetNbBits(ctx->max_route_id);",
          "2964:   if (!bcfg->routeIDbits) bcfg->routeIDbits = nbb;",
          "2967:   nbb = GetNbBits(ctx->max_proto_id);",
          "2968:   if (!bcfg->protoIDbits) bcfg->protoIDbits=nbb;",
          "2972:   encode_names = 0;",
          "",
          "[Removed Lines]",
          "2961:   if (bcfg->nodeIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.NodeIDBits TOO SMALL\\n\");",
          "2965:   if (bcfg->routeIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.RouteIDBits TOO SMALL\\n\");",
          "2969:   if (bcfg->protoIDbits<nbb) fprintf(stderr, \"Warning: BIFSConfig.ProtoIDBits TOO SMALL\\n\");",
          "",
          "[Added Lines]",
          "2963:   if (bcfg->nodeIDbits<nbb) M4_LOG(GF_LOG_WARNING, (\"Warning: BIFSConfig.NodeIDBits TOO SMALL\\n\"));",
          "2967:   if (bcfg->routeIDbits<nbb) M4_LOG(GF_LOG_WARNING, (\"Warning: BIFSConfig.RouteIDBits TOO SMALL\\n\"));",
          "2971:   if (bcfg->protoIDbits<nbb) M4_LOG(GF_LOG_WARNING, (\"Warning: BIFSConfig.ProtoIDBits TOO SMALL\\n\"));",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3019: GF_Err EncodeFileChunk(char *chunkFile, char *bifs, char *inputContext, char *outputContext, const char *tmpdir)",
          "3020: {",
          "3021: #if defined(GPAC_DISABLE_SMGR) || defined(GPAC_DISABLE_BIFS_ENC) || defined(GPAC_DISABLE_SCENE_ENCODER) || defined (GPAC_DISABLE_SCENE_DUMP)",
          "3023:  return GF_NOT_SUPPORTED;",
          "3024: #else",
          "3025:  GF_Err e;",
          "",
          "[Removed Lines]",
          "3022:  fprintf(stderr, \"BIFS encoding is not supported in this build of GPAC\\n\");",
          "",
          "[Added Lines]",
          "3024:  M4_LOG(GF_LOG_WARNING, (\"BIFS encoding is not supported in this build of GPAC\\n\"));",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3039:  if (!e) e = gf_sm_load_run(&load);",
          "3040:  gf_sm_load_done(&load);",
          "3041:  if (e) {",
          "3043:   goto exit;",
          "3044:  }",
          "",
          "[Removed Lines]",
          "3042:   fprintf(stderr, \"Cannot load context %s: %s\\n\", inputContext, gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "3044:   M4_LOG(GF_LOG_WARNING, (\"Cannot load context %s: %s\\n\", inputContext, gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3056:  if (!e) e = gf_sm_load_run(&load);",
          "3057:  gf_sm_load_done(&load);",
          "3058:  if (e) {",
          "3060:   goto exit;",
          "3061:  }",
          "",
          "[Removed Lines]",
          "3059:   fprintf(stderr, \"Cannot load scene commands chunk %s: %s\\n\", chunkFile, gf_error_to_string(e));",
          "3062:  fprintf(stderr, \"Context and chunks loaded\\n\");",
          "",
          "[Added Lines]",
          "3061:   M4_LOG(GF_LOG_WARNING, (\"Cannot load scene commands chunk %s: %s\\n\", chunkFile, gf_error_to_string(e)));",
          "3064:  M4_LOG(GF_LOG_INFO, (\"Context and chunks loaded\\n\"));",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3168:  type = gf_xml_get_root_type(file_name, &e);",
          "3169:  if (!type) {",
          "3171:   return NULL;",
          "3172:  }",
          "3173:  if (make_wgt) {",
          "3174:   if (strcmp(type, \"widget\")) {",
          "3176:    gf_free(type);",
          "3177:    return NULL;",
          "3178:   }",
          "",
          "[Removed Lines]",
          "3170:   fprintf(stderr, \"Cannot process XML file %s: %s\\n\", file_name, gf_error_to_string(e) );",
          "3175:    fprintf(stderr, \"XML Root type %s differs from \\\"widget\\\" \\n\", type);",
          "",
          "[Added Lines]",
          "3172:   M4_LOG(GF_LOG_ERROR, (\"Cannot process XML file %s: %s\\n\", file_name, gf_error_to_string(e) ));",
          "3177:    M4_LOG(GF_LOG_ERROR, (\"XML Root type %s differs from \\\"widget\\\" \\n\", type));",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3221:   else if (!stricmp(type, \"xmt-a\")) mtype = ascii ? GF_META_TYPE_XMTA : GF_META_TYPE_XMTZ;",
          "3222:  }",
          "3223:  if (!mtype) {",
          "3225:   e = GF_BAD_PARAM;",
          "3226:   goto exit;",
          "3227:  }",
          "",
          "[Removed Lines]",
          "3224:   fprintf(stderr, \"Missing 4CC code for meta name - please use ABCD:fileName\\n\");",
          "",
          "[Added Lines]",
          "3226:   M4_LOG(GF_LOG_ERROR, (\"Missing 4CC code for meta name - please use ABCD:fileName\\n\"));",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3251:    if (gf_isom_probe_file(res_url)) {",
          "3252:     if (res_url) gf_free(res_url);",
          "3253:     if (isom_src) {",
          "3255:      e = GF_NOT_SUPPORTED;",
          "3256:      goto exit;",
          "3257:     }",
          "",
          "[Removed Lines]",
          "3254:      fprintf(stderr, \"Cannot package several IsoMedia files together\\n\");",
          "",
          "[Added Lines]",
          "3256:      M4_LOG(GF_LOG_ERROR, (\"Cannot package several IsoMedia files together\\n\"));",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3362:  parser = gf_xml_dom_new();",
          "3363:  e = gf_xml_dom_parse(parser, file_name, NULL, NULL);",
          "3364:  if (e) {",
          "3366:   gf_xml_dom_del(parser);",
          "3367:   return e;",
          "3368:  }",
          "3369:  root = gf_xml_dom_get_root(parser);",
          "3370:  if (!root) {",
          "3372:   gf_xml_dom_del(parser);",
          "3373:   return e;",
          "3374:  }",
          "3375:  if (strcmp(root->name, \"HDR\")) {",
          "3377:   gf_xml_dom_del(parser);",
          "3378:   return GF_NON_COMPLIANT_BITSTREAM;",
          "3379:  }",
          "",
          "[Removed Lines]",
          "3365:   fprintf(stderr, \"Error parsing HDR XML file: Line %d - %s. Abort.\\n\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser));",
          "3371:   fprintf(stderr, \"Error parsing HDR XML file: no \\\"root\\\" found. Abort.\\n\");",
          "3376:   fprintf(stderr, \"Error parsing HDR XML file: root name is \\\"%s\\\", expecting \\\"HDR\\\"\\n\", root->name);",
          "",
          "[Added Lines]",
          "3367:   M4_LOG(GF_LOG_ERROR, (\"Error parsing HDR XML file: Line %d - %s. Abort.\\n\", gf_xml_dom_get_line(parser), gf_xml_dom_get_error(parser)));",
          "3373:   M4_LOG(GF_LOG_ERROR, (\"Error parsing HDR XML file: no \\\"root\\\" found. Abort.\\n\"));",
          "3378:   M4_LOG(GF_LOG_ERROR, (\"Error parsing HDR XML file: root name is \\\"%s\\\", expecting \\\"HDR\\\"\\n\", root->name));",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "3430:   e = gf_isom_set_high_dynamic_range_info(movie, id, 1, &mdcv, &clli);",
          "3431:   if (e) {",
          "3433:    break;",
          "3434:   }",
          "3435:  }",
          "",
          "[Removed Lines]",
          "3432:    fprintf(stderr, \"HDR XML: error in gf_isom_set_high_dynamic_range_info()\\n\");",
          "",
          "[Added Lines]",
          "3434:    M4_LOG(GF_LOG_ERROR, (\"HDR XML: error in gf_isom_set_high_dynamic_range_info()\\n\"));",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "3441: #else",
          "3442: GF_ISOFile *package_file(char *file_name, char *fcc, const char *tmpdir, Bool make_wgt)",
          "3443: {",
          "3445:  return NULL;",
          "3446: }",
          "3448: GF_Err parse_high_dynamc_range_xml_desc(GF_ISOFile* movie, char* file_name)",
          "3449: {",
          "3451:  return GF_OK;",
          "3452: }",
          "3453: #endif //#ifndef GPAC_DISABLE_CORE_TOOLS",
          "",
          "[Removed Lines]",
          "3444:  fprintf(stderr, \"XML Not supported in this build of GPAC - cannot package file\\n\");",
          "3450:  fprintf(stderr, \"XML Not supported in this build of GPAC - cannot process HDR parameter file\\n\");",
          "",
          "[Added Lines]",
          "3446:  M4_LOG(GF_LOG_ERROR, (\"XML Not supported in this build of GPAC - cannot package file\\n\"));",
          "3452:  M4_LOG(GF_LOG_ERROR, (\"XML Not supported in this build of GPAC - cannot process HDR parameter file\\n\"));",
          "",
          "---------------"
        ],
        "applications/mp4box/live.c||applications/mp4box/live.c": [
          "File: applications/mp4box/live.c -> applications/mp4box/live.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "391:   }",
          "392:  }",
          "393:  if (!filename) {",
          "395:   PrintLiveUsage();",
          "396:   return 1;",
          "397:  }",
          "",
          "[Removed Lines]",
          "394:   fprintf(stderr, \"Missing filename\\n\");",
          "",
          "[Added Lines]",
          "394:   M4_LOG(GF_LOG_ERROR, (\"Missing filename\\n\"));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "402:  livesess.seng = gf_seng_init(&livesess, filename, load_type, NULL, (load_type == GF_SM_LOAD_DIMS) ? 1 : 0);",
          "403:  if (!livesess.seng) {",
          "405:   return 1;",
          "406:  }",
          "407:  if (livesess.streams) {",
          "",
          "[Removed Lines]",
          "404:   fprintf(stderr, \"Cannot create scene engine\\n\");",
          "",
          "[Added Lines]",
          "404:   M4_LOG(GF_LOG_ERROR, (\"Cannot create scene engine\\n\"));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "440:     sscanf(arg, \"-rap=ESID=%u:%u\", &id, &period);",
          "441:     e = gf_seng_enable_aggregation(livesess.seng, id, 1);",
          "442:     if (e) {",
          "444:      goto exit;",
          "445:     }",
          "446:    } else {",
          "",
          "[Removed Lines]",
          "443:      fprintf(stderr, \"Cannot enable aggregation on stream %u: %s\\n\", id, gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "443:      M4_LOG(GF_LOG_ERROR, (\"Cannot enable aggregation on stream %u: %s\\n\", id, gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "700:     if (update_length) {",
          "701:      e = gf_seng_encode_from_string(livesess.seng, es_id, aggregate_au ? 0 : 1, update_buffer, live_session_callback);",
          "703:      e = gf_seng_aggregate_context(livesess.seng, 0);",
          "705:      update_context = 1;",
          "",
          "[Removed Lines]",
          "702:      if (e) fprintf(stderr, \"Processing command failed: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "702:      if (e) {",
          "703:       M4_LOG(GF_LOG_ERROR, (\"Processing command failed: %s\\n\", gf_error_to_string(e)));",
          "704:      }",
          "",
          "---------------"
        ],
        "applications/mp4box/main.c||applications/mp4box/main.c": [
          "File: applications/mp4box/main.c -> applications/mp4box/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2034:  if ((act_type==TRAC_ACTION_SET_ID) || (act_type==TRAC_ACTION_SWAP_ID)) {",
          "2035:   if (sscanf(param, \"%d:%u\", &tka->trackID, &tka->newTrackID) != 2) {",
          "2037:    return GF_FALSE;",
          "2038:   }",
          "2039:   return GF_TRUE;",
          "",
          "[Removed Lines]",
          "2036:    fprintf(stderr, \"Bad format for -set-track-id - expecting \\\"id1:id2\\\" got \\\"%s\\\"\\n\", param);",
          "",
          "[Added Lines]",
          "2036:    M4_LOG(GF_LOG_ERROR, (\"Bad format for -set-track-id - expecting \\\"id1:id2\\\" got \\\"%s\\\"\\n\", param));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2042:   char *ext;",
          "2043:   ext = strchr(param, '=');",
          "2044:   if (!ext) {",
          "2046:    return GF_FALSE;",
          "2047:   }",
          "2048:   ext[0] = 0;",
          "",
          "[Removed Lines]",
          "2045:    fprintf(stderr, \"Bad format for track par - expecting tkID=none or tkID=PAR_NUM:PAR_DEN got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2045:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track par - expecting tkID=none or tkID=PAR_NUM:PAR_DEN got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2065:     ext++;",
          "2066:    }",
          "2067:    if (sscanf(ext+1, \"%d:%d\", &tka->par_num, &tka->par_den) != 2) {",
          "2069:     return GF_FALSE;",
          "2070:    }",
          "2071:   }",
          "",
          "[Removed Lines]",
          "2068:     fprintf(stderr, \"Bad format for track par - expecting tkID=PAR_NUM:PAR_DEN got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2068:     M4_LOG(GF_LOG_ERROR, (\"Bad format for track par - expecting tkID=PAR_NUM:PAR_DEN got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2074:  if (act_type==TRAC_ACTION_SET_CLAP) {",
          "2075:   char *ext = strchr(param, '=');",
          "2076:   if (!ext) {",
          "2078:    return GF_FALSE;",
          "2079:   }",
          "2080:   ext[0] = 0;",
          "",
          "[Removed Lines]",
          "2077:    fprintf(stderr, \"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2077:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2083:   if (stricmp(ext + 1, \"none\")) {",
          "2084:    if (sscanf(ext + 1, \"%d,%d,%d,%d,%d,%d,%d,%d\", &tka->clap_wnum, &tka->clap_wden, &tka->clap_hnum, &tka->clap_hden, &tka->clap_honum, &tka->clap_hoden, &tka->clap_vonum, &tka->clap_voden) != 8) {",
          "2087:     return GF_FALSE;",
          "2088:    }",
          "2089:   }",
          "",
          "[Removed Lines]",
          "2086:     fprintf(stderr, \"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2086:     M4_LOG(GF_LOG_ERROR, (\"Bad format for track clap - expecting tkID=none or tkID=Wn,Wd,Hn,Hd,HOn,HOd,VOn,VOd got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2093:  if (act_type==TRAC_ACTION_SET_MX) {",
          "2094:   char *ext = strchr(param, '=');",
          "2095:   if (!ext) {",
          "2097:    return GF_FALSE;",
          "2098:   }",
          "2099:   ext[0] = 0;",
          "",
          "[Removed Lines]",
          "2096:    fprintf(stderr, \"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2096:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2110:     res = sscanf(ext + 1, \"%d:%d:%d:%d:%d:%d:%d:%d:%d\", &tka->mx[0], &tka->mx[1], &tka->mx[2], &tka->mx[3], &tka->mx[4], &tka->mx[5], &tka->mx[6], &tka->mx[7], &tka->mx[8]);",
          "2111:    }",
          "2112:    if (res != 9) {",
          "2114:     return GF_FALSE;",
          "2115:    }",
          "2116:   }",
          "",
          "[Removed Lines]",
          "2113:     fprintf(stderr, \"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2113:     M4_LOG(GF_LOG_ERROR, (\"Bad format for track matrix - expecting ID=none or ID=M1:M2:M3:M4:M5:M6:M7:M8:M9 got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2119:  if (act_type==TRAC_ACTION_SET_EDITS) {",
          "2120:   char *ext = strchr(param, '=');",
          "2121:   if (!ext) {",
          "2123:    return GF_FALSE;",
          "2124:   }",
          "2125:   ext[0] = 0;",
          "",
          "[Removed Lines]",
          "2122:    fprintf(stderr, \"Bad format for track edits - expecting ID=EDITS got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2122:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track edits - expecting ID=EDITS got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2169:   if (!scheme_start || !scheme_start[0]) {",
          "2171:    return GF_FALSE;",
          "2172:   } else {",
          "2173:    ext = strchr(scheme_start, '=');",
          "",
          "[Removed Lines]",
          "2170:    fprintf(stderr, \"Missing kind scheme - expecting ID=schemeURI=value got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2170:    M4_LOG(GF_LOG_ERROR, (\"Missing kind scheme - expecting ID=schemeURI=value got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2185:  if (act_type==TRAC_ACTION_SET_DELAY) {",
          "2186:   char *ext = strchr(param, '=');",
          "2187:   if (!ext) {",
          "2189:    return GF_FALSE;",
          "2190:   }",
          "2191:   ext[0] = 0;",
          "",
          "[Removed Lines]",
          "2188:    fprintf(stderr, \"Bad format for track delay - expecting tkID=DLAY got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2188:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track delay - expecting tkID=DLAY got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2201:   char *ext = strchr(param, '=');",
          "2202:   if (!ext) ext = strchr(param, ':');",
          "2203:   if (!ext) {",
          "2205:    return GF_FALSE;",
          "2206:   }",
          "2207:   ext[0] = 0;",
          "",
          "[Removed Lines]",
          "2204:    fprintf(stderr, \"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2204:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2211:   char *ext2 = strchr(ext, ':');",
          "2212:   if (!ext2) {",
          "2214:    return GF_FALSE;",
          "2215:   }",
          "2216:   ext2[0] = 0;",
          "",
          "[Removed Lines]",
          "2213:    fprintf(stderr, \"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2213:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track reference - expecting tkID:XXXX:refID got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2222:  if (act_type==TRAC_ACTION_SET_HANDLER_NAME) {",
          "2223:   char *ext = strchr(param, '=');",
          "2224:   if (!ext) {",
          "2226:    return GF_FALSE;",
          "2227:   }",
          "2228:   ext[0] = 0;",
          "",
          "[Removed Lines]",
          "2225:    fprintf(stderr, \"Bad format for track name - expecting tkID=name got %s\\n\", param);",
          "",
          "[Added Lines]",
          "2225:    M4_LOG(GF_LOG_ERROR, (\"Bad format for track name - expecting tkID=name got %s\\n\", param));",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2348:  else if (!stricmp(arg_val, \"single\"))  bitstream_switching_mode = GF_DASH_BSMODE_SINGLE;",
          "2349:  else if (!stricmp(arg_val, \"inband\"))  bitstream_switching_mode = GF_DASH_BSMODE_INBAND;",
          "2350:  else {",
          "2352:   return 2;",
          "2353:  }",
          "2354:  return 0;",
          "",
          "[Removed Lines]",
          "2351:   fprintf(stderr, \"Unrecognized bitstream switching mode \\\"%s\\\" - please check usage\\n\", arg_val);",
          "",
          "[Added Lines]",
          "2351:   M4_LOG(GF_LOG_ERROR, (\"Unrecognized bitstream switching mode \\\"%s\\\" - please check usage\\n\", arg_val));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2360:  else if (!strcmp(arg_val, \"as\")) cp_location_mode = GF_DASH_CPMODE_ADAPTATION_SET;",
          "2361:  else if (!strcmp(arg_val, \"rep\")) cp_location_mode = GF_DASH_CPMODE_REPRESENTATION;",
          "2362:  else {",
          "2364:   return 2;",
          "2365:  }",
          "2366:  return 0;",
          "",
          "[Removed Lines]",
          "2363:   fprintf(stderr, \"Unrecognized ContentProtection loction mode \\\"%s\\\" - please check usage\\n\", arg_val);",
          "",
          "[Added Lines]",
          "2363:   M4_LOG(GF_LOG_ERROR, (\"Unrecognized ContentProtection loction mode \\\"%s\\\" - please check usage\\n\", arg_val));",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2492:  else if (!stricmp(arg_val, \"main\")) dash_profile = GF_DASH_PROFILE_MAIN;",
          "2493:  else if (!stricmp(arg_val, \"full\")) dash_profile = GF_DASH_PROFILE_FULL;",
          "2494:  else {",
          "2496:   return 2;",
          "2497:  }",
          "2498:  return 0;",
          "",
          "[Removed Lines]",
          "2495:   fprintf(stderr, \"\\tUnrecognized DASH profile \\\"%s\\\" - please check usage\\n\", arg_val);",
          "",
          "[Added Lines]",
          "2495:   M4_LOG(GF_LOG_ERROR, (\"Unrecognized DASH profile \\\"%s\\\" - please check usage\\n\", arg_val));",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2502: {",
          "2503:  u32 ticks, dts_inc;",
          "2504:  if (!strcmp(arg_val, \"auto\")) {",
          "2506:  }",
          "2507:  else if ((sscanf(arg_val, \"%u-%u\", &ticks, &dts_inc)==2) || (sscanf(arg_val, \"%u/%u\", &ticks, &dts_inc)==2) ) {",
          "2508:   if (!dts_inc) dts_inc = 1;",
          "",
          "[Removed Lines]",
          "2505:   fprintf(stderr, \"Warning, fps=auto option is deprecated\\n\");",
          "",
          "[Added Lines]",
          "2505:   M4_LOG(GF_LOG_WARNING, (\"Warning, fps=auto option is deprecated\\n\"));",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2537:  case 3: //-split-chunk, -splitx",
          "2538:   if (!strstr(arg_val, \":\")) {",
          "2540:    return 2;",
          "2541:   }",
          "2542:   if (strstr(arg_val, \"end\")) {",
          "",
          "[Removed Lines]",
          "2539:    fprintf(stderr, \"Chunk extraction usage: \\\"-splitx start:end\\\" expressed in seconds\\n\");",
          "",
          "[Added Lines]",
          "2539:    M4_LOG(GF_LOG_ERROR, (\"Chunk extraction usage: \\\"-splitx start:end\\\" expressed in seconds\\n\"));",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2632:   if (strlen(arg_val) == 5) trackID = 2;",
          "2633:   else trackID = 1 + atoi(arg_val + 5);",
          "2634:  } else {",
          "2636:   return 2;",
          "2637:  }",
          "2638:  track_dump_type = GF_EXPORT_AVI_NATIVE;",
          "",
          "[Removed Lines]",
          "2635:   fprintf(stderr, \"Usage: \\\"-aviraw video\\\" or \\\"-aviraw audio\\\"\\n\");",
          "",
          "[Added Lines]",
          "2635:   M4_LOG(GF_LOG_ERROR, (\"Expected `-aviraw video` or `-aviraw audio`got %s\\n\", arg_val));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2657:   u32 hex1, hex2, hex3, hex4;",
          "2658:   if (sscanf(code, \"%02x%02x%02x%02x\", &hex1, &hex2, &hex3, &hex4) != 4) {",
          "2660:    return 2;",
          "2661:   }",
          "2662:   dump_udta_type = GF_4CC(hex1, hex2, hex3, hex4);",
          "2663:  } else {",
          "2665:   return 2;",
          "2666:  }",
          "2667:  return 0;",
          "",
          "[Removed Lines]",
          "2659:    fprintf(stderr, \"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\");",
          "2664:   fprintf(stderr, \"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\");",
          "",
          "[Added Lines]",
          "2659:    M4_LOG(GF_LOG_ERROR, (\"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\"));",
          "2664:   M4_LOG(GF_LOG_ERROR, (\"udta code is either a 4CC or 8 hex chars for non-printable 4CC\\n\"));",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2725:  else if (!strcmp(arg_val, \"dash\")) PrintDASHUsage();",
          "2726:  else if (!strcmp(arg_val, \"dump\")) PrintDumpUsage();",
          "2727:  else if (!strcmp(arg_val, \"import\")) PrintImportUsage();",
          "2729:  else if (!strcmp(arg_val, \"hint\")) PrintHintUsage();",
          "2730:  else if (!strcmp(arg_val, \"encode\")) PrintEncodeUsage();",
          "2731:  else if (!strcmp(arg_val, \"crypt\")) PrintEncryptUsage();",
          "2732:  else if (!strcmp(arg_val, \"meta\")) PrintMetaUsage();",
          "2733:  else if (!strcmp(arg_val, \"swf\")) PrintSWFUsage();",
          "2734: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "2736:  else if (!strcmp(arg_val, \"live\")) PrintLiveUsage();",
          "2737: #endif",
          "2738:  else if (!strcmp(arg_val, \"core\")) PrintCoreUsage();",
          "",
          "[Removed Lines]",
          "2728:  else if (!strcmp(arg_val, \"format\")) fprintf(stderr, \"deprecated, see [filters documentation](Filters)\\n\");",
          "2735:  else if (!strcmp(arg_val, \"rtp\")) fprintf(stderr, \"RTP streaming deprecated in MP4Box, use gpac application\\n\");",
          "",
          "[Added Lines]",
          "2728:  else if (!strcmp(arg_val, \"format\")) {",
          "2729:   M4_LOG(GF_LOG_WARNING, (\"deprecated, see [filters documentation](Filters)\\n\"));",
          "2730:  }",
          "2737:  else if (!strcmp(arg_val, \"rtp\")) {",
          "2738:   M4_LOG(GF_LOG_WARNING, (\"RTP streaming deprecated in MP4Box, use gpac application\\n\"));",
          "2739:  }",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "2883: #ifdef TEST_ARGS",
          "2884:   char *sep = strchr(arg_desc->name, ' ');",
          "2885:   if (sep) {",
          "2887:    exit(1);",
          "2888:   }",
          "2889: #endif",
          "",
          "[Removed Lines]",
          "2886:    fprintf(stderr, \"invalid arg %s, space not allowed\\n\", arg_desc->name);",
          "",
          "[Added Lines]",
          "2890:    M4_LOG(GF_LOG_ERROR, (\"Invalid arg %s, space not allowed\\n\", arg_desc->name));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "2915:     has_next = GF_FALSE;",
          "2916:   }",
          "2917:   if (!has_next && ! (arg_desc->parse_flags & ARG_EMPTY) ) {",
          "2919:    arg_parse_res = 2;",
          "2920:    return GF_TRUE;",
          "2921:   }",
          "",
          "[Removed Lines]",
          "2918:    fprintf(stderr, \"Missing argument value for %s - please check usage\\n\", arg);",
          "",
          "[Added Lines]",
          "2922:    M4_LOG(GF_LOG_ERROR, (\"Missing argument value for %s - please check usage\\n\", arg));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "2988:   if (arg_desc->parse_flags & ARG_IS_4CC) {",
          "2989:    u32 alen = (u32) strlen(arg_val);",
          "2990:    if ((alen<3) || (alen>4)) {",
          "2992:     arg_parse_res = 2;",
          "2993:     return GF_TRUE;",
          "2994:    }",
          "",
          "[Removed Lines]",
          "2991:     fprintf(stderr, \"Value for %s must be a 4CC, %s is not - please check usage\\n\", arg, arg_val);",
          "",
          "[Added Lines]",
          "2995:     M4_LOG(GF_LOG_ERROR, (\"Value for %s must be a 4CC, %s is not - please check usage\\n\", arg, arg_val));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "3005:    v /= 1000;",
          "3006:   }",
          "3007:   if ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {",
          "3009:    arg_parse_res = 2;",
          "3010:    return GF_TRUE;",
          "3011:   }",
          "",
          "[Removed Lines]",
          "3008:    fprintf(stderr, \"Value for %s shall not be 0 - please check usage\\n\", arg);",
          "",
          "[Added Lines]",
          "3012:    M4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "3014:  }",
          "3016:  if (arg_desc->type != GF_ARG_INT) {",
          "3018:   arg_parse_res = 2;",
          "3019:   return GF_TRUE;",
          "3020:  }",
          "",
          "[Removed Lines]",
          "3017:   fprintf(stderr, \"Unsupported argument type for %s - please report to gpac devs\\n\", arg);",
          "",
          "[Added Lines]",
          "3021:   M4_LOG(GF_LOG_ERROR, (\"Unsupported argument type for %s - please report to gpac devs\\n\", arg));",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "3025:    v /= 1000;",
          "3026:   }",
          "3027:   if ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {",
          "3029:    arg_parse_res = 2;",
          "3030:    return GF_TRUE;",
          "3031:   }",
          "",
          "[Removed Lines]",
          "3028:    fprintf(stderr, \"Value for %s shall not be 0 - please check usage\\n\", arg);",
          "",
          "[Added Lines]",
          "3032:    M4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "3036:    v /= 1000;",
          "3037:   }",
          "3038:   if ((arg_desc->parse_flags & ARG_NON_ZERO) && !v) {",
          "3040:    arg_parse_res = 2;",
          "3041:    return GF_TRUE;",
          "3042:   }",
          "",
          "[Removed Lines]",
          "3039:    fprintf(stderr, \"Value for %s shall not be 0 - please check usage\\n\", arg);",
          "",
          "[Added Lines]",
          "3043:    M4_LOG(GF_LOG_ERROR, (\"Value for %s shall not be 0 - please check usage\\n\", arg));",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "3076:    char *arg_val = arg;",
          "3077:    if (!stricmp(arg, \"--\")) {",
          "3078:     if (i+1==(u32)argc) {",
          "3080:      return 2;",
          "3081:     }",
          "3082:     has_next_arg = GF_TRUE;",
          "",
          "[Removed Lines]",
          "3079:      fprintf(stderr, \"Missing arg for `--` - please check usage\\n\"); return mp4box_cleanup(1);",
          "",
          "[Added Lines]",
          "3083:      M4_LOG(GF_LOG_ERROR, (\"Missing arg for `--` - please check usage\\n\"));",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "3084:     i++;",
          "3085:    }",
          "3086:    if (argc < 3) {",
          "3088:     return 2;",
          "3089:    }",
          "3090:    else if (inName) {",
          "",
          "[Removed Lines]",
          "3087:     fprintf(stderr, \"Error - only one input file found as argument, please check usage\\n\");",
          "",
          "[Added Lines]",
          "3091:     M4_LOG(GF_LOG_ERROR, (\"Error - only one input file found as argument, please check usage\\n\"));",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "3095:      dash_inputs = set_dash_input(dash_inputs, arg_val, &nb_dash_inputs);",
          "3096:     }",
          "3097:     else {",
          "3099:      return 2;",
          "3100:     }",
          "3101:    }",
          "",
          "[Removed Lines]",
          "3098:      fprintf(stderr, \"Error - 2 input names specified, please check usage\\n\");",
          "",
          "[Added Lines]",
          "3102:      M4_LOG(GF_LOG_ERROR, (\"Error - 2 input names specified, please check usage\\n\"));",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "3105:   }",
          "3107:   else if (!stricmp(arg, \"-grab-ts\") || !stricmp(arg, \"-atsc\") || !stricmp(arg, \"-rtp\")) {",
          "3110:   }",
          "3111:   else if (!stricmp(arg, \"-write-buffer\")) {",
          "3113:    gf_opts_set_key(\"temp\", \"bs-cache-size\", argv[i + 1]);",
          "3114:    i++;",
          "3115:   }",
          "3116:   else if (!stricmp(arg, \"-pssh-moof\")) {",
          "3119:   }",
          "3120:   else if (!stricmp(arg, \"-tag-list\")) {",
          "3123:   }",
          "",
          "[Removed Lines]",
          "3108:    fprintf(stderr, \"Deprecated fuctionnality `%s` - use gpac application\\n\", arg);",
          "3109:    return mp4box_cleanup(2);",
          "3112:    fprintf(stderr, \"`%s` option deprecated, use `-bs-cache-size`\", arg);",
          "3117:    fprintf(stderr, \"`-pssh-moof` option deprecated , use `-pssh` option\\n\");",
          "3118:    return mp4box_cleanup(2);",
          "3121:    fprintf(stderr, \"`-tag-list`option deprecated, use `-h tags`\\n\");",
          "3122:    return 1;",
          "",
          "[Added Lines]",
          "3112:    M4_LOG(GF_LOG_ERROR, (\"Deprecated fuctionnality `%s` - use gpac application\\n\", arg));",
          "3113:    return 2;",
          "3116:    M4_LOG(GF_LOG_WARNING, (\"`%s` option deprecated, use `-bs-cache-size`\", arg));",
          "3121:    M4_LOG(GF_LOG_ERROR, (\"`-pssh-moof` option deprecated , use `-pssh` option\\n\"));",
          "3122:    return 2;",
          "3125:    M4_LOG(GF_LOG_ERROR, (\"`-tag-list`option deprecated, use `-h tags`\\n\"));",
          "3126:    return 2;",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "3240:   if (!gf_isom_get_sample_count(file, i+1)) continue;",
          "3241:   if (!gf_isom_is_track_enabled(file, i+1)) {",
          "3243:    continue;",
          "3244:   }",
          "",
          "[Removed Lines]",
          "3242:    fprintf(stderr, \"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) );",
          "",
          "[Added Lines]",
          "3246:    M4_LOG(GF_LOG_INFO, (\"Track ID %d disabled - skipping hint\\n\", gf_isom_get_track_id(file, i+1) ));",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "3320:   if (!hinter) {",
          "3321:    if (e) {",
          "3323:     if (!nb_done) return e;",
          "3324:    }",
          "3325:    continue;",
          "",
          "[Removed Lines]",
          "3322:     fprintf(stderr, \"Cannot create hinter (%s)\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "3326:     M4_LOG(nb_done ? GF_LOG_WARNING : GF_LOG_ERROR, (\"Cannot create hinter (%s)\\n\", gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "3336:   gf_isom_set_nalu_extract_mode(file, i+1, GF_ISOM_NALU_EXTRACT_LAYER_ONLY);",
          "3338:   gf_hinter_track_get_payload_name(hinter, szPayload);",
          "3345:   e = gf_hinter_track_process(hinter);",
          "3347:   if (!e) e = gf_hinter_track_finalize(hinter, has_iod);",
          "3348:   gf_hinter_track_del(hinter);",
          "3350:   if (e) {",
          "3352:    if (!nb_done) return e;",
          "3353:   }",
          "3354:   init_payt++;",
          "",
          "[Removed Lines]",
          "3339:   fprintf(stderr, \"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw);",
          "3340:   if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) fprintf(stderr, \"\\tMPEG-4 Systems stream carousel enabled\\n\");",
          "3342:     if (flags & GP_RTP_PCK_FORCE_MPEG4) fprintf(stderr, \"\\tMPEG4 transport forced\\n\");",
          "3343:     if (flags & GP_RTP_PCK_USE_MULTI) fprintf(stderr, \"\\tRTP aggregation enabled\\n\");",
          "3351:    fprintf(stderr, \"Error while hinting (%s)\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "3343:   M4_LOG(GF_LOG_INFO, (\"Hinting track ID %d - Type \\\"%s:%s\\\" (%s) - BW %d kbps\\n\", gf_isom_get_track_id(file, i+1), gf_4cc_to_str(mtype), gf_4cc_to_str(mtype), szPayload, bw));",
          "3344:   if (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) M4_LOG(GF_LOG_INFO, (\"\\tMPEG-4 Systems stream carousel enabled\\n\"));",
          "3351:    M4_LOG(GF_LOG_ERROR, (\"Error while hinting (%s)\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "3364:  gf_hinter_finalize(file, iod_mode, tot_bw);",
          "3366:  if (!single_ocr)",
          "3369:  return GF_OK;",
          "3370: }",
          "",
          "[Removed Lines]",
          "3367:   fprintf(stderr, \"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\");",
          "",
          "[Added Lines]",
          "3367:   M4_LOG(GF_LOG_WARNING, (\"Warning: at least 2 timelines found in the file\\nThis may not be supported by servers/players\\n\\n\"));",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "3518:  e = gf_xml_dom_parse(dom, inName, NULL, NULL);",
          "3519:  if (e) {",
          "3520:   gf_xml_dom_del(dom);",
          "3522:   return e;",
          "3523:  }",
          "3524:  root = gf_xml_dom_get_root_idx(dom, 0);",
          "",
          "[Removed Lines]",
          "3521:   fprintf(stderr, \"Failed to parse XML file: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "3521:   M4_LOG(GF_LOG_ERROR, (\"Failed to parse XML file: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "3531:  gf_xml_dom_del(dom);",
          "3533:  if (e) {",
          "3535:   return e;",
          "3536:  }",
          "",
          "[Removed Lines]",
          "3534:   fprintf(stderr, \"Failed to parse binary sequence: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "3534:   M4_LOG(GF_LOG_ERROR, (\"Failed to parse binary sequence: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "3548:   }",
          "3549:   t = gf_fopen(szFile, \"wb\");",
          "3550:   if (!t) {",
          "3552:    e = GF_IO_ERR;",
          "3553:   } else {",
          "3554:    if (gf_fwrite(data, data_size, t) != data_size) {",
          "3556:     e = GF_IO_ERR;",
          "3557:    }",
          "3558:    gf_fclose(t);",
          "",
          "[Removed Lines]",
          "3551:    fprintf(stderr, \"Failed to open file %s\\n\", szFile);",
          "3555:     fprintf(stderr, \"Failed to write output to file %s\\n\", szFile);",
          "",
          "[Added Lines]",
          "3551:    M4_LOG(GF_LOG_ERROR, (\"Failed to open file %s\\n\", szFile));",
          "3555:     M4_LOG(GF_LOG_ERROR, (\"Failed to write output to file %s\\n\", szFile));",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "3622:  GF_BitStream *bs_in, *bs_out;",
          "3624:  if (!outName) {",
          "3626:   return GF_BAD_PARAM;",
          "3627:  }",
          "",
          "[Removed Lines]",
          "3625:   fprintf(stderr, \"Missing output file name\\n\");",
          "",
          "[Added Lines]",
          "3625:   M4_LOG(GF_LOG_ERROR, (\"Missing output file name\\n\"));",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "3702:  gf_fclose(in);",
          "3703:  gf_fclose(out);",
          "3704:  if (e) {",
          "3706:   return e;",
          "3707:  }",
          "",
          "[Removed Lines]",
          "3705:   fprintf(stderr, \"Error compressing: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "3705:   M4_LOG(GF_LOG_ERROR, (\"Error compressing: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "3764:  return GF_OK;",
          "3765: }",
          "3773:  }",
          "3777:  }",
          "3788:  }",
          "3802:   }",
          "3866:   }",
          "3869:  }",
          "3878: {",
          "3886: #endif",
          "3892: #else",
          "3894: #endif",
          "3903:    }",
          "3904:   }",
          "3921:  }",
          "3933:  }",
          "4038:   }",
          "4039:  }",
          "4044:  }",
          "4055: #endif",
          "4074:  }",
          "4164:  }",
          "4168:  }",
          "4184:  }",
          "4189:  }",
          "4230:   if (e) {",
          "4239:  }",
          "4273:   }",
          "4277:   }",
          "4298:   }",
          "4361:      }",
          "4381:      }",
          "4388:      }",
          "4400:     }",
          "4413:     }",
          "4414:    }",
          "4415:   }",
          "4490:   }",
          "4494:  }",
          "4560:   }",
          "4582:    }",
          "4583:   }",
          "4620:   }",
          "4625:   }",
          "4638:    }",
          "4643:     e = GF_OK;",
          "4652:     e = GF_OK;",
          "4653:    }",
          "4665:     }",
          "4673:       }",
          "4677:       }",
          "4681:       }",
          "4682:      }",
          "4686:      }",
          "4696:      }",
          "4697:     }",
          "4700:    }",
          "4701:   }",
          "4710:    }",
          "4711:   }",
          "4717:   if (e) return mp4box_cleanup(1);",
          "4718:   goto exit;",
          "4719:  }",
          "4722: #ifndef GPAC_DISABLE_MEDIA_EXPORT",
          "4723:           && !(track_dump_type & GF_EXPORT_AVI_NATIVE)",
          "4724: #endif",
          "",
          "[Removed Lines]",
          "3769: static u32 mp4box_cleanup(u32 ret_code) {",
          "3770:  if (mpd_base_urls) {",
          "3771:   gf_free(mpd_base_urls);",
          "3772:   mpd_base_urls = NULL;",
          "3774:  if (sdp_lines) {",
          "3775:   gf_free(sdp_lines);",
          "3776:   sdp_lines = NULL;",
          "3778:  if (metas) {",
          "3779:   u32 i;",
          "3780:   for (i=0; i<nb_meta_act; i++) {",
          "3781:    if (metas[i].enc_type) gf_free(metas[i].enc_type);",
          "3782:    if (metas[i].mime_type) gf_free(metas[i].mime_type);",
          "3783:    if (metas[i].szName) gf_free(metas[i].szName);",
          "3784:    if (metas[i].szPath) gf_free(metas[i].szPath);",
          "3785:   }",
          "3786:   gf_free(metas);",
          "3787:   metas = NULL;",
          "3789:  if (tracks) {",
          "3790:   u32 i;",
          "3791:   for (i = 0; i<nb_track_act; i++) {",
          "3792:    if (tracks[i].out_name)",
          "3793:     gf_free(tracks[i].out_name);",
          "3794:    if (tracks[i].src_name)",
          "3795:     gf_free(tracks[i].src_name);",
          "3796:    if (tracks[i].string)",
          "3797:     gf_free(tracks[i].string);",
          "3798:    if (tracks[i].kind_scheme)",
          "3799:     gf_free(tracks[i].kind_scheme);",
          "3800:    if (tracks[i].kind_value)",
          "3801:     gf_free(tracks[i].kind_value);",
          "3803:   gf_free(tracks);",
          "3804:   tracks = NULL;",
          "3805:  }",
          "3806:  if (tsel_acts) {",
          "3807:   gf_free(tsel_acts);",
          "3808:   tsel_acts = NULL;",
          "3809:  }",
          "3810:  if (brand_add) {",
          "3811:   gf_free(brand_add);",
          "3812:   brand_add = NULL;",
          "3813:  }",
          "3814:  if (brand_rem) {",
          "3815:   gf_free(brand_rem);",
          "3816:   brand_rem = NULL;",
          "3817:  }",
          "3818:  if (dash_inputs) {",
          "3819:   u32 i, j;",
          "3820:   for (i = 0; i<nb_dash_inputs; i++) {",
          "3821:    GF_DashSegmenterInput *di = &dash_inputs[i];",
          "3822:    if (di->nb_baseURL) {",
          "3823:     for (j = 0; j<di->nb_baseURL; j++) {",
          "3824:      gf_free(di->baseURL[j]);",
          "3825:     }",
          "3826:     gf_free(di->baseURL);",
          "3827:    }",
          "3828:    if (di->rep_descs) {",
          "3829:     for (j = 0; j<di->nb_rep_descs; j++) {",
          "3830:      gf_free(di->rep_descs[j]);",
          "3831:     }",
          "3832:     gf_free(di->rep_descs);",
          "3833:    }",
          "3834:    if (di->as_descs) {",
          "3835:     for (j = 0; j<di->nb_as_descs; j++) {",
          "3836:      gf_free(di->as_descs[j]);",
          "3837:     }",
          "3838:     gf_free(di->as_descs);",
          "3839:    }",
          "3840:    if (di->as_c_descs) {",
          "3841:     for (j = 0; j<di->nb_as_c_descs; j++) {",
          "3842:      gf_free(di->as_c_descs[j]);",
          "3843:     }",
          "3844:     gf_free(di->as_c_descs);",
          "3845:    }",
          "3846:    if (di->p_descs) {",
          "3847:     for (j = 0; j<di->nb_p_descs; j++) {",
          "3848:      gf_free(di->p_descs[j]);",
          "3849:     }",
          "3850:     gf_free(di->p_descs);",
          "3851:    }",
          "3852:    if (di->representationID) gf_free(di->representationID);",
          "3853:    if (di->periodID) gf_free(di->periodID);",
          "3854:    if (di->xlink) gf_free(di->xlink);",
          "3855:    if (di->seg_template) gf_free(di->seg_template);",
          "3856:    if (di->hls_pl) gf_free(di->hls_pl);",
          "3857:    if (di->source_opts) gf_free(di->source_opts);",
          "3858:    if (di->filter_chain) gf_free(di->filter_chain);",
          "3860:    if (di->roles) {",
          "3861:     for (j = 0; j<di->nb_roles; j++) {",
          "3862:      gf_free(di->roles[j]);",
          "3863:     }",
          "3864:     gf_free(di->roles);",
          "3865:    }",
          "3867:   gf_free(dash_inputs);",
          "3868:   dash_inputs = NULL;",
          "3870:  if (logfile) gf_fclose(logfile);",
          "3871:  gf_sys_close();",
          "3872:  return ret_code;",
          "3873: }",
          "3877: int mp4boxMain(int argc, char **argv)",
          "3879:  u32 i, j;",
          "3880:  const char *gpac_profile = \"0\";",
          "3881:  GF_Err e = GF_OK;",
          "3883: #ifdef TEST_ARGS",
          "3884:  i=0;",
          "3885:  mp4box_parse_single_arg(argc, argv, \"\", &i);",
          "3888:  for (i = 1; i < (u32) argc ; i++) {",
          "3889:   if (!strcmp(argv[i], \"-mem-track\") || !strcmp(argv[i], \"-mem-track-stack\")) {",
          "3890: #ifdef GPAC_MEMORY_TRACKING",
          "3891:             mem_track = !strcmp(argv[i], \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;",
          "3893:    fprintf(stderr, \"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", argv[i]);",
          "3895:    break;",
          "3896:   }",
          "3897:   else if (!strcmp(argv[i], \"-p\")) {",
          "3898:    if (i+1<(u32) argc)",
          "3899:     gpac_profile = argv[i+1];",
          "3900:    else {",
          "3901:     fprintf(stderr, \"Bad argument for -p, expecting profile name but no more args\\n\");",
          "3902:     return 1;",
          "3905:   else if (!strncmp(argv[i], \"-p=\", 3))",
          "3906:    gpac_profile = argv[i]+3;",
          "3907:  }",
          "3909: #ifdef _TWO_DIGIT_EXPONENT",
          "3910:  _set_output_format(_TWO_DIGIT_EXPONENT);",
          "3911: #endif",
          "3914:  gf_sys_init(mem_track, gpac_profile);",
          "3915:  if (argc < 2) {",
          "3916:   fprintf(stderr, \"Not enough arguments - check usage with -h\\n\"",
          "3917:    \"MP4Box - GPAC version %s\\n\"",
          "3918:          \"%s\\n\", gf_gpac_version(), gf_gpac_copyright_cite());",
          "3919:   gf_sys_close();",
          "3920:   return 0;",
          "3923:  helpout = stdout;",
          "3925:  i = mp4box_parse_args(argc, argv);",
          "3926:  if (i) {",
          "3927:   return mp4box_cleanup(i - 1);",
          "3928:  }",
          "3929: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "3930:  if (live_scene) {",
          "3931:   int ret = live_session(argc, argv);",
          "3932:   return mp4box_cleanup(ret);",
          "3934: #endif",
          "3936:  if (do_mpd_conv) inName = do_mpd_conv;",
          "3938:  if (import_flags & GF_IMPORT_FORCE_MPEG4)",
          "3939:   hint_flags |= GP_RTP_PCK_FORCE_MPEG4;",
          "3941:  if (!inName && dump_std)",
          "3942:   inName = \"std\";",
          "3944:  if (!dash_duration && cprt)",
          "3945:   open_edit = GF_TRUE;",
          "3947:  if (!inName) {",
          "3948:   if (has_next_arg) {",
          "3949:    fprintf(stderr, \"Broken argument specifier or file name missing - check usage with -h\\n\");",
          "3950:   } else {",
          "3951:    PrintUsage();",
          "3952:   }",
          "3953:   return mp4box_cleanup(1);",
          "3954:  }",
          "3955:  if (!strcmp(inName, \"std\")) dump_std = 2;",
          "3956:  if (!strcmp(inName, \"stdb\")) {",
          "3957:   inName = \"std\";",
          "3958:   dump_std = 1;",
          "3959:  }",
          "3961:  if (!interleaving_time) {",
          "3963:   if (dash_duration)",
          "3964:    interleaving_time = dash_duration;",
          "3965:   else if (!do_flat) {",
          "3966:    interleaving_time = DEFAULT_INTERLEAVING_IN_SEC;",
          "3967:   }",
          "3968:  }",
          "3970:  if (dump_std)",
          "3971:   outName = \"std\";",
          "3973:  if (dump_std==2) {",
          "3974: #ifdef WIN32",
          "3975:   if ( _setmode(_fileno(stdout), _O_BINARY) == -1 )",
          "3976: #else",
          "3977:   if ( freopen(NULL, \"wb\", stdout) == NULL)",
          "3978: #endif",
          "3979:   {",
          "3980:    fprintf(stderr, \"Fatal error: cannot reopen stdout in binary mode.\\n\");",
          "3981:    return mp4box_cleanup(1);",
          "3982:   }",
          "3983:  }",
          "3985:  GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO;",
          "3986:  gf_log_set_tool_level(GF_LOG_CONTAINER, level);",
          "3987:  gf_log_set_tool_level(GF_LOG_SCENE, level);",
          "3988:  gf_log_set_tool_level(GF_LOG_PARSER, level);",
          "3989:  gf_log_set_tool_level(GF_LOG_AUTHOR, level);",
          "3990:  gf_log_set_tool_level(GF_LOG_CODING, level);",
          "3991:  gf_log_set_tool_level(GF_LOG_DASH, level);",
          "3992: #ifdef GPAC_MEMORY_TRACKING",
          "3993:  if (mem_track)",
          "3994:   gf_log_set_tool_level(GF_LOG_MEMORY, level);",
          "3995: #endif",
          "3997:  e = gf_sys_set_args(argc, (const char **) argv);",
          "3998:  if (e) {",
          "3999:   fprintf(stderr, \"Error assigning libgpac arguments: %s\\n\", gf_error_to_string(e) );",
          "4000:   return mp4box_cleanup(1);",
          "4001:  }",
          "4003:  if (raw_cat) {",
          "4004:   char chunk[4096];",
          "4005:   FILE *fin, *fout;",
          "4006:   s64 to_copy, done;",
          "4007:   fin = gf_fopen(raw_cat, \"rb\");",
          "4008:   if (!fin) return mp4box_cleanup(1);",
          "4010:   fout = gf_fopen(inName, \"a+b\");",
          "4011:   if (!fout) {",
          "4012:    gf_fclose(fin);",
          "4013:    return mp4box_cleanup(1);",
          "4014:   }",
          "4015:   gf_fseek(fin, 0, SEEK_END);",
          "4016:   to_copy = gf_ftell(fin);",
          "4017:   gf_fseek(fin, 0, SEEK_SET);",
          "4018:   done = 0;",
          "4019:   while (1) {",
          "4020:    u32 nb_bytes = (u32) gf_fread(chunk, 4096, fin);",
          "4021:    gf_fwrite(chunk, nb_bytes, fout);",
          "4022:    done += nb_bytes;",
          "4023:    fprintf(stderr, \"Appending file %s - %02.2f done\\r\", raw_cat, 100.0*done/to_copy);",
          "4024:    if (done >= to_copy) break;",
          "4025:   }",
          "4026:   gf_fclose(fin);",
          "4027:   gf_fclose(fout);",
          "4028:   return mp4box_cleanup(0);",
          "4029:  }",
          "4030:  if (compress_top_boxes) {",
          "4031:   if (size_top_box) {",
          "4032:    u64 top_size = do_size_top_boxes(inName, compress_top_boxes, size_top_box);",
          "4033:    fprintf(stdout, LLU\"\\n\", top_size);",
          "4034:    return mp4box_cleanup(e ? 1 : 0);",
          "4035:   } else {",
          "4036:    e = do_compress_top_boxes(inName, outName);",
          "4037:    return mp4box_cleanup(e ? 1 : 0);",
          "4041:  if (do_mpd_rip) {",
          "4042:   e = rip_mpd(inName, outName);",
          "4043:   return mp4box_cleanup(e ? 1 : 0);",
          "4046: #ifndef GPAC_DISABLE_CORE_TOOLS",
          "4047:  if (do_wget != NULL) {",
          "4048:   e = gf_dm_wget(do_wget, inName, 0, 0, NULL);",
          "4049:   if (e != GF_OK) {",
          "4050:    fprintf(stderr, \"Cannot retrieve %s: %s\\n\", do_wget, gf_error_to_string(e) );",
          "4051:    return mp4box_cleanup(1);",
          "4052:   }",
          "4053:   return mp4box_cleanup(0);",
          "4054:  }",
          "4057:  if (udp_dest) {",
          "4058:   GF_Socket *sock = gf_sk_new(GF_SOCK_TYPE_UDP);",
          "4059:   u16 port = 2345;",
          "4060:   char *sep = strrchr(udp_dest, ':');",
          "4061:   if (sep) {",
          "4062:    sep[0] = 0;",
          "4063:    port = atoi(sep+1);",
          "4064:   }",
          "4065:   e = gf_sk_bind( sock, \"127.0.0.1\", 0, udp_dest, port, 0);",
          "4066:   if (sep) sep[0] = ':';",
          "4067:   if (e) fprintf(stderr, \"Failed to bind socket to %s: %s\\n\", udp_dest, gf_error_to_string(e) );",
          "4068:   else {",
          "4069:    e = gf_sk_send(sock, (u8 *) inName, (u32)strlen(inName));",
          "4070:    if (e) fprintf(stderr, \"Failed to send datagram: %s\\n\", gf_error_to_string(e) );",
          "4071:   }",
          "4072:   gf_sk_del(sock);",
          "4073:   return 0;",
          "4076: #ifndef GPAC_DISABLE_MPD",
          "4077:  if (do_mpd_conv) {",
          "4078:   Bool remote = GF_FALSE;",
          "4079:   GF_MPD *mpd;",
          "4080:   char *mpd_base_url = NULL;",
          "4081:   if (!strnicmp(inName, \"http://\", 7) || !strnicmp(inName, \"https://\", 8)) {",
          "4082: #if !defined(GPAC_DISABLE_CORE_TOOLS)",
          "4083:    e = gf_dm_wget(inName, \"tmp_main.m3u8\", 0, 0, &mpd_base_url);",
          "4084:    if (e != GF_OK) {",
          "4085:     fprintf(stderr, \"Cannot retrieve M3U8 (%s): %s\\n\", inName, gf_error_to_string(e));",
          "4086:     if (mpd_base_url) gf_free(mpd_base_url);",
          "4087:     return mp4box_cleanup(1);",
          "4088:    }",
          "4089:    remote = GF_TRUE;",
          "4090: #else",
          "4091:    gf_free(mpd_base_url);",
          "4092:    fprintf(stderr, \"HTTP Downloader disabled in this build\\n\");",
          "4093:    return mp4box_cleanup(1);",
          "4094: #endif",
          "4096:    if (outName)",
          "4097:     strcpy(outfile, outName);",
          "4098:    else {",
          "4099:     const char *sep = gf_file_basename(inName);",
          "4100:     char *ext = gf_file_ext_start(sep);",
          "4101:     if (ext) ext[0] = 0;",
          "4102:     sprintf(outfile, \"%s.mpd\", sep);",
          "4103:     if (ext) ext[0] = '.';",
          "4104:    }",
          "4105:   } else {",
          "4106:    if (outName)",
          "4107:     strcpy(outfile, outName);",
          "4108:    else {",
          "4109:     char *dst = strdup(inName);",
          "4110:     char *ext = strstr(dst, \".m3u8\");",
          "4111:     if (ext) ext[0] = 0;",
          "4112:     sprintf(outfile, \"%s.mpd\", dst);",
          "4113:     gf_free(dst);",
          "4114:    }",
          "4115:   }",
          "4117:   mpd = gf_mpd_new();",
          "4118:   if (!mpd) {",
          "4119:    e = GF_OUT_OF_MEM;",
          "4120:    fprintf(stderr, \"[DASH] Error: MPD creation problem %s\\n\", gf_error_to_string(e));",
          "4121:    mp4box_cleanup(1);",
          "4122:   }",
          "4123:   FILE *f = gf_fopen(remote ? \"tmp_main.m3u8\" : inName, \"r\");",
          "4124:   u32 manif_type = 0;",
          "4125:   if (f) {",
          "4126:    char szDATA[1000];",
          "4127:    s32 read;",
          "4128:    szDATA[999]=0;",
          "4129:    read = (s32) gf_fread(szDATA, 999, f);",
          "4130:    if (read<0) read = 0;",
          "4131:    szDATA[read]=0;",
          "4132:    gf_fclose(f);",
          "4133:    if (strstr(szDATA, \"SmoothStreamingMedia\"))",
          "4134:     manif_type = 2;",
          "4135:    else if (strstr(szDATA, \"#EXTM3U\"))",
          "4136:     manif_type = 1;",
          "4137:   }",
          "4139:   if (manif_type==1) {",
          "4140:    e = gf_m3u8_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd_base_url ? mpd_base_url : inName, outfile, 0, \"video/mp2t\", GF_TRUE, use_url_template, segment_timeline, NULL, mpd, GF_TRUE, GF_TRUE);",
          "4141:   } else if (manif_type==2) {",
          "4142:    e = gf_mpd_smooth_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd, mpd_base_url ? mpd_base_url : inName);",
          "4143:   } else {",
          "4144:    e = GF_NOT_SUPPORTED;",
          "4145:   }",
          "4146:   if (!e)",
          "4147:    gf_mpd_write_file(mpd, outfile);",
          "4149:   if (mpd)",
          "4150:    gf_mpd_del(mpd);",
          "4151:   if (mpd_base_url)",
          "4152:    gf_free(mpd_base_url);",
          "4154:   if (remote) {",
          "4155:    gf_file_delete(\"tmp_main.m3u8\");",
          "4156:   }",
          "4157:   if (e != GF_OK) {",
          "4158:    fprintf(stderr, \"Error converting %s (%s) to MPD (%s): %s\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile, gf_error_to_string(e));",
          "4159:    return mp4box_cleanup(1);",
          "4160:   } else {",
          "4161:    fprintf(stderr, \"Done converting %s (%s) to MPD (%s)\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile);",
          "4162:    return mp4box_cleanup(0);",
          "4163:   }",
          "4165: #endif",
          "4166:  if (dash_duration && !nb_dash_inputs) {",
          "4167:   dash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);",
          "4171:  if (do_saf && !encode) {",
          "4172:   switch (get_file_type_by_ext(inName)) {",
          "4173:   case GF_FILE_TYPE_BT_WRL_X3DV:",
          "4174:   case GF_FILE_TYPE_XMT_X3D:",
          "4175:   case GF_FILE_TYPE_SVG:",
          "4176:    encode = GF_TRUE;",
          "4177:    break;",
          "4178:   case GF_FILE_TYPE_NOT_SUPPORTED:",
          "4179:   case GF_FILE_TYPE_ISO_MEDIA:",
          "4180:   case GF_FILE_TYPE_SWF:",
          "4181:   case GF_FILE_TYPE_LSR_SAF:",
          "4182:    break;",
          "4183:   }",
          "4186: #ifndef GPAC_DISABLE_SCENE_DUMP",
          "4187:  if (dump_mode == GF_SM_DUMP_SVG) {",
          "4188:   if (strstr(inName, \".srt\") || strstr(inName, \".ttxt\")) import_subtitle = 2;",
          "4190: #endif",
          "4193:  if (import_subtitle && !trackID) {",
          "4195:      i.e. we parse it and store the content as samples of a 3GPP Timed Text track in an ISO file,",
          "4197: #ifndef GPAC_DISABLE_MEDIA_IMPORT",
          "4198:   GF_MediaImporter import;",
          "4200:   file = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);",
          "4201:   if (timescale && file) gf_isom_set_timescale(file, timescale);",
          "4203:   memset(&import, 0, sizeof(GF_MediaImporter));",
          "4204:   import.dest = file;",
          "4205:   import.in_name = inName;",
          "4207:   e = gf_media_import(&import);",
          "4208:   if (e) {",
          "4209:    fprintf(stderr, \"Error importing %s: %s\\n\", inName, gf_error_to_string(e));",
          "4210:    gf_isom_delete(file);",
          "4211:    gf_file_delete(\"ttxt_convert\");",
          "4212:    return mp4box_cleanup(1);",
          "4213:   }",
          "4215:   strcpy(outfile, inName);",
          "4216:   if (strchr(outfile, '.')) {",
          "4217:    while (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;",
          "4218:    outfile[strlen(outfile)-1] = 0;",
          "4219:   }",
          "4220: #ifndef GPAC_DISABLE_ISOM_DUMP",
          "4222:   dump_isom_timed_text(file, gf_isom_get_track_id(file, 1),",
          "4223:          dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,",
          "4224:                         GF_TRUE,",
          "4225:                         (import_subtitle==2) ? GF_TEXTDUMPTYPE_SVG : (dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT));",
          "4226: #endif",
          "4228:   gf_isom_delete(file);",
          "4229:   gf_file_delete(\"ttxt_convert\");",
          "4231:    fprintf(stderr, \"Error converting %s: %s\\n\", inName, gf_error_to_string(e));",
          "4232:    return mp4box_cleanup(1);",
          "4233:   }",
          "4234:   return mp4box_cleanup(0);",
          "4235: #else",
          "4236:   fprintf(stderr, \"Feature not supported\\n\");",
          "4237:   return mp4box_cleanup(1);",
          "4238: #endif",
          "4241: #if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)",
          "4242:  if (nb_add || nb_cat) {",
          "4243:   u32 ipass, nb_pass = 1;",
          "4244:   char *mux_args=NULL;",
          "4245:   GF_FilterSession *fs = NULL;",
          "4246:   if (nb_add) {",
          "4248:    GF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT;",
          "4249:    if (force_new) {",
          "4250:     open_mode = (do_flat || (force_new==2)) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "4251:    } else {",
          "4252:     FILE *test = gf_fopen(inName, \"rb\");",
          "4253:     if (!test) {",
          "4254:      open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "4255:      if (!outName) outName = inName;",
          "4256:     } else {",
          "4257:      gf_fclose(test);",
          "4258:      if (! gf_isom_probe_file(inName) ) {",
          "4259:       open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "4260:       if (!outName) outName = inName;",
          "4261:      }",
          "4262:     }",
          "4263:    }",
          "4264:    open_edit = do_flat ? GF_FALSE : GF_TRUE;",
          "4265:    file = gf_isom_open(inName, open_mode, tmpdir);",
          "4266:    if (!file) {",
          "4267:     fprintf(stderr, \"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) );",
          "4268:     return mp4box_cleanup(1);",
          "4269:    }",
          "4271:    if (freeze_box_order)",
          "4272:     gf_isom_freeze_order(file);",
          "4275:   if (file && keep_utc && open_edit) {",
          "4276:    gf_isom_keep_utc_times(file, 1);",
          "4279:   if (do_flat && interleaving_time) {",
          "4280:    char szSubArg[100];",
          "4281:    gf_isom_set_storage_mode(file, GF_ISOM_STORE_FASTSTART);",
          "4282:    do_flat = 2;",
          "4283:    nb_pass = 2;",
          "4284:    fs = gf_fs_new_defaults(0);",
          "4285:    if (!fs) {",
          "4286:     fprintf(stderr, \"Error creating filter session\\n\");",
          "4287:     gf_isom_delete(file);",
          "4288:     return mp4box_cleanup(1);",
          "4289:    }",
          "4292:    gf_dynstrcat(&mux_args, \"mp4mx:importer:store=fstart\", \":\");",
          "4294:    sprintf(szSubArg, \"file=%p\", file);",
          "4295:    gf_dynstrcat(&mux_args, szSubArg, \":\");",
          "4296:    sprintf(szSubArg, \"cdur=%g\", interleaving_time);",
          "4297:    gf_dynstrcat(&mux_args, szSubArg, \":\");",
          "4300:   for (ipass=0; ipass<nb_pass; ipass++) {",
          "4301:    u32 tk_idx = 1;",
          "4302:    for (i=0; i<(u32) argc; i++) {",
          "4303:     char *margs=NULL;",
          "4304:     if (!strcmp(argv[i], \"-add\")) {",
          "4305:      char *src = argv[i+1];",
          "4307:      while (src) {",
          "4308:       char *loc_src = src;",
          "4309:       char *sep = NULL;",
          "4310:       while (1) {",
          "4311:        char *opt_sep;",
          "4312:        sep = strchr(loc_src, '+');",
          "4313:        if (!sep) break;",
          "4315:        sep[0] = 0;",
          "4316:        if (strstr(src, \"://\"))",
          "4317:         break;",
          "4319:        opt_sep = gf_url_colon_suffix(src);",
          "4320:        if (opt_sep)",
          "4321:         opt_sep[0] = 0;",
          "4322:        if (gf_file_exists(src)) {",
          "4323:         if (opt_sep)",
          "4324:          opt_sep[0] = ':';",
          "4325:         break;",
          "4326:        }",
          "4327:        if (opt_sep)",
          "4328:         opt_sep[0] = ':';",
          "4330:        sep[0] = '+';",
          "4331:        loc_src = sep+1;",
          "4332:       }",
          "4334:       e = import_file(file, src, import_flags, import_fps, agg_samples, fs, (fs && (ipass==0)) ? &margs : NULL, tk_idx);",
          "4335:       tk_idx++;",
          "4337:       if (margs) {",
          "4338:        gf_dynstrcat(&mux_args, margs, \":\");",
          "4339:        gf_free(margs);",
          "4340:       }",
          "4342:       if (e) {",
          "4343:        fprintf(stderr, \"Error importing %s: %s\\n\", argv[i+1], gf_error_to_string(e));",
          "4344:        gf_isom_delete(file);",
          "4345:        if (fs)",
          "4346:         gf_fs_del(fs);",
          "4347:        return mp4box_cleanup(1);",
          "4348:       }",
          "4349:       if (sep) {",
          "4350:        sep[0] = '+';",
          "4351:        src = sep+1;",
          "4352:       } else {",
          "4353:        break;",
          "4354:       }",
          "4355:      }",
          "4356:      i++;",
          "4357:     } else if (!strcmp(argv[i], \"-cat\") || !strcmp(argv[i], \"-catx\") || !strcmp(argv[i], \"-catpl\")) {",
          "4358:      if (nb_pass == 2) {",
          "4359:       fprintf(stderr, \"Cannot cat files when using -newfs mode\\n\");",
          "4360:       return mp4box_cleanup(1);",
          "4362:      if (!file) {",
          "4363:       u8 open_mode = GF_ISOM_OPEN_EDIT;",
          "4364:       if (force_new) {",
          "4365:        open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "4366:       } else {",
          "4367:        FILE *test = gf_fopen(inName, \"rb\");",
          "4368:        if (!test) {",
          "4369:         open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "4370:         if (!outName) outName = inName;",
          "4371:        }",
          "4372:        else gf_fclose(test);",
          "4373:       }",
          "4375:       open_edit = GF_TRUE;",
          "4376:       file = gf_isom_open(inName, open_mode, tmpdir);",
          "4377:       if (!file) {",
          "4378:        fprintf(stderr, \"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) );",
          "4379:        return mp4box_cleanup(1);",
          "4380:       }",
          "4383:      e = cat_isomedia_file(file, argv[i+1], import_flags, import_fps, agg_samples, tmpdir, force_cat, align_cat, !strcmp(argv[i], \"-catx\") ? GF_TRUE : GF_FALSE, !strcmp(argv[i], \"-catpl\") ? GF_TRUE : GF_FALSE);",
          "4384:      if (e) {",
          "4385:       fprintf(stderr, \"Error appending %s: %s\\n\", argv[i+1], gf_error_to_string(e));",
          "4386:       gf_isom_delete(file);",
          "4387:       return mp4box_cleanup(1);",
          "4389:      i++;",
          "4390:     }",
          "4391:    }",
          "4392:    if ((nb_pass == 2) && !ipass) {",
          "4393:     GF_Filter *mux_filter = gf_fs_load_filter(fs, mux_args, NULL);",
          "4394:     gf_free(mux_args);",
          "4395:     if (!mux_filter) {",
          "4396:      fprintf(stderr, \"Error loadin isobmff mux filter\\n\");",
          "4397:      gf_isom_delete(file);",
          "4398:      gf_fs_del(fs);",
          "4399:      return mp4box_cleanup(1);",
          "4402:     e = gf_fs_run(fs);",
          "4403:     if (e==GF_EOS) e = GF_OK;",
          "4405:     if (!e) e = gf_fs_get_last_connect_error(fs);",
          "4406:     if (!e) e = gf_fs_get_last_process_error(fs);",
          "4408:     if (e) {",
          "4409:      fprintf(stderr, \"Error importing sources: %s\\n\", gf_error_to_string(e));",
          "4410:      gf_isom_delete(file);",
          "4411:      gf_fs_del(fs);",
          "4412:      return mp4box_cleanup(1);",
          "4416:   if (fs) {",
          "4417:    gf_fs_print_non_connected(fs);",
          "4418:    if (fs_dump_flags & 1) gf_fs_print_stats(fs);",
          "4419:    if (fs_dump_flags & 2) gf_fs_print_connections(fs);",
          "4420:    gf_fs_del(fs);",
          "4421:   }",
          "4424: #ifndef GPAC_DISABLE_AV_PARSERS",
          "4425:   if (!keep_sys_tracks) remove_systems_tracks(file);",
          "4426: #endif",
          "4427:   do_save = GF_TRUE;",
          "4428:  }",
          "4431: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "4432:  else if (chunk_mode) {",
          "4433:   if (!inName) {",
          "4434:    fprintf(stderr, \"chunk encoding syntax: [-outctx outDump] -inctx inScene auFile\\n\");",
          "4435:    return mp4box_cleanup(1);",
          "4436:   }",
          "4437:   e = EncodeFileChunk(inName, outName ? outName : inName, input_ctx, output_ctx, tmpdir);",
          "4438:   if (e) {",
          "4439:    fprintf(stderr, \"Error encoding chunk file %s\\n\", gf_error_to_string(e));",
          "4440:    return mp4box_cleanup(1);",
          "4441:   }",
          "4442:   goto exit;",
          "4443:  }",
          "4444: #endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "4445:  else if (encode) {",
          "4446: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "4447:   FILE *logs = NULL;",
          "4448:   if (do_scene_log) {",
          "4449:    char alogfile[GF_MAX_PATH];",
          "4450:    strcpy(alogfile, inName);",
          "4451:    if (strchr(alogfile, '.')) {",
          "4452:     while (alogfile[strlen(alogfile)-1] != '.') alogfile[strlen(alogfile)-1] = 0;",
          "4453:     alogfile[strlen(alogfile)-1] = 0;",
          "4454:    }",
          "4455:    strcat(alogfile, \"_enc.logs\");",
          "4456:    logs = gf_fopen(alogfile, \"wt\");",
          "4457:   }",
          "4458:   strcpy(outfile, outName ? outName : inName);",
          "4459:   if (strchr(outfile, '.')) {",
          "4460:    while (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;",
          "4461:    outfile[strlen(outfile)-1] = 0;",
          "4462:   }",
          "4463:   strcat(outfile, \".mp4\");",
          "4464:   file = gf_isom_open(outfile, GF_ISOM_WRITE_EDIT, tmpdir);",
          "4465:   smenc_opts.mediaSource = mediaSource ? mediaSource : outfile;",
          "4466:   e = EncodeFile(inName, file, &smenc_opts, logs);",
          "4467:   if (logs) gf_fclose(logs);",
          "4468:   if (e) goto err_exit;",
          "4469:   do_save = GF_TRUE;",
          "4470:   if (do_saf) {",
          "4471:    do_save = GF_FALSE;",
          "4472:    open_edit = GF_FALSE;",
          "4473:   }",
          "4474: #endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "4475:  }",
          "4477: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "4478:  else if (pack_file) {",
          "4479:   char *fileName = gf_url_colon_suffix(pack_file);",
          "4480:   if (fileName && ((fileName - pack_file)==4)) {",
          "4481:    fileName[0] = 0;",
          "4482:    file = package_file(fileName + 1, pack_file, tmpdir, pack_wgt);",
          "4483:    fileName[0] = ':';",
          "4484:   } else {",
          "4485:    file = package_file(pack_file, NULL, tmpdir, pack_wgt);",
          "4486:    if (!file) {",
          "4487:     fprintf(stderr, \"Failed to package file\\n\");",
          "4488:     return mp4box_cleanup(1);",
          "4489:    }",
          "4491:   if (!outName) outName = inName;",
          "4492:   do_save = GF_TRUE;",
          "4493:   open_edit = GF_TRUE;",
          "4495: #endif //GPAC_DISABLE_ISOM_WRITE",
          "4497:  if (dash_duration) {",
          "4498:   Bool del_file = GF_FALSE;",
          "4499:   char szMPD[GF_MAX_PATH], *sep;",
          "4500:   char szStateFile[GF_MAX_PATH];",
          "4501:   Bool dyn_state_file = GF_FALSE;",
          "4502:   u32 do_abort = 0;",
          "4503:   GF_DASHSegmenter *dasher=NULL;",
          "4505:   if (crypt) {",
          "4506:    fprintf(stderr, \"MP4Box cannot crypt and DASH on the same pass. Please encrypt your content first.\\n\");",
          "4507:    return mp4box_cleanup(1);",
          "4508:   }",
          "4510:   strcpy(outfile, outName ? outName : gf_url_get_resource_name(inName) );",
          "4511:   sep = strrchr(outfile, '.');",
          "4512:   if (sep) sep[0] = 0;",
          "4513:   if (!outName) strcat(outfile, \"_dash\");",
          "4514:   strcpy(szMPD, outfile);",
          "4515:   if (outName && sep) {",
          "4516:    sep[0] = '.';",
          "4517:    strcat(szMPD, sep);",
          "4518:   } else {",
          "4519:    strcat(szMPD, \".mpd\");",
          "4520:   }",
          "4522:   if ((dash_subduration>0) && (dash_duration > dash_subduration)) {",
          "4523:    fprintf(stderr, \"Warning: -subdur parameter (%g s) should be greater than segment duration (%g s), using segment duration instead\\n\", dash_subduration, dash_duration);",
          "4524:    dash_subduration = dash_duration;",
          "4525:   }",
          "4527:   if (dash_mode && dash_live)",
          "4528:    fprintf(stderr, \"Live DASH-ing - press 'q' to quit, 's' to save context and quit\\n\");",
          "4530:   if (!dash_ctx_file && dash_live) {",
          "4531:    u32 r1;",
          "4532:    u64 add = (u64) (intptr_t) &dasher;",
          "4533:    add ^= gf_net_get_utc();",
          "4534:    r1 = (u32) add ^ (u32) (add/0xFFFFFFFF);",
          "4535:    r1 ^= gf_rand();",
          "4536:     sprintf(szStateFile, \"%s/dasher_%X.xml\", gf_get_default_cache_directory(), r1 );",
          "4537:    dash_ctx_file = szStateFile;",
          "4538:    dyn_state_file = GF_TRUE;",
          "4539:   } else if (dash_ctx_file) {",
          "4540:    if (force_new)",
          "4541:     gf_file_delete(dash_ctx_file);",
          "4542:   }",
          "4544:   if (dash_profile==GF_DASH_PROFILE_AUTO)",
          "4545:    dash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL;",
          "4547:   if (!dash_mode) {",
          "4548:    time_shift_depth = 0;",
          "4549:    mpd_update_time = 0;",
          "4550:   } else if ((dash_profile>=GF_DASH_PROFILE_MAIN) && !use_url_template && !mpd_update_time) {",
          "4552:    mpd_update_time = (Double) (dash_subduration ? dash_subduration : dash_duration);",
          "4553:    fprintf(stderr, \"Using default MPD refresh of %g seconds\\n\", mpd_update_time);",
          "4554:   }",
          "4556:   if (file && do_save) {",
          "4557:    gf_isom_close(file);",
          "4558:    file = NULL;",
          "4559:    del_file = GF_TRUE;",
          "4563:   dasher = gf_dasher_new(szMPD, dash_profile, tmpdir, dash_scale, dash_ctx_file);",
          "4564:   if (!dasher) {",
          "4565:    return mp4box_cleanup(1);",
          "4566:   }",
          "4567:   e = gf_dasher_set_info(dasher, dash_title, cprt, dash_more_info, dash_source, NULL);",
          "4568:   if (e) {",
          "4569:    fprintf(stderr, \"DASH Error: %s\\n\", gf_error_to_string(e));",
          "4570:    gf_dasher_del(dasher);",
          "4571:    return mp4box_cleanup(1);",
          "4572:   }",
          "4574:   gf_dasher_set_start_date(dasher, dash_start_date);",
          "4575:   gf_dasher_set_location(dasher, dash_source);",
          "4576:   for (i=0; i < nb_mpd_base_urls; i++) {",
          "4577:    e = gf_dasher_add_base_url(dasher, mpd_base_urls[i]);",
          "4578:    if (e) {",
          "4579:     fprintf(stderr, \"DASH Error: %s\\n\", gf_error_to_string(e));",
          "4580:     gf_dasher_del(dasher);",
          "4581:     return mp4box_cleanup(1);",
          "4585:   if (segment_timeline && !use_url_template) {",
          "4586:    fprintf(stderr, \"DASH Warning: using -segment-timeline with no -url-template. Forcing URL template.\\n\");",
          "4587:    use_url_template = GF_TRUE;",
          "4588:   }",
          "4590:   e = gf_dasher_enable_url_template(dasher, (Bool) use_url_template, seg_name, seg_ext, init_seg_ext);",
          "4591:   if (!e) e = gf_dasher_enable_segment_timeline(dasher, segment_timeline);",
          "4592:   if (!e) e = gf_dasher_enable_single_segment(dasher, single_segment);",
          "4593:   if (!e) e = gf_dasher_enable_single_file(dasher, single_file);",
          "4594:   if (!e) e = gf_dasher_set_switch_mode(dasher, bitstream_switching_mode);",
          "4595:   if (!e) e = gf_dasher_set_durations(dasher, dash_duration, interleaving_time, dash_subduration);",
          "4596:   if (!e) e = gf_dasher_enable_rap_splitting(dasher, seg_at_rap, frag_at_rap);",
          "4597:   if (!e) e = gf_dasher_set_segment_marker(dasher, segment_marker);",
          "4598:   if (!e) e = gf_dasher_enable_sidx(dasher, (subsegs_per_sidx>=0) ? 1 : 0, (u32) subsegs_per_sidx, daisy_chain_sidx, use_ssix);",
          "4599:   if (!e) e = gf_dasher_set_dynamic_mode(dasher, dash_mode, mpd_update_time, time_shift_depth, mpd_live_duration);",
          "4600:   if (!e) e = gf_dasher_set_min_buffer(dasher, min_buffer);",
          "4601:   if (!e) e = gf_dasher_set_ast_offset(dasher, ast_offset_ms);",
          "4602:   if (!e) e = gf_dasher_enable_memory_fragmenting(dasher, memory_frags);",
          "4603:   if (!e) e = gf_dasher_set_initial_isobmf(dasher, initial_moof_sn, initial_tfdt);",
          "4604:   if (!e) e = gf_dasher_configure_isobmf_default(dasher, no_fragments_defaults, pssh_mode, samplegroups_in_traf, single_traf_per_moof, tfdt_per_traf, mvex_after_traks, sdtp_in_traf);",
          "4605:   if (!e) e = gf_dasher_enable_utc_ref(dasher, insert_utc);",
          "4606:   if (!e) e = gf_dasher_enable_real_time(dasher, frag_real_time);",
          "4607:   if (!e) e = gf_dasher_set_content_protection_location_mode(dasher, cp_location_mode);",
          "4608:   if (!e) e = gf_dasher_set_profile_extension(dasher, dash_profile_extension);",
          "4609:   if (!e) e = gf_dasher_enable_cached_inputs(dasher, no_cache);",
          "4610:   if (!e) e = gf_dasher_enable_loop_inputs(dasher, ! no_loop);",
          "4611:   if (!e) e = gf_dasher_set_split_mode(dasher, dash_split_mode);",
          "4612:   if (!e) e = gf_dasher_set_last_segment_merge(dasher, merge_last_seg);",
          "4613:   if (!e) e = gf_dasher_set_hls_clock(dasher, hls_clock);",
          "4614:   if (!e && dash_cues) e = gf_dasher_set_cues(dasher, dash_cues, strict_cues);",
          "4615:   if (!e) e = gf_dasher_print_session_info(dasher, fs_dump_flags);",
          "4616:   if (!e)  e = gf_dasher_keep_source_utc(dasher, keep_utc);",
          "4618:   for (i=0; i < nb_dash_inputs; i++) {",
          "4619:    if (!e) e = gf_dasher_add_input(dasher, &dash_inputs[i]);",
          "4621:   if (e) {",
          "4622:    fprintf(stderr, \"DASH Setup Error: %s\\n\", gf_error_to_string(e));",
          "4623:    gf_dasher_del(dasher);",
          "4624:    return mp4box_cleanup(1);",
          "4627:   dash_cumulated_time=0;",
          "4629:   while (1) {",
          "4630:    if (run_for && (dash_cumulated_time >= run_for)) {",
          "4631:     fprintf(stderr, \"Done running, computing static MPD\\n\");",
          "4632:     do_abort = 3;",
          "4633:    }",
          "4635:    dash_prev_time=gf_sys_clock();",
          "4636:    if (do_abort>=2) {",
          "4637:     e = gf_dasher_set_dynamic_mode(dasher, GF_DASH_DYNAMIC_LAST, 0, time_shift_depth, mpd_live_duration);",
          "4640:    if (!e) e = gf_dasher_process(dasher);",
          "4641:    if (!dash_live && (e==GF_EOS) ) {",
          "4642:     fprintf(stderr, \"Nothing to dash, too early ...\\n\");",
          "4644:    }",
          "4646:    if (do_abort)",
          "4647:     break;",
          "4650:    if (dash_live && (e==GF_IO_ERR) ) {",
          "4651:     fprintf(stderr, \"Error dashing file (%s) but continuing ...\\n\", gf_error_to_string(e) );",
          "4655:    if (e) break;",
          "4657:    if (dash_live) {",
          "4658:     u64 ms_in_session=0;",
          "4659:     u32 slept = gf_sys_clock();",
          "4660:     u32 sleep_for = gf_dasher_next_update_time(dasher, &ms_in_session);",
          "4661:     fprintf(stderr, \"Next generation scheduled in %u ms (DASH time \"LLU\" ms)\\r\", sleep_for, ms_in_session);",
          "4662:     if (run_for && (ms_in_session>=run_for)) {",
          "4663:      dash_cumulated_time = 1+run_for;",
          "4664:      continue;",
          "4667:     while (1) {",
          "4668:      if (gf_prompt_has_input()) {",
          "4669:       char c = (char) gf_prompt_get_char();",
          "4670:       if (c=='X') {",
          "4671:        do_abort = 1;",
          "4672:        break;",
          "4674:       if (c=='q') {",
          "4675:        do_abort = 2;",
          "4676:        break;",
          "4678:       if (c=='s') {",
          "4679:        do_abort = 3;",
          "4680:        break;",
          "4684:      if (dash_mode == GF_DASH_DYNAMIC_DEBUG) {",
          "4685:       break;",
          "4687:      if (!sleep_for) break;",
          "4689:      gf_sleep(sleep_for/10);",
          "4690:      sleep_for = gf_dasher_next_update_time(dasher, NULL);",
          "4691:      if (sleep_for<=1) {",
          "4692:       dash_now_time=gf_sys_clock();",
          "4693:       dash_cumulated_time+=(dash_now_time-dash_prev_time);",
          "4694:       fprintf(stderr, \"Slept for %d ms before generation, dash cumulated time %d\\n\", dash_now_time - slept, dash_cumulated_time);",
          "4695:       break;",
          "4698:    } else {",
          "4699:     break;",
          "4703:   gf_dasher_del(dasher);",
          "4705:   if (!run_for && dash_ctx_file && (do_abort==3) && (dyn_state_file) && !gf_sys_is_test_mode() ) {",
          "4706:    char szName[1024];",
          "4707:    fprintf(stderr, \"Enter file name to save dash context:\\n\");",
          "4708:    if (scanf(\"%1023s\", szName) == 1) {",
          "4709:     gf_file_move(dash_ctx_file, szName);",
          "4712:   if (e) fprintf(stderr, \"Error DASHing file: %s\\n\", gf_error_to_string(e));",
          "4713:   if (file) gf_isom_delete(file);",
          "4714:   if (del_file)",
          "4715:    gf_file_delete(inName);",
          "4721:  else if (!file && !do_hash",
          "",
          "[Added Lines]",
          "3767: static u32 do_raw_cat()",
          "3768: {",
          "3769:  char chunk[4096];",
          "3770:  FILE *fin, *fout;",
          "3771:  s64 to_copy, done;",
          "3772:  fin = gf_fopen(raw_cat, \"rb\");",
          "3773:  if (!fin) return mp4box_cleanup(1);",
          "3775:  fout = gf_fopen(inName, \"a+b\");",
          "3776:  if (!fout) {",
          "3777:   gf_fclose(fin);",
          "3778:   return mp4box_cleanup(1);",
          "3780:  gf_fseek(fin, 0, SEEK_END);",
          "3781:  to_copy = gf_ftell(fin);",
          "3782:  gf_fseek(fin, 0, SEEK_SET);",
          "3783:  done = 0;",
          "3784:  while (1) {",
          "3785:   u32 nb_bytes = (u32) gf_fread(chunk, 4096, fin);",
          "3786:   gf_fwrite(chunk, nb_bytes, fout);",
          "3787:   done += nb_bytes;",
          "3788:   fprintf(stderr, \"Appending file %s - %02.2f done\\r\", raw_cat, 100.0*done/to_copy);",
          "3789:   if (done >= to_copy) break;",
          "3790:  }",
          "3791:  gf_fclose(fin);",
          "3792:  gf_fclose(fout);",
          "3793:  return mp4box_cleanup(0);",
          "3794: }",
          "3796: static u32 do_write_udp()",
          "3797: {",
          "3798:  GF_Err e;",
          "3799:  GF_Socket *sock = gf_sk_new(GF_SOCK_TYPE_UDP);",
          "3800:  u16 port = 2345;",
          "3801:  char *sep = strrchr(udp_dest, ':');",
          "3802:  if (sep) {",
          "3803:   sep[0] = 0;",
          "3804:   port = atoi(sep+1);",
          "3806:  e = gf_sk_bind( sock, \"127.0.0.1\", 0, udp_dest, port, 0);",
          "3807:  if (sep) sep[0] = ':';",
          "3808:  if (e) {",
          "3809:   M4_LOG(GF_LOG_ERROR, (\"Failed to bind socket to %s: %s\\n\", udp_dest, gf_error_to_string(e) ));",
          "3810:  } else {",
          "3811:   e = gf_sk_send(sock, (u8 *) inName, (u32)strlen(inName));",
          "3812:   if (e)",
          "3813:    M4_LOG(GF_LOG_ERROR, (\"Failed to send datagram: %s\\n\", gf_error_to_string(e) ));",
          "3815:  gf_sk_del(sock);",
          "3816:  return 0;",
          "3817: }",
          "3819: #ifndef GPAC_DISABLE_MPD",
          "3820: static u32 convert_mpd()",
          "3821: {",
          "3822:  GF_Err e;",
          "3823:  Bool remote = GF_FALSE;",
          "3824:  GF_MPD *mpd;",
          "3825:  char *mpd_base_url = NULL;",
          "3826:  if (!strnicmp(inName, \"http://\", 7) || !strnicmp(inName, \"https://\", 8)) {",
          "3827: #if !defined(GPAC_DISABLE_CORE_TOOLS)",
          "3828:   e = gf_dm_wget(inName, \"tmp_main.m3u8\", 0, 0, &mpd_base_url);",
          "3829:   if (e != GF_OK) {",
          "3830:    M4_LOG(GF_LOG_ERROR, (\"Cannot retrieve M3U8 (%s): %s\\n\", inName, gf_error_to_string(e)));",
          "3831:    if (mpd_base_url) gf_free(mpd_base_url);",
          "3832:    return mp4box_cleanup(1);",
          "3834:   remote = GF_TRUE;",
          "3835: #else",
          "3836:   gf_free(mpd_base_url);",
          "3837:   M4_LOG(GF_LOG_ERROR, (\"HTTP Downloader disabled in this build\\n\"));",
          "3838:   return mp4box_cleanup(1);",
          "3839: #endif",
          "3841:   if (outName)",
          "3842:    strcpy(outfile, outName);",
          "3843:   else {",
          "3844:    const char *sep = gf_file_basename(inName);",
          "3845:    char *ext = gf_file_ext_start(sep);",
          "3846:    if (ext) ext[0] = 0;",
          "3847:    sprintf(outfile, \"%s.mpd\", sep);",
          "3848:    if (ext) ext[0] = '.';",
          "3850:  } else {",
          "3851:   if (outName)",
          "3852:    strcpy(outfile, outName);",
          "3853:   else {",
          "3854:    char *dst = strdup(inName);",
          "3855:    char *ext = strstr(dst, \".m3u8\");",
          "3856:    if (ext) ext[0] = 0;",
          "3857:    sprintf(outfile, \"%s.mpd\", dst);",
          "3858:    gf_free(dst);",
          "3859:   }",
          "3860:  }",
          "3862:  mpd = gf_mpd_new();",
          "3863:  if (!mpd) {",
          "3864:   e = GF_OUT_OF_MEM;",
          "3865:   M4_LOG(GF_LOG_ERROR, (\"[DASH] Error: MPD creation problem %s\\n\", gf_error_to_string(e)));",
          "3866:   mp4box_cleanup(1);",
          "3867:  }",
          "3868:  FILE *f = gf_fopen(remote ? \"tmp_main.m3u8\" : inName, \"r\");",
          "3869:  u32 manif_type = 0;",
          "3870:  if (f) {",
          "3871:   char szDATA[1000];",
          "3872:   s32 read;",
          "3873:   szDATA[999]=0;",
          "3874:   read = (s32) gf_fread(szDATA, 999, f);",
          "3875:   if (read<0) read = 0;",
          "3876:   szDATA[read]=0;",
          "3877:   gf_fclose(f);",
          "3878:   if (strstr(szDATA, \"SmoothStreamingMedia\"))",
          "3879:    manif_type = 2;",
          "3880:   else if (strstr(szDATA, \"#EXTM3U\"))",
          "3881:    manif_type = 1;",
          "3882:  }",
          "3884:  if (manif_type==1) {",
          "3885:   e = gf_m3u8_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd_base_url ? mpd_base_url : inName, outfile, 0, \"video/mp2t\", GF_TRUE, use_url_template, segment_timeline, NULL, mpd, GF_TRUE, GF_TRUE);",
          "3886:  } else if (manif_type==2) {",
          "3887:   e = gf_mpd_smooth_to_mpd(remote ? \"tmp_main.m3u8\" : inName, mpd, mpd_base_url ? mpd_base_url : inName);",
          "3888:  } else {",
          "3889:   e = GF_NOT_SUPPORTED;",
          "3891:  if (!e)",
          "3892:   gf_mpd_write_file(mpd, outfile);",
          "3894:  if (mpd)",
          "3895:   gf_mpd_del(mpd);",
          "3896:  if (mpd_base_url)",
          "3897:   gf_free(mpd_base_url);",
          "3899:  if (remote) {",
          "3900:   gf_file_delete(\"tmp_main.m3u8\");",
          "3901:  }",
          "3902:  if (e != GF_OK) {",
          "3903:   M4_LOG(GF_LOG_ERROR, (\"Error converting %s (%s) to MPD (%s): %s\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile, gf_error_to_string(e)));",
          "3904:   return mp4box_cleanup(1);",
          "3905:  } else {",
          "3906:   M4_LOG(GF_LOG_INFO, (\"Done converting %s (%s) to MPD (%s)\\n\", (manif_type==1) ? \"HLS\" : \"Smooth\",  inName, outfile));",
          "3907:   return mp4box_cleanup(0);",
          "3908:  }",
          "3909: }",
          "3910: #endif",
          "3912: static u32 do_import_sub()",
          "3914:  GF_Err e;",
          "3916:     i.e. we parse it and store the content as samples of a 3GPP Timed Text track in an ISO file,",
          "3918: #ifndef GPAC_DISABLE_MEDIA_IMPORT",
          "3919:  GF_MediaImporter import;",
          "3921:  file = gf_isom_open(\"ttxt_convert\", GF_ISOM_OPEN_WRITE, NULL);",
          "3922:  if (timescale && file) gf_isom_set_timescale(file, timescale);",
          "3924:  memset(&import, 0, sizeof(GF_MediaImporter));",
          "3925:  import.dest = file;",
          "3926:  import.in_name = inName;",
          "3928:  e = gf_media_import(&import);",
          "3929:  if (e) {",
          "3930:   M4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", inName, gf_error_to_string(e)));",
          "3931:   gf_isom_delete(file);",
          "3932:   gf_file_delete(\"ttxt_convert\");",
          "3933:   return mp4box_cleanup(1);",
          "3934:  }",
          "3936:  strcpy(outfile, inName);",
          "3937:  if (strchr(outfile, '.')) {",
          "3938:   while (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;",
          "3939:   outfile[strlen(outfile)-1] = 0;",
          "3940:  }",
          "3941: #ifndef GPAC_DISABLE_ISOM_DUMP",
          "3943:  dump_isom_timed_text(file, gf_isom_get_track_id(file, 1),",
          "3944:         dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE,",
          "3945:         GF_TRUE,",
          "3946:         (import_subtitle==2) ? GF_TEXTDUMPTYPE_SVG : (dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT));",
          "3949:  gf_isom_delete(file);",
          "3950:  gf_file_delete(\"ttxt_convert\");",
          "3951:  if (e) {",
          "3952:   M4_LOG(GF_LOG_ERROR, (\"Error converting %s: %s\\n\", inName, gf_error_to_string(e)));",
          "3953:   return mp4box_cleanup(1);",
          "3954:  }",
          "3955:  return mp4box_cleanup(0);",
          "3957:  M4_LOG(GF_LOG_ERROR, (\"Feature not supported\\n\"));",
          "3958:  return mp4box_cleanup(1);",
          "3960: }",
          "3962: #if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)",
          "3963: static u32 do_add_cat(int argc, char **argv)",
          "3964: {",
          "3965:  GF_Err e;",
          "3966:  u32 i, ipass, nb_pass = 1;",
          "3967:  char *mux_args=NULL;",
          "3968:  GF_FilterSession *fs = NULL;",
          "3969:  if (nb_add) {",
          "3971:   GF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT;",
          "3972:   if (force_new) {",
          "3973:    open_mode = (do_flat || (force_new==2)) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "3974:   } else {",
          "3975:    FILE *test = gf_fopen(inName, \"rb\");",
          "3976:    if (!test) {",
          "3977:     open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "3978:     if (!outName) outName = inName;",
          "3979:    } else {",
          "3980:     gf_fclose(test);",
          "3981:     if (! gf_isom_probe_file(inName) ) {",
          "3982:      open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "3983:      if (!outName) outName = inName;",
          "3984:     }",
          "3987:   open_edit = do_flat ? GF_FALSE : GF_TRUE;",
          "3988:   file = gf_isom_open(inName, open_mode, tmpdir);",
          "3989:   if (!file) {",
          "3990:    M4_LOG(GF_LOG_ERROR, (\"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));",
          "3991:    return mp4box_cleanup(1);",
          "3992:   }",
          "3994:   if (freeze_box_order)",
          "3995:    gf_isom_freeze_order(file);",
          "3996:  }",
          "3998:  if (file && keep_utc && open_edit) {",
          "3999:   gf_isom_keep_utc_times(file, 1);",
          "4002:  if (do_flat && interleaving_time) {",
          "4003:   char szSubArg[100];",
          "4004:   gf_isom_set_storage_mode(file, GF_ISOM_STORE_FASTSTART);",
          "4005:   do_flat = 2;",
          "4006:   nb_pass = 2;",
          "4007:   fs = gf_fs_new_defaults(0);",
          "4008:   if (!fs) {",
          "4009:    M4_LOG(GF_LOG_ERROR, (\"Error creating filter session\\n\"));",
          "4010:    gf_isom_delete(file);",
          "4011:    return mp4box_cleanup(1);",
          "4012:   }",
          "4015:   gf_dynstrcat(&mux_args, \"mp4mx:importer:store=fstart\", \":\");",
          "4017:   sprintf(szSubArg, \"file=%p\", file);",
          "4018:   gf_dynstrcat(&mux_args, szSubArg, \":\");",
          "4019:   sprintf(szSubArg, \"cdur=%g\", interleaving_time);",
          "4020:   gf_dynstrcat(&mux_args, szSubArg, \":\");",
          "4023:  for (ipass=0; ipass<nb_pass; ipass++) {",
          "4024:   u32 tk_idx = 1;",
          "4025:   for (i=0; i<(u32) argc; i++) {",
          "4026:    char *margs=NULL;",
          "4027:    if (!strcmp(argv[i], \"-add\")) {",
          "4028:     char *src = argv[i+1];",
          "4030:     while (src) {",
          "4031:      char *loc_src = src;",
          "4032:      char *sep = NULL;",
          "4033:      while (1) {",
          "4034:       char *opt_sep;",
          "4035:       sep = strchr(loc_src, '+');",
          "4036:       if (!sep) break;",
          "4038:       sep[0] = 0;",
          "4039:       if (strstr(src, \"://\"))",
          "4040:        break;",
          "4042:       opt_sep = gf_url_colon_suffix(src);",
          "4043:       if (opt_sep)",
          "4044:        opt_sep[0] = 0;",
          "4045:       if (gf_file_exists(src)) {",
          "4046:        if (opt_sep)",
          "4047:         opt_sep[0] = ':';",
          "4048:        break;",
          "4049:       }",
          "4050:       if (opt_sep)",
          "4051:        opt_sep[0] = ':';",
          "4053:       sep[0] = '+';",
          "4054:       loc_src = sep+1;",
          "4055:      }",
          "4057:      e = import_file(file, src, import_flags, import_fps, agg_samples, fs, (fs && (ipass==0)) ? &margs : NULL, tk_idx);",
          "4058:      tk_idx++;",
          "4060:      if (margs) {",
          "4061:       gf_dynstrcat(&mux_args, margs, \":\");",
          "4062:       gf_free(margs);",
          "4063:      }",
          "4065:      if (e) {",
          "4066:       M4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", argv[i+1], gf_error_to_string(e)));",
          "4067:       gf_isom_delete(file);",
          "4068:       if (fs)",
          "4069:        gf_fs_del(fs);",
          "4070:       return mp4box_cleanup(1);",
          "4071:      }",
          "4072:      if (sep) {",
          "4073:       sep[0] = '+';",
          "4074:       src = sep+1;",
          "4075:      } else {",
          "4076:       break;",
          "4077:      }",
          "4078:     }",
          "4079:     i++;",
          "4080:    } else if (!strcmp(argv[i], \"-cat\") || !strcmp(argv[i], \"-catx\") || !strcmp(argv[i], \"-catpl\")) {",
          "4081:     if (nb_pass == 2) {",
          "4082:      M4_LOG(GF_LOG_ERROR, (\"Cannot cat files when using -newfs mode\\n\"));",
          "4083:      return mp4box_cleanup(1);",
          "4084:     }",
          "4085:     if (!file) {",
          "4086:      u8 open_mode = GF_ISOM_OPEN_EDIT;",
          "4087:      if (force_new) {",
          "4088:       open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "4089:      } else {",
          "4090:       FILE *test = gf_fopen(inName, \"rb\");",
          "4091:       if (!test) {",
          "4092:        open_mode = (do_flat) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT;",
          "4093:        if (!outName) outName = inName;",
          "4094:       }",
          "4095:       else gf_fclose(test);",
          "4096:      }",
          "4098:      open_edit = GF_TRUE;",
          "4099:      file = gf_isom_open(inName, open_mode, tmpdir);",
          "4100:      if (!file) {",
          "4101:       M4_LOG(GF_LOG_ERROR, (\"Cannot open destination file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)) ));",
          "4102:       return mp4box_cleanup(1);",
          "4103:      }",
          "4104:     }",
          "4106:     e = cat_isomedia_file(file, argv[i+1], import_flags, import_fps, agg_samples, tmpdir, force_cat, align_cat, !strcmp(argv[i], \"-catx\") ? GF_TRUE : GF_FALSE, !strcmp(argv[i], \"-catpl\") ? GF_TRUE : GF_FALSE);",
          "4107:     if (e) {",
          "4108:      M4_LOG(GF_LOG_ERROR, (\"Error appending %s: %s\\n\", argv[i+1], gf_error_to_string(e)));",
          "4109:      gf_isom_delete(file);",
          "4110:      return mp4box_cleanup(1);",
          "4111:     }",
          "4112:     i++;",
          "4113:    }",
          "4114:   }",
          "4115:   if ((nb_pass == 2) && !ipass) {",
          "4116:    GF_Filter *mux_filter = gf_fs_load_filter(fs, mux_args, NULL);",
          "4117:    gf_free(mux_args);",
          "4118:    if (!mux_filter) {",
          "4119:     M4_LOG(GF_LOG_ERROR, (\"Error loadin isobmff mux filter\\n\"));",
          "4120:     gf_isom_delete(file);",
          "4121:     gf_fs_del(fs);",
          "4122:     return mp4box_cleanup(1);",
          "4123:    }",
          "4125:    e = gf_fs_run(fs);",
          "4126:    if (e==GF_EOS) e = GF_OK;",
          "4128:    if (!e) e = gf_fs_get_last_connect_error(fs);",
          "4129:    if (!e) e = gf_fs_get_last_process_error(fs);",
          "4131:    if (e) {",
          "4132:     M4_LOG(GF_LOG_ERROR, (\"Error importing sources: %s\\n\", gf_error_to_string(e)));",
          "4133:     gf_isom_delete(file);",
          "4134:     gf_fs_del(fs);",
          "4135:     return mp4box_cleanup(1);",
          "4136:    }",
          "4139:  if (fs) {",
          "4140:   gf_fs_print_non_connected(fs);",
          "4141:   if (fs_dump_flags & 1) gf_fs_print_stats(fs);",
          "4142:   if (fs_dump_flags & 2) gf_fs_print_connections(fs);",
          "4143:   gf_fs_del(fs);",
          "4147: #ifndef GPAC_DISABLE_AV_PARSERS",
          "4148:  if (!keep_sys_tracks) remove_systems_tracks(file);",
          "4150:  do_save = GF_TRUE;",
          "4152:  return 0;",
          "4153: }",
          "4157: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "4158: static GF_Err do_scene_encode()",
          "4159: {",
          "4160:  GF_Err e;",
          "4161:  FILE *logs = NULL;",
          "4162:  if (do_scene_log) {",
          "4163:   char alogfile[GF_MAX_PATH];",
          "4164:   strcpy(alogfile, inName);",
          "4165:   if (strchr(alogfile, '.')) {",
          "4166:    while (alogfile[strlen(alogfile)-1] != '.') alogfile[strlen(alogfile)-1] = 0;",
          "4167:    alogfile[strlen(alogfile)-1] = 0;",
          "4168:   }",
          "4169:   strcat(alogfile, \"_enc.logs\");",
          "4170:   logs = gf_fopen(alogfile, \"wt\");",
          "4171:  }",
          "4172:  strcpy(outfile, outName ? outName : inName);",
          "4173:  if (strchr(outfile, '.')) {",
          "4174:   while (outfile[strlen(outfile)-1] != '.') outfile[strlen(outfile)-1] = 0;",
          "4175:   outfile[strlen(outfile)-1] = 0;",
          "4176:  }",
          "4177:  strcat(outfile, \".mp4\");",
          "4178:  file = gf_isom_open(outfile, GF_ISOM_WRITE_EDIT, tmpdir);",
          "4179:  smenc_opts.mediaSource = mediaSource ? mediaSource : outfile;",
          "4180:  e = EncodeFile(inName, file, &smenc_opts, logs);",
          "4181:  if (logs) gf_fclose(logs);",
          "4182:  if (e) return e;",
          "4183:  do_save = GF_TRUE;",
          "4184:  if (do_saf) {",
          "4185:   do_save = GF_FALSE;",
          "4186:   open_edit = GF_FALSE;",
          "4188:  return GF_OK;",
          "4189: }",
          "4190: #endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "4193: static GF_Err do_dash()",
          "4194: {",
          "4195:  GF_Err e;",
          "4196:  u32 i;",
          "4197:  Bool del_file = GF_FALSE;",
          "4198:  char szMPD[GF_MAX_PATH], *sep;",
          "4199:  char szStateFile[GF_MAX_PATH];",
          "4200:  Bool dyn_state_file = GF_FALSE;",
          "4201:  u32 do_abort = 0;",
          "4202:  GF_DASHSegmenter *dasher=NULL;",
          "4204:  if (crypt) {",
          "4205:   M4_LOG(GF_LOG_ERROR, (\"MP4Box cannot use -crypt and -dash in the same pass. Please encrypt your content first, or specify encryption filters on dash sources.\\n\"));",
          "4206:   return GF_BAD_PARAM;",
          "4207:  }",
          "4209:  strcpy(outfile, outName ? outName : gf_url_get_resource_name(inName) );",
          "4210:  sep = strrchr(outfile, '.');",
          "4211:  if (sep) sep[0] = 0;",
          "4212:  if (!outName) strcat(outfile, \"_dash\");",
          "4213:  strcpy(szMPD, outfile);",
          "4214:  if (outName && sep) {",
          "4215:   sep[0] = '.';",
          "4216:   strcat(szMPD, sep);",
          "4217:  } else {",
          "4218:   strcat(szMPD, \".mpd\");",
          "4219:  }",
          "4221:  if ((dash_subduration>0) && (dash_duration > dash_subduration)) {",
          "4222:   M4_LOG(GF_LOG_WARNING, (\"Warning: -subdur parameter (%g s) should be greater than segment duration (%g s), using segment duration instead\\n\", dash_subduration, dash_duration));",
          "4223:   dash_subduration = dash_duration;",
          "4226:  if (dash_mode && dash_live)",
          "4227:   M4_LOG(GF_LOG_INFO, (\"Live DASH-ing - press 'q' to quit, 's' to save context and quit\\n\"));",
          "4229:  if (!dash_ctx_file && dash_live) {",
          "4230:   u32 r1;",
          "4231:   u64 add = (u64) (intptr_t) &dasher;",
          "4232:   add ^= gf_net_get_utc();",
          "4233:   r1 = (u32) add ^ (u32) (add/0xFFFFFFFF);",
          "4234:   r1 ^= gf_rand();",
          "4235:   sprintf(szStateFile, \"%s/dasher_%X.xml\", gf_get_default_cache_directory(), r1 );",
          "4236:   dash_ctx_file = szStateFile;",
          "4237:   dyn_state_file = GF_TRUE;",
          "4238:  } else if (dash_ctx_file) {",
          "4239:   if (force_new)",
          "4240:    gf_file_delete(dash_ctx_file);",
          "4243:  if (dash_profile==GF_DASH_PROFILE_AUTO)",
          "4244:   dash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL;",
          "4246:  if (!dash_mode) {",
          "4247:   time_shift_depth = 0;",
          "4248:   mpd_update_time = 0;",
          "4249:  } else if ((dash_profile>=GF_DASH_PROFILE_MAIN) && !use_url_template && !mpd_update_time) {",
          "4251:   mpd_update_time = (Double) (dash_subduration ? dash_subduration : dash_duration);",
          "4252:   M4_LOG(GF_LOG_INFO, (\"Using default MPD refresh of %g seconds\\n\", mpd_update_time));",
          "4255:  if (file && do_save) {",
          "4256:   gf_isom_close(file);",
          "4257:   file = NULL;",
          "4258:   del_file = GF_TRUE;",
          "4262:  dasher = gf_dasher_new(szMPD, dash_profile, tmpdir, dash_scale, dash_ctx_file);",
          "4263:  if (!dasher) {",
          "4264:   return mp4box_cleanup(1);",
          "4265:  }",
          "4266:  e = gf_dasher_set_info(dasher, dash_title, cprt, dash_more_info, dash_source, NULL);",
          "4267:  if (e) {",
          "4268:   M4_LOG(GF_LOG_ERROR, (\"DASH Error: %s\\n\", gf_error_to_string(e)));",
          "4269:   gf_dasher_del(dasher);",
          "4270:   return e;",
          "4271:  }",
          "4273:  gf_dasher_set_start_date(dasher, dash_start_date);",
          "4274:  gf_dasher_set_location(dasher, dash_source);",
          "4275:  for (i=0; i < nb_mpd_base_urls; i++) {",
          "4276:   e = gf_dasher_add_base_url(dasher, mpd_base_urls[i]);",
          "4278:    M4_LOG(GF_LOG_ERROR, (\"DASH Error: %s\\n\", gf_error_to_string(e)));",
          "4279:    gf_dasher_del(dasher);",
          "4280:    return e;",
          "4281:   }",
          "4282:  }",
          "4284:  if (segment_timeline && !use_url_template) {",
          "4285:   M4_LOG(GF_LOG_WARNING, (\"DASH Warning: using -segment-timeline with no -url-template. Forcing URL template.\\n\"));",
          "4286:   use_url_template = GF_TRUE;",
          "4287:  }",
          "4289:  e = gf_dasher_enable_url_template(dasher, (Bool) use_url_template, seg_name, seg_ext, init_seg_ext);",
          "4290:  if (!e) e = gf_dasher_enable_segment_timeline(dasher, segment_timeline);",
          "4291:  if (!e) e = gf_dasher_enable_single_segment(dasher, single_segment);",
          "4292:  if (!e) e = gf_dasher_enable_single_file(dasher, single_file);",
          "4293:  if (!e) e = gf_dasher_set_switch_mode(dasher, bitstream_switching_mode);",
          "4294:  if (!e) e = gf_dasher_set_durations(dasher, dash_duration, interleaving_time, dash_subduration);",
          "4295:  if (!e) e = gf_dasher_enable_rap_splitting(dasher, seg_at_rap, frag_at_rap);",
          "4296:  if (!e) e = gf_dasher_set_segment_marker(dasher, segment_marker);",
          "4297:  if (!e) e = gf_dasher_enable_sidx(dasher, (subsegs_per_sidx>=0) ? 1 : 0, (u32) subsegs_per_sidx, daisy_chain_sidx, use_ssix);",
          "4298:  if (!e) e = gf_dasher_set_dynamic_mode(dasher, dash_mode, mpd_update_time, time_shift_depth, mpd_live_duration);",
          "4299:  if (!e) e = gf_dasher_set_min_buffer(dasher, min_buffer);",
          "4300:  if (!e) e = gf_dasher_set_ast_offset(dasher, ast_offset_ms);",
          "4301:  if (!e) e = gf_dasher_enable_memory_fragmenting(dasher, memory_frags);",
          "4302:  if (!e) e = gf_dasher_set_initial_isobmf(dasher, initial_moof_sn, initial_tfdt);",
          "4303:  if (!e) e = gf_dasher_configure_isobmf_default(dasher, no_fragments_defaults, pssh_mode, samplegroups_in_traf, single_traf_per_moof, tfdt_per_traf, mvex_after_traks, sdtp_in_traf);",
          "4304:  if (!e) e = gf_dasher_enable_utc_ref(dasher, insert_utc);",
          "4305:  if (!e) e = gf_dasher_enable_real_time(dasher, frag_real_time);",
          "4306:  if (!e) e = gf_dasher_set_content_protection_location_mode(dasher, cp_location_mode);",
          "4307:  if (!e) e = gf_dasher_set_profile_extension(dasher, dash_profile_extension);",
          "4308:  if (!e) e = gf_dasher_enable_cached_inputs(dasher, no_cache);",
          "4309:  if (!e) e = gf_dasher_enable_loop_inputs(dasher, ! no_loop);",
          "4310:  if (!e) e = gf_dasher_set_split_mode(dasher, dash_split_mode);",
          "4311:  if (!e) e = gf_dasher_set_last_segment_merge(dasher, merge_last_seg);",
          "4312:  if (!e) e = gf_dasher_set_hls_clock(dasher, hls_clock);",
          "4313:  if (!e && dash_cues) e = gf_dasher_set_cues(dasher, dash_cues, strict_cues);",
          "4314:  if (!e) e = gf_dasher_print_session_info(dasher, fs_dump_flags);",
          "4315:  if (!e)  e = gf_dasher_keep_source_utc(dasher, keep_utc);",
          "4317:  for (i=0; i < nb_dash_inputs; i++) {",
          "4318:   if (!e) e = gf_dasher_add_input(dasher, &dash_inputs[i]);",
          "4319:  }",
          "4320:  if (e) {",
          "4321:   M4_LOG(GF_LOG_ERROR, (\"DASH Setup Error: %s\\n\", gf_error_to_string(e)));",
          "4322:   gf_dasher_del(dasher);",
          "4323:   return e;",
          "4326:  dash_cumulated_time=0;",
          "4328:  while (1) {",
          "4329:   if (run_for && (dash_cumulated_time >= run_for)) {",
          "4330:    M4_LOG(GF_LOG_INFO, (\"Done running, computing static MPD\\n\"));",
          "4331:    do_abort = 3;",
          "4334:   dash_prev_time=gf_sys_clock();",
          "4335:   if (do_abort>=2) {",
          "4336:    e = gf_dasher_set_dynamic_mode(dasher, GF_DASH_DYNAMIC_LAST, 0, time_shift_depth, mpd_live_duration);",
          "4339:   if (!e) e = gf_dasher_process(dasher);",
          "4340:   if (!dash_live && (e==GF_EOS) ) {",
          "4341:    M4_LOG(GF_LOG_INFO, (\"Nothing to dash, too early ...\\n\"));",
          "4342:    e = GF_OK;",
          "4345:   if (do_abort)",
          "4346:    break;",
          "4349:   if (dash_live && (e==GF_IO_ERR) ) {",
          "4350:    M4_LOG(GF_LOG_WARNING, (\"Error dashing file (%s) but continuing ...\\n\", gf_error_to_string(e) ));",
          "4351:    e = GF_OK;",
          "4352:   }",
          "4354:   if (e) break;",
          "4356:   if (dash_live) {",
          "4357:    u64 ms_in_session=0;",
          "4358:    u32 slept = gf_sys_clock();",
          "4359:    u32 sleep_for = gf_dasher_next_update_time(dasher, &ms_in_session);",
          "4360:    M4_LOG(GF_LOG_INFO, (\"Next generation scheduled in %u ms (DASH time \"LLU\" ms)\\r\", sleep_for, ms_in_session));",
          "4361:    if (run_for && (ms_in_session>=run_for)) {",
          "4362:     dash_cumulated_time = 1+run_for;",
          "4363:     continue;",
          "4364:    }",
          "4366:    while (1) {",
          "4367:     if (gf_prompt_has_input()) {",
          "4368:      char c = (char) gf_prompt_get_char();",
          "4369:      if (c=='X') {",
          "4370:       do_abort = 1;",
          "4371:       break;",
          "4373:      if (c=='q') {",
          "4374:       do_abort = 2;",
          "4375:       break;",
          "4377:      if (c=='s') {",
          "4378:       do_abort = 3;",
          "4379:       break;",
          "4383:     if (dash_mode == GF_DASH_DYNAMIC_DEBUG) {",
          "4384:      break;",
          "4385:     }",
          "4386:     if (!sleep_for) break;",
          "4388:     gf_sleep(sleep_for/10);",
          "4389:     sleep_for = gf_dasher_next_update_time(dasher, NULL);",
          "4390:     if (sleep_for<=1) {",
          "4391:      dash_now_time=gf_sys_clock();",
          "4392:      dash_cumulated_time+=(dash_now_time-dash_prev_time);",
          "4393:      M4_LOG(GF_LOG_INFO, (\"Slept for %d ms before generation, dash cumulated time %d\\n\", dash_now_time - slept, dash_cumulated_time));",
          "4394:      break;",
          "4397:   } else {",
          "4398:    break;",
          "4400:  }",
          "4402:  gf_dasher_del(dasher);",
          "4404:  if (!run_for && dash_ctx_file && (do_abort==3) && (dyn_state_file) && !gf_sys_is_test_mode() ) {",
          "4405:   char szName[1024];",
          "4406:   M4_LOG(GF_LOG_INFO, (\"Enter file name to save dash context:\\n\"));",
          "4407:   if (scanf(\"%1023s\", szName) == 1) {",
          "4408:    gf_file_move(dash_ctx_file, szName);",
          "4411:  if (e) M4_LOG(GF_LOG_ERROR, (\"Error DASHing file: %s\\n\", gf_error_to_string(e)));",
          "4412:  if (file) gf_isom_delete(file);",
          "4413:  if (del_file)",
          "4414:   gf_file_delete(inName);",
          "4416:  return e;",
          "4417: }",
          "4419: static GF_Err do_export_avi()",
          "4420: {",
          "4421:  char szFile[GF_MAX_PATH+24];",
          "4422:  GF_MediaExporter mdump;",
          "4423:  memset(&mdump, 0, sizeof(mdump));",
          "4424:  mdump.in_name = inName;",
          "4425:  mdump.flags = GF_EXPORT_AVI_NATIVE;",
          "4426:  mdump.trackID = trackID;",
          "4427:  if (dump_std) {",
          "4428:   mdump.out_name = \"std\";",
          "4429:  } else if (outName) {",
          "4430:   mdump.out_name = outName;",
          "4431:  } else if (trackID>2) {",
          "4432:   sprintf(szFile, \"%s_audio%d\", outfile, trackID-1);",
          "4433:   mdump.out_name = szFile;",
          "4434:  } else {",
          "4435:   sprintf(szFile, \"%s_%s\", outfile, (trackID==1) ? \"video\" : \"audio\");",
          "4436:   mdump.out_name = szFile;",
          "4437:  }",
          "4439:  mdump.print_stats_graph = fs_dump_flags;",
          "4440:  return gf_media_export(&mdump);",
          "4441: }",
          "4443: static GF_Err do_export_tracks_non_isobmf()",
          "4444: {",
          "4445:  u32 i;",
          "4447:  GF_MediaExporter mdump;",
          "4448:  char szFile[GF_MAX_PATH+24];",
          "4449:  for (i=0; i<nb_track_act; i++) {",
          "4450:   GF_Err e;",
          "4451:   TrackAction *tka = &tracks[i];",
          "4452:   if (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;",
          "4453:   memset(&mdump, 0, sizeof(mdump));",
          "4454:   mdump.in_name = inName;",
          "4455:   mdump.flags = tka->dump_type;",
          "4456:   mdump.trackID = tka->trackID;",
          "4457:   mdump.sample_num = tka->sample_num;",
          "4458:   if (outName) {",
          "4459:    mdump.out_name = outName;",
          "4460:    mdump.flags |= GF_EXPORT_MERGE;",
          "4461:   } else if (nb_track_act>1) {",
          "4462:    sprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);",
          "4463:    mdump.out_name = szFile;",
          "4464:   } else {",
          "4465:    mdump.out_name = outfile;",
          "4467:   mdump.print_stats_graph = fs_dump_flags;",
          "4468:   e = gf_media_export(&mdump);",
          "4469:   if (e) return e;",
          "4470:  }",
          "4471:  return GF_OK;",
          "4472: }",
          "4475: static GF_Err do_dump_iod()",
          "4476: {",
          "4477:  GF_Err e = GF_OK;",
          "4478:  GF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);",
          "4479:  if (!iod) {",
          "4480:   M4_LOG(GF_LOG_WARNING, (\"File %s has no IOD\\n\", inName));",
          "4481:  } else {",
          "4482:   char szName[GF_MAX_PATH+10];",
          "4483:   FILE *iodf;",
          "4484:   sprintf(szName, \"%s.iod\", outfile);",
          "4485:   iodf = gf_fopen(szName, \"wb\");",
          "4486:   if (!iodf) {",
          "4487:    M4_LOG(GF_LOG_ERROR, (\"Cannot open destination %s\\n\", szName));",
          "4488:    e = GF_IO_ERR;",
          "4489:   } else {",
          "4490:    u8 *desc;",
          "4491:    u32 size;",
          "4492:    GF_BitStream *bs = gf_bs_from_file(iodf, GF_BITSTREAM_WRITE);",
          "4493:    if (gf_odf_desc_write((GF_Descriptor *)iod, &desc, &size)==GF_OK) {",
          "4494:     gf_fwrite(desc, size, iodf);",
          "4495:     gf_free(desc);",
          "4496:    } else {",
          "4497:     M4_LOG(GF_LOG_ERROR, (\"Error writing IOD %s\\n\", szName));",
          "4498:     e = GF_IO_ERR;",
          "4500:    gf_bs_del(bs);",
          "4501:    gf_fclose(iodf);",
          "4503:   gf_odf_desc_del((GF_Descriptor*)iod);",
          "4504:  }",
          "4505:  return e;",
          "4506: }",
          "4508: static GF_Err do_export_tracks()",
          "4509: {",
          "4510:  GF_Err e;",
          "4511:  u32 i;",
          "4512:  char szFile[GF_MAX_PATH+24];",
          "4513:  GF_MediaExporter mdump;",
          "4514:  for (i=0; i<nb_track_act; i++) {",
          "4515:   u32 j;",
          "4516:   TrackAction *tka = &tracks[i];",
          "4517:   if (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;",
          "4518:   memset(&mdump, 0, sizeof(mdump));",
          "4519:   mdump.file = file;",
          "4520:   mdump.flags = tka->dump_type;",
          "4521:   mdump.trackID = tka->trackID;",
          "4522:   mdump.sample_num = tka->sample_num;",
          "4523:   if (tka->out_name) {",
          "4524:    mdump.out_name = tka->out_name;",
          "4525:   } else if (outName) {",
          "4526:    mdump.out_name = outName;",
          "4527:    mdump.flags |= GF_EXPORT_MERGE;",
          "4529:    mdump.flags |= GF_EXPORT_NO_FILE_EXT;",
          "4530:   } else if (mdump.trackID) {",
          "4531:    sprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);",
          "4532:    mdump.out_name = szFile;",
          "4533:   } else {",
          "4534:    sprintf(szFile, \"%s_export\", outfile);",
          "4535:    mdump.out_name = szFile;",
          "4537:   if (tka->trackID==(u32) -1) {",
          "4538:    for (j=0; j<gf_isom_get_track_count(file); j++) {",
          "4539:     mdump.trackID = gf_isom_get_track_id(file, j+1);",
          "4540:     sprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);",
          "4541:     mdump.out_name = szFile;",
          "4542:     mdump.print_stats_graph = fs_dump_flags;",
          "4543:     e = gf_media_export(&mdump);",
          "4544:     if (e) return e;",
          "4545:    }",
          "4546:   } else {",
          "4547:    mdump.print_stats_graph = fs_dump_flags;",
          "4548:    e = gf_media_export(&mdump);",
          "4549:    if (e) return e;",
          "4551:  }",
          "4552:  return GF_OK;",
          "4553: }",
          "4555: static GF_Err do_meta_act()",
          "4556: {",
          "4557:  u32 i;",
          "4558:  for (i=0; i<nb_meta_act; i++) {",
          "4559:   GF_Err e;",
          "4560:   u32 j, tk = 0;",
          "4561: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "4562:   Bool self_ref;",
          "4563: #endif",
          "4564:   MetaAction *meta = &metas[i];",
          "4566:   if (meta->trackID) tk = gf_isom_get_track_by_id(file, meta->trackID);",
          "4568:   switch (meta->act_type) {",
          "4569: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "4570:   case META_ACTION_SET_TYPE:",
          "4572:    e = gf_isom_set_meta_type(file, meta->root_meta, tk, meta->meta_4cc);",
          "4573:    gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO2, GF_TRUE);",
          "4574:    do_save = GF_TRUE;",
          "4575:    break;",
          "4576:   case META_ACTION_ADD_ITEM:",
          "4577:    self_ref = !stricmp(meta->szPath, \"NULL\") || !stricmp(meta->szPath, \"this\") || !stricmp(meta->szPath, \"self\");",
          "4578:    e = gf_isom_add_meta_item(file, meta->root_meta, tk, self_ref, self_ref ? NULL : meta->szPath,",
          "4579:                              meta->szName,",
          "4580:                              meta->item_id,",
          "4581:            meta->item_type,",
          "4582:                              meta->mime_type,",
          "4583:                              meta->enc_type,",
          "4584:                              meta->use_dref ? meta->szPath : NULL,  NULL,",
          "4585:                              meta->image_props);",
          "4586:    if (meta->item_refs && gf_list_count(meta->item_refs)) {",
          "4587:     u32 ref_i;",
          "4588:     for (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {",
          "4589:      MetaRef *ref_entry = gf_list_get(meta->item_refs, ref_i);",
          "4590:      e = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);",
          "4591:     }",
          "4593:    do_save = GF_TRUE;",
          "4594:    break;",
          "4595:   case META_ACTION_ADD_IMAGE_ITEM:",
          "4596:   {",
          "4597:    u32 old_tk_count = gf_isom_get_track_count(file);",
          "4598:    u32 src_tk_id = 1;",
          "4599:    GF_Fraction _frac = {0,0};",
          "4600:    GF_ISOFile *fsrc = file;",
          "4601:    self_ref = GF_FALSE;",
          "4603:    tk = 0;",
          "4604:    if (meta->image_props && meta->image_props->auto_grid) {",
          "4606:     self_ref = GF_TRUE;",
          "4607:    } else if (!meta->szPath || (meta->image_props && meta->image_props->sample_num && meta->image_props->use_reference)) {",
          "4609:     self_ref = GF_TRUE;",
          "4610:     src_tk_id = meta->trackID;",
          "4611:    } else if (meta->szPath) {",
          "4612:     if (meta->image_props && gf_isom_probe_file(meta->szPath) && !meta->image_props->tile_mode) {",
          "4613:      meta->image_props->src_file = gf_isom_open(meta->szPath, GF_ISOM_OPEN_READ, NULL);",
          "4614:      e = gf_isom_last_error(meta->image_props->src_file);",
          "4615:      fsrc = meta->image_props->src_file;",
          "4616:     } else {",
          "4617:      e = import_file(file, meta->szPath, 0, _frac, 0, NULL, NULL, 0);",
          "4618:     }",
          "4619:    } else {",
          "4620:     M4_LOG(GF_LOG_ERROR, (\"Missing file name to import\\n\"));",
          "4621:     e = GF_BAD_PARAM;",
          "4623:    if (e == GF_OK) {",
          "4624:     u32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);",
          "4625:     if (!meta_type) {",
          "4626:      e = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);",
          "4627:     } else {",
          "4628:      if (meta_type != GF_META_ITEM_TYPE_PICT) {",
          "4629:       GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));",
          "4630:       e = GF_BAD_PARAM;",
          "4631:      }",
          "4633:     if (e == GF_OK) {",
          "4634:      if (!meta->item_id) {",
          "4635:       e = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);",
          "4636:      }",
          "4637:      if (e == GF_OK) {",
          "4638:       if (!src_tk_id) {",
          "4639:        for (j=0; j<gf_isom_get_track_count(fsrc); j++) {",
          "4640:         if (gf_isom_is_video_handler_type (gf_isom_get_media_type(fsrc, j+1))) {",
          "4641:          src_tk_id = gf_isom_get_track_id(fsrc, j+1);",
          "4642:          break;",
          "4643:         }",
          "4644:        }",
          "4646:        if (!src_tk_id) {",
          "4647:         M4_LOG(GF_LOG_ERROR, (\"No video track in file, cannot add image from track\\n\"));",
          "4648:         e = GF_BAD_PARAM;",
          "4649:         break;",
          "4650:        }",
          "4653:       e = gf_isom_iff_create_image_item_from_track(file, meta->root_meta, tk, src_tk_id, meta->szName, meta->item_id, meta->image_props, NULL);",
          "4654:       if (e == GF_OK && meta->primary) {",
          "4655:        e = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);",
          "4657:       if (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {",
          "4658:        u32 ref_i;",
          "4659:        for (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {",
          "4660:         MetaRef *ref_entry = gf_list_get(meta->item_refs, ref_i);",
          "4661:         e = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);",
          "4662:        }",
          "4663:       }",
          "4664:       if (e == GF_OK && meta->group_type) {",
          "4665:        e = gf_isom_meta_add_item_group(file, meta->root_meta, tk, meta->item_id, meta->group_id, meta->group_type);",
          "4668:     }",
          "4669:    }",
          "4670:    if (meta->image_props && meta->image_props->src_file) {",
          "4671:     gf_isom_delete(meta->image_props->src_file);",
          "4672:     meta->image_props->src_file = NULL;",
          "4673:    } else if (!self_ref) {",
          "4674:     gf_isom_remove_track(file, old_tk_count+1);",
          "4675:     if (do_flat) {",
          "4676:      M4_LOG(GF_LOG_ERROR, (\"Warning: -flat storage cannot be used when using -add-image on external file\\n\"));",
          "4677:      e = GF_NOT_SUPPORTED;",
          "4678:     }",
          "4679:    }",
          "4680:    do_save = GF_TRUE;",
          "4681:   }",
          "4682:    break;",
          "4683:   case META_ACTION_ADD_IMAGE_GRID:",
          "4684:   {",
          "4685:    u32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);",
          "4686:    e = GF_OK;",
          "4687:    if (!meta_type) {",
          "4688:     e = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);",
          "4689:    } else {",
          "4690:     if (meta_type != GF_META_ITEM_TYPE_PICT) {",
          "4691:      GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));",
          "4692:      e = GF_BAD_PARAM;",
          "4693:     }",
          "4694:    }",
          "4695:    if (e == GF_OK) {",
          "4696:     if (!meta->item_id) {",
          "4697:      e = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);",
          "4698:     }",
          "4699:     if (e == GF_OK) {",
          "4700:      e = gf_isom_iff_create_image_grid_item(file, meta->root_meta, tk,",
          "4701:        meta->szName && strlen(meta->szName) ? meta->szName : NULL,",
          "4702:        meta->item_id,",
          "4703:        meta->image_props);",
          "4704:      if (e == GF_OK && meta->primary) {",
          "4705:       e = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);",
          "4707:      if (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {",
          "4708:       u32 ref_i;",
          "4709:       for (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {",
          "4710:        MetaRef *ref_entry = gf_list_get(meta->item_refs, ref_i);",
          "4711:        e = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);",
          "4712:       }",
          "4716:    do_save = GF_TRUE;",
          "4718:    break;",
          "4719:   case META_ACTION_REM_ITEM:",
          "4720:    e = gf_isom_remove_meta_item(file, meta->root_meta, tk, meta->item_id);",
          "4721:    do_save = GF_TRUE;",
          "4722:    break;",
          "4723:   case META_ACTION_SET_PRIMARY_ITEM:",
          "4724:    e = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);",
          "4725:    do_save = GF_TRUE;",
          "4726:    break;",
          "4727:   case META_ACTION_SET_XML:",
          "4728:   case META_ACTION_SET_BINARY_XML:",
          "4729:    e = gf_isom_set_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL, 0, (meta->act_type==META_ACTION_SET_BINARY_XML) ? 1 : 0);",
          "4730:    do_save = GF_TRUE;",
          "4731:    break;",
          "4732:   case META_ACTION_REM_XML:",
          "4733:    if (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {",
          "4734:     e = gf_isom_remove_meta_xml(file, meta->root_meta, tk);",
          "4735:     do_save = GF_TRUE;",
          "4736:    } else {",
          "4737:     M4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));",
          "4738:    }",
          "4739:    break;",
          "4740:   case META_ACTION_DUMP_ITEM:",
          "4741:    if (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {",
          "4742:     e = gf_isom_extract_meta_item(file, meta->root_meta, tk, meta->item_id, meta->szPath && strlen(meta->szPath) ? meta->szPath : NULL);",
          "4743:    } else {",
          "4744:     M4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));",
          "4745:    }",
          "4746:    break;",
          "4747: #endif // GPAC_DISABLE_ISOM_WRITE",
          "4749:   case META_ACTION_DUMP_XML:",
          "4750:    if (gf_isom_has_meta_xml(file, meta->root_meta, tk)) {",
          "4751:     e = gf_isom_extract_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL);",
          "4752:    } else {",
          "4753:     M4_LOG(GF_LOG_WARNING, (\"No meta box in input file\\n\"));",
          "4754:    }",
          "4755:    break;",
          "4756:   default:",
          "4757:    break;",
          "4758:   }",
          "4759:   if (meta->item_refs) {",
          "4760:    while (gf_list_count(meta->item_refs)) {",
          "4761:     gf_free(gf_list_pop_back(meta->item_refs));",
          "4762:    }",
          "4763:    gf_list_del(meta->item_refs);",
          "4764:    meta->item_refs = NULL;",
          "4765:   }",
          "4766:   if (meta->image_props) {",
          "4767:    gf_free(meta->image_props);",
          "4768:    meta->image_props = NULL;",
          "4769:   }",
          "4770:   if (e) return e;",
          "4771:  }",
          "4772:  return GF_OK;",
          "4773: }",
          "4775: static GF_Err do_tsel_act()",
          "4776: {",
          "4777:  u32 i;",
          "4778:  GF_Err e;",
          "4779:  for (i=0; i<nb_tsel_acts; i++) {",
          "4780:   switch (tsel_acts[i].act_type) {",
          "4781:   case TSEL_ACTION_SET_PARAM:",
          "4782:    e = gf_isom_set_track_switch_parameter(file,",
          "4783:                                           gf_isom_get_track_by_id(file, tsel_acts[i].trackID),",
          "4784:                                           tsel_acts[i].refTrackID ? gf_isom_get_track_by_id(file, tsel_acts[i].refTrackID) : 0,",
          "4785:                                           tsel_acts[i].is_switchGroup ? 1 : 0,",
          "4786:                                           &tsel_acts[i].switchGroupID,",
          "4787:                                           tsel_acts[i].criteria, tsel_acts[i].nb_criteria);",
          "4788:    if (e == GF_BAD_PARAM) {",
          "4789:     u32 alternateGroupID, nb_groups;",
          "4790:     gf_isom_get_track_switch_group_count(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), &alternateGroupID, &nb_groups);",
          "4791:     if (alternateGroupID) {",
          "4792:      M4_LOG(GF_LOG_ERROR, (\"Error - for adding more tracks to group, using: -group-add -refTrack=ID1:[criteria:]trackID=ID2\\n\"));",
          "4793:     } else {",
          "4794:      M4_LOG(GF_LOG_ERROR, (\"Error - for creating a new grouping information, using -group-add -trackID=ID1:[criteria:]trackID=ID2\\n\"));",
          "4795:     }",
          "4796:    }",
          "4797:    if (e) return e;",
          "4798:    do_save = GF_TRUE;",
          "4799:    break;",
          "4800:   case TSEL_ACTION_REMOVE_TSEL:",
          "4801:    e = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 0);",
          "4802:    if (e) return e;",
          "4803:    do_save = GF_TRUE;",
          "4804:    break;",
          "4805:   case TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP:",
          "4806:    e = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 1);",
          "4807:    if (e) return e;",
          "4808:    do_save = GF_TRUE;",
          "4809:    break;",
          "4810:   default:",
          "4811:    break;",
          "4812:   }",
          "4813:  }",
          "4814:  return GF_OK;",
          "4815: }",
          "4817: static void do_ipod_conv()",
          "4818: {",
          "4819:  u32 i, ipod_major_brand = 0;",
          "4820:  M4_LOG(GF_LOG_INFO, (\"Setting up iTunes/iPod file\\n\"));",
          "4822:  for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "4823:   u32 mType = gf_isom_get_media_type(file, i+1);",
          "4824:   switch (mType) {",
          "4825:   case GF_ISOM_MEDIA_VISUAL:",
          "4826:   case GF_ISOM_MEDIA_AUXV:",
          "4827:   case GF_ISOM_MEDIA_PICT:",
          "4828:    ipod_major_brand = GF_ISOM_BRAND_M4V;",
          "4829:    gf_isom_set_ipod_compatible(file, i+1);",
          "4830:    break;",
          "4831:   case GF_ISOM_MEDIA_AUDIO:",
          "4832:    if (!ipod_major_brand) ipod_major_brand = GF_ISOM_BRAND_M4A;",
          "4833:    else gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_M4A, GF_TRUE);",
          "4834:    break;",
          "4835:   case GF_ISOM_MEDIA_TEXT:",
          "4837:    if (gf_isom_get_media_subtype(file, i+1, 1) == GF_ISOM_SUBTYPE_TX3G) {",
          "4838:     Bool is_chap = 0;",
          "4839:     u32 j;",
          "4840:     for (j=0; j<gf_isom_get_track_count(file); j++) {",
          "4841:      s32 count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_CHAP);",
          "4842:      if (count>0) {",
          "4843:       u32 tk, k;",
          "4844:       for (k=0; k<(u32) count; k++) {",
          "4845:        gf_isom_get_reference(file, j+1, GF_ISOM_REF_CHAP, k+1, &tk);",
          "4846:        if (tk==i+1) {",
          "4847:         is_chap = 1;",
          "4848:         break;",
          "4849:        }",
          "4850:       }",
          "4851:       if (is_chap) break;",
          "4852:      }",
          "4853:      if (is_chap) break;",
          "4854:     }",
          "4856:     if (!is_chap)",
          "4857:      gf_isom_set_media_type(file, i+1, GF_ISOM_MEDIA_SUBT);",
          "4858:    }",
          "4859:    break;",
          "4860:   }",
          "4861:  }",
          "4862:  gf_isom_set_brand_info(file, ipod_major_brand, 1);",
          "4863:  gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MP42, GF_TRUE);",
          "4864:  do_save = GF_TRUE;",
          "4865: }",
          "4867: static GF_Err do_track_act()",
          "4868: {",
          "4869:  u32 j, i;",
          "4870:  GF_Err e;",
          "4871:  for (j=0; j<nb_track_act; j++) {",
          "4872:   TrackAction *tka = &tracks[j];",
          "4873:   u32 track = tka->trackID ? gf_isom_get_track_by_id(file, tka->trackID) : 0;",
          "4875:   timescale = gf_isom_get_timescale(file);",
          "4876:   switch (tka->act_type) {",
          "4877:   case TRAC_ACTION_REM_TRACK:",
          "4878:    e = gf_isom_remove_track(file, track);",
          "4879:    if (e) {",
          "4880:     M4_LOG(GF_LOG_ERROR, (\"Error Removing track ID %d: %s\\n\", tka->trackID, gf_error_to_string(e)));",
          "4881:    } else {",
          "4882:     M4_LOG(GF_LOG_INFO, (\"Removing track ID %d\\n\", tka->trackID));",
          "4883:    }",
          "4884:    do_save = GF_TRUE;",
          "4885:    break;",
          "4886:   case TRAC_ACTION_SET_LANGUAGE:",
          "4887:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "4888:     if (track && (track != i+1)) continue;",
          "4889:     e = gf_isom_set_media_language(file, i+1, tka->lang);",
          "4890:     if (e) return e;",
          "4891:     do_save = GF_TRUE;",
          "4892:    }",
          "4893:    do_save = GF_TRUE;",
          "4894:    break;",
          "4895:   case TRAC_ACTION_SET_KIND:",
          "4896:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "4897:     if (track && (track != i+1)) continue;",
          "4898:     e = gf_isom_add_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "4899:     if (e) return e;",
          "4900:     do_save = GF_TRUE;",
          "4901:    }",
          "4902:    do_save = GF_TRUE;",
          "4903:    break;",
          "4904:   case TRAC_ACTION_REM_KIND:",
          "4905:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "4906:     if (track && (track != i+1)) continue;",
          "4907:     e = gf_isom_remove_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "4908:     if (e) return e;",
          "4909:     do_save = GF_TRUE;",
          "4910:    }",
          "4911:    do_save = GF_TRUE;",
          "4912:    break;",
          "4913:   case TRAC_ACTION_SET_DELAY:",
          "4914:    if (tka->delay.num && tka->delay.den) {",
          "4915:     u64 tk_dur;",
          "4917:     gf_isom_remove_edits(file, track);",
          "4918:     tk_dur = gf_isom_get_track_duration(file, track);",
          "4919:     if (gf_isom_get_edits_count(file, track))",
          "4920:      do_save = GF_TRUE;",
          "4921:     if (tka->delay.num>0) {",
          "4923:      gf_isom_append_edit(file, track, ((u64) tka->delay.num) * timescale / tka->delay.den, 0, GF_ISOM_EDIT_EMPTY);",
          "4924:      gf_isom_append_edit(file, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);",
          "4925:      do_save = GF_TRUE;",
          "4926:     } else {",
          "4928:      u64 to_skip = ((u64) -tka->delay.num) * timescale / tka->delay.den;",
          "4929:      if (to_skip<tk_dur) {",
          "4931:       u64 media_time = ((u64) -tka->delay.num) * gf_isom_get_media_timescale(file, track) / tka->delay.den;",
          "4932:       gf_isom_append_edit(file, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);",
          "4933:       do_save = GF_TRUE;",
          "4934:      } else {",
          "4935:       M4_LOG(GF_LOG_WARNING, (\"Warning: request negative delay longer than track duration - ignoring\\n\"));",
          "4936:      }",
          "4937:     }",
          "4938:    } else if (gf_isom_get_edits_count(file, track)) {",
          "4939:     gf_isom_remove_edits(file, track);",
          "4940:     do_save = GF_TRUE;",
          "4941:    }",
          "4942:    break;",
          "4943:   case TRAC_ACTION_SET_KMS_URI:",
          "4944:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "4945:     if (track && (track != i+1)) continue;",
          "4946:     if (!gf_isom_is_media_encrypted(file, i+1, 1)) continue;",
          "4947:     if (!gf_isom_is_ismacryp_media(file, i+1, 1)) continue;",
          "4948:     e = gf_isom_change_ismacryp_protection(file, i+1, 1, NULL, (char *) tka->kms);",
          "4949:     if (e) return e;",
          "4950:     do_save = GF_TRUE;",
          "4951:    }",
          "4952:    break;",
          "4953:   case TRAC_ACTION_SET_ID:",
          "4954:    if (!tka->trackID && (gf_isom_get_track_count(file) == 1)) {",
          "4955:     M4_LOG(GF_LOG_WARNING, (\"Warning: track id is not specified, but file has only one track - assume that you want to change id for this track\\n\"));",
          "4956:     track = 1;",
          "4957:    }",
          "4958:    if (track) {",
          "4959:     u32 newTrack;",
          "4960:     newTrack = gf_isom_get_track_by_id(file, tka->newTrackID);",
          "4961:     if (newTrack != 0) {",
          "4962:      M4_LOG(GF_LOG_WARNING, (\"Cannot set track id with value %d because a track already exists - ignoring\", tka->newTrackID));",
          "4963:     } else {",
          "4964:      e = gf_isom_set_track_id(file, track, tka->newTrackID);",
          "4965:      do_save = GF_TRUE;",
          "4966:     }",
          "4967:    } else {",
          "4968:     M4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));",
          "4969:    }",
          "4970:    break;",
          "4971:   case TRAC_ACTION_SWAP_ID:",
          "4972:    if (track) {",
          "4973:     u32 tk1, tk2;",
          "4974:     tk1 = gf_isom_get_track_by_id(file, tka->trackID);",
          "4975:     tk2 = gf_isom_get_track_by_id(file, tka->newTrackID);",
          "4976:     if (!tk1 || !tk2) {",
          "4977:      M4_LOG(GF_LOG_WARNING, (\"Error: Cannot swap track IDs because not existing - ignoring\"));",
          "4978:     } else {",
          "4979:      e = gf_isom_set_track_id(file, tk2, 0);",
          "4980:      if (!e) e = gf_isom_set_track_id(file, tk1, tka->newTrackID);",
          "4981:      if (!e) e = gf_isom_set_track_id(file, tk2, tka->trackID);",
          "4982:      do_save = GF_TRUE;",
          "4983:     }",
          "4984:    } else {",
          "4985:     M4_LOG(GF_LOG_WARNING, (\"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID));",
          "4986:    }",
          "4987:    break;",
          "4988:   case TRAC_ACTION_SET_PAR:",
          "4989:    e = gf_media_change_par(file, track, tka->par_num, tka->par_den, tka->force_par, tka->rewrite_bs);",
          "4990:    do_save = GF_TRUE;",
          "4991:    break;",
          "4992:   case TRAC_ACTION_SET_CLAP:",
          "4993:    e = gf_isom_set_clean_aperture(file, track, 1, tka->clap_wnum, tka->clap_wden, tka->clap_hnum, tka->clap_hden, tka->clap_honum, tka->clap_hoden, tka->clap_vonum, tka->clap_voden);",
          "4994:    do_save = GF_TRUE;",
          "4995:    break;",
          "4996:   case TRAC_ACTION_SET_MX:",
          "4997:    e = gf_isom_set_track_matrix(file, track, tka->mx);",
          "4998:    do_save = GF_TRUE;",
          "4999:    break;",
          "5000:   case TRAC_ACTION_SET_HANDLER_NAME:",
          "5001:    e = gf_isom_set_handler_name(file, track, tka->hdl_name);",
          "5002:    do_save = GF_TRUE;",
          "5003:    break;",
          "5004:   case TRAC_ACTION_ENABLE:",
          "5005:    if (!gf_isom_is_track_enabled(file, track)) {",
          "5006:     e = gf_isom_set_track_enabled(file, track, GF_TRUE);",
          "5007:     do_save = GF_TRUE;",
          "5008:    }",
          "5009:    break;",
          "5010:   case TRAC_ACTION_DISABLE:",
          "5011:    if (gf_isom_is_track_enabled(file, track)) {",
          "5012:     e = gf_isom_set_track_enabled(file, track, GF_FALSE);",
          "5013:     do_save = GF_TRUE;",
          "5014:    }",
          "5015:    break;",
          "5016:   case TRAC_ACTION_REFERENCE:",
          "5017:    e = gf_isom_set_track_reference(file, track, GF_4CC(tka->lang[0], tka->lang[1], tka->lang[2], tka->lang[3]), tka->newTrackID);",
          "5018:    do_save = GF_TRUE;",
          "5019:    break;",
          "5020:   case TRAC_ACTION_REM_NON_RAP:",
          "5021:    e = gf_media_remove_non_rap(file, track, GF_FALSE);",
          "5022:    do_save = GF_TRUE;",
          "5023:    break;",
          "5024:   case TRAC_ACTION_REM_NON_REFS:",
          "5025:    e = gf_media_remove_non_rap(file, track, GF_TRUE);",
          "5026:    do_save = GF_TRUE;",
          "5027:    break;",
          "5028:   case TRAC_ACTION_SET_UDTA:",
          "5029:    e = set_file_udta(file, track, tka->udta_type, tka->string ? tka->string : tka->src_name , tka->sample_num ? GF_TRUE : GF_FALSE, tka->string ? GF_TRUE : GF_FALSE);",
          "5030:    if (e) return e;",
          "5031:    do_save = GF_TRUE;",
          "5032:    break;",
          "5033:   case TRAC_ACTION_SET_EDITS:",
          "5034:    e = apply_edits(file, track, tka->string);",
          "5035:    do_save = GF_TRUE;",
          "5036:    break;",
          "5037:   case TRAC_ACTION_SET_TIME:",
          "5038:    if (!tka->trackID) {",
          "5039:     e = gf_isom_set_creation_time(file, tka->time, tka->time);",
          "5040:     if (e) return e;",
          "5041:     for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5042:      e = gf_isom_set_track_creation_time(file, i+1, tka->time, tka->time);",
          "5043:      if (e) return e;",
          "5044:     }",
          "5045:    } else {",
          "5046:     e = gf_isom_set_track_creation_time(file, track, tka->time, tka->time);",
          "5047:    }",
          "5048:    do_save = GF_TRUE;",
          "5049:    break;",
          "5050:   default:",
          "5051:    break;",
          "5052:   }",
          "5053:   if (e) return e;",
          "5054:  }",
          "5055:  return GF_OK;",
          "5056: }",
          "5058: static GF_Err do_itunes_tag()",
          "5059: {",
          "5060:  GF_Err e;",
          "5061:  char *itunes_data = NULL;",
          "5062:  char *tags = itunes_tags;",
          "5064:  if (gf_file_exists(itunes_tags)) {",
          "5065:   u32 len;",
          "5066:   e = gf_file_load_data(itunes_tags, (u8 **) &itunes_data, &len);",
          "5067:   if (e) return e;;",
          "5068:   tags = itunes_data;",
          "5069:  }",
          "5071:  while (tags) {",
          "5072:   char *val;",
          "5073:   Bool clear = GF_FALSE;",
          "5074:   u32 tlen, tagtype, itag = 0;",
          "5075:   s32 tag_idx;",
          "5076:   char *sep = itunes_data ? strchr(tags, '\\n') : gf_url_colon_suffix(tags);",
          "5077:   while (sep) {",
          "5078:    char *eq = strchr(sep+1, '=');",
          "5079:    if (eq) eq[0] = 0;",
          "5080:    s32 next_tag_idx = gf_itags_find_by_name(sep+1);",
          "5081:    if ((next_tag_idx<0) && strlen(sep+1)==4)",
          "5082:     next_tag_idx = 0;",
          "5084:    if (eq) eq[0] = '=';",
          "5085:    if (next_tag_idx>=0) {",
          "5086:     sep[0] = 0;",
          "5087:     break;",
          "5088:    }",
          "5089:    sep = itunes_data ? strchr(sep+1, '\\n') : gf_url_colon_suffix(sep+1);",
          "5090:   }",
          "5091:   val = strchr(tags, '=');",
          "5092:   if (val) val[0] = 0;",
          "5093:   if (!strcmp(tags, \"clear\") || !strcmp(tags, \"reset\")) {",
          "5094:    clear = GF_TRUE;",
          "5095:   } else {",
          "5096:    tag_idx = gf_itags_find_by_name(tags);",
          "5097:    if ((tag_idx<0) && (strlen(tags)==4)) {",
          "5098:     itag = GF_4CC(tags[0], tags[1], tags[2], tags[3]);",
          "5099:     tagtype = GF_ITAG_STR;",
          "5100:    }",
          "5101:   }",
          "5102:   if (val) {",
          "5103:    val[0] = '=';",
          "5104:    val++;",
          "5105:   }",
          "5106:   if (!itag && !clear) {",
          "5107:    if (tag_idx<0) {",
          "5108:     M4_LOG(GF_LOG_WARNING, (\"Invalid iTune tag name \\\"%s\\\" - ignoring\\n\", tags));",
          "5109:     break;",
          "5110:    }",
          "5111:    itag = gf_itags_get_itag(tag_idx);",
          "5112:    tagtype = gf_itags_get_type(tag_idx);",
          "5113:   }",
          "5114:   if (!val || (val[0]==':') || !val[0] || !stricmp(val, \"NULL\") ) val = NULL;",
          "5116:   tlen = val ? (u32) strlen(val) : 0;",
          "5117:   if (clear) {",
          "5118:    e = gf_isom_apple_set_tag(file, GF_ISOM_ITUNE_RESET, NULL, 0, 0, 0);",
          "5120:   }",
          "5121:   else if (val && (tagtype==GF_ITAG_FILE)) {",
          "5122:    u32 flen = (u32) strlen(val);",
          "5123:    u8 *d=NULL;",
          "5124:    while (flen && val[flen-1]=='\\n') flen--;",
          "5125:    val[flen] = 0;",
          "5126:    e = gf_file_load_data(val, (u8 **) &d, &tlen);",
          "5127:    val[flen] = '\\n';",
          "5129:    if (!e)",
          "5130:     e = gf_isom_apple_set_tag(file, itag, d, tlen, 0, 0);",
          "5132:    if (d) gf_free(d);",
          "5133:   } else {",
          "5134:    e = gf_isom_apple_set_tag(file, itag, (u8 *) val, tlen, 0, 0);",
          "5135:   }",
          "5136:   if (e) {",
          "5137:    M4_LOG(GF_LOG_ERROR, (\"Error assigning tag %s: %s\\n\", tags, gf_error_to_string(e) ));",
          "5138:   }",
          "5140:   do_save = GF_TRUE;",
          "5142:   if (sep) {",
          "5143:    sep[0] = itunes_data ? '\\n' : ':';",
          "5144:    tags = sep+1;",
          "5145:   } else {",
          "5146:    tags = NULL;",
          "5147:   }",
          "5148:  }",
          "5149:  if (itunes_data) gf_free(itunes_data);",
          "5150:  return GF_OK;",
          "5151: }",
          "5153: #if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)",
          "5154: static void set_sdp_ext()",
          "5155: {",
          "5156:  u32 i, j;",
          "5157:  for (i=0; i<nb_sdp_ex; i++) {",
          "5158:   if (sdp_lines[i].trackID) {",
          "5159:    u32 track = gf_isom_get_track_by_id(file, sdp_lines[i].trackID);",
          "5160:    if (gf_isom_get_media_type(file, track)!=GF_ISOM_MEDIA_HINT) {",
          "5161:     s32 ref_count;",
          "5162:     u32 k, count = gf_isom_get_track_count(file);",
          "5163:     for (j=0; j<count; j++) {",
          "5164:      if (gf_isom_get_media_type(file, j+1)!=GF_ISOM_MEDIA_HINT) continue;",
          "5165:      ref_count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_HINT);",
          "5166:      if (ref_count<0) continue;",
          "5167:      for (k=0; k<(u32) ref_count; k++) {",
          "5168:       u32 refTk;",
          "5169:       if (gf_isom_get_reference(file, j+1, GF_ISOM_REF_HINT, k+1, &refTk)) continue;",
          "5170:       if (refTk==track) {",
          "5171:        track = j+1;",
          "5172:        j=count;",
          "5173:        break;",
          "5174:       }",
          "5175:      }",
          "5176:     }",
          "5177:    }",
          "5178:    gf_isom_sdp_add_track_line(file, track, sdp_lines[i].line);",
          "5179:    do_save = GF_TRUE;",
          "5180:   } else {",
          "5181:    gf_isom_sdp_add_line(file, sdp_lines[i].line);",
          "5182:    do_save = GF_TRUE;",
          "5183:   }",
          "5184:  }",
          "5185: }",
          "5188: static u32 mp4box_cleanup(u32 ret_code) {",
          "5189:  if (mpd_base_urls) {",
          "5190:   gf_free(mpd_base_urls);",
          "5191:   mpd_base_urls = NULL;",
          "5192:  }",
          "5193:  if (sdp_lines) {",
          "5194:   gf_free(sdp_lines);",
          "5195:   sdp_lines = NULL;",
          "5196:  }",
          "5197:  if (metas) {",
          "5198:   u32 i;",
          "5199:   for (i=0; i<nb_meta_act; i++) {",
          "5200:    if (metas[i].enc_type) gf_free(metas[i].enc_type);",
          "5201:    if (metas[i].mime_type) gf_free(metas[i].mime_type);",
          "5202:    if (metas[i].szName) gf_free(metas[i].szName);",
          "5203:    if (metas[i].szPath) gf_free(metas[i].szPath);",
          "5204:   }",
          "5205:   gf_free(metas);",
          "5206:   metas = NULL;",
          "5207:  }",
          "5208:  if (tracks) {",
          "5209:   u32 i;",
          "5210:   for (i = 0; i<nb_track_act; i++) {",
          "5211:    if (tracks[i].out_name)",
          "5212:     gf_free(tracks[i].out_name);",
          "5213:    if (tracks[i].src_name)",
          "5214:     gf_free(tracks[i].src_name);",
          "5215:    if (tracks[i].string)",
          "5216:     gf_free(tracks[i].string);",
          "5217:    if (tracks[i].kind_scheme)",
          "5218:     gf_free(tracks[i].kind_scheme);",
          "5219:    if (tracks[i].kind_value)",
          "5220:     gf_free(tracks[i].kind_value);",
          "5221:   }",
          "5222:   gf_free(tracks);",
          "5223:   tracks = NULL;",
          "5224:  }",
          "5225:  if (tsel_acts) {",
          "5226:   gf_free(tsel_acts);",
          "5227:   tsel_acts = NULL;",
          "5228:  }",
          "5229:  if (brand_add) {",
          "5230:   gf_free(brand_add);",
          "5231:   brand_add = NULL;",
          "5232:  }",
          "5233:  if (brand_rem) {",
          "5234:   gf_free(brand_rem);",
          "5235:   brand_rem = NULL;",
          "5236:  }",
          "5237:  if (dash_inputs) {",
          "5238:   u32 i, j;",
          "5239:   for (i = 0; i<nb_dash_inputs; i++) {",
          "5240:    GF_DashSegmenterInput *di = &dash_inputs[i];",
          "5241:    if (di->nb_baseURL) {",
          "5242:     for (j = 0; j<di->nb_baseURL; j++) {",
          "5243:      gf_free(di->baseURL[j]);",
          "5244:     }",
          "5245:     gf_free(di->baseURL);",
          "5246:    }",
          "5247:    if (di->rep_descs) {",
          "5248:     for (j = 0; j<di->nb_rep_descs; j++) {",
          "5249:      gf_free(di->rep_descs[j]);",
          "5250:     }",
          "5251:     gf_free(di->rep_descs);",
          "5252:    }",
          "5253:    if (di->as_descs) {",
          "5254:     for (j = 0; j<di->nb_as_descs; j++) {",
          "5255:      gf_free(di->as_descs[j]);",
          "5256:     }",
          "5257:     gf_free(di->as_descs);",
          "5258:    }",
          "5259:    if (di->as_c_descs) {",
          "5260:     for (j = 0; j<di->nb_as_c_descs; j++) {",
          "5261:      gf_free(di->as_c_descs[j]);",
          "5262:     }",
          "5263:     gf_free(di->as_c_descs);",
          "5264:    }",
          "5265:    if (di->p_descs) {",
          "5266:     for (j = 0; j<di->nb_p_descs; j++) {",
          "5267:      gf_free(di->p_descs[j]);",
          "5268:     }",
          "5269:     gf_free(di->p_descs);",
          "5270:    }",
          "5271:    if (di->representationID) gf_free(di->representationID);",
          "5272:    if (di->periodID) gf_free(di->periodID);",
          "5273:    if (di->xlink) gf_free(di->xlink);",
          "5274:    if (di->seg_template) gf_free(di->seg_template);",
          "5275:    if (di->hls_pl) gf_free(di->hls_pl);",
          "5276:    if (di->source_opts) gf_free(di->source_opts);",
          "5277:    if (di->filter_chain) gf_free(di->filter_chain);",
          "5279:    if (di->roles) {",
          "5280:     for (j = 0; j<di->nb_roles; j++) {",
          "5281:      gf_free(di->roles[j]);",
          "5282:     }",
          "5283:     gf_free(di->roles);",
          "5284:    }",
          "5285:   }",
          "5286:   gf_free(dash_inputs);",
          "5287:   dash_inputs = NULL;",
          "5288:  }",
          "5289:  if (logfile) gf_fclose(logfile);",
          "5290:  gf_sys_close();",
          "5291:  return ret_code;",
          "5292: }",
          "5296: int mp4boxMain(int argc, char **argv)",
          "5297: {",
          "5298:  u32 i, j;",
          "5299:  const char *gpac_profile = \"0\";",
          "5300:  GF_Err e = GF_OK;",
          "5302: #ifdef TEST_ARGS",
          "5303:  i=0;",
          "5304:  mp4box_parse_single_arg(argc, argv, \"\", &i);",
          "5305: #endif",
          "5307:  for (i = 1; i < (u32) argc ; i++) {",
          "5308:   if (!strcmp(argv[i], \"-mem-track\") || !strcmp(argv[i], \"-mem-track-stack\")) {",
          "5309: #ifdef GPAC_MEMORY_TRACKING",
          "5310:             mem_track = !strcmp(argv[i], \"-mem-track-stack\") ? GF_MemTrackerBackTrace : GF_MemTrackerSimple;",
          "5311: #else",
          "5312:    M4_LOG(GF_LOG_WARNING, (\"WARNING - GPAC not compiled with Memory Tracker - ignoring \\\"%s\\\"\\n\", argv[i]));",
          "5313: #endif",
          "5314:    break;",
          "5315:   }",
          "5316:   else if (!strcmp(argv[i], \"-p\")) {",
          "5317:    if (i+1<(u32) argc)",
          "5318:     gpac_profile = argv[i+1];",
          "5319:    else {",
          "5320:     M4_LOG(GF_LOG_ERROR, (\"Bad argument for -p, expecting profile name but no more args\\n\"));",
          "5321:     return 1;",
          "5324:   else if (!strncmp(argv[i], \"-p=\", 3))",
          "5325:    gpac_profile = argv[i]+3;",
          "5326:  }",
          "5328: #ifdef _TWO_DIGIT_EXPONENT",
          "5329:  _set_output_format(_TWO_DIGIT_EXPONENT);",
          "5330: #endif",
          "5333:  gf_sys_init(mem_track, gpac_profile);",
          "5334:  if (argc < 2) {",
          "5335:   M4_LOG(GF_LOG_ERROR, (\"Not enough arguments - check usage with -h\\n\"));",
          "5336:   M4_LOG(GF_LOG_INFO, (\"MP4Box - GPAC version %s\\n\"",
          "5337:          \"%s\\n\", gf_gpac_version(), gf_gpac_copyright_cite() ));",
          "5338:   gf_sys_close();",
          "5339:   return 0;",
          "5340:  }",
          "5342:  helpout = stdout;",
          "5344:  i = mp4box_parse_args(argc, argv);",
          "5345:  if (i) {",
          "5346:   return mp4box_cleanup(i - 1);",
          "5347:  }",
          "5348: #if !defined(GPAC_DISABLE_STREAMING) && !defined(GPAC_DISABLE_SENG)",
          "5349:  if (live_scene) {",
          "5350:   int ret = live_session(argc, argv);",
          "5351:   return mp4box_cleanup(ret);",
          "5352:  }",
          "5353: #endif",
          "5355:  if (do_mpd_conv) inName = do_mpd_conv;",
          "5357:  if (import_flags & GF_IMPORT_FORCE_MPEG4)",
          "5358:   hint_flags |= GP_RTP_PCK_FORCE_MPEG4;",
          "5360:  if (!inName && dump_std)",
          "5361:   inName = \"std\";",
          "5363:  if (!dash_duration && cprt)",
          "5364:   open_edit = GF_TRUE;",
          "5366:  if (!inName) {",
          "5367:   if (has_next_arg) {",
          "5368:    M4_LOG(GF_LOG_ERROR, (\"Broken argument specifier or file name missing - check usage with -h\\n\"));",
          "5369:   } else {",
          "5370:    PrintUsage();",
          "5371:   }",
          "5372:   return mp4box_cleanup(1);",
          "5373:  }",
          "5374:  if (!strcmp(inName, \"std\")) dump_std = 2;",
          "5375:  if (!strcmp(inName, \"stdb\")) {",
          "5376:   inName = \"std\";",
          "5377:   dump_std = 1;",
          "5378:  }",
          "5380:  if (!interleaving_time) {",
          "5382:   if (dash_duration)",
          "5383:    interleaving_time = dash_duration;",
          "5384:   else if (!do_flat) {",
          "5385:    interleaving_time = DEFAULT_INTERLEAVING_IN_SEC;",
          "5386:   }",
          "5387:  }",
          "5389:  if (dump_std)",
          "5390:   outName = \"std\";",
          "5392:  if (dump_std==2) {",
          "5393: #ifdef WIN32",
          "5394:   if ( _setmode(_fileno(stdout), _O_BINARY) == -1 )",
          "5395: #else",
          "5396:   if ( freopen(NULL, \"wb\", stdout) == NULL)",
          "5397: #endif",
          "5398:   {",
          "5399:    M4_LOG(GF_LOG_ERROR, (\"Fatal error: cannot reopen stdout in binary mode.\\n\"));",
          "5400:    return mp4box_cleanup(1);",
          "5401:   }",
          "5402:  }",
          "5404:  GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO;",
          "5405:  gf_log_set_tool_level(GF_LOG_CONTAINER, level);",
          "5406:  gf_log_set_tool_level(GF_LOG_SCENE, level);",
          "5407:  gf_log_set_tool_level(GF_LOG_PARSER, level);",
          "5408:  gf_log_set_tool_level(GF_LOG_AUTHOR, level);",
          "5409:  gf_log_set_tool_level(GF_LOG_CODING, level);",
          "5410:  gf_log_set_tool_level(GF_LOG_DASH, level);",
          "5411: #ifdef GPAC_MEMORY_TRACKING",
          "5412:  if (mem_track)",
          "5413:   gf_log_set_tool_level(GF_LOG_MEMORY, level);",
          "5414: #endif",
          "5416:  e = gf_sys_set_args(argc, (const char **) argv);",
          "5417:  if (e) {",
          "5418:   M4_LOG(GF_LOG_ERROR, (\"Error assigning libgpac arguments: %s\\n\", gf_error_to_string(e) ));",
          "5419:   return mp4box_cleanup(1);",
          "5420:  }",
          "5422:  if (raw_cat)",
          "5423:   return do_raw_cat();",
          "5425:  if (compress_top_boxes) {",
          "5426:   if (size_top_box) {",
          "5427:    u64 top_size = do_size_top_boxes(inName, compress_top_boxes, size_top_box);",
          "5428:    fprintf(stdout, LLU\"\\n\", top_size);",
          "5429:    return mp4box_cleanup(e ? 1 : 0);",
          "5430:   } else {",
          "5431:    e = do_compress_top_boxes(inName, outName);",
          "5432:    return mp4box_cleanup(e ? 1 : 0);",
          "5433:   }",
          "5434:  }",
          "5436:  if (do_mpd_rip) {",
          "5437:   e = rip_mpd(inName, outName);",
          "5438:   return mp4box_cleanup(e ? 1 : 0);",
          "5439:  }",
          "5441: #ifndef GPAC_DISABLE_CORE_TOOLS",
          "5442:  if (do_wget != NULL) {",
          "5443:   e = gf_dm_wget(do_wget, inName, 0, 0, NULL);",
          "5444:   if (e != GF_OK) {",
          "5445:    M4_LOG(GF_LOG_ERROR, (\"Cannot retrieve %s: %s\\n\", do_wget, gf_error_to_string(e) ));",
          "5446:    return mp4box_cleanup(1);",
          "5447:   }",
          "5448:   return mp4box_cleanup(0);",
          "5449:  }",
          "5450: #endif",
          "5452:  if (udp_dest)",
          "5453:   return do_write_udp();",
          "5455: #ifndef GPAC_DISABLE_MPD",
          "5456:  if (do_mpd_conv)",
          "5457:   return convert_mpd();",
          "5458: #endif",
          "5460:  if (dash_duration && !nb_dash_inputs) {",
          "5461:   dash_inputs = set_dash_input(dash_inputs, inName, &nb_dash_inputs);",
          "5462:  }",
          "5464:  if (do_saf && !encode) {",
          "5465:   switch (get_file_type_by_ext(inName)) {",
          "5466:   case GF_FILE_TYPE_BT_WRL_X3DV:",
          "5467:   case GF_FILE_TYPE_XMT_X3D:",
          "5468:   case GF_FILE_TYPE_SVG:",
          "5469:    encode = GF_TRUE;",
          "5470:    break;",
          "5471:   case GF_FILE_TYPE_NOT_SUPPORTED:",
          "5472:   case GF_FILE_TYPE_ISO_MEDIA:",
          "5473:   case GF_FILE_TYPE_SWF:",
          "5474:   case GF_FILE_TYPE_LSR_SAF:",
          "5475:    break;",
          "5476:   }",
          "5477:  }",
          "5479: #ifndef GPAC_DISABLE_SCENE_DUMP",
          "5480:  if (dump_mode == GF_SM_DUMP_SVG) {",
          "5481:   if (strstr(inName, \".srt\") || strstr(inName, \".ttxt\")) import_subtitle = 2;",
          "5482:  }",
          "5483: #endif",
          "5485:  if (import_subtitle && !trackID)",
          "5486:   return do_import_sub();",
          "5489: #if !defined(GPAC_DISABLE_MEDIA_IMPORT) && !defined(GPAC_DISABLE_ISOM_WRITE)",
          "5490:  if (nb_add || nb_cat) {",
          "5491:   u32 res = do_add_cat(argc, argv);",
          "5492:   if (res) return res;",
          "5493:  }",
          "5496: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "5497:  else if (chunk_mode) {",
          "5498:   if (!inName) {",
          "5499:    M4_LOG(GF_LOG_ERROR, (\"chunk encoding syntax: [-outctx outDump] -inctx inScene auFile\\n\"));",
          "5500:    return mp4box_cleanup(1);",
          "5501:   }",
          "5502:   e = EncodeFileChunk(inName, outName ? outName : inName, input_ctx, output_ctx, tmpdir);",
          "5503:   if (e) {",
          "5504:    M4_LOG(GF_LOG_ERROR, (\"Error encoding chunk file %s\\n\", gf_error_to_string(e)));",
          "5505:    return mp4box_cleanup(1);",
          "5506:   }",
          "5507:   goto exit;",
          "5508:  }",
          "5509: #endif // !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "5511:  else if (encode) {",
          "5512: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "5513:   e = do_scene_encode();",
          "5514:   if (e) goto err_exit;",
          "5515: #endif //!defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_SCENE_ENCODER) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "5516:  }",
          "5518: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "5519:  else if (pack_file) {",
          "5520:   char *fileName = gf_url_colon_suffix(pack_file);",
          "5521:   if (fileName && ((fileName - pack_file)==4)) {",
          "5522:    fileName[0] = 0;",
          "5523:    file = package_file(fileName + 1, pack_file, tmpdir, pack_wgt);",
          "5524:    fileName[0] = ':';",
          "5525:   } else {",
          "5526:    file = package_file(pack_file, NULL, tmpdir, pack_wgt);",
          "5527:    if (!file) {",
          "5528:     M4_LOG(GF_LOG_ERROR, (\"Failed to package file\\n\"));",
          "5529:     return mp4box_cleanup(1);",
          "5530:    }",
          "5531:   }",
          "5532:   if (!outName) outName = inName;",
          "5533:   do_save = GF_TRUE;",
          "5534:   open_edit = GF_TRUE;",
          "5535:  }",
          "5536: #endif //GPAC_DISABLE_ISOM_WRITE",
          "5538:  if (dash_duration) {",
          "5539:   e = do_dash();",
          "5545:  if (!file && !do_hash",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "4745:     if (file) {",
          "4746:      e = gf_isom_open_segment(file, inName, 0, 0, 0);",
          "4747:      if (e) {",
          "4749:       gf_isom_delete(file);",
          "4750:       file = NULL;",
          "4751:      }",
          "",
          "[Removed Lines]",
          "4748:       fprintf(stderr, \"Error opening segment %s: %s\\n\", inName, gf_error_to_string(e) );",
          "",
          "[Added Lines]",
          "5572:       M4_LOG(GF_LOG_ERROR, (\"Error opening segment %s: %s\\n\", inName, gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "4757:    if (!file && (gf_isom_last_error(NULL) == GF_ISOM_INCOMPLETE_FILE) && !open_edit) {",
          "4758:     u64 missing_bytes;",
          "4759:     e = gf_isom_open_progressive(inName, 0, 0, GF_FALSE, &file, &missing_bytes);",
          "4761:    }",
          "4763:    if (!file) {",
          "",
          "[Removed Lines]",
          "4760:     fprintf(stderr, \"Truncated file - missing \"LLD\" bytes\\n\", missing_bytes);",
          "",
          "[Added Lines]",
          "5584:     M4_LOG(GF_LOG_ERROR, (\"Truncated file - missing \"LLD\" bytes\\n\", missing_bytes));",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "4767:     }",
          "4769:     if (!file) {",
          "4771:      return mp4box_cleanup(1);",
          "4772:     }",
          "4773:    }",
          "",
          "[Removed Lines]",
          "4770:      fprintf(stderr, \"Error opening file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL)));",
          "",
          "[Added Lines]",
          "5594:      M4_LOG(GF_LOG_ERROR, (\"Error opening file %s: %s\\n\", inName, gf_error_to_string(gf_isom_last_error(NULL))));",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "4811:      import.flags = GF_IMPORT_MPE_DEMUX;",
          "4812:      e = gf_media_import(&import);",
          "4813:      if (e) {",
          "4815:       gf_isom_delete(file);",
          "4816:       gf_file_delete(\"ttxt_convert\");",
          "4817:       return mp4box_cleanup(1);",
          "",
          "[Removed Lines]",
          "4814:       fprintf(stderr, \"Error importing %s: %s\\n\", inName, gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "5638:       M4_LOG(GF_LOG_ERROR, (\"Error importing %s: %s\\n\", inName, gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "4838:      convert_file_info(inName, info_track_id);",
          "4839: #endif",
          "4840:     } else {",
          "4842:      return mp4box_cleanup(1);",
          "4843:     }",
          "4844:     goto exit;",
          "",
          "[Removed Lines]",
          "4841:      fprintf(stderr, \"Input %s is not an MP4 file, operation not allowed\\n\", inName);",
          "",
          "[Added Lines]",
          "5665:      M4_LOG(GF_LOG_ERROR, (\"Input %s is not an MP4 file, operation not allowed\\n\", inName));",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "4848:     file = gf_isom_open(inName, GF_ISOM_WRITE_EDIT, tmpdir);",
          "4849:     if (!outName && file) outName = inName;",
          "4850:    } else if (!file_exists) {",
          "4852:     return mp4box_cleanup(1);",
          "4853:    } else {",
          "4855:     return mp4box_cleanup(1);",
          "4856:    }",
          "4857:   }",
          "",
          "[Removed Lines]",
          "4851:     fprintf(stderr, \"Error creating file %s: %s\\n\", inName, gf_error_to_string(GF_URL_ERROR));",
          "4854:     fprintf(stderr, \"Cannot open %s - extension not supported\\n\", inName);",
          "",
          "[Added Lines]",
          "5675:     M4_LOG(GF_LOG_ERROR, (\"Error creating file %s: %s\\n\", inName, gf_error_to_string(GF_URL_ERROR)));",
          "5678:     M4_LOG(GF_LOG_ERROR, (\"Cannot open %s - extension not supported\\n\", inName));",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "4871:   return mp4box_cleanup(1);",
          "4872:  }",
          "4893:  }",
          "4895: #ifndef GPAC_DISABLE_MEDIA_EXPORT",
          "4896:  if (track_dump_type & GF_EXPORT_AVI_NATIVE) {",
          "4917:   if (e) goto err_exit;",
          "4918:   goto exit;",
          "4919:  }",
          "4920:  if (!open_edit && track_dump_type && !gf_isom_probe_file(inName)) {",
          "4944:   goto exit;",
          "4945:  }",
          "",
          "[Removed Lines]",
          "4874:  {",
          "4876:   char *szExt = gf_file_ext_start(outfile);",
          "4878:   if (szExt)",
          "4879:   {",
          "4881:    if (!stricmp(szExt, \".3gp\") || !stricmp(szExt, \".3gpp\") || !stricmp(szExt, \".3g2\"))",
          "4882:     conv_type = GF_ISOM_CONV_TYPE_3GPP;",
          "4883:    else if (!stricmp(szExt, \".m4a\") || !stricmp(szExt, \".m4v\"))",
          "4884:     conv_type = GF_ISOM_CONV_TYPE_IPOD;",
          "4885:    else if (!stricmp(szExt, \".psp\"))",
          "4886:     conv_type = GF_ISOM_CONV_TYPE_PSP;",
          "4887:    else if (!stricmp(szExt, \".mov\") || !stricmp(szExt, \".qt\"))",
          "4888:     conv_type = GF_ISOM_CONV_TYPE_MOV;",
          "4892:   }",
          "4897:   char szFile[GF_MAX_PATH+24];",
          "4898:   GF_MediaExporter mdump;",
          "4899:   memset(&mdump, 0, sizeof(mdump));",
          "4900:   mdump.in_name = inName;",
          "4901:   mdump.flags = GF_EXPORT_AVI_NATIVE;",
          "4902:   mdump.trackID = trackID;",
          "4903:   if (dump_std) {",
          "4904:    mdump.out_name = \"std\";",
          "4905:   } else if (outName) {",
          "4906:    mdump.out_name = outName;",
          "4907:   } else if (trackID>2) {",
          "4908:    sprintf(szFile, \"%s_audio%d\", outfile, trackID-1);",
          "4909:    mdump.out_name = szFile;",
          "4910:   } else {",
          "4911:    sprintf(szFile, \"%s_%s\", outfile, (trackID==1) ? \"video\" : \"audio\");",
          "4912:    mdump.out_name = szFile;",
          "4913:   }",
          "4915:   mdump.print_stats_graph = fs_dump_flags;",
          "4916:   e = gf_media_export(&mdump);",
          "4921:   GF_MediaExporter mdump;",
          "4922:   char szFile[GF_MAX_PATH+24];",
          "4923:   for (i=0; i<nb_track_act; i++) {",
          "4924:    TrackAction *tka = &tracks[i];",
          "4925:    if (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;",
          "4926:    memset(&mdump, 0, sizeof(mdump));",
          "4927:    mdump.in_name = inName;",
          "4928:    mdump.flags = tka->dump_type;",
          "4929:    mdump.trackID = tka->trackID;",
          "4930:    mdump.sample_num = tka->sample_num;",
          "4931:    if (outName) {",
          "4932:     mdump.out_name = outName;",
          "4933:     mdump.flags |= GF_EXPORT_MERGE;",
          "4934:    } else if (nb_track_act>1) {",
          "4935:     sprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);",
          "4936:     mdump.out_name = szFile;",
          "4937:    } else {",
          "4938:     mdump.out_name = outfile;",
          "4939:    }",
          "4940:    mdump.print_stats_graph = fs_dump_flags;",
          "4941:    e = gf_media_export(&mdump);",
          "4942:    if (e) goto err_exit;",
          "4943:   }",
          "",
          "[Added Lines]",
          "5698:  char *szExt = gf_file_ext_start(outfile);",
          "5699:  if (szExt) {",
          "5701:   if (!stricmp(szExt, \".3gp\") || !stricmp(szExt, \".3gpp\") || !stricmp(szExt, \".3g2\"))",
          "5702:    conv_type = GF_ISOM_CONV_TYPE_3GPP;",
          "5703:   else if (!stricmp(szExt, \".m4a\") || !stricmp(szExt, \".m4v\"))",
          "5704:    conv_type = GF_ISOM_CONV_TYPE_IPOD;",
          "5705:   else if (!stricmp(szExt, \".psp\"))",
          "5706:    conv_type = GF_ISOM_CONV_TYPE_PSP;",
          "5707:   else if (!stricmp(szExt, \".mov\") || !stricmp(szExt, \".qt\"))",
          "5708:    conv_type = GF_ISOM_CONV_TYPE_MOV;",
          "5716:   e = do_export_avi();",
          "5721:   e = do_export_tracks_non_isobmf();",
          "5722:   if (e) goto err_exit;",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "4965:  }",
          "4966:  if (print_info) {",
          "4967:   if (!file) {",
          "4969:   } else {",
          "4970:    if (info_track_id) DumpTrackInfo(file, info_track_id, 1, (print_info==2) ? GF_TRUE : GF_FALSE, GF_FALSE);",
          "4971:    else DumpMovieInfo(file);",
          "",
          "[Removed Lines]",
          "4968:    fprintf(stderr, \"Cannot print info on a non ISOM file (%s)\\n\", inName);",
          "",
          "[Added Lines]",
          "5747:    M4_LOG(GF_LOG_ERROR, (\"Cannot print info on a non ISOM file (%s)\\n\", inName));",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "5015: #endif",
          "5017:  if (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);",
          "5047:  }",
          "5049: #if !defined(GPAC_DISABLE_ISOM_WRITE) && !defined(GPAC_DISABLE_MEDIA_IMPORT)",
          "",
          "[Removed Lines]",
          "5018:  if (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);",
          "5019:  if (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);",
          "5021:  if (dump_iod) {",
          "5022:   GF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);",
          "5023:   if (!iod) {",
          "5024:    fprintf(stderr, \"File %s has no IOD\\n\", inName);",
          "5025:   } else {",
          "5026:    char szName[GF_MAX_PATH+10];",
          "5027:    FILE *iodf;",
          "5028:    sprintf(szName, \"%s.iod\", outfile);",
          "5029:    iodf = gf_fopen(szName, \"wb\");",
          "5030:    if (!iodf) {",
          "5031:     fprintf(stderr, \"Cannot open destination %s\\n\", szName);",
          "5032:    } else {",
          "5033:     u8 *desc;",
          "5034:     u32 size;",
          "5035:     GF_BitStream *bs = gf_bs_from_file(iodf, GF_BITSTREAM_WRITE);",
          "5036:     if (gf_odf_desc_write((GF_Descriptor *)iod, &desc, &size)==GF_OK) {",
          "5037:      gf_fwrite(desc, size, iodf);",
          "5038:      gf_free(desc);",
          "5039:     } else {",
          "5040:      fprintf(stderr, \"Error writing IOD %s\\n\", szName);",
          "5041:     }",
          "5042:     gf_bs_del(bs);",
          "5043:     gf_fclose(iodf);",
          "5044:    }",
          "5045:    gf_odf_desc_del((GF_Descriptor*)iod);",
          "5046:   }",
          "",
          "[Added Lines]",
          "5797:  if (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);",
          "5798:  if (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);",
          "5800:  if (dump_iod) {",
          "5801:   e = do_dump_iod();",
          "5802:   if (e) goto err_exit;",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "5059: #ifndef GPAC_DISABLE_MEDIA_EXPORT",
          "5060:  if (track_dump_type) {",
          "5100:  } else if (do_saf) {",
          "5101:   GF_MediaExporter mdump;",
          "5102:   memset(&mdump, 0, sizeof(mdump));",
          "",
          "[Removed Lines]",
          "5061:   char szFile[GF_MAX_PATH+24];",
          "5062:   GF_MediaExporter mdump;",
          "5063:   for (i=0; i<nb_track_act; i++) {",
          "5064:    TrackAction *tka = &tracks[i];",
          "5065:    if (tka->act_type != TRAC_ACTION_RAW_EXTRACT) continue;",
          "5066:    memset(&mdump, 0, sizeof(mdump));",
          "5067:    mdump.file = file;",
          "5068:    mdump.flags = tka->dump_type;",
          "5069:    mdump.trackID = tka->trackID;",
          "5070:    mdump.sample_num = tka->sample_num;",
          "5071:    if (tka->out_name) {",
          "5072:     mdump.out_name = tka->out_name;",
          "5073:    } else if (outName) {",
          "5074:     mdump.out_name = outName;",
          "5075:     mdump.flags |= GF_EXPORT_MERGE;",
          "5077:     mdump.flags |= GF_EXPORT_NO_FILE_EXT;",
          "5078:    } else if (mdump.trackID) {",
          "5079:     sprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);",
          "5080:     mdump.out_name = szFile;",
          "5081:    } else {",
          "5082:     sprintf(szFile, \"%s_export\", outfile);",
          "5083:     mdump.out_name = szFile;",
          "5084:    }",
          "5085:    if (tka->trackID==(u32) -1) {",
          "5086:     for (j=0; j<gf_isom_get_track_count(file); j++) {",
          "5087:      mdump.trackID = gf_isom_get_track_id(file, j+1);",
          "5088:      sprintf(szFile, \"%s_track%d\", outfile, mdump.trackID);",
          "5089:      mdump.out_name = szFile;",
          "5090:      mdump.print_stats_graph = fs_dump_flags;",
          "5091:      e = gf_media_export(&mdump);",
          "5092:      if (e) goto err_exit;",
          "5093:     }",
          "5094:    } else {",
          "5095:     mdump.print_stats_graph = fs_dump_flags;",
          "5096:     e = gf_media_export(&mdump);",
          "5097:     if (e) goto err_exit;",
          "5098:    }",
          "5099:   }",
          "",
          "[Added Lines]",
          "5817:   e = do_export_tracks();",
          "5818:   if (e) goto err_exit;",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "5109:  }",
          "5110: #endif",
          "5324:  if (!open_edit && !do_save) {",
          "5325:   if (file) gf_isom_delete(file);",
          "5326:   goto exit;",
          "",
          "[Removed Lines]",
          "5112:  for (i=0; i<nb_meta_act; i++) {",
          "5113:   u32 tk = 0;",
          "5114: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "5115:   Bool self_ref;",
          "5116: #endif",
          "5117:   MetaAction *meta = &metas[i];",
          "5119:   if (meta->trackID) tk = gf_isom_get_track_by_id(file, meta->trackID);",
          "5121:   switch (meta->act_type) {",
          "5122: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "5123:   case META_ACTION_SET_TYPE:",
          "5125:    e = gf_isom_set_meta_type(file, meta->root_meta, tk, meta->meta_4cc);",
          "5126:    gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO2, GF_TRUE);",
          "5127:    do_save = GF_TRUE;",
          "5128:    break;",
          "5129:   case META_ACTION_ADD_ITEM:",
          "5130:    self_ref = !stricmp(meta->szPath, \"NULL\") || !stricmp(meta->szPath, \"this\") || !stricmp(meta->szPath, \"self\");",
          "5131:    e = gf_isom_add_meta_item(file, meta->root_meta, tk, self_ref, self_ref ? NULL : meta->szPath,",
          "5132:                              meta->szName,",
          "5133:                              meta->item_id,",
          "5134:            meta->item_type,",
          "5135:                              meta->mime_type,",
          "5136:                              meta->enc_type,",
          "5137:                              meta->use_dref ? meta->szPath : NULL,  NULL,",
          "5138:                              meta->image_props);",
          "5139:    if (meta->item_refs && gf_list_count(meta->item_refs)) {",
          "5140:     u32 ref_i;",
          "5141:     for (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {",
          "5142:      MetaRef *ref_entry = gf_list_get(meta->item_refs, ref_i);",
          "5143:      e = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);",
          "5144:     }",
          "5145:    }",
          "5146:    do_save = GF_TRUE;",
          "5147:    break;",
          "5148:   case META_ACTION_ADD_IMAGE_ITEM:",
          "5149:   {",
          "5150:    u32 old_tk_count = gf_isom_get_track_count(file);",
          "5151:    u32 src_tk_id = 1;",
          "5152:    GF_Fraction _frac = {0,0};",
          "5153:    GF_ISOFile *fsrc = file;",
          "5154:    self_ref = GF_FALSE;",
          "5156:    tk = 0;",
          "5157:    if (meta->image_props && meta->image_props->auto_grid) {",
          "5158:     e = GF_OK;",
          "5159:     self_ref = GF_TRUE;",
          "5160:    } else if (!meta->szPath || (meta->image_props && meta->image_props->sample_num && meta->image_props->use_reference)) {",
          "5161:     e = GF_OK;",
          "5162:     self_ref = GF_TRUE;",
          "5163:     src_tk_id = meta->trackID;",
          "5164:    } else if (meta->szPath) {",
          "5165:     if (meta->image_props && gf_isom_probe_file(meta->szPath) && !meta->image_props->tile_mode) {",
          "5166:      meta->image_props->src_file = gf_isom_open(meta->szPath, GF_ISOM_OPEN_READ, NULL);",
          "5167:      e = gf_isom_last_error(meta->image_props->src_file);",
          "5168:      fsrc = meta->image_props->src_file;",
          "5169:     } else {",
          "5170:      e = import_file(file, meta->szPath, 0, _frac, 0, NULL, NULL, 0);",
          "5171:     }",
          "5172:    } else {",
          "5173:     fprintf(stderr, \"Missing file name to import\\n\");",
          "5174:     e = GF_BAD_PARAM;",
          "5175:    }",
          "5176:    if (e == GF_OK) {",
          "5177:     u32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);",
          "5178:     if (!meta_type) {",
          "5179:      e = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);",
          "5180:     } else {",
          "5181:      if (meta_type != GF_META_ITEM_TYPE_PICT) {",
          "5182:       GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));",
          "5183:       e = GF_BAD_PARAM;",
          "5184:      }",
          "5185:     }",
          "5186:     if (e == GF_OK) {",
          "5187:      if (!meta->item_id) {",
          "5188:       e = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);",
          "5189:      }",
          "5190:      if (e == GF_OK) {",
          "5191:       if (!src_tk_id) {",
          "5192:        for (j=0; j<gf_isom_get_track_count(fsrc); j++) {",
          "5193:         if (gf_isom_is_video_handler_type (gf_isom_get_media_type(fsrc, j+1))) {",
          "5194:          src_tk_id = gf_isom_get_track_id(fsrc, j+1);",
          "5195:          break;",
          "5196:         }",
          "5197:        }",
          "5199:        if (!src_tk_id) {",
          "5200:         fprintf(stderr, \"No video track in file, cannot add image from track\\n\");",
          "5201:         e = GF_BAD_PARAM;",
          "5202:         break;",
          "5203:        }",
          "5204:       }",
          "5206:       e = gf_isom_iff_create_image_item_from_track(file, meta->root_meta, tk, src_tk_id, meta->szName, meta->item_id, meta->image_props, NULL);",
          "5207:       if (e == GF_OK && meta->primary) {",
          "5208:        e = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);",
          "5209:       }",
          "5210:       if (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {",
          "5211:        u32 ref_i;",
          "5212:        for (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {",
          "5213:         MetaRef *ref_entry = gf_list_get(meta->item_refs, ref_i);",
          "5214:         e = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);",
          "5215:        }",
          "5216:       }",
          "5217:       if (e == GF_OK && meta->group_type) {",
          "5218:        e = gf_isom_meta_add_item_group(file, meta->root_meta, tk, meta->item_id, meta->group_id, meta->group_type);",
          "5219:       }",
          "5220:      }",
          "5221:     }",
          "5222:    }",
          "5223:    if (meta->image_props && meta->image_props->src_file) {",
          "5224:     gf_isom_delete(meta->image_props->src_file);",
          "5225:     meta->image_props->src_file = NULL;",
          "5226:    } else if (!self_ref) {",
          "5227:     gf_isom_remove_track(file, old_tk_count+1);",
          "5228:     if (do_flat) {",
          "5229:      GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Warning: -flat storage cannot be used when using -add-image on external file\\n\"));",
          "5230:      e = GF_NOT_SUPPORTED;",
          "5231:     }",
          "5232:    }",
          "5233:    do_save = GF_TRUE;",
          "5234:   }",
          "5235:    break;",
          "5236:   case META_ACTION_ADD_IMAGE_GRID:",
          "5237:    {",
          "5238:     u32 meta_type = gf_isom_get_meta_type(file, meta->root_meta, tk);",
          "5239:     if (!meta_type) {",
          "5240:      e = gf_isom_set_meta_type(file, meta->root_meta, tk, GF_META_ITEM_TYPE_PICT);",
          "5241:     } else {",
          "5242:      if (meta_type != GF_META_ITEM_TYPE_PICT) {",
          "5243:       GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Warning: file already has a root 'meta' box of type %s\\n\", gf_4cc_to_str(meta_type)));",
          "5244:       e = GF_BAD_PARAM;",
          "5245:      }",
          "5246:     }",
          "5247:     if (e == GF_OK) {",
          "5248:      if (!meta->item_id) {",
          "5249:       e = gf_isom_meta_get_next_item_id(file, meta->root_meta, tk, &meta->item_id);",
          "5250:      }",
          "5251:      if (e == GF_OK) {",
          "5252:       e = gf_isom_iff_create_image_grid_item(file, meta->root_meta, tk,",
          "5253:            meta->szName && strlen(meta->szName) ? meta->szName : NULL,",
          "5254:         meta->item_id,",
          "5255:         meta->image_props);",
          "5256:       if (e == GF_OK && meta->primary) {",
          "5257:        e = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);",
          "5258:       }",
          "5259:       if (e == GF_OK && meta->item_refs && gf_list_count(meta->item_refs)) {",
          "5260:        u32 ref_i;",
          "5261:        for (ref_i = 0; ref_i < gf_list_count(meta->item_refs); ref_i++) {",
          "5262:         MetaRef *ref_entry = gf_list_get(meta->item_refs, ref_i);",
          "5263:         e = gf_isom_meta_add_item_ref(file, meta->root_meta, tk, meta->item_id, ref_entry->ref_item_id, ref_entry->ref_type, NULL);",
          "5264:        }",
          "5265:       }",
          "5266:      }",
          "5267:     }",
          "5268:     do_save = GF_TRUE;",
          "5269:    }",
          "5270:    break;",
          "5271:   case META_ACTION_REM_ITEM:",
          "5272:    e = gf_isom_remove_meta_item(file, meta->root_meta, tk, meta->item_id);",
          "5273:    do_save = GF_TRUE;",
          "5274:    break;",
          "5275:   case META_ACTION_SET_PRIMARY_ITEM:",
          "5276:    e = gf_isom_set_meta_primary_item(file, meta->root_meta, tk, meta->item_id);",
          "5277:    do_save = GF_TRUE;",
          "5278:    break;",
          "5279:   case META_ACTION_SET_XML:",
          "5280:   case META_ACTION_SET_BINARY_XML:",
          "5281:    e = gf_isom_set_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL, 0, (meta->act_type==META_ACTION_SET_BINARY_XML) ? 1 : 0);",
          "5282:    do_save = GF_TRUE;",
          "5283:    break;",
          "5284:   case META_ACTION_REM_XML:",
          "5285:    if (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {",
          "5286:     e = gf_isom_remove_meta_xml(file, meta->root_meta, tk);",
          "5287:     do_save = GF_TRUE;",
          "5288:    } else {",
          "5289:     fprintf(stderr, \"No meta box in input file\\n\");",
          "5290:    }",
          "5291:    break;",
          "5292:   case META_ACTION_DUMP_ITEM:",
          "5293:    if (gf_isom_get_meta_item_count(file, meta->root_meta, tk)) {",
          "5294:     e = gf_isom_extract_meta_item(file, meta->root_meta, tk, meta->item_id, meta->szPath && strlen(meta->szPath) ? meta->szPath : NULL);",
          "5295:    } else {",
          "5296:     fprintf(stderr, \"No meta box in input file\\n\");",
          "5297:    }",
          "5298:    break;",
          "5299: #endif // GPAC_DISABLE_ISOM_WRITE",
          "5301:   case META_ACTION_DUMP_XML:",
          "5302:    if (gf_isom_has_meta_xml(file, meta->root_meta, tk)) {",
          "5303:     e = gf_isom_extract_meta_xml(file, meta->root_meta, tk, meta->szPath, NULL);",
          "5304:    } else {",
          "5305:     fprintf(stderr, \"No meta box in input file\\n\");",
          "5306:    }",
          "5307:    break;",
          "5308:   default:",
          "5309:    break;",
          "5310:   }",
          "5311:   if (meta->item_refs) {",
          "5312:    while (gf_list_count(meta->item_refs)) {",
          "5313:     gf_free(gf_list_pop_back(meta->item_refs));",
          "5314:    }",
          "5315:    gf_list_del(meta->item_refs);",
          "5316:    meta->item_refs = NULL;",
          "5317:   }",
          "5318:   if (meta->image_props) {",
          "5319:    gf_free(meta->image_props);",
          "5320:    meta->image_props = NULL;",
          "5321:   }",
          "5322:   if (e) goto err_exit;",
          "5323:  }",
          "",
          "[Added Lines]",
          "5831:  e = do_meta_act();",
          "5832:  if (e) goto err_exit;",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "5330: #ifndef GPAC_DISABLE_ISOM_WRITE",
          "5370:  }",
          "5372:  if (remove_sys_tracks) {",
          "5373: #ifndef GPAC_DISABLE_AV_PARSERS",
          "5374:   remove_systems_tracks(file);",
          "",
          "[Removed Lines]",
          "5331:  if (clean_groups) {",
          "5332:   e = gf_isom_reset_switch_parameters(file);",
          "5333:   if (e) goto err_exit;",
          "5334:   do_save = GF_TRUE;",
          "5335:  }",
          "5337:  for (i=0; i<nb_tsel_acts; i++) {",
          "5338:   switch (tsel_acts[i].act_type) {",
          "5339:   case TSEL_ACTION_SET_PARAM:",
          "5340:    e = gf_isom_set_track_switch_parameter(file,",
          "5341:                                           gf_isom_get_track_by_id(file, tsel_acts[i].trackID),",
          "5342:                                           tsel_acts[i].refTrackID ? gf_isom_get_track_by_id(file, tsel_acts[i].refTrackID) : 0,",
          "5343:                                           tsel_acts[i].is_switchGroup ? 1 : 0,",
          "5344:                                           &tsel_acts[i].switchGroupID,",
          "5345:                                           tsel_acts[i].criteria, tsel_acts[i].nb_criteria);",
          "5346:    if (e == GF_BAD_PARAM) {",
          "5347:     u32 alternateGroupID, nb_groups;",
          "5348:     gf_isom_get_track_switch_group_count(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), &alternateGroupID, &nb_groups);",
          "5349:     if (alternateGroupID)",
          "5350:      fprintf(stderr, \"Hint: for adding more tracks to group, using: -group-add -refTrack=ID1:[criteria:]trackID=ID2\\n\");",
          "5351:     else",
          "5352:      fprintf(stderr, \"Hint: for creates a new grouping information, using -group-add -trackID=ID1:[criteria:]trackID=ID2\\n\");",
          "5353:    }",
          "5354:    if (e) goto err_exit;",
          "5355:    do_save = GF_TRUE;",
          "5356:    break;",
          "5357:   case TSEL_ACTION_REMOVE_TSEL:",
          "5358:    e = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 0);",
          "5359:    if (e) goto err_exit;",
          "5360:    do_save = GF_TRUE;",
          "5361:    break;",
          "5362:   case TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP:",
          "5363:    e = gf_isom_reset_track_switch_parameter(file, gf_isom_get_track_by_id(file, tsel_acts[i].trackID), 1);",
          "5364:    if (e) goto err_exit;",
          "5365:    do_save = GF_TRUE;",
          "5366:    break;",
          "5367:   default:",
          "5368:    break;",
          "5369:   }",
          "",
          "[Added Lines]",
          "5841:  if (clean_groups) {",
          "5842:   e = gf_isom_reset_switch_parameters(file);",
          "5843:   if (e) goto err_exit;",
          "5844:   do_save = GF_TRUE;",
          "5848:  e = do_tsel_act();",
          "5849:  if (e) goto err_exit;",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "5384:  if (remove_hint) {",
          "5385:   for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5386:    if (gf_isom_get_media_type(file, i+1) == GF_ISOM_MEDIA_HINT) {",
          "5388:     gf_isom_remove_track(file, i+1);",
          "5389:     i--;",
          "5390:    }",
          "",
          "[Removed Lines]",
          "5387:     fprintf(stderr, \"Removing hint track ID %d\\n\", gf_isom_get_track_id(file, i+1));",
          "",
          "[Added Lines]",
          "5866:     M4_LOG(GF_LOG_INFO, (\"Removing hint track ID %d\\n\", gf_isom_get_track_id(file, i+1)));",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "5402:  if (!encode) {",
          "5403:   if (!file) {",
          "5405:    goto exit;",
          "5406:   }",
          "5407:   if (outName) {",
          "",
          "[Removed Lines]",
          "5404:    fprintf(stderr, \"Nothing to do - exiting\\n\");",
          "",
          "[Added Lines]",
          "5883:    M4_LOG(GF_LOG_INFO, (\"Nothing to do - exiting\\n\"));",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "5427:   }",
          "5428: #ifndef GPAC_DISABLE_MEDIA_IMPORT",
          "5429:   if ((conv_type == GF_ISOM_CONV_TYPE_ISMA) || (conv_type == GF_ISOM_CONV_TYPE_ISMA_EX)) {",
          "5432:    e = gf_media_make_isma(file, crypt ? 1 : 0, GF_FALSE, (conv_type==GF_ISOM_CONV_TYPE_ISMA_EX) ? 1 : 0);",
          "5433:    if (e) goto err_exit;",
          "5434:    do_save = GF_TRUE;",
          "5435:   }",
          "5436:   if (conv_type == GF_ISOM_CONV_TYPE_3GPP) {",
          "5438:    e = gf_media_make_3gpp(file);",
          "5439:    if (e) goto err_exit;",
          "5440:    do_save = GF_TRUE;",
          "5441:   }",
          "5442:   if (conv_type == GF_ISOM_CONV_TYPE_PSP) {",
          "5444:    e = gf_media_make_psp(file);",
          "5445:    if (e) goto err_exit;",
          "5446:    do_save = GF_TRUE;",
          "",
          "[Removed Lines]",
          "5430:    fprintf(stderr, \"Converting to ISMA Audio-Video MP4 file...\\n\");",
          "5437:    fprintf(stderr, \"Converting to 3GP file...\\n\");",
          "5443:    fprintf(stderr, \"Converting to PSP file...\\n\");",
          "",
          "[Added Lines]",
          "5909:    M4_LOG(GF_LOG_INFO, (\"Converting to ISMA Audio-Video MP4 file\\n\"));",
          "5916:    M4_LOG(GF_LOG_INFO, (\"Converting to 3GP file\\n\"));",
          "5922:    M4_LOG(GF_LOG_INFO, (\"Converting to PSP file\\n\"));",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "5453:   }",
          "5455:   if (conv_type == GF_ISOM_CONV_TYPE_IPOD) {",
          "5501:   }",
          "5503:  } else if (outName) {",
          "5504:   strcpy(outfile, outName);",
          "5505:  }",
          "5696:  if (itunes_tags) {",
          "5785:  }",
          "5787:  if (cprt) {",
          "",
          "[Removed Lines]",
          "5456:    u32 ipod_major_brand = 0;",
          "5457:    fprintf(stderr, \"Setting up iTunes/iPod file...\\n\");",
          "5459:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5460:     u32 mType = gf_isom_get_media_type(file, i+1);",
          "5461:     switch (mType) {",
          "5462:     case GF_ISOM_MEDIA_VISUAL:",
          "5463:                 case GF_ISOM_MEDIA_AUXV:",
          "5464:                 case GF_ISOM_MEDIA_PICT:",
          "5465:      ipod_major_brand = GF_ISOM_BRAND_M4V;",
          "5466:      gf_isom_set_ipod_compatible(file, i+1);",
          "5467:      break;",
          "5468:     case GF_ISOM_MEDIA_AUDIO:",
          "5469:      if (!ipod_major_brand) ipod_major_brand = GF_ISOM_BRAND_M4A;",
          "5470:      else gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_M4A, GF_TRUE);",
          "5471:      break;",
          "5472:     case GF_ISOM_MEDIA_TEXT:",
          "5474:      if (gf_isom_get_media_subtype(file, i+1, 1) == GF_ISOM_SUBTYPE_TX3G) {",
          "5475:       Bool is_chap = 0;",
          "5476:       for (j=0; j<gf_isom_get_track_count(file); j++) {",
          "5477:        s32 count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_CHAP);",
          "5478:        if (count>0) {",
          "5479:         u32 tk, k;",
          "5480:         for (k=0; k<(u32) count; k++) {",
          "5481:          gf_isom_get_reference(file, j+1, GF_ISOM_REF_CHAP, k+1, &tk);",
          "5482:          if (tk==i+1) {",
          "5483:           is_chap = 1;",
          "5484:           break;",
          "5485:          }",
          "5486:         }",
          "5487:         if (is_chap) break;",
          "5488:        }",
          "5489:        if (is_chap) break;",
          "5490:       }",
          "5492:       if (!is_chap)",
          "5493:        gf_isom_set_media_type(file, i+1, GF_ISOM_MEDIA_SUBT);",
          "5494:      }",
          "5495:      break;",
          "5496:     }",
          "5497:    }",
          "5498:    gf_isom_set_brand_info(file, ipod_major_brand, 1);",
          "5499:    gf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_MP42, GF_TRUE);",
          "5500:    do_save = GF_TRUE;",
          "5507:  for (j=0; j<nb_track_act; j++) {",
          "5508:   TrackAction *tka = &tracks[j];",
          "5509:   u32 track = tka->trackID ? gf_isom_get_track_by_id(file, tka->trackID) : 0;",
          "5511:   timescale = gf_isom_get_timescale(file);",
          "5512:   switch (tka->act_type) {",
          "5513:   case TRAC_ACTION_REM_TRACK:",
          "5514:    e = gf_isom_remove_track(file, track);",
          "5515:    if (e) {",
          "5516:     fprintf(stderr, \"Error Removing track ID %d: %s\\n\", tka->trackID, gf_error_to_string(e));",
          "5517:    } else {",
          "5518:     fprintf(stderr, \"Removing track ID %d\\n\", tka->trackID);",
          "5519:    }",
          "5520:    do_save = GF_TRUE;",
          "5521:    break;",
          "5522:   case TRAC_ACTION_SET_LANGUAGE:",
          "5523:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5524:     if (track && (track != i+1)) continue;",
          "5525:     e = gf_isom_set_media_language(file, i+1, tka->lang);",
          "5526:     if (e) goto err_exit;",
          "5527:     do_save = GF_TRUE;",
          "5528:    }",
          "5529:    do_save = GF_TRUE;",
          "5530:    break;",
          "5531:   case TRAC_ACTION_SET_KIND:",
          "5532:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5533:     if (track && (track != i+1)) continue;",
          "5534:     e = gf_isom_add_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "5535:     if (e) goto err_exit;",
          "5536:     do_save = GF_TRUE;",
          "5537:    }",
          "5538:    do_save = GF_TRUE;",
          "5539:    break;",
          "5540:   case TRAC_ACTION_REM_KIND:",
          "5541:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5542:     if (track && (track != i+1)) continue;",
          "5543:     e = gf_isom_remove_track_kind(file, i+1, tka->kind_scheme, tka->kind_value);",
          "5544:     if (e) goto err_exit;",
          "5545:     do_save = GF_TRUE;",
          "5546:    }",
          "5547:    do_save = GF_TRUE;",
          "5548:    break;",
          "5549:   case TRAC_ACTION_SET_DELAY:",
          "5550:    if (tka->delay.num && tka->delay.den) {",
          "5551:     u64 tk_dur;",
          "5553:     gf_isom_remove_edits(file, track);",
          "5554:     tk_dur = gf_isom_get_track_duration(file, track);",
          "5555:     if (gf_isom_get_edits_count(file, track))",
          "5556:      do_save = GF_TRUE;",
          "5557:     if (tka->delay.num>0) {",
          "5559:      gf_isom_append_edit(file, track, ((u64) tka->delay.num) * timescale / tka->delay.den, 0, GF_ISOM_EDIT_EMPTY);",
          "5560:      gf_isom_append_edit(file, track, tk_dur, 0, GF_ISOM_EDIT_NORMAL);",
          "5561:      do_save = GF_TRUE;",
          "5562:     } else {",
          "5564:      u64 to_skip = ((u64) -tka->delay.num) * timescale / tka->delay.den;",
          "5565:      if (to_skip<tk_dur) {",
          "5567:       u64 media_time = ((u64) -tka->delay.num) * gf_isom_get_media_timescale(file, track) / tka->delay.den;",
          "5568:       gf_isom_append_edit(file, track, tk_dur-to_skip, media_time, GF_ISOM_EDIT_NORMAL);",
          "5569:       do_save = GF_TRUE;",
          "5570:      } else {",
          "5571:       fprintf(stderr, \"Warning: request negative delay longer than track duration - ignoring\\n\");",
          "5572:      }",
          "5573:     }",
          "5574:    } else if (gf_isom_get_edits_count(file, track)) {",
          "5575:     gf_isom_remove_edits(file, track);",
          "5576:     do_save = GF_TRUE;",
          "5577:    }",
          "5578:    break;",
          "5579:   case TRAC_ACTION_SET_KMS_URI:",
          "5580:    for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5581:     if (track && (track != i+1)) continue;",
          "5582:     if (!gf_isom_is_media_encrypted(file, i+1, 1)) continue;",
          "5583:     if (!gf_isom_is_ismacryp_media(file, i+1, 1)) continue;",
          "5584:     e = gf_isom_change_ismacryp_protection(file, i+1, 1, NULL, (char *) tka->kms);",
          "5585:     if (e) goto err_exit;",
          "5586:     do_save = GF_TRUE;",
          "5587:    }",
          "5588:    break;",
          "5589:   case TRAC_ACTION_SET_ID:",
          "5590:    if (!tka->trackID && (gf_isom_get_track_count(file) == 1)) {",
          "5591:     fprintf(stderr, \"Warning: track id is not specified, but file has only one track - assume that you want to change id for this track\\n\");",
          "5592:     track = 1;",
          "5593:    }",
          "5594:    if (track) {",
          "5595:     u32 newTrack;",
          "5596:     newTrack = gf_isom_get_track_by_id(file, tka->newTrackID);",
          "5597:     if (newTrack != 0) {",
          "5598:      fprintf(stderr, \"Error: Cannot set track id with value %d because a track already exists - ignoring\", tka->newTrackID);",
          "5599:     } else {",
          "5600:      e = gf_isom_set_track_id(file, track, tka->newTrackID);",
          "5601:      do_save = GF_TRUE;",
          "5602:     }",
          "5603:    } else {",
          "5604:     fprintf(stderr, \"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID);",
          "5605:    }",
          "5606:    break;",
          "5607:   case TRAC_ACTION_SWAP_ID:",
          "5608:    if (track) {",
          "5609:     u32 tk1, tk2;",
          "5610:     tk1 = gf_isom_get_track_by_id(file, tka->trackID);",
          "5611:     tk2 = gf_isom_get_track_by_id(file, tka->newTrackID);",
          "5612:     if (!tk1 || !tk2) {",
          "5613:      fprintf(stderr, \"Error: Cannot swap track IDs because not existing - ignoring\");",
          "5614:     } else {",
          "5615:      e = gf_isom_set_track_id(file, tk2, 0);",
          "5616:      if (!e) e = gf_isom_set_track_id(file, tk1, tka->newTrackID);",
          "5617:      if (!e) e = gf_isom_set_track_id(file, tk2, tka->trackID);",
          "5618:      do_save = GF_TRUE;",
          "5619:     }",
          "5620:    } else {",
          "5621:     fprintf(stderr, \"Error: Cannot change id for track %d because it does not exist - ignoring\", tka->trackID);",
          "5622:    }",
          "5623:    break;",
          "5624:   case TRAC_ACTION_SET_PAR:",
          "5625:    e = gf_media_change_par(file, track, tka->par_num, tka->par_den, tka->force_par, tka->rewrite_bs);",
          "5626:    do_save = GF_TRUE;",
          "5627:    break;",
          "5628:   case TRAC_ACTION_SET_CLAP:",
          "5629:    e = gf_isom_set_clean_aperture(file, track, 1, tka->clap_wnum, tka->clap_wden, tka->clap_hnum, tka->clap_hden, tka->clap_honum, tka->clap_hoden, tka->clap_vonum, tka->clap_voden);",
          "5630:    do_save = GF_TRUE;",
          "5631:    break;",
          "5632:   case TRAC_ACTION_SET_MX:",
          "5633:    e = gf_isom_set_track_matrix(file, track, tka->mx);",
          "5634:    do_save = GF_TRUE;",
          "5635:    break;",
          "5636:   case TRAC_ACTION_SET_HANDLER_NAME:",
          "5637:    e = gf_isom_set_handler_name(file, track, tka->hdl_name);",
          "5638:    do_save = GF_TRUE;",
          "5639:    break;",
          "5640:   case TRAC_ACTION_ENABLE:",
          "5641:    if (!gf_isom_is_track_enabled(file, track)) {",
          "5642:     e = gf_isom_set_track_enabled(file, track, GF_TRUE);",
          "5643:     do_save = GF_TRUE;",
          "5644:    }",
          "5645:    break;",
          "5646:   case TRAC_ACTION_DISABLE:",
          "5647:    if (gf_isom_is_track_enabled(file, track)) {",
          "5648:     e = gf_isom_set_track_enabled(file, track, GF_FALSE);",
          "5649:     do_save = GF_TRUE;",
          "5650:    }",
          "5651:    break;",
          "5652:   case TRAC_ACTION_REFERENCE:",
          "5653:    e = gf_isom_set_track_reference(file, track, GF_4CC(tka->lang[0], tka->lang[1], tka->lang[2], tka->lang[3]), tka->newTrackID);",
          "5654:    do_save = GF_TRUE;",
          "5655:    break;",
          "5656:   case TRAC_ACTION_REM_NON_RAP:",
          "5657:    fprintf(stderr, \"Removing non-rap samples from track %d\\n\", tka->trackID);",
          "5658:    e = gf_media_remove_non_rap(file, track, GF_FALSE);",
          "5659:    do_save = GF_TRUE;",
          "5660:    break;",
          "5661:   case TRAC_ACTION_REM_NON_REFS:",
          "5662:    fprintf(stderr, \"Removing non-reference samples from track %d\\n\", tka->trackID);",
          "5663:    e = gf_media_remove_non_rap(file, track, GF_TRUE);",
          "5664:    do_save = GF_TRUE;",
          "5665:    break;",
          "5666:   case TRAC_ACTION_SET_UDTA:",
          "5667:    fprintf(stderr, \"Assigning udta box\\n\");",
          "5668:    e = set_file_udta(file, track, tka->udta_type, tka->string ? tka->string : tka->src_name , tka->sample_num ? GF_TRUE : GF_FALSE, tka->string ? GF_TRUE : GF_FALSE);",
          "5669:    if (e) goto err_exit;",
          "5670:    do_save = GF_TRUE;",
          "5671:    break;",
          "5672:   case TRAC_ACTION_SET_EDITS:",
          "5673:    e = apply_edits(file, track, tka->string);",
          "5674:    do_save = GF_TRUE;",
          "5675:    break;",
          "5676:   case TRAC_ACTION_SET_TIME:",
          "5677:    if (!tka->trackID) {",
          "5678:     e = gf_isom_set_creation_time(file, tka->time, tka->time);",
          "5679:     if (e) goto err_exit;",
          "5680:     for (i=0; i<gf_isom_get_track_count(file); i++) {",
          "5681:      e = gf_isom_set_track_creation_time(file, i+1, tka->time, tka->time);",
          "5682:      if (e) goto err_exit;",
          "5683:     }",
          "5684:    } else {",
          "5685:     e = gf_isom_set_track_creation_time(file, track, tka->time, tka->time);",
          "5686:     if (e) goto err_exit;",
          "5687:    }",
          "5688:    do_save = GF_TRUE;",
          "5689:    break;",
          "5690:   default:",
          "5691:    break;",
          "5692:   }",
          "5693:   if (e) goto err_exit;",
          "5694:  }",
          "5697:   char *itunes_data = NULL;",
          "5698:   char *tags = itunes_tags;",
          "5699:   if (gf_file_exists(itunes_tags)) {",
          "5700:    u32 len;",
          "5701:    e = gf_file_load_data(itunes_tags, (u8 **) &itunes_data, &len);",
          "5702:    if (e) goto err_exit;",
          "5703:    tags = itunes_data;",
          "5704:   }",
          "5706:   while (tags) {",
          "5707:    char *val;",
          "5708:    Bool clear = GF_FALSE;",
          "5709:    u32 tlen, tagtype, itag = 0;",
          "5710:    s32 tag_idx;",
          "5711:    char *sep = itunes_data ? strchr(tags, '\\n') : gf_url_colon_suffix(tags);",
          "5712:    while (sep) {",
          "5713:     char *eq = strchr(sep+1, '=');",
          "5714:     if (eq) eq[0] = 0;",
          "5715:     s32 next_tag_idx = gf_itags_find_by_name(sep+1);",
          "5716:     if ((next_tag_idx<0) && strlen(sep+1)==4)",
          "5717:      next_tag_idx = 0;",
          "5719:     if (eq) eq[0] = '=';",
          "5720:     if (next_tag_idx>=0) {",
          "5721:      sep[0] = 0;",
          "5722:      break;",
          "5723:     }",
          "5724:     sep = itunes_data ? strchr(sep+1, '\\n') : gf_url_colon_suffix(sep+1);",
          "5725:    }",
          "5726:    val = strchr(tags, '=');",
          "5727:    if (val) val[0] = 0;",
          "5728:    if (!strcmp(tags, \"clear\") || !strcmp(tags, \"reset\")) {",
          "5729:     clear = GF_TRUE;",
          "5730:    } else {",
          "5731:     tag_idx = gf_itags_find_by_name(tags);",
          "5732:     if ((tag_idx<0) && (strlen(tags)==4)) {",
          "5733:      itag = GF_4CC(tags[0], tags[1], tags[2], tags[3]);",
          "5734:      tagtype = GF_ITAG_STR;",
          "5735:     }",
          "5736:    }",
          "5737:    if (val) {",
          "5738:     val[0] = '=';",
          "5739:     val++;",
          "5740:    }",
          "5741:    if (!itag && !clear) {",
          "5742:     if (tag_idx<0) {",
          "5743:      fprintf(stderr, \"Invalid iTune tag name \\\"%s\\\" - ignoring\\n\", tags);",
          "5744:      break;",
          "5745:     }",
          "5746:     itag = gf_itags_get_itag(tag_idx);",
          "5747:     tagtype = gf_itags_get_type(tag_idx);",
          "5748:    }",
          "5749:    if (!val || (val[0]==':') || !val[0] || !stricmp(val, \"NULL\") ) val = NULL;",
          "5751:    tlen = val ? (u32) strlen(val) : 0;",
          "5752:    if (clear) {",
          "5753:     e = gf_isom_apple_set_tag(file, GF_ISOM_ITUNE_RESET, NULL, 0, 0, 0);",
          "5755:    }",
          "5756:    else if (val && (tagtype==GF_ITAG_FILE)) {",
          "5757:     u32 flen = (u32) strlen(val);",
          "5758:     u8 *d=NULL;",
          "5759:     while (flen && val[flen-1]=='\\n') flen--;",
          "5760:     val[flen] = 0;",
          "5761:     e = gf_file_load_data(val, (u8 **) &d, &tlen);",
          "5762:     val[flen] = '\\n';",
          "5764:     if (!e)",
          "5765:      e = gf_isom_apple_set_tag(file, itag, d, tlen, 0, 0);",
          "5767:     if (d) gf_free(d);",
          "5768:    } else {",
          "5769:     e = gf_isom_apple_set_tag(file, itag, (u8 *) val, tlen, 0, 0);",
          "5770:    }",
          "5771:    if (e) {",
          "5772:     fprintf(stderr, \"Error assigning tag %s: %s\\n\", tags, gf_error_to_string(e) );",
          "5773:    }",
          "5775:    do_save = GF_TRUE;",
          "5777:    if (sep) {",
          "5778:     sep[0] = itunes_data ? '\\n' : ':';",
          "5779:     tags = sep+1;",
          "5780:    } else {",
          "5781:     tags = NULL;",
          "5782:    }",
          "5783:   }",
          "5784:   if (itunes_data) gf_free(itunes_data);",
          "",
          "[Added Lines]",
          "5935:    do_ipod_conv();",
          "5942:  e = do_track_act();",
          "5943:  if (e) goto err_exit;",
          "5946:   e = do_itunes_tag();",
          "5947:   if (e) goto err_exit;",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "5799:   e = gf_media_import_chapters(file, chap_file, import_fps, chap_qt);",
          "5800:   do_save = GF_TRUE;",
          "5801: #else",
          "5803:   e = GF_NOT_SUPPORTED;",
          "5804: #endif",
          "5805:   if (e) goto err_exit;",
          "",
          "[Removed Lines]",
          "5802:   fprintf(stderr, \"Warning: GPAC compiled without Media Import, chapters can't be imported\\n\");",
          "",
          "[Added Lines]",
          "5965:   M4_LOG(GF_LOG_WARNING, (\"Warning: GPAC compiled without Media Import, chapters can't be imported\\n\"));",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "5820:  if (box_patch_filename) {",
          "5821:   e = gf_isom_apply_box_patch(file, box_patch_trackID, box_patch_filename, GF_FALSE);",
          "5822:   if (e) {",
          "5824:    goto err_exit;",
          "5825:   }",
          "5826:   do_save = GF_TRUE;",
          "",
          "[Removed Lines]",
          "5823:    fprintf(stderr, \"Failed to apply box patch %s: %s\\n\", box_patch_filename, gf_error_to_string(e) );",
          "",
          "[Added Lines]",
          "5986:    M4_LOG(GF_LOG_ERROR, (\"Failed to apply box patch %s: %s\\n\", box_patch_filename, gf_error_to_string(e) ));",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "5829: #ifndef GPAC_DISABLE_CRYPTO",
          "5830:  if (crypt) {",
          "5831:   if (!drm_file && (crypt==1) ) {",
          "5838:    e = GF_BAD_PARAM;",
          "5839:    goto err_exit;",
          "5840:   }",
          "",
          "[Removed Lines]",
          "5832:    fprintf(stderr, \"Missing DRM file location - usage '-%s drm_file input_file\\n\", (crypt==1) ? \"crypt\" : \"decrypt\");",
          "5833:    e = GF_BAD_PARAM;",
          "5834:    goto err_exit;",
          "5835:   }",
          "5836:   if (get_file_type_by_ext(inName) != GF_FILE_TYPE_ISO_MEDIA) {",
          "5837:    fprintf(stderr, \"MP4Box can crypt only ISOMedia File\\n\");",
          "",
          "[Added Lines]",
          "5995:    M4_LOG(GF_LOG_ERROR, (\"Missing DRM file location - usage '-%s drm_file input_file\\n\", (crypt==1) ? \"crypt\" : \"decrypt\"));",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "5871: #ifndef GPAC_DISABLE_ISOM_FRAGMENTS",
          "5872:  if (do_frag) {",
          "5873:   if (!interleaving_time) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC;",
          "5876:   e = gf_media_fragment_file(file, outfile, interleaving_time, use_mfra);",
          "5878:   if (!e && !outName) {",
          "5881:   }",
          "5882:   if (e) goto err_exit;",
          "5883:   gf_isom_delete(file);",
          "",
          "[Removed Lines]",
          "5874:   if (do_hint) fprintf(stderr, \"Warning: cannot hint and fragment - ignoring hint\\n\");",
          "5875:   fprintf(stderr, \"Fragmenting file (%.3f seconds fragments)\\n\", interleaving_time);",
          "5877:   if (e) fprintf(stderr, \"Error while fragmenting file: %s\\n\", gf_error_to_string(e));",
          "5879:    if (gf_file_exists(inName) && gf_file_delete(inName)) fprintf(stderr, \"Error removing file %s\\n\", inName);",
          "5880:    else if (gf_file_move(outfile, inName)) fprintf(stderr, \"Error renaming file %s to %s\\n\", outfile, inName);",
          "",
          "[Added Lines]",
          "6032:   if (do_hint) M4_LOG(GF_LOG_WARNING, (\"Warning: cannot hint and fragment - ignoring hint\\n\"));",
          "6033:   M4_LOG(GF_LOG_INFO, (\"Fragmenting file (%.3f seconds fragments)\\n\", interleaving_time));",
          "6035:   if (e) M4_LOG(GF_LOG_ERROR, (\"Error while fragmenting file: %s\\n\", gf_error_to_string(e)));",
          "6037:    if (gf_file_exists(inName) && gf_file_delete(inName)) {",
          "6038:     M4_LOG(GF_LOG_INFO, (\"Error removing file %s\\n\", inName));",
          "6039:    }",
          "6040:    else if (gf_file_move(outfile, inName)) {",
          "6041:     M4_LOG(GF_LOG_INFO, (\"Error renaming file %s to %s\\n\", outfile, inName));",
          "6042:    }",
          "",
          "---------------",
          "--- Hunk 63 ---",
          "[Context before]",
          "5888: #ifndef GPAC_DISABLE_ISOM_HINTING",
          "5889:  if (do_hint) {",
          "5890:   if (force_ocr) SetupClockReferences(file);",
          "5892:   MTUSize -= 12;",
          "5893:   e = HintFile(file, MTUSize, max_ptime, rtp_rate, hint_flags, HintCopy, hint_interleave, regular_iod, single_group, hint_no_offset);",
          "5894:   if (e) goto err_exit;",
          "",
          "[Removed Lines]",
          "5891:   fprintf(stderr, \"Hinting file with Path-MTU %d Bytes\\n\", MTUSize);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 64 ---",
          "[Context before]",
          "5898: #endif",
          "5900: #if !defined(GPAC_DISABLE_ISOM_HINTING) && !defined(GPAC_DISABLE_SENG)",
          "5931:  if (force_co64)",
          "",
          "[Removed Lines]",
          "5901:  for (i=0; i<nb_sdp_ex; i++) {",
          "5902:   if (sdp_lines[i].trackID) {",
          "5903:    u32 track = gf_isom_get_track_by_id(file, sdp_lines[i].trackID);",
          "5904:    if (gf_isom_get_media_type(file, track)!=GF_ISOM_MEDIA_HINT) {",
          "5905:     s32 ref_count;",
          "5906:     u32 k, count = gf_isom_get_track_count(file);",
          "5907:     for (j=0; j<count; j++) {",
          "5908:      if (gf_isom_get_media_type(file, j+1)!=GF_ISOM_MEDIA_HINT) continue;",
          "5909:      ref_count = gf_isom_get_reference_count(file, j+1, GF_ISOM_REF_HINT);",
          "5910:      if (ref_count<0) continue;",
          "5911:      for (k=0; k<(u32) ref_count; k++) {",
          "5912:       u32 refTk;",
          "5913:       if (gf_isom_get_reference(file, j+1, GF_ISOM_REF_HINT, k+1, &refTk)) continue;",
          "5914:       if (refTk==track) {",
          "5915:        track = j+1;",
          "5916:        j=count;",
          "5917:        break;",
          "5918:       }",
          "5919:      }",
          "5920:     }",
          "5921:    }",
          "5922:    gf_isom_sdp_add_track_line(file, track, sdp_lines[i].line);",
          "5923:    do_save = GF_TRUE;",
          "5924:   } else {",
          "5925:    gf_isom_sdp_add_line(file, sdp_lines[i].line);",
          "5926:    do_save = GF_TRUE;",
          "5927:   }",
          "5928:  }",
          "",
          "[Added Lines]",
          "6062:  set_sdp_ext();",
          "",
          "---------------",
          "--- Hunk 65 ---",
          "[Context before]",
          "5970:   if (!gf_sys_is_quiet()) {",
          "5971:    if (outName) {",
          "5972:    } else if (encode || pack_file) {",
          "5974:    } else {",
          "5976:    }",
          "5983:   }",
          "5985:   e = gf_isom_close(file);",
          "",
          "[Removed Lines]",
          "5973:     fprintf(stderr, \"Saving to %s: \", gf_isom_get_filename(file) );",
          "5975:     fprintf(stderr, \"Saving %s: \", inName);",
          "5977:    if (is_inplace) fprintf(stderr, \"In-place rewrite\\n\");",
          "5978:    else if (do_hint && full_interleave) fprintf(stderr, \"Hinted file - Full Interleaving\\n\");",
          "5979:    else if (full_interleave) fprintf(stderr, \"Full Interleaving\\n\");",
          "5980:    else if ((force_new==2) && interleaving_time) fprintf(stderr, \"Fast-start interleaved storage\\n\");",
          "5981:    else if (do_flat || !interleaving_time) fprintf(stderr, \"Flat storage\\n\");",
          "5982:    else fprintf(stderr, \"%.3f secs Interleaving%s\\n\", interleaving_time, old_interleave ? \" - no drift control\" : \"\");",
          "",
          "[Added Lines]",
          "6107:     M4_LOG(GF_LOG_INFO, (\"Saving to %s: \", gf_isom_get_filename(file) ));",
          "6108:    } else {",
          "6109:     M4_LOG(GF_LOG_INFO, (\"Saving %s: \", inName));",
          "6110:    }",
          "6111:    if (is_inplace) {",
          "6112:     M4_LOG(GF_LOG_INFO, (\"In-place rewrite\\n\"));",
          "6113:    } else if (do_hint && full_interleave) {",
          "6114:     M4_LOG(GF_LOG_INFO, (\"Hinted file - Full Interleaving\\n\"));",
          "6115:    } else if (full_interleave) {",
          "6116:     M4_LOG(GF_LOG_INFO, (\"Full Interleaving\\n\"));",
          "6117:    } else if ((force_new==2) && interleaving_time) {",
          "6118:     M4_LOG(GF_LOG_INFO, (\"Fast-start interleaved storage\\n\"));",
          "6119:    } else if (do_flat || !interleaving_time) {",
          "6120:     M4_LOG(GF_LOG_INFO, (\"Flat storage\\n\"));",
          "6122:     M4_LOG(GF_LOG_INFO, (\"%.3f secs Interleaving%s\\n\", interleaving_time, old_interleave ? \" - no drift control\" : \"\"));",
          "",
          "---------------",
          "--- Hunk 66 ---",
          "[Context before]",
          "5989:    if (gf_file_exists(inName)) {",
          "5990:     e = gf_file_delete(inName);",
          "5991:     if (e) {",
          "5993:     }",
          "5994:    }",
          "5996:    e = gf_file_move(outfile, inName);",
          "5997:    if (e) {",
          "5999:    }",
          "6000:   }",
          "6001:  } else {",
          "",
          "[Removed Lines]",
          "5992:      fprintf(stderr, \"Error removing file %s\\n\", inName);",
          "5998:     fprintf(stderr, \"Error renaming file %s to %s\\n\", outfile, inName);",
          "",
          "[Added Lines]",
          "6133:      M4_LOG(GF_LOG_ERROR, (\"Error removing file %s\\n\", inName));",
          "6139:     M4_LOG(GF_LOG_ERROR, (\"Error renaming file %s to %s\\n\", outfile, inName));",
          "",
          "---------------",
          "--- Hunk 67 ---",
          "[Context before]",
          "6003:  }",
          "6005:  if (e) {",
          "6007:   goto err_exit;",
          "6008:  }",
          "6009:  goto exit;",
          "",
          "[Removed Lines]",
          "6006:   fprintf(stderr, \"Error: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "6147:   M4_LOG(GF_LOG_ERROR, (\"Error: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------",
          "--- Hunk 68 ---",
          "[Context before]",
          "6011: #else",
          "6013:  gf_isom_delete(file);",
          "6015:  return mp4box_cleanup(1);",
          "6016: #endif //GPAC_DISABLE_ISOM_WRITE",
          "",
          "[Removed Lines]",
          "6014:  fprintf(stderr, \"Error: Read-only version of MP4Box.\\n\");",
          "",
          "[Added Lines]",
          "6155:  M4_LOG(GF_LOG_ERROR, (\"Error: Read-only version of MP4Box.\\n\"));",
          "",
          "---------------",
          "--- Hunk 69 ---",
          "[Context before]",
          "6019: err_exit:",
          "6021:  if (file) gf_isom_delete(file);",
          "6023:  return mp4box_cleanup(1);",
          "6025: exit:",
          "",
          "[Removed Lines]",
          "6022:  fprintf(stderr, \"\\n\\tError: %s\\n\", gf_error_to_string(e));",
          "",
          "[Added Lines]",
          "6163:  M4_LOG(GF_LOG_ERROR, (\"\\n\\tError: %s\\n\", gf_error_to_string(e)));",
          "",
          "---------------"
        ],
        "applications/mp4box/mp4box.h||applications/mp4box/mp4box.h": [
          "File: applications/mp4box/mp4box.h -> applications/mp4box/mp4box.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "37: #include <gpac/scene_manager.h>",
          "38: #endif",
          "41: typedef enum {",
          "42:  GF_FILE_TYPE_NOT_SUPPORTED = 0,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "40: #ifndef GPAC_DISABLE_LOG",
          "41: #define M4_LOG(_a, _b) GF_LOG(_a, GF_LOG_APP, _b)",
          "42: #else",
          "43: void mp4box_log(const char *fmt, ...);",
          "45: #define M4_LOG(_a, _b) mp4box_log _b",
          "46: #endif",
          "",
          "---------------"
        ],
        "src/compositor/hardcoded_protos.c||src/compositor/hardcoded_protos.c": [
          "File: src/compositor/hardcoded_protos.c -> src/compositor/hardcoded_protos.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1351:   if (tr_state->traversing_mode==TRAVERSE_DRAW_3D) {",
          "1352:    Bool visible = GF_FALSE;",
          "1353:    const char *pid_name = gf_filter_pid_get_name(txh->stream->odm->pid);",
          "1355:    if (! tr_state->camera_was_dirty && !mesh_was_reset) {",
          "1356:     visible = (stack->mesh->flags & MESH_WAS_VISIBLE) ? GF_TRUE : GF_FALSE;",
          "1357:    } else if ((vrinfo.srd_w==vrinfo.srd_max_x) && (vrinfo.srd_h==vrinfo.srd_max_y)) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1353: #ifndef GPAC_DISABLE_LOG",
          "1355: #endif",
          "",
          "---------------"
        ],
        "src/filters/load_text.c||src/filters/load_text.c": [
          "File: src/filters/load_text.c -> src/filters/load_text.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1619:   }",
          "1620:  }",
          "1625:  }",
          "1626:  return GF_OK;",
          "1627: }",
          "",
          "[Removed Lines]",
          "1622:  for (k=0; k<gf_list_count(ctx->intervals); k++) {",
          "1623:   TTMLInterval *ival = gf_list_get(ctx->intervals, k);",
          "1624:   GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] Interval %d: \"LLU\"-\"LLU\"\\n\", k+1, ival->begin, ival->end));",
          "",
          "[Added Lines]",
          "1622: #ifndef GPAC_DISABLE_LOG",
          "1623:  if (gf_log_tool_level_on(GF_LOG_PARSER, GF_LOG_DEBUG)) {",
          "1624:   for (k=0; k<gf_list_count(ctx->intervals); k++) {",
          "1625:    TTMLInterval *ival = gf_list_get(ctx->intervals, k);",
          "1626:    GF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] Interval %d: \"LLU\"-\"LLU\"\\n\", k+1, ival->begin, ival->end));",
          "1627:   }",
          "1629: #endif",
          "",
          "---------------"
        ],
        "src/filters/reframe_mhas.c||src/filters/reframe_mhas.c": [
          "File: src/filters/reframe_mhas.c -> src/filters/reframe_mhas.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "394:  }",
          "395: }",
          "397: static const char *mhas_pck_name(u32 pck_type)",
          "398: {",
          "399:  switch (pck_type) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "397: #ifndef GPAC_DISABLE_LOG",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "421:  }",
          "422:  return \"error\";",
          "423: }",
          "425: GF_Err mhas_dmx_process(GF_Filter *filter)",
          "426: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "425: #endif",
          "",
          "---------------"
        ],
        "src/jsmods/core.c||src/jsmods/core.c": [
          "File: src/jsmods/core.c -> src/jsmods/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "728:  case JS_SYS_OLD_ARCH:",
          "729:   return JS_NewBool(ctx, gf_sys_old_arch_compat() );",
          "730:  case JS_SYS_LOG_COLOR:",
          "731:   return JS_NewBool(ctx, gf_log_use_color() );",
          "732:  case JS_SYS_QUIET:",
          "733:   return JS_NewBool(ctx, gf_sys_is_quiet() );",
          "734:  case JS_SYS_USERNAME:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "731: #ifdef GPAC_DISABLE_LOG",
          "732:   return JS_NewBool(ctx, GF_FALSE );",
          "733: #else",
          "735: #endif",
          "",
          "---------------"
        ],
        "src/utils/error.c||src/utils/error.c": [
          "File: src/utils/error.c -> src/utils/error.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: #include <gpac/tools.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <gpac/thread.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "693: static void *user_log_cbk = NULL;",
          "694: gf_log_cbk log_cbk = default_log_callback_color;",
          "695: static Bool log_exit_on_error = GF_FALSE;",
          "",
          "[Removed Lines]",
          "692: #include <gpac/thread.h>",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/utils/os_divers.c||src/utils/os_divers.c": [
          "File: src/utils/os_divers.c -> src/utils/os_divers.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1070: void gpac_rmt_log_callback(void *cbck, GF_LOG_Level level, GF_LOG_Tool tool, const char *fmt, va_list vlist)",
          "1071: {",
          "1072: #define RMT_LOG_SIZE 5000",
          "1073:  char szMsg[RMT_LOG_SIZE];",
          "1074:  u32 len;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1072: #ifndef GPAC_DISABLE_LOG",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1081:  rmt_LogText(szMsg);",
          "1083: #undef RMT_LOG_SIZE",
          "1084: }",
          "1086: static void *rmt_udta = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1087: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "99aa090d7df4178d11319f6c4ee50e1e103c043e",
      "candidate_info": {
        "commit_hash": "99aa090d7df4178d11319f6c4ee50e1e103c043e",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/99aa090d7df4178d11319f6c4ee50e1e103c043e",
        "files": [
          "src/filters/write_nhml.c"
        ],
        "message": "fix duplicate audio attributes in NHML",
        "before_after_code_files": [
          "src/filters/write_nhml.c||src/filters/write_nhml.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/filters/write_nhml.c||src/filters/write_nhml.c"
          ],
          "candidate": [
            "src/filters/write_nhml.c||src/filters/write_nhml.c"
          ]
        }
      },
      "candidate_diff": {
        "src/filters/write_nhml.c||src/filters/write_nhml.c": [
          "File: src/filters/write_nhml.c -> src/filters/write_nhml.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "403:   }",
          "404:  }",
          "405:  else if (ctx->sr && ctx->chan) {",
          "408:   sprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);",
          "409:   gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));",
          "410:   p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_AUDIO_FORMAT);",
          "412:    sprintf(nhml, \"bitsPerSample=\\\"%d\\\" \", gf_audio_fmt_bit_depth(p->value.uint));",
          "414:  }",
          "416:  NHML_PRINT_4CC(0, \"codec_vendor\", \"codecVendor\")",
          "",
          "[Removed Lines]",
          "406:   sprintf(nhml, \"sampleRate=\\\"%d\\\" numChannels=\\\"%d\\\" \", ctx->sr, ctx->chan);",
          "407:   gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));",
          "411:   if (p)",
          "413:   gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));",
          "",
          "[Added Lines]",
          "409:   if (p) {",
          "411:    gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml));",
          "412:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94b10de5b1cc226538625c306d00ece67a1140be",
      "candidate_info": {
        "commit_hash": "94b10de5b1cc226538625c306d00ece67a1140be",
        "repo": "gpac/gpac",
        "commit_url": "https://github.com/gpac/gpac/commit/94b10de5b1cc226538625c306d00ece67a1140be",
        "files": [
          "applications/mp4box/main.c",
          "include/gpac/bitstream.h",
          "src/isomedia/meta.c",
          "testsuite"
        ],
        "message": "fixed mp4box dump item - cf #1617",
        "before_after_code_files": [
          "applications/mp4box/main.c||applications/mp4box/main.c",
          "include/gpac/bitstream.h||include/gpac/bitstream.h",
          "src/isomedia/meta.c||src/isomedia/meta.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "applications/mp4box/main.c||applications/mp4box/main.c"
          ],
          "candidate": [
            "applications/mp4box/main.c||applications/mp4box/main.c"
          ]
        }
      },
      "candidate_diff": {
        "applications/mp4box/main.c||applications/mp4box/main.c": [
          "File: applications/mp4box/main.c -> applications/mp4box/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5619:     } else {",
          "5620:      fprintf(stderr, \"Error writing IOD %s\\n\", szName);",
          "5621:     }",
          "5623:     gf_bs_del(bs);",
          "5624:    }",
          "5625:    gf_odf_desc_del((GF_Descriptor*)iod);",
          "5626:   }",
          "",
          "[Removed Lines]",
          "5622:     gf_fclose(iodf);",
          "",
          "[Added Lines]",
          "5623:     gf_fclose(iodf);",
          "",
          "---------------"
        ],
        "include/gpac/bitstream.h||include/gpac/bitstream.h": [
          "File: include/gpac/bitstream.h -> include/gpac/bitstream.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "104: \\brief bitstream destructor from file handle",
          "106: Deletes the bitstream object. If the buffer was created by the bitstream, it is deleted if still present.",
          "107: \\param bs the target bitstream",
          "109: void gf_bs_del(GF_BitStream *bs);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "107: \\WARNING If the bitstream was constructed from a FILE object in write mode, the FILE object MUST be closed after destructing the bitstream",
          "",
          "---------------"
        ],
        "src/isomedia/meta.c||src/isomedia/meta.c": [
          "File: src/isomedia/meta.c -> src/isomedia/meta.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "385:  if (out_data) {",
          "386:   gf_bs_get_content_no_truncate(item_bs, out_data, out_size, out_alloc_size);",
          "387:  }",
          "388:  if (resource) {",
          "389:   gf_fclose(resource);",
          "390:  }",
          "392:  return GF_OK;",
          "393: }",
          "",
          "[Removed Lines]",
          "391:  gf_bs_del(item_bs);",
          "",
          "[Added Lines]",
          "388:  gf_bs_del(item_bs);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2022-35982",
  "cve_desc": "TensorFlow is an open source platform for machine learning. If `SparseBincount` is given inputs for `indices`, `values`, and `dense_shape` that do not make a valid sparse tensor, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 40adbe4dd15b582b0210dfbf40c243a62f5119fa. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "40adbe4dd15b582b0210dfbf40c243a62f5119fa",
  "patch_info": {
    "commit_hash": "40adbe4dd15b582b0210dfbf40c243a62f5119fa",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/40adbe4dd15b582b0210dfbf40c243a62f5119fa",
    "files": [
      "tensorflow/core/kernels/BUILD",
      "tensorflow/core/kernels/bincount_op.cc",
      "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
    ],
    "message": "Add sparse tensor validation to SparseBincountOp.\n\nAddresses a security issue.\n\nPiperOrigin-RevId: 460573866",
    "before_after_code_files": [
      "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
      "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc": [
      "File: tensorflow/core/kernels/bincount_op.cc -> tensorflow/core/kernels/bincount_op.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "23: #include \"tensorflow/core/framework/types.h\"",
      "24: #include \"tensorflow/core/kernels/bincount_op.h\"",
      "25: #include \"tensorflow/core/kernels/fill_functor.h\"",
      "26: #include \"tensorflow/core/lib/core/threadpool.h\"",
      "27: #include \"tensorflow/core/platform/types.h\"",
      "28: #include \"tensorflow/core/util/determinism.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "26: #include \"tensorflow/core/kernels/sparse_utils.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "370:   void Compute(OpKernelContext* ctx) override {",
      "371:     const Tensor& indices = ctx->input(0);",
      "373:     const Tensor& dense_shape = ctx->input(2);",
      "374:     const Tensor& size_t = ctx->input(3);",
      "375:     const auto weights = ctx->input(4).flat<T>();",
      "",
      "[Removed Lines]",
      "372:     const auto values = ctx->input(1).flat<Tidx>();",
      "",
      "[Added Lines]",
      "373:     const Tensor& values = ctx->input(1);",
      "374:     const auto values_flat = values.flat<Tidx>();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "382:     OP_REQUIRES(",
      "383:         ctx, size >= 0,",
      "384:         errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));",
      "386:     bool is_1d = dense_shape.NumElements() == 1;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "387:     OP_REQUIRES_OK(",
      "388:         ctx, sparse_utils::ValidateSparseTensor<int64_t>(",
      "389:                  indices, values, dense_shape, /*validate_indices=*/true));",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "394:       if (binary_output_) {",
      "395:         OP_REQUIRES_OK(ctx,",
      "396:                        functor::BincountFunctor<Device, Tidx, T, true>::Compute(",
      "398:       } else {",
      "399:         OP_REQUIRES_OK(",
      "400:             ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(",
      "402:       }",
      "403:     } else {",
      "404:       const auto shape = dense_shape.flat<int64_t>();",
      "",
      "[Removed Lines]",
      "397:                            ctx, values, weights, out, size));",
      "401:                      ctx, values, weights, out, size));",
      "",
      "[Added Lines]",
      "402:                            ctx, values_flat, weights, out, size));",
      "406:                      ctx, values_flat, weights, out, size));",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "410:       const auto indices_mat = indices.matrix<int64_t>();",
      "411:       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {",
      "412:         const int64_t batch = indices_mat(i, 0);",
      "414:         OP_REQUIRES(",
      "415:             ctx, batch < out.dimension(0),",
      "416:             errors::InvalidArgument(\"Index out of bound. `batch` (\", batch,",
      "",
      "[Removed Lines]",
      "413:         const Tidx bin = values(i);",
      "",
      "[Added Lines]",
      "418:         const Tidx bin = values_flat(i);",
      "",
      "---------------"
    ],
    "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py": [
      "File: tensorflow/python/kernel_tests/math_ops/bincount_op_test.py -> tensorflow/python/kernel_tests/math_ops/bincount_op_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "366:     num_rows = 128",
      "367:     size = 1000",
      "368:     n_elems = 4096",
      "370:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
      "372:     np_out = np.bincount(inp_vals, minlength=size)",
      "",
      "[Removed Lines]",
      "369:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
      "",
      "[Added Lines]",
      "369:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "390:     num_rows = 128",
      "391:     size = 1000",
      "392:     n_elems = 4096",
      "394:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
      "395:     inp_weight = np.random.random((n_elems,))",
      "",
      "[Removed Lines]",
      "393:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
      "",
      "[Added Lines]",
      "393:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "415:     num_rows = 128",
      "416:     size = 10",
      "417:     n_elems = 4096",
      "419:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
      "421:     np_out = np.ones((size,))",
      "",
      "[Removed Lines]",
      "418:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
      "",
      "[Added Lines]",
      "418:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "440:     num_rows = 128",
      "441:     size = 10",
      "442:     n_elems = 4096",
      "444:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
      "445:     inp_weight = np.random.random((n_elems,))",
      "",
      "[Removed Lines]",
      "443:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
      "",
      "[Added Lines]",
      "443:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "532:               weights=[0, 0],",
      "533:               binary_output=False))",
      "536: class RaggedBincountOpTest(test_util.TensorFlowTestCase,",
      "537:                            parameterized.TestCase):",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "535:   def test_sparse_bincount_input_validation(self):",
      "536:     np.random.seed(42)",
      "537:     num_rows = 128",
      "538:     size = 1000",
      "539:     n_elems = 4096",
      "540:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
      "541:     inp_vals = np.random.randint(0, size, (n_elems,))",
      "543:     # Insert negative index.",
      "544:     inp_indices[10, 0] = -2",
      "546:     with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),",
      "547:                                 \"out of bounds\"):",
      "548:       self.evaluate(",
      "549:           gen_math_ops.sparse_bincount(",
      "550:               indices=inp_indices,",
      "551:               values=inp_vals,",
      "552:               dense_shape=[num_rows],",
      "553:               size=size,",
      "554:               weights=[]))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4a684f1ca9e1cbf845a9cec2185e844429e2d8c8",
      "candidate_info": {
        "commit_hash": "4a684f1ca9e1cbf845a9cec2185e844429e2d8c8",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/4a684f1ca9e1cbf845a9cec2185e844429e2d8c8",
        "files": [
          "tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/core/kernels/sparse_utils.cc",
          "tensorflow/core/kernels/sparse_utils.h",
          "tensorflow/core/kernels/sparse_utils_test.cc"
        ],
        "message": "Add ordered sparse index validation.\n\nOption to check that the indices tensor is lexicographically ordered,\nwhich is required by some ops.\n\nPiperOrigin-RevId: 460978686",
        "before_after_code_files": [
          "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/core/kernels/sparse_utils.cc||tensorflow/core/kernels/sparse_utils.cc",
          "tensorflow/core/kernels/sparse_utils.h||tensorflow/core/kernels/sparse_utils.h",
          "tensorflow/core/kernels/sparse_utils_test.cc||tensorflow/core/kernels/sparse_utils_test.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc": [
          "File: tensorflow/core/kernels/bincount_op.cc -> tensorflow/core/kernels/bincount_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "392:     OP_REQUIRES(",
          "393:         ctx, size >= 0,",
          "394:         errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));",
          "399:     bool is_1d = dense_shape.NumElements() == 1;",
          "",
          "[Removed Lines]",
          "395:     OP_REQUIRES_OK(",
          "396:         ctx, sparse_utils::ValidateSparseTensor<int64_t>(",
          "397:                  indices, values, dense_shape, /*validate_indices=*/true));",
          "",
          "[Added Lines]",
          "395:     OP_REQUIRES_OK(ctx, sparse_utils::ValidateSparseTensor<int64_t>(",
          "396:                             indices, values, dense_shape,",
          "397:                             sparse_utils::IndexValidation::kUnordered));",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/sparse_utils.cc||tensorflow/core/kernels/sparse_utils.cc": [
          "File: tensorflow/core/kernels/sparse_utils.cc -> tensorflow/core/kernels/sparse_utils.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "179:   return Status::OK();",
          "180: }",
          "183: template <typename Tindices>",
          "186:   const auto indices_mat = indices.flat_inner_dims<Tindices>();",
          "187:   const auto shape_vec = shape.flat<Tindices>();",
          "",
          "[Removed Lines]",
          "184: Status ValidateSparseTensorIndices(const Tensor& indices, const Tensor& shape) {",
          "",
          "[Added Lines]",
          "183: template <typename IndexTensor>",
          "184: string CreateIndexString(const IndexTensor& indices, int64_t row) {",
          "185:   const int64_t ndims = indices.dimension(1);",
          "186:   string index_str = strings::StrCat(\"indices[\", row, \", :] = [\");",
          "187:   for (int64_t dim = 0; dim < ndims; ++dim) {",
          "188:     strings::StrAppend(&index_str, indices(row, dim),",
          "189:                        dim < ndims - 1 ? \", \" : \"]\");",
          "190:   }",
          "191:   if (ndims == 0) {",
          "192:     strings::StrAppend(&index_str, \"]\");",
          "193:   }",
          "194:   return index_str;",
          "195: }",
          "199: Status ValidateSparseTensorIndicesUnordered(const Tensor& indices,",
          "200:                                             const Tensor& shape) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "192:     for (int64_t dim = 0; dim < ndims; ++dim) {",
          "193:       const Tindices idx = indices_mat(i, dim);",
          "194:       if (TF_PREDICT_FALSE(idx < 0 || idx >= shape_vec(dim))) {",
          "200:         return errors::InvalidArgument(\"Sparse index tuple \", index_str,",
          "201:                                        \" is out of bounds\");",
          "202:       }",
          "",
          "[Removed Lines]",
          "195:         string index_str = strings::StrCat(\"indices[\", i, \", :] = [\");",
          "196:         for (int64_t dim = 0; dim < ndims; ++dim) {",
          "197:           strings::StrAppend(&index_str, indices_mat(i, dim),",
          "198:                              dim < ndims - 1 ? \", \" : \"]\");",
          "199:         }",
          "",
          "[Added Lines]",
          "211:         string index_str = CreateIndexString(indices_mat, i);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "206:   return Status::OK();",
          "207: }",
          "209: }  // namespace",
          "211: template <typename Tindices>",
          "212: Status ValidateSparseTensor(const Tensor& indices, const Tensor& values,",
          "214:   TF_RETURN_IF_ERROR(ValidateSparseTensorShape(indices, values, shape));",
          "217:   }",
          "218:   return Status::OK();",
          "219: }",
          "",
          "[Removed Lines]",
          "213:                             const Tensor& shape, bool validate_indices) {",
          "215:   if (validate_indices) {",
          "216:     return ValidateSparseTensorIndices<Tindices>(indices, shape);",
          "",
          "[Added Lines]",
          "223: template <typename Tindices>",
          "224: Status ValidateSparseTensorIndicesOrdered(const Tensor& indices,",
          "225:                                           const Tensor& shape) {",
          "226:   const auto indices_mat = indices.flat_inner_dims<Tindices>();",
          "227:   const auto shape_vec = shape.flat<Tindices>();",
          "228:   int64_t nnz = indices.dim_size(0);",
          "229:   int64_t ndims = indices.dim_size(1);",
          "231:   if (nnz == 0) {",
          "232:     return Status::OK();",
          "233:   }",
          "236:   for (int64_t dim = 0; dim < ndims; ++dim) {",
          "237:     const Tindices idx = indices_mat(0, dim);",
          "238:     if (TF_PREDICT_FALSE(idx < 0 || idx >= shape_vec(dim))) {",
          "239:       string index_str = CreateIndexString(indices_mat, 0);",
          "240:       return errors::InvalidArgument(\"Sparse index tuple \", index_str,",
          "241:                                      \" is out of bounds\");",
          "242:     }",
          "243:   }",
          "247:   for (int64_t i = 1; i < nnz; ++i) {",
          "248:     bool different = false;",
          "249:     for (int64_t dim = 0; dim < ndims; ++dim) {",
          "250:       const Tindices idx = indices_mat(i, dim);",
          "251:       const Tindices prev_idx = indices_mat(i - 1, dim);",
          "254:       if (TF_PREDICT_TRUE(different)) {",
          "255:         if (TF_PREDICT_FALSE(idx < 0 || idx >= shape_vec(dim))) {",
          "256:           string index_str = CreateIndexString(indices_mat, i);",
          "257:           return errors::InvalidArgument(\"Sparse index tuple \", index_str,",
          "258:                                          \" is out of bounds\");",
          "259:         }",
          "260:       } else {",
          "262:         if (TF_PREDICT_FALSE(idx < prev_idx || idx >= shape_vec(dim))) {",
          "263:           string index_str = CreateIndexString(indices_mat, i);",
          "265:           if (TF_PREDICT_FALSE(idx < 0 || idx >= shape_vec(dim))) {",
          "266:             return errors::InvalidArgument(\"Sparse index tuple \", index_str,",
          "267:                                            \" is out of bounds\");",
          "268:           } else {",
          "269:             return errors::InvalidArgument(\"Sparse index tuple \", index_str,",
          "270:                                            \" is out of order\");",
          "271:           }",
          "272:         } else if (TF_PREDICT_TRUE(idx > prev_idx)) {",
          "273:           different = true;",
          "274:         }",
          "275:       }  // if (different)",
          "276:     }    // for dim in [0, ndims)",
          "278:     if (TF_PREDICT_FALSE(!different)) {",
          "279:       string index_str = CreateIndexString(indices_mat, i);",
          "280:       return errors::InvalidArgument(\"Sparse index tuple \", index_str,",
          "281:                                      \" is repeated\");",
          "282:     }",
          "283:   }  // for i in [1, nnz)",
          "285:   return Status::OK();",
          "286: }",
          "292:                             const Tensor& shape,",
          "293:                             IndexValidation index_validation) {",
          "295:   switch (index_validation) {",
          "296:     case IndexValidation::kOrdered:",
          "297:       return ValidateSparseTensorIndicesOrdered<Tindices>(indices, shape);",
          "298:     case IndexValidation::kUnordered:",
          "299:       return ValidateSparseTensorIndicesUnordered<Tindices>(indices, shape);",
          "300:     case IndexValidation::kNone: {",
          "301:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "232:       const TypeIndex num_nonzero_entries_in_sparse_mat);                   \\",
          "233:   template Status ValidateSparseTensor<TypeIndex>(                          \\",
          "234:       const Tensor& indices, const Tensor& values, const Tensor& shape,     \\",
          "237: REGISTER_SPARSE_UTIL_FUNCTIONS(int32);",
          "238: REGISTER_SPARSE_UTIL_FUNCTIONS(int64);",
          "",
          "[Removed Lines]",
          "235:       bool validate_indices)",
          "",
          "[Added Lines]",
          "320:       IndexValidation index_validation)",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/sparse_utils.h||tensorflow/core/kernels/sparse_utils.h": [
          "File: tensorflow/core/kernels/sparse_utils.h -> tensorflow/core/kernels/sparse_utils.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: template <typename Tindices>",
          "66: bool ContainsEmptyRows(const std::vector<Tindices>& row_start_indices);",
          "71: template <typename Tindices>",
          "72: Status ValidateSparseTensor(const Tensor& indices, const Tensor& values,",
          "75: }  // namespace sparse_utils",
          "76: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "73:                             const Tensor& shape, bool validate_indices);",
          "",
          "[Added Lines]",
          "69: enum class IndexValidation {",
          "70:   kNone,      // Indices are not used by the op, or are not directly accessible",
          "72:   kOrdered,   // Indices must be unique, in lexicographical order, and within",
          "74:   kUnordered  // Indices must be within safe bounds, but may repeat or appear",
          "76: };",
          "82:                             const Tensor& shape,",
          "83:                             IndexValidation index_validation);",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/sparse_utils_test.cc||tensorflow/core/kernels/sparse_utils_test.cc": [
          "File: tensorflow/core/kernels/sparse_utils_test.cc -> tensorflow/core/kernels/sparse_utils_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #include <algorithm>",
          "19: #include <cstdint>",
          "20: #include <utility>",
          "21: #include <vector>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include <set>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "307: }",
          "311: void GenerateRandomSparseTensor(int64_t max_nnz, const TensorShape& shape,",
          "314:   const int64_t ndims = shape.dims();",
          "",
          "[Removed Lines]",
          "312:                                 Tensor& output_indices, Tensor& output_values,",
          "313:                                 Tensor& output_shape) {",
          "",
          "[Added Lines]",
          "314:                                 bool ordered, Tensor& output_indices,",
          "315:                                 Tensor& output_values, Tensor& output_shape) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "319:   output_values = Tensor(DT_FLOAT, TensorShape({nnz}));",
          "320:   output_shape = Tensor(DT_INT64, TensorShape({ndims}));",
          "326:   auto values_vec = output_values.vec<float>();",
          "327:   values_vec.setRandom();",
          "",
          "[Removed Lines]",
          "323:   FillIndicesWithRandomTuples<absl::flat_hash_set<std::vector<int64_t>>>(",
          "324:       shape, output_indices);",
          "",
          "[Added Lines]",
          "325:   if (ordered) {",
          "327:     FillIndicesWithRandomTuples<std::set<std::vector<int64_t>>>(shape,",
          "328:                                                                 output_indices);",
          "329:   } else {",
          "330:     FillIndicesWithRandomTuples<absl::flat_hash_set<std::vector<int64_t>>>(",
          "331:         shape, output_indices);",
          "332:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "332:   }",
          "333: }",
          "336:   constexpr int kNumNonZeros = 1000;",
          "338:   const TensorShape kTensorShapes[] = {",
          "339:       {}, {3}, {4, 5}, {6, 7, 8}, {9, 10, 11, 12}};",
          "341:     Tensor indices, values, shape;",
          "343:     TF_EXPECT_OK((ValidateSparseTensor<int64_t>(indices, values, shape,",
          "345:   }",
          "346: }",
          "349:   constexpr int kNumNonZeros = 1000;",
          "350:   constexpr int kNumDims = 3;",
          "353:   const TensorShape kInvalidIndicesShapes[] = {",
          "354:       {}, {kNumNonZeros}, {kNumNonZeros, kNumDims, 4}};",
          "355:   for (const TensorShape& invalid_shape : kInvalidIndicesShapes) {",
          "356:     const Tensor indices = Tensor(DT_INT64, invalid_shape);",
          "357:     const Tensor values = Tensor(DT_FLOAT, TensorShape({kNumNonZeros}));",
          "358:     const Tensor shape = Tensor(DT_INT64, TensorShape({kNumDims}));",
          "359:     EXPECT_THAT((ValidateSparseTensor<int64_t>(indices, values, shape,",
          "361:                 StatusIs(error::INVALID_ARGUMENT,",
          "362:                          MatchesRegex(\"Sparse indices must be rank 2 .*\")));",
          "363:   }",
          "364: }",
          "367:   constexpr int kNumNonZeros = 1000;",
          "368:   constexpr int kNumDims = 3;",
          "371:   const TensorShape kInvalidValuesShapes[] = {{}, {kNumNonZeros, 2}};",
          "372:   for (const TensorShape& invalid_shape : kInvalidValuesShapes) {",
          "373:     const Tensor indices =",
          "374:         Tensor(DT_INT64, TensorShape({kNumNonZeros, kNumDims}));",
          "375:     const Tensor values = Tensor(DT_FLOAT, invalid_shape);",
          "376:     const Tensor shape = Tensor(DT_INT64, TensorShape({kNumDims}));",
          "377:     EXPECT_THAT((ValidateSparseTensor<int64_t>(indices, values, shape,",
          "379:                 StatusIs(error::INVALID_ARGUMENT,",
          "380:                          MatchesRegex(\"Sparse values must be rank 1 .*\")));",
          "381:   }",
          "382: }",
          "385:   constexpr int kNumNonZeros = 1000;",
          "386:   constexpr int kNumDims = 3;",
          "389:   const TensorShape kInvalidShapeShapes[] = {{}, {kNumDims, 2}};",
          "390:   for (const TensorShape& invalid_shape : kInvalidShapeShapes) {",
          "",
          "[Removed Lines]",
          "335: TEST(ValidateSparseTensorTest, ValidSparseTensorPasses) {",
          "337:   constexpr bool kValidateIndices = true;",
          "340:   for (const TensorShape& tshape : kTensorShapes) {",
          "342:     GenerateRandomSparseTensor(kNumNonZeros, tshape, indices, values, shape);",
          "344:                                                 kValidateIndices)));",
          "348: TEST(ValidateSparseTensorTest, InvalidIndicesRankFails) {",
          "351:   constexpr bool kValidateIndices = false;",
          "360:                                                kValidateIndices)),",
          "366: TEST(ValidateSparseTensorTest, InvalidValuesRankFails) {",
          "369:   constexpr bool kValidateIndices = false;",
          "378:                                                kValidateIndices)),",
          "384: TEST(ValidateSparseTensorTest, InvalidShapeRankFails) {",
          "387:   constexpr bool kValidateIndices = false;",
          "",
          "[Added Lines]",
          "343: using ValidateSparseTensorTest = ::testing::TestWithParam<IndexValidation>;",
          "345: TEST_P(ValidateSparseTensorTest, ValidSparseTensorPasses) {",
          "349:   const IndexValidation index_validation = GetParam();",
          "350:   const bool ordered = (index_validation == IndexValidation::kOrdered);",
          "351:   for (const TensorShape& test_shape : kTensorShapes) {",
          "353:     GenerateRandomSparseTensor(kNumNonZeros, test_shape, ordered, indices,",
          "354:                                values, shape);",
          "356:                                                 index_validation)));",
          "360: TEST_P(ValidateSparseTensorTest, InvalidIndicesRankFails) {",
          "366:   const IndexValidation index_validation = GetParam();",
          "372:                                                index_validation)),",
          "378: TEST_P(ValidateSparseTensorTest, InvalidValuesRankFails) {",
          "383:   const IndexValidation index_validation = GetParam();",
          "390:                                                index_validation)),",
          "396: TEST_P(ValidateSparseTensorTest, InvalidShapeRankFails) {",
          "399:   const IndexValidation index_validation = GetParam();",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "393:     const Tensor values = Tensor(DT_FLOAT, TensorShape({kNumNonZeros}));",
          "394:     const Tensor shape = Tensor(DT_INT64, invalid_shape);",
          "395:     EXPECT_THAT((ValidateSparseTensor<int64_t>(indices, values, shape,",
          "397:                 StatusIs(error::INVALID_ARGUMENT,",
          "398:                          MatchesRegex(\"Sparse shape must be rank 1 .*\")));",
          "399:   }",
          "400: }",
          "403:   constexpr int kNumNonZeros = 1000;",
          "404:   constexpr int kNumDims = 3;",
          "407:   const Tensor values = Tensor(DT_FLOAT, TensorShape({kNumNonZeros}));",
          "408:   const Tensor shape = Tensor(DT_INT64, TensorShape({kNumDims}));",
          "",
          "[Removed Lines]",
          "396:                                                kValidateIndices)),",
          "402: TEST(ValidateSparseTensorTest, IncompatibleShapesFails) {",
          "405:   constexpr bool kValidateIndices = false;",
          "",
          "[Added Lines]",
          "408:                                                index_validation)),",
          "414: TEST_P(ValidateSparseTensorTest, IncompatibleShapesFails) {",
          "417:   const IndexValidation index_validation = GetParam();",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "412:     const Tensor indices =",
          "413:         Tensor(DT_INT64, TensorShape({kNumNonZeros + 1, kNumDims}));",
          "414:     EXPECT_THAT((ValidateSparseTensor<int64_t>(indices, values, shape,",
          "416:                 StatusIs(error::INVALID_ARGUMENT,",
          "417:                          MatchesRegex(\"Number of elements in indices .* and \"",
          "418:                                       \"values .* do not match\")));",
          "",
          "[Removed Lines]",
          "415:                                                kValidateIndices)),",
          "",
          "[Added Lines]",
          "427:                                                index_validation)),",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "425:         Tensor(DT_INT64, TensorShape({kNumNonZeros, kNumDims + 1}));",
          "426:     EXPECT_THAT(",
          "427:         (ValidateSparseTensor<int64_t>(indices, values, shape,",
          "429:         StatusIs(error::INVALID_ARGUMENT,",
          "430:                  MatchesRegex(\"Index rank .* and shape rank .* do not match\")));",
          "431:   }",
          "432: }",
          "435:   constexpr int kNumNonZeros = 1000;",
          "436:   constexpr int kNumTests = 100;",
          "439:   const TensorShape kTensorShapes[] = {{3}, {4, 5}, {6, 7, 8}, {9, 10, 11, 12}};",
          "441:     Tensor indices, values, shape;",
          "444:     auto indices_mat = indices.matrix<int64_t>();",
          "445:     for (int test = 0; test < kNumTests; ++test) {",
          "",
          "[Removed Lines]",
          "428:                                        kValidateIndices)),",
          "434: TEST(ValidateSparseTensorTest, IndexOutOfBoundsFails) {",
          "437:   constexpr bool kValidateIndices = true;",
          "440:   for (const TensorShape& tshape : kTensorShapes) {",
          "442:     GenerateRandomSparseTensor(kNumNonZeros, tshape, indices, values, shape);",
          "",
          "[Added Lines]",
          "440:                                        index_validation)),",
          "446: TEST_P(ValidateSparseTensorTest, IndexOutOfBoundsFails) {",
          "449:   const IndexValidation index_validation = GetParam();",
          "450:   const bool ordered = (index_validation == IndexValidation::kOrdered);",
          "454:   for (const TensorShape& test_shape : kTensorShapes) {",
          "456:     GenerateRandomSparseTensor(kNumNonZeros, test_shape, ordered, indices,",
          "457:                                values, shape);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "448:       int64_t dim = RandomPhilox().Uniform64(indices.dim_size(1));",
          "449:       int64_t old_val = indices_mat(row, dim);",
          "466:       indices_mat(row, dim) = old_val;",
          "",
          "[Removed Lines]",
          "451:       indices_mat(row, dim) = -1;",
          "452:       EXPECT_THAT(",
          "453:           (ValidateSparseTensor<int64_t>(indices, values, shape,",
          "454:                                          kValidateIndices)),",
          "455:           StatusIs(error::INVALID_ARGUMENT,",
          "456:                    MatchesRegex(\"Sparse index tuple .* is out of bounds\")));",
          "458:       indices_mat(row, dim) = tshape.dim_size(dim);",
          "459:       EXPECT_THAT(",
          "460:           (ValidateSparseTensor<int64_t>(indices, values, shape,",
          "461:                                          kValidateIndices)),",
          "462:           StatusIs(error::INVALID_ARGUMENT,",
          "463:                    MatchesRegex(\"Sparse index tuple .* is out of bounds\")));",
          "",
          "[Added Lines]",
          "466:       for (int64_t val : {static_cast<int64_t>(-1), test_shape.dim_size(dim)}) {",
          "467:         indices_mat(row, dim) = val;",
          "468:         Status indices_valid = ValidateSparseTensor<int64_t>(",
          "469:             indices, values, shape, index_validation);",
          "470:         if (index_validation == IndexValidation::kNone) {",
          "471:           TF_EXPECT_OK(indices_valid);",
          "472:         } else {",
          "473:           EXPECT_THAT(",
          "474:               indices_valid,",
          "475:               StatusIs(error::INVALID_ARGUMENT,",
          "476:                        MatchesRegex(\"Sparse index tuple .* is out of bounds\")))",
          "477:               << indices_mat;",
          "478:         }",
          "479:       }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "468:   }",
          "469: }",
          "471: }  // namespace",
          "472: }  // namespace sparse_utils",
          "473: }  // namespace tensorflow",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "487: TEST_P(ValidateSparseTensorTest, IndexOutOfOrderFailsForOrderedValidation) {",
          "488:   constexpr int kNumNonZeros = 1000;",
          "489:   constexpr int kNumTests = 100;",
          "490:   const TensorShape kTensorShapes[] = {{3}, {4, 5}, {6, 7, 8}, {9, 10, 11, 12}};",
          "491:   const IndexValidation index_validation = GetParam();",
          "492:   const bool ordered = (index_validation == IndexValidation::kOrdered);",
          "494:   for (const TensorShape& test_shape : kTensorShapes) {",
          "495:     Tensor indices, values, shape;",
          "496:     GenerateRandomSparseTensor(kNumNonZeros, test_shape, ordered, indices,",
          "497:                                values, shape);",
          "499:     auto indices_mat = indices.matrix<int64_t>();",
          "500:     const int64_t nnz = indices.dim_size(0);",
          "501:     const int64_t ndims = indices.dim_size(1);",
          "502:     for (int test = 0; test < kNumTests; ++test) {",
          "504:       int64_t row1 = RandomPhilox().Uniform64(nnz);",
          "505:       int64_t row2;",
          "506:       do {",
          "507:         row2 = RandomPhilox().Uniform64(nnz);",
          "508:       } while (row1 == row2);",
          "509:       for (int dim = 0; dim < ndims; ++dim) {",
          "510:         std::swap(indices_mat(row1, dim), indices_mat(row2, dim));",
          "511:       }",
          "513:       Status indices_valid = ValidateSparseTensor<int64_t>(",
          "514:           indices, values, shape, index_validation);",
          "515:       if (ordered) {",
          "516:         EXPECT_THAT(",
          "517:             indices_valid,",
          "518:             StatusIs(error::INVALID_ARGUMENT,",
          "519:                      MatchesRegex(\"Sparse index tuple .* is out of order\")));",
          "520:       } else {",
          "521:         TF_EXPECT_OK(indices_valid);",
          "522:       }",
          "525:       for (int dim = 0; dim < ndims; ++dim) {",
          "526:         std::swap(indices_mat(row1, dim), indices_mat(row2, dim));",
          "527:       }",
          "528:     }",
          "529:   }",
          "530: }",
          "532: INSTANTIATE_TEST_SUITE_P(",
          "533:     ValidateSparseTensorTestSuite, ValidateSparseTensorTest,",
          "534:     ::testing::Values(IndexValidation::kNone, IndexValidation::kOrdered,",
          "535:                       IndexValidation::kUnordered),",
          "536:     [](const ::testing::TestParamInfo<ValidateSparseTensorTest::ParamType>&",
          "537:            info) {",
          "538:       switch (info.param) {",
          "539:         case IndexValidation::kNone:",
          "540:           return \"None\";",
          "541:         case IndexValidation::kUnordered:",
          "542:           return \"Unordered\";",
          "543:         case IndexValidation::kOrdered:",
          "544:           return \"Ordered\";",
          "545:       }",
          "546:     });",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "80699b1c09888651da0a9a7f55456a73ef86e2fa",
      "candidate_info": {
        "commit_hash": "80699b1c09888651da0a9a7f55456a73ef86e2fa",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/80699b1c09888651da0a9a7f55456a73ef86e2fa",
        "files": [
          "tensorflow/core/kernels/BUILD",
          "tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
        ],
        "message": "Add sparse tensor validation to SparseBincountOp.\n\nAddresses a security issue.\n\nPiperOrigin-RevId: 460573866",
        "before_after_code_files": [
          "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
            "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
            "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc": [
          "File: tensorflow/core/kernels/bincount_op.cc -> tensorflow/core/kernels/bincount_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"tensorflow/core/framework/types.h\"",
          "24: #include \"tensorflow/core/kernels/bincount_op.h\"",
          "25: #include \"tensorflow/core/kernels/fill_functor.h\"",
          "26: #include \"tensorflow/core/lib/core/threadpool.h\"",
          "27: #include \"tensorflow/core/platform/types.h\"",
          "28: #include \"tensorflow/core/util/determinism.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include \"tensorflow/core/kernels/sparse_utils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "370:   void Compute(OpKernelContext* ctx) override {",
          "371:     const Tensor& indices = ctx->input(0);",
          "373:     const Tensor& dense_shape = ctx->input(2);",
          "374:     const Tensor& size_t = ctx->input(3);",
          "375:     const auto weights = ctx->input(4).flat<T>();",
          "",
          "[Removed Lines]",
          "372:     const auto values = ctx->input(1).flat<Tidx>();",
          "",
          "[Added Lines]",
          "373:     const Tensor& values = ctx->input(1);",
          "374:     const auto values_flat = values.flat<Tidx>();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "382:     OP_REQUIRES(",
          "383:         ctx, size >= 0,",
          "384:         errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));",
          "386:     bool is_1d = dense_shape.NumElements() == 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "387:     OP_REQUIRES_OK(",
          "388:         ctx, sparse_utils::ValidateSparseTensor<int64_t>(",
          "389:                  indices, values, dense_shape, /*validate_indices=*/true));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "394:       if (binary_output_) {",
          "395:         OP_REQUIRES_OK(ctx,",
          "396:                        functor::BincountFunctor<Device, Tidx, T, true>::Compute(",
          "398:       } else {",
          "399:         OP_REQUIRES_OK(",
          "400:             ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(",
          "402:       }",
          "403:     } else {",
          "404:       const auto shape = dense_shape.flat<int64_t>();",
          "",
          "[Removed Lines]",
          "397:                            ctx, values, weights, out, size));",
          "401:                      ctx, values, weights, out, size));",
          "",
          "[Added Lines]",
          "402:                            ctx, values_flat, weights, out, size));",
          "406:                      ctx, values_flat, weights, out, size));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "410:       const auto indices_mat = indices.matrix<int64_t>();",
          "411:       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {",
          "412:         const int64_t batch = indices_mat(i, 0);",
          "414:         OP_REQUIRES(",
          "415:             ctx, batch < out.dimension(0),",
          "416:             errors::InvalidArgument(\"Index out of bound. `batch` (\", batch,",
          "",
          "[Removed Lines]",
          "413:         const Tidx bin = values(i);",
          "",
          "[Added Lines]",
          "418:         const Tidx bin = values_flat(i);",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py": [
          "File: tensorflow/python/kernel_tests/math_ops/bincount_op_test.py -> tensorflow/python/kernel_tests/math_ops/bincount_op_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "366:     num_rows = 128",
          "367:     size = 1000",
          "368:     n_elems = 4096",
          "370:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "372:     np_out = np.bincount(inp_vals, minlength=size)",
          "",
          "[Removed Lines]",
          "369:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "369:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "390:     num_rows = 128",
          "391:     size = 1000",
          "392:     n_elems = 4096",
          "394:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "395:     inp_weight = np.random.random((n_elems,))",
          "",
          "[Removed Lines]",
          "393:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "393:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "415:     num_rows = 128",
          "416:     size = 10",
          "417:     n_elems = 4096",
          "419:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "421:     np_out = np.ones((size,))",
          "",
          "[Removed Lines]",
          "418:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "418:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "440:     num_rows = 128",
          "441:     size = 10",
          "442:     n_elems = 4096",
          "444:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "445:     inp_weight = np.random.random((n_elems,))",
          "",
          "[Removed Lines]",
          "443:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "443:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "532:               weights=[0, 0],",
          "533:               binary_output=False))",
          "536: class RaggedBincountOpTest(test_util.TensorFlowTestCase,",
          "537:                            parameterized.TestCase):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535:   def test_sparse_bincount_input_validation(self):",
          "536:     np.random.seed(42)",
          "537:     num_rows = 128",
          "538:     size = 1000",
          "539:     n_elems = 4096",
          "540:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "541:     inp_vals = np.random.randint(0, size, (n_elems,))",
          "543:     # Insert negative index.",
          "544:     inp_indices[10, 0] = -2",
          "546:     with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),",
          "547:                                 \"out of bounds\"):",
          "548:       self.evaluate(",
          "549:           gen_math_ops.sparse_bincount(",
          "550:               indices=inp_indices,",
          "551:               values=inp_vals,",
          "552:               dense_shape=[num_rows],",
          "553:               size=size,",
          "554:               weights=[]))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ca3507945219b72bd92ef4b2a7d71f5cb32a1cb3",
      "candidate_info": {
        "commit_hash": "ca3507945219b72bd92ef4b2a7d71f5cb32a1cb3",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/ca3507945219b72bd92ef4b2a7d71f5cb32a1cb3",
        "files": [
          "tensorflow/core/kernels/BUILD",
          "tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
        ],
        "message": "Add sparse tensor validation to SparseBincountOp.\n\nAddresses a security issue.\n\nPiperOrigin-RevId: 460573866",
        "before_after_code_files": [
          "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
            "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
            "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc": [
          "File: tensorflow/core/kernels/bincount_op.cc -> tensorflow/core/kernels/bincount_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"tensorflow/core/framework/types.h\"",
          "24: #include \"tensorflow/core/kernels/bincount_op.h\"",
          "25: #include \"tensorflow/core/kernels/fill_functor.h\"",
          "26: #include \"tensorflow/core/lib/core/threadpool.h\"",
          "27: #include \"tensorflow/core/platform/types.h\"",
          "28: #include \"tensorflow/core/util/determinism.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include \"tensorflow/core/kernels/sparse_utils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "370:   void Compute(OpKernelContext* ctx) override {",
          "371:     const Tensor& indices = ctx->input(0);",
          "373:     const Tensor& dense_shape = ctx->input(2);",
          "374:     const Tensor& size_t = ctx->input(3);",
          "375:     const auto weights = ctx->input(4).flat<T>();",
          "",
          "[Removed Lines]",
          "372:     const auto values = ctx->input(1).flat<Tidx>();",
          "",
          "[Added Lines]",
          "373:     const Tensor& values = ctx->input(1);",
          "374:     const auto values_flat = values.flat<Tidx>();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "382:     OP_REQUIRES(",
          "383:         ctx, size >= 0,",
          "384:         errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));",
          "386:     bool is_1d = dense_shape.NumElements() == 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "387:     OP_REQUIRES_OK(",
          "388:         ctx, sparse_utils::ValidateSparseTensor<int64_t>(",
          "389:                  indices, values, dense_shape, /*validate_indices=*/true));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "394:       if (binary_output_) {",
          "395:         OP_REQUIRES_OK(ctx,",
          "396:                        functor::BincountFunctor<Device, Tidx, T, true>::Compute(",
          "398:       } else {",
          "399:         OP_REQUIRES_OK(",
          "400:             ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(",
          "402:       }",
          "403:     } else {",
          "404:       const auto shape = dense_shape.flat<int64_t>();",
          "",
          "[Removed Lines]",
          "397:                            ctx, values, weights, out, size));",
          "401:                      ctx, values, weights, out, size));",
          "",
          "[Added Lines]",
          "402:                            ctx, values_flat, weights, out, size));",
          "406:                      ctx, values_flat, weights, out, size));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "410:       const auto indices_mat = indices.matrix<int64_t>();",
          "411:       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {",
          "412:         const int64_t batch = indices_mat(i, 0);",
          "414:         OP_REQUIRES(",
          "415:             ctx, batch < out.dimension(0),",
          "416:             errors::InvalidArgument(\"Index out of bound. `batch` (\", batch,",
          "",
          "[Removed Lines]",
          "413:         const Tidx bin = values(i);",
          "",
          "[Added Lines]",
          "418:         const Tidx bin = values_flat(i);",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/math_ops/bincount_op_test.py||tensorflow/python/kernel_tests/math_ops/bincount_op_test.py": [
          "File: tensorflow/python/kernel_tests/math_ops/bincount_op_test.py -> tensorflow/python/kernel_tests/math_ops/bincount_op_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "366:     num_rows = 128",
          "367:     size = 1000",
          "368:     n_elems = 4096",
          "370:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "372:     np_out = np.bincount(inp_vals, minlength=size)",
          "",
          "[Removed Lines]",
          "369:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "369:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "390:     num_rows = 128",
          "391:     size = 1000",
          "392:     n_elems = 4096",
          "394:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "395:     inp_weight = np.random.random((n_elems,))",
          "",
          "[Removed Lines]",
          "393:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "393:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "415:     num_rows = 128",
          "416:     size = 10",
          "417:     n_elems = 4096",
          "419:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "421:     np_out = np.ones((size,))",
          "",
          "[Removed Lines]",
          "418:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "418:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "440:     num_rows = 128",
          "441:     size = 10",
          "442:     n_elems = 4096",
          "444:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "445:     inp_weight = np.random.random((n_elems,))",
          "",
          "[Removed Lines]",
          "443:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "443:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "532:               weights=[0, 0],",
          "533:               binary_output=False))",
          "536: class RaggedBincountOpTest(test_util.TensorFlowTestCase,",
          "537:                            parameterized.TestCase):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "535:   def test_sparse_bincount_input_validation(self):",
          "536:     np.random.seed(42)",
          "537:     num_rows = 128",
          "538:     size = 1000",
          "539:     n_elems = 4096",
          "540:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "541:     inp_vals = np.random.randint(0, size, (n_elems,))",
          "543:     # Insert negative index.",
          "544:     inp_indices[10, 0] = -2",
          "546:     with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),",
          "547:                                 \"out of bounds\"):",
          "548:       self.evaluate(",
          "549:           gen_math_ops.sparse_bincount(",
          "550:               indices=inp_indices,",
          "551:               values=inp_vals,",
          "552:               dense_shape=[num_rows],",
          "553:               size=size,",
          "554:               weights=[]))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "f2490982282004dbe202cecb8148817e8149177a",
      "candidate_info": {
        "commit_hash": "f2490982282004dbe202cecb8148817e8149177a",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/f2490982282004dbe202cecb8148817e8149177a",
        "files": [
          "tensorflow/core/kernels/BUILD",
          "tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/python/kernel_tests/bincount_op_test.py"
        ],
        "message": "Add sparse tensor validation to SparseBincountOp.\n\nAddresses a security issue.\n\nPiperOrigin-RevId: 460573866",
        "before_after_code_files": [
          "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc",
          "tensorflow/python/kernel_tests/bincount_op_test.py||tensorflow/python/kernel_tests/bincount_op_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/bincount_op.cc||tensorflow/core/kernels/bincount_op.cc": [
          "File: tensorflow/core/kernels/bincount_op.cc -> tensorflow/core/kernels/bincount_op.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"tensorflow/core/framework/types.h\"",
          "24: #include \"tensorflow/core/kernels/bincount_op.h\"",
          "25: #include \"tensorflow/core/kernels/fill_functor.h\"",
          "26: #include \"tensorflow/core/lib/core/threadpool.h\"",
          "27: #include \"tensorflow/core/platform/types.h\"",
          "28: #include \"tensorflow/core/util/determinism.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include \"tensorflow/core/kernels/sparse_utils.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "370:   void Compute(OpKernelContext* ctx) override {",
          "371:     const Tensor& indices = ctx->input(0);",
          "373:     const Tensor& dense_shape = ctx->input(2);",
          "374:     const Tensor& size_t = ctx->input(3);",
          "375:     const auto weights = ctx->input(4).flat<T>();",
          "",
          "[Removed Lines]",
          "372:     const auto values = ctx->input(1).flat<Tidx>();",
          "",
          "[Added Lines]",
          "373:     const Tensor& values = ctx->input(1);",
          "374:     const auto values_flat = values.flat<Tidx>();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "382:     OP_REQUIRES(",
          "383:         ctx, size >= 0,",
          "384:         errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));",
          "386:     bool is_1d = dense_shape.NumElements() == 1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "387:     OP_REQUIRES_OK(",
          "388:         ctx, sparse_utils::ValidateSparseTensor<int64_t>(",
          "389:                  indices, values, dense_shape, /*validate_indices=*/true));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "394:       if (binary_output_) {",
          "395:         OP_REQUIRES_OK(ctx,",
          "396:                        functor::BincountFunctor<Device, Tidx, T, true>::Compute(",
          "398:       } else {",
          "399:         OP_REQUIRES_OK(",
          "400:             ctx, functor::BincountFunctor<Device, Tidx, T, false>::Compute(",
          "402:       }",
          "403:     } else {",
          "404:       const auto shape = dense_shape.flat<int64_t>();",
          "",
          "[Removed Lines]",
          "397:                            ctx, values, weights, out, size));",
          "401:                      ctx, values, weights, out, size));",
          "",
          "[Added Lines]",
          "402:                            ctx, values_flat, weights, out, size));",
          "406:                      ctx, values_flat, weights, out, size));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "410:       const auto indices_mat = indices.matrix<int64_t>();",
          "411:       for (int64_t i = 0; i < indices_mat.dimension(0); ++i) {",
          "412:         const int64_t batch = indices_mat(i, 0);",
          "414:         OP_REQUIRES(",
          "415:             ctx, batch < out.dimension(0),",
          "416:             errors::InvalidArgument(\"Index out of bound. `batch` (\", batch,",
          "",
          "[Removed Lines]",
          "413:         const Tidx bin = values(i);",
          "",
          "[Added Lines]",
          "418:         const Tidx bin = values_flat(i);",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/bincount_op_test.py||tensorflow/python/kernel_tests/bincount_op_test.py": [
          "File: tensorflow/python/kernel_tests/bincount_op_test.py -> tensorflow/python/kernel_tests/bincount_op_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "370:     num_rows = 128",
          "371:     size = 1000",
          "372:     n_elems = 4096",
          "374:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "376:     np_out = np.bincount(inp_vals, minlength=size)",
          "",
          "[Removed Lines]",
          "373:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "373:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "394:     num_rows = 128",
          "395:     size = 1000",
          "396:     n_elems = 4096",
          "398:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "399:     inp_weight = np.random.random((n_elems,))",
          "",
          "[Removed Lines]",
          "397:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "397:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "419:     num_rows = 128",
          "420:     size = 10",
          "421:     n_elems = 4096",
          "423:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "425:     np_out = np.ones((size,))",
          "",
          "[Removed Lines]",
          "422:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "422:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "444:     num_rows = 128",
          "445:     size = 10",
          "446:     n_elems = 4096",
          "448:     inp_vals = np.random.randint(0, size, (n_elems,), dtype=dtype)",
          "449:     inp_weight = np.random.random((n_elems,))",
          "",
          "[Removed Lines]",
          "447:     inp_indices = np.random.randint(0, num_rows, (n_elems,))",
          "",
          "[Added Lines]",
          "447:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "536:               weights=[0, 0],",
          "537:               binary_output=False))",
          "540: class RaggedBincountOpTest(test_util.TensorFlowTestCase,",
          "541:                            parameterized.TestCase):",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "539:   def test_sparse_bincount_input_validation(self):",
          "540:     np.random.seed(42)",
          "541:     num_rows = 128",
          "542:     size = 1000",
          "543:     n_elems = 4096",
          "544:     inp_indices = np.random.randint(0, num_rows, (n_elems, 1))",
          "545:     inp_vals = np.random.randint(0, size, (n_elems,))",
          "547:     # Insert negative index.",
          "548:     inp_indices[10, 0] = -2",
          "550:     with self.assertRaisesRegex((ValueError, errors.InvalidArgumentError),",
          "551:                                 \"out of bounds\"):",
          "552:       self.evaluate(",
          "553:           gen_math_ops.sparse_bincount(",
          "554:               indices=inp_indices,",
          "555:               values=inp_vals,",
          "556:               dense_shape=[num_rows],",
          "557:               size=size,",
          "558:               weights=[]))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-15475",
  "cve_desc": "In nDPI through 3.2, ndpi_reset_packet_line_info in lib/ndpi_main.c omits certain reinitialization, leading to a use-after-free.",
  "repo": "ntop/nDPI",
  "patch_hash": "6a9f5e4f7c3fd5ddab3e6727b071904d76773952",
  "patch_info": {
    "commit_hash": "6a9f5e4f7c3fd5ddab3e6727b071904d76773952",
    "repo": "ntop/nDPI",
    "commit_url": "https://github.com/ntop/nDPI/commit/6a9f5e4f7c3fd5ddab3e6727b071904d76773952",
    "files": [
      "src/lib/ndpi_main.c",
      "tests/pcap/http-crash-content-disposition.pcap",
      "tests/result/WebattackRCE.pcap.out",
      "tests/result/http-crash-content-disposition.pcap.out"
    ],
    "message": "Fixed use after free caused by dangling pointer\n\n * This fix also improved RCE Injection detection\n\nSigned-off-by: Toni Uhlig <matzeton@googlemail.com>",
    "before_after_code_files": [
      "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
    ]
  },
  "patch_diff": {
    "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
      "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4336:     packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,",
      "4337:     packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,",
      "4338:     packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,",
      "4340:     packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,",
      "4341:     packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,",
      "4342:     packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,",
      "",
      "[Removed Lines]",
      "4339:     packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,",
      "",
      "[Added Lines]",
      "4339:     packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,",
      "4340:     packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4d5ca2c473242c65a2bf87a1f0350ccb54fe231b",
      "candidate_info": {
        "commit_hash": "4d5ca2c473242c65a2bf87a1f0350ccb54fe231b",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/4d5ca2c473242c65a2bf87a1f0350ccb54fe231b",
        "files": [
          "src/lib/ndpi_main.c"
        ],
        "message": ":cool: code ident & style",
        "before_after_code_files": [
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "59: static void *(*_ndpi_flow_malloc)(size_t size);",
          "62: static void *(*_ndpi_malloc)(size_t size);",
          "83: }",
          "93: {",
          "101: }",
          "110: }",
          "119: }",
          "134: }",
          "138: {",
          "148: }",
          "156: };",
          "178: }",
          "190: }",
          "194: #ifdef CODE_UNUSED",
          "210: }",
          "211: #endif",
          "230: }",
          "240: }",
          "250: }",
          "",
          "[Removed Lines]",
          "60: static void  (*_ndpi_flow_free)(void *ptr);",
          "63: static void  (*_ndpi_free)(void *ptr);",
          "68: static void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str,",
          "69:       ndpi_port_range *range,",
          "70:       ndpi_proto_defaults_t *def,",
          "71:       u_int8_t customUserProto,",
          "72:       ndpi_default_ports_tree_node_t **root,",
          "73:       const char *_func, int _line);",
          "75: static int removeDefaultPort(ndpi_port_range *range,",
          "76:         ndpi_proto_defaults_t *def,",
          "77:         ndpi_default_ports_tree_node_t **root);",
          "81: static inline uint8_t flow_is_proto(struct ndpi_flow_struct *flow, u_int16_t p) {",
          "82:   return((flow->detected_protocol_stack[0] == p) || (flow->detected_protocol_stack[1] == p));",
          "87: void* ndpi_malloc(size_t size) { return(_ndpi_malloc ? _ndpi_malloc(size) : malloc(size)); }",
          "88: void* ndpi_flow_malloc(size_t size) { return(_ndpi_flow_malloc ? _ndpi_flow_malloc(size) : ndpi_malloc(size)); }",
          "92: void * ndpi_calloc(unsigned long count, size_t size)",
          "94:   size_t len = count*size;",
          "95:   void *p = ndpi_malloc(len);",
          "97:   if(p)",
          "98:     memset(p, 0, len);",
          "100:   return(p);",
          "105: void ndpi_free(void *ptr) {",
          "106:   if(_ndpi_free)",
          "107:     _ndpi_free(ptr);",
          "108:   else",
          "109:     free(ptr);",
          "114: void ndpi_flow_free(void *ptr) {",
          "115:   if(_ndpi_flow_free)",
          "116:     _ndpi_flow_free(ptr);",
          "117:   else",
          "118:     ndpi_free_flow((struct ndpi_flow_struct *) ptr);",
          "123: void * ndpi_realloc(void *ptr, size_t old_size,",
          "124:       size_t new_size) {",
          "125:   void *ret = ndpi_malloc(new_size);",
          "127:   if(!ret)",
          "128:     return(ret);",
          "129:   else {",
          "130:     memcpy(ret, ptr, old_size);",
          "131:     ndpi_free(ptr);",
          "132:     return(ret);",
          "133:   }",
          "137: char * ndpi_strdup(const char *s)",
          "139:   int len = strlen(s);",
          "140:   char *m = ndpi_malloc(len+1);",
          "142:   if(m) {",
          "143:     memcpy(m, s, len);",
          "144:     m[len] = '\\0';",
          "145:   }",
          "147:   return(m);",
          "153: struct ndpi_ptree {",
          "154:   patricia_tree_t *v4;",
          "155:   patricia_tree_t *v6;",
          "160: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_struct(void) { return(sizeof(struct ndpi_flow_struct)); }",
          "164: u_int32_t ndpi_detection_get_sizeof_ndpi_id_struct(void) { return(sizeof(struct ndpi_id_struct)); }",
          "168: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_tcp_struct(void) { return(sizeof(struct ndpi_flow_tcp_struct)); }",
          "172: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_udp_struct(void) { return(sizeof(struct ndpi_flow_udp_struct)); }",
          "176: char * ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_str, u_int id) {",
          "177:   return((id >= ndpi_str->ndpi_num_supported_protocols) ? NULL : ndpi_str->proto_defaults[id].protoName);",
          "182: u_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name) {",
          "183:   u_int16_t i, num = ndpi_get_num_supported_protocols(ndpi_str);",
          "185:   for(i = 0; i < num; i++)",
          "186:     if(strcasecmp(ndpi_get_proto_by_id(ndpi_str, i), name) == 0)",
          "187:       return(i);",
          "189:   return(NDPI_PROTOCOL_UNKNOWN);",
          "195: ndpi_port_range * ndpi_build_default_ports_range(ndpi_port_range *ports,",
          "196:        u_int16_t portA_low, u_int16_t portA_high,",
          "197:        u_int16_t portB_low, u_int16_t portB_high,",
          "198:        u_int16_t portC_low, u_int16_t portC_high,",
          "199:        u_int16_t portD_low, u_int16_t portD_high,",
          "200:        u_int16_t portE_low, u_int16_t portE_high) {",
          "201:   int i = 0;",
          "203:   ports[i].port_low = portA_low, ports[i].port_high = portA_high; i++;",
          "204:   ports[i].port_low = portB_low, ports[i].port_high = portB_high; i++;",
          "205:   ports[i].port_low = portC_low, ports[i].port_high = portC_high; i++;",
          "206:   ports[i].port_low = portD_low, ports[i].port_high = portD_high; i++;",
          "207:   ports[i].port_low = portE_low, ports[i].port_high = portE_high;",
          "209:   return(ports);",
          "215: ndpi_port_range * ndpi_build_default_ports(ndpi_port_range *ports,",
          "216:         u_int16_t portA,",
          "217:         u_int16_t portB,",
          "218:         u_int16_t portC,",
          "219:         u_int16_t portD,",
          "220:         u_int16_t portE) {",
          "221:   int i = 0;",
          "223:   ports[i].port_low = portA, ports[i].port_high = portA; i++;",
          "224:   ports[i].port_low = portB, ports[i].port_high = portB; i++;",
          "225:   ports[i].port_low = portC, ports[i].port_high = portC; i++;",
          "226:   ports[i].port_low = portD, ports[i].port_high = portD; i++;",
          "227:   ports[i].port_low = portE, ports[i].port_high = portE;",
          "229:   return(ports);",
          "234: void ndpi_set_proto_breed(struct ndpi_detection_module_struct *ndpi_str,",
          "235:      u_int16_t protoId, ndpi_protocol_breed_t breed) {",
          "236:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "237:     return;",
          "238:   else",
          "239:     ndpi_str->proto_defaults[protoId].protoBreed = breed;",
          "244: void ndpi_set_proto_category(struct ndpi_detection_module_struct *ndpi_str,",
          "245:         u_int16_t protoId, ndpi_protocol_category_t protoCategory) {",
          "246:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "247:     return;",
          "248:   else",
          "249:     ndpi_str->proto_defaults[protoId].protoCategory = protoCategory;",
          "",
          "[Added Lines]",
          "59: static void (*_ndpi_flow_free)(void *ptr);",
          "62: static void (*_ndpi_free)(void *ptr);",
          "67: static void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,",
          "68:                            ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,",
          "69:                            const char *_func, int _line);",
          "71: static int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root);",
          "75: static inline uint8_t flow_is_proto(struct ndpi_flow_struct *flow, u_int16_t p)",
          "76: {",
          "77:     return ((flow->detected_protocol_stack[0] == p) || (flow->detected_protocol_stack[1] == p));",
          "82: void *ndpi_malloc(size_t size)",
          "83: {",
          "84:     return (_ndpi_malloc ? _ndpi_malloc(size) : malloc(size));",
          "85: }",
          "86: void *ndpi_flow_malloc(size_t size)",
          "87: {",
          "88:     return (_ndpi_flow_malloc ? _ndpi_flow_malloc(size) : ndpi_malloc(size));",
          "89: }",
          "93: void *ndpi_calloc(unsigned long count, size_t size)",
          "95:     size_t len = count * size;",
          "96:     void *p = ndpi_malloc(len);",
          "98:     if (p)",
          "99:         memset(p, 0, len);",
          "101:     return (p);",
          "106: void ndpi_free(void *ptr)",
          "107: {",
          "108:     if (_ndpi_free)",
          "109:         _ndpi_free(ptr);",
          "110:     else",
          "111:         free(ptr);",
          "116: void ndpi_flow_free(void *ptr)",
          "117: {",
          "118:     if (_ndpi_flow_free)",
          "119:         _ndpi_flow_free(ptr);",
          "120:     else",
          "121:         ndpi_free_flow((struct ndpi_flow_struct *) ptr);",
          "126: void *ndpi_realloc(void *ptr, size_t old_size, size_t new_size)",
          "127: {",
          "128:     void *ret = ndpi_malloc(new_size);",
          "130:     if (!ret)",
          "131:         return (ret);",
          "132:     else {",
          "133:         memcpy(ret, ptr, old_size);",
          "134:         ndpi_free(ptr);",
          "135:         return (ret);",
          "136:     }",
          "140: char *ndpi_strdup(const char *s)",
          "142:     int len = strlen(s);",
          "143:     char *m = ndpi_malloc(len + 1);",
          "145:     if (m) {",
          "146:         memcpy(m, s, len);",
          "147:         m[len] = '\\0';",
          "148:     }",
          "150:     return (m);",
          "156: struct ndpi_ptree",
          "157: {",
          "158:     patricia_tree_t *v4;",
          "159:     patricia_tree_t *v6;",
          "164: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_struct(void)",
          "165: {",
          "166:     return (sizeof(struct ndpi_flow_struct));",
          "167: }",
          "171: u_int32_t ndpi_detection_get_sizeof_ndpi_id_struct(void)",
          "172: {",
          "173:     return (sizeof(struct ndpi_id_struct));",
          "174: }",
          "178: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_tcp_struct(void)",
          "179: {",
          "180:     return (sizeof(struct ndpi_flow_tcp_struct));",
          "181: }",
          "185: u_int32_t ndpi_detection_get_sizeof_ndpi_flow_udp_struct(void)",
          "186: {",
          "187:     return (sizeof(struct ndpi_flow_udp_struct));",
          "188: }",
          "192: char *ndpi_get_proto_by_id(struct ndpi_detection_module_struct *ndpi_str, u_int id)",
          "193: {",
          "194:     return ((id >= ndpi_str->ndpi_num_supported_protocols) ? NULL : ndpi_str->proto_defaults[id].protoName);",
          "199: u_int16_t ndpi_get_proto_by_name(struct ndpi_detection_module_struct *ndpi_str, const char *name)",
          "200: {",
          "201:     u_int16_t i, num = ndpi_get_num_supported_protocols(ndpi_str);",
          "203:     for (i = 0; i < num; i++)",
          "204:         if (strcasecmp(ndpi_get_proto_by_id(ndpi_str, i), name) == 0)",
          "205:             return (i);",
          "207:     return (NDPI_PROTOCOL_UNKNOWN);",
          "213: ndpi_port_range *ndpi_build_default_ports_range(ndpi_port_range *ports, u_int16_t portA_low, u_int16_t portA_high,",
          "214:                                                 u_int16_t portB_low, u_int16_t portB_high, u_int16_t portC_low,",
          "215:                                                 u_int16_t portC_high, u_int16_t portD_low, u_int16_t portD_high,",
          "216:                                                 u_int16_t portE_low, u_int16_t portE_high)",
          "217: {",
          "218:     int i = 0;",
          "220:     ports[i].port_low = portA_low, ports[i].port_high = portA_high;",
          "221:     i++;",
          "222:     ports[i].port_low = portB_low, ports[i].port_high = portB_high;",
          "223:     i++;",
          "224:     ports[i].port_low = portC_low, ports[i].port_high = portC_high;",
          "225:     i++;",
          "226:     ports[i].port_low = portD_low, ports[i].port_high = portD_high;",
          "227:     i++;",
          "228:     ports[i].port_low = portE_low, ports[i].port_high = portE_high;",
          "230:     return (ports);",
          "236: ndpi_port_range *ndpi_build_default_ports(ndpi_port_range *ports, u_int16_t portA, u_int16_t portB, u_int16_t portC,",
          "237:                                           u_int16_t portD, u_int16_t portE)",
          "238: {",
          "239:     int i = 0;",
          "241:     ports[i].port_low = portA, ports[i].port_high = portA;",
          "242:     i++;",
          "243:     ports[i].port_low = portB, ports[i].port_high = portB;",
          "244:     i++;",
          "245:     ports[i].port_low = portC, ports[i].port_high = portC;",
          "246:     i++;",
          "247:     ports[i].port_low = portD, ports[i].port_high = portD;",
          "248:     i++;",
          "249:     ports[i].port_low = portE, ports[i].port_high = portE;",
          "251:     return (ports);",
          "256: void ndpi_set_proto_breed(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId, ndpi_protocol_breed_t breed)",
          "257: {",
          "258:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "259:         return;",
          "260:     else",
          "261:         ndpi_str->proto_defaults[protoId].protoBreed = breed;",
          "266: void ndpi_set_proto_category(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId,",
          "267:                              ndpi_protocol_category_t protoCategory)",
          "268: {",
          "269:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "270:         return;",
          "271:     else",
          "272:         ndpi_str->proto_defaults[protoId].protoCategory = protoCategory;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "262:   - HTTP/SSL are NOT informative as SSL.Facebook (likely) means that this is",
          "263:   SSL (HTTPS) traffic containg Facebook traffic.",
          "279: }",
          "287: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "295: #endif",
          "298: }",
          "312: #ifdef DEBUG",
          "314: #endif",
          "319: #ifdef DEBUG",
          "321: #endif",
          "348: }",
          "352: static int ndpi_default_ports_tree_node_t_cmp(const void *a, const void *b)",
          "353: {",
          "360: }",
          "364: void ndpi_default_ports_tree_node_t_walker(const void *node, const ndpi_VISIT which, const int depth)",
          "365: {",
          "375: }",
          "405:     }",
          "407: }",
          "",
          "[Removed Lines]",
          "265: u_int8_t ndpi_is_subprotocol_informative(struct ndpi_detection_module_struct *ndpi_str,",
          "266:       u_int16_t protoId) {",
          "267:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "268:     return(0);",
          "270:   switch(protoId) {",
          "272:   case NDPI_PROTOCOL_DNS:",
          "273:     return(1);",
          "274:     break;",
          "276:   default:",
          "277:     return(0);",
          "278:   }",
          "282: void ndpi_exclude_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "283:       struct ndpi_flow_struct *flow,",
          "284:       u_int16_t protocol_id,",
          "285:       const char *_file, const char *_func,int _line) {",
          "286:   if(protocol_id < NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "288:     if( ndpi_str &&",
          "289:  ndpi_str->ndpi_log_level >= NDPI_LOG_DEBUG &&",
          "290:  ndpi_str->ndpi_debug_printf != NULL) {",
          "292:       (*(ndpi_str->ndpi_debug_printf))(protocol_id, ndpi_str, NDPI_LOG_DEBUG,",
          "293:        _file, _func, _line, \"exclude %s\\n\",ndpi_get_proto_name(ndpi_str, protocol_id));",
          "294:     }",
          "296:     NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, protocol_id);",
          "297:   }",
          "302: void ndpi_set_proto_defaults(struct ndpi_detection_module_struct *ndpi_str,",
          "303:         ndpi_protocol_breed_t breed, u_int16_t protoId,",
          "304:         u_int8_t can_have_a_subprotocol,",
          "305:         u_int16_t tcp_master_protoId[2], u_int16_t udp_master_protoId[2],",
          "306:         char *protoName, ndpi_protocol_category_t protoCategory,",
          "307:         ndpi_port_range *tcpDefPorts, ndpi_port_range *udpDefPorts) {",
          "308:   char *name;",
          "309:   int j;",
          "311:   if(protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "313:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: INTERNAL ERROR\\n\", protoName, protoId);",
          "315:     return;",
          "316:   }",
          "318:   if(ndpi_str->proto_defaults[protoId].protoName != NULL) {",
          "320:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: already initialized. Ignoring it\\n\", protoName, protoId);",
          "322:     return;",
          "323:   }",
          "325:   name = ndpi_strdup(protoName);",
          "327:   if(ndpi_str->proto_defaults[protoId].protoName)",
          "328:     ndpi_free(ndpi_str->proto_defaults[protoId].protoName);",
          "330:   ndpi_str->proto_defaults[protoId].protoName = name,",
          "331:     ndpi_str->proto_defaults[protoId].protoCategory = protoCategory,",
          "332:     ndpi_str->proto_defaults[protoId].protoId = protoId,",
          "333:     ndpi_str->proto_defaults[protoId].protoBreed = breed;",
          "334:   ndpi_str->proto_defaults[protoId].can_have_a_subprotocol = can_have_a_subprotocol;",
          "336:   memcpy(&ndpi_str->proto_defaults[protoId].master_tcp_protoId, tcp_master_protoId, 2*sizeof(u_int16_t));",
          "337:   memcpy(&ndpi_str->proto_defaults[protoId].master_udp_protoId, udp_master_protoId, 2*sizeof(u_int16_t));",
          "339:   for(j=0; j<MAX_DEFAULT_PORTS; j++) {",
          "340:     if(udpDefPorts[j].port_low != 0)",
          "341:       addDefaultPort(ndpi_str, &udpDefPorts[j],",
          "342:        &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->udpRoot, __FUNCTION__,__LINE__);",
          "344:     if(tcpDefPorts[j].port_low != 0)",
          "345:       addDefaultPort(ndpi_str, &tcpDefPorts[j],",
          "346:        &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->tcpRoot, __FUNCTION__,__LINE__);",
          "347:   }",
          "354:   ndpi_default_ports_tree_node_t *fa = (ndpi_default_ports_tree_node_t*)a;",
          "355:   ndpi_default_ports_tree_node_t *fb = (ndpi_default_ports_tree_node_t*)b;",
          "359:   return((fa->default_port == fb->default_port) ? 0 : ((fa->default_port < fb->default_port) ? -1 : 1));",
          "366:   ndpi_default_ports_tree_node_t *f = *(ndpi_default_ports_tree_node_t **)node;",
          "368:   printf(\"<%d>Walk on node %s (%u)\\n\",",
          "369:   depth,",
          "370:   which == ndpi_preorder?\"ndpi_preorder\":",
          "371:   which == ndpi_postorder?\"ndpi_postorder\":",
          "372:   which == ndpi_endorder?\"ndpi_endorder\":",
          "373:   which == ndpi_leaf?\"ndpi_leaf\": \"unknown\",",
          "374:   f->default_port);",
          "379: static void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str,",
          "380:       ndpi_port_range *range,",
          "381:       ndpi_proto_defaults_t *def,",
          "382:       u_int8_t customUserProto,",
          "383:       ndpi_default_ports_tree_node_t **root,",
          "384:       const char *_func, int _line) {",
          "385:   u_int16_t port;",
          "387:   for(port=range->port_low; port<=range->port_high; port++) {",
          "388:     ndpi_default_ports_tree_node_t *node = (ndpi_default_ports_tree_node_t*)ndpi_malloc(sizeof(ndpi_default_ports_tree_node_t));",
          "389:     ndpi_default_ports_tree_node_t *ret;",
          "391:     if(!node) {",
          "392:       NDPI_LOG_ERR(ndpi_str, \"%s:%d not enough memory\\n\", _func, _line);",
          "393:       break;",
          "394:     }",
          "396:     node->proto = def, node->default_port = port, node->customUserProto = customUserProto;",
          "399:     if(ret != node) {",
          "400:       NDPI_LOG_DBG(ndpi_str, \"[NDPI] %s:%d found duplicate for port %u: overwriting it with new value\\n\",",
          "401:      _func, _line, port);",
          "403:       ret->proto = def;",
          "404:       ndpi_free(node);",
          "406:   }",
          "",
          "[Added Lines]",
          "288: u_int8_t ndpi_is_subprotocol_informative(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protoId)",
          "289: {",
          "290:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)",
          "291:         return (0);",
          "293:     switch (protoId) {",
          "295:         case NDPI_PROTOCOL_DNS:",
          "296:             return (1);",
          "297:             break;",
          "299:         default:",
          "300:             return (0);",
          "301:     }",
          "305: void ndpi_exclude_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "306:                            u_int16_t protocol_id, const char *_file, const char *_func, int _line)",
          "307: {",
          "308:     if (protocol_id < NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "310:         if (ndpi_str && ndpi_str->ndpi_log_level >= NDPI_LOG_DEBUG && ndpi_str->ndpi_debug_printf != NULL) {",
          "311:             (*(ndpi_str->ndpi_debug_printf))(protocol_id, ndpi_str, NDPI_LOG_DEBUG, _file, _func, _line, \"exclude %s\\n\",",
          "312:                                              ndpi_get_proto_name(ndpi_str, protocol_id));",
          "313:         }",
          "315:         NDPI_ADD_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, protocol_id);",
          "316:     }",
          "321: void ndpi_set_proto_defaults(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_breed_t breed,",
          "322:                              u_int16_t protoId, u_int8_t can_have_a_subprotocol, u_int16_t tcp_master_protoId[2],",
          "323:                              u_int16_t udp_master_protoId[2], char *protoName, ndpi_protocol_category_t protoCategory,",
          "324:                              ndpi_port_range *tcpDefPorts, ndpi_port_range *udpDefPorts)",
          "325: {",
          "326:     char *name;",
          "327:     int j;",
          "329:     if (protoId >= NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS) {",
          "331:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: INTERNAL ERROR\\n\", protoName, protoId);",
          "333:         return;",
          "334:     }",
          "336:     if (ndpi_str->proto_defaults[protoId].protoName != NULL) {",
          "338:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] %s/protoId=%d: already initialized. Ignoring it\\n\", protoName, protoId);",
          "340:         return;",
          "341:     }",
          "343:     name = ndpi_strdup(protoName);",
          "345:     if (ndpi_str->proto_defaults[protoId].protoName)",
          "346:         ndpi_free(ndpi_str->proto_defaults[protoId].protoName);",
          "348:     ndpi_str->proto_defaults[protoId].protoName = name, ndpi_str->proto_defaults[protoId].protoCategory = protoCategory,",
          "349:     ndpi_str->proto_defaults[protoId].protoId = protoId, ndpi_str->proto_defaults[protoId].protoBreed = breed;",
          "350:     ndpi_str->proto_defaults[protoId].can_have_a_subprotocol = can_have_a_subprotocol;",
          "352:     memcpy(&ndpi_str->proto_defaults[protoId].master_tcp_protoId, tcp_master_protoId, 2 * sizeof(u_int16_t));",
          "353:     memcpy(&ndpi_str->proto_defaults[protoId].master_udp_protoId, udp_master_protoId, 2 * sizeof(u_int16_t));",
          "355:     for (j = 0; j < MAX_DEFAULT_PORTS; j++) {",
          "356:         if (udpDefPorts[j].port_low != 0)",
          "357:             addDefaultPort(ndpi_str, &udpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->udpRoot,",
          "358:                            __FUNCTION__, __LINE__);",
          "360:         if (tcpDefPorts[j].port_low != 0)",
          "361:             addDefaultPort(ndpi_str, &tcpDefPorts[j], &ndpi_str->proto_defaults[protoId], 0, &ndpi_str->tcpRoot,",
          "362:                            __FUNCTION__, __LINE__);",
          "363:     }",
          "370:     ndpi_default_ports_tree_node_t *fa = (ndpi_default_ports_tree_node_t *) a;",
          "371:     ndpi_default_ports_tree_node_t *fb = (ndpi_default_ports_tree_node_t *) b;",
          "375:     return ((fa->default_port == fb->default_port) ? 0 : ((fa->default_port < fb->default_port) ? -1 : 1));",
          "382:     ndpi_default_ports_tree_node_t *f = *(ndpi_default_ports_tree_node_t **) node;",
          "384:     printf(\"<%d>Walk on node %s (%u)\\n\", depth,",
          "385:            which == ndpi_preorder ?",
          "386:                \"ndpi_preorder\" :",
          "387:                which == ndpi_postorder ?",
          "388:                \"ndpi_postorder\" :",
          "389:                which == ndpi_endorder ? \"ndpi_endorder\" : which == ndpi_leaf ? \"ndpi_leaf\" : \"unknown\",",
          "390:            f->default_port);",
          "395: static void addDefaultPort(struct ndpi_detection_module_struct *ndpi_str, ndpi_port_range *range,",
          "396:                            ndpi_proto_defaults_t *def, u_int8_t customUserProto, ndpi_default_ports_tree_node_t **root,",
          "397:                            const char *_func, int _line)",
          "398: {",
          "399:     u_int16_t port;",
          "401:     for (port = range->port_low; port <= range->port_high; port++) {",
          "402:         ndpi_default_ports_tree_node_t *node =",
          "403:             (ndpi_default_ports_tree_node_t *) ndpi_malloc(sizeof(ndpi_default_ports_tree_node_t));",
          "404:         ndpi_default_ports_tree_node_t *ret;",
          "406:         if (!node) {",
          "407:             NDPI_LOG_ERR(ndpi_str, \"%s:%d not enough memory\\n\", _func, _line);",
          "408:             break;",
          "409:         }",
          "411:         node->proto = def, node->default_port = port, node->customUserProto = customUserProto;",
          "412:         ret = (ndpi_default_ports_tree_node_t *) ndpi_tsearch(",
          "415:         if (ret != node) {",
          "416:             NDPI_LOG_DBG(ndpi_str, \"[NDPI] %s:%d found duplicate for port %u: overwriting it with new value\\n\", _func,",
          "417:                          _line, port);",
          "419:             ret->proto = def;",
          "420:             ndpi_free(node);",
          "421:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "414:   This function must be called with a semaphore set, this in order to avoid",
          "415:   changing the datastructures while using them",
          "420: {",
          "434:     }",
          "438: }",
          "463: #ifdef MATCH_DEBUG",
          "466: #endif",
          "480: }",
          "493: #ifdef DEBUG",
          "495: #endif",
          "506: }",
          "510: #ifdef CODE_UNUSED",
          "517: }",
          "518: #endif",
          "",
          "[Removed Lines]",
          "417: static int removeDefaultPort(ndpi_port_range *range,",
          "418:         ndpi_proto_defaults_t *def,",
          "419:         ndpi_default_ports_tree_node_t **root)",
          "421:   ndpi_default_ports_tree_node_t node;",
          "422:   u_int16_t port;",
          "424:   for(port=range->port_low; port<=range->port_high; port++) {",
          "425:     ndpi_default_ports_tree_node_t *ret;",
          "427:     node.proto = def, node.default_port = port;",
          "428:     ret = (ndpi_default_ports_tree_node_t*)ndpi_tdelete(&node, (void*)root,",
          "431:     if(ret != NULL) {",
          "432:       ndpi_free((ndpi_default_ports_tree_node_t*)ret);",
          "433:       return(0);",
          "435:   }",
          "437:   return(-1);",
          "442: static int ndpi_string_to_automa(struct ndpi_detection_module_struct *ndpi_str,",
          "443:      ndpi_automa *automa,",
          "444:      char *value, u_int16_t protocol_id,",
          "445:      ndpi_protocol_category_t category,",
          "446:      ndpi_protocol_breed_t breed,",
          "447:      u_int8_t free_str_on_duplicate) {",
          "448:   AC_PATTERN_t ac_pattern;",
          "449:   AC_ERROR_t rc;",
          "451:   if((value == NULL)",
          "452:      || (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS))) {",
          "453:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] protoId=%d: INTERNAL ERROR\\n\", protocol_id);",
          "454:     return(-1);",
          "455:   }",
          "457:   if(automa->ac_automa == NULL) return(-2);",
          "458:   ac_pattern.astring = value,",
          "459:     ac_pattern.rep.number = protocol_id,",
          "460:     ac_pattern.rep.category = (u_int16_t)category,",
          "461:     ac_pattern.rep.breed = (u_int16_t)breed;",
          "464:   printf(\"Adding to automa [%s][protocol_id: %u][category: %u][breed: %u]\\n\",",
          "465:   value, protocol_id, category, breed);",
          "468:   if(value == NULL)",
          "469:     ac_pattern.length = 0;",
          "470:   else",
          "471:     ac_pattern.length = strlen(ac_pattern.astring);",
          "473:   rc = ac_automata_add(((AC_AUTOMATA_t*)automa->ac_automa), &ac_pattern);",
          "474:   if (rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS)",
          "475:     return(-2);",
          "476:   if (rc == ACERR_DUPLICATE_PATTERN && free_str_on_duplicate)",
          "477:     ndpi_free(value);",
          "479:   return(0);",
          "484: static int ndpi_add_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "485:       char *_value, int protocol_id,",
          "486:       ndpi_protocol_category_t category,",
          "487:       ndpi_protocol_breed_t breed) {",
          "488:   int rv;",
          "489:   char *value = ndpi_strdup(_value);",
          "491:   if(!value) return(-1);",
          "494:   NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding [%s][%d]\\n\", value, protocol_id);",
          "497:   rv = ndpi_string_to_automa(ndpi_str,",
          "498:           &ndpi_str->host_automa,",
          "499:           value,",
          "500:           protocol_id,",
          "501:           category, breed, 1);",
          "503:   if(rv != 0) ndpi_free(value);",
          "505:   return(rv);",
          "511: int ndpi_add_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "512:      char *value, int protocol_id,",
          "513:      ndpi_protocol_category_t category,",
          "514:      ndpi_protocol_breed_t breed) {",
          "515:   return(ndpi_string_to_automa(ndpi_str, &ndpi_str->content_automa,",
          "516:           value, protocol_id, category, breed, 0));",
          "",
          "[Added Lines]",
          "433: static int removeDefaultPort(ndpi_port_range *range, ndpi_proto_defaults_t *def, ndpi_default_ports_tree_node_t **root)",
          "435:     ndpi_default_ports_tree_node_t node;",
          "436:     u_int16_t port;",
          "438:     for (port = range->port_low; port <= range->port_high; port++) {",
          "439:         ndpi_default_ports_tree_node_t *ret;",
          "441:         node.proto = def, node.default_port = port;",
          "442:         ret = (ndpi_default_ports_tree_node_t *) ndpi_tdelete(",
          "445:         if (ret != NULL) {",
          "446:             ndpi_free((ndpi_default_ports_tree_node_t *) ret);",
          "447:             return (0);",
          "448:         }",
          "451:     return (-1);",
          "456: static int ndpi_string_to_automa(struct ndpi_detection_module_struct *ndpi_str, ndpi_automa *automa, char *value,",
          "457:                                  u_int16_t protocol_id, ndpi_protocol_category_t category, ndpi_protocol_breed_t breed,",
          "458:                                  u_int8_t free_str_on_duplicate)",
          "459: {",
          "460:     AC_PATTERN_t ac_pattern;",
          "461:     AC_ERROR_t rc;",
          "463:     if ((value == NULL) || (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))) {",
          "464:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] protoId=%d: INTERNAL ERROR\\n\", protocol_id);",
          "465:         return (-1);",
          "466:     }",
          "468:     if (automa->ac_automa == NULL)",
          "469:         return (-2);",
          "470:     ac_pattern.astring = value, ac_pattern.rep.number = protocol_id, ac_pattern.rep.category = (u_int16_t) category,",
          "471:     ac_pattern.rep.breed = (u_int16_t) breed;",
          "474:     printf(\"Adding to automa [%s][protocol_id: %u][category: %u][breed: %u]\\n\", value, protocol_id, category, breed);",
          "477:     if (value == NULL)",
          "478:         ac_pattern.length = 0;",
          "479:     else",
          "480:         ac_pattern.length = strlen(ac_pattern.astring);",
          "482:     rc = ac_automata_add(((AC_AUTOMATA_t *) automa->ac_automa), &ac_pattern);",
          "483:     if (rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS)",
          "484:         return (-2);",
          "485:     if (rc == ACERR_DUPLICATE_PATTERN && free_str_on_duplicate)",
          "486:         ndpi_free(value);",
          "488:     return (0);",
          "493: static int ndpi_add_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *_value, int protocol_id,",
          "494:                                          ndpi_protocol_category_t category, ndpi_protocol_breed_t breed)",
          "495: {",
          "496:     int rv;",
          "497:     char *value = ndpi_strdup(_value);",
          "499:     if (!value)",
          "500:         return (-1);",
          "503:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding [%s][%d]\\n\", value, protocol_id);",
          "506:     rv = ndpi_string_to_automa(ndpi_str, &ndpi_str->host_automa, value, protocol_id, category, breed, 1);",
          "508:     if (rv != 0)",
          "509:         ndpi_free(value);",
          "511:     return (rv);",
          "517: int ndpi_add_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id,",
          "518:                                  ndpi_protocol_category_t category, ndpi_protocol_breed_t breed)",
          "519: {",
          "520:     return (ndpi_string_to_automa(ndpi_str, &ndpi_str->content_automa, value, protocol_id, category, breed, 0));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "525:   This function must be called with a semaphore set, this in order to avoid",
          "526:   changing the datastructures while using them",
          "530: {",
          "533: }",
          "565: }",
          "569: #ifdef HAVE_HYPERSCAN",
          "591: }",
          "609: }",
          "658: #ifdef DEBUG",
          "660: #endif",
          "662:     }",
          "676: }",
          "686: }",
          "693: }",
          "695: #endif",
          "",
          "[Removed Lines]",
          "528: static int ndpi_remove_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "529:          char *value, int protocol_id)",
          "531:   NDPI_LOG_ERR(ndpi_str, \"[NDPI] Missing implementation for proto %s/%d\\n\",value,protocol_id);",
          "532:   return(-1);",
          "537: void ndpi_init_protocol_match(struct ndpi_detection_module_struct *ndpi_str,",
          "538:          ndpi_protocol_match *match) {",
          "539:   u_int16_t no_master[2] = { NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO };",
          "540:   ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "542:   if(ndpi_str->proto_defaults[match->protocol_id].protoName == NULL) {",
          "543:     ndpi_str->proto_defaults[match->protocol_id].protoName    = ndpi_strdup(match->proto_name);",
          "545:     ndpi_str->proto_defaults[match->protocol_id].protoId       = match->protocol_id;",
          "546:     ndpi_str->proto_defaults[match->protocol_id].protoCategory = match->protocol_category;",
          "547:     ndpi_str->proto_defaults[match->protocol_id].protoBreed    = match->protocol_breed;",
          "549:     ndpi_set_proto_defaults(ndpi_str,",
          "550:        ndpi_str->proto_defaults[match->protocol_id].protoBreed,",
          "551:        ndpi_str->proto_defaults[match->protocol_id].protoId,",
          "552:        0 /* can_have_a_subprotocol */,",
          "553:        no_master, no_master,",
          "554:        ndpi_str->proto_defaults[match->protocol_id].protoName,",
          "555:        ndpi_str->proto_defaults[match->protocol_id].protoCategory,",
          "556:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "557:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "558:   }",
          "560:   ndpi_add_host_url_subprotocol(ndpi_str,",
          "561:     match->string_to_match,",
          "562:     match->protocol_id,",
          "563:     match->protocol_category,",
          "564:     match->protocol_breed);",
          "571: static int hyperscan_load_patterns(struct hs *hs, u_int num_patterns,",
          "572:        const char **expressions, unsigned int *ids) {",
          "573:   hs_compile_error_t *compile_err;",
          "575:   if(hs_compile_multi(expressions, NULL, ids,",
          "576:         num_patterns, HS_MODE_BLOCK, NULL,",
          "577:         &hs->database, &compile_err) != HS_SUCCESS) {",
          "578:     NDPI_LOG_ERR(ndpi_str, \"Unable to initialize hyperscan database\\n\");",
          "579:     hs_free_compile_error(compile_err);",
          "580:     return(-1);",
          "581:   }",
          "583:   hs->scratch = NULL;",
          "584:   if(hs_alloc_scratch(hs->database, &hs->scratch) != HS_SUCCESS) {",
          "585:     NDPI_LOG_ERR(ndpi_str, \"Unable to allocate hyperscan scratch space\\n\");",
          "586:     hs_free_database(hs->database);",
          "587:     return(-1);",
          "588:   }",
          "590:   return(0);",
          "595: static char* string2hex(const char *pat) {",
          "596:   u_int patlen, i;",
          "597:   char *hexbuf, *buf;",
          "599:   patlen = strlen(pat);",
          "600:   hexbuf = (char*)ndpi_calloc(sizeof(char), patlen * 4 + 1);",
          "601:   if(!hexbuf) return(NULL);",
          "603:   for (i = 0, buf = hexbuf; i < patlen; i++, buf += 4) {",
          "604:     snprintf(buf, 5, \"\\\\x%02x\", (unsigned char)pat[i]);",
          "605:   }",
          "608:   return(hexbuf);",
          "613: static int init_hyperscan(struct ndpi_detection_module_struct *ndpi_str) {",
          "614:   u_int num_patterns = 0, i, j;",
          "615:   char **expressions;",
          "616:   unsigned int *ids;",
          "617:   unsigned char *need_to_be_free;",
          "618:   struct hs *hs;",
          "619:   int rc;",
          "621:   ndpi_str->hyperscan = (void*)ndpi_malloc(sizeof(struct hs));",
          "622:   if(!ndpi_str->hyperscan) return(-1);",
          "623:   hs = (struct hs*)ndpi_str->hyperscan;",
          "625:   for(i = 0; (host_match[i].string_to_match != NULL)",
          "626:  || (host_match[i].pattern_to_match != NULL); i++)",
          "627:     num_patterns++;",
          "629:   expressions = (char**)ndpi_calloc(sizeof(char*), num_patterns + 1);",
          "630:   if(!expressions) return(-1);",
          "632:   ids = (unsigned int*)ndpi_calloc(sizeof(unsigned int), num_patterns + 1);",
          "633:   if(!ids) {",
          "634:     ndpi_free(expressions);",
          "635:     return(-1);",
          "636:   }",
          "638:   need_to_be_free = (unsigned char*)ndpi_calloc(sizeof(unsigned char), num_patterns + 1);",
          "639:   if(!need_to_be_free) {",
          "640:     ndpi_free(expressions);",
          "641:     ndpi_free(ids);",
          "642:     return(-1);",
          "643:   }",
          "645:   for(i = 0, j = 0; host_match[i].string_to_match != NULL || host_match[i].pattern_to_match != NULL; i++) {",
          "646:     if(host_match[i].pattern_to_match) {",
          "647:       expressions[j] = host_match[i].pattern_to_match;",
          "648:       ids[j] = host_match[i].protocol_id;",
          "649:       need_to_be_free[j] = 0;",
          "650:       ++j;",
          "651:     } else {",
          "652:       expressions[j] = string2hex(host_match[i].string_to_match);",
          "653:       if(expressions[j] != NULL) {",
          "654:         ids[j] = host_match[i].protocol_id;",
          "655:         need_to_be_free[j] = 1;",
          "656:         ++j;",
          "657:       } else {",
          "659:         printf(\"Fail to calloc memory for %s\\n\", host_match[i].string_to_match);",
          "661:       }",
          "664:   }",
          "666:   rc = hyperscan_load_patterns(hs, j, (const char**)expressions, ids);",
          "668:   for(i = 0; i < j; ++i)",
          "669:     if(need_to_be_free[i])",
          "670:       ndpi_free(expressions[i]);",
          "672:   ndpi_free(expressions), ndpi_free(ids);",
          "673:   ndpi_free(need_to_be_free);",
          "675:   return(rc);",
          "680: static void free_hyperscan_memory(struct hs *h) {",
          "681:   if(h) {",
          "682:     hs_free_scratch(h->scratch);",
          "683:     hs_free_database(h->database);",
          "684:     ndpi_free(h);",
          "685:   }",
          "690: static void destroy_hyperscan(struct ndpi_detection_module_struct *ndpi_str) {",
          "691:   if(ndpi_str->hyperscan)",
          "692:     free_hyperscan_memory((struct hs*)ndpi_str->hyperscan);",
          "",
          "[Added Lines]",
          "532: static int ndpi_remove_host_url_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id)",
          "534:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] Missing implementation for proto %s/%d\\n\", value, protocol_id);",
          "535:     return (-1);",
          "540: void ndpi_init_protocol_match(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_match *match)",
          "541: {",
          "542:     u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};",
          "543:     ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "545:     if (ndpi_str->proto_defaults[match->protocol_id].protoName == NULL) {",
          "546:         ndpi_str->proto_defaults[match->protocol_id].protoName = ndpi_strdup(match->proto_name);",
          "548:         ndpi_str->proto_defaults[match->protocol_id].protoId = match->protocol_id;",
          "549:         ndpi_str->proto_defaults[match->protocol_id].protoCategory = match->protocol_category;",
          "550:         ndpi_str->proto_defaults[match->protocol_id].protoBreed = match->protocol_breed;",
          "552:         ndpi_set_proto_defaults(ndpi_str, ndpi_str->proto_defaults[match->protocol_id].protoBreed,",
          "553:                                 ndpi_str->proto_defaults[match->protocol_id].protoId, 0 /* can_have_a_subprotocol */,",
          "554:                                 no_master, no_master, ndpi_str->proto_defaults[match->protocol_id].protoName,",
          "555:                                 ndpi_str->proto_defaults[match->protocol_id].protoCategory,",
          "556:                                 ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "557:                                 ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "558:     }",
          "560:     ndpi_add_host_url_subprotocol(ndpi_str, match->string_to_match, match->protocol_id, match->protocol_category,",
          "561:                                   match->protocol_breed);",
          "568: static int hyperscan_load_patterns(struct hs *hs, u_int num_patterns, const char **expressions, unsigned int *ids)",
          "569: {",
          "570:     hs_compile_error_t *compile_err;",
          "572:     if (hs_compile_multi(expressions, NULL, ids, num_patterns, HS_MODE_BLOCK, NULL, &hs->database, &compile_err) !=",
          "573:         HS_SUCCESS) {",
          "574:         NDPI_LOG_ERR(ndpi_str, \"Unable to initialize hyperscan database\\n\");",
          "575:         hs_free_compile_error(compile_err);",
          "576:         return (-1);",
          "577:     }",
          "579:     hs->scratch = NULL;",
          "580:     if (hs_alloc_scratch(hs->database, &hs->scratch) != HS_SUCCESS) {",
          "581:         NDPI_LOG_ERR(ndpi_str, \"Unable to allocate hyperscan scratch space\\n\");",
          "582:         hs_free_database(hs->database);",
          "583:         return (-1);",
          "584:     }",
          "586:     return (0);",
          "591: static char *string2hex(const char *pat)",
          "592: {",
          "593:     u_int patlen, i;",
          "594:     char *hexbuf, *buf;",
          "596:     patlen = strlen(pat);",
          "597:     hexbuf = (char *) ndpi_calloc(sizeof(char), patlen * 4 + 1);",
          "598:     if (!hexbuf)",
          "599:         return (NULL);",
          "601:     for (i = 0, buf = hexbuf; i < patlen; i++, buf += 4) {",
          "602:         snprintf(buf, 5, \"\\\\x%02x\", (unsigned char) pat[i]);",
          "603:     }",
          "606:     return (hexbuf);",
          "611: static int init_hyperscan(struct ndpi_detection_module_struct *ndpi_str)",
          "612: {",
          "613:     u_int num_patterns = 0, i, j;",
          "614:     char **expressions;",
          "615:     unsigned int *ids;",
          "616:     unsigned char *need_to_be_free;",
          "617:     struct hs *hs;",
          "618:     int rc;",
          "620:     ndpi_str->hyperscan = (void *) ndpi_malloc(sizeof(struct hs));",
          "621:     if (!ndpi_str->hyperscan)",
          "622:         return (-1);",
          "623:     hs = (struct hs *) ndpi_str->hyperscan;",
          "625:     for (i = 0; (host_match[i].string_to_match != NULL) || (host_match[i].pattern_to_match != NULL); i++)",
          "626:         num_patterns++;",
          "628:     expressions = (char **) ndpi_calloc(sizeof(char *), num_patterns + 1);",
          "629:     if (!expressions)",
          "630:         return (-1);",
          "632:     ids = (unsigned int *) ndpi_calloc(sizeof(unsigned int), num_patterns + 1);",
          "633:     if (!ids) {",
          "634:         ndpi_free(expressions);",
          "635:         return (-1);",
          "636:     }",
          "638:     need_to_be_free = (unsigned char *) ndpi_calloc(sizeof(unsigned char), num_patterns + 1);",
          "639:     if (!need_to_be_free) {",
          "640:         ndpi_free(expressions);",
          "641:         ndpi_free(ids);",
          "642:         return (-1);",
          "643:     }",
          "645:     for (i = 0, j = 0; host_match[i].string_to_match != NULL || host_match[i].pattern_to_match != NULL; i++) {",
          "646:         if (host_match[i].pattern_to_match) {",
          "647:             expressions[j] = host_match[i].pattern_to_match;",
          "648:             ids[j] = host_match[i].protocol_id;",
          "649:             need_to_be_free[j] = 0;",
          "650:             ++j;",
          "651:         } else {",
          "652:             expressions[j] = string2hex(host_match[i].string_to_match);",
          "653:             if (expressions[j] != NULL) {",
          "654:                 ids[j] = host_match[i].protocol_id;",
          "655:                 need_to_be_free[j] = 1;",
          "656:                 ++j;",
          "657:             } else {",
          "659:                 printf(\"Fail to calloc memory for %s\\n\", host_match[i].string_to_match);",
          "661:             }",
          "662:         }",
          "666:     rc = hyperscan_load_patterns(hs, j, (const char **) expressions, ids);",
          "668:     for (i = 0; i < j; ++i)",
          "669:         if (need_to_be_free[i])",
          "670:             ndpi_free(expressions[i]);",
          "672:     ndpi_free(expressions), ndpi_free(ids);",
          "673:     ndpi_free(need_to_be_free);",
          "675:     return (rc);",
          "680: static void free_hyperscan_memory(struct hs *h)",
          "681: {",
          "682:     if (h) {",
          "683:         hs_free_scratch(h->scratch);",
          "684:         hs_free_database(h->database);",
          "685:         ndpi_free(h);",
          "686:     }",
          "691: static void destroy_hyperscan(struct ndpi_detection_module_struct *ndpi_str)",
          "692: {",
          "693:     if (ndpi_str->hyperscan)",
          "694:         free_hyperscan_memory((struct hs *) ndpi_str->hyperscan);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "711:     }",
          "713: }",
          "720: #ifdef HAVE_HYPERSCAN",
          "723: #endif",
          "730: #ifdef MATCH_DEBUG",
          "732: #endif",
          "743: }",
          "760: }",
          "776:     }",
          "778: }",
          "",
          "[Removed Lines]",
          "700: void ndpi_self_check_host_match() {",
          "701:   u_int32_t i, j;",
          "703:   for(i=0; host_match[i].string_to_match != NULL; i++) {",
          "704:     for(j=0; host_match[j].string_to_match != NULL; j++) {",
          "705:       if((i != j) && (strcmp(host_match[i].string_to_match, host_match[j].string_to_match) == 0)) {",
          "706:  printf(\"[INTERNAL ERROR]: Duplicate string detected '%s' [id: %u, id %u]\\n\",",
          "707:         host_match[i].string_to_match, i, j);",
          "708:  printf(\"\\nPlease fix host_match[] in ndpi_content_match.c.inc\\n\");",
          "709:  exit(0);",
          "710:       }",
          "712:   }",
          "717: static void init_string_based_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "718:   int i;",
          "722:   init_hyperscan(ndpi_str);",
          "725:   for(i=0; host_match[i].string_to_match != NULL; i++)",
          "726:     ndpi_init_protocol_match(ndpi_str, &host_match[i]);",
          "728:   ndpi_enable_loaded_categories(ndpi_str);",
          "734:   for(i=0; ndpi_en_bigrams[i] != NULL; i++)",
          "735:     ndpi_string_to_automa(ndpi_str, &ndpi_str->bigrams_automa,",
          "736:      (char*)ndpi_en_bigrams[i],",
          "737:      1, 1, 1, 0);",
          "739:   for(i=0; ndpi_en_impossible_bigrams[i] != NULL; i++)",
          "740:     ndpi_string_to_automa(ndpi_str, &ndpi_str->impossible_bigrams_automa,",
          "741:      (char*)ndpi_en_impossible_bigrams[i],",
          "742:      1, 1, 1, 0);",
          "747: int ndpi_set_detection_preferences(struct ndpi_detection_module_struct *ndpi_str,",
          "748:        ndpi_detection_preference pref,",
          "749:        int value) {",
          "750:   switch(pref) {",
          "751:   case ndpi_pref_direction_detect_disable:",
          "752:     ndpi_str->direction_detect_disable = (u_int8_t)value;",
          "753:     break;",
          "755:   default:",
          "756:     return(-1);",
          "757:   }",
          "759:   return(0);",
          "764: static void ndpi_validate_protocol_initialization(struct ndpi_detection_module_struct *ndpi_str) {",
          "765:   int i;",
          "767:   for(i=0; i<(int)ndpi_str->ndpi_num_supported_protocols; i++) {",
          "768:     if(ndpi_str->proto_defaults[i].protoName == NULL) {",
          "769:       NDPI_LOG_ERR(ndpi_str, \"[NDPI] INTERNAL ERROR missing protoName initialization for [protoId=%d]: recovering\\n\",  i);",
          "770:     } else {",
          "771:       if((i != NDPI_PROTOCOL_UNKNOWN)",
          "772:   && (ndpi_str->proto_defaults[i].protoCategory == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "773:  NDPI_LOG_ERR(ndpi_str, \"[NDPI] INTERNAL ERROR missing category [protoId=%d/%s] initialization: recovering\\n\",",
          "774:        i, ndpi_str->proto_defaults[i].protoName ? ndpi_str->proto_defaults[i].protoName : \"???\");",
          "775:       }",
          "777:   }",
          "",
          "[Added Lines]",
          "702: void ndpi_self_check_host_match()",
          "703: {",
          "704:     u_int32_t i, j;",
          "706:     for (i = 0; host_match[i].string_to_match != NULL; i++) {",
          "707:         for (j = 0; host_match[j].string_to_match != NULL; j++) {",
          "708:             if ((i != j) && (strcmp(host_match[i].string_to_match, host_match[j].string_to_match) == 0)) {",
          "709:                 printf(\"[INTERNAL ERROR]: Duplicate string detected '%s' [id: %u, id %u]\\n\",",
          "710:                        host_match[i].string_to_match, i, j);",
          "711:                 printf(\"\\nPlease fix host_match[] in ndpi_content_match.c.inc\\n\");",
          "712:                 exit(0);",
          "713:             }",
          "714:         }",
          "720: static void init_string_based_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "721: {",
          "722:     int i;",
          "726:     init_hyperscan(ndpi_str);",
          "729:     for (i = 0; host_match[i].string_to_match != NULL; i++)",
          "730:         ndpi_init_protocol_match(ndpi_str, &host_match[i]);",
          "732:     ndpi_enable_loaded_categories(ndpi_str);",
          "738:     for (i = 0; ndpi_en_bigrams[i] != NULL; i++)",
          "739:         ndpi_string_to_automa(ndpi_str, &ndpi_str->bigrams_automa, (char *) ndpi_en_bigrams[i], 1, 1, 1, 0);",
          "741:     for (i = 0; ndpi_en_impossible_bigrams[i] != NULL; i++)",
          "742:         ndpi_string_to_automa(ndpi_str, &ndpi_str->impossible_bigrams_automa, (char *) ndpi_en_impossible_bigrams[i], 1,",
          "743:                               1, 1, 0);",
          "748: int ndpi_set_detection_preferences(struct ndpi_detection_module_struct *ndpi_str, ndpi_detection_preference pref,",
          "749:                                    int value)",
          "750: {",
          "751:     switch (pref) {",
          "752:         case ndpi_pref_direction_detect_disable:",
          "753:             ndpi_str->direction_detect_disable = (u_int8_t) value;",
          "754:             break;",
          "756:         default:",
          "757:             return (-1);",
          "758:     }",
          "760:     return (0);",
          "765: static void ndpi_validate_protocol_initialization(struct ndpi_detection_module_struct *ndpi_str)",
          "766: {",
          "767:     int i;",
          "769:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {",
          "770:         if (ndpi_str->proto_defaults[i].protoName == NULL) {",
          "771:             NDPI_LOG_ERR(ndpi_str,",
          "772:                          \"[NDPI] INTERNAL ERROR missing protoName initialization for [protoId=%d]: recovering\\n\", i);",
          "773:         } else {",
          "774:             if ((i != NDPI_PROTOCOL_UNKNOWN) &&",
          "775:                 (ndpi_str->proto_defaults[i].protoCategory == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "776:                 NDPI_LOG_ERR(ndpi_str,",
          "777:                              \"[NDPI] INTERNAL ERROR missing category [protoId=%d/%s] initialization: recovering\\n\", i,",
          "778:                              ndpi_str->proto_defaults[i].protoName ? ndpi_str->proto_defaults[i].protoName : \"???\");",
          "779:             }",
          "780:         }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "785:    Do NOT add web services (NDPI_SERVICE_xxx) here.",
          "793:     memset(ndpi_str->proto_defaults, 0, sizeof(ndpi_str->proto_defaults));",
          "925:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECT_DOWNLOAD_LINK,",
          "930:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_APPLEJUICE,",
          "935:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_DIRECTCONNECT,",
          "955:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_KONTIKI,",
          "960:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_OPENFT,",
          "965:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_FASTTRACK,",
          "970:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_GNUTELLA,",
          "990:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE_CALL,",
          "1025:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NEST_LOG_SINK,",
          "1035:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_CALL,",
          "1078:                             ndpi_build_default_ports(ports_a, 1935, 3478, 3479, 3480, 0) /* TCP */,",
          "1130:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_DOWNLOAD,",
          "1166:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UNENCRYPTED_JABBER,",
          "1201:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_HOTSPOT_SHIELD,",
          "1212:     custom_master[0] = NDPI_PROTOCOL_SIP, custom_master[1] = NDPI_PROTOCOL_H323;",
          "1253:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IP_IN_IP,",
          "1273:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PCANYWHERE,",
          "1283:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP_FILES,",
          "1332:                             ndpi_build_default_ports(ports_a, 6556, 0, 0, 0, 0) /* TCP */,",
          "1333:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1334:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_STEALTHNET,",
          "1394:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_ACTIVESYNC,",
          "1449:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_CONNECT,",
          "1454:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_PROXY,",
          "1474:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMVIEWER,",
          "1479:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LOTUS_NOTES,",
          "1514:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_APPLE_PUSH,",
          "1544:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KAKAOTALK_VOICE,",
          "1716:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HANGOUT_DUO,",
          "1771:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TARGUS_GETDATA,",
          "1776:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMAZON_VIDEO,",
          "1820: #ifdef CUSTOM_NDPI_PROTOCOLS",
          "1821: #include \"../../../nDPI-custom/custom_ndpi_main.c\"",
          "",
          "[Removed Lines]",
          "787: static void ndpi_init_protocol_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "788:   ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "789:   u_int16_t no_master[2] = { NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO },",
          "790:     custom_master[2];",
          "795:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNRATED, NDPI_PROTOCOL_UNKNOWN,",
          "796:        0 /* can_have_a_subprotocol */, no_master,",
          "797:        no_master, \"Unknown\", NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "798:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "799:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "800:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_FTP_CONTROL,",
          "801:        0 /* can_have_a_subprotocol */, no_master,",
          "802:        no_master, \"FTP_CONTROL\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "803:        ndpi_build_default_ports(ports_a, 21, 0, 0, 0, 0) /* TCP */,",
          "804:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "805:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_FTP_DATA,",
          "806:        0 /* can_have_a_subprotocol */, no_master,",
          "807:        no_master, \"FTP_DATA\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "808:        ndpi_build_default_ports(ports_a, 20, 0, 0, 0, 0) /* TCP */,",
          "809:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "810:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_POP,",
          "811:        0 /* can_have_a_subprotocol */, no_master,",
          "812:        no_master, \"POP3\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "813:        ndpi_build_default_ports(ports_a, 110, 0, 0, 0, 0) /* TCP */,",
          "814:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "815:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_POPS,",
          "816:        0 /* can_have_a_subprotocol */, no_master,",
          "817:        no_master, \"POPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "818:        ndpi_build_default_ports(ports_a, 995, 0, 0, 0, 0) /* TCP */,",
          "819:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "820:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MAIL_SMTP,",
          "821:        0 /* can_have_a_subprotocol */, no_master,",
          "822:        no_master, \"SMTP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "823:        ndpi_build_default_ports(ports_a, 25, 0, 0, 0, 0) /* TCP */,",
          "824:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "825:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_SMTPS,",
          "826:        0 /* can_have_a_subprotocol */, no_master,",
          "827:        no_master, \"SMTPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "828:        ndpi_build_default_ports(ports_a, 465, 587, 0, 0, 0) /* TCP */,",
          "829:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "830:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_IMAP,",
          "831:        0 /* can_have_a_subprotocol */, no_master,",
          "832:        no_master, \"IMAP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "833:        ndpi_build_default_ports(ports_a, 143, 0, 0, 0, 0) /* TCP */,",
          "834:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "835:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_IMAPS,",
          "836:        0 /* can_have_a_subprotocol */, no_master,",
          "837:        no_master, \"IMAPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "838:        ndpi_build_default_ports(ports_a, 993, 0, 0, 0, 0) /* TCP */,",
          "839:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "840:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNS,",
          "841:        1 /* can_have_a_subprotocol */, no_master,",
          "842:        no_master, \"DNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "843:        ndpi_build_default_ports(ports_a, 53, 0, 0, 0, 0) /* TCP */,",
          "844:        ndpi_build_default_ports(ports_b, 53, 0, 0, 0, 0) /* UDP */);",
          "845:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IPP,",
          "846:        0 /* can_have_a_subprotocol */, no_master,",
          "847:        no_master, \"IPP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "848:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "849:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "850:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IMO,",
          "851:        0 /* can_have_a_subprotocol */, no_master,",
          "852:        no_master, \"IMO\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "853:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "854:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "855:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP,",
          "856:        1 /* can_have_a_subprotocol */, no_master,",
          "857:        no_master, \"HTTP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "858:        ndpi_build_default_ports(ports_a, 80, 0 /* ntop */, 0, 0, 0) /* TCP */,",
          "859:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "860:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MDNS,",
          "861:        1 /* can_have_a_subprotocol */, no_master,",
          "862:        no_master, \"MDNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "863:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "864:        ndpi_build_default_ports(ports_b, 5353, 5354, 0, 0, 0) /* UDP */);",
          "865:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NTP,",
          "866:        0 /* can_have_a_subprotocol */, no_master,",
          "867:        no_master, \"NTP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "868:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "869:        ndpi_build_default_ports(ports_b, 123, 0, 0, 0, 0) /* UDP */);",
          "870:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETBIOS,",
          "871:        0 /* can_have_a_subprotocol */, no_master,",
          "872:        no_master, \"NetBIOS\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "873:        ndpi_build_default_ports(ports_a, 139, 0, 0, 0, 0) /* TCP */,",
          "874:        ndpi_build_default_ports(ports_b, 137, 138, 139, 0, 0) /* UDP */);",
          "875:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NFS,",
          "876:        0 /* can_have_a_subprotocol */, no_master,",
          "877:        no_master, \"NFS\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "878:        ndpi_build_default_ports(ports_a, 2049, 0, 0, 0, 0) /* TCP */,",
          "879:        ndpi_build_default_ports(ports_b, 2049, 0, 0, 0, 0) /* UDP */);",
          "880:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSDP,",
          "881:        0 /* can_have_a_subprotocol */, no_master,",
          "882:        no_master, \"SSDP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "883:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "884:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "885:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BGP,",
          "886:        0 /* can_have_a_subprotocol */, no_master,",
          "887:        no_master, \"BGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "888:        ndpi_build_default_ports(ports_a, 179, 2605, 0, 0, 0) /* TCP */,",
          "889:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "890:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SNMP,",
          "891:        0 /* can_have_a_subprotocol */, no_master,",
          "892:        no_master, \"SNMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "893:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "894:        ndpi_build_default_ports(ports_b, 161, 162, 0, 0, 0) /* UDP */);",
          "895:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_XDMCP,",
          "896:        0 /* can_have_a_subprotocol */, no_master,",
          "897:        no_master, \"XDMCP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "898:        ndpi_build_default_ports(ports_a, 177, 0, 0, 0, 0) /* TCP */,",
          "899:        ndpi_build_default_ports(ports_b, 177, 0, 0, 0, 0) /* UDP */);",
          "900:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_DANGEROUS, NDPI_PROTOCOL_SMBV1,",
          "901:        0 /* can_have_a_subprotocol */, no_master,",
          "902:        no_master, \"SMBv1\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "903:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "904:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "905:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SYSLOG,",
          "906:        0 /* can_have_a_subprotocol */, no_master,",
          "907:        no_master, \"Syslog\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "908:        ndpi_build_default_ports(ports_a, 514, 0, 0, 0, 0) /* TCP */,",
          "909:        ndpi_build_default_ports(ports_b, 514, 0, 0, 0, 0) /* UDP */);",
          "910:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCP,",
          "911:        0 /* can_have_a_subprotocol */, no_master,",
          "912:        no_master, \"DHCP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "913:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "914:        ndpi_build_default_ports(ports_b, 67, 68, 0, 0, 0) /* UDP */);",
          "915:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_POSTGRES,",
          "916:        0 /* can_have_a_subprotocol */, no_master,",
          "917:        no_master, \"PostgreSQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "918:        ndpi_build_default_ports(ports_a, 5432, 0, 0, 0, 0) /* TCP */,",
          "919:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "920:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MYSQL,",
          "921:        0 /* can_have_a_subprotocol */, no_master,",
          "922:        no_master, \"MySQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "923:        ndpi_build_default_ports(ports_a, 3306, 0, 0, 0, 0) /* TCP */,",
          "924:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "926:        0 /* can_have_a_subprotocol */, no_master,",
          "927:        no_master, \"Direct_Download_Link\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "928:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "929:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "931:        0 /* can_have_a_subprotocol */, no_master,",
          "932:        no_master, \"AppleJuice\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "933:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "934:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "936:        0 /* can_have_a_subprotocol */, no_master,",
          "937:        no_master, \"DirectConnect\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "938:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "939:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "940:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_NTOP,",
          "941:        0 /* can_have_a_subprotocol */, no_master,",
          "942:        no_master, \"ntop\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "943:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "944:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "945:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VMWARE,",
          "946:        0 /* can_have_a_subprotocol */, no_master,",
          "947:        no_master, \"VMware\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "948:        ndpi_build_default_ports(ports_a, 903, 0, 0, 0, 0) /* TCP */,",
          "949:        ndpi_build_default_ports(ports_b, 902, 903, 0, 0, 0) /* UDP */);",
          "950:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FBZERO,",
          "951:        0 /* can_have_a_subprotocol */, no_master,",
          "952:        no_master, \"FacebookZero\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "953:        ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "954:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "956:        0 /* can_have_a_subprotocol */, no_master,",
          "957:        no_master, \"Kontiki\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "958:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "959:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "961:        0 /* can_have_a_subprotocol */, no_master,",
          "962:        no_master, \"OpenFT\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "963:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "964:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "966:        0 /* can_have_a_subprotocol */, no_master,",
          "967:        no_master, \"FastTrack\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "968:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "969:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "971:        0 /* can_have_a_subprotocol */, no_master,",
          "972:        no_master, \"Gnutella\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "973:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "974:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "975:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_EDONKEY,",
          "976:        0 /* can_have_a_subprotocol */, no_master,",
          "977:        no_master, \"eDonkey\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "978:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "979:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "980:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_BITTORRENT,",
          "981:        0 /* can_have_a_subprotocol */, no_master,",
          "982:        no_master, \"BitTorrent\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "983:        ndpi_build_default_ports(ports_a, 51413, 53646, 0, 0, 0) /* TCP */,",
          "984:        ndpi_build_default_ports(ports_b, 6771, 51413, 0, 0, 0) /* UDP */);",
          "985:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE,",
          "986:        0 /* can_have_a_subprotocol */, no_master,",
          "987:        no_master, \"Skype\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "988:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "989:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "991:        0 /* can_have_a_subprotocol */, no_master,",
          "992:        no_master, \"SkypeCall\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "993:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "994:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "995:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TIKTOK,",
          "996:        0 /* can_have_a_subprotocol */, no_master,",
          "997:        no_master, \"TikTok\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "998:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "999:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1000:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEREDO,",
          "1001:        0 /* can_have_a_subprotocol */, no_master,",
          "1002:        no_master, \"Teredo\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1003:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1004:        ndpi_build_default_ports(ports_b, 3544, 0, 0, 0, 0) /* UDP */);",
          "1005:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WECHAT,",
          "1007:        no_master, \"WeChat\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1008:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1009:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1010:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEMCACHED,",
          "1011:        0 /* can_have_a_subprotocol */, no_master,",
          "1012:        no_master, \"Memcached\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1013:        ndpi_build_default_ports(ports_a, 11211, 0, 0, 0, 0) /* TCP */,",
          "1014:        ndpi_build_default_ports(ports_b, 11211, 0, 0, 0, 0) /* UDP */);",
          "1015:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMBV23,",
          "1016:        0 /* can_have_a_subprotocol */, no_master,",
          "1017:        no_master, \"SMBv23\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1018:        ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,",
          "1019:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1020:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MINING,",
          "1021:        0 /* can_have_a_subprotocol */, no_master,",
          "1022:        no_master, \"Mining\", CUSTOM_CATEGORY_MINING,",
          "1023:        ndpi_build_default_ports(ports_a, 8333, 30303, 0, 0, 0) /* TCP */,",
          "1024:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1026:        0 /* can_have_a_subprotocol */, no_master,",
          "1027:        no_master, \"NestLogSink\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1028:        ndpi_build_default_ports(ports_a, 11095, 0, 0, 0, 0) /* TCP */,",
          "1029:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1030:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MODBUS,",
          "1031:        1 /* no subprotocol */, no_master,",
          "1033:        ndpi_build_default_ports(ports_a, 502, 0, 0, 0, 0) /* TCP */,",
          "1034:        ndpi_build_default_ports(ports_b, 0,   0, 0, 0, 0) /* UDP */);",
          "1036:        0 /* can_have_a_subprotocol */, no_master,",
          "1037:        no_master, \"WhatsAppCall\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1038:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1039:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1040:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DATASAVER,",
          "1041:        0 /* can_have_a_subprotocol */, no_master,",
          "1042:        no_master, \"DataSaver\", NDPI_PROTOCOL_CATEGORY_WEB /* dummy */,",
          "1043:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1044:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1045:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SIGNAL,",
          "1047:        no_master, \"Signal\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1048:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1049:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1050:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOH_DOT,",
          "1051:        0 /* can_have_a_subprotocol */, no_master,",
          "1052:        no_master, \"DoH_DoT\", NDPI_PROTOCOL_CATEGORY_NETWORK /* dummy */,",
          "1053:        ndpi_build_default_ports(ports_a, 853, 0, 0, 0, 0) /* TCP */,",
          "1054:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1055:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FREE_205,",
          "1056:        0 /* can_have_a_subprotocol */, no_master,",
          "1057:        no_master, \"FREE_205\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1058:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1059:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1060:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WIREGUARD,",
          "1061:        0 /* can_have_a_subprotocol */, no_master,",
          "1062:        no_master, \"WireGuard\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1063:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1064:        ndpi_build_default_ports(ports_b, 51820, 0, 0, 0, 0) /* UDP */);",
          "1065:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM,",
          "1066:        0 /* can_have_a_subprotocol */, no_master,",
          "1067:        no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1068:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1069:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1070:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_XBOX,",
          "1071:        0 /* can_have_a_subprotocol */, no_master,",
          "1072:        no_master, \"Xbox\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1073:        ndpi_build_default_ports(ports_a, 3074, 3076, 0, 0, 0)         /* TCP */,",
          "1074:        ndpi_build_default_ports(ports_b, 3074, 3076, 500, 3544, 4500) /* UDP */);",
          "1075:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PLAYSTATION,",
          "1076:                             0 /* can_have_a_subprotocol */, no_master,",
          "1077:                             no_master, \"Playstation\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1079:                             ndpi_build_default_ports(ports_b, 3478, 3479, 0, 0, 0)       /* UDP */);",
          "1080:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQ,",
          "1081:        0 /* can_have_a_subprotocol */, no_master,",
          "1082:        no_master, \"QQ\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1083:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1084:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1085:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_RTSP,",
          "1086:        0 /* can_have_a_subprotocol */, no_master,",
          "1087:        no_master, \"RTSP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1088:        ndpi_build_default_ports(ports_a, 554, 0, 0, 0, 0) /* TCP */,",
          "1089:        ndpi_build_default_ports(ports_b, 554, 0, 0, 0, 0) /* UDP */);",
          "1090:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ICECAST,",
          "1091:        0 /* can_have_a_subprotocol */, no_master,",
          "1092:        no_master, \"IceCast\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1093:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1094:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1095:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPLIVE,",
          "1096:        0 /* can_have_a_subprotocol */, no_master,",
          "1097:        no_master, \"PPLive\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1098:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1099:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1100:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM,",
          "1101:        0 /* can_have_a_subprotocol */, no_master,",
          "1102:        no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1103:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1104:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1105:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ZATTOO,",
          "1106:        0 /* can_have_a_subprotocol */, no_master,",
          "1107:        no_master, \"Zattoo\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1108:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1109:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1110:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SHOUTCAST,",
          "1111:        0 /* can_have_a_subprotocol */, no_master,",
          "1112:        no_master, \"ShoutCast\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1113:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1114:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1115:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOPCAST,",
          "1116:        0 /* can_have_a_subprotocol */, no_master,",
          "1117:        no_master, \"Sopcast\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1118:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1119:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1120:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVANTS,",
          "1121:        0 /* can_have_a_subprotocol */, no_master,",
          "1122:        no_master, \"Tvants\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1123:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1124:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1125:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVUPLAYER,",
          "1126:        0 /* can_have_a_subprotocol */, no_master,",
          "1127:        no_master, \"TVUplayer\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1128:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1129:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1131:        1 /* can_have_a_subprotocol */, no_master,",
          "1132:        no_master, \"HTTP_Download\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1133:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1134:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1135:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQLIVE,",
          "1136:        0 /* can_have_a_subprotocol */, no_master,",
          "1137:        no_master, \"QQLive\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1138:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1139:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1140:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_THUNDER,",
          "1141:        0 /* can_have_a_subprotocol */, no_master,",
          "1142:        no_master, \"Thunder\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1143:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1144:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1145:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOULSEEK,",
          "1146:        0 /* can_have_a_subprotocol */, no_master,",
          "1147:        no_master, \"Soulseek\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1148:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1149:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1151:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PS_VUE,",
          "1152:        0 /* can_have_a_subprotocol */, no_master,",
          "1153:        no_master, \"PS_VUE\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1154:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1155:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1156:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_IRC,",
          "1157:        0 /* can_have_a_subprotocol */, no_master,",
          "1158:        no_master, \"IRC\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1159:        ndpi_build_default_ports(ports_a, 194, 0, 0, 0, 0) /* TCP */,",
          "1160:        ndpi_build_default_ports(ports_b, 194, 0, 0, 0, 0) /* UDP */);",
          "1161:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AYIYA,",
          "1162:        0 /* can_have_a_subprotocol */, no_master,",
          "1163:        no_master, \"Ayiya\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1164:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1165:        ndpi_build_default_ports(ports_b, 5072, 0, 0, 0, 0) /* UDP */);",
          "1167:        0 /* can_have_a_subprotocol */, no_master,",
          "1168:        no_master, \"Unencrypted_Jabber\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1169:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1170:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1171:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OSCAR,",
          "1172:        0 /* can_have_a_subprotocol */, no_master,",
          "1173:        no_master, \"Oscar\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1174:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1175:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1176:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_BATTLEFIELD,",
          "1177:        0 /* can_have_a_subprotocol */, no_master,",
          "1178:        no_master, \"BattleField\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1179:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1180:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1181:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_VRRP,",
          "1182:        0 /* can_have_a_subprotocol */, no_master,",
          "1183:        no_master, \"VRRP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1184:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1185:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1186:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STEAM,",
          "1187:        0 /* can_have_a_subprotocol */, no_master,",
          "1188:        no_master, \"Steam\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1189:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1190:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1191:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HALFLIFE2,",
          "1192:        0 /* can_have_a_subprotocol */, no_master,",
          "1193:        no_master, \"HalfLife2\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1194:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1195:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1196:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLDOFWARCRAFT,",
          "1197:        0 /* can_have_a_subprotocol */, no_master,",
          "1198:        no_master, \"WorldOfWarcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1199:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1200:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1202:        0 /* can_have_a_subprotocol */, no_master,",
          "1203:        no_master, \"HotspotShield\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1204:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1205:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1206:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_TELNET,",
          "1207:        0 /* can_have_a_subprotocol */, no_master,",
          "1208:        no_master, \"Telnet\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1209:        ndpi_build_default_ports(ports_a, 23, 0, 0, 0, 0) /* TCP */,",
          "1210:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1213:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_STUN,",
          "1214:        0 /* can_have_a_subprotocol */, no_master,",
          "1215:        custom_master, \"STUN\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1216:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1217:        ndpi_build_default_ports(ports_b, 3478, 0, 0, 0, 0) /* UDP */);",
          "1218:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_IP_IPSEC,",
          "1219:        0 /* can_have_a_subprotocol */, no_master,",
          "1220:        no_master, \"IPsec\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1221:        ndpi_build_default_ports(ports_a, 500, 0, 0, 0, 0) /* TCP */,",
          "1222:        ndpi_build_default_ports(ports_b, 500, 4500, 0, 0, 0) /* UDP */);",
          "1223:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_GRE,",
          "1224:        0 /* can_have_a_subprotocol */, no_master,",
          "1225:        no_master, \"GRE\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1226:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1227:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1228:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMP,",
          "1229:        0 /* can_have_a_subprotocol */, no_master,",
          "1230:        no_master, \"ICMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1231:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1232:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1233:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IGMP,",
          "1234:        0 /* can_have_a_subprotocol */, no_master,",
          "1235:        no_master, \"IGMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1236:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1237:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1238:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_EGP,",
          "1239:        0 /* can_have_a_subprotocol */, no_master,",
          "1240:        no_master, \"EGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1241:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1242:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1243:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_SCTP,",
          "1244:        0 /* can_have_a_subprotocol */, no_master,",
          "1245:        no_master, \"SCTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1246:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1247:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1248:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_OSPF,",
          "1249:        0 /* can_have_a_subprotocol */, no_master,",
          "1250:        no_master, \"OSPF\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1251:        ndpi_build_default_ports(ports_a, 2604, 0, 0, 0, 0) /* TCP */,",
          "1252:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1254:        0 /* can_have_a_subprotocol */, no_master,",
          "1255:        no_master, \"IP_in_IP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1256:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1257:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1258:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTP,",
          "1259:        0 /* can_have_a_subprotocol */, no_master,",
          "1260:        no_master, \"RTP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1261:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1262:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1263:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RDP,",
          "1264:        0 /* can_have_a_subprotocol */, no_master,",
          "1265:        no_master, \"RDP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1266:        ndpi_build_default_ports(ports_a, 3389, 0, 0, 0, 0) /* TCP */,",
          "1267:        ndpi_build_default_ports(ports_b, 3389, 0, 0, 0, 0) /* UDP */);",
          "1268:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VNC,",
          "1269:        0 /* can_have_a_subprotocol */, no_master,",
          "1270:        no_master, \"VNC\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1271:        ndpi_build_default_ports(ports_a, 5900, 5901, 5800, 0, 0) /* TCP */,",
          "1272:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1274:        0 /* can_have_a_subprotocol */, no_master,",
          "1275:        no_master, \"PcAnywhere\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1276:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1277:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1278:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZOOM,",
          "1279:        0 /* can_have_a_subprotocol */, no_master,",
          "1280:        no_master, \"Zoom\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1281:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1282:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1284:        0 /* can_have_a_subprotocol */, no_master,",
          "1285:        no_master, \"WhatsAppFiles\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1286:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1287:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1288:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP,",
          "1289:        0 /* can_have_a_subprotocol */, no_master,",
          "1290:        no_master, \"WhatsApp\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1291:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1292:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1294:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_TLS,",
          "1295:        1 /* can_have_a_subprotocol */, no_master,",
          "1296:        no_master, \"TLS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1297:        ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "1298:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1299:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSH,",
          "1300:        0 /* can_have_a_subprotocol */, no_master,",
          "1301:        no_master, \"SSH\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1302:        ndpi_build_default_ports(ports_a, 22, 0, 0, 0, 0) /* TCP */,",
          "1303:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1304:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_USENET,",
          "1305:        0 /* can_have_a_subprotocol */, no_master,",
          "1306:        no_master, \"Usenet\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1307:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1308:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1309:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MGCP,",
          "1310:        0 /* can_have_a_subprotocol */, no_master,",
          "1311:        no_master, \"MGCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1312:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1313:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1314:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IAX,",
          "1315:        0 /* can_have_a_subprotocol */, no_master,",
          "1316:        no_master, \"IAX\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1317:        ndpi_build_default_ports(ports_a, 4569, 0, 0, 0, 0) /* TCP */,",
          "1318:        ndpi_build_default_ports(ports_b, 4569, 0, 0, 0, 0) /* UDP */);",
          "1319:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AFP,",
          "1320:        0 /* can_have_a_subprotocol */, no_master,",
          "1321:        no_master, \"AFP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1322:        ndpi_build_default_ports(ports_a, 548, 0, 0, 0, 0) /* TCP */,",
          "1323:        ndpi_build_default_ports(ports_b, 548, 0, 0, 0, 0) /* UDP */);",
          "1324:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HULU,",
          "1325:        0 /* can_have_a_subprotocol */, no_master,",
          "1326:        no_master, \"Hulu\", NDPI_PROTOCOL_CATEGORY_STREAMING,",
          "1327:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1328:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1329:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CHECKMK,",
          "1330:                             0 /* can_have_a_subprotocol */, no_master,",
          "1331:                             no_master, \"CHECKMK\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1335:        0 /* can_have_a_subprotocol */, no_master,",
          "1336:        no_master, \"Stealthnet\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1337:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1338:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1339:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_AIMINI,",
          "1340:        0 /* can_have_a_subprotocol */, no_master,",
          "1341:        no_master, \"Aimini\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1342:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1343:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1344:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SIP,",
          "1345:        0 /* can_have_a_subprotocol */, no_master,",
          "1346:        no_master, \"SIP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1347:        ndpi_build_default_ports(ports_a, 5060, 5061, 0, 0, 0) /* TCP */,",
          "1348:        ndpi_build_default_ports(ports_b, 5060, 5061, 0, 0, 0) /* UDP */);",
          "1349:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TRUPHONE,",
          "1350:        0 /* can_have_a_subprotocol */, no_master,",
          "1351:        no_master, \"TruPhone\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1352:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1353:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1354:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMPV6,",
          "1355:        0 /* can_have_a_subprotocol */, no_master,",
          "1356:        no_master, \"ICMPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1357:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1358:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1359:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCPV6,",
          "1360:        0 /* can_have_a_subprotocol */, no_master,",
          "1361:        no_master, \"DHCPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1362:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1363:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1364:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ARMAGETRON,",
          "1365:        0 /* can_have_a_subprotocol */, no_master,",
          "1366:        no_master, \"Armagetron\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1367:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1368:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1369:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CROSSFIRE,",
          "1370:        0 /* can_have_a_subprotocol */, no_master,",
          "1371:        no_master, \"Crossfire\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1372:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1373:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1374:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOFUS,",
          "1375:        0 /* can_have_a_subprotocol */, no_master,",
          "1376:        no_master, \"Dofus\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1377:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1378:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1379:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FIESTA,",
          "1380:        0 /* can_have_a_subprotocol */, no_master,",
          "1381:        no_master, \"Fiesta\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1382:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1383:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1384:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FLORENSIA,",
          "1385:        0 /* can_have_a_subprotocol */, no_master,",
          "1386:        no_master, \"Florensia\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1387:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1388:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1389:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_GUILDWARS,",
          "1390:        0 /* can_have_a_subprotocol */, no_master,",
          "1391:        no_master, \"Guildwars\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1392:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1393:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1395:        1 /* can_have_a_subprotocol */, no_master,",
          "1396:        no_master, \"HTTP_ActiveSync\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1397:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1398:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1399:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KERBEROS,",
          "1400:        0 /* can_have_a_subprotocol */, no_master,",
          "1401:        no_master, \"Kerberos\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1402:        ndpi_build_default_ports(ports_a, 88, 0, 0, 0, 0) /* TCP */,",
          "1403:        ndpi_build_default_ports(ports_b, 88, 0, 0, 0, 0) /* UDP */);",
          "1404:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LDAP,",
          "1405:        0 /* can_have_a_subprotocol */, no_master,",
          "1406:        no_master, \"LDAP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1407:        ndpi_build_default_ports(ports_a, 389, 0, 0, 0, 0) /* TCP */,",
          "1408:        ndpi_build_default_ports(ports_b, 389, 0, 0, 0, 0) /* UDP */);",
          "1409:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MAPLESTORY,",
          "1410:        0 /* can_have_a_subprotocol */, no_master,",
          "1411:        no_master, \"MapleStory\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1412:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1413:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1414:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MSSQL_TDS,",
          "1415:        0 /* can_have_a_subprotocol */, no_master,",
          "1416:        no_master, \"MsSQL-TDS\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1417:        ndpi_build_default_ports(ports_a, 1433, 1434, 0, 0, 0) /* TCP */,",
          "1418:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1419:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PPTP,",
          "1420:        0 /* can_have_a_subprotocol */, no_master,",
          "1421:        no_master, \"PPTP\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1422:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1423:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1424:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WARCRAFT3,",
          "1425:        0 /* can_have_a_subprotocol */, no_master,",
          "1426:        no_master, \"Warcraft3\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1427:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1428:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1429:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLD_OF_KUNG_FU,",
          "1430:        0 /* can_have_a_subprotocol */, no_master,",
          "1431:        no_master, \"WorldOfKungFu\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1432:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1433:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1434:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DCERPC,",
          "1435:        0 /* can_have_a_subprotocol */, no_master,",
          "1436:        no_master, \"DCE_RPC\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1437:        ndpi_build_default_ports(ports_a, 135, 0, 0, 0, 0) /* TCP */,",
          "1438:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1439:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETFLOW,",
          "1440:        0 /* can_have_a_subprotocol */, no_master,",
          "1441:        no_master, \"NetFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1442:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1443:        ndpi_build_default_ports(ports_b, 2055, 0, 0, 0, 0) /* UDP */);",
          "1444:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SFLOW,",
          "1445:        0 /* can_have_a_subprotocol */, no_master,",
          "1446:        no_master, \"sFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1447:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1448:        ndpi_build_default_ports(ports_b, 6343, 0, 0, 0, 0) /* UDP */);",
          "1450:        1 /* can_have_a_subprotocol */, no_master,",
          "1451:        no_master, \"HTTP_Connect\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1452:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1453:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1455:        1 /* can_have_a_subprotocol */, no_master,",
          "1456:        no_master, \"HTTP_Proxy\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1457:        ndpi_build_default_ports(ports_a, 8080, 3128, 0, 0, 0) /* TCP */,",
          "1458:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1459:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CITRIX,",
          "1460:        0 /* can_have_a_subprotocol */, no_master,",
          "1461:        no_master, \"Citrix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1462:        ndpi_build_default_ports(ports_a, 1494, 2598, 0, 0, 0) /* TCP */,",
          "1463:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1464:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBEX,",
          "1465:        0 /* can_have_a_subprotocol */, no_master,",
          "1466:        no_master, \"Webex\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1467:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1468:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1469:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RADIUS,",
          "1470:        0 /* can_have_a_subprotocol */, no_master,",
          "1471:        no_master, \"Radius\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1472:        ndpi_build_default_ports(ports_a, 1812, 1813, 0, 0, 0) /* TCP */,",
          "1473:        ndpi_build_default_ports(ports_b, 1812, 1813, 0, 0, 0) /* UDP */);",
          "1475:        0 /* can_have_a_subprotocol */, no_master,",
          "1476:        no_master, \"TeamViewer\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1477:        ndpi_build_default_ports(ports_a, 5938, 0, 0, 0, 0) /* TCP */,",
          "1478:        ndpi_build_default_ports(ports_b, 5938, 0, 0, 0, 0) /* UDP */);",
          "1480:        0 /* can_have_a_subprotocol */, no_master,",
          "1481:        no_master, \"LotusNotes\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1482:        ndpi_build_default_ports(ports_a, 1352, 0, 0, 0, 0) /* TCP */,",
          "1483:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1484:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SAP,",
          "1485:        0 /* can_have_a_subprotocol */, no_master,",
          "1486:        no_master, \"SAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1487:        ndpi_build_default_ports(ports_a, 3201, 0, 0, 0, 0) /* TCP */,",
          "1489:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_GTP,",
          "1490:        0 /* can_have_a_subprotocol */, no_master,",
          "1491:        no_master, \"GTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1492:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1493:        ndpi_build_default_ports(ports_b, 2152, 2123, 0, 0, 0) /* UDP */);",
          "1494:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UPNP,",
          "1495:        0 /* can_have_a_subprotocol */, no_master,",
          "1496:        no_master, \"UPnP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1497:        ndpi_build_default_ports(ports_a, 1780, 0, 0, 0, 0) /* TCP */,",
          "1498:        ndpi_build_default_ports(ports_b, 1900, 0, 0, 0, 0) /* UDP */);",
          "1499:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TELEGRAM,",
          "1500:        0 /* can_have_a_subprotocol */, no_master,",
          "1501:        no_master, \"Telegram\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1502:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1503:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1504:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_QUIC,",
          "1505:        1 /* can_have_a_subprotocol */, no_master,",
          "1506:        no_master, \"QUIC\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1507:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1508:        ndpi_build_default_ports(ports_b, 443, 80, 0, 0, 0) /* UDP */);",
          "1509:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DIAMETER,",
          "1510:        0 /* can_have_a_subprotocol */, no_master,",
          "1511:        no_master, \"Diameter\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1512:        ndpi_build_default_ports(ports_a, 3868, 0, 0, 0, 0) /* TCP */,",
          "1513:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1515:        0 /* can_have_a_subprotocol */, no_master,",
          "1516:        no_master, \"ApplePush\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1517:        ndpi_build_default_ports(ports_a, 1, 0, 0, 0, 0) /* TCP */,",
          "1518:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1519:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DROPBOX,",
          "1520:        0 /* can_have_a_subprotocol */, no_master,",
          "1521:        no_master, \"Dropbox\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1522:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1523:        ndpi_build_default_ports(ports_b, 17500, 0, 0, 0, 0) /* UDP */);",
          "1524:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SPOTIFY,",
          "1525:        0 /* can_have_a_subprotocol */, no_master,",
          "1526:        no_master, \"Spotify\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1527:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1528:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1529:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MESSENGER,",
          "1530:        0 /* can_have_a_subprotocol */, no_master,",
          "1531:        no_master, \"Messenger\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1532:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1533:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1534:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LISP,",
          "1535:        0 /* can_have_a_subprotocol */, no_master,",
          "1536:        no_master, \"LISP\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1537:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1538:        ndpi_build_default_ports(ports_b, 4342, 4341, 0, 0, 0) /* UDP */);",
          "1539:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_EAQ,",
          "1540:        0 /* can_have_a_subprotocol */, no_master,",
          "1541:        no_master, \"EAQ\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1542:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1543:        ndpi_build_default_ports(ports_b, 6000, 0, 0, 0, 0) /* UDP */);",
          "1545:        0 /* can_have_a_subprotocol */, no_master,",
          "1546:        no_master, \"KakaoTalk_Voice\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1547:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1548:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1549:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MPEGTS,",
          "1550:        0 /* can_have_a_subprotocol */, no_master,",
          "1551:        no_master, \"MPEG_TS\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1552:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1553:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1555:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LLMNR,",
          "1556:        0 /* can_have_a_subprotocol */, no_master,",
          "1557:        no_master, \"LLMNR\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1558:        ndpi_build_default_ports(ports_a, 5355, 0, 0, 0, 0) /* TCP */,",
          "1560:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_REMOTE_SCAN,",
          "1561:        0 /* can_have_a_subprotocol */, no_master,",
          "1562:        no_master, \"RemoteScan\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1563:        ndpi_build_default_ports(ports_a, 6077, 0, 0, 0, 0) /* TCP */,",
          "1566:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_H323,",
          "1567:        0 /* can_have_a_subprotocol */, no_master,",
          "1568:        no_master,\"H323\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1569:        ndpi_build_default_ports(ports_a, 1719, 1720, 0, 0, 0) /* TCP */,",
          "1570:        ndpi_build_default_ports(ports_b, 1719, 1720, 0, 0, 0) /* UDP */);",
          "1571:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OPENVPN,",
          "1572:        0 /* can_have_a_subprotocol */, no_master,",
          "1573:        no_master, \"OpenVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1574:        ndpi_build_default_ports(ports_a, 1194, 0, 0, 0, 0) /* TCP */,",
          "1575:        ndpi_build_default_ports(ports_b, 1194, 0, 0, 0, 0) /* UDP */);",
          "1576:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NOE,",
          "1577:        0 /* can_have_a_subprotocol */, no_master,",
          "1578:        no_master, \"NOE\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1579:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1580:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1581:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CISCOVPN,",
          "1582:        0 /* can_have_a_subprotocol */, no_master,",
          "1583:        no_master, \"CiscoVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1584:        ndpi_build_default_ports(ports_a, 10000, 8008, 8009, 0, 0) /* TCP */,",
          "1585:        ndpi_build_default_ports(ports_b, 10000, 0, 0, 0, 0) /* UDP */);",
          "1586:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMSPEAK,",
          "1587:        0 /* can_have_a_subprotocol */, no_master,",
          "1588:        no_master, \"TeamSpeak\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1589:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1590:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1591:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKINNY,",
          "1592:        0 /* can_have_a_subprotocol */, no_master,",
          "1593:        no_master, \"CiscoSkinny\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1594:        ndpi_build_default_ports(ports_a, 2000, 0, 0, 0, 0) /* TCP */,",
          "1595:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1596:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTCP,",
          "1597:        0 /* can_have_a_subprotocol */, no_master,",
          "1598:        no_master, \"RTCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1599:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1600:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1601:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RSYNC,",
          "1602:        0 /* can_have_a_subprotocol */, no_master,",
          "1603:        no_master, \"RSYNC\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1604:        ndpi_build_default_ports(ports_a, 873, 0, 0, 0, 0) /* TCP */,",
          "1605:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1606:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ORACLE,",
          "1607:        0 /* can_have_a_subprotocol */, no_master,",
          "1608:        no_master, \"Oracle\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1609:        ndpi_build_default_ports(ports_a, 1521, 0, 0, 0, 0) /* TCP */,",
          "1610:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1611:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CORBA,",
          "1612:        0 /* can_have_a_subprotocol */, no_master,",
          "1613:        no_master, \"Corba\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1614:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1615:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1616:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UBUNTUONE,",
          "1617:        0 /* can_have_a_subprotocol */, no_master,",
          "1618:        no_master, \"UbuntuONE\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1619:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1620:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1621:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHOIS_DAS,",
          "1622:        0 /* can_have_a_subprotocol */, no_master,",
          "1623:        no_master, \"Whois-DAS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1626:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_COLLECTD,",
          "1627:        0 /* can_have_a_subprotocol */, no_master,",
          "1628:        no_master, \"Collectd\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1631:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOCKS,",
          "1632:        0 /* can_have_a_subprotocol */, no_master,",
          "1633:        no_master, \"SOCKS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1636:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TFTP,",
          "1637:        0 /* can_have_a_subprotocol */, no_master,",
          "1638:        no_master, \"TFTP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1641:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTMP,",
          "1642:        0 /* can_have_a_subprotocol */, no_master,",
          "1643:        no_master, \"RTMP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1646:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PANDO,",
          "1647:        0 /* can_have_a_subprotocol */, no_master,",
          "1648:        no_master, \"Pando_Media_Booster\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1651:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEGACO,",
          "1652:        0 /* can_have_a_subprotocol */, no_master,",
          "1653:        no_master, \"Megaco\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1656:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_REDIS,",
          "1657:        0 /* can_have_a_subprotocol */, no_master,",
          "1658:        no_master, \"Redis\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1661:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZMQ,",
          "1662:        0 /* can_have_a_subprotocol */, no_master,",
          "1663:        no_master, \"ZeroMQ\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1666:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_VHUA,",
          "1667:        0 /* can_have_a_subprotocol */, no_master,",
          "1668:        no_master, \"VHUA\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1671:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STARCRAFT,",
          "1672:        0 /* can_have_a_subprotocol */, no_master,",
          "1673:        no_master, \"Starcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1676:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_UBNTAC2,",
          "1677:        0 /* can_have_a_subprotocol */, no_master,",
          "1678:        no_master, \"UBNTAC2\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1681:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VIBER,",
          "1682:        0 /* can_have_a_subprotocol */, no_master,",
          "1683:        no_master, \"Viber\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1686:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_COAP,",
          "1687:        0 /* can_have_a_subprotocol */, no_master,",
          "1688:        no_master, \"COAP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1691:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MQTT,",
          "1692:        0 /* can_have_a_subprotocol */, no_master,",
          "1693:        no_master, \"MQTT\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1696:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOMEIP,",
          "1697:        0 /* can_have_a_subprotocol */, no_master,",
          "1698:        no_master, \"SOMEIP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1701:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RX,",
          "1702:        0 /* can_have_a_subprotocol */, no_master,",
          "1703:        no_master, \"RX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1706:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_GIT,",
          "1707:        0 /* can_have_a_subprotocol */, no_master,",
          "1708:        no_master, \"Git\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1711:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DRDA,",
          "1712:        0 /* can_have_a_subprotocol */, no_master,",
          "1713:        no_master, \"DRDA\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1717:        0 /* can_have_a_subprotocol */, no_master,",
          "1718:        no_master, \"GoogleHangoutDuo\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1719:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1720:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1721:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BJNP,",
          "1722:        0 /* can_have_a_subprotocol */, no_master,",
          "1723:        no_master, \"BJNP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1724:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1725:        ndpi_build_default_ports(ports_b, 8612, 0, 0, 0, 0) /* UDP */);",
          "1726:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMPP,",
          "1727:        0 /* can_have_a_subprotocol */, no_master,",
          "1728:        no_master, \"SMPP\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1731:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_OOKLA,",
          "1732:        0 /* can_have_a_subprotocol */, no_master,",
          "1733:        no_master, \"Ookla\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1736:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMQP,",
          "1737:        0 /* can_have_a_subprotocol */, no_master,",
          "1738:        no_master, \"AMQP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1741:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_DNSCRYPT,",
          "1742:        0 /* can_have_a_subprotocol */, no_master,",
          "1743:        no_master, \"DNScrypt\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1746:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TINC,",
          "1747:        0 /* can_have_a_subprotocol */, no_master,",
          "1748:        no_master, \"TINC\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1749:        ndpi_build_default_ports(ports_a, 655, 0, 0, 0, 0) /* TCP */,",
          "1750:        ndpi_build_default_ports(ports_b, 655, 0, 0, 0, 0) /* UDP */);",
          "1751:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FIX,",
          "1752:        0 /* can_have_a_subprotocol */, no_master,",
          "1753:        no_master, \"FIX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1754:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1755:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1756:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_NINTENDO,",
          "1757:        0 /* can_have_a_subprotocol */, no_master,",
          "1758:        no_master, \"Nintendo\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1759:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1760:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1761:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CSGO,",
          "1762:        0 /* can_have_a_subprotocol */, no_master,",
          "1763:        no_master, \"CSGO\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1764:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1765:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1766:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AJP,",
          "1767:        0 /* can_have_a_subprotocol */, no_master,",
          "1768:        no_master, \"AJP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1769:        ndpi_build_default_ports(ports_a, 8009, 0, 0, 0, 0) /* TCP */,",
          "1770:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1772:        0 /* can_have_a_subprotocol */, no_master,",
          "1773:        no_master, \"Targus Dataspeed\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1774:        ndpi_build_default_ports(ports_a, 5001, 5201, 0, 0, 0) /* TCP */,",
          "1775:        ndpi_build_default_ports(ports_b, 5001, 5201, 0, 0, 0) /* UDP */);",
          "1777:        0 /* can_have_a_subprotocol */, no_master,",
          "1778:        no_master, \"AmazonVideo\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1779:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1780:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1781:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNP3,",
          "1782:        1 /* no subprotocol */, no_master,",
          "1783:        no_master, \"DNP3\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1784:        ndpi_build_default_ports(ports_a, 20000, 0, 0, 0, 0) /* TCP */,",
          "1785:        ndpi_build_default_ports(ports_b, 0,   0, 0, 0, 0) /* UDP */);",
          "1786:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IEC60870,",
          "1787:        1 /* no subprotocol */, no_master,",
          "1789:        ndpi_build_default_ports(ports_a, 2404, 0, 0, 0, 0) /* TCP */,",
          "1790:        ndpi_build_default_ports(ports_b, 0,   0, 0, 0, 0) /* UDP */);",
          "1791:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BLOOMBERG,",
          "1792:        1 /* no subprotocol */, no_master,",
          "1793:        no_master, \"Bloomberg\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1794:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1795:        ndpi_build_default_ports(ports_b, 0,   0, 0, 0, 0) /* UDP */);",
          "1796:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CAPWAP,",
          "1797:        1 /* no subprotocol */, no_master,",
          "1798:        no_master, \"CAPWAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1799:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1801:        );",
          "1802:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZABBIX,",
          "1803:        1 /* no subprotocol */, no_master,",
          "1804:        no_master, \"Zabbix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1805:        ndpi_build_default_ports(ports_a, 10050, 0, 0, 0, 0) /* TCP */,",
          "1807:        );",
          "1808:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_S7COMM,",
          "1809:        1 /* no subprotocol */, no_master,",
          "1810:        no_master, \"s7comm\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1811:        ndpi_build_default_ports(ports_a, 102, 0, 0, 0, 0) /* TCP */,",
          "1812:        ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1813:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MSTEAMS,",
          "1814:        1 /* no subprotocol */, no_master,",
          "1815:        no_master, \"Teams\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1816:        ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1818:        );",
          "",
          "[Added Lines]",
          "791: static void ndpi_init_protocol_defaults(struct ndpi_detection_module_struct *ndpi_str)",
          "792: {",
          "793:     ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "794:     u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO}, custom_master[2];",
          "799:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNRATED, NDPI_PROTOCOL_UNKNOWN, 0 /* can_have_a_subprotocol */,",
          "800:                             no_master, no_master, \"Unknown\", NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "801:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "802:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "803:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_FTP_CONTROL, 0 /* can_have_a_subprotocol */,",
          "804:                             no_master, no_master, \"FTP_CONTROL\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "805:                             ndpi_build_default_ports(ports_a, 21, 0, 0, 0, 0) /* TCP */,",
          "806:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "807:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_FTP_DATA, 0 /* can_have_a_subprotocol */,",
          "808:                             no_master, no_master, \"FTP_DATA\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "809:                             ndpi_build_default_ports(ports_a, 20, 0, 0, 0, 0) /* TCP */,",
          "810:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "811:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_POP, 0 /* can_have_a_subprotocol */,",
          "812:                             no_master, no_master, \"POP3\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "813:                             ndpi_build_default_ports(ports_a, 110, 0, 0, 0, 0) /* TCP */,",
          "814:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "815:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_POPS, 0 /* can_have_a_subprotocol */,",
          "816:                             no_master, no_master, \"POPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "817:                             ndpi_build_default_ports(ports_a, 995, 0, 0, 0, 0) /* TCP */,",
          "818:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "819:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MAIL_SMTP, 0 /* can_have_a_subprotocol */,",
          "820:                             no_master, no_master, \"SMTP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "821:                             ndpi_build_default_ports(ports_a, 25, 0, 0, 0, 0) /* TCP */,",
          "822:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "823:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_SMTPS, 0 /* can_have_a_subprotocol */,",
          "824:                             no_master, no_master, \"SMTPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "825:                             ndpi_build_default_ports(ports_a, 465, 587, 0, 0, 0) /* TCP */,",
          "826:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "827:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MAIL_IMAP, 0 /* can_have_a_subprotocol */,",
          "828:                             no_master, no_master, \"IMAP\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "829:                             ndpi_build_default_ports(ports_a, 143, 0, 0, 0, 0) /* TCP */,",
          "830:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "831:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MAIL_IMAPS, 0 /* can_have_a_subprotocol */,",
          "832:                             no_master, no_master, \"IMAPS\", NDPI_PROTOCOL_CATEGORY_MAIL,",
          "833:                             ndpi_build_default_ports(ports_a, 993, 0, 0, 0, 0) /* TCP */,",
          "834:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "835:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNS, 1 /* can_have_a_subprotocol */,",
          "836:                             no_master, no_master, \"DNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "837:                             ndpi_build_default_ports(ports_a, 53, 0, 0, 0, 0) /* TCP */,",
          "838:                             ndpi_build_default_ports(ports_b, 53, 0, 0, 0, 0) /* UDP */);",
          "839:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IPP, 0 /* can_have_a_subprotocol */,",
          "840:                             no_master, no_master, \"IPP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "841:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "842:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "843:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IMO, 0 /* can_have_a_subprotocol */,",
          "844:                             no_master, no_master, \"IMO\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "845:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "846:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "847:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP, 1 /* can_have_a_subprotocol */,",
          "848:                             no_master, no_master, \"HTTP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "849:                             ndpi_build_default_ports(ports_a, 80, 0 /* ntop */, 0, 0, 0) /* TCP */,",
          "850:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "851:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MDNS, 1 /* can_have_a_subprotocol */,",
          "852:                             no_master, no_master, \"MDNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "853:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "854:                             ndpi_build_default_ports(ports_b, 5353, 5354, 0, 0, 0) /* UDP */);",
          "855:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NTP, 0 /* can_have_a_subprotocol */,",
          "856:                             no_master, no_master, \"NTP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "857:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "858:                             ndpi_build_default_ports(ports_b, 123, 0, 0, 0, 0) /* UDP */);",
          "859:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETBIOS, 0 /* can_have_a_subprotocol */,",
          "860:                             no_master, no_master, \"NetBIOS\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "861:                             ndpi_build_default_ports(ports_a, 139, 0, 0, 0, 0) /* TCP */,",
          "862:                             ndpi_build_default_ports(ports_b, 137, 138, 139, 0, 0) /* UDP */);",
          "863:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NFS, 0 /* can_have_a_subprotocol */,",
          "864:                             no_master, no_master, \"NFS\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "865:                             ndpi_build_default_ports(ports_a, 2049, 0, 0, 0, 0) /* TCP */,",
          "866:                             ndpi_build_default_ports(ports_b, 2049, 0, 0, 0, 0) /* UDP */);",
          "867:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSDP, 0 /* can_have_a_subprotocol */,",
          "868:                             no_master, no_master, \"SSDP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "869:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "870:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "871:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BGP, 0 /* can_have_a_subprotocol */,",
          "872:                             no_master, no_master, \"BGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "873:                             ndpi_build_default_ports(ports_a, 179, 2605, 0, 0, 0) /* TCP */,",
          "874:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "875:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SNMP, 0 /* can_have_a_subprotocol */,",
          "876:                             no_master, no_master, \"SNMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "877:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "878:                             ndpi_build_default_ports(ports_b, 161, 162, 0, 0, 0) /* UDP */);",
          "879:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_XDMCP, 0 /* can_have_a_subprotocol */,",
          "880:                             no_master, no_master, \"XDMCP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "881:                             ndpi_build_default_ports(ports_a, 177, 0, 0, 0, 0) /* TCP */,",
          "882:                             ndpi_build_default_ports(ports_b, 177, 0, 0, 0, 0) /* UDP */);",
          "883:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_DANGEROUS, NDPI_PROTOCOL_SMBV1, 0 /* can_have_a_subprotocol */,",
          "884:                             no_master, no_master, \"SMBv1\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "885:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "886:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "887:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SYSLOG, 0 /* can_have_a_subprotocol */,",
          "888:                             no_master, no_master, \"Syslog\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "889:                             ndpi_build_default_ports(ports_a, 514, 0, 0, 0, 0) /* TCP */,",
          "890:                             ndpi_build_default_ports(ports_b, 514, 0, 0, 0, 0) /* UDP */);",
          "891:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCP, 0 /* can_have_a_subprotocol */,",
          "892:                             no_master, no_master, \"DHCP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "893:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "894:                             ndpi_build_default_ports(ports_b, 67, 68, 0, 0, 0) /* UDP */);",
          "895:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_POSTGRES, 0 /* can_have_a_subprotocol */,",
          "896:                             no_master, no_master, \"PostgreSQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "897:                             ndpi_build_default_ports(ports_a, 5432, 0, 0, 0, 0) /* TCP */,",
          "898:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "899:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MYSQL, 0 /* can_have_a_subprotocol */,",
          "900:                             no_master, no_master, \"MySQL\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "901:                             ndpi_build_default_ports(ports_a, 3306, 0, 0, 0, 0) /* TCP */,",
          "902:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "904:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Direct_Download_Link\",",
          "905:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "906:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "907:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "909:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"AppleJuice\",",
          "910:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "911:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "912:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "914:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"DirectConnect\",",
          "915:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "916:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "917:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "918:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_NTOP, 0 /* can_have_a_subprotocol */, no_master,",
          "919:                             no_master, \"ntop\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "920:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "921:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "922:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VMWARE, 0 /* can_have_a_subprotocol */,",
          "923:                             no_master, no_master, \"VMware\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "924:                             ndpi_build_default_ports(ports_a, 903, 0, 0, 0, 0) /* TCP */,",
          "925:                             ndpi_build_default_ports(ports_b, 902, 903, 0, 0, 0) /* UDP */);",
          "926:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FBZERO, 0 /* can_have_a_subprotocol */,",
          "927:                             no_master, no_master, \"FacebookZero\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "928:                             ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "929:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "931:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Kontiki\",",
          "932:                             NDPI_PROTOCOL_CATEGORY_MEDIA, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "933:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "935:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"OpenFT\",",
          "936:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "937:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "938:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "940:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"FastTrack\",",
          "941:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "942:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "943:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "945:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Gnutella\",",
          "946:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "947:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "948:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "949:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_EDONKEY, 0 /* can_have_a_subprotocol */,",
          "950:                             no_master, no_master, \"eDonkey\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "951:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "952:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "953:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_BITTORRENT, 0 /* can_have_a_subprotocol */,",
          "954:                             no_master, no_master, \"BitTorrent\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "955:                             ndpi_build_default_ports(ports_a, 51413, 53646, 0, 0, 0) /* TCP */,",
          "956:                             ndpi_build_default_ports(ports_b, 6771, 51413, 0, 0, 0) /* UDP */);",
          "957:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKYPE, 0 /* can_have_a_subprotocol */,",
          "958:                             no_master, no_master, \"Skype\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "959:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "960:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "962:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"SkypeCall\",",
          "963:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "964:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "965:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TIKTOK, 0 /* can_have_a_subprotocol */,",
          "966:                             no_master, no_master, \"TikTok\", NDPI_PROTOCOL_CATEGORY_SOCIAL_NETWORK,",
          "967:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "968:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "969:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEREDO, 0 /* can_have_a_subprotocol */,",
          "970:                             no_master, no_master, \"Teredo\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "971:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "972:                             ndpi_build_default_ports(ports_b, 3544, 0, 0, 0, 0) /* UDP */);",
          "973:     ndpi_set_proto_defaults(",
          "975:         no_master, \"WeChat\", NDPI_PROTOCOL_CATEGORY_CHAT, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "976:         ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "977:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEMCACHED, 0 /* can_have_a_subprotocol */,",
          "978:                             no_master, no_master, \"Memcached\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "979:                             ndpi_build_default_ports(ports_a, 11211, 0, 0, 0, 0) /* TCP */,",
          "980:                             ndpi_build_default_ports(ports_b, 11211, 0, 0, 0, 0) /* UDP */);",
          "981:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMBV23, 0 /* can_have_a_subprotocol */,",
          "982:                             no_master, no_master, \"SMBv23\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "983:                             ndpi_build_default_ports(ports_a, 445, 0, 0, 0, 0) /* TCP */,",
          "984:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "985:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_MINING, 0 /* can_have_a_subprotocol */,",
          "986:                             no_master, no_master, \"Mining\", CUSTOM_CATEGORY_MINING,",
          "987:                             ndpi_build_default_ports(ports_a, 8333, 30303, 0, 0, 0) /* TCP */,",
          "988:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "990:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"NestLogSink\",",
          "991:                             NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "992:                             ndpi_build_default_ports(ports_a, 11095, 0, 0, 0, 0) /* TCP */,",
          "993:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "994:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MODBUS, 1 /* no subprotocol */, no_master,",
          "996:                             ndpi_build_default_ports(ports_a, 502, 0, 0, 0, 0) /* TCP */,",
          "997:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "999:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppCall\",",
          "1000:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1001:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1002:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DATASAVER, 0 /* can_have_a_subprotocol */,",
          "1003:                             no_master, no_master, \"DataSaver\", NDPI_PROTOCOL_CATEGORY_WEB /* dummy */,",
          "1004:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1005:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1006:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SIGNAL, 0 /* can_have_a_subprotocol */,",
          "1008:                             no_master, \"Signal\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1009:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1010:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1011:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOH_DOT, 0 /* can_have_a_subprotocol */,",
          "1012:                             no_master, no_master, \"DoH_DoT\", NDPI_PROTOCOL_CATEGORY_NETWORK /* dummy */,",
          "1013:                             ndpi_build_default_ports(ports_a, 853, 0, 0, 0, 0) /* TCP */,",
          "1014:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1015:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FREE_205, 0 /* can_have_a_subprotocol */,",
          "1016:                             no_master, no_master, \"FREE_205\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1017:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1018:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1019:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WIREGUARD, 0 /* can_have_a_subprotocol */,",
          "1020:                             no_master, no_master, \"WireGuard\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1021:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1022:                             ndpi_build_default_ports(ports_b, 51820, 0, 0, 0, 0) /* UDP */);",
          "1023:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,",
          "1024:                             no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1025:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1026:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1027:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_XBOX, 0 /* can_have_a_subprotocol */, no_master,",
          "1028:                             no_master, \"Xbox\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1029:                             ndpi_build_default_ports(ports_a, 3074, 3076, 0, 0, 0) /* TCP */,",
          "1030:                             ndpi_build_default_ports(ports_b, 3074, 3076, 500, 3544, 4500) /* UDP */);",
          "1031:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PLAYSTATION, 0 /* can_have_a_subprotocol */,",
          "1032:                             no_master, no_master, \"Playstation\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1034:                             ndpi_build_default_ports(ports_b, 3478, 3479, 0, 0, 0) /* UDP */);",
          "1035:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQ, 0 /* can_have_a_subprotocol */, no_master,",
          "1036:                             no_master, \"QQ\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1037:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1038:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1039:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_RTSP, 0 /* can_have_a_subprotocol */, no_master,",
          "1040:                             no_master, \"RTSP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1041:                             ndpi_build_default_ports(ports_a, 554, 0, 0, 0, 0) /* TCP */,",
          "1042:                             ndpi_build_default_ports(ports_b, 554, 0, 0, 0, 0) /* UDP */);",
          "1043:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ICECAST, 0 /* can_have_a_subprotocol */,",
          "1044:                             no_master, no_master, \"IceCast\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1045:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1046:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1047:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPLIVE, 0 /* can_have_a_subprotocol */,",
          "1048:                             no_master, no_master, \"PPLive\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1049:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1050:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1051:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PPSTREAM, 0 /* can_have_a_subprotocol */,",
          "1052:                             no_master, no_master, \"PPStream\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1053:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1054:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1055:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ZATTOO, 0 /* can_have_a_subprotocol */,",
          "1056:                             no_master, no_master, \"Zattoo\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1057:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1058:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1059:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SHOUTCAST, 0 /* can_have_a_subprotocol */,",
          "1060:                             no_master, no_master, \"ShoutCast\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1061:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1062:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1063:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOPCAST, 0 /* can_have_a_subprotocol */,",
          "1064:                             no_master, no_master, \"Sopcast\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1065:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1066:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1067:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVANTS, 0 /* can_have_a_subprotocol */,",
          "1068:                             no_master, no_master, \"Tvants\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1069:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1070:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1071:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_TVUPLAYER, 0 /* can_have_a_subprotocol */,",
          "1072:                             no_master, no_master, \"TVUplayer\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1073:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1074:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1076:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Download\",",
          "1077:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1078:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1079:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1080:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_QQLIVE, 0 /* can_have_a_subprotocol */,",
          "1081:                             no_master, no_master, \"QQLive\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1082:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1083:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1084:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_THUNDER, 0 /* can_have_a_subprotocol */,",
          "1085:                             no_master, no_master, \"Thunder\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1086:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1087:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1088:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_SOULSEEK, 0 /* can_have_a_subprotocol */,",
          "1089:                             no_master, no_master, \"Soulseek\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1090:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1091:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1093:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PS_VUE, 0 /* can_have_a_subprotocol */,",
          "1094:                             no_master, no_master, \"PS_VUE\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1095:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1096:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1097:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_IRC, 0 /* can_have_a_subprotocol */,",
          "1098:                             no_master, no_master, \"IRC\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1099:                             ndpi_build_default_ports(ports_a, 194, 0, 0, 0, 0) /* TCP */,",
          "1100:                             ndpi_build_default_ports(ports_b, 194, 0, 0, 0, 0) /* UDP */);",
          "1101:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AYIYA, 0 /* can_have_a_subprotocol */,",
          "1102:                             no_master, no_master, \"Ayiya\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1103:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1104:                             ndpi_build_default_ports(ports_b, 5072, 0, 0, 0, 0) /* UDP */);",
          "1106:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Unencrypted_Jabber\",",
          "1107:                             NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1108:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1109:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OSCAR, 0 /* can_have_a_subprotocol */,",
          "1110:                             no_master, no_master, \"Oscar\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1111:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1112:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1113:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_BATTLEFIELD, 0 /* can_have_a_subprotocol */,",
          "1114:                             no_master, no_master, \"BattleField\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1115:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1116:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1117:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_VRRP, 0 /* can_have_a_subprotocol */,",
          "1118:                             no_master, no_master, \"VRRP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1119:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1120:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1121:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STEAM, 0 /* can_have_a_subprotocol */, no_master,",
          "1122:                             no_master, \"Steam\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1123:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1124:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1125:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HALFLIFE2, 0 /* can_have_a_subprotocol */,",
          "1126:                             no_master, no_master, \"HalfLife2\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1127:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1128:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1129:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLDOFWARCRAFT, 0 /* can_have_a_subprotocol */,",
          "1130:                             no_master, no_master, \"WorldOfWarcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1131:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1132:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1134:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"HotspotShield\",",
          "1135:                             NDPI_PROTOCOL_CATEGORY_VPN, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1136:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1137:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_UNSAFE, NDPI_PROTOCOL_TELNET, 0 /* can_have_a_subprotocol */,",
          "1138:                             no_master, no_master, \"Telnet\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1139:                             ndpi_build_default_ports(ports_a, 23, 0, 0, 0, 0) /* TCP */,",
          "1140:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1143:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_STUN, 0 /* can_have_a_subprotocol */,",
          "1144:                             no_master, custom_master, \"STUN\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1145:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1146:                             ndpi_build_default_ports(ports_b, 3478, 0, 0, 0, 0) /* UDP */);",
          "1147:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_IP_IPSEC, 0 /* can_have_a_subprotocol */,",
          "1148:                             no_master, no_master, \"IPsec\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1149:                             ndpi_build_default_ports(ports_a, 500, 0, 0, 0, 0) /* TCP */,",
          "1150:                             ndpi_build_default_ports(ports_b, 500, 4500, 0, 0, 0) /* UDP */);",
          "1151:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_GRE, 0 /* can_have_a_subprotocol */,",
          "1152:                             no_master, no_master, \"GRE\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1153:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1154:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1155:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMP, 0 /* can_have_a_subprotocol */,",
          "1156:                             no_master, no_master, \"ICMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1157:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1158:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1159:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_IGMP, 0 /* can_have_a_subprotocol */,",
          "1160:                             no_master, no_master, \"IGMP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1161:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1162:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1163:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_EGP, 0 /* can_have_a_subprotocol */,",
          "1164:                             no_master, no_master, \"EGP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1165:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1166:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1167:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_SCTP, 0 /* can_have_a_subprotocol */,",
          "1168:                             no_master, no_master, \"SCTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1169:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1170:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1171:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_OSPF, 0 /* can_have_a_subprotocol */,",
          "1172:                             no_master, no_master, \"OSPF\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1173:                             ndpi_build_default_ports(ports_a, 2604, 0, 0, 0, 0) /* TCP */,",
          "1174:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1176:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"IP_in_IP\",",
          "1177:                             NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1178:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1179:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTP, 0 /* can_have_a_subprotocol */,",
          "1180:                             no_master, no_master, \"RTP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1181:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1182:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1183:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RDP, 0 /* can_have_a_subprotocol */,",
          "1184:                             no_master, no_master, \"RDP\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1185:                             ndpi_build_default_ports(ports_a, 3389, 0, 0, 0, 0) /* TCP */,",
          "1186:                             ndpi_build_default_ports(ports_b, 3389, 0, 0, 0, 0) /* UDP */);",
          "1187:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VNC, 0 /* can_have_a_subprotocol */,",
          "1188:                             no_master, no_master, \"VNC\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1189:                             ndpi_build_default_ports(ports_a, 5900, 5901, 5800, 0, 0) /* TCP */,",
          "1190:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1192:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"PcAnywhere\",",
          "1193:                             NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1194:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1195:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1196:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZOOM, 0 /* can_have_a_subprotocol */,",
          "1197:                             no_master, no_master, \"Zoom\", NDPI_PROTOCOL_CATEGORY_VIDEO,",
          "1198:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1199:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1201:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"WhatsAppFiles\",",
          "1202:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1203:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1204:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1205:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHATSAPP, 0 /* can_have_a_subprotocol */,",
          "1206:                             no_master, no_master, \"WhatsApp\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1207:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1208:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1210:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_TLS, 1 /* can_have_a_subprotocol */, no_master,",
          "1211:                             no_master, \"TLS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1212:                             ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "1213:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1214:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSH, 0 /* can_have_a_subprotocol */,",
          "1215:                             no_master, no_master, \"SSH\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1216:                             ndpi_build_default_ports(ports_a, 22, 0, 0, 0, 0) /* TCP */,",
          "1217:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1218:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_USENET, 0 /* can_have_a_subprotocol */,",
          "1219:                             no_master, no_master, \"Usenet\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1220:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1221:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1222:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MGCP, 0 /* can_have_a_subprotocol */,",
          "1223:                             no_master, no_master, \"MGCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1224:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1225:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1226:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IAX, 0 /* can_have_a_subprotocol */,",
          "1227:                             no_master, no_master, \"IAX\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1228:                             ndpi_build_default_ports(ports_a, 4569, 0, 0, 0, 0) /* TCP */,",
          "1229:                             ndpi_build_default_ports(ports_b, 4569, 0, 0, 0, 0) /* UDP */);",
          "1230:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AFP, 0 /* can_have_a_subprotocol */,",
          "1231:                             no_master, no_master, \"AFP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1232:                             ndpi_build_default_ports(ports_a, 548, 0, 0, 0, 0) /* TCP */,",
          "1233:                             ndpi_build_default_ports(ports_b, 548, 0, 0, 0, 0) /* UDP */);",
          "1234:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_HULU, 0 /* can_have_a_subprotocol */, no_master,",
          "1235:                             no_master, \"Hulu\", NDPI_PROTOCOL_CATEGORY_STREAMING,",
          "1236:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1237:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1238:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CHECKMK, 0 /* can_have_a_subprotocol */,",
          "1239:                             no_master, no_master, \"CHECKMK\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1243:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Stealthnet\",",
          "1244:                             NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1245:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1246:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1247:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_AIMINI, 0 /* can_have_a_subprotocol */,",
          "1248:                             no_master, no_master, \"Aimini\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1249:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1250:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1251:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SIP, 0 /* can_have_a_subprotocol */,",
          "1252:                             no_master, no_master, \"SIP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1253:                             ndpi_build_default_ports(ports_a, 5060, 5061, 0, 0, 0) /* TCP */,",
          "1254:                             ndpi_build_default_ports(ports_b, 5060, 5061, 0, 0, 0) /* UDP */);",
          "1255:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TRUPHONE, 0 /* can_have_a_subprotocol */,",
          "1256:                             no_master, no_master, \"TruPhone\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1257:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1258:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1259:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IP_ICMPV6, 0 /* can_have_a_subprotocol */,",
          "1260:                             no_master, no_master, \"ICMPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1261:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1262:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1263:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DHCPV6, 0 /* can_have_a_subprotocol */,",
          "1264:                             no_master, no_master, \"DHCPV6\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1265:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1266:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1267:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_ARMAGETRON, 0 /* can_have_a_subprotocol */,",
          "1268:                             no_master, no_master, \"Armagetron\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1269:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1270:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1271:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CROSSFIRE, 0 /* can_have_a_subprotocol */,",
          "1272:                             no_master, no_master, \"Crossfire\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1273:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1274:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1275:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_DOFUS, 0 /* can_have_a_subprotocol */, no_master,",
          "1276:                             no_master, \"Dofus\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1277:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1278:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1279:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FIESTA, 0 /* can_have_a_subprotocol */,",
          "1280:                             no_master, no_master, \"Fiesta\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1281:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1282:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1283:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_FLORENSIA, 0 /* can_have_a_subprotocol */,",
          "1284:                             no_master, no_master, \"Florensia\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1285:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1286:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1287:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_GUILDWARS, 0 /* can_have_a_subprotocol */,",
          "1288:                             no_master, no_master, \"Guildwars\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1289:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1290:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1292:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_ActiveSync\",",
          "1293:                             NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1294:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1295:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_KERBEROS, 0 /* can_have_a_subprotocol */,",
          "1296:                             no_master, no_master, \"Kerberos\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1297:                             ndpi_build_default_ports(ports_a, 88, 0, 0, 0, 0) /* TCP */,",
          "1298:                             ndpi_build_default_ports(ports_b, 88, 0, 0, 0, 0) /* UDP */);",
          "1299:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LDAP, 0 /* can_have_a_subprotocol */,",
          "1300:                             no_master, no_master, \"LDAP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1301:                             ndpi_build_default_ports(ports_a, 389, 0, 0, 0, 0) /* TCP */,",
          "1302:                             ndpi_build_default_ports(ports_b, 389, 0, 0, 0, 0) /* UDP */);",
          "1303:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MAPLESTORY, 0 /* can_have_a_subprotocol */,",
          "1304:                             no_master, no_master, \"MapleStory\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1305:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1306:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1307:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MSSQL_TDS, 0 /* can_have_a_subprotocol */,",
          "1308:                             no_master, no_master, \"MsSQL-TDS\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1309:                             ndpi_build_default_ports(ports_a, 1433, 1434, 0, 0, 0) /* TCP */,",
          "1310:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1311:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_PPTP, 0 /* can_have_a_subprotocol */,",
          "1312:                             no_master, no_master, \"PPTP\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1313:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1314:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1315:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WARCRAFT3, 0 /* can_have_a_subprotocol */,",
          "1316:                             no_master, no_master, \"Warcraft3\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1317:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1318:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1319:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_WORLD_OF_KUNG_FU, 0 /* can_have_a_subprotocol */,",
          "1320:                             no_master, no_master, \"WorldOfKungFu\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1321:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1322:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1323:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DCERPC, 0 /* can_have_a_subprotocol */,",
          "1324:                             no_master, no_master, \"DCE_RPC\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1325:                             ndpi_build_default_ports(ports_a, 135, 0, 0, 0, 0) /* TCP */,",
          "1326:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1327:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NETFLOW, 0 /* can_have_a_subprotocol */,",
          "1328:                             no_master, no_master, \"NetFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1329:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1330:                             ndpi_build_default_ports(ports_b, 2055, 0, 0, 0, 0) /* UDP */);",
          "1331:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SFLOW, 0 /* can_have_a_subprotocol */,",
          "1332:                             no_master, no_master, \"sFlow\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1333:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1334:                             ndpi_build_default_ports(ports_b, 6343, 0, 0, 0, 0) /* UDP */);",
          "1336:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Connect\",",
          "1337:                             NDPI_PROTOCOL_CATEGORY_WEB, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1338:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1340:                             1 /* can_have_a_subprotocol */, no_master, no_master, \"HTTP_Proxy\",",
          "1341:                             NDPI_PROTOCOL_CATEGORY_WEB,",
          "1342:                             ndpi_build_default_ports(ports_a, 8080, 3128, 0, 0, 0) /* TCP */,",
          "1343:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1344:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CITRIX, 0 /* can_have_a_subprotocol */,",
          "1345:                             no_master, no_master, \"Citrix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1346:                             ndpi_build_default_ports(ports_a, 1494, 2598, 0, 0, 0) /* TCP */,",
          "1347:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1348:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WEBEX, 0 /* can_have_a_subprotocol */,",
          "1349:                             no_master, no_master, \"Webex\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1350:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1351:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1352:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RADIUS, 0 /* can_have_a_subprotocol */,",
          "1353:                             no_master, no_master, \"Radius\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1354:                             ndpi_build_default_ports(ports_a, 1812, 1813, 0, 0, 0) /* TCP */,",
          "1355:                             ndpi_build_default_ports(ports_b, 1812, 1813, 0, 0, 0) /* UDP */);",
          "1357:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"TeamViewer\",",
          "1358:                             NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1359:                             ndpi_build_default_ports(ports_a, 5938, 0, 0, 0, 0) /* TCP */,",
          "1360:                             ndpi_build_default_ports(ports_b, 5938, 0, 0, 0, 0) /* UDP */);",
          "1362:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"LotusNotes\",",
          "1363:                             NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1364:                             ndpi_build_default_ports(ports_a, 1352, 0, 0, 0, 0) /* TCP */,",
          "1365:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1366:     ndpi_set_proto_defaults(",
          "1367:         ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SAP, 0 /* can_have_a_subprotocol */, no_master, no_master,",
          "1368:         \"SAP\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 3201, 0, 0, 0, 0) /* TCP */,",
          "1370:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_GTP, 0 /* can_have_a_subprotocol */,",
          "1371:                             no_master, no_master, \"GTP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1372:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1373:                             ndpi_build_default_ports(ports_b, 2152, 2123, 0, 0, 0) /* UDP */);",
          "1374:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UPNP, 0 /* can_have_a_subprotocol */,",
          "1375:                             no_master, no_master, \"UPnP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1376:                             ndpi_build_default_ports(ports_a, 1780, 0, 0, 0, 0) /* TCP */,",
          "1377:                             ndpi_build_default_ports(ports_b, 1900, 0, 0, 0, 0) /* UDP */);",
          "1378:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TELEGRAM, 0 /* can_have_a_subprotocol */,",
          "1379:                             no_master, no_master, \"Telegram\", NDPI_PROTOCOL_CATEGORY_CHAT,",
          "1380:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1381:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1382:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_QUIC, 1 /* can_have_a_subprotocol */,",
          "1383:                             no_master, no_master, \"QUIC\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1384:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1385:                             ndpi_build_default_ports(ports_b, 443, 80, 0, 0, 0) /* UDP */);",
          "1386:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DIAMETER, 0 /* can_have_a_subprotocol */,",
          "1387:                             no_master, no_master, \"Diameter\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1388:                             ndpi_build_default_ports(ports_a, 3868, 0, 0, 0, 0) /* TCP */,",
          "1389:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1391:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"ApplePush\",",
          "1392:                             NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 1, 0, 0, 0, 0) /* TCP */,",
          "1393:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1394:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DROPBOX, 0 /* can_have_a_subprotocol */,",
          "1395:                             no_master, no_master, \"Dropbox\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1396:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1397:                             ndpi_build_default_ports(ports_b, 17500, 0, 0, 0, 0) /* UDP */);",
          "1398:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SPOTIFY, 0 /* can_have_a_subprotocol */,",
          "1399:                             no_master, no_master, \"Spotify\", NDPI_PROTOCOL_CATEGORY_MUSIC,",
          "1400:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1401:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1402:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MESSENGER, 0 /* can_have_a_subprotocol */,",
          "1403:                             no_master, no_master, \"Messenger\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1404:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1405:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1406:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LISP, 0 /* can_have_a_subprotocol */,",
          "1407:                             no_master, no_master, \"LISP\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1408:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1409:                             ndpi_build_default_ports(ports_b, 4342, 4341, 0, 0, 0) /* UDP */);",
          "1410:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_EAQ, 0 /* can_have_a_subprotocol */,",
          "1411:                             no_master, no_master, \"EAQ\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1412:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1413:                             ndpi_build_default_ports(ports_b, 6000, 0, 0, 0, 0) /* UDP */);",
          "1415:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"KakaoTalk_Voice\",",
          "1416:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1417:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1418:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_MPEGTS, 0 /* can_have_a_subprotocol */,",
          "1419:                             no_master, no_master, \"MPEG_TS\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1420:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1421:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1423:     ndpi_set_proto_defaults(",
          "1424:         ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_LLMNR, 0 /* can_have_a_subprotocol */, no_master, no_master,",
          "1425:         \"LLMNR\", NDPI_PROTOCOL_CATEGORY_NETWORK, ndpi_build_default_ports(ports_a, 5355, 0, 0, 0, 0) /* TCP */,",
          "1427:     ndpi_set_proto_defaults(",
          "1428:         ndpi_str, NDPI_PROTOCOL_POTENTIALLY_DANGEROUS, NDPI_PROTOCOL_REMOTE_SCAN, 0 /* can_have_a_subprotocol */,",
          "1429:         no_master, no_master, \"RemoteScan\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1430:         ndpi_build_default_ports(ports_a, 6077, 0, 0, 0, 0) /* TCP */,",
          "1433:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_H323, 0 /* can_have_a_subprotocol */,",
          "1434:                             no_master, no_master, \"H323\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1435:                             ndpi_build_default_ports(ports_a, 1719, 1720, 0, 0, 0) /* TCP */,",
          "1436:                             ndpi_build_default_ports(ports_b, 1719, 1720, 0, 0, 0) /* UDP */);",
          "1437:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_OPENVPN, 0 /* can_have_a_subprotocol */,",
          "1438:                             no_master, no_master, \"OpenVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1439:                             ndpi_build_default_ports(ports_a, 1194, 0, 0, 0, 0) /* TCP */,",
          "1440:                             ndpi_build_default_ports(ports_b, 1194, 0, 0, 0, 0) /* UDP */);",
          "1441:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NOE, 0 /* can_have_a_subprotocol */,",
          "1442:                             no_master, no_master, \"NOE\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1443:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1444:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1445:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CISCOVPN, 0 /* can_have_a_subprotocol */,",
          "1446:                             no_master, no_master, \"CiscoVPN\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1447:                             ndpi_build_default_ports(ports_a, 10000, 8008, 8009, 0, 0) /* TCP */,",
          "1448:                             ndpi_build_default_ports(ports_b, 10000, 0, 0, 0, 0) /* UDP */);",
          "1449:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TEAMSPEAK, 0 /* can_have_a_subprotocol */,",
          "1450:                             no_master, no_master, \"TeamSpeak\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1451:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1452:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1453:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SKINNY, 0 /* can_have_a_subprotocol */,",
          "1454:                             no_master, no_master, \"CiscoSkinny\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1455:                             ndpi_build_default_ports(ports_a, 2000, 0, 0, 0, 0) /* TCP */,",
          "1456:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1457:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTCP, 0 /* can_have_a_subprotocol */,",
          "1458:                             no_master, no_master, \"RTCP\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1459:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1460:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1461:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RSYNC, 0 /* can_have_a_subprotocol */,",
          "1462:                             no_master, no_master, \"RSYNC\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1463:                             ndpi_build_default_ports(ports_a, 873, 0, 0, 0, 0) /* TCP */,",
          "1464:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1465:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ORACLE, 0 /* can_have_a_subprotocol */,",
          "1466:                             no_master, no_master, \"Oracle\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1467:                             ndpi_build_default_ports(ports_a, 1521, 0, 0, 0, 0) /* TCP */,",
          "1468:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1469:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CORBA, 0 /* can_have_a_subprotocol */,",
          "1470:                             no_master, no_master, \"Corba\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1471:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1472:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1473:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_UBUNTUONE, 0 /* can_have_a_subprotocol */,",
          "1474:                             no_master, no_master, \"UbuntuONE\", NDPI_PROTOCOL_CATEGORY_CLOUD,",
          "1475:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1476:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1477:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_WHOIS_DAS, 0 /* can_have_a_subprotocol */,",
          "1478:                             no_master, no_master, \"Whois-DAS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1481:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_COLLECTD, 0 /* can_have_a_subprotocol */,",
          "1482:                             no_master, no_master, \"Collectd\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1485:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOCKS, 0 /* can_have_a_subprotocol */,",
          "1486:                             no_master, no_master, \"SOCKS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1489:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TFTP, 0 /* can_have_a_subprotocol */,",
          "1490:                             no_master, no_master, \"TFTP\", NDPI_PROTOCOL_CATEGORY_DATA_TRANSFER,",
          "1493:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RTMP, 0 /* can_have_a_subprotocol */,",
          "1494:                             no_master, no_master, \"RTMP\", NDPI_PROTOCOL_CATEGORY_MEDIA,",
          "1497:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_PANDO, 0 /* can_have_a_subprotocol */, no_master,",
          "1498:                             no_master, \"Pando_Media_Booster\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1501:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MEGACO, 0 /* can_have_a_subprotocol */,",
          "1502:                             no_master, no_master, \"Megaco\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1505:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_REDIS, 0 /* can_have_a_subprotocol */,",
          "1506:                             no_master, no_master, \"Redis\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1509:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZMQ, 0 /* can_have_a_subprotocol */,",
          "1510:                             no_master, no_master, \"ZeroMQ\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1513:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_VHUA, 0 /* can_have_a_subprotocol */, no_master,",
          "1514:                             no_master, \"VHUA\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1517:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_STARCRAFT, 0 /* can_have_a_subprotocol */,",
          "1518:                             no_master, no_master, \"Starcraft\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1521:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_UBNTAC2, 0 /* can_have_a_subprotocol */,",
          "1522:                             no_master, no_master, \"UBNTAC2\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1525:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_VIBER, 0 /* can_have_a_subprotocol */,",
          "1526:                             no_master, no_master, \"Viber\", NDPI_PROTOCOL_CATEGORY_VOIP,",
          "1529:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_COAP, 0 /* can_have_a_subprotocol */, no_master,",
          "1530:                             no_master, \"COAP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1533:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MQTT, 0 /* can_have_a_subprotocol */,",
          "1534:                             no_master, no_master, \"MQTT\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1537:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SOMEIP, 0 /* can_have_a_subprotocol */,",
          "1538:                             no_master, no_master, \"SOMEIP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1541:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_RX, 0 /* can_have_a_subprotocol */,",
          "1542:                             no_master, no_master, \"RX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1545:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_GIT, 0 /* can_have_a_subprotocol */, no_master,",
          "1546:                             no_master, \"Git\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1549:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DRDA, 0 /* can_have_a_subprotocol */,",
          "1550:                             no_master, no_master, \"DRDA\", NDPI_PROTOCOL_CATEGORY_DATABASE,",
          "1554:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"GoogleHangoutDuo\",",
          "1555:                             NDPI_PROTOCOL_CATEGORY_VOIP, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1556:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1557:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BJNP, 0 /* can_have_a_subprotocol */,",
          "1558:                             no_master, no_master, \"BJNP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "1559:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1560:                             ndpi_build_default_ports(ports_b, 8612, 0, 0, 0, 0) /* UDP */);",
          "1561:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SMPP, 0 /* can_have_a_subprotocol */,",
          "1562:                             no_master, no_master, \"SMPP\", NDPI_PROTOCOL_CATEGORY_DOWNLOAD_FT,",
          "1565:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_OOKLA, 0 /* can_have_a_subprotocol */,",
          "1566:                             no_master, no_master, \"Ookla\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1569:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AMQP, 0 /* can_have_a_subprotocol */,",
          "1570:                             no_master, no_master, \"AMQP\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1573:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_DNSCRYPT, 0 /* can_have_a_subprotocol */,",
          "1574:                             no_master, no_master, \"DNScrypt\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1577:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_TINC, 0 /* can_have_a_subprotocol */,",
          "1578:                             no_master, no_master, \"TINC\", NDPI_PROTOCOL_CATEGORY_VPN,",
          "1579:                             ndpi_build_default_ports(ports_a, 655, 0, 0, 0, 0) /* TCP */,",
          "1580:                             ndpi_build_default_ports(ports_b, 655, 0, 0, 0, 0) /* UDP */);",
          "1581:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_FIX, 0 /* can_have_a_subprotocol */, no_master,",
          "1582:                             no_master, \"FIX\", NDPI_PROTOCOL_CATEGORY_RPC,",
          "1583:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1584:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1585:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_NINTENDO, 0 /* can_have_a_subprotocol */,",
          "1586:                             no_master, no_master, \"Nintendo\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1587:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1588:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1589:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_FUN, NDPI_PROTOCOL_CSGO, 0 /* can_have_a_subprotocol */, no_master,",
          "1590:                             no_master, \"CSGO\", NDPI_PROTOCOL_CATEGORY_GAME,",
          "1591:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1592:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1593:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_AJP, 0 /* can_have_a_subprotocol */,",
          "1594:                             no_master, no_master, \"AJP\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1595:                             ndpi_build_default_ports(ports_a, 8009, 0, 0, 0, 0) /* TCP */,",
          "1596:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1598:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"Targus Dataspeed\",",
          "1599:                             NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1600:                             ndpi_build_default_ports(ports_a, 5001, 5201, 0, 0, 0) /* TCP */,",
          "1601:                             ndpi_build_default_ports(ports_b, 5001, 5201, 0, 0, 0) /* UDP */);",
          "1603:                             0 /* can_have_a_subprotocol */, no_master, no_master, \"AmazonVideo\",",
          "1604:                             NDPI_PROTOCOL_CATEGORY_CLOUD, ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1605:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1606:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DNP3, 1 /* no subprotocol */, no_master,",
          "1607:                             no_master, \"DNP3\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1608:                             ndpi_build_default_ports(ports_a, 20000, 0, 0, 0, 0) /* TCP */,",
          "1609:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1610:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IEC60870, 1 /* no subprotocol */,",
          "1611:                             no_master, no_master, \"IEC60870\",",
          "1613:                             ndpi_build_default_ports(ports_a, 2404, 0, 0, 0, 0) /* TCP */,",
          "1614:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1615:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_BLOOMBERG, 1 /* no subprotocol */,",
          "1616:                             no_master, no_master, \"Bloomberg\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1617:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1618:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1619:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CAPWAP, 1 /* no subprotocol */, no_master,",
          "1620:                             no_master, \"CAPWAP\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1621:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1623:     );",
          "1624:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_ZABBIX, 1 /* no subprotocol */, no_master,",
          "1625:                             no_master, \"Zabbix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1626:                             ndpi_build_default_ports(ports_a, 10050, 0, 0, 0, 0) /* TCP */,",
          "1628:     );",
          "1629:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_S7COMM, 1 /* no subprotocol */, no_master,",
          "1630:                             no_master, \"s7comm\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1631:                             ndpi_build_default_ports(ports_a, 102, 0, 0, 0, 0) /* TCP */,",
          "1632:                             ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1633:     ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_MSTEAMS, 1 /* no subprotocol */, no_master,",
          "1634:                             no_master, \"Teams\", NDPI_PROTOCOL_CATEGORY_COLLABORATIVE,",
          "1635:                             ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1637:     );",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1847: #ifdef MATCH_DEBUG",
          "1851: #endif",
          "1855: #ifdef MATCH_DEBUG",
          "1860: #endif",
          "1864:       The patch below allows in case of pattern ws.amazon.com",
          "1865:       to avoid matching aws.amazon.com whereas a.ws.amazon.com",
          "1866:       has to match",
          "1885:     Return 1 for stopping to the first match.",
          "1886:     We might consider searching for the more",
          "1887:     specific match, paying more cpu cycles.",
          "1894: #ifdef MATCH_DEBUG",
          "1899: #endif",
          "1902: #ifdef MATCH_DEBUG",
          "1904: #endif",
          "1907: }",
          "1924: }",
          "1929: #ifdef PATRICIA_IPV6",
          "1937: #else",
          "1939: #endif",
          "1940: }",
          "1944: u_int16_t ndpi_network_ptree_match(struct ndpi_detection_module_struct *ndpi_str,",
          "1954: }",
          "",
          "[Removed Lines]",
          "1838: static int ac_match_handler(AC_MATCH_t *m, AC_TEXT_t *txt, AC_REP_t *match) {",
          "1839:   int min_len = (txt->length < m->patterns->length) ? txt->length : m->patterns->length;",
          "1840:   char buf[64] = { '\\0' }, *whatfound;",
          "1841:   int min_buf_len = (txt->length > 63 /* sizeof(buf)-1 */) ? 63 : txt->length;",
          "1842:   u_int buf_len = strlen(buf);",
          "1844:   strncpy(buf, txt->astring, min_buf_len);",
          "1845:   buf[min_buf_len] = '\\0';",
          "1848:   printf(\"Searching [to search: %s/%u][pattern: %s/%u] [len: %d][match_num: %u][%s]\\n\",",
          "1849:   buf, (unigned int)txt->length, m->patterns->astring, (unigned int)m->patterns->length,",
          "1850:   min_len, m->match_num, m->patterns->astring);",
          "1853:   whatfound = strstr(buf, m->patterns->astring);",
          "1856:   printf(\"[NDPI] %s() [searching=%s][pattern=%s][%s][%c]\\n\",",
          "1857:   __FUNCTION__, buf,  m->patterns->astring,",
          "1858:   whatfound ? whatfound : \"<NULL>\",",
          "1859:   whatfound[-1]);",
          "1862:   if(whatfound) {",
          "1868:     if((whatfound != buf)",
          "1870:        && strchr(m->patterns->astring, '.') /* The matched pattern has a . (e.g. numeric or sym IPs) */) {",
          "1871:       int len = strlen(m->patterns->astring);",
          "1873:       if((whatfound[-1] != '.')",
          "1874:   || ((m->patterns->astring[len-1] != '.') && (whatfound[len] != '\\0') /* endsWith does not hold here */)",
          "1875:   ) {",
          "1876:  return(0);",
          "1877:       } else {",
          "1880:       }",
          "1881:     }",
          "1882:   }",
          "1889:   memcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t));",
          "1891:   if(((buf_len >= min_len) && (strncmp(&buf[buf_len-min_len], m->patterns->astring, min_len) == 0))",
          "1893:      ) {",
          "1895:     printf(\"Found match [%s][%s] [len: %d]\"",
          "1897:     \"\\n\",",
          "1898:     buf, m->patterns->astring, min_len /* , *matching_protocol_id */);",
          "1901:   } else {",
          "1903:     printf(\"NO match found: continue\\n\");",
          "1906:   }",
          "1911: static int fill_prefix_v4(prefix_t *p, const struct in_addr *a, int b, int mb) {",
          "1912:   do {",
          "1913:     if(b < 0 || b > mb)",
          "1914:       return(-1);",
          "1916:     memset(p, 0, sizeof(prefix_t));",
          "1917:     memcpy(&p->add.sin, a, (mb+7)/8);",
          "1918:     p->family = AF_INET;",
          "1919:     p->bitlen = b;",
          "1920:     p->ref_count = 0;",
          "1921:   } while(0);",
          "1923:   return(0);",
          "1928: static int fill_prefix_v6(prefix_t *prefix, const struct in6_addr *addr, int bits, int maxbits) {",
          "1930:     if(bits < 0 || bits > maxbits)",
          "1931:     return -1;",
          "1933:   memcpy(&prefix->add.sin6, addr, (maxbits + 7) / 8);",
          "1934:   prefix->family = AF_INET6, prefix->bitlen = bits, prefix->ref_count = 0;",
          "1936:   return 0;",
          "1938:     return(-1);",
          "1945:        struct in_addr *pin /* network byte order */) {",
          "1946:   prefix_t prefix;",
          "1947:   patricia_node_t *node;",
          "1950:   fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t*)ndpi_str->protocols_ptree)->maxbits);",
          "1951:   node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);",
          "1953:   return(node ? node->value.user_value : NDPI_PROTOCOL_UNKNOWN);",
          "",
          "[Added Lines]",
          "1657: static int ac_match_handler(AC_MATCH_t *m, AC_TEXT_t *txt, AC_REP_t *match)",
          "1658: {",
          "1659:     int min_len = (txt->length < m->patterns->length) ? txt->length : m->patterns->length;",
          "1660:     char buf[64] = {'\\0'}, *whatfound;",
          "1661:     int min_buf_len = (txt->length > 63 /* sizeof(buf)-1 */) ? 63 : txt->length;",
          "1662:     u_int buf_len = strlen(buf);",
          "1664:     strncpy(buf, txt->astring, min_buf_len);",
          "1665:     buf[min_buf_len] = '\\0';",
          "1668:     printf(\"Searching [to search: %s/%u][pattern: %s/%u] [len: %d][match_num: %u][%s]\\n\", buf,",
          "1669:            (unigned int) txt->length, m->patterns->astring, (unigned int) m->patterns->length, min_len, m->match_num,",
          "1670:            m->patterns->astring);",
          "1673:     whatfound = strstr(buf, m->patterns->astring);",
          "1676:     printf(\"[NDPI] %s() [searching=%s][pattern=%s][%s][%c]\\n\", __FUNCTION__, buf, m->patterns->astring,",
          "1677:            whatfound ? whatfound : \"<NULL>\", whatfound[-1]);",
          "1680:     if (whatfound) {",
          "1687:             && strchr(m->patterns->astring, '.') /* The matched pattern has a . (e.g. numeric or sym IPs) */) {",
          "1688:             int len = strlen(m->patterns->astring);",
          "1690:             if ((whatfound[-1] != '.') || ((m->patterns->astring[len - 1] != '.') &&",
          "1691:                                            (whatfound[len] != '\\0') /* endsWith does not hold here */)) {",
          "1692:                 return (0);",
          "1693:             } else {",
          "1696:             }",
          "1697:         }",
          "1698:     }",
          "1705:     memcpy(match, &m->patterns[0].rep, sizeof(AC_REP_t));",
          "1707:     if (((buf_len >= min_len) && (strncmp(&buf[buf_len - min_len], m->patterns->astring, min_len) == 0)) ||",
          "1709:     ) {",
          "1711:         printf(\"Found match [%s][%s] [len: %d]\"",
          "1713:                \"\\n\",",
          "1714:                buf, m->patterns->astring, min_len /* , *matching_protocol_id */);",
          "1717:     } else {",
          "1719:         printf(\"NO match found: continue\\n\");",
          "1722:     }",
          "1727: static int fill_prefix_v4(prefix_t *p, const struct in_addr *a, int b, int mb)",
          "1728: {",
          "1729:     do {",
          "1730:         if (b < 0 || b > mb)",
          "1731:             return (-1);",
          "1733:         memset(p, 0, sizeof(prefix_t));",
          "1734:         memcpy(&p->add.sin, a, (mb + 7) / 8);",
          "1735:         p->family = AF_INET;",
          "1736:         p->bitlen = b;",
          "1737:         p->ref_count = 0;",
          "1738:     } while (0);",
          "1740:     return (0);",
          "1745: static int fill_prefix_v6(prefix_t *prefix, const struct in6_addr *addr, int bits, int maxbits)",
          "1746: {",
          "1748:     if (bits < 0 || bits > maxbits)",
          "1749:         return -1;",
          "1751:     memcpy(&prefix->add.sin6, addr, (maxbits + 7) / 8);",
          "1752:     prefix->family = AF_INET6, prefix->bitlen = bits, prefix->ref_count = 0;",
          "1754:     return 0;",
          "1756:     return (-1);",
          "1763:                                    struct in_addr *pin /* network byte order */)",
          "1764: {",
          "1765:     prefix_t prefix;",
          "1766:     patricia_node_t *node;",
          "1769:     fill_prefix_v4(&prefix, pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "1770:     node = ndpi_patricia_search_best(ndpi_str->protocols_ptree, &prefix);",
          "1772:     return (node ? node->value.user_value : NDPI_PROTOCOL_UNKNOWN);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1974:     }",
          "1978: }",
          "1992: }",
          "",
          "[Removed Lines]",
          "1966: u_int8_t ndpi_is_tor_flow(struct ndpi_detection_module_struct *ndpi_str,",
          "1967:      struct ndpi_flow_struct *flow) {",
          "1968:   struct ndpi_packet_struct *packet = &flow->packet;",
          "1970:   if(packet->tcp != NULL) {",
          "1971:     if(packet->iph) {",
          "1972:       if(flow->guessed_host_protocol_id == NDPI_PROTOCOL_TOR)",
          "1973:  return(1);",
          "1975:   }",
          "1977:   return(0);",
          "1982: static patricia_node_t* add_to_ptree(patricia_tree_t *tree, int family,",
          "1983:          void *addr, int bits) {",
          "1984:   prefix_t prefix;",
          "1985:   patricia_node_t *node;",
          "1987:   fill_prefix_v4(&prefix, (struct in_addr*)addr, bits, tree->maxbits);",
          "1989:   node = ndpi_patricia_lookup(tree, &prefix);",
          "1991:   return(node);",
          "",
          "[Added Lines]",
          "1785: u_int8_t ndpi_is_tor_flow(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "1786: {",
          "1787:     struct ndpi_packet_struct *packet = &flow->packet;",
          "1789:     if (packet->tcp != NULL) {",
          "1790:         if (packet->iph) {",
          "1791:             if (flow->guessed_host_protocol_id == NDPI_PROTOCOL_TOR)",
          "1792:                 return (1);",
          "1793:         }",
          "1796:     return (0);",
          "1801: static patricia_node_t *add_to_ptree(patricia_tree_t *tree, int family, void *addr, int bits)",
          "1802: {",
          "1803:     prefix_t prefix;",
          "1804:     patricia_node_t *node;",
          "1806:     fill_prefix_v4(&prefix, (struct in_addr *) addr, bits, tree->maxbits);",
          "1808:     node = ndpi_patricia_lookup(tree, &prefix);",
          "1810:     return (node);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1999:   Return: the number of entries loaded or -1 in case of error",
          "2039:     }",
          "2044: }",
          "2066: }",
          "2091: }",
          "2102: {",
          "2103: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2105: #define MAX_STR_LEN 250",
          "2120: #endif",
          "2121: }",
          "2124: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2126: #endif",
          "2127: }",
          "2239: };",
          "2248: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2256: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2266: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "2268: #endif",
          "2305: #ifdef HAVE_HYPERSCAN",
          "2308: #else",
          "2311: #endif",
          "2327: }",
          "2362:     }",
          "2364: }",
          "2371: }",
          "2387: }",
          "2391: }",
          "2413:     As ac_automata_search can detect partial matches and continue the search process",
          "2414:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "2415:     and in this case return it",
          "2420: }",
          "2440:     As ac_automata_search can detect partial matches and continue the search process",
          "2441:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "2442:     and in this case return it",
          "2449: }",
          "2453: #ifdef HAVE_HYPERSCAN",
          "2461: #ifdef DEBUG",
          "2463: #endif",
          "2466: }",
          "2467: #endif",
          "2473: #ifdef HAVE_HYPERSCAN",
          "2487: #ifdef DEBUG",
          "2489: #endif",
          "2494: #else",
          "2496: #endif",
          "2497: }",
          "2539: }",
          "2586: #ifdef HAVE_HYPERSCAN",
          "2598: #else",
          "2604: #endif",
          "2614: }",
          "2632: }",
          "2655:     }",
          "2661: }",
          "",
          "[Removed Lines]",
          "2001: int ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str,",
          "2002:     const char *path, u_int16_t protocol_id) {",
          "2003:   char buffer[128], *line, *addr, *cidr, *saveptr;",
          "2004:   FILE *fd;",
          "2005:   int len;",
          "2006:   u_int num_loaded = 0;",
          "2008:   fd = fopen(path, \"r\");",
          "2010:   if(fd == NULL) {",
          "2011:     NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2012:     return(-1);",
          "2013:   }",
          "2015:   while(1) {",
          "2016:     line = fgets(buffer, sizeof(buffer), fd);",
          "2018:     if(line == NULL)",
          "2019:       break;",
          "2021:     len = strlen(line);",
          "2023:     if((len <= 1) || (line[0] == '#'))",
          "2024:       continue;",
          "2026:     line[len-1] = '\\0';",
          "2027:     addr = strtok_r(line, \"/\", &saveptr);",
          "2029:     if(addr) {",
          "2030:       struct in_addr pin;",
          "2031:       patricia_node_t *node;",
          "2033:       cidr = strtok_r(NULL, \"\\n\", &saveptr);",
          "2035:       pin.s_addr = inet_addr(addr);",
          "2036:       if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET,",
          "2037:          &pin, cidr ? atoi(cidr) : 32 /* bits */)) != NULL)",
          "2038:  node->value.user_value = protocol_id, num_loaded++;",
          "2040:   }",
          "2042:   fclose(fd);",
          "2043:   return(num_loaded);",
          "2049: static void ndpi_init_ptree_ipv4(struct ndpi_detection_module_struct *ndpi_str,",
          "2050:      void *ptree, ndpi_network host_list[],",
          "2051:      u_int8_t skip_tor_hosts) {",
          "2052:   int i;",
          "2054:   for(i=0; host_list[i].network != 0x0; i++) {",
          "2055:     struct in_addr pin;",
          "2056:     patricia_node_t *node;",
          "2058:     if(skip_tor_hosts && (host_list[i].value == NDPI_PROTOCOL_TOR))",
          "2059:       continue;",
          "2061:     pin.s_addr = htonl(host_list[i].network);",
          "2062:     if((node = add_to_ptree(ptree, AF_INET,",
          "2063:        &pin, host_list[i].cidr /* bits */)) != NULL)",
          "2064:       node->value.user_value = host_list[i].value;",
          "2065:   }",
          "2070: static int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "2071:      char *value, int protocol_id) {",
          "2073:   patricia_node_t *node;",
          "2074:   struct in_addr pin;",
          "2075:   int bits = 32;",
          "2076:   char *ptr = strrchr(value, '/');",
          "2078:   if(ptr) {",
          "2079:     ptr[0] = '\\0';",
          "2080:     ptr++;",
          "2081:     if(atoi(ptr)>=0 && atoi(ptr)<=32)",
          "2082:       bits = atoi(ptr);",
          "2083:   }",
          "2085:   inet_pton(AF_INET, value, &pin);",
          "2087:   if((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits)) != NULL)",
          "2088:     node->value.user_value = protocol_id;",
          "2090:   return(0);",
          "2093: void set_ndpi_malloc(void* (*__ndpi_malloc)(size_t size)) { _ndpi_malloc = __ndpi_malloc; }",
          "2094: void set_ndpi_flow_malloc(void* (*__ndpi_flow_malloc)(size_t size)) { _ndpi_flow_malloc = __ndpi_flow_malloc; }",
          "2096: void set_ndpi_free(void  (*__ndpi_free)(void *ptr))       { _ndpi_free = __ndpi_free; }",
          "2097: void set_ndpi_flow_free(void  (*__ndpi_flow_free)(void *ptr))       { _ndpi_flow_free = __ndpi_flow_free; }",
          "2099: void ndpi_debug_printf(unsigned int proto, struct ndpi_detection_module_struct *ndpi_str,",
          "2100:          ndpi_log_level_t log_level, const char *file_name, const char *func_name, int line_number,",
          "2101:          const char * format, ...)",
          "2104:   va_list args;",
          "2106:   char str[MAX_STR_LEN];",
          "2107:   if(ndpi_str != NULL && log_level > NDPI_LOG_ERROR  &&",
          "2108:      proto > 0 && proto < NDPI_MAX_SUPPORTED_PROTOCOLS &&",
          "2109:      !NDPI_ISSET(&ndpi_str->debug_bitmask,proto)) return;",
          "2110:   va_start(args, format);",
          "2111:   vsnprintf(str,sizeof(str)-1, format, args);",
          "2112:   va_end(args);",
          "2114:   if(ndpi_str != NULL) {",
          "2115:     printf(\"%s:%s:%-3d - [%s]: %s\",",
          "2116:     file_name, func_name, line_number, ndpi_get_proto_name(ndpi_str, proto), str);",
          "2117:   } else {",
          "2118:     printf(\"Proto: %u, %s\", proto, str);",
          "2119:   }",
          "2123: void set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str, ndpi_debug_function_ptr ndpi_debug_printf) {",
          "2125:   ndpi_str->ndpi_debug_printf = ndpi_debug_printf;",
          "2132: static const char* categories[] = {",
          "2133:   \"Unspecified\",",
          "2134:   \"Media\",",
          "2135:   \"VPN\",",
          "2136:   \"Email\",",
          "2137:   \"DataTransfer\",",
          "2138:   \"Web\",",
          "2139:   \"SocialNetwork\",",
          "2140:   \"Download-FileTransfer-FileSharing\",",
          "2141:   \"Game\",",
          "2142:   \"Chat\",",
          "2143:   \"VoIP\",",
          "2144:   \"Database\",",
          "2145:   \"RemoteAccess\",",
          "2146:   \"Cloud\",",
          "2147:   \"Network\",",
          "2148:   \"Collaborative\",",
          "2149:   \"RPC\",",
          "2150:   \"Streaming\",",
          "2151:   \"System\",",
          "2152:   \"SoftwareUpdate\",",
          "2153:   \"\",",
          "2154:   \"\",",
          "2155:   \"\",",
          "2156:   \"\",",
          "2157:   \"\",",
          "2158:   \"Music\",",
          "2159:   \"Video\",",
          "2160:   \"Shopping\",",
          "2161:   \"Productivity\",",
          "2162:   \"FileSharing\",",
          "2163:   \"\",",
          "2164:   \"\",",
          "2165:   \"\",",
          "2166:   \"\",",
          "2167:   \"\",",
          "2168:   \"\",",
          "2169:   \"\",",
          "2170:   \"\",",
          "2171:   \"\",",
          "2172:   \"\",",
          "2173:   \"\",",
          "2174:   \"\",",
          "2175:   \"\",",
          "2176:   \"\",",
          "2177:   \"\",",
          "2178:   \"\",",
          "2179:   \"\",",
          "2180:   \"\",",
          "2181:   \"\",",
          "2182:   \"\",",
          "2183:   \"\",",
          "2184:   \"\",",
          "2185:   \"\",",
          "2186:   \"\",",
          "2187:   \"\",",
          "2188:   \"\",",
          "2189:   \"\",",
          "2190:   \"\",",
          "2191:   \"\",",
          "2192:   \"\",",
          "2193:   \"\",",
          "2194:   \"\",",
          "2195:   \"\",",
          "2196:   \"\",",
          "2197:   \"\",",
          "2198:   \"\",",
          "2199:   \"\",",
          "2200:   \"\",",
          "2201:   \"\",",
          "2202:   \"\",",
          "2203:   \"\",",
          "2204:   \"\",",
          "2205:   \"\",",
          "2206:   \"\",",
          "2207:   \"\",",
          "2208:   \"\",",
          "2209:   \"\",",
          "2210:   \"\",",
          "2211:   \"\",",
          "2212:   \"\",",
          "2213:   \"\",",
          "2214:   \"\",",
          "2215:   \"\",",
          "2216:   \"\",",
          "2217:   \"\",",
          "2218:   \"\",",
          "2219:   \"\",",
          "2220:   \"\",",
          "2221:   \"\",",
          "2222:   \"\",",
          "2223:   \"\",",
          "2224:   \"\",",
          "2225:   \"\",",
          "2226:   \"\",",
          "2227:   \"\",",
          "2228:   \"\",",
          "2229:   \"\",",
          "2230:   \"\",",
          "2231:   \"\",",
          "2233:   \"Malware\",",
          "2234:   \"Advertisement\",",
          "2235:   \"Banned_Site\",",
          "2236:   \"Site_Unavailable\",",
          "2237:   \"Allowed_Site\",",
          "2238:   \"Antimalware\",",
          "2243: struct ndpi_detection_module_struct *ndpi_init_detection_module(ndpi_init_prefs prefs) {",
          "2244:   struct ndpi_detection_module_struct *ndpi_str = ndpi_malloc(sizeof(struct ndpi_detection_module_struct));",
          "2245:   int i;",
          "2247:   if(ndpi_str == NULL) {",
          "2249:     NDPI_LOG_ERR(ndpi_str, \"ndpi_init_detection_module initial malloc failed for ndpi_str\\n\");",
          "2251:     return(NULL);",
          "2252:   }",
          "2254:   memset(ndpi_str, 0, sizeof(struct ndpi_detection_module_struct));",
          "2257:   set_ndpi_debug_function(ndpi_str, (ndpi_debug_function_ptr)ndpi_debug_printf);",
          "2260:   if((ndpi_str->protocols_ptree = ndpi_New_Patricia(32 /* IPv4 */)) != NULL)",
          "2261:     ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree,",
          "2262:     host_protocol_list,",
          "2263:     prefs & ndpi_dont_load_tor_hosts);",
          "2265:   NDPI_BITMASK_RESET(ndpi_str->detection_bitmask);",
          "2267:   ndpi_str->user_data = NULL;",
          "2271:   ndpi_str->tcp_max_retransmission_window_size = NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE;",
          "2272:   ndpi_str->directconnect_connection_ip_tick_timeout =",
          "2273:     NDPI_DIRECTCONNECT_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2275:   ndpi_str->rtsp_connection_timeout = NDPI_RTSP_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2276:   ndpi_str->tvants_connection_timeout = NDPI_TVANTS_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2277:   ndpi_str->irc_timeout = NDPI_IRC_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2278:   ndpi_str->gnutella_timeout = NDPI_GNUTELLA_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2280:   ndpi_str->battlefield_timeout = NDPI_BATTLEFIELD_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2282:   ndpi_str->thunder_timeout = NDPI_THUNDER_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2283:   ndpi_str->yahoo_detect_http_connections = NDPI_YAHOO_DETECT_HTTP_CONNECTIONS;",
          "2285:   ndpi_str->yahoo_lan_video_timeout = NDPI_YAHOO_LAN_VIDEO_TIMEOUT * ndpi_str->ticks_per_second;",
          "2286:   ndpi_str->zattoo_connection_timeout = NDPI_ZATTOO_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2287:   ndpi_str->jabber_stun_timeout = NDPI_JABBER_STUN_TIMEOUT * ndpi_str->ticks_per_second;",
          "2288:   ndpi_str->jabber_file_transfer_timeout = NDPI_JABBER_FT_TIMEOUT * ndpi_str->ticks_per_second;",
          "2289:   ndpi_str->soulseek_connection_ip_tick_timeout = NDPI_SOULSEEK_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2291:   ndpi_str->ndpi_num_supported_protocols = NDPI_MAX_SUPPORTED_PROTOCOLS;",
          "2292:   ndpi_str->ndpi_num_custom_protocols = 0;",
          "2294:   ndpi_str->host_automa.ac_automa               = ac_automata_init(ac_match_handler);",
          "2295:   ndpi_str->content_automa.ac_automa            = ac_automata_init(ac_match_handler);",
          "2296:   ndpi_str->bigrams_automa.ac_automa            = ac_automata_init(ac_match_handler);",
          "2297:   ndpi_str->impossible_bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2299:   if((sizeof(categories)/sizeof(char*)) != NDPI_PROTOCOL_NUM_CATEGORIES) {",
          "2300:     NDPI_LOG_ERR(ndpi_str, \"[NDPI] invalid categories length: expected %u, got %u\\n\",",
          "2301:    NDPI_PROTOCOL_NUM_CATEGORIES, (unsigned int)(sizeof(categories)/sizeof(char*)));",
          "2302:     return(NULL);",
          "2303:   }",
          "2306:   ndpi_str->custom_categories.num_to_load = 0, ndpi_str->custom_categories.to_load = NULL;",
          "2307:   ndpi_str->custom_categories.hostnames = NULL;",
          "2309:   ndpi_str->custom_categories.hostnames.ac_automa        = ac_automata_init(ac_match_handler);",
          "2310:   ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "2313:   ndpi_str->custom_categories.ipAddresses                = ndpi_New_Patricia(32 /* IPv4 */);",
          "2314:   ndpi_str->custom_categories.ipAddresses_shadow         = ndpi_New_Patricia(32 /* IPv4 */);",
          "2316:   if((ndpi_str->custom_categories.ipAddresses == NULL)",
          "2317:      || (ndpi_str->custom_categories.ipAddresses_shadow == NULL))",
          "2318:     return(NULL);",
          "2320:   ndpi_init_protocol_defaults(ndpi_str);",
          "2322:   for(i=0; i<NUM_CUSTOM_CATEGORIES; i++)",
          "2323:     snprintf(ndpi_str->custom_category_labels[i],",
          "2324:       CUSTOM_CATEGORY_LABEL_LEN, \"User custom category %u\", (unsigned int)(i+1));",
          "2326:   return(ndpi_str);",
          "2331: void ndpi_finalize_initalization(struct ndpi_detection_module_struct *ndpi_str) {",
          "2332:   u_int i;",
          "2334:   for(i=0; i<4; i++) {",
          "2335:     ndpi_automa *automa;",
          "2337:     switch(i) {",
          "2338:     case 0:",
          "2339:       automa = &ndpi_str->host_automa;",
          "2340:       break;",
          "2342:     case 1:",
          "2343:       automa = &ndpi_str->content_automa;",
          "2344:       break;",
          "2346:     case 2:",
          "2347:       automa = &ndpi_str->bigrams_automa;",
          "2348:       break;",
          "2350:     case 3:",
          "2351:       automa = &ndpi_str->impossible_bigrams_automa;",
          "2352:       break;",
          "2354:     default:",
          "2355:         automa = NULL;",
          "2356:         break;",
          "2357:     }",
          "2359:     if (automa) {",
          "2360:         ac_automata_finalize((AC_AUTOMATA_t*)automa->ac_automa);",
          "2361:         automa->ac_automa_finalized = 1;",
          "2363:   }",
          "2369: void* ndpi_init_automa(void) {",
          "2370:   return(ac_automata_init(ac_match_handler));",
          "2373: int ndpi_add_string_value_to_automa(void *_automa, char *str, unsigned long num) {",
          "2374:   AC_PATTERN_t ac_pattern;",
          "2375:   AC_AUTOMATA_t *automa = (AC_AUTOMATA_t*)_automa;",
          "2376:   AC_ERROR_t rc;",
          "2378:   if(automa == NULL) return(-1);",
          "2380:   memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "2381:   ac_pattern.astring = str;",
          "2382:   ac_pattern.rep.number = num;",
          "2383:   ac_pattern.length = strlen(ac_pattern.astring);",
          "2385:   rc = ac_automata_add(automa, &ac_pattern);",
          "2386:   return(rc == ACERR_SUCCESS || rc == ACERR_DUPLICATE_PATTERN ? 0 : -1);",
          "2389: int ndpi_add_string_to_automa(void *_automa, char *str) {",
          "2390:   return(ndpi_add_string_value_to_automa(_automa, str, 1));",
          "2393: void ndpi_free_automa(void *_automa)     { ac_automata_release((AC_AUTOMATA_t*)_automa, 0);  }",
          "2394: void ndpi_finalize_automa(void *_automa) { ac_automata_finalize((AC_AUTOMATA_t*)_automa); }",
          "2398: int ndpi_match_string(void *_automa, char *string_to_match) {",
          "2399:   AC_REP_t match = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };",
          "2400:   AC_TEXT_t ac_input_text;",
          "2401:   AC_AUTOMATA_t *automa = (AC_AUTOMATA_t*)_automa;",
          "2402:   int rc;",
          "2404:   if((automa == NULL)",
          "2405:      || (string_to_match == NULL)",
          "2406:      || (string_to_match[0] == '\\0'))",
          "2407:     return(-2);",
          "2409:   ac_input_text.astring = string_to_match, ac_input_text.length = strlen(string_to_match);",
          "2410:   rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2417:   if((rc == 0) && (match.number != 0)) rc = 1;",
          "2419:   return(rc ? match.number : 0);",
          "2424: int ndpi_match_string_id(void *_automa, char *string_to_match, u_int match_len, unsigned long *id) {",
          "2425:   AC_TEXT_t ac_input_text;",
          "2426:   AC_AUTOMATA_t *automa = (AC_AUTOMATA_t*)_automa;",
          "2427:   AC_REP_t match = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };",
          "2428:   int rc;",
          "2431:   if((automa == NULL)",
          "2432:      || (string_to_match == NULL)",
          "2433:      || (string_to_match[0] == '\\0'))",
          "2434:     return(-2);",
          "2436:   ac_input_text.astring = string_to_match, ac_input_text.length = match_len;",
          "2437:   rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2444:   if((rc == 0) && (match.number != 0)) rc = 1;",
          "2448:   return(*id != NDPI_PROTOCOL_UNKNOWN ? 0 : -1);",
          "2455: static int hyperscanCustomEventHandler(unsigned int id,",
          "2456:            unsigned long long from,",
          "2457:            unsigned long long to,",
          "2458:            unsigned int flags, void *ctx) {",
          "2462:   printf(\"[HS] Found category %u\\n\", id);",
          "2465:   return(HS_SCAN_TERMINATED);",
          "2471: int ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_str,",
          "2472:           char *name, u_int name_len, unsigned long *id) {",
          "2474:   if(ndpi_str->custom_categories.hostnames == NULL)",
          "2475:     return(-1);",
          "2476:   else {",
          "2477:     hs_error_t rc;",
          "2481:     rc = hs_scan(ndpi_str->custom_categories.hostnames->database,",
          "2482:    name, name_len, 0,",
          "2483:    ndpi_str->custom_categories.hostnames->scratch,",
          "2484:    hyperscanCustomEventHandler, id);",
          "2486:     if(rc == HS_SCAN_TERMINATED) {",
          "2488:       printf(\"[HS] Found category %lu for %s\\n\", *id, name);",
          "2490:       return(0);",
          "2491:     } else",
          "2492:       return(-1);",
          "2493:   }",
          "2495:   return(ndpi_match_string_id(ndpi_str->custom_categories.hostnames.ac_automa, name, name_len, id));",
          "2501: int ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_str,",
          "2502:        char *name_or_ip, u_int name_len, unsigned long *id) {",
          "2503:   char ipbuf[64], *ptr;",
          "2504:   struct in_addr pin;",
          "2505:   u_int cp_len = ndpi_min(sizeof(ipbuf)-1, name_len);",
          "2507:   if(!ndpi_str->custom_categories.categories_loaded)",
          "2508:     return(-1);",
          "2510:   if(cp_len > 0) {",
          "2511:     memcpy(ipbuf, name_or_ip, cp_len);",
          "2512:     ipbuf[cp_len] = '\\0';",
          "2513:   } else",
          "2514:     ipbuf[0] = '\\0';",
          "2516:   ptr = strrchr(ipbuf, '/');",
          "2518:   if(ptr)",
          "2519:     ptr[0] = '\\0';",
          "2521:   if(inet_pton(AF_INET, ipbuf, &pin) == 1) {",
          "2523:     prefix_t prefix;",
          "2524:     patricia_node_t *node;",
          "2527:     fill_prefix_v4(&prefix, &pin, 32, ((patricia_tree_t*)ndpi_str->protocols_ptree)->maxbits);",
          "2528:     node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "2530:     if(node) {",
          "2532:       return(0);",
          "2533:     }",
          "2535:     return(-1);",
          "2536:   } else",
          "2538:     return(ndpi_match_custom_category(ndpi_str, name_or_ip, name_len, id));",
          "2543: static void free_ptree_data(void *data) { ; }",
          "2547: void ndpi_exit_detection_module(struct ndpi_detection_module_struct *ndpi_str) {",
          "2548:   if(ndpi_str != NULL) {",
          "2549:     int i;",
          "2551:     for(i=0; i<(NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS); i++) {",
          "2552:       if(ndpi_str->proto_defaults[i].protoName)",
          "2553:  ndpi_free(ndpi_str->proto_defaults[i].protoName);",
          "2554:     }",
          "2557:     if(ndpi_str->tinc_cache)",
          "2558:       cache_free((cache_t)(ndpi_str->tinc_cache));",
          "2560:     if(ndpi_str->ookla_cache)",
          "2561:       ndpi_lru_free_cache(ndpi_str->ookla_cache);",
          "2563:     if(ndpi_str->stun_cache)",
          "2564:       ndpi_lru_free_cache(ndpi_str->stun_cache);",
          "2566:     if(ndpi_str->protocols_ptree)",
          "2567:       ndpi_Destroy_Patricia((patricia_tree_t*)ndpi_str->protocols_ptree, free_ptree_data);",
          "2569:     if(ndpi_str->udpRoot != NULL)",
          "2570:       ndpi_tdestroy(ndpi_str->udpRoot, ndpi_free);",
          "2571:     if(ndpi_str->tcpRoot != NULL)",
          "2572:       ndpi_tdestroy(ndpi_str->tcpRoot, ndpi_free);",
          "2574:     if(ndpi_str->host_automa.ac_automa != NULL)",
          "2575:       ac_automata_release((AC_AUTOMATA_t*)ndpi_str->host_automa.ac_automa, 1 /* free patterns strings memory */);",
          "2577:     if(ndpi_str->content_automa.ac_automa != NULL)",
          "2578:       ac_automata_release((AC_AUTOMATA_t*)ndpi_str->content_automa.ac_automa, 0);",
          "2580:     if(ndpi_str->bigrams_automa.ac_automa != NULL)",
          "2581:       ac_automata_release((AC_AUTOMATA_t*)ndpi_str->bigrams_automa.ac_automa, 0);",
          "2583:     if(ndpi_str->impossible_bigrams_automa.ac_automa != NULL)",
          "2584:       ac_automata_release((AC_AUTOMATA_t*)ndpi_str->impossible_bigrams_automa.ac_automa, 0);",
          "2587:     destroy_hyperscan(ndpi_str);",
          "2589:     while(ndpi_str->custom_categories.to_load != NULL) {",
          "2590:       struct hs_list *next = ndpi_str->custom_categories.to_load->next;",
          "2592:       ndpi_free(ndpi_str->custom_categories.to_load->expression);",
          "2593:       ndpi_free(ndpi_str->custom_categories.to_load);",
          "2594:       ndpi_str->custom_categories.to_load = next;",
          "2595:     }",
          "2597:     free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "2599:     if(ndpi_str->custom_categories.hostnames.ac_automa != NULL)",
          "2600:       ac_automata_release((AC_AUTOMATA_t*)ndpi_str->custom_categories.hostnames.ac_automa, 1 /* free patterns strings memory */);",
          "2602:     if(ndpi_str->custom_categories.hostnames_shadow.ac_automa != NULL)",
          "2603:       ac_automata_release((AC_AUTOMATA_t*)ndpi_str->custom_categories.hostnames_shadow.ac_automa, 1 /* free patterns strings memory */);",
          "2606:     if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "2607:       ndpi_Destroy_Patricia((patricia_tree_t*)ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "2609:     if(ndpi_str->custom_categories.ipAddresses_shadow != NULL)",
          "2610:       ndpi_Destroy_Patricia((patricia_tree_t*)ndpi_str->custom_categories.ipAddresses_shadow, free_ptree_data);",
          "2612:     ndpi_free(ndpi_str);",
          "2613:   }",
          "2618: int ndpi_get_protocol_id_master_proto(struct ndpi_detection_module_struct *ndpi_str,",
          "2619:           u_int16_t protocol_id,",
          "2620:           u_int16_t** tcp_master_proto,",
          "2621:           u_int16_t** udp_master_proto) {",
          "2622:   if(protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) {",
          "2625:     return(-1);",
          "2626:   }",
          "2631:   return(0);",
          "2636: static ndpi_default_ports_tree_node_t* ndpi_get_guessed_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "2637:             u_int8_t proto, u_int16_t sport, u_int16_t dport) {",
          "2638:   ndpi_default_ports_tree_node_t node;",
          "2640:   if(sport && dport) {",
          "2641:     int low  = ndpi_min(sport, dport);",
          "2642:     int high = ndpi_max(sport, dport);",
          "2643:     const void *ret;",
          "2646:     ret = ndpi_tfind(&node,",
          "2647:        (proto == IPPROTO_TCP) ? (void*)&ndpi_str->tcpRoot : (void*)&ndpi_str->udpRoot,",
          "2648:        ndpi_default_ports_tree_node_t_cmp);",
          "2650:     if(ret == NULL) {",
          "2651:       node.default_port = high;",
          "2652:       ret = ndpi_tfind(&node,",
          "2653:          (proto == IPPROTO_TCP) ? (void*)&ndpi_str->tcpRoot : (void*)&ndpi_str->udpRoot,",
          "2654:          ndpi_default_ports_tree_node_t_cmp);",
          "2657:     if(ret) return(*(ndpi_default_ports_tree_node_t**)ret);",
          "2658:   }",
          "2660:   return(NULL);",
          "",
          "[Added Lines]",
          "1820: int ndpi_load_ipv4_ptree(struct ndpi_detection_module_struct *ndpi_str, const char *path, u_int16_t protocol_id)",
          "1821: {",
          "1822:     char buffer[128], *line, *addr, *cidr, *saveptr;",
          "1823:     FILE *fd;",
          "1824:     int len;",
          "1825:     u_int num_loaded = 0;",
          "1827:     fd = fopen(path, \"r\");",
          "1829:     if (fd == NULL) {",
          "1830:         NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "1831:         return (-1);",
          "1832:     }",
          "1834:     while (1) {",
          "1835:         line = fgets(buffer, sizeof(buffer), fd);",
          "1837:         if (line == NULL)",
          "1838:             break;",
          "1840:         len = strlen(line);",
          "1842:         if ((len <= 1) || (line[0] == '#'))",
          "1843:             continue;",
          "1845:         line[len - 1] = '\\0';",
          "1846:         addr = strtok_r(line, \"/\", &saveptr);",
          "1848:         if (addr) {",
          "1849:             struct in_addr pin;",
          "1850:             patricia_node_t *node;",
          "1852:             cidr = strtok_r(NULL, \"\\n\", &saveptr);",
          "1854:             pin.s_addr = inet_addr(addr);",
          "1855:             if ((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, cidr ? atoi(cidr) : 32 /* bits */)) !=",
          "1856:                 NULL)",
          "1857:                 node->value.user_value = protocol_id, num_loaded++;",
          "1858:         }",
          "1861:     fclose(fd);",
          "1862:     return (num_loaded);",
          "1867: static void ndpi_init_ptree_ipv4(struct ndpi_detection_module_struct *ndpi_str, void *ptree, ndpi_network host_list[],",
          "1868:                                  u_int8_t skip_tor_hosts)",
          "1869: {",
          "1870:     int i;",
          "1872:     for (i = 0; host_list[i].network != 0x0; i++) {",
          "1873:         struct in_addr pin;",
          "1874:         patricia_node_t *node;",
          "1876:         if (skip_tor_hosts && (host_list[i].value == NDPI_PROTOCOL_TOR))",
          "1877:             continue;",
          "1879:         pin.s_addr = htonl(host_list[i].network);",
          "1880:         if ((node = add_to_ptree(ptree, AF_INET, &pin, host_list[i].cidr /* bits */)) != NULL)",
          "1881:             node->value.user_value = host_list[i].value;",
          "1882:     }",
          "1887: static int ndpi_add_host_ip_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *value, int protocol_id)",
          "1888: {",
          "1889:     patricia_node_t *node;",
          "1890:     struct in_addr pin;",
          "1891:     int bits = 32;",
          "1892:     char *ptr = strrchr(value, '/');",
          "1894:     if (ptr) {",
          "1895:         ptr[0] = '\\0';",
          "1896:         ptr++;",
          "1897:         if (atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "1898:             bits = atoi(ptr);",
          "1899:     }",
          "1901:     inet_pton(AF_INET, value, &pin);",
          "1903:     if ((node = add_to_ptree(ndpi_str->protocols_ptree, AF_INET, &pin, bits)) != NULL)",
          "1904:         node->value.user_value = protocol_id;",
          "1906:     return (0);",
          "1909: void set_ndpi_malloc(void *(*__ndpi_malloc)(size_t size))",
          "1910: {",
          "1911:     _ndpi_malloc = __ndpi_malloc;",
          "1912: }",
          "1913: void set_ndpi_flow_malloc(void *(*__ndpi_flow_malloc)(size_t size))",
          "1914: {",
          "1915:     _ndpi_flow_malloc = __ndpi_flow_malloc;",
          "1916: }",
          "1918: void set_ndpi_free(void (*__ndpi_free)(void *ptr))",
          "1919: {",
          "1920:     _ndpi_free = __ndpi_free;",
          "1921: }",
          "1922: void set_ndpi_flow_free(void (*__ndpi_flow_free)(void *ptr))",
          "1923: {",
          "1924:     _ndpi_flow_free = __ndpi_flow_free;",
          "1925: }",
          "1927: void ndpi_debug_printf(unsigned int proto, struct ndpi_detection_module_struct *ndpi_str, ndpi_log_level_t log_level,",
          "1928:                        const char *file_name, const char *func_name, int line_number, const char *format, ...)",
          "1931:     va_list args;",
          "1933:     char str[MAX_STR_LEN];",
          "1934:     if (ndpi_str != NULL && log_level > NDPI_LOG_ERROR && proto > 0 && proto < NDPI_MAX_SUPPORTED_PROTOCOLS &&",
          "1935:         !NDPI_ISSET(&ndpi_str->debug_bitmask, proto))",
          "1936:         return;",
          "1937:     va_start(args, format);",
          "1938:     vsnprintf(str, sizeof(str) - 1, format, args);",
          "1939:     va_end(args);",
          "1941:     if (ndpi_str != NULL) {",
          "1942:         printf(\"%s:%s:%-3d - [%s]: %s\", file_name, func_name, line_number, ndpi_get_proto_name(ndpi_str, proto), str);",
          "1943:     } else {",
          "1944:         printf(\"Proto: %u, %s\", proto, str);",
          "1945:     }",
          "1949: void set_ndpi_debug_function(struct ndpi_detection_module_struct *ndpi_str, ndpi_debug_function_ptr ndpi_debug_printf)",
          "1950: {",
          "1952:     ndpi_str->ndpi_debug_printf = ndpi_debug_printf;",
          "1959: static const char *categories[] = {",
          "1960:     \"Unspecified\",",
          "1961:     \"Media\",",
          "1962:     \"VPN\",",
          "1963:     \"Email\",",
          "1964:     \"DataTransfer\",",
          "1965:     \"Web\",",
          "1966:     \"SocialNetwork\",",
          "1967:     \"Download-FileTransfer-FileSharing\",",
          "1968:     \"Game\",",
          "1969:     \"Chat\",",
          "1970:     \"VoIP\",",
          "1971:     \"Database\",",
          "1972:     \"RemoteAccess\",",
          "1973:     \"Cloud\",",
          "1974:     \"Network\",",
          "1975:     \"Collaborative\",",
          "1976:     \"RPC\",",
          "1977:     \"Streaming\",",
          "1978:     \"System\",",
          "1979:     \"SoftwareUpdate\",",
          "1980:     \"\",",
          "1981:     \"\",",
          "1982:     \"\",",
          "1983:     \"\",",
          "1984:     \"\",",
          "1985:     \"Music\",",
          "1986:     \"Video\",",
          "1987:     \"Shopping\",",
          "1988:     \"Productivity\",",
          "1989:     \"FileSharing\",",
          "1990:     \"\",",
          "1991:     \"\",",
          "1992:     \"\",",
          "1993:     \"\",",
          "1994:     \"\",",
          "1995:     \"\",",
          "1996:     \"\",",
          "1997:     \"\",",
          "1998:     \"\",",
          "1999:     \"\",",
          "2000:     \"\",",
          "2001:     \"\",",
          "2002:     \"\",",
          "2003:     \"\",",
          "2004:     \"\",",
          "2005:     \"\",",
          "2006:     \"\",",
          "2007:     \"\",",
          "2008:     \"\",",
          "2009:     \"\",",
          "2010:     \"\",",
          "2011:     \"\",",
          "2012:     \"\",",
          "2013:     \"\",",
          "2014:     \"\",",
          "2015:     \"\",",
          "2016:     \"\",",
          "2017:     \"\",",
          "2018:     \"\",",
          "2019:     \"\",",
          "2020:     \"\",",
          "2021:     \"\",",
          "2022:     \"\",",
          "2023:     \"\",",
          "2024:     \"\",",
          "2025:     \"\",",
          "2026:     \"\",",
          "2027:     \"\",",
          "2028:     \"\",",
          "2029:     \"\",",
          "2030:     \"\",",
          "2031:     \"\",",
          "2032:     \"\",",
          "2033:     \"\",",
          "2034:     \"\",",
          "2035:     \"\",",
          "2036:     \"\",",
          "2037:     \"\",",
          "2038:     \"\",",
          "2039:     \"\",",
          "2040:     \"\",",
          "2041:     \"\",",
          "2042:     \"\",",
          "2043:     \"\",",
          "2044:     \"\",",
          "2045:     \"\",",
          "2046:     \"\",",
          "2047:     \"\",",
          "2048:     \"\",",
          "2049:     \"\",",
          "2050:     \"\",",
          "2051:     \"\",",
          "2052:     \"\",",
          "2053:     \"\",",
          "2054:     \"\",",
          "2055:     \"\",",
          "2056:     \"\",",
          "2057:     \"\",",
          "2058:     \"\",",
          "2060:     \"Malware\",",
          "2061:     \"Advertisement\",",
          "2062:     \"Banned_Site\",",
          "2063:     \"Site_Unavailable\",",
          "2064:     \"Allowed_Site\",",
          "2065:     \"Antimalware\",",
          "2070: struct ndpi_detection_module_struct *ndpi_init_detection_module(ndpi_init_prefs prefs)",
          "2071: {",
          "2072:     struct ndpi_detection_module_struct *ndpi_str = ndpi_malloc(sizeof(struct ndpi_detection_module_struct));",
          "2073:     int i;",
          "2075:     if (ndpi_str == NULL) {",
          "2077:         NDPI_LOG_ERR(ndpi_str, \"ndpi_init_detection_module initial malloc failed for ndpi_str\\n\");",
          "2079:         return (NULL);",
          "2080:     }",
          "2082:     memset(ndpi_str, 0, sizeof(struct ndpi_detection_module_struct));",
          "2085:     set_ndpi_debug_function(ndpi_str, (ndpi_debug_function_ptr) ndpi_debug_printf);",
          "2088:     if ((ndpi_str->protocols_ptree = ndpi_New_Patricia(32 /* IPv4 */)) != NULL)",
          "2089:         ndpi_init_ptree_ipv4(ndpi_str, ndpi_str->protocols_ptree, host_protocol_list, prefs & ndpi_dont_load_tor_hosts);",
          "2091:     NDPI_BITMASK_RESET(ndpi_str->detection_bitmask);",
          "2093:     ndpi_str->user_data = NULL;",
          "2097:     ndpi_str->tcp_max_retransmission_window_size = NDPI_DEFAULT_MAX_TCP_RETRANSMISSION_WINDOW_SIZE;",
          "2098:     ndpi_str->directconnect_connection_ip_tick_timeout =",
          "2099:         NDPI_DIRECTCONNECT_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2101:     ndpi_str->rtsp_connection_timeout = NDPI_RTSP_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2102:     ndpi_str->tvants_connection_timeout = NDPI_TVANTS_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2103:     ndpi_str->irc_timeout = NDPI_IRC_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2104:     ndpi_str->gnutella_timeout = NDPI_GNUTELLA_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2106:     ndpi_str->battlefield_timeout = NDPI_BATTLEFIELD_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2108:     ndpi_str->thunder_timeout = NDPI_THUNDER_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2109:     ndpi_str->yahoo_detect_http_connections = NDPI_YAHOO_DETECT_HTTP_CONNECTIONS;",
          "2111:     ndpi_str->yahoo_lan_video_timeout = NDPI_YAHOO_LAN_VIDEO_TIMEOUT * ndpi_str->ticks_per_second;",
          "2112:     ndpi_str->zattoo_connection_timeout = NDPI_ZATTOO_CONNECTION_TIMEOUT * ndpi_str->ticks_per_second;",
          "2113:     ndpi_str->jabber_stun_timeout = NDPI_JABBER_STUN_TIMEOUT * ndpi_str->ticks_per_second;",
          "2114:     ndpi_str->jabber_file_transfer_timeout = NDPI_JABBER_FT_TIMEOUT * ndpi_str->ticks_per_second;",
          "2115:     ndpi_str->soulseek_connection_ip_tick_timeout =",
          "2116:         NDPI_SOULSEEK_CONNECTION_IP_TICK_TIMEOUT * ndpi_str->ticks_per_second;",
          "2118:     ndpi_str->ndpi_num_supported_protocols = NDPI_MAX_SUPPORTED_PROTOCOLS;",
          "2119:     ndpi_str->ndpi_num_custom_protocols = 0;",
          "2121:     ndpi_str->host_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2122:     ndpi_str->content_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2123:     ndpi_str->bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2124:     ndpi_str->impossible_bigrams_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "2126:     if ((sizeof(categories) / sizeof(char *)) != NDPI_PROTOCOL_NUM_CATEGORIES) {",
          "2127:         NDPI_LOG_ERR(ndpi_str, \"[NDPI] invalid categories length: expected %u, got %u\\n\", NDPI_PROTOCOL_NUM_CATEGORIES,",
          "2128:                      (unsigned int) (sizeof(categories) / sizeof(char *)));",
          "2129:         return (NULL);",
          "2130:     }",
          "2133:     ndpi_str->custom_categories.num_to_load = 0, ndpi_str->custom_categories.to_load = NULL;",
          "2134:     ndpi_str->custom_categories.hostnames = NULL;",
          "2136:     ndpi_str->custom_categories.hostnames.ac_automa = ac_automata_init(ac_match_handler);",
          "2137:     ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "2140:     ndpi_str->custom_categories.ipAddresses = ndpi_New_Patricia(32 /* IPv4 */);",
          "2141:     ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "2143:     if ((ndpi_str->custom_categories.ipAddresses == NULL) || (ndpi_str->custom_categories.ipAddresses_shadow == NULL))",
          "2144:         return (NULL);",
          "2146:     ndpi_init_protocol_defaults(ndpi_str);",
          "2148:     for (i = 0; i < NUM_CUSTOM_CATEGORIES; i++)",
          "2149:         snprintf(ndpi_str->custom_category_labels[i], CUSTOM_CATEGORY_LABEL_LEN, \"User custom category %u\",",
          "2150:                  (unsigned int) (i + 1));",
          "2152:     return (ndpi_str);",
          "2157: void ndpi_finalize_initalization(struct ndpi_detection_module_struct *ndpi_str)",
          "2158: {",
          "2159:     u_int i;",
          "2161:     for (i = 0; i < 4; i++) {",
          "2162:         ndpi_automa *automa;",
          "2164:         switch (i) {",
          "2165:             case 0:",
          "2166:                 automa = &ndpi_str->host_automa;",
          "2167:                 break;",
          "2169:             case 1:",
          "2170:                 automa = &ndpi_str->content_automa;",
          "2171:                 break;",
          "2173:             case 2:",
          "2174:                 automa = &ndpi_str->bigrams_automa;",
          "2175:                 break;",
          "2177:             case 3:",
          "2178:                 automa = &ndpi_str->impossible_bigrams_automa;",
          "2179:                 break;",
          "2181:             default:",
          "2182:                 automa = NULL;",
          "2183:                 break;",
          "2184:         }",
          "2186:         if (automa) {",
          "2187:             ac_automata_finalize((AC_AUTOMATA_t *) automa->ac_automa);",
          "2188:             automa->ac_automa_finalized = 1;",
          "2189:         }",
          "2196: void *ndpi_init_automa(void)",
          "2197: {",
          "2198:     return (ac_automata_init(ac_match_handler));",
          "2201: int ndpi_add_string_value_to_automa(void *_automa, char *str, unsigned long num)",
          "2202: {",
          "2203:     AC_PATTERN_t ac_pattern;",
          "2204:     AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2205:     AC_ERROR_t rc;",
          "2207:     if (automa == NULL)",
          "2208:         return (-1);",
          "2210:     memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "2211:     ac_pattern.astring = str;",
          "2212:     ac_pattern.rep.number = num;",
          "2213:     ac_pattern.length = strlen(ac_pattern.astring);",
          "2215:     rc = ac_automata_add(automa, &ac_pattern);",
          "2216:     return (rc == ACERR_SUCCESS || rc == ACERR_DUPLICATE_PATTERN ? 0 : -1);",
          "2219: int ndpi_add_string_to_automa(void *_automa, char *str)",
          "2220: {",
          "2221:     return (ndpi_add_string_value_to_automa(_automa, str, 1));",
          "2224: void ndpi_free_automa(void *_automa)",
          "2225: {",
          "2226:     ac_automata_release((AC_AUTOMATA_t *) _automa, 0);",
          "2227: }",
          "2228: void ndpi_finalize_automa(void *_automa)",
          "2229: {",
          "2230:     ac_automata_finalize((AC_AUTOMATA_t *) _automa);",
          "2231: }",
          "2235: int ndpi_match_string(void *_automa, char *string_to_match)",
          "2236: {",
          "2237:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "2238:     AC_TEXT_t ac_input_text;",
          "2239:     AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2240:     int rc;",
          "2242:     if ((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))",
          "2243:         return (-2);",
          "2245:     ac_input_text.astring = string_to_match, ac_input_text.length = strlen(string_to_match);",
          "2246:     rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2253:     if ((rc == 0) && (match.number != 0))",
          "2254:         rc = 1;",
          "2256:     return (rc ? match.number : 0);",
          "2261: int ndpi_match_string_id(void *_automa, char *string_to_match, u_int match_len, unsigned long *id)",
          "2262: {",
          "2263:     AC_TEXT_t ac_input_text;",
          "2264:     AC_AUTOMATA_t *automa = (AC_AUTOMATA_t *) _automa;",
          "2265:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "2266:     int rc;",
          "2269:     if ((automa == NULL) || (string_to_match == NULL) || (string_to_match[0] == '\\0'))",
          "2270:         return (-2);",
          "2272:     ac_input_text.astring = string_to_match, ac_input_text.length = match_len;",
          "2273:     rc = ac_automata_search(automa, &ac_input_text, &match);",
          "2280:     if ((rc == 0) && (match.number != 0))",
          "2281:         rc = 1;",
          "2285:     return (*id != NDPI_PROTOCOL_UNKNOWN ? 0 : -1);",
          "2292: static int hyperscanCustomEventHandler(unsigned int id, unsigned long long from, unsigned long long to,",
          "2293:                                        unsigned int flags, void *ctx)",
          "2294: {",
          "2298:     printf(\"[HS] Found category %u\\n\", id);",
          "2301:     return (HS_SCAN_TERMINATED);",
          "2307: int ndpi_match_custom_category(struct ndpi_detection_module_struct *ndpi_str, char *name, u_int name_len,",
          "2308:                                unsigned long *id)",
          "2309: {",
          "2311:     if (ndpi_str->custom_categories.hostnames == NULL)",
          "2312:         return (-1);",
          "2313:     else {",
          "2314:         hs_error_t rc;",
          "2318:         rc = hs_scan(ndpi_str->custom_categories.hostnames->database, name, name_len, 0,",
          "2319:                      ndpi_str->custom_categories.hostnames->scratch, hyperscanCustomEventHandler, id);",
          "2321:         if (rc == HS_SCAN_TERMINATED) {",
          "2323:             printf(\"[HS] Found category %lu for %s\\n\", *id, name);",
          "2325:             return (0);",
          "2326:         } else",
          "2327:             return (-1);",
          "2328:     }",
          "2330:     return (ndpi_match_string_id(ndpi_str->custom_categories.hostnames.ac_automa, name, name_len, id));",
          "2336: int ndpi_get_custom_category_match(struct ndpi_detection_module_struct *ndpi_str, char *name_or_ip, u_int name_len,",
          "2337:                                    unsigned long *id)",
          "2338: {",
          "2339:     char ipbuf[64], *ptr;",
          "2340:     struct in_addr pin;",
          "2341:     u_int cp_len = ndpi_min(sizeof(ipbuf) - 1, name_len);",
          "2343:     if (!ndpi_str->custom_categories.categories_loaded)",
          "2344:         return (-1);",
          "2346:     if (cp_len > 0) {",
          "2347:         memcpy(ipbuf, name_or_ip, cp_len);",
          "2348:         ipbuf[cp_len] = '\\0';",
          "2349:     } else",
          "2350:         ipbuf[0] = '\\0';",
          "2352:     ptr = strrchr(ipbuf, '/');",
          "2354:     if (ptr)",
          "2355:         ptr[0] = '\\0';",
          "2357:     if (inet_pton(AF_INET, ipbuf, &pin) == 1) {",
          "2359:         prefix_t prefix;",
          "2360:         patricia_node_t *node;",
          "2363:         fill_prefix_v4(&prefix, &pin, 32, ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "2364:         node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "2366:         if (node) {",
          "2368:             return (0);",
          "2369:         }",
          "2371:         return (-1);",
          "2372:     } else",
          "2374:         return (ndpi_match_custom_category(ndpi_str, name_or_ip, name_len, id));",
          "2379: static void free_ptree_data(void *data)",
          "2380: {",
          "2381:     ;",
          "2382: }",
          "2386: void ndpi_exit_detection_module(struct ndpi_detection_module_struct *ndpi_str)",
          "2387: {",
          "2388:     if (ndpi_str != NULL) {",
          "2389:         int i;",
          "2391:         for (i = 0; i < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS); i++) {",
          "2392:             if (ndpi_str->proto_defaults[i].protoName)",
          "2393:                 ndpi_free(ndpi_str->proto_defaults[i].protoName);",
          "2394:         }",
          "2397:         if (ndpi_str->tinc_cache)",
          "2398:             cache_free((cache_t)(ndpi_str->tinc_cache));",
          "2400:         if (ndpi_str->ookla_cache)",
          "2401:             ndpi_lru_free_cache(ndpi_str->ookla_cache);",
          "2403:         if (ndpi_str->stun_cache)",
          "2404:             ndpi_lru_free_cache(ndpi_str->stun_cache);",
          "2406:         if (ndpi_str->protocols_ptree)",
          "2407:             ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->protocols_ptree, free_ptree_data);",
          "2409:         if (ndpi_str->udpRoot != NULL)",
          "2410:             ndpi_tdestroy(ndpi_str->udpRoot, ndpi_free);",
          "2411:         if (ndpi_str->tcpRoot != NULL)",
          "2412:             ndpi_tdestroy(ndpi_str->tcpRoot, ndpi_free);",
          "2414:         if (ndpi_str->host_automa.ac_automa != NULL)",
          "2415:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->host_automa.ac_automa,",
          "2416:                                 1 /* free patterns strings memory */);",
          "2418:         if (ndpi_str->content_automa.ac_automa != NULL)",
          "2419:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->content_automa.ac_automa, 0);",
          "2421:         if (ndpi_str->bigrams_automa.ac_automa != NULL)",
          "2422:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->bigrams_automa.ac_automa, 0);",
          "2424:         if (ndpi_str->impossible_bigrams_automa.ac_automa != NULL)",
          "2425:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->impossible_bigrams_automa.ac_automa, 0);",
          "2428:         destroy_hyperscan(ndpi_str);",
          "2430:         while (ndpi_str->custom_categories.to_load != NULL) {",
          "2431:             struct hs_list *next = ndpi_str->custom_categories.to_load->next;",
          "2433:             ndpi_free(ndpi_str->custom_categories.to_load->expression);",
          "2434:             ndpi_free(ndpi_str->custom_categories.to_load);",
          "2435:             ndpi_str->custom_categories.to_load = next;",
          "2436:         }",
          "2438:         free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "2440:         if (ndpi_str->custom_categories.hostnames.ac_automa != NULL)",
          "2441:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "2442:                                 1 /* free patterns strings memory */);",
          "2444:         if (ndpi_str->custom_categories.hostnames_shadow.ac_automa != NULL)",
          "2445:             ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa,",
          "2446:                                 1 /* free patterns strings memory */);",
          "2449:         if (ndpi_str->custom_categories.ipAddresses != NULL)",
          "2450:             ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "2452:         if (ndpi_str->custom_categories.ipAddresses_shadow != NULL)",
          "2453:             ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses_shadow, free_ptree_data);",
          "2455:         ndpi_free(ndpi_str);",
          "2456:     }",
          "2461: int ndpi_get_protocol_id_master_proto(struct ndpi_detection_module_struct *ndpi_str, u_int16_t protocol_id,",
          "2462:                                       u_int16_t **tcp_master_proto, u_int16_t **udp_master_proto)",
          "2463: {",
          "2464:     if (protocol_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) {",
          "2467:         return (-1);",
          "2468:     }",
          "2473:     return (0);",
          "2478: static ndpi_default_ports_tree_node_t *ndpi_get_guessed_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "2479:                                                                     u_int8_t proto, u_int16_t sport, u_int16_t dport)",
          "2480: {",
          "2481:     ndpi_default_ports_tree_node_t node;",
          "2483:     if (sport && dport) {",
          "2484:         int low = ndpi_min(sport, dport);",
          "2485:         int high = ndpi_max(sport, dport);",
          "2486:         const void *ret;",
          "2489:         ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,",
          "2490:                          ndpi_default_ports_tree_node_t_cmp);",
          "2492:         if (ret == NULL) {",
          "2493:             node.default_port = high;",
          "2494:             ret = ndpi_tfind(&node, (proto == IPPROTO_TCP) ? (void *) &ndpi_str->tcpRoot : (void *) &ndpi_str->udpRoot,",
          "2495:                              ndpi_default_ports_tree_node_t_cmp);",
          "2496:         }",
          "2498:         if (ret)",
          "2499:             return (*(ndpi_default_ports_tree_node_t **) ret);",
          "2502:     return (NULL);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2667:   and thus that if have NOT been detected they cannot be guessed",
          "2668:   as they have been excluded",
          "2680: }",
          "2747: }",
          "2753: }",
          "2757: #ifdef WIN32",
          "2759: {",
          "2767: }",
          "2768: #endif",
          "2878:     }",
          "2882: }",
          "",
          "[Removed Lines]",
          "2670: u_int8_t is_udp_guessable_protocol(u_int16_t l7_guessed_proto) {",
          "2671:   switch(l7_guessed_proto) {",
          "2672:   case NDPI_PROTOCOL_QUIC:",
          "2673:   case NDPI_PROTOCOL_SNMP:",
          "2674:   case NDPI_PROTOCOL_NETFLOW:",
          "2676:     return(1);",
          "2677:   }",
          "2679:   return(0);",
          "2684: u_int16_t ndpi_guess_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "2685:      struct ndpi_flow_struct *flow,",
          "2686:      u_int8_t proto, u_int16_t sport, u_int16_t dport,",
          "2687:      u_int8_t *user_defined_proto) {",
          "2690:   if(sport && dport) {",
          "2691:     ndpi_default_ports_tree_node_t *found = ndpi_get_guessed_protocol_id(ndpi_str, proto, sport, dport);",
          "2693:     if(found != NULL) {",
          "2694:       u_int16_t guessed_proto = found->proto->protoId;",
          "2697:       if(flow",
          "2698:   && (proto == IPPROTO_UDP)",
          "2699:   && NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, guessed_proto)",
          "2700:   && is_udp_guessable_protocol(guessed_proto)",
          "2701:   )",
          "2702:  return(NDPI_PROTOCOL_UNKNOWN);",
          "2703:       else {",
          "2705:  return(guessed_proto);",
          "2706:       }",
          "2707:     }",
          "2708:   } else {",
          "2711:     switch(proto) {",
          "2712:     case NDPI_IPSEC_PROTOCOL_ESP:",
          "2713:     case NDPI_IPSEC_PROTOCOL_AH:",
          "2714:       return(NDPI_PROTOCOL_IP_IPSEC);",
          "2715:       break;",
          "2716:     case NDPI_GRE_PROTOCOL_TYPE:",
          "2717:       return(NDPI_PROTOCOL_IP_GRE);",
          "2718:       break;",
          "2719:     case NDPI_ICMP_PROTOCOL_TYPE:",
          "2720:       return(NDPI_PROTOCOL_IP_ICMP);",
          "2721:       break;",
          "2722:     case NDPI_IGMP_PROTOCOL_TYPE:",
          "2723:       return(NDPI_PROTOCOL_IP_IGMP);",
          "2724:       break;",
          "2725:     case NDPI_EGP_PROTOCOL_TYPE:",
          "2726:       return(NDPI_PROTOCOL_IP_EGP);",
          "2727:       break;",
          "2728:     case NDPI_SCTP_PROTOCOL_TYPE:",
          "2729:       return(NDPI_PROTOCOL_IP_SCTP);",
          "2730:       break;",
          "2731:     case NDPI_OSPF_PROTOCOL_TYPE:",
          "2732:       return(NDPI_PROTOCOL_IP_OSPF);",
          "2733:       break;",
          "2734:     case NDPI_IPIP_PROTOCOL_TYPE:",
          "2735:       return(NDPI_PROTOCOL_IP_IP_IN_IP);",
          "2736:       break;",
          "2737:     case NDPI_ICMPV6_PROTOCOL_TYPE:",
          "2738:       return(NDPI_PROTOCOL_IP_ICMPV6);",
          "2739:       break;",
          "2740:     case 112:",
          "2741:       return(NDPI_PROTOCOL_IP_VRRP);",
          "2742:       break;",
          "2743:     }",
          "2744:   }",
          "2746:   return(NDPI_PROTOCOL_UNKNOWN);",
          "2751: u_int ndpi_get_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "2752:   return(ndpi_str->ndpi_num_supported_protocols);",
          "2758: char * strsep(char **sp, char *sep)",
          "2760:   char *p, *s;",
          "2761:   if(sp == NULL || *sp == NULL || **sp == '\\0') return(NULL);",
          "2762:   s = *sp;",
          "2763:   p = s + strcspn(s, sep);",
          "2764:   if(*p != '\\0') *p++ = '\\0';",
          "2766:   return(s);",
          "2772: int ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str,",
          "2773:        char* rule, u_int8_t do_add) {",
          "2774:   char *at, *proto, *elem;",
          "2775:   ndpi_proto_defaults_t *def;",
          "2776:   int subprotocol_id, i;",
          "2778:   at = strrchr(rule, '@');",
          "2779:   if(at == NULL) {",
          "2780:     NDPI_LOG_ERR(ndpi_str, \"Invalid rule '%s'\\n\", rule);",
          "2781:     return(-1);",
          "2782:   } else",
          "2783:     at[0] = 0, proto = &at[1];",
          "2785:   for(i=0; proto[i] != '\\0'; i++) {",
          "2786:     switch(proto[i]) {",
          "2787:     case '/':",
          "2788:     case '&':",
          "2789:     case '^':",
          "2790:     case ':':",
          "2791:     case ';':",
          "2792:     case '\\'':",
          "2793:     case '\"':",
          "2794:     case ' ':",
          "2795:       proto[i] = '_';",
          "2796:       break;",
          "2797:     }",
          "2798:   }",
          "2800:   for(i=0, def = NULL; i<(int)ndpi_str->ndpi_num_supported_protocols; i++) {",
          "2801:     if(ndpi_str->proto_defaults[i].protoName && strcasecmp(ndpi_str->proto_defaults[i].protoName, proto) == 0) {",
          "2802:       def = &ndpi_str->proto_defaults[i];",
          "2803:       subprotocol_id = i;",
          "2804:       break;",
          "2805:     }",
          "2806:   }",
          "2808:   if(def == NULL) {",
          "2809:     if(!do_add) {",
          "2811:       NDPI_LOG_ERR(ndpi_str, \"Unable to find protocol '%s': skipping rule '%s'\\n\", proto, rule);",
          "2812:       return(-3);",
          "2813:     } else {",
          "2814:       ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "2815:       u_int16_t no_master[2] = { NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO };",
          "2817:       if(ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS-1)) {",
          "2818:  NDPI_LOG_ERR(ndpi_str, \"Too many protocols defined (%u): skipping protocol %s\\n\",",
          "2819:        ndpi_str->ndpi_num_custom_protocols, proto);",
          "2820:  return(-2);",
          "2821:       }",
          "2823:       ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE,",
          "2824:          ndpi_str->ndpi_num_supported_protocols,",
          "2825:          0 /* can_have_a_subprotocol */, no_master,",
          "2826:          no_master,",
          "2827:          proto,",
          "2829:          ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "2830:          ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "2831:       def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];",
          "2832:       subprotocol_id = ndpi_str->ndpi_num_supported_protocols;",
          "2833:       ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;",
          "2834:     }",
          "2835:   }",
          "2837:   while((elem = strsep(&rule, \",\")) != NULL) {",
          "2838:     char *attr = elem, *value = NULL;",
          "2839:     ndpi_port_range range;",
          "2840:     int is_tcp = 0, is_udp = 0, is_ip = 0;",
          "2842:     if(strncmp(attr, \"tcp:\", 4) == 0)",
          "2843:       is_tcp = 1, value = &attr[4];",
          "2844:     else if(strncmp(attr, \"udp:\", 4) == 0)",
          "2845:       is_udp = 1, value = &attr[4];",
          "2846:     else if(strncmp(attr, \"ip:\", 3) == 0)",
          "2847:       is_ip = 1, value = &attr[3];",
          "2848:     else if(strncmp(attr, \"host:\", 5) == 0) {",
          "2850:       value = &attr[5];",
          "2853:     }",
          "2855:     if(is_tcp || is_udp) {",
          "2856:       u_int p_low, p_high;",
          "2858:       if(sscanf(value, \"%u-%u\", &p_low, &p_high) == 2)",
          "2859:  range.port_low = p_low, range.port_high = p_high;",
          "2860:       else",
          "2861:  range.port_low = range.port_high = atoi(&elem[4]);",
          "2863:       if(do_add)",
          "2864:  addDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,",
          "2865:          is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__,__LINE__);",
          "2866:       else",
          "2867:  removeDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);",
          "2868:     } else if(is_ip) {",
          "2870:       ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id);",
          "2871:     } else {",
          "2872:       if(do_add)",
          "2873:  ndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id,",
          "2874:           NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "2875:           NDPI_PROTOCOL_ACCEPTABLE);",
          "2876:       else",
          "2877:  ndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);",
          "2879:   }",
          "2881:   return(0);",
          "",
          "[Added Lines]",
          "2512: u_int8_t is_udp_guessable_protocol(u_int16_t l7_guessed_proto)",
          "2513: {",
          "2514:     switch (l7_guessed_proto) {",
          "2515:         case NDPI_PROTOCOL_QUIC:",
          "2516:         case NDPI_PROTOCOL_SNMP:",
          "2517:         case NDPI_PROTOCOL_NETFLOW:",
          "2519:             return (1);",
          "2520:     }",
          "2522:     return (0);",
          "2527: u_int16_t ndpi_guess_protocol_id(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "2528:                                  u_int8_t proto, u_int16_t sport, u_int16_t dport, u_int8_t *user_defined_proto)",
          "2529: {",
          "2532:     if (sport && dport) {",
          "2533:         ndpi_default_ports_tree_node_t *found = ndpi_get_guessed_protocol_id(ndpi_str, proto, sport, dport);",
          "2535:         if (found != NULL) {",
          "2536:             u_int16_t guessed_proto = found->proto->protoId;",
          "2539:             if (flow && (proto == IPPROTO_UDP) &&",
          "2540:                 NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, guessed_proto) &&",
          "2541:                 is_udp_guessable_protocol(guessed_proto))",
          "2542:                 return (NDPI_PROTOCOL_UNKNOWN);",
          "2543:             else {",
          "2545:                 return (guessed_proto);",
          "2546:             }",
          "2547:         }",
          "2548:     } else {",
          "2551:         switch (proto) {",
          "2552:             case NDPI_IPSEC_PROTOCOL_ESP:",
          "2553:             case NDPI_IPSEC_PROTOCOL_AH:",
          "2554:                 return (NDPI_PROTOCOL_IP_IPSEC);",
          "2555:                 break;",
          "2556:             case NDPI_GRE_PROTOCOL_TYPE:",
          "2557:                 return (NDPI_PROTOCOL_IP_GRE);",
          "2558:                 break;",
          "2559:             case NDPI_ICMP_PROTOCOL_TYPE:",
          "2560:                 return (NDPI_PROTOCOL_IP_ICMP);",
          "2561:                 break;",
          "2562:             case NDPI_IGMP_PROTOCOL_TYPE:",
          "2563:                 return (NDPI_PROTOCOL_IP_IGMP);",
          "2564:                 break;",
          "2565:             case NDPI_EGP_PROTOCOL_TYPE:",
          "2566:                 return (NDPI_PROTOCOL_IP_EGP);",
          "2567:                 break;",
          "2568:             case NDPI_SCTP_PROTOCOL_TYPE:",
          "2569:                 return (NDPI_PROTOCOL_IP_SCTP);",
          "2570:                 break;",
          "2571:             case NDPI_OSPF_PROTOCOL_TYPE:",
          "2572:                 return (NDPI_PROTOCOL_IP_OSPF);",
          "2573:                 break;",
          "2574:             case NDPI_IPIP_PROTOCOL_TYPE:",
          "2575:                 return (NDPI_PROTOCOL_IP_IP_IN_IP);",
          "2576:                 break;",
          "2577:             case NDPI_ICMPV6_PROTOCOL_TYPE:",
          "2578:                 return (NDPI_PROTOCOL_IP_ICMPV6);",
          "2579:                 break;",
          "2580:             case 112:",
          "2581:                 return (NDPI_PROTOCOL_IP_VRRP);",
          "2582:                 break;",
          "2583:         }",
          "2584:     }",
          "2586:     return (NDPI_PROTOCOL_UNKNOWN);",
          "2591: u_int ndpi_get_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "2592: {",
          "2593:     return (ndpi_str->ndpi_num_supported_protocols);",
          "2599: char *strsep(char **sp, char *sep)",
          "2601:     char *p, *s;",
          "2602:     if (sp == NULL || *sp == NULL || **sp == '\\0')",
          "2603:         return (NULL);",
          "2604:     s = *sp;",
          "2605:     p = s + strcspn(s, sep);",
          "2606:     if (*p != '\\0')",
          "2609:     return (s);",
          "2615: int ndpi_handle_rule(struct ndpi_detection_module_struct *ndpi_str, char *rule, u_int8_t do_add)",
          "2616: {",
          "2617:     char *at, *proto, *elem;",
          "2618:     ndpi_proto_defaults_t *def;",
          "2619:     int subprotocol_id, i;",
          "2621:     at = strrchr(rule, '@');",
          "2622:     if (at == NULL) {",
          "2623:         NDPI_LOG_ERR(ndpi_str, \"Invalid rule '%s'\\n\", rule);",
          "2624:         return (-1);",
          "2625:     } else",
          "2626:         at[0] = 0, proto = &at[1];",
          "2628:     for (i = 0; proto[i] != '\\0'; i++) {",
          "2629:         switch (proto[i]) {",
          "2630:             case '/':",
          "2631:             case '&':",
          "2632:             case '^':",
          "2633:             case ':':",
          "2634:             case ';':",
          "2635:             case '\\'':",
          "2636:             case '\"':",
          "2637:             case ' ':",
          "2638:                 proto[i] = '_';",
          "2639:                 break;",
          "2640:         }",
          "2641:     }",
          "2643:     for (i = 0, def = NULL; i < (int) ndpi_str->ndpi_num_supported_protocols; i++) {",
          "2644:         if (ndpi_str->proto_defaults[i].protoName && strcasecmp(ndpi_str->proto_defaults[i].protoName, proto) == 0) {",
          "2645:             def = &ndpi_str->proto_defaults[i];",
          "2646:             subprotocol_id = i;",
          "2647:             break;",
          "2648:         }",
          "2649:     }",
          "2651:     if (def == NULL) {",
          "2652:         if (!do_add) {",
          "2654:             NDPI_LOG_ERR(ndpi_str, \"Unable to find protocol '%s': skipping rule '%s'\\n\", proto, rule);",
          "2655:             return (-3);",
          "2656:         } else {",
          "2657:             ndpi_port_range ports_a[MAX_DEFAULT_PORTS], ports_b[MAX_DEFAULT_PORTS];",
          "2658:             u_int16_t no_master[2] = {NDPI_PROTOCOL_NO_MASTER_PROTO, NDPI_PROTOCOL_NO_MASTER_PROTO};",
          "2660:             if (ndpi_str->ndpi_num_custom_protocols >= (NDPI_MAX_NUM_CUSTOM_PROTOCOLS - 1)) {",
          "2661:                 NDPI_LOG_ERR(ndpi_str, \"Too many protocols defined (%u): skipping protocol %s\\n\",",
          "2662:                              ndpi_str->ndpi_num_custom_protocols, proto);",
          "2663:                 return (-2);",
          "2664:             }",
          "2666:             ndpi_set_proto_defaults(",
          "2667:                 ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, ndpi_str->ndpi_num_supported_protocols,",
          "2668:                 0 /* can_have_a_subprotocol */, no_master, no_master, proto,",
          "2670:                 ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "2671:                 ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "2672:             def = &ndpi_str->proto_defaults[ndpi_str->ndpi_num_supported_protocols];",
          "2673:             subprotocol_id = ndpi_str->ndpi_num_supported_protocols;",
          "2674:             ndpi_str->ndpi_num_supported_protocols++, ndpi_str->ndpi_num_custom_protocols++;",
          "2675:         }",
          "2676:     }",
          "2678:     while ((elem = strsep(&rule, \",\")) != NULL) {",
          "2679:         char *attr = elem, *value = NULL;",
          "2680:         ndpi_port_range range;",
          "2681:         int is_tcp = 0, is_udp = 0, is_ip = 0;",
          "2683:         if (strncmp(attr, \"tcp:\", 4) == 0)",
          "2684:             is_tcp = 1, value = &attr[4];",
          "2685:         else if (strncmp(attr, \"udp:\", 4) == 0)",
          "2686:             is_udp = 1, value = &attr[4];",
          "2687:         else if (strncmp(attr, \"ip:\", 3) == 0)",
          "2688:             is_ip = 1, value = &attr[3];",
          "2689:         else if (strncmp(attr, \"host:\", 5) == 0) {",
          "2691:             value = &attr[5];",
          "2692:             if (value[0] == '\"')",
          "2694:             if (value[strlen(value) - 1] == '\"')",
          "2696:         }",
          "2698:         if (is_tcp || is_udp) {",
          "2699:             u_int p_low, p_high;",
          "2701:             if (sscanf(value, \"%u-%u\", &p_low, &p_high) == 2)",
          "2702:                 range.port_low = p_low, range.port_high = p_high;",
          "2703:             else",
          "2704:                 range.port_low = range.port_high = atoi(&elem[4]);",
          "2706:             if (do_add)",
          "2707:                 addDefaultPort(ndpi_str, &range, def, 1 /* Custom user proto */,",
          "2708:                                is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot, __FUNCTION__, __LINE__);",
          "2709:             else",
          "2710:                 removeDefaultPort(&range, def, is_tcp ? &ndpi_str->tcpRoot : &ndpi_str->udpRoot);",
          "2711:         } else if (is_ip) {",
          "2713:             ndpi_add_host_ip_subprotocol(ndpi_str, value, subprotocol_id);",
          "2714:         } else {",
          "2715:             if (do_add)",
          "2716:                 ndpi_add_host_url_subprotocol(ndpi_str, value, subprotocol_id, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "2717:                                               NDPI_PROTOCOL_ACCEPTABLE);",
          "2718:             else",
          "2719:                 ndpi_remove_host_url_subprotocol(ndpi_str, value, subprotocol_id);",
          "2720:         }",
          "2723:     return (0);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2930:     }",
          "2937: }",
          "",
          "[Removed Lines]",
          "2895: int ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char* path) {",
          "2896:   char buffer[512], *line, *name, *category, *saveptr;",
          "2897:   FILE *fd;",
          "2898:   int len, num = 0;",
          "2900:   fd = fopen(path, \"r\");",
          "2902:   if(fd == NULL) {",
          "2903:     NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2904:     return(-1);",
          "2905:   }",
          "2907:   while(1) {",
          "2908:     line = fgets(buffer, sizeof(buffer), fd);",
          "2910:     if(line == NULL)",
          "2911:       break;",
          "2913:     len = strlen(line);",
          "2915:     if((len <= 1) || (line[0] == '#'))",
          "2916:       continue;",
          "2918:     line[len-1] = '\\0';",
          "2919:     name = strtok_r(line, \"\\t\", &saveptr);",
          "2921:     if(name) {",
          "2922:       category = strtok_r(NULL, \"\\t\", &saveptr);",
          "2924:       if(category) {",
          "2925:         int rc = ndpi_load_category(ndpi_str, name, (ndpi_protocol_category_t) atoi(category));",
          "2927:  if(rc >= 0)",
          "2928:    num++;",
          "2929:       }",
          "2931:   }",
          "2933:   fclose(fd);",
          "2934:   ndpi_enable_loaded_categories(ndpi_str);",
          "2936:   return(num);",
          "",
          "[Added Lines]",
          "2737: int ndpi_load_categories_file(struct ndpi_detection_module_struct *ndpi_str, const char *path)",
          "2738: {",
          "2739:     char buffer[512], *line, *name, *category, *saveptr;",
          "2740:     FILE *fd;",
          "2741:     int len, num = 0;",
          "2743:     fd = fopen(path, \"r\");",
          "2745:     if (fd == NULL) {",
          "2746:         NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2747:         return (-1);",
          "2748:     }",
          "2750:     while (1) {",
          "2751:         line = fgets(buffer, sizeof(buffer), fd);",
          "2753:         if (line == NULL)",
          "2754:             break;",
          "2756:         len = strlen(line);",
          "2758:         if ((len <= 1) || (line[0] == '#'))",
          "2759:             continue;",
          "2761:         line[len - 1] = '\\0';",
          "2762:         name = strtok_r(line, \"\\t\", &saveptr);",
          "2764:         if (name) {",
          "2765:             category = strtok_r(NULL, \"\\t\", &saveptr);",
          "2767:             if (category) {",
          "2768:                 int rc = ndpi_load_category(ndpi_str, name, (ndpi_protocol_category_t) atoi(category));",
          "2770:                 if (rc >= 0)",
          "2771:                     num++;",
          "2772:             }",
          "2773:         }",
          "2776:     fclose(fd);",
          "2777:     ndpi_enable_loaded_categories(ndpi_str);",
          "2779:     return (num);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2953:   udp:139@NETBIOS",
          "3019: }",
          "3034:     Compare specify protocol bitmask with main detection bitmask",
          "3037: #ifdef DEBUG",
          "3041: #endif",
          "3046: #ifdef DEBUG",
          "3050: #endif",
          "3054:       Set function and index protocol within proto_default structure for port protocol detection",
          "3055:       and callback_buffer function for DPI protocol detection",
          "3061:       Set ndpi_selection_bitmask for protocol",
          "3066:       Reset protocol detection bitmask via NDPI_PROTOCOL_UNKNOWN and than add specify protocol bitmast to callback",
          "3067:       buffer.",
          "3074: }",
          "3078: void ndpi_set_protocol_detection_bitmask2(struct ndpi_detection_module_struct *ndpi_str,",
          "3569: #ifdef CUSTOM_NDPI_PROTOCOLS",
          "3570: #include \"../../../nDPI-custom/custom_ndpi_main_init.c\"",
          "3571: #endif",
          "3639: }",
          "3641: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "",
          "[Removed Lines]",
          "2956: int ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_str, const char* path) {",
          "2957:   FILE *fd;",
          "2958:   char *buffer, *old_buffer;",
          "2959:   int chunk_len = 512, buffer_len = chunk_len, old_buffer_len;",
          "2960:   int i, rc = -1;",
          "2962:   fd = fopen(path, \"r\");",
          "2964:   if(fd == NULL) {",
          "2965:     NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2966:     goto error;",
          "2967:   }",
          "2969:   buffer = ndpi_malloc(buffer_len);",
          "2971:   if(buffer == NULL) {",
          "2972:     NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2973:     goto close_fd;",
          "2974:   }",
          "2976:   while(1) {",
          "2977:     char *line = buffer;",
          "2978:     int line_len = buffer_len;",
          "2980:     while((line = fgets(line, line_len, fd)) != NULL && line[strlen(line)-1] != '\\n') {",
          "2981:       i = strlen(line);",
          "2982:       old_buffer = buffer;",
          "2983:       old_buffer_len = buffer_len;",
          "2984:       buffer_len += chunk_len;",
          "2986:       buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);",
          "2988:       if(buffer == NULL) {",
          "2989:         NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2990:         ndpi_free(old_buffer);",
          "2991:         goto close_fd;",
          "2992:       }",
          "2994:       line = &buffer[i];",
          "2995:       line_len = chunk_len;",
          "2996:     }",
          "2999:       break;",
          "3001:     i = strlen(buffer);",
          "3002:     if((i <= 1) || (buffer[0] == '#'))",
          "3003:       continue;",
          "3004:     else",
          "3005:       buffer[i-1] = '\\0';",
          "3007:     ndpi_handle_rule(ndpi_str, buffer, 1);",
          "3008:   }",
          "3010:   rc = 0;",
          "3012:   ndpi_free(buffer);",
          "3014:  close_fd:",
          "3015:   fclose(fd);",
          "3017:  error:",
          "3018:   return(rc);",
          "3024: void ndpi_set_bitmask_protocol_detection(char * label,",
          "3025:       struct ndpi_detection_module_struct *ndpi_str,",
          "3026:       const NDPI_PROTOCOL_BITMASK * detection_bitmask,",
          "3027:       const u_int32_t idx,",
          "3028:       u_int16_t ndpi_protocol_id,",
          "3029:       void (*func) (struct ndpi_detection_module_struct *, struct ndpi_flow_struct *flow),",
          "3030:       const NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_bitmask,",
          "3031:       u_int8_t b_save_bitmask_unknow,",
          "3032:       u_int8_t b_add_detection_bitmask) {",
          "3036:   if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(*detection_bitmask, ndpi_protocol_id) != 0) {",
          "3038:     NDPI_LOG_DBG2(ndpi_str,",
          "3039:     \"[NDPI] ndpi_set_bitmask_protocol_detection: %s : [callback_buffer] idx= %u, [proto_defaults] protocol_id=%u\\n\",",
          "3040:     label, idx, ndpi_protocol_id);",
          "3043:     if(ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx != 0) {",
          "3044:       NDPI_LOG_DBG2(ndpi_str,",
          "3045:       \"[NDPI] Internal error: protocol %s/%u has been already registered\\n\", label, ndpi_protocol_id);",
          "3047:     } else {",
          "3048:       NDPI_LOG_DBG2(ndpi_str,",
          "3049:       \"[NDPI] Adding %s with protocol id %d\\n\", label, ndpi_protocol_id);",
          "3051:     }",
          "3057:     ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx = idx;",
          "3058:     ndpi_str->proto_defaults[ndpi_protocol_id].func = ndpi_str->callback_buffer[idx].func = func;",
          "3063:     ndpi_str->callback_buffer[idx].ndpi_selection_bitmask = ndpi_selection_bitmask;",
          "3069:     if(b_save_bitmask_unknow) NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, NDPI_PROTOCOL_UNKNOWN);",
          "3070:     if(b_add_detection_bitmask) NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, ndpi_protocol_id);",
          "3072:     NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].excluded_protocol_bitmask, ndpi_protocol_id);",
          "3073:   }",
          "3079:        const NDPI_PROTOCOL_BITMASK * dbm) {",
          "3080:   NDPI_PROTOCOL_BITMASK detection_bitmask_local;",
          "3081:   NDPI_PROTOCOL_BITMASK *detection_bitmask = &detection_bitmask_local;",
          "3082:   u_int32_t a = 0;",
          "3084:   NDPI_BITMASK_SET(detection_bitmask_local, *dbm);",
          "3085:   NDPI_BITMASK_SET(ndpi_str->detection_bitmask, *dbm);",
          "3088:   ndpi_str->callback_buffer_size = 0;",
          "3091:   init_http_dissector(ndpi_str, &a, detection_bitmask);",
          "3094:   init_starcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "3097:   init_tls_dissector(ndpi_str, &a, detection_bitmask);",
          "3100:   init_stun_dissector(ndpi_str, &a, detection_bitmask);",
          "3103:   init_rtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3106:   init_rtsp_dissector(ndpi_str, &a, detection_bitmask);",
          "3109:   init_rdp_dissector(ndpi_str, &a, detection_bitmask);",
          "3112:   init_sip_dissector(ndpi_str, &a, detection_bitmask);",
          "3115:   init_imo_dissector(ndpi_str, &a, detection_bitmask);",
          "3118:   init_teredo_dissector(ndpi_str, &a, detection_bitmask);",
          "3121:   init_edonkey_dissector(ndpi_str, &a, detection_bitmask);",
          "3124:   init_fasttrack_dissector(ndpi_str, &a, detection_bitmask);",
          "3127:   init_gnutella_dissector(ndpi_str, &a, detection_bitmask);",
          "3130:   init_directconnect_dissector(ndpi_str, &a, detection_bitmask);",
          "3133:   init_msn_dissector(ndpi_str, &a, detection_bitmask);",
          "3136:   init_yahoo_dissector(ndpi_str, &a, detection_bitmask);",
          "3139:   init_oscar_dissector(ndpi_str, &a, detection_bitmask);",
          "3142:   init_applejuice_dissector(ndpi_str, &a, detection_bitmask);",
          "3145:   init_soulseek_dissector(ndpi_str, &a, detection_bitmask);",
          "3148:   init_socks_dissector(ndpi_str, &a, detection_bitmask);",
          "3151:   init_irc_dissector(ndpi_str, &a, detection_bitmask);",
          "3154:   init_jabber_dissector(ndpi_str, &a, detection_bitmask);",
          "3157:   init_mail_pop_dissector(ndpi_str, &a, detection_bitmask);",
          "3160:   init_mail_imap_dissector(ndpi_str, &a, detection_bitmask);",
          "3163:   init_mail_smtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3166:   init_usenet_dissector(ndpi_str, &a, detection_bitmask);",
          "3169:   init_dns_dissector(ndpi_str, &a, detection_bitmask);",
          "3172:   init_fbzero_dissector(ndpi_str, &a, detection_bitmask);",
          "3175:   init_vmware_dissector(ndpi_str, &a, detection_bitmask);",
          "3178:   init_non_tcp_udp_dissector(ndpi_str, &a, detection_bitmask);",
          "3181:   init_tvants_dissector(ndpi_str, &a, detection_bitmask);",
          "3184:   init_sopcast_dissector(ndpi_str, &a, detection_bitmask);",
          "3187:   init_tvuplayer_dissector(ndpi_str, &a, detection_bitmask);",
          "3190:   init_ppstream_dissector(ndpi_str, &a, detection_bitmask);",
          "3193:   init_pplive_dissector(ndpi_str, &a, detection_bitmask);",
          "3196:   init_iax_dissector(ndpi_str, &a, detection_bitmask);",
          "3199:   init_mgpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3202:   init_zattoo_dissector(ndpi_str, &a, detection_bitmask);",
          "3205:   init_qq_dissector(ndpi_str, &a, detection_bitmask);",
          "3208:   init_ssh_dissector(ndpi_str, &a, detection_bitmask);",
          "3211:   init_ayiya_dissector(ndpi_str, &a, detection_bitmask);",
          "3214:   init_thunder_dissector(ndpi_str, &a, detection_bitmask);",
          "3217:   init_vnc_dissector(ndpi_str, &a, detection_bitmask);",
          "3220:   init_teamviewer_dissector(ndpi_str, &a, detection_bitmask);",
          "3223:   init_dhcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3226:   init_steam_dissector(ndpi_str, &a, detection_bitmask);",
          "3229:   init_halflife2_dissector(ndpi_str, &a, detection_bitmask);",
          "3232:   init_xbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3235:   init_http_activesync_dissector(ndpi_str, &a, detection_bitmask);",
          "3238:   init_smb_dissector(ndpi_str, &a, detection_bitmask);",
          "3241:   init_mining_dissector(ndpi_str, &a, detection_bitmask);",
          "3244:   init_telnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3247:   init_ntp_dissector(ndpi_str, &a, detection_bitmask);",
          "3250:   init_nfs_dissector(ndpi_str, &a, detection_bitmask);",
          "3253:   init_ssdp_dissector(ndpi_str, &a, detection_bitmask);",
          "3256:   init_world_of_warcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "3259:   init_postgres_dissector(ndpi_str, &a, detection_bitmask);",
          "3262:   init_mysql_dissector(ndpi_str, &a, detection_bitmask);",
          "3265:   init_bgp_dissector(ndpi_str, &a, detection_bitmask);",
          "3268:   init_battlefield_dissector(ndpi_str, &a, detection_bitmask);",
          "3271:   init_pcanywhere_dissector(ndpi_str, &a, detection_bitmask);",
          "3274:   init_snmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3277:   init_kontiki_dissector(ndpi_str, &a, detection_bitmask);",
          "3280:   init_icecast_dissector(ndpi_str, &a, detection_bitmask);",
          "3283:   init_shoutcast_dissector(ndpi_str, &a, detection_bitmask);",
          "3286:   init_kerberos_dissector(ndpi_str, &a, detection_bitmask);",
          "3289:   init_openft_dissector(ndpi_str, &a, detection_bitmask);",
          "3292:   init_syslog_dissector(ndpi_str, &a, detection_bitmask);",
          "3295:   init_directdownloadlink_dissector(ndpi_str, &a, detection_bitmask);",
          "3298:   init_netbios_dissector(ndpi_str, &a, detection_bitmask);",
          "3301:   init_mdns_dissector(ndpi_str, &a, detection_bitmask);",
          "3304:   init_ipp_dissector(ndpi_str, &a, detection_bitmask);",
          "3307:   init_ldap_dissector(ndpi_str, &a, detection_bitmask);",
          "3310:   init_warcraft3_dissector(ndpi_str, &a, detection_bitmask);",
          "3313:   init_xdmcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3316:   init_tftp_dissector(ndpi_str, &a, detection_bitmask);",
          "3319:   init_mssql_tds_dissector(ndpi_str, &a, detection_bitmask);",
          "3322:   init_pptp_dissector(ndpi_str, &a, detection_bitmask);",
          "3325:   init_stealthnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3328:   init_dhcpv6_dissector(ndpi_str, &a, detection_bitmask);",
          "3331:   init_afp_dissector(ndpi_str, &a, detection_bitmask);",
          "3334:   init_checkmk_dissector(ndpi_str, &a, detection_bitmask);",
          "3337:   init_aimini_dissector(ndpi_str, &a, detection_bitmask);",
          "3340:   init_florensia_dissector(ndpi_str, &a, detection_bitmask);",
          "3343:   init_maplestory_dissector(ndpi_str, &a, detection_bitmask);",
          "3346:   init_dofus_dissector(ndpi_str, &a, detection_bitmask);",
          "3349:   init_world_of_kung_fu_dissector(ndpi_str, &a, detection_bitmask);",
          "3352:   init_fiesta_dissector(ndpi_str, &a, detection_bitmask);",
          "3355:   init_crossfire_dissector(ndpi_str, &a, detection_bitmask);",
          "3358:   init_guildwars_dissector(ndpi_str, &a, detection_bitmask);",
          "3361:   init_armagetron_dissector(ndpi_str, &a, detection_bitmask);",
          "3364:   init_dropbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3367:   init_spotify_dissector(ndpi_str, &a, detection_bitmask);",
          "3370:   init_radius_dissector(ndpi_str, &a, detection_bitmask);",
          "3373:   init_citrix_dissector(ndpi_str, &a, detection_bitmask);",
          "3376:   init_lotus_notes_dissector(ndpi_str, &a, detection_bitmask);",
          "3379:   init_gtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3382:   init_dcerpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3385:   init_netflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3388:   init_sflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3391:   init_h323_dissector(ndpi_str, &a, detection_bitmask);",
          "3394:   init_openvpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3397:   init_noe_dissector(ndpi_str, &a, detection_bitmask);",
          "3400:   init_ciscovpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3403:   init_teamspeak_dissector(ndpi_str, &a, detection_bitmask);",
          "3406:   init_tor_dissector(ndpi_str, &a, detection_bitmask);",
          "3409:   init_skinny_dissector(ndpi_str, &a, detection_bitmask);",
          "3412:   init_rtcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3415:   init_rsync_dissector(ndpi_str, &a, detection_bitmask);",
          "3418:   init_whois_das_dissector(ndpi_str, &a, detection_bitmask);",
          "3421:   init_oracle_dissector(ndpi_str, &a, detection_bitmask);",
          "3424:   init_corba_dissector(ndpi_str, &a, detection_bitmask);",
          "3427:   init_rtmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3430:   init_ftp_control_dissector(ndpi_str, &a, detection_bitmask);",
          "3433:   init_ftp_data_dissector(ndpi_str, &a, detection_bitmask);",
          "3436:   init_pando_dissector(ndpi_str, &a, detection_bitmask);",
          "3439:   init_megaco_dissector(ndpi_str, &a, detection_bitmask);",
          "3442:   init_redis_dissector(ndpi_str, &a, detection_bitmask);",
          "3445:   init_upnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3448:   init_vhua_dissector(ndpi_str, &a, detection_bitmask);",
          "3451:   init_zmq_dissector(ndpi_str, &a, detection_bitmask);",
          "3454:   init_telegram_dissector(ndpi_str, &a, detection_bitmask);",
          "3457:   init_quic_dissector(ndpi_str, &a, detection_bitmask);",
          "3460:   init_diameter_dissector(ndpi_str, &a, detection_bitmask);",
          "3463:   init_apple_push_dissector(ndpi_str, &a, detection_bitmask);",
          "3466:   init_eaq_dissector(ndpi_str, &a, detection_bitmask);",
          "3469:   init_kakaotalk_voice_dissector(ndpi_str, &a, detection_bitmask);",
          "3472:   init_mpegts_dissector(ndpi_str, &a, detection_bitmask);",
          "3475:   init_ubntac2_dissector(ndpi_str, &a, detection_bitmask);",
          "3478:   init_coap_dissector(ndpi_str, &a, detection_bitmask);",
          "3481:   init_mqtt_dissector(ndpi_str, &a, detection_bitmask);",
          "3484:   init_someip_dissector(ndpi_str, &a, detection_bitmask);",
          "3487:   init_rx_dissector(ndpi_str, &a, detection_bitmask);",
          "3490:   init_git_dissector(ndpi_str, &a, detection_bitmask);",
          "3493:   init_hangout_dissector(ndpi_str, &a, detection_bitmask);",
          "3496:   init_drda_dissector(ndpi_str, &a, detection_bitmask);",
          "3499:   init_bjnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3502:   init_smpp_dissector(ndpi_str, &a, detection_bitmask);",
          "3505:   init_tinc_dissector(ndpi_str, &a, detection_bitmask);",
          "3508:   init_fix_dissector(ndpi_str, &a, detection_bitmask);",
          "3511:   init_nintendo_dissector(ndpi_str, &a, detection_bitmask);",
          "3514:   init_modbus_dissector(ndpi_str, &a, detection_bitmask);",
          "3517:   init_capwap_dissector(ndpi_str, &a, detection_bitmask);",
          "3520:   init_zabbix_dissector(ndpi_str, &a, detection_bitmask);",
          "3525:   init_viber_dissector(ndpi_str, &a, detection_bitmask);",
          "3528:   init_skype_dissector(ndpi_str, &a, detection_bitmask);",
          "3531:   init_bittorrent_dissector(ndpi_str, &a, detection_bitmask);",
          "3534:   init_whatsapp_dissector(ndpi_str, &a, detection_bitmask);",
          "3537:   init_ookla_dissector(ndpi_str, &a, detection_bitmask);",
          "3540:   init_amqp_dissector(ndpi_str, &a, detection_bitmask);",
          "3543:   init_csgo_dissector(ndpi_str, &a, detection_bitmask);",
          "3546:   init_lisp_dissector(ndpi_str, &a, detection_bitmask);",
          "3549:   init_ajp_dissector(ndpi_str, &a, detection_bitmask);",
          "3552:   init_memcached_dissector(ndpi_str, &a, detection_bitmask);",
          "3555:   init_nest_log_sink_dissector(ndpi_str, &a, detection_bitmask);",
          "3558:   init_wireguard_dissector(ndpi_str, &a, detection_bitmask);",
          "3561:   init_amazon_video_dissector(ndpi_str, &a, detection_bitmask);",
          "3564:   init_targus_getdata_dissector(ndpi_str, &a, detection_bitmask);",
          "3567:   init_s7comm_dissector(ndpi_str, &a, detection_bitmask);",
          "3575:   ndpi_str->callback_buffer_size = a;",
          "3577:   NDPI_LOG_DBG2(ndpi_str,",
          "3578:   \"callback_buffer_size is %u\\n\", ndpi_str->callback_buffer_size);",
          "3581:   ndpi_str->callback_buffer_size_tcp_payload = 0;",
          "3582:   ndpi_str->callback_buffer_size_tcp_no_payload = 0;",
          "3583:   for(a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3584:     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask",
          "3585:  & (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP |",
          "3586:     NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3587:     NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {",
          "3588:       if(_ndpi_debug_callbacks) NDPI_LOG_DBG2(ndpi_str,",
          "3589:            \"callback_buffer_tcp_payload, adding buffer %u as entry %u\\n\", a,",
          "3590:            ndpi_str->callback_buffer_size_tcp_payload);",
          "3592:       memcpy(&ndpi_str->callback_buffer_tcp_payload[ndpi_str->callback_buffer_size_tcp_payload],",
          "3593:       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3594:       ndpi_str->callback_buffer_size_tcp_payload++;",
          "3596:       if((ndpi_str->",
          "3597:    callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0) {",
          "3598:  if(_ndpi_debug_callbacks) NDPI_LOG_DBG2(ndpi_str,",
          "3599:       \"\\tcallback_buffer_tcp_no_payload, additional adding buffer %u to no_payload process\\n\", a);",
          "3601:  memcpy(&ndpi_str->callback_buffer_tcp_no_payload",
          "3602:         [ndpi_str->callback_buffer_size_tcp_no_payload], &ndpi_str->callback_buffer[a],",
          "3603:         sizeof(struct ndpi_call_function_struct));",
          "3604:  ndpi_str->callback_buffer_size_tcp_no_payload++;",
          "3605:       }",
          "3606:     }",
          "3607:   }",
          "3609:   ndpi_str->callback_buffer_size_udp = 0;",
          "3610:   for(a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3611:     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |",
          "3612:           NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3613:           NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC))",
          "3614:        != 0) {",
          "3615:       if(_ndpi_debug_callbacks) NDPI_LOG_DBG2(ndpi_str,",
          "3616:            \"callback_buffer_size_udp: adding buffer : %u as entry %u\\n\", a, ndpi_str->callback_buffer_size_udp);",
          "3618:       memcpy(&ndpi_str->callback_buffer_udp[ndpi_str->callback_buffer_size_udp],",
          "3619:       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3620:       ndpi_str->callback_buffer_size_udp++;",
          "3621:     }",
          "3622:   }",
          "3624:   ndpi_str->callback_buffer_size_non_tcp_udp = 0;",
          "3625:   for(a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3626:     if((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP |",
          "3627:           NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |",
          "3628:           NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)) == 0",
          "3629:        || (ndpi_str->",
          "3630:     callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC) != 0) {",
          "3631:       if(_ndpi_debug_callbacks) NDPI_LOG_DBG2(ndpi_str,",
          "3632:            \"callback_buffer_non_tcp_udp: adding buffer : %u as entry %u\\n\", a, ndpi_str->callback_buffer_size_non_tcp_udp);",
          "3634:       memcpy(&ndpi_str->callback_buffer_non_tcp_udp[ndpi_str->callback_buffer_size_non_tcp_udp],",
          "3635:       &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3636:       ndpi_str->callback_buffer_size_non_tcp_udp++;",
          "3637:     }",
          "3638:   }",
          "",
          "[Added Lines]",
          "2799: int ndpi_load_protocols_file(struct ndpi_detection_module_struct *ndpi_str, const char *path)",
          "2800: {",
          "2801:     FILE *fd;",
          "2802:     char *buffer, *old_buffer;",
          "2803:     int chunk_len = 512, buffer_len = chunk_len, old_buffer_len;",
          "2804:     int i, rc = -1;",
          "2806:     fd = fopen(path, \"r\");",
          "2808:     if (fd == NULL) {",
          "2809:         NDPI_LOG_ERR(ndpi_str, \"Unable to open file %s [%s]\\n\", path, strerror(errno));",
          "2810:         goto error;",
          "2811:     }",
          "2813:     buffer = ndpi_malloc(buffer_len);",
          "2815:     if (buffer == NULL) {",
          "2816:         NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2817:         goto close_fd;",
          "2818:     }",
          "2820:     while (1) {",
          "2821:         char *line = buffer;",
          "2822:         int line_len = buffer_len;",
          "2824:         while ((line = fgets(line, line_len, fd)) != NULL && line[strlen(line) - 1] != '\\n') {",
          "2825:             i = strlen(line);",
          "2826:             old_buffer = buffer;",
          "2827:             old_buffer_len = buffer_len;",
          "2828:             buffer_len += chunk_len;",
          "2830:             buffer = ndpi_realloc(old_buffer, old_buffer_len, buffer_len);",
          "2832:             if (buffer == NULL) {",
          "2833:                 NDPI_LOG_ERR(ndpi_str, \"Memory allocation failure\\n\");",
          "2834:                 ndpi_free(old_buffer);",
          "2835:                 goto close_fd;",
          "2836:             }",
          "2838:             line = &buffer[i];",
          "2839:             line_len = chunk_len;",
          "2840:         }",
          "2843:             break;",
          "2845:         i = strlen(buffer);",
          "2846:         if ((i <= 1) || (buffer[0] == '#'))",
          "2847:             continue;",
          "2848:         else",
          "2849:             buffer[i - 1] = '\\0';",
          "2851:         ndpi_handle_rule(ndpi_str, buffer, 1);",
          "2852:     }",
          "2854:     rc = 0;",
          "2856:     ndpi_free(buffer);",
          "2858: close_fd:",
          "2859:     fclose(fd);",
          "2861: error:",
          "2862:     return (rc);",
          "2868: void ndpi_set_bitmask_protocol_detection(char *label, struct ndpi_detection_module_struct *ndpi_str,",
          "2869:                                          const NDPI_PROTOCOL_BITMASK *detection_bitmask, const u_int32_t idx,",
          "2870:                                          u_int16_t ndpi_protocol_id,",
          "2871:                                          void (*func)(struct ndpi_detection_module_struct *,",
          "2872:                                                       struct ndpi_flow_struct *flow),",
          "2873:                                          const NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_bitmask,",
          "2874:                                          u_int8_t b_save_bitmask_unknow, u_int8_t b_add_detection_bitmask)",
          "2875: {",
          "2879:     if (NDPI_COMPARE_PROTOCOL_TO_BITMASK(*detection_bitmask, ndpi_protocol_id) != 0) {",
          "2881:         NDPI_LOG_DBG2(ndpi_str,",
          "2882:                       \"[NDPI] ndpi_set_bitmask_protocol_detection: %s : [callback_buffer] idx= %u, [proto_defaults] \"",
          "2883:                       \"protocol_id=%u\\n\",",
          "2884:                       label, idx, ndpi_protocol_id);",
          "2887:         if (ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx != 0) {",
          "2888:             NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Internal error: protocol %s/%u has been already registered\\n\", label,",
          "2889:                           ndpi_protocol_id);",
          "2891:         } else {",
          "2892:             NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Adding %s with protocol id %d\\n\", label, ndpi_protocol_id);",
          "2894:         }",
          "2900:         ndpi_str->proto_defaults[ndpi_protocol_id].protoIdx = idx;",
          "2901:         ndpi_str->proto_defaults[ndpi_protocol_id].func = ndpi_str->callback_buffer[idx].func = func;",
          "2906:         ndpi_str->callback_buffer[idx].ndpi_selection_bitmask = ndpi_selection_bitmask;",
          "2912:         if (b_save_bitmask_unknow)",
          "2913:             NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, NDPI_PROTOCOL_UNKNOWN);",
          "2914:         if (b_add_detection_bitmask)",
          "2915:             NDPI_ADD_PROTOCOL_TO_BITMASK(ndpi_str->callback_buffer[idx].detection_bitmask, ndpi_protocol_id);",
          "2917:         NDPI_SAVE_AS_BITMASK(ndpi_str->callback_buffer[idx].excluded_protocol_bitmask, ndpi_protocol_id);",
          "2918:     }",
          "2924:                                           const NDPI_PROTOCOL_BITMASK *dbm)",
          "2925: {",
          "2926:     NDPI_PROTOCOL_BITMASK detection_bitmask_local;",
          "2927:     NDPI_PROTOCOL_BITMASK *detection_bitmask = &detection_bitmask_local;",
          "2928:     u_int32_t a = 0;",
          "2930:     NDPI_BITMASK_SET(detection_bitmask_local, *dbm);",
          "2931:     NDPI_BITMASK_SET(ndpi_str->detection_bitmask, *dbm);",
          "2934:     ndpi_str->callback_buffer_size = 0;",
          "2937:     init_http_dissector(ndpi_str, &a, detection_bitmask);",
          "2940:     init_starcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "2943:     init_tls_dissector(ndpi_str, &a, detection_bitmask);",
          "2946:     init_stun_dissector(ndpi_str, &a, detection_bitmask);",
          "2949:     init_rtp_dissector(ndpi_str, &a, detection_bitmask);",
          "2952:     init_rtsp_dissector(ndpi_str, &a, detection_bitmask);",
          "2955:     init_rdp_dissector(ndpi_str, &a, detection_bitmask);",
          "2958:     init_sip_dissector(ndpi_str, &a, detection_bitmask);",
          "2961:     init_imo_dissector(ndpi_str, &a, detection_bitmask);",
          "2964:     init_teredo_dissector(ndpi_str, &a, detection_bitmask);",
          "2967:     init_edonkey_dissector(ndpi_str, &a, detection_bitmask);",
          "2970:     init_fasttrack_dissector(ndpi_str, &a, detection_bitmask);",
          "2973:     init_gnutella_dissector(ndpi_str, &a, detection_bitmask);",
          "2976:     init_directconnect_dissector(ndpi_str, &a, detection_bitmask);",
          "2979:     init_msn_dissector(ndpi_str, &a, detection_bitmask);",
          "2982:     init_yahoo_dissector(ndpi_str, &a, detection_bitmask);",
          "2985:     init_oscar_dissector(ndpi_str, &a, detection_bitmask);",
          "2988:     init_applejuice_dissector(ndpi_str, &a, detection_bitmask);",
          "2991:     init_soulseek_dissector(ndpi_str, &a, detection_bitmask);",
          "2994:     init_socks_dissector(ndpi_str, &a, detection_bitmask);",
          "2997:     init_irc_dissector(ndpi_str, &a, detection_bitmask);",
          "3000:     init_jabber_dissector(ndpi_str, &a, detection_bitmask);",
          "3003:     init_mail_pop_dissector(ndpi_str, &a, detection_bitmask);",
          "3006:     init_mail_imap_dissector(ndpi_str, &a, detection_bitmask);",
          "3009:     init_mail_smtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3012:     init_usenet_dissector(ndpi_str, &a, detection_bitmask);",
          "3015:     init_dns_dissector(ndpi_str, &a, detection_bitmask);",
          "3018:     init_fbzero_dissector(ndpi_str, &a, detection_bitmask);",
          "3021:     init_vmware_dissector(ndpi_str, &a, detection_bitmask);",
          "3024:     init_non_tcp_udp_dissector(ndpi_str, &a, detection_bitmask);",
          "3027:     init_tvants_dissector(ndpi_str, &a, detection_bitmask);",
          "3030:     init_sopcast_dissector(ndpi_str, &a, detection_bitmask);",
          "3033:     init_tvuplayer_dissector(ndpi_str, &a, detection_bitmask);",
          "3036:     init_ppstream_dissector(ndpi_str, &a, detection_bitmask);",
          "3039:     init_pplive_dissector(ndpi_str, &a, detection_bitmask);",
          "3042:     init_iax_dissector(ndpi_str, &a, detection_bitmask);",
          "3045:     init_mgpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3048:     init_zattoo_dissector(ndpi_str, &a, detection_bitmask);",
          "3051:     init_qq_dissector(ndpi_str, &a, detection_bitmask);",
          "3054:     init_ssh_dissector(ndpi_str, &a, detection_bitmask);",
          "3057:     init_ayiya_dissector(ndpi_str, &a, detection_bitmask);",
          "3060:     init_thunder_dissector(ndpi_str, &a, detection_bitmask);",
          "3063:     init_vnc_dissector(ndpi_str, &a, detection_bitmask);",
          "3066:     init_teamviewer_dissector(ndpi_str, &a, detection_bitmask);",
          "3069:     init_dhcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3072:     init_steam_dissector(ndpi_str, &a, detection_bitmask);",
          "3075:     init_halflife2_dissector(ndpi_str, &a, detection_bitmask);",
          "3078:     init_xbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3081:     init_http_activesync_dissector(ndpi_str, &a, detection_bitmask);",
          "3084:     init_smb_dissector(ndpi_str, &a, detection_bitmask);",
          "3087:     init_mining_dissector(ndpi_str, &a, detection_bitmask);",
          "3090:     init_telnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3093:     init_ntp_dissector(ndpi_str, &a, detection_bitmask);",
          "3096:     init_nfs_dissector(ndpi_str, &a, detection_bitmask);",
          "3099:     init_ssdp_dissector(ndpi_str, &a, detection_bitmask);",
          "3102:     init_world_of_warcraft_dissector(ndpi_str, &a, detection_bitmask);",
          "3105:     init_postgres_dissector(ndpi_str, &a, detection_bitmask);",
          "3108:     init_mysql_dissector(ndpi_str, &a, detection_bitmask);",
          "3111:     init_bgp_dissector(ndpi_str, &a, detection_bitmask);",
          "3114:     init_battlefield_dissector(ndpi_str, &a, detection_bitmask);",
          "3117:     init_pcanywhere_dissector(ndpi_str, &a, detection_bitmask);",
          "3120:     init_snmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3123:     init_kontiki_dissector(ndpi_str, &a, detection_bitmask);",
          "3126:     init_icecast_dissector(ndpi_str, &a, detection_bitmask);",
          "3129:     init_shoutcast_dissector(ndpi_str, &a, detection_bitmask);",
          "3132:     init_kerberos_dissector(ndpi_str, &a, detection_bitmask);",
          "3135:     init_openft_dissector(ndpi_str, &a, detection_bitmask);",
          "3138:     init_syslog_dissector(ndpi_str, &a, detection_bitmask);",
          "3141:     init_directdownloadlink_dissector(ndpi_str, &a, detection_bitmask);",
          "3144:     init_netbios_dissector(ndpi_str, &a, detection_bitmask);",
          "3147:     init_mdns_dissector(ndpi_str, &a, detection_bitmask);",
          "3150:     init_ipp_dissector(ndpi_str, &a, detection_bitmask);",
          "3153:     init_ldap_dissector(ndpi_str, &a, detection_bitmask);",
          "3156:     init_warcraft3_dissector(ndpi_str, &a, detection_bitmask);",
          "3159:     init_xdmcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3162:     init_tftp_dissector(ndpi_str, &a, detection_bitmask);",
          "3165:     init_mssql_tds_dissector(ndpi_str, &a, detection_bitmask);",
          "3168:     init_pptp_dissector(ndpi_str, &a, detection_bitmask);",
          "3171:     init_stealthnet_dissector(ndpi_str, &a, detection_bitmask);",
          "3174:     init_dhcpv6_dissector(ndpi_str, &a, detection_bitmask);",
          "3177:     init_afp_dissector(ndpi_str, &a, detection_bitmask);",
          "3180:     init_checkmk_dissector(ndpi_str, &a, detection_bitmask);",
          "3183:     init_aimini_dissector(ndpi_str, &a, detection_bitmask);",
          "3186:     init_florensia_dissector(ndpi_str, &a, detection_bitmask);",
          "3189:     init_maplestory_dissector(ndpi_str, &a, detection_bitmask);",
          "3192:     init_dofus_dissector(ndpi_str, &a, detection_bitmask);",
          "3195:     init_world_of_kung_fu_dissector(ndpi_str, &a, detection_bitmask);",
          "3198:     init_fiesta_dissector(ndpi_str, &a, detection_bitmask);",
          "3201:     init_crossfire_dissector(ndpi_str, &a, detection_bitmask);",
          "3204:     init_guildwars_dissector(ndpi_str, &a, detection_bitmask);",
          "3207:     init_armagetron_dissector(ndpi_str, &a, detection_bitmask);",
          "3210:     init_dropbox_dissector(ndpi_str, &a, detection_bitmask);",
          "3213:     init_spotify_dissector(ndpi_str, &a, detection_bitmask);",
          "3216:     init_radius_dissector(ndpi_str, &a, detection_bitmask);",
          "3219:     init_citrix_dissector(ndpi_str, &a, detection_bitmask);",
          "3222:     init_lotus_notes_dissector(ndpi_str, &a, detection_bitmask);",
          "3225:     init_gtp_dissector(ndpi_str, &a, detection_bitmask);",
          "3228:     init_dcerpc_dissector(ndpi_str, &a, detection_bitmask);",
          "3231:     init_netflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3234:     init_sflow_dissector(ndpi_str, &a, detection_bitmask);",
          "3237:     init_h323_dissector(ndpi_str, &a, detection_bitmask);",
          "3240:     init_openvpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3243:     init_noe_dissector(ndpi_str, &a, detection_bitmask);",
          "3246:     init_ciscovpn_dissector(ndpi_str, &a, detection_bitmask);",
          "3249:     init_teamspeak_dissector(ndpi_str, &a, detection_bitmask);",
          "3252:     init_tor_dissector(ndpi_str, &a, detection_bitmask);",
          "3255:     init_skinny_dissector(ndpi_str, &a, detection_bitmask);",
          "3258:     init_rtcp_dissector(ndpi_str, &a, detection_bitmask);",
          "3261:     init_rsync_dissector(ndpi_str, &a, detection_bitmask);",
          "3264:     init_whois_das_dissector(ndpi_str, &a, detection_bitmask);",
          "3267:     init_oracle_dissector(ndpi_str, &a, detection_bitmask);",
          "3270:     init_corba_dissector(ndpi_str, &a, detection_bitmask);",
          "3273:     init_rtmp_dissector(ndpi_str, &a, detection_bitmask);",
          "3276:     init_ftp_control_dissector(ndpi_str, &a, detection_bitmask);",
          "3279:     init_ftp_data_dissector(ndpi_str, &a, detection_bitmask);",
          "3282:     init_pando_dissector(ndpi_str, &a, detection_bitmask);",
          "3285:     init_megaco_dissector(ndpi_str, &a, detection_bitmask);",
          "3288:     init_redis_dissector(ndpi_str, &a, detection_bitmask);",
          "3291:     init_upnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3294:     init_vhua_dissector(ndpi_str, &a, detection_bitmask);",
          "3297:     init_zmq_dissector(ndpi_str, &a, detection_bitmask);",
          "3300:     init_telegram_dissector(ndpi_str, &a, detection_bitmask);",
          "3303:     init_quic_dissector(ndpi_str, &a, detection_bitmask);",
          "3306:     init_diameter_dissector(ndpi_str, &a, detection_bitmask);",
          "3309:     init_apple_push_dissector(ndpi_str, &a, detection_bitmask);",
          "3312:     init_eaq_dissector(ndpi_str, &a, detection_bitmask);",
          "3315:     init_kakaotalk_voice_dissector(ndpi_str, &a, detection_bitmask);",
          "3318:     init_mpegts_dissector(ndpi_str, &a, detection_bitmask);",
          "3321:     init_ubntac2_dissector(ndpi_str, &a, detection_bitmask);",
          "3324:     init_coap_dissector(ndpi_str, &a, detection_bitmask);",
          "3327:     init_mqtt_dissector(ndpi_str, &a, detection_bitmask);",
          "3330:     init_someip_dissector(ndpi_str, &a, detection_bitmask);",
          "3333:     init_rx_dissector(ndpi_str, &a, detection_bitmask);",
          "3336:     init_git_dissector(ndpi_str, &a, detection_bitmask);",
          "3339:     init_hangout_dissector(ndpi_str, &a, detection_bitmask);",
          "3342:     init_drda_dissector(ndpi_str, &a, detection_bitmask);",
          "3345:     init_bjnp_dissector(ndpi_str, &a, detection_bitmask);",
          "3348:     init_smpp_dissector(ndpi_str, &a, detection_bitmask);",
          "3351:     init_tinc_dissector(ndpi_str, &a, detection_bitmask);",
          "3354:     init_fix_dissector(ndpi_str, &a, detection_bitmask);",
          "3357:     init_nintendo_dissector(ndpi_str, &a, detection_bitmask);",
          "3360:     init_modbus_dissector(ndpi_str, &a, detection_bitmask);",
          "3363:     init_capwap_dissector(ndpi_str, &a, detection_bitmask);",
          "3366:     init_zabbix_dissector(ndpi_str, &a, detection_bitmask);",
          "3371:     init_viber_dissector(ndpi_str, &a, detection_bitmask);",
          "3374:     init_skype_dissector(ndpi_str, &a, detection_bitmask);",
          "3377:     init_bittorrent_dissector(ndpi_str, &a, detection_bitmask);",
          "3380:     init_whatsapp_dissector(ndpi_str, &a, detection_bitmask);",
          "3383:     init_ookla_dissector(ndpi_str, &a, detection_bitmask);",
          "3386:     init_amqp_dissector(ndpi_str, &a, detection_bitmask);",
          "3389:     init_csgo_dissector(ndpi_str, &a, detection_bitmask);",
          "3392:     init_lisp_dissector(ndpi_str, &a, detection_bitmask);",
          "3395:     init_ajp_dissector(ndpi_str, &a, detection_bitmask);",
          "3398:     init_memcached_dissector(ndpi_str, &a, detection_bitmask);",
          "3401:     init_nest_log_sink_dissector(ndpi_str, &a, detection_bitmask);",
          "3404:     init_wireguard_dissector(ndpi_str, &a, detection_bitmask);",
          "3407:     init_amazon_video_dissector(ndpi_str, &a, detection_bitmask);",
          "3410:     init_targus_getdata_dissector(ndpi_str, &a, detection_bitmask);",
          "3413:     init_s7comm_dissector(ndpi_str, &a, detection_bitmask);",
          "3421:     ndpi_str->callback_buffer_size = a;",
          "3423:     NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size is %u\\n\", ndpi_str->callback_buffer_size);",
          "3426:     ndpi_str->callback_buffer_size_tcp_payload = 0;",
          "3427:     ndpi_str->callback_buffer_size_tcp_no_payload = 0;",
          "3428:     for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3429:         if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3430:              (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3431:               NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {",
          "3432:             if (_ndpi_debug_callbacks)",
          "3433:                 NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_tcp_payload, adding buffer %u as entry %u\\n\", a,",
          "3434:                               ndpi_str->callback_buffer_size_tcp_payload);",
          "3436:             memcpy(&ndpi_str->callback_buffer_tcp_payload[ndpi_str->callback_buffer_size_tcp_payload],",
          "3437:                    &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3438:             ndpi_str->callback_buffer_size_tcp_payload++;",
          "3440:             if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) ==",
          "3441:                 0) {",
          "3442:                 if (_ndpi_debug_callbacks)",
          "3443:                     NDPI_LOG_DBG2(",
          "3444:                         ndpi_str,",
          "3445:                         \"\\tcallback_buffer_tcp_no_payload, additional adding buffer %u to no_payload process\\n\", a);",
          "3447:                 memcpy(&ndpi_str->callback_buffer_tcp_no_payload[ndpi_str->callback_buffer_size_tcp_no_payload],",
          "3448:                        &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3449:                 ndpi_str->callback_buffer_size_tcp_no_payload++;",
          "3450:             }",
          "3451:         }",
          "3452:     }",
          "3454:     ndpi_str->callback_buffer_size_udp = 0;",
          "3455:     for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3456:         if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3457:              (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP |",
          "3458:               NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC)) != 0) {",
          "3459:             if (_ndpi_debug_callbacks)",
          "3460:                 NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_size_udp: adding buffer : %u as entry %u\\n\", a,",
          "3461:                               ndpi_str->callback_buffer_size_udp);",
          "3463:             memcpy(&ndpi_str->callback_buffer_udp[ndpi_str->callback_buffer_size_udp], &ndpi_str->callback_buffer[a],",
          "3464:                    sizeof(struct ndpi_call_function_struct));",
          "3465:             ndpi_str->callback_buffer_size_udp++;",
          "3466:         }",
          "3467:     }",
          "3469:     ndpi_str->callback_buffer_size_non_tcp_udp = 0;",
          "3470:     for (a = 0; a < ndpi_str->callback_buffer_size; a++) {",
          "3471:         if ((ndpi_str->callback_buffer[a].ndpi_selection_bitmask &",
          "3472:              (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP |",
          "3473:               NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)) == 0 ||",
          "3474:             (ndpi_str->callback_buffer[a].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC) !=",
          "3475:                 0) {",
          "3476:             if (_ndpi_debug_callbacks)",
          "3477:                 NDPI_LOG_DBG2(ndpi_str, \"callback_buffer_non_tcp_udp: adding buffer : %u as entry %u\\n\", a,",
          "3478:                               ndpi_str->callback_buffer_size_non_tcp_udp);",
          "3480:             memcpy(&ndpi_str->callback_buffer_non_tcp_udp[ndpi_str->callback_buffer_size_non_tcp_udp],",
          "3481:                    &ndpi_str->callback_buffer[a], sizeof(struct ndpi_call_function_struct));",
          "3482:             ndpi_str->callback_buffer_size_non_tcp_udp++;",
          "3483:         }",
          "3484:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "3689: }",
          "3693: static u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, const u_int16_t ipsize)",
          "3694: {",
          "3703: }",
          "3709: {",
          "3711: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3713: #endif",
          "3727: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3733: #endif",
          "3742: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3747: #endif",
          "3760: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3769:     }",
          "3772: #endif",
          "3790: }",
          "3794: {",
          "3797: }",
          "3819: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3827: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3833: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3840: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3847: #endif",
          "3918:     } else {",
          "3941: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3943: #endif",
          "3955: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3959: #endif",
          "4014:         analyzer which require this info can make use of this info",
          "4023:     actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.",
          "4219: }",
          "4232: }",
          "4251:     }",
          "4255: }",
          "4371:  As Google has recently introduced Duo,",
          "4372:  we need to distinguish between it and hangout",
          "4373:  thing that should be handled by the STUN dissector",
          "4376:     }",
          "4383: }",
          "4427: }",
          "4459: }",
          "4475: #if 0",
          "4476:   printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);",
          "",
          "[Removed Lines]",
          "3653: int ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t ** l4ptr, u_int16_t * l4len, u_int8_t * nxt_hdr)",
          "3654: {",
          "3655:   while((*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {",
          "3656:     u_int16_t ehdr_len;",
          "3659:     if(*nxt_hdr == 59) {",
          "3660:       return(1);",
          "3661:     }",
          "3663:     if(*nxt_hdr == 44) {",
          "3664:       if(*l4len < 8) {",
          "3665:  return(1);",
          "3666:       }",
          "3669:       (*l4ptr) += 8;",
          "3670:       continue;",
          "3671:     }",
          "3674:     if (*l4len < 2) {",
          "3675:       return(1);",
          "3676:     }",
          "3677:     ehdr_len = (*l4ptr)[1];",
          "3678:     ehdr_len *= 8;",
          "3679:     ehdr_len += 8;",
          "3681:     if(*l4len < ehdr_len) {",
          "3682:       return(1);",
          "3683:     }",
          "3686:     (*l4ptr) += ehdr_len;",
          "3687:   }",
          "3688:   return(0);",
          "3696:   if(ipsize < iph->ihl * 4 ||",
          "3697:      ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 || (iph->frag_off & htons(0x1FFF)) != 0) {",
          "3698:     return(0);",
          "3699:   }",
          "3702:   return(1);",
          "3705: static u_int8_t ndpi_detection_get_l4_internal(struct ndpi_detection_module_struct *ndpi_str,",
          "3706:             const u_int8_t * l3, u_int16_t l3_len,",
          "3707:             const u_int8_t ** l4_return, u_int16_t * l4_len_return,",
          "3708:             u_int8_t * l4_protocol_return, u_int32_t flags)",
          "3710:   const struct ndpi_iphdr *iph = NULL;",
          "3712:   const struct ndpi_ipv6hdr *iph_v6 = NULL;",
          "3714:   u_int16_t l4len = 0;",
          "3715:   const u_int8_t *l4ptr = NULL;",
          "3716:   u_int8_t l4protocol = 0;",
          "3718:   if(l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))",
          "3719:     return(1);",
          "3721:   if((iph = (const struct ndpi_iphdr *) l3) == NULL)",
          "3722:     return(1);",
          "3724:   if(iph->version == IPVERSION && iph->ihl >= 5) {",
          "3725:     NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3726:   }",
          "3728:   else if(iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {",
          "3729:     NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3730:     iph_v6 = (const struct ndpi_ipv6hdr *) l3;",
          "3731:     iph = NULL;",
          "3732:   }",
          "3734:   else {",
          "3735:     return(1);",
          "3736:   }",
          "3738:   if((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {",
          "3739:     NDPI_LOG_DBG2(ndpi_str, \"ipv4 header found but excluded by flag\\n\");",
          "3740:     return(1);",
          "3741:   }",
          "3743:   else if((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {",
          "3744:     NDPI_LOG_DBG2(ndpi_str, \"ipv6 header found but excluded by flag\\n\");",
          "3745:     return(1);",
          "3746:   }",
          "3749:   if(iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {",
          "3750:     u_int16_t len  = ntohs(iph->tot_len);",
          "3751:     u_int16_t hlen = (iph->ihl * 4);",
          "3753:     l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);",
          "3755:     if(len == 0) len = l3_len;",
          "3757:     l4len = (len > hlen) ? (len - hlen) : 0;",
          "3758:     l4protocol = iph->protocol;",
          "3759:   }",
          "3761:   else if(iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {",
          "3762:     l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));",
          "3763:     l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);",
          "3764:     l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;",
          "3767:     if(ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {",
          "3768:       return(1);",
          "3771:   }",
          "3773:   else {",
          "3774:     return(1);",
          "3775:   }",
          "3777:   if(l4_return != NULL) {",
          "3779:   }",
          "3781:   if(l4_len_return != NULL) {",
          "3783:   }",
          "3785:   if(l4_protocol_return != NULL) {",
          "3787:   }",
          "3789:   return(0);",
          "3792: void ndpi_apply_flow_protocol_to_packet(struct ndpi_flow_struct *flow,",
          "3793:      struct ndpi_packet_struct *packet)",
          "3795:   memcpy(&packet->detected_protocol_stack, &flow->detected_protocol_stack, sizeof(packet->detected_protocol_stack));",
          "3796:   memcpy(&packet->protocol_stack_info, &flow->protocol_stack_info, sizeof(packet->protocol_stack_info));",
          "3799: static int ndpi_init_packet_header(struct ndpi_detection_module_struct *ndpi_str,",
          "3800:        struct ndpi_flow_struct *flow,",
          "3801:        unsigned short packetlen) {",
          "3802:   const struct ndpi_iphdr *decaps_iph = NULL;",
          "3803:   u_int16_t l3len;",
          "3804:   u_int16_t l4len;",
          "3805:   const u_int8_t *l4ptr;",
          "3806:   u_int8_t l4protocol;",
          "3807:   u_int8_t l4_result;",
          "3809:   if (!flow)",
          "3810:     return(1);",
          "3813:   flow->packet.payload_packet_len = 0;",
          "3814:   flow->packet.l4_packet_len = 0;",
          "3815:   flow->packet.l3_packet_len = packetlen;",
          "3817:   flow->packet.tcp = NULL, flow->packet.udp = NULL;",
          "3818:   flow->packet.generic_l4_ptr = NULL;",
          "3820:   flow->packet.iphv6 = NULL;",
          "3823:   ndpi_apply_flow_protocol_to_packet(flow, &flow->packet);",
          "3825:   l3len = flow->packet.l3_packet_len;",
          "3828:   if(flow->packet.iph != NULL) {",
          "3831:     decaps_iph = flow->packet.iph;",
          "3834:   }",
          "3837:   if(decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {",
          "3838:     NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3839:   }",
          "3841:   else if(decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&",
          "3842:    (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {",
          "3843:     NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3844:     flow->packet.iphv6 = (struct ndpi_ipv6hdr *)flow->packet.iph;",
          "3845:     flow->packet.iph = NULL;",
          "3846:   }",
          "3848:   else {",
          "3849:     flow->packet.iph = NULL;",
          "3850:     return(1);",
          "3851:   }",
          "3859:   l4ptr = NULL;",
          "3860:   l4len = 0;",
          "3861:   l4protocol = 0;",
          "3863:   l4_result =",
          "3864:     ndpi_detection_get_l4_internal(ndpi_str, (const u_int8_t *) decaps_iph, l3len, &l4ptr, &l4len, &l4protocol, 0);",
          "3866:   if(l4_result != 0) {",
          "3867:     return(1);",
          "3868:   }",
          "3870:   flow->packet.l4_protocol = l4protocol;",
          "3871:   flow->packet.l4_packet_len = l4len;",
          "3872:   flow->l4_proto = l4protocol;",
          "3875:   if(l4protocol == IPPROTO_TCP && flow->packet.l4_packet_len >= 20 /* min size of tcp */ ) {",
          "3877:     flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;",
          "3878:     if(flow->packet.l4_packet_len >=flow->packet.tcp->doff * 4) {",
          "3879:       flow->packet.payload_packet_len =",
          "3880:  flow->packet.l4_packet_len -flow->packet.tcp->doff * 4;",
          "3881:       flow->packet.actual_payload_len = flow->packet.payload_packet_len;",
          "3882:       flow->packet.payload = ((u_int8_t *)flow->packet.tcp) + (flow->packet.tcp->doff * 4);",
          "3887:       if(flow->packet.tcp->syn != 0",
          "3888:   && flow->packet.tcp->ack == 0",
          "3889:   && flow->init_finished != 0",
          "3890:   && flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3891:  u_int8_t backup;",
          "3892:  u_int16_t backup1, backup2;",
          "3894:  if(flow->http.url)                  { ndpi_free(flow->http.url); flow->http.url = NULL; }",
          "3895:  if(flow->http.content_type)         { ndpi_free(flow->http.content_type); flow->http.content_type = NULL; }",
          "3896:  if(flow->http.user_agent)           { ndpi_free(flow->http.user_agent); flow->http.user_agent = NULL; }",
          "3897:  if(flow->kerberos_buf.pktbuf) {",
          "3898:   ndpi_free(flow->kerberos_buf.pktbuf);",
          "3899:   flow->kerberos_buf.pktbuf = NULL;",
          "3900:  }",
          "3901:  if(flow->l4.tcp.tls.message.buffer) {",
          "3902:      ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "3903:      flow->l4.tcp.tls.message.buffer = NULL;",
          "3904:      flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;",
          "3905:  }",
          "3907:  backup  = flow->num_processed_pkts;",
          "3908:  backup1 = flow->guessed_protocol_id;",
          "3909:  backup2 = flow->guessed_host_protocol_id;",
          "3910:  memset(flow, 0, sizeof(*(flow)));",
          "3911:  flow->num_processed_pkts = backup;",
          "3912:  flow->guessed_protocol_id      = backup1;",
          "3913:  flow->guessed_host_protocol_id = backup2;",
          "3915:  NDPI_LOG_DBG(ndpi_str,",
          "3916:        \"tcp syn packet for unknown protocol, reset detection state\\n\");",
          "3917:       }",
          "3920:       flow->packet.tcp = NULL;",
          "3921:     }",
          "3922:   } else if(l4protocol == IPPROTO_UDP && flow->packet.l4_packet_len >= 8 /* size of udp */ ) {",
          "3923:     flow->packet.udp = (struct ndpi_udphdr *) l4ptr;",
          "3924:     flow->packet.payload_packet_len =flow->packet.l4_packet_len - 8;",
          "3925:     flow->packet.payload = ((u_int8_t *)flow->packet.udp) + 8;",
          "3926:   } else {",
          "3927:     flow->packet.generic_l4_ptr = l4ptr;",
          "3928:   }",
          "3930:   return(0);",
          "3931: }",
          "3933: void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,",
          "3934:          struct ndpi_flow_struct *flow) {",
          "3935:   if(!flow) {",
          "3936:     return;",
          "3937:   } else {",
          "3939:     struct ndpi_packet_struct *packet = &flow->packet;",
          "3940:     const struct ndpi_iphdr *iph = packet->iph;",
          "3942:     const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "3944:     const struct ndpi_tcphdr *tcph = packet->tcp;",
          "3945:     const struct ndpi_udphdr *udph = flow->packet.udp;",
          "3947:     packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "3949:     if(ndpi_str->direction_detect_disable) {",
          "3950:       packet->packet_direction = flow->packet_direction;",
          "3951:     } else {",
          "3952:       if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "3953:  packet->packet_direction = 1;",
          "3956:       if(iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src,",
          "3957:            &iphv6->ip6_dst) != 0)",
          "3958:  packet->packet_direction = 1;",
          "3960:     }",
          "3962:     packet->packet_lines_parsed_complete = 0;",
          "3964:     if(flow->init_finished == 0) {",
          "3965:       flow->init_finished = 1;",
          "3966:       flow->setup_packet_direction = packet->packet_direction;",
          "3967:     }",
          "3969:     if(tcph != NULL) {",
          "3971:       packet->num_retried_bytes = 0;",
          "3973:       if(!ndpi_str->direction_detect_disable)",
          "3974:  packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "3976:       if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0",
          "3977:   && flow->l4.tcp.seen_ack == 0) {",
          "3978:  flow->l4.tcp.seen_syn = 1;",
          "3979:       }",
          "3980:       if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0",
          "3981:   && flow->l4.tcp.seen_ack == 0) {",
          "3982:  flow->l4.tcp.seen_syn_ack = 1;",
          "3983:       }",
          "3984:       if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1",
          "3985:   && flow->l4.tcp.seen_ack == 0) {",
          "3986:  flow->l4.tcp.seen_ack = 1;",
          "3987:       }",
          "3988:       if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0)",
          "3989:   || (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "3998:  if(tcph->ack != 0) {",
          "3999:    flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "4000:      ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "4002:    flow->next_tcp_seq_nr[1 -flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "4003:  }",
          "4004:       } else if(packet->payload_packet_len > 0) {",
          "4006:  if(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "4007:     ndpi_str->tcp_max_retransmission_window_size) {",
          "4009:    packet->tcp_retransmission = 1;",
          "4012:    if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) < packet->payload_packet_len)) {",
          "4016:      packet->num_retried_bytes = (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "4017:      packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "4018:      flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "4019:    }",
          "4020:  }",
          "4025:  else {",
          "4026:    packet->num_retried_bytes = 0;",
          "4027:    flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "4028:  }",
          "4029:       }",
          "4031:       if(tcph->rst) {",
          "4032:  flow->next_tcp_seq_nr[0] = 0;",
          "4033:  flow->next_tcp_seq_nr[1] = 0;",
          "4034:       }",
          "4035:     } else if(udph != NULL) {",
          "4036:       if(!ndpi_str->direction_detect_disable)",
          "4037:  packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "4038:     }",
          "4040:     if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "4041:       flow->packet_counter++;",
          "4042:     }",
          "4044:     if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "4045:       flow->packet_direction_counter[packet->packet_direction]++;",
          "4046:     }",
          "4048:     if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "4049:        flow->byte_counter[packet->packet_direction]) {",
          "4050:       flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "4051:     }",
          "4052:   }",
          "4053: }",
          "4055: void check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4056:     struct ndpi_flow_struct *flow,",
          "4057:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4059:   if (!flow) {",
          "4060:     return;",
          "4061:   }",
          "4063:   void *func = NULL;",
          "4064:   u_int32_t a;",
          "4065:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4066:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4067:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4069:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4071:   if((proto_id != NDPI_PROTOCOL_UNKNOWN)",
          "4072:      && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4073:         ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0",
          "4074:      && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask,",
          "4075:         detection_bitmask) != 0",
          "4076:      && (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask",
          "4077:   & *ndpi_selection_packet) == ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4078:     if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4079:        && (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "4080:       ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4081:  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4082:   }",
          "4084:   for(a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {",
          "4085:     if((func != ndpi_str->callback_buffer_non_tcp_udp[a].func)",
          "4086:        && (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4087:        ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask",
          "4088:        &&",
          "4089:     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4090:     ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0",
          "4091:        && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask,",
          "4092:           detection_bitmask) != 0) {",
          "4094:       if(ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)",
          "4095:  ndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow);",
          "4097:       if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4099:     }",
          "4100:   }",
          "4101: }",
          "4104: void check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4105:          struct ndpi_flow_struct *flow,",
          "4106:          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4107:   void *func = NULL;",
          "4108:   u_int32_t a;",
          "4109:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4110:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4111:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4113:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4115:   if((proto_id != NDPI_PROTOCOL_UNKNOWN)",
          "4116:      && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4117:         ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0",
          "4118:      && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask,",
          "4119:         detection_bitmask) != 0",
          "4120:      && (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask",
          "4121:   & *ndpi_selection_packet) == ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4122:     if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4123:        && (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "4124:       ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4125:  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4126:   }",
          "4128:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4129:     for(a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "4130:       if((func != ndpi_str->callback_buffer_udp[a].func)",
          "4131:   && (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4132:   ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask",
          "4133:   && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4134:      ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0",
          "4135:   && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask,",
          "4136:      detection_bitmask) != 0) {",
          "4137:  ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);",
          "4140:  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4142:       } else",
          "4143:  if(_ndpi_debug_callbacks) NDPI_LOG_DBG2(ndpi_str,",
          "4144:       \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\",a);",
          "4145:     }",
          "4146:   }",
          "4147: }",
          "4150: void check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4151:          struct ndpi_flow_struct *flow,",
          "4152:          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4153:   void *func = NULL;",
          "4154:   u_int32_t a;",
          "4155:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4156:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4157:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4159:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4161:   if(flow->packet.payload_packet_len != 0) {",
          "4162:     if((proto_id != NDPI_PROTOCOL_UNKNOWN)",
          "4163:        && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4164:           ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0",
          "4165:        && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0",
          "4166:        && (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) == ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4167:       if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4168:   && (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "4169:  ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4170:    func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4171:     }",
          "4173:     if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4174:       for(a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {",
          "4175:  if((func != ndpi_str->callback_buffer_tcp_payload[a].func)",
          "4176:     && (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) == ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask",
          "4177:     && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4178:        ndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0",
          "4179:     && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,",
          "4180:        detection_bitmask) != 0) {",
          "4181:    ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow);",
          "4183:    if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4185:  }",
          "4186:       }",
          "4187:     }",
          "4188:   } else {",
          "4190:     if((proto_id != NDPI_PROTOCOL_UNKNOWN)",
          "4191:        && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4192:           ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0",
          "4193:        && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask,",
          "4194:           detection_bitmask) != 0",
          "4195:        && (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask",
          "4196:     & *ndpi_selection_packet) == ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4197:       if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4198:   && (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL)",
          "4199:   && ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask & NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))",
          "4200:  ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4201:    func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4202:     }",
          "4204:     for(a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {",
          "4205:       if((func != ndpi_str->callback_buffer_tcp_payload[a].func)",
          "4206:   && (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4207:   ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask",
          "4208:   && NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4209:      ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0",
          "4210:   && NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,",
          "4211:      detection_bitmask) != 0) {",
          "4212:  ndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow);",
          "4214:  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4216:       }",
          "4217:     }",
          "4218:   }",
          "4223: void ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4224:      struct ndpi_flow_struct *flow,",
          "4225:      NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4226:   if(flow->packet.tcp != NULL)",
          "4227:     check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4228:   else if(flow->packet.udp != NULL)",
          "4229:     check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4230:   else",
          "4231:     check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4236: u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "4237:           struct ndpi_flow_struct *flow) {",
          "4238:   u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4240:   if(flow->packet.iph) {",
          "4241:     struct in_addr addr;",
          "4243:     addr.s_addr = flow->packet.iph->saddr;",
          "4246:     ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4248:     if(ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4249:       addr.s_addr = flow->packet.iph->daddr;",
          "4250:       ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4252:   }",
          "4254:   return(ret);",
          "4259: ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str,",
          "4260:         struct ndpi_flow_struct *flow,",
          "4261:         u_int8_t enable_guess,",
          "4262:         u_int8_t *protocol_was_guessed) {",
          "4263:   ndpi_protocol ret = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };",
          "4267:   if(flow == NULL)",
          "4268:     return(ret);",
          "4271:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4272:   ret.category = flow->category;",
          "4275:   if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4276:     return(ret);",
          "4279:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4280:     u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN,",
          "4281:       guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4283:     if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4284:       goto check_stun_export;",
          "4285:     else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO)",
          "4286:      || (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER)",
          "4287:      || (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL))",
          "4288:       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4289:     else if((flow->l4.tcp.tls.hello_processed == 1)",
          "4290:      && (flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0')) {",
          "4291:       ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4292:     } else if(enable_guess) {",
          "4293:       if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN)",
          "4294:   && (flow->packet.l4_protocol == IPPROTO_TCP)",
          "4295:   && flow->l4.tcp.tls.hello_processed)",
          "4296:  flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4298:       guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4300:       if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4301:   && ((flow->packet.l4_protocol == IPPROTO_UDP)",
          "4302:       && NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id)",
          "4303:       && is_udp_guessable_protocol(guessed_host_protocol_id)",
          "4304:       ))",
          "4305:  flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4308:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4310:   && (flow->packet.l4_protocol == IPPROTO_UDP)",
          "4311:   && NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id)",
          "4312:   && is_udp_guessable_protocol(guessed_protocol_id))",
          "4313:  flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4315:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4316:   || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4317:  if((guessed_protocol_id == 0)",
          "4318:     && (flow->protos.stun_ssl.stun.num_binding_requests > 0)",
          "4319:     && (flow->protos.stun_ssl.stun.num_processed_pkts > 0))",
          "4320:    guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4322:  if(flow->host_server_name[0] != '\\0') {",
          "4323:    ndpi_protocol_match_result ret_match;",
          "4325:    memset(&ret_match, 0, sizeof(ret_match));",
          "4327:    ndpi_match_host_subprotocol(ndpi_str, flow,",
          "4328:           (char *)flow->host_server_name,",
          "4329:           strlen((const char*)flow->host_server_name),",
          "4330:           &ret_match,",
          "4331:           NDPI_PROTOCOL_DNS);",
          "4333:    if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4334:      guessed_host_protocol_id = ret_match.protocol_id;",
          "4335:  }",
          "4337:  ndpi_int_change_protocol(ndpi_str, flow,",
          "4338:      guessed_host_protocol_id,",
          "4339:      guessed_protocol_id);",
          "4340:       }",
          "4341:     }",
          "4342:   } else if(enable_guess) {",
          "4343:     if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4344:       flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4346:     if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4347:       flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4349:     if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0])",
          "4350:       flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4351:   }",
          "4353:   if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN)",
          "4354:      && (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4355:   check_stun_export:",
          "4356:     if(flow->protos.stun_ssl.stun.num_processed_pkts || flow->protos.stun_ssl.stun.num_udp_pkts) {",
          "4358:       ndpi_set_detected_protocol(ndpi_str, flow,",
          "4359:      flow->guessed_host_protocol_id,",
          "4360:      NDPI_PROTOCOL_STUN);",
          "4361:     }",
          "4362:   }",
          "4364:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4366:   if(ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4367:     if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4368:       ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4369:     else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4375:       ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4377:   }",
          "4379:   if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "4380:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4382:   return(ret);",
          "4387: void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str,",
          "4388:           struct ndpi_flow_struct *flow,",
          "4389:           const unsigned char *packet,",
          "4390:           const unsigned short packetlen,",
          "4391:           const u_int64_t current_tick_l,",
          "4392:           struct ndpi_id_struct *src,",
          "4393:           struct ndpi_id_struct *dst) {",
          "4394:   if(flow == NULL)",
          "4395:     return;",
          "4400:   if(packetlen < 20) {",
          "4401:     return;",
          "4402:   }",
          "4404:   flow->packet.tick_timestamp_l = current_tick_l;",
          "4405:   flow->packet.tick_timestamp = (u_int32_t)(current_tick_l/ndpi_str->ticks_per_second);",
          "4408:   flow->packet.iph = (struct ndpi_iphdr *)packet;",
          "4412:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4413:     return;",
          "4416:   flow->src = src, flow->dst = dst;",
          "4417:   ndpi_connection_tracking(ndpi_str, flow);",
          "4420:   if(flow->extra_packets_func) {",
          "4421:     if((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4422:       flow->check_extra_packets = 0;",
          "4424:     if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4426:   }",
          "4431: int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str,",
          "4432:       const char *ip_address_and_mask, ndpi_protocol_category_t category) {",
          "4433:   patricia_node_t *node;",
          "4434:   struct in_addr pin;",
          "4435:   int bits = 32;",
          "4436:   char *ptr;",
          "4437:   char ipbuf[64];",
          "4439:   strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4440:   ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4442:   ptr = strrchr(ipbuf, '/');",
          "4444:   if(ptr) {",
          "4446:     if(atoi(ptr)>=0 && atoi(ptr)<=32)",
          "4447:       bits = atoi(ptr);",
          "4448:   }",
          "4450:   if(inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4451:     NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4452:     return(-1);",
          "4453:   }",
          "4455:   if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow,",
          "4456:      AF_INET, &pin, bits)) != NULL)",
          "4457:     node->value.user_value = (int)category;",
          "4458:   return(0);",
          "4463: int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str,",
          "4464:     const char *name_to_add, ndpi_protocol_category_t category) {",
          "4465:   char *name;",
          "4467:   if(name_to_add == NULL)",
          "4468:     return(-1);",
          "4470:   name = ndpi_strdup(name_to_add);",
          "4472:   if(name == NULL)",
          "4473:     return(-1);",
          "",
          "[Added Lines]",
          "3499: int ndpi_handle_ipv6_extension_headers(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t **l4ptr,",
          "3500:                                        u_int16_t *l4len, u_int8_t *nxt_hdr)",
          "3501: {",
          "3502:     while ((*nxt_hdr == 0 || *nxt_hdr == 43 || *nxt_hdr == 44 || *nxt_hdr == 60 || *nxt_hdr == 135 || *nxt_hdr == 59)) {",
          "3503:         u_int16_t ehdr_len;",
          "3506:         if (*nxt_hdr == 59) {",
          "3507:             return (1);",
          "3508:         }",
          "3510:         if (*nxt_hdr == 44) {",
          "3511:             if (*l4len < 8) {",
          "3512:                 return (1);",
          "3513:             }",
          "3516:             (*l4ptr) += 8;",
          "3517:             continue;",
          "3518:         }",
          "3521:         if (*l4len < 2) {",
          "3522:             return (1);",
          "3523:         }",
          "3524:         ehdr_len = (*l4ptr)[1];",
          "3525:         ehdr_len *= 8;",
          "3526:         ehdr_len += 8;",
          "3528:         if (*l4len < ehdr_len) {",
          "3529:             return (1);",
          "3530:         }",
          "3533:         (*l4ptr) += ehdr_len;",
          "3534:     }",
          "3535:     return (0);",
          "3542:     if (ipsize < iph->ihl * 4 || ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 ||",
          "3543:         (iph->frag_off & htons(0x1FFF)) != 0) {",
          "3544:         return (0);",
          "3545:     }",
          "3548:     return (1);",
          "3551: static u_int8_t ndpi_detection_get_l4_internal(struct ndpi_detection_module_struct *ndpi_str, const u_int8_t *l3,",
          "3552:                                                u_int16_t l3_len, const u_int8_t **l4_return, u_int16_t *l4_len_return,",
          "3553:                                                u_int8_t *l4_protocol_return, u_int32_t flags)",
          "3555:     const struct ndpi_iphdr *iph = NULL;",
          "3557:     const struct ndpi_ipv6hdr *iph_v6 = NULL;",
          "3559:     u_int16_t l4len = 0;",
          "3560:     const u_int8_t *l4ptr = NULL;",
          "3561:     u_int8_t l4protocol = 0;",
          "3563:     if (l3 == NULL || l3_len < sizeof(struct ndpi_iphdr))",
          "3564:         return (1);",
          "3566:     if ((iph = (const struct ndpi_iphdr *) l3) == NULL)",
          "3567:         return (1);",
          "3569:     if (iph->version == IPVERSION && iph->ihl >= 5) {",
          "3570:         NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3571:     }",
          "3573:     else if (iph->version == 6 && l3_len >= sizeof(struct ndpi_ipv6hdr)) {",
          "3574:         NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3575:         iph_v6 = (const struct ndpi_ipv6hdr *) l3;",
          "3576:         iph = NULL;",
          "3577:     }",
          "3579:     else {",
          "3580:         return (1);",
          "3581:     }",
          "3583:     if ((flags & NDPI_DETECTION_ONLY_IPV6) && iph != NULL) {",
          "3584:         NDPI_LOG_DBG2(ndpi_str, \"ipv4 header found but excluded by flag\\n\");",
          "3585:         return (1);",
          "3586:     }",
          "3588:     else if ((flags & NDPI_DETECTION_ONLY_IPV4) && iph_v6 != NULL) {",
          "3589:         NDPI_LOG_DBG2(ndpi_str, \"ipv6 header found but excluded by flag\\n\");",
          "3590:         return (1);",
          "3591:     }",
          "3594:     if (iph != NULL && ndpi_iph_is_valid_and_not_fragmented(iph, l3_len)) {",
          "3595:         u_int16_t len = ntohs(iph->tot_len);",
          "3596:         u_int16_t hlen = (iph->ihl * 4);",
          "3598:         l4ptr = (((const u_int8_t *) iph) + iph->ihl * 4);",
          "3600:         if (len == 0)",
          "3601:             len = l3_len;",
          "3603:         l4len = (len > hlen) ? (len - hlen) : 0;",
          "3604:         l4protocol = iph->protocol;",
          "3605:     }",
          "3607:     else if (iph_v6 != NULL && (l3_len - sizeof(struct ndpi_ipv6hdr)) >= ntohs(iph_v6->ip6_hdr.ip6_un1_plen)) {",
          "3608:         l4ptr = (((const u_int8_t *) iph_v6) + sizeof(struct ndpi_ipv6hdr));",
          "3609:         l4len = ntohs(iph_v6->ip6_hdr.ip6_un1_plen);",
          "3610:         l4protocol = iph_v6->ip6_hdr.ip6_un1_nxt;",
          "3613:         if (ndpi_handle_ipv6_extension_headers(ndpi_str, &l4ptr, &l4len, &l4protocol) != 0) {",
          "3614:             return (1);",
          "3615:         }",
          "3619:     else {",
          "3620:         return (1);",
          "3621:     }",
          "3623:     if (l4_return != NULL) {",
          "3625:     }",
          "3627:     if (l4_len_return != NULL) {",
          "3629:     }",
          "3631:     if (l4_protocol_return != NULL) {",
          "3633:     }",
          "3635:     return (0);",
          "3638: void ndpi_apply_flow_protocol_to_packet(struct ndpi_flow_struct *flow, struct ndpi_packet_struct *packet)",
          "3640:     memcpy(&packet->detected_protocol_stack, &flow->detected_protocol_stack, sizeof(packet->detected_protocol_stack));",
          "3641:     memcpy(&packet->protocol_stack_info, &flow->protocol_stack_info, sizeof(packet->protocol_stack_info));",
          "3644: static int ndpi_init_packet_header(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3645:                                    unsigned short packetlen)",
          "3646: {",
          "3647:     const struct ndpi_iphdr *decaps_iph = NULL;",
          "3648:     u_int16_t l3len;",
          "3649:     u_int16_t l4len;",
          "3650:     const u_int8_t *l4ptr;",
          "3651:     u_int8_t l4protocol;",
          "3652:     u_int8_t l4_result;",
          "3654:     if (!flow)",
          "3655:         return (1);",
          "3658:     flow->packet.payload_packet_len = 0;",
          "3659:     flow->packet.l4_packet_len = 0;",
          "3660:     flow->packet.l3_packet_len = packetlen;",
          "3662:     flow->packet.tcp = NULL, flow->packet.udp = NULL;",
          "3663:     flow->packet.generic_l4_ptr = NULL;",
          "3665:     flow->packet.iphv6 = NULL;",
          "3668:     ndpi_apply_flow_protocol_to_packet(flow, &flow->packet);",
          "3670:     l3len = flow->packet.l3_packet_len;",
          "3673:     if (flow->packet.iph != NULL) {",
          "3676:         decaps_iph = flow->packet.iph;",
          "3679:     }",
          "3682:     if (decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {",
          "3683:         NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "3684:     }",
          "3686:     else if (decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&",
          "3687:              (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {",
          "3688:         NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "3689:         flow->packet.iphv6 = (struct ndpi_ipv6hdr *) flow->packet.iph;",
          "3690:         flow->packet.iph = NULL;",
          "3691:     }",
          "3693:     else {",
          "3694:         flow->packet.iph = NULL;",
          "3695:         return (1);",
          "3696:     }",
          "3704:     l4ptr = NULL;",
          "3705:     l4len = 0;",
          "3706:     l4protocol = 0;",
          "3708:     l4_result =",
          "3709:         ndpi_detection_get_l4_internal(ndpi_str, (const u_int8_t *) decaps_iph, l3len, &l4ptr, &l4len, &l4protocol, 0);",
          "3711:     if (l4_result != 0) {",
          "3712:         return (1);",
          "3713:     }",
          "3715:     flow->packet.l4_protocol = l4protocol;",
          "3716:     flow->packet.l4_packet_len = l4len;",
          "3717:     flow->l4_proto = l4protocol;",
          "3720:     if (l4protocol == IPPROTO_TCP && flow->packet.l4_packet_len >= 20 /* min size of tcp */) {",
          "3722:         flow->packet.tcp = (struct ndpi_tcphdr *) l4ptr;",
          "3723:         if (flow->packet.l4_packet_len >= flow->packet.tcp->doff * 4) {",
          "3724:             flow->packet.payload_packet_len = flow->packet.l4_packet_len - flow->packet.tcp->doff * 4;",
          "3725:             flow->packet.actual_payload_len = flow->packet.payload_packet_len;",
          "3726:             flow->packet.payload = ((u_int8_t *) flow->packet.tcp) + (flow->packet.tcp->doff * 4);",
          "3731:             if (flow->packet.tcp->syn != 0 && flow->packet.tcp->ack == 0 && flow->init_finished != 0 &&",
          "3732:                 flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3733:                 u_int8_t backup;",
          "3734:                 u_int16_t backup1, backup2;",
          "3736:                 if (flow->http.url) {",
          "3737:                     ndpi_free(flow->http.url);",
          "3738:                     flow->http.url = NULL;",
          "3739:                 }",
          "3740:                 if (flow->http.content_type) {",
          "3741:                     ndpi_free(flow->http.content_type);",
          "3742:                     flow->http.content_type = NULL;",
          "3743:                 }",
          "3744:                 if (flow->http.user_agent) {",
          "3745:                     ndpi_free(flow->http.user_agent);",
          "3746:                     flow->http.user_agent = NULL;",
          "3747:                 }",
          "3748:                 if (flow->kerberos_buf.pktbuf) {",
          "3749:                     ndpi_free(flow->kerberos_buf.pktbuf);",
          "3750:                     flow->kerberos_buf.pktbuf = NULL;",
          "3751:                 }",
          "3752:                 if (flow->l4.tcp.tls.message.buffer) {",
          "3753:                     ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "3754:                     flow->l4.tcp.tls.message.buffer = NULL;",
          "3755:                     flow->l4.tcp.tls.message.buffer_len = flow->l4.tcp.tls.message.buffer_used = 0;",
          "3756:                 }",
          "3758:                 backup = flow->num_processed_pkts;",
          "3759:                 backup1 = flow->guessed_protocol_id;",
          "3760:                 backup2 = flow->guessed_host_protocol_id;",
          "3761:                 memset(flow, 0, sizeof(*(flow)));",
          "3762:                 flow->num_processed_pkts = backup;",
          "3763:                 flow->guessed_protocol_id = backup1;",
          "3764:                 flow->guessed_host_protocol_id = backup2;",
          "3766:                 NDPI_LOG_DBG(ndpi_str, \"tcp syn packet for unknown protocol, reset detection state\\n\");",
          "3767:             }",
          "3768:         } else {",
          "3770:             flow->packet.tcp = NULL;",
          "3771:         }",
          "3772:     } else if (l4protocol == IPPROTO_UDP && flow->packet.l4_packet_len >= 8 /* size of udp */) {",
          "3773:         flow->packet.udp = (struct ndpi_udphdr *) l4ptr;",
          "3774:         flow->packet.payload_packet_len = flow->packet.l4_packet_len - 8;",
          "3775:         flow->packet.payload = ((u_int8_t *) flow->packet.udp) + 8;",
          "3777:         flow->packet.generic_l4_ptr = l4ptr;",
          "3778:     }",
          "3780:     return (0);",
          "3781: }",
          "3783: void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "3784: {",
          "3785:     if (!flow) {",
          "3786:         return;",
          "3787:     } else {",
          "3789:         struct ndpi_packet_struct *packet = &flow->packet;",
          "3790:         const struct ndpi_iphdr *iph = packet->iph;",
          "3792:         const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "3794:         const struct ndpi_tcphdr *tcph = packet->tcp;",
          "3795:         const struct ndpi_udphdr *udph = flow->packet.udp;",
          "3797:         packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "3799:         if (ndpi_str->direction_detect_disable) {",
          "3800:             packet->packet_direction = flow->packet_direction;",
          "3801:         } else {",
          "3802:             if (iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "3803:                 packet->packet_direction = 1;",
          "3806:             if (iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)",
          "3807:                 packet->packet_direction = 1;",
          "3809:         }",
          "3811:         packet->packet_lines_parsed_complete = 0;",
          "3813:         if (flow->init_finished == 0) {",
          "3814:             flow->init_finished = 1;",
          "3815:             flow->setup_packet_direction = packet->packet_direction;",
          "3816:         }",
          "3818:         if (tcph != NULL) {",
          "3820:             packet->num_retried_bytes = 0;",
          "3822:             if (!ndpi_str->direction_detect_disable)",
          "3823:                 packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "3825:             if (tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3826:                 flow->l4.tcp.seen_ack == 0) {",
          "3827:                 flow->l4.tcp.seen_syn = 1;",
          "3828:             }",
          "3829:             if (tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3830:                 flow->l4.tcp.seen_ack == 0) {",
          "3831:                 flow->l4.tcp.seen_syn_ack = 1;",
          "3832:             }",
          "3833:             if (tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&",
          "3834:                 flow->l4.tcp.seen_ack == 0) {",
          "3835:                 flow->l4.tcp.seen_ack = 1;",
          "3836:             }",
          "3837:             if ((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||",
          "3838:                 (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "3847:                 if (tcph->ack != 0) {",
          "3848:                     flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "3849:                         ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "3851:                     flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "3852:                 }",
          "3853:             } else if (packet->payload_packet_len > 0) {",
          "3855:                 if (((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "3856:                     ndpi_str->tcp_max_retransmission_window_size) {",
          "3857:                     packet->tcp_retransmission = 1;",
          "3860:                     if ((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <",
          "3861:                          packet->payload_packet_len)) {",
          "3865:                         packet->num_retried_bytes =",
          "3866:                             (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "3867:                         packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "3868:                         flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3869:                     }",
          "3870:                 }",
          "3875:                 else {",
          "3876:                     packet->num_retried_bytes = 0;",
          "3877:                     flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3878:                 }",
          "3879:             }",
          "3881:             if (tcph->rst) {",
          "3882:                 flow->next_tcp_seq_nr[0] = 0;",
          "3883:                 flow->next_tcp_seq_nr[1] = 0;",
          "3884:             }",
          "3885:         } else if (udph != NULL) {",
          "3886:             if (!ndpi_str->direction_detect_disable)",
          "3887:                 packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "3888:         }",
          "3890:         if (flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "3891:             flow->packet_counter++;",
          "3892:         }",
          "3894:         if (flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&",
          "3895:             packet->payload_packet_len) {",
          "3896:             flow->packet_direction_counter[packet->packet_direction]++;",
          "3897:         }",
          "3899:         if (flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "3900:             flow->byte_counter[packet->packet_direction]) {",
          "3901:             flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "3902:         }",
          "3903:     }",
          "3904: }",
          "3906: void check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3907:                                 NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "3908: {",
          "3909:     if (!flow) {",
          "3910:         return;",
          "3911:     }",
          "3913:     void *func = NULL;",
          "3914:     u_int32_t a;",
          "3915:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3916:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3917:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3919:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3921:     if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3922:         NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3923:                              ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3924:         NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3925:         (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3926:             ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3927:         if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3928:             (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3929:             ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3930:                 func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3931:     }",
          "3933:     for (a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {",
          "3934:         if ((func != ndpi_str->callback_buffer_non_tcp_udp[a].func) &&",
          "3935:             (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3936:                 ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask &&",
          "3937:             NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3938:                                  ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3939:             NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3940:             if (ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)",
          "3941:                 ndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow);",
          "3943:             if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "3945:         }",
          "3946:     }",
          "3947: }",
          "3949: void check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3950:                               NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "3951: {",
          "3952:     void *func = NULL;",
          "3953:     u_int32_t a;",
          "3954:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3955:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3956:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3958:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3960:     if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3961:         NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3962:                              ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3963:         NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3964:         (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3965:             ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3966:         if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3967:             (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3968:             ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3969:                 func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "3970:     }",
          "3972:     if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3973:         for (a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "3974:             if ((func != ndpi_str->callback_buffer_udp[a].func) &&",
          "3975:                 (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3976:                     ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask &&",
          "3977:                 NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3978:                                      ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3979:                 NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3980:                 ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow);",
          "3983:                 if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "3985:             } else if (_ndpi_debug_callbacks)",
          "3986:                 NDPI_LOG_DBG2(ndpi_str, \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\", a);",
          "3987:         }",
          "3988:     }",
          "3989: }",
          "3991: void check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "3992:                               NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "3993: {",
          "3994:     void *func = NULL;",
          "3995:     u_int32_t a;",
          "3996:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3997:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3998:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4000:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4002:     if (flow->packet.payload_packet_len != 0) {",
          "4003:         if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4004:             NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4005:                                  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4006:             NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4007:             (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4008:                 ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4009:             if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4010:                 (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "4011:                 ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4012:                     func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4013:         }",
          "4015:         if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4016:             for (a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {",
          "4017:                 if ((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4018:                     (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4019:                         ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask &&",
          "4020:                     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4021:                                          ndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4022:                     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,",
          "4023:                                          detection_bitmask) != 0) {",
          "4024:                     ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow);",
          "4026:                     if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4028:                 }",
          "4029:             }",
          "4030:         }",
          "4031:     } else {",
          "4033:         if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4034:             NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4035:                                  ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4036:             NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4037:             (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4038:                 ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4039:             if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4040:                 (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&",
          "4041:                 ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &",
          "4042:                   NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))",
          "4043:                 ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4044:                     func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4045:         }",
          "4047:         for (a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {",
          "4048:             if ((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4049:                 (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4050:                     ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask &&",
          "4051:                 NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4052:                                      ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4053:                 NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,",
          "4054:                                      detection_bitmask) != 0) {",
          "4055:                 ndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow);",
          "4057:                 if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4059:             }",
          "4060:         }",
          "4061:     }",
          "4066: void ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4067:                           NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4068: {",
          "4069:     if (flow->packet.tcp != NULL)",
          "4070:         check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4071:     else if (flow->packet.udp != NULL)",
          "4072:         check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4073:     else",
          "4074:         check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet);",
          "4079: u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "4080: {",
          "4081:     u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4083:     if (flow->packet.iph) {",
          "4084:         struct in_addr addr;",
          "4086:         addr.s_addr = flow->packet.iph->saddr;",
          "4089:         ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4091:         if (ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4092:             addr.s_addr = flow->packet.iph->daddr;",
          "4093:             ret = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4094:         }",
          "4097:     return (ret);",
          "4102: ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4103:                                     u_int8_t enable_guess, u_int8_t *protocol_was_guessed)",
          "4104: {",
          "4105:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4109:     if (flow == NULL)",
          "4110:         return (ret);",
          "4113:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4114:     ret.category = flow->category;",
          "4117:     if ((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4118:         return (ret);",
          "4121:     if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4122:         u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4124:         if (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4125:             goto check_stun_export;",
          "4126:         else if ((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||",
          "4127:                  (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||",
          "4128:                  (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL))",
          "4129:             ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4130:         else if ((flow->l4.tcp.tls.hello_processed == 1) &&",
          "4131:                  (flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0')) {",
          "4132:             ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4133:         } else if (enable_guess) {",
          "4134:             if ((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&",
          "4135:                 flow->l4.tcp.tls.hello_processed)",
          "4136:                 flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4138:             guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4140:             if ((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4141:                 ((flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4142:                  NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&",
          "4143:                  is_udp_guessable_protocol(guessed_host_protocol_id)))",
          "4144:                 flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4147:             if ((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4149:                 && (flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4150:                 NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&",
          "4151:                 is_udp_guessable_protocol(guessed_protocol_id))",
          "4152:                 flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4154:             if ((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4155:                 if ((guessed_protocol_id == 0) && (flow->protos.stun_ssl.stun.num_binding_requests > 0) &&",
          "4156:                     (flow->protos.stun_ssl.stun.num_processed_pkts > 0))",
          "4157:                     guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4159:                 if (flow->host_server_name[0] != '\\0') {",
          "4160:                     ndpi_protocol_match_result ret_match;",
          "4162:                     memset(&ret_match, 0, sizeof(ret_match));",
          "4164:                     ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,",
          "4165:                                                 strlen((const char *) flow->host_server_name), &ret_match,",
          "4166:                                                 NDPI_PROTOCOL_DNS);",
          "4168:                     if (ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4169:                         guessed_host_protocol_id = ret_match.protocol_id;",
          "4170:                 }",
          "4172:                 ndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);",
          "4173:             }",
          "4174:         }",
          "4175:     } else if (enable_guess) {",
          "4176:         if (flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4177:             flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4179:         if (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4180:             flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4182:         if (flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0])",
          "4183:             flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4184:     }",
          "4186:     if ((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&",
          "4187:         (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4188:     check_stun_export:",
          "4189:         if (flow->protos.stun_ssl.stun.num_processed_pkts || flow->protos.stun_ssl.stun.num_udp_pkts) {",
          "4191:             ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);",
          "4192:         }",
          "4193:     }",
          "4195:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4197:     if (ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4198:         if (ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4199:             ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4200:         else if (ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4206:             ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4207:         }",
          "4210:     if (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "4211:         ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4213:     return (ret);",
          "4218: void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4219:                                const unsigned char *packet, const unsigned short packetlen,",
          "4220:                                const u_int64_t current_tick_l, struct ndpi_id_struct *src, struct ndpi_id_struct *dst)",
          "4221: {",
          "4222:     if (flow == NULL)",
          "4223:         return;",
          "4225:     if (flow->server_id == NULL)",
          "4229:     if (packetlen < 20) {",
          "4230:         return;",
          "4231:     }",
          "4233:     flow->packet.tick_timestamp_l = current_tick_l;",
          "4234:     flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);",
          "4237:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4241:     if (ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4242:         return;",
          "4245:     flow->src = src, flow->dst = dst;",
          "4246:     ndpi_connection_tracking(ndpi_str, flow);",
          "4249:     if (flow->extra_packets_func) {",
          "4250:         if ((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4251:             flow->check_extra_packets = 0;",
          "4253:         if (++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4255:     }",
          "4260: int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,",
          "4261:                           ndpi_protocol_category_t category)",
          "4262: {",
          "4263:     patricia_node_t *node;",
          "4264:     struct in_addr pin;",
          "4265:     int bits = 32;",
          "4266:     char *ptr;",
          "4267:     char ipbuf[64];",
          "4269:     strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4270:     ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4272:     ptr = strrchr(ipbuf, '/');",
          "4274:     if (ptr) {",
          "4276:         if (atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "4277:             bits = atoi(ptr);",
          "4278:     }",
          "4280:     if (inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4281:         NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4282:         return (-1);",
          "4283:     }",
          "4285:     if ((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL)",
          "4286:         node->value.user_value = (int) category;",
          "4287:     return (0);",
          "4292: int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,",
          "4293:                                 ndpi_protocol_category_t category)",
          "4294: {",
          "4295:     char *name;",
          "4297:     if (name_to_add == NULL)",
          "4298:         return (-1);",
          "4300:     name = ndpi_strdup(name_to_add);",
          "4302:     if (name == NULL)",
          "4303:         return (-1);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4479: #ifdef HAVE_HYPERSCAN",
          "4480:     {",
          "4492:     }",
          "4493: #else",
          "4494:     AC_PATTERN_t ac_pattern;",
          "",
          "[Removed Lines]",
          "4481:       struct hs_list *h = (struct hs_list*)ndpi_malloc(sizeof(struct hs_list));",
          "4483:       if(h) {",
          "4484:  h->expression = name, h->id = (unsigned int)category;",
          "4485:  h->next = ndpi_str->custom_categories.to_load;",
          "4486:  ndpi_str->custom_categories.to_load = h;",
          "4487:  ndpi_str->custom_categories.num_to_load++;",
          "4488:       } else {",
          "4489:         free(name);",
          "4490:         return(-1);",
          "4491:       }",
          "",
          "[Added Lines]",
          "4311:         struct hs_list *h = (struct hs_list *) ndpi_malloc(sizeof(struct hs_list));",
          "4313:         if (h) {",
          "4314:             h->expression = name, h->id = (unsigned int) category;",
          "4315:             h->next = ndpi_str->custom_categories.to_load;",
          "4316:             ndpi_str->custom_categories.to_load = h;",
          "4317:             ndpi_str->custom_categories.num_to_load++;",
          "4318:         } else {",
          "4319:             free(name);",
          "4320:             return (-1);",
          "4321:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "4497:     memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "4502:     }",
          "4504:     ac_pattern.astring = name, ac_pattern.length = strlen(ac_pattern.astring);",
          "4507:     rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);",
          "4508:     if (rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {",
          "4511:     }",
          "4512:     if (rc == ACERR_DUPLICATE_PATTERN)",
          "4514: #endif",
          "4517: }",
          "4535: }",
          "4546: #ifdef HAVE_HYPERSCAN",
          "4565: #ifdef DEBUG",
          "4567: #endif",
          "4607:     }",
          "4609: #else",
          "4621: #endif",
          "4633: }",
          "4665:     }",
          "4671: }",
          "4706:     }",
          "4710: }",
          "4748: }",
          "4752: ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,",
          "4837: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4847: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4851: #endif",
          "4904:    We could implement a shortcut here skipping dissectors for",
          "4905:    protocols we have identified by other means such as with the IP",
          "",
          "[Removed Lines]",
          "4499:     if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4500:       free(name);",
          "4501:       return(-1);",
          "4505:     ac_pattern.rep.number = (int)category;",
          "4509:       free(name);",
          "4510:       return(-1);",
          "4513:       free(name);",
          "4516:   return(0);",
          "4522: int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct,",
          "4523:      const char *ip_or_name, ndpi_protocol_category_t category) {",
          "4524:   int rv;",
          "4527:   rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4529:   if(rv < 0) {",
          "4531:     rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4532:   }",
          "4534:   return(rv);",
          "4539: int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {",
          "4540:   int i;",
          "4543:   for(i=0; category_match[i].string_to_match != NULL; i++)",
          "4544:     ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4547:   if(ndpi_str->custom_categories.num_to_load > 0) {",
          "4548:     const char **expressions;",
          "4549:     unsigned int *ids;",
          "4550:     int rc;",
          "4551:     struct hs_list *head = ndpi_str->custom_categories.to_load;",
          "4553:     expressions = (const char**)ndpi_calloc(sizeof(char*),",
          "4554:          ndpi_str->custom_categories.num_to_load+1);",
          "4555:     if(!expressions) return(-1);",
          "4557:     ids = (unsigned int*)ndpi_calloc(sizeof(unsigned int),",
          "4558:          ndpi_str->custom_categories.num_to_load+1);",
          "4559:     if(!ids) {",
          "4560:       ndpi_free(expressions);",
          "4561:       return(-1);",
          "4562:     }",
          "4564:     for(i=0; head != NULL; i++) {",
          "4566:       printf(\"[HS] Loading category %u for %s\\n\", head->id, head->expression);",
          "4568:       expressions[i] = head->expression, ids[i] = head->id;",
          "4569:       head = head->next;",
          "4570:     }",
          "4572:     if(i != ndpi_str->custom_categories.num_to_load){",
          "4573:       ndpi_free(expressions);",
          "4574:       return(-1);",
          "4575:     }",
          "4577:     free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "4578:     ndpi_str->custom_categories.hostnames = (struct hs*)ndpi_malloc(sizeof(struct hs));",
          "4580:     if(ndpi_str->custom_categories.hostnames == NULL) {",
          "4581:       ndpi_free(expressions);",
          "4582:       ndpi_free(ids);",
          "4584:     }",
          "4586:     rc = hyperscan_load_patterns(ndpi_str->custom_categories.hostnames,",
          "4587:      ndpi_str->custom_categories.num_to_load,",
          "4588:      expressions, ids);",
          "4589:     ndpi_free(expressions), ndpi_free(ids);",
          "4591:     head = ndpi_str->custom_categories.to_load;",
          "4592:     while(head != NULL) {",
          "4593:       struct hs_list *next = head->next;",
          "4595:       ndpi_free(head->expression);",
          "4596:       ndpi_free(head);",
          "4598:       head = next;",
          "4599:     }",
          "4601:     ndpi_str->custom_categories.to_load = NULL;",
          "4602:     ndpi_str->custom_categories.num_to_load = 0;",
          "4604:     if(rc < 0) {",
          "4605:       ndpi_free(ndpi_str->custom_categories.hostnames);",
          "4606:       ndpi_str->custom_categories.hostnames = NULL;",
          "4608:   }",
          "4611:   ac_automata_release((AC_AUTOMATA_t*)ndpi_str->custom_categories.hostnames.ac_automa, 1 /* free patterns strings memory */);",
          "4614:   ac_automata_finalize((AC_AUTOMATA_t*)ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4617:   ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4620:   ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4623:   if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "4624:     ndpi_Destroy_Patricia((patricia_tree_t*)ndpi_str->custom_categories.ipAddresses,",
          "4625:      free_ptree_data);",
          "4627:   ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4628:   ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "4630:   ndpi_str->custom_categories.categories_loaded = 1;",
          "4632:   return(0);",
          "4637: int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str,",
          "4638:        u_int32_t saddr,",
          "4639:        u_int32_t daddr,",
          "4640:        ndpi_protocol *ret) {",
          "4641:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4642:     prefix_t prefix;",
          "4643:     patricia_node_t *node;",
          "4645:     if(saddr == 0)",
          "4646:       node = NULL;",
          "4647:     else {",
          "4649:       fill_prefix_v4(&prefix, (struct in_addr *)&saddr,",
          "4650:        32, ((patricia_tree_t*)ndpi_str->protocols_ptree)->maxbits);",
          "4651:       node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4652:     }",
          "4654:     if(!node) {",
          "4655:       if(daddr != 0) {",
          "4656:  fill_prefix_v4(&prefix, (struct in_addr *)&daddr,",
          "4657:          32, ((patricia_tree_t*)ndpi_str->protocols_ptree)->maxbits);",
          "4658:  node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4659:       }",
          "4660:     }",
          "4662:     if(node) {",
          "4663:       ret->category = (ndpi_protocol_category_t)node->value.user_value;",
          "4664:       return(1);",
          "4666:   }",
          "4668:   ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4670:   return(0);",
          "4675: void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str,",
          "4676:      struct ndpi_flow_struct *flow,",
          "4677:      ndpi_protocol *ret) {",
          "4678:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4679:     if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4680:       flow->category = ret->category = flow->guessed_header_category;",
          "4681:       return;",
          "4682:     }",
          "4684:     if(flow->host_server_name[0] != '\\0') {",
          "4685:       unsigned long id;",
          "4686:       int rc = ndpi_match_custom_category(ndpi_str, (char *)flow->host_server_name,",
          "4687:        strlen((char *)flow->host_server_name), &id);",
          "4689:       if(rc == 0) {",
          "4690:  flow->category = ret->category = (ndpi_protocol_category_t)id;",
          "4691:  return;",
          "4692:       }",
          "4693:     }",
          "4695:     if(flow->l4.tcp.tls.hello_processed == 1 && flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0') {",
          "4696:       unsigned long id;",
          "4697:       int rc = ndpi_match_custom_category(ndpi_str,",
          "4698:        (char *)flow->protos.stun_ssl.ssl.client_requested_server_name,",
          "4699:        strlen(flow->protos.stun_ssl.ssl.client_requested_server_name),",
          "4700:        &id);",
          "4702:       if(rc == 0) {",
          "4703:  flow->category = ret->category = (ndpi_protocol_category_t)id;",
          "4704:  return;",
          "4705:       }",
          "4707:   }",
          "4709:   flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4714: static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {",
          "4715:   packet->parsed_lines = 0,",
          "4716:   packet->empty_line_position_set = 0,",
          "4717:   packet->host_line.ptr = NULL,",
          "4718:   packet->host_line.len = 0,",
          "4719:   packet->referer_line.ptr = NULL,",
          "4720:   packet->referer_line.len = 0,",
          "4721:   packet->content_line.ptr = NULL,",
          "4722:   packet->content_line.len = 0,",
          "4723:   packet->accept_line.ptr = NULL,",
          "4724:   packet->accept_line.len = 0,",
          "4725:   packet->user_agent_line.ptr = NULL,",
          "4726:   packet->user_agent_line.len = 0,",
          "4727:   packet->http_url_name.ptr = NULL,",
          "4728:   packet->http_url_name.len = 0,",
          "4729:   packet->http_encoding.ptr = NULL,",
          "4730:   packet->http_encoding.len = 0,",
          "4731:   packet->http_transfer_encoding.ptr = NULL,",
          "4732:   packet->http_transfer_encoding.len = 0,",
          "4733:   packet->http_contentlen.ptr = NULL,",
          "4734:   packet->http_contentlen.len = 0,",
          "4735:   packet->http_cookie.ptr = NULL,",
          "4736:   packet->http_cookie.len = 0,",
          "4737:   packet->http_origin.len = 0,",
          "4738:   packet->http_origin.ptr = NULL,",
          "4739:   packet->http_x_session_type.ptr = NULL,",
          "4740:   packet->http_x_session_type.len = 0,",
          "4741:   packet->server_line.ptr = NULL,",
          "4742:   packet->server_line.len = 0,",
          "4743:   packet->http_method.ptr = NULL,",
          "4744:   packet->http_method.len = 0,",
          "4745:   packet->http_response.ptr = NULL,",
          "4746:   packet->http_response.len = 0,",
          "4747:   packet->http_num_headers = 0;",
          "4753:          struct ndpi_flow_struct *flow,",
          "4754:          const unsigned char *packet,",
          "4755:          const unsigned short packetlen,",
          "4756:          const u_int64_t current_tick_l,",
          "4757:          struct ndpi_id_struct *src,",
          "4758:          struct ndpi_id_struct *dst) {",
          "4759:   NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "4760:   u_int32_t a;",
          "4761:   ndpi_protocol ret = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };",
          "4763:   if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "4764:     NDPI_LOG(flow ? flow->detected_protocol_stack[0]:NDPI_PROTOCOL_UNKNOWN,",
          "4765:       ndpi_str, NDPI_LOG_TRACE, \"START packet processing\\n\");",
          "4767:   if(flow == NULL)",
          "4768:     return(ret);",
          "4769:   else",
          "4770:     ret.category = flow->category;",
          "4772:   flow->num_processed_pkts++;",
          "4775:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4779:   if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {",
          "4780:     if(flow->check_extra_packets) {",
          "4781:       ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_tick_l, src, dst);",
          "4783:       ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0], ret.category = flow->category;",
          "4784:       goto invalidate_ptr;",
          "4785:     } else",
          "4786:       goto ret_protocols;",
          "4787:   }",
          "4790:   if(packetlen < 20) {",
          "4792:     ndpi_int_reset_packet_protocol(&flow->packet);",
          "4793:     goto invalidate_ptr;",
          "4794:   }",
          "4796:   flow->packet.tick_timestamp_l = current_tick_l;",
          "4797:   flow->packet.tick_timestamp = (u_int32_t)(current_tick_l/ndpi_str->ticks_per_second);",
          "4800:   flow->packet.iph = (struct ndpi_iphdr *)packet;",
          "4803:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4804:     goto invalidate_ptr;",
          "4807:   flow->src = src, flow->dst = dst;",
          "4809:   ndpi_connection_tracking(ndpi_str, flow);",
          "4812:   ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "4813:   if(flow->packet.iph != NULL)",
          "4814:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4816:   if(flow->packet.tcp != NULL)",
          "4817:     ndpi_selection_packet |=",
          "4818:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4820:   if(flow->packet.udp != NULL)",
          "4821:     ndpi_selection_packet |=",
          "4822:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4824:   if(flow->packet.payload_packet_len != 0)",
          "4825:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "4827:   if(flow->packet.tcp_retransmission == 0)",
          "4828:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "4830: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4831:   if(flow->packet.iphv6 != NULL)",
          "4832:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4835:   if((!flow->protocol_id_already_guessed)",
          "4836:      && (",
          "4838:   flow->packet.iphv6 ||",
          "4839: #endif",
          "4840:   flow->packet.iph)) {",
          "4841:     u_int16_t sport, dport;",
          "4842:     u_int8_t protocol;",
          "4843:     u_int8_t user_defined_proto;",
          "4845:     flow->protocol_id_already_guessed = 1;",
          "4848:     if(flow->packet.iphv6 != NULL) {",
          "4849:       protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "4850:     } else",
          "4852:       {",
          "4853:  protocol = flow->packet.iph->protocol;",
          "4854:       }",
          "4856:     if(flow->packet.udp) sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "4857:     else if(flow->packet.tcp) sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "4858:     else sport = dport = 0;",
          "4861:     flow->guessed_protocol_id = (int16_t)ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "4862:     flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4864:     if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "4865:       ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);",
          "4866:       flow->guessed_header_category = ret.category;",
          "4867:     } else",
          "4868:       flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "4870:     if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4872:       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "4873:  ret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "4874:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4875:       goto invalidate_ptr;",
          "4876:     }",
          "4878:     if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4879:       if(flow->packet.iph) {",
          "4880:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4881:    u_int8_t protocol_was_guessed;",
          "4884:    ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4885:  }",
          "4887:  ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4888:  goto invalidate_ptr;",
          "4889:       }",
          "4890:     } else {",
          "4892:       if(flow->packet.iph) {",
          "4893:  struct in_addr addr;",
          "4895:  addr.s_addr = flow->packet.iph->saddr;",
          "4896:  flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4898:  if(flow->guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN) {",
          "4899:    addr.s_addr = flow->packet.iph->daddr;",
          "4900:    flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4901:  }",
          "",
          "[Added Lines]",
          "4329:     if (ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4330:         free(name);",
          "4331:         return (-1);",
          "4335:     ac_pattern.rep.number = (int) category;",
          "4339:         free(name);",
          "4340:         return (-1);",
          "4343:         free(name);",
          "4346:     return (0);",
          "4352: int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,",
          "4353:                        ndpi_protocol_category_t category)",
          "4354: {",
          "4355:     int rv;",
          "4358:     rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4360:     if (rv < 0) {",
          "4362:         rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4363:     }",
          "4365:     return (rv);",
          "4370: int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str)",
          "4371: {",
          "4372:     int i;",
          "4375:     for (i = 0; category_match[i].string_to_match != NULL; i++)",
          "4376:         ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4379:     if (ndpi_str->custom_categories.num_to_load > 0) {",
          "4380:         const char **expressions;",
          "4381:         unsigned int *ids;",
          "4382:         int rc;",
          "4383:         struct hs_list *head = ndpi_str->custom_categories.to_load;",
          "4385:         expressions = (const char **) ndpi_calloc(sizeof(char *), ndpi_str->custom_categories.num_to_load + 1);",
          "4386:         if (!expressions)",
          "4387:             return (-1);",
          "4389:         ids = (unsigned int *) ndpi_calloc(sizeof(unsigned int), ndpi_str->custom_categories.num_to_load + 1);",
          "4390:         if (!ids) {",
          "4391:             ndpi_free(expressions);",
          "4392:             return (-1);",
          "4393:         }",
          "4395:         for (i = 0; head != NULL; i++) {",
          "4397:             printf(\"[HS] Loading category %u for %s\\n\", head->id, head->expression);",
          "4399:             expressions[i] = head->expression, ids[i] = head->id;",
          "4400:             head = head->next;",
          "4401:         }",
          "4403:         if (i != ndpi_str->custom_categories.num_to_load) {",
          "4404:             ndpi_free(expressions);",
          "4405:             return (-1);",
          "4406:         }",
          "4408:         free_hyperscan_memory(ndpi_str->custom_categories.hostnames);",
          "4409:         ndpi_str->custom_categories.hostnames = (struct hs *) ndpi_malloc(sizeof(struct hs));",
          "4411:         if (ndpi_str->custom_categories.hostnames == NULL) {",
          "4412:             ndpi_free(expressions);",
          "4413:             ndpi_free(ids);",
          "4415:         }",
          "4417:         rc = hyperscan_load_patterns(ndpi_str->custom_categories.hostnames, ndpi_str->custom_categories.num_to_load,",
          "4418:                                      expressions, ids);",
          "4419:         ndpi_free(expressions), ndpi_free(ids);",
          "4421:         head = ndpi_str->custom_categories.to_load;",
          "4422:         while (head != NULL) {",
          "4423:             struct hs_list *next = head->next;",
          "4425:             ndpi_free(head->expression);",
          "4426:             ndpi_free(head);",
          "4428:             head = next;",
          "4429:         }",
          "4431:         ndpi_str->custom_categories.to_load = NULL;",
          "4432:         ndpi_str->custom_categories.num_to_load = 0;",
          "4434:         if (rc < 0) {",
          "4435:             ndpi_free(ndpi_str->custom_categories.hostnames);",
          "4436:             ndpi_str->custom_categories.hostnames = NULL;",
          "4437:         }",
          "4441:     ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "4442:                         1 /* free patterns strings memory */);",
          "4445:     ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4448:     ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4451:     ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4454:     if (ndpi_str->custom_categories.ipAddresses != NULL)",
          "4455:         ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "4457:     ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4458:     ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "4460:     ndpi_str->custom_categories.categories_loaded = 1;",
          "4462:     return (0);",
          "4467: int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,",
          "4468:                                    ndpi_protocol *ret)",
          "4469: {",
          "4470:     if (ndpi_str->custom_categories.categories_loaded) {",
          "4471:         prefix_t prefix;",
          "4472:         patricia_node_t *node;",
          "4474:         if (saddr == 0)",
          "4475:             node = NULL;",
          "4476:         else {",
          "4478:             fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,",
          "4479:                            ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4480:             node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4481:         }",
          "4483:         if (!node) {",
          "4484:             if (daddr != 0) {",
          "4485:                 fill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,",
          "4486:                                ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4487:                 node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4488:             }",
          "4489:         }",
          "4491:         if (node) {",
          "4492:             ret->category = (ndpi_protocol_category_t) node->value.user_value;",
          "4493:             return (1);",
          "4494:         }",
          "4497:     ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4499:     return (0);",
          "4504: void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4505:                                  ndpi_protocol *ret)",
          "4506: {",
          "4507:     if (ndpi_str->custom_categories.categories_loaded) {",
          "4508:         if (flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4509:             flow->category = ret->category = flow->guessed_header_category;",
          "4510:             return;",
          "4511:         }",
          "4513:         if (flow->host_server_name[0] != '\\0') {",
          "4514:             unsigned long id;",
          "4515:             int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,",
          "4516:                                                 strlen((char *) flow->host_server_name), &id);",
          "4518:             if (rc == 0) {",
          "4519:                 flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4520:                 return;",
          "4521:             }",
          "4522:         }",
          "4524:         if (flow->l4.tcp.tls.hello_processed == 1 &&",
          "4525:             flow->protos.stun_ssl.ssl.client_requested_server_name[0] != '\\0') {",
          "4526:             unsigned long id;",
          "4527:             int rc =",
          "4528:                 ndpi_match_custom_category(ndpi_str, (char *) flow->protos.stun_ssl.ssl.client_requested_server_name,",
          "4529:                                            strlen(flow->protos.stun_ssl.ssl.client_requested_server_name), &id);",
          "4531:             if (rc == 0) {",
          "4532:                 flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4533:                 return;",
          "4534:             }",
          "4535:         }",
          "4538:     flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4543: static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet)",
          "4544: {",
          "4545:     packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,",
          "4546:     packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,",
          "4547:     packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,",
          "4548:     packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,",
          "4549:     packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,",
          "4550:     packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,",
          "4551:     packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,",
          "4552:     packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,",
          "4553:     packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,",
          "4554:     packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,",
          "4555:     packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;",
          "4561:                                             struct ndpi_flow_struct *flow, const unsigned char *packet,",
          "4562:                                             const unsigned short packetlen, const u_int64_t current_tick_l,",
          "4563:                                             struct ndpi_id_struct *src, struct ndpi_id_struct *dst)",
          "4564: {",
          "4565:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "4566:     u_int32_t a;",
          "4567:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4569:     if (ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "4570:         NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,",
          "4571:                  \"START packet processing\\n\");",
          "4573:     if (flow == NULL)",
          "4574:         return (ret);",
          "4575:     else",
          "4576:         ret.category = flow->category;",
          "4578:     flow->num_processed_pkts++;",
          "4581:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4583:     if (flow->server_id == NULL)",
          "4586:     if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN) {",
          "4587:         if (flow->check_extra_packets) {",
          "4588:             ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_tick_l, src, dst);",
          "4590:             ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0],",
          "4591:             ret.category = flow->category;",
          "4592:             goto invalidate_ptr;",
          "4593:         } else",
          "4594:             goto ret_protocols;",
          "4595:     }",
          "4598:     if (packetlen < 20) {",
          "4600:         ndpi_int_reset_packet_protocol(&flow->packet);",
          "4601:         goto invalidate_ptr;",
          "4602:     }",
          "4604:     flow->packet.tick_timestamp_l = current_tick_l;",
          "4605:     flow->packet.tick_timestamp = (u_int32_t)(current_tick_l / ndpi_str->ticks_per_second);",
          "4608:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4611:     if (ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4612:         goto invalidate_ptr;",
          "4615:     flow->src = src, flow->dst = dst;",
          "4617:     ndpi_connection_tracking(ndpi_str, flow);",
          "4620:     ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "4621:     if (flow->packet.iph != NULL)",
          "4622:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4624:     if (flow->packet.tcp != NULL)",
          "4625:         ndpi_selection_packet |=",
          "4626:             (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4628:     if (flow->packet.udp != NULL)",
          "4629:         ndpi_selection_packet |=",
          "4630:             (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4632:     if (flow->packet.payload_packet_len != 0)",
          "4633:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "4635:     if (flow->packet.tcp_retransmission == 0)",
          "4636:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "4639:     if (flow->packet.iphv6 != NULL)",
          "4640:         ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4643:     if ((!flow->protocol_id_already_guessed) && (",
          "4645:                                                     flow->packet.iphv6 ||",
          "4647:                                                     flow->packet.iph)) {",
          "4648:         u_int16_t sport, dport;",
          "4649:         u_int8_t protocol;",
          "4650:         u_int8_t user_defined_proto;",
          "4652:         flow->protocol_id_already_guessed = 1;",
          "4654: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4655:         if (flow->packet.iphv6 != NULL) {",
          "4656:             protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "4657:         } else",
          "4658: #endif",
          "4659:         {",
          "4660:             protocol = flow->packet.iph->protocol;",
          "4661:         }",
          "4663:         if (flow->packet.udp)",
          "4664:             sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "4665:         else if (flow->packet.tcp)",
          "4666:             sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "4667:         else",
          "4668:             sport = dport = 0;",
          "4671:         flow->guessed_protocol_id =",
          "4672:             (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "4673:         flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4675:         if (ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "4676:             ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);",
          "4677:             flow->guessed_header_category = ret.category;",
          "4678:         } else",
          "4679:             flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "4681:         if (flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4683:             ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "4684:             ret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "4685:             ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4686:             goto invalidate_ptr;",
          "4687:         }",
          "4689:         if (user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4690:             if (flow->packet.iph) {",
          "4691:                 if (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4692:                     u_int8_t protocol_was_guessed;",
          "4695:                     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4696:                 }",
          "4698:                 ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4699:                 goto invalidate_ptr;",
          "4700:             }",
          "4701:         } else {",
          "4703:             if (flow->packet.iph) {",
          "4704:                 struct in_addr addr;",
          "4706:                 addr.s_addr = flow->packet.iph->saddr;",
          "4707:                 flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4709:                 if (flow->guessed_host_protocol_id == NDPI_PROTOCOL_UNKNOWN) {",
          "4710:                     addr.s_addr = flow->packet.iph->daddr;",
          "4711:                     flow->guessed_host_protocol_id = ndpi_network_ptree_match(ndpi_str, &addr);",
          "4712:                 }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "4909:    and extract metadata.",
          "4911: #if SKIP_INVOKING_THE_DISSECTORS",
          "4914:      We have identified a protocol using the IP address so",
          "4915:      it is not worth to dissect the traffic as we already have",
          "4916:      the solution",
          "4921: #endif",
          "4923:     }",
          "4951:     }",
          "4980:       This is a TCP flow",
          "4981:       - whose first packet is NOT a SYN",
          "4982:       - no protocol has been detected",
          "",
          "[Removed Lines]",
          "4912:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4918:    ret.master_protocol = flow->guessed_protocol_id,",
          "4919:      ret.app_protocol = flow->guessed_host_protocol_id;",
          "4920:  }",
          "4922:       }",
          "4924:   }",
          "4926:   if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4928:     ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4930:     ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4931:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4932:     goto invalidate_ptr;",
          "4933:   }",
          "4935:   ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4937:   a = flow->packet.detected_protocol_stack[0];",
          "4938:   if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "4939:     a = NDPI_PROTOCOL_UNKNOWN;",
          "4941:   if(a != NDPI_PROTOCOL_UNKNOWN) {",
          "4942:     int i;",
          "4944:     for(i=0; i<sizeof(flow->host_server_name); i++) {",
          "4945:       if(flow->host_server_name[i] != '\\0')",
          "4946:  flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "4947:       else {",
          "4948:  flow->host_server_name[i] ='\\0';",
          "4949:  break;",
          "4950:       }",
          "4952:   }",
          "4954:  ret_protocols:",
          "4955:   if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "4956:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4958:     if(ret.app_protocol == ret.master_protocol)",
          "4959:       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4960:   } else",
          "4961:     ret.app_protocol = flow->detected_protocol_stack[0];",
          "4964:   if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "4965:      && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4966:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4967:   else",
          "4968:     ret.category = flow->category;",
          "4970:   if((flow->num_processed_pkts == 1)",
          "4971:      && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN)",
          "4972:      && (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN)",
          "4973:      && flow->packet.tcp",
          "4974:      && (flow->packet.tcp->syn == 0)",
          "4975:      && (flow->guessed_protocol_id == 0)",
          "4976:      ) {",
          "4977:     u_int8_t protocol_was_guessed;",
          "",
          "[Added Lines]",
          "4723:                 if (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4729:                     ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4730:                 }",
          "4732:             }",
          "4733:         }",
          "4736:     if (flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4738:         ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4740:         ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4741:         ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4742:         goto invalidate_ptr;",
          "4743:     }",
          "4745:     ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4747:     a = flow->packet.detected_protocol_stack[0];",
          "4748:     if (NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "4749:         a = NDPI_PROTOCOL_UNKNOWN;",
          "4751:     if (a != NDPI_PROTOCOL_UNKNOWN) {",
          "4752:         int i;",
          "4754:         for (i = 0; i < sizeof(flow->host_server_name); i++) {",
          "4755:             if (flow->host_server_name[i] != '\\0')",
          "4756:                 flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "4757:             else {",
          "4758:                 flow->host_server_name[i] = '\\0';",
          "4759:                 break;",
          "4760:             }",
          "4761:         }",
          "4764: ret_protocols:",
          "4765:     if (flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "4766:         ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4768:         if (ret.app_protocol == ret.master_protocol)",
          "4769:             ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4770:     } else",
          "4771:         ret.app_protocol = flow->detected_protocol_stack[0];",
          "4774:     if ((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4775:         ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4776:     else",
          "4777:         ret.category = flow->category;",
          "4779:     if ((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&",
          "4780:         (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&",
          "4781:         (flow->guessed_protocol_id == 0)) {",
          "4782:         u_int8_t protocol_was_guessed;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "4984:       We don't see how future packets can match anything",
          "4985:       hence we giveup here",
          "4999:      Invalidate packet memory to avoid accessing the pointers below",
          "5000:      when the packet is no longer accessible",
          "5006: }",
          "5011: {",
          "5025: }",
          "5029: #ifdef CODE_UNUSED",
          "5062: }",
          "5064: #endif",
          "5081: }",
          "5116: }",
          "5154: }",
          "5388:     }",
          "5397: }",
          "5403: {",
          "5440:     }",
          "5442: }",
          "5524: }",
          "5526: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "5531: {",
          "5542: }",
          "5543: #endif",
          "5552: }",
          "5577: }",
          "5584: }",
          "5595:     flow->detected_protocol_stack[1] = lower_detected_protocol;",
          "5596: }",
          "5614:     packet->detected_protocol_stack[1] = lower_detected_protocol;",
          "5615: }",
          "",
          "[Removed Lines]",
          "4987:     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4988:   }",
          "4990:   if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN)",
          "4991:      && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "4992:      && (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4993:     ret.master_protocol = ret.app_protocol;",
          "4994:     ret.app_protocol = flow->guessed_host_protocol_id;",
          "4995:   }",
          "4997:  invalidate_ptr:",
          "5002:   flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "5003:   ndpi_reset_packet_line_info(&flow->packet);",
          "5005:   return(ret);",
          "5010: u_int32_t ndpi_bytestream_to_number(const u_int8_t * str, u_int16_t max_chars_to_read, u_int16_t * bytes_read)",
          "5012:   u_int32_t val;",
          "5013:   val = 0;",
          "5016:   while(*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "5017:     val *= 10;",
          "5018:     val += *str - '0';",
          "5019:     str++;",
          "5020:     max_chars_to_read = max_chars_to_read - 1;",
          "5022:   }",
          "5024:   return(val);",
          "5030: u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t * str, u_int16_t max_chars_to_read,",
          "5031:             u_int16_t * bytes_read) {",
          "5032:   u_int32_t val;",
          "5033:   val = 0;",
          "5034:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5035:     return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "5036:   } else {",
          "5038:     str += 2;",
          "5039:     max_chars_to_read -= 2;",
          "5042:     while(max_chars_to_read > 0) {",
          "5043:       if(*str >= '0' && *str <= '9') {",
          "5044:  val *= 16;",
          "5045:  val += *str - '0';",
          "5046:       } else if(*str >= 'a' && *str <= 'f') {",
          "5047:  val *= 16;",
          "5048:  val += *str + 10 - 'a';",
          "5049:       } else if(*str >= 'A' && *str <= 'F') {",
          "5050:  val *= 16;",
          "5051:  val += *str + 10 - 'A';",
          "5052:       } else {",
          "5053:  break;",
          "5054:       }",
          "5055:       str++;",
          "5056:       max_chars_to_read = max_chars_to_read - 1;",
          "5058:     }",
          "5059:   }",
          "5061:   return(val);",
          "5068: u_int64_t ndpi_bytestream_to_number64(const u_int8_t * str, u_int16_t max_chars_to_read,",
          "5069:           u_int16_t * bytes_read) {",
          "5070:   u_int64_t val;",
          "5071:   val = 0;",
          "5073:   while(max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "5074:     val *= 10;",
          "5075:     val += *str - '0';",
          "5076:     str++;",
          "5077:     max_chars_to_read = max_chars_to_read - 1;",
          "5079:   }",
          "5080:   return(val);",
          "5085: u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t * str, u_int16_t max_chars_to_read, u_int16_t * bytes_read)",
          "5086: {",
          "5087:   u_int64_t val;",
          "5088:   val = 0;",
          "5089:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5090:     return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "5091:   } else {",
          "5093:     str += 2;",
          "5094:     max_chars_to_read -= 2;",
          "5096:     while(max_chars_to_read > 0) {",
          "5098:       if(*str >= '0' && *str <= '9') {",
          "5099:  val *= 16;",
          "5100:  val += *str - '0';",
          "5101:       } else if(*str >= 'a' && *str <= 'f') {",
          "5102:  val *= 16;",
          "5103:  val += *str + 10 - 'a';",
          "5104:       } else if(*str >= 'A' && *str <= 'F') {",
          "5105:  val *= 16;",
          "5106:  val += *str + 10 - 'A';",
          "5107:       } else {",
          "5108:  break;",
          "5109:       }",
          "5110:       str++;",
          "5111:       max_chars_to_read = max_chars_to_read - 1;",
          "5113:     }",
          "5114:   }",
          "5115:   return(val);",
          "5120: u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t * str, u_int16_t max_chars_to_read, u_int16_t * bytes_read)",
          "5121: {",
          "5122:   u_int32_t val;",
          "5123:   u_int16_t read = 0;",
          "5124:   u_int16_t oldread;",
          "5125:   u_int32_t c;",
          "5127:   oldread = read;",
          "5128:   c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "5129:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5130:     return(0);",
          "5131:   read++;",
          "5132:   val = c << 24;",
          "5133:   oldread = read;",
          "5134:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5135:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5136:     return(0);",
          "5137:   read++;",
          "5138:   val = val + (c << 16);",
          "5139:   oldread = read;",
          "5140:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5141:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5142:     return(0);",
          "5143:   read++;",
          "5144:   val = val + (c << 8);",
          "5145:   oldread = read;",
          "5146:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5147:   if(c > 255 || oldread == read || max_chars_to_read == read)",
          "5148:     return(0);",
          "5149:   val = val + c;",
          "5153:   return(htonl(val));",
          "5159: void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str,",
          "5160:      struct ndpi_flow_struct *flow)",
          "5161: {",
          "5162:   u_int32_t a;",
          "5163:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5165:   if(packet->packet_lines_parsed_complete != 0)",
          "5166:     return;",
          "5168:   packet->packet_lines_parsed_complete = 1;",
          "5169:   ndpi_reset_packet_line_info(packet);",
          "5171:   if((packet->payload_packet_len < 3)",
          "5172:      || (packet->payload == NULL))",
          "5173:     return;",
          "5175:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5176:   packet->line[packet->parsed_lines].len = 0;",
          "5178:   for(a = 0; (a < packet->payload_packet_len)",
          "5179:  && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "5180:     if((a + 1) >= packet->payload_packet_len)",
          "5184:       packet->line[packet->parsed_lines].len = (u_int16_t)(((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5187:       if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "5188:   strncasecmp((const char *)packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "5190:   packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "5191:  packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "5192:  packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "5193:  packet->http_num_headers++;",
          "5196:  if(packet->payload_packet_len >= 12) {",
          "5197:    char buf[4];",
          "5200:    strncpy(buf, (char*)&packet->payload[9], 3);",
          "5201:    buf[3] = '\\0';",
          "5203:    flow->http.response_status_code = atoi(buf);",
          "5205:    if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "5207:  }",
          "5208:       }",
          "5211:       if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1",
          "5212:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "5214:         if(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "5215:           packet->server_line.ptr =",
          "5216:             &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "5217:           packet->server_line.len =",
          "5218:             packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "5219:         } else {",
          "5220:           packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "5221:           packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "5222:         }",
          "5223:         packet->http_num_headers++;",
          "5224:       }",
          "5226:       if(packet->line[packet->parsed_lines].len > 6",
          "5227:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr,",
          "5228:    \"Host:\", 5) == 0) {",
          "5230:         if(packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "5231:           packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "5232:           packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "5233:         } else {",
          "5234:           packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "5235:           packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "5236:         }",
          "5237:         packet->http_num_headers++;",
          "5238:       }",
          "5240:       if(packet->line[packet->parsed_lines].len > 17",
          "5241:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "5243:         if(packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "5244:           packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "5245:           packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "5246:         } else {",
          "5247:           packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5248:           packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "5249:         }",
          "5250:         packet->http_num_headers++;",
          "5251:       }",
          "5253:       if(packet->line[packet->parsed_lines].len > 14",
          "5254:   && (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0",
          "5255:       || strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5256:         packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5257:         packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5259:  while((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5260:    packet->content_line.len--, packet->content_line.ptr++;",
          "5262:         packet->http_num_headers++;",
          "5263:       }",
          "5265:       if((packet->content_line.len == 0)",
          "5266:   && (packet->line[packet->parsed_lines].len > 13)",
          "5267:   && (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5268:         packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5269:         packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5270:         packet->http_num_headers++;",
          "5271:       }",
          "5273:       if(packet->content_line.len > 0) {",
          "5275:  char separator[] = { ';', '\\r', '\\0' };",
          "5276:  int i;",
          "5278:  for(i=0; separator[i] != '\\0'; i++) {",
          "5279:    char *c = memchr((char*)packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5281:    if(c != NULL)",
          "5282:      packet->content_line.len = c - (char*)packet->content_line.ptr;",
          "5283:  }",
          "5284:       }",
          "5287:       if(packet->line[packet->parsed_lines].len > 8",
          "5288:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5289:         packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5290:         packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5291:         packet->http_num_headers++;",
          "5292:       }",
          "5294:       if(packet->line[packet->parsed_lines].len > 9",
          "5295:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5296:         packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5297:         packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5298:         packet->http_num_headers++;",
          "5299:       }",
          "5301:       if(packet->line[packet->parsed_lines].len > 12",
          "5302:   && (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0",
          "5303:       || strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5304:         packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5305:         packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5306:         packet->http_num_headers++;",
          "5307:       }",
          "5309:       if(packet->line[packet->parsed_lines].len > 18",
          "5310:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5311:         packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5312:         packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5313:         packet->http_num_headers++;",
          "5314:       }",
          "5316:       if(packet->line[packet->parsed_lines].len > 19",
          "5317:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5318:         packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5319:         packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5320:         packet->http_num_headers++;",
          "5321:       }",
          "5323:       if(packet->line[packet->parsed_lines].len > 16",
          "5324:   && ((strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0)",
          "5325:       || (strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5326:         packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5327:         packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5328:         packet->http_num_headers++;",
          "5329:       }",
          "5331:       if(packet->line[packet->parsed_lines].len > 8",
          "5332:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5333:         packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5334:         packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5335:         packet->http_num_headers++;",
          "5336:       }",
          "5338:       if(packet->line[packet->parsed_lines].len > 8",
          "5339:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5340:         packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5341:         packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5342:         packet->http_num_headers++;",
          "5343:       }",
          "5345:       if(packet->line[packet->parsed_lines].len > 16",
          "5346:   && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5347:         packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5348:         packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5349:         packet->http_num_headers++;",
          "5350:       }",
          "5357:       if((packet->line[packet->parsed_lines].len >  6 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5358:                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5359:                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0 )) ||",
          "5360:          (packet->line[packet->parsed_lines].len >  8 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5361:          (packet->line[packet->parsed_lines].len >  9 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5362:          (packet->line[packet->parsed_lines].len > 12 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5363:                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5364:                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5365:          (packet->line[packet->parsed_lines].len > 15 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5366:                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5367:          (packet->line[packet->parsed_lines].len > 17 && ( strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5368:                                                            strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5369:          (packet->line[packet->parsed_lines].len > 27 && strncasecmp((const char *)packet->line[packet->parsed_lines].ptr, \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5371:         packet->http_num_headers++;",
          "5372:       }",
          "5375:       if(packet->line[packet->parsed_lines].len == 0) {",
          "5376:         packet->empty_line_position = a;",
          "5377:         packet->empty_line_position_set = 1;",
          "5378:       }",
          "5380:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5381:         return;",
          "5383:       packet->parsed_lines++;",
          "5384:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5385:       packet->line[packet->parsed_lines].len = 0;",
          "5389:   }",
          "5391:   if(packet->parsed_lines >= 1) {",
          "5392:     packet->line[packet->parsed_lines].len",
          "5393:       = (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -",
          "5394:       ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5395:     packet->parsed_lines++;",
          "5396:   }",
          "5401: void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str,",
          "5402:          struct ndpi_flow_struct *flow)",
          "5404:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5405:   u_int32_t a;",
          "5406:   u_int16_t end = packet->payload_packet_len;",
          "5408:   if(packet->packet_lines_parsed_complete != 0)",
          "5409:     return;",
          "5411:   packet->packet_lines_parsed_complete = 1;",
          "5412:   packet->parsed_lines = 0;",
          "5414:   if(packet->payload_packet_len == 0)",
          "5415:     return;",
          "5417:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5418:   packet->line[packet->parsed_lines].len = 0;",
          "5420:   for(a = 0; a < end; a++) {",
          "5421:     if(packet->payload[a] == 0x0a) {",
          "5422:       packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5423:           ((unsigned long) &packet->payload[a]) -",
          "5424:           ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5426:       if(a > 0 && packet->payload[a-1] == 0x0d)",
          "5427:         packet->line[packet->parsed_lines].len--;",
          "5429:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5430:         break;",
          "5432:       packet->parsed_lines++;",
          "5433:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5434:       packet->line[packet->parsed_lines].len = 0;",
          "5436:       if((a + 1) >= packet->payload_packet_len)",
          "5437:         break;",
          "5441:   }",
          "5446: u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str,",
          "5447:            struct ndpi_flow_struct *flow, u_int16_t counter)",
          "5448: {",
          "5450:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5452:   NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5454:   if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z')",
          "5455:            || (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z')",
          "5456:            || (packet->payload[counter] >= '0' && packet->payload[counter] <= '9')",
          "5457:            || packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5458:     NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5459:     counter++;",
          "5460:     while(packet->payload_packet_len > counter",
          "5461:     && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z')",
          "5462:         || (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z')",
          "5463:         || (packet->payload[counter] >= '0' && packet->payload[counter] <= '9')",
          "5464:         || packet->payload[counter] == '-' || packet->payload[counter] == '_'",
          "5465:         || packet->payload[counter] == '.')) {",
          "5466:       NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5467:       counter++;",
          "5468:       if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5469:  NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5470:  counter++;",
          "5471:  while(packet->payload_packet_len > counter",
          "5472:         && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z')",
          "5473:      || (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z')",
          "5474:      || (packet->payload[counter] >= '0' && packet->payload[counter] <= '9')",
          "5475:      || packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5476:    NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5477:    counter++;",
          "5478:    if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5479:      NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5480:      counter++;",
          "5481:      if(packet->payload_packet_len > counter + 1",
          "5482:         && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z')",
          "5483:      && (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5484:        NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5485:        counter += 2;",
          "5486:        if(packet->payload_packet_len > counter",
          "5487:    && (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5488:   NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5489:   return(counter);",
          "5490:        } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a'",
          "5491:    && packet->payload[counter] <= 'z') {",
          "5492:   NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5493:   counter++;",
          "5494:   if(packet->payload_packet_len > counter",
          "5495:      && (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5496:     NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5497:     return(counter);",
          "5498:   } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a'",
          "5499:      && packet->payload[counter] <= 'z') {",
          "5500:     counter++;",
          "5501:     if(packet->payload_packet_len > counter",
          "5502:        && (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5503:       NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "5504:       return(counter);",
          "5505:     } else {",
          "5506:       return(0);",
          "5507:     }",
          "5508:   } else {",
          "5509:     return(0);",
          "5510:   }",
          "5511:        } else {",
          "5512:   return(0);",
          "5513:        }",
          "5514:      } else {",
          "5515:        return(0);",
          "5516:      }",
          "5517:    }",
          "5518:  }",
          "5519:  return(0);",
          "5520:       }",
          "5521:     }",
          "5522:   }",
          "5523:   return(0);",
          "5529: void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct",
          "5535:   if(ndpi_str->ndpi_debug_print_file != NULL)",
          "5538:   if(ndpi_str->ndpi_debug_print_function != NULL)",
          "5547: u_int8_t ndpi_detection_get_l4(const u_int8_t * l3, u_int16_t l3_len,",
          "5548:           const u_int8_t ** l4_return, u_int16_t * l4_len_return,",
          "5549:           u_int8_t * l4_protocol_return, u_int32_t flags) {",
          "5550:   return(ndpi_detection_get_l4_internal(NULL, l3, l3_len,",
          "5551:      l4_return, l4_len_return, l4_protocol_return, flags));",
          "5556: void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5557:     struct ndpi_flow_struct *flow,",
          "5558:     u_int16_t upper_detected_protocol,",
          "5559:     u_int16_t lower_detected_protocol) {",
          "5560:   struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5562:   ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5564:   if(src != NULL) {",
          "5565:     NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5567:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5568:       NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5569:   }",
          "5571:   if(dst != NULL) {",
          "5572:     NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5574:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5575:       NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5576:   }",
          "5581: u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5582:            struct ndpi_flow_struct *flow) {",
          "5583:   return(flow->detected_protocol_stack[1]);",
          "5588: void ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5589:        struct ndpi_flow_struct *flow,",
          "5590:        u_int16_t upper_detected_protocol,",
          "5591:        u_int16_t lower_detected_protocol) {",
          "5592:   if(!flow) return;",
          "5594:   flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5600: void ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5601:          struct ndpi_flow_struct *flow,",
          "5602:          u_int16_t upper_detected_protocol,",
          "5603:          u_int16_t lower_detected_protocol) {",
          "5604:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5610:   if(!packet)",
          "5611:     return;",
          "5613:   packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "",
          "[Added Lines]",
          "4792:         ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4793:     }",
          "4795:     if ((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&",
          "4796:         (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4797:         ret.master_protocol = ret.app_protocol;",
          "4798:         ret.app_protocol = flow->guessed_host_protocol_id;",
          "4799:     }",
          "4801: invalidate_ptr:",
          "4806:     flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "4807:     ndpi_reset_packet_line_info(&flow->packet);",
          "4809:     return (ret);",
          "4814: u_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4816:     u_int32_t val;",
          "4817:     val = 0;",
          "4820:     while (*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "4821:         val *= 10;",
          "4822:         val += *str - '0';",
          "4823:         str++;",
          "4824:         max_chars_to_read = max_chars_to_read - 1;",
          "4826:     }",
          "4828:     return (val);",
          "4834: u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4835: {",
          "4836:     u_int32_t val;",
          "4837:     val = 0;",
          "4838:     if (max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "4839:         return (ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "4840:     } else {",
          "4842:         str += 2;",
          "4843:         max_chars_to_read -= 2;",
          "4846:         while (max_chars_to_read > 0) {",
          "4847:             if (*str >= '0' && *str <= '9') {",
          "4848:                 val *= 16;",
          "4849:                 val += *str - '0';",
          "4850:             } else if (*str >= 'a' && *str <= 'f') {",
          "4851:                 val *= 16;",
          "4852:                 val += *str + 10 - 'a';",
          "4853:             } else if (*str >= 'A' && *str <= 'F') {",
          "4854:                 val *= 16;",
          "4855:                 val += *str + 10 - 'A';",
          "4856:             } else {",
          "4857:                 break;",
          "4858:             }",
          "4859:             str++;",
          "4860:             max_chars_to_read = max_chars_to_read - 1;",
          "4862:         }",
          "4863:     }",
          "4865:     return (val);",
          "4872: u_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4873: {",
          "4874:     u_int64_t val;",
          "4875:     val = 0;",
          "4877:     while (max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "4878:         val *= 10;",
          "4879:         val += *str - '0';",
          "4880:         str++;",
          "4881:         max_chars_to_read = max_chars_to_read - 1;",
          "4883:     }",
          "4884:     return (val);",
          "4889: u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,",
          "4890:                                                  u_int16_t *bytes_read)",
          "4891: {",
          "4892:     u_int64_t val;",
          "4893:     val = 0;",
          "4894:     if (max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "4895:         return (ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "4896:     } else {",
          "4898:         str += 2;",
          "4899:         max_chars_to_read -= 2;",
          "4901:         while (max_chars_to_read > 0) {",
          "4902:             if (*str >= '0' && *str <= '9') {",
          "4903:                 val *= 16;",
          "4904:                 val += *str - '0';",
          "4905:             } else if (*str >= 'a' && *str <= 'f') {",
          "4906:                 val *= 16;",
          "4907:                 val += *str + 10 - 'a';",
          "4908:             } else if (*str >= 'A' && *str <= 'F') {",
          "4909:                 val *= 16;",
          "4910:                 val += *str + 10 - 'A';",
          "4911:             } else {",
          "4912:                 break;",
          "4913:             }",
          "4914:             str++;",
          "4915:             max_chars_to_read = max_chars_to_read - 1;",
          "4917:         }",
          "4918:     }",
          "4919:     return (val);",
          "4924: u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "4925: {",
          "4926:     u_int32_t val;",
          "4927:     u_int16_t read = 0;",
          "4928:     u_int16_t oldread;",
          "4929:     u_int32_t c;",
          "4931:     oldread = read;",
          "4932:     c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "4933:     if (c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4934:         return (0);",
          "4935:     read++;",
          "4936:     val = c << 24;",
          "4937:     oldread = read;",
          "4938:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4939:     if (c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4940:         return (0);",
          "4941:     read++;",
          "4942:     val = val + (c << 16);",
          "4943:     oldread = read;",
          "4944:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4945:     if (c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "4946:         return (0);",
          "4947:     read++;",
          "4948:     val = val + (c << 8);",
          "4949:     oldread = read;",
          "4950:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "4951:     if (c > 255 || oldread == read || max_chars_to_read == read)",
          "4952:         return (0);",
          "4953:     val = val + c;",
          "4957:     return (htonl(val));",
          "4963: void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "4964: {",
          "4965:     u_int32_t a;",
          "4966:     struct ndpi_packet_struct *packet = &flow->packet;",
          "4968:     if (packet->packet_lines_parsed_complete != 0)",
          "4969:         return;",
          "4971:     packet->packet_lines_parsed_complete = 1;",
          "4972:     ndpi_reset_packet_line_info(packet);",
          "4974:     if ((packet->payload_packet_len < 3) || (packet->payload == NULL))",
          "4975:         return;",
          "4977:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "4978:     packet->line[packet->parsed_lines].len = 0;",
          "4980:     for (a = 0; (a < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "4981:         if ((a + 1) >= packet->payload_packet_len)",
          "4984:         if (get_u_int16_t(packet->payload, a) ==",
          "4986:             packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "4987:                 ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "4990:             if (packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "4991:                 strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "4993:                 packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "4994:                 packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "4995:                 packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "4996:                 packet->http_num_headers++;",
          "4999:                 if (packet->payload_packet_len >= 12) {",
          "5000:                     char buf[4];",
          "5003:                     strncpy(buf, (char *) &packet->payload[9], 3);",
          "5004:                     buf[3] = '\\0';",
          "5006:                     flow->http.response_status_code = atoi(buf);",
          "5008:                     if ((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "5010:                 }",
          "5011:             }",
          "5014:             if (packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&",
          "5015:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5016:                             \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "5018:                 if (packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "5019:                     packet->server_line.ptr =",
          "5020:                         &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "5021:                     packet->server_line.len =",
          "5022:                         packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "5023:                 } else {",
          "5024:                     packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "5025:                     packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "5026:                 }",
          "5027:                 packet->http_num_headers++;",
          "5028:             }",
          "5030:             if (packet->line[packet->parsed_lines].len > 6 &&",
          "5031:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {",
          "5033:                 if (packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "5034:                     packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "5035:                     packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "5036:                 } else {",
          "5037:                     packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "5038:                     packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "5039:                 }",
          "5040:                 packet->http_num_headers++;",
          "5041:             }",
          "5043:             if (packet->line[packet->parsed_lines].len > 17 &&",
          "5044:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "5046:                 if (packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "5047:                     packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "5048:                     packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "5049:                 } else {",
          "5050:                     packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5051:                     packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "5052:                 }",
          "5053:                 packet->http_num_headers++;",
          "5054:             }",
          "5056:             if (packet->line[packet->parsed_lines].len > 14 &&",
          "5057:                 (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||",
          "5058:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5059:                 packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5060:                 packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5062:                 while ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5063:                     packet->content_line.len--, packet->content_line.ptr++;",
          "5065:                 packet->http_num_headers++;",
          "5066:             }",
          "5068:             if ((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&",
          "5069:                 (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5070:                 packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5071:                 packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5072:                 packet->http_num_headers++;",
          "5073:             }",
          "5075:             if (packet->content_line.len > 0) {",
          "5077:                 char separator[] = {';', '\\r', '\\0'};",
          "5078:                 int i;",
          "5080:                 for (i = 0; separator[i] != '\\0'; i++) {",
          "5081:                     char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5083:                     if (c != NULL)",
          "5084:                         packet->content_line.len = c - (char *) packet->content_line.ptr;",
          "5085:                 }",
          "5086:             }",
          "5089:             if (packet->line[packet->parsed_lines].len > 8 &&",
          "5090:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5091:                 packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5092:                 packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5093:                 packet->http_num_headers++;",
          "5094:             }",
          "5096:             if (packet->line[packet->parsed_lines].len > 9 &&",
          "5097:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5098:                 packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5099:                 packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5100:                 packet->http_num_headers++;",
          "5101:             }",
          "5103:             if (packet->line[packet->parsed_lines].len > 12 &&",
          "5104:                 (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||",
          "5105:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5106:                 packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5107:                 packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5108:                 packet->http_num_headers++;",
          "5109:             }",
          "5111:             if (packet->line[packet->parsed_lines].len > 18 &&",
          "5112:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5113:                 packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5114:                 packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5115:                 packet->http_num_headers++;",
          "5116:             }",
          "5118:             if (packet->line[packet->parsed_lines].len > 19 &&",
          "5119:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5120:                 packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5121:                 packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5122:                 packet->http_num_headers++;",
          "5123:             }",
          "5125:             if (packet->line[packet->parsed_lines].len > 16 &&",
          "5126:                 ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||",
          "5127:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5128:                 packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5129:                 packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5130:                 packet->http_num_headers++;",
          "5131:             }",
          "5133:             if (packet->line[packet->parsed_lines].len > 8 &&",
          "5134:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5135:                 packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5136:                 packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5137:                 packet->http_num_headers++;",
          "5138:             }",
          "5140:             if (packet->line[packet->parsed_lines].len > 8 &&",
          "5141:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5142:                 packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5143:                 packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5144:                 packet->http_num_headers++;",
          "5145:             }",
          "5147:             if (packet->line[packet->parsed_lines].len > 16 &&",
          "5148:                 strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5149:                 packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5150:                 packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5151:                 packet->http_num_headers++;",
          "5152:             }",
          "5159:             if ((packet->line[packet->parsed_lines].len > 6 &&",
          "5160:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5161:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5162:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||",
          "5163:                 (packet->line[packet->parsed_lines].len > 8 &&",
          "5164:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5165:                 (packet->line[packet->parsed_lines].len > 9 &&",
          "5166:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5167:                 (packet->line[packet->parsed_lines].len > 12 &&",
          "5168:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5169:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5170:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5171:                 (packet->line[packet->parsed_lines].len > 15 &&",
          "5172:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5173:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5174:                 (packet->line[packet->parsed_lines].len > 17 &&",
          "5175:                  (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5176:                   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5177:                 (packet->line[packet->parsed_lines].len > 27 &&",
          "5178:                  strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5179:                              \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5181:                 packet->http_num_headers++;",
          "5182:             }",
          "5184:             if (packet->line[packet->parsed_lines].len == 0) {",
          "5185:                 packet->empty_line_position = a;",
          "5186:                 packet->empty_line_position_set = 1;",
          "5187:             }",
          "5189:             if (packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5190:                 return;",
          "5192:             packet->parsed_lines++;",
          "5193:             packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5194:             packet->line[packet->parsed_lines].len = 0;",
          "5197:         }",
          "5200:     if (packet->parsed_lines >= 1) {",
          "5201:         packet->line[packet->parsed_lines].len =",
          "5202:             (u_int16_t)(((unsigned long) &packet->payload[packet->payload_packet_len]) -",
          "5203:                         ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5204:         packet->parsed_lines++;",
          "5205:     }",
          "5210: void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "5212:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5213:     u_int32_t a;",
          "5214:     u_int16_t end = packet->payload_packet_len;",
          "5216:     if (packet->packet_lines_parsed_complete != 0)",
          "5217:         return;",
          "5219:     packet->packet_lines_parsed_complete = 1;",
          "5220:     packet->parsed_lines = 0;",
          "5222:     if (packet->payload_packet_len == 0)",
          "5223:         return;",
          "5225:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5226:     packet->line[packet->parsed_lines].len = 0;",
          "5228:     for (a = 0; a < end; a++) {",
          "5229:         if (packet->payload[a] == 0x0a) {",
          "5230:             packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5231:                 ((unsigned long) &packet->payload[a]) - ((unsigned long) packet->line[packet->parsed_lines].ptr));",
          "5233:             if (a > 0 && packet->payload[a - 1] == 0x0d)",
          "5234:                 packet->line[packet->parsed_lines].len--;",
          "5236:             if (packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5237:                 break;",
          "5239:             packet->parsed_lines++;",
          "5240:             packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5241:             packet->line[packet->parsed_lines].len = 0;",
          "5243:             if ((a + 1) >= packet->payload_packet_len)",
          "5244:                 break;",
          "5247:         }",
          "5253: u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5254:                                        u_int16_t counter)",
          "5255: {",
          "5256:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5258:     NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5260:     if (packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5261:                                                  (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5262:                                                  (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5263:                                                  packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5264:         NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5265:         counter++;",
          "5266:         while (packet->payload_packet_len > counter &&",
          "5267:                ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5268:                 (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5269:                 (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5270:                 packet->payload[counter] == '-' || packet->payload[counter] == '_' ||",
          "5271:                 packet->payload[counter] == '.')) {",
          "5272:             NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5273:             counter++;",
          "5274:             if (packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5275:                 NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5276:                 counter++;",
          "5277:                 while (packet->payload_packet_len > counter &&",
          "5278:                        ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5279:                         (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5280:                         (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5281:                         packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5282:                     NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5283:                     counter++;",
          "5284:                     if (packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5285:                         NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5286:                         counter++;",
          "5287:                         if (packet->payload_packet_len > counter + 1 &&",
          "5288:                             ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&",
          "5289:                              (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5290:                             NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5291:                             counter += 2;",
          "5292:                             if (packet->payload_packet_len > counter &&",
          "5293:                                 (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5294:                                 NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5295:                                 return (counter);",
          "5296:                             } else if (packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5297:                                        packet->payload[counter] <= 'z') {",
          "5298:                                 NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5299:                                 counter++;",
          "5300:                                 if (packet->payload_packet_len > counter &&",
          "5301:                                     (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5302:                                     NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5303:                                     return (counter);",
          "5304:                                 } else if (packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5305:                                            packet->payload[counter] <= 'z') {",
          "5306:                                     counter++;",
          "5307:                                     if (packet->payload_packet_len > counter &&",
          "5308:                                         (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5309:                                         NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "5310:                                         return (counter);",
          "5311:                                     } else {",
          "5312:                                         return (0);",
          "5313:                                     }",
          "5314:                                 } else {",
          "5315:                                     return (0);",
          "5316:                                 }",
          "5317:                             } else {",
          "5318:                                 return (0);",
          "5319:                             }",
          "5320:                         } else {",
          "5321:                             return (0);",
          "5322:                         }",
          "5323:                     }",
          "5324:                 }",
          "5325:                 return (0);",
          "5326:             }",
          "5327:         }",
          "5328:     }",
          "5329:     return (0);",
          "5335: void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,",
          "5336:                                            const char **func, u_int32_t *line)",
          "5341:     if (ndpi_str->ndpi_debug_print_file != NULL)",
          "5344:     if (ndpi_str->ndpi_debug_print_function != NULL)",
          "5353: u_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,",
          "5354:                                u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags)",
          "5355: {",
          "5356:     return (ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));",
          "5361: void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5362:                                 u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5363: {",
          "5364:     struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5366:     ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5368:     if (src != NULL) {",
          "5369:         NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5371:         if (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5372:             NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5373:     }",
          "5375:     if (dst != NULL) {",
          "5376:         NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5378:         if (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5379:             NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5380:     }",
          "5385: u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "5386: {",
          "5387:     return (flow->detected_protocol_stack[1]);",
          "5392: void ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5393:                                    u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5394: {",
          "5395:     if (!flow)",
          "5396:         return;",
          "5398:     flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5404: void ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5405:                                      u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5406: {",
          "5407:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5413:     if (!packet)",
          "5414:         return;",
          "5416:     packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "5651: }",
          "5659: }",
          "5669: }",
          "5680: }",
          "5686: }",
          "5690: #ifdef CODE_UNUSED",
          "5693: {",
          "5695: }",
          "5696: #endif",
          "",
          "[Removed Lines]",
          "5625: void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5626:          struct ndpi_flow_struct *flow,",
          "5627:          u_int16_t upper_detected_protocol,",
          "5628:          u_int16_t lower_detected_protocol) {",
          "5629:   if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN)",
          "5630:      && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5631:     upper_detected_protocol = lower_detected_protocol;",
          "5633:   if(upper_detected_protocol == lower_detected_protocol)",
          "5634:     lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5636:   if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5637:      && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5638:     if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "5639:        && (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5640:       if(ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {",
          "5641:  lower_detected_protocol = upper_detected_protocol;",
          "5642:  upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5643:       }",
          "5644:     }",
          "5645:   }",
          "5647:   ndpi_int_change_flow_protocol(ndpi_str, flow,",
          "5648:     upper_detected_protocol, lower_detected_protocol);",
          "5649:   ndpi_int_change_packet_protocol(ndpi_str, flow,",
          "5650:       upper_detected_protocol, lower_detected_protocol);",
          "5655: void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str,",
          "5656:          struct ndpi_flow_struct *flow,",
          "5657:          ndpi_protocol_category_t protocol_category) {",
          "5658:   flow->category = protocol_category;",
          "5664: void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {",
          "5665:   int a;",
          "5667:   for(a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5668:     packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5673: void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {",
          "5674:   if(flow) {",
          "5675:     int a;",
          "5677:     for(a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5678:       flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5679:   }",
          "5684: void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t * ip) {",
          "5685:   memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "5692: int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t * ip)",
          "5694:   return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "",
          "[Added Lines]",
          "5428: void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5429:                               u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol)",
          "5430: {",
          "5431:     if ((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5432:         upper_detected_protocol = lower_detected_protocol;",
          "5434:     if (upper_detected_protocol == lower_detected_protocol)",
          "5435:         lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5437:     if ((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5438:         if ((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "5439:             (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5440:             if (ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {",
          "5441:                 lower_detected_protocol = upper_detected_protocol;",
          "5442:                 upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5443:             }",
          "5444:         }",
          "5445:     }",
          "5447:     ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5448:     ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5453: void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5454:                               ndpi_protocol_category_t protocol_category)",
          "5455: {",
          "5456:     flow->category = protocol_category;",
          "5462: void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet)",
          "5463: {",
          "5464:     int a;",
          "5466:     for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5467:         packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5472: void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow)",
          "5473: {",
          "5474:     if (flow) {",
          "5475:         int a;",
          "5477:         for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5478:             flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5479:     }",
          "5484: void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip)",
          "5485: {",
          "5486:     memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "5493: int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip)",
          "5495:     return (memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "5703: {",
          "5705: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5718: #endif",
          "5724: }",
          "5730: {",
          "5732: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5745: #endif",
          "5752: }",
          "5759: {",
          "5762: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5773: #endif",
          "5777: }",
          "5784: {",
          "5787: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5798: #endif",
          "5801: }",
          "5806: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5810: #else",
          "5812: #endif",
          "5813: }",
          "5820: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5827: #endif",
          "5833: }",
          "5845: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5849: #endif",
          "5853: }",
          "5862: }",
          "5868: }",
          "5874: }",
          "5878: ndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5959: }",
          "5979: }",
          "5997: }",
          "6030: }",
          "6065: }",
          "6083: }",
          "6094: }",
          "6106: }",
          "6136: }",
          "6148: }",
          "6163: }",
          "6177: }",
          "",
          "[Removed Lines]",
          "5702: int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t * ip)",
          "5708:   if(packet->iphv6 != NULL) {",
          "5710:     if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5711:        packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5712:        packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5713:        packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5714:       return(1);",
          "5716:     return(0);",
          "5717:   }",
          "5721:   if(packet->iph->saddr == ip->ipv4)",
          "5722:     return(1);",
          "5723:   return(0);",
          "5729: int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t * ip)",
          "5735:   if(packet->iphv6 != NULL) {",
          "5737:     if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5738:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5739:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5740:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5741:       return(1);",
          "5743:     return(0);",
          "5744:   }",
          "5748:   if(packet->iph->saddr == ip->ipv4)",
          "5749:     return(1);",
          "5751:   return(0);",
          "5758: void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t * ip)",
          "5760:   NDPI_PROTOCOL_IP_clear(ip);",
          "5765:   if(packet->iphv6 != NULL) {",
          "5767:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "5768:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "5769:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "5770:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "5772:   } else",
          "5776:     ip->ipv4 = packet->iph->saddr;",
          "5783: void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t * ip)",
          "5785:   NDPI_PROTOCOL_IP_clear(ip);",
          "5789:   if(packet->iphv6 != NULL) {",
          "5791:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "5792:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "5793:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "5794:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "5796:   } else",
          "5800:     ip->ipv4 = packet->iph->daddr;",
          "5805: u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {",
          "5807:   return(ip->ipv6.u6_addr.u6_addr32[1] != 0 ||",
          "5808:          ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "5809:          ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "5811:   return(0);",
          "5817: char *ndpi_get_ip_string(const ndpi_ip_addr_t * ip, char *buf, u_int buf_len) {",
          "5818:   const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "5821:   if(ndpi_is_ipv6(ip)) {",
          "5822:     if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "5823:       buf[0] = '\\0';",
          "5825:     return(buf);",
          "5826:   }",
          "5829:   snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "5831:   return(buf);",
          "5838: int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {",
          "5839:   int rv = -1;",
          "5840:   memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "5842:   if(strchr(ip_str, '.')) {",
          "5843:     if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "5844:       rv = 4;",
          "5846:   } else {",
          "5847:     if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "5848:       rv = 6;",
          "5850:   }",
          "5852:   return(rv);",
          "5857: u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t * str,",
          "5858:        u_int16_t max_chars_to_read,",
          "5859:        u_int16_t * bytes_read) {",
          "5860:   u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "5861:   return(ntohs(val));",
          "5866: u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {",
          "5867:   return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "5872: u_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {",
          "5873:   return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "5879:           struct ndpi_flow_struct *flow,",
          "5880:           u_int8_t proto,",
          "5881:           u_int32_t shost /* host byte order */, u_int16_t sport,",
          "5882:           u_int32_t dhost /* host byte order */, u_int16_t dport) {",
          "5883:   u_int32_t rc;",
          "5884:   struct in_addr addr;",
          "5885:   ndpi_protocol ret = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };",
          "5886:   u_int8_t user_defined_proto;",
          "5888:   if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "5889:     rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "5891:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5892:       if(flow && (proto == IPPROTO_UDP)",
          "5893:   && NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc)",
          "5894:   && is_udp_guessable_protocol(rc))",
          "5895:  ;",
          "5896:       else {",
          "5897:  ret.app_protocol = rc,",
          "5898:    ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport,",
          "5899:              dport, &user_defined_proto);",
          "5901:  if(ret.app_protocol == ret.master_protocol)",
          "5902:    ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5904:  ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5905:  return(ret);",
          "5906:       }",
          "5907:     }",
          "5909:     rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5910:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5911:       if(flow && (proto == IPPROTO_UDP)",
          "5912:   && NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc)",
          "5913:   && is_udp_guessable_protocol(rc))",
          "5914:  ;",
          "5915:       else {",
          "5916:  ret.app_protocol = rc;",
          "5918:  if(rc == NDPI_PROTOCOL_TLS)",
          "5919:    goto check_guessed_skype;",
          "5920:  else {",
          "5921:    ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5922:    return(ret);",
          "5923:  }",
          "5924:       }",
          "5925:     }",
          "5927:   check_guessed_skype:",
          "5928:     addr.s_addr = htonl(shost);",
          "5929:     if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "5930:       ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5931:     } else {",
          "5932:       addr.s_addr = htonl(dhost);",
          "5933:       if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "5934:  ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5935:     }",
          "5936:   } else",
          "5937:     ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport,",
          "5938:            dport, &user_defined_proto);",
          "5940:   ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5941:   return(ret);",
          "5942: }",
          "5946: char* ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,",
          "5947:          ndpi_protocol proto, char *buf, u_int buf_len) {",
          "5948:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5949:      && (proto.master_protocol != proto.app_protocol)) {",
          "5950:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5951:       snprintf(buf, buf_len, \"%u.%u\",",
          "5952:         proto.master_protocol, proto.app_protocol);",
          "5953:     else",
          "5954:       snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "5955:   } else",
          "5956:     snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "5958:   return(buf);",
          "5963: char* ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,",
          "5964:     ndpi_protocol proto, char *buf, u_int buf_len) {",
          "5965:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5966:      && (proto.master_protocol != proto.app_protocol)) {",
          "5967:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5968:       snprintf(buf, buf_len, \"%s.%s\",",
          "5969:         ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "5970:         ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5971:     else",
          "5972:       snprintf(buf, buf_len, \"%s\",",
          "5973:         ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "5974:   } else",
          "5975:     snprintf(buf, buf_len, \"%s\",",
          "5976:       ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5978:   return(buf);",
          "5983: int ndpi_is_custom_category(ndpi_protocol_category_t category) {",
          "5984:   switch(category) {",
          "5985:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5986:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5987:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5988:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5989:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5990:     return(1);",
          "5991:     break;",
          "5993:   default:",
          "5994:     return(0);",
          "5995:     break;",
          "5996:   }",
          "6001: void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6002:        ndpi_protocol_category_t category, char *name) {",
          "6004:   if(!name) return;",
          "6006:   switch(category) {",
          "6007:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6008:     snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6009:     break;",
          "6011:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6012:     snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6013:     break;",
          "6015:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6016:     snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6017:     break;",
          "6019:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6020:     snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6021:     break;",
          "6023:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6024:     snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6025:     break;",
          "6027:   default:",
          "6028:     break;",
          "6029:   }",
          "6034: const char* ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6035:        ndpi_protocol_category_t category) {",
          "6036:   if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "6037:     static char b[24];",
          "6039:     if(!ndpi_str)",
          "6040:       snprintf(b, sizeof(b), \"NULL nDPI\");",
          "6041:     else",
          "6042:       snprintf(b, sizeof(b), \"Invalid category %d\", (int)category);",
          "6043:     return(b);",
          "6044:   }",
          "6046:   if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "6047:     switch(category) {",
          "6048:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6049:       return(ndpi_str->custom_category_labels[0]);",
          "6050:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6051:       return(ndpi_str->custom_category_labels[1]);",
          "6052:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6053:       return(ndpi_str->custom_category_labels[2]);",
          "6054:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6055:       return(ndpi_str->custom_category_labels[3]);",
          "6056:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6057:       return(ndpi_str->custom_category_labels[4]);",
          "6058:     case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "6059:       return(\"Code should not use this internal constant\");",
          "6060:     default:",
          "6061:       return(\"Unspecified\");",
          "6062:     }",
          "6063:   } else",
          "6064:     return(categories[category]);",
          "6069: ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,",
          "6070:        ndpi_protocol proto) {",
          "6071:   if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6072:     return(proto.category);",
          "6075:   else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN)",
          "6076:    || (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "6077:     if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6078:       return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "6079:   } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6080:     return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "6082:   return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "6087: char* ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str, u_int16_t proto_id) {",
          "6088:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols)",
          "6089:      || (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6090:      || (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6091:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6093:   return(ndpi_str->proto_defaults[proto_id].protoName);",
          "6098: ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,",
          "6099:         u_int16_t proto_id) {",
          "6100:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols)",
          "6101:      || (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS+NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6102:      || (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6103:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6105:   return(ndpi_str->proto_defaults[proto_id].protoBreed);",
          "6110: char* ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6111:     ndpi_protocol_breed_t breed_id) {",
          "6112:   switch(breed_id) {",
          "6113:   case NDPI_PROTOCOL_SAFE:",
          "6114:     return(\"Safe\");",
          "6115:     break;",
          "6116:   case NDPI_PROTOCOL_ACCEPTABLE:",
          "6117:     return(\"Acceptable\");",
          "6118:     break;",
          "6119:   case NDPI_PROTOCOL_FUN:",
          "6120:     return(\"Fun\");",
          "6121:     break;",
          "6122:   case NDPI_PROTOCOL_UNSAFE:",
          "6123:     return(\"Unsafe\");",
          "6124:     break;",
          "6125:   case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "6126:     return(\"Potentially Dangerous\");",
          "6127:     break;",
          "6128:   case NDPI_PROTOCOL_DANGEROUS:",
          "6129:     return(\"Dangerous\");",
          "6130:     break;",
          "6131:   case NDPI_PROTOCOL_UNRATED:",
          "6132:   default:",
          "6133:     return(\"Unrated\");",
          "6134:     break;",
          "6135:   }",
          "6140: int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {",
          "6141:   int i;",
          "6143:   for(i=0; i<(int)ndpi_str->ndpi_num_supported_protocols; i++)",
          "6144:     if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "6145:       return(i);",
          "6147:   return(-1);",
          "6152: int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {",
          "6153:   int i;",
          "6155:   for(i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "6156:     const char *name = ndpi_category_get_name(ndpi_str, i);",
          "6158:     if(strcasecmp(cat, name) == 0)",
          "6159:       return(i);",
          "6160:   }",
          "6162:   return(-1);",
          "6167: void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6168:   int i;",
          "6170:   for(i=0; i<(int)ndpi_str->ndpi_num_supported_protocols; i++)",
          "6171:     printf(\"%3d %-22s %-8s %-12s %s\\n\", i,",
          "6172:     ndpi_str->proto_defaults[i].protoName,",
          "6173:     ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "6174:     ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "6175:     ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory)",
          "6176:     );",
          "",
          "[Added Lines]",
          "5503: int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip)",
          "5508:     if (packet->iphv6 != NULL) {",
          "5509:         if (packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5510:             packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5511:             packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5512:             packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5513:             return (1);",
          "5515:         return (0);",
          "5516:     }",
          "5520:     if (packet->iph->saddr == ip->ipv4)",
          "5521:         return (1);",
          "5522:     return (0);",
          "5528: int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip)",
          "5533:     if (packet->iphv6 != NULL) {",
          "5534:         if (packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5535:             packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5536:             packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5537:             packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5538:             return (1);",
          "5540:         return (0);",
          "5541:     }",
          "5545:     if (packet->iph->saddr == ip->ipv4)",
          "5546:         return (1);",
          "5548:     return (0);",
          "5555: void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip)",
          "5557:     NDPI_PROTOCOL_IP_clear(ip);",
          "5562:     if (packet->iphv6 != NULL) {",
          "5563:         ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "5564:         ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "5565:         ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "5566:         ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "5568:     } else",
          "5572:         ip->ipv4 = packet->iph->saddr;",
          "5579: void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip)",
          "5581:     NDPI_PROTOCOL_IP_clear(ip);",
          "5585:     if (packet->iphv6 != NULL) {",
          "5586:         ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "5587:         ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "5588:         ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "5589:         ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "5591:     } else",
          "5595:         ip->ipv4 = packet->iph->daddr;",
          "5600: u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip)",
          "5601: {",
          "5603:     return (ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "5604:             ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "5606:     return (0);",
          "5612: char *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len)",
          "5613: {",
          "5614:     const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "5617:     if (ndpi_is_ipv6(ip)) {",
          "5618:         if (inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "5619:             buf[0] = '\\0';",
          "5621:         return (buf);",
          "5622:     }",
          "5625:     snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "5627:     return (buf);",
          "5633: int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip)",
          "5634: {",
          "5635:     int rv = -1;",
          "5636:     memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "5638:     if (strchr(ip_str, '.')) {",
          "5639:         if (inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "5640:             rv = 4;",
          "5642:     } else {",
          "5643:         if (inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "5644:             rv = 6;",
          "5646:     }",
          "5648:     return (rv);",
          "5653: u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read)",
          "5654: {",
          "5655:     u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "5656:     return (ntohs(val));",
          "5661: u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p)",
          "5662: {",
          "5663:     return (((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "5668: u_int16_t ndpi_get_lower_proto(ndpi_protocol proto)",
          "5669: {",
          "5670:     return ((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "5676:                                              struct ndpi_flow_struct *flow, u_int8_t proto,",
          "5677:                                              u_int32_t shost /* host byte order */, u_int16_t sport,",
          "5678:                                              u_int32_t dhost /* host byte order */, u_int16_t dport)",
          "5679: {",
          "5680:     u_int32_t rc;",
          "5681:     struct in_addr addr;",
          "5682:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "5683:     u_int8_t user_defined_proto;",
          "5685:     if ((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "5686:         rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "5688:         if (rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5689:             if (flow && (proto == IPPROTO_UDP) &&",
          "5690:                 NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5691:                 ;",
          "5692:             else {",
          "5693:                 ret.app_protocol = rc,",
          "5694:                 ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5696:                 if (ret.app_protocol == ret.master_protocol)",
          "5697:                     ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5699:                 ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5700:                 return (ret);",
          "5701:             }",
          "5702:         }",
          "5704:         rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5705:         if (rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5706:             if (flow && (proto == IPPROTO_UDP) &&",
          "5707:                 NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5708:                 ;",
          "5709:             else {",
          "5710:                 ret.app_protocol = rc;",
          "5712:                 if (rc == NDPI_PROTOCOL_TLS)",
          "5713:                     goto check_guessed_skype;",
          "5714:                 else {",
          "5715:                     ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5716:                     return (ret);",
          "5717:                 }",
          "5718:             }",
          "5719:         }",
          "5721:     check_guessed_skype:",
          "5722:         addr.s_addr = htonl(shost);",
          "5723:         if (ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "5724:             ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5725:         } else {",
          "5726:             addr.s_addr = htonl(dhost);",
          "5727:             if (ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "5728:                 ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5729:         }",
          "5730:     } else",
          "5731:         ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5733:     ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5734:     return (ret);",
          "5739: char *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol proto, char *buf, u_int buf_len)",
          "5740: {",
          "5741:     if ((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5742:         if (proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5743:             snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);",
          "5744:         else",
          "5745:             snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "5746:     } else",
          "5747:         snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "5749:     return (buf);",
          "5754: char *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol proto, char *buf, u_int buf_len)",
          "5755: {",
          "5756:     if ((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5757:         if (proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5758:             snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "5759:                      ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5760:         else",
          "5761:             snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "5762:     } else",
          "5763:         snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5765:     return (buf);",
          "5770: int ndpi_is_custom_category(ndpi_protocol_category_t category)",
          "5771: {",
          "5772:     switch (category) {",
          "5773:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5774:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5775:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5776:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5777:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5778:             return (1);",
          "5779:             break;",
          "5781:         default:",
          "5782:             return (0);",
          "5783:             break;",
          "5784:     }",
          "5785: }",
          "5789: void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_category_t category,",
          "5790:                             char *name)",
          "5791: {",
          "5792:     if (!name)",
          "5793:         return;",
          "5795:     switch (category) {",
          "5796:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5797:             snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5798:             break;",
          "5800:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5801:             snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5802:             break;",
          "5804:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5805:             snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5806:             break;",
          "5808:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5809:             snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5810:             break;",
          "5812:         case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5813:             snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "5814:             break;",
          "5816:         default:",
          "5817:             break;",
          "5818:     }",
          "5823: const char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_category_t category)",
          "5824: {",
          "5825:     if ((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "5826:         static char b[24];",
          "5828:         if (!ndpi_str)",
          "5829:             snprintf(b, sizeof(b), \"NULL nDPI\");",
          "5830:         else",
          "5831:             snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);",
          "5832:         return (b);",
          "5833:     }",
          "5835:     if ((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "5836:         switch (category) {",
          "5837:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5838:                 return (ndpi_str->custom_category_labels[0]);",
          "5839:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5840:                 return (ndpi_str->custom_category_labels[1]);",
          "5841:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5842:                 return (ndpi_str->custom_category_labels[2]);",
          "5843:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5844:                 return (ndpi_str->custom_category_labels[3]);",
          "5845:             case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5846:                 return (ndpi_str->custom_category_labels[4]);",
          "5847:             case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "5848:                 return (\"Code should not use this internal constant\");",
          "5849:             default:",
          "5850:                 return (\"Unspecified\");",
          "5851:         }",
          "5852:     } else",
          "5853:         return (categories[category]);",
          "5858: ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol proto)",
          "5859: {",
          "5860:     if (proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "5861:         return (proto.category);",
          "5864:     else if ((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||",
          "5865:              (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "5866:         if (proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "5867:             return (ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "5868:     } else if (proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "5869:         return (ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "5871:     return (NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "5876: char *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str, u_int16_t proto_id)",
          "5877: {",
          "5878:     if ((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "5879:         (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "5880:         (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "5881:         proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "5883:     return (ndpi_str->proto_defaults[proto_id].protoName);",
          "5888: ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str, u_int16_t proto_id)",
          "5889: {",
          "5890:     if ((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "5891:         (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "5892:         (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "5893:         proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "5895:     return (ndpi_str->proto_defaults[proto_id].protoBreed);",
          "5900: char *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str, ndpi_protocol_breed_t breed_id)",
          "5901: {",
          "5902:     switch (breed_id) {",
          "5903:         case NDPI_PROTOCOL_SAFE:",
          "5904:             return (\"Safe\");",
          "5905:             break;",
          "5906:         case NDPI_PROTOCOL_ACCEPTABLE:",
          "5907:             return (\"Acceptable\");",
          "5908:             break;",
          "5909:         case NDPI_PROTOCOL_FUN:",
          "5910:             return (\"Fun\");",
          "5911:             break;",
          "5912:         case NDPI_PROTOCOL_UNSAFE:",
          "5913:             return (\"Unsafe\");",
          "5914:             break;",
          "5915:         case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "5916:             return (\"Potentially Dangerous\");",
          "5917:             break;",
          "5918:         case NDPI_PROTOCOL_DANGEROUS:",
          "5919:             return (\"Dangerous\");",
          "5920:             break;",
          "5921:         case NDPI_PROTOCOL_UNRATED:",
          "5922:         default:",
          "5923:             return (\"Unrated\");",
          "5924:             break;",
          "5925:     }",
          "5930: int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto)",
          "5931: {",
          "5932:     int i;",
          "5934:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "5935:         if (strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "5936:             return (i);",
          "5938:     return (-1);",
          "5943: int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat)",
          "5944: {",
          "5945:     int i;",
          "5947:     for (i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "5948:         const char *name = ndpi_category_get_name(ndpi_str, i);",
          "5950:         if (strcasecmp(cat, name) == 0)",
          "5951:             return (i);",
          "5952:     }",
          "5954:     return (-1);",
          "5959: void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "5960: {",
          "5961:     int i;",
          "5963:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "5964:         printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,",
          "5965:                ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "5966:                ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "5967:                ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "6205: }",
          "",
          "[Removed Lines]",
          "6185: char* ndpi_strnstr(const char *s, const char *find, size_t slen) {",
          "6186:   char c;",
          "6187:   size_t len;",
          "6189:   if((c = *find++) != '\\0') {",
          "6190:     len = strnlen(find, slen);",
          "6191:     do {",
          "6192:       char sc;",
          "6194:       do {",
          "6195:  if(slen-- < 1 || (sc = *s++) == '\\0')",
          "6196:    return(NULL);",
          "6197:       } while(sc != c);",
          "6198:       if(len > slen)",
          "6199:  return(NULL);",
          "6200:     } while(strncmp(s, find, len) != 0);",
          "6201:     s--;",
          "6202:   }",
          "6204:   return((char *)s);",
          "",
          "[Added Lines]",
          "5976: char *ndpi_strnstr(const char *s, const char *find, size_t slen)",
          "5977: {",
          "5978:     char c;",
          "5979:     size_t len;",
          "5981:     if ((c = *find++) != '\\0') {",
          "5982:         len = strnlen(find, slen);",
          "5983:         do {",
          "5984:             char sc;",
          "5986:             do {",
          "5987:                 if (slen-- < 1 || (sc = *s++) == '\\0')",
          "5988:                     return (NULL);",
          "5989:             } while (sc != c);",
          "5990:             if (len > slen)",
          "5991:                 return (NULL);",
          "5992:         } while (strncmp(s, find, len) != 0);",
          "5993:         s--;",
          "5994:     }",
          "5996:     return ((char *) s);",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "6233: }",
          "6242: }",
          "6267:     As ac_automata_search can detect partial matches and continue the search process",
          "6268:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6269:     and in this case return it",
          "6276:     ret_match->protocol_breed = match.breed;",
          "6279: }",
          "6281: #ifdef HAVE_HYPERSCAN",
          "6293: }",
          "6295: #endif",
          "6314: }",
          "6318: static u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6327: #ifndef HAVE_HYPERSCAN",
          "6331: #else",
          "6337:     TODO HYPERSCAN",
          "6338:     In case of match fill up ret_match and set flow protocol + category",
          "6355:     ret_match->protocol_category = ndpi_str->proto_defaults[matching_protocol_id].protoCategory,",
          "6356:     ret_match->protocol_breed = ndpi_str->proto_defaults[matching_protocol_id].protoBreed;",
          "6357: #endif",
          "6359: #ifdef DEBUG",
          "6370: #endif",
          "6387: #ifdef DEBUG",
          "6390: #endif",
          "6394:     ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;",
          "6397: }",
          "6415:     }",
          "6419: }",
          "6446: }",
          "6458: }",
          "6480:     As ac_automata_search can detect partial matches and continue the search process",
          "6481:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6482:     and in this case return it",
          "6487: }",
          "6515:     }",
          "6519: }",
          "6527: #ifdef WIN32",
          "6548: }",
          "6549: #endif",
          "6560: }",
          "6562: #ifdef CODE_UNUSED",
          "6571: }",
          "6579: }",
          "6580: #endif",
          "6584: }",
          "6588: }",
          "6592: }",
          "6596: }",
          "6600: }",
          "6604: }",
          "6624: }",
          "6629: }",
          "6640: }",
          "6648: }",
          "",
          "[Removed Lines]",
          "6212: char* ndpi_strncasestr(const char *s, const char *find, size_t slen) {",
          "6213:   char c;",
          "6214:   size_t len;",
          "6216:   if((c = *find++) != '\\0') {",
          "6217:     len = strlen(find);",
          "6218:     do {",
          "6219:       char sc;",
          "6221:       do {",
          "6222:  if(slen-- < 1 || (sc = *s++) == '\\0')",
          "6223:    return(NULL);",
          "6224:       } while(sc != c);",
          "6226:       if(len > slen)",
          "6227:  return(NULL);",
          "6228:     } while(strncasecmp(s, find, len) != 0);",
          "6230:     s--;",
          "6231:   }",
          "6232:   return((char *)s);",
          "6237: int ndpi_match_prefix(const u_int8_t *payload, size_t payload_len,",
          "6238:         const char *str, size_t str_len) {",
          "6239:   int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "6241:   return(rc);",
          "6246: int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6247:       char *string_to_match, u_int string_to_match_len,",
          "6248:       ndpi_protocol_match_result *ret_match,",
          "6249:       u_int8_t is_host_match) {",
          "6250:   AC_TEXT_t ac_input_text;",
          "6251:   ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "6252:   AC_REP_t match = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };",
          "6253:   int rc;",
          "6255:   if((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "6256:     return(NDPI_PROTOCOL_UNKNOWN);",
          "6258:   if(!automa->ac_automa_finalized) {",
          "6259:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6261:   }",
          "6263:   ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "6264:   rc = ac_automata_search(((AC_AUTOMATA_t*)automa->ac_automa), &ac_input_text, &match);",
          "6271:   if((rc == 0) && (match.number != 0)) rc = 1;",
          "6274:   ret_match->protocol_id = match.number,",
          "6275:     ret_match->protocol_category = match.category,",
          "6278:   return(rc ? match.number : 0);",
          "6285: static int hyperscanEventHandler(unsigned int id, unsigned long long from,",
          "6286:      unsigned long long to, unsigned int flags, void *ctx) {",
          "6289:   NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Match with: %d [from: %llu][to: %llu]\\n\", id, from, to);",
          "6299: static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {",
          "6302:   if((previous_proto == NDPI_PROTOCOL_UNKNOWN)",
          "6303:      || (previous_proto == new_proto))",
          "6304:     return(0);",
          "6306:   switch(previous_proto) {",
          "6307:   case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6308:   case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6309:     if(new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6310:       return(1);",
          "6311:   }",
          "6313:   return(0);",
          "6319:             struct ndpi_flow_struct *flow,",
          "6320:             char *string_to_match, u_int string_to_match_len,",
          "6321:             u_int16_t master_protocol_id,",
          "6322:             ndpi_protocol_match_result *ret_match,",
          "6323:             u_int8_t is_host_match) {",
          "6324:   int matching_protocol_id;",
          "6325:   struct ndpi_packet_struct *packet = &flow->packet;",
          "6328:   matching_protocol_id = ndpi_match_string_subprotocol(ndpi_str, string_to_match,",
          "6329:              string_to_match_len, ret_match,",
          "6330:              is_host_match);",
          "6332:   struct hs *hs = (struct hs*)ndpi_str->hyperscan;",
          "6333:   hs_error_t status;",
          "6335:   matching_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "6340:   status = hs_scan(hs->database, string_to_match,",
          "6341:      string_to_match_len, 0, hs->scratch,",
          "6342:      hyperscanEventHandler, &matching_protocol_id);",
          "6344:   if(status == HS_SUCCESS) {",
          "6345:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine completed normally. Result: %s [%d][%s]\\n\",",
          "6346:     ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6347:   } else if(status == HS_SCAN_TERMINATED) {",
          "6348:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine was terminated by callback. Result: %s [%d][%s]\\n\",",
          "6349:     ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6350:   } else {",
          "6351:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan returned with error.\\n\");",
          "6352:   }",
          "6354:   ret_match->protocol_id = matching_protocol_id,",
          "6360:   {",
          "6361:     char m[256];",
          "6362:     int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6364:     strncpy(m, string_to_match, len);",
          "6365:     m[len] = '\\0';",
          "6367:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\",",
          "6368:     m, ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6369:   }",
          "6372:   if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "6373:      && (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6375:     packet->detected_protocol_stack[1] = master_protocol_id,",
          "6376:       packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6378:     flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6379:       flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6381:     if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6382:       flow->category = ret_match->protocol_category;",
          "6384:     return(packet->detected_protocol_stack[0]);",
          "6385:   }",
          "6388:   string_to_match[string_to_match_len] = '\\0';",
          "6389:   NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6392:   ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN,",
          "6393:     ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6396:   return(NDPI_PROTOCOL_UNKNOWN);",
          "6401: u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6402:           struct ndpi_flow_struct *flow,",
          "6403:           char *string_to_match, u_int string_to_match_len,",
          "6404:           ndpi_protocol_match_result *ret_match,",
          "6405:           u_int16_t master_protocol_id) {",
          "6406:   u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str,",
          "6407:             flow, string_to_match, string_to_match_len,",
          "6408:             master_protocol_id, ret_match, 1);",
          "6409:   unsigned long id = ret_match->protocol_category;",
          "6411:   if(ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {",
          "6412:     if(id != -1) {",
          "6413:       flow->category = ret_match->protocol_category = id;",
          "6414:       rc = master_protocol_id;",
          "6416:   }",
          "6418:   return(rc);",
          "6423: int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct,",
          "6424:      struct ndpi_flow_struct *flow,",
          "6425:      u_int16_t master_protocol,",
          "6426:      char *name, u_int name_len) {",
          "6427:   ndpi_protocol_match_result ret_match;",
          "6428:   u_int16_t subproto, what_len;",
          "6429:   char *what;",
          "6431:   if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6432:     what = &name[1], what_len = name_len - 1;",
          "6433:   else",
          "6434:     what = name, what_len = name_len;",
          "6436:   subproto = ndpi_match_host_subprotocol(ndpi_struct, flow,",
          "6437:       what, what_len,",
          "6438:       &ret_match, master_protocol);",
          "6440:   if(subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6441:     ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6442:     ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6443:     return(1);",
          "6444:   } else",
          "6445:     return(0);",
          "6450: u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6451:       struct ndpi_flow_struct *flow,",
          "6452:       char *string_to_match, u_int string_to_match_len,",
          "6453:       ndpi_protocol_match_result *ret_match,",
          "6454:       u_int16_t master_protocol_id) {",
          "6455:   return(ndpi_automa_match_string_subprotocol(ndpi_str, flow,",
          "6456:            string_to_match, string_to_match_len,",
          "6457:            master_protocol_id, ret_match, 0));",
          "6462: int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6463:         ndpi_automa *automa, char *bigram_to_match) {",
          "6464:   AC_TEXT_t ac_input_text;",
          "6465:   AC_REP_t match = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED };",
          "6466:   int rc;",
          "6468:   if((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6469:     return(-1);",
          "6471:   if(!automa->ac_automa_finalized) {",
          "6472:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6474:   }",
          "6476:   ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6477:   rc = ac_automata_search(((AC_AUTOMATA_t*)automa->ac_automa), &ac_input_text, &match);",
          "6484:   if((rc == 0) && (match.number != 0)) rc = 1;",
          "6486:   return(rc ? match.number : 0);",
          "6491: void ndpi_free_flow(struct ndpi_flow_struct *flow) {",
          "6492:   if(flow) {",
          "6493:     if(flow->http.url)            ndpi_free(flow->http.url);",
          "6494:     if(flow->http.content_type)   ndpi_free(flow->http.content_type);",
          "6495:     if(flow->http.user_agent)     ndpi_free(flow->http.user_agent);",
          "6496:     if(flow->kerberos_buf.pktbuf) ndpi_free(flow->kerberos_buf.pktbuf);",
          "6498:     if(flow_is_proto(flow, NDPI_PROTOCOL_TLS)) {",
          "6499:       if(flow->protos.stun_ssl.ssl.server_names)",
          "6500:  ndpi_free(flow->protos.stun_ssl.ssl.server_names);",
          "6502:       if(flow->protos.stun_ssl.ssl.alpn)",
          "6503:  ndpi_free(flow->protos.stun_ssl.ssl.alpn);",
          "6505:       if(flow->protos.stun_ssl.ssl.tls_supported_versions)",
          "6506:  ndpi_free(flow->protos.stun_ssl.ssl.tls_supported_versions);",
          "6508:       if(flow->l4.tcp.tls.srv_cert_fingerprint_ctx)",
          "6509:  ndpi_free(flow->l4.tcp.tls.srv_cert_fingerprint_ctx);",
          "6510:     }",
          "6512:     if(flow->l4_proto == IPPROTO_TCP) {",
          "6513:       if(flow->l4.tcp.tls.message.buffer)",
          "6514:  ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "6517:     ndpi_free(flow);",
          "6518:   }",
          "6523: char* ndpi_revision() { return(NDPI_GIT_RELEASE); }",
          "6530: int gettimeofday(struct timeval * tp, struct timezone * tzp) {",
          "6534:   static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6536:   SYSTEMTIME  system_time;",
          "6537:   FILETIME    file_time;",
          "6538:   uint64_t    time;",
          "6540:   GetSystemTime( &system_time );",
          "6541:   SystemTimeToFileTime( &system_time, &file_time );",
          "6542:   time =  ((uint64_t)file_time.dwLowDateTime )      ;",
          "6543:   time += ((uint64_t)file_time.dwHighDateTime) << 32;",
          "6545:   tp->tv_sec  = (long) ((time - EPOCH) / 10000000L);",
          "6546:   tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6547:   return(0);",
          "6551: int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {",
          "6552:   int i;",
          "6554:   for(i=0; i<NDPI_NUM_FDS_BITS; i++) {",
          "6555:     if(a.fds_bits[i] & b.fds_bits[i])",
          "6556:       return(1);",
          "6557:   }",
          "6559:   return(0);",
          "6563: int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {",
          "6564:   int i;",
          "6566:   for(i=0; i<NDPI_NUM_FDS_BITS; i++)",
          "6567:     if(a.fds_bits[i] != 0)",
          "6568:       return(0);",
          "6570:   return(1);",
          "6573: void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {",
          "6574:   int i;",
          "6575:   for(i=0; i<NDPI_NUM_FDS_BITS; i++)",
          "6576:     printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6578:   printf(\"\\n\");",
          "6582: u_int16_t ndpi_get_api_version() {",
          "6583:   return(NDPI_API_VERSION);",
          "6586: ndpi_proto_defaults_t* ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "6587:   return(ndpi_str->proto_defaults);",
          "6590: u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6591:   return(ndpi_str->ndpi_num_supported_protocols);",
          "6594: u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6595:   return(ndpi_str->ndpi_num_custom_protocols);",
          "6598: u_int ndpi_get_ndpi_detection_module_size() {",
          "6599:   return(sizeof(struct ndpi_detection_module_struct));",
          "6602: void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l) {",
          "6603:   ndpi_str->ndpi_log_level = l;",
          "6609: struct ndpi_lru_cache* ndpi_lru_cache_init(u_int32_t num_entries) {",
          "6610:   struct ndpi_lru_cache *c = (struct ndpi_lru_cache*)ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6612:   if(!c) return(NULL);",
          "6614:   c->entries = (struct ndpi_lru_cache_entry*)ndpi_calloc(num_entries,",
          "6615:         sizeof(struct ndpi_lru_cache_entry));",
          "6617:   if(!c->entries) {",
          "6618:     ndpi_free(c);",
          "6619:     return(NULL);",
          "6620:   } else",
          "6621:     c->num_entries = num_entries;",
          "6623:   return(c);",
          "6626: void ndpi_lru_free_cache(struct ndpi_lru_cache *c) {",
          "6627:   ndpi_free(c->entries);",
          "6628:   ndpi_free(c);",
          "6631: u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t *value, u_int8_t clean_key_when_found) {",
          "6632:   u_int32_t slot = key % c->num_entries;",
          "6634:   if(c->entries[slot].is_full) {",
          "6636:     if(clean_key_when_found) c->entries[slot].is_full = 0;",
          "6637:     return(1);",
          "6638:   } else",
          "6639:     return(0);",
          "6642: void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {",
          "6643:   u_int32_t slot = key % c->num_entries;",
          "6645:   c->entries[slot].is_full = 1,",
          "6646:     c->entries[slot].key = key,",
          "6647:     c->entries[slot].value = value;",
          "",
          "[Added Lines]",
          "6004: char *ndpi_strncasestr(const char *s, const char *find, size_t slen)",
          "6005: {",
          "6006:     char c;",
          "6007:     size_t len;",
          "6009:     if ((c = *find++) != '\\0') {",
          "6010:         len = strlen(find);",
          "6011:         do {",
          "6012:             char sc;",
          "6014:             do {",
          "6015:                 if (slen-- < 1 || (sc = *s++) == '\\0')",
          "6016:                     return (NULL);",
          "6017:             } while (sc != c);",
          "6019:             if (len > slen)",
          "6020:                 return (NULL);",
          "6021:         } while (strncasecmp(s, find, len) != 0);",
          "6023:         s--;",
          "6024:     }",
          "6025:     return ((char *) s);",
          "6030: int ndpi_match_prefix(const u_int8_t *payload, size_t payload_len, const char *str, size_t str_len)",
          "6031: {",
          "6032:     int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "6034:     return (rc);",
          "6039: int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,",
          "6040:                                   u_int string_to_match_len, ndpi_protocol_match_result *ret_match,",
          "6041:                                   u_int8_t is_host_match)",
          "6042: {",
          "6043:     AC_TEXT_t ac_input_text;",
          "6044:     ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "6045:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6046:     int rc;",
          "6048:     if ((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "6049:         return (NDPI_PROTOCOL_UNKNOWN);",
          "6051:     if (!automa->ac_automa_finalized) {",
          "6052:         printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6054:     }",
          "6056:     ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "6057:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6064:     if ((rc == 0) && (match.number != 0))",
          "6065:         rc = 1;",
          "6068:     ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,",
          "6071:     return (rc ? match.number : 0);",
          "6078: static int hyperscanEventHandler(unsigned int id, unsigned long long from, unsigned long long to, unsigned int flags,",
          "6079:                                  void *ctx)",
          "6080: {",
          "6083:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Match with: %d [from: %llu][to: %llu]\\n\", id, from, to);",
          "6093: static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto)",
          "6094: {",
          "6097:     if ((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))",
          "6098:         return (0);",
          "6100:     switch (previous_proto) {",
          "6101:         case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6102:         case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6103:             if (new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6104:                 return (1);",
          "6105:     }",
          "6107:     return (0);",
          "6113:                                                       struct ndpi_flow_struct *flow, char *string_to_match,",
          "6114:                                                       u_int string_to_match_len, u_int16_t master_protocol_id,",
          "6115:                                                       ndpi_protocol_match_result *ret_match, u_int8_t is_host_match)",
          "6116: {",
          "6117:     int matching_protocol_id;",
          "6118:     struct ndpi_packet_struct *packet = &flow->packet;",
          "6121:     matching_protocol_id =",
          "6122:         ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);",
          "6124:     struct hs *hs = (struct hs *) ndpi_str->hyperscan;",
          "6125:     hs_error_t status;",
          "6127:     matching_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "6132:     status = hs_scan(hs->database, string_to_match, string_to_match_len, 0, hs->scratch, hyperscanEventHandler,",
          "6133:                      &matching_protocol_id);",
          "6135:     if (status == HS_SUCCESS) {",
          "6136:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine completed normally. Result: %s [%d][%s]\\n\",",
          "6137:                       ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6138:     } else if (status == HS_SCAN_TERMINATED) {",
          "6139:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan engine was terminated by callback. Result: %s [%d][%s]\\n\",",
          "6140:                       ndpi_get_proto_name(ndpi_str, matching_protocol_id), matching_protocol_id, string_to_match);",
          "6141:     } else {",
          "6142:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] Hyperscan returned with error.\\n\");",
          "6143:     }",
          "6145:     ret_match->protocol_id = matching_protocol_id,",
          "6151:     {",
          "6152:         char m[256];",
          "6153:         int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6155:         strncpy(m, string_to_match, len);",
          "6156:         m[len] = '\\0';",
          "6158:         NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,",
          "6159:                       ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6160:     }",
          "6163:     if ((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "6164:         (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6166:         packet->detected_protocol_stack[1] = master_protocol_id,",
          "6167:         packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6169:         flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6170:         flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6172:         if (flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6173:             flow->category = ret_match->protocol_category;",
          "6175:         return (packet->detected_protocol_stack[0]);",
          "6176:     }",
          "6179:     string_to_match[string_to_match_len] = '\\0';",
          "6180:     NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6183:     ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6186:     return (NDPI_PROTOCOL_UNKNOWN);",
          "6191: u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6192:                                       char *string_to_match, u_int string_to_match_len,",
          "6193:                                       ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id)",
          "6194: {",
          "6195:     u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6196:                                                         master_protocol_id, ret_match, 1);",
          "6197:     unsigned long id = ret_match->protocol_category;",
          "6199:     if (ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {",
          "6200:         if (id != -1) {",
          "6201:             flow->category = ret_match->protocol_category = id;",
          "6202:             rc = master_protocol_id;",
          "6203:         }",
          "6206:     return (rc);",
          "6211: int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow,",
          "6212:                                  u_int16_t master_protocol, char *name, u_int name_len)",
          "6213: {",
          "6214:     ndpi_protocol_match_result ret_match;",
          "6215:     u_int16_t subproto, what_len;",
          "6216:     char *what;",
          "6218:     if ((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6219:         what = &name[1], what_len = name_len - 1;",
          "6220:     else",
          "6221:         what = name, what_len = name_len;",
          "6223:     subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len, &ret_match, master_protocol);",
          "6225:     if (subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6226:         ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6227:         ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6228:         return (1);",
          "6229:     } else",
          "6230:         return (0);",
          "6235: u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6236:                                          char *string_to_match, u_int string_to_match_len,",
          "6237:                                          ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id)",
          "6238: {",
          "6239:     return (ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6240:                                                  master_protocol_id, ret_match, 0));",
          "6245: int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str, ndpi_automa *automa, char *bigram_to_match)",
          "6246: {",
          "6247:     AC_TEXT_t ac_input_text;",
          "6248:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6249:     int rc;",
          "6251:     if ((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6252:         return (-1);",
          "6254:     if (!automa->ac_automa_finalized) {",
          "6255:         printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6257:     }",
          "6259:     ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6260:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6267:     if ((rc == 0) && (match.number != 0))",
          "6268:         rc = 1;",
          "6270:     return (rc ? match.number : 0);",
          "6275: void ndpi_free_flow(struct ndpi_flow_struct *flow)",
          "6276: {",
          "6277:     if (flow) {",
          "6278:         if (flow->http.url)",
          "6279:             ndpi_free(flow->http.url);",
          "6280:         if (flow->http.content_type)",
          "6281:             ndpi_free(flow->http.content_type);",
          "6282:         if (flow->http.user_agent)",
          "6283:             ndpi_free(flow->http.user_agent);",
          "6284:         if (flow->kerberos_buf.pktbuf)",
          "6285:             ndpi_free(flow->kerberos_buf.pktbuf);",
          "6287:         if (flow_is_proto(flow, NDPI_PROTOCOL_TLS)) {",
          "6288:             if (flow->protos.stun_ssl.ssl.server_names)",
          "6289:                 ndpi_free(flow->protos.stun_ssl.ssl.server_names);",
          "6291:             if (flow->protos.stun_ssl.ssl.alpn)",
          "6292:                 ndpi_free(flow->protos.stun_ssl.ssl.alpn);",
          "6294:             if (flow->protos.stun_ssl.ssl.tls_supported_versions)",
          "6295:                 ndpi_free(flow->protos.stun_ssl.ssl.tls_supported_versions);",
          "6297:             if (flow->l4.tcp.tls.srv_cert_fingerprint_ctx)",
          "6298:                 ndpi_free(flow->l4.tcp.tls.srv_cert_fingerprint_ctx);",
          "6299:         }",
          "6301:         if (flow->l4_proto == IPPROTO_TCP) {",
          "6302:             if (flow->l4.tcp.tls.message.buffer)",
          "6303:                 ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "6304:         }",
          "6306:         ndpi_free(flow);",
          "6312: char *ndpi_revision()",
          "6313: {",
          "6314:     return (NDPI_GIT_RELEASE);",
          "6315: }",
          "6322: int gettimeofday(struct timeval *tp, struct timezone *tzp)",
          "6323: {",
          "6327:     static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6329:     SYSTEMTIME system_time;",
          "6330:     FILETIME file_time;",
          "6331:     uint64_t time;",
          "6333:     GetSystemTime(&system_time);",
          "6334:     SystemTimeToFileTime(&system_time, &file_time);",
          "6335:     time = ((uint64_t) file_time.dwLowDateTime);",
          "6336:     time += ((uint64_t) file_time.dwHighDateTime) << 32;",
          "6338:     tp->tv_sec = (long) ((time - EPOCH) / 10000000L);",
          "6339:     tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6340:     return (0);",
          "6344: int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b)",
          "6345: {",
          "6346:     int i;",
          "6348:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++) {",
          "6349:         if (a.fds_bits[i] & b.fds_bits[i])",
          "6350:             return (1);",
          "6351:     }",
          "6353:     return (0);",
          "6357: int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a)",
          "6358: {",
          "6359:     int i;",
          "6361:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6362:         if (a.fds_bits[i] != 0)",
          "6363:             return (0);",
          "6365:     return (1);",
          "6368: void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a)",
          "6369: {",
          "6370:     int i;",
          "6371:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6372:         printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6374:     printf(\"\\n\");",
          "6378: u_int16_t ndpi_get_api_version()",
          "6379: {",
          "6380:     return (NDPI_API_VERSION);",
          "6383: ndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str)",
          "6384: {",
          "6385:     return (ndpi_str->proto_defaults);",
          "6388: u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "6389: {",
          "6390:     return (ndpi_str->ndpi_num_supported_protocols);",
          "6393: u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str)",
          "6394: {",
          "6395:     return (ndpi_str->ndpi_num_custom_protocols);",
          "6398: u_int ndpi_get_ndpi_detection_module_size()",
          "6399: {",
          "6400:     return (sizeof(struct ndpi_detection_module_struct));",
          "6403: void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l)",
          "6404: {",
          "6405:     ndpi_str->ndpi_log_level = l;",
          "6411: struct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries)",
          "6412: {",
          "6413:     struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6415:     if (!c)",
          "6416:         return (NULL);",
          "6418:     c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));",
          "6420:     if (!c->entries) {",
          "6421:         ndpi_free(c);",
          "6422:         return (NULL);",
          "6423:     } else",
          "6424:         c->num_entries = num_entries;",
          "6426:     return (c);",
          "6429: void ndpi_lru_free_cache(struct ndpi_lru_cache *c)",
          "6430: {",
          "6431:     ndpi_free(c->entries);",
          "6432:     ndpi_free(c);",
          "6435: u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t *value, u_int8_t clean_key_when_found)",
          "6436: {",
          "6437:     u_int32_t slot = key % c->num_entries;",
          "6439:     if (c->entries[slot].is_full) {",
          "6441:         if (clean_key_when_found)",
          "6442:             c->entries[slot].is_full = 0;",
          "6443:         return (1);",
          "6444:     } else",
          "6445:         return (0);",
          "6448: void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value)",
          "6449: {",
          "6450:     u_int32_t slot = key % c->num_entries;",
          "6452:     c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "6654:    0 - All possible dissection has been completed",
          "6655:    1 - Additional dissection is possible",
          "6661: #if 0",
          "6662:   printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,",
          "",
          "[Removed Lines]",
          "6657: u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,",
          "6658:      struct ndpi_flow_struct *flow) {",
          "6659:   u_int16_t proto = flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "",
          "[Added Lines]",
          "6462: u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow)",
          "6463: {",
          "6464:     u_int16_t proto =",
          "6465:         flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "6665:    proto);",
          "6666: #endif",
          "6705: }",
          "6729: }",
          "6745: }",
          "6759:     }",
          "6763: }",
          "6774: }",
          "6806: }",
          "6830: }",
          "6840: }",
          "",
          "[Removed Lines]",
          "6668:   switch(proto) {",
          "6669:   case NDPI_PROTOCOL_TLS:",
          "6670:     if(!flow->l4.tcp.tls.certificate_processed)",
          "6672:     break;",
          "6674:   case NDPI_PROTOCOL_HTTP:",
          "6675:     if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "6676:       return(1);",
          "6677:     break;",
          "6679:   case NDPI_PROTOCOL_DNS:",
          "6680:     if(flow->protos.dns.num_answers == 0)",
          "6681:       return(1);",
          "6682:     break;",
          "6684:   case NDPI_PROTOCOL_FTP_CONTROL:",
          "6685:   case NDPI_PROTOCOL_MAIL_POP:",
          "6686:   case NDPI_PROTOCOL_MAIL_IMAP:",
          "6687:   case NDPI_PROTOCOL_MAIL_SMTP:",
          "6688:     if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "6689:       return(1);",
          "6690:     break;",
          "6692:   case NDPI_PROTOCOL_SSH:",
          "6693:     if((flow->protos.ssh.hassh_client[0] == '\\0')",
          "6694:        || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "6695:       return(1);",
          "6696:     break;",
          "6698:   case NDPI_PROTOCOL_TELNET:",
          "6699:     if(!flow->protos.telnet.password_detected)",
          "6700:       return(1);",
          "6701:     break;",
          "6702:   }",
          "6704:   return(0);",
          "6709: const char* ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {",
          "6710:   switch(proto) {",
          "6711:   case ndpi_l4_proto_unknown:",
          "6712:     return(\"\");",
          "6713:     break;",
          "6715:   case ndpi_l4_proto_tcp_only:",
          "6716:     return(\"TCP\");",
          "6717:     break;",
          "6719:   case ndpi_l4_proto_udp_only:",
          "6720:     return(\"UDP\");",
          "6721:     break;",
          "6723:   case ndpi_l4_proto_tcp_and_udp:",
          "6724:     return(\"TCP/UDP\");",
          "6725:     break;",
          "6726:   }",
          "6728:   return(\"\");",
          "6733: ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,",
          "6734:        u_int16_t ndpi_proto_id) {",
          "6735:   if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "6736:     u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "6737:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "6739:     if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)             return(ndpi_l4_proto_tcp_only);",
          "6740:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)        return(ndpi_l4_proto_udp_only);",
          "6741:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP) return(ndpi_l4_proto_tcp_and_udp);",
          "6742:   }",
          "6749: ndpi_ptree_t* ndpi_ptree_create(void) {",
          "6750:   ndpi_ptree_t *tree = (ndpi_ptree_t*) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "6752:   if(tree) {",
          "6753:     tree->v4 = ndpi_New_Patricia(32);",
          "6754:     tree->v6 = ndpi_New_Patricia(128);",
          "6756:     if((!tree->v4) || (!tree->v6)) {",
          "6757:       ndpi_ptree_destroy(tree);",
          "6758:       return(NULL);",
          "6760:   }",
          "6762:   return(tree);",
          "6767: void ndpi_ptree_destroy(ndpi_ptree_t *tree) {",
          "6768:   if(tree) {",
          "6769:     if(tree->v4) ndpi_Destroy_Patricia(tree->v4, free_ptree_data);",
          "6770:     if(tree->v6) ndpi_Destroy_Patricia(tree->v6, free_ptree_data);",
          "6772:     ndpi_free(tree);",
          "6773:   }",
          "6778: int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, u_int8_t bits, uint user_data) {",
          "6779:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6780:   patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6781:   prefix_t prefix;",
          "6782:   patricia_node_t *node;",
          "6784:   if(bits > ptree->maxbits)",
          "6785:     return(-1);",
          "6787:   if(is_v6)",
          "6788:     fill_prefix_v6(&prefix, (const struct in6_addr*)&addr->ipv6, bits, ptree->maxbits);",
          "6789:   else",
          "6790:     fill_prefix_v4(&prefix, (const struct in_addr*)&addr->ipv4, bits, ptree->maxbits);",
          "6793:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "6795:   if(node && (node->prefix->bitlen == bits))",
          "6796:     return(-2);",
          "6798:   node = ndpi_patricia_lookup(ptree, &prefix);",
          "6800:   if(node != NULL) {",
          "6801:     node->value.user_value = user_data;",
          "6802:     return(0);",
          "6803:   }",
          "6805:   return(-3);",
          "6810: int ndpi_ptree_match_addr(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, uint *user_data) {",
          "6811:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6812:   patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6813:   prefix_t prefix;",
          "6814:   patricia_node_t *node;",
          "6815:   int bits = ptree->maxbits;",
          "6817:   if(is_v6)",
          "6818:     fill_prefix_v6(&prefix, (const struct in6_addr*)&addr->ipv6, bits, ptree->maxbits);",
          "6819:   else",
          "6820:     fill_prefix_v4(&prefix, (const struct in_addr*)&addr->ipv4, bits, ptree->maxbits);",
          "6822:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "6824:   if(node) {",
          "6826:     return(0);",
          "6827:   }",
          "6829:   return(-1);",
          "6834: void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {",
          "6835:   ndpi_MD5_CTX ctx;",
          "6837:   ndpi_MD5Init(&ctx);",
          "6838:   ndpi_MD5Update(&ctx, data, data_len);",
          "6839:   ndpi_MD5Final(hash, &ctx);",
          "",
          "[Added Lines]",
          "6474:     switch (proto) {",
          "6475:         case NDPI_PROTOCOL_TLS:",
          "6476:             if (!flow->l4.tcp.tls.certificate_processed)",
          "6478:             break;",
          "6480:         case NDPI_PROTOCOL_HTTP:",
          "6481:             if ((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "6482:                 return (1);",
          "6483:             break;",
          "6485:         case NDPI_PROTOCOL_DNS:",
          "6486:             if (flow->protos.dns.num_answers == 0)",
          "6487:                 return (1);",
          "6488:             break;",
          "6490:         case NDPI_PROTOCOL_FTP_CONTROL:",
          "6491:         case NDPI_PROTOCOL_MAIL_POP:",
          "6492:         case NDPI_PROTOCOL_MAIL_IMAP:",
          "6493:         case NDPI_PROTOCOL_MAIL_SMTP:",
          "6494:             if (flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "6495:                 return (1);",
          "6496:             break;",
          "6498:         case NDPI_PROTOCOL_SSH:",
          "6499:             if ((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "6500:                 return (1);",
          "6501:             break;",
          "6503:         case NDPI_PROTOCOL_TELNET:",
          "6504:             if (!flow->protos.telnet.password_detected)",
          "6505:                 return (1);",
          "6506:             break;",
          "6507:     }",
          "6509:     return (0);",
          "6514: const char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto)",
          "6515: {",
          "6516:     switch (proto) {",
          "6517:         case ndpi_l4_proto_unknown:",
          "6518:             return (\"\");",
          "6519:             break;",
          "6521:         case ndpi_l4_proto_tcp_only:",
          "6522:             return (\"TCP\");",
          "6523:             break;",
          "6525:         case ndpi_l4_proto_udp_only:",
          "6526:             return (\"UDP\");",
          "6527:             break;",
          "6529:         case ndpi_l4_proto_tcp_and_udp:",
          "6530:             return (\"TCP/UDP\");",
          "6531:             break;",
          "6532:     }",
          "6534:     return (\"\");",
          "6539: ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct, u_int16_t ndpi_proto_id)",
          "6540: {",
          "6541:     if (ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "6542:         u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "6543:         NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "6545:         if (bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)",
          "6546:             return (ndpi_l4_proto_tcp_only);",
          "6547:         else if (bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)",
          "6548:             return (ndpi_l4_proto_udp_only);",
          "6549:         else if (bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)",
          "6550:             return (ndpi_l4_proto_tcp_and_udp);",
          "6551:     }",
          "6558: ndpi_ptree_t *ndpi_ptree_create(void)",
          "6559: {",
          "6560:     ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "6562:     if (tree) {",
          "6563:         tree->v4 = ndpi_New_Patricia(32);",
          "6564:         tree->v6 = ndpi_New_Patricia(128);",
          "6566:         if ((!tree->v4) || (!tree->v6)) {",
          "6567:             ndpi_ptree_destroy(tree);",
          "6568:             return (NULL);",
          "6569:         }",
          "6572:     return (tree);",
          "6577: void ndpi_ptree_destroy(ndpi_ptree_t *tree)",
          "6578: {",
          "6579:     if (tree) {",
          "6580:         if (tree->v4)",
          "6581:             ndpi_Destroy_Patricia(tree->v4, free_ptree_data);",
          "6582:         if (tree->v6)",
          "6583:             ndpi_Destroy_Patricia(tree->v6, free_ptree_data);",
          "6585:         ndpi_free(tree);",
          "6586:     }",
          "6591: int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, u_int8_t bits, uint user_data)",
          "6592: {",
          "6593:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6594:     patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6595:     prefix_t prefix;",
          "6596:     patricia_node_t *node;",
          "6598:     if (bits > ptree->maxbits)",
          "6599:         return (-1);",
          "6601:     if (is_v6)",
          "6602:         fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6603:     else",
          "6604:         fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6607:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "6609:     if (node && (node->prefix->bitlen == bits))",
          "6610:         return (-2);",
          "6612:     node = ndpi_patricia_lookup(ptree, &prefix);",
          "6614:     if (node != NULL) {",
          "6615:         node->value.user_value = user_data;",
          "6616:         return (0);",
          "6617:     }",
          "6619:     return (-3);",
          "6624: int ndpi_ptree_match_addr(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr, uint *user_data)",
          "6625: {",
          "6626:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6627:     patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6628:     prefix_t prefix;",
          "6629:     patricia_node_t *node;",
          "6630:     int bits = ptree->maxbits;",
          "6632:     if (is_v6)",
          "6633:         fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6634:     else",
          "6635:         fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6637:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "6639:     if (node) {",
          "6641:         return (0);",
          "6642:     }",
          "6644:     return (-1);",
          "6649: void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16])",
          "6650: {",
          "6651:     ndpi_MD5_CTX ctx;",
          "6653:     ndpi_MD5Init(&ctx);",
          "6654:     ndpi_MD5Update(&ctx, data, data_len);",
          "6655:     ndpi_MD5Final(hash, &ctx);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "45e9c3c4389557ba4fe3e813da48ca03cc8d9d39",
      "candidate_info": {
        "commit_hash": "45e9c3c4389557ba4fe3e813da48ca03cc8d9d39",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/45e9c3c4389557ba4fe3e813da48ca03cc8d9d39",
        "files": [
          "src/include/ndpi_utils.h",
          "src/lib/ndpi_main.c",
          "src/lib/ndpi_utils.c",
          "tests/pcap/reasm_crash_anon.pcapng",
          "tests/pcap/reasm_segv_anon.pcapng",
          "tests/result/reasm_crash_anon.pcapng.out",
          "tests/result/reasm_segv_anon.pcapng.out"
        ],
        "message": "Partial fix for #1129",
        "before_after_code_files": [
          "src/include/ndpi_utils.h||src/include/ndpi_utils.h",
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c",
          "src/lib/ndpi_utils.c||src/lib/ndpi_utils.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/include/ndpi_utils.h||src/include/ndpi_utils.h": [
          "File: src/include/ndpi_utils.h -> src/include/ndpi_utils.h"
        ],
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2018:   if(!(prefs & ndpi_dont_init_libgcrypt)) {",
          "2019:     if(!gcry_control (GCRYCTL_INITIALIZATION_FINISHED_P)) {",
          "2020:       const char *gcrypt_ver = gcry_check_version(NULL);",
          "2022:         NDPI_LOG_ERR(ndpi_str, \"Error initializing libgcrypt\\n\");",
          "2023:         ndpi_free(ndpi_str);",
          "2024:         return NULL;",
          "",
          "[Removed Lines]",
          "2021:       if (!gcrypt_ver) {",
          "",
          "[Added Lines]",
          "2021:       if(!gcrypt_ver) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3499: static u_int8_t ndpi_iph_is_valid_and_not_fragmented(const struct ndpi_iphdr *iph, const u_int16_t ipsize) {",
          "3503:     the logic has been inverted!!! returned value:",
          "3509:   u_int16_t tot_len = ntohs(iph->tot_len);",
          "3512:     return(1);",
          "3518:     return(3);",
          "",
          "[Removed Lines]",
          "3501:   #ifdef FRAG_MAN",
          "3504:       0: not fragmented (instead of fragmented)",
          "3505:       1: packet too small",
          "3506:       2: fragmented and last, reassemble",
          "3507:       3: fragmented but not the last, add to buffer",
          "3510:   if ( ipsize < iph->ihl * 4 || ipsize < tot_len || tot_len < iph->ihl * 4 )",
          "3513:   else if ((iph->frag_off & htons(0x2000)) != 0) {",
          "3519:   } else if ((iph->frag_off & htons(0x1FFF)) != 0) {",
          "",
          "[Added Lines]",
          "3501: #ifdef FRAG_MAN",
          "3504:     0: not fragmented (instead of fragmented)",
          "3505:     1: packet too small",
          "3506:     2: fragmented and last, reassemble",
          "3507:     3: fragmented but not the last, add to buffer",
          "3510:   if( ipsize < iph->ihl * 4 || ipsize < tot_len || tot_len < iph->ihl * 4 )",
          "3513:   else if((iph->frag_off & htons(0x2000)) != 0) {",
          "3519:   } else if((iph->frag_off & htons(0x1FFF)) != 0) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3526:   return (0);",
          "3528: #else // FRAG_MAN",
          "3530:     returned value:",
          "3535:   if(ipsize < iph->ihl * 4 || ipsize < ntohs(iph->tot_len) || ntohs(iph->tot_len) < iph->ihl * 4 ||",
          "",
          "[Removed Lines]",
          "3531:       0: fragmented",
          "3532:       1: not fragmented",
          "",
          "[Added Lines]",
          "3531:     0: fragmented",
          "3532:     1: not fragmented",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3544: }",
          "3550:   0: ok, extracted",
          "3551:   1: packet too small",
          "3552:   2,3: fragmented, ....",
          "3554:   0: ok, extracted",
          "3555:   1: error or not available",
          "",
          "[Removed Lines]",
          "3547: extract the l4 payload, if available",
          "3548: returned value:",
          "3549: FRAG_MAN",
          "3553: else",
          "",
          "[Added Lines]",
          "3547:   extract the l4 payload, if available",
          "3548:   returned value:",
          "3549:   FRAG_MAN",
          "3553:   else",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3600:   if(iph != NULL) {",
          "3601:     u_int8_t check4Frag = ndpi_iph_is_valid_and_not_fragmented(iph, l3_len);",
          "3604:       u_int16_t len = ntohs(iph->tot_len);",
          "3605:       u_int16_t hlen = (iph->ihl * 4);",
          "",
          "[Removed Lines]",
          "3603:     if (!check4Frag) {",
          "",
          "[Added Lines]",
          "3603:     if(!check4Frag) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3761:       if(flow->packet.tcp->syn != 0 && flow->packet.tcp->ack == 0 && flow->init_finished != 0 &&",
          "3764:         u_int8_t backup;",
          "3767:         backup = flow->num_processed_pkts;",
          "3768:         backup1 = flow->guessed_protocol_id;",
          "",
          "[Removed Lines]",
          "3762:        flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3765:        u_int16_t backup1, backup2;",
          "",
          "[Added Lines]",
          "3762:   flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "3765:  u_int16_t backup1, backup2;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3813: #ifdef FRAG_MAN",
          "3814: uint8_t ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,",
          "3816: #else // FRAG_MAN",
          "3819: #endif // FRAG_MAN",
          "3821: #ifdef FRAG_MAN",
          "3823: #else // FRAG_MAN",
          "3825: #endif // FRAG_MAN",
          "3830: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3832: #endif",
          "3844: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "3847: #endif",
          "3875:       }",
          "3877: #ifdef FRAG_MAN",
          "3884: #endif //FRAG_MAN",
          "3925:    }",
          "3926:  }",
          "3934:  }",
          "3935:       }",
          "3940:       }",
          "3958:     }",
          "3960: #ifdef FRAG_MAN",
          "3962: #endif // FRAG_MAN",
          "4003:   }",
          "4055:  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4059:     }",
          "4080:     if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4081:        NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4082:        ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "",
          "[Removed Lines]",
          "3815:          struct ndpi_flow_struct *flow) {",
          "3817: void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,",
          "3818:          struct ndpi_flow_struct *flow) {",
          "3820:   if(!flow) {",
          "3822:   return 0;",
          "3824:     return;",
          "3826:   } else {",
          "3828:     struct ndpi_packet_struct *packet = &flow->packet;",
          "3829:     const struct ndpi_iphdr *iph = packet->iph;",
          "3831:     const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "3833:     const struct ndpi_tcphdr *tcph = packet->tcp;",
          "3834:     const struct ndpi_udphdr *udph = packet->udp;",
          "3836:     packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "3838:     if(ndpi_str->direction_detect_disable) {",
          "3839:       packet->packet_direction = flow->packet_direction;",
          "3840:     } else {",
          "3841:       if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "3842:  packet->packet_direction = 1;",
          "3845:       if(iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)",
          "3846:  packet->packet_direction = 1;",
          "3848:     }",
          "3850:     packet->packet_lines_parsed_complete = 0;",
          "3852:     if(flow->init_finished == 0) {",
          "3853:       flow->init_finished = 1;",
          "3854:       flow->setup_packet_direction = packet->packet_direction;",
          "3855:     }",
          "3857:     if(tcph != NULL) {",
          "3859:       packet->num_retried_bytes = 0;",
          "3861:       if(!ndpi_str->direction_detect_disable)",
          "3862:  packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "3864:       if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3865:   flow->l4.tcp.seen_ack == 0) {",
          "3866:  flow->l4.tcp.seen_syn = 1;",
          "3867:       } else",
          "3868:       if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3869:   flow->l4.tcp.seen_ack == 0) {",
          "3870:  flow->l4.tcp.seen_syn_ack = 1;",
          "3871:       } else",
          "3872:       if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&",
          "3873:   flow->l4.tcp.seen_ack == 0) {",
          "3874:  flow->l4.tcp.seen_ack = 1;",
          "3879:       if ( check_for_sequence(flow, tcph) ) {",
          "3882:         return 0;",
          "3883:       }",
          "3886:       if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||",
          "3887:   (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "3896:  if(tcph->ack != 0) {",
          "3897:    flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "3898:      ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "3901:      Check to avoid discrepancies in case we analyze a flow that does not start with SYN...",
          "3902:      but that is already started when nDPI being to process it. See also (***) below",
          "3904:    if(flow->num_processed_pkts > 1)",
          "3905:      flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "3906:  }",
          "3907:       } else if(packet->payload_packet_len > 0) {",
          "3909:  if(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "3910:     ndpi_str->tcp_max_retransmission_window_size) {",
          "3911:    packet->tcp_retransmission = 1;",
          "3914:    if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <",
          "3915:        packet->payload_packet_len)) {",
          "3917:         analyzer which require this info can make use of this info",
          "3919:      packet->num_retried_bytes =",
          "3920:        (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "3921:      packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "3924:        flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3929:     actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.",
          "3931:  else {",
          "3932:    packet->num_retried_bytes = 0;",
          "3933:    flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3937:       if(tcph->rst) {",
          "3938:  flow->next_tcp_seq_nr[0] = 0;",
          "3939:  flow->next_tcp_seq_nr[1] = 0;",
          "3941:     } else if(udph != NULL) {",
          "3942:       if(!ndpi_str->direction_detect_disable)",
          "3943:  packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "3944:     }",
          "3946:     if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "3947:       flow->packet_counter++;",
          "3948:     }",
          "3950:     if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&",
          "3951:        packet->payload_packet_len) {",
          "3952:       flow->packet_direction_counter[packet->packet_direction]++;",
          "3953:     }",
          "3955:     if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "3956:        flow->byte_counter[packet->packet_direction]) {",
          "3957:       flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "3959:   }",
          "3961:   return 1;",
          "3963: }",
          "3967: u_int32_t check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "3968:          struct ndpi_flow_struct *flow,",
          "3969:          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "3970:   void *func = NULL;",
          "3971:   u_int32_t a, num_calls = 0;",
          "3972:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3973:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3974:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3976:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3978:   if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3979:      NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3980:      ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3981:      NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3982:      (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3983:      ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3984:     if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3985:        (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3986:       ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3987:  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func, num_calls++;",
          "3988:   }",
          "3990:   for (a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {",
          "3991:     if((func != ndpi_str->callback_buffer_non_tcp_udp[a].func) &&",
          "3992:        (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3993:        ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask &&",
          "3994:        NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3995:        ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3996:        NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3997:       if(ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)",
          "3998:  ndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow), num_calls++;",
          "4000:       if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4002:     }",
          "4005:   return(num_calls);",
          "4006: }",
          "4010: static u_int32_t check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4011:        struct ndpi_flow_struct *flow,",
          "4012:        NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4013:   void *func = NULL;",
          "4014:   u_int32_t a, num_calls = 0;",
          "4015:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4016:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4017:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4019:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4021:   if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4022:      NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4023:      ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4024:      NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4025:      (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4026:      ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4027:     if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4028:        (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "4029:       ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4030:  func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func, num_calls++;",
          "4031:   }",
          "4033:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4034:     for (a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "4035:       if((func != ndpi_str->callback_buffer_udp[a].func) &&",
          "4036:   (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4037:   ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask &&",
          "4038:   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4039:          ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0 &&",
          "4040:   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "4041:  ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow), num_calls++;",
          "4045: #ifdef DEBUG_UDP_CALLS",
          "4046:  {",
          "4047:    char buf[64];",
          "4048:    u_int16_t proto_id = ndpi_str->callback_buffer_udp[a].ndpi_protocol_id;",
          "4049:    ndpi_protocol proto = { proto_id, proto_id, 0 };",
          "4050:    printf(\"-> [UDP,CALL] dissector of protocol as callback_buffer idx =  %d / %s\\n\",",
          "4051:    proto_id, ndpi_protocol2name(ndpi_str, proto, buf, sizeof(buf)));",
          "4052:  }",
          "4053: #endif",
          "4057:       } else if(_ndpi_debug_callbacks)",
          "4058:  NDPI_LOG_DBG2(ndpi_str, \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\", a);",
          "4060:   } else",
          "4061:     num_calls = 1;",
          "4063:   return(num_calls);",
          "4064: }",
          "4068: static u_int32_t check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4069:        struct ndpi_flow_struct *flow,",
          "4070:        NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4071:   void *func = NULL;",
          "4072:   u_int32_t a, num_calls = 0;",
          "4073:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4074:   int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4075:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4077:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4079:   if(flow->packet.payload_packet_len != 0) {",
          "",
          "[Added Lines]",
          "3815:      struct ndpi_flow_struct *flow) {",
          "3817:   void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,",
          "3818:     struct ndpi_flow_struct *flow) {",
          "3820:     if(!flow) {",
          "3822:       return 0;",
          "3824:       return;",
          "3826:     } else {",
          "3828:       struct ndpi_packet_struct *packet = &flow->packet;",
          "3829:       const struct ndpi_iphdr *iph = packet->iph;",
          "3831:       const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "3833:       const struct ndpi_tcphdr *tcph = packet->tcp;",
          "3834:       const struct ndpi_udphdr *udph = packet->udp;",
          "3836:       packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "3838:       if(ndpi_str->direction_detect_disable) {",
          "3839:  packet->packet_direction = flow->packet_direction;",
          "3840:       } else {",
          "3841:  if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "3842:    packet->packet_direction = 1;",
          "3845:  if(iphv6 != NULL && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)",
          "3846:    packet->packet_direction = 1;",
          "3848:       }",
          "3850:       packet->packet_lines_parsed_complete = 0;",
          "3852:       if(flow->init_finished == 0) {",
          "3853:  flow->init_finished = 1;",
          "3854:  flow->setup_packet_direction = packet->packet_direction;",
          "3857:       if(tcph != NULL) {",
          "3859:  packet->num_retried_bytes = 0;",
          "3861:  if(!ndpi_str->direction_detect_disable)",
          "3862:    packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "3864:  if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3865:     flow->l4.tcp.seen_ack == 0) {",
          "3866:    flow->l4.tcp.seen_syn = 1;",
          "3867:  } else",
          "3868:    if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "3869:       flow->l4.tcp.seen_ack == 0) {",
          "3870:      flow->l4.tcp.seen_syn_ack = 1;",
          "3871:    } else",
          "3872:      if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&",
          "3873:         flow->l4.tcp.seen_ack == 0) {",
          "3874:        flow->l4.tcp.seen_ack = 1;",
          "3875:      }",
          "3879:  if( check_for_sequence(flow, tcph) ) {",
          "3882:    return 0;",
          "3883:  }",
          "3886:  if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||",
          "3887:     (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "3896:    if(tcph->ack != 0) {",
          "3897:      flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "3898:        ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "3901:        Check to avoid discrepancies in case we analyze a flow that does not start with SYN...",
          "3902:        but that is already started when nDPI being to process it. See also (***) below",
          "3904:      if(flow->num_processed_pkts > 1)",
          "3905:        flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "3906:    }",
          "3907:  } else if(packet->payload_packet_len > 0) {",
          "3909:    if(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "3910:       ndpi_str->tcp_max_retransmission_window_size) {",
          "3911:      packet->tcp_retransmission = 1;",
          "3914:      if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <",
          "3915:   packet->payload_packet_len)) {",
          "3917:    analyzer which require this info can make use of this info",
          "3919:        packet->num_retried_bytes =",
          "3920:   (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "3921:        packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "3924:   flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3925:      }",
          "3926:    }",
          "3929:       actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.",
          "3931:    else {",
          "3932:      packet->num_retried_bytes = 0;",
          "3933:      flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "3937:  if(tcph->rst) {",
          "3938:    flow->next_tcp_seq_nr[0] = 0;",
          "3939:    flow->next_tcp_seq_nr[1] = 0;",
          "3941:       } else if(udph != NULL) {",
          "3942:  if(!ndpi_str->direction_detect_disable)",
          "3943:    packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "3946:       if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "3947:  flow->packet_counter++;",
          "3950:       if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&",
          "3951:   packet->payload_packet_len) {",
          "3952:  flow->packet_direction_counter[packet->packet_direction]++;",
          "3953:       }",
          "3955:       if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "3956:   flow->byte_counter[packet->packet_direction]) {",
          "3957:  flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "3958:       }",
          "3961:     return 1;",
          "3967:   u_int32_t check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "3968:            struct ndpi_flow_struct *flow,",
          "3969:            NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "3970:     void *func = NULL;",
          "3971:     u_int32_t a, num_calls = 0;",
          "3972:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "3973:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "3974:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "3976:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "3978:     if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3979:        NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3980:        ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "3981:        NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "3982:        (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3983:        ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "3984:       if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "3985:   (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "3986:  ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "3987:    func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func, num_calls++;",
          "3988:     }",
          "3990:     for (a = 0; a < ndpi_str->callback_buffer_size_non_tcp_udp; a++) {",
          "3991:       if((func != ndpi_str->callback_buffer_non_tcp_udp[a].func) &&",
          "3992:   (ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "3993:   ndpi_str->callback_buffer_non_tcp_udp[a].ndpi_selection_bitmask &&",
          "3994:   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "3995:          ndpi_str->callback_buffer_non_tcp_udp[a].excluded_protocol_bitmask) == 0 &&",
          "3996:   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_non_tcp_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "3997:  if(ndpi_str->callback_buffer_non_tcp_udp[a].func != NULL)",
          "3998:    ndpi_str->callback_buffer_non_tcp_udp[a].func(ndpi_str, flow), num_calls++;",
          "4002:       }",
          "4005:     return(num_calls);",
          "4006:   }",
          "4010:   static u_int32_t check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4011:          struct ndpi_flow_struct *flow,",
          "4012:          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4013:     void *func = NULL;",
          "4014:     u_int32_t a, num_calls = 0;",
          "4015:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4016:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4017:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4019:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4090:     }",
          "4092:     if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4097:     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4102:    if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4105:       }",
          "4130:   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4137:       }",
          "4138:     }",
          "4184:     }",
          "4185:   }",
          "4262:  }",
          "4266:       }",
          "4277:     }",
          "4282:     }",
          "4307:     }",
          "4313:   }",
          "4347: #ifdef FRAG_MAN",
          "4349: #else // FRAG_MAN",
          "4351: #endif // FRAG_MAN",
          "4361: #ifdef FRAG_MAN",
          "4363: #endif // FRAG_MAN",
          "4416: #if 0",
          "4418: #endif",
          "4516:          ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4517:  node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4518:       }",
          "4525:     }",
          "4551:       }",
          "4563:       }",
          "4564:     }",
          "4565:   }",
          "4618:     }",
          "4638:   }",
          "4652:     }",
          "4671:    ndpi_lru_add_to_cache(ndpi_str->msteams_cache,",
          "4672:     flow->packet.iph->saddr,",
          "4673:     (flow->packet.current_time_ms / 1000) & 0xFFFF /* 16 bit */);",
          "4675:       }",
          "4686:       break;",
          "4689:       break;",
          "4690:     }",
          "4720: #ifdef FRAG_MAN",
          "4722: #endif // FRAG_MAN",
          "4781: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4787: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4789: #endif",
          "4797: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "4801: #endif",
          "4841:  ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4842:  goto invalidate_ptr;",
          "4843:       }",
          "4867: #endif",
          "4868:       }",
          "4869:     }",
          "4896:       }",
          "4897:     }",
          "4971:  }",
          "4982:       }",
          "4988:     }",
          "4999: #ifdef FRAG_MAN",
          "5008: #endif // FRAG_MAN",
          "5032:   }",
          "5064:       str++;",
          "5065:       max_chars_to_read = max_chars_to_read - 1;",
          "5067:     }",
          "5087:   }",
          "5117:       str++;",
          "5118:       max_chars_to_read = max_chars_to_read - 1;",
          "5120:     }",
          "5121:   }",
          "5203:  }",
          "5230:  }",
          "5246:  }",
          "5259:  }",
          "5272:  }",
          "5305:  }",
          "5351:       }",
          "5419:       packet->parsed_lines++;",
          "5424:     }",
          "5425:   }",
          "5473:     }",
          "5474:   }",
          "5498:       counter++;",
          "5501:  counter++;",
          "5508:    counter++;",
          "5511:      counter++;",
          "5525:   if(packet->payload_packet_len > counter &&",
          "5526:      (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5528:     return(counter);",
          "5529:   } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5530:      packet->payload[counter] <= 'z') {",
          "5531:     counter++;",
          "5532:     if(packet->payload_packet_len > counter &&",
          "5533:        (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5535:       return(counter);",
          "5536:     } else {",
          "5537:       return(0);",
          "5538:     }",
          "",
          "[Removed Lines]",
          "4093:       for (a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {",
          "4094:  if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4095:     (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4096:     ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask &&",
          "4098:     ndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4099:     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,",
          "4100:     detection_bitmask) != 0) {",
          "4101:    ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow), num_calls++;",
          "4104:  }",
          "4106:     }",
          "4107:   } else {",
          "4110:     num_calls = 1;",
          "4112:     if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4113:        NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4114:        ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4115:        NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4116:        (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4117:        ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4118:       if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4119:   (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&",
          "4120:   ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &",
          "4121:     NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))",
          "4122:  ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4123:    func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func, num_calls++;",
          "4124:     }",
          "4126:     for (a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {",
          "4127:       if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4128:   (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4129:   ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask &&",
          "4131:          ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4132:   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,",
          "4133:          detection_bitmask) != 0) {",
          "4134:  ndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow), num_calls++;",
          "4135:  if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4139:   }",
          "4141:   return(num_calls);",
          "4142: }",
          "4146: u_int32_t ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4147:           struct ndpi_flow_struct *flow,",
          "4148:           NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4149:   if(!flow)",
          "4150:     return(0);",
          "4151:   else if(flow->packet.tcp != NULL)",
          "4152:     return(check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4153:   else if(flow->packet.udp != NULL)",
          "4154:     return(check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4155:   else",
          "4156:     return(check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4157: }",
          "4161: u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "4162:           struct ndpi_flow_struct *flow) {",
          "4163:   u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4165:   if(flow->packet.iph) {",
          "4166:     struct in_addr addr;",
          "4167:     u_int16_t sport, dport;",
          "4169:     addr.s_addr = flow->packet.iph->saddr;",
          "4171:     if((flow->l4_proto == IPPROTO_TCP) && flow->packet.tcp)",
          "4172:       sport = flow->packet.tcp->source, dport = flow->packet.tcp->dest;",
          "4173:     else if((flow->l4_proto == IPPROTO_UDP) && flow->packet.udp)",
          "4174:       sport = flow->packet.udp->source, dport = flow->packet.udp->dest;",
          "4175:     else",
          "4176:       sport = dport = 0;",
          "4179:     ret = ndpi_network_port_ptree_match(ndpi_str, &addr, sport);",
          "4181:     if(ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4182:       addr.s_addr = flow->packet.iph->daddr;",
          "4183:       ret = ndpi_network_port_ptree_match(ndpi_str, &addr, dport);",
          "4187:   return(ret);",
          "4188: }",
          "4192: ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4193:                                     u_int8_t enable_guess, u_int8_t *protocol_was_guessed) {",
          "4194:   ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4198:   if(flow == NULL)",
          "4199:     return(ret);",
          "4202:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4203:   ret.category = flow->category;",
          "4206:   if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4207:     return(ret);",
          "4210:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4211:     u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4213:     if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4214:       goto check_stun_export;",
          "4215:     else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||",
          "4216:      (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||",
          "4217:      (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {",
          "4219:       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4220:     }",
          "4221:     else if((flow->l4.tcp.tls.hello_processed == 1) &&",
          "4222:      (flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0')) {",
          "4224:       ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4225:     } else if(enable_guess) {",
          "4226:       if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&",
          "4227:   flow->l4.tcp.tls.hello_processed)",
          "4228:  flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4230:       guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4232:       if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4233:   ((flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4234:    NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&",
          "4235:    is_udp_guessable_protocol(guessed_host_protocol_id)))",
          "4236:  flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4239:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4241:   && (flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4242:   NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&",
          "4243:   is_udp_guessable_protocol(guessed_protocol_id))",
          "4244:  flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4246:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4247:  if((guessed_protocol_id == 0) && (flow->protos.tls_quic_stun.stun.num_binding_requests > 0) &&",
          "4248:     (flow->protos.tls_quic_stun.stun.num_processed_pkts > 0))",
          "4249:    guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4251:  if(flow->host_server_name[0] != '\\0') {",
          "4252:    ndpi_protocol_match_result ret_match;",
          "4254:    memset(&ret_match, 0, sizeof(ret_match));",
          "4256:    ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,",
          "4257:           strlen((const char *) flow->host_server_name), &ret_match,",
          "4258:           NDPI_PROTOCOL_DNS);",
          "4260:    if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4261:      guessed_host_protocol_id = ret_match.protocol_id;",
          "4265:  ndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);",
          "4267:     }",
          "4268:   } else if(enable_guess) {",
          "4269:     if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4271:       flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4272:     }",
          "4274:     if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4276:       flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4279:     if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {",
          "4281:       flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4283:   }",
          "4285:   if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&",
          "4286:      (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4287:   check_stun_export:",
          "4288:     if(flow->protos.tls_quic_stun.stun.num_processed_pkts || flow->protos.tls_quic_stun.stun.num_udp_pkts) {",
          "4291:       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);",
          "4292:     }",
          "4293:   }",
          "4295:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4297:   if(ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4298:     if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4299:       ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4300:     else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4302:  As Google has recently introduced Duo,",
          "4303:  we need to distinguish between it and hangout",
          "4304:  thing that should be handled by the STUN dissector",
          "4306:       ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4308:   }",
          "4310:   if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {",
          "4312:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4315:   return(ret);",
          "4316: }",
          "4320: void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4321:                                const unsigned char *packet, const unsigned short packetlen,",
          "4322:                                const u_int64_t current_time_ms, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4323:   if(flow == NULL)",
          "4324:     return;",
          "4326:   if(flow->server_id == NULL)",
          "4330:   if(packetlen < 20) {",
          "4331:     return;",
          "4332:   }",
          "4334:   flow->packet.current_time_ms = current_time_ms;",
          "4337:   flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4341:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4342:     return;",
          "4345:   flow->src = src, flow->dst = dst;",
          "4348:   if ( ndpi_connection_tracking(ndpi_str, flow) ) {",
          "4350:   ndpi_connection_tracking(ndpi_str, flow);",
          "4354:   if(flow->extra_packets_func) {",
          "4355:     if((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4356:       flow->check_extra_packets = 0;",
          "4358:     if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4360:   }",
          "4362:   }",
          "4364: }",
          "4370: int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,",
          "4371:                           ndpi_protocol_category_t category) {",
          "4372:   patricia_node_t *node;",
          "4373:   struct in_addr pin;",
          "4374:   int bits = 32;",
          "4375:   char *ptr;",
          "4376:   char ipbuf[64];",
          "4378:   strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4379:   ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4381:   ptr = strrchr(ipbuf, '/');",
          "4383:   if(ptr) {",
          "4385:     if(atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "4386:       bits = atoi(ptr);",
          "4387:   }",
          "4389:   if(inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4390:     NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4391:     return(-1);",
          "4392:   }",
          "4394:   if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL) {",
          "4395:     node->value.u.uv32.user_value = (u_int16_t)category, node->value.u.uv32.additional_user_value = 0;",
          "4396:   }",
          "4398:   return(0);",
          "4399: }",
          "4404: int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,",
          "4405:                                 ndpi_protocol_category_t category) {",
          "4406:   char *name;",
          "4408:   if(name_to_add == NULL)",
          "4409:     return(-1);",
          "4411:   name = ndpi_strdup(name_to_add);",
          "4413:   if(name == NULL)",
          "4414:     return(-1);",
          "4417:   printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);",
          "4420:   AC_PATTERN_t ac_pattern;",
          "4421:   AC_ERROR_t rc;",
          "4423:   memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "4425:   if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4426:     ndpi_free(name);",
          "4427:     return(-1);",
          "4428:   }",
          "4430:   ac_pattern.astring = name, ac_pattern.length = strlen(ac_pattern.astring);",
          "4431:   ac_pattern.rep.number = (u_int32_t) category,  ac_pattern.rep.category = category;;",
          "4433:   rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);",
          "4434:   if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {",
          "4435:     ndpi_free(name);",
          "4436:     return(-1);",
          "4437:   }",
          "4439:   if(rc == ACERR_DUPLICATE_PATTERN)",
          "4440:     ndpi_free(name);",
          "4442:   return(0);",
          "4443: }",
          "4448: int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,",
          "4449:                        ndpi_protocol_category_t category) {",
          "4450:   int rv;",
          "4453:   rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4455:   if(rv < 0) {",
          "4457:     rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4458:   }",
          "4460:   return(rv);",
          "4461: }",
          "4465: int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {",
          "4466:   int i;",
          "4469:   for (i = 0; category_match[i].string_to_match != NULL; i++)",
          "4470:     ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4473:   ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "4474:         1 /* free patterns strings memory */);",
          "4477:   ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4480:   ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4483:   ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4485:   if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "4486:     ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "4488:   ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4489:   ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "4491:   ndpi_str->custom_categories.categories_loaded = 1;",
          "4493:   return(0);",
          "4494: }",
          "4498: int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,",
          "4499:                                    ndpi_protocol *ret) {",
          "4500:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4501:     prefix_t prefix;",
          "4502:     patricia_node_t *node;",
          "4504:     if(saddr == 0)",
          "4505:       node = NULL;",
          "4506:     else {",
          "4508:       fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,",
          "4509:        ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4510:       node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4511:     }",
          "4513:     if(!node) {",
          "4514:       if(daddr != 0) {",
          "4515:  fill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,",
          "4519:     }",
          "4521:     if(node) {",
          "4522:       ret->category = (ndpi_protocol_category_t) node->value.u.uv32.user_value;",
          "4524:       return(1);",
          "4526:   }",
          "4528:   ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4530:   return(0);",
          "4531: }",
          "4535: void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4536:                                  ndpi_protocol *ret) {",
          "4537:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4538:     if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4539:       flow->category = ret->category = flow->guessed_header_category;",
          "4540:       return;",
          "4541:     }",
          "4543:     if(flow->host_server_name[0] != '\\0') {",
          "4544:       u_int32_t id;",
          "4545:       int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,",
          "4546:        strlen((char *) flow->host_server_name), &id);",
          "4548:       if(rc == 0) {",
          "4549:  flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4550:  return;",
          "4552:     }",
          "4554:     if(flow->l4.tcp.tls.hello_processed == 1 &&",
          "4555:        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {",
          "4556:       u_int32_t id;",
          "4557:       int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,",
          "4558:        strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name), &id);",
          "4560:       if(rc == 0) {",
          "4561:  flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4562:  return;",
          "4567:   flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4568: }",
          "4572: static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {",
          "4573:   packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,",
          "4574:     packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,",
          "4575:     packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,",
          "4576:     packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,",
          "4577:     packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,",
          "4578:     packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,",
          "4579:     packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,",
          "4580:     packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,",
          "4581:     packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,",
          "4582:     packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,",
          "4583:     packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,",
          "4584:     packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0,",
          "4585:     packet->forwarded_line.ptr = NULL, packet->forwarded_line.len = 0;",
          "4586: }",
          "4590: static int ndpi_is_ntop_protocol(ndpi_protocol *ret) {",
          "4591:   if((ret->master_protocol == NDPI_PROTOCOL_HTTP) && (ret->app_protocol == NDPI_PROTOCOL_NTOP))",
          "4592:     return(1);",
          "4593:   else",
          "4594:     return(0);",
          "4595: }",
          "4599: static int ndpi_check_protocol_port_mismatch_exceptions(struct ndpi_detection_module_struct *ndpi_str,",
          "4600:        struct ndpi_flow_struct *flow,",
          "4601:        ndpi_default_ports_tree_node_t *expected_proto,",
          "4602:        ndpi_protocol *returned_proto) {",
          "4604:     For TLS (and other protocols) it is not simple to guess the exact protocol so before",
          "4605:     triggering an alert we need to make sure what we have exhausted all the possible",
          "4606:     options available",
          "4609:   if(ndpi_is_ntop_protocol(returned_proto)) return(1);",
          "4611:   if(returned_proto->master_protocol == NDPI_PROTOCOL_TLS) {",
          "4612:     switch(expected_proto->proto->protoId) {",
          "4613:     case NDPI_PROTOCOL_MAIL_IMAPS:",
          "4614:     case NDPI_PROTOCOL_MAIL_POPS:",
          "4615:     case NDPI_PROTOCOL_MAIL_SMTPS:",
          "4617:       break;",
          "4619:   }",
          "4621:   return(0);",
          "4622: }",
          "4626: static void ndpi_reconcile_protocols(struct ndpi_detection_module_struct *ndpi_str,",
          "4627:          struct ndpi_flow_struct *flow,",
          "4628:          ndpi_protocol *ret) {",
          "4630:     Skype for a host doing MS Teams means MS Teams",
          "4631:     (MS Teams uses Skype as transport protocol for voice/video)",
          "4633:   if(flow) {",
          "4635:     if((flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN)",
          "4636:        && (flow->detected_protocol_stack[0] /* app */ != flow->detected_protocol_stack[1] /* major */))",
          "4637:       NDPI_CLR_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "4640:   switch(ret->app_protocol) {",
          "4641:   case NDPI_PROTOCOL_MSTEAMS:",
          "4642:     if(flow->packet.iph && flow->packet.tcp) {",
          "4645:       if(ndpi_str->msteams_cache == NULL)",
          "4646:  ndpi_str->msteams_cache = ndpi_lru_cache_init(1024);",
          "4648:       if(ndpi_str->msteams_cache)",
          "4649:  ndpi_lru_add_to_cache(ndpi_str->msteams_cache,",
          "4650:          flow->packet.iph->saddr,",
          "4651:          (flow->packet.current_time_ms / 1000) & 0xFFFF /* 16 bit */);",
          "4653:     break;",
          "4655:   case NDPI_PROTOCOL_SKYPE:",
          "4656:   case NDPI_PROTOCOL_SKYPE_CALL:",
          "4657:     if(flow->packet.iph",
          "4658:        && flow->packet.udp",
          "4659:        && ndpi_str->msteams_cache) {",
          "4660:       u_int16_t when;",
          "4662:       if(ndpi_lru_find_cache(ndpi_str->msteams_cache, flow->packet.iph->saddr,",
          "4663:         &when, 0 /* Don't remove it as it can be used for other connections */)) {",
          "4664:  u_int16_t tdiff = ((flow->packet.current_time_ms /1000) & 0xFFFF) - when;",
          "4666:  if(tdiff < 60 /* sec */) {",
          "4668:    ret->app_protocol = NDPI_PROTOCOL_MSTEAMS;",
          "4674:  }",
          "4676:     }",
          "4677:     break;",
          "4680:   if(flow) {",
          "4681:     switch(ndpi_get_proto_breed(ndpi_str, ret->app_protocol)) {",
          "4682:     case NDPI_PROTOCOL_UNSAFE:",
          "4683:     case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "4684:     case NDPI_PROTOCOL_DANGEROUS:",
          "4685:       NDPI_SET_BIT(flow->risk, NDPI_UNSAFE_PROTOCOL);",
          "4687:     default:",
          "4691:   }",
          "4693: }",
          "4697: ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,",
          "4698:                                             struct ndpi_flow_struct *flow, const unsigned char *packet,",
          "4699:                                             const unsigned short packetlen, const u_int64_t current_time_ms,",
          "4700:                                             struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4701:   NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "4702:   u_int32_t a, num_calls = 0;",
          "4703:   ndpi_protocol ret = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };",
          "4705:   if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "4706:     NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,",
          "4707:       \"START packet processing\\n\");",
          "4709:   if(flow == NULL)",
          "4710:     return(ret);",
          "4711:   else",
          "4712:     ret.category = flow->category;",
          "4714:   if(flow->fail_with_unknown) {",
          "4716:     return(ret);",
          "4717:   }",
          "4719:   flow->num_processed_pkts++;",
          "4721:   flow->tcp_segments_management=1;",
          "4725:   ret.master_protocol = flow->detected_protocol_stack[1],",
          "4726:     ret.app_protocol = flow->detected_protocol_stack[0];",
          "4728:   if(flow->server_id == NULL)",
          "4731:   if(flow->check_extra_packets) {",
          "4732:     ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_time_ms, src, dst);",
          "4734:     ret.master_protocol = flow->detected_protocol_stack[1],",
          "4735:     ret.app_protocol = flow->detected_protocol_stack[0],",
          "4736:     ret.category = flow->category;",
          "4737:     goto invalidate_ptr;",
          "4738:   } else if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4739:     goto ret_protocols;",
          "4742:   if(packetlen < 20) {",
          "4744:     ndpi_int_reset_packet_protocol(&flow->packet);",
          "4745:     goto invalidate_ptr;",
          "4746:   }",
          "4748:   flow->packet.current_time_ms = current_time_ms;",
          "4751:   flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4754:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4755:     goto invalidate_ptr;",
          "4758:   flow->src = src, flow->dst = dst;",
          "4760:   ndpi_connection_tracking(ndpi_str, flow);",
          "4763:   ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "4764:   if(flow->packet.iph != NULL)",
          "4765:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4767:   if(flow->packet.tcp != NULL)",
          "4768:     ndpi_selection_packet |=",
          "4769:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4771:   if(flow->packet.udp != NULL)",
          "4772:     ndpi_selection_packet |=",
          "4773:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4775:   if(flow->packet.payload_packet_len != 0)",
          "4776:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "4778:   if(flow->packet.tcp_retransmission == 0)",
          "4779:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "4782:   if(flow->packet.iphv6 != NULL)",
          "4783:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4786:   if((!flow->protocol_id_already_guessed) && (",
          "4788:            flow->packet.iphv6 ||",
          "4790:            flow->packet.iph)) {",
          "4791:     u_int16_t sport, dport;",
          "4792:     u_int8_t protocol;",
          "4793:     u_int8_t user_defined_proto;",
          "4795:     flow->protocol_id_already_guessed = 1;",
          "4798:     if(flow->packet.iphv6 != NULL) {",
          "4799:       protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "4800:     } else",
          "4802:       {",
          "4803:  protocol = flow->packet.iph->protocol;",
          "4804:       }",
          "4806:     if(flow->packet.udp)",
          "4807:       sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "4808:     else if(flow->packet.tcp)",
          "4809:       sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "4810:     else",
          "4811:       sport = dport = 0;",
          "4814:     flow->guessed_protocol_id =",
          "4815:       (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "4816:     flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4818:     if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "4819:       ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);",
          "4820:       flow->guessed_header_category = ret.category;",
          "4821:     } else",
          "4822:       flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "4824:     if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4826:       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "4827:  ret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "4828:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4829:       goto invalidate_ptr;",
          "4830:     }",
          "4832:     if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4833:       if(flow->packet.iph) {",
          "4834:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4835:    u_int8_t protocol_was_guessed;",
          "4838:    ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4839:  }",
          "4844:     } else {",
          "4846:       if(flow->packet.iph) {",
          "4848:  flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4851:    We could implement a shortcut here skipping dissectors for",
          "4852:    protocols we have identified by other means such as with the IP",
          "4854:    However we do NOT stop here and skip invoking the dissectors",
          "4855:    because we want to dissect the flow (e.g. dissect the TLS)",
          "4856:    and extract metadata.",
          "4858: #if SKIP_INVOKING_THE_DISSECTORS",
          "4859:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4861:      We have identified a protocol using the IP address so",
          "4862:      it is not worth to dissect the traffic as we already have",
          "4863:      the solution",
          "4865:    ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4866:  }",
          "4870:   }",
          "4872:   if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4874:     ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4876:     num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4877:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4878:     goto invalidate_ptr;",
          "4879:   }",
          "4881:   num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4883:   a = flow->packet.detected_protocol_stack[0];",
          "4884:   if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "4885:     a = NDPI_PROTOCOL_UNKNOWN;",
          "4887:   if(a != NDPI_PROTOCOL_UNKNOWN) {",
          "4888:     int i;",
          "4890:     for (i = 0; i < sizeof(flow->host_server_name); i++) {",
          "4891:       if(flow->host_server_name[i] != '\\0')",
          "4892:  flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "4893:       else {",
          "4894:  flow->host_server_name[i] = '\\0';",
          "4895:  break;",
          "4898:   }",
          "4900:  ret_protocols:",
          "4901:   if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "4902:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4904:     if(ret.app_protocol == ret.master_protocol)",
          "4905:       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4906:   } else",
          "4907:     ret.app_protocol = flow->detected_protocol_stack[0];",
          "4910:   if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4911:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4912:   else",
          "4913:     ret.category = flow->category;",
          "4915:   if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&",
          "4916:      (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&",
          "4917:      (flow->guessed_protocol_id == 0)) {",
          "4918:     u_int8_t protocol_was_guessed;",
          "4921:       This is a TCP flow",
          "4922:       - whose first packet is NOT a SYN",
          "4923:       - no protocol has been detected",
          "4925:       We don't see how future packets can match anything",
          "4926:       hence we giveup here",
          "4928:     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4929:   }",
          "4931:   if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&",
          "4932:      (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4933:     ret.master_protocol = ret.app_protocol;",
          "4934:     ret.app_protocol = flow->guessed_host_protocol_id;",
          "4935:   }",
          "4937:   if((!flow->risk_checked) && (ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)) {",
          "4938:     ndpi_default_ports_tree_node_t *found;",
          "4939:     u_int16_t *default_ports, sport, dport;",
          "4941:     if(flow->packet.udp)",
          "4942:       found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,",
          "4943:         sport = ntohs(flow->packet.udp->source),",
          "4944:         dport = ntohs(flow->packet.udp->dest)),",
          "4945:  default_ports = ndpi_str->proto_defaults[ret.master_protocol].udp_default_ports;",
          "4946:     else if(flow->packet.tcp)",
          "4947:       found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,",
          "4948:         sport = ntohs(flow->packet.tcp->source),",
          "4949:         dport = ntohs(flow->packet.tcp->dest)),",
          "4950:  default_ports = ndpi_str->proto_defaults[ret.master_protocol].tcp_default_ports;",
          "4951:     else",
          "4952:       found = NULL, default_ports = NULL;",
          "4954:     if(found",
          "4955:        && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)",
          "4956:        && (found->proto->protoId != ret.master_protocol)",
          "4957:        && (found->proto->protoId != ret.app_protocol)",
          "4958:        ) {",
          "4961:       if(!ndpi_check_protocol_port_mismatch_exceptions(ndpi_str, flow, found, &ret))",
          "4962:  NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "4963:     } else if((!ndpi_is_ntop_protocol(&ret)) && default_ports && (default_ports[0] != 0)) {",
          "4964:       u_int8_t found = 0, i, num_loops = 0;",
          "4966:     check_default_ports:",
          "4967:       for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {",
          "4968:  if((default_ports[i] == sport) || (default_ports[i] == dport)) {",
          "4969:    found = 1;",
          "4970:    break;",
          "4974:       if((num_loops == 0) && (!found)) {",
          "4975:  if(flow->packet.udp)",
          "4976:    default_ports = ndpi_str->proto_defaults[ret.app_protocol].udp_default_ports;",
          "4977:  else",
          "4978:    default_ports = ndpi_str->proto_defaults[ret.app_protocol].tcp_default_ports;",
          "4980:  num_loops = 1;",
          "4981:  goto check_default_ports;",
          "4984:       if(!found) {",
          "4986:  NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "4987:       }",
          "4990:     flow->risk_checked = 1;",
          "4991:   }",
          "4993:   ndpi_reconcile_protocols(ndpi_str, flow, &ret);",
          "4995:   if(num_calls == 0)",
          "4996:     flow->fail_with_unknown = 1;",
          "4998:  invalidate_ptr:",
          "5000: if (flow->must_free[flow->packet.packet_direction] &&",
          "5001:       flow->packet.payload_packet_len>0 && flow->packet.payload) {",
          "5003:     ndpi_free((void*)flow->packet.payload);",
          "5005:     flow->packet.payload_packet_len=0;",
          "5006:     flow->must_free[flow->packet.packet_direction]=0;",
          "5007:   }",
          "5010:     Invalidate packet memory to avoid accessing the pointers below",
          "5011:     when the packet is no longer accessible",
          "5013:   flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "5014:   ndpi_reset_packet_line_info(&flow->packet);",
          "5016:   return(ret);",
          "5017: }",
          "5021: u_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5022:   u_int32_t val;",
          "5023:   val = 0;",
          "5026:   while (*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "5027:     val *= 10;",
          "5028:     val += *str - '0';",
          "5029:     str++;",
          "5030:     max_chars_to_read = max_chars_to_read - 1;",
          "5034:   return(val);",
          "5035: }",
          "5039: #ifdef CODE_UNUSED",
          "5040: u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5041:   u_int32_t val;",
          "5042:   val = 0;",
          "5043:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5044:     return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "5045:   } else {",
          "5047:     str += 2;",
          "5048:     max_chars_to_read -= 2;",
          "5051:     while (max_chars_to_read > 0) {",
          "5052:       if(*str >= '0' && *str <= '9') {",
          "5053:  val *= 16;",
          "5054:  val += *str - '0';",
          "5055:       } else if(*str >= 'a' && *str <= 'f') {",
          "5056:  val *= 16;",
          "5057:  val += *str + 10 - 'a';",
          "5058:       } else if(*str >= 'A' && *str <= 'F') {",
          "5059:  val *= 16;",
          "5060:  val += *str + 10 - 'A';",
          "5061:       } else {",
          "5062:  break;",
          "5063:       }",
          "5068:   }",
          "5070:   return(val);",
          "5071: }",
          "5073: #endif",
          "5077: u_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5078:   u_int64_t val;",
          "5079:   val = 0;",
          "5081:   while (max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "5082:     val *= 10;",
          "5083:     val += *str - '0';",
          "5084:     str++;",
          "5085:     max_chars_to_read = max_chars_to_read - 1;",
          "5088:   return(val);",
          "5089: }",
          "5093: u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,",
          "5094:                                                  u_int16_t *bytes_read) {",
          "5095:   u_int64_t val;",
          "5096:   val = 0;",
          "5097:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5098:     return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "5099:   } else {",
          "5101:     str += 2;",
          "5102:     max_chars_to_read -= 2;",
          "5104:     while (max_chars_to_read > 0) {",
          "5105:       if(*str >= '0' && *str <= '9') {",
          "5106:  val *= 16;",
          "5107:  val += *str - '0';",
          "5108:       } else if(*str >= 'a' && *str <= 'f') {",
          "5109:  val *= 16;",
          "5110:  val += *str + 10 - 'a';",
          "5111:       } else if(*str >= 'A' && *str <= 'F') {",
          "5112:  val *= 16;",
          "5113:  val += *str + 10 - 'A';",
          "5114:       } else {",
          "5115:  break;",
          "5116:       }",
          "5122:   return(val);",
          "5123: }",
          "5127: u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5128:   u_int32_t val;",
          "5129:   u_int16_t read = 0;",
          "5130:   u_int16_t oldread;",
          "5131:   u_int32_t c;",
          "5134:   oldread = read;",
          "5135:   c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "5136:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5137:     return(0);",
          "5139:   read++;",
          "5140:   val = c << 24;",
          "5141:   oldread = read;",
          "5142:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5143:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5144:     return(0);",
          "5146:   read++;",
          "5147:   val = val + (c << 16);",
          "5148:   oldread = read;",
          "5149:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5150:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5151:     return(0);",
          "5153:   read++;",
          "5154:   val = val + (c << 8);",
          "5155:   oldread = read;",
          "5156:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5157:   if(c > 255 || oldread == read || max_chars_to_read == read)",
          "5158:     return(0);",
          "5160:   val = val + c;",
          "5164:   return(htonl(val));",
          "5165: }",
          "5170: void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5171:   u_int32_t a;",
          "5172:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5174:   if((packet->payload_packet_len < 3) || (packet->payload == NULL))",
          "5175:     return;",
          "5177:   if(packet->packet_lines_parsed_complete != 0)",
          "5178:     return;",
          "5180:   packet->packet_lines_parsed_complete = 1;",
          "5181:   ndpi_reset_packet_line_info(packet);",
          "5183:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5184:   packet->line[packet->parsed_lines].len = 0;",
          "5186:   for (a = 0; ((a+1) < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "5187:     if((packet->payload[a] == 0x0d) && (packet->payload[a+1] == 0x0a)) {",
          "5190:       if(((a + 3) < packet->payload_packet_len)",
          "5191:   && (packet->payload[a+2] == 0x0d)",
          "5192:   && (packet->payload[a+3] == 0x0a)) {",
          "5195:  u_int32_t a1 = a + 4;",
          "5197:  diff = packet->payload_packet_len - a1;",
          "5199:  if(diff > 0) {",
          "5200:    diff = ndpi_min(diff, sizeof(flow->initial_binary_bytes));",
          "5201:    memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);",
          "5202:    flow->initial_binary_bytes_len = diff;",
          "5204:       }",
          "5206:       packet->line[packet->parsed_lines].len =",
          "5207:  (u_int16_t)(((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5210:       if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "5211:   strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "5213:   packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "5214:  packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "5215:  packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "5216:  packet->http_num_headers++;",
          "5219:  if(packet->payload_packet_len >= 12) {",
          "5220:    char buf[4];",
          "5223:    strncpy(buf, (char *) &packet->payload[9], 3);",
          "5224:    buf[3] = '\\0';",
          "5226:    flow->http.response_status_code = atoi(buf);",
          "5228:    if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "5231:       }",
          "5234:       if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&",
          "5235:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5236:        \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "5238:  if(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "5239:    packet->server_line.ptr =",
          "5240:      &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "5241:    packet->server_line.len =",
          "5242:      packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "5243:  } else {",
          "5244:    packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "5245:    packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "5247:  packet->http_num_headers++;",
          "5248:       }",
          "5250:       if(packet->line[packet->parsed_lines].len > 6 &&",
          "5251:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {",
          "5253:  if(packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "5254:    packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "5255:    packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "5256:  } else {",
          "5257:    packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "5258:    packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "5260:  packet->http_num_headers++;",
          "5261:       }",
          "5263:       if(packet->line[packet->parsed_lines].len > 17 &&",
          "5264:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "5266:  if(packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "5267:    packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "5268:    packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "5269:  } else {",
          "5270:    packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5271:    packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "5273:  packet->http_num_headers++;",
          "5274:       }",
          "5276:       if(packet->line[packet->parsed_lines].len > 14 &&",
          "5277:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||",
          "5278:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5279:  packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5280:  packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5282:  while ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5283:    packet->content_line.len--, packet->content_line.ptr++;",
          "5285:  packet->http_num_headers++;",
          "5286:       }",
          "5288:       if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&",
          "5289:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5290:  packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5291:  packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5292:  packet->http_num_headers++;",
          "5293:       }",
          "5295:       if(packet->content_line.len > 0) {",
          "5297:  char separator[] = {';', '\\r', '\\0'};",
          "5298:  int i;",
          "5300:  for (i = 0; separator[i] != '\\0'; i++) {",
          "5301:    char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5303:    if(c != NULL)",
          "5304:      packet->content_line.len = c - (char *) packet->content_line.ptr;",
          "5306:       }",
          "5309:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5310:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5311:  packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5312:  packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5313:  packet->http_num_headers++;",
          "5314:       }",
          "5316:       if(packet->line[packet->parsed_lines].len > 9 &&",
          "5317:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5318:  packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5319:  packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5320:  packet->http_num_headers++;",
          "5321:       }",
          "5323:       if(packet->line[packet->parsed_lines].len > 12 &&",
          "5324:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||",
          "5325:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5326:  packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5327:  packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5328:  packet->http_num_headers++;",
          "5329:       }",
          "5331:       if(packet->line[packet->parsed_lines].len > 18 &&",
          "5332:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5333:  packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5334:  packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5335:  packet->http_num_headers++;",
          "5336:       }",
          "5338:       if(packet->line[packet->parsed_lines].len > 19 &&",
          "5339:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5340:  packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5341:  packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5342:  packet->http_num_headers++;",
          "5343:       }",
          "5345:       if(packet->line[packet->parsed_lines].len > 16 &&",
          "5346:   ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||",
          "5347:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5348:  packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5349:  packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5350:  packet->http_num_headers++;",
          "5353:       if(packet->line[packet->parsed_lines].len > 21 &&",
          "5354:   ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Disposition: \", 21) == 0))) {",
          "5355:  packet->content_disposition_line.ptr = &packet->line[packet->parsed_lines].ptr[21];",
          "5356:  packet->content_disposition_line.len = packet->line[packet->parsed_lines].len - 21;",
          "5357:  packet->http_num_headers++;",
          "5358:       }",
          "5360:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5361:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5362:  packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5363:  packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5364:  packet->http_num_headers++;",
          "5365:       }",
          "5367:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5368:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5369:  packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5370:  packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5371:  packet->http_num_headers++;",
          "5372:       }",
          "5374:       if(packet->line[packet->parsed_lines].len > 16 &&",
          "5375:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5376:  packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5377:  packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5378:  packet->http_num_headers++;",
          "5379:       }",
          "5386:       if((packet->line[packet->parsed_lines].len > 6 &&",
          "5387:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5388:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5389:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||",
          "5390:   (packet->line[packet->parsed_lines].len > 8 &&",
          "5391:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5392:   (packet->line[packet->parsed_lines].len > 9 &&",
          "5393:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5394:   (packet->line[packet->parsed_lines].len > 12 &&",
          "5395:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5396:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5397:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5398:   (packet->line[packet->parsed_lines].len > 15 &&",
          "5399:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5400:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5401:   (packet->line[packet->parsed_lines].len > 17 &&",
          "5402:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5403:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5404:   (packet->line[packet->parsed_lines].len > 27 &&",
          "5405:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5406:         \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5408:  packet->http_num_headers++;",
          "5409:       }",
          "5411:       if(packet->line[packet->parsed_lines].len == 0) {",
          "5412:  packet->empty_line_position = a;",
          "5413:  packet->empty_line_position_set = 1;",
          "5414:       }",
          "5416:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5417:  return;",
          "5420:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5421:       packet->line[packet->parsed_lines].len = 0;",
          "5427:   if(packet->parsed_lines >= 1) {",
          "5428:     packet->line[packet->parsed_lines].len =",
          "5429:       (u_int16_t)(((size_t) &packet->payload[packet->payload_packet_len]) -",
          "5430:     ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5431:     packet->parsed_lines++;",
          "5432:   }",
          "5433: }",
          "5437: void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5438:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5439:   u_int32_t a;",
          "5440:   u_int16_t end = packet->payload_packet_len;",
          "5442:   if(packet->packet_lines_parsed_complete != 0)",
          "5443:     return;",
          "5445:   packet->packet_lines_parsed_complete = 1;",
          "5446:   packet->parsed_lines = 0;",
          "5448:   if(packet->payload_packet_len == 0)",
          "5449:     return;",
          "5451:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5452:   packet->line[packet->parsed_lines].len = 0;",
          "5454:   for (a = 0; a < end; a++) {",
          "5455:     if(packet->payload[a] == 0x0a) {",
          "5456:       packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5457:           ((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5459:       if(a > 0 && packet->payload[a - 1] == 0x0d)",
          "5460:  packet->line[packet->parsed_lines].len--;",
          "5462:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5463:  break;",
          "5465:       packet->parsed_lines++;",
          "5466:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5467:       packet->line[packet->parsed_lines].len = 0;",
          "5469:       if((a + 1) >= packet->payload_packet_len)",
          "5470:  break;",
          "5475: }",
          "5479: u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5480:                                        u_int16_t counter) {",
          "5481:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5483:   NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5485:   if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5486:            (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5487:            (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5488:            packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5489:     NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5490:     counter++;",
          "5491:     while (packet->payload_packet_len > counter &&",
          "5492:     ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5493:      (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5494:      (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5495:      packet->payload[counter] == '-' || packet->payload[counter] == '_' ||",
          "5496:      packet->payload[counter] == '.')) {",
          "5497:       NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5499:       if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5500:  NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5502:  while (packet->payload_packet_len > counter &&",
          "5503:         ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5504:   (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5505:   (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5506:   packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5507:    NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5509:    if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5510:      NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5512:      if(packet->payload_packet_len > counter + 1 &&",
          "5513:         ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&",
          "5514:   (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5515:        NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5516:        counter += 2;",
          "5517:        if(packet->payload_packet_len > counter &&",
          "5518:    (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5519:   NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5520:   return(counter);",
          "5521:        } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5522:    packet->payload[counter] <= 'z') {",
          "5523:   NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5524:   counter++;",
          "5527:     NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5534:       NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "",
          "[Added Lines]",
          "4034:       for (a = 0; a < ndpi_str->callback_buffer_size_udp; a++) {",
          "4035:  if((func != ndpi_str->callback_buffer_udp[a].func) &&",
          "4036:     (ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4037:     ndpi_str->callback_buffer_udp[a].ndpi_selection_bitmask &&",
          "4039:     ndpi_str->callback_buffer_udp[a].excluded_protocol_bitmask) == 0 &&",
          "4040:     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_udp[a].detection_bitmask, detection_bitmask) != 0) {",
          "4041:    ndpi_str->callback_buffer_udp[a].func(ndpi_str, flow), num_calls++;",
          "4045: #ifdef DEBUG_UDP_CALLS",
          "4046:    {",
          "4047:      char buf[64];",
          "4048:      u_int16_t proto_id = ndpi_str->callback_buffer_udp[a].ndpi_protocol_id;",
          "4049:      ndpi_protocol proto = { proto_id, proto_id, 0 };",
          "4050:      printf(\"-> [UDP,CALL] dissector of protocol as callback_buffer idx =  %d / %s\\n\",",
          "4051:      proto_id, ndpi_protocol2name(ndpi_str, proto, buf, sizeof(buf)));",
          "4052:    }",
          "4053: #endif",
          "4057:  } else if(_ndpi_debug_callbacks)",
          "4058:    NDPI_LOG_DBG2(ndpi_str, \"[UDP,SKIP] dissector of protocol as callback_buffer idx =  %d\\n\", a);",
          "4060:     } else",
          "4061:       num_calls = 1;",
          "4063:     return(num_calls);",
          "4064:   }",
          "4068:   static u_int32_t check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4069:          struct ndpi_flow_struct *flow,",
          "4070:          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4071:     void *func = NULL;",
          "4072:     u_int32_t a, num_calls = 0;",
          "4073:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4074:     int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4075:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4077:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4079:     if(flow->packet.payload_packet_len != 0) {",
          "4080:       if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4082:          ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4083:   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4084:   (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4085:   ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4086:  if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4087:     (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL))",
          "4088:    ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4089:      func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func, num_calls++;",
          "4090:       }",
          "4092:       if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4093:  for (a = 0; a < ndpi_str->callback_buffer_size_tcp_payload; a++) {",
          "4094:    if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4095:       (ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4096:       ndpi_str->callback_buffer_tcp_payload[a].ndpi_selection_bitmask &&",
          "4097:       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4098:       ndpi_str->callback_buffer_tcp_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4099:       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_payload[a].detection_bitmask,",
          "4100:       detection_bitmask) != 0) {",
          "4101:      ndpi_str->callback_buffer_tcp_payload[a].func(ndpi_str, flow), num_calls++;",
          "4102:      if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4104:    }",
          "4105:  }",
          "4106:       }",
          "4107:     } else {",
          "4110:       num_calls = 1;",
          "4112:       if((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4113:   NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4114:          ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4115:   NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4116:   (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4117:   ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask) {",
          "4118:  if((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4119:     (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&",
          "4120:     ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &",
          "4121:       NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0))",
          "4122:    ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow),",
          "4123:      func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func, num_calls++;",
          "4124:       }",
          "4126:       for (a = 0; a < ndpi_str->callback_buffer_size_tcp_no_payload; a++) {",
          "4127:  if((func != ndpi_str->callback_buffer_tcp_payload[a].func) &&",
          "4128:     (ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask & *ndpi_selection_packet) ==",
          "4129:     ndpi_str->callback_buffer_tcp_no_payload[a].ndpi_selection_bitmask &&",
          "4130:     NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4131:     ndpi_str->callback_buffer_tcp_no_payload[a].excluded_protocol_bitmask) == 0 &&",
          "4132:     NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer_tcp_no_payload[a].detection_bitmask,",
          "4133:     detection_bitmask) != 0) {",
          "4134:    ndpi_str->callback_buffer_tcp_no_payload[a].func(ndpi_str, flow), num_calls++;",
          "4135:    if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4137:  }",
          "4141:     return(num_calls);",
          "4142:   }",
          "4146:   u_int32_t ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4147:      struct ndpi_flow_struct *flow,",
          "4148:      NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4149:     if(!flow)",
          "4150:       return(0);",
          "4151:     else if(flow->packet.tcp != NULL)",
          "4152:       return(check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4153:     else if(flow->packet.udp != NULL)",
          "4154:       return(check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4155:     else",
          "4156:       return(check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4157:   }",
          "4161:   u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "4162:      struct ndpi_flow_struct *flow) {",
          "4163:     u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4165:     if(flow->packet.iph) {",
          "4166:       struct in_addr addr;",
          "4167:       u_int16_t sport, dport;",
          "4169:       addr.s_addr = flow->packet.iph->saddr;",
          "4171:       if((flow->l4_proto == IPPROTO_TCP) && flow->packet.tcp)",
          "4172:  sport = flow->packet.tcp->source, dport = flow->packet.tcp->dest;",
          "4173:       else if((flow->l4_proto == IPPROTO_UDP) && flow->packet.udp)",
          "4174:  sport = flow->packet.udp->source, dport = flow->packet.udp->dest;",
          "4175:       else",
          "4176:  sport = dport = 0;",
          "4179:       ret = ndpi_network_port_ptree_match(ndpi_str, &addr, sport);",
          "4181:       if(ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4182:  addr.s_addr = flow->packet.iph->daddr;",
          "4183:  ret = ndpi_network_port_ptree_match(ndpi_str, &addr, dport);",
          "4184:       }",
          "4187:     return(ret);",
          "4192:   ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4193:           u_int8_t enable_guess, u_int8_t *protocol_was_guessed) {",
          "4194:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4198:     if(flow == NULL)",
          "4199:       return(ret);",
          "4202:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4203:     ret.category = flow->category;",
          "4206:     if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4207:       return(ret);",
          "4210:     if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4211:       u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4213:       if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4214:  goto check_stun_export;",
          "4215:       else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||",
          "4216:        (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||",
          "4217:        (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {",
          "4219:  ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4220:       }",
          "4221:       else if((flow->l4.tcp.tls.hello_processed == 1) &&",
          "4222:        (flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0')) {",
          "4224:  ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4225:       } else if(enable_guess) {",
          "4226:  if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&",
          "4227:     flow->l4.tcp.tls.hello_processed)",
          "4228:    flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4230:  guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4232:  if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4233:     ((flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4234:      NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&",
          "4235:      is_udp_guessable_protocol(guessed_host_protocol_id)))",
          "4236:    flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4239:  if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4241:     && (flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4242:     NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&",
          "4243:     is_udp_guessable_protocol(guessed_protocol_id))",
          "4244:    flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4246:  if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4247:    if((guessed_protocol_id == 0) && (flow->protos.tls_quic_stun.stun.num_binding_requests > 0) &&",
          "4248:       (flow->protos.tls_quic_stun.stun.num_processed_pkts > 0))",
          "4249:      guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4251:    if(flow->host_server_name[0] != '\\0') {",
          "4252:      ndpi_protocol_match_result ret_match;",
          "4254:      memset(&ret_match, 0, sizeof(ret_match));",
          "4256:      ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,",
          "4257:      strlen((const char *) flow->host_server_name), &ret_match,",
          "4258:      NDPI_PROTOCOL_DNS);",
          "4260:      if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4261:        guessed_host_protocol_id = ret_match.protocol_id;",
          "4262:    }",
          "4265:    ndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);",
          "4267:       }",
          "4268:     } else if(enable_guess) {",
          "4269:       if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4271:  flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4272:       }",
          "4274:       if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4276:  flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4279:       if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {",
          "4281:  flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4282:       }",
          "4285:     if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&",
          "4286:        (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4287:     check_stun_export:",
          "4288:       if(flow->protos.tls_quic_stun.stun.num_processed_pkts || flow->protos.tls_quic_stun.stun.num_udp_pkts) {",
          "4291:  ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);",
          "4292:       }",
          "4295:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4297:     if(ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4298:       if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4299:  ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4300:       else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4302:    As Google has recently introduced Duo,",
          "4303:    we need to distinguish between it and hangout",
          "4304:    thing that should be handled by the STUN dissector",
          "4306:  ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4307:       }",
          "4308:     }",
          "4310:     if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {",
          "4312:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4315:     return(ret);",
          "4320:   void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4321:      const unsigned char *packet, const unsigned short packetlen,",
          "4322:      const u_int64_t current_time_ms, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4323:     if(flow == NULL)",
          "4324:       return;",
          "4326:     if(flow->server_id == NULL)",
          "4330:     if(packetlen < 20) {",
          "4331:       return;",
          "4332:     }",
          "4334:     flow->packet.current_time_ms = current_time_ms;",
          "4337:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4341:     if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4342:       return;",
          "4345:     flow->src = src, flow->dst = dst;",
          "4348:     if( ndpi_connection_tracking(ndpi_str, flow) ) {",
          "4350:       ndpi_connection_tracking(ndpi_str, flow);",
          "4354:       if(flow->extra_packets_func) {",
          "4355:  if((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4356:    flow->check_extra_packets = 0;",
          "4358:  if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4360:       }",
          "4362:     }",
          "4364:   }",
          "4370:   int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,",
          "4371:        ndpi_protocol_category_t category) {",
          "4372:     patricia_node_t *node;",
          "4373:     struct in_addr pin;",
          "4374:     int bits = 32;",
          "4375:     char *ptr;",
          "4376:     char ipbuf[64];",
          "4378:     strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4379:     ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4381:     ptr = strrchr(ipbuf, '/');",
          "4383:     if(ptr) {",
          "4385:       if(atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "4386:  bits = atoi(ptr);",
          "4387:     }",
          "4389:     if(inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4390:       NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4391:       return(-1);",
          "4392:     }",
          "4394:     if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL) {",
          "4395:       node->value.u.uv32.user_value = (u_int16_t)category, node->value.u.uv32.additional_user_value = 0;",
          "4396:     }",
          "4398:     return(0);",
          "4399:   }",
          "4404:   int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,",
          "4405:       ndpi_protocol_category_t category) {",
          "4406:     char *name;",
          "4408:     if(name_to_add == NULL)",
          "4409:       return(-1);",
          "4411:     name = ndpi_strdup(name_to_add);",
          "4413:     if(name == NULL)",
          "4414:       return(-1);",
          "4417:     printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);",
          "4420:     AC_PATTERN_t ac_pattern;",
          "4421:     AC_ERROR_t rc;",
          "4423:     memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "4425:     if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4426:       ndpi_free(name);",
          "4427:       return(-1);",
          "4428:     }",
          "4430:     ac_pattern.astring = name, ac_pattern.length = strlen(ac_pattern.astring);",
          "4431:     ac_pattern.rep.number = (u_int32_t) category,  ac_pattern.rep.category = category;;",
          "4433:     rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);",
          "4434:     if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {",
          "4435:       ndpi_free(name);",
          "4436:       return(-1);",
          "4437:     }",
          "4439:     if(rc == ACERR_DUPLICATE_PATTERN)",
          "4440:       ndpi_free(name);",
          "4442:     return(0);",
          "4443:   }",
          "4448:   int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,",
          "4449:     ndpi_protocol_category_t category) {",
          "4450:     int rv;",
          "4453:     rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4455:     if(rv < 0) {",
          "4457:       rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4458:     }",
          "4460:     return(rv);",
          "4461:   }",
          "4465:   int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {",
          "4466:     int i;",
          "4469:     for (i = 0; category_match[i].string_to_match != NULL; i++)",
          "4470:       ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4473:     ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "4474:    1 /* free patterns strings memory */);",
          "4477:     ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4480:     ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4483:     ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4485:     if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "4486:       ndpi_Destroy_Patricia((patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "4488:     ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4489:     ndpi_str->custom_categories.ipAddresses_shadow = ndpi_New_Patricia(32 /* IPv4 */);",
          "4491:     ndpi_str->custom_categories.categories_loaded = 1;",
          "4493:     return(0);",
          "4494:   }",
          "4498:   int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,",
          "4499:          ndpi_protocol *ret) {",
          "4500:     if(ndpi_str->custom_categories.categories_loaded) {",
          "4501:       prefix_t prefix;",
          "4502:       patricia_node_t *node;",
          "4504:       if(saddr == 0)",
          "4505:  node = NULL;",
          "4506:       else {",
          "4508:  fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,",
          "4513:       if(!node) {",
          "4514:  if(daddr != 0) {",
          "4515:    fill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,",
          "4516:     ((patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4517:    node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4518:  }",
          "4519:       }",
          "4521:       if(node) {",
          "4522:  ret->category = (ndpi_protocol_category_t) node->value.u.uv32.user_value;",
          "4524:  return(1);",
          "4525:       }",
          "4528:     ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4530:     return(0);",
          "4531:   }",
          "4535:   void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4536:        ndpi_protocol *ret) {",
          "4537:     if(ndpi_str->custom_categories.categories_loaded) {",
          "4538:       if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4539:  flow->category = ret->category = flow->guessed_header_category;",
          "4540:  return;",
          "4541:       }",
          "4543:       if(flow->host_server_name[0] != '\\0') {",
          "4544:  u_int32_t id;",
          "4545:  int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,",
          "4546:          strlen((char *) flow->host_server_name), &id);",
          "4548:  if(rc == 0) {",
          "4549:    flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4550:    return;",
          "4551:  }",
          "4554:       if(flow->l4.tcp.tls.hello_processed == 1 &&",
          "4555:   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {",
          "4556:  u_int32_t id;",
          "4557:  int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,",
          "4558:          strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name), &id);",
          "4560:  if(rc == 0) {",
          "4561:    flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4562:    return;",
          "4563:  }",
          "4567:     flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4572:   static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {",
          "4573:     packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,",
          "4574:       packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,",
          "4575:       packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,",
          "4576:       packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,",
          "4577:       packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,",
          "4578:       packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,",
          "4579:       packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,",
          "4580:       packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,",
          "4581:       packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,",
          "4582:       packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,",
          "4583:       packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,",
          "4584:       packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0,",
          "4585:       packet->forwarded_line.ptr = NULL, packet->forwarded_line.len = 0;",
          "4586:   }",
          "4590:   static int ndpi_is_ntop_protocol(ndpi_protocol *ret) {",
          "4591:     if((ret->master_protocol == NDPI_PROTOCOL_HTTP) && (ret->app_protocol == NDPI_PROTOCOL_NTOP))",
          "4592:       return(1);",
          "4593:     else",
          "4594:       return(0);",
          "4595:   }",
          "4599:   static int ndpi_check_protocol_port_mismatch_exceptions(struct ndpi_detection_module_struct *ndpi_str,",
          "4600:          struct ndpi_flow_struct *flow,",
          "4601:          ndpi_default_ports_tree_node_t *expected_proto,",
          "4602:          ndpi_protocol *returned_proto) {",
          "4604:       For TLS (and other protocols) it is not simple to guess the exact protocol so before",
          "4605:       triggering an alert we need to make sure what we have exhausted all the possible",
          "4606:       options available",
          "4609:     if(ndpi_is_ntop_protocol(returned_proto)) return(1);",
          "4611:     if(returned_proto->master_protocol == NDPI_PROTOCOL_TLS) {",
          "4612:       switch(expected_proto->proto->protoId) {",
          "4613:       case NDPI_PROTOCOL_MAIL_IMAPS:",
          "4614:       case NDPI_PROTOCOL_MAIL_POPS:",
          "4615:       case NDPI_PROTOCOL_MAIL_SMTPS:",
          "4617:  break;",
          "4618:       }",
          "4621:     return(0);",
          "4626:   static void ndpi_reconcile_protocols(struct ndpi_detection_module_struct *ndpi_str,",
          "4627:            struct ndpi_flow_struct *flow,",
          "4628:            ndpi_protocol *ret) {",
          "4630:       Skype for a host doing MS Teams means MS Teams",
          "4631:       (MS Teams uses Skype as transport protocol for voice/video)",
          "4633:     if(flow) {",
          "4635:       if((flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN)",
          "4636:   && (flow->detected_protocol_stack[0] /* app */ != flow->detected_protocol_stack[1] /* major */))",
          "4637:  NDPI_CLR_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "4640:     switch(ret->app_protocol) {",
          "4641:     case NDPI_PROTOCOL_MSTEAMS:",
          "4642:       if(flow->packet.iph && flow->packet.tcp) {",
          "4645:  if(ndpi_str->msteams_cache == NULL)",
          "4646:    ndpi_str->msteams_cache = ndpi_lru_cache_init(1024);",
          "4648:  if(ndpi_str->msteams_cache)",
          "4655:     case NDPI_PROTOCOL_SKYPE:",
          "4656:     case NDPI_PROTOCOL_SKYPE_CALL:",
          "4657:       if(flow->packet.iph",
          "4658:   && flow->packet.udp",
          "4659:   && ndpi_str->msteams_cache) {",
          "4660:  u_int16_t when;",
          "4662:  if(ndpi_lru_find_cache(ndpi_str->msteams_cache, flow->packet.iph->saddr,",
          "4663:           &when, 0 /* Don't remove it as it can be used for other connections */)) {",
          "4664:    u_int16_t tdiff = ((flow->packet.current_time_ms /1000) & 0xFFFF) - when;",
          "4666:    if(tdiff < 60 /* sec */) {",
          "4668:      ret->app_protocol = NDPI_PROTOCOL_MSTEAMS;",
          "4671:      ndpi_lru_add_to_cache(ndpi_str->msteams_cache,",
          "4672:       flow->packet.iph->saddr,",
          "4673:       (flow->packet.current_time_ms / 1000) & 0xFFFF /* 16 bit */);",
          "4674:    }",
          "4675:  }",
          "4676:       }",
          "4680:     if(flow) {",
          "4681:       switch(ndpi_get_proto_breed(ndpi_str, ret->app_protocol)) {",
          "4682:       case NDPI_PROTOCOL_UNSAFE:",
          "4683:       case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "4684:       case NDPI_PROTOCOL_DANGEROUS:",
          "4685:  NDPI_SET_BIT(flow->risk, NDPI_UNSAFE_PROTOCOL);",
          "4686:  break;",
          "4687:       default:",
          "4689:  break;",
          "4690:       }",
          "4693:   }",
          "4697:   ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,",
          "4698:            struct ndpi_flow_struct *flow, const unsigned char *packet,",
          "4699:            const unsigned short packetlen, const u_int64_t current_time_ms,",
          "4700:            struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4701:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "4702:     u_int32_t a, num_calls = 0;",
          "4703:     ndpi_protocol ret = { NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED };",
          "4705:     if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "4706:       NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,",
          "4707:         \"START packet processing\\n\");",
          "4709:     if(flow == NULL)",
          "4710:       return(ret);",
          "4711:     else",
          "4712:       ret.category = flow->category;",
          "4714:     if(flow->fail_with_unknown) {",
          "4716:       return(ret);",
          "4717:     }",
          "4719:     flow->num_processed_pkts++;",
          "4721:     flow->tcp_segments_management=1;",
          "4725:     ret.master_protocol = flow->detected_protocol_stack[1],",
          "4726:       ret.app_protocol = flow->detected_protocol_stack[0];",
          "4728:     if(flow->server_id == NULL)",
          "4731:     if(flow->check_extra_packets) {",
          "4732:       ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_time_ms, src, dst);",
          "4734:       ret.master_protocol = flow->detected_protocol_stack[1],",
          "4735:  ret.app_protocol = flow->detected_protocol_stack[0],",
          "4736:  ret.category = flow->category;",
          "4737:       goto invalidate_ptr;",
          "4738:     } else if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4739:       goto ret_protocols;",
          "4742:     if(packetlen < 20) {",
          "4744:       ndpi_int_reset_packet_protocol(&flow->packet);",
          "4745:       goto invalidate_ptr;",
          "4746:     }",
          "4748:     flow->packet.current_time_ms = current_time_ms;",
          "4751:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4754:     if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4755:       goto invalidate_ptr;",
          "4758:     flow->src = src, flow->dst = dst;",
          "4760:     ndpi_connection_tracking(ndpi_str, flow);",
          "4763:     ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "4764:     if(flow->packet.iph != NULL)",
          "4765:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4767:     if(flow->packet.tcp != NULL)",
          "4768:       ndpi_selection_packet |=",
          "4769:  (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4771:     if(flow->packet.udp != NULL)",
          "4772:       ndpi_selection_packet |=",
          "4773:  (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "4775:     if(flow->packet.payload_packet_len != 0)",
          "4776:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "4778:     if(flow->packet.tcp_retransmission == 0)",
          "4779:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "4782:     if(flow->packet.iphv6 != NULL)",
          "4783:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "4786:     if((!flow->protocol_id_already_guessed) && (",
          "4788:       flow->packet.iphv6 ||",
          "4790:       flow->packet.iph)) {",
          "4791:       u_int16_t sport, dport;",
          "4792:       u_int8_t protocol;",
          "4793:       u_int8_t user_defined_proto;",
          "4795:       flow->protocol_id_already_guessed = 1;",
          "4798:       if(flow->packet.iphv6 != NULL) {",
          "4799:  protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "4800:       } else",
          "4802:  {",
          "4803:    protocol = flow->packet.iph->protocol;",
          "4804:  }",
          "4806:       if(flow->packet.udp)",
          "4807:  sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "4808:       else if(flow->packet.tcp)",
          "4809:  sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "4810:       else",
          "4811:  sport = dport = 0;",
          "4814:       flow->guessed_protocol_id =",
          "4815:  (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "4816:       flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4818:       if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "4819:  ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, &ret);",
          "4820:  flow->guessed_header_category = ret.category;",
          "4821:       } else",
          "4822:  flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "4824:       if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4826:  ret.master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "4827:    ret.app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "4832:       if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4833:  if(flow->packet.iph) {",
          "4834:    if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4835:      u_int8_t protocol_was_guessed;",
          "4838:      ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4839:    }",
          "4841:    ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4842:    goto invalidate_ptr;",
          "4843:  }",
          "4844:       } else {",
          "4846:  if(flow->packet.iph) {",
          "4848:    flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "4851:      We could implement a shortcut here skipping dissectors for",
          "4852:      protocols we have identified by other means such as with the IP",
          "4854:      However we do NOT stop here and skip invoking the dissectors",
          "4855:      because we want to dissect the flow (e.g. dissect the TLS)",
          "4856:      and extract metadata.",
          "4858: #if SKIP_INVOKING_THE_DISSECTORS",
          "4859:    if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4861:        We have identified a protocol using the IP address so",
          "4862:        it is not worth to dissect the traffic as we already have",
          "4863:        the solution",
          "4865:      ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4866:    }",
          "4868:  }",
          "4872:     if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "4874:       ret.master_protocol = flow->guessed_protocol_id, ret.app_protocol = flow->guessed_host_protocol_id;",
          "4876:       num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4877:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4878:       goto invalidate_ptr;",
          "4879:     }",
          "4881:     num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "4883:     a = flow->packet.detected_protocol_stack[0];",
          "4884:     if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "4885:       a = NDPI_PROTOCOL_UNKNOWN;",
          "4887:     if(a != NDPI_PROTOCOL_UNKNOWN) {",
          "4888:       int i;",
          "4890:       for (i = 0; i < sizeof(flow->host_server_name); i++) {",
          "4891:  if(flow->host_server_name[i] != '\\0')",
          "4892:    flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "4893:  else {",
          "4894:    flow->host_server_name[i] = '\\0';",
          "4895:    break;",
          "4896:  }",
          "4900:   ret_protocols:",
          "4901:     if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "4902:       ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4904:       if(ret.app_protocol == ret.master_protocol)",
          "4905:  ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "4906:     } else",
          "4907:       ret.app_protocol = flow->detected_protocol_stack[0];",
          "4910:     if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4911:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4912:     else",
          "4913:       ret.category = flow->category;",
          "4915:     if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&",
          "4916:        (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&",
          "4917:        (flow->guessed_protocol_id == 0)) {",
          "4918:       u_int8_t protocol_was_guessed;",
          "4921:  This is a TCP flow",
          "4922:  - whose first packet is NOT a SYN",
          "4923:  - no protocol has been detected",
          "4925:  We don't see how future packets can match anything",
          "4926:  hence we giveup here",
          "4928:       ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "4929:     }",
          "4931:     if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&",
          "4932:        (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4933:       ret.master_protocol = ret.app_protocol;",
          "4934:       ret.app_protocol = flow->guessed_host_protocol_id;",
          "4935:     }",
          "4937:     if((!flow->risk_checked) && (ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)) {",
          "4938:       ndpi_default_ports_tree_node_t *found;",
          "4939:       u_int16_t *default_ports, sport, dport;",
          "4941:       if(flow->packet.udp)",
          "4942:  found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,",
          "4943:           sport = ntohs(flow->packet.udp->source),",
          "4944:           dport = ntohs(flow->packet.udp->dest)),",
          "4945:    default_ports = ndpi_str->proto_defaults[ret.master_protocol].udp_default_ports;",
          "4946:       else if(flow->packet.tcp)",
          "4947:  found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,",
          "4948:           sport = ntohs(flow->packet.tcp->source),",
          "4949:           dport = ntohs(flow->packet.tcp->dest)),",
          "4950:    default_ports = ndpi_str->proto_defaults[ret.master_protocol].tcp_default_ports;",
          "4951:       else",
          "4952:  found = NULL, default_ports = NULL;",
          "4954:       if(found",
          "4955:   && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)",
          "4956:   && (found->proto->protoId != ret.master_protocol)",
          "4957:   && (found->proto->protoId != ret.app_protocol)",
          "4958:   ) {",
          "4961:  if(!ndpi_check_protocol_port_mismatch_exceptions(ndpi_str, flow, found, &ret))",
          "4962:    NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "4963:       } else if((!ndpi_is_ntop_protocol(&ret)) && default_ports && (default_ports[0] != 0)) {",
          "4964:  u_int8_t found = 0, i, num_loops = 0;",
          "4966:       check_default_ports:",
          "4967:  for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {",
          "4968:    if((default_ports[i] == sport) || (default_ports[i] == dport)) {",
          "4969:      found = 1;",
          "4970:      break;",
          "4971:    }",
          "4974:  if((num_loops == 0) && (!found)) {",
          "4975:    if(flow->packet.udp)",
          "4976:      default_ports = ndpi_str->proto_defaults[ret.app_protocol].udp_default_ports;",
          "4977:    else",
          "4978:      default_ports = ndpi_str->proto_defaults[ret.app_protocol].tcp_default_ports;",
          "4980:    num_loops = 1;",
          "4981:    goto check_default_ports;",
          "4984:  if(!found) {",
          "4986:    NDPI_SET_BIT(flow->risk, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "4987:  }",
          "4990:       flow->risk_checked = 1;",
          "4993:     ndpi_reconcile_protocols(ndpi_str, flow, &ret);",
          "4995:     if(num_calls == 0)",
          "4996:       flow->fail_with_unknown = 1;",
          "4998:   invalidate_ptr:",
          "5000:     if((flow->must_free[flow->packet.packet_direction] == 1)",
          "5001:        && (flow->packet.payload_packet_len > 0)",
          "5002:        && flow->packet.payload) {",
          "5004:       ndpi_free((void*)flow->packet.payload);",
          "5006:       flow->packet.payload_packet_len = 0;",
          "5007:       flow->must_free[flow->packet.packet_direction] = 0;",
          "5008:     }",
          "5011:       Invalidate packet memory to avoid accessing the pointers below",
          "5012:       when the packet is no longer accessible",
          "5014:     flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "5015:     ndpi_reset_packet_line_info(&flow->packet);",
          "5017:     return(ret);",
          "5022:   u_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5023:     u_int32_t val;",
          "5024:     val = 0;",
          "5027:     while (*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "5028:       val *= 10;",
          "5029:       val += *str - '0';",
          "5035:     return(val);",
          "5036:   }",
          "5040: #ifdef CODE_UNUSED",
          "5041:   u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5042:     u_int32_t val;",
          "5043:     val = 0;",
          "5044:     if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5045:       return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "5046:     } else {",
          "5048:       str += 2;",
          "5049:       max_chars_to_read -= 2;",
          "5052:       while (max_chars_to_read > 0) {",
          "5053:  if(*str >= '0' && *str <= '9') {",
          "5054:    val *= 16;",
          "5055:    val += *str - '0';",
          "5056:  } else if(*str >= 'a' && *str <= 'f') {",
          "5057:    val *= 16;",
          "5058:    val += *str + 10 - 'a';",
          "5059:  } else if(*str >= 'A' && *str <= 'F') {",
          "5060:    val *= 16;",
          "5061:    val += *str + 10 - 'A';",
          "5062:  } else {",
          "5063:    break;",
          "5064:  }",
          "5065:  str++;",
          "5066:  max_chars_to_read = max_chars_to_read - 1;",
          "5068:       }",
          "5069:     }",
          "5071:     return(val);",
          "5074: #endif",
          "5078:   u_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5079:     u_int64_t val;",
          "5080:     val = 0;",
          "5082:     while (max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "5083:       val *= 10;",
          "5084:       val += *str - '0';",
          "5089:     return(val);",
          "5090:   }",
          "5094:   u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,",
          "5095:          u_int16_t *bytes_read) {",
          "5096:     u_int64_t val;",
          "5097:     val = 0;",
          "5098:     if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5099:       return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "5100:     } else {",
          "5102:       str += 2;",
          "5103:       max_chars_to_read -= 2;",
          "5105:       while (max_chars_to_read > 0) {",
          "5106:  if(*str >= '0' && *str <= '9') {",
          "5107:    val *= 16;",
          "5108:    val += *str - '0';",
          "5109:  } else if(*str >= 'a' && *str <= 'f') {",
          "5110:    val *= 16;",
          "5111:    val += *str + 10 - 'a';",
          "5112:  } else if(*str >= 'A' && *str <= 'F') {",
          "5113:    val *= 16;",
          "5114:    val += *str + 10 - 'A';",
          "5115:  } else {",
          "5116:    break;",
          "5117:  }",
          "5118:  str++;",
          "5119:  max_chars_to_read = max_chars_to_read - 1;",
          "5121:       }",
          "5122:     }",
          "5123:     return(val);",
          "5128:   u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5129:     u_int32_t val;",
          "5130:     u_int16_t read = 0;",
          "5131:     u_int16_t oldread;",
          "5132:     u_int32_t c;",
          "5135:     oldread = read;",
          "5136:     c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "5137:     if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5138:       return(0);",
          "5140:     read++;",
          "5141:     val = c << 24;",
          "5142:     oldread = read;",
          "5143:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5144:     if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5145:       return(0);",
          "5147:     read++;",
          "5148:     val = val + (c << 16);",
          "5149:     oldread = read;",
          "5150:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5151:     if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5152:       return(0);",
          "5154:     read++;",
          "5155:     val = val + (c << 8);",
          "5156:     oldread = read;",
          "5157:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5158:     if(c > 255 || oldread == read || max_chars_to_read == read)",
          "5159:       return(0);",
          "5161:     val = val + c;",
          "5165:     return(htonl(val));",
          "5166:   }",
          "5171:   void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5172:     u_int32_t a;",
          "5173:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5175:     if((packet->payload_packet_len < 3) || (packet->payload == NULL))",
          "5176:       return;",
          "5178:     if(packet->packet_lines_parsed_complete != 0)",
          "5179:       return;",
          "5181:     packet->packet_lines_parsed_complete = 1;",
          "5182:     ndpi_reset_packet_line_info(packet);",
          "5184:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5185:     packet->line[packet->parsed_lines].len = 0;",
          "5187:     for (a = 0; ((a+1) < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "5188:       if((packet->payload[a] == 0x0d) && (packet->payload[a+1] == 0x0a)) {",
          "5191:  if(((a + 3) < packet->payload_packet_len)",
          "5192:     && (packet->payload[a+2] == 0x0d)",
          "5193:     && (packet->payload[a+3] == 0x0a)) {",
          "5196:    u_int32_t a1 = a + 4;",
          "5198:    diff = packet->payload_packet_len - a1;",
          "5200:    if(diff > 0) {",
          "5201:      diff = ndpi_min(diff, sizeof(flow->initial_binary_bytes));",
          "5202:      memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);",
          "5203:      flow->initial_binary_bytes_len = diff;",
          "5204:    }",
          "5207:  packet->line[packet->parsed_lines].len =",
          "5208:    (u_int16_t)(((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5211:  if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "5212:     strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "5214:     packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "5215:    packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "5216:    packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "5217:    packet->http_num_headers++;",
          "5220:    if(packet->payload_packet_len >= 12) {",
          "5221:      char buf[4];",
          "5224:      strncpy(buf, (char *) &packet->payload[9], 3);",
          "5225:      buf[3] = '\\0';",
          "5227:      flow->http.response_status_code = atoi(buf);",
          "5229:      if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "5231:    }",
          "5235:  if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&",
          "5236:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5237:          \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "5239:    if(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "5240:      packet->server_line.ptr =",
          "5241:        &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "5242:      packet->server_line.len =",
          "5243:        packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "5244:    } else {",
          "5245:      packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "5246:      packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "5247:    }",
          "5248:    packet->http_num_headers++;",
          "5251:  if(packet->line[packet->parsed_lines].len > 6 &&",
          "5252:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {",
          "5254:    if(packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "5255:      packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "5256:      packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "5257:    } else {",
          "5258:      packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "5259:      packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "5260:    }",
          "5261:    packet->http_num_headers++;",
          "5264:  if(packet->line[packet->parsed_lines].len > 17 &&",
          "5265:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "5267:    if(packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "5268:      packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "5269:      packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "5270:    } else {",
          "5271:      packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5272:      packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "5273:    }",
          "5274:    packet->http_num_headers++;",
          "5277:  if(packet->line[packet->parsed_lines].len > 14 &&",
          "5278:     (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||",
          "5279:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5280:    packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5281:    packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5283:    while ((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5284:      packet->content_line.len--, packet->content_line.ptr++;",
          "5286:    packet->http_num_headers++;",
          "5287:  }",
          "5289:  if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&",
          "5290:     (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5291:    packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5292:    packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5293:    packet->http_num_headers++;",
          "5294:  }",
          "5296:  if(packet->content_line.len > 0) {",
          "5298:    char separator[] = {';', '\\r', '\\0'};",
          "5299:    int i;",
          "5301:    for (i = 0; separator[i] != '\\0'; i++) {",
          "5302:      char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5304:      if(c != NULL)",
          "5305:        packet->content_line.len = c - (char *) packet->content_line.ptr;",
          "5306:    }",
          "5310:  if(packet->line[packet->parsed_lines].len > 8 &&",
          "5311:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5312:    packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5313:    packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5314:    packet->http_num_headers++;",
          "5315:  }",
          "5317:  if(packet->line[packet->parsed_lines].len > 9 &&",
          "5318:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5319:    packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5320:    packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5321:    packet->http_num_headers++;",
          "5322:  }",
          "5324:  if(packet->line[packet->parsed_lines].len > 12 &&",
          "5325:     (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||",
          "5326:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5327:    packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5328:    packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5329:    packet->http_num_headers++;",
          "5330:  }",
          "5332:  if(packet->line[packet->parsed_lines].len > 18 &&",
          "5333:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5334:    packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5335:    packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5336:    packet->http_num_headers++;",
          "5337:  }",
          "5339:  if(packet->line[packet->parsed_lines].len > 19 &&",
          "5340:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5341:    packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5342:    packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5343:    packet->http_num_headers++;",
          "5344:  }",
          "5346:  if(packet->line[packet->parsed_lines].len > 16 &&",
          "5347:     ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||",
          "5348:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5349:    packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5350:    packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5351:    packet->http_num_headers++;",
          "5352:  }",
          "5354:  if(packet->line[packet->parsed_lines].len > 21 &&",
          "5355:     ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Disposition: \", 21) == 0))) {",
          "5356:    packet->content_disposition_line.ptr = &packet->line[packet->parsed_lines].ptr[21];",
          "5357:    packet->content_disposition_line.len = packet->line[packet->parsed_lines].len - 21;",
          "5358:    packet->http_num_headers++;",
          "5359:  }",
          "5361:  if(packet->line[packet->parsed_lines].len > 8 &&",
          "5362:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5363:    packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5364:    packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5365:    packet->http_num_headers++;",
          "5366:  }",
          "5368:  if(packet->line[packet->parsed_lines].len > 8 &&",
          "5369:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5370:    packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5371:    packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5372:    packet->http_num_headers++;",
          "5373:  }",
          "5375:  if(packet->line[packet->parsed_lines].len > 16 &&",
          "5376:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5377:    packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5378:    packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5379:    packet->http_num_headers++;",
          "5380:  }",
          "5387:  if((packet->line[packet->parsed_lines].len > 6 &&",
          "5388:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5389:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5390:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||",
          "5391:     (packet->line[packet->parsed_lines].len > 8 &&",
          "5392:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5393:     (packet->line[packet->parsed_lines].len > 9 &&",
          "5394:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5395:     (packet->line[packet->parsed_lines].len > 12 &&",
          "5396:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5397:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5398:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5399:     (packet->line[packet->parsed_lines].len > 15 &&",
          "5400:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5401:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5402:     (packet->line[packet->parsed_lines].len > 17 &&",
          "5403:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5404:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5405:     (packet->line[packet->parsed_lines].len > 27 &&",
          "5406:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5407:    \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5409:    packet->http_num_headers++;",
          "5410:  }",
          "5412:  if(packet->line[packet->parsed_lines].len == 0) {",
          "5413:    packet->empty_line_position = a;",
          "5414:    packet->empty_line_position_set = 1;",
          "5415:  }",
          "5417:  if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5418:    return;",
          "5420:  packet->parsed_lines++;",
          "5421:  packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5422:  packet->line[packet->parsed_lines].len = 0;",
          "5426:     }",
          "5428:     if(packet->parsed_lines >= 1) {",
          "5429:       packet->line[packet->parsed_lines].len =",
          "5430:  (u_int16_t)(((size_t) &packet->payload[packet->payload_packet_len]) -",
          "5431:       ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5438:   void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5439:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5440:     u_int32_t a;",
          "5441:     u_int16_t end = packet->payload_packet_len;",
          "5443:     if(packet->packet_lines_parsed_complete != 0)",
          "5444:       return;",
          "5446:     packet->packet_lines_parsed_complete = 1;",
          "5447:     packet->parsed_lines = 0;",
          "5449:     if(packet->payload_packet_len == 0)",
          "5450:       return;",
          "5452:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5453:     packet->line[packet->parsed_lines].len = 0;",
          "5455:     for (a = 0; a < end; a++) {",
          "5456:       if(packet->payload[a] == 0x0a) {",
          "5457:  packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5458:             ((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5460:  if(a > 0 && packet->payload[a - 1] == 0x0d)",
          "5461:    packet->line[packet->parsed_lines].len--;",
          "5463:  if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5464:    break;",
          "5466:  packet->parsed_lines++;",
          "5467:  packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5468:  packet->line[packet->parsed_lines].len = 0;",
          "5470:  if((a + 1) >= packet->payload_packet_len)",
          "5471:    break;",
          "5474:       }",
          "5480:   u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5481:       u_int16_t counter) {",
          "5482:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5484:     NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5486:     if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5487:       (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5488:       (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5489:       packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5490:       NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5492:       while (packet->payload_packet_len > counter &&",
          "5493:       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5494:        (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5495:        (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5496:        packet->payload[counter] == '-' || packet->payload[counter] == '_' ||",
          "5497:        packet->payload[counter] == '.')) {",
          "5498:  NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5500:  if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5501:    NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5503:    while (packet->payload_packet_len > counter &&",
          "5504:    ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5505:     (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5506:     (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5507:     packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5508:      NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5510:      if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5511:        NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5512:        counter++;",
          "5513:        if(packet->payload_packet_len > counter + 1 &&",
          "5514:    ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&",
          "5515:     (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5516:   NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5517:   counter += 2;",
          "5520:     NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5524:     NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5528:       NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5530:     } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5531:        packet->payload[counter] <= 'z') {",
          "5532:       counter++;",
          "5533:       if(packet->payload_packet_len > counter &&",
          "5534:          (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5535:         NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "5536:         return(counter);",
          "5537:       } else {",
          "5538:         return(0);",
          "5539:       }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "5542:        } else {",
          "5543:   return(0);",
          "5544:        }",
          "5547:      }",
          "5548:    }",
          "5549:  }",
          "5551:       }",
          "5552:     }",
          "5553:   }",
          "5557: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "5573: #endif",
          "5602:   }",
          "5661:       }",
          "5662:     }",
          "5694:   }",
          "5705: #ifdef CODE_UNUSED",
          "5710: #endif",
          "5717: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5725:       return(1);",
          "5727:     return(0);",
          "5728:   }",
          "5741: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5753: #endif",
          "5769: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5779: #endif",
          "5792: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5802: #endif",
          "5810: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5813: #else",
          "5815: #endif",
          "5823: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5830: #endif",
          "5847: #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "5851: #endif",
          "5918:    ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5919:    return(ret);",
          "5920:  }",
          "5921:       }",
          "5958:     ndpi_protocol proto, char *buf, u_int buf_len) {",
          "5986:   }",
          "6020:   }",
          "6038:     switch(category) {",
          "6039:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6041:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6043:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6045:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6047:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6051:     default:",
          "6053:     }",
          "6127:   }",
          "6152:   }",
          "6184:       do {",
          "6186:    return(NULL);",
          "6192:   }",
          "6214:   }",
          "6244:   }",
          "6270:     return(0);",
          "6277:   }",
          "6294: #ifdef DEBUG",
          "6305: #endif",
          "6322: #ifdef DEBUG",
          "6325: #endif",
          "6346:     }",
          "6401: #if 1",
          "6403: #else",
          "6406: #endif",
          "6470: #ifdef FRAG_MAN",
          "6473: #endif",
          "6474:     }",
          "6475:   }",
          "6482:   }",
          "6493: #ifdef WIN32",
          "6515: #endif",
          "6528: #ifdef CODE_UNUSED",
          "6547: #endif",
          "6554: #ifdef HAVE_LIBGCRYPT",
          "6556: #endif",
          "6577: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "6579: #endif",
          "6642: #if 0",
          "6647: #endif",
          "6692:   }",
          "6716:   }",
          "6735:   }",
          "6752:     }",
          "6768:   }",
          "6800:   }",
          "6826:   }",
          "6864: #ifdef DGA_DEBUG",
          "6866: #endif",
          "6882: #ifdef DGA_DEBUG",
          "6884: #endif",
          "6895: #ifdef DGA_DEBUG",
          "6897: #endif",
          "6954: #ifdef DGA_DEBUG",
          "6957: #endif",
          "6977: #ifdef DGA_DEBUG",
          "6979: #endif",
          "6993: #ifdef DGA_DEBUG",
          "6995: #endif",
          "7044: #ifdef DGA_DEBUG",
          "7046: #endif",
          "7051: #ifdef DGA_DEBUG",
          "7053: #endif",
          "7061: #ifdef DGA_DEBUG",
          "7064: #endif",
          "7073: #ifdef DGA_DEBUG",
          "7077: #endif",
          "7080: #ifdef DGA_DEBUG",
          "7082: #endif",
          "",
          "[Removed Lines]",
          "5545:      } else {",
          "5546:        return(0);",
          "5550:  return(0);",
          "5554:   return(0);",
          "5555: }",
          "5560: void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,",
          "5561:                                            const char **func, u_int32_t *line) {",
          "5565:   if(ndpi_str->ndpi_debug_print_file != NULL)",
          "5568:   if(ndpi_str->ndpi_debug_print_function != NULL)",
          "5572: }",
          "5577: u_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,",
          "5578:                                u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags) {",
          "5579:   return(ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));",
          "5580: }",
          "5584: void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5585:                                 u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5586:   struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5588:   ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5590:   if(src != NULL) {",
          "5591:     NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5593:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5594:       NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5595:   }",
          "5597:   if(dst != NULL) {",
          "5598:     NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5600:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5601:       NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5603: }",
          "5607: u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5608:   return(flow->detected_protocol_stack[1]);",
          "5609: }",
          "5613: void ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5614:                                    u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5615:   if(!flow)",
          "5616:     return;",
          "5618:   flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5619:     flow->detected_protocol_stack[1] = lower_detected_protocol;",
          "5620: }",
          "5624: void ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5625:                                      u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5626:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5632:   if(!packet)",
          "5633:     return;",
          "5635:   packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "5636:     packet->detected_protocol_stack[1] = lower_detected_protocol;",
          "5637: }",
          "5647: void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5648:                               u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5649:   if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5650:     upper_detected_protocol = lower_detected_protocol;",
          "5652:   if(upper_detected_protocol == lower_detected_protocol)",
          "5653:     lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5655:   if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5656:     if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "5657:        (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5658:       if(ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {",
          "5659:  lower_detected_protocol = upper_detected_protocol;",
          "5660:  upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5663:   }",
          "5665:   ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5666:   ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5667: }",
          "5671: void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5672:                               ndpi_protocol_category_t protocol_category) {",
          "5673:   flow->category = protocol_category;",
          "5674: }",
          "5679: void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {",
          "5680:   int a;",
          "5682:   for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5683:     packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5684: }",
          "5688: void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {",
          "5689:   if(flow) {",
          "5690:     int a;",
          "5692:     for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5693:       flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5695: }",
          "5699: void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip) {",
          "5700:   memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "5701: }",
          "5707: int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip) {",
          "5708:   return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "5709: }",
          "5716: int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "5720:   if(packet->iphv6 != NULL) {",
          "5721:     if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5722:        packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5723:        packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5724:        packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5729: #endif",
          "5732:   if(packet->iph->saddr == ip->ipv4)",
          "5733:     return(1);",
          "5734:   return(0);",
          "5735: }",
          "5740: int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "5744:   if(packet->iphv6 != NULL) {",
          "5745:     if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5746:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5747:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5748:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5749:       return(1);",
          "5751:     return(0);",
          "5752:   }",
          "5756:   if(packet->iph->saddr == ip->ipv4)",
          "5757:     return(1);",
          "5759:   return(0);",
          "5760: }",
          "5766: void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "5767:   NDPI_PROTOCOL_IP_clear(ip);",
          "5772:   if(packet->iphv6 != NULL) {",
          "5773:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "5774:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "5775:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "5776:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "5778:   } else",
          "5782:     ip->ipv4 = packet->iph->saddr;",
          "5783: }",
          "5789: void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "5790:   NDPI_PROTOCOL_IP_clear(ip);",
          "5794:   if(packet->iphv6 != NULL) {",
          "5795:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "5796:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "5797:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "5798:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "5800:   } else",
          "5804:     ip->ipv4 = packet->iph->daddr;",
          "5805: }",
          "5809: u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {",
          "5811:   return(ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "5812:   ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "5814:   return(0);",
          "5816: }",
          "5820: char *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len) {",
          "5821:   const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "5824:   if(ndpi_is_ipv6(ip)) {",
          "5825:     if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "5826:       buf[0] = '\\0';",
          "5828:     return(buf);",
          "5829:   }",
          "5832:   snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "5834:   return(buf);",
          "5835: }",
          "5840: int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {",
          "5841:   int rv = -1;",
          "5842:   memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "5844:   if(strchr(ip_str, '.')) {",
          "5845:     if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "5846:       rv = 4;",
          "5848:   } else {",
          "5849:     if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "5850:       rv = 6;",
          "5852:   }",
          "5854:   return(rv);",
          "5855: }",
          "5859: u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str,",
          "5860:        u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5861:   u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "5862:   return(ntohs(val));",
          "5863: }",
          "5867: u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {",
          "5868:   return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "5869: }",
          "5873: u_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {",
          "5874:   return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "5875: }",
          "5879: ndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5880:                                              struct ndpi_flow_struct *flow, u_int8_t proto,",
          "5881:                                              u_int32_t shost /* host byte order */, u_int16_t sport,",
          "5882:                                              u_int32_t dhost /* host byte order */, u_int16_t dport) {",
          "5883:   u_int32_t rc;",
          "5884:   struct in_addr addr;",
          "5885:   ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "5886:   u_int8_t user_defined_proto;",
          "5888:   if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "5889:     rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "5891:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5892:       if(flow && (proto == IPPROTO_UDP) &&",
          "5893:   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5894:  ;",
          "5895:       else {",
          "5896:  ret.app_protocol = rc,",
          "5897:    ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5899:  if(ret.app_protocol == ret.master_protocol)",
          "5900:    ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5902:  ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5903:  return(ret);",
          "5904:       }",
          "5905:     }",
          "5907:     rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5908:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5909:       if(flow && (proto == IPPROTO_UDP) &&",
          "5910:   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5911:  ;",
          "5912:       else {",
          "5913:  ret.app_protocol = rc;",
          "5915:  if(rc == NDPI_PROTOCOL_TLS)",
          "5916:    goto check_guessed_skype;",
          "5917:  else {",
          "5922:     }",
          "5924:   check_guessed_skype:",
          "5925:     addr.s_addr = htonl(shost);",
          "5926:     if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "5927:       ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5928:     } else {",
          "5929:       addr.s_addr = htonl(dhost);",
          "5930:       if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "5931:  ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5932:     }",
          "5933:   } else",
          "5934:     ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5936:   ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5937:   return(ret);",
          "5938: }",
          "5942: char *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,",
          "5943:          ndpi_protocol proto, char *buf, u_int buf_len) {",
          "5944:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5945:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5946:       snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);",
          "5947:     else",
          "5948:       snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "5949:   } else",
          "5950:     snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "5952:   return(buf);",
          "5953: }",
          "5957: char *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,",
          "5959:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5960:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5961:       snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "5962:         ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5963:     else",
          "5964:       snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "5965:   } else",
          "5966:     snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5968:   return(buf);",
          "5969: }",
          "5973: int ndpi_is_custom_category(ndpi_protocol_category_t category) {",
          "5974:   switch(category) {",
          "5975:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5976:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5977:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5978:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5979:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5980:     return(1);",
          "5981:     break;",
          "5983:   default:",
          "5984:     return(0);",
          "5985:     break;",
          "5987: }",
          "5991: void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,",
          "5992:        ndpi_protocol_category_t category,",
          "5993:                             char *name) {",
          "5994:   if(!name)",
          "5995:     return;",
          "5997:   switch(category) {",
          "5998:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5999:     snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6000:     break;",
          "6002:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6003:     snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6004:     break;",
          "6006:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6007:     snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6008:     break;",
          "6010:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6011:     snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6012:     break;",
          "6014:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6015:     snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6016:     break;",
          "6018:   default:",
          "6019:     break;",
          "6021: }",
          "6025: const char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6026:        ndpi_protocol_category_t category) {",
          "6027:   if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "6028:     static char b[24];",
          "6030:     if(!ndpi_str)",
          "6031:       snprintf(b, sizeof(b), \"NULL nDPI\");",
          "6032:     else",
          "6033:       snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);",
          "6034:     return(b);",
          "6035:   }",
          "6037:   if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "6040:       return(ndpi_str->custom_category_labels[0]);",
          "6042:       return(ndpi_str->custom_category_labels[1]);",
          "6044:       return(ndpi_str->custom_category_labels[2]);",
          "6046:       return(ndpi_str->custom_category_labels[3]);",
          "6048:       return(ndpi_str->custom_category_labels[4]);",
          "6049:     case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "6050:       return(\"Code should not use this internal constant\");",
          "6052:       return(\"Unspecified\");",
          "6054:   } else",
          "6055:     return(categories[category]);",
          "6056: }",
          "6060: ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,",
          "6061:        ndpi_protocol proto) {",
          "6062:   if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6063:     return(proto.category);",
          "6066:   else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||",
          "6067:    (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "6068:     if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6069:       return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "6070:   } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6071:     return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "6073:   return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "6074: }",
          "6078: char *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6079:      u_int16_t proto_id) {",
          "6080:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6081:      (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6082:      (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6083:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6085:   return(ndpi_str->proto_defaults[proto_id].protoName);",
          "6086: }",
          "6090: ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,",
          "6091:         u_int16_t proto_id) {",
          "6092:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6093:      (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6094:      (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6095:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6097:   return(ndpi_str->proto_defaults[proto_id].protoBreed);",
          "6098: }",
          "6102: char *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6103:     ndpi_protocol_breed_t breed_id) {",
          "6104:   switch(breed_id) {",
          "6105:   case NDPI_PROTOCOL_SAFE:",
          "6106:     return(\"Safe\");",
          "6107:     break;",
          "6108:   case NDPI_PROTOCOL_ACCEPTABLE:",
          "6109:     return(\"Acceptable\");",
          "6110:     break;",
          "6111:   case NDPI_PROTOCOL_FUN:",
          "6112:     return(\"Fun\");",
          "6113:     break;",
          "6114:   case NDPI_PROTOCOL_UNSAFE:",
          "6115:     return(\"Unsafe\");",
          "6116:     break;",
          "6117:   case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "6118:     return(\"Potentially Dangerous\");",
          "6119:     break;",
          "6120:   case NDPI_PROTOCOL_DANGEROUS:",
          "6121:     return(\"Dangerous\");",
          "6122:     break;",
          "6123:   case NDPI_PROTOCOL_UNRATED:",
          "6124:   default:",
          "6125:     return(\"Unrated\");",
          "6126:     break;",
          "6128: }",
          "6132: int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {",
          "6133:   int i;",
          "6135:   for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6136:     if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "6137:       return(i);",
          "6139:   return(-1);",
          "6140: }",
          "6144: int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {",
          "6145:   int i;",
          "6147:   for (i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "6148:     const char *name = ndpi_category_get_name(ndpi_str, i);",
          "6150:     if(strcasecmp(cat, name) == 0)",
          "6151:       return(i);",
          "6154:   return(-1);",
          "6155: }",
          "6159: void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6160:   int i;",
          "6162:   for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6163:     printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,",
          "6164:     ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "6165:     ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "6166:     ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));",
          "6167: }",
          "6175: char *ndpi_strnstr(const char *s, const char *find, size_t slen) {",
          "6176:   char c;",
          "6177:   size_t len;",
          "6179:   if((c = *find++) != '\\0') {",
          "6180:     len = strnlen(find, slen);",
          "6181:     do {",
          "6182:       char sc;",
          "6185:  if(slen-- < 1 || (sc = *s++) == '\\0')",
          "6187:       } while (sc != c);",
          "6188:       if(len > slen)",
          "6189:  return(NULL);",
          "6190:     } while (strncmp(s, find, len) != 0);",
          "6191:     s--;",
          "6194:   return((char *) s);",
          "6195: }",
          "6202: const char * ndpi_strncasestr(const char *str1, const char *str2, size_t len) {",
          "6203:   size_t str1_len = strnlen(str1, len);",
          "6204:   size_t str2_len = strlen(str2);",
          "6205:   size_t i;",
          "6207:   for(i = 0; i < (str1_len - str2_len + 1); i++){",
          "6208:     if(str1[0] == '\\0')",
          "6209:       return NULL;",
          "6210:     else if(strncasecmp(str1, str2, str2_len) == 0)",
          "6211:       return(str1);",
          "6213:     str1++;",
          "6216:   return NULL;",
          "6217: }",
          "6221: int ndpi_match_prefix(const u_int8_t *payload,",
          "6222:         size_t payload_len, const char *str, size_t str_len) {",
          "6223:   int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "6225:   return(rc);",
          "6226: }",
          "6230: int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,",
          "6231:                                   u_int string_to_match_len, ndpi_protocol_match_result *ret_match,",
          "6232:                                   u_int8_t is_host_match) {",
          "6233:   AC_TEXT_t ac_input_text;",
          "6234:   ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "6235:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6236:   int rc;",
          "6238:   if((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "6239:     return(NDPI_PROTOCOL_UNKNOWN);",
          "6241:   if(!automa->ac_automa_finalized) {",
          "6242:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6246:   ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "6247:   rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6250:     As ac_automata_search can detect partial matches and continue the search process",
          "6251:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6252:     and in this case return it",
          "6254:   if((rc == 0) && (match.number != 0))",
          "6255:     rc = 1;",
          "6258:   ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,",
          "6259:     ret_match->protocol_breed = match.breed;",
          "6261:   return(rc ? match.number : 0);",
          "6262: }",
          "6266: static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {",
          "6269:   if((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))",
          "6272:   switch(previous_proto) {",
          "6273:   case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6274:   case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6275:     if(new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6276:       return(1);",
          "6279:   return(0);",
          "6280: }",
          "6284: static u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6285:                                                       struct ndpi_flow_struct *flow, char *string_to_match,",
          "6286:                                                       u_int string_to_match_len, u_int16_t master_protocol_id,",
          "6287:                                                       ndpi_protocol_match_result *ret_match, u_int8_t is_host_match) {",
          "6288:   int matching_protocol_id;",
          "6289:   struct ndpi_packet_struct *packet = &flow->packet;",
          "6291:   matching_protocol_id =",
          "6292:     ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);",
          "6295:   {",
          "6296:     char m[256];",
          "6297:     int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6299:     strncpy(m, string_to_match, len);",
          "6300:     m[len] = '\\0';",
          "6302:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,",
          "6303:     ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6304:   }",
          "6307:   if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "6308:      (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6310:     packet->detected_protocol_stack[1] = master_protocol_id,",
          "6311:       packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6313:     flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6314:       flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6316:     if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6317:       flow->category = ret_match->protocol_category;",
          "6319:     return(packet->detected_protocol_stack[0]);",
          "6320:   }",
          "6323:   string_to_match[string_to_match_len] = '\\0';",
          "6324:   NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6327:   ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6328:     ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;",
          "6330:   return(NDPI_PROTOCOL_UNKNOWN);",
          "6331: }",
          "6335: u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6336:                                       char *string_to_match, u_int string_to_match_len,",
          "6337:                                       ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id) {",
          "6338:   u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6339:             master_protocol_id, ret_match, 1);",
          "6340:   ndpi_protocol_category_t id = ret_match->protocol_category;",
          "6342:   if(ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {",
          "6344:       flow->category = ret_match->protocol_category = id;",
          "6345:       rc = master_protocol_id;",
          "6347:   }",
          "6349:   return(rc);",
          "6350: }",
          "6354: int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow,",
          "6355:                                  u_int16_t master_protocol, char *name, u_int name_len) {",
          "6356:   ndpi_protocol_match_result ret_match;",
          "6357:   u_int16_t subproto, what_len, i;",
          "6358:   char *what;",
          "6360:   if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6361:     what = &name[1], what_len = name_len - 1;",
          "6362:   else",
          "6363:     what = name, what_len = name_len;",
          "6366:   for(i=0; i<name_len; i++) what[i] = tolower(what[i]);",
          "6368:   subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len, &ret_match, master_protocol);",
          "6370:   if(subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6371:     ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6372:     ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6373:     return(1);",
          "6374:   } else",
          "6375:     return(0);",
          "6376: }",
          "6380: u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6381:       struct ndpi_flow_struct *flow,",
          "6382:                                          char *string_to_match, u_int string_to_match_len,",
          "6383:                                          ndpi_protocol_match_result *ret_match,",
          "6384:       u_int16_t master_protocol_id) {",
          "6385:   return(ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6386:            master_protocol_id, ret_match, 0));",
          "6387: }",
          "6391: int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6392:         ndpi_automa *automa, char *bigram_to_match) {",
          "6393:   AC_TEXT_t ac_input_text;",
          "6394:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6395:   int rc;",
          "6397:   if((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6398:     return(-1);",
          "6400:   if(!automa->ac_automa_finalized) {",
          "6402:     ndpi_finalize_initalization(ndpi_str);",
          "6404:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6407:   }",
          "6409:   ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6410:   rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6413:     As ac_automata_search can detect partial matches and continue the search process",
          "6414:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6415:     and in this case return it",
          "6417:   if((rc == 0) && (match.number != 0))",
          "6418:     rc = 1;",
          "6420:   return(rc ? match.number : 0);",
          "6421: }",
          "6425: void ndpi_free_flow_data(struct ndpi_flow_struct *flow) {",
          "6426:   if(flow) {",
          "6427:     u_int is_quic = flow_is_proto(flow, NDPI_PROTOCOL_QUIC);",
          "6429:     if(flow->http.url)",
          "6430:       ndpi_free(flow->http.url);",
          "6432:     if(flow->http.content_type)",
          "6433:       ndpi_free(flow->http.content_type);",
          "6435:     if(flow->http.request_content_type)",
          "6436:       ndpi_free(flow->http.request_content_type);",
          "6438:     if(flow->http.user_agent)",
          "6439:       ndpi_free(flow->http.user_agent);",
          "6441:     if(flow->kerberos_buf.pktbuf)",
          "6442:       ndpi_free(flow->kerberos_buf.pktbuf);",
          "6444:     if(is_quic",
          "6445:        || flow_is_proto(flow, NDPI_PROTOCOL_TLS)",
          "6446:        || flow_is_proto(flow, NDPI_PROTOCOL_DTLS)",
          "6447:        ) {",
          "6448:       if(flow->protos.tls_quic_stun.tls_quic.server_names)",
          "6449:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.server_names);",
          "6451:       if(flow->protos.tls_quic_stun.tls_quic.alpn)",
          "6452:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.alpn);",
          "6454:       if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions)",
          "6455:         ndpi_free(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions);",
          "6457:       if(flow->protos.tls_quic_stun.tls_quic.issuerDN)",
          "6458:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.issuerDN);",
          "6460:       if(flow->protos.tls_quic_stun.tls_quic.subjectDN)",
          "6461:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.subjectDN);",
          "6463:       if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni)",
          "6464:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni);",
          "6465:     }",
          "6467:     if(flow->l4_proto == IPPROTO_TCP) {",
          "6468:       if(flow->l4.tcp.tls.message.buffer)",
          "6469:  ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "6471:       free_fragment(&flow->tcp_segments_list[0]);",
          "6472:       free_fragment(&flow->tcp_segments_list[1]);",
          "6476: }",
          "6478: void ndpi_free_flow(struct ndpi_flow_struct *flow) {",
          "6479:   if (flow) {",
          "6480:     ndpi_free_flow_data(flow);",
          "6481:     ndpi_free(flow);",
          "6483: }",
          "6487: char *ndpi_revision() {",
          "6488:   return(NDPI_GIT_RELEASE);",
          "6489: }",
          "6496: int gettimeofday(struct timeval *tp, struct timezone *tzp) {",
          "6500:   static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6502:   SYSTEMTIME system_time;",
          "6503:   FILETIME file_time;",
          "6504:   uint64_t time;",
          "6506:   GetSystemTime(&system_time);",
          "6507:   SystemTimeToFileTime(&system_time, &file_time);",
          "6508:   time = ((uint64_t) file_time.dwLowDateTime);",
          "6509:   time += ((uint64_t) file_time.dwHighDateTime) << 32;",
          "6511:   tp->tv_sec = (long) ((time - EPOCH) / 10000000L);",
          "6512:   tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6513:   return(0);",
          "6514: }",
          "6517: int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {",
          "6518:   int i;",
          "6520:   for (i = 0; i < NDPI_NUM_FDS_BITS; i++) {",
          "6521:     if(a.fds_bits[i] & b.fds_bits[i])",
          "6522:       return(1);",
          "6523:   }",
          "6525:   return(0);",
          "6526: }",
          "6529: int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {",
          "6530:   int i;",
          "6532:   for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6533:     if(a.fds_bits[i] != 0)",
          "6534:       return(0);",
          "6536:   return(1);",
          "6537: }",
          "6539: void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {",
          "6540:   int i;",
          "6542:   for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6543:     printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6545:   printf(\"\\n\");",
          "6546: }",
          "6549: u_int16_t ndpi_get_api_version() {",
          "6550:   return(NDPI_API_VERSION);",
          "6551: }",
          "6553: const char *ndpi_get_gcrypt_version(void) {",
          "6555:   return gcry_check_version(NULL);",
          "6557:   return NULL;",
          "6558: }",
          "6560: ndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "6561:   return(ndpi_str->proto_defaults);",
          "6562: }",
          "6564: u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6565:   return(ndpi_str->ndpi_num_supported_protocols);",
          "6566: }",
          "6568: u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6569:   return(ndpi_str->ndpi_num_custom_protocols);",
          "6570: }",
          "6572: u_int ndpi_get_ndpi_detection_module_size() {",
          "6573:   return(sizeof(struct ndpi_detection_module_struct));",
          "6574: }",
          "6576: void ndpi_set_debug_bitmask(struct ndpi_detection_module_struct *ndpi_str, NDPI_PROTOCOL_BITMASK debug_bitmask) {",
          "6578:   ndpi_str->debug_bitmask = debug_bitmask;",
          "6580: }",
          "6582: void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){",
          "6583:   ndpi_str->ndpi_log_level = l;",
          "6584: }",
          "6589: struct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries) {",
          "6590:   struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6592:   if(!c)",
          "6593:     return(NULL);",
          "6595:   c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));",
          "6597:   if(!c->entries) {",
          "6598:     ndpi_free(c);",
          "6599:     return(NULL);",
          "6600:   } else",
          "6601:     c->num_entries = num_entries;",
          "6603:   return(c);",
          "6604: }",
          "6606: void ndpi_lru_free_cache(struct ndpi_lru_cache *c) {",
          "6607:   ndpi_free(c->entries);",
          "6608:   ndpi_free(c);",
          "6609: }",
          "6611: u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key,",
          "6612:         u_int16_t *value, u_int8_t clean_key_when_found) {",
          "6613:   u_int32_t slot = key % c->num_entries;",
          "6615:   if(c->entries[slot].is_full) {",
          "6617:     if(clean_key_when_found)",
          "6618:       c->entries[slot].is_full = 0;",
          "6619:     return(1);",
          "6620:   } else",
          "6621:     return(0);",
          "6622: }",
          "6624: void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {",
          "6625:   u_int32_t slot = key % c->num_entries;",
          "6627:   c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;",
          "6628: }",
          "6633:   This function tells if it's possible to further dissect a given flow",
          "6634:   0 - All possible dissection has been completed",
          "6635:   1 - Additional dissection is possible",
          "6637: u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,",
          "6638:      struct ndpi_flow_struct *flow) {",
          "6639:   u_int16_t proto =",
          "6640:     flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "6643:   printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,",
          "6644:   flow->detected_protocol_stack[0],",
          "6645:   flow->detected_protocol_stack[1],",
          "6646:   proto);",
          "6649:   switch(proto) {",
          "6650:   case NDPI_PROTOCOL_TLS:",
          "6651:     if(flow->l4.tcp.tls.certificate_processed) return(0);",
          "6653:     if(flow->l4.tcp.tls.num_tls_blocks <= ndpi_str->num_tls_blocks_to_follow) {",
          "6655:       return(1);",
          "6656:     }",
          "6657:     break;",
          "6659:   case NDPI_PROTOCOL_HTTP:",
          "6660:     if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "6661:       return(1);",
          "6662:     break;",
          "6664:   case NDPI_PROTOCOL_DNS:",
          "6665:   case NDPI_PROTOCOL_MDNS:",
          "6666:     if(flow->protos.dns.num_answers == 0)",
          "6667:       return(1);",
          "6668:     break;",
          "6670:   case NDPI_PROTOCOL_FTP_CONTROL:",
          "6671:   case NDPI_PROTOCOL_MAIL_POP:",
          "6672:   case NDPI_PROTOCOL_MAIL_IMAP:",
          "6673:   case NDPI_PROTOCOL_MAIL_SMTP:",
          "6674:     if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "6675:       return(1);",
          "6676:     break;",
          "6678:   case NDPI_PROTOCOL_SSH:",
          "6679:     if((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "6680:       return(1);",
          "6681:     break;",
          "6683:   case NDPI_PROTOCOL_TELNET:",
          "6684:     if(!flow->protos.telnet.password_detected)",
          "6685:       return(1);",
          "6686:     break;",
          "6688:   case NDPI_PROTOCOL_SKYPE:",
          "6689:     if (flow->extra_packets_func)",
          "6690:       return(1);",
          "6691:     break;",
          "6694:   return(0);",
          "6695: }",
          "6699: const char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {",
          "6700:   switch(proto) {",
          "6701:   case ndpi_l4_proto_unknown:",
          "6702:     return(\"\");",
          "6703:     break;",
          "6705:   case ndpi_l4_proto_tcp_only:",
          "6706:     return(\"TCP\");",
          "6707:     break;",
          "6709:   case ndpi_l4_proto_udp_only:",
          "6710:     return(\"UDP\");",
          "6711:     break;",
          "6713:   case ndpi_l4_proto_tcp_and_udp:",
          "6714:     return(\"TCP/UDP\");",
          "6715:     break;",
          "6718:   return(\"\");",
          "6719: }",
          "6723: ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,",
          "6724:        u_int16_t ndpi_proto_id) {",
          "6725:   if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "6726:     u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "6727:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "6729:     if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)",
          "6730:       return(ndpi_l4_proto_tcp_only);",
          "6731:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)",
          "6732:       return(ndpi_l4_proto_udp_only);",
          "6733:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)",
          "6734:       return(ndpi_l4_proto_tcp_and_udp);",
          "6738: }",
          "6742: ndpi_ptree_t *ndpi_ptree_create(void) {",
          "6743:   ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "6745:   if(tree) {",
          "6746:     tree->v4 = ndpi_New_Patricia(32);",
          "6747:     tree->v6 = ndpi_New_Patricia(128);",
          "6749:     if((!tree->v4) || (!tree->v6)) {",
          "6750:       ndpi_ptree_destroy(tree);",
          "6751:       return(NULL);",
          "6753:   }",
          "6755:   return(tree);",
          "6756: }",
          "6760: void ndpi_ptree_destroy(ndpi_ptree_t *tree) {",
          "6761:   if(tree) {",
          "6762:     if(tree->v4)",
          "6763:       ndpi_Destroy_Patricia(tree->v4, free_ptree_data);",
          "6764:     if(tree->v6)",
          "6765:       ndpi_Destroy_Patricia(tree->v6, free_ptree_data);",
          "6767:     ndpi_free(tree);",
          "6769: }",
          "6773: int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr,",
          "6774:         u_int8_t bits, u_int64_t user_data) {",
          "6775:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6776:   patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6777:   prefix_t prefix;",
          "6778:   patricia_node_t *node;",
          "6780:   if(bits > ptree->maxbits)",
          "6781:     return(-1);",
          "6783:   if(is_v6)",
          "6784:     fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6785:   else",
          "6786:     fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6789:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "6791:   if(node && (node->prefix->bitlen == bits))",
          "6792:     return(-2);",
          "6794:   node = ndpi_patricia_lookup(ptree, &prefix);",
          "6796:   if(node != NULL) {",
          "6797:     node->value.u.uv64 = user_data;",
          "6799:     return(0);",
          "6802:   return(-3);",
          "6803: }",
          "6807: int ndpi_ptree_match_addr(ndpi_ptree_t *tree,",
          "6808:      const ndpi_ip_addr_t *addr, u_int64_t *user_data) {",
          "6809:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6810:   patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6811:   prefix_t prefix;",
          "6812:   patricia_node_t *node;",
          "6813:   int bits = ptree->maxbits;",
          "6815:   if(is_v6)",
          "6816:     fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6817:   else",
          "6818:     fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6820:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "6822:   if(node) {",
          "6825:     return(0);",
          "6828:   return(-1);",
          "6829: }",
          "6833: void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {",
          "6834:   ndpi_MD5_CTX ctx;",
          "6836:   ndpi_MD5Init(&ctx);",
          "6837:   ndpi_MD5Update(&ctx, data, data_len);",
          "6838:   ndpi_MD5Final(hash, &ctx);",
          "6839: }",
          "6843: static int enough(int a, int b) {",
          "6844:   u_int8_t percentage = 20;",
          "6846:   if(b == 0) return(0);",
          "6847:   if(a == 0) return(1);",
          "6849:   if(b > (((a+1)*percentage)/100)) return(1);",
          "6851:   return(0);",
          "6852: }",
          "6856: static u_int8_t endsWith(char *str, char *ends, u_int8_t ends_len) {",
          "6857:   u_int str_len = str ? strlen(str) : 0;",
          "6858:   u_int8_t rc;",
          "6860:   if(str_len < ends_len) return(0);",
          "6862:   rc = (strncmp(&str[str_len-ends_len], ends, ends_len) != 0) ? 0 : 1;",
          "6865:   printf(\"[DGA] %s / %s [rc: %u]\\n\", str, ends, rc);",
          "6868:   return(rc);",
          "6869: }",
          "6873: int ndpi_check_dga_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6874:    struct ndpi_flow_struct *flow,",
          "6875:    char *name, u_int8_t is_hostname) {",
          "6876:   int len, rc = 0;",
          "6877:   u_int8_t max_num_char_repetitions = 0, last_char = 0, num_char_repetitions = 0, num_dots = 0;",
          "6878:   u_int8_t max_domain_element_len = 0, curr_domain_element_len = 0, first_element_is_numeric = 1;",
          "6880:   if(!name) return(0);",
          "6883:   printf(\"[DGA] %s\\n\", name);",
          "6886:   len = strlen(name);",
          "6888:   if(len >= 5) {",
          "6889:     int i, j, num_found = 0, num_impossible = 0, num_bigram_checks = 0, num_digits = 0, num_vowels = 0, num_words = 0;",
          "6890:     char tmp[128], *word, *tok_tmp;",
          "6891:     u_int max_tmp_len = sizeof(tmp)-1;",
          "6893:     len = snprintf(tmp, max_tmp_len, \"%s\", name);",
          "6894:     if(len < 0) {",
          "6896:       printf(\"[DGA] Too short\");",
          "6898:       return(0);",
          "6899:     } else",
          "6900:       tmp[len < max_tmp_len ? len : max_tmp_len] = '\\0';",
          "6902:     for(i=0, j=0; (i<len) && (j<max_tmp_len); i++) {",
          "6903:       tmp[j] = tolower(name[i]);",
          "6905:       if(tmp[j] == '.')",
          "6906:  num_dots++;",
          "6907:       else if(num_dots == 0) {",
          "6908:  if(!isdigit(tmp[j]))",
          "6909:    first_element_is_numeric = 0;",
          "6910:       }",
          "6912:       if(last_char == tmp[j]) {",
          "6913:  if(++num_char_repetitions > max_num_char_repetitions)",
          "6914:    max_num_char_repetitions = num_char_repetitions;",
          "6915:       } else",
          "6916:  num_char_repetitions = 1, last_char = tmp[j];",
          "6918:       switch(tmp[j]) {",
          "6919:       case '.':",
          "6920:       case '-':",
          "6921:       case '_':",
          "6922:       case '/':",
          "6923:       case ')':",
          "6924:       case '(':",
          "6925:       case ';':",
          "6926:       case ':':",
          "6927:       case '[':",
          "6928:       case ']':",
          "6929:       case ' ':",
          "6931:    Domain/word separator chars",
          "6933:    NOTE:",
          "6934:    this function is used also to detect other type of issues",
          "6935:    such as invalid/suspiciuous user agent",
          "6937:  if(curr_domain_element_len > max_domain_element_len)",
          "6938:    max_domain_element_len = curr_domain_element_len;",
          "6940:  curr_domain_element_len = 0;",
          "6941:  break;",
          "6943:       default:",
          "6944:  curr_domain_element_len++;",
          "6945:  break;",
          "6946:       }",
          "6948:       j++;",
          "6949:     }",
          "6951:     if(curr_domain_element_len > max_domain_element_len)",
          "6952:       max_domain_element_len = curr_domain_element_len;",
          "6955:     printf(\"[DGA] [max_num_char_repetitions: %u][max_domain_element_len: %u]\\n\",",
          "6956:     max_num_char_repetitions, max_domain_element_len);",
          "6959:     if(",
          "6960:        (is_hostname",
          "6961:  && (num_dots > 5)",
          "6962:  && (!first_element_is_numeric)",
          "6963:  && (!endsWith(tmp, \"in-addr.arpa\", 12))",
          "6964:  )",
          "6965:        || (max_num_char_repetitions > 5 /* num or consecutive repeated chars */)",
          "6967:   In case of a name with too many consecutive chars an alert is triggered",
          "6968:   This is the case for instance of the wildcard DNS query used by NetBIOS",
          "6969:   (ckaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) and that can be exploited",
          "6970:   for reflection attacks",
          "6971:   - https://www.akamai.com/uk/en/multimedia/documents/state-of-the-internet/ddos-reflection-netbios-name-server-rpc-portmap-sentinel-udp-threat-advisory.pdf",
          "6972:   - http://ubiqx.org/cifs/NetBIOS.html",
          "6974:        || (max_domain_element_len >= 19 /* word too long. Example bbcbedxhgjmdobdprmen.com */)",
          "6975:        ) {",
          "6976:       if(flow) NDPI_SET_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "6978:       printf(\"[DGA] Found!\");",
          "6980:       return(1);",
          "6981:     }",
          "6983:     tmp[j] = '\\0';",
          "6984:     len = j;",
          "6986:     for(word = strtok_r(tmp, \".\", &tok_tmp); ; word = strtok_r(NULL, \".\", &tok_tmp)) {",
          "6987:       if(!word) break;",
          "6989:       num_words++;",
          "6991:       if(strlen(word) < 3) continue;",
          "6994:       printf(\"-> %s [%s][len: %u]\\n\", word, name, (unsigned int)strlen(word));",
          "6997:       for(i = 0; word[i+1] != '\\0'; i++) {",
          "6998:  if(isdigit(word[i])) {",
          "6999:    num_digits++;",
          "7003:    continue;",
          "7004:  }",
          "7006:  switch(word[i]) {",
          "7007:  case '-':",
          "7009:       Let's check for double+consecutive --",
          "7010:       that are usually ok",
          "7011:       r2---sn-uxaxpu5ap5-2n5e.gvt1.com",
          "7013:    if(word[i+1] == '-')",
          "7016:  case '_':",
          "7017:  case ':':",
          "7018:    continue;",
          "7019:    break;",
          "7021:  case '.':",
          "7022:    continue;",
          "7023:    break;",
          "7024:  }",
          "7026:  switch(word[i]) {",
          "7027:  case 'a':",
          "7028:  case 'e':",
          "7029:  case 'i':",
          "7030:  case 'o':",
          "7031:  case 'u':",
          "7032:    num_vowels++;",
          "7033:    break;",
          "7034:  }",
          "7036:  if(isdigit(word[i+1])) {",
          "7037:    num_digits++;",
          "7039:    continue;",
          "7040:  }",
          "7042:  num_bigram_checks++;",
          "7045:  printf(\"-> Checking %c%c\\n\", word[i], word[i+1]);",
          "7048:  if(ndpi_match_bigram(ndpi_str,",
          "7049:         &ndpi_str->impossible_bigrams_automa,",
          "7050:         &word[i])) {",
          "7052:    printf(\"IMPOSSIBLE %s\\n\", &word[i]);",
          "7054:    num_impossible++;",
          "7055:  } else if(ndpi_match_bigram(ndpi_str, &ndpi_str->bigrams_automa, &word[i])) {",
          "7056:    num_found++;",
          "7057:  }",
          "7062:     printf(\"[num_found: %u][num_impossible: %u][num_digits: %u][num_bigram_checks: %u][num_vowels: %u/%u]\\n\",",
          "7063:     num_found, num_impossible, num_digits, num_bigram_checks, num_vowels, j-num_vowels);",
          "7066:     if(num_bigram_checks",
          "7067:        && ((num_found == 0) || ((num_digits > 5) && (num_words <= 3)) || enough(num_found, num_impossible)))",
          "7068:       rc = 1;",
          "7070:     if(rc && flow)",
          "7071:       NDPI_SET_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7074:     if(rc)",
          "7075:       printf(\"DGA %s [num_found: %u][num_impossible: %u]\\n\",",
          "7076:       name, num_found, num_impossible);",
          "7078:   }",
          "7081:   printf(\"[DGA] Result: %u\", rc);",
          "7084:   return(rc);",
          "7085: }",
          "",
          "[Added Lines]",
          "5551:    return(0);",
          "5555:     return(0);",
          "5561:   void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,",
          "5562:           const char **func, u_int32_t *line) {",
          "5566:     if(ndpi_str->ndpi_debug_print_file != NULL)",
          "5569:     if(ndpi_str->ndpi_debug_print_function != NULL)",
          "5573:   }",
          "5578:   u_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,",
          "5579:      u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags) {",
          "5580:     return(ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));",
          "5581:   }",
          "5585:   void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5586:       u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5587:     struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5589:     ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5591:     if(src != NULL) {",
          "5592:       NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5594:       if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5595:  NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5596:     }",
          "5598:     if(dst != NULL) {",
          "5599:       NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5601:       if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5602:  NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5603:     }",
          "5608:   u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5609:     return(flow->detected_protocol_stack[1]);",
          "5610:   }",
          "5614:   void ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5615:          u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5616:     if(!flow)",
          "5617:       return;",
          "5619:     flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5620:       flow->detected_protocol_stack[1] = lower_detected_protocol;",
          "5621:   }",
          "5625:   void ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5626:            u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5627:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5633:     if(!packet)",
          "5634:       return;",
          "5636:     packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "5637:       packet->detected_protocol_stack[1] = lower_detected_protocol;",
          "5638:   }",
          "5648:   void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5649:     u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5650:     if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5651:       upper_detected_protocol = lower_detected_protocol;",
          "5653:     if(upper_detected_protocol == lower_detected_protocol)",
          "5654:       lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5656:     if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5657:       if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "5658:   (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5659:  if(ndpi_str->proto_defaults[upper_detected_protocol].can_have_a_subprotocol) {",
          "5660:    lower_detected_protocol = upper_detected_protocol;",
          "5661:    upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5662:  }",
          "5666:     ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5667:     ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5668:   }",
          "5672:   void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5673:     ndpi_protocol_category_t protocol_category) {",
          "5674:     flow->category = protocol_category;",
          "5675:   }",
          "5680:   void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {",
          "5681:     int a;",
          "5683:     for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5684:       packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5685:   }",
          "5689:   void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {",
          "5690:     if(flow) {",
          "5691:       int a;",
          "5693:       for (a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "5694:  flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "5695:     }",
          "5700:   void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip) {",
          "5701:     memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "5702:   }",
          "5708:   int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip) {",
          "5709:     return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "5710:   }",
          "5717:   int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "5721:     if(packet->iphv6 != NULL) {",
          "5722:       if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5723:   packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5724:   packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5725:   packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5726:  return(1);",
          "5728:       return(0);",
          "5729:     }",
          "5730: #endif",
          "5733:     if(packet->iph->saddr == ip->ipv4)",
          "5741:   int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "5745:     if(packet->iphv6 != NULL) {",
          "5746:       if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "5747:   packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "5748:   packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "5749:   packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "5750:  return(1);",
          "5752:       return(0);",
          "5753:     }",
          "5757:     if(packet->iph->saddr == ip->ipv4)",
          "5758:       return(1);",
          "5760:     return(0);",
          "5761:   }",
          "5767:   void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "5768:     NDPI_PROTOCOL_IP_clear(ip);",
          "5773:     if(packet->iphv6 != NULL) {",
          "5774:       ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "5775:       ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "5776:       ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "5777:       ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "5779:     } else",
          "5783:       ip->ipv4 = packet->iph->saddr;",
          "5784:   }",
          "5790:   void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "5791:     NDPI_PROTOCOL_IP_clear(ip);",
          "5795:     if(packet->iphv6 != NULL) {",
          "5796:       ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "5797:       ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "5798:       ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "5799:       ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "5801:     } else",
          "5805:       ip->ipv4 = packet->iph->daddr;",
          "5806:   }",
          "5810:   u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {",
          "5812:     return(ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "5813:     ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "5815:     return(0);",
          "5817:   }",
          "5821:   char *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len) {",
          "5822:     const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "5825:     if(ndpi_is_ipv6(ip)) {",
          "5826:       if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "5827:  buf[0] = '\\0';",
          "5829:       return(buf);",
          "5830:     }",
          "5833:     snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "5835:     return(buf);",
          "5836:   }",
          "5841:   int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {",
          "5842:     int rv = -1;",
          "5843:     memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "5845:     if(strchr(ip_str, '.')) {",
          "5846:       if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "5847:  rv = 4;",
          "5849:     } else {",
          "5850:       if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "5851:  rv = 6;",
          "5853:     }",
          "5855:     return(rv);",
          "5856:   }",
          "5860:   u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str,",
          "5861:          u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5862:     u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "5863:     return(ntohs(val));",
          "5864:   }",
          "5868:   u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {",
          "5869:     return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "5870:   }",
          "5874:   u_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {",
          "5875:     return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "5876:   }",
          "5880:   ndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "5881:             struct ndpi_flow_struct *flow, u_int8_t proto,",
          "5882:             u_int32_t shost /* host byte order */, u_int16_t sport,",
          "5883:             u_int32_t dhost /* host byte order */, u_int16_t dport) {",
          "5884:     u_int32_t rc;",
          "5885:     struct in_addr addr;",
          "5886:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "5887:     u_int8_t user_defined_proto;",
          "5889:     if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "5890:       rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "5892:       if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5893:  if(flow && (proto == IPPROTO_UDP) &&",
          "5894:     NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5895:    ;",
          "5896:  else {",
          "5897:    ret.app_protocol = rc,",
          "5898:      ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5900:    if(ret.app_protocol == ret.master_protocol)",
          "5901:      ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5908:       rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5909:       if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "5910:  if(flow && (proto == IPPROTO_UDP) &&",
          "5911:     NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "5912:    ;",
          "5913:  else {",
          "5914:    ret.app_protocol = rc;",
          "5916:    if(rc == NDPI_PROTOCOL_TLS)",
          "5917:      goto check_guessed_skype;",
          "5918:    else {",
          "5919:      ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5920:      return(ret);",
          "5921:    }",
          "5922:  }",
          "5923:       }",
          "5925:     check_guessed_skype:",
          "5926:       addr.s_addr = htonl(shost);",
          "5927:       if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "5928:  ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5929:       } else {",
          "5930:  addr.s_addr = htonl(dhost);",
          "5931:  if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "5932:    ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "5933:       }",
          "5934:     } else",
          "5935:       ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "5937:     ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "5938:     return(ret);",
          "5939:   }",
          "5943:   char *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,",
          "5945:     if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5946:       if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5947:  snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);",
          "5948:       else",
          "5949:  snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "5950:     } else",
          "5951:       snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "5953:     return(buf);",
          "5958:   char *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,",
          "5959:       ndpi_protocol proto, char *buf, u_int buf_len) {",
          "5960:     if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "5961:       if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5962:  snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "5963:    ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5964:       else",
          "5965:  snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "5966:     } else",
          "5967:       snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "5969:     return(buf);",
          "5970:   }",
          "5974:   int ndpi_is_custom_category(ndpi_protocol_category_t category) {",
          "5975:     switch(category) {",
          "5976:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "5977:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "5978:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "5979:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "5980:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "5981:       return(1);",
          "5982:       break;",
          "5984:     default:",
          "5985:       return(0);",
          "5986:       break;",
          "5987:     }",
          "5992:   void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,",
          "5993:          ndpi_protocol_category_t category,",
          "5994:          char *name) {",
          "5995:     if(!name)",
          "5996:       return;",
          "6000:       snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6001:       break;",
          "6004:       snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6005:       break;",
          "6008:       snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6009:       break;",
          "6012:       snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6013:       break;",
          "6016:       snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6017:       break;",
          "6020:       break;",
          "6022:   }",
          "6026:   const char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6027:          ndpi_protocol_category_t category) {",
          "6028:     if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "6029:       static char b[24];",
          "6031:       if(!ndpi_str)",
          "6032:  snprintf(b, sizeof(b), \"NULL nDPI\");",
          "6033:       else",
          "6034:  snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);",
          "6035:       return(b);",
          "6036:     }",
          "6038:     if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "6039:       switch(category) {",
          "6040:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6041:  return(ndpi_str->custom_category_labels[0]);",
          "6042:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6043:  return(ndpi_str->custom_category_labels[1]);",
          "6044:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6045:  return(ndpi_str->custom_category_labels[2]);",
          "6046:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6047:  return(ndpi_str->custom_category_labels[3]);",
          "6048:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6049:  return(ndpi_str->custom_category_labels[4]);",
          "6050:       case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "6051:  return(\"Code should not use this internal constant\");",
          "6052:       default:",
          "6053:  return(\"Unspecified\");",
          "6054:       }",
          "6055:     } else",
          "6056:       return(categories[category]);",
          "6057:   }",
          "6061:   ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,",
          "6062:          ndpi_protocol proto) {",
          "6063:     if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6064:       return(proto.category);",
          "6067:     else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||",
          "6068:      (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "6069:       if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6070:  return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "6071:     } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6072:       return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "6074:     return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "6075:   }",
          "6079:   char *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6080:        u_int16_t proto_id) {",
          "6081:     if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6082:        (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6083:        (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6084:       proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6086:     return(ndpi_str->proto_defaults[proto_id].protoName);",
          "6091:   ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,",
          "6092:           u_int16_t proto_id) {",
          "6093:     if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6094:        (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6095:        (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6096:       proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6098:     return(ndpi_str->proto_defaults[proto_id].protoBreed);",
          "6099:   }",
          "6103:   char *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6104:       ndpi_protocol_breed_t breed_id) {",
          "6105:     switch(breed_id) {",
          "6106:     case NDPI_PROTOCOL_SAFE:",
          "6107:       return(\"Safe\");",
          "6108:       break;",
          "6109:     case NDPI_PROTOCOL_ACCEPTABLE:",
          "6110:       return(\"Acceptable\");",
          "6111:       break;",
          "6112:     case NDPI_PROTOCOL_FUN:",
          "6113:       return(\"Fun\");",
          "6114:       break;",
          "6115:     case NDPI_PROTOCOL_UNSAFE:",
          "6116:       return(\"Unsafe\");",
          "6117:       break;",
          "6118:     case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "6119:       return(\"Potentially Dangerous\");",
          "6120:       break;",
          "6121:     case NDPI_PROTOCOL_DANGEROUS:",
          "6122:       return(\"Dangerous\");",
          "6123:       break;",
          "6124:     case NDPI_PROTOCOL_UNRATED:",
          "6125:     default:",
          "6126:       return(\"Unrated\");",
          "6127:       break;",
          "6128:     }",
          "6129:   }",
          "6133:   int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {",
          "6134:     int i;",
          "6136:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6137:       if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "6138:  return(i);",
          "6140:     return(-1);",
          "6145:   int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {",
          "6146:     int i;",
          "6148:     for (i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "6149:       const char *name = ndpi_category_get_name(ndpi_str, i);",
          "6151:       if(strcasecmp(cat, name) == 0)",
          "6152:  return(i);",
          "6153:     }",
          "6155:     return(-1);",
          "6156:   }",
          "6160:   void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6161:     int i;",
          "6163:     for (i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6164:       printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,",
          "6165:       ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "6166:       ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "6167:       ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));",
          "6168:   }",
          "6176:   char *ndpi_strnstr(const char *s, const char *find, size_t slen) {",
          "6177:     char c;",
          "6178:     size_t len;",
          "6180:     if((c = *find++) != '\\0') {",
          "6181:       len = strnlen(find, slen);",
          "6183:  char sc;",
          "6185:  do {",
          "6186:    if(slen-- < 1 || (sc = *s++) == '\\0')",
          "6187:      return(NULL);",
          "6188:  } while (sc != c);",
          "6189:  if(len > slen)",
          "6191:       } while (strncmp(s, find, len) != 0);",
          "6192:       s--;",
          "6193:     }",
          "6195:     return((char *) s);",
          "6203:   const char * ndpi_strncasestr(const char *str1, const char *str2, size_t len) {",
          "6204:     size_t str1_len = strnlen(str1, len);",
          "6205:     size_t str2_len = strlen(str2);",
          "6206:     size_t i;",
          "6208:     for(i = 0; i < (str1_len - str2_len + 1); i++){",
          "6209:       if(str1[0] == '\\0')",
          "6210:  return NULL;",
          "6211:       else if(strncasecmp(str1, str2, str2_len) == 0)",
          "6212:  return(str1);",
          "6214:       str1++;",
          "6215:     }",
          "6217:     return NULL;",
          "6218:   }",
          "6222:   int ndpi_match_prefix(const u_int8_t *payload,",
          "6223:    size_t payload_len, const char *str, size_t str_len) {",
          "6224:     int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "6226:     return(rc);",
          "6231:   int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,",
          "6232:         u_int string_to_match_len, ndpi_protocol_match_result *ret_match,",
          "6233:         u_int8_t is_host_match) {",
          "6234:     AC_TEXT_t ac_input_text;",
          "6235:     ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "6236:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6237:     int rc;",
          "6239:     if((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "6240:       return(NDPI_PROTOCOL_UNKNOWN);",
          "6242:     if(!automa->ac_automa_finalized) {",
          "6243:       printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6245:     }",
          "6247:     ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "6248:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6251:       As ac_automata_search can detect partial matches and continue the search process",
          "6252:       in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6253:       and in this case return it",
          "6255:     if((rc == 0) && (match.number != 0))",
          "6256:       rc = 1;",
          "6259:     ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,",
          "6260:       ret_match->protocol_breed = match.breed;",
          "6262:     return(rc ? match.number : 0);",
          "6267:   static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {",
          "6270:     if((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))",
          "6271:       return(0);",
          "6273:     switch(previous_proto) {",
          "6274:     case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6275:     case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6276:       if(new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6277:  return(1);",
          "6278:     }",
          "6285:   static u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6286:        struct ndpi_flow_struct *flow, char *string_to_match,",
          "6287:        u_int string_to_match_len, u_int16_t master_protocol_id,",
          "6288:        ndpi_protocol_match_result *ret_match, u_int8_t is_host_match) {",
          "6289:     int matching_protocol_id;",
          "6290:     struct ndpi_packet_struct *packet = &flow->packet;",
          "6292:     matching_protocol_id =",
          "6293:       ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);",
          "6296:     {",
          "6297:       char m[256];",
          "6298:       int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6300:       strncpy(m, string_to_match, len);",
          "6301:       m[len] = '\\0';",
          "6303:       NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,",
          "6304:       ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6305:     }",
          "6308:     if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "6309:        (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6311:       packet->detected_protocol_stack[1] = master_protocol_id,",
          "6312:  packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6314:       flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6315:  flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6317:       if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6318:  flow->category = ret_match->protocol_category;",
          "6320:       return(packet->detected_protocol_stack[0]);",
          "6321:     }",
          "6324:     string_to_match[string_to_match_len] = '\\0';",
          "6325:     NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6328:     ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6329:       ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;",
          "6331:     return(NDPI_PROTOCOL_UNKNOWN);",
          "6332:   }",
          "6336:   u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6337:      char *string_to_match, u_int string_to_match_len,",
          "6338:      ndpi_protocol_match_result *ret_match, u_int16_t master_protocol_id) {",
          "6339:     u_int16_t rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6340:        master_protocol_id, ret_match, 1);",
          "6341:     ndpi_protocol_category_t id = ret_match->protocol_category;",
          "6343:     if(ndpi_get_custom_category_match(ndpi_str, string_to_match, string_to_match_len, &id) != -1) {",
          "6345:  flow->category = ret_match->protocol_category = id;",
          "6346:  rc = master_protocol_id;",
          "6347:       }",
          "6350:     return(rc);",
          "6351:   }",
          "6355:   int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow,",
          "6356:        u_int16_t master_protocol, char *name, u_int name_len) {",
          "6357:     ndpi_protocol_match_result ret_match;",
          "6358:     u_int16_t subproto, what_len, i;",
          "6359:     char *what;",
          "6361:     if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6362:       what = &name[1], what_len = name_len - 1;",
          "6363:     else",
          "6364:       what = name, what_len = name_len;",
          "6367:     for(i=0; i<name_len; i++) what[i] = tolower(what[i]);",
          "6369:     subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len, &ret_match, master_protocol);",
          "6371:     if(subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6372:       ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6373:       ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6374:       return(1);",
          "6375:     } else",
          "6376:       return(0);",
          "6377:   }",
          "6381:   u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6382:         struct ndpi_flow_struct *flow,",
          "6383:         char *string_to_match, u_int string_to_match_len,",
          "6384:         ndpi_protocol_match_result *ret_match,",
          "6385:         u_int16_t master_protocol_id) {",
          "6386:     return(ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6387:       master_protocol_id, ret_match, 0));",
          "6388:   }",
          "6392:   int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6393:    ndpi_automa *automa, char *bigram_to_match) {",
          "6394:     AC_TEXT_t ac_input_text;",
          "6395:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6396:     int rc;",
          "6398:     if((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6399:       return(-1);",
          "6401:     if(!automa->ac_automa_finalized) {",
          "6403:       ndpi_finalize_initalization(ndpi_str);",
          "6405:       printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initalization()\\n\", __FILE__, __LINE__);",
          "6408:     }",
          "6410:     ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6411:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6414:       As ac_automata_search can detect partial matches and continue the search process",
          "6415:       in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6416:       and in this case return it",
          "6418:     if((rc == 0) && (match.number != 0))",
          "6419:       rc = 1;",
          "6421:     return(rc ? match.number : 0);",
          "6422:   }",
          "6426:   void ndpi_free_flow_data(struct ndpi_flow_struct *flow) {",
          "6427:     if(flow) {",
          "6428:       u_int is_quic = flow_is_proto(flow, NDPI_PROTOCOL_QUIC);",
          "6430:       if(flow->http.url)",
          "6431:  ndpi_free(flow->http.url);",
          "6433:       if(flow->http.content_type)",
          "6434:  ndpi_free(flow->http.content_type);",
          "6436:       if(flow->http.request_content_type)",
          "6437:  ndpi_free(flow->http.request_content_type);",
          "6439:       if(flow->http.user_agent)",
          "6440:  ndpi_free(flow->http.user_agent);",
          "6442:       if(flow->kerberos_buf.pktbuf)",
          "6443:  ndpi_free(flow->kerberos_buf.pktbuf);",
          "6445:       if(is_quic",
          "6446:   || flow_is_proto(flow, NDPI_PROTOCOL_TLS)",
          "6447:   || flow_is_proto(flow, NDPI_PROTOCOL_DTLS)",
          "6448:   ) {",
          "6449:  if(flow->protos.tls_quic_stun.tls_quic.server_names)",
          "6450:    ndpi_free(flow->protos.tls_quic_stun.tls_quic.server_names);",
          "6452:  if(flow->protos.tls_quic_stun.tls_quic.alpn)",
          "6453:    ndpi_free(flow->protos.tls_quic_stun.tls_quic.alpn);",
          "6455:  if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions)",
          "6456:    ndpi_free(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions);",
          "6458:  if(flow->protos.tls_quic_stun.tls_quic.issuerDN)",
          "6459:    ndpi_free(flow->protos.tls_quic_stun.tls_quic.issuerDN);",
          "6461:  if(flow->protos.tls_quic_stun.tls_quic.subjectDN)",
          "6462:    ndpi_free(flow->protos.tls_quic_stun.tls_quic.subjectDN);",
          "6464:  if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni)",
          "6465:    ndpi_free(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni);",
          "6466:       }",
          "6468:       if(flow->l4_proto == IPPROTO_TCP) {",
          "6469:  if(flow->l4.tcp.tls.message.buffer)",
          "6470:    ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "6472:  free_fragment(&flow->tcp_segments_list[0]);",
          "6473:  free_fragment(&flow->tcp_segments_list[1]);",
          "6475:       }",
          "6479:   void ndpi_free_flow(struct ndpi_flow_struct *flow) {",
          "6480:     if(flow) {",
          "6481:       ndpi_free_flow_data(flow);",
          "6482:       ndpi_free(flow);",
          "6483:     }",
          "6488:   char *ndpi_revision() {",
          "6489:     return(NDPI_GIT_RELEASE);",
          "6490:   }",
          "6497:   int gettimeofday(struct timeval *tp, struct timezone *tzp) {",
          "6501:     static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6503:     SYSTEMTIME system_time;",
          "6504:     FILETIME file_time;",
          "6505:     uint64_t time;",
          "6507:     GetSystemTime(&system_time);",
          "6508:     SystemTimeToFileTime(&system_time, &file_time);",
          "6509:     time = ((uint64_t) file_time.dwLowDateTime);",
          "6510:     time += ((uint64_t) file_time.dwHighDateTime) << 32;",
          "6512:     tp->tv_sec = (long) ((time - EPOCH) / 10000000L);",
          "6513:     tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6514:     return(0);",
          "6515:   }",
          "6518:   int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {",
          "6519:     int i;",
          "6521:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++) {",
          "6522:       if(a.fds_bits[i] & b.fds_bits[i])",
          "6523:  return(1);",
          "6524:     }",
          "6526:     return(0);",
          "6527:   }",
          "6530:   int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {",
          "6531:     int i;",
          "6533:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6534:       if(a.fds_bits[i] != 0)",
          "6535:  return(0);",
          "6537:     return(1);",
          "6538:   }",
          "6540:   void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {",
          "6541:     int i;",
          "6543:     for (i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6544:       printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6546:     printf(\"\\n\");",
          "6547:   }",
          "6550:   u_int16_t ndpi_get_api_version() {",
          "6551:     return(NDPI_API_VERSION);",
          "6552:   }",
          "6554:   const char *ndpi_get_gcrypt_version(void) {",
          "6556:     return gcry_check_version(NULL);",
          "6558:     return NULL;",
          "6559:   }",
          "6561:   ndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "6562:     return(ndpi_str->proto_defaults);",
          "6563:   }",
          "6565:   u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6566:     return(ndpi_str->ndpi_num_supported_protocols);",
          "6567:   }",
          "6569:   u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6570:     return(ndpi_str->ndpi_num_custom_protocols);",
          "6571:   }",
          "6573:   u_int ndpi_get_ndpi_detection_module_size() {",
          "6574:     return(sizeof(struct ndpi_detection_module_struct));",
          "6575:   }",
          "6577:   void ndpi_set_debug_bitmask(struct ndpi_detection_module_struct *ndpi_str, NDPI_PROTOCOL_BITMASK debug_bitmask) {",
          "6579:     ndpi_str->debug_bitmask = debug_bitmask;",
          "6581:   }",
          "6583:   void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){",
          "6584:     ndpi_str->ndpi_log_level = l;",
          "6585:   }",
          "6590:   struct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries) {",
          "6591:     struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6593:     if(!c)",
          "6594:       return(NULL);",
          "6596:     c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));",
          "6598:     if(!c->entries) {",
          "6599:       ndpi_free(c);",
          "6600:       return(NULL);",
          "6601:     } else",
          "6602:       c->num_entries = num_entries;",
          "6604:     return(c);",
          "6605:   }",
          "6607:   void ndpi_lru_free_cache(struct ndpi_lru_cache *c) {",
          "6608:     ndpi_free(c->entries);",
          "6609:     ndpi_free(c);",
          "6610:   }",
          "6612:   u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key,",
          "6613:           u_int16_t *value, u_int8_t clean_key_when_found) {",
          "6614:     u_int32_t slot = key % c->num_entries;",
          "6616:     if(c->entries[slot].is_full) {",
          "6618:       if(clean_key_when_found)",
          "6619:  c->entries[slot].is_full = 0;",
          "6620:       return(1);",
          "6621:     } else",
          "6622:       return(0);",
          "6623:   }",
          "6625:   void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {",
          "6626:     u_int32_t slot = key % c->num_entries;",
          "6628:     c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;",
          "6629:   }",
          "6634:     This function tells if it's possible to further dissect a given flow",
          "6635:     0 - All possible dissection has been completed",
          "6636:     1 - Additional dissection is possible",
          "6638:   u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,",
          "6639:        struct ndpi_flow_struct *flow) {",
          "6640:     u_int16_t proto =",
          "6641:       flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "6644:     printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,",
          "6645:     flow->detected_protocol_stack[0],",
          "6646:     flow->detected_protocol_stack[1],",
          "6647:     proto);",
          "6650:     switch(proto) {",
          "6651:     case NDPI_PROTOCOL_TLS:",
          "6652:       if(flow->l4.tcp.tls.certificate_processed) return(0);",
          "6654:       if(flow->l4.tcp.tls.num_tls_blocks <= ndpi_str->num_tls_blocks_to_follow) {",
          "6656:  return(1);",
          "6657:       }",
          "6658:       break;",
          "6660:     case NDPI_PROTOCOL_HTTP:",
          "6661:       if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "6662:  return(1);",
          "6663:       break;",
          "6665:     case NDPI_PROTOCOL_DNS:",
          "6666:     case NDPI_PROTOCOL_MDNS:",
          "6667:       if(flow->protos.dns.num_answers == 0)",
          "6668:  return(1);",
          "6669:       break;",
          "6671:     case NDPI_PROTOCOL_FTP_CONTROL:",
          "6672:     case NDPI_PROTOCOL_MAIL_POP:",
          "6673:     case NDPI_PROTOCOL_MAIL_IMAP:",
          "6674:     case NDPI_PROTOCOL_MAIL_SMTP:",
          "6675:       if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "6676:  return(1);",
          "6677:       break;",
          "6679:     case NDPI_PROTOCOL_SSH:",
          "6680:       if((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "6681:  return(1);",
          "6682:       break;",
          "6684:     case NDPI_PROTOCOL_TELNET:",
          "6685:       if(!flow->protos.telnet.password_detected)",
          "6686:  return(1);",
          "6687:       break;",
          "6689:     case NDPI_PROTOCOL_SKYPE:",
          "6690:       if(flow->extra_packets_func)",
          "6691:  return(1);",
          "6692:       break;",
          "6693:     }",
          "6695:     return(0);",
          "6700:   const char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {",
          "6701:     switch(proto) {",
          "6702:     case ndpi_l4_proto_unknown:",
          "6703:       return(\"\");",
          "6704:       break;",
          "6706:     case ndpi_l4_proto_tcp_only:",
          "6707:       return(\"TCP\");",
          "6708:       break;",
          "6710:     case ndpi_l4_proto_udp_only:",
          "6711:       return(\"UDP\");",
          "6712:       break;",
          "6714:     case ndpi_l4_proto_tcp_and_udp:",
          "6715:       return(\"TCP/UDP\");",
          "6716:       break;",
          "6717:     }",
          "6719:     return(\"\");",
          "6724:   ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,",
          "6725:          u_int16_t ndpi_proto_id) {",
          "6726:     if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "6727:       u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "6728:       NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "6730:       if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)",
          "6731:  return(ndpi_l4_proto_tcp_only);",
          "6732:       else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)",
          "6733:  return(ndpi_l4_proto_udp_only);",
          "6734:       else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)",
          "6735:  return(ndpi_l4_proto_tcp_and_udp);",
          "6736:     }",
          "6743:   ndpi_ptree_t *ndpi_ptree_create(void) {",
          "6744:     ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "6746:     if(tree) {",
          "6747:       tree->v4 = ndpi_New_Patricia(32);",
          "6748:       tree->v6 = ndpi_New_Patricia(128);",
          "6750:       if((!tree->v4) || (!tree->v6)) {",
          "6751:  ndpi_ptree_destroy(tree);",
          "6752:  return(NULL);",
          "6753:       }",
          "6756:     return(tree);",
          "6757:   }",
          "6761:   void ndpi_ptree_destroy(ndpi_ptree_t *tree) {",
          "6762:     if(tree) {",
          "6763:       if(tree->v4)",
          "6764:  ndpi_Destroy_Patricia(tree->v4, free_ptree_data);",
          "6765:       if(tree->v6)",
          "6766:  ndpi_Destroy_Patricia(tree->v6, free_ptree_data);",
          "6768:       ndpi_free(tree);",
          "6769:     }",
          "6774:   int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr,",
          "6775:    u_int8_t bits, u_int64_t user_data) {",
          "6776:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6777:     patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6778:     prefix_t prefix;",
          "6779:     patricia_node_t *node;",
          "6781:     if(bits > ptree->maxbits)",
          "6782:       return(-1);",
          "6784:     if(is_v6)",
          "6785:       fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6786:     else",
          "6787:       fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6790:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "6792:     if(node && (node->prefix->bitlen == bits))",
          "6793:       return(-2);",
          "6795:     node = ndpi_patricia_lookup(ptree, &prefix);",
          "6797:     if(node != NULL) {",
          "6798:       node->value.u.uv64 = user_data;",
          "6800:       return(0);",
          "6801:     }",
          "6803:     return(-3);",
          "6808:   int ndpi_ptree_match_addr(ndpi_ptree_t *tree,",
          "6809:        const ndpi_ip_addr_t *addr, u_int64_t *user_data) {",
          "6810:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "6811:     patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "6812:     prefix_t prefix;",
          "6813:     patricia_node_t *node;",
          "6814:     int bits = ptree->maxbits;",
          "6816:     if(is_v6)",
          "6817:       fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "6818:     else",
          "6819:       fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "6821:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "6823:     if(node) {",
          "6826:       return(0);",
          "6827:     }",
          "6829:     return(-1);",
          "6834:   void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {",
          "6835:     ndpi_MD5_CTX ctx;",
          "6837:     ndpi_MD5Init(&ctx);",
          "6838:     ndpi_MD5Update(&ctx, data, data_len);",
          "6839:     ndpi_MD5Final(hash, &ctx);",
          "6840:   }",
          "6844:   static int enough(int a, int b) {",
          "6845:     u_int8_t percentage = 20;",
          "6847:     if(b == 0) return(0);",
          "6848:     if(a == 0) return(1);",
          "6850:     if(b > (((a+1)*percentage)/100)) return(1);",
          "6852:     return(0);",
          "6853:   }",
          "6857:   static u_int8_t endsWith(char *str, char *ends, u_int8_t ends_len) {",
          "6858:     u_int str_len = str ? strlen(str) : 0;",
          "6859:     u_int8_t rc;",
          "6861:     if(str_len < ends_len) return(0);",
          "6863:     rc = (strncmp(&str[str_len-ends_len], ends, ends_len) != 0) ? 0 : 1;",
          "6866:     printf(\"[DGA] %s / %s [rc: %u]\\n\", str, ends, rc);",
          "6869:     return(rc);",
          "6870:   }",
          "6874:   int ndpi_check_dga_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6875:      struct ndpi_flow_struct *flow,",
          "6876:      char *name, u_int8_t is_hostname) {",
          "6877:     int len, rc = 0;",
          "6878:     u_int8_t max_num_char_repetitions = 0, last_char = 0, num_char_repetitions = 0, num_dots = 0;",
          "6879:     u_int8_t max_domain_element_len = 0, curr_domain_element_len = 0, first_element_is_numeric = 1;",
          "6881:     if(!name) return(0);",
          "6884:     printf(\"[DGA] %s\\n\", name);",
          "6887:     len = strlen(name);",
          "6889:     if(len >= 5) {",
          "6890:       int i, j, num_found = 0, num_impossible = 0, num_bigram_checks = 0, num_digits = 0, num_vowels = 0, num_words = 0;",
          "6891:       char tmp[128], *word, *tok_tmp;",
          "6892:       u_int max_tmp_len = sizeof(tmp)-1;",
          "6894:       len = snprintf(tmp, max_tmp_len, \"%s\", name);",
          "6895:       if(len < 0) {",
          "6897:  printf(\"[DGA] Too short\");",
          "6899:  return(0);",
          "6900:       } else",
          "6901:  tmp[len < max_tmp_len ? len : max_tmp_len] = '\\0';",
          "6903:       for(i=0, j=0; (i<len) && (j<max_tmp_len); i++) {",
          "6904:  tmp[j] = tolower(name[i]);",
          "6906:  if(tmp[j] == '.')",
          "6907:    num_dots++;",
          "6908:  else if(num_dots == 0) {",
          "6909:    if(!isdigit(tmp[j]))",
          "6910:      first_element_is_numeric = 0;",
          "6911:  }",
          "6913:  if(last_char == tmp[j]) {",
          "6914:    if(++num_char_repetitions > max_num_char_repetitions)",
          "6915:      max_num_char_repetitions = num_char_repetitions;",
          "6916:  } else",
          "6917:    num_char_repetitions = 1, last_char = tmp[j];",
          "6919:  switch(tmp[j]) {",
          "6920:  case '.':",
          "6921:  case '-':",
          "6922:  case '_':",
          "6923:  case '/':",
          "6924:  case ')':",
          "6925:  case '(':",
          "6926:  case ';':",
          "6927:  case ':':",
          "6928:  case '[':",
          "6929:  case ']':",
          "6930:  case ' ':",
          "6932:      Domain/word separator chars",
          "6934:      NOTE:",
          "6935:      this function is used also to detect other type of issues",
          "6936:      such as invalid/suspiciuous user agent",
          "6938:    if(curr_domain_element_len > max_domain_element_len)",
          "6939:      max_domain_element_len = curr_domain_element_len;",
          "6941:    curr_domain_element_len = 0;",
          "6942:    break;",
          "6944:  default:",
          "6945:    curr_domain_element_len++;",
          "6946:    break;",
          "6947:  }",
          "6949:  j++;",
          "6950:       }",
          "6952:       if(curr_domain_element_len > max_domain_element_len)",
          "6953:  max_domain_element_len = curr_domain_element_len;",
          "6956:       printf(\"[DGA] [max_num_char_repetitions: %u][max_domain_element_len: %u]\\n\",",
          "6957:       max_num_char_repetitions, max_domain_element_len);",
          "6960:       if(",
          "6961:   (is_hostname",
          "6962:    && (num_dots > 5)",
          "6963:    && (!first_element_is_numeric)",
          "6964:    && (!endsWith(tmp, \"in-addr.arpa\", 12))",
          "6965:    )",
          "6966:   || (max_num_char_repetitions > 5 /* num or consecutive repeated chars */)",
          "6968:     In case of a name with too many consecutive chars an alert is triggered",
          "6969:     This is the case for instance of the wildcard DNS query used by NetBIOS",
          "6970:     (ckaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) and that can be exploited",
          "6971:     for reflection attacks",
          "6972:     - https://www.akamai.com/uk/en/multimedia/documents/state-of-the-internet/ddos-reflection-netbios-name-server-rpc-portmap-sentinel-udp-threat-advisory.pdf",
          "6973:     - http://ubiqx.org/cifs/NetBIOS.html",
          "6975:   || (max_domain_element_len >= 19 /* word too long. Example bbcbedxhgjmdobdprmen.com */)",
          "6976:   ) {",
          "6977:  if(flow) NDPI_SET_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "6979:  printf(\"[DGA] Found!\");",
          "6981:  return(1);",
          "6982:       }",
          "6984:       tmp[j] = '\\0';",
          "6985:       len = j;",
          "6987:       for(word = strtok_r(tmp, \".\", &tok_tmp); ; word = strtok_r(NULL, \".\", &tok_tmp)) {",
          "6988:  if(!word) break;",
          "6990:  num_words++;",
          "6992:  if(strlen(word) < 3) continue;",
          "6995:  printf(\"-> %s [%s][len: %u]\\n\", word, name, (unsigned int)strlen(word));",
          "6998:  for(i = 0; word[i+1] != '\\0'; i++) {",
          "6999:    if(isdigit(word[i])) {",
          "7000:      num_digits++;",
          "7004:      continue;",
          "7005:    }",
          "7007:    switch(word[i]) {",
          "7008:    case '-':",
          "7010:         Let's check for double+consecutive --",
          "7011:         that are usually ok",
          "7012:         r2---sn-uxaxpu5ap5-2n5e.gvt1.com",
          "7014:      if(word[i+1] == '-')",
          "7017:    case '_':",
          "7018:    case ':':",
          "7019:      continue;",
          "7020:      break;",
          "7022:    case '.':",
          "7023:      continue;",
          "7024:      break;",
          "7025:    }",
          "7027:    switch(word[i]) {",
          "7028:    case 'a':",
          "7029:    case 'e':",
          "7030:    case 'i':",
          "7031:    case 'o':",
          "7032:    case 'u':",
          "7033:      num_vowels++;",
          "7034:      break;",
          "7035:    }",
          "7037:    if(isdigit(word[i+1])) {",
          "7038:      num_digits++;",
          "7040:      continue;",
          "7041:    }",
          "7043:    num_bigram_checks++;",
          "7046:    printf(\"-> Checking %c%c\\n\", word[i], word[i+1]);",
          "7049:    if(ndpi_match_bigram(ndpi_str,",
          "7050:           &ndpi_str->impossible_bigrams_automa,",
          "7051:           &word[i])) {",
          "7053:      printf(\"IMPOSSIBLE %s\\n\", &word[i]);",
          "7055:      num_impossible++;",
          "7056:    } else if(ndpi_match_bigram(ndpi_str, &ndpi_str->bigrams_automa, &word[i])) {",
          "7057:      num_found++;",
          "7058:    }",
          "7063:       printf(\"[num_found: %u][num_impossible: %u][num_digits: %u][num_bigram_checks: %u][num_vowels: %u/%u]\\n\",",
          "7064:       num_found, num_impossible, num_digits, num_bigram_checks, num_vowels, j-num_vowels);",
          "7067:       if(num_bigram_checks",
          "7068:   && ((num_found == 0) || ((num_digits > 5) && (num_words <= 3)) || enough(num_found, num_impossible)))",
          "7069:  rc = 1;",
          "7071:       if(rc && flow)",
          "7072:  NDPI_SET_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7075:       if(rc)",
          "7076:  printf(\"DGA %s [num_found: %u][num_impossible: %u]\\n\",",
          "7077:         name, num_found, num_impossible);",
          "7079:     }",
          "7082:     printf(\"[DGA] Result: %u\", rc);",
          "7085:     return(rc);",
          "7086:   }",
          "",
          "---------------"
        ],
        "src/lib/ndpi_utils.c||src/lib/ndpi_utils.c": [
          "File: src/lib/ndpi_utils.c -> src/lib/ndpi_utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "987:   int pad = 0;",
          "989:   memset(dtable, 0x80, 256);",
          "991:     dtable[base64_table[i]] = (u_char) i;",
          "992:   dtable['='] = 0;",
          "994:   count = 0;",
          "997:       count++;",
          "998:   }",
          "1001:     return NULL;",
          "1003:   olen = count / 4 * 3;",
          "1004:   pos = out = ndpi_malloc(olen);",
          "1006:     return NULL;",
          "1008:   count = 0;",
          "1010:     tmp = dtable[src[i]];",
          "1012:       continue;",
          "1015:       pad++;",
          "1016:     block[count] = tmp;",
          "1017:     count++;",
          "1022:       count = 0;",
          "1025:    pos--;",
          "1027:    pos -= 2;",
          "1028:  else {",
          "",
          "[Removed Lines]",
          "990:   for (i = 0; i < sizeof(base64_table) - 1; i++)",
          "995:   for (i = 0; i < len; i++) {",
          "996:     if (dtable[src[i]] != 0x80)",
          "1000:   if (count == 0 || count % 4)",
          "1005:   if (out == NULL)",
          "1009:   for (i = 0; i < len; i++) {",
          "1011:     if (tmp == 0x80)",
          "1014:     if (src[i] == '=')",
          "1018:     if (count == 4) {",
          "1023:       if (pad) {",
          "1024:  if (pad == 1)",
          "1026:  else if (pad == 2)",
          "",
          "[Added Lines]",
          "1004:   for(i = 0; i < sizeof(base64_table) - 1; i++)",
          "1009:   for(i = 0; i < len; i++) {",
          "1010:     if(dtable[src[i]] != 0x80)",
          "1014:   if(count == 0 || count % 4)",
          "1019:   if(out == NULL)",
          "1023:   for(i = 0; i < len; i++) {",
          "1025:     if(tmp == 0x80)",
          "1028:     if(src[i] == '=')",
          "1032:     if(count == 4) {",
          "1037:       if(pad) {",
          "1038:  if(pad == 1)",
          "1040:  else if(pad == 2)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1507: }",
          "1509: static int ndpi_is_rce_injection(char* query) {",
          "1511:     ndpi_compile_rce_regex();",
          "1512:     initialized_comp_rx = 1;",
          "1513:   }",
          "",
          "[Removed Lines]",
          "1510:   if (!initialized_comp_rx) {",
          "",
          "[Added Lines]",
          "1524:   if(!initialized_comp_rx) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1522:                             comp_rx[i]->optimized,",
          "1523:                             query, length, 0, 0, subStrVec, 30);",
          "1526:       return 1;",
          "1527:     }",
          "1528: #ifdef DEBUG",
          "",
          "[Removed Lines]",
          "1525:     if (pcreExecRet >= 0) {",
          "",
          "[Added Lines]",
          "1539:     if(pcreExecRet >= 0) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1795: void printRawData(const uint8_t *ptr, size_t len) {",
          "1796:   uint8_t *p=(uint8_t*)ptr;",
          "1797:   DBGINFO(\"ptr=%p, len=%llu\", ptr, (unsigned long long)len)",
          "1799:       size_t ctLines=0,i,j;",
          "1800:       char line1[ARRAYSZ_255]={0}, line2[ARRAYSZ_255]={0}, temp[ARRAYSZ_255];",
          "1801:       snprintf(line1,sizeof(line1),\"\\t%05X\",(unsigned int)(16*ctLines));",
          "1805:    printf(\"%s\\t%s\\n\", line1,line2);",
          "1806:    ctLines++;",
          "1807:    snprintf(line1,ARRAYSZ_255,\"\\t%05X\",(unsigned int)(16*ctLines));",
          "",
          "[Removed Lines]",
          "1798:     if (p && len>0) {",
          "1802:       for (i=0; i<len; i++) {",
          "1804:  if (i>0 && i%16==0) {",
          "",
          "[Added Lines]",
          "1812:     if(p && len > 0) {",
          "1816:       for(i=0; i<len; i++) {",
          "1818:  if(i > 0 && i%16==0) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1814:  p++;",
          "1815:       }",
          "1816:       uint8_t exv= i%16;",
          "1818:  strncat(line1, \"   \", 3);",
          "1819:       }",
          "1820:       printf(\"%s\\t%s\\n\", line1,line2);",
          "",
          "[Removed Lines]",
          "1817:       for(j=exv;exv>0 && j<16;j++) {",
          "",
          "[Added Lines]",
          "1831:       for(j=exv;exv > 0 && j<16;j++) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1828: void ins_sort_array(sorter_index_item_t arr[], int len) {",
          "1829:   DBGINFO(\"sorting  no. %u items\", (unsigned)len)",
          "1832:  sorter_index_item_t temp = arr[j];",
          "1833:  arr[j] = arr[j-1];",
          "1834:  arr[j-1] = temp;",
          "",
          "[Removed Lines]",
          "1830:     for (int i=1; i<len; i++) {",
          "1831:       for (int j=i; j>0 && arr[j].sort_value<arr[j-1].sort_value; j--) {",
          "",
          "[Added Lines]",
          "1844:     for(int i=1; i<len; i++) {",
          "1845:       for(int j=i; j > 0 && arr[j].sort_value<arr[j-1].sort_value; j--) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1839: void shell_sort_array(sorter_index_item_t arr[], int n) {",
          "1841:   DBGINFO(\"sorting  no. %u items\", (unsigned)n)",
          "1844:  sorter_index_item_t temp = arr[i];",
          "1845:  int j;",
          "1847:    arr[j] = arr[j - interval];",
          "1852:       }",
          "1853:     }",
          "1854: }",
          "",
          "[Removed Lines]",
          "1842:     for (int interval = n / 2; interval > 0; interval /= 2) {",
          "1843:       for (int i = interval; i < n; i += 1) {",
          "1846:  for (j = i; j >= interval && arr[j - interval].sort_value > temp.sort_value; j -= interval) {",
          "1848:    DBGTRACER(\"exchanged item no. %d (%d) with: %d (%d)\", j, arr[j].sort_value, j-interval, temp.sort_value)",
          "1849:      }",
          "1850:  DBGTRACER(\"item no. %d value: %d\", j, temp.sort_value)",
          "1851:    arr[j] = temp;",
          "",
          "[Added Lines]",
          "1856:     for(int interval = n / 2; interval > 0; interval /= 2) {",
          "1857:       for(int i = interval; i < n; i += 1) {",
          "1860:  for(j = i; j >= interval && arr[j - interval].sort_value > temp.sort_value; j -= interval) {",
          "1862:    DBGTRACER(\"exchanged item no. %d (%d) with: %d (%d)\", j, arr[j].sort_value, j-interval, temp.sort_value);",
          "1863:  }",
          "1865:  DBGTRACER(\"item no. %d value: %d\", j, temp.sort_value);",
          "1866:  arr[j] = temp;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1859: void free_fragment(fragments_wrapper_t *frag) {",
          "1891:     frag->ct_frag=0;",
          "1892:     frag->initial_offset=0;",
          "",
          "[Removed Lines]",
          "1862:     typedef struct fragment_wrapper {",
          "1863:     uint16_t id;",
          "1864:     uint8_t l4_protocol;",
          "1865:     uint8_t ct_frag;",
          "1866:     #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "1867:     char   *flow_label;    // IP6",
          "1868:     #endif",
          "1869:     fragment_t **fragments_list;",
          "1870:     } fragments_wrapper_t;",
          "1873:   if (frag) {",
          "1874:     DBGTRACER(\"(frag:%p) freeing fragments list -> %p\",frag, frag->fragments_list)",
          "1875:       if (frag->fragments_list) {",
          "1876:         DBGTRACER(\"fragments are %u.\",frag->ct_frag)",
          "1877:    for (int y=0;y<frag->ct_frag;y++) {",
          "1878:      if (frag->fragments_list[y]) {",
          "1879:        if (frag->fragments_list[y]->data) {",
          "1880:   DBGPOINTER(\"freeing fragment item %d -> %p\",y, frag->fragments_list[y])",
          "1881:     ndpi_free(frag->fragments_list[y]->data);",
          "1882:        }",
          "1883:        ndpi_free(frag->fragments_list[y]);",
          "1884:      }",
          "1885:    }",
          "1886:         DBGPOINTER(\"freeing fragments list -> %p\",frag->fragments_list)",
          "1887:    ndpi_free(frag->fragments_list);",
          "1888:         frag->fragments_list= NULL;",
          "1889:       }",
          "",
          "[Added Lines]",
          "1877:    typedef struct fragment_wrapper {",
          "1878:    uint16_t id;",
          "1879:    uint8_t l4_protocol;",
          "1880:    uint8_t ct_frag;",
          "1881:    #ifdef NDPI_DETECTION_SUPPORT_IPV6",
          "1882:    char   *flow_label;    // IP6",
          "1883:    #endif",
          "1884:    fragment_t **fragments_list;",
          "1885:    } fragments_wrapper_t;",
          "1888:   if(frag) {",
          "1889:     DBGTRACER(\"(frag:%p) freeing fragments list -> %p\",frag, frag->fragments_list);",
          "1890:     if(frag->fragments_list) {",
          "1891:       DBGTRACER(\"fragments are %u.\",frag->ct_frag);",
          "1893:       for(int y=0;y<frag->ct_frag;y++) {",
          "1894:  if(frag->fragments_list[y]) {",
          "1895:    if(frag->fragments_list[y]->data) {",
          "1896:      DBGPOINTER(\"freeing fragment item %d -> %p\",y, frag->fragments_list[y]);",
          "1897:      ndpi_free(frag->fragments_list[y]->data);",
          "1898:    }",
          "1900:    ndpi_free(frag->fragments_list[y]);",
          "1901:  }",
          "1902:       }",
          "1903:       DBGPOINTER(\"freeing fragments list -> %p\",frag->fragments_list)",
          "1904:  ndpi_free(frag->fragments_list);",
          "1905:       frag->fragments_list= NULL;",
          "1906:     }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1899:   DBGINFO(\"[flow:%p], dir: %d, seq:%u, ack:%u, len: %ubytes\",",
          "1900:           flow, flow->packet.packet_direction, ntohl(tcph->seq), ntohl(tcph->ack_seq), flow->packet.payload_packet_len)",
          "1927:       }",
          "1983:   return 0;",
          "1984: }",
          "",
          "[Removed Lines]",
          "1902:   if (flow->tcp_segments_management) {",
          "1903:     fragments_wrapper_t *fragW= &flow->tcp_segments_list[flow->packet.packet_direction];",
          "1904:     DBGTRACER(\"tcp segments management enabled (list container: %p)\",fragW)",
          "1906:     if (fragW->ct_frag == 0) {",
          "1907:       if (fragW->fragments_list)",
          "1908:         free_fragment(fragW);",
          "1911:       fragW->initial_offset = new_expected_seq;",
          "1912:       DBGTRACER(\"initialized initial_offset: %u)\",fragW->initial_offset)",
          "1913:     }",
          "1915:     if (flow->packet.payload_packet_len>0) {",
          "1916:       uint32_t seq;",
          "1919:       size_t new_len= (1+fragW->ct_frag) * sizeof(fragment_t*);",
          "1920:       DBGTRACER(\"actual fragment list ct=%d, new size: %llu\", fragW->ct_frag, (unsigned long long)new_len)",
          "1922:       fragW->fragments_list = ndpi_realloc(fragW->fragments_list,(fragW->ct_frag * sizeof(fragment_t*)),new_len);",
          "1923:       if (fragW->fragments_list == NULL) {",
          "1924:  flow->tcp_segments_management= 0;",
          "1925:  fprintf(stderr, \"[%8u] Not enough memory for new fragment \\n\", flow->packet_counter);",
          "1926:  return 0;",
          "1929:       DBGPOINTER(\"fragments_list initialized for item no. %u, list->%p i-esimo->%p\",",
          "1930:                  fragW->ct_frag, fragW->fragments_list, fragW->fragments_list[fragW->ct_frag])",
          "1933:       fragment_t *new_frag = (fragment_t*)ndpi_calloc(1, sizeof(fragment_t));",
          "1934:       if (new_frag == NULL) {",
          "1935:  flow->tcp_segments_management= 0;",
          "1936:  free_fragment(fragW);",
          "1937:  fprintf(stderr, \"[%8u] Not enough memory for new fragment \\n\", flow->packet_counter);",
          "1938:  return 0;",
          "1939:       }",
          "1941:       DBGPOINTER(\"new_frag=> %p\",new_frag)",
          "1944:       seq = (0xffffffff & ntohl(tcph->seq));",
          "1945:       if (seq >= fragW->initial_offset /* safety check */) {",
          "1946:         new_frag->offset = seq - fragW->initial_offset;",
          "1947:       } else {",
          "1949:         fprintf(stderr, \"[%8u] Bad seq or initial offset (seq = %u, initial offset = %u)\\n\",",
          "1950:                 flow->packet_counter, seq, fragW->initial_offset);",
          "1952:         flow->tcp_segments_management= 0;",
          "1953:         ndpi_free(new_frag);",
          "1954:         free_fragment(fragW);",
          "1955:         return 0;",
          "1956:       }",
          "1958:       DBGTRACER(\"offset calculation: seq %u, init: %u, offset result: %u\", ntohl(tcph->seq),",
          "1959:                 fragW->initial_offset, new_frag->offset)",
          "1960:          new_frag->len= flow->packet.payload_packet_len;",
          "1962:       new_frag->data = (void*)ndpi_calloc(new_frag->len, sizeof(char));",
          "1963:       DBGPOINTER(\"new_frag->data=> %p\",new_frag->data)",
          "1964:       if (new_frag->data) {",
          "1965:         memcpy(new_frag->data,flow->packet.payload,new_frag->len);",
          "1966:         fragW->fragments_list[fragW->ct_frag++]= new_frag;",
          "1967:       } else {",
          "1968:         flow->tcp_segments_management= 0;",
          "1969:         ndpi_free(new_frag);",
          "1970:         free_fragment(fragW);",
          "1971:         fprintf(stderr, \"[%8u] Not enough memory for new fragment data \\n\", flow->packet_counter);",
          "1972:         return 0;",
          "1973:       }",
          "1975:       DBGINFO(\"item no. %u: %p->%p [off:%u, len:%u, data:%p]\",",
          "1976:               fragW->ct_frag, fragW->fragments_list, *fragW->fragments_list,",
          "1977:               (unsigned int) new_frag->offset, (unsigned int)new_frag->len, new_frag->data)",
          "1979:       return fragW->ct_frag;",
          "1980:     }",
          "1981:   }",
          "",
          "[Added Lines]",
          "1919:     if(flow->tcp_segments_management) {",
          "1920:       fragments_wrapper_t *fragW= &flow->tcp_segments_list[flow->packet.packet_direction];",
          "1921:       DBGTRACER(\"tcp segments management enabled (list container: %p)\", fragW);",
          "1923:       if(fragW->ct_frag == 0) {",
          "1924:  if(fragW->fragments_list)",
          "1925:    free_fragment(fragW);",
          "1928:  fragW->initial_offset = new_expected_seq;",
          "1929:  DBGTRACER(\"initialized initial_offset: %u)\",fragW->initial_offset);",
          "1932:       if(flow->packet.payload_packet_len > 0) {",
          "1933:  uint32_t seq;",
          "1936:  size_t new_len= (1+fragW->ct_frag) * sizeof(fragment_t*);",
          "1937:  DBGTRACER(\"actual fragment list ct=%d, new size: %llu\", fragW->ct_frag, (unsigned long long)new_len);",
          "1939:  fragW->fragments_list = ndpi_realloc(fragW->fragments_list,(fragW->ct_frag * sizeof(fragment_t*)),new_len);",
          "1940:  if(fragW->fragments_list == NULL) {",
          "1941:    flow->tcp_segments_management= 0;",
          "1943:    return 0;",
          "1944:  }",
          "1946:  DBGPOINTER(\"fragments_list initialized for item no. %u, list->%p i-esimo->%p\",",
          "1947:      fragW->ct_frag, fragW->fragments_list, fragW->fragments_list[fragW->ct_frag]);",
          "1950:  fragment_t *new_frag = (fragment_t*)ndpi_calloc(1, sizeof(fragment_t));",
          "1951:  if(new_frag == NULL) {",
          "1952:    flow->tcp_segments_management= 0;",
          "1953:    free_fragment(fragW);",
          "1955:    return 0;",
          "1956:  }",
          "1958:  DBGPOINTER(\"new_frag=> %p\",new_frag);",
          "1961:  seq = (0xffffffff & ntohl(tcph->seq));",
          "1962:  if(seq >= fragW->initial_offset /* safety check */) {",
          "1963:    new_frag->offset = seq - fragW->initial_offset;",
          "1964:  } else {",
          "1966:       fprintf(stderr, \"[%8u] Bad seq or initial offset (seq = %u, initial offset = %u)\\n\",",
          "1967:       flow->packet_counter, seq, fragW->initial_offset);",
          "1969:    flow->tcp_segments_management= 0;",
          "1970:    ndpi_free(new_frag);",
          "1971:    free_fragment(fragW);",
          "1972:    return 0;",
          "1973:  }",
          "1975:  DBGTRACER(\"offset calculation: seq %u, init: %u, offset result: %u\", ntohl(tcph->seq),",
          "1976:     fragW->initial_offset, new_frag->offset);",
          "1977:  new_frag->len = flow->packet.payload_packet_len;",
          "1979:  new_frag->data = (void*)ndpi_calloc(new_frag->len, sizeof(char));",
          "1980:  DBGPOINTER(\"new_frag->data=> %p\",new_frag->data)",
          "1981:    if(new_frag->data) {",
          "1982:      memcpy(new_frag->data,flow->packet.payload,new_frag->len);",
          "1984: #ifdef DEBUG_REASSEMBLY",
          "1985:      printf(\"[%s:%u] ==>> %s() [%p][offset: %u]\\n\",",
          "1986:      __FILE__, __LINE__, __FUNCTION__, new_frag, new_frag->offset);",
          "1987: #endif",
          "1990:    } else {",
          "1991:      flow->tcp_segments_management= 0;",
          "1992:      ndpi_free(new_frag);",
          "1993:      free_fragment(fragW);",
          "1995:      return 0;",
          "1996:    }",
          "1998:  DBGINFO(\"item no. %u: %p->%p [off:%u, len:%u, data:%p]\",",
          "1999:   fragW->ct_frag, fragW->fragments_list, *fragW->fragments_list,",
          "2000:   (unsigned int) new_frag->offset, (unsigned int)new_frag->len, new_frag->data);",
          "2002:  return fragW->ct_frag;",
          "2003:       }",
          "2004:     }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1991:   uint32_t ret_value = 0;",
          "1992:   uint16_t last_item = 0;",
          "1994:   sorter_index_item_t *sorted_indexes;",
          "1995:   fragments_wrapper_t *fragW;",
          "1996:   uint8_t *buffer;",
          "1998:   fragW = &flow->tcp_segments_list[flow->packet.packet_direction];",
          "2000:   DBGTRACER(\"tcph:%p, ret_buffer:%p, len_buffer:%u\", tcph, ret_buffer, len_buffer);",
          "",
          "[Removed Lines]",
          "1990: uint32_t reassembly_fragment(struct ndpi_flow_struct *const flow, struct ndpi_tcphdr const * tcph, uint8_t **ret_buffer, size_t *len_buffer) {",
          "1993:   size_t length = 0,tot_length = 0;",
          "",
          "[Added Lines]",
          "2013: uint32_t reassembly_fragment(struct ndpi_flow_struct *const flow,",
          "2014:         struct ndpi_tcphdr const * tcph,",
          "2015:         uint8_t **ret_buffer, size_t *len_buffer) {",
          "2018:   size_t length = 0, tot_length = 0;",
          "2023: #ifdef DEBUG_REASSEMBLY",
          "2024:   printf(\"[%s:%u] ==>> %s()\\n\", __FILE__, __LINE__, __FUNCTION__);",
          "2025: #endif",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2003:   DBGINFO(\"phase 1: init sorter, calculate the size of buffer to reassemble: %u items\", fragW->ct_frag);",
          "2010:     free_fragment(fragW);",
          "2011:     return 0;",
          "2012:   }",
          "2017:     fragment_t *item = (fragment_t*)fragW->fragments_list[i];",
          "2019:     sorted_indexes[i].sort_value = item->offset;",
          "2020:     sorted_indexes[i].item_index = i;",
          "2021:     tot_length += item->len;",
          "2023:     DBGTRACER(\"segment (%d): len:%lu, offset: %u => partial buffer len: %lu\",",
          "2025:   }",
          "2028:   DBGINFO(\" phase 2 sorting %d segments and checking\",fragW->ct_frag);",
          "2034:     fragment_t *item = (fragment_t*)fragW->fragments_list[ sorted_indexes[i].item_index ];",
          "2037:     DBGTRACER(\"checking %d/%d element: offset=%lu vs t_length=%lu\",",
          "2038:               i, sorted_indexes[i].item_index, (unsigned long)item->offset, (unsigned long)tot_length);",
          "2042:       DBGINFO(\"stop processing at %d/%d element: len= %u; offset= %u\",",
          "2043:               i, sorted_indexes[i].item_index, (unsigned)length, (unsigned)item->offset)",
          "2048:       ret_value = fragW->initial_offset + item->offset;",
          "2050:       break;",
          "2056:       DBGINFO(\"checking %d/%d element: stop processing! len: %u; n_offset: %u\",",
          "2057:               i, sorted_indexes[i].item_index, (unsigned)length, (unsigned)item->offset);",
          "2062:       ret_value = fragW->initial_offset + item->offset;",
          "2064:       break;",
          "2066:     } else {",
          "2070:     }",
          "2071:   }",
          "2072:   last_item++;  // index to number aligment",
          "2075:   DBGINFO(\"phase 3: allocate memory for %u items and fill the buffer tot: %lu\", last_item, (unsigned long int)tot_length);",
          "2077:   buffer = ndpi_calloc(tot_length, sizeof(uint8_t));",
          "2082:     free_fragment(fragW);",
          "2083:     ndpi_free(sorted_indexes);",
          "2084:     return 0;",
          "",
          "[Removed Lines]",
          "2005:   sorted_indexes = ndpi_calloc(fragW->ct_frag, sizeof(sorter_index_item_t));",
          "2007:   if (sorted_indexes == NULL) {",
          "2008:     fprintf(stderr, \"[%8u] Not enough memory to sort the %u segments \\n\",",
          "2009:            flow->packet_counter, fragW->ct_frag);",
          "2014:   DBGPOINTER(\"sorted_indexes=> %p\", sorted_indexes)",
          "2016:   for (int i=0; i<fragW->ct_frag; i++) {",
          "2024:               i, (long unsigned int)item->len, (unsigned int)item->offset, (long unsigned int)tot_length);",
          "2030:   if (fragW->ct_frag>1) shell_sort_array(sorted_indexes, fragW->ct_frag);",
          "2033:   for (uint i=0; i<fragW->ct_frag; i++) {",
          "2040:     if (item->offset > (uint32_t)tot_length) {",
          "2045:       tot_length = length;",
          "2053:     } else if (item->offset != (uint32_t)length) {",
          "2059:       tot_length = length;",
          "2068:       length+= item->len;",
          "2069:       last_item= i;",
          "2079:   if (buffer == NULL) {",
          "2080:     fprintf(stderr, \"[%8u] Not enough memory for buffer for %u segments \\n\",",
          "2081:             flow->packet_counter,last_item);",
          "",
          "[Added Lines]",
          "2034:   sorted_indexes = (sorter_index_item_t*)ndpi_calloc(fragW->ct_frag, sizeof(sorter_index_item_t));",
          "2036:   if(sorted_indexes == NULL) {",
          "2042:   DBGPOINTER(\"sorted_indexes=> %p\", sorted_indexes);",
          "2044:   for(int i=0; i<fragW->ct_frag; i++) {",
          "2052:        i, (long unsigned int)item->len, (unsigned int)item->offset, (long unsigned int)tot_length);",
          "2058:   if(fragW->ct_frag>1) shell_sort_array(sorted_indexes, fragW->ct_frag);",
          "2061:   for(uint i=0; i<fragW->ct_frag; i++) {",
          "2068:     if((item->offset+item->len) > (uint32_t)tot_length) {",
          "2074: #ifdef DEBUG_REASSEMBLY",
          "2075:  printf(\"[%s:%u] ==>> Too long [last_item: %u][offset: %u/len: %u][%p]\\n\", __FILE__, __LINE__,",
          "2076:         last_item, item->offset, item->len, item);",
          "2077: #endif",
          "2085:     } else if(item->offset != (uint32_t)length) {",
          "2097:       length += item->len;",
          "2098:       last_item = i;",
          "2106: #ifdef DEBUG_REASSEMBLY",
          "2107:   printf(\"[%s:%u] ==>> [tot_length: %u][length: %u]\\n\",",
          "2108:   __FILE__, __LINE__, (u_int32_t)tot_length, (u_int32_t)length);",
          "2109: #endif",
          "2113:   if(buffer == NULL) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "2087:   DBGPOINTER(\"buffer (len:%lu)=> %p\", (unsigned long)tot_length, buffer);",
          "2090:     fragment_t *item = (fragment_t*) fragW->fragments_list[sorted_indexes[i].item_index];",
          "2092:     DBGINFO(\"copying data item no:%u of len: %lu to buffer: %p (offset:%lu)\",",
          "2093:             sorted_indexes[i].item_index, (unsigned long int)item->len, buffer,",
          "2094:             (unsigned long int)item->offset);",
          "2096:     memcpy((void*)(buffer + item->offset), item->data, item->len);",
          "",
          "[Removed Lines]",
          "2089:   for (uint i=0; i<last_item; i++) {",
          "",
          "[Added Lines]",
          "2122:   for(uint i=0; i<last_item; i++) {",
          "2129:     if((item->offset+item->len) > tot_length) {",
          "2131:       printf(\"[%s:%u] ==>> Out of boundary [%u vs %u][offset: %u][len: %u][item: %u/%u]\\n\", __FILE__, __LINE__,",
          "2132:       (u_int32_t)(item->offset+item->len), (u_int32_t)tot_length,",
          "2133:       (u_int32_t)item->offset, (u_int32_t)item->len, i, last_item);",
          "2135:       continue;",
          "2136:     } else {",
          "2137: #ifdef DEBUG_REASSEMBLY",
          "2138:       printf(\"[%s:%u] ==>> memcpy OK [%u vs %u][offset: %u][item: %u/%u]\\n\",",
          "2139:       __FILE__, __LINE__,",
          "2140:       (u_int32_t)(item->offset+item->len), (u_int32_t)tot_length,",
          "2141:       item->offset, i, last_item);",
          "2142: #endif",
          "2143:     }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "2102:     fragW->fragments_list[sorted_indexes[i].item_index]=NULL;",
          "2103:   }",
          "2106:     DBGTRACER(\"all processed: free all memory!\");",
          "2107:     free_fragment(fragW);",
          "2108:   } else {",
          "",
          "[Removed Lines]",
          "2105:   if (last_item == fragW->ct_frag) {",
          "",
          "[Added Lines]",
          "2154:   if(last_item == fragW->ct_frag) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "2113:     DBGPOINTER(\"old segments list: %p, new segments list: %p.\",",
          "2114:                fragW_old_list, fragW->fragments_list);",
          "2118:       free_fragment(fragW);",
          "2119:       ndpi_free(buffer);",
          "2120:       ndpi_free(sorted_indexes);",
          "",
          "[Removed Lines]",
          "2116:     if (!fragW->fragments_list) {",
          "2117:       fprintf(stderr, \"[%8u] Not enough memory for new segments list \\n\", flow->packet_counter);",
          "",
          "[Added Lines]",
          "2165:     if(!fragW->fragments_list) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "2122:     }",
          "2126:       fragment_t *item = (fragment_t*)fragW_old_list[sorted_indexes[i].item_index];",
          "2127:       fragW->fragments_list[i-last_item] = item;",
          "2129:         item->offset -= tot_length;",
          "2130:       }",
          "2138:       DBGTRACER(\"moving the item (%p), index %u - to position %u of new segments list; new offset: %u.\",",
          "",
          "[Removed Lines]",
          "2125:     for (uint i = last_item; i < fragW->ct_frag; i++) {",
          "2128:       if (item->offset >= tot_length /* safety check */) {",
          "2132:       else {",
          "2133:         fprintf(stderr, \"[%8u] Bad offset update (item->offset = %u, tot_length = %lu)\\n\",",
          "2134:           flow->packet_counter, item->offset, tot_length);",
          "2135:       }",
          "",
          "[Added Lines]",
          "2174:     for(uint i = last_item; i < fragW->ct_frag; i++) {",
          "2177:       if(item->offset >= tot_length /* safety check */) {",
          "2181:   else {",
          "2182:   fprintf(stderr, \"[%8u] Bad offset update (item->offset = %u, tot_length = %lu)\\n\",",
          "2183:   flow->packet_counter, item->offset, tot_length);",
          "2184:   }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "2147:             (unsigned)fragW->ct_frag, (unsigned)fragW->initial_offset);",
          "2149:     DBGPOINTER(\"freeing old segments list: %p \", fragW_old_list)",
          "2151:   }",
          "2154:     DBGPOINTER(\"freeing sorter indexes: %p \", sorted_indexes);",
          "2155:     ndpi_free(sorted_indexes);",
          "2156:   }",
          "",
          "[Removed Lines]",
          "2150:     ndpi_free(fragW_old_list);",
          "2153:   if (sorted_indexes) {",
          "",
          "[Added Lines]",
          "2199:       ndpi_free(fragW_old_list);",
          "2202:   if(sorted_indexes) {",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "2171:   }",
          "2173:   DBGINFO(\"returning: %d\", ret_value);",
          "2175: }",
          "",
          "[Removed Lines]",
          "2174:   return ret_value;",
          "",
          "[Added Lines]",
          "2223:   return(ret_value);",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "2183:   DBGINFO(\"## sorted flags: %d/%d \",flow->not_sorted[0],flow->not_sorted[1]);",
          "2186:     uint32_t *trigger, expected;",
          "2187:     uint8_t *not_sorted;",
          "",
          "[Removed Lines]",
          "2185:   if (flow->next_tcp_seq_nr[flow->packet.packet_direction]) {",
          "",
          "[Added Lines]",
          "2234:   if(flow->next_tcp_seq_nr[flow->packet.packet_direction]) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "2190:     not_sorted = &flow->not_sorted[flow->packet.packet_direction];",
          "2191:     trigger = &flow->trigger[flow->packet.packet_direction];",
          "2199:       DBGINFO(\"received a segment (seq:%u) over the expected (next:%u)\", (0xffffffff & ntohl(tcph->seq)), expected);",
          "",
          "[Removed Lines]",
          "2193:     DBGTRACER(\"dir:%d, trg:%u, next:%u\", flow->packet.packet_direction,*trigger, flow->next_tcp_seq_nr[flow->packet.packet_direction]);",
          "2195:     expected = (*not_sorted && *trigger) ? ndpi_min(*trigger,flow->next_tcp_seq_nr[flow->packet.packet_direction]) : flow->next_tcp_seq_nr[flow->packet.packet_direction];",
          "2197:     if (expected < (0xffffffff & ntohl(tcph->seq))) {",
          "2201:       if (add_segment_to_buffer(flow, tcph, expected)) {",
          "2202:  DBGTRACER(\"segment (seq:%u) bufferized, waiting for (next:%u)\", (0xffffffff & ntohl(tcph->seq)), expected);",
          "",
          "[Added Lines]",
          "2242:     DBGTRACER(\"dir:%d, trg:%u, next:%u\", flow->packet.packet_direction,*trigger,",
          "2243:        flow->next_tcp_seq_nr[flow->packet.packet_direction]);",
          "2245:     expected = (*not_sorted && *trigger) ? ndpi_min(*trigger, flow->next_tcp_seq_nr[flow->packet.packet_direction]) : flow->next_tcp_seq_nr[flow->packet.packet_direction];",
          "2247:     if(expected < (0xffffffff & ntohl(tcph->seq))) {",
          "2251:       if(add_segment_to_buffer(flow, tcph, expected)) {",
          "2252:  DBGTRACER(\"segment (seq:%u) bufferized, waiting for(next:%u)\", (0xffffffff & ntohl(tcph->seq)), expected);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "2208:       }",
          "2209:       return 1;",
          "2212:       DBGINFO(\"received a segment (seq:%u) minus than the expected (next:%u): retransmission!!\", (0xffffffff & ntohl(tcph->seq)), flow->next_tcp_seq_nr[flow->packet.packet_direction]);",
          "2214:       flow->packet.tcp_retransmission = 1;",
          "",
          "[Removed Lines]",
          "2211:     } else if (expected>(0xffffffff & ntohl(tcph->seq))) {",
          "",
          "[Added Lines]",
          "2261:     } else if(expected>(0xffffffff & ntohl(tcph->seq))) {",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "2228:       }",
          "2230:     } else {",
          "2240:      flow->packet.payload_packet_len= len_buffer;",
          "2241:      flow->packet.payload= ret_buffer;",
          "",
          "[Removed Lines]",
          "2231:       DBGTRACER(\"seq (%u) and expected (%u) matched! sorted flag: %d\", (0xffffffff & ntohl(tcph->seq)), flow->next_tcp_seq_nr[flow->packet.packet_direction], *not_sorted);",
          "2233:       if (*not_sorted) {",
          "2234:  if (add_segment_to_buffer(flow, tcph, 0)) {",
          "2238:    if (len_buffer>0) {",
          "",
          "[Added Lines]",
          "2281:       DBGTRACER(\"seq (%u) and expected (%u) matched! sorted flag: %d\",",
          "2282:   (0xffffffff & ntohl(tcph->seq)),",
          "2283:   flow->next_tcp_seq_nr[flow->packet.packet_direction],",
          "2286:       if(*not_sorted) {",
          "2287:  if(add_segment_to_buffer(flow, tcph, 0)) {",
          "2291:    if(len_buffer > 0) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ca15e3295e217578fd08d6677e1f1a346ec15481",
      "candidate_info": {
        "commit_hash": "ca15e3295e217578fd08d6677e1f1a346ec15481",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/ca15e3295e217578fd08d6677e1f1a346ec15481",
        "files": [
          "example/ndpiReader.c",
          "src/include/ndpi_api.h.in",
          "src/include/ndpi_typedefs.h",
          "src/lib/ndpi_main.c",
          "src/lib/ndpi_utils.c",
          "src/lib/protocols/tls.c"
        ],
        "message": "Added risk/score dump (ndpiReader -h) Added ndpi_dump_risks_score() API score",
        "before_after_code_files": [
          "example/ndpiReader.c||example/ndpiReader.c",
          "src/include/ndpi_api.h.in||src/include/ndpi_api.h.in",
          "src/include/ndpi_typedefs.h||src/include/ndpi_typedefs.h",
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c",
          "src/lib/ndpi_utils.c||src/lib/ndpi_utils.c",
          "src/lib/protocols/tls.c||src/lib/protocols/tls.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "example/ndpiReader.c||example/ndpiReader.c": [
          "File: example/ndpiReader.c -> example/ndpiReader.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "535:     ndpi_set_protocol_detection_bitmask2(ndpi_info_mod, &all);",
          "537:     ndpi_dump_protocols(ndpi_info_mod);",
          "538:   }",
          "540:   exit(!long_help);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "539:     printf(\"\\n\\nnDPI supported risks:\\n\");",
          "540:     ndpi_dump_risks_score(ndpi_info_mod);",
          "",
          "---------------"
        ],
        "src/include/ndpi_api.h.in||src/include/ndpi_api.h.in": [
          "File: src/include/ndpi_api.h.in -> src/include/ndpi_api.h.in",
          "--- Hunk 1 ---",
          "[Context before]",
          "681:   void ndpi_dump_protocols(struct ndpi_detection_module_struct *mod);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "688:   void ndpi_dump_risks_score();",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1512:   void ndpi_serialize_risk(ndpi_serializer *serializer, struct ndpi_flow_struct *flow);",
          "1514:   const char* ndpi_risk2str(ndpi_risk_enum risk);",
          "1515:   ndpi_risk_severity ndpi_risk2severity(ndpi_risk_enum risk);",
          "1516:   u_int16_t ndpi_risk2score(ndpi_risk risk);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1522:   const char* ndpi_severity2str(ndpi_risk_severity s);",
          "",
          "---------------"
        ],
        "src/include/ndpi_typedefs.h||src/include/ndpi_typedefs.h": [
          "File: src/include/ndpi_typedefs.h -> src/include/ndpi_typedefs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "114:   NDPI_RISK_SEVERE",
          "115: } ndpi_risk_severity;",
          "123: typedef enum {",
          "",
          "[Removed Lines]",
          "117: #define NDPI_SCORE_RISK_LOW      10",
          "118: #define NDPI_SCORE_RISK_MEDIUM   50",
          "119: #define NDPI_SCORE_RISK_HIGH    100",
          "120: #define NDPI_SCORE_RISK_SEVERE  250",
          "",
          "[Added Lines]",
          "117: typedef enum {",
          "118:   NDPI_SCORE_RISK_LOW    =  10,",
          "119:   NDPI_SCORE_RISK_MEDIUM =  50,",
          "120:   NDPI_SCORE_RISK_HIGH   = 100,",
          "121:   NDPI_SCORE_RISK_SEVERE = 250,",
          "122: } ndpi_risk_score;",
          "",
          "---------------"
        ],
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "326:   va_start(ap, protoId);",
          "327:   while (current_arg != NDPI_PROTOCOL_NO_MORE_SUBPROTOCOLS)",
          "332:   va_end(ap);",
          "334:   ndpi_str->proto_defaults[protoId].subprotocols = NULL;",
          "",
          "[Removed Lines]",
          "328:   {",
          "329:     ndpi_str->proto_defaults[protoId].subprotocol_count++;",
          "330:     current_arg = va_arg(ap, int);",
          "331:   }",
          "",
          "[Added Lines]",
          "328:     {",
          "329:       ndpi_str->proto_defaults[protoId].subprotocol_count++;",
          "330:       current_arg = va_arg(ap, int);",
          "331:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "337:   ndpi_str->proto_defaults[protoId].subprotocol_count--;",
          "339:   if (ndpi_str->proto_defaults[protoId].subprotocol_count == 0)",
          "344:   ndpi_str->proto_defaults[protoId].subprotocols =",
          "345:     ndpi_malloc(sizeof(protoId) * ndpi_str->proto_defaults[protoId].subprotocol_count);",
          "",
          "[Removed Lines]",
          "340:   {",
          "341:     return;",
          "342:   }",
          "",
          "[Added Lines]",
          "340:     {",
          "341:       return;",
          "342:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "348:   va_start(ap, protoId);",
          "349:   current_arg = va_arg(ap, int);",
          "350:   while (current_arg != NDPI_PROTOCOL_NO_MORE_SUBPROTOCOLS)",
          "355:   va_end(ap);",
          "356: }",
          "",
          "[Removed Lines]",
          "351:   {",
          "352:     ndpi_str->proto_defaults[protoId].subprotocols[i++] = current_arg;",
          "353:     current_arg = va_arg(ap, int);",
          "354:   }",
          "",
          "[Added Lines]",
          "351:     {",
          "352:       ndpi_str->proto_defaults[protoId].subprotocols[i++] = current_arg;",
          "353:       current_arg = va_arg(ap, int);",
          "354:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "790:      ndpi_build_default_ports(ports_a, 53, 0, 0, 0, 0) /* TCP */,",
          "791:      ndpi_build_default_ports(ports_b, 53, 0, 0, 0, 0) /* UDP */);",
          "792:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_DNS,",
          "795:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_IPP,",
          "796:      \"IPP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "797:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "",
          "[Removed Lines]",
          "793:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "[Added Lines]",
          "793:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "805:      ndpi_build_default_ports(ports_a, 80, 0 /* ntop */, 0, 0, 0) /* TCP */,",
          "806:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "807:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_HTTP,",
          "811:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_MDNS,",
          "812:      \"MDNS\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "813:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "814:      ndpi_build_default_ports(ports_b, 5353, 5354, 0, 0, 0) /* UDP */);",
          "815:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_MDNS,",
          "818:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_NTP,",
          "819:      \"NTP\", NDPI_PROTOCOL_CATEGORY_SYSTEM_OS,",
          "820:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "",
          "[Removed Lines]",
          "808:      NDPI_PROTOCOL_AIMINI,",
          "809:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "816:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "[Added Lines]",
          "808:          NDPI_PROTOCOL_AIMINI,",
          "809:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "816:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1156:      ndpi_build_default_ports(ports_a, 443, 0, 0, 0, 0) /* TCP */,",
          "1157:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1158:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_TLS,",
          "1161:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_SAFE, NDPI_PROTOCOL_DTLS,",
          "1162:      \"DTLS\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1163:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1164:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1165:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_DTLS,",
          "1168:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_SSH,",
          "1169:      \"SSH\", NDPI_PROTOCOL_CATEGORY_REMOTE_ACCESS,",
          "1170:      ndpi_build_default_ports(ports_a, 22, 0, 0, 0, 0) /* TCP */,",
          "",
          "[Removed Lines]",
          "1159:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "1166:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "[Added Lines]",
          "1159:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "1166:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1290:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1291:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1292:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_HTTP_CONNECT,",
          "1295:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_HTTP_PROXY,",
          "1296:      \"HTTP_Proxy\", NDPI_PROTOCOL_CATEGORY_WEB,",
          "1297:      ndpi_build_default_ports(ports_a, 8080, 3128, 0, 0, 0) /* TCP */,",
          "1298:      ndpi_build_default_ports(ports_b, 0, 0, 0, 0, 0) /* UDP */);",
          "1299:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_HTTP_PROXY,",
          "1302:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_CITRIX,",
          "1303:      \"Citrix\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1304:      ndpi_build_default_ports(ports_a, 1494, 2598, 0, 0, 0) /* TCP */,",
          "",
          "[Removed Lines]",
          "1293:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "1300:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "[Added Lines]",
          "1293:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "1300:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1340:      ndpi_build_default_ports(ports_a, 0, 0, 0, 0, 0) /* TCP */,",
          "1341:      ndpi_build_default_ports(ports_b, 443, 80, 0, 0, 0) /* UDP */);",
          "1342:   ndpi_set_proto_subprotocols(ndpi_str, NDPI_PROTOCOL_QUIC,",
          "1345:   ndpi_set_proto_defaults(ndpi_str, NDPI_PROTOCOL_ACCEPTABLE, NDPI_PROTOCOL_DIAMETER,",
          "1346:      \"Diameter\", NDPI_PROTOCOL_CATEGORY_NETWORK,",
          "1347:      ndpi_build_default_ports(ports_a, 3868, 0, 0, 0, 0) /* TCP */,",
          "",
          "[Removed Lines]",
          "1343:      NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "[Added Lines]",
          "1343:          NDPI_PROTOCOL_MATCHED_BY_CONTENT,",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1823:   if(ndpi_str->ndpi_num_custom_protocols == 0) {",
          "1832:     if(ndpi_is_public_ipv4(ntohl(pin->s_addr)) == 0)",
          "",
          "[Removed Lines]",
          "1825:        In case we don't have defined any custom protocol we check the ptree",
          "1826:        only in case of public IP addresses as in ndpi_content_match.c.inc",
          "1827:        we only have public IP addresses. Instead with custom protocols, users",
          "1828:        might have defined private protocols hence we should not skip",
          "1829:        the checks below",
          "",
          "[Added Lines]",
          "1825:       In case we don't have defined any custom protocol we check the ptree",
          "1826:       only in case of public IP addresses as in ndpi_content_match.c.inc",
          "1827:       we only have public IP addresses. Instead with custom protocols, users",
          "1828:       might have defined private protocols hence we should not skip",
          "1829:       the checks below",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2608:     if(ndpi_str->malicious_sha1_automa.ac_automa != NULL)",
          "2609:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->malicious_sha1_automa.ac_automa,",
          "2612:     if(ndpi_str->custom_categories.hostnames.ac_automa != NULL)",
          "2613:       ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "",
          "[Removed Lines]",
          "2610:                            1 /* free patterns strings memory */);",
          "",
          "[Added Lines]",
          "2610:      1 /* free patterns strings memory */);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2974: static int ndpi_load_risky_domain(struct ndpi_detection_module_struct *ndpi_str,",
          "2976:   if(ndpi_str->risky_domain_automa.ac_automa == NULL)",
          "2977:     ndpi_str->risky_domain_automa.ac_automa = ac_automata_init(ac_match_handler);",
          "",
          "[Removed Lines]",
          "2975:      char* domain_name) {",
          "",
          "[Added Lines]",
          "2975:       char* domain_name) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "4034: void ndpi_free_flow_data(struct ndpi_flow_struct* flow) {",
          "4080:     }",
          "4081: }",
          "",
          "[Removed Lines]",
          "4035:     if(flow) {",
          "4036:         if(flow->http.url)",
          "4037:             ndpi_free(flow->http.url);",
          "4039:         if(flow->http.content_type)",
          "4040:             ndpi_free(flow->http.content_type);",
          "4042:         if(flow->http.request_content_type)",
          "4043:             ndpi_free(flow->http.request_content_type);",
          "4045:         if(flow->http.user_agent)",
          "4046:             ndpi_free(flow->http.user_agent);",
          "4048:         if(flow->kerberos_buf.pktbuf)",
          "4049:             ndpi_free(flow->kerberos_buf.pktbuf);",
          "4051:         if(flow_is_proto(flow, NDPI_PROTOCOL_QUIC) ||",
          "4052:             flow_is_proto(flow, NDPI_PROTOCOL_TLS) ||",
          "4053:             flow_is_proto(flow, NDPI_PROTOCOL_DTLS) ||",
          "4054:             flow_is_proto(flow, NDPI_PROTOCOL_MAIL_SMTPS) ||",
          "4055:             flow_is_proto(flow, NDPI_PROTOCOL_MAIL_POPS) ||",
          "4056:             flow_is_proto(flow, NDPI_PROTOCOL_MAIL_IMAPS)) {",
          "4057:             if(flow->protos.tls_quic_stun.tls_quic.server_names)",
          "4058:                 ndpi_free(flow->protos.tls_quic_stun.tls_quic.server_names);",
          "4060:             if(flow->protos.tls_quic_stun.tls_quic.alpn)",
          "4061:                 ndpi_free(flow->protos.tls_quic_stun.tls_quic.alpn);",
          "4063:             if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions)",
          "4064:                 ndpi_free(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions);",
          "4066:             if(flow->protos.tls_quic_stun.tls_quic.issuerDN)",
          "4067:                 ndpi_free(flow->protos.tls_quic_stun.tls_quic.issuerDN);",
          "4069:             if(flow->protos.tls_quic_stun.tls_quic.subjectDN)",
          "4070:                 ndpi_free(flow->protos.tls_quic_stun.tls_quic.subjectDN);",
          "4072:             if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni)",
          "4073:                 ndpi_free(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni);",
          "4074:         }",
          "4076:         if(flow->l4_proto == IPPROTO_TCP) {",
          "4077:             if(flow->l4.tcp.tls.message.buffer)",
          "4078:                 ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "4079:         }",
          "",
          "[Added Lines]",
          "4035:   if(flow) {",
          "4036:     if(flow->http.url)",
          "4037:       ndpi_free(flow->http.url);",
          "4039:     if(flow->http.content_type)",
          "4040:       ndpi_free(flow->http.content_type);",
          "4042:     if(flow->http.request_content_type)",
          "4043:       ndpi_free(flow->http.request_content_type);",
          "4045:     if(flow->http.user_agent)",
          "4046:       ndpi_free(flow->http.user_agent);",
          "4048:     if(flow->kerberos_buf.pktbuf)",
          "4049:       ndpi_free(flow->kerberos_buf.pktbuf);",
          "4051:     if(flow_is_proto(flow, NDPI_PROTOCOL_QUIC) ||",
          "4052:        flow_is_proto(flow, NDPI_PROTOCOL_TLS) ||",
          "4053:        flow_is_proto(flow, NDPI_PROTOCOL_DTLS) ||",
          "4054:        flow_is_proto(flow, NDPI_PROTOCOL_MAIL_SMTPS) ||",
          "4055:        flow_is_proto(flow, NDPI_PROTOCOL_MAIL_POPS) ||",
          "4056:        flow_is_proto(flow, NDPI_PROTOCOL_MAIL_IMAPS)) {",
          "4057:       if(flow->protos.tls_quic_stun.tls_quic.server_names)",
          "4058:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.server_names);",
          "4060:       if(flow->protos.tls_quic_stun.tls_quic.alpn)",
          "4061:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.alpn);",
          "4063:       if(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions)",
          "4064:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.tls_supported_versions);",
          "4066:       if(flow->protos.tls_quic_stun.tls_quic.issuerDN)",
          "4067:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.issuerDN);",
          "4069:       if(flow->protos.tls_quic_stun.tls_quic.subjectDN)",
          "4070:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.subjectDN);",
          "4072:       if(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni)",
          "4073:  ndpi_free(flow->protos.tls_quic_stun.tls_quic.encrypted_sni.esni);",
          "4074:     }",
          "4076:     if(flow->l4_proto == IPPROTO_TCP) {",
          "4077:       if(flow->l4.tcp.tls.message.buffer)",
          "4078:  ndpi_free(flow->l4.tcp.tls.message.buffer);",
          "4080:   }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "4114:   if(decaps_iph && decaps_iph->version == IPVERSION && decaps_iph->ihl >= 5) {",
          "4115:     NDPI_LOG_DBG2(ndpi_str, \"ipv4 header\\n\");",
          "4116:   } else if(decaps_iph && decaps_iph->version == 6 && l3len >= sizeof(struct ndpi_ipv6hdr) &&",
          "4118:     NDPI_LOG_DBG2(ndpi_str, \"ipv6 header\\n\");",
          "4119:     flow->packet.iphv6 = (struct ndpi_ipv6hdr *) flow->packet.iph;",
          "4120:     flow->packet.iph = NULL;",
          "",
          "[Removed Lines]",
          "4117:    (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {",
          "",
          "[Added Lines]",
          "4117:      (ndpi_str->ip_version_limit & NDPI_DETECTION_ONLY_IPV4) == 0) {",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "4242:     flow->l4.tcp.seen_ack == 0) {",
          "4244:  } else",
          "4246:       flow->l4.tcp.seen_ack == 0) {",
          "4294:    }",
          "4302:    }",
          "4303:  }",
          "4308:  }",
          "4312:       }",
          "4316:       }",
          "4327:     }",
          "4328:   }",
          "4353:     {",
          "4354:       if ((flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4355:           (ndpi_str->proto_defaults[flow->guessed_protocol_id].func != NULL) &&",
          "4356:           (is_tcp_without_payload == 0 ||",
          "4357:            ((ndpi_str->callback_buffer[flow->guessed_protocol_id].ndpi_selection_bitmask &",
          "4364:     }",
          "4367:     {",
          "4368:       for (u_int32_t a = 0; a < callback_buffer_size; a++) {",
          "4369:         if ((func != callback_buffer[a].func) &&",
          "4370:             (callback_buffer[a].ndpi_selection_bitmask & ndpi_selection_packet) ==",
          "4372:             NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4373:                                  callback_buffer[a].excluded_protocol_bitmask) == 0 &&",
          "4374:             NDPI_BITMASK_COMPARE(callback_buffer[a].detection_bitmask,",
          "4375:                                  detection_bitmask) != 0)",
          "4385:       }",
          "4386:     }",
          "4390:     {",
          "4391:       u_int16_t subproto_id = ndpi_str->proto_defaults[flow->detected_protocol_stack[0]].subprotocols[a];",
          "4392:       if (subproto_id == (uint16_t)NDPI_PROTOCOL_MATCHED_BY_CONTENT)",
          "4397:       u_int16_t subproto_index = ndpi_str->proto_defaults[subproto_id].protoIdx;",
          "4398:       if ((func != ndpi_str->proto_defaults[subproto_id].func) &&",
          "4399:           (ndpi_str->callback_buffer[subproto_index].ndpi_selection_bitmask & ndpi_selection_packet) ==",
          "4401:           NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4402:                                ndpi_str->callback_buffer[subproto_index].excluded_protocol_bitmask) == 0 &&",
          "4403:           NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[subproto_index].detection_bitmask,",
          "4404:                                detection_bitmask) != 0)",
          "4410:       if (flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN)",
          "4414:     }",
          "4457:   }",
          "4500:     }",
          "4503:   }",
          "4534:     }",
          "4595:     } else if(enable_guess) {",
          "4609:       }",
          "4610:     }",
          "4621:     }",
          "4636:     }",
          "4641:     }",
          "4644:   }",
          "4718:   }",
          "4764:   }",
          "4782:   }",
          "4831:  node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4832:       }",
          "4847:     }",
          "4876:       }",
          "4888:       }",
          "4889:     }",
          "4892:   }",
          "4943:     }",
          "4946:   }",
          "4954: #if 0",
          "4961: #endif",
          "4967:       Skype for a host doing MS Teams means MS Teams",
          "4968:       (MS Teams uses Skype as transport protocol for voice/video)",
          "4978:    ndpi_lru_add_to_cache(ndpi_str->msteams_cache,",
          "4979:     flow->packet.iph->saddr,",
          "4980:     (flow->packet.current_time_ms / 1000) & 0xFFFF /* 16 bit */);",
          "5004:  }",
          "5005:       }",
          "5011:       break;",
          "5025:     }",
          "5027:   }",
          "5084:  }",
          "5098: #if SKIP_INVOKING_THE_DISSECTORS",
          "5108:  }",
          "5109:       }",
          "5110:     }",
          "5128:   }",
          "5239:       }",
          "5240:     }",
          "5324:  }",
          "5330:       }",
          "5333:     }",
          "5367:   }",
          "5371: #ifdef CODE_UNUSED",
          "5399:       }",
          "5400:     }",
          "5403:   }",
          "5405: #endif",
          "5421:   }",
          "5452:       }",
          "5453:     }",
          "5455:   }",
          "5536:  }",
          "5563:  }",
          "5580:  }",
          "5593:  }",
          "5606:  }",
          "5638:  }",
          "5757:     }",
          "5765:   }",
          "5806:     }",
          "5807:   }",
          "5822:       counter++;",
          "5830:  counter++;",
          "5833:    counter++;",
          "5840:      counter++;",
          "5849:   if(packet->payload_packet_len > counter &&",
          "5850:      (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5852:     return(counter);",
          "5853:   } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5854:      packet->payload[counter] <= 'z') {",
          "5856:     counter++;",
          "5857:     if(packet->payload_packet_len > counter &&",
          "5858:        (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5860:       return(counter);",
          "5871:     } else {",
          "5872:       return(0);",
          "5873:     }",
          "",
          "[Removed Lines]",
          "4202:   void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,",
          "4203:     struct ndpi_flow_struct *flow) {",
          "4204:     if(!flow) {",
          "4205:       return;",
          "4206:     } else {",
          "4208:       struct ndpi_packet_struct *packet = &flow->packet;",
          "4209:       const struct ndpi_iphdr *iph = packet->iph;",
          "4210:       const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "4211:       const struct ndpi_tcphdr *tcph = packet->tcp;",
          "4212:       const struct ndpi_udphdr *udph = packet->udp;",
          "4214:       packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "4216:       if(ndpi_str->direction_detect_disable) {",
          "4217:  packet->packet_direction = flow->packet_direction;",
          "4218:       } else {",
          "4219:  if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "4220:    packet->packet_direction = 1;",
          "4222:  if((iphv6 != NULL)",
          "4223:     && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)",
          "4224:    packet->packet_direction = 1;",
          "4225:       }",
          "4227:       packet->packet_lines_parsed_complete = 0;",
          "4229:       if(flow->init_finished == 0) {",
          "4230:  flow->init_finished = 1;",
          "4231:  flow->setup_packet_direction = packet->packet_direction;",
          "4232:       }",
          "4234:       if(tcph != NULL) {",
          "4236:  packet->num_retried_bytes = 0;",
          "4238:  if(!ndpi_str->direction_detect_disable)",
          "4239:    packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "4241:  if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "4243:    flow->l4.tcp.seen_syn = 1;",
          "4245:    if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "4247:      flow->l4.tcp.seen_syn_ack = 1;",
          "4248:    } else",
          "4249:      if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&",
          "4250:         flow->l4.tcp.seen_ack == 0) {",
          "4251:        flow->l4.tcp.seen_ack = 1;",
          "4252:      }",
          "4254:  if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||",
          "4255:     (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "4264:    if(tcph->ack != 0) {",
          "4265:      flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "4266:        ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "4269:        Check to avoid discrepancies in case we analyze a flow that does not start with SYN...",
          "4270:        but that is already started when nDPI being to process it. See also (***) below",
          "4272:      if(flow->num_processed_pkts > 1)",
          "4273:        flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "4274:    }",
          "4275:  } else if(packet->payload_packet_len > 0) {",
          "4277:    if(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "4278:       ndpi_str->tcp_max_retransmission_window_size) {",
          "4279:      packet->tcp_retransmission = 1;",
          "4282:      if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <",
          "4283:   packet->payload_packet_len)) {",
          "4285:    analyzer which require this info can make use of this info",
          "4287:        packet->num_retried_bytes =",
          "4288:   (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "4289:        packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "4292:   flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "4293:      }",
          "4297:       actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.",
          "4299:    else {",
          "4300:      packet->num_retried_bytes = 0;",
          "4301:      flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "4305:  if(tcph->rst) {",
          "4306:    flow->next_tcp_seq_nr[0] = 0;",
          "4307:    flow->next_tcp_seq_nr[1] = 0;",
          "4309:       } else if(udph != NULL) {",
          "4310:  if(!ndpi_str->direction_detect_disable)",
          "4311:    packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "4314:       if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "4315:  flow->packet_counter++;",
          "4318:       if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&",
          "4319:   packet->payload_packet_len) {",
          "4320:  flow->packet_direction_counter[packet->packet_direction]++;",
          "4321:       }",
          "4323:       if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "4324:   flow->byte_counter[packet->packet_direction]) {",
          "4325:  flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "4326:       }",
          "4332:   static u_int32_t check_ndpi_detection_func(struct ndpi_detection_module_struct * const ndpi_str,",
          "4333:                                              struct ndpi_flow_struct * const flow,",
          "4334:                                              NDPI_SELECTION_BITMASK_PROTOCOL_SIZE const ndpi_selection_packet,",
          "4335:                                              struct ndpi_call_function_struct const * const callback_buffer,",
          "4336:                                              uint32_t callback_buffer_size)",
          "4337:   {",
          "4338:     void *func = NULL;",
          "4339:     u_int8_t is_tcp_without_payload = (callback_buffer == ndpi_str->callback_buffer_tcp_no_payload);",
          "4340:     u_int32_t num_calls = (is_tcp_without_payload != 0 ? 1 : 0);",
          "4341:     u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4342:     u_int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4343:     NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4345:     NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4347:     if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4348:         NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4349:                              ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4350:         NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4351:         (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & ndpi_selection_packet) ==",
          "4352:          ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask)",
          "4358:             NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0)))",
          "4359:       {",
          "4360:         ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow);",
          "4361:         func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4362:         num_calls++;",
          "4363:       }",
          "4366:     if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN)",
          "4371:              callback_buffer[a].ndpi_selection_bitmask &&",
          "4376:         {",
          "4377:           callback_buffer[a].func(ndpi_str, flow);",
          "4378:           num_calls++;",
          "4380:           if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4381:           {",
          "4383:           }",
          "4384:         }",
          "4389:     for (u_int32_t a = 0; a < ndpi_str->proto_defaults[flow->detected_protocol_stack[0]].subprotocol_count; a++)",
          "4393:       {",
          "4394:         continue;",
          "4395:       }",
          "4400:            ndpi_str->callback_buffer[subproto_index].ndpi_selection_bitmask &&",
          "4405:       {",
          "4406:         ndpi_str->callback_buffer[subproto_index].func(ndpi_str, flow);",
          "4407:         num_calls++;",
          "4408:       }",
          "4411:       {",
          "4413:       }",
          "4416:     return num_calls;",
          "4417:   }",
          "4421:   u_int32_t check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4422:            struct ndpi_flow_struct *flow,",
          "4423:            NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4424:   {",
          "4425:     return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4426:                                      ndpi_str->callback_buffer_non_tcp_udp,",
          "4427:                                      ndpi_str->callback_buffer_size_non_tcp_udp);",
          "4428:   }",
          "4432:   static u_int32_t check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4433:                                             struct ndpi_flow_struct *flow,",
          "4434:                                             NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4435:   {",
          "4436:     return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4437:                                      ndpi_str->callback_buffer_udp,",
          "4438:                                      ndpi_str->callback_buffer_size_udp);",
          "4439:   }",
          "4443:   static u_int32_t check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4444:          struct ndpi_flow_struct *flow,",
          "4445:          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4446:   {",
          "4447:     if (flow->packet.payload_packet_len != 0) {",
          "4448:       return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4449:                                        ndpi_str->callback_buffer_tcp_payload,",
          "4450:                                        ndpi_str->callback_buffer_size_tcp_payload);",
          "4451:     } else {",
          "4453:       return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4454:                                        ndpi_str->callback_buffer_tcp_no_payload,",
          "4455:                                        ndpi_str->callback_buffer_size_tcp_no_payload);",
          "4456:     }",
          "4461:   u_int32_t ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4462:      struct ndpi_flow_struct *flow,",
          "4463:      NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4464:     if(!flow)",
          "4465:       return(0);",
          "4466:     else if(flow->packet.tcp != NULL)",
          "4467:       return(check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4468:     else if(flow->packet.udp != NULL)",
          "4469:       return(check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4470:     else",
          "4471:       return(check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4472:   }",
          "4476:   u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "4477:      struct ndpi_flow_struct *flow) {",
          "4478:     u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4480:     if(flow->packet.iph) {",
          "4481:       struct in_addr addr;",
          "4482:       u_int16_t sport, dport;",
          "4484:       addr.s_addr = flow->packet.iph->saddr;",
          "4486:       if((flow->l4_proto == IPPROTO_TCP) && flow->packet.tcp)",
          "4487:  sport = flow->packet.tcp->source, dport = flow->packet.tcp->dest;",
          "4488:       else if((flow->l4_proto == IPPROTO_UDP) && flow->packet.udp)",
          "4489:  sport = flow->packet.udp->source, dport = flow->packet.udp->dest;",
          "4490:       else",
          "4491:  sport = dport = 0;",
          "4494:       ret = ndpi_network_port_ptree_match(ndpi_str, &addr, sport);",
          "4496:       if(ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4497:  addr.s_addr = flow->packet.iph->daddr;",
          "4498:  ret = ndpi_network_port_ptree_match(ndpi_str, &addr, dport);",
          "4499:       }",
          "4502:     return(ret);",
          "4507:   ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4508:           u_int8_t enable_guess, u_int8_t *protocol_was_guessed) {",
          "4509:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4513:     if(flow == NULL)",
          "4514:       return(ret);",
          "4517:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4518:     ret.category = flow->category;",
          "4521:     if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4522:       return(ret);",
          "4524:     if(ndpi_str->mining_cache && flow->packet.iph) {",
          "4525:       u_int16_t cached_proto;",
          "4526:       u_int32_t key = flow->packet.iph->saddr + flow->packet.iph->daddr;",
          "4528:       if(ndpi_lru_find_cache(ndpi_str->mining_cache, key,",
          "4529:         &cached_proto, 0 /* Don't remove it as it can be used for other connections */)) {",
          "4530:  ndpi_set_detected_protocol(ndpi_str, flow, cached_proto, NDPI_PROTOCOL_UNKNOWN);",
          "4531:  ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4532:  return(ret);",
          "4533:       }",
          "4537:     if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4538:       u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4540:       if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4541:  goto check_stun_export;",
          "4542:       else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||",
          "4543:        (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||",
          "4544:        (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {",
          "4546:  ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4547:       }",
          "4548:       else if((flow->l4.tcp.tls.hello_processed == 1) &&",
          "4549:        (flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0')) {",
          "4551:  ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4552:       } else if(enable_guess) {",
          "4553:  if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&",
          "4554:     flow->l4.tcp.tls.hello_processed)",
          "4555:    flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4557:  guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4559:  if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4560:     ((flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4561:      NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&",
          "4562:      is_udp_guessable_protocol(guessed_host_protocol_id)))",
          "4563:    flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4566:  if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4568:     && (flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4569:     NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&",
          "4570:     is_udp_guessable_protocol(guessed_protocol_id))",
          "4571:    flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4573:  if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4574:    if((guessed_protocol_id == 0) && (flow->protos.tls_quic_stun.stun.num_binding_requests > 0) &&",
          "4575:       (flow->protos.tls_quic_stun.stun.num_processed_pkts > 0))",
          "4576:      guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4578:    if(flow->host_server_name[0] != '\\0') {",
          "4579:      ndpi_protocol_match_result ret_match;",
          "4581:      memset(&ret_match, 0, sizeof(ret_match));",
          "4583:      ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,",
          "4584:      strlen((const char *) flow->host_server_name), &ret_match,",
          "4585:      NDPI_PROTOCOL_DNS);",
          "4587:      if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4588:        guessed_host_protocol_id = ret_match.protocol_id;",
          "4589:    }",
          "4592:    ndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);",
          "4593:  }",
          "4594:       }",
          "4596:       if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4598:  flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4599:       }",
          "4601:       if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4603:  flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4604:       }",
          "4606:       if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {",
          "4608:  flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4612:     if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&",
          "4613:        (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4614:     check_stun_export:",
          "4616:  {",
          "4619:  ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);",
          "4620:       }",
          "4623:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4625:     if(ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4626:       if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4627:  ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4628:       else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4630:    As Google has recently introduced Duo,",
          "4631:    we need to distinguish between it and hangout",
          "4632:    thing that should be handled by the STUN dissector",
          "4634:  ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4635:       }",
          "4638:     if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {",
          "4640:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4643:     return(ret);",
          "4648:   void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4649:      const unsigned char *packet, const unsigned short packetlen,",
          "4650:      const u_int64_t current_time_ms, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4651:     if(flow == NULL)",
          "4652:       return;",
          "4654:     if(flow->server_id == NULL)",
          "4658:     if(packetlen < 20) {",
          "4659:       return;",
          "4660:     }",
          "4662:     flow->packet.current_time_ms = current_time_ms;",
          "4665:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4669:     if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4670:       return;",
          "4673:     flow->src = src, flow->dst = dst;",
          "4675:       ndpi_connection_tracking(ndpi_str, flow);",
          "4678:       if(flow->extra_packets_func) {",
          "4679:  if((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4680:    flow->check_extra_packets = 0;",
          "4682:  if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4684:       }",
          "4685:   }",
          "4689:   int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,",
          "4690:        ndpi_protocol_category_t category) {",
          "4691:     ndpi_patricia_node_t *node;",
          "4692:     struct in_addr pin;",
          "4693:     int bits = 32;",
          "4694:     char *ptr;",
          "4695:     char ipbuf[64];",
          "4697:     strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4698:     ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4700:     ptr = strrchr(ipbuf, '/');",
          "4702:     if(ptr) {",
          "4704:       if(atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "4705:  bits = atoi(ptr);",
          "4706:     }",
          "4708:     if(inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4709:       NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4710:       return(-1);",
          "4711:     }",
          "4713:     if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL) {",
          "4714:       node->value.u.uv32.user_value = (u_int16_t)category, node->value.u.uv32.additional_user_value = 0;",
          "4715:     }",
          "4717:     return(0);",
          "4723:   int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,",
          "4724:       ndpi_protocol_category_t category) {",
          "4725:     char *name;",
          "4726:     u_int len;",
          "4727:     AC_PATTERN_t ac_pattern;",
          "4728:     AC_ERROR_t rc;",
          "4730:     if(name_to_add == NULL)",
          "4731:       return(-1);",
          "4732:     else",
          "4733:       len = strlen(name_to_add);",
          "4735:     if((name = (char*)ndpi_malloc(len+3)) == NULL)",
          "4736:       return(-1);",
          "4738:     memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "4739:     ac_pattern.length = snprintf(name, len+2, \"%s%s\", name_to_add,",
          "4740:      ndpi_is_middle_string_char(name_to_add[len-1]) ? \"\" : \"$\");",
          "4742: #if 0",
          "4743:     printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);",
          "4744: #endif",
          "4746:     if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4747:       ndpi_free(name);",
          "4748:       return(-1);",
          "4749:     }",
          "4751:     ac_pattern.astring = name;",
          "4752:     ac_pattern.rep.number = (u_int32_t) category,  ac_pattern.rep.category = category;",
          "4754:     rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);",
          "4755:     if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {",
          "4756:       ndpi_free(name);",
          "4757:       return(-1);",
          "4758:     }",
          "4760:     if(rc == ACERR_DUPLICATE_PATTERN)",
          "4761:       ndpi_free(name);",
          "4763:     return(0);",
          "4769:   int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,",
          "4770:     ndpi_protocol_category_t category) {",
          "4771:     int rv;",
          "4774:     rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4776:     if(rv < 0) {",
          "4778:       rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4779:     }",
          "4781:     return(rv);",
          "4786:   int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {",
          "4787:     int i;",
          "4790:     for(i = 0; category_match[i].string_to_match != NULL; i++)",
          "4791:       ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4794:     ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "4795:    1 /* free patterns strings memory */);",
          "4798:     ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4801:     ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4804:     ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4806:     if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "4807:       ndpi_patricia_destroy((ndpi_patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "4809:     ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4810:     ndpi_str->custom_categories.ipAddresses_shadow = ndpi_patricia_new(32 /* IPv4 */);",
          "4812:     ndpi_str->custom_categories.categories_loaded = 1;",
          "4814:     return(0);",
          "4815:   }",
          "4819:   int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,",
          "4820:          ndpi_protocol *ret) {",
          "4821:     if(ndpi_str->custom_categories.categories_loaded) {",
          "4822:       ndpi_prefix_t prefix;",
          "4823:       ndpi_patricia_node_t *node;",
          "4825:       if(saddr == 0)",
          "4826:  node = NULL;",
          "4827:       else {",
          "4829:  ndpi_fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,",
          "4830:          ((ndpi_patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4834:       if(!node) {",
          "4835:  if(daddr != 0) {",
          "4836:    ndpi_fill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,",
          "4837:     ((ndpi_patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4838:    node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4839:  }",
          "4840:       }",
          "4842:       if(node) {",
          "4843:  ret->category = (ndpi_protocol_category_t) node->value.u.uv32.user_value;",
          "4845:  return(1);",
          "4846:       }",
          "4849:     ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4851:     return(0);",
          "4852:   }",
          "4856:   void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4857:        ndpi_protocol *ret) {",
          "4858:     if((ret->master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret->app_protocol == NDPI_PROTOCOL_UNKNOWN))",
          "4859:       return;",
          "4861:     if(ndpi_str->custom_categories.categories_loaded) {",
          "4862:       if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4863:  flow->category = ret->category = flow->guessed_header_category;",
          "4864:  return;",
          "4865:       }",
          "4867:       if(flow->host_server_name[0] != '\\0') {",
          "4868:  u_int32_t id;",
          "4869:  int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,",
          "4870:          strlen((char *) flow->host_server_name), &id);",
          "4872:  if(rc == 0) {",
          "4873:    flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4874:    return;",
          "4875:  }",
          "4878:       if(flow->l4.tcp.tls.hello_processed == 1 &&",
          "4879:   flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {",
          "4880:  u_int32_t id;",
          "4881:  int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,",
          "4882:          strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name), &id);",
          "4884:  if(rc == 0) {",
          "4885:    flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4886:    return;",
          "4887:  }",
          "4891:     flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4896:   static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {",
          "4897:     packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,",
          "4898:       packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,",
          "4899:       packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,",
          "4900:       packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,",
          "4901:       packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,",
          "4902:       packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,",
          "4903:       packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,",
          "4904:       packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,",
          "4905:       packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,",
          "4906:       packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,",
          "4907:       packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,",
          "4908:       packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0,",
          "4909:       packet->forwarded_line.ptr = NULL, packet->forwarded_line.len = 0;",
          "4910:   }",
          "4914:   static int ndpi_is_ntop_protocol(ndpi_protocol *ret) {",
          "4915:     if((ret->master_protocol == NDPI_PROTOCOL_HTTP) && (ret->app_protocol == NDPI_PROTOCOL_NTOP))",
          "4916:       return(1);",
          "4917:     else",
          "4918:       return(0);",
          "4919:   }",
          "4923:   static int ndpi_check_protocol_port_mismatch_exceptions(struct ndpi_detection_module_struct *ndpi_str,",
          "4924:          struct ndpi_flow_struct *flow,",
          "4925:          ndpi_default_ports_tree_node_t *expected_proto,",
          "4926:          ndpi_protocol *returned_proto) {",
          "4928:       For TLS (and other protocols) it is not simple to guess the exact protocol so before",
          "4929:       triggering an alert we need to make sure what we have exhausted all the possible",
          "4930:       options available",
          "4933:     if(ndpi_is_ntop_protocol(returned_proto)) return(1);",
          "4935:     if(returned_proto->master_protocol == NDPI_PROTOCOL_TLS) {",
          "4936:       switch(expected_proto->proto->protoId) {",
          "4937:       case NDPI_PROTOCOL_MAIL_IMAPS:",
          "4938:       case NDPI_PROTOCOL_MAIL_POPS:",
          "4939:       case NDPI_PROTOCOL_MAIL_SMTPS:",
          "4941:  break;",
          "4942:       }",
          "4945:     return(0);",
          "4950:   static void ndpi_reconcile_protocols(struct ndpi_detection_module_struct *ndpi_str,",
          "4951:            struct ndpi_flow_struct *flow,",
          "4952:            ndpi_protocol *ret) {",
          "4955:     if(flow) {",
          "4957:       if((flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN)",
          "4958:   && (flow->detected_protocol_stack[0] /* app */ != flow->detected_protocol_stack[1] /* major */))",
          "4959:  NDPI_CLR_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "4960:     }",
          "4965:     switch(ret->app_protocol) {",
          "4970:     case NDPI_PROTOCOL_MSTEAMS:",
          "4971:       if(flow->packet.iph && flow->packet.tcp) {",
          "4974:  if(ndpi_str->msteams_cache == NULL)",
          "4975:    ndpi_str->msteams_cache = ndpi_lru_cache_init(1024);",
          "4977:  if(ndpi_str->msteams_cache)",
          "4981:       }",
          "4982:       break;",
          "4984:     case NDPI_PROTOCOL_SKYPE:",
          "4985:     case NDPI_PROTOCOL_SKYPE_CALL:",
          "4986:       if(flow->packet.iph",
          "4987:   && flow->packet.udp",
          "4988:   && ndpi_str->msteams_cache) {",
          "4989:  u_int16_t when;",
          "4991:  if(ndpi_lru_find_cache(ndpi_str->msteams_cache, flow->packet.iph->saddr,",
          "4992:           &when, 0 /* Don't remove it as it can be used for other connections */)) {",
          "4993:    u_int16_t tdiff = ((flow->packet.current_time_ms /1000) & 0xFFFF) - when;",
          "4995:    if(tdiff < 60 /* sec */) {",
          "4997:      ret->app_protocol = NDPI_PROTOCOL_MSTEAMS;",
          "5000:      ndpi_lru_add_to_cache(ndpi_str->msteams_cache,",
          "5001:       flow->packet.iph->saddr,",
          "5002:       (flow->packet.current_time_ms / 1000) & 0xFFFF /* 16 bit */);",
          "5003:    }",
          "5006:       break;",
          "5008:     case NDPI_PROTOCOL_ANYDESK:",
          "5014:     if(flow) {",
          "5015:       switch(ndpi_get_proto_breed(ndpi_str, ret->app_protocol)) {",
          "5016:       case NDPI_PROTOCOL_UNSAFE:",
          "5017:       case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "5018:       case NDPI_PROTOCOL_DANGEROUS:",
          "5019:  ndpi_set_risk(flow, NDPI_UNSAFE_PROTOCOL);",
          "5020:  break;",
          "5021:       default:",
          "5023:  break;",
          "5024:       }",
          "5031:   static int ndpi_do_guess(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow, ndpi_protocol *ret) {",
          "5032:     ret->master_protocol = ret->app_protocol = NDPI_PROTOCOL_UNKNOWN, ret->category = 0;",
          "5034:     if(flow->packet.iphv6 || flow->packet.iph) {",
          "5035:       u_int16_t sport, dport;",
          "5036:       u_int8_t protocol;",
          "5037:       u_int8_t user_defined_proto;",
          "5039:       if(flow->packet.iphv6 != NULL) {",
          "5040:  protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "5041:       } else",
          "5042:  protocol = flow->packet.iph->protocol;",
          "5044:       if(flow->packet.udp)",
          "5045:  sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "5046:       else if(flow->packet.tcp)",
          "5047:  sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "5048:       else",
          "5049:  sport = dport = 0;",
          "5052:       flow->guessed_protocol_id      = (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "5053:       flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "5055:       if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "5056:  if(ndpi_str->ndpi_num_custom_protocols != 0)",
          "5057:    ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, ret);",
          "5058:  flow->guessed_header_category = ret->category;",
          "5059:       } else",
          "5060:  flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "5062:       if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "5064:  ret->master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "5065:    ret->app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "5068:    ndpi_fill_protocol_category(ndpi_str, flow, ret);",
          "5069:  return(-1);",
          "5070:       }",
          "5072:       if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "5073:  if(flow->packet.iph) {",
          "5074:    if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "5075:      u_int8_t protocol_was_guessed;",
          "5079:    }",
          "5082:      ndpi_fill_protocol_category(ndpi_str, flow, ret);",
          "5083:    return(-1);",
          "5085:       } else {",
          "5087:  if(flow->packet.iph) {",
          "5088:    flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "5091:      We could implement a shortcut here skipping dissectors for",
          "5092:      protocols we have identified by other means such as with the IP",
          "5094:      However we do NOT stop here and skip invoking the dissectors",
          "5095:      because we want to dissect the flow (e.g. dissect the TLS)",
          "5096:      and extract metadata.",
          "5099:    if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "5101:        We have identified a protocol using the IP address so",
          "5102:        it is not worth to dissect the traffic as we already have",
          "5103:        the solution",
          "5105:      ret->master_protocol = flow->guessed_protocol_id, ret->app_protocol = flow->guessed_host_protocol_id;",
          "5106:    }",
          "5107: #endif",
          "5112:     if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "5114:       NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "5117:       ret->master_protocol = flow->guessed_protocol_id, ret->app_protocol = flow->guessed_host_protocol_id;",
          "5120:       ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "5123:  ndpi_fill_protocol_category(ndpi_str, flow, ret);",
          "5124:       return(-1);",
          "5125:     }",
          "5127:     return(0);",
          "5132:   ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,",
          "5133:            struct ndpi_flow_struct *flow, const unsigned char *packet,",
          "5134:            const unsigned short packetlen, const u_int64_t current_time_ms,",
          "5135:            struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "5136:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "5137:     u_int32_t a, num_calls = 0;",
          "5138:     ndpi_protocol ret = { flow->detected_protocol_stack[1], flow->detected_protocol_stack[0], flow->category };",
          "5140:     if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "5141:       NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,",
          "5142:         \"START packet processing\\n\");",
          "5144:     if(flow == NULL)",
          "5145:       return(ret);",
          "5146:     else",
          "5147:       ret.category = flow->category;",
          "5149:     if(flow->fail_with_unknown) {",
          "5151:       return(ret);",
          "5152:     }",
          "5154:     flow->num_processed_pkts++;",
          "5157:     ret.master_protocol = flow->detected_protocol_stack[1],",
          "5158:       ret.app_protocol = flow->detected_protocol_stack[0];",
          "5160:     if(flow->server_id == NULL)",
          "5163:     if(flow->check_extra_packets) {",
          "5164:       ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_time_ms, src, dst);",
          "5166:       ret.master_protocol = flow->detected_protocol_stack[1],",
          "5167:  ret.app_protocol = flow->detected_protocol_stack[0],",
          "5168:  ret.category = flow->category;",
          "5169:       goto invalidate_ptr;",
          "5170:     } else if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "5171:       goto ret_protocols;",
          "5174:     if(packetlen < 20) {",
          "5176:       ndpi_int_reset_packet_protocol(&flow->packet);",
          "5177:       goto invalidate_ptr;",
          "5178:     }",
          "5180:     flow->packet.current_time_ms = current_time_ms;",
          "5183:     flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "5186:     if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "5187:       goto invalidate_ptr;",
          "5190:     flow->src = src, flow->dst = dst;",
          "5192:     ndpi_connection_tracking(ndpi_str, flow);",
          "5195:     ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "5196:     if(flow->packet.iph != NULL)",
          "5197:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "5199:     if(flow->packet.tcp != NULL)",
          "5200:       ndpi_selection_packet |=",
          "5201:  (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "5203:     if(flow->packet.udp != NULL)",
          "5204:       ndpi_selection_packet |=",
          "5205:  (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "5207:     if(flow->packet.payload_packet_len != 0)",
          "5208:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "5210:     if(flow->packet.tcp_retransmission == 0)",
          "5211:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "5213:     if(flow->packet.iphv6 != NULL)",
          "5214:       ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "5216:     if(!flow->protocol_id_already_guessed) {",
          "5217:       flow->protocol_id_already_guessed = 1;",
          "5219:       if(ndpi_do_guess(ndpi_str, flow, &ret) == -1)",
          "5220:  goto invalidate_ptr;",
          "5221:     }",
          "5223:     num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "5225:     a = flow->packet.detected_protocol_stack[0];",
          "5226:     if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "5227:       a = NDPI_PROTOCOL_UNKNOWN;",
          "5229:     if(a != NDPI_PROTOCOL_UNKNOWN) {",
          "5230:       int i;",
          "5232:       for(i = 0; i < sizeof(flow->host_server_name); i++) {",
          "5233:  if(flow->host_server_name[i] != '\\0')",
          "5234:    flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "5235:  else {",
          "5236:    flow->host_server_name[i] = '\\0';",
          "5237:    break;",
          "5238:  }",
          "5242:   ret_protocols:",
          "5243:     if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "5244:       ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "5246:       if(ret.app_protocol == ret.master_protocol)",
          "5247:  ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5248:     } else",
          "5249:       ret.app_protocol = flow->detected_protocol_stack[0];",
          "5252:     if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5253:       ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "5254:     else",
          "5255:       ret.category = flow->category;",
          "5257:     if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&",
          "5258:        (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&",
          "5259:        (flow->guessed_protocol_id == 0)) {",
          "5260:       u_int8_t protocol_was_guessed;",
          "5263:  This is a TCP flow",
          "5264:  - whose first packet is NOT a SYN",
          "5265:  - no protocol has been detected",
          "5267:  We don't see how future packets can match anything",
          "5268:  hence we giveup here",
          "5270:       ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "5271:     }",
          "5273:     if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&",
          "5274:        (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "5275:       ret.master_protocol = ret.app_protocol;",
          "5276:       ret.app_protocol = flow->guessed_host_protocol_id;",
          "5277:     }",
          "5279:     if((!flow->risk_checked) && (ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)) {",
          "5280:       ndpi_default_ports_tree_node_t *found;",
          "5281:       u_int16_t *default_ports, sport, dport;",
          "5283:       if(flow->packet.udp)",
          "5284:  found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,",
          "5285:           sport = ntohs(flow->packet.udp->source),",
          "5286:           dport = ntohs(flow->packet.udp->dest)),",
          "5287:    default_ports = ndpi_str->proto_defaults[ret.master_protocol].udp_default_ports;",
          "5288:       else if(flow->packet.tcp)",
          "5289:  found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,",
          "5290:           sport = ntohs(flow->packet.tcp->source),",
          "5291:           dport = ntohs(flow->packet.tcp->dest)),",
          "5292:    default_ports = ndpi_str->proto_defaults[ret.master_protocol].tcp_default_ports;",
          "5293:       else",
          "5294:  found = NULL, default_ports = NULL, sport = dport = 0;",
          "5296:       if(found",
          "5297:   && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)",
          "5298:   && (found->proto->protoId != ret.master_protocol)",
          "5299:   && (found->proto->protoId != ret.app_protocol)",
          "5300:   ) {",
          "5303:  if(!ndpi_check_protocol_port_mismatch_exceptions(ndpi_str, flow, found, &ret))",
          "5304:    ndpi_set_risk(flow, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "5305:       } else if((!ndpi_is_ntop_protocol(&ret)) && default_ports && (default_ports[0] != 0)) {",
          "5306:  u_int8_t found = 0, i, num_loops = 0;",
          "5308:       check_default_ports:",
          "5309:  for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {",
          "5310:    if((default_ports[i] == sport) || (default_ports[i] == dport)) {",
          "5311:      found = 1;",
          "5312:      break;",
          "5313:    }",
          "5316:  if((num_loops == 0) && (!found)) {",
          "5317:    if(flow->packet.udp)",
          "5318:      default_ports = ndpi_str->proto_defaults[ret.app_protocol].udp_default_ports;",
          "5319:    else",
          "5320:      default_ports = ndpi_str->proto_defaults[ret.app_protocol].tcp_default_ports;",
          "5322:    num_loops = 1;",
          "5323:    goto check_default_ports;",
          "5326:  if(!found) {",
          "5328:    ndpi_set_risk(flow, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "5329:  }",
          "5332:       flow->risk_checked = 1;",
          "5335:     ndpi_reconcile_protocols(ndpi_str, flow, &ret);",
          "5337:     if(num_calls == 0)",
          "5338:       flow->fail_with_unknown = 1;",
          "5340:   invalidate_ptr:",
          "5342:       Invalidate packet memory to avoid accessing the pointers below",
          "5343:       when the packet is no longer accessible",
          "5345:     flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "5346:     ndpi_reset_packet_line_info(&flow->packet);",
          "5348:     return(ret);",
          "5349:   }",
          "5353:   u_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5354:     u_int32_t val;",
          "5355:     val = 0;",
          "5358:     while(*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "5359:       val *= 10;",
          "5360:       val += *str - '0';",
          "5361:       str++;",
          "5362:       max_chars_to_read = max_chars_to_read - 1;",
          "5364:     }",
          "5366:     return(val);",
          "5372:   u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5373:     u_int32_t val;",
          "5374:     val = 0;",
          "5375:     if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5376:       return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "5377:     } else {",
          "5379:       str += 2;",
          "5380:       max_chars_to_read -= 2;",
          "5383:       while(max_chars_to_read > 0) {",
          "5384:  if(*str >= '0' && *str <= '9') {",
          "5385:    val *= 16;",
          "5386:    val += *str - '0';",
          "5387:  } else if(*str >= 'a' && *str <= 'f') {",
          "5388:    val *= 16;",
          "5389:    val += *str + 10 - 'a';",
          "5390:  } else if(*str >= 'A' && *str <= 'F') {",
          "5391:    val *= 16;",
          "5392:    val += *str + 10 - 'A';",
          "5393:  } else {",
          "5394:    break;",
          "5395:  }",
          "5396:  str++;",
          "5397:  max_chars_to_read = max_chars_to_read - 1;",
          "5402:     return(val);",
          "5409:   u_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5410:     u_int64_t val;",
          "5411:     val = 0;",
          "5413:     while(max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "5414:       val *= 10;",
          "5415:       val += *str - '0';",
          "5416:       str++;",
          "5417:       max_chars_to_read = max_chars_to_read - 1;",
          "5419:     }",
          "5420:     return(val);",
          "5425:   u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,",
          "5426:          u_int16_t *bytes_read) {",
          "5427:     u_int64_t val;",
          "5428:     val = 0;",
          "5429:     if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5430:       return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "5431:     } else {",
          "5433:       str += 2;",
          "5434:       max_chars_to_read -= 2;",
          "5436:       while(max_chars_to_read > 0) {",
          "5437:  if(*str >= '0' && *str <= '9') {",
          "5438:    val *= 16;",
          "5439:    val += *str - '0';",
          "5440:  } else if(*str >= 'a' && *str <= 'f') {",
          "5441:    val *= 16;",
          "5442:    val += *str + 10 - 'a';",
          "5443:  } else if(*str >= 'A' && *str <= 'F') {",
          "5444:    val *= 16;",
          "5445:    val += *str + 10 - 'A';",
          "5446:  } else {",
          "5447:    break;",
          "5448:  }",
          "5449:  str++;",
          "5450:  max_chars_to_read = max_chars_to_read - 1;",
          "5454:     return(val);",
          "5459:   u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5460:     u_int32_t val;",
          "5461:     u_int16_t read = 0;",
          "5462:     u_int16_t oldread;",
          "5463:     u_int32_t c;",
          "5466:     oldread = read;",
          "5467:     c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "5468:     if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5469:       return(0);",
          "5471:     read++;",
          "5472:     val = c << 24;",
          "5473:     oldread = read;",
          "5474:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5475:     if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5476:       return(0);",
          "5478:     read++;",
          "5479:     val = val + (c << 16);",
          "5480:     oldread = read;",
          "5481:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5482:     if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5483:       return(0);",
          "5485:     read++;",
          "5486:     val = val + (c << 8);",
          "5487:     oldread = read;",
          "5488:     c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5489:     if(c > 255 || oldread == read || max_chars_to_read == read)",
          "5490:       return(0);",
          "5492:     val = val + c;",
          "5496:     return(htonl(val));",
          "5497:   }",
          "5502:   void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5503:     u_int32_t a;",
          "5504:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5506:     if((packet->payload_packet_len < 3) || (packet->payload == NULL))",
          "5507:       return;",
          "5509:     if(packet->packet_lines_parsed_complete != 0)",
          "5510:       return;",
          "5512:     packet->packet_lines_parsed_complete = 1;",
          "5513:     ndpi_reset_packet_line_info(packet);",
          "5515:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5516:     packet->line[packet->parsed_lines].len = 0;",
          "5518:     for(a = 0; ((a+1) < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "5519:       if((packet->payload[a] == 0x0d) && (packet->payload[a+1] == 0x0a)) {",
          "5522:  if(((a + 3) < packet->payload_packet_len)",
          "5523:     && (packet->payload[a+2] == 0x0d)",
          "5524:     && (packet->payload[a+3] == 0x0a)) {",
          "5527:    u_int32_t a1 = a + 4;",
          "5529:    diff = packet->payload_packet_len - a1;",
          "5531:    if(diff > 0) {",
          "5532:      diff = ndpi_min(diff, sizeof(flow->initial_binary_bytes));",
          "5533:      memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);",
          "5534:      flow->initial_binary_bytes_len = diff;",
          "5535:    }",
          "5538:  packet->line[packet->parsed_lines].len =",
          "5539:    (u_int16_t)(((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5542:  if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "5543:     strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "5545:     packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "5546:    packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "5547:    packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "5548:    packet->http_num_headers++;",
          "5551:    if(packet->payload_packet_len >= 12) {",
          "5552:      char buf[4];",
          "5555:      strncpy(buf, (char *) &packet->payload[9], 3);",
          "5556:      buf[3] = '\\0';",
          "5558:      flow->http.response_status_code = atoi(buf);",
          "5560:      if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "5562:    }",
          "5566:  if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&",
          "5567:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5568:          \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "5570:    if(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "5571:      packet->server_line.ptr =",
          "5572:        &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "5573:      packet->server_line.len =",
          "5574:        packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "5575:    } else {",
          "5576:      packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "5577:      packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "5578:    }",
          "5579:    packet->http_num_headers++;",
          "5582:  if(packet->line[packet->parsed_lines].len > 6 &&",
          "5583:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {",
          "5585:    if(packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "5586:      packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "5587:      packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "5588:    } else {",
          "5589:      packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "5590:      packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "5591:    }",
          "5592:    packet->http_num_headers++;",
          "5595:  if(packet->line[packet->parsed_lines].len > 17 &&",
          "5596:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "5598:    if(packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "5599:      packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "5600:      packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "5601:    } else {",
          "5602:      packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5603:      packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "5604:    }",
          "5605:    packet->http_num_headers++;",
          "5608:  if(packet->line[packet->parsed_lines].len > 14 &&",
          "5609:     (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||",
          "5610:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5611:    packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5612:    packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5614:    while((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5615:      packet->content_line.len--, packet->content_line.ptr++;",
          "5617:    packet->http_num_headers++;",
          "5618:  }",
          "5620:  if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&",
          "5621:     (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5622:    packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5623:    packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5624:    packet->http_num_headers++;",
          "5625:  }",
          "5627:  if(packet->content_line.len > 0) {",
          "5629:    char separator[] = {';', '\\r', '\\0'};",
          "5630:    int i;",
          "5632:    for(i = 0; separator[i] != '\\0'; i++) {",
          "5633:      char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5635:      if(c != NULL)",
          "5636:        packet->content_line.len = c - (char *) packet->content_line.ptr;",
          "5637:    }",
          "5641:  if(packet->line[packet->parsed_lines].len > 8 &&",
          "5642:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5643:    packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5644:    packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5645:    packet->http_num_headers++;",
          "5646:  }",
          "5648:  if(packet->line[packet->parsed_lines].len > 9 &&",
          "5649:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5650:    packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5651:    packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5652:    packet->http_num_headers++;",
          "5653:  }",
          "5655:  if(packet->line[packet->parsed_lines].len > 12 &&",
          "5656:     (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||",
          "5657:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5658:    packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5659:    packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5660:    packet->http_num_headers++;",
          "5661:  }",
          "5663:  if(packet->line[packet->parsed_lines].len > 18 &&",
          "5664:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5665:    packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5666:    packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5667:    packet->http_num_headers++;",
          "5668:  }",
          "5670:  if(packet->line[packet->parsed_lines].len > 19 &&",
          "5671:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5672:    packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5673:    packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5674:    packet->http_num_headers++;",
          "5675:  }",
          "5677:  if(packet->line[packet->parsed_lines].len > 16 &&",
          "5678:     ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||",
          "5679:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5680:    packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5681:    packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5682:    packet->http_num_headers++;",
          "5683:  }",
          "5685:  if(packet->line[packet->parsed_lines].len > 21 &&",
          "5686:     ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Disposition: \", 21) == 0))) {",
          "5687:    packet->content_disposition_line.ptr = &packet->line[packet->parsed_lines].ptr[21];",
          "5688:    packet->content_disposition_line.len = packet->line[packet->parsed_lines].len - 21;",
          "5689:    packet->http_num_headers++;",
          "5690:  }",
          "5692:  if(packet->line[packet->parsed_lines].len > 8 &&",
          "5693:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5694:    packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5695:    packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5696:    packet->http_num_headers++;",
          "5697:  }",
          "5699:  if(packet->line[packet->parsed_lines].len > 8 &&",
          "5700:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5701:    packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5702:    packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5703:    packet->http_num_headers++;",
          "5704:  }",
          "5706:  if(packet->line[packet->parsed_lines].len > 16 &&",
          "5707:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5708:    packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5709:    packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5710:    packet->http_num_headers++;",
          "5711:  }",
          "5718:  if((packet->line[packet->parsed_lines].len > 6 &&",
          "5719:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5720:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5721:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||",
          "5722:     (packet->line[packet->parsed_lines].len > 8 &&",
          "5723:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5724:     (packet->line[packet->parsed_lines].len > 9 &&",
          "5725:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5726:     (packet->line[packet->parsed_lines].len > 12 &&",
          "5727:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5728:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5729:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5730:     (packet->line[packet->parsed_lines].len > 15 &&",
          "5731:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5732:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5733:     (packet->line[packet->parsed_lines].len > 17 &&",
          "5734:      (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5735:       strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5736:     (packet->line[packet->parsed_lines].len > 27 &&",
          "5737:      strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5738:    \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5740:    packet->http_num_headers++;",
          "5741:  }",
          "5743:  if(packet->line[packet->parsed_lines].len == 0) {",
          "5744:    packet->empty_line_position = a;",
          "5745:    packet->empty_line_position_set = 1;",
          "5746:  }",
          "5748:  if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5749:    return;",
          "5751:  packet->parsed_lines++;",
          "5752:  packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5753:  packet->line[packet->parsed_lines].len = 0;",
          "5756:       }",
          "5759:     if(packet->parsed_lines >= 1) {",
          "5760:       packet->line[packet->parsed_lines].len =",
          "5761:  (u_int16_t)(((size_t) &packet->payload[packet->payload_packet_len]) -",
          "5762:       ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5763:       packet->parsed_lines++;",
          "5764:     }",
          "5769:   void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5770:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5771:     u_int32_t a;",
          "5772:     u_int16_t end = packet->payload_packet_len;",
          "5774:     if(packet->packet_lines_parsed_complete != 0)",
          "5775:       return;",
          "5777:     packet->packet_lines_parsed_complete = 1;",
          "5778:     packet->parsed_lines = 0;",
          "5780:     if(packet->payload_packet_len == 0)",
          "5781:       return;",
          "5783:     packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5784:     packet->line[packet->parsed_lines].len = 0;",
          "5786:     for(a = 0; a < end; a++) {",
          "5787:       if(packet->payload[a] == 0x0a) {",
          "5788:  packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5789:             ((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5791:  if(a > 0 && packet->payload[a - 1] == 0x0d)",
          "5792:    packet->line[packet->parsed_lines].len--;",
          "5794:  if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5795:    break;",
          "5797:  packet->parsed_lines++;",
          "5798:  packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5799:  packet->line[packet->parsed_lines].len = 0;",
          "5801:  if((a + 1) >= packet->payload_packet_len)",
          "5802:    break;",
          "5805:       }",
          "5811:   u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5812:       u_int16_t counter) {",
          "5813:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5815:     NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5817:     if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5818:       (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5819:       (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5820:       packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5821:       NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5823:       while(packet->payload_packet_len > counter &&",
          "5824:       ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5825:        (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5826:        (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5827:        packet->payload[counter] == '-' || packet->payload[counter] == '_' ||",
          "5828:        packet->payload[counter] == '.')) {",
          "5829:  NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5831:  if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5832:    NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5834:    while(packet->payload_packet_len > counter &&",
          "5835:    ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5836:     (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5837:     (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5838:     packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5839:      NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5841:      if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5842:        NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5843:        counter++;",
          "5844:        if(packet->payload_packet_len > counter + 1 &&",
          "5845:    ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&",
          "5846:     (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5847:   NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5848:   counter += 2;",
          "5851:     NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5855:     NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5859:       NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5861:     } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5862:        packet->payload[counter] <= 'z') {",
          "5863:       counter++;",
          "5864:       if(packet->payload_packet_len > counter &&",
          "5865:          (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5866:         NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "5867:         return(counter);",
          "5868:       } else {",
          "5869:         return(0);",
          "5870:       }",
          "",
          "[Added Lines]",
          "4202: void ndpi_connection_tracking(struct ndpi_detection_module_struct *ndpi_str,",
          "4203:          struct ndpi_flow_struct *flow) {",
          "4204:   if(!flow) {",
          "4205:     return;",
          "4206:   } else {",
          "4208:     struct ndpi_packet_struct *packet = &flow->packet;",
          "4209:     const struct ndpi_iphdr *iph = packet->iph;",
          "4210:     const struct ndpi_ipv6hdr *iphv6 = packet->iphv6;",
          "4211:     const struct ndpi_tcphdr *tcph = packet->tcp;",
          "4212:     const struct ndpi_udphdr *udph = packet->udp;",
          "4214:     packet->tcp_retransmission = 0, packet->packet_direction = 0;",
          "4216:     if(ndpi_str->direction_detect_disable) {",
          "4217:       packet->packet_direction = flow->packet_direction;",
          "4218:     } else {",
          "4219:       if(iph != NULL && ntohl(iph->saddr) < ntohl(iph->daddr))",
          "4220:  packet->packet_direction = 1;",
          "4222:       if((iphv6 != NULL)",
          "4223:   && NDPI_COMPARE_IPV6_ADDRESS_STRUCTS(&iphv6->ip6_src, &iphv6->ip6_dst) != 0)",
          "4224:  packet->packet_direction = 1;",
          "4225:     }",
          "4227:     packet->packet_lines_parsed_complete = 0;",
          "4229:     if(flow->init_finished == 0) {",
          "4230:       flow->init_finished = 1;",
          "4231:       flow->setup_packet_direction = packet->packet_direction;",
          "4232:     }",
          "4234:     if(tcph != NULL) {",
          "4236:       packet->num_retried_bytes = 0;",
          "4238:       if(!ndpi_str->direction_detect_disable)",
          "4239:  packet->packet_direction = (ntohs(tcph->source) < ntohs(tcph->dest)) ? 1 : 0;",
          "4241:       if(tcph->syn != 0 && tcph->ack == 0 && flow->l4.tcp.seen_syn == 0 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "4242:   flow->l4.tcp.seen_ack == 0) {",
          "4243:  flow->l4.tcp.seen_syn = 1;",
          "4244:       } else",
          "4245:  if(tcph->syn != 0 && tcph->ack != 0 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 0 &&",
          "4247:    flow->l4.tcp.seen_syn_ack = 1;",
          "4249:    if(tcph->syn == 0 && tcph->ack == 1 && flow->l4.tcp.seen_syn == 1 && flow->l4.tcp.seen_syn_ack == 1 &&",
          "4251:      flow->l4.tcp.seen_ack = 1;",
          "4254:       if((flow->next_tcp_seq_nr[0] == 0 && flow->next_tcp_seq_nr[1] == 0) ||",
          "4255:   (flow->next_tcp_seq_nr[0] == 0 || flow->next_tcp_seq_nr[1] == 0)) {",
          "4264:  if(tcph->ack != 0) {",
          "4265:    flow->next_tcp_seq_nr[flow->packet.packet_direction] =",
          "4266:      ntohl(tcph->seq) + (tcph->syn ? 1 : packet->payload_packet_len);",
          "4269:      Check to avoid discrepancies in case we analyze a flow that does not start with SYN...",
          "4270:      but that is already started when nDPI being to process it. See also (***) below",
          "4272:    if(flow->num_processed_pkts > 1)",
          "4273:      flow->next_tcp_seq_nr[1 - flow->packet.packet_direction] = ntohl(tcph->ack_seq);",
          "4274:  }",
          "4275:       } else if(packet->payload_packet_len > 0) {",
          "4277:  if(((u_int32_t)(ntohl(tcph->seq) - flow->next_tcp_seq_nr[packet->packet_direction])) >",
          "4278:     ndpi_str->tcp_max_retransmission_window_size) {",
          "4279:    packet->tcp_retransmission = 1;",
          "4282:    if((flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq) <",
          "4283:        packet->payload_packet_len)) {",
          "4285:         analyzer which require this info can make use of this info",
          "4287:      packet->num_retried_bytes =",
          "4288:        (u_int16_t)(flow->next_tcp_seq_nr[packet->packet_direction] - ntohl(tcph->seq));",
          "4289:      packet->actual_payload_len = packet->payload_packet_len - packet->num_retried_bytes;",
          "4292:        flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "4297:     actual_payload_len is initialized to payload_packet_len during tcp header parsing itself.",
          "4299:  else {",
          "4300:    packet->num_retried_bytes = 0;",
          "4301:    flow->next_tcp_seq_nr[packet->packet_direction] = ntohl(tcph->seq) + packet->payload_packet_len;",
          "4305:       if(tcph->rst) {",
          "4306:  flow->next_tcp_seq_nr[0] = 0;",
          "4307:  flow->next_tcp_seq_nr[1] = 0;",
          "4309:     } else if(udph != NULL) {",
          "4310:       if(!ndpi_str->direction_detect_disable)",
          "4311:  packet->packet_direction = (htons(udph->source) < htons(udph->dest)) ? 1 : 0;",
          "4312:     }",
          "4314:     if(flow->packet_counter < MAX_PACKET_COUNTER && packet->payload_packet_len) {",
          "4315:       flow->packet_counter++;",
          "4316:     }",
          "4318:     if(flow->packet_direction_counter[packet->packet_direction] < MAX_PACKET_COUNTER &&",
          "4319:        packet->payload_packet_len) {",
          "4320:       flow->packet_direction_counter[packet->packet_direction]++;",
          "4321:     }",
          "4323:     if(flow->byte_counter[packet->packet_direction] + packet->payload_packet_len >",
          "4324:        flow->byte_counter[packet->packet_direction]) {",
          "4325:       flow->byte_counter[packet->packet_direction] += packet->payload_packet_len;",
          "4328: }",
          "4332: static u_int32_t check_ndpi_detection_func(struct ndpi_detection_module_struct * const ndpi_str,",
          "4333:         struct ndpi_flow_struct * const flow,",
          "4334:         NDPI_SELECTION_BITMASK_PROTOCOL_SIZE const ndpi_selection_packet,",
          "4335:         struct ndpi_call_function_struct const * const callback_buffer,",
          "4336:         uint32_t callback_buffer_size)",
          "4337: {",
          "4338:   void *func = NULL;",
          "4339:   u_int8_t is_tcp_without_payload = (callback_buffer == ndpi_str->callback_buffer_tcp_no_payload);",
          "4340:   u_int32_t num_calls = (is_tcp_without_payload != 0 ? 1 : 0);",
          "4341:   u_int16_t proto_index = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoIdx;",
          "4342:   u_int16_t proto_id = ndpi_str->proto_defaults[flow->guessed_protocol_id].protoId;",
          "4343:   NDPI_PROTOCOL_BITMASK detection_bitmask;",
          "4345:   NDPI_SAVE_AS_BITMASK(detection_bitmask, flow->packet.detected_protocol_stack[0]);",
          "4347:   if ((proto_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4348:       NDPI_BITMASK_COMPARE(flow->excluded_protocol_bitmask,",
          "4349:       ndpi_str->callback_buffer[proto_index].excluded_protocol_bitmask) == 0 &&",
          "4350:       NDPI_BITMASK_COMPARE(ndpi_str->callback_buffer[proto_index].detection_bitmask, detection_bitmask) != 0 &&",
          "4351:       (ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask & ndpi_selection_packet) ==",
          "4352:       ndpi_str->callback_buffer[proto_index].ndpi_selection_bitmask)",
          "4358:       NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD) == 0)))",
          "4359:  {",
          "4360:    ndpi_str->proto_defaults[flow->guessed_protocol_id].func(ndpi_str, flow);",
          "4361:    func = ndpi_str->proto_defaults[flow->guessed_protocol_id].func;",
          "4362:    num_calls++;",
          "4363:  }",
          "4366:   if (flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN)",
          "4371:      callback_buffer[a].ndpi_selection_bitmask &&",
          "4376:    {",
          "4377:      callback_buffer[a].func(ndpi_str, flow);",
          "4378:      num_calls++;",
          "4380:      if (flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "4381:        {",
          "4383:        }",
          "4384:    }",
          "4389:   for (u_int32_t a = 0; a < ndpi_str->proto_defaults[flow->detected_protocol_stack[0]].subprotocol_count; a++)",
          "4393:  {",
          "4394:    continue;",
          "4395:  }",
          "4400:    ndpi_str->callback_buffer[subproto_index].ndpi_selection_bitmask &&",
          "4405:  {",
          "4406:    ndpi_str->callback_buffer[subproto_index].func(ndpi_str, flow);",
          "4407:    num_calls++;",
          "4408:  }",
          "4411:  {",
          "4413:  }",
          "4416:   return num_calls;",
          "4417: }",
          "4421: u_int32_t check_ndpi_other_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4422:          struct ndpi_flow_struct *flow,",
          "4423:          NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4424: {",
          "4425:   return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4426:        ndpi_str->callback_buffer_non_tcp_udp,",
          "4427:        ndpi_str->callback_buffer_size_non_tcp_udp);",
          "4428: }",
          "4432: static u_int32_t check_ndpi_udp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4433:        struct ndpi_flow_struct *flow,",
          "4434:        NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4435: {",
          "4436:   return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4437:        ndpi_str->callback_buffer_udp,",
          "4438:        ndpi_str->callback_buffer_size_udp);",
          "4439: }",
          "4443: static u_int32_t check_ndpi_tcp_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4444:        struct ndpi_flow_struct *flow,",
          "4445:        NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet)",
          "4446: {",
          "4447:   if (flow->packet.payload_packet_len != 0) {",
          "4448:     return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4449:          ndpi_str->callback_buffer_tcp_payload,",
          "4450:          ndpi_str->callback_buffer_size_tcp_payload);",
          "4451:   } else {",
          "4453:     return check_ndpi_detection_func(ndpi_str, flow, *ndpi_selection_packet,",
          "4454:          ndpi_str->callback_buffer_tcp_no_payload,",
          "4455:          ndpi_str->callback_buffer_size_tcp_no_payload);",
          "4457: }",
          "4461: u_int32_t ndpi_check_flow_func(struct ndpi_detection_module_struct *ndpi_str,",
          "4462:           struct ndpi_flow_struct *flow,",
          "4463:           NDPI_SELECTION_BITMASK_PROTOCOL_SIZE *ndpi_selection_packet) {",
          "4464:   if(!flow)",
          "4465:     return(0);",
          "4466:   else if(flow->packet.tcp != NULL)",
          "4467:     return(check_ndpi_tcp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4468:   else if(flow->packet.udp != NULL)",
          "4469:     return(check_ndpi_udp_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4470:   else",
          "4471:     return(check_ndpi_other_flow_func(ndpi_str, flow, ndpi_selection_packet));",
          "4472: }",
          "4476: u_int16_t ndpi_guess_host_protocol_id(struct ndpi_detection_module_struct *ndpi_str,",
          "4477:           struct ndpi_flow_struct *flow) {",
          "4478:   u_int16_t ret = NDPI_PROTOCOL_UNKNOWN;",
          "4480:   if(flow->packet.iph) {",
          "4481:     struct in_addr addr;",
          "4482:     u_int16_t sport, dport;",
          "4484:     addr.s_addr = flow->packet.iph->saddr;",
          "4486:     if((flow->l4_proto == IPPROTO_TCP) && flow->packet.tcp)",
          "4487:       sport = flow->packet.tcp->source, dport = flow->packet.tcp->dest;",
          "4488:     else if((flow->l4_proto == IPPROTO_UDP) && flow->packet.udp)",
          "4489:       sport = flow->packet.udp->source, dport = flow->packet.udp->dest;",
          "4490:     else",
          "4491:       sport = dport = 0;",
          "4494:     ret = ndpi_network_port_ptree_match(ndpi_str, &addr, sport);",
          "4496:     if(ret == NDPI_PROTOCOL_UNKNOWN) {",
          "4497:       addr.s_addr = flow->packet.iph->daddr;",
          "4498:       ret = ndpi_network_port_ptree_match(ndpi_str, &addr, dport);",
          "4502:   return(ret);",
          "4503: }",
          "4507: ndpi_protocol ndpi_detection_giveup(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4508:         u_int8_t enable_guess, u_int8_t *protocol_was_guessed) {",
          "4509:   ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "4513:   if(flow == NULL)",
          "4514:     return(ret);",
          "4517:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4518:   ret.category = flow->category;",
          "4521:   if((ret.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "4522:     return(ret);",
          "4524:   if(ndpi_str->mining_cache && flow->packet.iph) {",
          "4525:     u_int16_t cached_proto;",
          "4526:     u_int32_t key = flow->packet.iph->saddr + flow->packet.iph->daddr;",
          "4528:     if(ndpi_lru_find_cache(ndpi_str->mining_cache, key,",
          "4529:       &cached_proto, 0 /* Don't remove it as it can be used for other connections */)) {",
          "4530:       ndpi_set_detected_protocol(ndpi_str, flow, cached_proto, NDPI_PROTOCOL_UNKNOWN);",
          "4531:       ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4532:       return(ret);",
          "4534:   }",
          "4537:   if(flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) {",
          "4538:     u_int16_t guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN, guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4540:     if(flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)",
          "4541:       goto check_stun_export;",
          "4542:     else if((flow->guessed_protocol_id == NDPI_PROTOCOL_HANGOUT_DUO) ||",
          "4543:      (flow->guessed_protocol_id == NDPI_PROTOCOL_MESSENGER) ||",
          "4544:      (flow->guessed_protocol_id == NDPI_PROTOCOL_WHATSAPP_CALL)) {",
          "4546:       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_protocol_id, NDPI_PROTOCOL_UNKNOWN);",
          "4547:     }",
          "4548:     else if((flow->l4.tcp.tls.hello_processed == 1) &&",
          "4549:      (flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0')) {",
          "4551:       ndpi_set_detected_protocol(ndpi_str, flow, NDPI_PROTOCOL_TLS, NDPI_PROTOCOL_UNKNOWN);",
          "4553:       if((flow->guessed_protocol_id == NDPI_PROTOCOL_UNKNOWN) && (flow->packet.l4_protocol == IPPROTO_TCP) &&",
          "4554:   flow->l4.tcp.tls.hello_processed)",
          "4555:  flow->guessed_protocol_id = NDPI_PROTOCOL_TLS;",
          "4557:       guessed_protocol_id = flow->guessed_protocol_id, guessed_host_protocol_id = flow->guessed_host_protocol_id;",
          "4559:       if((guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "4560:   ((flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4561:    NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_host_protocol_id) &&",
          "4562:    is_udp_guessable_protocol(guessed_host_protocol_id)))",
          "4563:  flow->guessed_host_protocol_id = guessed_host_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4566:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4568:   && (flow->packet.l4_protocol == IPPROTO_UDP) &&",
          "4569:   NDPI_ISSET(&flow->excluded_protocol_bitmask, guessed_protocol_id) &&",
          "4570:   is_udp_guessable_protocol(guessed_protocol_id))",
          "4571:  flow->guessed_protocol_id = guessed_protocol_id = NDPI_PROTOCOL_UNKNOWN;",
          "4573:       if((guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) || (guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "4574:  if((guessed_protocol_id == 0) && (flow->protos.tls_quic_stun.stun.num_binding_requests > 0) &&",
          "4575:     (flow->protos.tls_quic_stun.stun.num_processed_pkts > 0))",
          "4576:    guessed_protocol_id = NDPI_PROTOCOL_STUN;",
          "4578:  if(flow->host_server_name[0] != '\\0') {",
          "4579:    ndpi_protocol_match_result ret_match;",
          "4581:    memset(&ret_match, 0, sizeof(ret_match));",
          "4583:    ndpi_match_host_subprotocol(ndpi_str, flow, (char *) flow->host_server_name,",
          "4584:           strlen((const char *) flow->host_server_name), &ret_match,",
          "4585:           NDPI_PROTOCOL_DNS);",
          "4587:    if(ret_match.protocol_id != NDPI_PROTOCOL_UNKNOWN)",
          "4588:      guessed_host_protocol_id = ret_match.protocol_id;",
          "4589:  }",
          "4592:  ndpi_int_change_protocol(ndpi_str, flow, guessed_host_protocol_id, guessed_protocol_id);",
          "4595:   } else if(enable_guess) {",
          "4596:     if(flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4598:       flow->detected_protocol_stack[1] = flow->guessed_protocol_id;",
          "4601:     if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "4603:       flow->detected_protocol_stack[0] = flow->guessed_host_protocol_id;",
          "4604:     }",
          "4606:     if(flow->detected_protocol_stack[1] == flow->detected_protocol_stack[0]) {",
          "4608:       flow->detected_protocol_stack[1] = flow->guessed_host_protocol_id;",
          "4610:   }",
          "4612:   if((flow->detected_protocol_stack[0] == NDPI_PROTOCOL_UNKNOWN) &&",
          "4613:      (flow->guessed_protocol_id == NDPI_PROTOCOL_STUN)) {",
          "4614:   check_stun_export:",
          "4616:     {",
          "4619:       ndpi_set_detected_protocol(ndpi_str, flow, flow->guessed_host_protocol_id, NDPI_PROTOCOL_STUN);",
          "4621:   }",
          "4623:   ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "4625:   if(ret.master_protocol == NDPI_PROTOCOL_STUN) {",
          "4626:     if(ret.app_protocol == NDPI_PROTOCOL_FACEBOOK)",
          "4627:       ret.app_protocol = NDPI_PROTOCOL_MESSENGER;",
          "4628:     else if(ret.app_protocol == NDPI_PROTOCOL_GOOGLE) {",
          "4630:  As Google has recently introduced Duo,",
          "4631:  we need to distinguish between it and hangout",
          "4632:  thing that should be handled by the STUN dissector",
          "4634:       ret.app_protocol = NDPI_PROTOCOL_HANGOUT_DUO;",
          "4635:     }",
          "4638:   if(ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) {",
          "4640:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "4641:   }",
          "4643:   return(ret);",
          "4644: }",
          "4648: void ndpi_process_extra_packet(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4649:           const unsigned char *packet, const unsigned short packetlen,",
          "4650:           const u_int64_t current_time_ms, struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "4651:   if(flow == NULL)",
          "4652:     return;",
          "4654:   if(flow->server_id == NULL)",
          "4658:   if(packetlen < 20) {",
          "4659:     return;",
          "4660:   }",
          "4662:   flow->packet.current_time_ms = current_time_ms;",
          "4665:   flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "4669:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "4670:     return;",
          "4673:   flow->src = src, flow->dst = dst;",
          "4675:   ndpi_connection_tracking(ndpi_str, flow);",
          "4678:   if(flow->extra_packets_func) {",
          "4679:     if((flow->extra_packets_func(ndpi_str, flow)) == 0)",
          "4680:       flow->check_extra_packets = 0;",
          "4682:     if(++flow->num_extra_packets_checked == flow->max_extra_packets_to_check)",
          "4684:   }",
          "4685: }",
          "4689: int ndpi_load_ip_category(struct ndpi_detection_module_struct *ndpi_str, const char *ip_address_and_mask,",
          "4690:      ndpi_protocol_category_t category) {",
          "4691:   ndpi_patricia_node_t *node;",
          "4692:   struct in_addr pin;",
          "4693:   int bits = 32;",
          "4694:   char *ptr;",
          "4695:   char ipbuf[64];",
          "4697:   strncpy(ipbuf, ip_address_and_mask, sizeof(ipbuf));",
          "4698:   ipbuf[sizeof(ipbuf) - 1] = '\\0';",
          "4700:   ptr = strrchr(ipbuf, '/');",
          "4702:   if(ptr) {",
          "4704:     if(atoi(ptr) >= 0 && atoi(ptr) <= 32)",
          "4705:       bits = atoi(ptr);",
          "4706:   }",
          "4708:   if(inet_pton(AF_INET, ipbuf, &pin) != 1) {",
          "4709:     NDPI_LOG_DBG2(ndpi_str, \"Invalid ip/ip+netmask: %s\\n\", ip_address_and_mask);",
          "4710:     return(-1);",
          "4713:   if((node = add_to_ptree(ndpi_str->custom_categories.ipAddresses_shadow, AF_INET, &pin, bits)) != NULL) {",
          "4714:     node->value.u.uv32.user_value = (u_int16_t)category, node->value.u.uv32.additional_user_value = 0;",
          "4715:   }",
          "4717:   return(0);",
          "4718: }",
          "4723: int ndpi_load_hostname_category(struct ndpi_detection_module_struct *ndpi_str, const char *name_to_add,",
          "4724:     ndpi_protocol_category_t category) {",
          "4725:   char *name;",
          "4726:   u_int len;",
          "4727:   AC_PATTERN_t ac_pattern;",
          "4728:   AC_ERROR_t rc;",
          "4730:   if(name_to_add == NULL)",
          "4731:     return(-1);",
          "4732:   else",
          "4733:     len = strlen(name_to_add);",
          "4735:   if((name = (char*)ndpi_malloc(len+3)) == NULL)",
          "4736:     return(-1);",
          "4738:   memset(&ac_pattern, 0, sizeof(ac_pattern));",
          "4739:   ac_pattern.length = snprintf(name, len+2, \"%s%s\", name_to_add,",
          "4740:           ndpi_is_middle_string_char(name_to_add[len-1]) ? \"\" : \"$\");",
          "4742: #if 0",
          "4743:   printf(\"===> %s() Loading %s as %u\\n\", __FUNCTION__, name, category);",
          "4744: #endif",
          "4746:   if(ndpi_str->custom_categories.hostnames_shadow.ac_automa == NULL) {",
          "4747:     ndpi_free(name);",
          "4748:     return(-1);",
          "4749:   }",
          "4751:   ac_pattern.astring = name;",
          "4752:   ac_pattern.rep.number = (u_int32_t) category,  ac_pattern.rep.category = category;",
          "4754:   rc = ac_automata_add(ndpi_str->custom_categories.hostnames_shadow.ac_automa, &ac_pattern);",
          "4755:   if(rc != ACERR_DUPLICATE_PATTERN && rc != ACERR_SUCCESS) {",
          "4756:     ndpi_free(name);",
          "4757:     return(-1);",
          "4760:   if(rc == ACERR_DUPLICATE_PATTERN)",
          "4761:     ndpi_free(name);",
          "4763:   return(0);",
          "4764: }",
          "4769: int ndpi_load_category(struct ndpi_detection_module_struct *ndpi_struct, const char *ip_or_name,",
          "4770:          ndpi_protocol_category_t category) {",
          "4771:   int rv;",
          "4774:   rv = ndpi_load_ip_category(ndpi_struct, ip_or_name, category);",
          "4776:   if(rv < 0) {",
          "4778:     rv = ndpi_load_hostname_category(ndpi_struct, ip_or_name, category);",
          "4781:   return(rv);",
          "4782: }",
          "4786: int ndpi_enable_loaded_categories(struct ndpi_detection_module_struct *ndpi_str) {",
          "4787:   int i;",
          "4790:   for(i = 0; category_match[i].string_to_match != NULL; i++)",
          "4791:     ndpi_load_category(ndpi_str, category_match[i].string_to_match, category_match[i].protocol_category);",
          "4794:   ac_automata_release((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames.ac_automa,",
          "4795:         1 /* free patterns strings memory */);",
          "4798:   ac_automata_finalize((AC_AUTOMATA_t *) ndpi_str->custom_categories.hostnames_shadow.ac_automa);",
          "4801:   ndpi_str->custom_categories.hostnames.ac_automa = ndpi_str->custom_categories.hostnames_shadow.ac_automa;",
          "4804:   ndpi_str->custom_categories.hostnames_shadow.ac_automa = ac_automata_init(ac_match_handler);",
          "4806:   if(ndpi_str->custom_categories.ipAddresses != NULL)",
          "4807:     ndpi_patricia_destroy((ndpi_patricia_tree_t *) ndpi_str->custom_categories.ipAddresses, free_ptree_data);",
          "4809:   ndpi_str->custom_categories.ipAddresses = ndpi_str->custom_categories.ipAddresses_shadow;",
          "4810:   ndpi_str->custom_categories.ipAddresses_shadow = ndpi_patricia_new(32 /* IPv4 */);",
          "4812:   ndpi_str->custom_categories.categories_loaded = 1;",
          "4814:   return(0);",
          "4815: }",
          "4819: int ndpi_fill_ip_protocol_category(struct ndpi_detection_module_struct *ndpi_str, u_int32_t saddr, u_int32_t daddr,",
          "4820:        ndpi_protocol *ret) {",
          "4821:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4822:     ndpi_prefix_t prefix;",
          "4823:     ndpi_patricia_node_t *node;",
          "4825:     if(saddr == 0)",
          "4826:       node = NULL;",
          "4827:     else {",
          "4829:       ndpi_fill_prefix_v4(&prefix, (struct in_addr *) &saddr, 32,",
          "4830:      ((ndpi_patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4831:       node = ndpi_patricia_search_best(ndpi_str->custom_categories.ipAddresses, &prefix);",
          "4832:     }",
          "4834:     if(!node) {",
          "4835:       if(daddr != 0) {",
          "4836:  ndpi_fill_prefix_v4(&prefix, (struct in_addr *) &daddr, 32,",
          "4837:        ((ndpi_patricia_tree_t *) ndpi_str->protocols_ptree)->maxbits);",
          "4840:     }",
          "4842:     if(node) {",
          "4843:       ret->category = (ndpi_protocol_category_t) node->value.u.uv32.user_value;",
          "4845:       return(1);",
          "4847:   }",
          "4849:   ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4851:   return(0);",
          "4852: }",
          "4856: void ndpi_fill_protocol_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "4857:      ndpi_protocol *ret) {",
          "4858:   if((ret->master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret->app_protocol == NDPI_PROTOCOL_UNKNOWN))",
          "4859:     return;",
          "4861:   if(ndpi_str->custom_categories.categories_loaded) {",
          "4862:     if(flow->guessed_header_category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) {",
          "4863:       flow->category = ret->category = flow->guessed_header_category;",
          "4864:       return;",
          "4865:     }",
          "4867:     if(flow->host_server_name[0] != '\\0') {",
          "4868:       u_int32_t id;",
          "4869:       int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->host_server_name,",
          "4870:        strlen((char *) flow->host_server_name), &id);",
          "4872:       if(rc == 0) {",
          "4873:  flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4874:  return;",
          "4876:     }",
          "4878:     if(flow->l4.tcp.tls.hello_processed == 1 &&",
          "4879:        flow->protos.tls_quic_stun.tls_quic.client_requested_server_name[0] != '\\0') {",
          "4880:       u_int32_t id;",
          "4881:       int rc = ndpi_match_custom_category(ndpi_str, (char *) flow->protos.tls_quic_stun.tls_quic.client_requested_server_name,",
          "4882:        strlen(flow->protos.tls_quic_stun.tls_quic.client_requested_server_name), &id);",
          "4884:       if(rc == 0) {",
          "4885:  flow->category = ret->category = (ndpi_protocol_category_t) id;",
          "4886:  return;",
          "4891:   flow->category = ret->category = ndpi_get_proto_category(ndpi_str, *ret);",
          "4892: }",
          "4896: static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {",
          "4897:   packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,",
          "4898:     packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,",
          "4899:     packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,",
          "4900:     packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,",
          "4901:     packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,",
          "4902:     packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,",
          "4903:     packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->content_disposition_line.ptr = NULL,",
          "4904:     packet->content_disposition_line.len = 0, packet->http_cookie.ptr = NULL,",
          "4905:     packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,",
          "4906:     packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,",
          "4907:     packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,",
          "4908:     packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0,",
          "4909:     packet->forwarded_line.ptr = NULL, packet->forwarded_line.len = 0;",
          "4910: }",
          "4914: static int ndpi_is_ntop_protocol(ndpi_protocol *ret) {",
          "4915:   if((ret->master_protocol == NDPI_PROTOCOL_HTTP) && (ret->app_protocol == NDPI_PROTOCOL_NTOP))",
          "4916:     return(1);",
          "4917:   else",
          "4918:     return(0);",
          "4919: }",
          "4923: static int ndpi_check_protocol_port_mismatch_exceptions(struct ndpi_detection_module_struct *ndpi_str,",
          "4924:        struct ndpi_flow_struct *flow,",
          "4925:        ndpi_default_ports_tree_node_t *expected_proto,",
          "4926:        ndpi_protocol *returned_proto) {",
          "4928:     For TLS (and other protocols) it is not simple to guess the exact protocol so before",
          "4929:     triggering an alert we need to make sure what we have exhausted all the possible",
          "4930:     options available",
          "4933:   if(ndpi_is_ntop_protocol(returned_proto)) return(1);",
          "4935:   if(returned_proto->master_protocol == NDPI_PROTOCOL_TLS) {",
          "4936:     switch(expected_proto->proto->protoId) {",
          "4937:     case NDPI_PROTOCOL_MAIL_IMAPS:",
          "4938:     case NDPI_PROTOCOL_MAIL_POPS:",
          "4939:     case NDPI_PROTOCOL_MAIL_SMTPS:",
          "4941:       break;",
          "4945:   return(0);",
          "4946: }",
          "4950: static void ndpi_reconcile_protocols(struct ndpi_detection_module_struct *ndpi_str,",
          "4951:          struct ndpi_flow_struct *flow,",
          "4952:          ndpi_protocol *ret) {",
          "4955:   if(flow) {",
          "4957:     if((flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN)",
          "4958:        && (flow->detected_protocol_stack[0] /* app */ != flow->detected_protocol_stack[1] /* major */))",
          "4959:       NDPI_CLR_BIT(flow->risk, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "4960:   }",
          "4965:   switch(ret->app_protocol) {",
          "4970:   case NDPI_PROTOCOL_MSTEAMS:",
          "4971:     if(flow->packet.iph && flow->packet.tcp) {",
          "4974:       if(ndpi_str->msteams_cache == NULL)",
          "4975:  ndpi_str->msteams_cache = ndpi_lru_cache_init(1024);",
          "4977:       if(ndpi_str->msteams_cache)",
          "4978:  ndpi_lru_add_to_cache(ndpi_str->msteams_cache,",
          "4979:          flow->packet.iph->saddr,",
          "4980:          (flow->packet.current_time_ms / 1000) & 0xFFFF /* 16 bit */);",
          "4981:     }",
          "4982:     break;",
          "4984:   case NDPI_PROTOCOL_SKYPE:",
          "4985:   case NDPI_PROTOCOL_SKYPE_CALL:",
          "4986:     if(flow->packet.iph",
          "4987:        && flow->packet.udp",
          "4988:        && ndpi_str->msteams_cache) {",
          "4989:       u_int16_t when;",
          "4991:       if(ndpi_lru_find_cache(ndpi_str->msteams_cache, flow->packet.iph->saddr,",
          "4992:         &when, 0 /* Don't remove it as it can be used for other connections */)) {",
          "4993:  u_int16_t tdiff = ((flow->packet.current_time_ms /1000) & 0xFFFF) - when;",
          "4995:  if(tdiff < 60 /* sec */) {",
          "4997:    ret->app_protocol = NDPI_PROTOCOL_MSTEAMS;",
          "5005:     }",
          "5006:     break;",
          "5008:   case NDPI_PROTOCOL_ANYDESK:",
          "5011:     break;",
          "5014:   if(flow) {",
          "5015:     switch(ndpi_get_proto_breed(ndpi_str, ret->app_protocol)) {",
          "5016:     case NDPI_PROTOCOL_UNSAFE:",
          "5017:     case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "5018:     case NDPI_PROTOCOL_DANGEROUS:",
          "5019:       ndpi_set_risk(flow, NDPI_UNSAFE_PROTOCOL);",
          "5020:       break;",
          "5021:     default:",
          "5027: }",
          "5031: static int ndpi_do_guess(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow, ndpi_protocol *ret) {",
          "5032:   ret->master_protocol = ret->app_protocol = NDPI_PROTOCOL_UNKNOWN, ret->category = 0;",
          "5034:   if(flow->packet.iphv6 || flow->packet.iph) {",
          "5035:     u_int16_t sport, dport;",
          "5036:     u_int8_t protocol;",
          "5037:     u_int8_t user_defined_proto;",
          "5039:     if(flow->packet.iphv6 != NULL) {",
          "5040:       protocol = flow->packet.iphv6->ip6_hdr.ip6_un1_nxt;",
          "5041:     } else",
          "5042:       protocol = flow->packet.iph->protocol;",
          "5044:     if(flow->packet.udp)",
          "5045:       sport = ntohs(flow->packet.udp->source), dport = ntohs(flow->packet.udp->dest);",
          "5046:     else if(flow->packet.tcp)",
          "5047:       sport = ntohs(flow->packet.tcp->source), dport = ntohs(flow->packet.tcp->dest);",
          "5048:     else",
          "5049:       sport = dport = 0;",
          "5052:     flow->guessed_protocol_id      = (int16_t) ndpi_guess_protocol_id(ndpi_str, flow, protocol, sport, dport, &user_defined_proto);",
          "5053:     flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "5055:     if(ndpi_str->custom_categories.categories_loaded && flow->packet.iph) {",
          "5056:       if(ndpi_str->ndpi_num_custom_protocols != 0)",
          "5057:  ndpi_fill_ip_protocol_category(ndpi_str, flow->packet.iph->saddr, flow->packet.iph->daddr, ret);",
          "5058:       flow->guessed_header_category = ret->category;",
          "5059:     } else",
          "5060:       flow->guessed_header_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED;",
          "5062:     if(flow->guessed_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "5064:       ret->master_protocol = NDPI_PROTOCOL_UNKNOWN,",
          "5065:  ret->app_protocol = flow->guessed_protocol_id ? flow->guessed_protocol_id : flow->guessed_host_protocol_id;",
          "5068:       ndpi_fill_protocol_category(ndpi_str, flow, ret);",
          "5069:       return(-1);",
          "5070:     }",
          "5072:     if(user_defined_proto && flow->guessed_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "5073:       if(flow->packet.iph) {",
          "5074:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "5075:    u_int8_t protocol_was_guessed;",
          "5082:  ndpi_fill_protocol_category(ndpi_str, flow, ret);",
          "5083:  return(-1);",
          "5084:       }",
          "5085:     } else {",
          "5087:       if(flow->packet.iph) {",
          "5088:  flow->guessed_host_protocol_id = ndpi_guess_host_protocol_id(ndpi_str, flow);",
          "5091:    We could implement a shortcut here skipping dissectors for",
          "5092:    protocols we have identified by other means such as with the IP",
          "5094:    However we do NOT stop here and skip invoking the dissectors",
          "5095:    because we want to dissect the flow (e.g. dissect the TLS)",
          "5096:    and extract metadata.",
          "5099:  if(flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) {",
          "5101:      We have identified a protocol using the IP address so",
          "5102:      it is not worth to dissect the traffic as we already have",
          "5103:      the solution",
          "5105:    ret->master_protocol = flow->guessed_protocol_id, ret->app_protocol = flow->guessed_host_protocol_id;",
          "5107: #endif",
          "5110:   }",
          "5112:   if(flow->guessed_host_protocol_id >= NDPI_MAX_SUPPORTED_PROTOCOLS) {",
          "5114:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "5117:     ret->master_protocol = flow->guessed_protocol_id, ret->app_protocol = flow->guessed_host_protocol_id;",
          "5120:     ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "5123:     ndpi_fill_protocol_category(ndpi_str, flow, ret);",
          "5124:     return(-1);",
          "5127:   return(0);",
          "5128: }",
          "5132: ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_str,",
          "5133:          struct ndpi_flow_struct *flow, const unsigned char *packet,",
          "5134:          const unsigned short packetlen, const u_int64_t current_time_ms,",
          "5135:          struct ndpi_id_struct *src, struct ndpi_id_struct *dst) {",
          "5136:   NDPI_SELECTION_BITMASK_PROTOCOL_SIZE ndpi_selection_packet;",
          "5137:   u_int32_t a, num_calls = 0;",
          "5138:   ndpi_protocol ret = { flow->detected_protocol_stack[1], flow->detected_protocol_stack[0], flow->category };",
          "5140:   if(ndpi_str->ndpi_log_level >= NDPI_LOG_TRACE)",
          "5141:     NDPI_LOG(flow ? flow->detected_protocol_stack[0] : NDPI_PROTOCOL_UNKNOWN, ndpi_str, NDPI_LOG_TRACE,",
          "5142:       \"START packet processing\\n\");",
          "5144:   if(flow == NULL)",
          "5145:     return(ret);",
          "5146:   else",
          "5147:     ret.category = flow->category;",
          "5149:   if(flow->fail_with_unknown) {",
          "5151:     return(ret);",
          "5152:   }",
          "5154:   flow->num_processed_pkts++;",
          "5157:   ret.master_protocol = flow->detected_protocol_stack[1],",
          "5158:     ret.app_protocol = flow->detected_protocol_stack[0];",
          "5160:   if(flow->server_id == NULL)",
          "5163:   if(flow->check_extra_packets) {",
          "5164:     ndpi_process_extra_packet(ndpi_str, flow, packet, packetlen, current_time_ms, src, dst);",
          "5166:     ret.master_protocol = flow->detected_protocol_stack[1],",
          "5167:       ret.app_protocol = flow->detected_protocol_stack[0],",
          "5168:       ret.category = flow->category;",
          "5169:     goto invalidate_ptr;",
          "5170:   } else if(flow->detected_protocol_stack[0] != NDPI_PROTOCOL_UNKNOWN)",
          "5171:     goto ret_protocols;",
          "5174:   if(packetlen < 20) {",
          "5176:     ndpi_int_reset_packet_protocol(&flow->packet);",
          "5177:     goto invalidate_ptr;",
          "5178:   }",
          "5180:   flow->packet.current_time_ms = current_time_ms;",
          "5183:   flow->packet.iph = (struct ndpi_iphdr *) packet;",
          "5186:   if(ndpi_init_packet_header(ndpi_str, flow, packetlen) != 0)",
          "5187:     goto invalidate_ptr;",
          "5190:   flow->src = src, flow->dst = dst;",
          "5192:   ndpi_connection_tracking(ndpi_str, flow);",
          "5195:   ndpi_selection_packet = NDPI_SELECTION_BITMASK_PROTOCOL_COMPLETE_TRAFFIC;",
          "5196:   if(flow->packet.iph != NULL)",
          "5197:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IP | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "5199:   if(flow->packet.tcp != NULL)",
          "5200:     ndpi_selection_packet |=",
          "5201:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "5203:   if(flow->packet.udp != NULL)",
          "5204:     ndpi_selection_packet |=",
          "5205:       (NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP | NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP);",
          "5207:   if(flow->packet.payload_packet_len != 0)",
          "5208:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_HAS_PAYLOAD;",
          "5210:   if(flow->packet.tcp_retransmission == 0)",
          "5211:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_NO_TCP_RETRANSMISSION;",
          "5213:   if(flow->packet.iphv6 != NULL)",
          "5214:     ndpi_selection_packet |= NDPI_SELECTION_BITMASK_PROTOCOL_IPV6 | NDPI_SELECTION_BITMASK_PROTOCOL_IPV4_OR_IPV6;",
          "5216:   if(!flow->protocol_id_already_guessed) {",
          "5217:     flow->protocol_id_already_guessed = 1;",
          "5219:     if(ndpi_do_guess(ndpi_str, flow, &ret) == -1)",
          "5220:       goto invalidate_ptr;",
          "5221:   }",
          "5223:   num_calls = ndpi_check_flow_func(ndpi_str, flow, &ndpi_selection_packet);",
          "5225:   a = flow->packet.detected_protocol_stack[0];",
          "5226:   if(NDPI_COMPARE_PROTOCOL_TO_BITMASK(ndpi_str->detection_bitmask, a) == 0)",
          "5227:     a = NDPI_PROTOCOL_UNKNOWN;",
          "5229:   if(a != NDPI_PROTOCOL_UNKNOWN) {",
          "5230:     int i;",
          "5232:     for(i = 0; i < sizeof(flow->host_server_name); i++) {",
          "5233:       if(flow->host_server_name[i] != '\\0')",
          "5234:  flow->host_server_name[i] = tolower(flow->host_server_name[i]);",
          "5235:       else {",
          "5236:  flow->host_server_name[i] = '\\0';",
          "5237:  break;",
          "5240:   }",
          "5242:  ret_protocols:",
          "5243:   if(flow->detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN) {",
          "5244:     ret.master_protocol = flow->detected_protocol_stack[1], ret.app_protocol = flow->detected_protocol_stack[0];",
          "5246:     if(ret.app_protocol == ret.master_protocol)",
          "5247:       ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5248:   } else",
          "5249:     ret.app_protocol = flow->detected_protocol_stack[0];",
          "5252:   if((flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5253:     ndpi_fill_protocol_category(ndpi_str, flow, &ret);",
          "5254:   else",
          "5255:     ret.category = flow->category;",
          "5257:   if((flow->num_processed_pkts == 1) && (ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) &&",
          "5258:      (ret.app_protocol == NDPI_PROTOCOL_UNKNOWN) && flow->packet.tcp && (flow->packet.tcp->syn == 0) &&",
          "5259:      (flow->guessed_protocol_id == 0)) {",
          "5260:     u_int8_t protocol_was_guessed;",
          "5263:       This is a TCP flow",
          "5264:       - whose first packet is NOT a SYN",
          "5265:       - no protocol has been detected",
          "5267:       We don't see how future packets can match anything",
          "5268:       hence we giveup here",
          "5270:     ret = ndpi_detection_giveup(ndpi_str, flow, 0, &protocol_was_guessed);",
          "5271:   }",
          "5273:   if((ret.master_protocol == NDPI_PROTOCOL_UNKNOWN) && (ret.app_protocol != NDPI_PROTOCOL_UNKNOWN) &&",
          "5274:      (flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN)) {",
          "5275:     ret.master_protocol = ret.app_protocol;",
          "5276:     ret.app_protocol = flow->guessed_host_protocol_id;",
          "5277:   }",
          "5279:   if((!flow->risk_checked) && (ret.master_protocol != NDPI_PROTOCOL_UNKNOWN)) {",
          "5280:     ndpi_default_ports_tree_node_t *found;",
          "5281:     u_int16_t *default_ports, sport, dport;",
          "5283:     if(flow->packet.udp)",
          "5284:       found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_UDP,",
          "5285:         sport = ntohs(flow->packet.udp->source),",
          "5286:         dport = ntohs(flow->packet.udp->dest)),",
          "5287:  default_ports = ndpi_str->proto_defaults[ret.master_protocol].udp_default_ports;",
          "5288:     else if(flow->packet.tcp)",
          "5289:       found = ndpi_get_guessed_protocol_id(ndpi_str, IPPROTO_TCP,",
          "5290:         sport = ntohs(flow->packet.tcp->source),",
          "5291:         dport = ntohs(flow->packet.tcp->dest)),",
          "5292:  default_ports = ndpi_str->proto_defaults[ret.master_protocol].tcp_default_ports;",
          "5293:     else",
          "5294:       found = NULL, default_ports = NULL, sport = dport = 0;",
          "5296:     if(found",
          "5297:        && (found->proto->protoId != NDPI_PROTOCOL_UNKNOWN)",
          "5298:        && (found->proto->protoId != ret.master_protocol)",
          "5299:        && (found->proto->protoId != ret.app_protocol)",
          "5300:        ) {",
          "5303:       if(!ndpi_check_protocol_port_mismatch_exceptions(ndpi_str, flow, found, &ret))",
          "5304:  ndpi_set_risk(flow, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "5305:     } else if((!ndpi_is_ntop_protocol(&ret)) && default_ports && (default_ports[0] != 0)) {",
          "5306:       u_int8_t found = 0, i, num_loops = 0;",
          "5308:     check_default_ports:",
          "5309:       for(i=0; (i<MAX_DEFAULT_PORTS) && (default_ports[i] != 0); i++) {",
          "5310:  if((default_ports[i] == sport) || (default_ports[i] == dport)) {",
          "5311:    found = 1;",
          "5312:    break;",
          "5316:       if((num_loops == 0) && (!found)) {",
          "5317:  if(flow->packet.udp)",
          "5318:    default_ports = ndpi_str->proto_defaults[ret.app_protocol].udp_default_ports;",
          "5319:  else",
          "5320:    default_ports = ndpi_str->proto_defaults[ret.app_protocol].tcp_default_ports;",
          "5322:  num_loops = 1;",
          "5323:  goto check_default_ports;",
          "5326:       if(!found) {",
          "5328:  ndpi_set_risk(flow, NDPI_KNOWN_PROTOCOL_ON_NON_STANDARD_PORT);",
          "5329:       }",
          "5332:     flow->risk_checked = 1;",
          "5333:   }",
          "5335:   ndpi_reconcile_protocols(ndpi_str, flow, &ret);",
          "5337:   if(num_calls == 0)",
          "5338:     flow->fail_with_unknown = 1;",
          "5340:  invalidate_ptr:",
          "5342:     Invalidate packet memory to avoid accessing the pointers below",
          "5343:     when the packet is no longer accessible",
          "5345:   flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "5346:   ndpi_reset_packet_line_info(&flow->packet);",
          "5348:   return(ret);",
          "5349: }",
          "5353: u_int32_t ndpi_bytestream_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5354:   u_int32_t val;",
          "5355:   val = 0;",
          "5358:   while(*str >= '0' && *str <= '9' && max_chars_to_read > 0) {",
          "5359:     val *= 10;",
          "5360:     val += *str - '0';",
          "5361:     str++;",
          "5362:     max_chars_to_read = max_chars_to_read - 1;",
          "5366:   return(val);",
          "5367: }",
          "5372: u_int32_t ndpi_bytestream_dec_or_hex_to_number(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5373:   u_int32_t val;",
          "5374:   val = 0;",
          "5375:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5376:     return(ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read));",
          "5377:   } else {",
          "5379:     str += 2;",
          "5380:     max_chars_to_read -= 2;",
          "5383:     while(max_chars_to_read > 0) {",
          "5384:       if(*str >= '0' && *str <= '9') {",
          "5385:  val *= 16;",
          "5386:  val += *str - '0';",
          "5387:       } else if(*str >= 'a' && *str <= 'f') {",
          "5388:  val *= 16;",
          "5389:  val += *str + 10 - 'a';",
          "5390:       } else if(*str >= 'A' && *str <= 'F') {",
          "5391:  val *= 16;",
          "5392:  val += *str + 10 - 'A';",
          "5393:       } else {",
          "5394:  break;",
          "5396:       str++;",
          "5397:       max_chars_to_read = max_chars_to_read - 1;",
          "5402:   return(val);",
          "5403: }",
          "5409: u_int64_t ndpi_bytestream_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5410:   u_int64_t val;",
          "5411:   val = 0;",
          "5413:   while(max_chars_to_read > 0 && *str >= '0' && *str <= '9') {",
          "5414:     val *= 10;",
          "5415:     val += *str - '0';",
          "5416:     str++;",
          "5417:     max_chars_to_read = max_chars_to_read - 1;",
          "5420:   return(val);",
          "5421: }",
          "5425: u_int64_t ndpi_bytestream_dec_or_hex_to_number64(const u_int8_t *str, u_int16_t max_chars_to_read,",
          "5426:        u_int16_t *bytes_read) {",
          "5427:   u_int64_t val;",
          "5428:   val = 0;",
          "5429:   if(max_chars_to_read <= 2 || str[0] != '0' || str[1] != 'x') {",
          "5430:     return(ndpi_bytestream_to_number64(str, max_chars_to_read, bytes_read));",
          "5431:   } else {",
          "5433:     str += 2;",
          "5434:     max_chars_to_read -= 2;",
          "5436:     while(max_chars_to_read > 0) {",
          "5437:       if(*str >= '0' && *str <= '9') {",
          "5438:  val *= 16;",
          "5439:  val += *str - '0';",
          "5440:       } else if(*str >= 'a' && *str <= 'f') {",
          "5441:  val *= 16;",
          "5442:  val += *str + 10 - 'a';",
          "5443:       } else if(*str >= 'A' && *str <= 'F') {",
          "5444:  val *= 16;",
          "5445:  val += *str + 10 - 'A';",
          "5446:       } else {",
          "5447:  break;",
          "5449:       str++;",
          "5450:       max_chars_to_read = max_chars_to_read - 1;",
          "5454:   return(val);",
          "5455: }",
          "5459: u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "5460:   u_int32_t val;",
          "5461:   u_int16_t read = 0;",
          "5462:   u_int16_t oldread;",
          "5463:   u_int32_t c;",
          "5466:   oldread = read;",
          "5467:   c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);",
          "5468:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5469:     return(0);",
          "5471:   read++;",
          "5472:   val = c << 24;",
          "5473:   oldread = read;",
          "5474:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5475:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5476:     return(0);",
          "5478:   read++;",
          "5479:   val = val + (c << 16);",
          "5480:   oldread = read;",
          "5481:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5482:   if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')",
          "5483:     return(0);",
          "5485:   read++;",
          "5486:   val = val + (c << 8);",
          "5487:   oldread = read;",
          "5488:   c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);",
          "5489:   if(c > 255 || oldread == read || max_chars_to_read == read)",
          "5490:     return(0);",
          "5492:   val = val + c;",
          "5496:   return(htonl(val));",
          "5497: }",
          "5502: void ndpi_parse_packet_line_info(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5503:   u_int32_t a;",
          "5504:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5506:   if((packet->payload_packet_len < 3) || (packet->payload == NULL))",
          "5507:     return;",
          "5509:   if(packet->packet_lines_parsed_complete != 0)",
          "5510:     return;",
          "5512:   packet->packet_lines_parsed_complete = 1;",
          "5513:   ndpi_reset_packet_line_info(packet);",
          "5515:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5516:   packet->line[packet->parsed_lines].len = 0;",
          "5518:   for(a = 0; ((a+1) < packet->payload_packet_len) && (packet->parsed_lines < NDPI_MAX_PARSE_LINES_PER_PACKET); a++) {",
          "5519:     if((packet->payload[a] == 0x0d) && (packet->payload[a+1] == 0x0a)) {",
          "5522:       if(((a + 3) < packet->payload_packet_len)",
          "5523:   && (packet->payload[a+2] == 0x0d)",
          "5524:   && (packet->payload[a+3] == 0x0a)) {",
          "5527:  u_int32_t a1 = a + 4;",
          "5529:  diff = packet->payload_packet_len - a1;",
          "5531:  if(diff > 0) {",
          "5532:    diff = ndpi_min(diff, sizeof(flow->initial_binary_bytes));",
          "5533:    memcpy(&flow->initial_binary_bytes, &packet->payload[a1], diff);",
          "5534:    flow->initial_binary_bytes_len = diff;",
          "5536:       }",
          "5538:       packet->line[packet->parsed_lines].len =",
          "5539:  (u_int16_t)(((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5542:       if(packet->parsed_lines == 0 && packet->line[0].len >= NDPI_STATICSTRING_LEN(\"HTTP/1.X 200 \") &&",
          "5543:   strncasecmp((const char *) packet->line[0].ptr, \"HTTP/1.\", NDPI_STATICSTRING_LEN(\"HTTP/1.\")) == 0 &&",
          "5545:   packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.X \")] < '6') {",
          "5546:  packet->http_response.ptr = &packet->line[0].ptr[NDPI_STATICSTRING_LEN(\"HTTP/1.1 \")];",
          "5547:  packet->http_response.len = packet->line[0].len - NDPI_STATICSTRING_LEN(\"HTTP/1.1 \");",
          "5548:  packet->http_num_headers++;",
          "5551:  if(packet->payload_packet_len >= 12) {",
          "5552:    char buf[4];",
          "5555:    strncpy(buf, (char *) &packet->payload[9], 3);",
          "5556:    buf[3] = '\\0';",
          "5558:    flow->http.response_status_code = atoi(buf);",
          "5560:    if((flow->http.response_status_code < 100) || (flow->http.response_status_code > 509))",
          "5563:       }",
          "5566:       if(packet->line[packet->parsed_lines].len > NDPI_STATICSTRING_LEN(\"Server:\") + 1 &&",
          "5567:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5568:        \"Server:\", NDPI_STATICSTRING_LEN(\"Server:\")) == 0) {",
          "5570:  if(packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")] == ' ') {",
          "5571:    packet->server_line.ptr =",
          "5572:      &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\") + 1];",
          "5573:    packet->server_line.len =",
          "5574:      packet->line[packet->parsed_lines].len - (NDPI_STATICSTRING_LEN(\"Server:\") + 1);",
          "5575:  } else {",
          "5576:    packet->server_line.ptr = &packet->line[packet->parsed_lines].ptr[NDPI_STATICSTRING_LEN(\"Server:\")];",
          "5577:    packet->server_line.len = packet->line[packet->parsed_lines].len - NDPI_STATICSTRING_LEN(\"Server:\");",
          "5579:  packet->http_num_headers++;",
          "5580:       }",
          "5582:       if(packet->line[packet->parsed_lines].len > 6 &&",
          "5583:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Host:\", 5) == 0) {",
          "5585:  if(packet->line[packet->parsed_lines].ptr[5] == ' ') {",
          "5586:    packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[6];",
          "5587:    packet->host_line.len = packet->line[packet->parsed_lines].len - 6;",
          "5588:  } else {",
          "5589:    packet->host_line.ptr = &packet->line[packet->parsed_lines].ptr[5];",
          "5590:    packet->host_line.len = packet->line[packet->parsed_lines].len - 5;",
          "5592:  packet->http_num_headers++;",
          "5593:       }",
          "5595:       if(packet->line[packet->parsed_lines].len > 17 &&",
          "5596:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Forwarded-For:\", 16) == 0) {",
          "5598:  if(packet->line[packet->parsed_lines].ptr[16] == ' ') {",
          "5599:    packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[17];",
          "5600:    packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 17;",
          "5601:  } else {",
          "5602:    packet->forwarded_line.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5603:    packet->forwarded_line.len = packet->line[packet->parsed_lines].len - 16;",
          "5605:  packet->http_num_headers++;",
          "5606:       }",
          "5608:       if(packet->line[packet->parsed_lines].len > 14 &&",
          "5609:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Type: \", 14) == 0 ||",
          "5610:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type: \", 14) == 0)) {",
          "5611:  packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[14];",
          "5612:  packet->content_line.len = packet->line[packet->parsed_lines].len - 14;",
          "5614:  while((packet->content_line.len > 0) && (packet->content_line.ptr[0] == ' '))",
          "5615:    packet->content_line.len--, packet->content_line.ptr++;",
          "5617:  packet->http_num_headers++;",
          "5618:       }",
          "5620:       if((packet->content_line.len == 0) && (packet->line[packet->parsed_lines].len > 13) &&",
          "5621:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-type:\", 13) == 0)) {",
          "5622:  packet->content_line.ptr = &packet->line[packet->parsed_lines].ptr[13];",
          "5623:  packet->content_line.len = packet->line[packet->parsed_lines].len - 13;",
          "5624:  packet->http_num_headers++;",
          "5625:       }",
          "5627:       if(packet->content_line.len > 0) {",
          "5629:  char separator[] = {';', '\\r', '\\0'};",
          "5630:  int i;",
          "5632:  for(i = 0; separator[i] != '\\0'; i++) {",
          "5633:    char *c = memchr((char *) packet->content_line.ptr, separator[i], packet->content_line.len);",
          "5635:    if(c != NULL)",
          "5636:      packet->content_line.len = c - (char *) packet->content_line.ptr;",
          "5638:       }",
          "5641:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5642:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept: \", 8) == 0) {",
          "5643:  packet->accept_line.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5644:  packet->accept_line.len = packet->line[packet->parsed_lines].len - 8;",
          "5645:  packet->http_num_headers++;",
          "5646:       }",
          "5648:       if(packet->line[packet->parsed_lines].len > 9 &&",
          "5649:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Referer: \", 9) == 0) {",
          "5650:  packet->referer_line.ptr = &packet->line[packet->parsed_lines].ptr[9];",
          "5651:  packet->referer_line.len = packet->line[packet->parsed_lines].len - 9;",
          "5652:  packet->http_num_headers++;",
          "5653:       }",
          "5655:       if(packet->line[packet->parsed_lines].len > 12 &&",
          "5656:   (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-Agent: \", 12) == 0 ||",
          "5657:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"User-agent: \", 12) == 0)) {",
          "5658:  packet->user_agent_line.ptr = &packet->line[packet->parsed_lines].ptr[12];",
          "5659:  packet->user_agent_line.len = packet->line[packet->parsed_lines].len - 12;",
          "5660:  packet->http_num_headers++;",
          "5661:       }",
          "5663:       if(packet->line[packet->parsed_lines].len > 18 &&",
          "5664:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Encoding: \", 18) == 0) {",
          "5665:  packet->http_encoding.ptr = &packet->line[packet->parsed_lines].ptr[18];",
          "5666:  packet->http_encoding.len = packet->line[packet->parsed_lines].len - 18;",
          "5667:  packet->http_num_headers++;",
          "5668:       }",
          "5670:       if(packet->line[packet->parsed_lines].len > 19 &&",
          "5671:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Transfer-Encoding: \", 19) == 0) {",
          "5672:  packet->http_transfer_encoding.ptr = &packet->line[packet->parsed_lines].ptr[19];",
          "5673:  packet->http_transfer_encoding.len = packet->line[packet->parsed_lines].len - 19;",
          "5674:  packet->http_num_headers++;",
          "5675:       }",
          "5677:       if(packet->line[packet->parsed_lines].len > 16 &&",
          "5678:   ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Length: \", 16) == 0) ||",
          "5679:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"content-length: \", 16) == 0))) {",
          "5680:  packet->http_contentlen.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5681:  packet->http_contentlen.len = packet->line[packet->parsed_lines].len - 16;",
          "5682:  packet->http_num_headers++;",
          "5683:       }",
          "5685:       if(packet->line[packet->parsed_lines].len > 21 &&",
          "5686:   ((strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Content-Disposition: \", 21) == 0))) {",
          "5687:  packet->content_disposition_line.ptr = &packet->line[packet->parsed_lines].ptr[21];",
          "5688:  packet->content_disposition_line.len = packet->line[packet->parsed_lines].len - 21;",
          "5689:  packet->http_num_headers++;",
          "5690:       }",
          "5692:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5693:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Cookie: \", 8) == 0) {",
          "5694:  packet->http_cookie.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5695:  packet->http_cookie.len = packet->line[packet->parsed_lines].len - 8;",
          "5696:  packet->http_num_headers++;",
          "5697:       }",
          "5699:       if(packet->line[packet->parsed_lines].len > 8 &&",
          "5700:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Origin: \", 8) == 0) {",
          "5701:  packet->http_origin.ptr = &packet->line[packet->parsed_lines].ptr[8];",
          "5702:  packet->http_origin.len = packet->line[packet->parsed_lines].len - 8;",
          "5703:  packet->http_num_headers++;",
          "5704:       }",
          "5706:       if(packet->line[packet->parsed_lines].len > 16 &&",
          "5707:   strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"X-Session-Type: \", 16) == 0) {",
          "5708:  packet->http_x_session_type.ptr = &packet->line[packet->parsed_lines].ptr[16];",
          "5709:  packet->http_x_session_type.len = packet->line[packet->parsed_lines].len - 16;",
          "5710:  packet->http_num_headers++;",
          "5711:       }",
          "5718:       if((packet->line[packet->parsed_lines].len > 6 &&",
          "5719:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Date: \", 6) == 0 ||",
          "5720:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Vary: \", 6) == 0 ||",
          "5721:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"ETag: \", 6) == 0)) ||",
          "5722:   (packet->line[packet->parsed_lines].len > 8 &&",
          "5723:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Pragma: \", 8) == 0) ||",
          "5724:   (packet->line[packet->parsed_lines].len > 9 &&",
          "5725:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Expires: \", 9) == 0) ||",
          "5726:   (packet->line[packet->parsed_lines].len > 12 &&",
          "5727:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Set-Cookie: \", 12) == 0 ||",
          "5728:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Keep-Alive: \", 12) == 0 ||",
          "5729:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Connection: \", 12) == 0)) ||",
          "5730:   (packet->line[packet->parsed_lines].len > 15 &&",
          "5731:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Last-Modified: \", 15) == 0 ||",
          "5732:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Ranges: \", 15) == 0)) ||",
          "5733:   (packet->line[packet->parsed_lines].len > 17 &&",
          "5734:    (strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Language: \", 17) == 0 ||",
          "5735:     strncasecmp((const char *) packet->line[packet->parsed_lines].ptr, \"Accept-Encoding: \", 17) == 0)) ||",
          "5736:   (packet->line[packet->parsed_lines].len > 27 &&",
          "5737:    strncasecmp((const char *) packet->line[packet->parsed_lines].ptr,",
          "5738:         \"Upgrade-Insecure-Requests: \", 27) == 0)) {",
          "5740:  packet->http_num_headers++;",
          "5741:       }",
          "5743:       if(packet->line[packet->parsed_lines].len == 0) {",
          "5744:  packet->empty_line_position = a;",
          "5745:  packet->empty_line_position_set = 1;",
          "5746:       }",
          "5748:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5749:  return;",
          "5751:       packet->parsed_lines++;",
          "5752:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 2];",
          "5753:       packet->line[packet->parsed_lines].len = 0;",
          "5757:   }",
          "5759:   if(packet->parsed_lines >= 1) {",
          "5760:     packet->line[packet->parsed_lines].len =",
          "5761:       (u_int16_t)(((size_t) &packet->payload[packet->payload_packet_len]) -",
          "5762:     ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5763:     packet->parsed_lines++;",
          "5765: }",
          "5769: void ndpi_parse_packet_line_info_any(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5770:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5771:   u_int32_t a;",
          "5772:   u_int16_t end = packet->payload_packet_len;",
          "5774:   if(packet->packet_lines_parsed_complete != 0)",
          "5775:     return;",
          "5777:   packet->packet_lines_parsed_complete = 1;",
          "5778:   packet->parsed_lines = 0;",
          "5780:   if(packet->payload_packet_len == 0)",
          "5781:     return;",
          "5783:   packet->line[packet->parsed_lines].ptr = packet->payload;",
          "5784:   packet->line[packet->parsed_lines].len = 0;",
          "5786:   for(a = 0; a < end; a++) {",
          "5787:     if(packet->payload[a] == 0x0a) {",
          "5788:       packet->line[packet->parsed_lines].len = (u_int16_t)(",
          "5789:           ((size_t) &packet->payload[a]) - ((size_t) packet->line[packet->parsed_lines].ptr));",
          "5791:       if(a > 0 && packet->payload[a - 1] == 0x0d)",
          "5792:  packet->line[packet->parsed_lines].len--;",
          "5794:       if(packet->parsed_lines >= (NDPI_MAX_PARSE_LINES_PER_PACKET - 1))",
          "5795:  break;",
          "5797:       packet->parsed_lines++;",
          "5798:       packet->line[packet->parsed_lines].ptr = &packet->payload[a + 1];",
          "5799:       packet->line[packet->parsed_lines].len = 0;",
          "5801:       if((a + 1) >= packet->payload_packet_len)",
          "5802:  break;",
          "5807: }",
          "5811: u_int16_t ndpi_check_for_email_address(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5812:            u_int16_t counter) {",
          "5813:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5815:   NDPI_LOG_DBG2(ndpi_str, \"called ndpi_check_for_email_address\\n\");",
          "5817:   if(packet->payload_packet_len > counter && ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5818:            (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5819:            (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5820:            packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5821:     NDPI_LOG_DBG2(ndpi_str, \"first letter\\n\");",
          "5822:     counter++;",
          "5823:     while(packet->payload_packet_len > counter &&",
          "5824:    ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5825:     (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5826:     (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5827:     packet->payload[counter] == '-' || packet->payload[counter] == '_' ||",
          "5828:     packet->payload[counter] == '.')) {",
          "5829:       NDPI_LOG_DBG2(ndpi_str, \"further letter\\n\");",
          "5831:       if(packet->payload_packet_len > counter && packet->payload[counter] == '@') {",
          "5832:  NDPI_LOG_DBG2(ndpi_str, \"@\\n\");",
          "5834:  while(packet->payload_packet_len > counter &&",
          "5835:        ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') ||",
          "5836:         (packet->payload[counter] >= 'A' && packet->payload[counter] <= 'Z') ||",
          "5837:         (packet->payload[counter] >= '0' && packet->payload[counter] <= '9') ||",
          "5838:         packet->payload[counter] == '-' || packet->payload[counter] == '_')) {",
          "5839:    NDPI_LOG_DBG2(ndpi_str, \"letter\\n\");",
          "5841:    if(packet->payload_packet_len > counter && packet->payload[counter] == '.') {",
          "5842:      NDPI_LOG_DBG2(ndpi_str, \".\\n\");",
          "5844:      if(packet->payload_packet_len > counter + 1 &&",
          "5845:         ((packet->payload[counter] >= 'a' && packet->payload[counter] <= 'z') &&",
          "5846:   (packet->payload[counter + 1] >= 'a' && packet->payload[counter + 1] <= 'z'))) {",
          "5847:        NDPI_LOG_DBG2(ndpi_str, \"two letters\\n\");",
          "5848:        counter += 2;",
          "5849:        if(packet->payload_packet_len > counter &&",
          "5850:    (packet->payload[counter] == ' ' || packet->payload[counter] == ';')) {",
          "5851:   NDPI_LOG_DBG2(ndpi_str, \"whitespace1\\n\");",
          "5852:   return(counter);",
          "5853:        } else if(packet->payload_packet_len > counter && packet->payload[counter] >= 'a' &&",
          "5854:    packet->payload[counter] <= 'z') {",
          "5855:   NDPI_LOG_DBG2(ndpi_str, \"one letter\\n\");",
          "5856:   counter++;",
          "5859:     NDPI_LOG_DBG2(ndpi_str, \"whitespace2\\n\");",
          "5866:       NDPI_LOG_DBG2(ndpi_str, \"whitespace3\\n\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "5877:        } else {",
          "5878:   return(0);",
          "5879:        }",
          "5880:      }",
          "5881:    }",
          "5883:  }",
          "5884:       }",
          "5885:     }",
          "5887:   }",
          "5889: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "5905: #endif",
          "5935:   }",
          "5994:       }",
          "5995:     }",
          "5999:   }",
          "6027:   }",
          "6037: #ifdef CODE_UNUSED",
          "6042: #endif",
          "6062:       return(1);",
          "6063:     return(0);",
          "6064:   }",
          "6083:       return(1);",
          "6085:     return(0);",
          "6086:   }",
          "6145:     return(buf);",
          "6146:   }",
          "6164:   }",
          "6220:       }",
          "6236:  }",
          "6237:       }",
          "6242:  ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "6258:     ndpi_protocol proto, char *buf, u_int buf_len) {",
          "6268:   }",
          "6284:   }",
          "6289:     switch(category) {",
          "6290:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6291:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6292:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6293:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6294:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6298:     default:",
          "6301:     }",
          "6371:   }",
          "6401:   }",
          "6437:       break;",
          "6440:       break;",
          "6443:       break;",
          "6446:       break;",
          "6447:     }",
          "6448:   }",
          "6460:   }",
          "6475:   }",
          "6515:   }",
          "6582:   }",
          "6614: #ifdef DEBUG",
          "6625: #endif",
          "6642: #ifdef DEBUG",
          "6645: #endif",
          "6661:   }",
          "6688:     }",
          "6698:   }",
          "6748: #if 1",
          "6750: #else",
          "6753: #endif",
          "6782: #if 1",
          "6784: #else",
          "6787: #endif",
          "6810:   }",
          "6819:   }",
          "6829: #ifdef WIN32",
          "6851: #endif",
          "6862:   }",
          "6864: #ifdef CODE_UNUSED",
          "6883: #endif",
          "6890: #ifdef HAVE_LIBGCRYPT",
          "6892: #endif",
          "6913: #ifdef NDPI_ENABLE_DEBUG_MESSAGES",
          "6915: #endif",
          "6978: #if 0",
          "6983: #endif",
          "7037:   }",
          "7061:   }",
          "7080:   }",
          "7098:   }",
          "7111:   }",
          "7145:   }",
          "7171:   }",
          "7218: #ifdef DGA_DEBUG",
          "7220: #endif",
          "7251:   }",
          "7339:    }",
          "7372:  }",
          "7488:        }",
          "7489:      }",
          "7515:    rc = 1;",
          "7528:       }",
          "7538:   }",
          "",
          "[Removed Lines]",
          "5882:    return(0);",
          "5886:     return(0);",
          "5892:   void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,",
          "5893:           const char **func, u_int32_t *line) {",
          "5897:     if(ndpi_str->ndpi_debug_print_file != NULL)",
          "5900:     if(ndpi_str->ndpi_debug_print_function != NULL)",
          "5904:   }",
          "5909:   u_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,",
          "5910:      u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags) {",
          "5911:     return(ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));",
          "5912:   }",
          "5916:   void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5917:       u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5918:     struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5920:     ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5922:     if(src != NULL) {",
          "5923:       NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5925:       if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5926:  NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5927:     }",
          "5929:     if(dst != NULL) {",
          "5930:       NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5932:       if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5933:  NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5934:     }",
          "5939:   u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5940:     return(flow->detected_protocol_stack[1]);",
          "5941:   }",
          "5945:   void ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5946:          u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5947:     if(!flow)",
          "5948:       return;",
          "5950:     flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5951:       flow->detected_protocol_stack[1] = lower_detected_protocol;",
          "5952:   }",
          "5956:   void ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5957:            u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5958:     struct ndpi_packet_struct *packet = &flow->packet;",
          "5964:     if(!packet)",
          "5965:       return;",
          "5967:     packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "5968:       packet->detected_protocol_stack[1] = lower_detected_protocol;",
          "5969:   }",
          "5979:   void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5980:     u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5981:     if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5982:       upper_detected_protocol = lower_detected_protocol;",
          "5984:     if(upper_detected_protocol == lower_detected_protocol)",
          "5985:       lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5987:     if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5988:       if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "5989:   (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5990:  if(ndpi_str->proto_defaults[upper_detected_protocol].subprotocol_count > 0) {",
          "5991:    lower_detected_protocol = upper_detected_protocol;",
          "5992:    upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5993:  }",
          "5997:     ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5998:     ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "6003:   void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6004:     ndpi_protocol_category_t protocol_category) {",
          "6005:     flow->category = protocol_category;",
          "6006:   }",
          "6011:   void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {",
          "6012:     int a;",
          "6014:     for(a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "6015:       packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "6016:   }",
          "6020:   void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {",
          "6021:     if(flow) {",
          "6022:       int a;",
          "6024:       for(a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "6025:  flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "6026:     }",
          "6031:   void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip) {",
          "6032:     memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "6033:   }",
          "6039:   int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip) {",
          "6040:     return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "6041:   }",
          "6048:   int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "6050:     if(packet->iphv6 != NULL) {",
          "6051:       if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "6052:   packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "6053:   packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "6054:   packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "6055:  return(1);",
          "6057:       return(0);",
          "6058:     }",
          "6061:     if(packet->iph->saddr == ip->ipv4)",
          "6069:   int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "6071:     if(packet->iphv6 != NULL) {",
          "6072:       if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "6073:   packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "6074:   packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "6075:   packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "6076:  return(1);",
          "6078:       return(0);",
          "6079:     }",
          "6082:     if(packet->iph->saddr == ip->ipv4)",
          "6092:   void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "6093:     NDPI_PROTOCOL_IP_clear(ip);",
          "6096:     if(packet->iphv6 != NULL) {",
          "6097:       ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "6098:       ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "6099:       ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "6100:       ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "6101:     } else {",
          "6103:       ip->ipv4 = packet->iph->saddr;",
          "6104:     }",
          "6105:   }",
          "6111:   void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "6112:     NDPI_PROTOCOL_IP_clear(ip);",
          "6114:     if(packet->iphv6 != NULL) {",
          "6115:       ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "6116:       ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "6117:       ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "6118:       ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "6120:     } else",
          "6121:       ip->ipv4 = packet->iph->daddr;",
          "6122:   }",
          "6126:   u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {",
          "6127:     return(ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "6128:     ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "6129:   }",
          "6133:   char *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len) {",
          "6134:     const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "6136:     if(ndpi_is_ipv6(ip)) {",
          "6137:       if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "6138:  buf[0] = '\\0';",
          "6140:       return(buf);",
          "6141:     }",
          "6143:     snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "6151:   int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {",
          "6152:     int rv = -1;",
          "6153:     memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "6155:     if(strchr(ip_str, '.')) {",
          "6156:       if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "6157:  rv = 4;",
          "6158:     } else {",
          "6159:       if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "6160:  rv = 6;",
          "6161:     }",
          "6163:     return(rv);",
          "6168:   u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str,",
          "6169:          u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "6170:     u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "6171:     return(ntohs(val));",
          "6172:   }",
          "6176:   u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {",
          "6177:     return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "6178:   }",
          "6182:   u_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {",
          "6183:     return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "6184:   }",
          "6188:   u_int16_t ndpi_get_upper_proto(ndpi_protocol proto) {",
          "6189:     return((proto.app_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.app_protocol : proto.master_protocol);",
          "6190:   }",
          "6194:   ndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6195:             struct ndpi_flow_struct *flow, u_int8_t proto,",
          "6196:             u_int32_t shost /* host byte order */, u_int16_t sport,",
          "6197:             u_int32_t dhost /* host byte order */, u_int16_t dport) {",
          "6198:     u_int32_t rc;",
          "6199:     struct in_addr addr;",
          "6200:     ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "6201:     u_int8_t user_defined_proto;",
          "6203:     if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "6204:       rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "6206:       if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "6207:  if(flow && (proto == IPPROTO_UDP) &&",
          "6208:     NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "6209:    ;",
          "6210:  else {",
          "6211:    ret.app_protocol = rc,",
          "6212:      ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "6214:    if(ret.app_protocol == ret.master_protocol)",
          "6215:      ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "6217:    ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "6218:    return(ret);",
          "6219:  }",
          "6222:       rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "6223:       if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "6224:  if(flow && (proto == IPPROTO_UDP) &&",
          "6225:     NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "6226:    ;",
          "6227:  else {",
          "6228:    ret.app_protocol = rc;",
          "6230:    if(rc == NDPI_PROTOCOL_TLS)",
          "6231:      goto check_guessed_skype;",
          "6232:    else {",
          "6233:      ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "6234:      return(ret);",
          "6235:    }",
          "6239:     check_guessed_skype:",
          "6240:       addr.s_addr = htonl(shost);",
          "6241:       if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "6243:       } else {",
          "6244:  addr.s_addr = htonl(dhost);",
          "6245:  if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "6246:    ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "6247:       }",
          "6248:     } else",
          "6249:       ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "6251:     ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "6252:     return(ret);",
          "6253:   }",
          "6257:   char *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,",
          "6259:     if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "6260:       if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "6261:  snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);",
          "6262:       else",
          "6263:  snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "6264:     } else",
          "6265:       snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "6267:     return(buf);",
          "6272:   char *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,",
          "6273:       ndpi_protocol proto, char *buf, u_int buf_len) {",
          "6274:     if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "6275:       if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "6276:  snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "6277:    ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "6278:       else",
          "6279:  snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "6280:     } else",
          "6281:       snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "6283:     return(buf);",
          "6288:   int ndpi_is_custom_category(ndpi_protocol_category_t category) {",
          "6295:       return(1);",
          "6296:       break;",
          "6299:       return(0);",
          "6300:       break;",
          "6302:   }",
          "6306:   void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6307:          ndpi_protocol_category_t category,",
          "6308:          char *name) {",
          "6309:     if(!name)",
          "6310:       return;",
          "6312:     switch(category) {",
          "6313:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6314:       snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6315:       break;",
          "6317:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6318:       snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6319:       break;",
          "6321:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6322:       snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6323:       break;",
          "6325:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6326:       snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6327:       break;",
          "6329:     case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6330:       snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6331:       break;",
          "6333:     default:",
          "6334:       break;",
          "6335:     }",
          "6336:   }",
          "6340:   const char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6341:          ndpi_protocol_category_t category) {",
          "6342:     if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "6343:       static char b[24];",
          "6345:       if(!ndpi_str)",
          "6346:  snprintf(b, sizeof(b), \"NULL nDPI\");",
          "6347:       else",
          "6348:  snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);",
          "6349:       return(b);",
          "6350:     }",
          "6352:     if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "6353:       switch(category) {",
          "6354:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6355:  return(ndpi_str->custom_category_labels[0]);",
          "6356:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6357:  return(ndpi_str->custom_category_labels[1]);",
          "6358:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6359:  return(ndpi_str->custom_category_labels[2]);",
          "6360:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6361:  return(ndpi_str->custom_category_labels[3]);",
          "6362:       case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6363:  return(ndpi_str->custom_category_labels[4]);",
          "6364:       case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "6365:  return(\"Code should not use this internal constant\");",
          "6366:       default:",
          "6367:  return(\"Unspecified\");",
          "6368:       }",
          "6369:     } else",
          "6370:       return(categories[category]);",
          "6375:   ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,",
          "6376:          ndpi_protocol proto) {",
          "6377:     if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6378:       return(proto.category);",
          "6381:     else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||",
          "6382:      (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "6383:       if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6384:  return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "6385:     } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6386:       return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "6388:     return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "6389:   }",
          "6393:   char *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6394:        u_int16_t proto_id) {",
          "6395:     if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6396:        (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6397:        (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6398:       proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6400:     return(ndpi_str->proto_defaults[proto_id].protoName);",
          "6405:   ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,",
          "6406:           u_int16_t proto_id) {",
          "6407:     if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6408:        (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6409:        (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6410:       proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6412:     return(ndpi_str->proto_defaults[proto_id].protoBreed);",
          "6413:   }",
          "6417:   char *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6418:       ndpi_protocol_breed_t breed_id) {",
          "6419:     switch(breed_id) {",
          "6420:     case NDPI_PROTOCOL_SAFE:",
          "6421:       return(\"Safe\");",
          "6422:       break;",
          "6423:     case NDPI_PROTOCOL_ACCEPTABLE:",
          "6424:       return(\"Acceptable\");",
          "6425:       break;",
          "6426:     case NDPI_PROTOCOL_FUN:",
          "6427:       return(\"Fun\");",
          "6428:       break;",
          "6429:     case NDPI_PROTOCOL_UNSAFE:",
          "6430:       return(\"Unsafe\");",
          "6431:       break;",
          "6432:     case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "6433:       return(\"Potentially Dangerous\");",
          "6434:       break;",
          "6435:     case NDPI_PROTOCOL_TRACKER_ADS:",
          "6436:       return(\"Tracker/Ads\");",
          "6438:     case NDPI_PROTOCOL_DANGEROUS:",
          "6439:       return(\"Dangerous\");",
          "6441:     case NDPI_PROTOCOL_UNRATED:",
          "6442:       return(\"Unrated\");",
          "6444:     default:",
          "6445:       return(\"???\");",
          "6452:   int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {",
          "6453:     int i;",
          "6455:     for(i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6456:       if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "6457:  return(i);",
          "6459:     return(-1);",
          "6464:   int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {",
          "6465:     int i;",
          "6467:     for(i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "6468:       const char *name = ndpi_category_get_name(ndpi_str, i);",
          "6470:       if(strcasecmp(cat, name) == 0)",
          "6471:  return(i);",
          "6472:     }",
          "6474:     return(-1);",
          "6479:   void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6480:     int i;",
          "6482:     for(i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6483:       printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,",
          "6484:       ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "6485:       ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "6486:       ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));",
          "6487:   }",
          "6495:   char *ndpi_strnstr(const char *s, const char *find, size_t slen) {",
          "6496:     char c;",
          "6497:     size_t len;",
          "6499:     if((c = *find++) != '\\0') {",
          "6500:       len = strnlen(find, slen);",
          "6501:       do {",
          "6502:  char sc;",
          "6504:  do {",
          "6505:    if(slen-- < 1 || (sc = *s++) == '\\0')",
          "6506:      return(NULL);",
          "6507:  } while(sc != c);",
          "6508:  if(len > slen)",
          "6509:    return(NULL);",
          "6510:       } while(strncmp(s, find, len) != 0);",
          "6511:       s--;",
          "6512:     }",
          "6514:     return((char *) s);",
          "6522:   const char * ndpi_strncasestr(const char *str1, const char *str2, size_t len) {",
          "6523:     size_t str1_len = strnlen(str1, len);",
          "6524:     size_t str2_len = strlen(str2);",
          "6525:     size_t i;",
          "6527:     for(i = 0; i < (str1_len - str2_len + 1); i++){",
          "6528:       if(str1[0] == '\\0')",
          "6529:  return NULL;",
          "6530:       else if(strncasecmp(str1, str2, str2_len) == 0)",
          "6531:  return(str1);",
          "6533:       str1++;",
          "6534:     }",
          "6536:     return NULL;",
          "6537:   }",
          "6541:   int ndpi_match_prefix(const u_int8_t *payload,",
          "6542:    size_t payload_len, const char *str, size_t str_len) {",
          "6543:     int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "6545:     return(rc);",
          "6546:   }",
          "6550:   int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,",
          "6551:         u_int string_to_match_len, ndpi_protocol_match_result *ret_match,",
          "6552:         u_int8_t is_host_match) {",
          "6553:     AC_TEXT_t ac_input_text;",
          "6554:     ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "6555:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6556:     int rc;",
          "6558:     if((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "6559:       return(NDPI_PROTOCOL_UNKNOWN);",
          "6561:     if(!automa->ac_automa_finalized) {",
          "6562:       printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initialization()\\n\", __FILE__, __LINE__);",
          "6564:     }",
          "6566:     ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "6567:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6570:       As ac_automata_search can detect partial matches and continue the search process",
          "6571:       in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6572:       and in this case return it",
          "6574:     if((rc == 0) && (match.number != 0))",
          "6575:       rc = 1;",
          "6578:     ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,",
          "6579:       ret_match->protocol_breed = match.breed;",
          "6581:     return(rc ? match.number : 0);",
          "6586:   static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {",
          "6589:     if((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))",
          "6590:       return(0);",
          "6592:     switch(previous_proto) {",
          "6593:     case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6594:     case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6595:       if(new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6596:  return(1);",
          "6597:     }",
          "6599:     return(0);",
          "6600:   }",
          "6604:   static u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6605:        struct ndpi_flow_struct *flow, char *string_to_match,",
          "6606:        u_int string_to_match_len, u_int16_t master_protocol_id,",
          "6607:        ndpi_protocol_match_result *ret_match, u_int8_t is_host_match) {",
          "6608:     int matching_protocol_id;",
          "6609:     struct ndpi_packet_struct *packet = &flow->packet;",
          "6611:     matching_protocol_id =",
          "6612:       ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);",
          "6615:     {",
          "6616:       char m[256];",
          "6617:       int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6619:       strncpy(m, string_to_match, len);",
          "6620:       m[len] = '\\0';",
          "6622:       NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,",
          "6623:       ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6624:     }",
          "6627:     if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "6628:        (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6630:       packet->detected_protocol_stack[1] = master_protocol_id,",
          "6631:  packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6633:       flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6634:  flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6636:       if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6637:  flow->category = ret_match->protocol_category;",
          "6639:       return(packet->detected_protocol_stack[0]);",
          "6640:     }",
          "6643:     string_to_match[string_to_match_len] = '\\0';",
          "6644:     NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6647:     ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6648:       ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;",
          "6650:     return(NDPI_PROTOCOL_UNKNOWN);",
          "6651:   }",
          "6655:   void ndpi_check_subprotocol_risk(struct ndpi_flow_struct *flow, u_int16_t subprotocol_id) {",
          "6656:     switch(subprotocol_id) {",
          "6657:     case NDPI_PROTOCOL_ANYDESK:",
          "6659:       break;",
          "6660:     }",
          "6665:   u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6666:      struct ndpi_flow_struct *flow,",
          "6667:      char *string_to_match, u_int string_to_match_len,",
          "6668:      ndpi_protocol_match_result *ret_match,",
          "6669:      u_int16_t master_protocol_id) {",
          "6670:     u_int16_t rc, buf_len, i;",
          "6671:     ndpi_protocol_category_t id;",
          "6672:     char buf[96];",
          "6674:     buf_len = ndpi_min(string_to_match_len, sizeof(buf)-2);",
          "6675:     for(i=0; i<buf_len; i++) buf[i] = tolower(string_to_match[i]);",
          "6677:     buf[i] = '\\0';",
          "6679:     rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, buf, i,",
          "6680:            master_protocol_id, ret_match, 1);",
          "6681:     id = ret_match->protocol_category;",
          "6683:     if(ndpi_get_custom_category_match(ndpi_str, buf, i, &id) != -1) {",
          "6685:  flow->category = ret_match->protocol_category = id;",
          "6686:  rc = master_protocol_id;",
          "6687:       }",
          "6690:     if(ndpi_str->risky_domain_automa.ac_automa != NULL) {",
          "6691:       u_int16_t rc1 = ndpi_match_string(ndpi_str->risky_domain_automa.ac_automa, buf);",
          "6693:       if(rc1 > 0)",
          "6694:  ndpi_set_risk(flow, NDPI_RISKY_DOMAIN);",
          "6695:     }",
          "6697:     return(rc);",
          "6702:   int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct,",
          "6703:        struct ndpi_flow_struct *flow,",
          "6704:        u_int16_t master_protocol, char *name, u_int name_len) {",
          "6705:     ndpi_protocol_match_result ret_match;",
          "6706:     u_int16_t subproto, what_len;",
          "6707:     char *what;",
          "6709:     if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6710:       what = &name[1], what_len = name_len - 1;",
          "6711:     else",
          "6712:       what = name, what_len = name_len;",
          "6714:     subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len,",
          "6715:         &ret_match, master_protocol);",
          "6717:     if(subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6718:       ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6719:       ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6720:       return(1);",
          "6721:     } else",
          "6722:       return(0);",
          "6723:   }",
          "6727:   u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6728:         struct ndpi_flow_struct *flow,",
          "6729:         char *string_to_match, u_int string_to_match_len,",
          "6730:         ndpi_protocol_match_result *ret_match,",
          "6731:         u_int16_t master_protocol_id) {",
          "6732:     return(ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6733:       master_protocol_id, ret_match, 0));",
          "6734:   }",
          "6738:   int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6739:    ndpi_automa *automa, char *bigram_to_match) {",
          "6740:     AC_TEXT_t ac_input_text;",
          "6741:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6742:     int rc;",
          "6744:     if((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6745:       return(-1);",
          "6747:     if(!automa->ac_automa_finalized) {",
          "6749:       ndpi_finalize_initialization(ndpi_str);",
          "6751:       printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initialization()\\n\", __FILE__, __LINE__);",
          "6754:     }",
          "6756:     ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6757:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6760:       As ac_automata_search can detect partial matches and continue the search process",
          "6761:       in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6762:       and in this case return it",
          "6764:     if((rc == 0) && (match.number != 0))",
          "6765:       rc = 1;",
          "6767:     return(rc ? match.number : 0);",
          "6768:   }",
          "6772:   int ndpi_match_trigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6773:    ndpi_automa *automa, char *trigram_to_match) {",
          "6774:     AC_TEXT_t ac_input_text;",
          "6775:     AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6776:     int rc;",
          "6778:     if((automa->ac_automa == NULL) || (trigram_to_match == NULL))",
          "6779:       return(-1);",
          "6781:     if(!automa->ac_automa_finalized) {",
          "6783:       ndpi_finalize_initialization(ndpi_str);",
          "6785:       printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initialization()\\n\", __FILE__, __LINE__);",
          "6788:     }",
          "6790:     ac_input_text.astring = trigram_to_match, ac_input_text.length = 3;",
          "6791:     rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6794:       As ac_automata_search can detect partial matches and continue the search process",
          "6795:       in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6796:       and in this case return it",
          "6798:     if((rc == 0) && (match.number != 0))",
          "6799:       rc = 1;",
          "6801:     if(ndpi_verbose_dga_detection && rc && match.number) {",
          "6802:       printf(\"[%s:%d] [NDPI] Trigram %c%c%c\\n\",",
          "6803:       __FILE__, __LINE__,",
          "6804:       trigram_to_match[0],",
          "6805:       trigram_to_match[1],",
          "6806:       trigram_to_match[2]);",
          "6807:     }",
          "6809:     return(rc ? match.number : 0);",
          "6814:   void ndpi_free_flow(struct ndpi_flow_struct *flow) {",
          "6815:     if(flow) {",
          "6816:       ndpi_free_flow_data(flow);",
          "6817:       ndpi_free(flow);",
          "6818:     }",
          "6823:   char *ndpi_revision() {",
          "6824:     return(NDPI_GIT_RELEASE);",
          "6825:   }",
          "6832:   int gettimeofday(struct timeval *tp, struct timezone *tzp) {",
          "6836:     static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6838:     SYSTEMTIME system_time;",
          "6839:     FILETIME file_time;",
          "6840:     uint64_t time;",
          "6842:     GetSystemTime(&system_time);",
          "6843:     SystemTimeToFileTime(&system_time, &file_time);",
          "6844:     time = ((uint64_t) file_time.dwLowDateTime);",
          "6845:     time += ((uint64_t) file_time.dwHighDateTime) << 32;",
          "6847:     tp->tv_sec = (long) ((time - EPOCH) / 10000000L);",
          "6848:     tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6849:     return(0);",
          "6850:   }",
          "6853:   int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {",
          "6854:     int i;",
          "6856:     for(i = 0; i < NDPI_NUM_FDS_BITS; i++) {",
          "6857:       if(a.fds_bits[i] & b.fds_bits[i])",
          "6858:  return(1);",
          "6859:     }",
          "6861:     return(0);",
          "6865:   int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {",
          "6866:     int i;",
          "6868:     for(i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6869:       if(a.fds_bits[i] != 0)",
          "6870:  return(0);",
          "6872:     return(1);",
          "6873:   }",
          "6875:   void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {",
          "6876:     int i;",
          "6878:     for(i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6879:       printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6881:     printf(\"\\n\");",
          "6882:   }",
          "6885:   u_int16_t ndpi_get_api_version() {",
          "6886:     return(NDPI_API_VERSION);",
          "6887:   }",
          "6889:   const char *ndpi_get_gcrypt_version(void) {",
          "6891:     return gcry_check_version(NULL);",
          "6893:     return NULL;",
          "6894:   }",
          "6896:   ndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "6897:     return(ndpi_str->proto_defaults);",
          "6898:   }",
          "6900:   u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6901:     return(ndpi_str->ndpi_num_supported_protocols);",
          "6902:   }",
          "6904:   u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6905:     return(ndpi_str->ndpi_num_custom_protocols);",
          "6906:   }",
          "6908:   u_int ndpi_get_ndpi_detection_module_size() {",
          "6909:     return(sizeof(struct ndpi_detection_module_struct));",
          "6910:   }",
          "6912:   void ndpi_set_debug_bitmask(struct ndpi_detection_module_struct *ndpi_str, NDPI_PROTOCOL_BITMASK debug_bitmask) {",
          "6914:     ndpi_str->debug_bitmask = debug_bitmask;",
          "6916:   }",
          "6918:   void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){",
          "6919:     ndpi_str->ndpi_log_level = l;",
          "6920:   }",
          "6925:   struct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries) {",
          "6926:     struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6928:     if(!c)",
          "6929:       return(NULL);",
          "6931:     c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));",
          "6933:     if(!c->entries) {",
          "6934:       ndpi_free(c);",
          "6935:       return(NULL);",
          "6936:     } else",
          "6937:       c->num_entries = num_entries;",
          "6939:     return(c);",
          "6940:   }",
          "6942:   void ndpi_lru_free_cache(struct ndpi_lru_cache *c) {",
          "6943:     ndpi_free(c->entries);",
          "6944:     ndpi_free(c);",
          "6945:   }",
          "6947:   u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key,",
          "6948:           u_int16_t *value, u_int8_t clean_key_when_found) {",
          "6949:     u_int32_t slot = key % c->num_entries;",
          "6951:     if(c->entries[slot].is_full) {",
          "6953:       if(clean_key_when_found)",
          "6954:  c->entries[slot].is_full = 0;",
          "6955:       return(1);",
          "6956:     } else",
          "6957:       return(0);",
          "6958:   }",
          "6960:   void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {",
          "6961:     u_int32_t slot = key % c->num_entries;",
          "6963:     c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;",
          "6964:   }",
          "6969:     This function tells if it's possible to further dissect a given flow",
          "6970:     0 - All possible dissection has been completed",
          "6971:     1 - Additional dissection is possible",
          "6973:   u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,",
          "6974:        struct ndpi_flow_struct *flow) {",
          "6975:     u_int16_t proto =",
          "6976:       flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "6979:     printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,",
          "6980:     flow->detected_protocol_stack[0],",
          "6981:     flow->detected_protocol_stack[1],",
          "6982:     proto);",
          "6985:     switch(proto) {",
          "6986:     case NDPI_PROTOCOL_TLS:",
          "6987:     case NDPI_PROTOCOL_DTLS:",
          "6988:       if(flow->l4.tcp.tls.certificate_processed) return(0);",
          "6990:       if(flow->l4.tcp.tls.num_tls_blocks <= ndpi_str->num_tls_blocks_to_follow) {",
          "6992:  return(1);",
          "6993:       }",
          "6994:       break;",
          "6996:     case NDPI_PROTOCOL_HTTP:",
          "6997:       if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "6998:  return(1);",
          "6999:       break;",
          "7001:     case NDPI_PROTOCOL_DNS:",
          "7002:     case NDPI_PROTOCOL_MDNS:",
          "7003:       if(flow->protos.dns.num_answers == 0)",
          "7004:  return(1);",
          "7005:       break;",
          "7007:     case NDPI_PROTOCOL_FTP_CONTROL:",
          "7008:     case NDPI_PROTOCOL_MAIL_POP:",
          "7009:     case NDPI_PROTOCOL_MAIL_IMAP:",
          "7010:     case NDPI_PROTOCOL_MAIL_SMTP:",
          "7011:       if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "7012:  return(1);",
          "7013:       break;",
          "7015:     case NDPI_PROTOCOL_SSH:",
          "7016:       if((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "7017:  return(1);",
          "7018:       break;",
          "7020:     case NDPI_PROTOCOL_TELNET:",
          "7021:       if(!flow->protos.telnet.password_detected)",
          "7022:  return(1);",
          "7023:       break;",
          "7025:     case NDPI_PROTOCOL_SKYPE:",
          "7026:       if(flow->extra_packets_func)",
          "7027:  return(1);",
          "7028:       break;",
          "7030:     case NDPI_PROTOCOL_QUIC:",
          "7031:       if(flow->extra_packets_func)",
          "7032:         return(1);",
          "7033:       break;",
          "7034:     }",
          "7036:     return(0);",
          "7041:   const char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {",
          "7042:     switch(proto) {",
          "7043:     case ndpi_l4_proto_unknown:",
          "7044:       return(\"\");",
          "7045:       break;",
          "7047:     case ndpi_l4_proto_tcp_only:",
          "7048:       return(\"TCP\");",
          "7049:       break;",
          "7051:     case ndpi_l4_proto_udp_only:",
          "7052:       return(\"UDP\");",
          "7053:       break;",
          "7055:     case ndpi_l4_proto_tcp_and_udp:",
          "7056:       return(\"TCP/UDP\");",
          "7057:       break;",
          "7058:     }",
          "7060:     return(\"\");",
          "7065:   ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,",
          "7066:          u_int16_t ndpi_proto_id) {",
          "7067:     if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "7068:       u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "7069:       NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "7071:       if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)",
          "7072:  return(ndpi_l4_proto_tcp_only);",
          "7073:       else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)",
          "7074:  return(ndpi_l4_proto_udp_only);",
          "7075:       else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)",
          "7076:  return(ndpi_l4_proto_tcp_and_udp);",
          "7077:     }",
          "7084:   ndpi_ptree_t *ndpi_ptree_create(void) {",
          "7085:     ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "7087:     if(tree) {",
          "7088:       tree->v4 = ndpi_patricia_new(32);",
          "7089:       tree->v6 = ndpi_patricia_new(128);",
          "7091:       if((!tree->v4) || (!tree->v6)) {",
          "7092:  ndpi_ptree_destroy(tree);",
          "7093:  return(NULL);",
          "7094:       }",
          "7095:     }",
          "7097:     return(tree);",
          "7102:   void ndpi_ptree_destroy(ndpi_ptree_t *tree) {",
          "7103:     if(tree) {",
          "7104:       if(tree->v4)",
          "7105:  ndpi_patricia_destroy(tree->v4, free_ptree_data);",
          "7106:       if(tree->v6)",
          "7107:  ndpi_patricia_destroy(tree->v6, free_ptree_data);",
          "7109:       ndpi_free(tree);",
          "7110:     }",
          "7115:   int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr,",
          "7116:    u_int8_t bits, u_int64_t user_data) {",
          "7117:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "7118:     ndpi_patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "7119:     ndpi_prefix_t prefix;",
          "7120:     ndpi_patricia_node_t *node;",
          "7122:     if(bits > ptree->maxbits)",
          "7123:       return(-1);",
          "7125:     if(is_v6)",
          "7126:       ndpi_fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "7127:     else",
          "7128:       ndpi_fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "7131:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "7133:     if(node && (node->prefix->bitlen == bits))",
          "7134:       return(-2);",
          "7136:     node = ndpi_patricia_lookup(ptree, &prefix);",
          "7138:     if(node != NULL) {",
          "7139:       node->value.u.uv64 = user_data;",
          "7141:       return(0);",
          "7142:     }",
          "7144:     return(-3);",
          "7149:   int ndpi_ptree_match_addr(ndpi_ptree_t *tree,",
          "7150:        const ndpi_ip_addr_t *addr, u_int64_t *user_data) {",
          "7151:     u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "7152:     ndpi_patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "7153:     ndpi_prefix_t prefix;",
          "7154:     ndpi_patricia_node_t *node;",
          "7155:     int bits = ptree->maxbits;",
          "7157:     if(is_v6)",
          "7158:       ndpi_fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "7159:     else",
          "7160:       ndpi_fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "7162:     node = ndpi_patricia_search_best(ptree, &prefix);",
          "7164:     if(node) {",
          "7167:       return(0);",
          "7168:     }",
          "7170:     return(-1);",
          "7176:   u_int32_t ndpi_quick_hash(unsigned char *str, u_int str_len) {",
          "7177:     u_int32_t hash = 5381, i;",
          "7179:     for(i=0; i<str_len; i++)",
          "7182:     return hash;",
          "7183:   }",
          "7187:   void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {",
          "7188:     ndpi_MD5_CTX ctx;",
          "7190:     ndpi_MD5Init(&ctx);",
          "7191:     ndpi_MD5Update(&ctx, data, data_len);",
          "7192:     ndpi_MD5Final(hash, &ctx);",
          "7193:   }",
          "7197:   static int enough(int a, int b) {",
          "7198:     u_int8_t percentage = 20;",
          "7200:     if(b <= 1) return(0);",
          "7201:     if(a == 0) return(1);",
          "7203:     if(b > (((a+1)*percentage)/100)) return(1);",
          "7205:     return(0);",
          "7206:   }",
          "7210:   static u_int8_t endsWith(char *str, char *ends, u_int8_t ends_len) {",
          "7211:     u_int str_len = str ? strlen(str) : 0;",
          "7212:     u_int8_t rc;",
          "7214:     if(str_len < ends_len) return(0);",
          "7216:     rc = (strncmp(&str[str_len-ends_len], ends, ends_len) != 0) ? 0 : 1;",
          "7219:     printf(\"[DGA] %s / %s [rc: %u]\\n\", str, ends, rc);",
          "7222:     return(rc);",
          "7223:   }",
          "7227:   static int ndpi_is_trigram_char(char c) {",
          "7228:     if(isdigit(c) || (c == '.') || (c == '-'))",
          "7229:       return(0);",
          "7230:     else",
          "7231:       return(1);",
          "7232:   }",
          "7236:   static int ndpi_is_vowel(char c) {",
          "7237:     switch(c) {",
          "7238:     case 'a':",
          "7239:     case 'e':",
          "7240:     case 'i':",
          "7241:     case 'o':",
          "7242:     case 'u':",
          "7243:     case 'y': // Not a real vowel...",
          "7244:     case 'x': // Not a real vowel...",
          "7245:       return(1);",
          "7246:       break;",
          "7248:     default:",
          "7249:       return(0);",
          "7250:     }",
          "7255:   int ndpi_check_dga_name(struct ndpi_detection_module_struct *ndpi_str,",
          "7256:      struct ndpi_flow_struct *flow,",
          "7257:      char *name, u_int8_t is_hostname) {",
          "7258:     if(ndpi_dga_function != NULL) {",
          "7260:       int rc = ndpi_dga_function(name, is_hostname);",
          "7262:       if(rc) {",
          "7263:  if(flow)",
          "7264:    ndpi_set_risk(flow, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7265:       }",
          "7267:       return(rc);",
          "7268:     } else {",
          "7269:       int len, rc = 0, trigram_char_skip = 0;",
          "7270:       u_int8_t max_num_char_repetitions = 0, last_char = 0, num_char_repetitions = 0, num_dots = 0, num_trigram_dots = 0;",
          "7271:       u_int8_t max_domain_element_len = 0, curr_domain_element_len = 0, first_element_is_numeric = 1;",
          "7273:       if((!name)",
          "7274:   || (strchr(name, '_') != NULL)",
          "7275:   || (endsWith(name, \"in-addr.arpa\", 12))",
          "7276:   || (endsWith(name, \"ip6.arpa\", 8))",
          "7278:   || (endsWith(name, \".local\", 6))",
          "7279:   || (endsWith(name, \".lan\", 4))",
          "7280:   || (endsWith(name, \".home\", 5))",
          "7281:   )",
          "7282:  return(0);",
          "7284:       if(flow && (flow->packet.detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN))",
          "7287:       if(strncmp(name, \"www.\", 4) == 0)",
          "7288:  name = &name[4];",
          "7290:       if(ndpi_verbose_dga_detection)",
          "7291:  printf(\"[DGA check] %s\\n\", name);",
          "7293:       len = strlen(name);",
          "7295:       if(len >= 5) {",
          "7296:  int i, j, num_found = 0, num_impossible = 0, num_bigram_checks = 0,",
          "7297:    num_trigram_found = 0, num_trigram_checked = 0, num_dash = 0,",
          "7298:    num_digits = 0, num_vowels = 0, num_trigram_vowels = 0, num_words = 0, skip_next_bigram = 0;",
          "7299:  char tmp[128], *word, *tok_tmp;",
          "7300:  u_int max_tmp_len = sizeof(tmp)-1;",
          "7302:  len = snprintf(tmp, max_tmp_len, \"%s\", name);",
          "7303:  if(len < 0) {",
          "7305:    if(ndpi_verbose_dga_detection)",
          "7306:      printf(\"[DGA] Too short\");",
          "7308:    return(0);",
          "7309:  } else",
          "7310:    tmp[len < max_tmp_len ? len : max_tmp_len] = '\\0';",
          "7312:  for(i=0, j=0; (i<len) && (j<max_tmp_len); i++) {",
          "7313:    tmp[j] = tolower(name[i]);",
          "7315:    if(tmp[j] == '.') {",
          "7316:      num_dots++;",
          "7317:    } else if(num_dots == 0) {",
          "7318:      if(!isdigit(tmp[j]))",
          "7319:        first_element_is_numeric = 0;",
          "7320:    }",
          "7322:    if(ndpi_is_vowel(tmp[j]))",
          "7323:      num_vowels++;",
          "7325:    if(last_char == tmp[j]) {",
          "7326:      if(++num_char_repetitions > max_num_char_repetitions)",
          "7327:        max_num_char_repetitions = num_char_repetitions;",
          "7328:    } else",
          "7329:      num_char_repetitions = 1, last_char = tmp[j];",
          "7331:    if(isdigit(tmp[j])) {",
          "7332:      num_digits++;",
          "7334:      if(((j+2)<len) && isdigit(tmp[j+1]) && (tmp[j+2] == '.')) {",
          "7336:        if(num_digits < 4)",
          "7338:      }",
          "7341:    switch(tmp[j]) {",
          "7342:    case '.':",
          "7343:    case '-':",
          "7344:    case '_':",
          "7345:    case '/':",
          "7346:    case ')':",
          "7347:    case '(':",
          "7348:    case ';':",
          "7349:    case ':':",
          "7350:    case '[':",
          "7351:    case ']':",
          "7352:    case ' ':",
          "7354:        Domain/word separator chars",
          "7356:        NOTE:",
          "7357:        this function is used also to detect other type of issues",
          "7358:        such as invalid/suspiciuous user agent",
          "7360:      if(curr_domain_element_len > max_domain_element_len)",
          "7361:        max_domain_element_len = curr_domain_element_len;",
          "7363:      curr_domain_element_len = 0;",
          "7364:      break;",
          "7366:    default:",
          "7367:      curr_domain_element_len++;",
          "7368:      break;",
          "7369:    }",
          "7371:    j++;",
          "7375:    return(0);",
          "7377:  if(curr_domain_element_len > max_domain_element_len)",
          "7378:    max_domain_element_len = curr_domain_element_len;",
          "7380:  if(ndpi_verbose_dga_detection)",
          "7381:    printf(\"[DGA] [max_num_char_repetitions: %u][max_domain_element_len: %u]\\n\",",
          "7382:    max_num_char_repetitions, max_domain_element_len);",
          "7384:  if(",
          "7385:     (is_hostname",
          "7386:      && (num_dots > 5)",
          "7387:      && (!first_element_is_numeric)",
          "7388:      )",
          "7389:     || (max_num_char_repetitions > 5 /* num or consecutive repeated chars */)",
          "7391:       In case of a name with too many consecutive chars an alert is triggered",
          "7392:       This is the case for instance of the wildcard DNS query used by NetBIOS",
          "7393:       (ckaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) and that can be exploited",
          "7394:       for reflection attacks",
          "7395:       - https://www.akamai.com/uk/en/multimedia/documents/state-of-the-internet/ddos-reflection-netbios-name-server-rpc-portmap-sentinel-udp-threat-advisory.pdf",
          "7396:       - http://ubiqx.org/cifs/NetBIOS.html",
          "7398:     || ((max_domain_element_len >= 19 /* word too long. Example bbcbedxhgjmdobdprmen.com */) && ((num_char_repetitions > 1) || (num_digits > 1)))",
          "7399:     ) {",
          "7400:    if(flow) ndpi_set_risk(flow, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7402:    if(ndpi_verbose_dga_detection)",
          "7403:      printf(\"[DGA] Found!\");",
          "7405:    return(1);",
          "7406:  }",
          "7408:  tmp[j] = '\\0';",
          "7409:  len = j;",
          "7411:  for(word = strtok_r(tmp, \".\", &tok_tmp); ; word = strtok_r(NULL, \".\", &tok_tmp)) {",
          "7412:    if(!word) break;",
          "7414:    num_words++;",
          "7416:    if(strlen(word) < 3) continue;",
          "7418:    if(ndpi_verbose_dga_detection)",
          "7419:      printf(\"-> word(%s) [%s][len: %u]\\n\", word, name, (unsigned int)strlen(word));",
          "7421:    trigram_char_skip = 0;",
          "7423:    for(i = 0; word[i+1] != '\\0'; i++) {",
          "7424:      switch(word[i]) {",
          "7425:      case '-':",
          "7426:        num_dash++;",
          "7428:   Let's check for double+consecutive --",
          "7429:   that are usually ok",
          "7430:   r2---sn-uxaxpu5ap5-2n5e.gvt1.com",
          "7432:        if(word[i+1] == '-')",
          "7435:      case '_':",
          "7436:      case ':':",
          "7437:        continue;",
          "7438:        break;",
          "7440:      case '.':",
          "7441:        continue;",
          "7442:        break;",
          "7443:      }",
          "7444:      num_bigram_checks++;",
          "7446:      if(ndpi_verbose_dga_detection)",
          "7447:        printf(\"-> Checking %c%c\\n\", word[i], word[i+1]);",
          "7449:      if(ndpi_match_bigram(ndpi_str,",
          "7450:      &ndpi_str->impossible_bigrams_automa,",
          "7451:      &word[i])) {",
          "7452:        if(ndpi_verbose_dga_detection)",
          "7453:   printf(\"IMPOSSIBLE %s\\n\", &word[i]);",
          "7455:        num_impossible++;",
          "7456:      } else {",
          "7457:        if(!skip_next_bigram) {",
          "7458:   if(ndpi_match_bigram(ndpi_str, &ndpi_str->bigrams_automa, &word[i])) {",
          "7459:     num_found++, skip_next_bigram = 1;",
          "7460:   }",
          "7461:        } else",
          "7462:   skip_next_bigram = 0;",
          "7463:      }",
          "7465:      if((num_trigram_dots < 2) && (word[i+2] != '\\0')) {",
          "7466:        if(ndpi_verbose_dga_detection)",
          "7467:   printf(\"***> %s [trigram_char_skip: %u]\\n\", &word[i], trigram_char_skip);",
          "7469:        if(ndpi_is_trigram_char(word[i]) && ndpi_is_trigram_char(word[i+1]) && ndpi_is_trigram_char(word[i+2])) {",
          "7470:   if(trigram_char_skip) {",
          "7471:     trigram_char_skip--;",
          "7472:   } else {",
          "7473:     num_trigram_checked++;",
          "7475:     if(ndpi_match_trigram(ndpi_str, &ndpi_str->trigrams_automa, &word[i]))",
          "7476:       num_trigram_found++, trigram_char_skip = 2 /* 1 char overlap */;",
          "7477:     else if(ndpi_verbose_dga_detection)",
          "7478:       printf(\"[NDPI] NO Trigram %c%c%c\\n\", word[i], word[i+1], word[i+2]);",
          "7481:     num_trigram_vowels += ndpi_is_vowel(word[i]) + ndpi_is_vowel(word[i+1]) + ndpi_is_vowel(word[i+2]);",
          "7482:   }",
          "7483:        } else {",
          "7484:   if(word[i] == '.')",
          "7485:     num_trigram_dots++;",
          "7487:   trigram_char_skip = 0;",
          "7493:  if(ndpi_verbose_dga_detection)",
          "7494:    printf(\"[%s][num_found: %u][num_impossible: %u][num_digits: %u][num_bigram_checks: %u][num_vowels: %u/%u][num_trigram_vowels: %u][num_trigram_found: %u/%u][vowels: %u][rc: %u]\\n\",",
          "7495:    name, num_found, num_impossible, num_digits, num_bigram_checks, num_vowels, len, num_trigram_vowels,",
          "7496:    num_trigram_checked, num_trigram_found, num_vowels, rc);",
          "7498:  if((len > 16) && (num_dots < 3) && ((num_vowels*4) < (len-num_dots))) {",
          "7499:    if((num_trigram_checked > 2) && (num_trigram_vowels >= (num_trigram_found-1)))",
          "7501:    else",
          "7502:      rc = 1;",
          "7503:  }",
          "7505:  if(num_bigram_checks",
          "7506:     && (num_dots > 0)",
          "7507:     && ((num_found == 0) || ((num_digits > 5) && (num_words <= 3))",
          "7508:         || enough(num_found, num_impossible)",
          "7509:         || ((num_trigram_checked > 2)",
          "7510:      && ((num_trigram_found < (num_trigram_checked/2))",
          "7511:          || ((num_trigram_vowels < (num_trigram_found-1)) && (num_dash == 0) && (num_dots > 1)))",
          "7512:      )",
          "7513:         )",
          "7514:     )",
          "7517:  if((num_trigram_checked > 2) && (num_vowels == 0))",
          "7518:    rc = 1;",
          "7520:  if(num_dash > 2)",
          "7521:    rc = 0;",
          "7523:  if(ndpi_verbose_dga_detection) {",
          "7524:    if(rc)",
          "7525:      printf(\"DGA %s [num_found: %u][num_impossible: %u]\\n\",",
          "7526:      name, num_found, num_impossible);",
          "7527:  }",
          "7530:       if(ndpi_verbose_dga_detection)",
          "7531:  printf(\"[DGA] Result: %u\\n\", rc);",
          "7533:       if(rc && flow)",
          "7534:  ndpi_set_risk(flow, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7536:       return(rc);",
          "7537:     }",
          "",
          "[Added Lines]",
          "5877:      } else {",
          "5878:        return(0);",
          "5882:  return(0);",
          "5886:   return(0);",
          "5887: }",
          "5892: void ndpi_debug_get_last_log_function_line(struct ndpi_detection_module_struct *ndpi_str, const char **file,",
          "5893:         const char **func, u_int32_t *line) {",
          "5897:   if(ndpi_str->ndpi_debug_print_file != NULL)",
          "5900:   if(ndpi_str->ndpi_debug_print_function != NULL)",
          "5904: }",
          "5909: u_int8_t ndpi_detection_get_l4(const u_int8_t *l3, u_int16_t l3_len, const u_int8_t **l4_return,",
          "5910:           u_int16_t *l4_len_return, u_int8_t *l4_protocol_return, u_int32_t flags) {",
          "5911:   return(ndpi_detection_get_l4_internal(NULL, l3, l3_len, l4_return, l4_len_return, l4_protocol_return, flags));",
          "5912: }",
          "5916: void ndpi_set_detected_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5917:     u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5918:   struct ndpi_id_struct *src = flow->src, *dst = flow->dst;",
          "5920:   ndpi_int_change_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5922:   if(src != NULL) {",
          "5923:     NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, upper_detected_protocol);",
          "5925:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5926:       NDPI_ADD_PROTOCOL_TO_BITMASK(src->detected_protocol_bitmask, lower_detected_protocol);",
          "5927:   }",
          "5929:   if(dst != NULL) {",
          "5930:     NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, upper_detected_protocol);",
          "5932:     if(lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "5933:       NDPI_ADD_PROTOCOL_TO_BITMASK(dst->detected_protocol_bitmask, lower_detected_protocol);",
          "5935: }",
          "5939: u_int16_t ndpi_get_flow_masterprotocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow) {",
          "5940:   return(flow->detected_protocol_stack[1]);",
          "5941: }",
          "5945: void ndpi_int_change_flow_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5946:        u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5947:   if(!flow)",
          "5948:     return;",
          "5950:   flow->detected_protocol_stack[0] = upper_detected_protocol,",
          "5951:     flow->detected_protocol_stack[1] = lower_detected_protocol;",
          "5952: }",
          "5956: void ndpi_int_change_packet_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5957:          u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5958:   struct ndpi_packet_struct *packet = &flow->packet;",
          "5964:   if(!packet)",
          "5965:     return;",
          "5967:   packet->detected_protocol_stack[0] = upper_detected_protocol,",
          "5968:     packet->detected_protocol_stack[1] = lower_detected_protocol;",
          "5969: }",
          "5979: void ndpi_int_change_protocol(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "5980:          u_int16_t upper_detected_protocol, u_int16_t lower_detected_protocol) {",
          "5981:   if((upper_detected_protocol == NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol != NDPI_PROTOCOL_UNKNOWN))",
          "5982:     upper_detected_protocol = lower_detected_protocol;",
          "5984:   if(upper_detected_protocol == lower_detected_protocol)",
          "5985:     lower_detected_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "5987:   if((upper_detected_protocol != NDPI_PROTOCOL_UNKNOWN) && (lower_detected_protocol == NDPI_PROTOCOL_UNKNOWN)) {",
          "5988:     if((flow->guessed_host_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "5989:        (upper_detected_protocol != flow->guessed_host_protocol_id)) {",
          "5990:       if(ndpi_str->proto_defaults[upper_detected_protocol].subprotocol_count > 0) {",
          "5991:  lower_detected_protocol = upper_detected_protocol;",
          "5992:  upper_detected_protocol = flow->guessed_host_protocol_id;",
          "5997:   ndpi_int_change_flow_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5998:   ndpi_int_change_packet_protocol(ndpi_str, flow, upper_detected_protocol, lower_detected_protocol);",
          "5999: }",
          "6003: void ndpi_int_change_category(struct ndpi_detection_module_struct *ndpi_str, struct ndpi_flow_struct *flow,",
          "6004:          ndpi_protocol_category_t protocol_category) {",
          "6005:   flow->category = protocol_category;",
          "6006: }",
          "6011: void ndpi_int_reset_packet_protocol(struct ndpi_packet_struct *packet) {",
          "6012:   int a;",
          "6014:   for(a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "6015:     packet->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "6016: }",
          "6020: void ndpi_int_reset_protocol(struct ndpi_flow_struct *flow) {",
          "6021:   if(flow) {",
          "6022:     int a;",
          "6024:     for(a = 0; a < NDPI_PROTOCOL_SIZE; a++)",
          "6025:       flow->detected_protocol_stack[a] = NDPI_PROTOCOL_UNKNOWN;",
          "6027: }",
          "6031: void NDPI_PROTOCOL_IP_clear(ndpi_ip_addr_t *ip) {",
          "6032:   memset(ip, 0, sizeof(ndpi_ip_addr_t));",
          "6033: }",
          "6039: int NDPI_PROTOCOL_IP_is_set(const ndpi_ip_addr_t *ip) {",
          "6040:   return(memcmp(ip, \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\", sizeof(ndpi_ip_addr_t)) != 0);",
          "6041: }",
          "6048: int ndpi_packet_src_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "6050:   if(packet->iphv6 != NULL) {",
          "6051:     if(packet->iphv6->ip6_src.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "6052:        packet->iphv6->ip6_src.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "6053:        packet->iphv6->ip6_src.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "6054:        packet->iphv6->ip6_src.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "6061:   if(packet->iph->saddr == ip->ipv4)",
          "6062:     return(1);",
          "6063:   return(0);",
          "6064: }",
          "6069: int ndpi_packet_dst_ip_eql(const struct ndpi_packet_struct *packet, const ndpi_ip_addr_t *ip) {",
          "6071:   if(packet->iphv6 != NULL) {",
          "6072:     if(packet->iphv6->ip6_dst.u6_addr.u6_addr32[0] == ip->ipv6.u6_addr.u6_addr32[0] &&",
          "6073:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[1] == ip->ipv6.u6_addr.u6_addr32[1] &&",
          "6074:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[2] == ip->ipv6.u6_addr.u6_addr32[2] &&",
          "6075:        packet->iphv6->ip6_dst.u6_addr.u6_addr32[3] == ip->ipv6.u6_addr.u6_addr32[3])",
          "6082:   if(packet->iph->saddr == ip->ipv4)",
          "6083:     return(1);",
          "6085:   return(0);",
          "6086: }",
          "6092: void ndpi_packet_src_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "6093:   NDPI_PROTOCOL_IP_clear(ip);",
          "6096:   if(packet->iphv6 != NULL) {",
          "6097:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_src.u6_addr.u6_addr32[0];",
          "6098:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_src.u6_addr.u6_addr32[1];",
          "6099:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_src.u6_addr.u6_addr32[2];",
          "6100:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_src.u6_addr.u6_addr32[3];",
          "6101:   } else {",
          "6103:     ip->ipv4 = packet->iph->saddr;",
          "6104:   }",
          "6105: }",
          "6111: void ndpi_packet_dst_ip_get(const struct ndpi_packet_struct *packet, ndpi_ip_addr_t *ip) {",
          "6112:   NDPI_PROTOCOL_IP_clear(ip);",
          "6114:   if(packet->iphv6 != NULL) {",
          "6115:     ip->ipv6.u6_addr.u6_addr32[0] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[0];",
          "6116:     ip->ipv6.u6_addr.u6_addr32[1] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[1];",
          "6117:     ip->ipv6.u6_addr.u6_addr32[2] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[2];",
          "6118:     ip->ipv6.u6_addr.u6_addr32[3] = packet->iphv6->ip6_dst.u6_addr.u6_addr32[3];",
          "6120:   } else",
          "6121:     ip->ipv4 = packet->iph->daddr;",
          "6122: }",
          "6126: u_int8_t ndpi_is_ipv6(const ndpi_ip_addr_t *ip) {",
          "6127:   return(ip->ipv6.u6_addr.u6_addr32[1] != 0 || ip->ipv6.u6_addr.u6_addr32[2] != 0 ||",
          "6128:   ip->ipv6.u6_addr.u6_addr32[3] != 0);",
          "6129: }",
          "6133: char *ndpi_get_ip_string(const ndpi_ip_addr_t *ip, char *buf, u_int buf_len) {",
          "6134:   const u_int8_t *a = (const u_int8_t *) &ip->ipv4;",
          "6136:   if(ndpi_is_ipv6(ip)) {",
          "6137:     if(inet_ntop(AF_INET6, &ip->ipv6.u6_addr, buf, buf_len) == NULL)",
          "6138:       buf[0] = '\\0';",
          "6143:   snprintf(buf, buf_len, \"%u.%u.%u.%u\", a[0], a[1], a[2], a[3]);",
          "6145:   return(buf);",
          "6146: }",
          "6151: int ndpi_parse_ip_string(const char *ip_str, ndpi_ip_addr_t *parsed_ip) {",
          "6152:   int rv = -1;",
          "6153:   memset(parsed_ip, 0, sizeof(*parsed_ip));",
          "6155:   if(strchr(ip_str, '.')) {",
          "6156:     if(inet_pton(AF_INET, ip_str, &parsed_ip->ipv4) > 0)",
          "6157:       rv = 4;",
          "6158:   } else {",
          "6159:     if(inet_pton(AF_INET6, ip_str, &parsed_ip->ipv6) > 0)",
          "6160:       rv = 6;",
          "6163:   return(rv);",
          "6164: }",
          "6168: u_int16_t ntohs_ndpi_bytestream_to_number(const u_int8_t *str,",
          "6169:        u_int16_t max_chars_to_read, u_int16_t *bytes_read) {",
          "6170:   u_int16_t val = ndpi_bytestream_to_number(str, max_chars_to_read, bytes_read);",
          "6171:   return(ntohs(val));",
          "6172: }",
          "6176: u_int8_t ndpi_is_proto(ndpi_protocol proto, u_int16_t p) {",
          "6177:   return(((proto.app_protocol == p) || (proto.master_protocol == p)) ? 1 : 0);",
          "6178: }",
          "6182: u_int16_t ndpi_get_lower_proto(ndpi_protocol proto) {",
          "6183:   return((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.master_protocol : proto.app_protocol);",
          "6184: }",
          "6188: u_int16_t ndpi_get_upper_proto(ndpi_protocol proto) {",
          "6189:   return((proto.app_protocol != NDPI_PROTOCOL_UNKNOWN) ? proto.app_protocol : proto.master_protocol);",
          "6190: }",
          "6194: ndpi_protocol ndpi_guess_undetected_protocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6195:           struct ndpi_flow_struct *flow, u_int8_t proto,",
          "6196:           u_int32_t shost /* host byte order */, u_int16_t sport,",
          "6197:           u_int32_t dhost /* host byte order */, u_int16_t dport) {",
          "6198:   u_int32_t rc;",
          "6199:   struct in_addr addr;",
          "6200:   ndpi_protocol ret = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED};",
          "6201:   u_int8_t user_defined_proto;",
          "6203:   if((proto == IPPROTO_TCP) || (proto == IPPROTO_UDP)) {",
          "6204:     rc = ndpi_search_tcp_or_udp_raw(ndpi_str, flow, proto, shost, dhost, sport, dport);",
          "6206:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "6207:       if(flow && (proto == IPPROTO_UDP) &&",
          "6208:   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "6209:  ;",
          "6210:       else {",
          "6211:  ret.app_protocol = rc,",
          "6212:    ret.master_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "6214:  if(ret.app_protocol == ret.master_protocol)",
          "6215:    ret.master_protocol = NDPI_PROTOCOL_UNKNOWN;",
          "6217:  ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "6218:  return(ret);",
          "6220:     }",
          "6222:     rc = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "6223:     if(rc != NDPI_PROTOCOL_UNKNOWN) {",
          "6224:       if(flow && (proto == IPPROTO_UDP) &&",
          "6225:   NDPI_COMPARE_PROTOCOL_TO_BITMASK(flow->excluded_protocol_bitmask, rc) && is_udp_guessable_protocol(rc))",
          "6226:  ;",
          "6227:       else {",
          "6228:  ret.app_protocol = rc;",
          "6230:  if(rc == NDPI_PROTOCOL_TLS)",
          "6231:    goto check_guessed_skype;",
          "6232:  else {",
          "6233:    ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "6234:    return(ret);",
          "6237:     }",
          "6239:   check_guessed_skype:",
          "6240:     addr.s_addr = htonl(shost);",
          "6241:     if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE) {",
          "6242:       ret.app_protocol = NDPI_PROTOCOL_SKYPE;",
          "6243:     } else {",
          "6244:       addr.s_addr = htonl(dhost);",
          "6245:       if(ndpi_network_ptree_match(ndpi_str, &addr) == NDPI_PROTOCOL_SKYPE)",
          "6247:     }",
          "6248:   } else",
          "6249:     ret.app_protocol = ndpi_guess_protocol_id(ndpi_str, flow, proto, sport, dport, &user_defined_proto);",
          "6251:   ret.category = ndpi_get_proto_category(ndpi_str, ret);",
          "6252:   return(ret);",
          "6253: }",
          "6257: char *ndpi_protocol2id(struct ndpi_detection_module_struct *ndpi_str,",
          "6258:          ndpi_protocol proto, char *buf, u_int buf_len) {",
          "6259:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "6260:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "6261:       snprintf(buf, buf_len, \"%u.%u\", proto.master_protocol, proto.app_protocol);",
          "6262:     else",
          "6263:       snprintf(buf, buf_len, \"%u\", proto.master_protocol);",
          "6264:   } else",
          "6265:     snprintf(buf, buf_len, \"%u\", proto.app_protocol);",
          "6267:   return(buf);",
          "6268: }",
          "6272: char *ndpi_protocol2name(struct ndpi_detection_module_struct *ndpi_str,",
          "6274:   if((proto.master_protocol != NDPI_PROTOCOL_UNKNOWN) && (proto.master_protocol != proto.app_protocol)) {",
          "6275:     if(proto.app_protocol != NDPI_PROTOCOL_UNKNOWN)",
          "6276:       snprintf(buf, buf_len, \"%s.%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol),",
          "6277:         ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "6278:     else",
          "6279:       snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.master_protocol));",
          "6280:   } else",
          "6281:     snprintf(buf, buf_len, \"%s\", ndpi_get_proto_name(ndpi_str, proto.app_protocol));",
          "6283:   return(buf);",
          "6284: }",
          "6288: int ndpi_is_custom_category(ndpi_protocol_category_t category) {",
          "6289:   switch(category) {",
          "6290:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6291:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6292:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6293:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6294:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6295:     return(1);",
          "6296:     break;",
          "6298:   default:",
          "6299:     return(0);",
          "6300:     break;",
          "6302: }",
          "6306: void ndpi_category_set_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6307:        ndpi_protocol_category_t category,",
          "6308:        char *name) {",
          "6309:   if(!name)",
          "6310:     return;",
          "6312:   switch(category) {",
          "6313:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_1:",
          "6314:     snprintf(ndpi_str->custom_category_labels[0], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6315:     break;",
          "6317:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_2:",
          "6318:     snprintf(ndpi_str->custom_category_labels[1], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6319:     break;",
          "6321:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_3:",
          "6322:     snprintf(ndpi_str->custom_category_labels[2], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6323:     break;",
          "6325:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_4:",
          "6326:     snprintf(ndpi_str->custom_category_labels[3], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6327:     break;",
          "6329:   case NDPI_PROTOCOL_CATEGORY_CUSTOM_5:",
          "6330:     snprintf(ndpi_str->custom_category_labels[4], CUSTOM_CATEGORY_LABEL_LEN, \"%s\", name);",
          "6331:     break;",
          "6333:   default:",
          "6334:     break;",
          "6336: }",
          "6340: const char *ndpi_category_get_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6341:        ndpi_protocol_category_t category) {",
          "6342:   if((!ndpi_str) || (category >= NDPI_PROTOCOL_NUM_CATEGORIES)) {",
          "6343:     static char b[24];",
          "6345:     if(!ndpi_str)",
          "6346:       snprintf(b, sizeof(b), \"NULL nDPI\");",
          "6347:     else",
          "6348:       snprintf(b, sizeof(b), \"Invalid category %d\", (int) category);",
          "6349:     return(b);",
          "6350:   }",
          "6352:   if((category >= NDPI_PROTOCOL_CATEGORY_CUSTOM_1) && (category <= NDPI_PROTOCOL_CATEGORY_CUSTOM_5)) {",
          "6355:       return(ndpi_str->custom_category_labels[0]);",
          "6357:       return(ndpi_str->custom_category_labels[1]);",
          "6359:       return(ndpi_str->custom_category_labels[2]);",
          "6361:       return(ndpi_str->custom_category_labels[3]);",
          "6363:       return(ndpi_str->custom_category_labels[4]);",
          "6364:     case NDPI_PROTOCOL_NUM_CATEGORIES:",
          "6365:       return(\"Code should not use this internal constant\");",
          "6367:       return(\"Unspecified\");",
          "6369:   } else",
          "6370:     return(categories[category]);",
          "6371: }",
          "6375: ndpi_protocol_category_t ndpi_get_proto_category(struct ndpi_detection_module_struct *ndpi_str,",
          "6376:        ndpi_protocol proto) {",
          "6377:   if(proto.category != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6378:     return(proto.category);",
          "6381:   else if((proto.master_protocol == NDPI_PROTOCOL_UNKNOWN) ||",
          "6382:    (ndpi_str->proto_defaults[proto.app_protocol].protoCategory != NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)) {",
          "6383:     if(proto.app_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6384:       return(ndpi_str->proto_defaults[proto.app_protocol].protoCategory);",
          "6385:   } else if(proto.master_protocol < (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS))",
          "6386:     return(ndpi_str->proto_defaults[proto.master_protocol].protoCategory);",
          "6388:   return(NDPI_PROTOCOL_CATEGORY_UNSPECIFIED);",
          "6389: }",
          "6393: char *ndpi_get_proto_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6394:      u_int16_t proto_id) {",
          "6395:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6396:      (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6397:      (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6398:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6400:   return(ndpi_str->proto_defaults[proto_id].protoName);",
          "6401: }",
          "6405: ndpi_protocol_breed_t ndpi_get_proto_breed(struct ndpi_detection_module_struct *ndpi_str,",
          "6406:         u_int16_t proto_id) {",
          "6407:   if((proto_id >= ndpi_str->ndpi_num_supported_protocols) ||",
          "6408:      (proto_id >= (NDPI_MAX_SUPPORTED_PROTOCOLS + NDPI_MAX_NUM_CUSTOM_PROTOCOLS)) ||",
          "6409:      (ndpi_str->proto_defaults[proto_id].protoName == NULL))",
          "6410:     proto_id = NDPI_PROTOCOL_UNKNOWN;",
          "6412:   return(ndpi_str->proto_defaults[proto_id].protoBreed);",
          "6413: }",
          "6417: char *ndpi_get_proto_breed_name(struct ndpi_detection_module_struct *ndpi_str,",
          "6418:     ndpi_protocol_breed_t breed_id) {",
          "6419:   switch(breed_id) {",
          "6420:   case NDPI_PROTOCOL_SAFE:",
          "6421:     return(\"Safe\");",
          "6422:     break;",
          "6423:   case NDPI_PROTOCOL_ACCEPTABLE:",
          "6424:     return(\"Acceptable\");",
          "6425:     break;",
          "6426:   case NDPI_PROTOCOL_FUN:",
          "6427:     return(\"Fun\");",
          "6428:     break;",
          "6429:   case NDPI_PROTOCOL_UNSAFE:",
          "6430:     return(\"Unsafe\");",
          "6431:     break;",
          "6432:   case NDPI_PROTOCOL_POTENTIALLY_DANGEROUS:",
          "6433:     return(\"Potentially Dangerous\");",
          "6434:     break;",
          "6435:   case NDPI_PROTOCOL_TRACKER_ADS:",
          "6436:     return(\"Tracker/Ads\");",
          "6437:     break;",
          "6438:   case NDPI_PROTOCOL_DANGEROUS:",
          "6439:     return(\"Dangerous\");",
          "6440:     break;",
          "6441:   case NDPI_PROTOCOL_UNRATED:",
          "6442:     return(\"Unrated\");",
          "6443:     break;",
          "6444:   default:",
          "6445:     return(\"???\");",
          "6446:     break;",
          "6448: }",
          "6452: int ndpi_get_protocol_id(struct ndpi_detection_module_struct *ndpi_str, char *proto) {",
          "6453:   int i;",
          "6455:   for(i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6456:     if(strcasecmp(proto, ndpi_str->proto_defaults[i].protoName) == 0)",
          "6457:       return(i);",
          "6459:   return(-1);",
          "6460: }",
          "6464: int ndpi_get_category_id(struct ndpi_detection_module_struct *ndpi_str, char *cat) {",
          "6465:   int i;",
          "6467:   for(i = 0; i < NDPI_PROTOCOL_NUM_CATEGORIES; i++) {",
          "6468:     const char *name = ndpi_category_get_name(ndpi_str, i);",
          "6470:     if(strcasecmp(cat, name) == 0)",
          "6471:       return(i);",
          "6474:   return(-1);",
          "6475: }",
          "6479: void ndpi_dump_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6480:   int i;",
          "6482:   for(i = 0; i < (int) ndpi_str->ndpi_num_supported_protocols; i++)",
          "6483:     printf(\"%3d %-22s %-8s %-12s %s\\n\", i, ndpi_str->proto_defaults[i].protoName,",
          "6484:     ndpi_get_l4_proto_name(ndpi_get_l4_proto_info(ndpi_str, i)),",
          "6485:     ndpi_get_proto_breed_name(ndpi_str, ndpi_str->proto_defaults[i].protoBreed),",
          "6486:     ndpi_category_get_name(ndpi_str, ndpi_str->proto_defaults[i].protoCategory));",
          "6487: }",
          "6491: void ndpi_dump_risks_score() {",
          "6492:   u_int i;",
          "6494:   printf(\"%3s %-48s %-8s %s\\n\",",
          "6495:   \"Id\", \"Risk\", \"Severity\", \"Score\");",
          "6497:   for(i = 1; i < NDPI_MAX_RISK; i++) {",
          "6498:     ndpi_risk_enum r = (ndpi_risk_enum)i;",
          "6499:     ndpi_risk_severity s = ndpi_risk2severity(r);",
          "6500:     u_int16_t score;",
          "6502:     switch(s) {",
          "6503:     case NDPI_RISK_LOW:",
          "6504:       score = NDPI_SCORE_RISK_LOW;",
          "6507:     case NDPI_RISK_MEDIUM:",
          "6508:       score = NDPI_SCORE_RISK_MEDIUM;",
          "6511:     case NDPI_RISK_HIGH:",
          "6512:       score = NDPI_SCORE_RISK_HIGH;",
          "6515:     case NDPI_RISK_SEVERE:",
          "6516:       score = NDPI_SCORE_RISK_SEVERE;",
          "6520:     printf(\"%3d %-48s %-8s %u\\n\",",
          "6521:     i, ndpi_risk2str(r),",
          "6522:     ndpi_severity2str(s),",
          "6523:     score);",
          "6525: }",
          "6533: char *ndpi_strnstr(const char *s, const char *find, size_t slen) {",
          "6534:   char c;",
          "6535:   size_t len;",
          "6537:   if((c = *find++) != '\\0') {",
          "6538:     len = strnlen(find, slen);",
          "6539:     do {",
          "6540:       char sc;",
          "6542:       do {",
          "6543:  if(slen-- < 1 || (sc = *s++) == '\\0')",
          "6544:    return(NULL);",
          "6545:       } while(sc != c);",
          "6546:       if(len > slen)",
          "6547:  return(NULL);",
          "6548:     } while(strncmp(s, find, len) != 0);",
          "6549:     s--;",
          "6552:   return((char *) s);",
          "6553: }",
          "6560: const char * ndpi_strncasestr(const char *str1, const char *str2, size_t len) {",
          "6561:   size_t str1_len = strnlen(str1, len);",
          "6562:   size_t str2_len = strlen(str2);",
          "6563:   size_t i;",
          "6565:   for(i = 0; i < (str1_len - str2_len + 1); i++){",
          "6566:     if(str1[0] == '\\0')",
          "6567:       return NULL;",
          "6568:     else if(strncasecmp(str1, str2, str2_len) == 0)",
          "6569:       return(str1);",
          "6571:     str1++;",
          "6574:   return NULL;",
          "6575: }",
          "6579: int ndpi_match_prefix(const u_int8_t *payload,",
          "6580:         size_t payload_len, const char *str, size_t str_len) {",
          "6581:   int rc = str_len <= payload_len ? memcmp(payload, str, str_len) == 0 : 0;",
          "6583:   return(rc);",
          "6584: }",
          "6588: int ndpi_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str, char *string_to_match,",
          "6589:       u_int string_to_match_len, ndpi_protocol_match_result *ret_match,",
          "6590:       u_int8_t is_host_match) {",
          "6591:   AC_TEXT_t ac_input_text;",
          "6592:   ndpi_automa *automa = is_host_match ? &ndpi_str->host_automa : &ndpi_str->content_automa;",
          "6593:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6594:   int rc;",
          "6596:   if((automa->ac_automa == NULL) || (string_to_match_len == 0))",
          "6597:     return(NDPI_PROTOCOL_UNKNOWN);",
          "6599:   if(!automa->ac_automa_finalized) {",
          "6600:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initialization()\\n\", __FILE__, __LINE__);",
          "6604:   ac_input_text.astring = string_to_match, ac_input_text.length = string_to_match_len;",
          "6605:   rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6608:     As ac_automata_search can detect partial matches and continue the search process",
          "6609:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6610:     and in this case return it",
          "6612:   if((rc == 0) && (match.number != 0))",
          "6613:     rc = 1;",
          "6616:   ret_match->protocol_id = match.number, ret_match->protocol_category = match.category,",
          "6617:     ret_match->protocol_breed = match.breed;",
          "6619:   return(rc ? match.number : 0);",
          "6620: }",
          "6624: static u_int8_t ndpi_is_more_generic_protocol(u_int16_t previous_proto, u_int16_t new_proto) {",
          "6627:   if((previous_proto == NDPI_PROTOCOL_UNKNOWN) || (previous_proto == new_proto))",
          "6628:     return(0);",
          "6630:   switch(previous_proto) {",
          "6631:   case NDPI_PROTOCOL_WHATSAPP_CALL:",
          "6632:   case NDPI_PROTOCOL_WHATSAPP_FILES:",
          "6633:     if(new_proto == NDPI_PROTOCOL_WHATSAPP)",
          "6634:       return(1);",
          "6637:   return(0);",
          "6638: }",
          "6642: static u_int16_t ndpi_automa_match_string_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6643:             struct ndpi_flow_struct *flow, char *string_to_match,",
          "6644:             u_int string_to_match_len, u_int16_t master_protocol_id,",
          "6645:             ndpi_protocol_match_result *ret_match, u_int8_t is_host_match) {",
          "6646:   int matching_protocol_id;",
          "6647:   struct ndpi_packet_struct *packet = &flow->packet;",
          "6649:   matching_protocol_id =",
          "6650:     ndpi_match_string_subprotocol(ndpi_str, string_to_match, string_to_match_len, ret_match, is_host_match);",
          "6653:   {",
          "6654:     char m[256];",
          "6655:     int len = ndpi_min(sizeof(m), string_to_match_len);",
          "6657:     strncpy(m, string_to_match, len);",
          "6658:     m[len] = '\\0';",
          "6660:     NDPI_LOG_DBG2(ndpi_str, \"[NDPI] ndpi_match_host_subprotocol(%s): %s\\n\", m,",
          "6661:     ndpi_str->proto_defaults[matching_protocol_id].protoName);",
          "6662:   }",
          "6665:   if((matching_protocol_id != NDPI_PROTOCOL_UNKNOWN) &&",
          "6666:      (!ndpi_is_more_generic_protocol(packet->detected_protocol_stack[0], matching_protocol_id))) {",
          "6668:     packet->detected_protocol_stack[1] = master_protocol_id,",
          "6669:       packet->detected_protocol_stack[0] = matching_protocol_id;",
          "6671:     flow->detected_protocol_stack[0] = packet->detected_protocol_stack[0],",
          "6672:       flow->detected_protocol_stack[1] = packet->detected_protocol_stack[1];",
          "6674:     if(flow->category == NDPI_PROTOCOL_CATEGORY_UNSPECIFIED)",
          "6675:       flow->category = ret_match->protocol_category;",
          "6677:     return(packet->detected_protocol_stack[0]);",
          "6678:   }",
          "6681:   string_to_match[string_to_match_len] = '\\0';",
          "6682:   NDPI_LOG_DBG2(ndpi_str, \"[NTOP] Unable to find a match for '%s'\\n\", string_to_match);",
          "6685:   ret_match->protocol_id = NDPI_PROTOCOL_UNKNOWN, ret_match->protocol_category = NDPI_PROTOCOL_CATEGORY_UNSPECIFIED,",
          "6686:     ret_match->protocol_breed = NDPI_PROTOCOL_UNRATED;",
          "6688:   return(NDPI_PROTOCOL_UNKNOWN);",
          "6689: }",
          "6693: void ndpi_check_subprotocol_risk(struct ndpi_flow_struct *flow, u_int16_t subprotocol_id) {",
          "6694:   switch(subprotocol_id) {",
          "6695:   case NDPI_PROTOCOL_ANYDESK:",
          "6697:     break;",
          "6699: }",
          "6703: u_int16_t ndpi_match_host_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6704:           struct ndpi_flow_struct *flow,",
          "6705:           char *string_to_match, u_int string_to_match_len,",
          "6706:           ndpi_protocol_match_result *ret_match,",
          "6707:           u_int16_t master_protocol_id) {",
          "6708:   u_int16_t rc, buf_len, i;",
          "6709:   ndpi_protocol_category_t id;",
          "6710:   char buf[96];",
          "6712:   buf_len = ndpi_min(string_to_match_len, sizeof(buf)-2);",
          "6713:   for(i=0; i<buf_len; i++) buf[i] = tolower(string_to_match[i]);",
          "6715:   buf[i] = '\\0';",
          "6717:   rc = ndpi_automa_match_string_subprotocol(ndpi_str, flow, buf, i,",
          "6718:          master_protocol_id, ret_match, 1);",
          "6719:   id = ret_match->protocol_category;",
          "6721:   if(ndpi_get_custom_category_match(ndpi_str, buf, i, &id) != -1) {",
          "6723:       flow->category = ret_match->protocol_category = id;",
          "6724:       rc = master_protocol_id;",
          "6726:   }",
          "6728:   if(ndpi_str->risky_domain_automa.ac_automa != NULL) {",
          "6729:     u_int16_t rc1 = ndpi_match_string(ndpi_str->risky_domain_automa.ac_automa, buf);",
          "6731:     if(rc1 > 0)",
          "6732:       ndpi_set_risk(flow, NDPI_RISKY_DOMAIN);",
          "6735:   return(rc);",
          "6736: }",
          "6740: int ndpi_match_hostname_protocol(struct ndpi_detection_module_struct *ndpi_struct,",
          "6741:      struct ndpi_flow_struct *flow,",
          "6742:      u_int16_t master_protocol, char *name, u_int name_len) {",
          "6743:   ndpi_protocol_match_result ret_match;",
          "6744:   u_int16_t subproto, what_len;",
          "6745:   char *what;",
          "6747:   if((name_len > 2) && (name[0] == '*') && (name[1] == '.'))",
          "6748:     what = &name[1], what_len = name_len - 1;",
          "6749:   else",
          "6750:     what = name, what_len = name_len;",
          "6752:   subproto = ndpi_match_host_subprotocol(ndpi_struct, flow, what, what_len,",
          "6753:       &ret_match, master_protocol);",
          "6755:   if(subproto != NDPI_PROTOCOL_UNKNOWN) {",
          "6756:     ndpi_set_detected_protocol(ndpi_struct, flow, subproto, master_protocol);",
          "6757:     ndpi_int_change_category(ndpi_struct, flow, ret_match.protocol_category);",
          "6758:     return(1);",
          "6759:   } else",
          "6760:     return(0);",
          "6761: }",
          "6765: u_int16_t ndpi_match_content_subprotocol(struct ndpi_detection_module_struct *ndpi_str,",
          "6766:       struct ndpi_flow_struct *flow,",
          "6767:       char *string_to_match, u_int string_to_match_len,",
          "6768:       ndpi_protocol_match_result *ret_match,",
          "6769:       u_int16_t master_protocol_id) {",
          "6770:   return(ndpi_automa_match_string_subprotocol(ndpi_str, flow, string_to_match, string_to_match_len,",
          "6771:            master_protocol_id, ret_match, 0));",
          "6772: }",
          "6776: int ndpi_match_bigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6777:         ndpi_automa *automa, char *bigram_to_match) {",
          "6778:   AC_TEXT_t ac_input_text;",
          "6779:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6780:   int rc;",
          "6782:   if((automa->ac_automa == NULL) || (bigram_to_match == NULL))",
          "6783:     return(-1);",
          "6785:   if(!automa->ac_automa_finalized) {",
          "6787:     ndpi_finalize_initialization(ndpi_str);",
          "6789:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initialization()\\n\", __FILE__, __LINE__);",
          "6792:   }",
          "6794:   ac_input_text.astring = bigram_to_match, ac_input_text.length = 2;",
          "6795:   rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6798:     As ac_automata_search can detect partial matches and continue the search process",
          "6799:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6800:     and in this case return it",
          "6802:   if((rc == 0) && (match.number != 0))",
          "6803:     rc = 1;",
          "6805:   return(rc ? match.number : 0);",
          "6806: }",
          "6810: int ndpi_match_trigram(struct ndpi_detection_module_struct *ndpi_str,",
          "6811:          ndpi_automa *automa, char *trigram_to_match) {",
          "6812:   AC_TEXT_t ac_input_text;",
          "6813:   AC_REP_t match = {NDPI_PROTOCOL_UNKNOWN, NDPI_PROTOCOL_CATEGORY_UNSPECIFIED, NDPI_PROTOCOL_UNRATED};",
          "6814:   int rc;",
          "6816:   if((automa->ac_automa == NULL) || (trigram_to_match == NULL))",
          "6817:     return(-1);",
          "6819:   if(!automa->ac_automa_finalized) {",
          "6821:     ndpi_finalize_initialization(ndpi_str);",
          "6823:     printf(\"[%s:%d] [NDPI] Internal error: please call ndpi_finalize_initialization()\\n\", __FILE__, __LINE__);",
          "6826:   }",
          "6828:   ac_input_text.astring = trigram_to_match, ac_input_text.length = 3;",
          "6829:   rc = ac_automata_search(((AC_AUTOMATA_t *) automa->ac_automa), &ac_input_text, &match);",
          "6832:     As ac_automata_search can detect partial matches and continue the search process",
          "6833:     in case rc == 0 (i.e. no match), we need to check if there is a partial match",
          "6834:     and in this case return it",
          "6836:   if((rc == 0) && (match.number != 0))",
          "6837:     rc = 1;",
          "6839:   if(ndpi_verbose_dga_detection && rc && match.number) {",
          "6840:     printf(\"[%s:%d] [NDPI] Trigram %c%c%c\\n\",",
          "6841:     __FILE__, __LINE__,",
          "6842:     trigram_to_match[0],",
          "6843:     trigram_to_match[1],",
          "6844:     trigram_to_match[2]);",
          "6847:   return(rc ? match.number : 0);",
          "6848: }",
          "6852: void ndpi_free_flow(struct ndpi_flow_struct *flow) {",
          "6853:   if(flow) {",
          "6854:     ndpi_free_flow_data(flow);",
          "6855:     ndpi_free(flow);",
          "6857: }",
          "6861: char *ndpi_revision() {",
          "6862:   return(NDPI_GIT_RELEASE);",
          "6863: }",
          "6870: int gettimeofday(struct timeval *tp, struct timezone *tzp) {",
          "6874:   static const uint64_t EPOCH = ((uint64_t) 116444736000000000ULL);",
          "6876:   SYSTEMTIME system_time;",
          "6877:   FILETIME file_time;",
          "6878:   uint64_t time;",
          "6880:   GetSystemTime(&system_time);",
          "6881:   SystemTimeToFileTime(&system_time, &file_time);",
          "6882:   time = ((uint64_t) file_time.dwLowDateTime);",
          "6883:   time += ((uint64_t) file_time.dwHighDateTime) << 32;",
          "6885:   tp->tv_sec = (long) ((time - EPOCH) / 10000000L);",
          "6886:   tp->tv_usec = (long) (system_time.wMilliseconds * 1000);",
          "6887:   return(0);",
          "6888: }",
          "6891: int NDPI_BITMASK_COMPARE(NDPI_PROTOCOL_BITMASK a, NDPI_PROTOCOL_BITMASK b) {",
          "6892:   int i;",
          "6894:   for(i = 0; i < NDPI_NUM_FDS_BITS; i++) {",
          "6895:     if(a.fds_bits[i] & b.fds_bits[i])",
          "6896:       return(1);",
          "6899:   return(0);",
          "6900: }",
          "6903: int NDPI_BITMASK_IS_EMPTY(NDPI_PROTOCOL_BITMASK a) {",
          "6904:   int i;",
          "6906:   for(i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6907:     if(a.fds_bits[i] != 0)",
          "6908:       return(0);",
          "6910:   return(1);",
          "6911: }",
          "6913: void NDPI_DUMP_BITMASK(NDPI_PROTOCOL_BITMASK a) {",
          "6914:   int i;",
          "6916:   for(i = 0; i < NDPI_NUM_FDS_BITS; i++)",
          "6917:     printf(\"[%d=%u]\", i, a.fds_bits[i]);",
          "6919:   printf(\"\\n\");",
          "6920: }",
          "6923: u_int16_t ndpi_get_api_version() {",
          "6924:   return(NDPI_API_VERSION);",
          "6925: }",
          "6927: const char *ndpi_get_gcrypt_version(void) {",
          "6929:   return gcry_check_version(NULL);",
          "6931:   return NULL;",
          "6932: }",
          "6934: ndpi_proto_defaults_t *ndpi_get_proto_defaults(struct ndpi_detection_module_struct *ndpi_str) {",
          "6935:   return(ndpi_str->proto_defaults);",
          "6936: }",
          "6938: u_int ndpi_get_ndpi_num_supported_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6939:   return(ndpi_str->ndpi_num_supported_protocols);",
          "6940: }",
          "6942: u_int ndpi_get_ndpi_num_custom_protocols(struct ndpi_detection_module_struct *ndpi_str) {",
          "6943:   return(ndpi_str->ndpi_num_custom_protocols);",
          "6944: }",
          "6946: u_int ndpi_get_ndpi_detection_module_size() {",
          "6947:   return(sizeof(struct ndpi_detection_module_struct));",
          "6948: }",
          "6950: void ndpi_set_debug_bitmask(struct ndpi_detection_module_struct *ndpi_str, NDPI_PROTOCOL_BITMASK debug_bitmask) {",
          "6952:   ndpi_str->debug_bitmask = debug_bitmask;",
          "6954: }",
          "6956: void ndpi_set_log_level(struct ndpi_detection_module_struct *ndpi_str, u_int l){",
          "6957:   ndpi_str->ndpi_log_level = l;",
          "6958: }",
          "6963: struct ndpi_lru_cache *ndpi_lru_cache_init(u_int32_t num_entries) {",
          "6964:   struct ndpi_lru_cache *c = (struct ndpi_lru_cache *) ndpi_malloc(sizeof(struct ndpi_lru_cache));",
          "6966:   if(!c)",
          "6967:     return(NULL);",
          "6969:   c->entries = (struct ndpi_lru_cache_entry *) ndpi_calloc(num_entries, sizeof(struct ndpi_lru_cache_entry));",
          "6971:   if(!c->entries) {",
          "6972:     ndpi_free(c);",
          "6973:     return(NULL);",
          "6974:   } else",
          "6975:     c->num_entries = num_entries;",
          "6977:   return(c);",
          "6978: }",
          "6980: void ndpi_lru_free_cache(struct ndpi_lru_cache *c) {",
          "6981:   ndpi_free(c->entries);",
          "6982:   ndpi_free(c);",
          "6983: }",
          "6985: u_int8_t ndpi_lru_find_cache(struct ndpi_lru_cache *c, u_int32_t key,",
          "6986:         u_int16_t *value, u_int8_t clean_key_when_found) {",
          "6987:   u_int32_t slot = key % c->num_entries;",
          "6989:   if(c->entries[slot].is_full) {",
          "6991:     if(clean_key_when_found)",
          "6992:       c->entries[slot].is_full = 0;",
          "6993:     return(1);",
          "6994:   } else",
          "6995:     return(0);",
          "6996: }",
          "6998: void ndpi_lru_add_to_cache(struct ndpi_lru_cache *c, u_int32_t key, u_int16_t value) {",
          "6999:   u_int32_t slot = key % c->num_entries;",
          "7001:   c->entries[slot].is_full = 1, c->entries[slot].key = key, c->entries[slot].value = value;",
          "7002: }",
          "7007:   This function tells if it's possible to further dissect a given flow",
          "7008:   0 - All possible dissection has been completed",
          "7009:   1 - Additional dissection is possible",
          "7011: u_int8_t ndpi_extra_dissection_possible(struct ndpi_detection_module_struct *ndpi_str,",
          "7012:      struct ndpi_flow_struct *flow) {",
          "7013:   u_int16_t proto =",
          "7014:     flow->detected_protocol_stack[1] ? flow->detected_protocol_stack[1] : flow->detected_protocol_stack[0];",
          "7017:   printf(\"[DEBUG] %s(%u.%u): %u\\n\", __FUNCTION__,",
          "7018:   flow->detected_protocol_stack[0],",
          "7019:   flow->detected_protocol_stack[1],",
          "7020:   proto);",
          "7023:   switch(proto) {",
          "7024:   case NDPI_PROTOCOL_TLS:",
          "7025:   case NDPI_PROTOCOL_DTLS:",
          "7026:     if(flow->l4.tcp.tls.certificate_processed) return(0);",
          "7028:     if(flow->l4.tcp.tls.num_tls_blocks <= ndpi_str->num_tls_blocks_to_follow) {",
          "7030:       return(1);",
          "7031:     }",
          "7032:     break;",
          "7034:   case NDPI_PROTOCOL_HTTP:",
          "7035:     if((flow->host_server_name[0] == '\\0') || (flow->http.response_status_code == 0))",
          "7036:       return(1);",
          "7037:     break;",
          "7039:   case NDPI_PROTOCOL_DNS:",
          "7040:   case NDPI_PROTOCOL_MDNS:",
          "7041:     if(flow->protos.dns.num_answers == 0)",
          "7042:       return(1);",
          "7043:     break;",
          "7045:   case NDPI_PROTOCOL_FTP_CONTROL:",
          "7046:   case NDPI_PROTOCOL_MAIL_POP:",
          "7047:   case NDPI_PROTOCOL_MAIL_IMAP:",
          "7048:   case NDPI_PROTOCOL_MAIL_SMTP:",
          "7049:     if(flow->protos.ftp_imap_pop_smtp.password[0] == '\\0')",
          "7050:       return(1);",
          "7051:     break;",
          "7053:   case NDPI_PROTOCOL_SSH:",
          "7054:     if((flow->protos.ssh.hassh_client[0] == '\\0') || (flow->protos.ssh.hassh_server[0] == '\\0'))",
          "7055:       return(1);",
          "7056:     break;",
          "7058:   case NDPI_PROTOCOL_TELNET:",
          "7059:     if(!flow->protos.telnet.password_detected)",
          "7060:       return(1);",
          "7061:     break;",
          "7063:   case NDPI_PROTOCOL_SKYPE:",
          "7064:     if(flow->extra_packets_func)",
          "7065:       return(1);",
          "7066:     break;",
          "7068:   case NDPI_PROTOCOL_QUIC:",
          "7069:     if(flow->extra_packets_func)",
          "7070:       return(1);",
          "7071:     break;",
          "7074:   return(0);",
          "7075: }",
          "7079: const char *ndpi_get_l4_proto_name(ndpi_l4_proto_info proto) {",
          "7080:   switch(proto) {",
          "7081:   case ndpi_l4_proto_unknown:",
          "7082:     return(\"\");",
          "7083:     break;",
          "7085:   case ndpi_l4_proto_tcp_only:",
          "7086:     return(\"TCP\");",
          "7087:     break;",
          "7089:   case ndpi_l4_proto_udp_only:",
          "7090:     return(\"UDP\");",
          "7091:     break;",
          "7093:   case ndpi_l4_proto_tcp_and_udp:",
          "7094:     return(\"TCP/UDP\");",
          "7095:     break;",
          "7098:   return(\"\");",
          "7099: }",
          "7103: ndpi_l4_proto_info ndpi_get_l4_proto_info(struct ndpi_detection_module_struct *ndpi_struct,",
          "7104:        u_int16_t ndpi_proto_id) {",
          "7105:   if(ndpi_proto_id < ndpi_struct->ndpi_num_supported_protocols) {",
          "7106:     u_int16_t idx = ndpi_struct->proto_defaults[ndpi_proto_id].protoIdx;",
          "7107:     NDPI_SELECTION_BITMASK_PROTOCOL_SIZE bm = ndpi_struct->callback_buffer[idx].ndpi_selection_bitmask;",
          "7109:     if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP)",
          "7110:       return(ndpi_l4_proto_tcp_only);",
          "7111:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_UDP)",
          "7112:       return(ndpi_l4_proto_udp_only);",
          "7113:     else if(bm & NDPI_SELECTION_BITMASK_PROTOCOL_INT_TCP_OR_UDP)",
          "7114:       return(ndpi_l4_proto_tcp_and_udp);",
          "7118: }",
          "7122: ndpi_ptree_t *ndpi_ptree_create(void) {",
          "7123:   ndpi_ptree_t *tree = (ndpi_ptree_t *) ndpi_malloc(sizeof(ndpi_ptree_t));",
          "7125:   if(tree) {",
          "7126:     tree->v4 = ndpi_patricia_new(32);",
          "7127:     tree->v6 = ndpi_patricia_new(128);",
          "7129:     if((!tree->v4) || (!tree->v6)) {",
          "7130:       ndpi_ptree_destroy(tree);",
          "7131:       return(NULL);",
          "7132:     }",
          "7135:   return(tree);",
          "7136: }",
          "7140: void ndpi_ptree_destroy(ndpi_ptree_t *tree) {",
          "7141:   if(tree) {",
          "7142:     if(tree->v4)",
          "7143:       ndpi_patricia_destroy(tree->v4, free_ptree_data);",
          "7144:     if(tree->v6)",
          "7145:       ndpi_patricia_destroy(tree->v6, free_ptree_data);",
          "7147:     ndpi_free(tree);",
          "7149: }",
          "7153: int ndpi_ptree_insert(ndpi_ptree_t *tree, const ndpi_ip_addr_t *addr,",
          "7154:         u_int8_t bits, u_int64_t user_data) {",
          "7155:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "7156:   ndpi_patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "7157:   ndpi_prefix_t prefix;",
          "7158:   ndpi_patricia_node_t *node;",
          "7160:   if(bits > ptree->maxbits)",
          "7161:     return(-1);",
          "7163:   if(is_v6)",
          "7164:     ndpi_fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "7165:   else",
          "7166:     ndpi_fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "7169:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "7171:   if(node && (node->prefix->bitlen == bits))",
          "7172:     return(-2);",
          "7174:   node = ndpi_patricia_lookup(ptree, &prefix);",
          "7176:   if(node != NULL) {",
          "7177:     node->value.u.uv64 = user_data;",
          "7179:     return(0);",
          "7182:   return(-3);",
          "7183: }",
          "7187: int ndpi_ptree_match_addr(ndpi_ptree_t *tree,",
          "7188:      const ndpi_ip_addr_t *addr, u_int64_t *user_data) {",
          "7189:   u_int8_t is_v6 = ndpi_is_ipv6(addr);",
          "7190:   ndpi_patricia_tree_t *ptree = is_v6 ? tree->v6 : tree->v4;",
          "7191:   ndpi_prefix_t prefix;",
          "7192:   ndpi_patricia_node_t *node;",
          "7193:   int bits = ptree->maxbits;",
          "7195:   if(is_v6)",
          "7196:     ndpi_fill_prefix_v6(&prefix, (const struct in6_addr *) &addr->ipv6, bits, ptree->maxbits);",
          "7197:   else",
          "7198:     ndpi_fill_prefix_v4(&prefix, (const struct in_addr *) &addr->ipv4, bits, ptree->maxbits);",
          "7200:   node = ndpi_patricia_search_best(ptree, &prefix);",
          "7202:   if(node) {",
          "7205:     return(0);",
          "7208:   return(-1);",
          "7209: }",
          "7214: u_int32_t ndpi_quick_hash(unsigned char *str, u_int str_len) {",
          "7215:   u_int32_t hash = 5381, i;",
          "7217:   for(i=0; i<str_len; i++)",
          "7220:   return hash;",
          "7221: }",
          "7225: void ndpi_md5(const u_char *data, size_t data_len, u_char hash[16]) {",
          "7226:   ndpi_MD5_CTX ctx;",
          "7228:   ndpi_MD5Init(&ctx);",
          "7229:   ndpi_MD5Update(&ctx, data, data_len);",
          "7230:   ndpi_MD5Final(hash, &ctx);",
          "7231: }",
          "7235: static int enough(int a, int b) {",
          "7236:   u_int8_t percentage = 20;",
          "7238:   if(b <= 1) return(0);",
          "7239:   if(a == 0) return(1);",
          "7241:   if(b > (((a+1)*percentage)/100)) return(1);",
          "7243:   return(0);",
          "7244: }",
          "7248: static u_int8_t endsWith(char *str, char *ends, u_int8_t ends_len) {",
          "7249:   u_int str_len = str ? strlen(str) : 0;",
          "7250:   u_int8_t rc;",
          "7252:   if(str_len < ends_len) return(0);",
          "7254:   rc = (strncmp(&str[str_len-ends_len], ends, ends_len) != 0) ? 0 : 1;",
          "7257:   printf(\"[DGA] %s / %s [rc: %u]\\n\", str, ends, rc);",
          "7260:   return(rc);",
          "7261: }",
          "7265: static int ndpi_is_trigram_char(char c) {",
          "7266:   if(isdigit(c) || (c == '.') || (c == '-'))",
          "7267:     return(0);",
          "7268:   else",
          "7269:     return(1);",
          "7270: }",
          "7274: static int ndpi_is_vowel(char c) {",
          "7275:   switch(c) {",
          "7276:   case 'a':",
          "7277:   case 'e':",
          "7278:   case 'i':",
          "7279:   case 'o':",
          "7280:   case 'u':",
          "7281:   case 'y': // Not a real vowel...",
          "7282:   case 'x': // Not a real vowel...",
          "7283:     return(1);",
          "7284:     break;",
          "7286:   default:",
          "7287:     return(0);",
          "7289: }",
          "7293: int ndpi_check_dga_name(struct ndpi_detection_module_struct *ndpi_str,",
          "7294:    struct ndpi_flow_struct *flow,",
          "7295:    char *name, u_int8_t is_hostname) {",
          "7296:   if(ndpi_dga_function != NULL) {",
          "7298:     int rc = ndpi_dga_function(name, is_hostname);",
          "7300:     if(rc) {",
          "7301:       if(flow)",
          "7302:  ndpi_set_risk(flow, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7303:     }",
          "7305:     return(rc);",
          "7306:   } else {",
          "7307:     int len, rc = 0, trigram_char_skip = 0;",
          "7308:     u_int8_t max_num_char_repetitions = 0, last_char = 0, num_char_repetitions = 0, num_dots = 0, num_trigram_dots = 0;",
          "7309:     u_int8_t max_domain_element_len = 0, curr_domain_element_len = 0, first_element_is_numeric = 1;",
          "7311:     if((!name)",
          "7312:        || (strchr(name, '_') != NULL)",
          "7313:        || (endsWith(name, \"in-addr.arpa\", 12))",
          "7314:        || (endsWith(name, \"ip6.arpa\", 8))",
          "7316:        || (endsWith(name, \".local\", 6))",
          "7317:        || (endsWith(name, \".lan\", 4))",
          "7318:        || (endsWith(name, \".home\", 5))",
          "7319:        )",
          "7320:       return(0);",
          "7322:     if(flow && (flow->packet.detected_protocol_stack[1] != NDPI_PROTOCOL_UNKNOWN))",
          "7325:     if(strncmp(name, \"www.\", 4) == 0)",
          "7326:       name = &name[4];",
          "7328:     if(ndpi_verbose_dga_detection)",
          "7329:       printf(\"[DGA check] %s\\n\", name);",
          "7331:     len = strlen(name);",
          "7333:     if(len >= 5) {",
          "7334:       int i, j, num_found = 0, num_impossible = 0, num_bigram_checks = 0,",
          "7335:  num_trigram_found = 0, num_trigram_checked = 0, num_dash = 0,",
          "7336:  num_digits = 0, num_vowels = 0, num_trigram_vowels = 0, num_words = 0, skip_next_bigram = 0;",
          "7337:       char tmp[128], *word, *tok_tmp;",
          "7338:       u_int max_tmp_len = sizeof(tmp)-1;",
          "7340:       len = snprintf(tmp, max_tmp_len, \"%s\", name);",
          "7341:       if(len < 0) {",
          "7343:  if(ndpi_verbose_dga_detection)",
          "7344:    printf(\"[DGA] Too short\");",
          "7346:  return(0);",
          "7347:       } else",
          "7348:  tmp[len < max_tmp_len ? len : max_tmp_len] = '\\0';",
          "7350:       for(i=0, j=0; (i<len) && (j<max_tmp_len); i++) {",
          "7351:  tmp[j] = tolower(name[i]);",
          "7353:  if(tmp[j] == '.') {",
          "7354:    num_dots++;",
          "7355:  } else if(num_dots == 0) {",
          "7356:    if(!isdigit(tmp[j]))",
          "7357:      first_element_is_numeric = 0;",
          "7358:  }",
          "7360:  if(ndpi_is_vowel(tmp[j]))",
          "7361:    num_vowels++;",
          "7363:  if(last_char == tmp[j]) {",
          "7364:    if(++num_char_repetitions > max_num_char_repetitions)",
          "7365:      max_num_char_repetitions = num_char_repetitions;",
          "7366:  } else",
          "7367:    num_char_repetitions = 1, last_char = tmp[j];",
          "7369:  if(isdigit(tmp[j])) {",
          "7370:    num_digits++;",
          "7372:    if(((j+2)<len) && isdigit(tmp[j+1]) && (tmp[j+2] == '.')) {",
          "7374:      if(num_digits < 4)",
          "7377:  }",
          "7379:  switch(tmp[j]) {",
          "7380:  case '.':",
          "7381:  case '-':",
          "7382:  case '_':",
          "7383:  case '/':",
          "7384:  case ')':",
          "7385:  case '(':",
          "7386:  case ';':",
          "7387:  case ':':",
          "7388:  case '[':",
          "7389:  case ']':",
          "7390:  case ' ':",
          "7392:      Domain/word separator chars",
          "7394:      NOTE:",
          "7395:      this function is used also to detect other type of issues",
          "7396:      such as invalid/suspiciuous user agent",
          "7398:    if(curr_domain_element_len > max_domain_element_len)",
          "7399:      max_domain_element_len = curr_domain_element_len;",
          "7401:    curr_domain_element_len = 0;",
          "7402:    break;",
          "7404:  default:",
          "7405:    curr_domain_element_len++;",
          "7406:    break;",
          "7409:  j++;",
          "7410:       }",
          "7413:  return(0);",
          "7415:       if(curr_domain_element_len > max_domain_element_len)",
          "7416:  max_domain_element_len = curr_domain_element_len;",
          "7418:       if(ndpi_verbose_dga_detection)",
          "7419:  printf(\"[DGA] [max_num_char_repetitions: %u][max_domain_element_len: %u]\\n\",",
          "7420:         max_num_char_repetitions, max_domain_element_len);",
          "7422:       if(",
          "7423:   (is_hostname",
          "7424:    && (num_dots > 5)",
          "7425:    && (!first_element_is_numeric)",
          "7426:    )",
          "7427:   || (max_num_char_repetitions > 5 /* num or consecutive repeated chars */)",
          "7429:     In case of a name with too many consecutive chars an alert is triggered",
          "7430:     This is the case for instance of the wildcard DNS query used by NetBIOS",
          "7431:     (ckaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) and that can be exploited",
          "7432:     for reflection attacks",
          "7433:     - https://www.akamai.com/uk/en/multimedia/documents/state-of-the-internet/ddos-reflection-netbios-name-server-rpc-portmap-sentinel-udp-threat-advisory.pdf",
          "7434:     - http://ubiqx.org/cifs/NetBIOS.html",
          "7436:   || ((max_domain_element_len >= 19 /* word too long. Example bbcbedxhgjmdobdprmen.com */) && ((num_char_repetitions > 1) || (num_digits > 1)))",
          "7437:   ) {",
          "7438:  if(flow) ndpi_set_risk(flow, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7440:  if(ndpi_verbose_dga_detection)",
          "7441:    printf(\"[DGA] Found!\");",
          "7443:  return(1);",
          "7444:       }",
          "7446:       tmp[j] = '\\0';",
          "7447:       len = j;",
          "7449:       for(word = strtok_r(tmp, \".\", &tok_tmp); ; word = strtok_r(NULL, \".\", &tok_tmp)) {",
          "7450:  if(!word) break;",
          "7452:  num_words++;",
          "7454:  if(strlen(word) < 3) continue;",
          "7456:  if(ndpi_verbose_dga_detection)",
          "7457:    printf(\"-> word(%s) [%s][len: %u]\\n\", word, name, (unsigned int)strlen(word));",
          "7459:  trigram_char_skip = 0;",
          "7461:  for(i = 0; word[i+1] != '\\0'; i++) {",
          "7462:    switch(word[i]) {",
          "7463:    case '-':",
          "7464:      num_dash++;",
          "7466:        Let's check for double+consecutive --",
          "7467:        that are usually ok",
          "7468:        r2---sn-uxaxpu5ap5-2n5e.gvt1.com",
          "7470:      if(word[i+1] == '-')",
          "7473:    case '_':",
          "7474:    case ':':",
          "7475:      continue;",
          "7476:      break;",
          "7478:    case '.':",
          "7479:      continue;",
          "7480:      break;",
          "7481:    }",
          "7482:    num_bigram_checks++;",
          "7484:    if(ndpi_verbose_dga_detection)",
          "7485:      printf(\"-> Checking %c%c\\n\", word[i], word[i+1]);",
          "7487:    if(ndpi_match_bigram(ndpi_str,",
          "7488:           &ndpi_str->impossible_bigrams_automa,",
          "7489:           &word[i])) {",
          "7490:      if(ndpi_verbose_dga_detection)",
          "7491:        printf(\"IMPOSSIBLE %s\\n\", &word[i]);",
          "7493:      num_impossible++;",
          "7494:    } else {",
          "7495:      if(!skip_next_bigram) {",
          "7496:        if(ndpi_match_bigram(ndpi_str, &ndpi_str->bigrams_automa, &word[i])) {",
          "7497:   num_found++, skip_next_bigram = 1;",
          "7498:        }",
          "7499:      } else",
          "7500:        skip_next_bigram = 0;",
          "7501:    }",
          "7503:    if((num_trigram_dots < 2) && (word[i+2] != '\\0')) {",
          "7504:      if(ndpi_verbose_dga_detection)",
          "7505:        printf(\"***> %s [trigram_char_skip: %u]\\n\", &word[i], trigram_char_skip);",
          "7507:      if(ndpi_is_trigram_char(word[i]) && ndpi_is_trigram_char(word[i+1]) && ndpi_is_trigram_char(word[i+2])) {",
          "7508:        if(trigram_char_skip) {",
          "7509:   trigram_char_skip--;",
          "7510:        } else {",
          "7511:   num_trigram_checked++;",
          "7513:   if(ndpi_match_trigram(ndpi_str, &ndpi_str->trigrams_automa, &word[i]))",
          "7514:     num_trigram_found++, trigram_char_skip = 2 /* 1 char overlap */;",
          "7515:   else if(ndpi_verbose_dga_detection)",
          "7516:     printf(\"[NDPI] NO Trigram %c%c%c\\n\", word[i], word[i+1], word[i+2]);",
          "7519:   num_trigram_vowels += ndpi_is_vowel(word[i]) + ndpi_is_vowel(word[i+1]) + ndpi_is_vowel(word[i+2]);",
          "7521:      } else {",
          "7522:        if(word[i] == '.')",
          "7523:   num_trigram_dots++;",
          "7525:        trigram_char_skip = 0;",
          "7527:    }",
          "7531:       if(ndpi_verbose_dga_detection)",
          "7532:  printf(\"[%s][num_found: %u][num_impossible: %u][num_digits: %u][num_bigram_checks: %u][num_vowels: %u/%u][num_trigram_vowels: %u][num_trigram_found: %u/%u][vowels: %u][rc: %u]\\n\",",
          "7533:         name, num_found, num_impossible, num_digits, num_bigram_checks, num_vowels, len, num_trigram_vowels,",
          "7534:         num_trigram_checked, num_trigram_found, num_vowels, rc);",
          "7536:       if((len > 16) && (num_dots < 3) && ((num_vowels*4) < (len-num_dots))) {",
          "7537:  if((num_trigram_checked > 2) && (num_trigram_vowels >= (num_trigram_found-1)))",
          "7539:  else",
          "7541:       }",
          "7543:       if(num_bigram_checks",
          "7544:   && (num_dots > 0)",
          "7545:   && ((num_found == 0) || ((num_digits > 5) && (num_words <= 3))",
          "7546:       || enough(num_found, num_impossible)",
          "7547:       || ((num_trigram_checked > 2)",
          "7548:    && ((num_trigram_found < (num_trigram_checked/2))",
          "7549:        || ((num_trigram_vowels < (num_trigram_found-1)) && (num_dash == 0) && (num_dots > 1)))",
          "7550:    )",
          "7551:       )",
          "7552:   )",
          "7553:  rc = 1;",
          "7555:       if((num_trigram_checked > 2) && (num_vowels == 0))",
          "7556:  rc = 1;",
          "7558:       if(num_dash > 2)",
          "7559:  rc = 0;",
          "7561:       if(ndpi_verbose_dga_detection) {",
          "7562:  if(rc)",
          "7563:    printf(\"DGA %s [num_found: %u][num_impossible: %u]\\n\",",
          "7564:    name, num_found, num_impossible);",
          "7566:     }",
          "7568:     if(ndpi_verbose_dga_detection)",
          "7569:       printf(\"[DGA] Result: %u\\n\", rc);",
          "7571:     if(rc && flow)",
          "7572:       ndpi_set_risk(flow, NDPI_SUSPICIOUS_DGA_DOMAIN);",
          "7574:     return(rc);",
          "7576: }",
          "",
          "---------------"
        ],
        "src/lib/ndpi_utils.c||src/lib/ndpi_utils.c": [
          "File: src/lib/ndpi_utils.c -> src/lib/ndpi_utils.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1714:     return(\"Possibly Malicious JA3 Fingerprint\");",
          "1716:   case NDPI_MALICIOUS_SHA1_CERTIFICATE:",
          "1719:   case NDPI_DESKTOP_OR_FILE_SHARING_SESSION:",
          "1720:     return(\"Desktop/File Sharing Session\");",
          "",
          "[Removed Lines]",
          "1717:     return(\"Possibly Malicious SSL Certificate SHA1 Fingerprint\");",
          "",
          "[Added Lines]",
          "1717:     return(\"Possibly Malicious SSL Cert. SHA1 Fingerprint\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1784: u_int16_t ndpi_risk2score(ndpi_risk risk) {",
          "1785:   u_int16_t score = 0;",
          "1786:   u_int32_t i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1784: const char* ndpi_severity2str(ndpi_risk_severity s) {",
          "1785:   switch(s) {",
          "1786:   case NDPI_RISK_LOW:",
          "1787:     return(\"Low\");",
          "1788:     break;",
          "1790:   case NDPI_RISK_MEDIUM:",
          "1791:     return(\"Medium\");",
          "1792:     break;",
          "1794:   case NDPI_RISK_HIGH:",
          "1795:     return(\"High\");",
          "1796:     break;",
          "1798:   case NDPI_RISK_SEVERE:",
          "1799:     return(\"Severe\");",
          "1800:     break;",
          "1801:   }",
          "1802: }",
          "",
          "---------------"
        ],
        "src/lib/protocols/tls.c||src/lib/protocols/tls.c": [
          "File: src/lib/protocols/tls.c -> src/lib/protocols/tls.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1513:    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 1;",
          "1514:  else if(safari_ciphers == 12)",
          "1515:    flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls = 1;",
          "1516:       } else {",
          "1517:  invalid_ja3 = 1;",
          "1518: #ifdef DEBUG_TLS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1519: #ifdef DEBUG_HEURISTIC",
          "1520:  printf(\"[is_chrome_tls: %u][is_safari_tls: %u]\\n\",",
          "1521:         flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls,",
          "1522:         flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls);",
          "1523: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1725:   }",
          "1727:   for(i=0; i<tot_signature_algorithms_len; i+=2) {",
          "1733:     case ECDSA_SECP521R1_SHA512:",
          "1734:       flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls = 1;",
          "1735:       break;",
          "",
          "[Removed Lines]",
          "1728:     u_int16_t cipher_id = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));",
          "1732:     switch(cipher_id) {",
          "",
          "[Added Lines]",
          "1736:     u_int16_t signature_algo = (u_int16_t)ntohs(*((u_int16_t*)&packet->payload[s_offset+i]));",
          "1738: #ifdef DEBUG_HEURISTIC",
          "1739:     printf(\"[TLS Signature Algorithm] 0x%04X\\n\", signature_algo);",
          "1740: #endif",
          "1741:     switch(signature_algo) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1757:   if(chrome_signature_algorithms != 8)",
          "1758:      flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls = 0;",
          "1760:   ja3.client.signature_algorithms[i*2] = '\\0';",
          "1762: #ifdef DEBUG_TLS",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1769: #ifdef DEBUG_HEURISTIC",
          "1770:   printf(\"[is_firefox_tls: %u][is_chrome_tls: %u][is_safari_tls: %u]\\n\",",
          "1771:          flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_firefox_tls,",
          "1772:          flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_chrome_tls,",
          "1773:          flow->protos.tls_quic_stun.tls_quic.browser_euristics.is_safari_tls);",
          "1774: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d6a97219ea14f0eb4d7d0831d4aefc971878caae",
      "candidate_info": {
        "commit_hash": "d6a97219ea14f0eb4d7d0831d4aefc971878caae",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/d6a97219ea14f0eb4d7d0831d4aefc971878caae",
        "files": [
          "src/lib/ndpi_main.c"
        ],
        "message": "Fix use-after-free in http content parsing",
        "before_after_code_files": [
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4379:     packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,",
          "4380:     packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,",
          "4381:     packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,",
          "4383: }",
          "",
          "[Removed Lines]",
          "4382:     packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;",
          "",
          "[Added Lines]",
          "4382:     packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0,",
          "4383:     packet->forwarded_line.ptr = NULL, packet->forwarded_line.len = 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "62fa0908a3fd0b3f354f420ca7259d414be3ba59",
      "candidate_info": {
        "commit_hash": "62fa0908a3fd0b3f354f420ca7259d414be3ba59",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/62fa0908a3fd0b3f354f420ca7259d414be3ba59",
        "files": [
          "src/lib/ndpi_main.c",
          "src/lib/protocols/steam.c",
          "tests/pcap/steam.pcap",
          "tests/result/steam.pcap.out"
        ],
        "message": "Improved packet datastructure cleanup after packet processing Cleaned up code of steam dissector Added steam test pcap",
        "before_after_code_files": [
          "src/lib/ndpi_main.c||src/lib/ndpi_main.c",
          "src/lib/protocols/steam.c||src/lib/protocols/steam.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ],
          "candidate": [
            "src/lib/ndpi_main.c||src/lib/ndpi_main.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/ndpi_main.c||src/lib/ndpi_main.c": [
          "File: src/lib/ndpi_main.c -> src/lib/ndpi_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4463: ndpi_protocol ndpi_detection_process_packet(struct ndpi_detection_module_struct *ndpi_struct,",
          "4464:          struct ndpi_flow_struct *flow,",
          "4465:          const unsigned char *packet,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4463: static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {",
          "4464:   packet->parsed_lines = 0,",
          "4465:   packet->empty_line_position_set = 0,",
          "4466:   packet->host_line.ptr = NULL,",
          "4467:   packet->host_line.len = 0,",
          "4468:   packet->referer_line.ptr = NULL,",
          "4469:   packet->referer_line.len = 0,",
          "4470:   packet->content_line.ptr = NULL,",
          "4471:   packet->content_line.len = 0,",
          "4472:   packet->accept_line.ptr = NULL,",
          "4473:   packet->accept_line.len = 0,",
          "4474:   packet->user_agent_line.ptr = NULL,",
          "4475:   packet->user_agent_line.len = 0,",
          "4476:   packet->http_url_name.ptr = NULL,",
          "4477:   packet->http_url_name.len = 0,",
          "4478:   packet->http_encoding.ptr = NULL,",
          "4479:   packet->http_encoding.len = 0,",
          "4480:   packet->http_transfer_encoding.ptr = NULL,",
          "4481:   packet->http_transfer_encoding.len = 0,",
          "4482:   packet->http_contentlen.ptr = NULL,",
          "4483:   packet->http_contentlen.len = 0,",
          "4484:   packet->http_cookie.ptr = NULL,",
          "4485:   packet->http_cookie.len = 0,",
          "4486:   packet->http_origin.len = 0,",
          "4487:   packet->http_origin.ptr = NULL,",
          "4488:   packet->http_x_session_type.ptr = NULL,",
          "4489:   packet->http_x_session_type.len = 0,",
          "4490:   packet->server_line.ptr = NULL,",
          "4491:   packet->server_line.len = 0,",
          "4492:   packet->http_method.ptr = NULL,",
          "4493:   packet->http_method.len = 0,",
          "4494:   packet->http_response.ptr = NULL,",
          "4495:   packet->http_response.len = 0,",
          "4496:   packet->http_num_headers = 0;",
          "4497: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4701:      Invalidate packet memory to avoid accessing the pointers below",
          "4702:      when the packet is no longer accessible",
          "4706:   return(ret);",
          "4707: }",
          "",
          "[Removed Lines]",
          "4704:   flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL;",
          "",
          "[Added Lines]",
          "4742:   flow->packet.iph = NULL, flow->packet.tcp = NULL, flow->packet.udp = NULL, flow->packet.payload = NULL;",
          "4743:   ndpi_reset_packet_line_info(&flow->packet);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "4864:     return;",
          "4866:   packet->packet_lines_parsed_complete = 1;",
          "4901:   if((packet->payload_packet_len < 3)",
          "4902:      || (packet->payload == NULL))",
          "4903:     return;",
          "",
          "[Removed Lines]",
          "4867:   packet->parsed_lines = 0;",
          "4868:   packet->empty_line_position_set = 0;",
          "4869:   packet->host_line.ptr = NULL;",
          "4870:   packet->host_line.len = 0;",
          "4871:   packet->referer_line.ptr = NULL;",
          "4872:   packet->referer_line.len = 0;",
          "4873:   packet->content_line.ptr = NULL;",
          "4874:   packet->content_line.len = 0;",
          "4875:   packet->accept_line.ptr = NULL;",
          "4876:   packet->accept_line.len = 0;",
          "4877:   packet->user_agent_line.ptr = NULL;",
          "4878:   packet->user_agent_line.len = 0;",
          "4879:   packet->http_url_name.ptr = NULL;",
          "4880:   packet->http_url_name.len = 0;",
          "4881:   packet->http_encoding.ptr = NULL;",
          "4882:   packet->http_encoding.len = 0;",
          "4883:   packet->http_transfer_encoding.ptr = NULL;",
          "4884:   packet->http_transfer_encoding.len = 0;",
          "4885:   packet->http_contentlen.ptr = NULL;",
          "4886:   packet->http_contentlen.len = 0;",
          "4887:   packet->http_cookie.ptr = NULL;",
          "4888:   packet->http_cookie.len = 0;",
          "4889:   packet->http_origin.len = 0;",
          "4890:   packet->http_origin.ptr = NULL;",
          "4891:   packet->http_x_session_type.ptr = NULL;",
          "4892:   packet->http_x_session_type.len = 0;",
          "4893:   packet->server_line.ptr = NULL;",
          "4894:   packet->server_line.len = 0;",
          "4895:   packet->http_method.ptr = NULL;",
          "4896:   packet->http_method.len = 0;",
          "4897:   packet->http_response.ptr = NULL;",
          "4898:   packet->http_response.len = 0;",
          "4899:   packet->http_num_headers=0;",
          "",
          "[Added Lines]",
          "4906:   ndpi_reset_packet_line_info(packet);",
          "",
          "---------------"
        ],
        "src/lib/protocols/steam.c||src/lib/protocols/steam.c": [
          "File: src/lib/protocols/steam.c -> src/lib/protocols/steam.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "242: void ndpi_search_steam(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow) {",
          "243:   struct ndpi_packet_struct *packet = &flow->packet;",
          "283:   }",
          "286: }",
          "291:   ndpi_set_bitmask_protocol_detection(\"Steam\", ndpi_struct, detection_bitmask, *id,",
          "292:           NDPI_PROTOCOL_STEAM,",
          "293:           ndpi_search_steam,",
          "",
          "[Removed Lines]",
          "246:   if (flow->packet_counter > 20) {",
          "247:     NDPI_EXCLUDE_PROTO(ndpi_struct, flow);",
          "248:     return;",
          "249:   }",
          "252:   if (packet->tcp_retransmission != 0) {",
          "253:     return;",
          "254:   }",
          "256:   if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM) {",
          "257:     return;",
          "258:   }",
          "260:   NDPI_LOG_DBG(ndpi_struct, \"search STEAM\\n\");",
          "261:   ndpi_check_steam_http(ndpi_struct, flow);",
          "263:   if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM) {",
          "264:     return;",
          "265:   }",
          "267:   ndpi_check_steam_tcp(ndpi_struct, flow);",
          "269:   if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM) {",
          "270:     return;",
          "271:   }",
          "273:   ndpi_check_steam_udp1(ndpi_struct, flow);",
          "275:   if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM) {",
          "276:     return;",
          "277:   }",
          "279:   ndpi_check_steam_udp2(ndpi_struct, flow);",
          "281:   if (packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM) {",
          "282:     return;",
          "285:   ndpi_check_steam_udp3(ndpi_struct, flow);",
          "289: void init_steam_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)",
          "290: {",
          "",
          "[Added Lines]",
          "246:   if(flow->packet.udp != NULL) {",
          "247:     if(flow->packet_counter > 5) {",
          "248:       NDPI_EXCLUDE_PROTO(ndpi_struct, flow);",
          "249:       return;",
          "250:     }",
          "252:     ndpi_check_steam_udp1(ndpi_struct, flow);",
          "254:     if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM)",
          "255:       return;",
          "257:     ndpi_check_steam_udp2(ndpi_struct, flow);",
          "259:     if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM)",
          "260:       return;",
          "262:     ndpi_check_steam_udp3(ndpi_struct, flow);",
          "263:   } else {",
          "265:     if(flow->packet_counter > 10) {",
          "266:       NDPI_EXCLUDE_PROTO(ndpi_struct, flow);",
          "267:       return;",
          "268:     }",
          "272:     if(packet->tcp_retransmission != 0) {",
          "273:       return;",
          "274:     }",
          "276:     if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM)",
          "277:       return;",
          "279:     NDPI_LOG_DBG(ndpi_struct, \"search STEAM\\n\");",
          "280:     ndpi_check_steam_http(ndpi_struct, flow);",
          "282:     if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM)",
          "283:       return;",
          "285:     ndpi_check_steam_tcp(ndpi_struct, flow);",
          "287:     if(packet->detected_protocol_stack[0] == NDPI_PROTOCOL_STEAM)",
          "288:       return;",
          "293: void init_steam_dissector(struct ndpi_detection_module_struct *ndpi_struct,",
          "294:      u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-4014",
  "cve_desc": "The capabilities implementation in the Linux kernel before 3.14.8 does not properly consider that namespaces are inapplicable to inodes, which allows local users to bypass intended chmod restrictions by first creating a user namespace, as demonstrated by setting the setgid bit on a file with group ownership of root.",
  "repo": "torvalds/linux",
  "patch_hash": "23adbe12ef7d3d4195e80800ab36b37bee28cd03",
  "patch_info": {
    "commit_hash": "23adbe12ef7d3d4195e80800ab36b37bee28cd03",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/23adbe12ef7d3d4195e80800ab36b37bee28cd03",
    "files": [
      "fs/attr.c",
      "fs/inode.c",
      "fs/namei.c",
      "fs/xfs/xfs_ioctl.c",
      "include/linux/capability.h",
      "kernel/capability.c"
    ],
    "message": "fs,userns: Change inode_capable to capable_wrt_inode_uidgid\n\nThe kernel has no concept of capabilities with respect to inodes; inodes\nexist independently of namespaces.  For example, inode_capable(inode,\nCAP_LINUX_IMMUTABLE) would be nonsense.\n\nThis patch changes inode_capable to check for uid and gid mappings and\nrenames it to capable_wrt_inode_uidgid, which should make it more\nobvious what it does.\n\nFixes CVE-2014-4014.\n\nCc: Theodore Ts'o <tytso@mit.edu>\nCc: Serge Hallyn <serge.hallyn@ubuntu.com>\nCc: \"Eric W. Biederman\" <ebiederm@xmission.com>\nCc: Dave Chinner <david@fromorbit.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Andy Lutomirski <luto@amacapital.net>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "fs/attr.c||fs/attr.c",
      "fs/inode.c||fs/inode.c",
      "fs/namei.c||fs/namei.c",
      "fs/xfs/xfs_ioctl.c||fs/xfs/xfs_ioctl.c",
      "include/linux/capability.h||include/linux/capability.h",
      "kernel/capability.c||kernel/capability.c"
    ]
  },
  "patch_diff": {
    "fs/attr.c||fs/attr.c": [
      "File: fs/attr.c -> fs/attr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "50:  if ((ia_valid & ATTR_UID) &&",
      "51:      (!uid_eq(current_fsuid(), inode->i_uid) ||",
      "52:       !uid_eq(attr->ia_uid, inode->i_uid)) &&",
      "54:   return -EPERM;",
      "57:  if ((ia_valid & ATTR_GID) &&",
      "58:      (!uid_eq(current_fsuid(), inode->i_uid) ||",
      "59:      (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&",
      "61:   return -EPERM;",
      "",
      "[Removed Lines]",
      "53:      !inode_capable(inode, CAP_CHOWN))",
      "60:      !inode_capable(inode, CAP_CHOWN))",
      "",
      "[Added Lines]",
      "53:      !capable_wrt_inode_uidgid(inode, CAP_CHOWN))",
      "60:      !capable_wrt_inode_uidgid(inode, CAP_CHOWN))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "68:   if (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :",
      "69:     inode->i_gid) &&",
      "71:    attr->ia_mode &= ~S_ISGID;",
      "72:  }",
      "",
      "[Removed Lines]",
      "70:       !inode_capable(inode, CAP_FSETID))",
      "",
      "[Added Lines]",
      "70:       !capable_wrt_inode_uidgid(inode, CAP_FSETID))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "160:   umode_t mode = attr->ia_mode;",
      "162:   if (!in_group_p(inode->i_gid) &&",
      "164:    mode &= ~S_ISGID;",
      "165:   inode->i_mode = mode;",
      "166:  }",
      "",
      "[Removed Lines]",
      "163:       !inode_capable(inode, CAP_FSETID))",
      "",
      "[Added Lines]",
      "163:       !capable_wrt_inode_uidgid(inode, CAP_FSETID))",
      "",
      "---------------"
    ],
    "fs/inode.c||fs/inode.c": [
      "File: fs/inode.c -> fs/inode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1845: bool inode_owner_or_capable(const struct inode *inode)",
      "1846: {",
      "1847:  if (uid_eq(current_fsuid(), inode->i_uid))",
      "1848:   return true;",
      "1850:   return true;",
      "1851:  return false;",
      "1852: }",
      "",
      "[Removed Lines]",
      "1849:  if (inode_capable(inode, CAP_FOWNER))",
      "",
      "[Added Lines]",
      "1847:  struct user_namespace *ns;",
      "1852:  ns = current_user_ns();",
      "1853:  if (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))",
      "",
      "---------------"
    ],
    "fs/namei.c||fs/namei.c": [
      "File: fs/namei.c -> fs/namei.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "333:  if (S_ISDIR(inode->i_mode)) {",
      "336:    return 0;",
      "337:   if (!(mask & MAY_WRITE))",
      "339:     return 0;",
      "340:   return -EACCES;",
      "341:  }",
      "",
      "[Removed Lines]",
      "335:   if (inode_capable(inode, CAP_DAC_OVERRIDE))",
      "338:    if (inode_capable(inode, CAP_DAC_READ_SEARCH))",
      "",
      "[Added Lines]",
      "335:   if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))",
      "338:    if (capable_wrt_inode_uidgid(inode,",
      "339:            CAP_DAC_READ_SEARCH))",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "347:  if (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))",
      "349:    return 0;",
      "",
      "[Removed Lines]",
      "348:   if (inode_capable(inode, CAP_DAC_OVERRIDE))",
      "",
      "[Added Lines]",
      "349:   if (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "354:  mask &= MAY_READ | MAY_WRITE | MAY_EXEC;",
      "355:  if (mask == MAY_READ)",
      "357:    return 0;",
      "359:  return -EACCES;",
      "",
      "[Removed Lines]",
      "356:   if (inode_capable(inode, CAP_DAC_READ_SEARCH))",
      "",
      "[Added Lines]",
      "357:   if (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2379:   return 0;",
      "2380:  if (uid_eq(dir->i_uid, fsuid))",
      "2381:   return 0;",
      "2383: }",
      "",
      "[Removed Lines]",
      "2382:  return !inode_capable(inode, CAP_FOWNER);",
      "",
      "[Added Lines]",
      "2383:  return !capable_wrt_inode_uidgid(inode, CAP_FOWNER);",
      "",
      "---------------"
    ],
    "fs/xfs/xfs_ioctl.c||fs/xfs/xfs_ioctl.c": [
      "File: fs/xfs/xfs_ioctl.c -> fs/xfs/xfs_ioctl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1217:   if ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&",
      "1219:    ip->i_d.di_mode &= ~(S_ISUID|S_ISGID);",
      "",
      "[Removed Lines]",
      "1218:       !inode_capable(VFS_I(ip), CAP_FSETID))",
      "",
      "[Added Lines]",
      "1218:       !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))",
      "",
      "---------------"
    ],
    "include/linux/capability.h||include/linux/capability.h": [
      "File: include/linux/capability.h -> include/linux/capability.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "210:           struct user_namespace *ns, int cap);",
      "211: extern bool capable(int cap);",
      "212: extern bool ns_capable(struct user_namespace *ns, int cap);",
      "214: extern bool file_ns_capable(const struct file *file, struct user_namespace *ns, int cap);",
      "",
      "[Removed Lines]",
      "213: extern bool inode_capable(const struct inode *inode, int cap);",
      "",
      "[Added Lines]",
      "213: extern bool capable_wrt_inode_uidgid(const struct inode *inode, int cap);",
      "",
      "---------------"
    ],
    "kernel/capability.c||kernel/capability.c": [
      "File: kernel/capability.c -> kernel/capability.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "424: EXPORT_SYMBOL(capable);",
      "441: {",
      "442:  struct user_namespace *ns = current_user_ns();",
      "445: }",
      "",
      "[Removed Lines]",
      "440: bool inode_capable(const struct inode *inode, int cap)",
      "444:  return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);",
      "446: EXPORT_SYMBOL(inode_capable);",
      "",
      "[Added Lines]",
      "435: bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)",
      "439:  return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&",
      "440:   kgid_has_mapping(ns, inode->i_gid);",
      "442: EXPORT_SYMBOL(capable_wrt_inode_uidgid);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "fd5e2aa8653665ae1cc60f7aca1069abdbcad3f6",
      "candidate_info": {
        "commit_hash": "fd5e2aa8653665ae1cc60f7aca1069abdbcad3f6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/fd5e2aa8653665ae1cc60f7aca1069abdbcad3f6",
        "files": [
          "fs/xfs/xfs_ioctl.c",
          "kernel/capability.c"
        ],
        "message": "xfs: ioctl check for capabilities in the current user namespace\n\nUse inode_capable() to check if SUID|SGID bits should be cleared to match\nsimilar check in inode_change_ok().\n\nThe check for CAP_LINUX_IMMUTABLE was not modified since all other file\nsystems also check against init_user_ns rather than current_user_ns.\n\nOnly allow changing of projid from init_user_ns.\n\nReviewed-by: Dave Chinner <dchinner@redhat.com>\nReviewed-by: Gao feng <gaofeng@cn.fujitsu.com>\nSigned-off-by: Dwight Engen <dwight.engen@oracle.com>\nSigned-off-by: Ben Myers <bpm@sgi.com>",
        "before_after_code_files": [
          "fs/xfs/xfs_ioctl.c||fs/xfs/xfs_ioctl.c",
          "kernel/capability.c||kernel/capability.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/xfs/xfs_ioctl.c||fs/xfs/xfs_ioctl.c",
            "kernel/capability.c||kernel/capability.c"
          ],
          "candidate": [
            "fs/xfs/xfs_ioctl.c||fs/xfs/xfs_ioctl.c",
            "kernel/capability.c||kernel/capability.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/xfs/xfs_ioctl.c||fs/xfs/xfs_ioctl.c": [
          "File: fs/xfs/xfs_ioctl.c -> fs/xfs/xfs_ioctl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1019:   code = XFS_ERROR(EPERM);",
          "1020:   goto error_return;",
          "1021:  }",
          "1026:  if (mask & FSX_PROJID) {",
          "1027:   if (XFS_IS_QUOTA_RUNNING(mp) &&",
          "1028:       XFS_IS_PQUOTA_ON(mp) &&",
          "1029:       xfs_get_projid(ip) != fa->fsx_projid) {",
          "",
          "[Removed Lines]",
          "1018:  if (current_fsuid() != ip->i_d.di_uid && !capable(CAP_FOWNER)) {",
          "",
          "[Added Lines]",
          "1018:  if (!inode_owner_or_capable(VFS_I(ip))) {",
          "1029:   if (current_user_ns() != &init_user_ns) {",
          "1030:    code = XFS_ERROR(EINVAL);",
          "1031:    goto error_return;",
          "1032:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1139:   if ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&",
          "1141:    ip->i_d.di_mode &= ~(S_ISUID|S_ISGID);",
          "",
          "[Removed Lines]",
          "1140:       !capable(CAP_FSETID))",
          "",
          "[Added Lines]",
          "1147:       !inode_capable(VFS_I(ip), CAP_FSETID))",
          "",
          "---------------"
        ],
        "kernel/capability.c||kernel/capability.c": [
          "File: kernel/capability.c -> kernel/capability.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "465:  return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);",
          "466: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "467: EXPORT_SYMBOL(inode_capable);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2018-13100",
  "cve_desc": "An issue was discovered in fs/f2fs/super.c in the Linux kernel through 4.17.3, which does not properly validate secs_per_zone in a corrupted f2fs image, as demonstrated by a divide-by-zero error.",
  "repo": "torvalds/linux",
  "patch_hash": "42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
  "patch_info": {
    "commit_hash": "42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/42bf546c1fe3f3654bdf914e977acbc2b80a5be5",
    "files": [
      "fs/f2fs/super.c"
    ],
    "message": "f2fs: fix to do sanity check with secs_per_zone\n\nAs Wen Xu reported in below link:\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=200183\n\n- Overview\nDivide zero in reset_curseg() when mounting a crafted f2fs image\n\n- Reproduce\n\n- Kernel message\n[  588.281510] divide error: 0000 [#1] SMP KASAN PTI\n[  588.282701] CPU: 0 PID: 1293 Comm: mount Not tainted 4.18.0-rc1+ #4\n[  588.284000] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n[  588.286178] RIP: 0010:reset_curseg+0x94/0x1a0\n[  588.298166] RSP: 0018:ffff8801e88d7940 EFLAGS: 00010246\n[  588.299360] RAX: 0000000000000014 RBX: ffff8801e1d46d00 RCX: ffffffffb88bf60b\n[  588.300809] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e1d46d64\n[  588.305272] R13: 0000000000000000 R14: 0000000000000014 R15: 0000000000000000\n[  588.306822] FS:  00007fad85008840(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  588.308456] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  588.309623] CR2: 0000000001705078 CR3: 00000001f30f8000 CR4: 00000000000006f0\n[  588.311085] Call Trace:\n[  588.311637]  f2fs_build_segment_manager+0x103f/0x3410\n[  588.316136]  ? f2fs_commit_super+0x1b0/0x1b0\n[  588.317031]  ? set_blocksize+0x90/0x140\n[  588.319473]  f2fs_mount+0x15/0x20\n[  588.320166]  mount_fs+0x60/0x1a0\n[  588.320847]  ? alloc_vfsmnt+0x309/0x360\n[  588.321647]  vfs_kern_mount+0x6b/0x1a0\n[  588.322432]  do_mount+0x34a/0x18c0\n[  588.323175]  ? strndup_user+0x46/0x70\n[  588.323937]  ? copy_mount_string+0x20/0x20\n[  588.324793]  ? memcg_kmem_put_cache+0x1b/0xa0\n[  588.325702]  ? kasan_check_write+0x14/0x20\n[  588.326562]  ? _copy_from_user+0x6a/0x90\n[  588.327375]  ? memdup_user+0x42/0x60\n[  588.328118]  ksys_mount+0x83/0xd0\n[  588.328808]  __x64_sys_mount+0x67/0x80\n[  588.329607]  do_syscall_64+0x78/0x170\n[  588.330400]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  588.331461] RIP: 0033:0x7fad848e8b9a\n[  588.336022] RSP: 002b:00007ffd7c5b6be8 EFLAGS: 00000206 ORIG_RAX: 00000000000000a5\n[  588.337547] RAX: ffffffffffffffda RBX: 00000000016f8030 RCX: 00007fad848e8b9a\n[  588.338999] RDX: 00000000016f8210 RSI: 00000000016f9f30 RDI: 0000000001700ec0\n[  588.340442] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000013\n[  588.341887] R10: 00000000c0ed0000 R11: 0000000000000206 R12: 0000000001700ec0\n[  588.343341] R13: 00000000016f8210 R14: 0000000000000000 R15: 0000000000000003\n[  588.354891] ---[ end trace 4ce02f25ff7d3df5 ]---\n[  588.355862] RIP: 0010:reset_curseg+0x94/0x1a0\n[  588.360742] RSP: 0018:ffff8801e88d7940 EFLAGS: 00010246\n[  588.361812] RAX: 0000000000000014 RBX: ffff8801e1d46d00 RCX: ffffffffb88bf60b\n[  588.363485] RDX: 0000000000000000 RSI: dffffc0000000000 RDI: ffff8801e1d46d64\n[  588.365213] RBP: ffff8801e88d7968 R08: ffffed003c32266f R09: ffffed003c32266f\n[  588.366661] R10: 0000000000000001 R11: ffffed003c32266e R12: ffff8801f0337700\n[  588.368110] R13: 0000000000000000 R14: 0000000000000014 R15: 0000000000000000\n[  588.370057] FS:  00007fad85008840(0000) GS:ffff8801f6e00000(0000) knlGS:0000000000000000\n[  588.372099] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  588.373291] CR2: 0000000001705078 CR3: 00000001f30f8000 CR4: 00000000000006f0\n\n- Location\nhttps://elixir.bootlin.com/linux/latest/source/fs/f2fs/segment.c#L2147\n        curseg->zone = GET_ZONE_FROM_SEG(sbi, curseg->segno);\n\nIf secs_per_zone is corrupted due to fuzzing test, it will cause divide\nzero operation when using GET_ZONE_FROM_SEG macro, so we should do more\nsanity check with secs_per_zone during mount to avoid this issue.\n\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
    "before_after_code_files": [
      "fs/f2fs/super.c||fs/f2fs/super.c"
    ]
  },
  "patch_diff": {
    "fs/f2fs/super.c||fs/f2fs/super.c": [
      "File: fs/f2fs/super.c -> fs/f2fs/super.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2227:   return 1;",
      "2228:  }",
      "2231:   f2fs_msg(sb, KERN_INFO,",
      "2233:    secs_per_zone, total_sections);",
      "2234:   return 1;",
      "2235:  }",
      "",
      "[Removed Lines]",
      "2230:  if (secs_per_zone > total_sections) {",
      "2232:    \"Wrong secs_per_zone (%u > %u)\",",
      "",
      "[Added Lines]",
      "2230:  if (secs_per_zone > total_sections || !secs_per_zone) {",
      "2232:    \"Wrong secs_per_zone / total_sections (%u, %u)\",",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e2374015f27fe5ee5d5c37966e2faf396cdaaa65",
      "candidate_info": {
        "commit_hash": "e2374015f27fe5ee5d5c37966e2faf396cdaaa65",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e2374015f27fe5ee5d5c37966e2faf396cdaaa65",
        "files": [
          "fs/f2fs/f2fs.h",
          "fs/f2fs/node.c"
        ],
        "message": "f2fs: fix to propagate return value of scan_nat_page()\n\nAs Anatoly Trosinenko reported in bugzilla:\n\nHow to reproduce:\n1. Compile the 73fcb1a370c76 version of the kernel using the config attached\n2. Unpack and mount the attached filesystem image as F2FS\n3. The kernel will BUG() on mount (BUGs are explicitly enabled in config)\n\n[    2.233612] F2FS-fs (sda): Found nat_bits in checkpoint\n[    2.248422] ------------[ cut here ]------------\n[    2.248857] kernel BUG at fs/f2fs/node.c:1967!\n[    2.249760] invalid opcode: 0000 [#1] SMP NOPTI\n[    2.250219] Modules linked in:\n[    2.251848] CPU: 0 PID: 944 Comm: mount Not tainted 4.17.0-rc5+ #1\n[    2.252331] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\n[    2.253305] RIP: 0010:build_free_nids+0x337/0x3f0\n[    2.253672] RSP: 0018:ffffae7fc0857c50 EFLAGS: 00000246\n[    2.254080] RAX: 00000000ffffffff RBX: 0000000000000123 RCX: 0000000000000001\n[    2.254638] RDX: ffff9aa7063d5c00 RSI: 0000000000000122 RDI: ffff9aa705852e00\n[    2.255190] RBP: ffff9aa705852e00 R08: 0000000000000001 R09: ffff9aa7059090c0\n[    2.255719] R10: 0000000000000000 R11: 0000000000000000 R12: ffff9aa705852e00\n[    2.256242] R13: ffff9aa7063ad000 R14: ffff9aa705919000 R15: 0000000000000123\n[    2.256809] FS:  00000000023078c0(0000) GS:ffff9aa707800000(0000) knlGS:0000000000000000\n[    2.258654] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[    2.259153] CR2: 00000000005511ae CR3: 0000000005872000 CR4: 00000000000006f0\n[    2.259801] Call Trace:\n[    2.260583]  build_node_manager+0x5cd/0x600\n[    2.260963]  f2fs_fill_super+0x66a/0x17c0\n[    2.261300]  ? f2fs_commit_super+0xe0/0xe0\n[    2.261622]  mount_bdev+0x16e/0x1a0\n[    2.261899]  mount_fs+0x30/0x150\n[    2.262398]  vfs_kern_mount.part.28+0x4f/0xf0\n[    2.262743]  do_mount+0x5d0/0xc60\n[    2.263010]  ? _copy_from_user+0x37/0x60\n[    2.263313]  ? memdup_user+0x39/0x60\n[    2.263692]  ksys_mount+0x7b/0xd0\n[    2.263960]  __x64_sys_mount+0x1c/0x20\n[    2.264268]  do_syscall_64+0x43/0xf0\n[    2.264560]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[    2.265095] RIP: 0033:0x48d31a\n[    2.265502] RSP: 002b:00007ffc6fe60a08 EFLAGS: 00000246 ORIG_RAX: 00000000000000a5\n[    2.266089] RAX: ffffffffffffffda RBX: 0000000000008000 RCX: 000000000048d31a\n[    2.266607] RDX: 00007ffc6fe62fa5 RSI: 00007ffc6fe62f9d RDI: 00007ffc6fe62f94\n[    2.267130] RBP: 00000000023078a0 R08: 0000000000000000 R09: 0000000000000000\n[    2.267670] R10: 0000000000008000 R11: 0000000000000246 R12: 0000000000000000\n[    2.268192] R13: 0000000000000000 R14: 00007ffc6fe60c78 R15: 0000000000000000\n[    2.268767] Code: e8 5f c3 ff ff 83 c3 01 41 83 c7 01 81 fb c7 01 00 00 74 48 44 39 7d 04 76 42 48 63 c3 48 8d 04 c0 41 8b 44 06 05 83 f8 ff 75 c1 <0f> 0b 49 8b 45 50 48 8d b8 b0 00 00 00 e8 37 59 69 00 b9 01 00\n[    2.270434] RIP: build_free_nids+0x337/0x3f0 RSP: ffffae7fc0857c50\n[    2.271426] ---[ end trace ab20c06cd3c8fde4 ]---\n\nDuring loading NAT entries, we will do sanity check, once the entry info\nis corrupted, it will cause BUG_ON directly to protect user data from\nbeing overwrited.\n\nIn this case, it will be better to just return failure on mount() instead\nof panic, so that user can get hint from kmsg and try fsck for recovery\nimmediately rather than after an abnormal reboot.\n\nhttps://bugzilla.kernel.org/show_bug.cgi?id=199769\n\nReported-by: Anatoly Trosinenko <anatoly.trosinenko@gmail.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/node.c||fs/f2fs/node.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2813: int f2fs_sync_node_pages(struct f2fs_sb_info *sbi,",
          "2814:    struct writeback_control *wbc,",
          "2815:    bool do_balance, enum iostat_type io_type);",
          "2817: bool f2fs_alloc_nid(struct f2fs_sb_info *sbi, nid_t *nid);",
          "2818: void f2fs_alloc_nid_done(struct f2fs_sb_info *sbi, nid_t nid);",
          "2819: void f2fs_alloc_nid_failed(struct f2fs_sb_info *sbi, nid_t nid);",
          "",
          "[Removed Lines]",
          "2816: void f2fs_build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount);",
          "",
          "[Added Lines]",
          "2816: int f2fs_build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount);",
          "",
          "---------------"
        ],
        "fs/f2fs/node.c||fs/f2fs/node.c": [
          "File: fs/f2fs/node.c -> fs/f2fs/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1977:   kmem_cache_free(free_nid_slab, i);",
          "1978: }",
          "1981:    struct page *nat_page, nid_t start_nid)",
          "1982: {",
          "1983:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "",
          "[Removed Lines]",
          "1980: static void scan_nat_page(struct f2fs_sb_info *sbi,",
          "",
          "[Added Lines]",
          "1980: static int scan_nat_page(struct f2fs_sb_info *sbi,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1995:    break;",
          "1997:   blk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);",
          "1999:   if (blk_addr == NULL_ADDR) {",
          "2000:    add_free_nid(sbi, start_nid, true, true);",
          "2001:   } else {",
          "",
          "[Removed Lines]",
          "1998:   f2fs_bug_on(sbi, blk_addr == NEW_ADDR);",
          "",
          "[Added Lines]",
          "1999:   if (blk_addr == NEW_ADDR)",
          "2000:    return -EINVAL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2004:    spin_unlock(&NM_I(sbi)->nid_list_lock);",
          "2005:   }",
          "2006:  }",
          "2007: }",
          "2009: static void scan_curseg_cache(struct f2fs_sb_info *sbi)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2011:  return 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2059:  up_read(&nm_i->nat_tree_lock);",
          "2060: }",
          "2063:       bool sync, bool mount)",
          "2064: {",
          "2065:  struct f2fs_nm_info *nm_i = NM_I(sbi);",
          "2067:  nid_t nid = nm_i->next_scan_nid;",
          "2069:  if (unlikely(nid >= nm_i->max_nid))",
          "",
          "[Removed Lines]",
          "2062: static void __f2fs_build_free_nids(struct f2fs_sb_info *sbi,",
          "2066:  int i = 0;",
          "",
          "[Added Lines]",
          "2067: static int __f2fs_build_free_nids(struct f2fs_sb_info *sbi,",
          "2071:  int i = 0, ret;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2073:  if (nm_i->nid_cnt[FREE_NID] >= NAT_ENTRY_PER_BLOCK)",
          "2076:  if (!sync && !f2fs_available_free_memory(sbi, FREE_NIDS))",
          "2079:  if (!mount) {",
          "2081:   scan_free_nid_bits(sbi);",
          "2083:   if (nm_i->nid_cnt[FREE_NID] >= NAT_ENTRY_PER_BLOCK)",
          "2085:  }",
          "",
          "[Removed Lines]",
          "2074:   return;",
          "2077:   return;",
          "2084:    return;",
          "",
          "[Added Lines]",
          "2079:   return 0;",
          "2082:   return 0;",
          "2089:    return 0;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2095:       nm_i->nat_block_bitmap)) {",
          "2096:    struct page *page = get_current_nat_page(sbi, nid);",
          "2099:    f2fs_put_page(page, 1);",
          "2100:   }",
          "2102:   nid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));",
          "",
          "[Removed Lines]",
          "2098:    scan_nat_page(sbi, page, nid);",
          "",
          "[Added Lines]",
          "2103:    ret = scan_nat_page(sbi, page, nid);",
          "2106:    if (ret) {",
          "2107:     up_read(&nm_i->nat_tree_lock);",
          "2108:     f2fs_bug_on(sbi, !mount);",
          "2109:     f2fs_msg(sbi->sb, KERN_ERR,",
          "2110:      \"NAT is corrupt, run fsck to fix it\");",
          "2111:     return -EINVAL;",
          "2112:    }",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2118:  f2fs_ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nm_i->next_scan_nid),",
          "2119:      nm_i->ra_nid_pages, META_NAT, false);",
          "2120: }",
          "2123: {",
          "2124:  mutex_lock(&NM_I(sbi)->build_lock);",
          "2126:  mutex_unlock(&NM_I(sbi)->build_lock);",
          "2127: }",
          "",
          "[Removed Lines]",
          "2122: void f2fs_build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)",
          "2125:  __f2fs_build_free_nids(sbi, sync, mount);",
          "",
          "[Added Lines]",
          "2134:  return 0;",
          "2137: int f2fs_build_free_nids(struct f2fs_sb_info *sbi, bool sync, bool mount)",
          "2139:  int ret;",
          "2142:  ret = __f2fs_build_free_nids(sbi, sync, mount);",
          "2145:  return ret;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2818:  load_free_nid_bitmap(sbi);",
          "2822: }",
          "2824: void f2fs_destroy_node_manager(struct f2fs_sb_info *sbi)",
          "",
          "[Removed Lines]",
          "2820:  f2fs_build_free_nids(sbi, true, true);",
          "2821:  return 0;",
          "",
          "[Added Lines]",
          "2839:  return f2fs_build_free_nids(sbi, true, true);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "46b3722cc7765582354488da633aafffcb138458",
      "candidate_info": {
        "commit_hash": "46b3722cc7765582354488da633aafffcb138458",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/46b3722cc7765582354488da633aafffcb138458",
        "files": [
          "tools/perf/util/comm.c"
        ],
        "message": "perf tools: Fix struct comm_str removal crash\n\nWe occasionaly hit following assert failure in 'perf top', when processing the\n/proc info in multiple threads.\n\n  perf: ...include/linux/refcount.h:109: refcount_inc:\n        Assertion `!(!refcount_inc_not_zero(r))' failed.\n\nThe gdb backtrace looks like this:\n\n  [Switching to Thread 0x7ffff11ba700 (LWP 13749)]\n  0x00007ffff50839fb in raise () from /lib64/libc.so.6\n  (gdb)\n  #0  0x00007ffff50839fb in raise () from /lib64/libc.so.6\n  #1  0x00007ffff5085800 in abort () from /lib64/libc.so.6\n  #2  0x00007ffff507c0da in __assert_fail_base () from /lib64/libc.so.6\n  #3  0x00007ffff507c152 in __assert_fail () from /lib64/libc.so.6\n  #4  0x0000000000535373 in refcount_inc (r=0x7fffdc009be0)\n      at ...include/linux/refcount.h:109\n  #5  0x00000000005354f1 in comm_str__get (cs=0x7fffdc009bc0)\n      at util/comm.c:24\n  #6  0x00000000005356bd in __comm_str__findnew (str=0x7fffd000b260 \":2\",\n      root=0xbed5c0 <comm_str_root>) at util/comm.c:72\n  #7  0x000000000053579e in comm_str__findnew (str=0x7fffd000b260 \":2\",\n      root=0xbed5c0 <comm_str_root>) at util/comm.c:95\n  #8  0x000000000053582e in comm__new (str=0x7fffd000b260 \":2\",\n      timestamp=0, exec=false) at util/comm.c:111\n  #9  0x00000000005363bc in thread__new (pid=2, tid=2) at util/thread.c:57\n  #10 0x0000000000523da0 in ____machine__findnew_thread (machine=0xbfde38,\n      threads=0xbfdf28, pid=2, tid=2, create=true) at util/machine.c:457\n  #11 0x0000000000523eb4 in __machine__findnew_thread (machine=0xbfde38,\n  ...\n\nThe failing assertion is this one:\n\n  REFCOUNT_WARN(!refcount_inc_not_zero(r), ...\n\nThe problem is that we keep global comm_str_root list, which\nis accessed by multiple threads during the 'perf top' startup\nand following 2 paths can race:\n\n  thread 1:\n    ...\n    thread__new\n      comm__new\n        comm_str__findnew\n          down_write(&comm_str_lock);\n          __comm_str__findnew\n            comm_str__get\n\n  thread 2:\n    ...\n    comm__override or comm__free\n      comm_str__put\n        refcount_dec_and_test\n          down_write(&comm_str_lock);\n          rb_erase(&cs->rb_node, &comm_str_root);\n\nBecause thread 2 first decrements the refcnt and only after then it removes the\nstruct comm_str from the list, the thread 1 can find this object on the list\nwith refcnt equls to 0 and hit the assert.\n\nThis patch fixes the thread 1 __comm_str__findnew path, by ignoring objects\nthat already dropped the refcnt to 0. For the rest of the objects we take the\nrefcnt before comparing its name and release it afterwards with comm_str__put,\nwhich can also release the object completely.\n\nSigned-off-by: Jiri Olsa <jolsa@kernel.org>\nAcked-by: Namhyung Kim <namhyung@kernel.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\nCc: Andi Kleen <ak@linux.intel.com>\nCc: David Ahern <dsahern@gmail.com>\nCc: Kan Liang <kan.liang@linux.intel.com>\nCc: Lukasz Odzioba <lukasz.odzioba@intel.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Wang Nan <wangnan0@huawei.com>\nCc: kernel-team@lge.com\nLink: http://lkml.kernel.org/r/20180720101740.GA27176@krava\nSigned-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>",
        "before_after_code_files": [
          "tools/perf/util/comm.c||tools/perf/util/comm.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "tools/perf/util/comm.c||tools/perf/util/comm.c": [
          "File: tools/perf/util/comm.c -> tools/perf/util/comm.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "21: static struct comm_str *comm_str__get(struct comm_str *cs)",
          "22: {",
          "26: }",
          "28: static void comm_str__put(struct comm_str *cs)",
          "",
          "[Removed Lines]",
          "23:  if (cs)",
          "24:   refcount_inc(&cs->refcnt);",
          "25:  return cs;",
          "",
          "[Added Lines]",
          "23:  if (cs && refcount_inc_not_zero(&cs->refcnt))",
          "24:   return cs;",
          "26:  return NULL;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:   parent = *p;",
          "68:   iter = rb_entry(parent, struct comm_str, rb_node);",
          "70:   cmp = strcmp(str, iter->str);",
          "74:   if (cmp < 0)",
          "75:    p = &(*p)->rb_left;",
          "",
          "[Removed Lines]",
          "71:   if (!cmp)",
          "72:    return comm_str__get(iter);",
          "",
          "[Added Lines]",
          "77:   if (!cmp && comm_str__get(iter))",
          "78:    return iter;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "89da619bc18d79bca5304724c11d4ba3b67ce2c6",
      "candidate_info": {
        "commit_hash": "89da619bc18d79bca5304724c11d4ba3b67ce2c6",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/89da619bc18d79bca5304724c11d4ba3b67ce2c6",
        "files": [
          "drivers/virtio/virtio_balloon.c"
        ],
        "message": "virtio_balloon: fix another race between migration and ballooning\n\nKernel panic when with high memory pressure, calltrace looks like,\n\nPID: 21439 TASK: ffff881be3afedd0 CPU: 16 COMMAND: \"java\"\n #0 [ffff881ec7ed7630] machine_kexec at ffffffff81059beb\n #1 [ffff881ec7ed7690] __crash_kexec at ffffffff81105942\n #2 [ffff881ec7ed7760] crash_kexec at ffffffff81105a30\n #3 [ffff881ec7ed7778] oops_end at ffffffff816902c8\n #4 [ffff881ec7ed77a0] no_context at ffffffff8167ff46\n #5 [ffff881ec7ed77f0] __bad_area_nosemaphore at ffffffff8167ffdc\n #6 [ffff881ec7ed7838] __node_set at ffffffff81680300\n #7 [ffff881ec7ed7860] __do_page_fault at ffffffff8169320f\n #8 [ffff881ec7ed78c0] do_page_fault at ffffffff816932b5\n #9 [ffff881ec7ed78f0] page_fault at ffffffff8168f4c8\n    [exception RIP: _raw_spin_lock_irqsave+47]\n    RIP: ffffffff8168edef RSP: ffff881ec7ed79a8 RFLAGS: 00010046\n    RAX: 0000000000000246 RBX: ffffea0019740d00 RCX: ffff881ec7ed7fd8\n    RDX: 0000000000020000 RSI: 0000000000000016 RDI: 0000000000000008\n    RBP: ffff881ec7ed79a8 R8: 0000000000000246 R9: 000000000001a098\n    R10: ffff88107ffda000 R11: 0000000000000000 R12: 0000000000000000\n    R13: 0000000000000008 R14: ffff881ec7ed7a80 R15: ffff881be3afedd0\n    ORIG_RAX: ffffffffffffffff CS: 0010 SS: 0018\n\nIt happens in the pagefault and results in double pagefault\nduring compacting pages when memory allocation fails.\n\nAnalysed the vmcore, the page leads to second pagefault is corrupted\nwith _mapcount=-256, but private=0.\n\nIt's caused by the race between migration and ballooning, and lock\nmissing in virtballoon_migratepage() of virtio_balloon driver.\nThis patch fix the bug.\n\nFixes: e22504296d4f64f (\"virtio_balloon: introduce migration primitives to balloon pages\")\nCc: stable@vger.kernel.org\nSigned-off-by: Jiang Biao <jiang.biao2@zte.com.cn>\nSigned-off-by: Huang Chong <huang.chong@zte.com.cn>\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>",
        "before_after_code_files": [
          "drivers/virtio/virtio_balloon.c||drivers/virtio/virtio_balloon.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/virtio/virtio_balloon.c||drivers/virtio/virtio_balloon.c": [
          "File: drivers/virtio/virtio_balloon.c -> drivers/virtio/virtio_balloon.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "513:  tell_host(vb, vb->inflate_vq);",
          "516:  balloon_page_delete(page);",
          "517:  vb->num_pfns = VIRTIO_BALLOON_PAGES_PER_PAGE;",
          "518:  set_page_pfns(vb, vb->pfns, page);",
          "519:  tell_host(vb, vb->deflate_vq);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "516:  spin_lock_irqsave(&vb_dev_info->pages_lock, flags);",
          "518:  spin_unlock_irqrestore(&vb_dev_info->pages_lock, flags);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "dcbb4c10e6d9693cc9d6fa493b4d130b66a60c7d",
      "candidate_info": {
        "commit_hash": "dcbb4c10e6d9693cc9d6fa493b4d130b66a60c7d",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/dcbb4c10e6d9693cc9d6fa493b4d130b66a60c7d",
        "files": [
          "fs/f2fs/checkpoint.c",
          "fs/f2fs/dir.c",
          "fs/f2fs/extent_cache.c",
          "fs/f2fs/f2fs.h",
          "fs/f2fs/file.c",
          "fs/f2fs/gc.c",
          "fs/f2fs/inline.c",
          "fs/f2fs/inode.c",
          "fs/f2fs/namei.c",
          "fs/f2fs/node.c",
          "fs/f2fs/recovery.c",
          "fs/f2fs/segment.c",
          "fs/f2fs/segment.h",
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: introduce f2fs_<level> macros to wrap f2fs_printk()\n\n- Add and use f2fs_<level> macros\n- Convert f2fs_msg to f2fs_printk\n- Remove level from f2fs_printk and embed the level in the format\n- Coalesce formats and align multi-line arguments\n- Remove unnecessary duplicate extern f2fs_msg f2fs.h\n\nSigned-off-by: Joe Perches <joe@perches.com>\nSigned-off-by: Chao Yu <yuchao0@huawei.com>\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/checkpoint.c||fs/f2fs/checkpoint.c",
          "fs/f2fs/dir.c||fs/f2fs/dir.c",
          "fs/f2fs/extent_cache.c||fs/f2fs/extent_cache.c",
          "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h",
          "fs/f2fs/file.c||fs/f2fs/file.c",
          "fs/f2fs/gc.c||fs/f2fs/gc.c",
          "fs/f2fs/inline.c||fs/f2fs/inline.c",
          "fs/f2fs/inode.c||fs/f2fs/inode.c",
          "fs/f2fs/namei.c||fs/f2fs/namei.c",
          "fs/f2fs/node.c||fs/f2fs/node.c",
          "fs/f2fs/recovery.c||fs/f2fs/recovery.c",
          "fs/f2fs/segment.c||fs/f2fs/segment.c",
          "fs/f2fs/segment.h||fs/f2fs/segment.h",
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/checkpoint.c||fs/f2fs/checkpoint.c": [
          "File: fs/f2fs/checkpoint.c -> fs/f2fs/checkpoint.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:  exist = f2fs_test_bit(offset, se->cur_valid_map);",
          "148:  if (!exist && type == DATA_GENERIC_ENHANCE) {",
          "151:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "152:   WARN_ON(1);",
          "153:  }",
          "",
          "[Removed Lines]",
          "149:   f2fs_msg(sbi->sb, KERN_ERR, \"Inconsistent error \"",
          "150:    \"blkaddr:%u, sit bitmap:%d\", blkaddr, exist);",
          "",
          "[Added Lines]",
          "149:   f2fs_err(sbi, \"Inconsistent error blkaddr:%u, sit bitmap:%d\",",
          "150:     blkaddr, exist);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "184:  case DATA_GENERIC_ENHANCE_READ:",
          "185:   if (unlikely(blkaddr >= MAX_BLKADDR(sbi) ||",
          "186:     blkaddr < MAIN_BLKADDR(sbi))) {",
          "189:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "190:    WARN_ON(1);",
          "191:    return false;",
          "",
          "[Removed Lines]",
          "187:    f2fs_msg(sbi->sb, KERN_WARNING,",
          "188:     \"access invalid blkaddr:%u\", blkaddr);",
          "",
          "[Added Lines]",
          "187:    f2fs_warn(sbi, \"access invalid blkaddr:%u\",",
          "188:       blkaddr);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "658: err_out:",
          "659:  set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "663:  return err;",
          "664: }",
          "",
          "[Removed Lines]",
          "660:  f2fs_msg(sbi->sb, KERN_WARNING,",
          "661:    \"%s: orphan failed (ino=%x), run fsck to fix.\",",
          "662:    __func__, ino);",
          "",
          "[Added Lines]",
          "660:  f2fs_warn(sbi, \"%s: orphan failed (ino=%x), run fsck to fix.\",",
          "661:     __func__, ino);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "676:   return 0;",
          "678:  if (bdev_read_only(sbi->sb->s_bdev)) {",
          "681:   return 0;",
          "682:  }",
          "684:  if (s_flags & SB_RDONLY) {",
          "686:   sbi->sb->s_flags &= ~SB_RDONLY;",
          "687:  }",
          "",
          "[Removed Lines]",
          "679:   f2fs_msg(sbi->sb, KERN_INFO, \"write access \"",
          "680:    \"unavailable, skipping orphan cleanup\");",
          "685:   f2fs_msg(sbi->sb, KERN_INFO, \"orphan cleanup on readonly fs\");",
          "",
          "[Added Lines]",
          "678:   f2fs_info(sbi, \"write access unavailable, skipping orphan cleanup\");",
          "683:   f2fs_info(sbi, \"orphan cleanup on readonly fs\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "827:  if (crc_offset < CP_MIN_CHKSUM_OFFSET ||",
          "828:    crc_offset > CP_CHKSUM_OFFSET) {",
          "829:   f2fs_put_page(*cp_page, 1);",
          "832:   return -EINVAL;",
          "833:  }",
          "835:  crc = f2fs_checkpoint_chksum(sbi, *cp_block);",
          "836:  if (crc != cur_cp_crc(*cp_block)) {",
          "837:   f2fs_put_page(*cp_page, 1);",
          "839:   return -EINVAL;",
          "840:  }",
          "",
          "[Removed Lines]",
          "830:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "831:    \"invalid crc_offset: %zu\", crc_offset);",
          "838:   f2fs_msg(sbi->sb, KERN_WARNING, \"invalid crc value\");",
          "",
          "[Added Lines]",
          "828:   f2fs_warn(sbi, \"invalid crc_offset: %zu\", crc_offset);",
          "835:   f2fs_warn(sbi, \"invalid crc value\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "859:  if (le32_to_cpu(cp_block->cp_pack_total_block_count) >",
          "860:      sbi->blocks_per_seg) {",
          "864:   goto invalid_cp;",
          "865:  }",
          "866:  pre_version = *version;",
          "",
          "[Removed Lines]",
          "861:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "862:    \"invalid cp_pack_total_block_count:%u\",",
          "863:    le32_to_cpu(cp_block->cp_pack_total_block_count));",
          "",
          "[Added Lines]",
          "858:   f2fs_warn(sbi, \"invalid cp_pack_total_block_count:%u\",",
          "859:      le32_to_cpu(cp_block->cp_pack_total_block_count));",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1559:  if (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {",
          "1560:   if (cpc->reason != CP_PAUSE)",
          "1561:    return 0;",
          "1564:  }",
          "1565:  mutex_lock(&sbi->cp_mutex);",
          "",
          "[Removed Lines]",
          "1562:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "1563:     \"Start checkpoint disabled!\");",
          "",
          "[Added Lines]",
          "1558:   f2fs_warn(sbi, \"Start checkpoint disabled!\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1626:  stat_inc_cp_count(sbi->stat_info);",
          "1628:  if (cpc->reason & CP_RECOVERY)",
          "1633:  f2fs_update_time(sbi, CP_TIME);",
          "",
          "[Removed Lines]",
          "1629:   f2fs_msg(sbi->sb, KERN_NOTICE,",
          "1630:    \"checkpoint: version = %llx\", ckpt_ver);",
          "",
          "[Added Lines]",
          "1624:   f2fs_notice(sbi, \"checkpoint: version = %llx\", ckpt_ver);",
          "",
          "---------------"
        ],
        "fs/f2fs/dir.c||fs/f2fs/dir.c": [
          "File: fs/f2fs/dir.c -> fs/f2fs/dir.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "219:  max_depth = F2FS_I(dir)->i_current_depth;",
          "220:  if (unlikely(max_depth > MAX_DIR_HASH_DEPTH)) {",
          "224:   max_depth = MAX_DIR_HASH_DEPTH;",
          "225:   f2fs_i_depth_write(dir, max_depth);",
          "226:  }",
          "",
          "[Removed Lines]",
          "221:   f2fs_msg(F2FS_I_SB(dir)->sb, KERN_WARNING,",
          "222:     \"Corrupted max_depth of %lu: %u\",",
          "223:     dir->i_ino, max_depth);",
          "",
          "[Added Lines]",
          "221:   f2fs_warn(F2FS_I_SB(dir), \"Corrupted max_depth of %lu: %u\",",
          "222:      dir->i_ino, max_depth);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "816:   bit_pos += GET_DENTRY_SLOTS(le16_to_cpu(de->name_len));",
          "817:   if (unlikely(bit_pos > d->max ||",
          "818:     le16_to_cpu(de->name_len) > F2FS_NAME_LEN)) {",
          "822:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "823:    err = -EINVAL;",
          "824:    goto out;",
          "",
          "[Removed Lines]",
          "819:    f2fs_msg(sbi->sb, KERN_WARNING,",
          "820:     \"%s: corrupted namelen=%d, run fsck to fix.\",",
          "821:     __func__, le16_to_cpu(de->name_len));",
          "",
          "[Added Lines]",
          "818:    f2fs_warn(sbi, \"%s: corrupted namelen=%d, run fsck to fix.\",",
          "819:       __func__, le16_to_cpu(de->name_len));",
          "",
          "---------------"
        ],
        "fs/f2fs/extent_cache.c||fs/f2fs/extent_cache.c": [
          "File: fs/f2fs/extent_cache.c -> fs/f2fs/extent_cache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "184:   next_re = rb_entry(next, struct rb_entry, rb_node);",
          "186:   if (cur_re->ofs + cur_re->len > next_re->ofs) {",
          "191:    return false;",
          "192:   }",
          "",
          "[Removed Lines]",
          "187:    f2fs_msg(sbi->sb, KERN_INFO, \"inconsistent rbtree, \"",
          "188:     \"cur(%u, %u) next(%u, %u)\",",
          "189:     cur_re->ofs, cur_re->len,",
          "190:     next_re->ofs, next_re->len);",
          "",
          "[Added Lines]",
          "187:    f2fs_info(sbi, \"inconsistent rbtree, cur(%u, %u) next(%u, %u)\",",
          "188:       cur_re->ofs, cur_re->len,",
          "189:       next_re->ofs, next_re->len);",
          "",
          "---------------"
        ],
        "fs/f2fs/f2fs.h||fs/f2fs/f2fs.h": [
          "File: fs/f2fs/f2fs.h -> fs/f2fs/f2fs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1808:  return -ENOSPC;",
          "1809: }",
          "1812: static inline void dec_valid_block_count(struct f2fs_sb_info *sbi,",
          "1813:       struct inode *inode,",
          "1814:       block_t count)",
          "",
          "[Removed Lines]",
          "1811: void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...);",
          "",
          "[Added Lines]",
          "1811: __printf(2, 3)",
          "1812: void f2fs_printk(struct f2fs_sb_info *sbi, const char *fmt, ...);",
          "1814: #define f2fs_err(sbi, fmt, ...)      \\",
          "1815:  f2fs_printk(sbi, KERN_ERR fmt, ##__VA_ARGS__)",
          "1816: #define f2fs_warn(sbi, fmt, ...)     \\",
          "1817:  f2fs_printk(sbi, KERN_WARNING fmt, ##__VA_ARGS__)",
          "1818: #define f2fs_notice(sbi, fmt, ...)     \\",
          "1819:  f2fs_printk(sbi, KERN_NOTICE fmt, ##__VA_ARGS__)",
          "1820: #define f2fs_info(sbi, fmt, ...)     \\",
          "1821:  f2fs_printk(sbi, KERN_INFO fmt, ##__VA_ARGS__)",
          "1822: #define f2fs_debug(sbi, fmt, ...)     \\",
          "1823:  f2fs_printk(sbi, KERN_DEBUG fmt, ##__VA_ARGS__)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1824:      sbi->current_reserved_blocks + count);",
          "1825:  spin_unlock(&sbi->stat_lock);",
          "1826:  if (unlikely(inode->i_blocks < sectors)) {",
          "1832:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "1833:   return;",
          "1834:  }",
          "",
          "[Removed Lines]",
          "1827:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "1828:    \"Inconsistent i_blocks, ino:%lu, iblocks:%llu, sectors:%llu\",",
          "1829:    inode->i_ino,",
          "1830:    (unsigned long long)inode->i_blocks,",
          "1831:    (unsigned long long)sectors);",
          "",
          "[Added Lines]",
          "1840:   f2fs_warn(sbi, \"Inconsistent i_blocks, ino:%lu, iblocks:%llu, sectors:%llu\",",
          "1841:      inode->i_ino,",
          "1842:      (unsigned long long)inode->i_blocks,",
          "1843:      (unsigned long long)sectors);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2066:   dquot_free_inode(inode);",
          "2067:  } else {",
          "2068:   if (unlikely(inode->i_blocks == 0)) {",
          "2073:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "2074:    return;",
          "2075:   }",
          "",
          "[Removed Lines]",
          "2069:    f2fs_msg(sbi->sb, KERN_WARNING,",
          "2070:     \"Inconsistent i_blocks, ino:%lu, iblocks:%llu\",",
          "2071:     inode->i_ino,",
          "2072:     (unsigned long long)inode->i_blocks);",
          "",
          "[Added Lines]",
          "2081:    f2fs_warn(sbi, \"Inconsistent i_blocks, ino:%lu, iblocks:%llu\",",
          "2082:       inode->i_ino,",
          "2083:       (unsigned long long)inode->i_blocks);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2839:      block_t blkaddr, int type)",
          "2840: {",
          "2841:  if (!f2fs_is_valid_blkaddr(sbi, blkaddr, type)) {",
          "2845:   f2fs_bug_on(sbi, 1);",
          "2846:  }",
          "2847: }",
          "",
          "[Removed Lines]",
          "2842:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2843:    \"invalid blkaddr: %u, type: %d, run fsck to fix.\",",
          "2844:    blkaddr, type);",
          "",
          "[Added Lines]",
          "2853:   f2fs_err(sbi, \"invalid blkaddr: %u, type: %d, run fsck to fix.\",",
          "2854:     blkaddr, type);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2972: void f2fs_quota_off_umount(struct super_block *sb);",
          "2973: int f2fs_commit_super(struct f2fs_sb_info *sbi, bool recover);",
          "2974: int f2fs_sync_fs(struct super_block *sb, int sync);",
          "2977: int f2fs_sanity_check_ckpt(struct f2fs_sb_info *sbi);",
          "",
          "[Removed Lines]",
          "2975: extern __printf(3, 4)",
          "2976: void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "fs/f2fs/file.c||fs/f2fs/file.c": [
          "File: fs/f2fs/file.c -> fs/f2fs/file.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1839:  if (get_dirty_pages(inode))",
          "1843:  ret = filemap_write_and_wait_range(inode->i_mapping, 0, LLONG_MAX);",
          "1844:  if (ret) {",
          "1845:   up_write(&F2FS_I(inode)->i_gc_rwsem[WRITE]);",
          "",
          "[Removed Lines]",
          "1840:   f2fs_msg(F2FS_I_SB(inode)->sb, KERN_WARNING,",
          "1841:   \"Unexpected flush for atomic writes: ino=%lu, npages=%u\",",
          "1842:      inode->i_ino, get_dirty_pages(inode));",
          "",
          "[Added Lines]",
          "1840:   f2fs_warn(F2FS_I_SB(inode), \"Unexpected flush for atomic writes: ino=%lu, npages=%u\",",
          "1841:      inode->i_ino, get_dirty_pages(inode));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2274:   return -EROFS;",
          "2276:  if (unlikely(is_sbi_flag_set(sbi, SBI_CP_DISABLED))) {",
          "2279:   return -EINVAL;",
          "2280:  }",
          "",
          "[Removed Lines]",
          "2277:   f2fs_msg(sbi->sb, KERN_INFO,",
          "2278:    \"Skipping Checkpoint. Checkpoints currently disabled.\");",
          "",
          "[Added Lines]",
          "2276:   f2fs_info(sbi, \"Skipping Checkpoint. Checkpoints currently disabled.\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2661:  if (!f2fs_is_multi_device(sbi) || sbi->s_ndevs - 1 <= range.dev_num ||",
          "2662:    __is_large_section(sbi)) {",
          "2667:   return -EINVAL;",
          "2668:  }",
          "",
          "[Removed Lines]",
          "2663:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "2664:    \"Can't flush %u in %d for segs_per_sec %u != 1\",",
          "2665:     range.dev_num, sbi->s_ndevs,",
          "2666:     sbi->segs_per_sec);",
          "",
          "[Added Lines]",
          "2661:   f2fs_warn(sbi, \"Can't flush %u in %d for segs_per_sec %u != 1\",",
          "2662:      range.dev_num, sbi->s_ndevs, sbi->segs_per_sec);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2948:     fi->i_gc_failures[GC_FAILURE_PIN] + 1);",
          "2950:  if (fi->i_gc_failures[GC_FAILURE_PIN] > sbi->gc_pin_file_threshold) {",
          "2955:   clear_inode_flag(inode, FI_PIN_FILE);",
          "2956:   return -EAGAIN;",
          "2957:  }",
          "",
          "[Removed Lines]",
          "2951:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "2952:    \"%s: Enable GC = ino %lx after %x GC trials\",",
          "2953:    __func__, inode->i_ino,",
          "2954:    fi->i_gc_failures[GC_FAILURE_PIN]);",
          "",
          "[Added Lines]",
          "2947:   f2fs_warn(sbi, \"%s: Enable GC = ino %lx after %x GC trials\",",
          "2948:      __func__, inode->i_ino,",
          "2949:      fi->i_gc_failures[GC_FAILURE_PIN]);",
          "",
          "---------------"
        ],
        "fs/f2fs/gc.c||fs/f2fs/gc.c": [
          "File: fs/f2fs/gc.c -> fs/f2fs/gc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "618:  }",
          "620:  if (sum->version != dni->version) {",
          "624:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "625:  }",
          "",
          "[Removed Lines]",
          "621:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "622:     \"%s: valid data with mismatched node version.\",",
          "623:     __func__);",
          "",
          "[Added Lines]",
          "621:   f2fs_warn(sbi, \"%s: valid data with mismatched node version.\",",
          "622:      __func__);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1184:   sum = page_address(sum_page);",
          "1185:   if (type != GET_SUM_TYPE((&sum->footer))) {",
          "1189:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "1190:    f2fs_stop_checkpoint(sbi, false);",
          "1191:    goto skip;",
          "",
          "[Removed Lines]",
          "1186:    f2fs_msg(sbi->sb, KERN_ERR, \"Inconsistent segment (%u) \"",
          "1187:     \"type [%d, %d] in SSA and SIT\",",
          "1188:     segno, type, GET_SUM_TYPE((&sum->footer)));",
          "",
          "[Added Lines]",
          "1185:    f2fs_err(sbi, \"Inconsistent segment (%u) type [%d, %d] in SSA and SIT\",",
          "1186:      segno, type, GET_SUM_TYPE((&sum->footer)));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1398:  next_inuse = find_next_inuse(FREE_I(sbi), end + 1, start);",
          "1399:  if (next_inuse <= end) {",
          "1402:   f2fs_bug_on(sbi, 1);",
          "1403:  }",
          "1404:  return err;",
          "",
          "[Removed Lines]",
          "1400:   f2fs_msg(sbi->sb, KERN_ERR,",
          "1401:    \"segno %u should be free but still inuse!\", next_inuse);",
          "",
          "[Added Lines]",
          "1398:   f2fs_err(sbi, \"segno %u should be free but still inuse!\",",
          "1399:     next_inuse);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1455:   return 0;",
          "1457:  if (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {",
          "1460:   return -EINVAL;",
          "1461:  }",
          "1463:  if (test_opt(sbi, DISABLE_CHECKPOINT)) {",
          "1466:   return -EINVAL;",
          "1467:  }",
          "",
          "[Removed Lines]",
          "1458:   f2fs_msg(sbi->sb, KERN_ERR,",
          "1459:    \"Should run fsck to repair first.\");",
          "1464:   f2fs_msg(sbi->sb, KERN_ERR,",
          "1465:    \"Checkpoint should be enabled.\");",
          "",
          "[Added Lines]",
          "1456:   f2fs_err(sbi, \"Should run fsck to repair first.\");",
          "1461:   f2fs_err(sbi, \"Checkpoint should be enabled.\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1526: out:",
          "1527:  if (err) {",
          "1528:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "1532:   MAIN_SECS(sbi) += secs;",
          "1533:   spin_lock(&sbi->stat_lock);",
          "",
          "[Removed Lines]",
          "1529:   f2fs_msg(sbi->sb, KERN_ERR,",
          "1530:     \"resize_fs failed, should run fsck to repair!\");",
          "",
          "[Added Lines]",
          "1525:   f2fs_err(sbi, \"resize_fs failed, should run fsck to repair!\");",
          "",
          "---------------"
        ],
        "fs/f2fs/inline.c||fs/f2fs/inline.c": [
          "File: fs/f2fs/inline.c -> fs/f2fs/inline.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "140:  if (unlikely(dn->data_blkaddr != NEW_ADDR)) {",
          "141:   f2fs_put_dnode(dn);",
          "142:   set_sbi_flag(fio.sbi, SBI_NEED_FSCK);",
          "147:   return -EINVAL;",
          "148:  }",
          "",
          "[Removed Lines]",
          "143:   f2fs_msg(fio.sbi->sb, KERN_WARNING,",
          "144:    \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"",
          "145:    \"run fsck to fix.\",",
          "146:    __func__, dn->inode->i_ino, dn->data_blkaddr);",
          "",
          "[Added Lines]",
          "143:   f2fs_warn(fio.sbi, \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, run fsck to fix.\",",
          "144:      __func__, dn->inode->i_ino, dn->data_blkaddr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "383:  if (unlikely(dn.data_blkaddr != NEW_ADDR)) {",
          "384:   f2fs_put_dnode(&dn);",
          "385:   set_sbi_flag(F2FS_P_SB(page), SBI_NEED_FSCK);",
          "390:   err = -EINVAL;",
          "391:   goto out;",
          "392:  }",
          "",
          "[Removed Lines]",
          "386:   f2fs_msg(F2FS_P_SB(page)->sb, KERN_WARNING,",
          "387:    \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, \"",
          "388:    \"run fsck to fix.\",",
          "389:    __func__, dir->i_ino, dn.data_blkaddr);",
          "",
          "[Added Lines]",
          "384:   f2fs_warn(F2FS_P_SB(page), \"%s: corrupted inline inode ino=%lx, i_addr[0]:0x%x, run fsck to fix.\",",
          "385:      __func__, dir->i_ino, dn.data_blkaddr);",
          "",
          "---------------"
        ],
        "fs/f2fs/inode.c||fs/f2fs/inode.c": [
          "File: fs/f2fs/inode.c -> fs/f2fs/inode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "176:  calculated = f2fs_inode_chksum(sbi, page);",
          "178:  if (provided != calculated)",
          "183:  return provided == calculated;",
          "184: }",
          "",
          "[Removed Lines]",
          "179:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "180:    \"checksum invalid, nid = %lu, ino_of_node = %x, %x vs. %x\",",
          "181:    page->index, ino_of_node(page), provided, calculated);",
          "",
          "[Added Lines]",
          "179:   f2fs_warn(sbi, \"checksum invalid, nid = %lu, ino_of_node = %x, %x vs. %x\",",
          "180:      page->index, ino_of_node(page), provided, calculated);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "202:  iblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);",
          "203:  if (!iblocks) {",
          "204:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "209:   return false;",
          "210:  }",
          "212:  if (ino_of_node(node_page) != nid_of_node(node_page)) {",
          "213:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "219:   return false;",
          "220:  }",
          "222:  if (f2fs_sb_has_flexible_inline_xattr(sbi)",
          "223:    && !f2fs_has_extra_attr(inode)) {",
          "224:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "228:   return false;",
          "229:  }",
          "231:  if (f2fs_has_extra_attr(inode) &&",
          "232:    !f2fs_sb_has_extra_attr(sbi)) {",
          "233:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "238:   return false;",
          "239:  }",
          "241:  if (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||",
          "242:    fi->i_extra_isize % sizeof(__le32)) {",
          "243:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "249:   return false;",
          "250:  }",
          "",
          "[Removed Lines]",
          "205:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "206:    \"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, \"",
          "207:    \"run fsck to fix.\",",
          "208:    __func__, inode->i_ino, iblocks);",
          "214:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "215:    \"%s: corrupted inode footer i_ino=%lx, ino,nid: \"",
          "216:    \"[%u, %u] run fsck to fix.\",",
          "217:    __func__, inode->i_ino,",
          "218:    ino_of_node(node_page), nid_of_node(node_page));",
          "225:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "226:    \"%s: corrupted inode ino=%lx, run fsck to fix.\",",
          "227:    __func__, inode->i_ino);",
          "234:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "235:    \"%s: inode (ino=%lx) is with extra_attr, \"",
          "236:    \"but extra_attr feature is off\",",
          "237:    __func__, inode->i_ino);",
          "244:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "245:    \"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, \"",
          "246:    \"max: %zu\",",
          "247:    __func__, inode->i_ino, fi->i_extra_isize,",
          "248:    F2FS_TOTAL_EXTRA_ATTR_SIZE);",
          "",
          "[Added Lines]",
          "204:   f2fs_warn(sbi, \"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, run fsck to fix.\",",
          "205:      __func__, inode->i_ino, iblocks);",
          "211:   f2fs_warn(sbi, \"%s: corrupted inode footer i_ino=%lx, ino,nid: [%u, %u] run fsck to fix.\",",
          "212:      __func__, inode->i_ino,",
          "213:      ino_of_node(node_page), nid_of_node(node_page));",
          "220:   f2fs_warn(sbi, \"%s: corrupted inode ino=%lx, run fsck to fix.\",",
          "221:      __func__, inode->i_ino);",
          "228:   f2fs_warn(sbi, \"%s: inode (ino=%lx) is with extra_attr, but extra_attr feature is off\",",
          "229:      __func__, inode->i_ino);",
          "236:   f2fs_warn(sbi, \"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, max: %zu\",",
          "237:      __func__, inode->i_ino, fi->i_extra_isize,",
          "238:      F2FS_TOTAL_EXTRA_ATTR_SIZE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "255:   (!fi->i_inline_xattr_size ||",
          "256:   fi->i_inline_xattr_size > MAX_INLINE_XATTR_SIZE)) {",
          "257:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "263:   return false;",
          "264:  }",
          "",
          "[Removed Lines]",
          "258:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "259:    \"%s: inode (ino=%lx) has corrupted \"",
          "260:    \"i_inline_xattr_size: %d, max: %zu\",",
          "261:    __func__, inode->i_ino, fi->i_inline_xattr_size,",
          "262:    MAX_INLINE_XATTR_SIZE);",
          "",
          "[Added Lines]",
          "248:   f2fs_warn(sbi, \"%s: inode (ino=%lx) has corrupted i_inline_xattr_size: %d, max: %zu\",",
          "249:      __func__, inode->i_ino, fi->i_inline_xattr_size,",
          "250:      MAX_INLINE_XATTR_SIZE);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "272:    !f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,",
          "273:       DATA_GENERIC_ENHANCE))) {",
          "274:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "280:    return false;",
          "281:   }",
          "282:  }",
          "",
          "[Removed Lines]",
          "275:    f2fs_msg(sbi->sb, KERN_WARNING,",
          "276:     \"%s: inode (ino=%lx) extent info [%u, %u, %u] \"",
          "277:     \"is incorrect, run fsck to fix\",",
          "278:     __func__, inode->i_ino,",
          "279:     ei->blk, ei->fofs, ei->len);",
          "",
          "[Added Lines]",
          "263:    f2fs_warn(sbi, \"%s: inode (ino=%lx) extent info [%u, %u, %u] is incorrect, run fsck to fix\",",
          "264:       __func__, inode->i_ino,",
          "265:       ei->blk, ei->fofs, ei->len);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "284:  if (f2fs_has_inline_data(inode) &&",
          "285:    (!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {",
          "286:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "291:   return false;",
          "292:  }",
          "294:  if (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {",
          "295:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "300:   return false;",
          "301:  }",
          "",
          "[Removed Lines]",
          "287:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "288:    \"%s: inode (ino=%lx, mode=%u) should not have \"",
          "289:    \"inline_data, run fsck to fix\",",
          "290:    __func__, inode->i_ino, inode->i_mode);",
          "296:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "297:    \"%s: inode (ino=%lx, mode=%u) should not have \"",
          "298:    \"inline_dentry, run fsck to fix\",",
          "299:    __func__, inode->i_ino, inode->i_mode);",
          "",
          "[Added Lines]",
          "273:   f2fs_warn(sbi, \"%s: inode (ino=%lx, mode=%u) should not have inline_data, run fsck to fix\",",
          "274:      __func__, inode->i_ino, inode->i_mode);",
          "280:   f2fs_warn(sbi, \"%s: inode (ino=%lx, mode=%u) should not have inline_dentry, run fsck to fix\",",
          "281:      __func__, inode->i_ino, inode->i_mode);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "785:  err = f2fs_get_node_info(sbi, inode->i_ino, &ni);",
          "786:  if (err) {",
          "787:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "790:   goto out;",
          "791:  }",
          "",
          "[Removed Lines]",
          "788:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "789:    \"May loss orphan inode, run fsck to fix.\");",
          "",
          "[Added Lines]",
          "770:   f2fs_warn(sbi, \"May loss orphan inode, run fsck to fix.\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "794:   err = f2fs_acquire_orphan_inode(sbi);",
          "795:   if (err) {",
          "796:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "799:   } else {",
          "800:    f2fs_add_orphan_inode(inode);",
          "801:   }",
          "",
          "[Removed Lines]",
          "797:    f2fs_msg(sbi->sb, KERN_WARNING,",
          "798:     \"Too many orphan inodes, run fsck to fix.\");",
          "",
          "[Added Lines]",
          "778:    f2fs_warn(sbi, \"Too many orphan inodes, run fsck to fix.\");",
          "",
          "---------------"
        ],
        "fs/f2fs/namei.c||fs/f2fs/namei.c": [
          "File: fs/f2fs/namei.c -> fs/f2fs/namei.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "385:  int err = 0;",
          "387:  if (f2fs_readonly(sbi->sb)) {",
          "391:   return 0;",
          "392:  }",
          "",
          "[Removed Lines]",
          "388:   f2fs_msg(sbi->sb, KERN_INFO,",
          "389:    \"skip recovering inline_dots inode (ino:%lu, pino:%u) \"",
          "390:    \"in readonly mountpoint\", dir->i_ino, pino);",
          "",
          "[Added Lines]",
          "388:   f2fs_info(sbi, \"skip recovering inline_dots inode (ino:%lu, pino:%u) in readonly mountpoint\",",
          "389:      dir->i_ino, pino);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "484:  if (IS_ENCRYPTED(dir) &&",
          "485:      (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) &&",
          "486:      !fscrypt_has_permitted_context(dir, inode)) {",
          "490:   err = -EPERM;",
          "491:   goto out_iput;",
          "492:  }",
          "",
          "[Removed Lines]",
          "487:   f2fs_msg(inode->i_sb, KERN_WARNING,",
          "488:     \"Inconsistent encryption contexts: %lu/%lu\",",
          "489:     dir->i_ino, inode->i_ino);",
          "",
          "[Added Lines]",
          "486:   f2fs_warn(F2FS_I_SB(inode), \"Inconsistent encryption contexts: %lu/%lu\",",
          "487:      dir->i_ino, inode->i_ino);",
          "",
          "---------------"
        ],
        "fs/f2fs/node.c||fs/f2fs/node.c": [
          "File: fs/f2fs/node.c -> fs/f2fs/node.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "34: {",
          "35:  if (unlikely(nid < F2FS_ROOT_INO(sbi) || nid >= NM_I(sbi)->max_nid)) {",
          "36:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "40:   return -EINVAL;",
          "41:  }",
          "42:  return 0;",
          "",
          "[Removed Lines]",
          "37:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "38:     \"%s: out-of-range nid=%x, run fsck to fix.\",",
          "39:     __func__, nid);",
          "",
          "[Added Lines]",
          "37:   f2fs_warn(sbi, \"%s: out-of-range nid=%x, run fsck to fix.\",",
          "38:      __func__, nid);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1189:  }",
          "1191:  if (unlikely(inode->i_blocks != 0 && inode->i_blocks != 8)) {",
          "1196:   set_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);",
          "1197:  }",
          "",
          "[Removed Lines]",
          "1192:   f2fs_msg(F2FS_I_SB(inode)->sb, KERN_WARNING,",
          "1193:    \"Inconsistent i_blocks, ino:%lu, iblocks:%llu\",",
          "1194:    inode->i_ino,",
          "1195:    (unsigned long long)inode->i_blocks);",
          "",
          "[Added Lines]",
          "1191:   f2fs_warn(F2FS_I_SB(inode), \"Inconsistent i_blocks, ino:%lu, iblocks:%llu\",",
          "1192:      inode->i_ino, (unsigned long long)inode->i_blocks);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1380:  }",
          "1381: page_hit:",
          "1382:  if(unlikely(nid != nid_of_node(page))) {",
          "1388:   err = -EINVAL;",
          "1389: out_err:",
          "1390:   ClearPageUptodate(page);",
          "",
          "[Removed Lines]",
          "1383:   f2fs_msg(sbi->sb, KERN_WARNING, \"inconsistent node block, \"",
          "1384:    \"nid:%lu, node_footer[nid:%u,ino:%u,ofs:%u,cpver:%llu,blkaddr:%u]\",",
          "1385:    nid, nid_of_node(page), ino_of_node(page),",
          "1386:    ofs_of_node(page), cpver_of_node(page),",
          "1387:    next_blkaddr_of_node(page));",
          "",
          "[Added Lines]",
          "1380:   f2fs_warn(sbi, \"inconsistent node block, nid:%lu, node_footer[nid:%u,ino:%u,ofs:%u,cpver:%llu,blkaddr:%u]\",",
          "1381:      nid, nid_of_node(page), ino_of_node(page),",
          "1382:      ofs_of_node(page), cpver_of_node(page),",
          "1383:      next_blkaddr_of_node(page));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1752:    break;",
          "1753:  }",
          "1754:  if (!ret && atomic && !marked) {",
          "1758:   lock_page(last_page);",
          "1759:   f2fs_wait_on_page_writeback(last_page, NODE, true, true);",
          "1760:   set_page_dirty(last_page);",
          "",
          "[Removed Lines]",
          "1755:   f2fs_msg(sbi->sb, KERN_DEBUG,",
          "1756:    \"Retry to write fsync mark: ino=%u, idx=%lx\",",
          "1757:      ino, last_page->index);",
          "",
          "[Added Lines]",
          "1751:   f2fs_debug(sbi, \"Retry to write fsync mark: ino=%u, idx=%lx\",",
          "1752:       ino, last_page->index);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2304:    if (ret) {",
          "2305:     up_read(&nm_i->nat_tree_lock);",
          "2306:     f2fs_bug_on(sbi, !mount);",
          "2309:     return ret;",
          "2310:    }",
          "2311:   }",
          "",
          "[Removed Lines]",
          "2307:     f2fs_msg(sbi->sb, KERN_ERR,",
          "2308:      \"NAT is corrupt, run fsck to fix it\");",
          "",
          "[Added Lines]",
          "2302:     f2fs_err(sbi, \"NAT is corrupt, run fsck to fix it\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2915:  nm_i->full_nat_bits = nm_i->nat_bits + 8;",
          "2916:  nm_i->empty_nat_bits = nm_i->full_nat_bits + nat_bits_bytes;",
          "2919:  return 0;",
          "2920: }",
          "",
          "[Removed Lines]",
          "2918:  f2fs_msg(sbi->sb, KERN_NOTICE, \"Found nat_bits in checkpoint\");",
          "",
          "[Added Lines]",
          "2912:  f2fs_notice(sbi, \"Found nat_bits in checkpoint\");",
          "",
          "---------------"
        ],
        "fs/f2fs/recovery.c||fs/f2fs/recovery.c": [
          "File: fs/f2fs/recovery.c -> fs/f2fs/recovery.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "188:   name = \"<encrypted>\";",
          "189:  else",
          "190:   name = raw_inode->i_name;",
          "195:  return err;",
          "196: }",
          "",
          "[Removed Lines]",
          "191:  f2fs_msg(inode->i_sb, KERN_NOTICE,",
          "192:    \"%s: ino = %x, name = %s, dir = %lx, err = %d\",",
          "193:    __func__, ino_of_node(ipage), name,",
          "194:    IS_ERR(dir) ? 0 : dir->i_ino, err);",
          "",
          "[Added Lines]",
          "191:  f2fs_notice(F2FS_I_SB(inode), \"%s: ino = %x, name = %s, dir = %lx, err = %d\",",
          "192:       __func__, ino_of_node(ipage), name,",
          "193:       IS_ERR(dir) ? 0 : dir->i_ino, err);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "292:  else",
          "293:   name = F2FS_INODE(page)->i_name;",
          "298:  return 0;",
          "299: }",
          "",
          "[Removed Lines]",
          "295:  f2fs_msg(inode->i_sb, KERN_NOTICE,",
          "296:   \"recover_inode: ino = %x, name = %s, inline = %x\",",
          "297:    ino_of_node(page), name, raw->i_inline);",
          "",
          "[Added Lines]",
          "294:  f2fs_notice(F2FS_I_SB(inode), \"recover_inode: ino = %x, name = %s, inline = %x\",",
          "295:       ino_of_node(page), name, raw->i_inline);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "372:   if (++loop_cnt >= free_blocks ||",
          "373:    blkaddr == next_blkaddr_of_node(page)) {",
          "378:    f2fs_put_page(page, 1);",
          "379:    err = -EINVAL;",
          "380:    break;",
          "",
          "[Removed Lines]",
          "374:    f2fs_msg(sbi->sb, KERN_NOTICE,",
          "375:     \"%s: detect looped node chain, \"",
          "376:     \"blkaddr:%u, next:%u\",",
          "377:     __func__, blkaddr, next_blkaddr_of_node(page));",
          "",
          "[Added Lines]",
          "372:    f2fs_notice(sbi, \"%s: detect looped node chain, blkaddr:%u, next:%u\",",
          "373:         __func__, blkaddr,",
          "374:         next_blkaddr_of_node(page));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "553:  f2fs_bug_on(sbi, ni.ino != ino_of_node(page));",
          "555:  if (ofs_of_node(dn.node_page) != ofs_of_node(page)) {",
          "560:   err = -EFAULT;",
          "561:   goto err;",
          "562:  }",
          "",
          "[Removed Lines]",
          "556:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "557:    \"Inconsistent ofs_of_node, ino:%lu, ofs:%u, %u\",",
          "558:    inode->i_ino, ofs_of_node(dn.node_page),",
          "559:    ofs_of_node(page));",
          "",
          "[Added Lines]",
          "553:   f2fs_warn(sbi, \"Inconsistent ofs_of_node, ino:%lu, ofs:%u, %u\",",
          "554:      inode->i_ino, ofs_of_node(dn.node_page),",
          "555:      ofs_of_node(page));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "642: err:",
          "643:  f2fs_put_dnode(&dn);",
          "644: out:",
          "650:  return err;",
          "651: }",
          "",
          "[Removed Lines]",
          "645:  f2fs_msg(sbi->sb, KERN_NOTICE,",
          "646:   \"recover_data: ino = %lx (i_size: %s) recovered = %d, err = %d\",",
          "647:   inode->i_ino,",
          "648:   file_keep_isize(inode) ? \"keep\" : \"recover\",",
          "649:   recovered, err);",
          "",
          "[Added Lines]",
          "641:  f2fs_notice(sbi, \"recover_data: ino = %lx (i_size: %s) recovered = %d, err = %d\",",
          "642:       inode->i_ino, file_keep_isize(inode) ? \"keep\" : \"recover\",",
          "643:       recovered, err);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "734: #endif",
          "736:  if (s_flags & SB_RDONLY) {",
          "739:   sbi->sb->s_flags &= ~SB_RDONLY;",
          "740:  }",
          "",
          "[Removed Lines]",
          "737:   f2fs_msg(sbi->sb, KERN_INFO,",
          "738:     \"recover fsync data on readonly fs\");",
          "",
          "[Added Lines]",
          "731:   f2fs_info(sbi, \"recover fsync data on readonly fs\");",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.c||fs/f2fs/segment.c": [
          "File: fs/f2fs/segment.c -> fs/f2fs/segment.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1757:   devi = f2fs_target_device_index(sbi, blkstart);",
          "1758:   if (blkstart < FDEV(devi).start_blk ||",
          "1759:       blkstart > FDEV(devi).end_blk) {",
          "1762:    return -EIO;",
          "1763:   }",
          "1764:   blkstart -= FDEV(devi).start_blk;",
          "",
          "[Removed Lines]",
          "1760:    f2fs_msg(sbi->sb, KERN_ERR, \"Invalid block %x\",",
          "1761:      blkstart);",
          "",
          "[Added Lines]",
          "1760:    f2fs_err(sbi, \"Invalid block %x\", blkstart);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1772:   if (sector & (bdev_zone_sectors(bdev) - 1) ||",
          "1773:     nr_sects != bdev_zone_sectors(bdev)) {",
          "1778:    return -EIO;",
          "1779:   }",
          "1780:   trace_f2fs_issue_reset_zone(bdev, blkstart);",
          "",
          "[Removed Lines]",
          "1774:    f2fs_msg(sbi->sb, KERN_ERR,",
          "1775:     \"(%d) %s: Unaligned zone reset attempted (block %x + %x)\",",
          "1776:     devi, sbi->s_ndevs ? FDEV(devi).path: \"\",",
          "1777:     blkstart, blklen);",
          "",
          "[Added Lines]",
          "1773:    f2fs_err(sbi, \"(%d) %s: Unaligned zone reset attempted (block %x + %x)\",",
          "1774:      devi, sbi->s_ndevs ? FDEV(devi).path : \"\",",
          "1775:      blkstart, blklen);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2138:   mir_exist = f2fs_test_and_set_bit(offset,",
          "2139:       se->cur_valid_map_mir);",
          "2140:   if (unlikely(exist != mir_exist)) {",
          "2144:    f2fs_bug_on(sbi, 1);",
          "2145:   }",
          "2146: #endif",
          "2147:   if (unlikely(exist)) {",
          "2150:    f2fs_bug_on(sbi, 1);",
          "2151:    se->valid_blocks--;",
          "2152:    del = 0;",
          "",
          "[Removed Lines]",
          "2141:    f2fs_msg(sbi->sb, KERN_ERR, \"Inconsistent error \"",
          "2142:     \"when setting bitmap, blk:%u, old bit:%d\",",
          "2143:     blkaddr, exist);",
          "2148:    f2fs_msg(sbi->sb, KERN_ERR,",
          "2149:     \"Bitmap was wrongly set, blk:%u\", blkaddr);",
          "",
          "[Added Lines]",
          "2139:    f2fs_err(sbi, \"Inconsistent error when setting bitmap, blk:%u, old bit:%d\",",
          "2140:      blkaddr, exist);",
          "2145:    f2fs_err(sbi, \"Bitmap was wrongly set, blk:%u\",",
          "2146:      blkaddr);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2167:   mir_exist = f2fs_test_and_clear_bit(offset,",
          "2168:       se->cur_valid_map_mir);",
          "2169:   if (unlikely(exist != mir_exist)) {",
          "2173:    f2fs_bug_on(sbi, 1);",
          "2174:   }",
          "2175: #endif",
          "2176:   if (unlikely(!exist)) {",
          "2179:    f2fs_bug_on(sbi, 1);",
          "2180:    se->valid_blocks++;",
          "2181:    del = 0;",
          "",
          "[Removed Lines]",
          "2170:    f2fs_msg(sbi->sb, KERN_ERR, \"Inconsistent error \"",
          "2171:     \"when clearing bitmap, blk:%u, old bit:%d\",",
          "2172:     blkaddr, exist);",
          "2177:    f2fs_msg(sbi->sb, KERN_ERR,",
          "2178:     \"Bitmap was wrongly cleared, blk:%u\", blkaddr);",
          "",
          "[Added Lines]",
          "2167:    f2fs_err(sbi, \"Inconsistent error when clearing bitmap, blk:%u, old bit:%d\",",
          "2168:      blkaddr, exist);",
          "2173:    f2fs_err(sbi, \"Bitmap was wrongly cleared, blk:%u\",",
          "2174:      blkaddr);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2683:  up_write(&SIT_I(sbi)->sentry_lock);",
          "2685:  if (segno != curseg->segno)",
          "2690:  mutex_unlock(&curseg->curseg_mutex);",
          "2691:  up_read(&SM_I(sbi)->curseg_lock);",
          "",
          "[Removed Lines]",
          "2686:   f2fs_msg(sbi->sb, KERN_NOTICE,",
          "2687:    \"For resize: curseg of type %d: %u ==> %u\",",
          "2688:    type, segno, curseg->segno);",
          "",
          "[Added Lines]",
          "2682:   f2fs_notice(sbi, \"For resize: curseg of type %d: %u ==> %u\",",
          "2683:        type, segno, curseg->segno);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2823:   goto out;",
          "2825:  if (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {",
          "2828:   return -EIO;",
          "2829:  }",
          "",
          "[Removed Lines]",
          "2826:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "2827:    \"Found FS corruption, run fsck to fix.\");",
          "",
          "[Added Lines]",
          "2821:   f2fs_warn(sbi, \"Found FS corruption, run fsck to fix.\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "3586:  if (nats_in_cursum(nat_j) > NAT_JOURNAL_ENTRIES ||",
          "3587:    sits_in_cursum(sit_j) > SIT_JOURNAL_ENTRIES) {",
          "3591:   return -EINVAL;",
          "3592:  }",
          "",
          "[Removed Lines]",
          "3588:   f2fs_msg(sbi->sb, KERN_ERR,",
          "3589:    \"invalid journal entries nats %u sits %u\\n\",",
          "3590:    nats_in_cursum(nat_j), sits_in_cursum(sit_j));",
          "",
          "[Added Lines]",
          "3582:   f2fs_err(sbi, \"invalid journal entries nats %u sits %u\\n\",",
          "3583:     nats_in_cursum(nat_j), sits_in_cursum(sit_j));",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "4156:   start = le32_to_cpu(segno_in_journal(journal, i));",
          "4157:   if (start >= MAIN_SEGS(sbi)) {",
          "4161:    set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "4162:    err = -EINVAL;",
          "4163:    break;",
          "",
          "[Removed Lines]",
          "4158:    f2fs_msg(sbi->sb, KERN_ERR,",
          "4159:      \"Wrong journal entry on segno %u\",",
          "4160:      start);",
          "",
          "[Added Lines]",
          "4151:    f2fs_err(sbi, \"Wrong journal entry on segno %u\",",
          "4152:      start);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "4196:  up_read(&curseg->journal_rwsem);",
          "4198:  if (!err && total_node_blocks != valid_node_count(sbi)) {",
          "4202:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "4203:   err = -EINVAL;",
          "4204:  }",
          "",
          "[Removed Lines]",
          "4199:   f2fs_msg(sbi->sb, KERN_ERR,",
          "4200:    \"SIT is corrupted node# %u vs %u\",",
          "4201:    total_node_blocks, valid_node_count(sbi));",
          "",
          "[Added Lines]",
          "4191:   f2fs_err(sbi, \"SIT is corrupted node# %u vs %u\",",
          "4192:     total_node_blocks, valid_node_count(sbi));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "4314:    if (!f2fs_test_bit(blkofs, se->cur_valid_map))",
          "4315:     continue;",
          "4316: out:",
          "4323:    return -EINVAL;",
          "4324:   }",
          "4325:  }",
          "",
          "[Removed Lines]",
          "4317:    f2fs_msg(sbi->sb, KERN_ERR,",
          "4318:     \"Current segment's next free block offset is \"",
          "4319:     \"inconsistent with bitmap, logtype:%u, \"",
          "4320:     \"segno:%u, type:%u, next_blkoff:%u, blkofs:%u\",",
          "4321:     i, curseg->segno, curseg->alloc_type,",
          "4322:     curseg->next_blkoff, blkofs);",
          "",
          "[Added Lines]",
          "4308:    f2fs_err(sbi,",
          "4309:      \"Current segment's next free block offset is inconsistent with bitmap, logtype:%u, segno:%u, type:%u, next_blkoff:%u, blkofs:%u\",",
          "4310:      i, curseg->segno, curseg->alloc_type,",
          "4311:      curseg->next_blkoff, blkofs);",
          "",
          "---------------"
        ],
        "fs/f2fs/segment.h||fs/f2fs/segment.h": [
          "File: fs/f2fs/segment.h -> fs/f2fs/segment.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "693:  } while (cur_pos < sbi->blocks_per_seg);",
          "695:  if (unlikely(GET_SIT_VBLOCKS(raw_sit) != valid_blocks)) {",
          "699:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "700:   return -EINVAL;",
          "701:  }",
          "",
          "[Removed Lines]",
          "696:   f2fs_msg(sbi->sb, KERN_ERR,",
          "697:     \"Mismatch valid blocks %d vs. %d\",",
          "698:      GET_SIT_VBLOCKS(raw_sit), valid_blocks);",
          "",
          "[Added Lines]",
          "696:   f2fs_err(sbi, \"Mismatch valid blocks %d vs. %d\",",
          "697:     GET_SIT_VBLOCKS(raw_sit), valid_blocks);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "704:  if (unlikely(GET_SIT_VBLOCKS(raw_sit) > sbi->blocks_per_seg",
          "705:      || segno > TOTAL_SEGS(sbi) - 1)) {",
          "709:   set_sbi_flag(sbi, SBI_NEED_FSCK);",
          "710:   return -EINVAL;",
          "711:  }",
          "",
          "[Removed Lines]",
          "706:   f2fs_msg(sbi->sb, KERN_ERR,",
          "707:     \"Wrong valid blocks %d or segno %u\",",
          "708:      GET_SIT_VBLOCKS(raw_sit), segno);",
          "",
          "[Added Lines]",
          "705:   f2fs_err(sbi, \"Wrong valid blocks %d or segno %u\",",
          "706:     GET_SIT_VBLOCKS(raw_sit), segno);",
          "",
          "---------------"
        ],
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:  {Opt_err, NULL},",
          "206: };",
          "209: {",
          "210:  struct va_format vaf;",
          "211:  va_list args;",
          "213:  va_start(args, fmt);",
          "215:  vaf.va = &args;",
          "217:  va_end(args);",
          "218: }",
          "",
          "[Removed Lines]",
          "208: void f2fs_msg(struct super_block *sb, const char *level, const char *fmt, ...)",
          "214:  vaf.fmt = fmt;",
          "216:  printk(\"%sF2FS-fs (%s): %pV\\n\", level, sb->s_id, &vaf);",
          "",
          "[Added Lines]",
          "208: void f2fs_printk(struct f2fs_sb_info *sbi, const char *fmt, ...)",
          "212:  int level;",
          "216:  level = printk_get_level(fmt);",
          "217:  vaf.fmt = printk_skip_level(fmt);",
          "219:  printk(\"%c%cF2FS-fs (%s): %pV\\n\",",
          "220:         KERN_SOH_ASCII, level, sbi->sb->s_id, &vaf);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "226:  if (test_opt(sbi, RESERVE_ROOT) &&",
          "227:    F2FS_OPTION(sbi).root_reserved_blocks > limit) {",
          "228:   F2FS_OPTION(sbi).root_reserved_blocks = limit;",
          "232:  }",
          "233:  if (!test_opt(sbi, RESERVE_ROOT) &&",
          "234:   (!uid_eq(F2FS_OPTION(sbi).s_resuid,",
          "235:     make_kuid(&init_user_ns, F2FS_DEF_RESUID)) ||",
          "236:   !gid_eq(F2FS_OPTION(sbi).s_resgid,",
          "237:     make_kgid(&init_user_ns, F2FS_DEF_RESGID))))",
          "244: }",
          "246: static void init_once(void *foo)",
          "",
          "[Removed Lines]",
          "229:   f2fs_msg(sbi->sb, KERN_INFO,",
          "230:    \"Reduce reserved blocks for root = %u\",",
          "231:    F2FS_OPTION(sbi).root_reserved_blocks);",
          "238:   f2fs_msg(sbi->sb, KERN_INFO,",
          "239:    \"Ignore s_resuid=%u, s_resgid=%u w/o reserve_root\",",
          "240:     from_kuid_munged(&init_user_ns,",
          "241:      F2FS_OPTION(sbi).s_resuid),",
          "242:     from_kgid_munged(&init_user_ns,",
          "243:      F2FS_OPTION(sbi).s_resgid));",
          "",
          "[Added Lines]",
          "234:   f2fs_info(sbi, \"Reduce reserved blocks for root = %u\",",
          "235:      F2FS_OPTION(sbi).root_reserved_blocks);",
          "242:   f2fs_info(sbi, \"Ignore s_resuid=%u, s_resgid=%u w/o reserve_root\",",
          "243:      from_kuid_munged(&init_user_ns,",
          "244:         F2FS_OPTION(sbi).s_resuid),",
          "245:      from_kgid_munged(&init_user_ns,",
          "246:         F2FS_OPTION(sbi).s_resgid));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "261:  int ret = -EINVAL;",
          "263:  if (sb_any_quota_loaded(sb) && !F2FS_OPTION(sbi).s_qf_names[qtype]) {",
          "267:   return -EINVAL;",
          "268:  }",
          "269:  if (f2fs_sb_has_quota_ino(sbi)) {",
          "272:   return 0;",
          "273:  }",
          "275:  qname = match_strdup(args);",
          "276:  if (!qname) {",
          "279:   return -ENOMEM;",
          "280:  }",
          "281:  if (F2FS_OPTION(sbi).s_qf_names[qtype]) {",
          "282:   if (strcmp(F2FS_OPTION(sbi).s_qf_names[qtype], qname) == 0)",
          "283:    ret = 0;",
          "284:   else",
          "287:      QTYPE2NAME(qtype));",
          "288:   goto errout;",
          "289:  }",
          "290:  if (strchr(qname, '/')) {",
          "293:   goto errout;",
          "294:  }",
          "295:  F2FS_OPTION(sbi).s_qf_names[qtype] = qname;",
          "",
          "[Removed Lines]",
          "264:   f2fs_msg(sb, KERN_ERR,",
          "265:    \"Cannot change journaled \"",
          "266:    \"quota options when quota turned on\");",
          "270:   f2fs_msg(sb, KERN_INFO,",
          "271:    \"QUOTA feature is enabled, so ignore qf_name\");",
          "277:   f2fs_msg(sb, KERN_ERR,",
          "278:    \"Not enough memory for storing quotafile name\");",
          "285:    f2fs_msg(sb, KERN_ERR,",
          "286:      \"%s quota file already specified\",",
          "291:   f2fs_msg(sb, KERN_ERR,",
          "292:    \"quotafile must be on filesystem root\");",
          "",
          "[Added Lines]",
          "267:   f2fs_err(sbi, \"Cannot change journaled quota options when quota turned on\");",
          "271:   f2fs_info(sbi, \"QUOTA feature is enabled, so ignore qf_name\");",
          "277:   f2fs_err(sbi, \"Not enough memory for storing quotafile name\");",
          "284:    f2fs_err(sbi, \"%s quota file already specified\",",
          "289:   f2fs_err(sbi, \"quotafile must be on filesystem root\");",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "305:  struct f2fs_sb_info *sbi = F2FS_SB(sb);",
          "307:  if (sb_any_quota_loaded(sb) && F2FS_OPTION(sbi).s_qf_names[qtype]) {",
          "310:   return -EINVAL;",
          "311:  }",
          "312:  kvfree(F2FS_OPTION(sbi).s_qf_names[qtype]);",
          "",
          "[Removed Lines]",
          "308:   f2fs_msg(sb, KERN_ERR, \"Cannot change journaled quota options\"",
          "309:    \" when quota turned on\");",
          "",
          "[Added Lines]",
          "305:   f2fs_err(sbi, \"Cannot change journaled quota options when quota turned on\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "324:  if (test_opt(sbi, PRJQUOTA) && !f2fs_sb_has_project_quota(sbi)) {",
          "327:   return -1;",
          "328:  }",
          "329:  if (F2FS_OPTION(sbi).s_qf_names[USRQUOTA] ||",
          "",
          "[Removed Lines]",
          "325:   f2fs_msg(sbi->sb, KERN_ERR, \"Project quota feature not enabled. \"",
          "326:     \"Cannot enable project quota enforcement.\");",
          "",
          "[Added Lines]",
          "321:   f2fs_err(sbi, \"Project quota feature not enabled. Cannot enable project quota enforcement.\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "344:   if (test_opt(sbi, GRPQUOTA) || test_opt(sbi, USRQUOTA) ||",
          "345:     test_opt(sbi, PRJQUOTA)) {",
          "348:    return -1;",
          "349:   }",
          "351:   if (!F2FS_OPTION(sbi).s_jquota_fmt) {",
          "354:    return -1;",
          "355:   }",
          "356:  }",
          "358:  if (f2fs_sb_has_quota_ino(sbi) && F2FS_OPTION(sbi).s_jquota_fmt) {",
          "361:   F2FS_OPTION(sbi).s_jquota_fmt = 0;",
          "362:  }",
          "363:  return 0;",
          "",
          "[Removed Lines]",
          "346:    f2fs_msg(sbi->sb, KERN_ERR, \"old and new quota \"",
          "347:      \"format mixing\");",
          "352:    f2fs_msg(sbi->sb, KERN_ERR, \"journaled quota format \"",
          "353:      \"not specified\");",
          "359:   f2fs_msg(sbi->sb, KERN_INFO,",
          "360:    \"QUOTA feature is enabled, so ignore jquota_fmt\");",
          "",
          "[Added Lines]",
          "341:    f2fs_err(sbi, \"old and new quota format mixing\");",
          "346:    f2fs_err(sbi, \"journaled quota format not specified\");",
          "352:   f2fs_info(sbi, \"QUOTA feature is enabled, so ignore jquota_fmt\");",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "425:    break;",
          "426:   case Opt_nodiscard:",
          "427:    if (f2fs_sb_has_blkzoned(sbi)) {",
          "430:     return -EINVAL;",
          "431:    }",
          "432:    clear_opt(sbi, DISCARD);",
          "",
          "[Removed Lines]",
          "428:     f2fs_msg(sb, KERN_WARNING,",
          "429:      \"discard is required for zoned block devices\");",
          "",
          "[Added Lines]",
          "420:     f2fs_warn(sbi, \"discard is required for zoned block devices\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "458:    break;",
          "459: #else",
          "460:   case Opt_user_xattr:",
          "463:    break;",
          "464:   case Opt_nouser_xattr:",
          "467:    break;",
          "468:   case Opt_inline_xattr:",
          "471:    break;",
          "472:   case Opt_noinline_xattr:",
          "475:    break;",
          "476: #endif",
          "477: #ifdef CONFIG_F2FS_FS_POSIX_ACL",
          "",
          "[Removed Lines]",
          "461:    f2fs_msg(sb, KERN_INFO,",
          "462:     \"user_xattr options not supported\");",
          "465:    f2fs_msg(sb, KERN_INFO,",
          "466:     \"nouser_xattr options not supported\");",
          "469:    f2fs_msg(sb, KERN_INFO,",
          "470:     \"inline_xattr options not supported\");",
          "473:    f2fs_msg(sb, KERN_INFO,",
          "474:     \"noinline_xattr options not supported\");",
          "",
          "[Added Lines]",
          "452:    f2fs_info(sbi, \"user_xattr options not supported\");",
          "455:    f2fs_info(sbi, \"nouser_xattr options not supported\");",
          "458:    f2fs_info(sbi, \"inline_xattr options not supported\");",
          "461:    f2fs_info(sbi, \"noinline_xattr options not supported\");",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "483:    break;",
          "484: #else",
          "485:   case Opt_acl:",
          "487:    break;",
          "488:   case Opt_noacl:",
          "490:    break;",
          "491: #endif",
          "492:   case Opt_active_logs:",
          "",
          "[Removed Lines]",
          "486:    f2fs_msg(sb, KERN_INFO, \"acl options not supported\");",
          "489:    f2fs_msg(sb, KERN_INFO, \"noacl options not supported\");",
          "",
          "[Added Lines]",
          "473:    f2fs_info(sbi, \"acl options not supported\");",
          "476:    f2fs_info(sbi, \"noacl options not supported\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "536:    if (args->from && match_int(args, &arg))",
          "537:     return -EINVAL;",
          "538:    if (test_opt(sbi, RESERVE_ROOT)) {",
          "542:    } else {",
          "543:     F2FS_OPTION(sbi).root_reserved_blocks = arg;",
          "544:     set_opt(sbi, RESERVE_ROOT);",
          "",
          "[Removed Lines]",
          "539:     f2fs_msg(sb, KERN_INFO,",
          "540:      \"Preserve previous reserve_root=%u\",",
          "541:      F2FS_OPTION(sbi).root_reserved_blocks);",
          "",
          "[Added Lines]",
          "526:     f2fs_info(sbi, \"Preserve previous reserve_root=%u\",",
          "527:        F2FS_OPTION(sbi).root_reserved_blocks);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "549:     return -EINVAL;",
          "550:    uid = make_kuid(current_user_ns(), arg);",
          "551:    if (!uid_valid(uid)) {",
          "554:     return -EINVAL;",
          "555:    }",
          "556:    F2FS_OPTION(sbi).s_resuid = uid;",
          "",
          "[Removed Lines]",
          "552:     f2fs_msg(sb, KERN_ERR,",
          "553:      \"Invalid uid value %d\", arg);",
          "",
          "[Added Lines]",
          "538:     f2fs_err(sbi, \"Invalid uid value %d\", arg);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "560:     return -EINVAL;",
          "561:    gid = make_kgid(current_user_ns(), arg);",
          "562:    if (!gid_valid(gid)) {",
          "565:     return -EINVAL;",
          "566:    }",
          "567:    F2FS_OPTION(sbi).s_resgid = gid;",
          "",
          "[Removed Lines]",
          "563:     f2fs_msg(sb, KERN_ERR,",
          "564:      \"Invalid gid value %d\", arg);",
          "",
          "[Added Lines]",
          "548:     f2fs_err(sbi, \"Invalid gid value %d\", arg);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "574:    if (strlen(name) == 8 &&",
          "575:      !strncmp(name, \"adaptive\", 8)) {",
          "576:     if (f2fs_sb_has_blkzoned(sbi)) {",
          "580:      kvfree(name);",
          "581:      return -EINVAL;",
          "582:     }",
          "",
          "[Removed Lines]",
          "577:      f2fs_msg(sb, KERN_WARNING,",
          "578:        \"adaptive mode is not allowed with \"",
          "579:        \"zoned block device feature\");",
          "",
          "[Added Lines]",
          "561:      f2fs_warn(sbi, \"adaptive mode is not allowed with zoned block device feature\");",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "594:    if (args->from && match_int(args, &arg))",
          "595:     return -EINVAL;",
          "596:    if (arg <= 0 || arg > __ilog2_u32(BIO_MAX_PAGES)) {",
          "600:     return -EINVAL;",
          "601:    }",
          "602:    F2FS_OPTION(sbi).write_io_size_bits = arg;",
          "",
          "[Removed Lines]",
          "597:     f2fs_msg(sb, KERN_WARNING,",
          "598:      \"Not support %d, larger than %d\",",
          "599:      1 << arg, BIO_MAX_PAGES);",
          "",
          "[Added Lines]",
          "579:     f2fs_warn(sbi, \"Not support %d, larger than %d\",",
          "580:        1 << arg, BIO_MAX_PAGES);",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "617:    break;",
          "618: #else",
          "619:   case Opt_fault_injection:",
          "622:    break;",
          "624:   case Opt_fault_type:",
          "627:    break;",
          "628: #endif",
          "629:   case Opt_lazytime:",
          "",
          "[Removed Lines]",
          "620:    f2fs_msg(sb, KERN_INFO,",
          "621:     \"fault_injection options not supported\");",
          "625:    f2fs_msg(sb, KERN_INFO,",
          "626:     \"fault_type options not supported\");",
          "",
          "[Added Lines]",
          "601:    f2fs_info(sbi, \"fault_injection options not supported\");",
          "605:    f2fs_info(sbi, \"fault_type options not supported\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "703:   case Opt_jqfmt_vfsv0:",
          "704:   case Opt_jqfmt_vfsv1:",
          "705:   case Opt_noquota:",
          "708:    break;",
          "709: #endif",
          "710:   case Opt_whint:",
          "",
          "[Removed Lines]",
          "706:    f2fs_msg(sb, KERN_INFO,",
          "707:      \"quota operations not supported\");",
          "",
          "[Added Lines]",
          "685:    f2fs_info(sbi, \"quota operations not supported\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "766:   case Opt_test_dummy_encryption:",
          "767: #ifdef CONFIG_FS_ENCRYPTION",
          "768:    if (!f2fs_sb_has_encrypt(sbi)) {",
          "770:     return -EINVAL;",
          "771:    }",
          "773:    F2FS_OPTION(sbi).test_dummy_encryption = true;",
          "776: #else",
          "779: #endif",
          "780:    break;",
          "781:   case Opt_checkpoint_disable_cap_perc:",
          "",
          "[Removed Lines]",
          "769:     f2fs_msg(sb, KERN_ERR, \"Encrypt feature is off\");",
          "774:    f2fs_msg(sb, KERN_INFO,",
          "775:      \"Test dummy encryption mode enabled\");",
          "777:    f2fs_msg(sb, KERN_INFO,",
          "778:      \"Test dummy encryption mount option ignored\");",
          "",
          "[Added Lines]",
          "747:     f2fs_err(sbi, \"Encrypt feature is off\");",
          "752:    f2fs_info(sbi, \"Test dummy encryption mode enabled\");",
          "754:    f2fs_info(sbi, \"Test dummy encryption mount option ignored\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "804:    clear_opt(sbi, DISABLE_CHECKPOINT);",
          "805:    break;",
          "806:   default:",
          "810:    return -EINVAL;",
          "811:   }",
          "812:  }",
          "",
          "[Removed Lines]",
          "807:    f2fs_msg(sb, KERN_ERR,",
          "808:     \"Unrecognized mount option \\\"%s\\\" or missing value\",",
          "809:     p);",
          "",
          "[Added Lines]",
          "783:    f2fs_err(sbi, \"Unrecognized mount option \\\"%s\\\" or missing value\",",
          "784:      p);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "815:   return -EINVAL;",
          "816: #else",
          "817:  if (f2fs_sb_has_quota_ino(sbi) && !f2fs_readonly(sbi->sb)) {",
          "821:   return -EINVAL;",
          "822:  }",
          "823:  if (f2fs_sb_has_project_quota(sbi) && !f2fs_readonly(sbi->sb)) {",
          "827:   return -EINVAL;",
          "828:  }",
          "829: #endif",
          "831:  if (F2FS_IO_SIZE_BITS(sbi) && !test_opt(sbi, LFS)) {",
          "835:   return -EINVAL;",
          "836:  }",
          "",
          "[Removed Lines]",
          "818:   f2fs_msg(sbi->sb, KERN_INFO,",
          "819:     \"Filesystem with quota feature cannot be mounted RDWR \"",
          "820:     \"without CONFIG_QUOTA\");",
          "824:   f2fs_msg(sb, KERN_ERR,",
          "825:    \"Filesystem with project quota feature cannot be \"",
          "826:    \"mounted RDWR without CONFIG_QUOTA\");",
          "832:   f2fs_msg(sb, KERN_ERR,",
          "833:     \"Should set mode=lfs with %uKB-sized IO\",",
          "834:     F2FS_IO_SIZE_KB(sbi));",
          "",
          "[Added Lines]",
          "793:   f2fs_info(sbi, \"Filesystem with quota feature cannot be mounted RDWR without CONFIG_QUOTA\");",
          "797:   f2fs_err(sbi, \"Filesystem with project quota feature cannot be mounted RDWR without CONFIG_QUOTA\");",
          "803:   f2fs_err(sbi, \"Should set mode=lfs with %uKB-sized IO\",",
          "804:     F2FS_IO_SIZE_KB(sbi));",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "841:   if (!f2fs_sb_has_extra_attr(sbi) ||",
          "842:    !f2fs_sb_has_flexible_inline_xattr(sbi)) {",
          "846:    return -EINVAL;",
          "847:   }",
          "848:   if (!test_opt(sbi, INLINE_XATTR)) {",
          "852:    return -EINVAL;",
          "853:   }",
          "",
          "[Removed Lines]",
          "843:    f2fs_msg(sb, KERN_ERR,",
          "844:      \"extra_attr or flexible_inline_xattr \"",
          "845:      \"feature is off\");",
          "849:    f2fs_msg(sb, KERN_ERR,",
          "850:      \"inline_xattr_size option should be \"",
          "851:      \"set with inline_xattr option\");",
          "",
          "[Added Lines]",
          "813:    f2fs_err(sbi, \"extra_attr or flexible_inline_xattr feature is off\");",
          "817:    f2fs_err(sbi, \"inline_xattr_size option should be set with inline_xattr option\");",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "858:   if (F2FS_OPTION(sbi).inline_xattr_size < min_size ||",
          "859:     F2FS_OPTION(sbi).inline_xattr_size > max_size) {",
          "863:    return -EINVAL;",
          "864:   }",
          "865:  }",
          "867:  if (test_opt(sbi, DISABLE_CHECKPOINT) && test_opt(sbi, LFS)) {",
          "870:   return -EINVAL;",
          "871:  }",
          "",
          "[Removed Lines]",
          "860:    f2fs_msg(sb, KERN_ERR,",
          "861:     \"inline xattr size is out of range: %d ~ %d\",",
          "862:     min_size, max_size);",
          "868:   f2fs_msg(sb, KERN_ERR,",
          "869:     \"LFS not compatible with checkpoint=disable\\n\");",
          "",
          "[Added Lines]",
          "826:    f2fs_err(sbi, \"inline xattr size is out of range: %d ~ %d\",",
          "827:      min_size, max_size);",
          "833:   f2fs_err(sbi, \"LFS not compatible with checkpoint=disable\\n\");",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1488:  block_t unusable;",
          "1490:  if (s_flags & SB_RDONLY) {",
          "1493:   return -EINVAL;",
          "1494:  }",
          "1495:  sbi->sb->s_flags |= SB_ACTIVE;",
          "",
          "[Removed Lines]",
          "1491:   f2fs_msg(sbi->sb, KERN_ERR,",
          "1492:     \"checkpoint=disable on readonly fs\");",
          "",
          "[Added Lines]",
          "1455:   f2fs_err(sbi, \"checkpoint=disable on readonly fs\");",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1593:  if (!(*flags & SB_RDONLY) && is_sbi_flag_set(sbi, SBI_NEED_SB_WRITE)) {",
          "1594:   err = f2fs_commit_super(sbi, false);",
          "1597:   if (!err)",
          "1598:    clear_sbi_flag(sbi, SBI_NEED_SB_WRITE);",
          "1599:  }",
          "",
          "[Removed Lines]",
          "1595:   f2fs_msg(sb, KERN_INFO,",
          "1596:    \"Try to recover all the superblocks, ret: %d\", err);",
          "",
          "[Added Lines]",
          "1558:   f2fs_info(sbi, \"Try to recover all the superblocks, ret: %d\",",
          "1559:      err);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1635:  if (no_extent_cache == !!test_opt(sbi, EXTENT_CACHE)) {",
          "1636:   err = -EINVAL;",
          "1639:   goto restore_opts;",
          "1640:  }",
          "1642:  if ((*flags & SB_RDONLY) && test_opt(sbi, DISABLE_CHECKPOINT)) {",
          "1643:   err = -EINVAL;",
          "1646:   goto restore_opts;",
          "1647:  }",
          "",
          "[Removed Lines]",
          "1637:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "1638:     \"switch extent_cache option is not allowed\");",
          "1644:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "1645:    \"disabling checkpoint not compatible with read-only\");",
          "",
          "[Added Lines]",
          "1600:   f2fs_warn(sbi, \"switch extent_cache option is not allowed\");",
          "1606:   f2fs_warn(sbi, \"disabling checkpoint not compatible with read-only\");",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1712: restore_gc:",
          "1713:  if (need_restart_gc) {",
          "1714:   if (f2fs_start_gc_thread(sbi))",
          "1717:  } else if (need_stop_gc) {",
          "1718:   f2fs_stop_gc_thread(sbi);",
          "1719:  }",
          "",
          "[Removed Lines]",
          "1715:    f2fs_msg(sbi->sb, KERN_WARNING,",
          "1716:     \"background gc thread has stopped\");",
          "",
          "[Added Lines]",
          "1676:    f2fs_warn(sbi, \"background gc thread has stopped\");",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1852: static int f2fs_quota_on_mount(struct f2fs_sb_info *sbi, int type)",
          "1853: {",
          "1854:  if (is_set_ckpt_flags(sbi, CP_QUOTA_NEED_FSCK_FLAG)) {",
          "1857:   return 0;",
          "1858:  }",
          "",
          "[Removed Lines]",
          "1855:   f2fs_msg(sbi->sb, KERN_ERR,",
          "1856:    \"quota sysfile may be corrupted, skip loading it\");",
          "",
          "[Added Lines]",
          "1815:   f2fs_err(sbi, \"quota sysfile may be corrupted, skip loading it\");",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1869:  if (f2fs_sb_has_quota_ino(sbi) && rdonly) {",
          "1870:   err = f2fs_enable_quotas(sbi->sb);",
          "1871:   if (err) {",
          "1874:    return 0;",
          "1875:   }",
          "1876:   return 1;",
          "",
          "[Removed Lines]",
          "1872:    f2fs_msg(sbi->sb, KERN_ERR,",
          "1873:      \"Cannot turn on quota_ino: %d\", err);",
          "",
          "[Added Lines]",
          "1831:    f2fs_err(sbi, \"Cannot turn on quota_ino: %d\", err);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1883:     enabled = 1;",
          "1884:     continue;",
          "1885:    }",
          "1888:   }",
          "1889:  }",
          "1890:  return enabled;",
          "",
          "[Removed Lines]",
          "1886:    f2fs_msg(sbi->sb, KERN_ERR,",
          "1887:     \"Cannot turn on quotas: %d on %d\", err, i);",
          "",
          "[Added Lines]",
          "1844:    f2fs_err(sbi, \"Cannot turn on quotas: %d on %d\",",
          "1845:      err, i);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1906:  qf_inode = f2fs_iget(sb, qf_inum);",
          "1907:  if (IS_ERR(qf_inode)) {",
          "1910:   return PTR_ERR(qf_inode);",
          "1911:  }",
          "",
          "[Removed Lines]",
          "1908:   f2fs_msg(sb, KERN_ERR,",
          "1909:    \"Bad quota inode %u:%lu\", type, qf_inum);",
          "",
          "[Added Lines]",
          "1866:   f2fs_err(F2FS_SB(sb), \"Bad quota inode %u:%lu\", type, qf_inum);",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1920: static int f2fs_enable_quotas(struct super_block *sb)",
          "1921: {",
          "1922:  int type, err = 0;",
          "1923:  unsigned long qf_inum;",
          "1924:  bool quota_mopt[MAXQUOTAS] = {",
          "1928:  };",
          "1930:  if (is_set_ckpt_flags(F2FS_SB(sb), CP_QUOTA_NEED_FSCK_FLAG)) {",
          "1933:   return 0;",
          "1934:  }",
          "",
          "[Removed Lines]",
          "1925:   test_opt(F2FS_SB(sb), USRQUOTA),",
          "1926:   test_opt(F2FS_SB(sb), GRPQUOTA),",
          "1927:   test_opt(F2FS_SB(sb), PRJQUOTA),",
          "1931:   f2fs_msg(sb, KERN_ERR,",
          "1932:    \"quota file may be corrupted, skip loading it\");",
          "",
          "[Added Lines]",
          "1879:  struct f2fs_sb_info *sbi = F2FS_SB(sb);",
          "1883:   test_opt(sbi, USRQUOTA),",
          "1884:   test_opt(sbi, GRPQUOTA),",
          "1885:   test_opt(sbi, PRJQUOTA),",
          "1889:   f2fs_err(sbi, \"quota file may be corrupted, skip loading it\");",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1942:     DQUOT_USAGE_ENABLED |",
          "1943:     (quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));",
          "1944:    if (err) {",
          "1949:     for (type--; type >= 0; type--)",
          "1950:      dquot_quota_off(sb, type);",
          "1951:     set_sbi_flag(F2FS_SB(sb),",
          "",
          "[Removed Lines]",
          "1945:     f2fs_msg(sb, KERN_ERR,",
          "1946:      \"Failed to enable quota tracking \"",
          "1947:      \"(type=%d, err=%d). Please run \"",
          "1948:      \"fsck to fix.\", type, err);",
          "",
          "[Added Lines]",
          "1902:     f2fs_err(sbi, \"Failed to enable quota tracking (type=%d, err=%d). Please run fsck to fix.\",",
          "1903:       type, err);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "2065:   if (err) {",
          "2066:    int ret = dquot_quota_off(sb, type);",
          "2072:    set_sbi_flag(F2FS_SB(sb), SBI_QUOTA_NEED_REPAIR);",
          "2073:   }",
          "2074:  }",
          "",
          "[Removed Lines]",
          "2068:    f2fs_msg(sb, KERN_ERR,",
          "2069:     \"Fail to turn off disk quota \"",
          "2070:     \"(type: %d, err: %d, ret:%d), Please \"",
          "2071:     \"run fsck to fix it.\", type, err, ret);",
          "",
          "[Added Lines]",
          "2023:    f2fs_err(F2FS_SB(sb), \"Fail to turn off disk quota (type: %d, err: %d, ret:%d), Please run fsck to fix it.\",",
          "2024:      type, err, ret);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "2361:     (segment_count << log_blocks_per_seg);",
          "2363:  if (segment0_blkaddr != cp_blkaddr) {",
          "2367:   return true;",
          "2368:  }",
          "2370:  if (cp_blkaddr + (segment_count_ckpt << log_blocks_per_seg) !=",
          "2371:        sit_blkaddr) {",
          "2376:   return true;",
          "2377:  }",
          "2379:  if (sit_blkaddr + (segment_count_sit << log_blocks_per_seg) !=",
          "2380:        nat_blkaddr) {",
          "2385:   return true;",
          "2386:  }",
          "2388:  if (nat_blkaddr + (segment_count_nat << log_blocks_per_seg) !=",
          "2389:        ssa_blkaddr) {",
          "2394:   return true;",
          "2395:  }",
          "2397:  if (ssa_blkaddr + (segment_count_ssa << log_blocks_per_seg) !=",
          "2398:        main_blkaddr) {",
          "2403:   return true;",
          "2404:  }",
          "2406:  if (main_end_blkaddr > seg_end_blkaddr) {",
          "2413:   return true;",
          "2414:  } else if (main_end_blkaddr < seg_end_blkaddr) {",
          "2415:   int err = 0;",
          "",
          "[Removed Lines]",
          "2364:   f2fs_msg(sb, KERN_INFO,",
          "2365:    \"Mismatch start address, segment0(%u) cp_blkaddr(%u)\",",
          "2366:    segment0_blkaddr, cp_blkaddr);",
          "2372:   f2fs_msg(sb, KERN_INFO,",
          "2373:    \"Wrong CP boundary, start(%u) end(%u) blocks(%u)\",",
          "2374:    cp_blkaddr, sit_blkaddr,",
          "2375:    segment_count_ckpt << log_blocks_per_seg);",
          "2381:   f2fs_msg(sb, KERN_INFO,",
          "2382:    \"Wrong SIT boundary, start(%u) end(%u) blocks(%u)\",",
          "2383:    sit_blkaddr, nat_blkaddr,",
          "2384:    segment_count_sit << log_blocks_per_seg);",
          "2390:   f2fs_msg(sb, KERN_INFO,",
          "2391:    \"Wrong NAT boundary, start(%u) end(%u) blocks(%u)\",",
          "2392:    nat_blkaddr, ssa_blkaddr,",
          "2393:    segment_count_nat << log_blocks_per_seg);",
          "2399:   f2fs_msg(sb, KERN_INFO,",
          "2400:    \"Wrong SSA boundary, start(%u) end(%u) blocks(%u)\",",
          "2401:    ssa_blkaddr, main_blkaddr,",
          "2402:    segment_count_ssa << log_blocks_per_seg);",
          "2407:   f2fs_msg(sb, KERN_INFO,",
          "2408:    \"Wrong MAIN_AREA boundary, start(%u) end(%u) block(%u)\",",
          "2409:    main_blkaddr,",
          "2410:    segment0_blkaddr +",
          "2411:     (segment_count << log_blocks_per_seg),",
          "2412:    segment_count_main << log_blocks_per_seg);",
          "",
          "[Added Lines]",
          "2317:   f2fs_info(sbi, \"Mismatch start address, segment0(%u) cp_blkaddr(%u)\",",
          "2318:      segment0_blkaddr, cp_blkaddr);",
          "2324:   f2fs_info(sbi, \"Wrong CP boundary, start(%u) end(%u) blocks(%u)\",",
          "2325:      cp_blkaddr, sit_blkaddr,",
          "2326:      segment_count_ckpt << log_blocks_per_seg);",
          "2332:   f2fs_info(sbi, \"Wrong SIT boundary, start(%u) end(%u) blocks(%u)\",",
          "2333:      sit_blkaddr, nat_blkaddr,",
          "2334:      segment_count_sit << log_blocks_per_seg);",
          "2340:   f2fs_info(sbi, \"Wrong NAT boundary, start(%u) end(%u) blocks(%u)\",",
          "2341:      nat_blkaddr, ssa_blkaddr,",
          "2342:      segment_count_nat << log_blocks_per_seg);",
          "2348:   f2fs_info(sbi, \"Wrong SSA boundary, start(%u) end(%u) blocks(%u)\",",
          "2349:      ssa_blkaddr, main_blkaddr,",
          "2350:      segment_count_ssa << log_blocks_per_seg);",
          "2355:   f2fs_info(sbi, \"Wrong MAIN_AREA boundary, start(%u) end(%u) block(%u)\",",
          "2356:      main_blkaddr,",
          "2357:      segment0_blkaddr +",
          "2358:      (segment_count << log_blocks_per_seg),",
          "2359:      segment_count_main << log_blocks_per_seg);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "2426:    err = __f2fs_commit_super(bh, NULL);",
          "2427:    res = err ? \"failed\" : \"done\";",
          "2428:   }",
          "2435:   if (err)",
          "2436:    return true;",
          "2437:  }",
          "",
          "[Removed Lines]",
          "2429:   f2fs_msg(sb, KERN_INFO,",
          "2430:    \"Fix alignment : %s, start(%u) end(%u) block(%u)\",",
          "2431:    res, main_blkaddr,",
          "2432:    segment0_blkaddr +",
          "2433:     (segment_count << log_blocks_per_seg),",
          "2434:    segment_count_main << log_blocks_per_seg);",
          "",
          "[Added Lines]",
          "2376:   f2fs_info(sbi, \"Fix alignment : %s, start(%u) end(%u) block(%u)\",",
          "2377:      res, main_blkaddr,",
          "2378:      segment0_blkaddr +",
          "2379:      (segment_count << log_blocks_per_seg),",
          "2380:      segment_count_main << log_blocks_per_seg);",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "2445:  block_t total_sections, blocks_per_seg;",
          "2446:  struct f2fs_super_block *raw_super = (struct f2fs_super_block *)",
          "2447:      (bh->b_data + F2FS_SUPER_OFFSET);",
          "2449:  unsigned int blocksize;",
          "2450:  size_t crc_offset = 0;",
          "2451:  __u32 crc = 0;",
          "",
          "[Removed Lines]",
          "2448:  struct super_block *sb = sbi->sb;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "2455:   crc_offset = le32_to_cpu(raw_super->checksum_offset);",
          "2456:   if (crc_offset !=",
          "2457:    offsetof(struct f2fs_super_block, crc)) {",
          "2461:    return 1;",
          "2462:   }",
          "2463:   crc = le32_to_cpu(raw_super->crc);",
          "2464:   if (!f2fs_crc_valid(sbi, crc, raw_super, crc_offset)) {",
          "2467:    return 1;",
          "2468:   }",
          "2469:  }",
          "2471:  if (F2FS_SUPER_MAGIC != le32_to_cpu(raw_super->magic)) {",
          "2475:   return 1;",
          "2476:  }",
          "2479:  if (F2FS_BLKSIZE != PAGE_SIZE) {",
          "2483:   return 1;",
          "2484:  }",
          "2487:  blocksize = 1 << le32_to_cpu(raw_super->log_blocksize);",
          "2488:  if (blocksize != F2FS_BLKSIZE) {",
          "2492:   return 1;",
          "2493:  }",
          "2496:  if (le32_to_cpu(raw_super->log_blocks_per_seg) != 9) {",
          "2500:   return 1;",
          "2501:  }",
          "",
          "[Removed Lines]",
          "2458:    f2fs_msg(sb, KERN_INFO,",
          "2459:     \"Invalid SB checksum offset: %zu\",",
          "2460:     crc_offset);",
          "2465:    f2fs_msg(sb, KERN_INFO,",
          "2466:     \"Invalid SB checksum value: %u\", crc);",
          "2472:   f2fs_msg(sb, KERN_INFO,",
          "2473:    \"Magic Mismatch, valid(0x%x) - read(0x%x)\",",
          "2474:    F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));",
          "2480:   f2fs_msg(sb, KERN_INFO,",
          "2481:    \"Invalid page_cache_size (%lu), supports only 4KB\",",
          "2482:    PAGE_SIZE);",
          "2489:   f2fs_msg(sb, KERN_INFO,",
          "2490:    \"Invalid blocksize (%u), supports only 4KB\",",
          "2491:    blocksize);",
          "2497:   f2fs_msg(sb, KERN_INFO,",
          "2498:    \"Invalid log blocks per segment (%u)\",",
          "2499:    le32_to_cpu(raw_super->log_blocks_per_seg));",
          "",
          "[Added Lines]",
          "2403:    f2fs_info(sbi, \"Invalid SB checksum offset: %zu\",",
          "2404:       crc_offset);",
          "2409:    f2fs_info(sbi, \"Invalid SB checksum value: %u\", crc);",
          "2415:   f2fs_info(sbi, \"Magic Mismatch, valid(0x%x) - read(0x%x)\",",
          "2416:      F2FS_SUPER_MAGIC, le32_to_cpu(raw_super->magic));",
          "2422:   f2fs_info(sbi, \"Invalid page_cache_size (%lu), supports only 4KB\",",
          "2423:      PAGE_SIZE);",
          "2430:   f2fs_info(sbi, \"Invalid blocksize (%u), supports only 4KB\",",
          "2431:      blocksize);",
          "2437:   f2fs_info(sbi, \"Invalid log blocks per segment (%u)\",",
          "2438:      le32_to_cpu(raw_super->log_blocks_per_seg));",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "2505:     F2FS_MAX_LOG_SECTOR_SIZE ||",
          "2506:   le32_to_cpu(raw_super->log_sectorsize) <",
          "2507:     F2FS_MIN_LOG_SECTOR_SIZE) {",
          "2510:   return 1;",
          "2511:  }",
          "2512:  if (le32_to_cpu(raw_super->log_sectors_per_block) +",
          "2513:   le32_to_cpu(raw_super->log_sectorsize) !=",
          "2514:    F2FS_MAX_LOG_SECTOR_SIZE) {",
          "2519:   return 1;",
          "2520:  }",
          "",
          "[Removed Lines]",
          "2508:   f2fs_msg(sb, KERN_INFO, \"Invalid log sectorsize (%u)\",",
          "2509:    le32_to_cpu(raw_super->log_sectorsize));",
          "2515:   f2fs_msg(sb, KERN_INFO,",
          "2516:    \"Invalid log sectors per block(%u) log sectorsize(%u)\",",
          "2517:    le32_to_cpu(raw_super->log_sectors_per_block),",
          "2518:    le32_to_cpu(raw_super->log_sectorsize));",
          "",
          "[Added Lines]",
          "2447:   f2fs_info(sbi, \"Invalid log sectorsize (%u)\",",
          "2448:      le32_to_cpu(raw_super->log_sectorsize));",
          "2454:   f2fs_info(sbi, \"Invalid log sectors per block(%u) log sectorsize(%u)\",",
          "2455:      le32_to_cpu(raw_super->log_sectors_per_block),",
          "2456:      le32_to_cpu(raw_super->log_sectorsize));",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "2530:  if (segment_count > F2FS_MAX_SEGMENT ||",
          "2531:     segment_count < F2FS_MIN_SEGMENTS) {",
          "2535:   return 1;",
          "2536:  }",
          "2538:  if (total_sections > segment_count ||",
          "2539:    total_sections < F2FS_MIN_SEGMENTS ||",
          "2540:    segs_per_sec > segment_count || !segs_per_sec) {",
          "2544:   return 1;",
          "2545:  }",
          "2547:  if ((segment_count / segs_per_sec) < total_sections) {",
          "2551:   return 1;",
          "2552:  }",
          "2554:  if (segment_count > (le64_to_cpu(raw_super->block_count) >> 9)) {",
          "2558:   return 1;",
          "2559:  }",
          "2561:  if (secs_per_zone > total_sections || !secs_per_zone) {",
          "2565:   return 1;",
          "2566:  }",
          "2567:  if (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||",
          "2568:    raw_super->hot_ext_count > F2FS_MAX_EXTENSION ||",
          "2569:    (le32_to_cpu(raw_super->extension_count) +",
          "2570:    raw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {",
          "2576:   return 1;",
          "2577:  }",
          "2579:  if (le32_to_cpu(raw_super->cp_payload) >",
          "2580:     (blocks_per_seg - F2FS_CP_PACKS)) {",
          "2585:   return 1;",
          "2586:  }",
          "",
          "[Removed Lines]",
          "2532:   f2fs_msg(sb, KERN_INFO,",
          "2533:    \"Invalid segment count (%u)\",",
          "2534:    segment_count);",
          "2541:   f2fs_msg(sb, KERN_INFO,",
          "2542:    \"Invalid segment/section count (%u, %u x %u)\",",
          "2543:    segment_count, total_sections, segs_per_sec);",
          "2548:   f2fs_msg(sb, KERN_INFO,",
          "2549:    \"Small segment_count (%u < %u * %u)\",",
          "2550:    segment_count, segs_per_sec, total_sections);",
          "2555:   f2fs_msg(sb, KERN_INFO,",
          "2556:    \"Wrong segment_count / block_count (%u > %llu)\",",
          "2557:    segment_count, le64_to_cpu(raw_super->block_count));",
          "2562:   f2fs_msg(sb, KERN_INFO,",
          "2563:    \"Wrong secs_per_zone / total_sections (%u, %u)\",",
          "2564:    secs_per_zone, total_sections);",
          "2571:   f2fs_msg(sb, KERN_INFO,",
          "2572:    \"Corrupted extension count (%u + %u > %u)\",",
          "2573:    le32_to_cpu(raw_super->extension_count),",
          "2574:    raw_super->hot_ext_count,",
          "2575:    F2FS_MAX_EXTENSION);",
          "2581:   f2fs_msg(sb, KERN_INFO,",
          "2582:    \"Insane cp_payload (%u > %u)\",",
          "2583:    le32_to_cpu(raw_super->cp_payload),",
          "2584:    blocks_per_seg - F2FS_CP_PACKS);",
          "",
          "[Added Lines]",
          "2470:   f2fs_info(sbi, \"Invalid segment count (%u)\", segment_count);",
          "2477:   f2fs_info(sbi, \"Invalid segment/section count (%u, %u x %u)\",",
          "2478:      segment_count, total_sections, segs_per_sec);",
          "2483:   f2fs_info(sbi, \"Small segment_count (%u < %u * %u)\",",
          "2484:      segment_count, segs_per_sec, total_sections);",
          "2489:   f2fs_info(sbi, \"Wrong segment_count / block_count (%u > %llu)\",",
          "2490:      segment_count, le64_to_cpu(raw_super->block_count));",
          "2495:   f2fs_info(sbi, \"Wrong secs_per_zone / total_sections (%u, %u)\",",
          "2496:      secs_per_zone, total_sections);",
          "2503:   f2fs_info(sbi, \"Corrupted extension count (%u + %u > %u)\",",
          "2504:      le32_to_cpu(raw_super->extension_count),",
          "2505:      raw_super->hot_ext_count,",
          "2506:      F2FS_MAX_EXTENSION);",
          "2512:   f2fs_info(sbi, \"Insane cp_payload (%u > %u)\",",
          "2513:      le32_to_cpu(raw_super->cp_payload),",
          "2514:      blocks_per_seg - F2FS_CP_PACKS);",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "2589:  if (le32_to_cpu(raw_super->node_ino) != 1 ||",
          "2590:   le32_to_cpu(raw_super->meta_ino) != 2 ||",
          "2591:   le32_to_cpu(raw_super->root_ino) != 3) {",
          "2597:   return 1;",
          "2598:  }",
          "",
          "[Removed Lines]",
          "2592:   f2fs_msg(sb, KERN_INFO,",
          "2593:    \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",",
          "2594:    le32_to_cpu(raw_super->node_ino),",
          "2595:    le32_to_cpu(raw_super->meta_ino),",
          "2596:    le32_to_cpu(raw_super->root_ino));",
          "",
          "[Added Lines]",
          "2522:   f2fs_info(sbi, \"Invalid Fs Meta Ino: node(%u) meta(%u) root(%u)\",",
          "2523:      le32_to_cpu(raw_super->node_ino),",
          "2524:      le32_to_cpu(raw_super->meta_ino),",
          "2525:      le32_to_cpu(raw_super->root_ino));",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "2638:  if (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||",
          "2639:    ovp_segments == 0 || reserved_segments == 0)) {",
          "2642:   return 1;",
          "2643:  }",
          "",
          "[Removed Lines]",
          "2640:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2641:    \"Wrong layout: check mkfs.f2fs version\");",
          "",
          "[Added Lines]",
          "2569:   f2fs_err(sbi, \"Wrong layout: check mkfs.f2fs version\");",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "2647:  log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);",
          "2648:  if (!user_block_count || user_block_count >=",
          "2649:    segment_count_main << log_blocks_per_seg) {",
          "2652:   return 1;",
          "2653:  }",
          "2655:  valid_user_blocks = le64_to_cpu(ckpt->valid_block_count);",
          "2656:  if (valid_user_blocks > user_block_count) {",
          "2660:   return 1;",
          "2661:  }",
          "",
          "[Removed Lines]",
          "2650:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2651:    \"Wrong user_block_count: %u\", user_block_count);",
          "2657:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2658:    \"Wrong valid_user_blocks: %u, user_block_count: %u\",",
          "2659:    valid_user_blocks, user_block_count);",
          "",
          "[Added Lines]",
          "2578:   f2fs_err(sbi, \"Wrong user_block_count: %u\",",
          "2579:     user_block_count);",
          "2585:   f2fs_err(sbi, \"Wrong valid_user_blocks: %u, user_block_count: %u\",",
          "2586:     valid_user_blocks, user_block_count);",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "2664:  avail_node_count = sbi->total_node_count - sbi->nquota_files -",
          "2665:       F2FS_RESERVED_NODE_NUM;",
          "2666:  if (valid_node_count > avail_node_count) {",
          "2670:   return 1;",
          "2671:  }",
          "",
          "[Removed Lines]",
          "2667:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2668:    \"Wrong valid_node_count: %u, avail_node_count: %u\",",
          "2669:    valid_node_count, avail_node_count);",
          "",
          "[Added Lines]",
          "2594:   f2fs_err(sbi, \"Wrong valid_node_count: %u, avail_node_count: %u\",",
          "2595:     valid_node_count, avail_node_count);",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "2680:   for (j = i + 1; j < NR_CURSEG_NODE_TYPE; j++) {",
          "2681:    if (le32_to_cpu(ckpt->cur_node_segno[i]) ==",
          "2682:     le32_to_cpu(ckpt->cur_node_segno[j])) {",
          "2687:     return 1;",
          "2688:    }",
          "2689:   }",
          "",
          "[Removed Lines]",
          "2683:     f2fs_msg(sbi->sb, KERN_ERR,",
          "2684:      \"Node segment (%u, %u) has the same \"",
          "2685:      \"segno: %u\", i, j,",
          "2686:      le32_to_cpu(ckpt->cur_node_segno[i]));",
          "",
          "[Added Lines]",
          "2609:     f2fs_err(sbi, \"Node segment (%u, %u) has the same segno: %u\",",
          "2610:       i, j,",
          "2611:       le32_to_cpu(ckpt->cur_node_segno[i]));",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "2695:   for (j = i + 1; j < NR_CURSEG_DATA_TYPE; j++) {",
          "2696:    if (le32_to_cpu(ckpt->cur_data_segno[i]) ==",
          "2697:     le32_to_cpu(ckpt->cur_data_segno[j])) {",
          "2702:     return 1;",
          "2703:    }",
          "2704:   }",
          "",
          "[Removed Lines]",
          "2698:     f2fs_msg(sbi->sb, KERN_ERR,",
          "2699:      \"Data segment (%u, %u) has the same \"",
          "2700:      \"segno: %u\", i, j,",
          "2701:      le32_to_cpu(ckpt->cur_data_segno[i]));",
          "",
          "[Added Lines]",
          "2623:     f2fs_err(sbi, \"Data segment (%u, %u) has the same segno: %u\",",
          "2624:       i, j,",
          "2625:       le32_to_cpu(ckpt->cur_data_segno[i]));",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "2707:   for (j = i; j < NR_CURSEG_DATA_TYPE; j++) {",
          "2708:    if (le32_to_cpu(ckpt->cur_node_segno[i]) ==",
          "2709:     le32_to_cpu(ckpt->cur_data_segno[j])) {",
          "2714:     return 1;",
          "2715:    }",
          "2716:   }",
          "",
          "[Removed Lines]",
          "2710:     f2fs_msg(sbi->sb, KERN_ERR,",
          "2711:      \"Data segment (%u) and Data segment (%u)\"",
          "2712:      \" has the same segno: %u\", i, j,",
          "2713:      le32_to_cpu(ckpt->cur_node_segno[i]));",
          "",
          "[Added Lines]",
          "2634:     f2fs_err(sbi, \"Data segment (%u) and Data segment (%u) has the same segno: %u\",",
          "2635:       i, j,",
          "2636:       le32_to_cpu(ckpt->cur_node_segno[i]));",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "2722:  if (sit_bitmap_size != ((sit_segs / 2) << log_blocks_per_seg) / 8 ||",
          "2723:   nat_bitmap_size != ((nat_segs / 2) << log_blocks_per_seg) / 8) {",
          "2727:   return 1;",
          "2728:  }",
          "",
          "[Removed Lines]",
          "2724:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2725:    \"Wrong bitmap size: sit: %u, nat:%u\",",
          "2726:    sit_bitmap_size, nat_bitmap_size);",
          "",
          "[Added Lines]",
          "2647:   f2fs_err(sbi, \"Wrong bitmap size: sit: %u, nat:%u\",",
          "2648:     sit_bitmap_size, nat_bitmap_size);",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "2732:  if (cp_pack_start_sum < cp_payload + 1 ||",
          "2733:   cp_pack_start_sum > blocks_per_seg - 1 -",
          "2734:    NR_CURSEG_TYPE) {",
          "2738:   return 1;",
          "2739:  }",
          "2741:  if (__is_set_ckpt_flags(ckpt, CP_LARGE_NAT_BITMAP_FLAG) &&",
          "2742:   le32_to_cpu(ckpt->checksum_offset) != CP_MIN_CHKSUM_OFFSET) {",
          "2747:   return 1;",
          "2748:  }",
          "2750:  if (unlikely(f2fs_cp_error(sbi))) {",
          "2752:   return 1;",
          "2753:  }",
          "2754:  return 0;",
          "",
          "[Removed Lines]",
          "2735:   f2fs_msg(sbi->sb, KERN_ERR,",
          "2736:    \"Wrong cp_pack_start_sum: %u\",",
          "2737:    cp_pack_start_sum);",
          "2743:   f2fs_msg(sbi->sb, KERN_WARNING,",
          "2744:    \"layout of large_nat_bitmap is deprecated, \"",
          "2745:    \"run fsck to repair, chksum_offset: %u\",",
          "2746:    le32_to_cpu(ckpt->checksum_offset));",
          "2751:   f2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");",
          "",
          "[Added Lines]",
          "2657:   f2fs_err(sbi, \"Wrong cp_pack_start_sum: %u\",",
          "2658:     cp_pack_start_sum);",
          "2664:   f2fs_warn(sbi, \"layout of large_nat_bitmap is deprecated, run fsck to repair, chksum_offset: %u\",",
          "2665:      le32_to_cpu(ckpt->checksum_offset));",
          "2670:   f2fs_err(sbi, \"A bug case: need to run fsck\");",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "2917:  for (block = 0; block < 2; block++) {",
          "2918:   bh = sb_bread(sb, block);",
          "2919:   if (!bh) {",
          "2922:    err = -EIO;",
          "2923:    continue;",
          "2924:   }",
          "2927:   if (sanity_check_raw_super(sbi, bh)) {",
          "2931:    err = -EINVAL;",
          "2932:    brelse(bh);",
          "2933:    continue;",
          "",
          "[Removed Lines]",
          "2920:    f2fs_msg(sb, KERN_ERR, \"Unable to read %dth superblock\",",
          "2921:     block + 1);",
          "2928:    f2fs_msg(sb, KERN_ERR,",
          "2929:     \"Can't find valid F2FS filesystem in %dth superblock\",",
          "2930:     block + 1);",
          "",
          "[Added Lines]",
          "2839:    f2fs_err(sbi, \"Unable to read %dth superblock\",",
          "2840:      block + 1);",
          "2847:    f2fs_err(sbi, \"Can't find valid F2FS filesystem in %dth superblock\",",
          "2848:      block + 1);",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "3057: #ifdef CONFIG_BLK_DEV_ZONED",
          "3058:   if (bdev_zoned_model(FDEV(i).bdev) == BLK_ZONED_HM &&",
          "3059:     !f2fs_sb_has_blkzoned(sbi)) {",
          "3062:    return -EINVAL;",
          "3063:   }",
          "3064:   if (bdev_zoned_model(FDEV(i).bdev) != BLK_ZONED_NONE) {",
          "3065:    if (init_blkz_info(sbi, i)) {",
          "3068:     return -EINVAL;",
          "3069:    }",
          "3070:    if (max_devices == 1)",
          "3071:     break;",
          "3079:    continue;",
          "3080:   }",
          "3081: #endif",
          "3090:  return 0;",
          "3091: }",
          "",
          "[Removed Lines]",
          "3060:    f2fs_msg(sbi->sb, KERN_ERR,",
          "3061:     \"Zoned block device feature not enabled\\n\");",
          "3066:     f2fs_msg(sbi->sb, KERN_ERR,",
          "3067:      \"Failed to initialize F2FS blkzone information\");",
          "3072:    f2fs_msg(sbi->sb, KERN_INFO,",
          "3073:     \"Mount Device [%2d]: %20s, %8u, %8x - %8x (zone: %s)\",",
          "3074:     i, FDEV(i).path,",
          "3075:     FDEV(i).total_segments,",
          "3076:     FDEV(i).start_blk, FDEV(i).end_blk,",
          "3077:     bdev_zoned_model(FDEV(i).bdev) == BLK_ZONED_HA ?",
          "3078:     \"Host-aware\" : \"Host-managed\");",
          "3082:   f2fs_msg(sbi->sb, KERN_INFO,",
          "3083:    \"Mount Device [%2d]: %20s, %8u, %8x - %8x\",",
          "3084:     i, FDEV(i).path,",
          "3085:     FDEV(i).total_segments,",
          "3086:     FDEV(i).start_blk, FDEV(i).end_blk);",
          "3087:  }",
          "3088:  f2fs_msg(sbi->sb, KERN_INFO,",
          "3089:    \"IO Block Size: %8d KB\", F2FS_IO_SIZE_KB(sbi));",
          "",
          "[Added Lines]",
          "2978:    f2fs_err(sbi, \"Zoned block device feature not enabled\\n\");",
          "2983:     f2fs_err(sbi, \"Failed to initialize F2FS blkzone information\");",
          "2988:    f2fs_info(sbi, \"Mount Device [%2d]: %20s, %8u, %8x - %8x (zone: %s)\",",
          "2989:       i, FDEV(i).path,",
          "2990:       FDEV(i).total_segments,",
          "2991:       FDEV(i).start_blk, FDEV(i).end_blk,",
          "2992:       bdev_zoned_model(FDEV(i).bdev) == BLK_ZONED_HA ?",
          "2993:       \"Host-aware\" : \"Host-managed\");",
          "2997:   f2fs_info(sbi, \"Mount Device [%2d]: %20s, %8u, %8x - %8x\",",
          "2998:      i, FDEV(i).path,",
          "2999:      FDEV(i).total_segments,",
          "3000:      FDEV(i).start_blk, FDEV(i).end_blk);",
          "3001:  }",
          "3002:  f2fs_info(sbi,",
          "3003:     \"IO Block Size: %8d KB\", F2FS_IO_SIZE_KB(sbi));",
          "",
          "---------------",
          "--- Hunk 50 ---",
          "[Context before]",
          "3133:  sbi->s_chksum_driver = crypto_alloc_shash(\"crc32\", 0, 0);",
          "3134:  if (IS_ERR(sbi->s_chksum_driver)) {",
          "3136:   err = PTR_ERR(sbi->s_chksum_driver);",
          "3137:   sbi->s_chksum_driver = NULL;",
          "3138:   goto free_sbi;",
          "",
          "[Removed Lines]",
          "3135:   f2fs_msg(sb, KERN_ERR, \"Cannot load crc32 driver.\");",
          "",
          "[Added Lines]",
          "3049:   f2fs_err(sbi, \"Cannot load crc32 driver.\");",
          "",
          "---------------",
          "--- Hunk 51 ---",
          "[Context before]",
          "3142:  if (unlikely(!sb_set_blocksize(sb, F2FS_BLKSIZE))) {",
          "3144:   goto free_sbi;",
          "3145:  }",
          "",
          "[Removed Lines]",
          "3143:   f2fs_msg(sb, KERN_ERR, \"unable to set blocksize\");",
          "",
          "[Added Lines]",
          "3057:   f2fs_err(sbi, \"unable to set blocksize\");",
          "",
          "---------------",
          "--- Hunk 52 ---",
          "[Context before]",
          "3165: #ifndef CONFIG_BLK_DEV_ZONED",
          "3166:  if (f2fs_sb_has_blkzoned(sbi)) {",
          "3169:   err = -EOPNOTSUPP;",
          "3170:   goto free_sb_buf;",
          "3171:  }",
          "",
          "[Removed Lines]",
          "3167:   f2fs_msg(sb, KERN_ERR,",
          "3168:     \"Zoned block device support is not enabled\");",
          "",
          "[Added Lines]",
          "3081:   f2fs_err(sbi, \"Zoned block device support is not enabled\");",
          "",
          "---------------",
          "--- Hunk 53 ---",
          "[Context before]",
          "3274:  sbi->meta_inode = f2fs_iget(sb, F2FS_META_INO(sbi));",
          "3275:  if (IS_ERR(sbi->meta_inode)) {",
          "3277:   err = PTR_ERR(sbi->meta_inode);",
          "3278:   goto free_io_dummy;",
          "3279:  }",
          "3281:  err = f2fs_get_valid_checkpoint(sbi);",
          "3282:  if (err) {",
          "3284:   goto free_meta_inode;",
          "3285:  }",
          "",
          "[Removed Lines]",
          "3276:   f2fs_msg(sb, KERN_ERR, \"Failed to read F2FS meta data inode\");",
          "3283:   f2fs_msg(sb, KERN_ERR, \"Failed to get valid F2FS checkpoint\");",
          "",
          "[Added Lines]",
          "3189:   f2fs_err(sbi, \"Failed to read F2FS meta data inode\");",
          "3196:   f2fs_err(sbi, \"Failed to get valid F2FS checkpoint\");",
          "",
          "---------------",
          "--- Hunk 54 ---",
          "[Context before]",
          "3298:  err = f2fs_scan_devices(sbi);",
          "3299:  if (err) {",
          "3301:   goto free_devices;",
          "3302:  }",
          "",
          "[Removed Lines]",
          "3300:   f2fs_msg(sb, KERN_ERR, \"Failed to find devices\");",
          "",
          "[Added Lines]",
          "3213:   f2fs_err(sbi, \"Failed to find devices\");",
          "",
          "---------------",
          "--- Hunk 55 ---",
          "[Context before]",
          "3329:  err = f2fs_build_segment_manager(sbi);",
          "3330:  if (err) {",
          "3333:   goto free_sm;",
          "3334:  }",
          "3335:  err = f2fs_build_node_manager(sbi);",
          "3336:  if (err) {",
          "3339:   goto free_nm;",
          "3340:  }",
          "",
          "[Removed Lines]",
          "3331:   f2fs_msg(sb, KERN_ERR,",
          "3332:    \"Failed to initialize F2FS segment manager (%d)\", err);",
          "3337:   f2fs_msg(sb, KERN_ERR,",
          "3338:    \"Failed to initialize F2FS node manager (%d)\", err);",
          "",
          "[Added Lines]",
          "3244:   f2fs_err(sbi, \"Failed to initialize F2FS segment manager (%d)\",",
          "3245:     err);",
          "3250:   f2fs_err(sbi, \"Failed to initialize F2FS node manager (%d)\",",
          "3251:     err);",
          "",
          "---------------",
          "--- Hunk 56 ---",
          "[Context before]",
          "3361:  sbi->node_inode = f2fs_iget(sb, F2FS_NODE_INO(sbi));",
          "3362:  if (IS_ERR(sbi->node_inode)) {",
          "3364:   err = PTR_ERR(sbi->node_inode);",
          "3365:   goto free_stats;",
          "3366:  }",
          "",
          "[Removed Lines]",
          "3363:   f2fs_msg(sb, KERN_ERR, \"Failed to read node inode\");",
          "",
          "[Added Lines]",
          "3276:   f2fs_err(sbi, \"Failed to read node inode\");",
          "",
          "---------------",
          "--- Hunk 57 ---",
          "[Context before]",
          "3369:  root = f2fs_iget(sb, F2FS_ROOT_INO(sbi));",
          "3370:  if (IS_ERR(root)) {",
          "3372:   err = PTR_ERR(root);",
          "3373:   goto free_node_inode;",
          "3374:  }",
          "",
          "[Removed Lines]",
          "3371:   f2fs_msg(sb, KERN_ERR, \"Failed to read root inode\");",
          "",
          "[Added Lines]",
          "3284:   f2fs_err(sbi, \"Failed to read root inode\");",
          "",
          "---------------",
          "--- Hunk 58 ---",
          "[Context before]",
          "3394:  if (f2fs_sb_has_quota_ino(sbi) && !f2fs_readonly(sb)) {",
          "3395:   err = f2fs_enable_quotas(sb);",
          "3396:   if (err)",
          "3399:  }",
          "3400: #endif",
          "",
          "[Removed Lines]",
          "3397:    f2fs_msg(sb, KERN_ERR,",
          "3398:     \"Cannot turn on quotas: error %d\", err);",
          "",
          "[Added Lines]",
          "3310:    f2fs_err(sbi, \"Cannot turn on quotas: error %d\", err);",
          "",
          "---------------",
          "--- Hunk 59 ---",
          "[Context before]",
          "3415:   if (f2fs_hw_is_readonly(sbi)) {",
          "3416:    if (!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {",
          "3417:     err = -EROFS;",
          "3421:     goto free_meta;",
          "3422:    }",
          "3425:    goto reset_checkpoint;",
          "3426:   }",
          "",
          "[Removed Lines]",
          "3418:     f2fs_msg(sb, KERN_ERR,",
          "3419:      \"Need to recover fsync data, but \"",
          "3420:      \"write access unavailable\");",
          "3423:    f2fs_msg(sbi->sb, KERN_INFO, \"write access \"",
          "3424:     \"unavailable, skipping recovery\");",
          "",
          "[Added Lines]",
          "3330:     f2fs_err(sbi, \"Need to recover fsync data, but write access unavailable\");",
          "3333:    f2fs_info(sbi, \"write access unavailable, skipping recovery\");",
          "",
          "---------------",
          "--- Hunk 60 ---",
          "[Context before]",
          "3436:    if (err != -ENOMEM)",
          "3437:     skip_recovery = true;",
          "3438:    need_fsck = true;",
          "3441:    goto free_meta;",
          "3442:   }",
          "3443:  } else {",
          "",
          "[Removed Lines]",
          "3439:    f2fs_msg(sb, KERN_ERR,",
          "3440:     \"Cannot recover all fsync data errno=%d\", err);",
          "",
          "[Added Lines]",
          "3348:    f2fs_err(sbi, \"Cannot recover all fsync data errno=%d\",",
          "3349:      err);",
          "",
          "---------------",
          "--- Hunk 61 ---",
          "[Context before]",
          "3446:   if (!f2fs_readonly(sb) && err > 0) {",
          "3447:    err = -EINVAL;",
          "3450:    goto free_meta;",
          "3451:   }",
          "3452:  }",
          "",
          "[Removed Lines]",
          "3448:    f2fs_msg(sb, KERN_ERR,",
          "3449:     \"Need to recover fsync data\");",
          "",
          "[Added Lines]",
          "3357:    f2fs_err(sbi, \"Need to recover fsync data\");",
          "",
          "---------------",
          "--- Hunk 62 ---",
          "[Context before]",
          "3478:  if (recovery) {",
          "3479:   err = f2fs_commit_super(sbi, true);",
          "3483:  }",
          "3485:  f2fs_join_shrinker(sbi);",
          "3487:  f2fs_tuning_parameters(sbi);",
          "3491:  f2fs_update_time(sbi, CP_TIME);",
          "3492:  f2fs_update_time(sbi, REQ_TIME);",
          "3493:  clear_sbi_flag(sbi, SBI_CP_DISABLED_QUICK);",
          "",
          "[Removed Lines]",
          "3480:   f2fs_msg(sb, KERN_INFO,",
          "3481:    \"Try to recover %dth superblock, ret: %d\",",
          "3482:    sbi->valid_super_block ? 1 : 2, err);",
          "3489:  f2fs_msg(sbi->sb, KERN_NOTICE, \"Mounted with checkpoint version = %llx\",",
          "3490:     cur_cp_version(F2FS_CKPT(sbi)));",
          "",
          "[Added Lines]",
          "3388:   f2fs_info(sbi, \"Try to recover %dth superblock, ret: %d\",",
          "3389:      sbi->valid_super_block ? 1 : 2, err);",
          "3396:  f2fs_notice(sbi, \"Mounted with checkpoint version = %llx\",",
          "3397:       cur_cp_version(F2FS_CKPT(sbi)));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0cfe75c5b011994651a4ca6d74f20aa997bfc69a",
      "candidate_info": {
        "commit_hash": "0cfe75c5b011994651a4ca6d74f20aa997bfc69a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0cfe75c5b011994651a4ca6d74f20aa997bfc69a",
        "files": [
          "fs/f2fs/super.c"
        ],
        "message": "f2fs: enhance sanity_check_raw_super() to avoid potential overflows\n\nIn order to avoid the below overflow issue, we should have checked the\nboundaries in superblock before reaching out to allocation. As Linus suggested,\nthe right place should be sanity_check_raw_super().\n\nDr Silvio Cesare of InfoSect reported:\n\nThere are integer overflows with using the cp_payload superblock field in the\nf2fs filesystem potentially leading to memory corruption.\n\ninclude/linux/f2fs_fs.h\n\nstruct f2fs_super_block {\n...\n        __le32 cp_payload;\n\nfs/f2fs/f2fs.h\n\ntypedef u32 block_t;    /*\n                         * should not change u32, since it is the on-disk block\n                         * address format, __le32.\n                         */\n...\n\nstatic inline block_t __cp_payload(struct f2fs_sb_info *sbi)\n{\n        return le32_to_cpu(F2FS_RAW_SUPER(sbi)->cp_payload);\n}\n\nfs/f2fs/checkpoint.c\n\n        block_t start_blk, orphan_blocks, i, j;\n...\n        start_blk = __start_cp_addr(sbi) + 1 + __cp_payload(sbi);\n        orphan_blocks = __start_sum_addr(sbi) - 1 - __cp_payload(sbi);\n\n+++ integer overflows\n\n...\n        unsigned int cp_blks = 1 + __cp_payload(sbi);\n...\n        sbi->ckpt = kzalloc(cp_blks * blk_size, GFP_KERNEL);\n\n+++ integer overflow leading to incorrect heap allocation.\n\n        int cp_payload_blks = __cp_payload(sbi);\n...\n        ckpt->cp_pack_start_sum = cpu_to_le32(1 + cp_payload_blks +\n                        orphan_blocks);\n\n+++ sign bug and integer overflow\n\n...\n        for (i = 1; i < 1 + cp_payload_blks; i++)\n\n+++ integer overflow\n\n...\n\n      sbi->max_orphans = (sbi->blocks_per_seg - F2FS_CP_PACKS -\n                        NR_CURSEG_TYPE - __cp_payload(sbi)) *\n                                F2FS_ORPHANS_PER_BLOCK;\n\n+++ integer overflow\n\nReported-by: Greg KH <greg@kroah.com>\nReported-by: Silvio Cesare <silvio.cesare@gmail.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nReviewed-by: Chao Yu <yuchao0@huawei.com>\nSigned-off-by: Jaegeuk Kim <jaegeuk@kernel.org>",
        "before_after_code_files": [
          "fs/f2fs/super.c||fs/f2fs/super.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ],
          "candidate": [
            "fs/f2fs/super.c||fs/f2fs/super.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/f2fs/super.c||fs/f2fs/super.c": [
          "File: fs/f2fs/super.c -> fs/f2fs/super.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2139: static int sanity_check_raw_super(struct f2fs_sb_info *sbi,",
          "2140:     struct buffer_head *bh)",
          "2141: {",
          "2142:  struct f2fs_super_block *raw_super = (struct f2fs_super_block *)",
          "2143:      (bh->b_data + F2FS_SUPER_OFFSET);",
          "2144:  struct super_block *sb = sbi->sb;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2142:  block_t segment_count, segs_per_sec, secs_per_zone;",
          "2143:  block_t total_sections, blocks_per_seg;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2195:   return 1;",
          "2196:  }",
          "2199:  if (le32_to_cpu(raw_super->node_ino) != 1 ||",
          "2200:   le32_to_cpu(raw_super->meta_ino) != 2 ||",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2200:  segment_count = le32_to_cpu(raw_super->segment_count);",
          "2201:  segs_per_sec = le32_to_cpu(raw_super->segs_per_sec);",
          "2202:  secs_per_zone = le32_to_cpu(raw_super->secs_per_zone);",
          "2203:  total_sections = le32_to_cpu(raw_super->section_count);",
          "2206:  blocks_per_seg = 1 << le32_to_cpu(raw_super->log_blocks_per_seg);",
          "2208:  if (segment_count > F2FS_MAX_SEGMENT ||",
          "2209:     segment_count < F2FS_MIN_SEGMENTS) {",
          "2210:   f2fs_msg(sb, KERN_INFO,",
          "2211:    \"Invalid segment count (%u)\",",
          "2212:    segment_count);",
          "2213:   return 1;",
          "2214:  }",
          "2216:  if (total_sections > segment_count ||",
          "2217:    total_sections < F2FS_MIN_SEGMENTS ||",
          "2218:    segs_per_sec > segment_count || !segs_per_sec) {",
          "2219:   f2fs_msg(sb, KERN_INFO,",
          "2220:    \"Invalid segment/section count (%u, %u x %u)\",",
          "2221:    segment_count, total_sections, segs_per_sec);",
          "2222:   return 1;",
          "2223:  }",
          "2225:  if ((segment_count / segs_per_sec) < total_sections) {",
          "2226:   f2fs_msg(sb, KERN_INFO,",
          "2227:    \"Small segment_count (%u < %u * %u)\",",
          "2228:    segment_count, segs_per_sec, total_sections);",
          "2229:   return 1;",
          "2230:  }",
          "2232:  if (segment_count > (le32_to_cpu(raw_super->block_count) >> 9)) {",
          "2233:   f2fs_msg(sb, KERN_INFO,",
          "2234:    \"Wrong segment_count / block_count (%u > %u)\",",
          "2235:    segment_count, le32_to_cpu(raw_super->block_count));",
          "2236:   return 1;",
          "2237:  }",
          "2239:  if (secs_per_zone > total_sections) {",
          "2240:   f2fs_msg(sb, KERN_INFO,",
          "2241:    \"Wrong secs_per_zone (%u > %u)\",",
          "2242:    secs_per_zone, total_sections);",
          "2243:   return 1;",
          "2244:  }",
          "2245:  if (le32_to_cpu(raw_super->extension_count) > F2FS_MAX_EXTENSION ||",
          "2246:    raw_super->hot_ext_count > F2FS_MAX_EXTENSION ||",
          "2247:    (le32_to_cpu(raw_super->extension_count) +",
          "2248:    raw_super->hot_ext_count) > F2FS_MAX_EXTENSION) {",
          "2249:   f2fs_msg(sb, KERN_INFO,",
          "2250:    \"Corrupted extension count (%u + %u > %u)\",",
          "2251:    le32_to_cpu(raw_super->extension_count),",
          "2252:    raw_super->hot_ext_count,",
          "2253:    F2FS_MAX_EXTENSION);",
          "2254:   return 1;",
          "2255:  }",
          "2257:  if (le32_to_cpu(raw_super->cp_payload) >",
          "2258:     (blocks_per_seg - F2FS_CP_PACKS)) {",
          "2259:   f2fs_msg(sb, KERN_INFO,",
          "2260:    \"Insane cp_payload (%u > %u)\",",
          "2261:    le32_to_cpu(raw_super->cp_payload),",
          "2262:    blocks_per_seg - F2FS_CP_PACKS);",
          "2263:   return 1;",
          "2264:  }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2207:   return 1;",
          "2208:  }",
          "2218:  if (sanity_check_area_boundary(sbi, bh))",
          "2219:   return 1;",
          "",
          "[Removed Lines]",
          "2210:  if (le32_to_cpu(raw_super->segment_count) > F2FS_MAX_SEGMENT) {",
          "2211:   f2fs_msg(sb, KERN_INFO,",
          "2212:    \"Invalid segment count (%u)\",",
          "2213:    le32_to_cpu(raw_super->segment_count));",
          "2214:   return 1;",
          "2215:  }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
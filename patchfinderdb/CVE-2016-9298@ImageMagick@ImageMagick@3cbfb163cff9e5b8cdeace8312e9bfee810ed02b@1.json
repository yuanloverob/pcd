{
  "cve_id": "CVE-2016-9298",
  "cve_desc": "Heap overflow in the WaveletDenoiseImage function in MagickCore/fx.c in ImageMagick before 6.9.6-4 and 7.x before 7.0.3-6 allows remote attackers to cause a denial of service (crash) via a crafted image.",
  "repo": "ImageMagick/ImageMagick",
  "patch_hash": "3cbfb163cff9e5b8cdeace8312e9bfee810ed02b",
  "patch_info": {
    "commit_hash": "3cbfb163cff9e5b8cdeace8312e9bfee810ed02b",
    "repo": "ImageMagick/ImageMagick",
    "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/3cbfb163cff9e5b8cdeace8312e9bfee810ed02b",
    "files": [
      "MagickCore/fx.c",
      "PerlMagick/demo/demo.pl"
    ],
    "message": "https://github.com/ImageMagick/ImageMagick/issues/296",
    "before_after_code_files": [
      "MagickCore/fx.c||MagickCore/fx.c",
      "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
    ]
  },
  "patch_diff": {
    "MagickCore/fx.c||MagickCore/fx.c": [
      "File: MagickCore/fx.c -> MagickCore/fx.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "5866:   if (AcquireMagickResource(WidthResource,4*image->columns) == MagickFalse)",
      "5867:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
      "5868:   pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*",
      "5870:   kernel=(float *) AcquireQuantumMemory(MagickMax(image->rows,image->columns),",
      "5871:     GetOpenMPMaximumThreads()*sizeof(*kernel));",
      "5872:   if ((pixels_info == (MemoryInfo *) NULL) || (kernel == (float *) NULL))",
      "",
      "[Removed Lines]",
      "5869:     sizeof(*pixels));",
      "",
      "[Added Lines]",
      "5869:     sizeof(*pixels));",
      "",
      "---------------"
    ],
    "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl": [
      "File: PerlMagick/demo/demo.pl -> PerlMagick/demo/demo.pl",
      "--- Hunk 1 ---",
      "[Context before]",
      "484: print \"WaveletDenoise...\\n\";",
      "485: $example=$model->Clone();",
      "487: $example->WaveletDenoise('5%');",
      "488: push(@$images,$example);",
      "",
      "[Removed Lines]",
      "486: $example->Label('WaveletDenoise');",
      "",
      "[Added Lines]",
      "486: $example->Label('Wavelet Denoise');",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "854656ff651b5cf2148ffdba2f44dadc5207bfe1",
      "candidate_info": {
        "commit_hash": "854656ff651b5cf2148ffdba2f44dadc5207bfe1",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/854656ff651b5cf2148ffdba2f44dadc5207bfe1",
        "files": [
          "MagickCore/fx.c",
          "PerlMagick/demo/demo.pl"
        ],
        "message": "...",
        "before_after_code_files": [
          "MagickCore/fx.c||MagickCore/fx.c",
          "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "MagickCore/fx.c||MagickCore/fx.c",
            "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
          ],
          "candidate": [
            "MagickCore/fx.c||MagickCore/fx.c",
            "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl"
          ]
        }
      },
      "candidate_diff": {
        "MagickCore/fx.c||MagickCore/fx.c": [
          "File: MagickCore/fx.c -> MagickCore/fx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5765: %",
          "5769:   const size_t height,const size_t radius,double *coefficients)",
          "5770: {",
          "5771:   register ssize_t",
          "5772:     i;",
          "5776:     filters are referred to as detail coefficients.  The detail coefficients",
          "5777:     have high values in the noisy parts of the signal.",
          "5780:     coefficients[i]=2.0*pixels[width*i]+pixels[width*(radius-i)]+",
          "5781:       pixels[width*(i+radius)];",
          "5783:     coefficients[i]=2.0*pixels[width*i]+pixels[width*(i-radius)]+",
          "5784:       pixels[width*(i+radius)];",
          "5786:     coefficients[i]=2.0*pixels[width*i]+pixels[width*(i-radius)]+",
          "5787:       pixels[width*(2*height-2-(i+radius))];",
          "5788: }",
          "",
          "[Removed Lines]",
          "5768: static inline void HatTransform(const float *restrict pixels,const size_t width,",
          "5775:     Lowpass filter outputs are called approximation coefficients & highigh_pass",
          "5779:   for (i=0; i < (ssize_t) radius; i++)",
          "5782:   for ( ; (i+radius) < (ssize_t) height; i++)",
          "5785:   for ( ; i < (ssize_t) height; i++)",
          "",
          "[Added Lines]",
          "5768: static inline void HatTransform(const float *restrict pixels,const size_t width,",
          "5775:     Lowpass filter outputs are called approximation kernel & highigh_pass",
          "5779:   for (i=0; i < (ssize_t) radius; i++)",
          "5782:   for ( ; (i+radius) < (ssize_t) height; i++)",
          "5785:   for ( ; i < (ssize_t) height; i++)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "5841:       return((Image *) NULL);",
          "5842:     }",
          "5843:   if (AcquireMagickResource(WidthResource,3*image->columns) == MagickFalse)",
          "5850:       (coefficients == (double *) NULL))",
          "5855:         wavelet_pixels_info=RelinquishVirtualMemory(wavelet_pixels_info);",
          "5856:       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5858:   wavelet_pixels=(float *) GetVirtualMemoryBlob(wavelet_pixels_info);",
          "5859:   status=MagickTrue;",
          "5860:   number_pixels=image->columns*image->rows;",
          "",
          "[Removed Lines]",
          "5844:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5845:   wavelet_pixels_info=AcquireVirtualMemory(3*image->columns,",
          "5846:     image->rows*sizeof(*wavelet_pixels));",
          "5847:   coefficients=(double *) AcquireQuantumMemory(MagickMax(image->rows,",
          "5848:     image->columns),GetOpenMPMaximumThreads()*sizeof(*coefficients));",
          "5849:   if ((wavelet_pixels_info == (MemoryInfo *) NULL) ||",
          "5851:     {",
          "5852:       if (coefficients != (double *) NULL)",
          "5853:         coefficients=(double *) RelinquishMagickMemory(coefficients);",
          "5854:       if (wavelet_pixels_info != (MemoryInfo *) NULL)",
          "5857:     }",
          "",
          "[Added Lines]",
          "5844:     ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5845:   pixels_info=AcquireVirtualMemory(3*image->columns,image->rows*",
          "5846:     sizeof(*pixels));",
          "5847:   kernel=(double *) AcquireQuantumMemory(MagickMax(image->rows,image->columns),",
          "5848:     GetOpenMPMaximumThreads()*sizeof(*kernel));",
          "5850:     {",
          "5851:       if (kernel != (double *) NULL)",
          "5852:         kernel=(double *) RelinquishMagickMemory(kernel);",
          "5853:       if (pixels_info != (MemoryInfo *) NULL)",
          "5856:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "5896:           break;",
          "5897:         }",
          "5898:       for (x=0; x < (ssize_t) image->columns; x++)",
          "5900:         wavelet_pixels[i]=(float) p[channel];",
          "5901:         i++;",
          "5902:         p+=GetPixelChannels(image);",
          "5903:       }",
          "5904:     }",
          "5907:       filters are referred to as detail coefficients. The detail coefficients",
          "5908:       have high values in the noisy parts of the signal.",
          "",
          "[Removed Lines]",
          "5899:       {",
          "5906:       Low pass filter outputs are called approximation coefficients & high pass",
          "",
          "[Added Lines]",
          "5898:       {",
          "5905:       Low pass filter outputs are called approximation kernel & high pass",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "5930:       {",
          "5931:         const int",
          "5932:           id = GetOpenMPThreadId();",
          "5937:         register ssize_t",
          "5938:           x;",
          "5942:           1UL << level,p);",
          "5944:           wavelet_pixels[y*image->columns+x+low_pass]=0.25*p[x];",
          "5945:       }",
          "5946: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "",
          "[Removed Lines]",
          "5934:         double",
          "5940:         p=coefficients+id*image->columns;",
          "5941:         HatTransform(wavelet_pixels+y*image->columns+high_pass,1,image->columns,",
          "5943:         for (x=0; x < (ssize_t) image->columns; x++)",
          "",
          "[Added Lines]",
          "5936:         HatTransform(pixels+y*image->columns+high_pass,1,image->columns,",
          "5938:         for (x=0; x < (ssize_t) image->columns; x++)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "5951:       {",
          "5952:         const int",
          "5953:           id = GetOpenMPThreadId();",
          "5958:         register ssize_t",
          "5959:           y;",
          "5963:           1UL << level,p);",
          "5965:           wavelet_pixels[y*image->columns+x+low_pass]=0.25*p[y];",
          "5966:       }",
          "",
          "[Removed Lines]",
          "5955:         double",
          "5961:         p=coefficients+id*image->rows;",
          "5962:         HatTransform(wavelet_pixels+x+low_pass,image->columns,image->rows,",
          "5964:         for (y=0; y < (ssize_t) image->rows; y++)",
          "",
          "[Added Lines]",
          "5953:         HatTransform(pixels+x+low_pass,image->columns,image->rows,1UL << level,",
          "5955:         for (y=0; y < (ssize_t) image->rows; y++)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "5974:       {",
          "5975:         double",
          "5976:           sample_squared;",
          "5979:             (wavelet_pixels[high_pass+i] < -magnitude))",
          "5982:         if (wavelet_pixels[low_pass+i] > 0.8)",
          "5983:           {",
          "5984:             standard_deviation[4]+=sample_squared;",
          "5985:             samples[4]++;",
          "5986:           }",
          "5988:           if (wavelet_pixels[low_pass+i] > 0.6)",
          "5989:             {",
          "5990:               standard_deviation[3]+=sample_squared;",
          "5991:               samples[3]++;",
          "5992:             }",
          "5994:             if (wavelet_pixels[low_pass+i] > 0.4)",
          "5995:               {",
          "5996:                 standard_deviation[2]+=sample_squared;",
          "5997:                 samples[2]++;",
          "5998:               }",
          "6000:               if (wavelet_pixels[low_pass+i] > 0.2)",
          "6001:                 {",
          "6002:                   standard_deviation[1]+=sample_squared;",
          "",
          "[Removed Lines]",
          "5978:         if ((wavelet_pixels[high_pass+i] > magnitude) &&",
          "5980:           continue;",
          "5981:         sample_squared=wavelet_pixels[high_pass+i]*wavelet_pixels[high_pass+i];",
          "5987:         else",
          "5993:           else",
          "5999:             else",
          "",
          "[Added Lines]",
          "5969:         if ((pixels[high_pass+i] > magnitude) &&",
          "5971:           continue;",
          "5972:         sample_squared=pixels[high_pass+i]*pixels[high_pass+i];",
          "5978:         else",
          "5984:           else",
          "5990:             else",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "6017:       magnitude=threshold*noise_levels[level];",
          "6018:       for (i=0; i < (ssize_t) number_pixels; ++i)",
          "6022:           wavelet_pixels[high_pass+i]+=magnitude-softness*magnitude;",
          "6025:             wavelet_pixels[high_pass+i]-=magnitude-softness*magnitude;",
          "6027:             wavelet_pixels[high_pass+i]*=softness;",
          "6029:           wavelet_pixels[i]+=wavelet_pixels[high_pass+i];",
          "6030:       }",
          "6031:       high_pass=low_pass;",
          "6032:     }",
          "6034:       Reconstruct image from the thresholded wavelet coefficients.",
          "6036:     i=0;",
          "",
          "[Removed Lines]",
          "6019:       {",
          "6020:         wavelet_pixels[high_pass+i]-=wavelet_pixels[low_pass+i];",
          "6021:         if (wavelet_pixels[high_pass+i] < -magnitude)",
          "6023:         else",
          "6024:           if (wavelet_pixels[high_pass+i] > magnitude)",
          "6026:           else",
          "6028:         if (high_pass != 0)",
          "",
          "[Added Lines]",
          "6010:       {",
          "6011:         pixels[high_pass+i]-=pixels[low_pass+i];",
          "6012:         if (pixels[high_pass+i] < -magnitude)",
          "6014:         else",
          "6015:           if (pixels[high_pass+i] > magnitude)",
          "6017:           else",
          "6019:         if (high_pass != 0)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "6061:       {",
          "6062:         float",
          "6063:           pixel;",
          "6065:         pixel=wavelet_pixels[i]+wavelet_pixels[low_pass+i];",
          "6066:         q[offset]=ClampToQuantum(pixel);",
          "6067:         i++;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "6083:       }",
          "6084:   }",
          "6085:   noise_view=DestroyCacheView(noise_view);",
          "6088:   wavelet_pixels_info=RelinquishVirtualMemory(wavelet_pixels_info);",
          "6089:   return(noise_image);",
          "",
          "[Removed Lines]",
          "6086:   image_view=DestroyCacheView(image_view);",
          "6087:   coefficients=(double *) RelinquishMagickMemory(coefficients);",
          "",
          "[Added Lines]",
          "6077:   image_view=DestroyCacheView(image_view);",
          "6078:   kernel=(double *) RelinquishMagickMemory(kernel);",
          "",
          "---------------"
        ],
        "PerlMagick/demo/demo.pl||PerlMagick/demo/demo.pl": [
          "File: PerlMagick/demo/demo.pl -> PerlMagick/demo/demo.pl",
          "--- Hunk 1 ---",
          "[Context before]",
          "484: print \"WaveletDenoise...\\n\";",
          "485: $example=$model->Clone();",
          "486: $example->Label('WaveletDenoise');",
          "488: push(@$images,$example);",
          "490: #",
          "",
          "[Removed Lines]",
          "487: $example->WaveletDenoise('0.1x0.1');",
          "",
          "[Added Lines]",
          "487: $example->WaveletDenoise('5%');",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6e3a82c240f2aea88544e19d12a64f3c410e58e9",
      "candidate_info": {
        "commit_hash": "6e3a82c240f2aea88544e19d12a64f3c410e58e9",
        "repo": "ImageMagick/ImageMagick",
        "commit_url": "https://github.com/ImageMagick/ImageMagick/commit/6e3a82c240f2aea88544e19d12a64f3c410e58e9",
        "files": [
          "MagickCore/accelerate-private.h",
          "MagickCore/accelerate.c",
          "MagickCore/accelerate.h",
          "MagickCore/fx.c",
          "MagickCore/fx.h",
          "MagickCore/opencl-private.h",
          "MagickCore/opencl.c",
          "MagickCore/option.c",
          "MagickWand/convert.c",
          "MagickWand/mogrify.c",
          "MagickWand/operation.c"
        ],
        "message": "Added wavelet denoise.",
        "before_after_code_files": [
          "MagickCore/accelerate-private.h||MagickCore/accelerate-private.h",
          "MagickCore/accelerate.c||MagickCore/accelerate.c",
          "MagickCore/accelerate.h||MagickCore/accelerate.h",
          "MagickCore/fx.c||MagickCore/fx.c",
          "MagickCore/fx.h||MagickCore/fx.h",
          "MagickCore/opencl-private.h||MagickCore/opencl-private.h",
          "MagickCore/opencl.c||MagickCore/opencl.c",
          "MagickCore/option.c||MagickCore/option.c",
          "MagickWand/convert.c||MagickWand/convert.c",
          "MagickWand/mogrify.c||MagickWand/mogrify.c",
          "MagickWand/operation.c||MagickWand/operation.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ],
          "candidate": [
            "MagickCore/fx.c||MagickCore/fx.c"
          ]
        }
      },
      "candidate_diff": {
        "MagickCore/accelerate-private.h||MagickCore/accelerate-private.h": [
          "File: MagickCore/accelerate-private.h -> MagickCore/accelerate-private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "3660:   }",
          "3661:  )",
          "3663:   ;",
          "3665: #endif // MAGICKCORE_OPENCL_SUPPORT",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3664:  STRINGIFY(",
          "3665:   __kernel __attribute__((reqd_work_group_size(64, 4, 1))) void WaveletDenoise(__global CLPixelType *srcImage, __global CLPixelType *dstImage,",
          "3666:      const float threshold,",
          "3667:      const int passes,",
          "3668:      const int imageWidth,",
          "3669:      const int imageHeight)",
          "3670:  {",
          "3671:   const int pad = (1 << (passes - 1));;",
          "3672:   const int tileSize = 64;",
          "3673:   const int tileRowPixels = 64;",
          "3674:   const float noise[] = { 0.8002, 0.2735, 0.1202, 0.0585, 0.0291, 0.0152, 0.0080, 0.0044 };",
          "3676:   CLPixelType stage[16];",
          "3678:   local float buffer[64 * 64];",
          "3680:   int srcx = get_group_id(0) * (tileSize - 2 * pad) - pad + get_local_id(0);",
          "3681:   int srcy = get_group_id(1) * (tileSize - 2 * pad) - pad;",
          "3683:   for (int i = get_local_id(1); i < tileSize; i += get_local_size(1)) {",
          "3684:    stage[i / 4] = srcImage[mirrorTop(mirrorBottom(srcx), imageWidth) + (mirrorTop(mirrorBottom(srcy + i) , imageHeight)) * imageWidth];",
          "3685:   }",
          "3688:   for (int channel = 0; channel < 3; ++channel) {",
          "3690:    switch (channel) {",
          "3691:    case 0:",
          "3692:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3693:      buffer[get_local_id(0) + i * tileRowPixels] = convert_float(stage[i / 4].s0);",
          "3694:     break;",
          "3695:    case 1:",
          "3696:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3697:      buffer[get_local_id(0) + i * tileRowPixels] = convert_float(stage[i / 4].s1);",
          "3698:     break;",
          "3699:    case 2:",
          "3700:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3701:      buffer[get_local_id(0) + i * tileRowPixels] = convert_float(stage[i / 4].s2);",
          "3702:     break;",
          "3703:    }",
          "3708:    float tmp[16];",
          "3709:    float accum[16];",
          "3710:    float pixel;",
          "3712:    for (int pass = 0; pass < passes; ++pass) {",
          "3713:     const int radius = 1 << pass;",
          "3714:     const int x = get_local_id(0);",
          "3715:     const float thresh = threshold * noise[pass];",
          "3717:     if (pass == 0)",
          "3718:      accum[0] = accum[1] = accum[2] = accum[3] = accum[4] = accum[5] = accum[6] = accum[6] = accum[7] = accum[8] = accum[9] = accum[10] = accum[11] = accum[12] = accum[13] = accum[14] = accum[15] = 0.0f;",
          "3723:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1)) {",
          "3724:      const int offset = i * tileRowPixels;",
          "3725:      if (pass == 0)",
          "3726:       tmp[i / 4] = buffer[x + offset];  // snapshot input on first pass",
          "3727:      pixel = 0.5f * tmp[i / 4] + 0.25 * (buffer[mirrorBottom(x - radius) + offset] + buffer[mirrorTop(x + radius, tileSize) + offset]);",
          "3728:      barrier(CLK_LOCAL_MEM_FENCE);",
          "3729:      buffer[x + offset] = pixel;",
          "3730:     }",
          "3731:     barrier(CLK_LOCAL_MEM_FENCE);",
          "3733:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1)) {",
          "3734:      pixel = 0.5f * buffer[x + i * tileRowPixels] + 0.25 * (buffer[x + mirrorBottom(i - radius) * tileRowPixels] + buffer[x + mirrorTop(i + radius, tileRowPixels) * tileRowPixels]);",
          "3735:      float delta = tmp[i / 4] - pixel;",
          "3736:      tmp[i / 4] = pixel;       // hold output in tmp until all workitems are done",
          "3737:      if (delta < -thresh)",
          "3738:       delta += thresh;",
          "3739:      else if (delta > thresh)",
          "3740:       delta -= thresh;",
          "3741:      else",
          "3742:       delta = 0;",
          "3743:      accum[i / 4] += delta;",
          "3745:     }",
          "3746:     barrier(CLK_LOCAL_MEM_FENCE);",
          "3747:     if (pass < passes - 1)",
          "3748:      for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3749:       buffer[x + i * tileRowPixels] = tmp[i / 4];  // store lowpass for next pass",
          "3750:     else  // last pass",
          "3751:      for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3752:       accum[i / 4] += tmp[i / 4];       // add the lowpass signal back to output",
          "3753:     barrier(CLK_LOCAL_MEM_FENCE);",
          "3754:    }",
          "3756:    switch (channel) {",
          "3757:    case 0:",
          "3758:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3759:      stage[i / 4].s0 = ClampToQuantum(accum[i / 4]);",
          "3760:     break;",
          "3761:    case 1:",
          "3762:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3763:      stage[i / 4].s1 = ClampToQuantum(accum[i / 4]);",
          "3764:     break;",
          "3765:    case 2:",
          "3766:     for (int i = get_local_id(1); i < tileSize; i += get_local_size(1))",
          "3767:      stage[i / 4].s2 = ClampToQuantum(accum[i / 4]);",
          "3768:     break;",
          "3769:    }",
          "3771:    barrier(CLK_LOCAL_MEM_FENCE);",
          "3772:   }",
          "3776:   if ((get_local_id(0) >= pad) && (get_local_id(0) < tileSize - pad) && (srcx >= 0) && (srcx  < imageWidth)) {",
          "3778:    for (int i = get_local_id(1); i < tileSize; i += get_local_size(1)) {",
          "3779:     if ((i >= pad) && (i < tileSize - pad) && (srcy + i > 0) && (srcy + i < imageHeight)) {",
          "3780:      dstImage[srcx + (srcy + i) * imageWidth] = stage[i / 4];",
          "3781:     }",
          "3782:    }",
          "3783:   }",
          "3784:  }",
          "3785:  )",
          "",
          "---------------"
        ],
        "MagickCore/accelerate.c||MagickCore/accelerate.c": [
          "File: MagickCore/accelerate.c -> MagickCore/accelerate.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "127:       image->colorspace != GRAYColorspace)",
          "128:     return(MagickFalse);",
          "135:   if ((GetImageVirtualPixelMethod(image) != UndefinedVirtualPixelMethod) &&",
          "136:       (GetImageVirtualPixelMethod(image) != EdgeVirtualPixelMethod))",
          "",
          "[Removed Lines]",
          "131:   if (image->storage_class != DirectClass)",
          "132:     return(MagickFalse);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7367:   return(filteredImage);",
          "7368: }",
          "7372: MagickExport Image *AccelerateAddNoiseImage(const Image *magick_unused(image),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7366: static Image *ComputeWaveletDenoiseImage(const Image *image,",
          "7367:   const double threshold,ExceptionInfo *exception)",
          "7368: {",
          "7369:   CacheView",
          "7373:   cl_command_queue",
          "7374:     queue;",
          "7376:   cl_context",
          "7377:   context;",
          "7379:   cl_int",
          "7380:     clStatus;",
          "7382:   cl_kernel",
          "7383:     denoiseKernel;",
          "7385:   cl_event",
          "7386:     event;",
          "7388:   cl_mem",
          "7389:     filteredImageBuffer,",
          "7390:     imageBuffer;",
          "7392:   cl_mem_flags",
          "7393:     mem_flags;",
          "7395:   const void",
          "7398:   Image",
          "7401:   MagickBooleanType",
          "7402:     outputReady;",
          "7404:   MagickCLEnv",
          "7405:     clEnv;",
          "7407:   MagickSizeType",
          "7408:     length;",
          "7410:   void",
          "7414:   unsigned int",
          "7415:     i;",
          "7417:   clEnv = NULL;",
          "7418:   filteredImage = NULL;",
          "7419:   filteredImage_view = NULL;",
          "7420:   context = NULL;",
          "7421:   imageBuffer = NULL;",
          "7422:   filteredImageBuffer = NULL;",
          "7423:   denoiseKernel = NULL;",
          "7424:   queue = NULL;",
          "7425:   outputReady = MagickFalse;",
          "7427:   clEnv = GetDefaultOpenCLEnv();",
          "7428:   context = GetOpenCLContext(clEnv);",
          "7429:   queue = AcquireOpenCLCommandQueue(clEnv);",
          "7432:   image_view = AcquireVirtualCacheView(image, exception);",
          "7433:   inputPixels = GetCacheViewVirtualPixels(image_view, 0, 0, image->columns, image->rows, exception);",
          "7434:   if (inputPixels == (const void *)NULL)",
          "7435:   {",
          "7436:     (void)OpenCLThrowMagickException(exception, GetMagickModule(), CacheWarning, \"UnableToReadPixelCache.\", \"`%s'\", image->filename);",
          "7437:     goto cleanup;",
          "7438:   }",
          "7441:   then use the host buffer directly from the GPU; otherwise,",
          "7443:   if (ALIGNED(inputPixels, CLPixelPacket))",
          "7444:   {",
          "7445:     mem_flags = CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR;",
          "7446:   }",
          "7447:   else",
          "7448:   {",
          "7449:     mem_flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;",
          "7450:   }",
          "7452:   length = image->columns * image->rows;",
          "7453:   imageBuffer = clEnv->library->clCreateBuffer(context, mem_flags, length * sizeof(CLPixelPacket), (void*)inputPixels, &clStatus);",
          "7454:   if (clStatus != CL_SUCCESS)",
          "7455:   {",
          "7456:     (void)OpenCLThrowMagickException(exception, GetMagickModule(), ResourceLimitWarning, \"clEnv->library->clCreateBuffer failed.\", \".\");",
          "7457:     goto cleanup;",
          "7458:   }",
          "7461:   filteredImage = CloneImage(image, image->columns, image->rows, MagickTrue, exception);",
          "7462:   assert(filteredImage != NULL);",
          "7463:   if (SetImageStorageClass(filteredImage, DirectClass, exception) != MagickTrue)",
          "7464:   {",
          "7465:     (void)OpenCLThrowMagickException(exception, GetMagickModule(), ResourceLimitWarning, \"CloneImage failed.\", \"'%s'\", \".\");",
          "7466:     goto cleanup;",
          "7467:   }",
          "7468:   filteredImage_view = AcquireAuthenticCacheView(filteredImage, exception);",
          "7469:   filteredPixels = GetCacheViewAuthenticPixels(filteredImage_view, 0, 0, filteredImage->columns, filteredImage->rows, exception);",
          "7470:   if (filteredPixels == (void *)NULL)",
          "7471:   {",
          "7472:     (void)OpenCLThrowMagickException(exception, GetMagickModule(), CacheWarning, \"UnableToReadPixelCache.\", \"`%s'\", filteredImage->filename);",
          "7473:     goto cleanup;",
          "7474:   }",
          "7476:   if (ALIGNED(filteredPixels, CLPixelPacket))",
          "7477:   {",
          "7478:     mem_flags = CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR;",
          "7479:     hostPtr = filteredPixels;",
          "7480:   }",
          "7481:   else",
          "7482:   {",
          "7483:     mem_flags = CL_MEM_WRITE_ONLY;",
          "7484:     hostPtr = NULL;",
          "7485:   }",
          "7488:   length = image->columns * image->rows;",
          "7489:   filteredImageBuffer = clEnv->library->clCreateBuffer(context, mem_flags, length * sizeof(CLPixelPacket), hostPtr, &clStatus);",
          "7490:   if (clStatus != CL_SUCCESS)",
          "7491:   {",
          "7492:     (void)OpenCLThrowMagickException(exception, GetMagickModule(), ResourceLimitWarning, \"clEnv->library->clCreateBuffer failed.\", \".\");",
          "7493:     goto cleanup;",
          "7494:   }",
          "7497:   denoiseKernel = AcquireOpenCLKernel(clEnv, MAGICK_OPENCL_ACCELERATE, \"WaveletDenoise\");",
          "7498:   if (denoiseKernel == NULL)",
          "7499:   {",
          "7500:     (void)OpenCLThrowMagickException(exception, GetMagickModule(), ResourceLimitWarning, \"AcquireOpenCLKernel failed.\", \"'%s'\", \".\");",
          "7501:     goto cleanup;",
          "7502:   };",
          "7505:   {",
          "7506:     const int PASSES = 5;",
          "7507:     cl_int width = (cl_int)image->columns;",
          "7508:     cl_int height = (cl_int)image->rows;",
          "7509:     cl_float thresh = threshold;",
          "7512:     i = 0;",
          "7513:     clStatus |= clEnv->library->clSetKernelArg(denoiseKernel, i++, sizeof(cl_mem), (void *)&imageBuffer);",
          "7514:     clStatus |= clEnv->library->clSetKernelArg(denoiseKernel, i++, sizeof(cl_mem), (void *)&filteredImageBuffer);",
          "7515:     clStatus |= clEnv->library->clSetKernelArg(denoiseKernel, i++, sizeof(cl_float), (void *)&thresh);",
          "7516:     clStatus |= clEnv->library->clSetKernelArg(denoiseKernel, i++, sizeof(cl_int), (void *)&PASSES);",
          "7517:     clStatus |= clEnv->library->clSetKernelArg(denoiseKernel, i++, sizeof(cl_int), (void *)&width);",
          "7518:     clStatus |= clEnv->library->clSetKernelArg(denoiseKernel, i++, sizeof(cl_int), (void *)&height);",
          "7520:     {",
          "7521:       const int TILESIZE = 64;",
          "7522:       const int PAD = 1 << (PASSES - 1);",
          "7523:       const int SIZE = TILESIZE - 2 * PAD;",
          "7525:       size_t gsize[2];",
          "7526:       size_t wsize[2];",
          "7528:       gsize[0] = ((width + (SIZE - 1)) / SIZE) * TILESIZE;",
          "7529:       gsize[1] = ((height + (SIZE - 1)) / SIZE) * 4;",
          "7530:       wsize[0] = TILESIZE;",
          "7531:       wsize[1] = 4;",
          "7533:       clStatus = clEnv->library->clEnqueueNDRangeKernel(queue, denoiseKernel, 2, NULL, gsize, wsize, 0, NULL, &event);",
          "7534:       if (clStatus != CL_SUCCESS)",
          "7535:       {",
          "7536:         (void)OpenCLThrowMagickException(exception, GetMagickModule(), ResourceLimitWarning, \"clEnv->library->clEnqueueNDRangeKernel failed.\", \"'%s'\", \".\");",
          "7537:         goto cleanup;",
          "7538:       }",
          "7539:     }",
          "7540:     RecordProfileData(clEnv, WaveletDenoiseKernel, event);",
          "7541:     clEnv->library->clReleaseEvent(event);",
          "7542:   }",
          "7546:   if (ALIGNED(filteredPixels, CLPixelPacket))",
          "7547:   {",
          "7548:     length = image->columns * image->rows;",
          "7549:     clEnv->library->clEnqueueMapBuffer(queue, filteredImageBuffer, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE, 0, length * sizeof(CLPixelPacket), 0, NULL, NULL, &clStatus);",
          "7550:   }",
          "7551:   else",
          "7552:   {",
          "7553:     length = image->columns * image->rows;",
          "7554:     clStatus = clEnv->library->clEnqueueReadBuffer(queue, filteredImageBuffer, CL_TRUE, 0, length * sizeof(CLPixelPacket), filteredPixels, 0, NULL, NULL);",
          "7555:   }",
          "7556:   if (clStatus != CL_SUCCESS)",
          "7557:   {",
          "7558:     (void)OpenCLThrowMagickException(exception, GetMagickModule(), ResourceLimitWarning, \"Reading output image from CL buffer failed.\", \"'%s'\", \".\");",
          "7559:     goto cleanup;",
          "7560:   }",
          "7562:   outputReady = SyncCacheViewAuthenticPixels(filteredImage_view, exception);",
          "7564: cleanup:",
          "7565:   OpenCLLogException(__FUNCTION__, __LINE__, exception);",
          "7567:   image_view = DestroyCacheView(image_view);",
          "7568:   if (filteredImage_view != NULL)",
          "7569:     filteredImage_view = DestroyCacheView(filteredImage_view);",
          "7571:   if (imageBuffer != NULL)   clEnv->library->clReleaseMemObject(imageBuffer);",
          "7572:   if (filteredImageBuffer != NULL) clEnv->library->clReleaseMemObject(filteredImageBuffer);",
          "7573:   if (denoiseKernel != NULL)  RelinquishOpenCLKernel(clEnv, denoiseKernel);",
          "7574:   if (queue != NULL)    RelinquishOpenCLCommandQueue(clEnv, queue);",
          "7575:   if (outputReady == MagickFalse)",
          "7576:   {",
          "7577:     if (filteredImage != NULL)",
          "7578:     {",
          "7579:       DestroyImage(filteredImage);",
          "7580:       filteredImage = NULL;",
          "7581:     }",
          "7582:   }",
          "7583:   return(filteredImage);",
          "7584: }",
          "7586: MagickExport Image *AccelerateWaveletDenoiseImage(const Image *image,",
          "7587:   const double threshold,ExceptionInfo *exception)",
          "7588: {",
          "7589:   Image",
          "7592:   assert(image != NULL);",
          "7593:   assert(exception != (ExceptionInfo *)NULL);",
          "7595:   if ((checkAccelerateCondition(image) == MagickFalse) ||",
          "7596:       (checkOpenCLEnvironment(exception) == MagickFalse))",
          "7597:     return (Image *) NULL;",
          "7599:   filteredImage=ComputeWaveletDenoiseImage(image,threshold,exception);",
          "7601:   return(filteredImage);",
          "7602: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "7581:   return((Image *) NULL);",
          "7582: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7818: MagickExport Image *AccelerateWaveletDenoiseImage(",
          "7819:   const Image *magick_unused(image),const double magick_unused(threshold),",
          "7820:   ExceptionInfo *magick_unused(exception))",
          "7821: {",
          "7822:   magick_unreferenced(image);",
          "7823:   magick_unreferenced(threshold);",
          "7824:   magick_unreferenced(exception);",
          "7826:   return((Image *)NULL);",
          "7827: }",
          "",
          "---------------"
        ],
        "MagickCore/accelerate.h||MagickCore/accelerate.h": [
          "File: MagickCore/accelerate.h -> MagickCore/accelerate.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "41:     const ResizeFilter *,ExceptionInfo *),",
          "46: extern MagickExport MagickBooleanType",
          "47:   AccelerateCompositeImage(Image *,const CompositeOperator,const Image *,",
          "",
          "[Removed Lines]",
          "44:     const double,const double,ExceptionInfo *);",
          "",
          "[Added Lines]",
          "44:     const double,const double,ExceptionInfo *),",
          "",
          "---------------"
        ],
        "MagickCore/fx.c||MagickCore/fx.c": [
          "File: MagickCore/fx.c -> MagickCore/fx.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5703:     for (x=0; x < (ssize_t) wave_image->columns; x++)",
          "5704:     {",
          "5705:       status=InterpolatePixelChannels(image,image_view,wave_image,method,",
          "5706:         (double) x,(double) (y-sine_map[x]),q,exception);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "5733: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "5734: %                                                                             %",
          "5735: %                                                                             %",
          "5736: %                                                                             %",
          "5737: %     W a v e l e t D e n o i s e I m a g e                                   %",
          "5738: %                                                                             %",
          "5739: %                                                                             %",
          "5740: %                                                                             %",
          "5741: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%",
          "5742: %",
          "5743: %  WaveletDenoiseImage() removes noise from the image using a wavelet",
          "5744: %  transform. Adapted from dcraw.c by David Coffin.",
          "5745: %",
          "5746: %  The format of the WaveletDenoiseImage method is:",
          "5747: %",
          "5748: %      Image *WaveletDenoiseImage(const Image *image, const double threshold,",
          "5749: %        ExceptionInfo *exception)",
          "5750: %",
          "5751: %  A description of each parameter follows:",
          "5752: %",
          "5753: %    o image: the image.",
          "5754: %",
          "5755: %    o threahold: defines the threshold for smoothing.",
          "5756: %",
          "5757: %    o exception: return any errors or warnings in this structure.",
          "5758: %",
          "5761: static inline void hat_transform(double *temp,double *base,ssize_t st,",
          "5762:   ssize_t size,ssize_t sc)",
          "5763: {",
          "5764:   ssize_t",
          "5765:     i;",
          "5767:   for (i = 0; i < sc; i++)",
          "5768:     temp[i]=2*base[st * i]+base[st*(sc - i)]+base[st*(i+sc)];",
          "5769:   for (; i + sc < size; i++)",
          "5770:     temp[i]=2*base[st*i]+base[st*(i-sc)]+base[st*(i+sc)];",
          "5771:   for (; i < size; i++)",
          "5772:     temp[i]=2*base[st*i]+base[st*(i-sc)]+base[st*(2*size-2-(i+sc))];",
          "5773: }",
          "5775: MagickExport Image *WaveletDenoiseImage(const Image *image, const double threshold,",
          "5776:   ExceptionInfo *exception)",
          "5777: {",
          "5778:   CacheView",
          "5782:   const Quantum",
          "5785:   double",
          "5788:   Image",
          "5791:   MemoryInfo",
          "5794:   Quantum",
          "5797:   size_t",
          "5798:     channel;",
          "5800:   ssize_t",
          "5801:     size,",
          "5802:     thread_count;",
          "5804:   static const double",
          "5805:     noise[]={0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044};",
          "5808:     Initialize noise image attributes.",
          "5810:   assert(image != (const Image *) NULL);",
          "5811:   assert(image->signature == MagickCoreSignature);",
          "5812:   if (image->debug != MagickFalse)",
          "5813:     (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);",
          "5814:   assert(exception != (ExceptionInfo *) NULL);",
          "5815:   assert(exception->signature == MagickCoreSignature);",
          "5817:   noise_image=(Image *) NULL;",
          "5818:   noise_image=AccelerateWaveletDenoiseImage(image,threshold,exception);",
          "5819:   if (noise_image != (Image *) NULL)",
          "5820:     return(noise_image);",
          "5822:   noise_image=CloneImage(image,0,0,MagickTrue,exception);",
          "5823:   if (noise_image == (Image *) NULL)",
          "5824:     return((Image *) NULL);",
          "5825:   if (SetImageStorageClass(noise_image,DirectClass,exception) == MagickFalse)",
          "5826:     {",
          "5827:       noise_image=DestroyImage(noise_image);",
          "5828:       return((Image *) NULL);",
          "5829:     }",
          "5831:   image_view=AcquireAuthenticCacheView(image,exception);",
          "5832:   noise_view=AcquireAuthenticCacheView(noise_image,exception);",
          "5834:   p=GetCacheViewAuthenticPixels(image_view,0,0,image->columns,image->rows,",
          "5835:     exception);",
          "5836:   q=GetCacheViewAuthenticPixels(noise_view,0,0,noise_image->columns,",
          "5837:     noise_image->rows,exception);",
          "5839:   thread_count=1;",
          "5840: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5841: #pragma omp parallel magick_threads(image,image,image->rows,1)",
          "5842:   {",
          "5843: #pragma omp single",
          "5844:     {",
          "5845:       thread_count = omp_get_num_threads();",
          "5846:     }",
          "5847:   }",
          "5848: #endif",
          "5851:   size=image->columns*image->rows;",
          "5852:   interImage_info=AcquireVirtualMemory((size*3+(image->rows+image->columns)*",
          "5853:     thread_count),sizeof(*interImage));",
          "5854:   if (interImage_info == (MemoryInfo *) NULL)",
          "5855:     {",
          "5856:       interImage_info=RelinquishVirtualMemory(interImage_info);",
          "5857:       ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");",
          "5858:     }",
          "5859:   interImage=(double *)GetVirtualMemoryBlob(interImage_info);",
          "5861:   for (channel = 0; channel < 3; ++channel)",
          "5862:   {",
          "5863:     double",
          "5864:       thold,",
          "5867:     register const Quantum",
          "5870:     size_t",
          "5871:       hpass,",
          "5872:       lev,",
          "5873:       lpass;",
          "5875:     ssize_t",
          "5876:       i,",
          "5877:       x,",
          "5878:       y;",
          "5880:     tmpBase=interImage+3*size;",
          "5882:     pp=p;",
          "5883:     switch (channel)",
          "5884:     {",
          "5885:       case 0:",
          "5886:         for (i = 0; i < (ssize_t) size; ++i)",
          "5887:         {",
          "5888:           interImage[i]=GetPixelRed(image,pp);",
          "5889:           pp+=image->number_channels;",
          "5890:         }",
          "5891:         break;",
          "5892:       case 1:",
          "5893:         for (i = 0; i < (ssize_t) size; ++i)",
          "5894:         {",
          "5895:           interImage[i]=GetPixelGreen(image,pp);",
          "5896:           pp+=image->number_channels;",
          "5897:         }",
          "5898:         break;",
          "5899:       case 2:",
          "5900:         for (i = 0; i < (ssize_t) size; ++i)",
          "5901:         {",
          "5902:           interImage[i]=GetPixelBlue(image,pp);",
          "5903:           pp+=image->number_channels;",
          "5904:         }",
          "5905:         break;",
          "5906:     }",
          "5907:     hpass=0;",
          "5908:     for (lev = 0; lev < 5; lev++)",
          "5909:     {",
          "5910:       lpass=size*((lev & 1)+1);",
          "5911: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5912:       #pragma omp parallel for schedule(static,1) private(x,y) \\",
          "5913:         magick_threads(image,image,image->rows,1)",
          "5914: #endif",
          "5915:       for (y = 0; y < (ssize_t) image->rows; ++y)",
          "5916:       {",
          "5917:         double",
          "5920:         tmp=tmpBase;",
          "5921: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5922:         tmp+=(image->rows+image->columns)*omp_get_thread_num();",
          "5923: #endif",
          "5924:         hat_transform(tmp,interImage+hpass+y*image->columns,1,",
          "5925:           (ssize_t) image->columns,(ssize_t)(1 << lev));",
          "5926:         for (x = 0; x < (ssize_t) image->columns; ++x)",
          "5927:         {",
          "5928:           interImage[lpass+y*image->columns+x]=tmp[x]*0.25;",
          "5929:         }",
          "5930:       }",
          "5931: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5932:       #pragma omp parallel for schedule(static,1) private(x,y) \\",
          "5933:         magick_threads(image,image,image->columns,1)",
          "5934: #endif",
          "5935:       for (x = 0; x < (ssize_t) image->columns; ++x)",
          "5936:       {",
          "5937:         double",
          "5940:         tmp=tmpBase;",
          "5941: #if defined(MAGICKCORE_OPENMP_SUPPORT)",
          "5942:         tmp+=(image->rows+image->columns)*omp_get_thread_num();",
          "5943: #endif",
          "5944:         hat_transform(tmp,interImage+lpass+x,(ssize_t) image->columns,",
          "5945:           (ssize_t) image->rows,(ssize_t)(1 << lev));",
          "5946:         for (y = 0; y < (ssize_t) image->rows; ++y)",
          "5947:         {",
          "5948:           interImage[lpass+y*image->columns+x]=tmp[y]*0.25;",
          "5949:         }",
          "5950:       }",
          "5951:       thold=threshold*noise[lev];",
          "5952:       for (i = 0; i < (ssize_t) size; ++i)",
          "5953:       {",
          "5954:         interImage[hpass+i]-=interImage[lpass+i];",
          "5955:         if (interImage[hpass+i] < -thold)",
          "5956:           interImage[hpass+i]+=thold;",
          "5957:         else if (interImage[hpass+i] > thold)",
          "5958:           interImage[hpass+i]-=thold;",
          "5959:         else",
          "5960:           interImage[hpass+i]=0;",
          "5961:         if (hpass)",
          "5962:           interImage[i]+=interImage[hpass+i];",
          "5963:       }",
          "5964:       hpass=lpass;",
          "5965:     }",
          "5968:     switch (channel)",
          "5969:     {",
          "5970:       case 0:",
          "5971:         for (i = 0; i < (ssize_t) size; ++i)",
          "5972:           SetPixelRed(noise_image,ClampToQuantum(interImage[i]+",
          "5973:             interImage[i+lpass]),q+i*noise_image->number_channels);",
          "5974:         break;",
          "5975:       case 1:",
          "5976:         for (i = 0; i < (ssize_t) size; ++i)",
          "5977:           SetPixelGreen(noise_image,ClampToQuantum(interImage[i]+",
          "5978:             interImage[i+lpass]),q+i*noise_image->number_channels);",
          "5979:         break;",
          "5980:       case 2:",
          "5981:         for (i = 0; i < (ssize_t) size; ++i)",
          "5982:           SetPixelBlue(noise_image,ClampToQuantum(interImage[i]+",
          "5983:             interImage[i+lpass]),q+i*noise_image->number_channels);",
          "5984:         break;",
          "5985:     }",
          "5986:   }",
          "5988:   noise_view=DestroyCacheView(noise_view);",
          "5989:   image_view=DestroyCacheView(image_view);",
          "5990:   interImage_info=RelinquishVirtualMemory(interImage_info);",
          "5992:   return(noise_image);",
          "5993: }",
          "",
          "---------------"
        ],
        "MagickCore/fx.h||MagickCore/fx.h": [
          "File: MagickCore/fx.h -> MagickCore/fx.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "64:     const ssize_t,ExceptionInfo *),",
          "68: extern MagickExport MagickBooleanType",
          "69:   PlasmaImage(Image *,const SegmentInfo *,size_t,size_t,ExceptionInfo *),",
          "",
          "[Removed Lines]",
          "66:     const PixelInterpolateMethod,ExceptionInfo *);",
          "",
          "[Added Lines]",
          "66:     const PixelInterpolateMethod,ExceptionInfo *),",
          "",
          "---------------"
        ],
        "MagickCore/opencl-private.h||MagickCore/opencl-private.h": [
          "File: MagickCore/opencl-private.h -> MagickCore/opencl-private.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "374:   RotationalBlurKernel,",
          "375:   UnsharpMaskBlurColumnKernel,",
          "376:   UnsharpMaskKernel,",
          "377:   KERNEL_COUNT",
          "378: } ProfiledKernels;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "377:   WaveletDenoiseKernel,",
          "",
          "---------------"
        ],
        "MagickCore/opencl.c||MagickCore/opencl.c": [
          "File: MagickCore/opencl.c -> MagickCore/opencl.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "128:   \"ResizeVertical\",",
          "129:   \"RotationalBlur\",",
          "130:   \"UnsharpMaskBlurColumn\",",
          "131:   \"UnsharpMask\",",
          "132:   \"NONE\" };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "131:   \"UnsharpMask\",",
          "",
          "---------------"
        ],
        "MagickCore/option.c||MagickCore/option.c": [
          "File: MagickCore/option.c -> MagickCore/option.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "830:     { \"-visual\", 1L, NonMagickOptionFlag, MagickFalse },",
          "831:     { \"+watermark\", 0L, NonMagickOptionFlag, MagickFalse },",
          "832:     { \"-watermark\", 1L, NonMagickOptionFlag, MagickFalse },",
          "833:     { \"+wave\", 1L, DeprecateOptionFlag, MagickTrue },",
          "834:     { \"-wave\", 1L, SimpleOperatorFlag, MagickFalse },",
          "835:     { \"+weight\", 1L, DeprecateOptionFlag, MagickTrue },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "833:     { \"+wave\", 1L, DeprecateOptionFlag, MagickTrue },",
          "834:     { \"-wave\", 1L, SimpleOperatorFlag, MagickFalse },",
          "",
          "---------------"
        ],
        "MagickWand/convert.c||MagickWand/convert.c": [
          "File: MagickWand/convert.c -> MagickWand/convert.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "318:       \"-type type           image type\",",
          "319:       \"-unique-colors       discard all but one of any pixel color\",",
          "320:       \"-unsharp geometry    sharpen the image\",",
          "321:       \"-vignette geometry   soften the edges of the image in vignette style\",",
          "322:       \"-wave geometry       alter an image along a sine wave\",",
          "323:       \"-white-threshold value\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "321:       \"-vignette geometry   soften the edges of the image in vignette style\",",
          "322:       \"-wave geometry       alter an image along a sine wave\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3160:               ThrowConvertException(OptionError,\"MissingArgument\",option);",
          "3161:             if (IsGeometry(argv[i]) == MagickFalse)",
          "3162:               ThrowConvertInvalidArgumentException(option,argv[i]);",
          "3163:             break;",
          "3164:           }",
          "3165:         if (LocaleCompare(\"weight\",option+1) == 0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3162:               ThrowConvertException(OptionError,\"MissingArgument\",option);",
          "3163:             if (IsGeometry(argv[i]) == MagickFalse)",
          "3164:               ThrowConvertInvalidArgumentException(option,argv[i]);",
          "3165:             break;",
          "3166:           }",
          "3167:         if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)",
          "3168:           {",
          "3169:             i++;",
          "",
          "---------------"
        ],
        "MagickWand/mogrify.c||MagickWand/mogrify.c": [
          "File: MagickWand/mogrify.c -> MagickWand/mogrify.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3291:             (void) SyncImageSettings(mogrify_info,*image,exception);",
          "3292:             flags=ParseGeometry(argv[i+1],&geometry_info);",
          "3293:             if ((flags & SigmaValue) == 0)",
          "3294:               geometry_info.sigma=1.0;",
          "3295:             mogrify_image=WaveImage(*image,geometry_info.rho,",
          "3296:               geometry_info.sigma,interpolate_method,exception);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3294:               geometry_info.sigma=1.0;",
          "3295:             mogrify_image=WaveImage(*image,geometry_info.rho,",
          "3296:               geometry_info.sigma,interpolate_method,exception);",
          "3297:             break;",
          "3298:           }",
          "3299:         if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)",
          "3300:           {",
          "3302:               Wavelet denoise image.",
          "3304:             (void) SyncImageSettings(mogrify_info,*image,exception);",
          "3305:             flags=ParseGeometry(argv[i+1],&geometry_info);",
          "3306:             if ((flags & PercentValue) != 0)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3595:       \"-transparent color   make this color transparent within the image\",",
          "3596:       \"-transpose           flip image vertically and rotate 90 degrees\",",
          "3597:       \"-transverse          flop image horizontally and rotate 270 degrees\",",
          "3598:       \"-trim                trim image edges\",",
          "3599:       \"-type type           image type\",",
          "3600:       \"-unique-colors       discard all but one of any pixel color\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3611:       \"-trim                trim image edges\",",
          "3612:       \"-type type           image type\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6386:         if (LocaleCompare(\"wave\",option+1) == 0)",
          "6387:           {",
          "6388:             i++;",
          "6389:             if (i == (ssize_t) argc)",
          "6390:               ThrowMogrifyException(OptionError,\"MissingArgument\",option);",
          "6391:             if (IsGeometry(argv[i]) == MagickFalse)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6402:           {",
          "6403:             i++;",
          "6404:             if (i == (ssize_t) argc)",
          "6405:               ThrowMogrifyException(OptionError,\"MissingArgument\",option);",
          "6406:             if (IsGeometry(argv[i]) == MagickFalse)",
          "6407:               ThrowMogrifyInvalidArgumentException(option,argv[i]);",
          "6408:             break;",
          "6409:           }",
          "6410:         if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)",
          "",
          "---------------"
        ],
        "MagickWand/operation.c||MagickWand/operation.c": [
          "File: MagickWand/operation.c -> MagickWand/operation.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3539:           flags=ParseGeometry(arg1,&geometry_info);",
          "3540:           if ((flags & (RhoValue|SigmaValue)) == 0)",
          "3541:             CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);",
          "3542:           if ((flags & SigmaValue) == 0)",
          "3543:             geometry_info.sigma=1.0;",
          "3544:           new_image=WaveImage(_image,geometry_info.rho,geometry_info.sigma,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3540:           if ((flags & (RhoValue|SigmaValue)) == 0)",
          "3541:             CLIWandExceptArgBreak(OptionError,\"InvalidArgument\",option,arg1);",
          "3542:           if ((flags & SigmaValue) == 0)",
          "3543:             geometry_info.sigma=1.0;",
          "3544:           new_image=WaveImage(_image,geometry_info.rho,geometry_info.sigma,",
          "3545:                _image->interpolate,_exception);",
          "3546:           break;",
          "3547:         }",
          "3548:       if (LocaleCompare(\"wavelet-denoise\",option+1) == 0)",
          "3549:         {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2016-2847",
  "cve_desc": "fs/pipe.c in the Linux kernel before 4.5 does not limit the amount of unread data in pipes, which allows local users to cause a denial of service (memory consumption) by creating many pipes with non-default sizes.",
  "repo": "torvalds/linux",
  "patch_hash": "759c01142a5d0f364a462346168a56de28a80f52",
  "patch_info": {
    "commit_hash": "759c01142a5d0f364a462346168a56de28a80f52",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/759c01142a5d0f364a462346168a56de28a80f52",
    "files": [
      "Documentation/sysctl/fs.txt",
      "fs/pipe.c",
      "include/linux/pipe_fs_i.h",
      "include/linux/sched.h",
      "kernel/sysctl.c"
    ],
    "message": "pipe: limit the per-user amount of pages allocated in pipes\n\nOn no-so-small systems, it is possible for a single process to cause an\nOOM condition by filling large pipes with data that are never read. A\ntypical process filling 4000 pipes with 1 MB of data will use 4 GB of\nmemory. On small systems it may be tricky to set the pipe max size to\nprevent this from happening.\n\nThis patch makes it possible to enforce a per-user soft limit above\nwhich new pipes will be limited to a single page, effectively limiting\nthem to 4 kB each, as well as a hard limit above which no new pipes may\nbe created for this user. This has the effect of protecting the system\nagainst memory abuse without hurting other users, and still allowing\npipes to work correctly though with less data at once.\n\nThe limit are controlled by two new sysctls : pipe-user-pages-soft, and\npipe-user-pages-hard. Both may be disabled by setting them to zero. The\ndefault soft limit allows the default number of FDs per process (1024)\nto create pipes of the default size (64kB), thus reaching a limit of 64MB\nbefore starting to create only smaller pipes. With 256 processes limited\nto 1024 FDs each, this results in 1024*64kB + (256*1024 - 1024) * 4kB =\n1084 MB of memory allocated for a user. The hard limit is disabled by\ndefault to avoid breaking existing applications that make intensive use\nof pipes (eg: for splicing).\n\nReported-by: socketpair@gmail.com\nReported-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nMitigates: CVE-2013-4312 (Linux 2.0+)\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Willy Tarreau <w@1wt.eu>\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
    "before_after_code_files": [
      "fs/pipe.c||fs/pipe.c",
      "include/linux/pipe_fs_i.h||include/linux/pipe_fs_i.h",
      "include/linux/sched.h||include/linux/sched.h",
      "kernel/sysctl.c||kernel/sysctl.c"
    ]
  },
  "patch_diff": {
    "fs/pipe.c||fs/pipe.c": [
      "File: fs/pipe.c -> fs/pipe.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "39: unsigned int pipe_min_size = PAGE_SIZE;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "44: unsigned long pipe_user_pages_hard;",
      "45: unsigned long pipe_user_pages_soft = PIPE_DEF_BUFFERS * INR_OPEN_CUR;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "583:  return retval;",
      "584: }",
      "586: struct pipe_inode_info *alloc_pipe_info(void)",
      "587: {",
      "588:  struct pipe_inode_info *pipe;",
      "590:  pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);",
      "591:  if (pipe) {",
      "593:   if (pipe->bufs) {",
      "594:    init_waitqueue_head(&pipe->wait);",
      "595:    pipe->r_counter = pipe->w_counter = 1;",
      "597:    mutex_init(&pipe->mutex);",
      "598:    return pipe;",
      "599:   }",
      "600:   kfree(pipe);",
      "601:  }",
      "",
      "[Removed Lines]",
      "592:   pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);",
      "596:    pipe->buffers = PIPE_DEF_BUFFERS;",
      "",
      "[Added Lines]",
      "592: static void account_pipe_buffers(struct pipe_inode_info *pipe,",
      "593:                                  unsigned long old, unsigned long new)",
      "594: {",
      "595:  atomic_long_add(new - old, &pipe->user->pipe_bufs);",
      "596: }",
      "598: static bool too_many_pipe_buffers_soft(struct user_struct *user)",
      "599: {",
      "600:  return pipe_user_pages_soft &&",
      "601:         atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;",
      "602: }",
      "604: static bool too_many_pipe_buffers_hard(struct user_struct *user)",
      "605: {",
      "606:  return pipe_user_pages_hard &&",
      "607:         atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;",
      "608: }",
      "616:   unsigned long pipe_bufs = PIPE_DEF_BUFFERS;",
      "617:   struct user_struct *user = get_current_user();",
      "619:   if (!too_many_pipe_buffers_hard(user)) {",
      "620:    if (too_many_pipe_buffers_soft(user))",
      "621:     pipe_bufs = 1;",
      "622:    pipe->bufs = kzalloc(sizeof(struct pipe_buffer) * pipe_bufs, GFP_KERNEL);",
      "623:   }",
      "628:    pipe->buffers = pipe_bufs;",
      "629:    pipe->user = user;",
      "630:    account_pipe_buffers(pipe, 0, pipe_bufs);",
      "634:   free_uid(user);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "607: {",
      "608:  int i;",
      "610:  for (i = 0; i < pipe->buffers; i++) {",
      "611:   struct pipe_buffer *buf = pipe->bufs + i;",
      "612:   if (buf->ops)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "645:  account_pipe_buffers(pipe, pipe->buffers, 0);",
      "646:  free_uid(pipe->user);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "998:    memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));",
      "999:  }",
      "1001:  pipe->curbuf = 0;",
      "1002:  kfree(pipe->bufs);",
      "1003:  pipe->bufs = bufs;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1038:  account_pipe_buffers(pipe, pipe->buffers, nr_pages);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1069:   if (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {",
      "1070:    ret = -EPERM;",
      "1071:    goto out;",
      "1072:   }",
      "1073:   ret = pipe_set_size(pipe, nr_pages);",
      "1074:   break;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1110:   } else if ((too_many_pipe_buffers_hard(pipe->user) ||",
      "1111:        too_many_pipe_buffers_soft(pipe->user)) &&",
      "1112:              !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {",
      "1113:    ret = -EPERM;",
      "1114:    goto out;",
      "",
      "---------------"
    ],
    "include/linux/pipe_fs_i.h||include/linux/pipe_fs_i.h": [
      "File: include/linux/pipe_fs_i.h -> include/linux/pipe_fs_i.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "57:  struct fasync_struct *fasync_readers;",
      "58:  struct fasync_struct *fasync_writers;",
      "59:  struct pipe_buffer *bufs;",
      "60: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "61:  struct user_struct *user;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "123: void pipe_double_lock(struct pipe_inode_info *, struct pipe_inode_info *);",
      "125: extern unsigned int pipe_max_size, pipe_min_size;",
      "126: int pipe_proc_fn(struct ctl_table *, int, void __user *, size_t *, loff_t *);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "128: extern unsigned long pipe_user_pages_hard;",
      "129: extern unsigned long pipe_user_pages_soft;",
      "",
      "---------------"
    ],
    "include/linux/sched.h||include/linux/sched.h": [
      "File: include/linux/sched.h -> include/linux/sched.h"
    ],
    "kernel/sysctl.c||kernel/sysctl.c": [
      "File: kernel/sysctl.c -> kernel/sysctl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1757:   .proc_handler = &pipe_proc_fn,",
      "1758:   .extra1  = &pipe_min_size,",
      "1759:  },",
      "1760:  { }",
      "1761: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1760:  {",
      "1761:   .procname = \"pipe-user-pages-hard\",",
      "1762:   .data  = &pipe_user_pages_hard,",
      "1763:   .maxlen  = sizeof(pipe_user_pages_hard),",
      "1764:   .mode  = 0644,",
      "1765:   .proc_handler = proc_doulongvec_minmax,",
      "1766:  },",
      "1767:  {",
      "1768:   .procname = \"pipe-user-pages-soft\",",
      "1769:   .data  = &pipe_user_pages_soft,",
      "1770:   .maxlen  = sizeof(pipe_user_pages_soft),",
      "1771:   .mode  = 0644,",
      "1772:   .proc_handler = proc_doulongvec_minmax,",
      "1773:  },",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a005ca0e6813e1d796a7422a7e31d8b8d6555df1",
      "candidate_info": {
        "commit_hash": "a005ca0e6813e1d796a7422a7e31d8b8d6555df1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a005ca0e6813e1d796a7422a7e31d8b8d6555df1",
        "files": [
          "fs/pipe.c"
        ],
        "message": "pipe: fix limit checking in alloc_pipe_info()\n\nThe limit checking in alloc_pipe_info() (used by pipe(2) and when\nopening a FIFO) has the following problems:\n\n(1) When checking capacity required for the new pipe, the checks against\n    the limit in /proc/sys/fs/pipe-user-pages-{soft,hard} are made\n    against existing consumption, and exclude the memory required for\n    the new pipe capacity. As a consequence: (1) the memory allocation\n    throttling provided by the soft limit does not kick in quite as\n    early as it should, and (2) the user can overrun the hard limit.\n\n(2) As currently implemented, accounting and checking against the limits\n    is done as follows:\n\n    (a) Test whether the user has exceeded the limit.\n    (b) Make new pipe buffer allocation.\n    (c) Account new allocation against the limits.\n\n    This is racey. Multiple processes may pass point (a) simultaneously,\n    and then allocate pipe buffers that are accounted for only in step\n    (c).  The race means that the user's pipe buffer allocation could be\n    pushed over the limit (by an arbitrary amount, depending on how\n    unlucky we were in the race). [Thanks to Vegard Nossum for spotting\n    this point, which I had missed.]\n\nThis patch addresses the above problems as follows:\n\n* Alter the checks against limits to include the memory required for the\n  new pipe.\n* Re-order the accounting step so that it precedes the buffer allocation.\n  If the accounting step determines that a limit has been reached, revert\n  the accounting and cause the operation to fail.\n\nLink: http://lkml.kernel.org/r/8ff3e9f9-23f6-510c-644f-8e70cd1c0bd9@gmail.com\nSigned-off-by: Michael Kerrisk <mtk.manpages@gmail.com>\nReviewed-by: Vegard Nossum <vegard.nossum@oracle.com>\nCc: Willy Tarreau <w@1wt.eu>\nCc: <socketpair@gmail.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: Jens Axboe <axboe@fb.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "fs/pipe.c||fs/pipe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/pipe.c||fs/pipe.c"
          ],
          "candidate": [
            "fs/pipe.c||fs/pipe.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/pipe.c||fs/pipe.c": [
          "File: fs/pipe.c -> fs/pipe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "629:  if (pipe == NULL)",
          "630:   goto out_free_uid;",
          "638:  }",
          "640:  if (pipe->bufs) {",
          "641:   init_waitqueue_head(&pipe->wait);",
          "642:   pipe->r_counter = pipe->w_counter = 1;",
          "643:   pipe->buffers = pipe_bufs;",
          "644:   pipe->user = user;",
          "646:   mutex_init(&pipe->mutex);",
          "647:   return pipe;",
          "648:  }",
          "650:  kfree(pipe);",
          "651: out_free_uid:",
          "652:  free_uid(user);",
          "",
          "[Removed Lines]",
          "632:  if (!too_many_pipe_buffers_hard(user)) {",
          "633:   if (too_many_pipe_buffers_soft(user))",
          "634:    pipe_bufs = 1;",
          "635:   pipe->bufs = kcalloc(pipe_bufs,",
          "636:          sizeof(struct pipe_buffer),",
          "637:          GFP_KERNEL_ACCOUNT);",
          "645:   account_pipe_buffers(user, 0, pipe_bufs);",
          "",
          "[Added Lines]",
          "632:  account_pipe_buffers(user, 0, pipe_bufs);",
          "634:  if (too_many_pipe_buffers_soft(user)) {",
          "635:   account_pipe_buffers(user, pipe_bufs, 1);",
          "636:   pipe_bufs = 1;",
          "639:  if (too_many_pipe_buffers_hard(user))",
          "640:   goto out_revert_acct;",
          "642:  pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),",
          "643:         GFP_KERNEL_ACCOUNT);",
          "654: out_revert_acct:",
          "655:  account_pipe_buffers(user, pipe_bufs, 0);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
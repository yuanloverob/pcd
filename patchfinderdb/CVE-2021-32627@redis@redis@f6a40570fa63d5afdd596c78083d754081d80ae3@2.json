{
  "cve_id": "CVE-2021-32627",
  "cve_desc": "Redis is an open source, in-memory database that persists on disk. In affected versions an integer overflow bug in Redis can be exploited to corrupt the heap and potentially result with remote code execution. The vulnerability involves changing the default proto-max-bulk-len and client-query-buffer-limit configuration parameters to very large values and constructing specially crafted very large stream elements. The problem is fixed in Redis 6.2.6, 6.0.16 and 5.0.14. For users unable to upgrade an additional workaround to mitigate the problem without patching the redis-server executable is to prevent users from modifying the proto-max-bulk-len configuration parameter. This can be done using ACL to restrict unprivileged users from using the CONFIG SET command.",
  "repo": "redis/redis",
  "patch_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
  "patch_info": {
    "commit_hash": "f6a40570fa63d5afdd596c78083d754081d80ae3",
    "repo": "redis/redis",
    "commit_url": "https://github.com/redis/redis/commit/f6a40570fa63d5afdd596c78083d754081d80ae3",
    "files": [
      "src/geo.c",
      "src/listpack.c",
      "src/quicklist.c",
      "src/rdb.c",
      "src/server.h",
      "src/t_hash.c",
      "src/t_list.c",
      "src/t_stream.c",
      "src/t_zset.c",
      "src/ziplist.c",
      "src/ziplist.h",
      "tests/support/util.tcl",
      "tests/unit/violations.tcl"
    ],
    "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.",
    "before_after_code_files": [
      "src/geo.c||src/geo.c",
      "src/listpack.c||src/listpack.c",
      "src/quicklist.c||src/quicklist.c",
      "src/rdb.c||src/rdb.c",
      "src/server.h||src/server.h",
      "src/t_hash.c||src/t_hash.c",
      "src/t_list.c||src/t_list.c",
      "src/t_stream.c||src/t_stream.c",
      "src/t_zset.c||src/t_zset.c",
      "src/ziplist.c||src/ziplist.c",
      "src/ziplist.h||src/ziplist.h",
      "tests/support/util.tcl||tests/support/util.tcl",
      "tests/unit/violations.tcl||tests/unit/violations.tcl"
    ]
  },
  "patch_diff": {
    "src/geo.c||src/geo.c": [
      "File: src/geo.c -> src/geo.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "635:         robj *zobj;",
      "636:         zset *zs;",
      "637:         int i;",
      "640:         if (returned_items) {",
      "641:             zobj = createZsetObject();",
      "",
      "[Removed Lines]",
      "638:         size_t maxelelen = 0;",
      "",
      "[Added Lines]",
      "638:         size_t maxelelen = 0, totelelen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "650:             size_t elelen = sdslen(gp->member);",
      "652:             if (maxelelen < elelen) maxelelen = elelen;",
      "653:             znode = zslInsert(zs->zsl,score,gp->member);",
      "654:             serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);",
      "655:             gp->member = NULL;",
      "656:         }",
      "658:         if (returned_items) {",
      "660:             setKey(c,c->db,storekey,zobj);",
      "661:             decrRefCount(zobj);",
      "662:             notifyKeyspaceEvent(NOTIFY_ZSET,\"georadiusstore\",storekey,",
      "",
      "[Removed Lines]",
      "659:             zsetConvertToZiplistIfNeeded(zobj,maxelelen);",
      "",
      "[Added Lines]",
      "653:             totelelen += elelen;",
      "660:             zsetConvertToZiplistIfNeeded(zobj,maxelelen,totelelen);",
      "",
      "---------------"
    ],
    "src/listpack.c||src/listpack.c": [
      "File: src/listpack.c -> src/listpack.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "283:     } else {",
      "284:         if (size < 64) *enclen = 1+size;",
      "285:         else if (size < 4096) *enclen = 2+size;",
      "287:         return LP_ENCODING_STRING;",
      "288:     }",
      "289: }",
      "",
      "[Removed Lines]",
      "286:         else *enclen = 5+size;",
      "",
      "[Added Lines]",
      "286:         else *enclen = 5+(uint64_t)size;",
      "",
      "---------------"
    ],
    "src/quicklist.c||src/quicklist.c": [
      "File: src/quicklist.c -> src/quicklist.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "32: #include \"quicklist.h\"",
      "33: #include \"zmalloc.h\"",
      "34: #include \"ziplist.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "32: #include \"redisassert.h\"",
      "",
      "---------------"
    ],
    "src/rdb.c||src/rdb.c": [
      "File: src/rdb.c -> src/rdb.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1561:     } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {",
      "1563:         uint64_t zsetlen;",
      "1565:         zset *zs;",
      "1567:         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
      "",
      "[Removed Lines]",
      "1564:         size_t maxelelen = 0;",
      "",
      "[Added Lines]",
      "1564:         size_t maxelelen = 0, totelelen = 0;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1600:             if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);",
      "1602:             znode = zslInsert(zs->zsl,score,sdsele);",
      "1603:             dictAdd(zs->dict,sdsele,&znode->score);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1601:             totelelen += sdslen(sdsele);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1607:         if (zsetLength(o) <= server.zset_max_ziplist_entries &&",
      "1610:     } else if (rdbtype == RDB_TYPE_HASH) {",
      "1611:         uint64_t len;",
      "1612:         int ret;",
      "",
      "[Removed Lines]",
      "1608:             maxelelen <= server.zset_max_ziplist_value)",
      "1609:                 zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
      "",
      "[Added Lines]",
      "1609:             maxelelen <= server.zset_max_ziplist_value &&",
      "1610:             ziplistSafeToAdd(NULL, totelelen))",
      "1611:         {",
      "1612:             zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
      "1613:         }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1635:                 return NULL;",
      "1636:             }",
      "1645:             if (sdslen(field) > server.hash_max_ziplist_value ||",
      "1647:             {",
      "1650:                 hashTypeConvert(o, OBJ_ENCODING_HT);",
      "1651:                 break;",
      "1652:             }",
      "1653:             sdsfree(field);",
      "1654:             sdsfree(value);",
      "1655:         }",
      "",
      "[Removed Lines]",
      "1639:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
      "1640:                     sdslen(field), ZIPLIST_TAIL);",
      "1641:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
      "1642:                     sdslen(value), ZIPLIST_TAIL);",
      "1646:                 sdslen(value) > server.hash_max_ziplist_value)",
      "1648:                 sdsfree(field);",
      "1649:                 sdsfree(value);",
      "",
      "[Added Lines]",
      "1644:                 sdslen(value) > server.hash_max_ziplist_value ||",
      "1645:                 !ziplistSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))",
      "1648:                 ret = dictAdd((dict*)o->ptr, field, value);",
      "1649:                 if (ret == DICT_ERR) {",
      "1650:                     rdbExitReportCorruptRDB(\"Duplicate hash fields detected\");",
      "1651:                 }",
      "1656:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
      "1657:                     sdslen(field), ZIPLIST_TAIL);",
      "1658:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
      "1659:                     sdslen(value), ZIPLIST_TAIL);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1726:                     while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {",
      "1727:                         if (flen > maxlen) maxlen = flen;",
      "1728:                         if (vlen > maxlen) maxlen = vlen;",
      "1729:                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);",
      "1730:                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);",
      "1731:                     }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1737:                         if (!ziplistSafeToAdd(zl, (size_t)flen + vlen)) {",
      "1738:                             rdbExitReportCorruptRDB(\"Hash zipmap too big (%u)\", flen);",
      "1739:                         }",
      "",
      "---------------"
    ],
    "src/server.h||src/server.h": [
      "File: src/server.h -> src/server.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "1999: unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",
      "2000: unsigned long zsetLength(const robj *zobj);",
      "2001: void zsetConvert(robj *zobj, int encoding);",
      "2003: int zsetScore(robj *zobj, sds member, double *score);",
      "2004: unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",
      "2005: int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);",
      "",
      "[Removed Lines]",
      "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);",
      "",
      "[Added Lines]",
      "2002: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",
      "",
      "---------------"
    ],
    "src/t_hash.c||src/t_hash.c": [
      "File: src/t_hash.c -> src/t_hash.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "40: void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {",
      "41:     int i;",
      "43:     if (o->encoding != OBJ_ENCODING_ZIPLIST) return;",
      "45:     for (i = start; i <= end; i++) {",
      "49:             hashTypeConvert(o, OBJ_ENCODING_HT);",
      "51:         }",
      "52:     }",
      "53: }",
      "",
      "[Removed Lines]",
      "46:         if (sdsEncodedObject(argv[i]) &&",
      "47:             sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)",
      "48:         {",
      "50:             break;",
      "",
      "[Added Lines]",
      "42:     size_t sum = 0;",
      "47:         if (!sdsEncodedObject(argv[i]))",
      "48:             continue;",
      "49:         size_t len = sdslen(argv[i]->ptr);",
      "50:         if (len > server.hash_max_ziplist_value) {",
      "52:             return;",
      "54:         sum += len;",
      "56:     if (!ziplistSafeToAdd(o->ptr, sum))",
      "57:         hashTypeConvert(o, OBJ_ENCODING_HT);",
      "",
      "---------------"
    ],
    "src/t_list.c||src/t_list.c": [
      "File: src/t_list.c -> src/t_list.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: #include \"server.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "32: #define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "197: void pushGenericCommand(client *c, int where) {",
      "198:     int j, pushed = 0;",
      "199:     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);",
      "201:     if (lobj && lobj->type != OBJ_LIST) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "202:     for (j = 2; j < c->argc; j++) {",
      "203:         if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {",
      "204:             addReplyError(c, \"Element too large\");",
      "205:             return;",
      "206:         }",
      "207:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "277:         return;",
      "278:     }",
      "280:     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||",
      "281:         checkType(c,subject,OBJ_LIST)) return;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "290:     if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {",
      "291:         addReplyError(c, \"Element too large\");",
      "292:         return;",
      "293:     }",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "344:     long index;",
      "345:     robj *value = c->argv[3];",
      "347:     if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))",
      "348:         return;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "362:     if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {",
      "363:         addReplyError(c, \"Element too large\");",
      "364:         return;",
      "365:     }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "510:     int direction = LIST_TAIL;",
      "514:     for (int j = 3; j < c->argc; j++) {",
      "515:         char *opt = c->argv[j]->ptr;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "533:     if (sdslen(ele->ptr) > LIST_MAX_ITEM_SIZE) {",
      "534:         addReplyError(c, \"Element too large\");",
      "535:         return;",
      "536:     }",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "610:     long toremove;",
      "611:     long removed = 0;",
      "613:     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))",
      "614:         return;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "638:     if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {",
      "639:         addReplyError(c, \"Element too large\");",
      "640:         return;",
      "641:     }",
      "",
      "---------------"
    ],
    "src/t_stream.c||src/t_stream.c": [
      "File: src/t_stream.c -> src/t_stream.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43: void streamFreeCG(streamCG *cg);",
      "44: void streamFreeNACK(streamNACK *na);",
      "45: size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "47: #define STREAM_LISTPACK_MAX_SIZE (1<<30)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "212:     raxIterator ri;",
      "",
      "[Removed Lines]",
      "209:     if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;",
      "",
      "[Added Lines]",
      "218:     if (streamCompareID(&id,&s->last_id) <= 0) {",
      "219:         errno = EDOM;",
      "220:         return C_ERR;",
      "221:     }",
      "226:     size_t totelelen = 0;",
      "227:     for (int64_t i = 0; i < numfields*2; i++) {",
      "228:         sds ele = argv[i]->ptr;",
      "229:         totelelen += sdslen(ele);",
      "230:     }",
      "231:     if (totelelen > STREAM_LISTPACK_MAX_SIZE) {",
      "232:         errno = ERANGE;",
      "233:         return C_ERR;",
      "234:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "267:     if (lp != NULL) {",
      "271:             lp = NULL;",
      "272:         } else if (server.stream_node_max_entries) {",
      "273:             int64_t count = lpGetInteger(lpFirst(lp));",
      "",
      "[Removed Lines]",
      "268:         if (server.stream_node_max_bytes &&",
      "269:             lp_bytes >= server.stream_node_max_bytes)",
      "270:         {",
      "",
      "[Added Lines]",
      "293:         size_t node_max_bytes = server.stream_node_max_bytes;",
      "294:         if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)",
      "295:             node_max_bytes = STREAM_LISTPACK_MAX_SIZE;",
      "296:         if (lp_bytes + totelelen >= node_max_bytes) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1269:     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,",
      "1272:     {",
      "1275:         return;",
      "1276:     }",
      "1277:     addReplyStreamID(c,&id);",
      "",
      "[Removed Lines]",
      "1270:         &id, id_given ? &id : NULL)",
      "1271:         == C_ERR)",
      "1273:         addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"",
      "1274:                         \"target stream top item\");",
      "",
      "[Added Lines]",
      "1296:         &id, id_given ? &id : NULL) == C_ERR)",
      "1298:         if (errno == EDOM)",
      "1299:             addReplyError(c,\"The ID specified in XADD is equal or smaller than \"",
      "1300:                             \"the target stream top item\");",
      "1301:         else",
      "1302:             addReplyError(c,\"Elements are too large to be stored\");",
      "",
      "---------------"
    ],
    "src/t_zset.c||src/t_zset.c": [
      "File: src/t_zset.c -> src/t_zset.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1238: }",
      "1244:     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;",
      "1245:     zset *zset = zobj->ptr;",
      "1247:     if (zset->zsl->length <= server.zset_max_ziplist_entries &&",
      "1250: }",
      "",
      "[Removed Lines]",
      "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {",
      "1248:         maxelelen <= server.zset_max_ziplist_value)",
      "1249:             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
      "",
      "[Added Lines]",
      "1243: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {",
      "1248:         maxelelen <= server.zset_max_ziplist_value &&",
      "1249:         ziplistSafeToAdd(NULL, totelelen))",
      "1250:     {",
      "1251:         zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
      "1252:     }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1355:             }",
      "1356:             return 1;",
      "1357:         } else if (!xx) {",
      "1363:                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);",
      "1367:         } else {",
      "1369:             return 1;",
      "1370:         }",
      "1372:         zset *zs = zobj->ptr;",
      "1373:         zskiplistNode *znode;",
      "1374:         dictEntry *de;",
      "",
      "[Removed Lines]",
      "1360:             zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
      "1361:             if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||",
      "1362:                 sdslen(ele) > server.zset_max_ziplist_value)",
      "1364:             if (newscore) *newscore = score;",
      "1366:             return 1;",
      "1371:     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
      "",
      "[Added Lines]",
      "1363:             if (zzlLength(zobj->ptr)+1 > server.zset_max_ziplist_entries ||",
      "1364:                 sdslen(ele) > server.zset_max_ziplist_value ||",
      "1365:                 !ziplistSafeToAdd(zobj->ptr, sdslen(ele)))",
      "1366:             {",
      "1368:             } else {",
      "1369:                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
      "1370:                 if (newscore) *newscore = score;",
      "1372:                 return 1;",
      "1373:             }",
      "1378:     }",
      "1382:     if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2180:     zsetopsrc *src;",
      "2181:     zsetopval zval;",
      "2182:     sds tmp;",
      "2184:     robj *dstobj;",
      "2185:     zset *dstzset;",
      "2186:     zskiplistNode *znode;",
      "",
      "[Removed Lines]",
      "2183:     size_t maxelelen = 0;",
      "",
      "[Added Lines]",
      "2194:     size_t maxelelen = 0, totelelen = 0;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2304:                     tmp = zuiNewSdsFromValue(&zval);",
      "2305:                     znode = zslInsert(dstzset->zsl,score,tmp);",
      "2306:                     dictAdd(dstzset->dict,tmp,&znode->score);",
      "2307:                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
      "2308:                 }",
      "2309:             }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2318:                     totelelen += sdslen(tmp);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2343:                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
      "2345:                     dictSetKey(accumulator, de, tmp);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2355:                      totelelen += sdslen(tmp);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "2380:     if (dbDelete(c->db,dstkey))",
      "2381:         touched = 1;",
      "2382:     if (dstzset->zsl->length) {",
      "2384:         dbAdd(c->db,dstkey,dstobj);",
      "2385:         addReplyLongLong(c,zsetLength(dstobj));",
      "2386:         signalModifiedKey(c,c->db,dstkey);",
      "",
      "[Removed Lines]",
      "2383:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen);",
      "",
      "[Added Lines]",
      "2396:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen,totelelen);",
      "",
      "---------------"
    ],
    "src/ziplist.c||src/ziplist.c": [
      "File: src/ziplist.c -> src/ziplist.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "265:         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\",
      "266: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "270: #define ZIPLIST_MAX_SAFETY_SIZE (1<<30)",
      "271: int ziplistSafeToAdd(unsigned char* zl, size_t add) {",
      "272:     size_t len = zl? ziplistBlobLen(zl): 0;",
      "273:     if (len + add > ZIPLIST_MAX_SAFETY_SIZE)",
      "274:         return 0;",
      "275:     return 1;",
      "276: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "586: }",
      "590:     zl = zrealloc(zl,len);",
      "591:     ZIPLIST_BYTES(zl) = intrev32ifbe(len);",
      "592:     zl[len-1] = ZIP_END;",
      "",
      "[Removed Lines]",
      "589: unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {",
      "",
      "[Added Lines]",
      "600: unsigned char *ziplistResize(unsigned char *zl, size_t len) {",
      "601:     assert(len < UINT32_MAX);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "899:     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;",
      "902:     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));",
      "903:     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "914:     assert(zlbytes < UINT32_MAX);",
      "",
      "---------------"
    ],
    "src/ziplist.h||src/ziplist.h": [
      "File: src/ziplist.h -> src/ziplist.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "49: unsigned int ziplistLen(unsigned char *zl);",
      "50: size_t ziplistBlobLen(unsigned char *zl);",
      "51: void ziplistRepr(unsigned char *zl);",
      "53: #ifdef REDIS_TEST",
      "54: int ziplistTest(int argc, char *argv[]);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "52: int ziplistSafeToAdd(unsigned char* zl, size_t add);",
      "",
      "---------------"
    ],
    "tests/support/util.tcl||tests/support/util.tcl": [
      "File: tests/support/util.tcl -> tests/support/util.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "110: # count current log lines in server's stdout",
      "111: proc count_log_lines {srv_idx} {",
      "113: }",
      "115: # verify pattern exists in server's sdtout after a certain line number",
      "",
      "[Removed Lines]",
      "112:     set _ [exec wc -l < [srv $srv_idx stdout]]",
      "",
      "[Added Lines]",
      "112:     set _ [string trim [exec wc -l < [srv $srv_idx stdout]]]",
      "113: }",
      "115: # returns the number of times a line with that pattern appears in a file",
      "116: proc count_message_lines {file pattern} {",
      "117:     set res 0",
      "118:     # exec fails when grep exists with status other than 0 (when the patter wasn't found)",
      "119:     catch {",
      "120:         set res [string trim [exec grep $pattern $file 2> /dev/null | wc -l]]",
      "121:     }",
      "122:     return $res",
      "123: }",
      "125: # returns the number of times a line with that pattern appears in the log",
      "126: proc count_log_message {srv_idx pattern} {",
      "127:     set stdout [srv $srv_idx stdout]",
      "128:     return [count_message_lines $stdout $pattern]",
      "",
      "---------------"
    ],
    "tests/unit/violations.tcl||tests/unit/violations.tcl": [
      "File: tests/unit/violations.tcl -> tests/unit/violations.tcl",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: # These tests consume massive amounts of memory, and are not",
      "2: # suitable to be executed as part of the normal test suite",
      "3: set ::str500 [string repeat x 500000000] ;# 500mb",
      "5: # Utility function to write big argument into redis client connection",
      "6: proc write_big_bulk {size} {",
      "7:     r write \"\\$$size\\r\\n\"",
      "8:     while {$size >= 500000000} {",
      "9:         r write $::str500",
      "10:         incr size -500000000",
      "11:     }",
      "12:     if {$size > 0} {",
      "13:         r write [string repeat x $size]",
      "14:     }",
      "15:     r write \"\\r\\n\"",
      "16: }",
      "18: # One XADD with one huge 5GB field",
      "19: # Expected to fail resulting in an empty stream",
      "20: start_server [list overrides [list save \"\"] ] {",
      "21:     test {XADD one huge field} {",
      "22:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "23:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "24:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
      "25:         r write \"\\$1\\r\\nA\\r\\n\"",
      "26:         write_big_bulk 5000000000 ;#5gb",
      "27:         r flush",
      "28:         catch {r read} err",
      "29:         assert_match {*too large*} $err",
      "30:         r xlen S1",
      "31:     } {0}",
      "32: }",
      "34: # One XADD with one huge (exactly nearly) 4GB field",
      "35: # This uncovers the overflow in lpEncodeGetType",
      "36: # Expected to fail resulting in an empty stream",
      "37: start_server [list overrides [list save \"\"] ] {",
      "38:     test {XADD one huge field - 1} {",
      "39:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "40:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "41:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
      "42:         r write \"\\$1\\r\\nA\\r\\n\"",
      "43:         write_big_bulk 4294967295 ;#4gb-1",
      "44:         r flush",
      "45:         catch {r read} err",
      "46:         assert_match {*too large*} $err",
      "47:         r xlen S1",
      "48:     } {0}",
      "49: }",
      "51: # Gradually add big stream fields using repeated XADD calls",
      "52: start_server [list overrides [list save \"\"] ] {",
      "53:     test {several XADD big fields} {",
      "54:         r config set stream-node-max-bytes 0",
      "55:         for {set j 0} {$j<10} {incr j} {",
      "56:             r xadd stream * 1 $::str500 2 $::str500",
      "57:         }",
      "58:         r ping",
      "59:         r xlen stream",
      "60:     } {10}",
      "61: }",
      "63: # Add over 4GB to a single stream listpack (one XADD command)",
      "64: # Expected to fail resulting in an empty stream",
      "65: start_server [list overrides [list save \"\"] ] {",
      "66:     test {single XADD big fields} {",
      "67:         r write \"*23\\r\\n\\$4\\r\\nXADD\\r\\n\\$1\\r\\nS\\r\\n\\$1\\r\\n*\\r\\n\"",
      "68:         for {set j 0} {$j<10} {incr j} {",
      "69:             r write \"\\$1\\r\\n$j\\r\\n\"",
      "70:             write_big_bulk 500000000 ;#500mb",
      "71:         }",
      "72:         r flush",
      "73:         catch {r read} err",
      "74:         assert_match {*too large*} $err",
      "75:         r xlen S",
      "76:     } {0}",
      "77: }",
      "79: # Gradually add big hash fields using repeated HSET calls",
      "80: # This reproduces the overflow in the call to ziplistResize",
      "81: # Object will be converted to hashtable encoding",
      "82: start_server [list overrides [list save \"\"] ] {",
      "83:     r config set hash-max-ziplist-value 1000000000 ;#1gb",
      "84:     test {hash with many big fields} {",
      "85:         for {set j 0} {$j<10} {incr j} {",
      "86:             r hset h $j $::str500",
      "87:         }",
      "88:         r object encoding h",
      "89:     } {hashtable}",
      "90: }",
      "92: # Add over 4GB to a single hash field (one HSET command)",
      "93: # Object will be converted to hashtable encoding",
      "94: start_server [list overrides [list save \"\"] ] {",
      "95:     test {hash with one huge field} {",
      "96:         catch {r config set hash-max-ziplist-value 10000000000} ;#10gb",
      "97:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "98:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "99:         r write \"*4\\r\\n\\$4\\r\\nHSET\\r\\n\\$2\\r\\nH1\\r\\n\"",
      "100:         r write \"\\$1\\r\\nA\\r\\n\"",
      "101:         write_big_bulk 5000000000 ;#5gb",
      "102:         r flush",
      "103:         r read",
      "104:         r object encoding H1",
      "105:     } {hashtable}",
      "106: }",
      "108: # Add over 4GB to a single list member (one LPUSH command)",
      "109: # Currently unsupported, and expected to fail rather than being truncated",
      "110: # Expected to fail resulting in a non-existing list",
      "111: start_server [list overrides [list save \"\"] ] {",
      "112:     test {list with one huge field} {",
      "113:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "114:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "115:         r write \"*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$2\\r\\nL1\\r\\n\"",
      "116:         write_big_bulk 5000000000 ;#5gb",
      "117:         r flush",
      "118:         catch {r read} err",
      "119:         assert_match {*too large*} $err",
      "120:         r exists L1",
      "121:     } {0}",
      "122: }",
      "124: # SORT which attempts to store an element larger than 4GB into a list.",
      "125: # Currently unsupported and results in an assertion instead of truncation",
      "126: start_server [list overrides [list save \"\"] ] {",
      "127:     test {SORT adds huge field to list} {",
      "128:         r config set proto-max-bulk-len 10000000000 ;#10gb",
      "129:         r config set client-query-buffer-limit 10000000000 ;#10gb",
      "130:         r write \"*3\\r\\n\\$3\\r\\nSET\\r\\n\\$2\\r\\nS1\\r\\n\"",
      "131:         write_big_bulk 5000000000 ;#5gb",
      "132:         r flush",
      "133:         r read",
      "134:         assert_equal [r strlen S1] 5000000000",
      "135:         r set S2 asdf",
      "136:         r sadd myset 1 2",
      "137:         r mset D1 1 D2 2",
      "138:         catch {r sort myset by D* get S* store mylist}",
      "139:         # assert_equal [count_log_message 0 \"crashed by signal\"] 0   - not suitable for 6.0",
      "140:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
      "141:     }",
      "142: }",
      "144: # SORT which stores an integer encoded element into a list.",
      "145: # Just for coverage, no news here.",
      "146: start_server [list overrides [list save \"\"] ] {",
      "147:     test {SORT adds integer field to list} {",
      "148:         r set S1 asdf",
      "149:         r set S2 123 ;# integer encoded",
      "150:         assert_encoding \"int\" S2",
      "151:         r sadd myset 1 2",
      "152:         r mset D1 1 D2 2",
      "153:         r sort myset by D* get S* store mylist",
      "154:         r llen mylist",
      "155:     } {2}",
      "156: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
      "candidate_info": {
        "commit_hash": "5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/5a82df05aa07cbc99213c5c0128276f6e12c8d3a",
        "files": [
          "src/rio.c"
        ],
        "message": "more strict check in rioConnRead (#7564)\n\n(cherry picked from commit da840e9851bab8d1674e245a812b2105be111208)",
        "before_after_code_files": [
          "src/rio.c||src/rio.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/rio.c||src/rio.c": [
          "File: src/rio.c -> src/rio.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "205:                 toread = r->io.conn.read_limit - r->io.conn.read_so_far - buffered;",
          "206:             else {",
          "207:                 errno = EOVERFLOW;",
          "",
          "[Removed Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + needs)",
          "",
          "[Added Lines]",
          "204:             if (r->io.conn.read_limit >= r->io.conn.read_so_far + len)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "aabe95125d2cc5d315da575e64bebc8680607fc1",
      "candidate_info": {
        "commit_hash": "aabe95125d2cc5d315da575e64bebc8680607fc1",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/aabe95125d2cc5d315da575e64bebc8680607fc1",
        "files": [
          "src/ae_kqueue.c"
        ],
        "message": "Fix the timing of read and write events under kqueue (#9416)\n\nNormally we execute the read event first and then the write event.\nWhen the barrier is set, we will do it reverse.\nHowever, under `kqueue`, if an `fd` has both read and write events,\nreading the event using `kevent` will generate two events, which will\nresult in uncontrolled read and write timing.\n\nThis also means that the guarantees of AOF `appendfsync` = `always` are\nnot met on MacOS without this fix.\n\nThe main change to this pr is to cache the events already obtained when reading\nthem, so that if the same `fd` occurs again, only the mask in the cache is updated,\nrather than a new event is generated.\n\nThis was exposed by the following test failure on MacOS:\n```\n*** [err]: AOF fsync always barrier issue in tests/integration/aof.tcl\nExpected 544 != 544 (context: type eval line 26 cmd {assert {$size1 != $size2}} proc ::test)\n```\n\n(cherry picked from commit 306a5ccd2d053ff653988b61a779e3cbce408874)",
        "before_after_code_files": [
          "src/ae_kqueue.c||src/ae_kqueue.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/redis/redis/pull/9584"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/ae_kqueue.c||src/ae_kqueue.c": [
          "File: src/ae_kqueue.c -> src/ae_kqueue.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: typedef struct aeApiState {",
          "37:     int kqfd;",
          "38:     struct kevent *events;",
          "39: } aeApiState;",
          "41: static int aeApiCreate(aeEventLoop *eventLoop) {",
          "42:     aeApiState *state = zmalloc(sizeof(aeApiState));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "43:     char *eventsMask;",
          "46: #define EVENT_MASK_MALLOC_SIZE(sz) (((sz) + 3) / 4)",
          "47: #define EVENT_MASK_OFFSET(fd) ((fd) % 4 * 2)",
          "48: #define EVENT_MASK_ENCODE(fd, mask) (((mask) & 0x3) << EVENT_MASK_OFFSET(fd))",
          "50: static inline int getEventMask(const char *eventsMask, int fd) {",
          "51:     return (eventsMask[fd/4] >> EVENT_MASK_OFFSET(fd)) & 0x3;",
          "52: }",
          "54: static inline void addEventMask(char *eventsMask, int fd, int mask) {",
          "55:     eventsMask[fd/4] |= EVENT_MASK_ENCODE(fd, mask);",
          "56: }",
          "58: static inline void resetEventMask(char *eventsMask, int fd) {",
          "59:     eventsMask[fd/4] &= ~EVENT_MASK_ENCODE(fd, 0x3);",
          "60: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "53:         zfree(state);",
          "54:         return -1;",
          "55:     }",
          "56:     eventLoop->apidata = state;",
          "57:     return 0;",
          "58: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "77:     state->eventsMask = zmalloc(EVENT_MASK_MALLOC_SIZE(eventLoop->setsize));",
          "78:     memset(state->eventsMask, 0, EVENT_MASK_MALLOC_SIZE(eventLoop->setsize));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "61:     aeApiState *state = eventLoop->apidata;",
          "63:     state->events = zrealloc(state->events, sizeof(struct kevent)*setsize);",
          "64:     return 0;",
          "65: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "87:     state->eventsMask = zrealloc(state->eventsMask, EVENT_MASK_MALLOC_SIZE(setsize));",
          "88:     memset(state->eventsMask, 0, EVENT_MASK_MALLOC_SIZE(setsize));",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:     close(state->kqfd);",
          "71:     zfree(state->events);",
          "72:     zfree(state);",
          "73: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97:     zfree(state->eventsMask);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "119:     if (retval > 0) {",
          "120:         int j;",
          "125:             struct kevent *e = state->events+j;",
          "131:         }",
          "132:     }",
          "133:     return numevents;",
          "",
          "[Removed Lines]",
          "122:         numevents = retval;",
          "123:         for(j = 0; j < numevents; j++) {",
          "124:             int mask = 0;",
          "127:             if (e->filter == EVFILT_READ) mask |= AE_READABLE;",
          "128:             if (e->filter == EVFILT_WRITE) mask |= AE_WRITABLE;",
          "129:             eventLoop->fired[j].fd = e->ident;",
          "130:             eventLoop->fired[j].mask = mask;",
          "",
          "[Added Lines]",
          "155:         for (j = 0; j < retval; j++) {",
          "157:             int fd = e->ident;",
          "158:             int mask = 0;",
          "160:             if (e->filter == EVFILT_READ) mask = AE_READABLE;",
          "161:             else if (e->filter == EVFILT_WRITE) mask = AE_WRITABLE;",
          "162:             addEventMask(state->eventsMask, fd, mask);",
          "163:         }",
          "167:         numevents = 0;",
          "168:         for (j = 0; j < retval; j++) {",
          "169:             struct kevent *e = state->events+j;",
          "170:             int fd = e->ident;",
          "171:             int mask = getEventMask(state->eventsMask, fd);",
          "173:             if (mask) {",
          "174:                 eventLoop->fired[numevents].fd = fd;",
          "175:                 eventLoop->fired[numevents].mask = mask;",
          "176:                 resetEventMask(state->eventsMask, fd);",
          "177:                 numevents++;",
          "178:             }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6facfb7a103b26b9a602253a738b2130afb7c5d3",
      "candidate_info": {
        "commit_hash": "6facfb7a103b26b9a602253a738b2130afb7c5d3",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/6facfb7a103b26b9a602253a738b2130afb7c5d3",
        "files": [
          "src/geo.c",
          "src/listpack.c",
          "src/quicklist.c",
          "src/rdb.c",
          "src/server.h",
          "src/t_hash.c",
          "src/t_list.c",
          "src/t_stream.c",
          "src/t_zset.c",
          "src/ziplist.c",
          "src/ziplist.h",
          "tests/support/util.tcl",
          "tests/unit/violations.tcl"
        ],
        "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.\n\n(cherry picked from commit 68e221a3f98a427805d31c1760b4cdf37ba810ab)",
        "before_after_code_files": [
          "src/geo.c||src/geo.c",
          "src/listpack.c||src/listpack.c",
          "src/quicklist.c||src/quicklist.c",
          "src/rdb.c||src/rdb.c",
          "src/server.h||src/server.h",
          "src/t_hash.c||src/t_hash.c",
          "src/t_list.c||src/t_list.c",
          "src/t_stream.c||src/t_stream.c",
          "src/t_zset.c||src/t_zset.c",
          "src/ziplist.c||src/ziplist.c",
          "src/ziplist.h||src/ziplist.h",
          "tests/support/util.tcl||tests/support/util.tcl",
          "tests/unit/violations.tcl||tests/unit/violations.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/geo.c||src/geo.c",
            "src/listpack.c||src/listpack.c",
            "src/quicklist.c||src/quicklist.c",
            "src/rdb.c||src/rdb.c",
            "src/server.h||src/server.h",
            "src/t_hash.c||src/t_hash.c",
            "src/t_list.c||src/t_list.c",
            "src/t_stream.c||src/t_stream.c",
            "src/t_zset.c||src/t_zset.c",
            "src/ziplist.c||src/ziplist.c",
            "src/ziplist.h||src/ziplist.h",
            "tests/support/util.tcl||tests/support/util.tcl",
            "tests/unit/violations.tcl||tests/unit/violations.tcl"
          ],
          "candidate": [
            "src/geo.c||src/geo.c",
            "src/listpack.c||src/listpack.c",
            "src/quicklist.c||src/quicklist.c",
            "src/rdb.c||src/rdb.c",
            "src/server.h||src/server.h",
            "src/t_hash.c||src/t_hash.c",
            "src/t_list.c||src/t_list.c",
            "src/t_stream.c||src/t_stream.c",
            "src/t_zset.c||src/t_zset.c",
            "src/ziplist.c||src/ziplist.c",
            "src/ziplist.h||src/ziplist.h",
            "tests/support/util.tcl||tests/support/util.tcl",
            "tests/unit/violations.tcl||tests/unit/violations.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/geo.c||src/geo.c": [
          "File: src/geo.c -> src/geo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "635:         robj *zobj;",
          "636:         zset *zs;",
          "637:         int i;",
          "640:         if (returned_items) {",
          "641:             zobj = createZsetObject();",
          "",
          "[Removed Lines]",
          "638:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "638:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "650:             size_t elelen = sdslen(gp->member);",
          "652:             if (maxelelen < elelen) maxelelen = elelen;",
          "653:             znode = zslInsert(zs->zsl,score,gp->member);",
          "654:             serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);",
          "655:             gp->member = NULL;",
          "656:         }",
          "658:         if (returned_items) {",
          "660:             setKey(c->db,storekey,zobj);",
          "661:             decrRefCount(zobj);",
          "662:             notifyKeyspaceEvent(NOTIFY_ZSET,\"georadiusstore\",storekey,",
          "",
          "[Removed Lines]",
          "659:             zsetConvertToZiplistIfNeeded(zobj,maxelelen);",
          "",
          "[Added Lines]",
          "653:             totelelen += elelen;",
          "660:             zsetConvertToZiplistIfNeeded(zobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/listpack.c||src/listpack.c": [
          "File: src/listpack.c -> src/listpack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "283:     } else {",
          "284:         if (size < 64) *enclen = 1+size;",
          "285:         else if (size < 4096) *enclen = 2+size;",
          "287:         return LP_ENCODING_STRING;",
          "288:     }",
          "289: }",
          "",
          "[Removed Lines]",
          "286:         else *enclen = 5+size;",
          "",
          "[Added Lines]",
          "286:         else *enclen = 5+(uint64_t)size;",
          "",
          "---------------"
        ],
        "src/quicklist.c||src/quicklist.c": [
          "File: src/quicklist.c -> src/quicklist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: #include \"quicklist.h\"",
          "33: #include \"zmalloc.h\"",
          "34: #include \"ziplist.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #include \"redisassert.h\"",
          "",
          "---------------"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1498:     } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {",
          "1500:         uint64_t zsetlen;",
          "1502:         zset *zs;",
          "1504:         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "",
          "[Removed Lines]",
          "1501:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "1501:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1527:             if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);",
          "1529:             znode = zslInsert(zs->zsl,score,sdsele);",
          "1530:             dictAdd(zs->dict,sdsele,&znode->score);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1528:             totelelen += sdslen(sdsele);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1534:         if (zsetLength(o) <= server.zset_max_ziplist_entries &&",
          "1537:     } else if (rdbtype == RDB_TYPE_HASH) {",
          "1538:         uint64_t len;",
          "1539:         int ret;",
          "",
          "[Removed Lines]",
          "1535:             maxelelen <= server.zset_max_ziplist_value)",
          "1536:                 zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1536:             maxelelen <= server.zset_max_ziplist_value &&",
          "1537:             ziplistSafeToAdd(NULL, totelelen))",
          "1538:         {",
          "1539:             zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "1540:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1557:             if ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,NULL))",
          "1558:                 == NULL) return NULL;",
          "1567:             if (sdslen(field) > server.hash_max_ziplist_value ||",
          "1569:             {",
          "1572:                 hashTypeConvert(o, OBJ_ENCODING_HT);",
          "1573:                 break;",
          "1574:             }",
          "1575:             sdsfree(field);",
          "1576:             sdsfree(value);",
          "1577:         }",
          "",
          "[Removed Lines]",
          "1561:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1562:                     sdslen(field), ZIPLIST_TAIL);",
          "1563:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1564:                     sdslen(value), ZIPLIST_TAIL);",
          "1568:                 sdslen(value) > server.hash_max_ziplist_value)",
          "1570:                 sdsfree(field);",
          "1571:                 sdsfree(value);",
          "",
          "[Added Lines]",
          "1566:                 sdslen(value) > server.hash_max_ziplist_value ||",
          "1567:                 !ziplistSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))",
          "1570:                 ret = dictAdd((dict*)o->ptr, field, value);",
          "1571:                 if (ret == DICT_ERR) {",
          "1572:                     rdbExitReportCorruptRDB(\"Duplicate hash fields detected\");",
          "1573:                 }",
          "1578:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1579:                     sdslen(field), ZIPLIST_TAIL);",
          "1580:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1581:                     sdslen(value), ZIPLIST_TAIL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1640:                     while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {",
          "1641:                         if (flen > maxlen) maxlen = flen;",
          "1642:                         if (vlen > maxlen) maxlen = vlen;",
          "1643:                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);",
          "1644:                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);",
          "1645:                     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1651:                         if (!ziplistSafeToAdd(zl, (size_t)flen + vlen)) {",
          "1652:                             rdbExitReportCorruptRDB(\"Hash zipmap too big (%u)\", flen);",
          "1653:                         }",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1702: unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",
          "1703: unsigned long zsetLength(const robj *zobj);",
          "1704: void zsetConvert(robj *zobj, int encoding);",
          "1706: int zsetScore(robj *zobj, sds member, double *score);",
          "1707: unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",
          "1708: int zsetAdd(robj *zobj, double score, sds ele, int *flags, double *newscore);",
          "",
          "[Removed Lines]",
          "1705: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);",
          "",
          "[Added Lines]",
          "1705: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",
          "",
          "---------------"
        ],
        "src/t_hash.c||src/t_hash.c": [
          "File: src/t_hash.c -> src/t_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {",
          "41:     int i;",
          "43:     if (o->encoding != OBJ_ENCODING_ZIPLIST) return;",
          "45:     for (i = start; i <= end; i++) {",
          "49:             hashTypeConvert(o, OBJ_ENCODING_HT);",
          "51:         }",
          "52:     }",
          "53: }",
          "",
          "[Removed Lines]",
          "46:         if (sdsEncodedObject(argv[i]) &&",
          "47:             sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)",
          "48:         {",
          "50:             break;",
          "",
          "[Added Lines]",
          "42:     size_t sum = 0;",
          "47:         if (!sdsEncodedObject(argv[i]))",
          "48:             continue;",
          "49:         size_t len = sdslen(argv[i]->ptr);",
          "50:         if (len > server.hash_max_ziplist_value) {",
          "52:             return;",
          "54:         sum += len;",
          "56:     if (!ziplistSafeToAdd(o->ptr, sum))",
          "57:         hashTypeConvert(o, OBJ_ENCODING_HT);",
          "",
          "---------------"
        ],
        "src/t_list.c||src/t_list.c": [
          "File: src/t_list.c -> src/t_list.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"server.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "197: void pushGenericCommand(client *c, int where) {",
          "198:     int j, pushed = 0;",
          "199:     robj *lobj = lookupKeyWrite(c->db,c->argv[1]);",
          "201:     if (lobj && lobj->type != OBJ_LIST) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "202:     for (j = 2; j < c->argc; j++) {",
          "203:         if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "204:             addReplyError(c, \"Element too large\");",
          "205:             return;",
          "206:         }",
          "207:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "277:         return;",
          "278:     }",
          "280:     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||",
          "281:         checkType(c,subject,OBJ_LIST)) return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:     if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "291:         addReplyError(c, \"Element too large\");",
          "292:         return;",
          "293:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "344:     long index;",
          "345:     robj *value = c->argv[3];",
          "347:     if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))",
          "348:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "362:     if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {",
          "363:         addReplyError(c, \"Element too large\");",
          "364:         return;",
          "365:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "493:     long toremove;",
          "494:     long removed = 0;",
          "496:     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))",
          "497:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "516:     if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {",
          "517:         addReplyError(c, \"Element too large\");",
          "518:         return;",
          "519:     }",
          "",
          "---------------"
        ],
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: void streamFreeCG(streamCG *cg);",
          "44: void streamFreeNACK(streamNACK *na);",
          "45: size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "47: #define STREAM_LISTPACK_MAX_SIZE (1<<30)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:     raxIterator ri;",
          "",
          "[Removed Lines]",
          "209:     if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;",
          "",
          "[Added Lines]",
          "218:     if (streamCompareID(&id,&s->last_id) <= 0) {",
          "219:         errno = EDOM;",
          "220:         return C_ERR;",
          "221:     }",
          "226:     size_t totelelen = 0;",
          "227:     for (int64_t i = 0; i < numfields*2; i++) {",
          "228:         sds ele = argv[i]->ptr;",
          "229:         totelelen += sdslen(ele);",
          "230:     }",
          "231:     if (totelelen > STREAM_LISTPACK_MAX_SIZE) {",
          "232:         errno = ERANGE;",
          "233:         return C_ERR;",
          "234:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "267:     if (lp != NULL) {",
          "271:             lp = NULL;",
          "272:         } else if (server.stream_node_max_entries) {",
          "273:             int64_t count = lpGetInteger(lpFirst(lp));",
          "",
          "[Removed Lines]",
          "268:         if (server.stream_node_max_bytes &&",
          "269:             lp_bytes >= server.stream_node_max_bytes)",
          "270:         {",
          "",
          "[Added Lines]",
          "293:         size_t node_max_bytes = server.stream_node_max_bytes;",
          "294:         if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)",
          "295:             node_max_bytes = STREAM_LISTPACK_MAX_SIZE;",
          "296:         if (lp_bytes + totelelen >= node_max_bytes) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1285:     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,",
          "1288:     {",
          "1291:         return;",
          "1292:     }",
          "1293:     addReplyStreamID(c,&id);",
          "",
          "[Removed Lines]",
          "1286:         &id, id_given ? &id : NULL)",
          "1287:         == C_ERR)",
          "1289:         addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"",
          "1290:                         \"target stream top item\");",
          "",
          "[Added Lines]",
          "1312:         &id, id_given ? &id : NULL) == C_ERR)",
          "1314:         if (errno == EDOM)",
          "1315:             addReplyError(c,\"The ID specified in XADD is equal or smaller than \"",
          "1316:                             \"the target stream top item\");",
          "1317:         else",
          "1318:             addReplyError(c,\"Elements are too large to be stored\");",
          "",
          "---------------"
        ],
        "src/t_zset.c||src/t_zset.c": [
          "File: src/t_zset.c -> src/t_zset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1237: }",
          "1243:     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;",
          "1244:     zset *zset = zobj->ptr;",
          "1246:     if (zset->zsl->length <= server.zset_max_ziplist_entries &&",
          "1249: }",
          "",
          "[Removed Lines]",
          "1242: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {",
          "1247:         maxelelen <= server.zset_max_ziplist_value)",
          "1248:             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1242: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {",
          "1247:         maxelelen <= server.zset_max_ziplist_value &&",
          "1248:         ziplistSafeToAdd(NULL, totelelen))",
          "1249:     {",
          "1250:         zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "1251:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1354:             }",
          "1355:             return 1;",
          "1356:         } else if (!xx) {",
          "1362:                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);",
          "1366:         } else {",
          "1368:             return 1;",
          "1369:         }",
          "1371:         zset *zs = zobj->ptr;",
          "1372:         zskiplistNode *znode;",
          "1373:         dictEntry *de;",
          "",
          "[Removed Lines]",
          "1359:             zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1360:             if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||",
          "1361:                 sdslen(ele) > server.zset_max_ziplist_value)",
          "1363:             if (newscore) *newscore = score;",
          "1365:             return 1;",
          "1370:     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "[Added Lines]",
          "1362:             if (zzlLength(zobj->ptr)+1 > server.zset_max_ziplist_entries ||",
          "1363:                 sdslen(ele) > server.zset_max_ziplist_value ||",
          "1364:                 !ziplistSafeToAdd(zobj->ptr, sdslen(ele)))",
          "1365:             {",
          "1367:             } else {",
          "1368:                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1369:                 if (newscore) *newscore = score;",
          "1371:                 return 1;",
          "1372:             }",
          "1377:     }",
          "1381:     if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2179:     zsetopsrc *src;",
          "2180:     zsetopval zval;",
          "2181:     sds tmp;",
          "2183:     robj *dstobj;",
          "2184:     zset *dstzset;",
          "2185:     zskiplistNode *znode;",
          "",
          "[Removed Lines]",
          "2182:     size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "2193:     size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2303:                     tmp = zuiNewSdsFromValue(&zval);",
          "2304:                     znode = zslInsert(dstzset->zsl,score,tmp);",
          "2305:                     dictAdd(dstzset->dict,tmp,&znode->score);",
          "2306:                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2307:                 }",
          "2308:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2317:                     totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2342:                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2344:                     dictSetKey(accumulator, de, tmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2354:                      totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2379:     if (dbDelete(c->db,dstkey))",
          "2380:         touched = 1;",
          "2381:     if (dstzset->zsl->length) {",
          "2383:         dbAdd(c->db,dstkey,dstobj);",
          "2384:         addReplyLongLong(c,zsetLength(dstobj));",
          "2385:         signalModifiedKey(c->db,dstkey);",
          "",
          "[Removed Lines]",
          "2382:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen);",
          "",
          "[Added Lines]",
          "2395:         zsetConvertToZiplistIfNeeded(dstobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/ziplist.c||src/ziplist.c": [
          "File: src/ziplist.c -> src/ziplist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\",
          "266: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "270: #define ZIPLIST_MAX_SAFETY_SIZE (1<<30)",
          "271: int ziplistSafeToAdd(unsigned char* zl, size_t add) {",
          "272:     size_t len = zl? ziplistBlobLen(zl): 0;",
          "273:     if (len + add > ZIPLIST_MAX_SAFETY_SIZE)",
          "274:         return 0;",
          "275:     return 1;",
          "276: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "586: }",
          "590:     zl = zrealloc(zl,len);",
          "591:     ZIPLIST_BYTES(zl) = intrev32ifbe(len);",
          "592:     zl[len-1] = ZIP_END;",
          "",
          "[Removed Lines]",
          "589: unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {",
          "",
          "[Added Lines]",
          "600: unsigned char *ziplistResize(unsigned char *zl, size_t len) {",
          "601:     assert(len < UINT32_MAX);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "899:     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;",
          "902:     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));",
          "903:     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "914:     assert(zlbytes < UINT32_MAX);",
          "",
          "---------------"
        ],
        "src/ziplist.h||src/ziplist.h": [
          "File: src/ziplist.h -> src/ziplist.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: unsigned int ziplistLen(unsigned char *zl);",
          "50: size_t ziplistBlobLen(unsigned char *zl);",
          "51: void ziplistRepr(unsigned char *zl);",
          "53: #ifdef REDIS_TEST",
          "54: int ziplistTest(int argc, char *argv[]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "52: int ziplistSafeToAdd(unsigned char* zl, size_t add);",
          "",
          "---------------"
        ],
        "tests/support/util.tcl||tests/support/util.tcl": [
          "File: tests/support/util.tcl -> tests/support/util.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "99:     }",
          "100: }",
          "102: # Random integer between 0 and max (excluded).",
          "103: proc randomInt {max} {",
          "104:     expr {int(rand()*$max)}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "102: # count current log lines in server's stdout",
          "103: proc count_log_lines {srv_idx} {",
          "104:     set _ [string trim [exec wc -l < [srv $srv_idx stdout]]]",
          "105: }",
          "107: # returns the number of times a line with that pattern appears in a file",
          "108: proc count_message_lines {file pattern} {",
          "109:     set res 0",
          "110:     # exec fails when grep exists with status other than 0 (when the patter wasn't found)",
          "111:     catch {",
          "112:         set res [string trim [exec grep $pattern $file 2> /dev/null | wc -l]]",
          "113:     }",
          "114:     return $res",
          "115: }",
          "117: # returns the number of times a line with that pattern appears in the log",
          "118: proc count_log_message {srv_idx pattern} {",
          "119:     set stdout [srv $srv_idx stdout]",
          "120:     return [count_message_lines $stdout $pattern]",
          "121: }",
          "",
          "---------------"
        ],
        "tests/unit/violations.tcl||tests/unit/violations.tcl": [
          "File: tests/unit/violations.tcl -> tests/unit/violations.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # These tests consume massive amounts of memory, and are not",
          "2: # suitable to be executed as part of the normal test suite",
          "3: set ::str500 [string repeat x 500000000] ;# 500mb",
          "5: # Utility function to write big argument into redis client connection",
          "6: proc write_big_bulk {size} {",
          "7:     r write \"\\$$size\\r\\n\"",
          "8:     while {$size >= 500000000} {",
          "9:         r write $::str500",
          "10:         incr size -500000000",
          "11:     }",
          "12:     if {$size > 0} {",
          "13:         r write [string repeat x $size]",
          "14:     }",
          "15:     r write \"\\r\\n\"",
          "16: }",
          "18: # One XADD with one huge 5GB field",
          "19: # Expected to fail resulting in an empty stream",
          "20: start_server [list overrides [list save \"\"] ] {",
          "21:     test {XADD one huge field} {",
          "22:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "23:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "24:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "25:         r write \"\\$1\\r\\nA\\r\\n\"",
          "26:         write_big_bulk 5000000000 ;#5gb",
          "27:         r flush",
          "28:         catch {r read} err",
          "29:         assert_match {*too large*} $err",
          "30:         r xlen S1",
          "31:     } {0}",
          "32: }",
          "34: # One XADD with one huge (exactly nearly) 4GB field",
          "35: # This uncovers the overflow in lpEncodeGetType",
          "36: # Expected to fail resulting in an empty stream",
          "37: start_server [list overrides [list save \"\"] ] {",
          "38:     test {XADD one huge field - 1} {",
          "39:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "40:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "41:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "42:         r write \"\\$1\\r\\nA\\r\\n\"",
          "43:         write_big_bulk 4294967295 ;#4gb-1",
          "44:         r flush",
          "45:         catch {r read} err",
          "46:         assert_match {*too large*} $err",
          "47:         r xlen S1",
          "48:     } {0}",
          "49: }",
          "51: # Gradually add big stream fields using repeated XADD calls",
          "52: start_server [list overrides [list save \"\"] ] {",
          "53:     test {several XADD big fields} {",
          "54:         r config set stream-node-max-bytes 0",
          "55:         for {set j 0} {$j<10} {incr j} {",
          "56:             r xadd stream * 1 $::str500 2 $::str500",
          "57:         }",
          "58:         r ping",
          "59:         r xlen stream",
          "60:     } {10}",
          "61: }",
          "63: # Add over 4GB to a single stream listpack (one XADD command)",
          "64: # Expected to fail resulting in an empty stream",
          "65: start_server [list overrides [list save \"\"] ] {",
          "66:     test {single XADD big fields} {",
          "67:         r write \"*23\\r\\n\\$4\\r\\nXADD\\r\\n\\$1\\r\\nS\\r\\n\\$1\\r\\n*\\r\\n\"",
          "68:         for {set j 0} {$j<10} {incr j} {",
          "69:             r write \"\\$1\\r\\n$j\\r\\n\"",
          "70:             write_big_bulk 500000000 ;#500mb",
          "71:         }",
          "72:         r flush",
          "73:         catch {r read} err",
          "74:         assert_match {*too large*} $err",
          "75:         r xlen S",
          "76:     } {0}",
          "77: }",
          "79: # Gradually add big hash fields using repeated HSET calls",
          "80: # This reproduces the overflow in the call to ziplistResize",
          "81: # Object will be converted to hashtable encoding",
          "82: start_server [list overrides [list save \"\"] ] {",
          "83:     r config set hash-max-ziplist-value 1000000000 ;#1gb",
          "84:     test {hash with many big fields} {",
          "85:         for {set j 0} {$j<10} {incr j} {",
          "86:             r hset h $j $::str500",
          "87:         }",
          "88:         r object encoding h",
          "89:     } {hashtable}",
          "90: }",
          "92: # Add over 4GB to a single hash field (one HSET command)",
          "93: # Object will be converted to hashtable encoding",
          "94: start_server [list overrides [list save \"\"] ] {",
          "95:     test {hash with one huge field} {",
          "96:         catch {r config set hash-max-ziplist-value 10000000000} ;#10gb",
          "97:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "98:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "99:         r write \"*4\\r\\n\\$4\\r\\nHSET\\r\\n\\$2\\r\\nH1\\r\\n\"",
          "100:         r write \"\\$1\\r\\nA\\r\\n\"",
          "101:         write_big_bulk 5000000000 ;#5gb",
          "102:         r flush",
          "103:         r read",
          "104:         r object encoding H1",
          "105:     } {hashtable}",
          "106: }",
          "108: # Add over 4GB to a single list member (one LPUSH command)",
          "109: # Currently unsupported, and expected to fail rather than being truncated",
          "110: # Expected to fail resulting in a non-existing list",
          "111: start_server [list overrides [list save \"\"] ] {",
          "112:     test {list with one huge field} {",
          "113:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "114:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "115:         r write \"*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$2\\r\\nL1\\r\\n\"",
          "116:         write_big_bulk 5000000000 ;#5gb",
          "117:         r flush",
          "118:         catch {r read} err",
          "119:         assert_match {*too large*} $err",
          "120:         r exists L1",
          "121:     } {0}",
          "122: }",
          "124: # SORT which attempts to store an element larger than 4GB into a list.",
          "125: # Currently unsupported and results in an assertion instead of truncation",
          "126: start_server [list overrides [list save \"\"] ] {",
          "127:     test {SORT adds huge field to list} {",
          "128:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "129:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "130:         r write \"*3\\r\\n\\$3\\r\\nSET\\r\\n\\$2\\r\\nS1\\r\\n\"",
          "131:         write_big_bulk 5000000000 ;#5gb",
          "132:         r flush",
          "133:         r read",
          "134:         assert_equal [r strlen S1] 5000000000",
          "135:         r set S2 asdf",
          "136:         r sadd myset 1 2",
          "137:         r mset D1 1 D2 2",
          "138:         catch {r sort myset by D* get S* store mylist}",
          "139:         # assert_equal [count_log_message 0 \"crashed by signal\"] 0   - not suitable for 6.0",
          "140:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "141:     }",
          "142: }",
          "144: # SORT which stores an integer encoded element into a list.",
          "145: # Just for coverage, no news here.",
          "146: start_server [list overrides [list save \"\"] ] {",
          "147:     test {SORT adds integer field to list} {",
          "148:         r set S1 asdf",
          "149:         r set S2 123 ;# integer encoded",
          "150:         assert_encoding \"int\" S2",
          "151:         r sadd myset 1 2",
          "152:         r mset D1 1 D2 2",
          "153:         r sort myset by D* get S* store mylist",
          "154:         r llen mylist",
          "155:     } {2}",
          "156: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2775a3526e3e8bb040e72995231632c801977395",
      "candidate_info": {
        "commit_hash": "2775a3526e3e8bb040e72995231632c801977395",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/2775a3526e3e8bb040e72995231632c801977395",
        "files": [
          "src/geo.c",
          "src/listpack.c",
          "src/module.c",
          "src/quicklist.c",
          "src/rdb.c",
          "src/server.h",
          "src/t_hash.c",
          "src/t_list.c",
          "src/t_stream.c",
          "src/t_zset.c",
          "src/ziplist.c",
          "src/ziplist.h",
          "tests/unit/violations.tcl"
        ],
        "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.",
        "before_after_code_files": [
          "src/geo.c||src/geo.c",
          "src/listpack.c||src/listpack.c",
          "src/module.c||src/module.c",
          "src/quicklist.c||src/quicklist.c",
          "src/rdb.c||src/rdb.c",
          "src/server.h||src/server.h",
          "src/t_hash.c||src/t_hash.c",
          "src/t_list.c||src/t_list.c",
          "src/t_stream.c||src/t_stream.c",
          "src/t_zset.c||src/t_zset.c",
          "src/ziplist.c||src/ziplist.c",
          "src/ziplist.h||src/ziplist.h",
          "tests/unit/violations.tcl||tests/unit/violations.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/geo.c||src/geo.c",
            "src/listpack.c||src/listpack.c",
            "src/quicklist.c||src/quicklist.c",
            "src/rdb.c||src/rdb.c",
            "src/server.h||src/server.h",
            "src/t_hash.c||src/t_hash.c",
            "src/t_list.c||src/t_list.c",
            "src/t_stream.c||src/t_stream.c",
            "src/t_zset.c||src/t_zset.c",
            "src/ziplist.c||src/ziplist.c",
            "src/ziplist.h||src/ziplist.h",
            "tests/unit/violations.tcl||tests/unit/violations.tcl"
          ],
          "candidate": [
            "src/geo.c||src/geo.c",
            "src/listpack.c||src/listpack.c",
            "src/quicklist.c||src/quicklist.c",
            "src/rdb.c||src/rdb.c",
            "src/server.h||src/server.h",
            "src/t_hash.c||src/t_hash.c",
            "src/t_list.c||src/t_list.c",
            "src/t_stream.c||src/t_stream.c",
            "src/t_zset.c||src/t_zset.c",
            "src/ziplist.c||src/ziplist.c",
            "src/ziplist.h||src/ziplist.h",
            "tests/unit/violations.tcl||tests/unit/violations.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/geo.c||src/geo.c": [
          "File: src/geo.c -> src/geo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "770:         robj *zobj;",
          "771:         zset *zs;",
          "772:         int i;",
          "775:         if (returned_items) {",
          "776:             zobj = createZsetObject();",
          "",
          "[Removed Lines]",
          "773:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "773:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "785:             size_t elelen = sdslen(gp->member);",
          "787:             if (maxelelen < elelen) maxelelen = elelen;",
          "788:             znode = zslInsert(zs->zsl,score,gp->member);",
          "789:             serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);",
          "790:             gp->member = NULL;",
          "791:         }",
          "793:         if (returned_items) {",
          "795:             setKey(c,c->db,storekey,zobj);",
          "796:             decrRefCount(zobj);",
          "797:             notifyKeyspaceEvent(NOTIFY_ZSET,flags & GEOSEARCH ? \"geosearchstore\" : \"georadiusstore\",storekey,",
          "",
          "[Removed Lines]",
          "794:             zsetConvertToZiplistIfNeeded(zobj,maxelelen);",
          "",
          "[Added Lines]",
          "788:             totelelen += elelen;",
          "795:             zsetConvertToZiplistIfNeeded(zobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/listpack.c||src/listpack.c": [
          "File: src/listpack.c -> src/listpack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:     } else {",
          "314:         if (size < 64) *enclen = 1+size;",
          "315:         else if (size < 4096) *enclen = 2+size;",
          "317:         return LP_ENCODING_STRING;",
          "318:     }",
          "319: }",
          "",
          "[Removed Lines]",
          "316:         else *enclen = 5+size;",
          "",
          "[Added Lines]",
          "316:         else *enclen = 5+(uint64_t)size;",
          "",
          "---------------"
        ],
        "src/module.c||src/module.c": [
          "File: src/module.c -> src/module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3362:         use_id_ptr = &use_id;",
          "3363:     }",
          "3364:     if (streamAppendItem(s, argv, numfields, &added_id, use_id_ptr) == C_ERR) {",
          "3367:         return REDISMODULE_ERR;",
          "3368:     }",
          "",
          "[Removed Lines]",
          "3366:         errno = EDOM;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/quicklist.c||src/quicklist.c": [
          "File: src/quicklist.c -> src/quicklist.c"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1625:     } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {",
          "1627:         uint64_t zsetlen;",
          "1629:         zset *zs;",
          "1631:         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "",
          "[Removed Lines]",
          "1628:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "1628:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1667:             if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);",
          "1669:             znode = zslInsert(zs->zsl,score,sdsele);",
          "1670:             if (dictAdd(zs->dict,sdsele,&znode->score) != DICT_OK) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1668:             totelelen += sdslen(sdsele);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1679:         if (zsetLength(o) <= server.zset_max_ziplist_entries &&",
          "1682:     } else if (rdbtype == RDB_TYPE_HASH) {",
          "1683:         uint64_t len;",
          "1684:         int ret;",
          "",
          "[Removed Lines]",
          "1680:             maxelelen <= server.zset_max_ziplist_value)",
          "1681:                 zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1681:             maxelelen <= server.zset_max_ziplist_value &&",
          "1682:             ziplistSafeToAdd(NULL, totelelen))",
          "1683:         {",
          "1684:             zsetConvert(o,OBJ_ENCODING_ZIPLIST);",
          "1685:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1731:                 }",
          "1732:             }",
          "1741:             if (sdslen(field) > server.hash_max_ziplist_value ||",
          "1743:             {",
          "1746:                 hashTypeConvert(o, OBJ_ENCODING_HT);",
          "1747:                 break;",
          "1748:             }",
          "1749:             sdsfree(field);",
          "1750:             sdsfree(value);",
          "1751:         }",
          "",
          "[Removed Lines]",
          "1735:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1736:                     sdslen(field), ZIPLIST_TAIL);",
          "1737:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1738:                     sdslen(value), ZIPLIST_TAIL);",
          "1742:                 sdslen(value) > server.hash_max_ziplist_value)",
          "1744:                 sdsfree(field);",
          "1745:                 sdsfree(value);",
          "",
          "[Added Lines]",
          "1740:                 sdslen(value) > server.hash_max_ziplist_value ||",
          "1741:                 !ziplistSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))",
          "1744:                 ret = dictAdd((dict*)o->ptr, field, value);",
          "1745:                 if (ret == DICT_ERR) {",
          "1746:                     rdbReportCorruptRDB(\"Duplicate hash fields detected\");",
          "1747:                     if (dupSearchDict) dictRelease(dupSearchDict);",
          "1748:                     sdsfree(value);",
          "1749:                     sdsfree(field);",
          "1750:                     decrRefCount(o);",
          "1751:                     return NULL;",
          "1752:                 }",
          "1757:             o->ptr = ziplistPush(o->ptr, (unsigned char*)field,",
          "1758:                     sdslen(field), ZIPLIST_TAIL);",
          "1759:             o->ptr = ziplistPush(o->ptr, (unsigned char*)value,",
          "1760:                     sdslen(value), ZIPLIST_TAIL);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1858:                     while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {",
          "1859:                         if (flen > maxlen) maxlen = flen;",
          "1860:                         if (vlen > maxlen) maxlen = vlen;",
          "1865:                         sds field = sdstrynewlen(fstr, flen);",
          "1867:                             rdbReportCorruptRDB(\"Hash zipmap with dup elements, or big length (%u)\", flen);",
          "1868:                             dictRelease(dupSearchDict);",
          "1869:                             sdsfree(field);",
          "",
          "[Removed Lines]",
          "1861:                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);",
          "1862:                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);",
          "1866:                         if (!field || dictAdd(dupSearchDict, field, NULL) != DICT_OK) {",
          "",
          "[Added Lines]",
          "1877:                         if (!field || dictAdd(dupSearchDict, field, NULL) != DICT_OK ||",
          "1878:                             !ziplistSafeToAdd(zl, (size_t)flen + vlen)) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1872:                             decrRefCount(o);",
          "1873:                             return NULL;",
          "1874:                         }",
          "1875:                     }",
          "1877:                     dictRelease(dupSearchDict);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1888:                         zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);",
          "1889:                         zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2173: unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",
          "2174: unsigned long zsetLength(const robj *zobj);",
          "2175: void zsetConvert(robj *zobj, int encoding);",
          "2177: int zsetScore(robj *zobj, sds member, double *score);",
          "2178: unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",
          "2179: int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore);",
          "",
          "[Removed Lines]",
          "2176: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen);",
          "",
          "[Added Lines]",
          "2176: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",
          "",
          "---------------"
        ],
        "src/t_hash.c||src/t_hash.c": [
          "File: src/t_hash.c -> src/t_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {",
          "41:     int i;",
          "43:     if (o->encoding != OBJ_ENCODING_ZIPLIST) return;",
          "45:     for (i = start; i <= end; i++) {",
          "49:             hashTypeConvert(o, OBJ_ENCODING_HT);",
          "51:         }",
          "52:     }",
          "53: }",
          "",
          "[Removed Lines]",
          "46:         if (sdsEncodedObject(argv[i]) &&",
          "47:             sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)",
          "48:         {",
          "50:             break;",
          "",
          "[Added Lines]",
          "42:     size_t sum = 0;",
          "47:         if (!sdsEncodedObject(argv[i]))",
          "48:             continue;",
          "49:         size_t len = sdslen(argv[i]->ptr);",
          "50:         if (len > server.hash_max_ziplist_value) {",
          "52:             return;",
          "54:         sum += len;",
          "56:     if (!ziplistSafeToAdd(o->ptr, sum))",
          "57:         hashTypeConvert(o, OBJ_ENCODING_HT);",
          "",
          "---------------"
        ],
        "src/t_list.c||src/t_list.c": [
          "File: src/t_list.c -> src/t_list.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"server.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "224: void pushGenericCommand(client *c, int where, int xx) {",
          "225:     int j;",
          "227:     robj *lobj = lookupKeyWrite(c->db, c->argv[1]);",
          "228:     if (checkType(c,lobj,OBJ_LIST)) return;",
          "229:     if (!lobj) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "229:     for (j = 2; j < c->argc; j++) {",
          "230:         if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "231:             addReplyError(c, \"Element too large\");",
          "232:             return;",
          "233:         }",
          "234:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "287:         return;",
          "288:     }",
          "290:     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||",
          "291:         checkType(c,subject,OBJ_LIST)) return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "299:     if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "300:         addReplyError(c, \"Element too large\");",
          "301:         return;",
          "302:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "354:     long index;",
          "355:     robj *value = c->argv[3];",
          "357:     if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))",
          "358:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "371:     if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {",
          "372:         addReplyError(c, \"Element too large\");",
          "373:         return;",
          "374:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "576:     int direction = LIST_TAIL;",
          "580:     for (int j = 3; j < c->argc; j++) {",
          "581:         char *opt = c->argv[j]->ptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "598:     if (sdslen(ele->ptr) > LIST_MAX_ITEM_SIZE) {",
          "599:         addReplyError(c, \"Element too large\");",
          "600:         return;",
          "601:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "671:     long toremove;",
          "672:     long removed = 0;",
          "674:     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))",
          "675:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "698:     if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {",
          "699:         addReplyError(c, \"Element too large\");",
          "700:         return;",
          "701:     }",
          "",
          "---------------"
        ],
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #define STREAM_LISTPACK_MAX_PRE_ALLOCATE 4096",
          "50: void streamFreeCG(streamCG *cg);",
          "51: void streamFreeNACK(streamNACK *na);",
          "52: size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #define STREAM_LISTPACK_MAX_SIZE (1<<30)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "454:     raxIterator ri;",
          "",
          "[Removed Lines]",
          "451:     if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;",
          "",
          "[Added Lines]",
          "460:     if (streamCompareID(&id,&s->last_id) <= 0) {",
          "461:         errno = EDOM;",
          "462:         return C_ERR;",
          "463:     }",
          "468:     size_t totelelen = 0;",
          "469:     for (int64_t i = 0; i < numfields*2; i++) {",
          "470:         sds ele = argv[i]->ptr;",
          "471:         totelelen += sdslen(ele);",
          "472:     }",
          "473:     if (totelelen > STREAM_LISTPACK_MAX_SIZE) {",
          "474:         errno = ERANGE;",
          "475:         return C_ERR;",
          "476:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "509:     if (lp != NULL) {",
          "513:             lp = NULL;",
          "514:         } else if (server.stream_node_max_entries) {",
          "515:             unsigned char *lp_ele = lpFirst(lp);",
          "",
          "[Removed Lines]",
          "510:         if (server.stream_node_max_bytes &&",
          "511:             lp_bytes >= server.stream_node_max_bytes)",
          "512:         {",
          "",
          "[Added Lines]",
          "535:         size_t node_max_bytes = server.stream_node_max_bytes;",
          "536:         if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)",
          "537:             node_max_bytes = STREAM_LISTPACK_MAX_SIZE;",
          "538:         if (lp_bytes + totelelen >= node_max_bytes) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1797:     streamID id;",
          "1798:     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,",
          "1801:     {",
          "1804:         return;",
          "1805:     }",
          "1806:     addReplyStreamID(c,&id);",
          "",
          "[Removed Lines]",
          "1799:         &id, parsed_args.id_given ? &parsed_args.id : NULL)",
          "1800:         == C_ERR)",
          "1802:         addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"",
          "1803:                         \"target stream top item\");",
          "",
          "[Added Lines]",
          "1825:         &id, parsed_args.id_given ? &parsed_args.id : NULL) == C_ERR)",
          "1827:         if (errno == EDOM)",
          "1828:             addReplyError(c,\"The ID specified in XADD is equal or smaller than \"",
          "1829:                             \"the target stream top item\");",
          "1830:         else",
          "1831:             addReplyError(c,\"Elements are too large to be stored\");",
          "",
          "---------------"
        ],
        "src/t_zset.c||src/t_zset.c": [
          "File: src/t_zset.c -> src/t_zset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1242: }",
          "1248:     if (zobj->encoding == OBJ_ENCODING_ZIPLIST) return;",
          "1249:     zset *zset = zobj->ptr;",
          "1251:     if (zset->zsl->length <= server.zset_max_ziplist_entries &&",
          "1254: }",
          "",
          "[Removed Lines]",
          "1247: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen) {",
          "1252:         maxelelen <= server.zset_max_ziplist_value)",
          "1253:             zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "",
          "[Added Lines]",
          "1247: void zsetConvertToZiplistIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {",
          "1252:         maxelelen <= server.zset_max_ziplist_value &&",
          "1253:         ziplistSafeToAdd(NULL, totelelen))",
          "1254:     {",
          "1255:         zsetConvert(zobj,OBJ_ENCODING_ZIPLIST);",
          "1256:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1370:             }",
          "1371:             return 1;",
          "1372:         } else if (!xx) {",
          "1378:                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);",
          "1382:         } else {",
          "1384:             return 1;",
          "1385:         }",
          "1387:         zset *zs = zobj->ptr;",
          "1388:         zskiplistNode *znode;",
          "1389:         dictEntry *de;",
          "",
          "[Removed Lines]",
          "1375:             zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1376:             if (zzlLength(zobj->ptr) > server.zset_max_ziplist_entries ||",
          "1377:                 sdslen(ele) > server.zset_max_ziplist_value)",
          "1379:             if (newscore) *newscore = score;",
          "1381:             return 1;",
          "1386:     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "[Added Lines]",
          "1378:             if (zzlLength(zobj->ptr)+1 > server.zset_max_ziplist_entries ||",
          "1379:                 sdslen(ele) > server.zset_max_ziplist_value ||",
          "1380:                 !ziplistSafeToAdd(zobj->ptr, sdslen(ele)))",
          "1381:             {",
          "1383:             } else {",
          "1384:                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1385:                 if (newscore) *newscore = score;",
          "1387:                 return 1;",
          "1388:             }",
          "1393:     }",
          "1397:     if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2361:     }",
          "2362: }",
          "2365:     dictIterator *di;",
          "2366:     dictEntry *de;",
          "2367:     size_t maxelelen = 0;",
          "",
          "[Removed Lines]",
          "2364: static int zsetDictGetMaxElementLength(dict *d) {",
          "",
          "[Added Lines]",
          "2375: static size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2371:     while((de = dictNext(di)) != NULL) {",
          "2372:         sds ele = dictGetKey(de);",
          "2373:         if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);",
          "2374:     }",
          "2376:     dictReleaseIterator(di);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2385:         if (totallen)",
          "2386:             (*totallen) += sdslen(ele);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2378:     return maxelelen;",
          "2379: }",
          "",
          "[Removed Lines]",
          "2381: static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {",
          "",
          "[Added Lines]",
          "2394: static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2426:             znode = zslInsert(dstzset->zsl,zval.score,tmp);",
          "2427:             dictAdd(dstzset->dict,tmp,&znode->score);",
          "2428:             if (sdslen(tmp) > *maxelelen) *maxelelen = sdslen(tmp);",
          "2429:         }",
          "2430:     }",
          "2431:     zuiClearIterator(&src[0]);",
          "2432: }",
          "",
          "[Removed Lines]",
          "2435: static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {",
          "",
          "[Added Lines]",
          "2442:             (*totelelen) += sdslen(tmp);",
          "2449: static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2523:     return (algo_one_work <= algo_two_work) ? 1 : 2;",
          "2524: }",
          "2528:     if (zuiLength(&src[0]) > 0) {",
          "2529:         int diff_algo = zsetChooseDiffAlgorithm(src, setnum);",
          "2530:         if (diff_algo == 1) {",
          "2532:         } else if (diff_algo == 2) {",
          "2534:         } else if (diff_algo != 0) {",
          "2535:             serverPanic(\"Unknown algorithm\");",
          "2536:         }",
          "",
          "[Removed Lines]",
          "2526: static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {",
          "2531:             zdiffAlgorithm1(src, setnum, dstzset, maxelelen);",
          "2533:             zdiffAlgorithm2(src, setnum, dstzset, maxelelen);",
          "",
          "[Added Lines]",
          "2540: static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {",
          "2545:             zdiffAlgorithm1(src, setnum, dstzset, maxelelen, totelelen);",
          "2547:             zdiffAlgorithm2(src, setnum, dstzset, maxelelen, totelelen);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2565:     zsetopsrc *src;",
          "2566:     zsetopval zval;",
          "2567:     sds tmp;",
          "2569:     robj *dstobj;",
          "2570:     zset *dstzset;",
          "2571:     zskiplistNode *znode;",
          "",
          "[Removed Lines]",
          "2568:     size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "2582:     size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2701:                     tmp = zuiNewSdsFromValue(&zval);",
          "2702:                     znode = zslInsert(dstzset->zsl,score,tmp);",
          "2703:                     dictAdd(dstzset->dict,tmp,&znode->score);",
          "2704:                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2705:                 }",
          "2706:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2718:                     totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2740:                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2742:                     dictSetKey(accumulator, de, tmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2755:                      totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2771:         dictReleaseIterator(di);",
          "2772:         dictRelease(accumulator);",
          "2773:     } else if (op == SET_OP_DIFF) {",
          "2775:     } else {",
          "2776:         serverPanic(\"Unknown operator\");",
          "2777:     }",
          "2779:     if (dstkey) {",
          "2780:         if (dstzset->zsl->length) {",
          "2782:             setKey(c, c->db, dstkey, dstobj);",
          "2783:             addReplyLongLong(c, zsetLength(dstobj));",
          "2784:             notifyKeyspaceEvent(NOTIFY_ZSET,",
          "",
          "[Removed Lines]",
          "2774:         zdiff(src, setnum, dstzset, &maxelelen);",
          "2781:             zsetConvertToZiplistIfNeeded(dstobj, maxelelen);",
          "",
          "[Added Lines]",
          "2790:         zdiff(src, setnum, dstzset, &maxelelen, &totelelen);",
          "2797:             zsetConvertToZiplistIfNeeded(dstobj, maxelelen, totelelen);",
          "",
          "---------------"
        ],
        "src/ziplist.c||src/ziplist.c": [
          "File: src/ziplist.c -> src/ziplist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "267:         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\",
          "268: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272: #define ZIPLIST_MAX_SAFETY_SIZE (1<<30)",
          "273: int ziplistSafeToAdd(unsigned char* zl, size_t add) {",
          "274:     size_t len = zl? ziplistBlobLen(zl): 0;",
          "275:     if (len + add > ZIPLIST_MAX_SAFETY_SIZE)",
          "276:         return 0;",
          "277:     return 1;",
          "278: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "709: }",
          "713:     zl = zrealloc(zl,len);",
          "714:     ZIPLIST_BYTES(zl) = intrev32ifbe(len);",
          "715:     zl[len-1] = ZIP_END;",
          "",
          "[Removed Lines]",
          "712: unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {",
          "",
          "[Added Lines]",
          "723: unsigned char *ziplistResize(unsigned char *zl, size_t len) {",
          "724:     assert(len < UINT32_MAX);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1071:     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;",
          "1074:     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));",
          "1075:     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1086:     assert(zlbytes < UINT32_MAX);",
          "",
          "---------------"
        ],
        "src/ziplist.h||src/ziplist.h": [
          "File: src/ziplist.h -> src/ziplist.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: void ziplistRandomPair(unsigned char *zl, unsigned long total_count, ziplistEntry *key, ziplistEntry *val);",
          "66: void ziplistRandomPairs(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals);",
          "67: unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals);",
          "69: #ifdef REDIS_TEST",
          "70: int ziplistTest(int argc, char *argv[], int accurate);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: int ziplistSafeToAdd(unsigned char* zl, size_t add);",
          "",
          "---------------"
        ],
        "tests/unit/violations.tcl||tests/unit/violations.tcl": [
          "File: tests/unit/violations.tcl -> tests/unit/violations.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # These tests consume massive amounts of memory, and are not",
          "2: # suitable to be executed as part of the normal test suite",
          "3: set ::str500 [string repeat x 500000000] ;# 500mb",
          "5: # Utility function to write big argument into redis client connection",
          "6: proc write_big_bulk {size} {",
          "7:     r write \"\\$$size\\r\\n\"",
          "8:     while {$size >= 500000000} {",
          "9:         r write $::str500",
          "10:         incr size -500000000",
          "11:     }",
          "12:     if {$size > 0} {",
          "13:         r write [string repeat x $size]",
          "14:     }",
          "15:     r write \"\\r\\n\"",
          "16: }",
          "18: # One XADD with one huge 5GB field",
          "19: # Expected to fail resulting in an empty stream",
          "20: start_server [list overrides [list save \"\"] ] {",
          "21:     test {XADD one huge field} {",
          "22:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "23:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "24:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "25:         r write \"\\$1\\r\\nA\\r\\n\"",
          "26:         write_big_bulk 5000000000 ;#5gb",
          "27:         r flush",
          "28:         catch {r read} err",
          "29:         assert_match {*too large*} $err",
          "30:         r xlen S1",
          "31:     } {0}",
          "32: }",
          "34: # One XADD with one huge (exactly nearly) 4GB field",
          "35: # This uncovers the overflow in lpEncodeGetType",
          "36: # Expected to fail resulting in an empty stream",
          "37: start_server [list overrides [list save \"\"] ] {",
          "38:     test {XADD one huge field - 1} {",
          "39:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "40:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "41:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "42:         r write \"\\$1\\r\\nA\\r\\n\"",
          "43:         write_big_bulk 4294967295 ;#4gb-1",
          "44:         r flush",
          "45:         catch {r read} err",
          "46:         assert_match {*too large*} $err",
          "47:         r xlen S1",
          "48:     } {0}",
          "49: }",
          "51: # Gradually add big stream fields using repeated XADD calls",
          "52: start_server [list overrides [list save \"\"] ] {",
          "53:     test {several XADD big fields} {",
          "54:         r config set stream-node-max-bytes 0",
          "55:         for {set j 0} {$j<10} {incr j} {",
          "56:             r xadd stream * 1 $::str500 2 $::str500",
          "57:         }",
          "58:         r ping",
          "59:         r xlen stream",
          "60:     } {10}",
          "61: }",
          "63: # Add over 4GB to a single stream listpack (one XADD command)",
          "64: # Expected to fail resulting in an empty stream",
          "65: start_server [list overrides [list save \"\"] ] {",
          "66:     test {single XADD big fields} {",
          "67:         r write \"*23\\r\\n\\$4\\r\\nXADD\\r\\n\\$1\\r\\nS\\r\\n\\$1\\r\\n*\\r\\n\"",
          "68:         for {set j 0} {$j<10} {incr j} {",
          "69:             r write \"\\$1\\r\\n$j\\r\\n\"",
          "70:             write_big_bulk 500000000 ;#500mb",
          "71:         }",
          "72:         r flush",
          "73:         catch {r read} err",
          "74:         assert_match {*too large*} $err",
          "75:         r xlen S",
          "76:     } {0}",
          "77: }",
          "79: # Gradually add big hash fields using repeated HSET calls",
          "80: # This reproduces the overflow in the call to ziplistResize",
          "81: # Object will be converted to hashtable encoding",
          "82: start_server [list overrides [list save \"\"] ] {",
          "83:     r config set hash-max-ziplist-value 1000000000 ;#1gb",
          "84:     test {hash with many big fields} {",
          "85:         for {set j 0} {$j<10} {incr j} {",
          "86:             r hset h $j $::str500",
          "87:         }",
          "88:         r object encoding h",
          "89:     } {hashtable}",
          "90: }",
          "92: # Add over 4GB to a single hash field (one HSET command)",
          "93: # Object will be converted to hashtable encoding",
          "94: start_server [list overrides [list save \"\"] ] {",
          "95:     test {hash with one huge field} {",
          "96:         catch {r config set hash-max-ziplist-value 10000000000} ;#10gb",
          "97:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "98:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "99:         r write \"*4\\r\\n\\$4\\r\\nHSET\\r\\n\\$2\\r\\nH1\\r\\n\"",
          "100:         r write \"\\$1\\r\\nA\\r\\n\"",
          "101:         write_big_bulk 5000000000 ;#5gb",
          "102:         r flush",
          "103:         r read",
          "104:         r object encoding H1",
          "105:     } {hashtable}",
          "106: }",
          "108: # Add over 4GB to a single list member (one LPUSH command)",
          "109: # Currently unsupported, and expected to fail rather than being truncated",
          "110: # Expected to fail resulting in a non-existing list",
          "111: start_server [list overrides [list save \"\"] ] {",
          "112:     test {list with one huge field} {",
          "113:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "114:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "115:         r write \"*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$2\\r\\nL1\\r\\n\"",
          "116:         write_big_bulk 5000000000 ;#5gb",
          "117:         r flush",
          "118:         catch {r read} err",
          "119:         assert_match {*too large*} $err",
          "120:         r exists L1",
          "121:     } {0}",
          "122: }",
          "124: # SORT which attempts to store an element larger than 4GB into a list.",
          "125: # Currently unsupported and results in an assertion instead of truncation",
          "126: start_server [list overrides [list save \"\"] ] {",
          "127:     test {SORT adds huge field to list} {",
          "128:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "129:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "130:         r write \"*3\\r\\n\\$3\\r\\nSET\\r\\n\\$2\\r\\nS1\\r\\n\"",
          "131:         write_big_bulk 5000000000 ;#5gb",
          "132:         r flush",
          "133:         r read",
          "134:         assert_equal [r strlen S1] 5000000000",
          "135:         r set S2 asdf",
          "136:         r sadd myset 1 2",
          "137:         r mset D1 1 D2 2",
          "138:         catch {r sort myset by D* get S* store mylist}",
          "139:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "140:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "141:     }",
          "142: }",
          "144: # SORT which stores an integer encoded element into a list.",
          "145: # Just for coverage, no news here.",
          "146: start_server [list overrides [list save \"\"] ] {",
          "147:     test {SORT adds integer field to list} {",
          "148:         r set S1 asdf",
          "149:         r set S2 123 ;# integer encoded",
          "150:         assert_encoding \"int\" S2",
          "151:         r sadd myset 1 2",
          "152:         r mset D1 1 D2 2",
          "153:         r sort myset by D* get S* store mylist",
          "154:         r llen mylist",
          "155:     } {2}",
          "156: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c5e6a6204c4cf57f85e7c83a9b4e99f1a7204fd2",
      "candidate_info": {
        "commit_hash": "c5e6a6204c4cf57f85e7c83a9b4e99f1a7204fd2",
        "repo": "redis/redis",
        "commit_url": "https://github.com/redis/redis/commit/c5e6a6204c4cf57f85e7c83a9b4e99f1a7204fd2",
        "files": [
          "src/geo.c",
          "src/listpack.c",
          "src/listpack.h",
          "src/module.c",
          "src/quicklist.c",
          "src/rdb.c",
          "src/server.h",
          "src/t_hash.c",
          "src/t_list.c",
          "src/t_stream.c",
          "src/t_zset.c",
          "src/ziplist.c",
          "src/ziplist.h",
          "tests/unit/violations.tcl"
        ],
        "message": "Fix ziplist and listpack overflows and truncations (CVE-2021-32627, CVE-2021-32628) (#9589)\n\n- fix possible heap corruption in ziplist and listpack resulting by trying to\n  allocate more than the maximum size of 4GB.\n- prevent ziplist (hash and zset) from reaching size of above 1GB, will be\n  converted to HT encoding, that's not a useful size.\n- prevent listpack (stream) from reaching size of above 1GB.\n- XADD will start a new listpack if the new record may cause the previous\n  listpack to grow over 1GB.\n- XADD will respond with an error if a single stream record is over 1GB\n- List type (ziplist in quicklist) was truncating strings that were over 4GB,\n  now it'll respond with an error.\n\nCo-authored-by: sundb <sundbcn@gmail.com>",
        "before_after_code_files": [
          "src/geo.c||src/geo.c",
          "src/listpack.c||src/listpack.c",
          "src/listpack.h||src/listpack.h",
          "src/module.c||src/module.c",
          "src/quicklist.c||src/quicklist.c",
          "src/rdb.c||src/rdb.c",
          "src/server.h||src/server.h",
          "src/t_hash.c||src/t_hash.c",
          "src/t_list.c||src/t_list.c",
          "src/t_stream.c||src/t_stream.c",
          "src/t_zset.c||src/t_zset.c",
          "src/ziplist.c||src/ziplist.c",
          "src/ziplist.h||src/ziplist.h",
          "tests/unit/violations.tcl||tests/unit/violations.tcl"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_olp_changes": 1,
        "olp_code_files": {
          "patch": [
            "src/geo.c||src/geo.c",
            "src/listpack.c||src/listpack.c",
            "src/quicklist.c||src/quicklist.c",
            "src/rdb.c||src/rdb.c",
            "src/server.h||src/server.h",
            "src/t_hash.c||src/t_hash.c",
            "src/t_list.c||src/t_list.c",
            "src/t_stream.c||src/t_stream.c",
            "src/t_zset.c||src/t_zset.c",
            "src/ziplist.c||src/ziplist.c",
            "src/ziplist.h||src/ziplist.h",
            "tests/unit/violations.tcl||tests/unit/violations.tcl"
          ],
          "candidate": [
            "src/geo.c||src/geo.c",
            "src/listpack.c||src/listpack.c",
            "src/quicklist.c||src/quicklist.c",
            "src/rdb.c||src/rdb.c",
            "src/server.h||src/server.h",
            "src/t_hash.c||src/t_hash.c",
            "src/t_list.c||src/t_list.c",
            "src/t_stream.c||src/t_stream.c",
            "src/t_zset.c||src/t_zset.c",
            "src/ziplist.c||src/ziplist.c",
            "src/ziplist.h||src/ziplist.h",
            "tests/unit/violations.tcl||tests/unit/violations.tcl"
          ]
        }
      },
      "candidate_diff": {
        "src/geo.c||src/geo.c": [
          "File: src/geo.c -> src/geo.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "797:         robj *zobj;",
          "798:         zset *zs;",
          "799:         int i;",
          "802:         if (returned_items) {",
          "803:             zobj = createZsetObject();",
          "",
          "[Removed Lines]",
          "800:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "800:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "812:             size_t elelen = sdslen(gp->member);",
          "814:             if (maxelelen < elelen) maxelelen = elelen;",
          "815:             znode = zslInsert(zs->zsl,score,gp->member);",
          "816:             serverAssert(dictAdd(zs->dict,gp->member,&znode->score) == DICT_OK);",
          "817:             gp->member = NULL;",
          "818:         }",
          "820:         if (returned_items) {",
          "822:             setKey(c,c->db,storekey,zobj);",
          "823:             decrRefCount(zobj);",
          "824:             notifyKeyspaceEvent(NOTIFY_ZSET,flags & GEOSEARCH ? \"geosearchstore\" : \"georadiusstore\",storekey,",
          "",
          "[Removed Lines]",
          "821:             zsetConvertToListpackIfNeeded(zobj,maxelelen);",
          "",
          "[Added Lines]",
          "815:             totelelen += elelen;",
          "822:             zsetConvertToListpackIfNeeded(zobj,maxelelen,totelelen);",
          "",
          "---------------"
        ],
        "src/listpack.c||src/listpack.c": [
          "File: src/listpack.c -> src/listpack.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "141: static inline void lpAssertValidEntry(unsigned char* lp, size_t lpbytes, unsigned char *p);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "145: #define LISTPACK_MAX_SAFETY_SIZE (1<<30)",
          "146: int lpSafeToAdd(unsigned char* lp, size_t add) {",
          "147:     size_t len = lp? lpGetTotalBytes(lp): 0;",
          "148:     if (len + add > LISTPACK_MAX_SAFETY_SIZE)",
          "149:         return 0;",
          "150:     return 1;",
          "151: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "324:     } else {",
          "325:         if (size < 64) *enclen = 1+size;",
          "326:         else if (size < 4096) *enclen = 2+size;",
          "328:         return LP_ENCODING_STRING;",
          "329:     }",
          "330: }",
          "",
          "[Removed Lines]",
          "327:         else *enclen = 5+size;",
          "",
          "[Added Lines]",
          "337:         else *enclen = 5+(uint64_t)size;",
          "",
          "---------------"
        ],
        "src/listpack.h||src/listpack.h": [
          "File: src/listpack.h -> src/listpack.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "87: void lpRandomPair(unsigned char *lp, unsigned long total_count, listpackEntry *key, listpackEntry *val);",
          "88: void lpRandomPairs(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals);",
          "89: unsigned int lpRandomPairsUnique(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals);",
          "91: #ifdef REDIS_TEST",
          "92: int listpackTest(int argc, char *argv[], int accurate);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "90: int lpSafeToAdd(unsigned char* lp, size_t add);",
          "",
          "---------------"
        ],
        "src/module.c||src/module.c": [
          "File: src/module.c -> src/module.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4107:         use_id_ptr = &use_id;",
          "4108:     }",
          "4109:     if (streamAppendItem(s, argv, numfields, &added_id, use_id_ptr) == C_ERR) {",
          "4112:         return REDISMODULE_ERR;",
          "4113:     }",
          "",
          "[Removed Lines]",
          "4111:         errno = EDOM;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/quicklist.c||src/quicklist.c": [
          "File: src/quicklist.c -> src/quicklist.c"
        ],
        "src/rdb.c||src/rdb.c": [
          "File: src/rdb.c -> src/rdb.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1753:     } else if (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) {",
          "1755:         uint64_t zsetlen;",
          "1757:         zset *zs;",
          "1759:         if ((zsetlen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;",
          "",
          "[Removed Lines]",
          "1756:         size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "1756:         size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1797:             if (sdslen(sdsele) > maxelelen) maxelelen = sdslen(sdsele);",
          "1799:             znode = zslInsert(zs->zsl,score,sdsele);",
          "1800:             if (dictAdd(zs->dict,sdsele,&znode->score) != DICT_OK) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1798:             totelelen += sdslen(sdsele);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1809:         if (zsetLength(o) <= server.zset_max_listpack_entries &&",
          "1812:     } else if (rdbtype == RDB_TYPE_HASH) {",
          "1813:         uint64_t len;",
          "1814:         int ret;",
          "",
          "[Removed Lines]",
          "1810:             maxelelen <= server.zset_max_listpack_value)",
          "1811:                 zsetConvert(o,OBJ_ENCODING_LISTPACK);",
          "",
          "[Added Lines]",
          "1811:             maxelelen <= server.zset_max_listpack_value &&",
          "1812:             lpSafeToAdd(NULL, totelelen))",
          "1813:         {",
          "1814:             zsetConvert(o,OBJ_ENCODING_LISTPACK);",
          "1815:         }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1862:                 }",
          "1863:             }",
          "1870:             if (sdslen(field) > server.hash_max_listpack_value ||",
          "1872:             {",
          "1875:                 hashTypeConvert(o, OBJ_ENCODING_HT);",
          "1876:                 break;",
          "1877:             }",
          "1878:             sdsfree(field);",
          "1879:             sdsfree(value);",
          "1880:         }",
          "",
          "[Removed Lines]",
          "1866:             o->ptr = lpAppend(o->ptr, (unsigned char*)field, sdslen(field));",
          "1867:             o->ptr = lpAppend(o->ptr, (unsigned char*)value, sdslen(value));",
          "1871:                 sdslen(value) > server.hash_max_listpack_value)",
          "1873:                 sdsfree(field);",
          "1874:                 sdsfree(value);",
          "",
          "[Added Lines]",
          "1871:                 sdslen(value) > server.hash_max_listpack_value ||",
          "1872:                 !lpSafeToAdd(o->ptr, sdslen(field)+sdslen(value)))",
          "1875:                 ret = dictAdd((dict*)o->ptr, field, value);",
          "1876:                 if (ret == DICT_ERR) {",
          "1877:                     rdbReportCorruptRDB(\"Duplicate hash fields detected\");",
          "1878:                     if (dupSearchDict) dictRelease(dupSearchDict);",
          "1879:                     sdsfree(value);",
          "1880:                     sdsfree(field);",
          "1881:                     decrRefCount(o);",
          "1882:                     return NULL;",
          "1883:                 }",
          "1888:             o->ptr = lpAppend(o->ptr, (unsigned char*)field, sdslen(field));",
          "1889:             o->ptr = lpAppend(o->ptr, (unsigned char*)value, sdslen(value));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1995:                 {",
          "1997:                     unsigned char *zi = zipmapRewind(o->ptr);",
          "1998:                     unsigned char *fstr, *vstr;",
          "1999:                     unsigned int flen, vlen;",
          "",
          "[Removed Lines]",
          "1996:                     unsigned char *zl = lpNew(0);",
          "",
          "[Added Lines]",
          "2009:                     unsigned char *lp = lpNew(0);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2003:                     while ((zi = zipmapNext(zi, &fstr, &flen, &vstr, &vlen)) != NULL) {",
          "2004:                         if (flen > maxlen) maxlen = flen;",
          "2005:                         if (vlen > maxlen) maxlen = vlen;",
          "2010:                         sds field = sdstrynewlen(fstr, flen);",
          "2012:                             rdbReportCorruptRDB(\"Hash zipmap with dup elements, or big length (%u)\", flen);",
          "2013:                             dictRelease(dupSearchDict);",
          "2014:                             sdsfree(field);",
          "",
          "[Removed Lines]",
          "2006:                         zl = lpAppend(zl, fstr, flen);",
          "2007:                         zl = lpAppend(zl, vstr, vlen);",
          "2011:                         if (!field || dictAdd(dupSearchDict, field, NULL) != DICT_OK) {",
          "",
          "[Added Lines]",
          "2022:                         if (!field || dictAdd(dupSearchDict, field, NULL) != DICT_OK ||",
          "2023:                             !lpSafeToAdd(lp, (size_t)flen + vlen)) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2017:                             decrRefCount(o);",
          "2018:                             return NULL;",
          "2019:                         }",
          "2020:                     }",
          "2022:                     dictRelease(dupSearchDict);",
          "2023:                     zfree(o->ptr);",
          "2025:                     o->type = OBJ_HASH;",
          "2026:                     o->encoding = OBJ_ENCODING_LISTPACK;",
          "",
          "[Removed Lines]",
          "2024:                     o->ptr = zl;",
          "",
          "[Added Lines]",
          "2033:                         lp = lpAppend(lp, fstr, flen);",
          "2034:                         lp = lpAppend(lp, vstr, vlen);",
          "2039:                     o->ptr = lp;",
          "",
          "---------------"
        ],
        "src/server.h||src/server.h": [
          "File: src/server.h -> src/server.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2384: unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",
          "2385: unsigned long zsetLength(const robj *zobj);",
          "2386: void zsetConvert(robj *zobj, int encoding);",
          "2388: int zsetScore(robj *zobj, sds member, double *score);",
          "2389: unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",
          "2390: int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore);",
          "",
          "[Removed Lines]",
          "2387: void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen);",
          "",
          "[Added Lines]",
          "2387: void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",
          "",
          "---------------"
        ],
        "src/t_hash.c||src/t_hash.c": [
          "File: src/t_hash.c -> src/t_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {",
          "41:     int i;",
          "43:     if (o->encoding != OBJ_ENCODING_LISTPACK) return;",
          "45:     for (i = start; i <= end; i++) {",
          "49:             hashTypeConvert(o, OBJ_ENCODING_HT);",
          "51:         }",
          "52:     }",
          "53: }",
          "",
          "[Removed Lines]",
          "46:         if (sdsEncodedObject(argv[i]) &&",
          "47:             sdslen(argv[i]->ptr) > server.hash_max_listpack_value)",
          "48:         {",
          "50:             break;",
          "",
          "[Added Lines]",
          "42:     size_t sum = 0;",
          "47:         if (!sdsEncodedObject(argv[i]))",
          "48:             continue;",
          "49:         size_t len = sdslen(argv[i]->ptr);",
          "50:         if (len > server.hash_max_listpack_value) {",
          "52:             return;",
          "54:         sum += len;",
          "56:     if (!lpSafeToAdd(o->ptr, sum))",
          "57:         hashTypeConvert(o, OBJ_ENCODING_HT);",
          "",
          "---------------"
        ],
        "src/t_list.c||src/t_list.c": [
          "File: src/t_list.c -> src/t_list.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"server.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "32: #define LIST_MAX_ITEM_SIZE ((1ull<<32)-1024)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "254: void pushGenericCommand(client *c, int where, int xx) {",
          "255:     int j;",
          "257:     robj *lobj = lookupKeyWrite(c->db, c->argv[1]);",
          "258:     if (checkType(c,lobj,OBJ_LIST)) return;",
          "259:     if (!lobj) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "259:     for (j = 2; j < c->argc; j++) {",
          "260:         if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "261:             addReplyError(c, \"Element too large\");",
          "262:             return;",
          "263:         }",
          "264:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "317:         return;",
          "318:     }",
          "320:     if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||",
          "321:         checkType(c,subject,OBJ_LIST)) return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329:     if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {",
          "330:         addReplyError(c, \"Element too large\");",
          "331:         return;",
          "332:     }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "384:     long index;",
          "385:     robj *value = c->argv[3];",
          "387:     if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))",
          "388:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "401:     if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {",
          "402:         addReplyError(c, \"Element too large\");",
          "403:         return;",
          "404:     }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "683:     int direction = LIST_TAIL;",
          "687:     for (int j = 3; j < c->argc; j++) {",
          "688:         char *opt = c->argv[j]->ptr;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "705:     if (sdslen(ele->ptr) > LIST_MAX_ITEM_SIZE) {",
          "706:         addReplyError(c, \"Element too large\");",
          "707:         return;",
          "708:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "778:     long toremove;",
          "779:     long removed = 0;",
          "781:     if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))",
          "782:         return;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "805:     if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {",
          "806:         addReplyError(c, \"Element too large\");",
          "807:         return;",
          "808:     }",
          "",
          "---------------"
        ],
        "src/t_stream.c||src/t_stream.c": [
          "File: src/t_stream.c -> src/t_stream.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "48: #define STREAM_LISTPACK_MAX_PRE_ALLOCATE 4096",
          "50: void streamFreeCG(streamCG *cg);",
          "51: void streamFreeNACK(streamNACK *na);",
          "52: size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "54: #define STREAM_LISTPACK_MAX_SIZE (1<<30)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "436:     raxIterator ri;",
          "",
          "[Removed Lines]",
          "433:     if (streamCompareID(&id,&s->last_id) <= 0) return C_ERR;",
          "",
          "[Added Lines]",
          "442:     if (streamCompareID(&id,&s->last_id) <= 0) {",
          "443:         errno = EDOM;",
          "444:         return C_ERR;",
          "445:     }",
          "450:     size_t totelelen = 0;",
          "451:     for (int64_t i = 0; i < numfields*2; i++) {",
          "452:         sds ele = argv[i]->ptr;",
          "453:         totelelen += sdslen(ele);",
          "454:     }",
          "455:     if (totelelen > STREAM_LISTPACK_MAX_SIZE) {",
          "456:         errno = ERANGE;",
          "457:         return C_ERR;",
          "458:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "491:     if (lp != NULL) {",
          "495:             lp = NULL;",
          "496:         } else if (server.stream_node_max_entries) {",
          "497:             unsigned char *lp_ele = lpFirst(lp);",
          "",
          "[Removed Lines]",
          "492:         if (server.stream_node_max_bytes &&",
          "493:             lp_bytes >= server.stream_node_max_bytes)",
          "494:         {",
          "",
          "[Added Lines]",
          "517:         size_t node_max_bytes = server.stream_node_max_bytes;",
          "518:         if (node_max_bytes == 0 || node_max_bytes > STREAM_LISTPACK_MAX_SIZE)",
          "519:             node_max_bytes = STREAM_LISTPACK_MAX_SIZE;",
          "520:         if (lp_bytes + totelelen >= node_max_bytes) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1783:     streamID id;",
          "1784:     if (streamAppendItem(s,c->argv+field_pos,(c->argc-field_pos)/2,",
          "1787:     {",
          "1790:         return;",
          "1791:     }",
          "1792:     addReplyStreamID(c,&id);",
          "",
          "[Removed Lines]",
          "1785:         &id, parsed_args.id_given ? &parsed_args.id : NULL)",
          "1786:         == C_ERR)",
          "1788:         addReplyError(c,\"The ID specified in XADD is equal or smaller than the \"",
          "1789:                         \"target stream top item\");",
          "",
          "[Added Lines]",
          "1811:         &id, parsed_args.id_given ? &parsed_args.id : NULL) == C_ERR)",
          "1813:         if (errno == EDOM)",
          "1814:             addReplyError(c,\"The ID specified in XADD is equal or smaller than \"",
          "1815:                             \"the target stream top item\");",
          "1816:         else",
          "1817:             addReplyError(c,\"Elements are too large to be stored\");",
          "",
          "---------------"
        ],
        "src/t_zset.c||src/t_zset.c": [
          "File: src/t_zset.c -> src/t_zset.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1227: }",
          "1233:     if (zobj->encoding == OBJ_ENCODING_LISTPACK) return;",
          "1234:     zset *zset = zobj->ptr;",
          "1236:     if (zset->zsl->length <= server.zset_max_listpack_entries &&",
          "1239: }",
          "",
          "[Removed Lines]",
          "1232: void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen) {",
          "1237:         maxelelen <= server.zset_max_listpack_value)",
          "1238:             zsetConvert(zobj,OBJ_ENCODING_LISTPACK);",
          "",
          "[Added Lines]",
          "1232: void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {",
          "1237:         maxelelen <= server.zset_max_listpack_value &&",
          "1238:         lpSafeToAdd(NULL, totelelen))",
          "1239:     {",
          "1240:         zsetConvert(zobj,OBJ_ENCODING_LISTPACK);",
          "1241:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1355:             }",
          "1356:             return 1;",
          "1357:         } else if (!xx) {",
          "1363:                 zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);",
          "1367:         } else {",
          "1369:             return 1;",
          "1370:         }",
          "1372:         zset *zs = zobj->ptr;",
          "1373:         zskiplistNode *znode;",
          "1374:         dictEntry *de;",
          "",
          "[Removed Lines]",
          "1360:             zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1361:             if (zzlLength(zobj->ptr) > server.zset_max_listpack_entries ||",
          "1362:                 sdslen(ele) > server.zset_max_listpack_value)",
          "1364:             if (newscore) *newscore = score;",
          "1366:             return 1;",
          "1371:     } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "[Added Lines]",
          "1363:             if (zzlLength(zobj->ptr)+1 > server.zset_max_listpack_entries ||",
          "1364:                 sdslen(ele) > server.zset_max_listpack_value ||",
          "1365:                 !lpSafeToAdd(zobj->ptr, sdslen(ele)))",
          "1366:             {",
          "1368:             } else {",
          "1369:                 zobj->ptr = zzlInsert(zobj->ptr,ele,score);",
          "1370:                 if (newscore) *newscore = score;",
          "1372:                 return 1;",
          "1373:             }",
          "1378:     }",
          "1382:     if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2304:     }",
          "2305: }",
          "2308:     dictIterator *di;",
          "2309:     dictEntry *de;",
          "2310:     size_t maxelelen = 0;",
          "",
          "[Removed Lines]",
          "2307: static int zsetDictGetMaxElementLength(dict *d) {",
          "",
          "[Added Lines]",
          "2318: static size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2314:     while((de = dictNext(di)) != NULL) {",
          "2315:         sds ele = dictGetKey(de);",
          "2316:         if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);",
          "2317:     }",
          "2319:     dictReleaseIterator(di);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2328:         if (totallen)",
          "2329:             (*totallen) += sdslen(ele);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "2321:     return maxelelen;",
          "2322: }",
          "",
          "[Removed Lines]",
          "2324: static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {",
          "",
          "[Added Lines]",
          "2337: static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "2369:             znode = zslInsert(dstzset->zsl,zval.score,tmp);",
          "2370:             dictAdd(dstzset->dict,tmp,&znode->score);",
          "2371:             if (sdslen(tmp) > *maxelelen) *maxelelen = sdslen(tmp);",
          "2372:         }",
          "2373:     }",
          "2374:     zuiClearIterator(&src[0]);",
          "2375: }",
          "",
          "[Removed Lines]",
          "2378: static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {",
          "",
          "[Added Lines]",
          "2385:             (*totelelen) += sdslen(tmp);",
          "2392: static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "2466:     return (algo_one_work <= algo_two_work) ? 1 : 2;",
          "2467: }",
          "2471:     if (zuiLength(&src[0]) > 0) {",
          "2472:         int diff_algo = zsetChooseDiffAlgorithm(src, setnum);",
          "2473:         if (diff_algo == 1) {",
          "2475:         } else if (diff_algo == 2) {",
          "2477:         } else if (diff_algo != 0) {",
          "2478:             serverPanic(\"Unknown algorithm\");",
          "2479:         }",
          "",
          "[Removed Lines]",
          "2469: static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen) {",
          "2474:             zdiffAlgorithm1(src, setnum, dstzset, maxelelen);",
          "2476:             zdiffAlgorithm2(src, setnum, dstzset, maxelelen);",
          "",
          "[Added Lines]",
          "2483: static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {",
          "2488:             zdiffAlgorithm1(src, setnum, dstzset, maxelelen, totelelen);",
          "2490:             zdiffAlgorithm2(src, setnum, dstzset, maxelelen, totelelen);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2510:     zsetopsrc *src;",
          "2511:     zsetopval zval;",
          "2512:     sds tmp;",
          "2514:     robj *dstobj;",
          "2515:     zset *dstzset;",
          "2516:     zskiplistNode *znode;",
          "",
          "[Removed Lines]",
          "2513:     size_t maxelelen = 0;",
          "",
          "[Added Lines]",
          "2527:     size_t maxelelen = 0, totelelen = 0;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2668:                     tmp = zuiNewSdsFromValue(&zval);",
          "2669:                     znode = zslInsert(dstzset->zsl,score,tmp);",
          "2670:                     dictAdd(dstzset->dict,tmp,&znode->score);",
          "2671:                     if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2672:                 }",
          "2673:             }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2685:                     totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2707:                      if (sdslen(tmp) > maxelelen) maxelelen = sdslen(tmp);",
          "2709:                     dictSetKey(accumulator, de, tmp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2722:                      totelelen += sdslen(tmp);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "2738:         dictReleaseIterator(di);",
          "2739:         dictRelease(accumulator);",
          "2740:     } else if (op == SET_OP_DIFF) {",
          "2742:     } else {",
          "2743:         serverPanic(\"Unknown operator\");",
          "2744:     }",
          "2746:     if (dstkey) {",
          "2747:         if (dstzset->zsl->length) {",
          "2749:             setKey(c, c->db, dstkey, dstobj);",
          "2750:             addReplyLongLong(c, zsetLength(dstobj));",
          "2751:             notifyKeyspaceEvent(NOTIFY_ZSET,",
          "",
          "[Removed Lines]",
          "2741:         zdiff(src, setnum, dstzset, &maxelelen);",
          "2748:             zsetConvertToListpackIfNeeded(dstobj, maxelelen);",
          "",
          "[Added Lines]",
          "2757:         zdiff(src, setnum, dstzset, &maxelelen, &totelelen);",
          "2764:             zsetConvertToListpackIfNeeded(dstobj, maxelelen, totelelen);",
          "",
          "---------------"
        ],
        "src/ziplist.c||src/ziplist.c": [
          "File: src/ziplist.c -> src/ziplist.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "267:         ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \\",
          "268: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272: #define ZIPLIST_MAX_SAFETY_SIZE (1<<30)",
          "273: int ziplistSafeToAdd(unsigned char* zl, size_t add) {",
          "274:     size_t len = zl? ziplistBlobLen(zl): 0;",
          "275:     if (len + add > ZIPLIST_MAX_SAFETY_SIZE)",
          "276:         return 0;",
          "277:     return 1;",
          "278: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "709: }",
          "713:     zl = zrealloc(zl,len);",
          "714:     ZIPLIST_BYTES(zl) = intrev32ifbe(len);",
          "715:     zl[len-1] = ZIP_END;",
          "",
          "[Removed Lines]",
          "712: unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {",
          "",
          "[Added Lines]",
          "723: unsigned char *ziplistResize(unsigned char *zl, size_t len) {",
          "724:     assert(len < UINT32_MAX);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1071:     zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;",
          "1074:     size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));",
          "1075:     size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1086:     assert(zlbytes < UINT32_MAX);",
          "",
          "---------------"
        ],
        "src/ziplist.h||src/ziplist.h": [
          "File: src/ziplist.h -> src/ziplist.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "65: void ziplistRandomPair(unsigned char *zl, unsigned long total_count, ziplistEntry *key, ziplistEntry *val);",
          "66: void ziplistRandomPairs(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals);",
          "67: unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals);",
          "69: #ifdef REDIS_TEST",
          "70: int ziplistTest(int argc, char *argv[], int accurate);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "68: int ziplistSafeToAdd(unsigned char* zl, size_t add);",
          "",
          "---------------"
        ],
        "tests/unit/violations.tcl||tests/unit/violations.tcl": [
          "File: tests/unit/violations.tcl -> tests/unit/violations.tcl",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: # These tests consume massive amounts of memory, and are not",
          "2: # suitable to be executed as part of the normal test suite",
          "3: set ::str500 [string repeat x 500000000] ;# 500mb",
          "5: # Utility function to write big argument into redis client connection",
          "6: proc write_big_bulk {size} {",
          "7:     r write \"\\$$size\\r\\n\"",
          "8:     while {$size >= 500000000} {",
          "9:         r write $::str500",
          "10:         incr size -500000000",
          "11:     }",
          "12:     if {$size > 0} {",
          "13:         r write [string repeat x $size]",
          "14:     }",
          "15:     r write \"\\r\\n\"",
          "16: }",
          "18: # One XADD with one huge 5GB field",
          "19: # Expected to fail resulting in an empty stream",
          "20: start_server [list overrides [list save \"\"] ] {",
          "21:     test {XADD one huge field} {",
          "22:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "23:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "24:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "25:         r write \"\\$1\\r\\nA\\r\\n\"",
          "26:         write_big_bulk 5000000000 ;#5gb",
          "27:         r flush",
          "28:         catch {r read} err",
          "29:         assert_match {*too large*} $err",
          "30:         r xlen S1",
          "31:     } {0}",
          "32: }",
          "34: # One XADD with one huge (exactly nearly) 4GB field",
          "35: # This uncovers the overflow in lpEncodeGetType",
          "36: # Expected to fail resulting in an empty stream",
          "37: start_server [list overrides [list save \"\"] ] {",
          "38:     test {XADD one huge field - 1} {",
          "39:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "40:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "41:         r write \"*5\\r\\n\\$4\\r\\nXADD\\r\\n\\$2\\r\\nS1\\r\\n\\$1\\r\\n*\\r\\n\"",
          "42:         r write \"\\$1\\r\\nA\\r\\n\"",
          "43:         write_big_bulk 4294967295 ;#4gb-1",
          "44:         r flush",
          "45:         catch {r read} err",
          "46:         assert_match {*too large*} $err",
          "47:         r xlen S1",
          "48:     } {0}",
          "49: }",
          "51: # Gradually add big stream fields using repeated XADD calls",
          "52: start_server [list overrides [list save \"\"] ] {",
          "53:     test {several XADD big fields} {",
          "54:         r config set stream-node-max-bytes 0",
          "55:         for {set j 0} {$j<10} {incr j} {",
          "56:             r xadd stream * 1 $::str500 2 $::str500",
          "57:         }",
          "58:         r ping",
          "59:         r xlen stream",
          "60:     } {10}",
          "61: }",
          "63: # Add over 4GB to a single stream listpack (one XADD command)",
          "64: # Expected to fail resulting in an empty stream",
          "65: start_server [list overrides [list save \"\"] ] {",
          "66:     test {single XADD big fields} {",
          "67:         r write \"*23\\r\\n\\$4\\r\\nXADD\\r\\n\\$1\\r\\nS\\r\\n\\$1\\r\\n*\\r\\n\"",
          "68:         for {set j 0} {$j<10} {incr j} {",
          "69:             r write \"\\$1\\r\\n$j\\r\\n\"",
          "70:             write_big_bulk 500000000 ;#500mb",
          "71:         }",
          "72:         r flush",
          "73:         catch {r read} err",
          "74:         assert_match {*too large*} $err",
          "75:         r xlen S",
          "76:     } {0}",
          "77: }",
          "79: # Gradually add big hash fields using repeated HSET calls",
          "80: # This reproduces the overflow in the call to ziplistResize",
          "81: # Object will be converted to hashtable encoding",
          "82: start_server [list overrides [list save \"\"] ] {",
          "83:     r config set hash-max-ziplist-value 1000000000 ;#1gb",
          "84:     test {hash with many big fields} {",
          "85:         for {set j 0} {$j<10} {incr j} {",
          "86:             r hset h $j $::str500",
          "87:         }",
          "88:         r object encoding h",
          "89:     } {hashtable}",
          "90: }",
          "92: # Add over 4GB to a single hash field (one HSET command)",
          "93: # Object will be converted to hashtable encoding",
          "94: start_server [list overrides [list save \"\"] ] {",
          "95:     test {hash with one huge field} {",
          "96:         catch {r config set hash-max-ziplist-value 10000000000} ;#10gb",
          "97:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "98:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "99:         r write \"*4\\r\\n\\$4\\r\\nHSET\\r\\n\\$2\\r\\nH1\\r\\n\"",
          "100:         r write \"\\$1\\r\\nA\\r\\n\"",
          "101:         write_big_bulk 5000000000 ;#5gb",
          "102:         r flush",
          "103:         r read",
          "104:         r object encoding H1",
          "105:     } {hashtable}",
          "106: }",
          "108: # Add over 4GB to a single list member (one LPUSH command)",
          "109: # Currently unsupported, and expected to fail rather than being truncated",
          "110: # Expected to fail resulting in a non-existing list",
          "111: start_server [list overrides [list save \"\"] ] {",
          "112:     test {list with one huge field} {",
          "113:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "114:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "115:         r write \"*3\\r\\n\\$5\\r\\nLPUSH\\r\\n\\$2\\r\\nL1\\r\\n\"",
          "116:         write_big_bulk 5000000000 ;#5gb",
          "117:         r flush",
          "118:         catch {r read} err",
          "119:         assert_match {*too large*} $err",
          "120:         r exists L1",
          "121:     } {0}",
          "122: }",
          "124: # SORT which attempts to store an element larger than 4GB into a list.",
          "125: # Currently unsupported and results in an assertion instead of truncation",
          "126: start_server [list overrides [list save \"\"] ] {",
          "127:     test {SORT adds huge field to list} {",
          "128:         r config set proto-max-bulk-len 10000000000 ;#10gb",
          "129:         r config set client-query-buffer-limit 10000000000 ;#10gb",
          "130:         r write \"*3\\r\\n\\$3\\r\\nSET\\r\\n\\$2\\r\\nS1\\r\\n\"",
          "131:         write_big_bulk 5000000000 ;#5gb",
          "132:         r flush",
          "133:         r read",
          "134:         assert_equal [r strlen S1] 5000000000",
          "135:         r set S2 asdf",
          "136:         r sadd myset 1 2",
          "137:         r mset D1 1 D2 2",
          "138:         catch {r sort myset by D* get S* store mylist}",
          "139:         assert_equal [count_log_message 0 \"crashed by signal\"] 0",
          "140:         assert_equal [count_log_message 0 \"ASSERTION FAILED\"] 1",
          "141:     }",
          "142: }",
          "144: # SORT which stores an integer encoded element into a list.",
          "145: # Just for coverage, no news here.",
          "146: start_server [list overrides [list save \"\"] ] {",
          "147:     test {SORT adds integer field to list} {",
          "148:         r set S1 asdf",
          "149:         r set S2 123 ;# integer encoded",
          "150:         assert_encoding \"int\" S2",
          "151:         r sadd myset 1 2",
          "152:         r mset D1 1 D2 2",
          "153:         r sort myset by D* get S* store mylist",
          "154:         r llen mylist",
          "155:     } {2}",
          "156: }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
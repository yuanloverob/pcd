{
  "cve_id": "CVE-2016-8649",
  "cve_desc": "lxc-attach in LXC before 1.0.9 and 2.x before 2.0.6 allows an attacker inside of an unprivileged container to use an inherited file descriptor, of the host's /proc, to access the rest of the host's filesystem via the openat() family of syscalls.",
  "repo": "lxc/lxc",
  "patch_hash": "81f466d05f2a89cb4f122ef7f593ff3f279b165c",
  "patch_info": {
    "commit_hash": "81f466d05f2a89cb4f122ef7f593ff3f279b165c",
    "repo": "lxc/lxc",
    "commit_url": "https://github.com/lxc/lxc/commit/81f466d05f2a89cb4f122ef7f593ff3f279b165c",
    "files": [
      "src/lxc/attach.c"
    ],
    "message": "attach: do not send procfd to attached process\n\nSo far, we opened a file descriptor refering to proc on the host inside the\nhost namespace and handed that fd to the attached process in\nattach_child_main(). This was done to ensure that LSM labels were correctly\nsetup. However, by exploiting a potential kernel bug, ptrace could be used to\nprevent the file descriptor from being closed which in turn could be used by an\nunprivileged container to gain access to the host namespace. Aside from this\nneeding an upstream kernel fix, we should make sure that we don't pass the fd\nfor proc itself to the attached process. However, we cannot completely prevent\nthis, as the attached process needs to be able to change its apparmor profile\nby writing to /proc/self/attr/exec or /proc/self/attr/current. To minimize the\nattack surface, we only send the fd for /proc/self/attr/exec or\n/proc/self/attr/current to the attached process. To do this we introduce a\nlittle more IPC between the child and parent:\n\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\nThe attached child tells the parent when it is ready to have its LSM labels set\nup. The parent then opens an approriate fd for the child PID to\n/proc/<pid>/attr/exec or /proc/<pid>/attr/current and sends it via SCM_RIGHTS\nto the child. The child can then set its LSM laben. Both sides then close the\nsocket fds and the child execs the requested process.\n\nSigned-off-by: Christian Brauner <christian.brauner@canonical.com>",
    "before_after_code_files": [
      "src/lxc/attach.c||src/lxc/attach.c"
    ]
  },
  "patch_diff": {
    "src/lxc/attach.c||src/lxc/attach.c": [
      "File: src/lxc/attach.c -> src/lxc/attach.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "54: #include \"namespace.h\"",
      "55: #include \"log.h\"",
      "56: #include \"attach.h\"",
      "57: #include \"caps.h\"",
      "58: #include \"config.h\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "56: #include \"af_unix.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "85: lxc_log_define(lxc_attach, lxc);",
      "88:  int labelfd = -1;",
      "90:  const char* name;",
      "93:  name = lsm_name();",
      "95:  if (strcmp(name, \"nop\") == 0)",
      "98:  if (strcmp(name, \"none\") == 0)",
      "102:  if (strcmp(name, \"AppArmor\") == 0)",
      "103:   on_exec = 0;",
      "105:  if (on_exec) {",
      "110:  }",
      "112:  if (labelfd < 0) {",
      "113:   SYSERROR(\"Unable to open LSM label\");",
      "116:  }",
      "118:  if (strcmp(name, \"AppArmor\") == 0) {",
      "119:   int size;",
      "121:   command = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);",
      "122:   if (!command) {",
      "123:    SYSERROR(\"Failed to write apparmor profile\");",
      "125:    goto out;",
      "126:   }",
      "128:   size = sprintf(command, \"changeprofile %s\", lsm_label);",
      "129:   if (size < 0) {",
      "130:    SYSERROR(\"Failed to write apparmor profile\");",
      "132:    goto out;",
      "133:   }",
      "138:    goto out;",
      "139:   }",
      "143:    SYSERROR(\"Unable to set LSM label\");",
      "145:    goto out;",
      "146:   }",
      "149:   ERROR(\"Unable to restore label for unknown LSM: %s\", name);",
      "151:   goto out;",
      "152:  }",
      "154: out:",
      "155:  free(command);",
      "161: }",
      "163: static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)",
      "",
      "[Removed Lines]",
      "87: int lsm_set_label_at(int procfd, int on_exec, char* lsm_label) {",
      "89:  int ret = 0;",
      "91:  char* command = NULL;",
      "96:   goto out;",
      "99:   goto out;",
      "106:   labelfd = openat(procfd, \"self/attr/exec\", O_RDWR);",
      "107:  }",
      "108:  else {",
      "109:   labelfd = openat(procfd, \"self/attr/current\", O_RDWR);",
      "114:   ret = -1;",
      "115:   goto out;",
      "124:    ret = -1;",
      "131:    ret = -1;",
      "135:   if (write(labelfd, command, size + 1) < 0) {",
      "136:    SYSERROR(\"Unable to set LSM label\");",
      "137:    ret = -1;",
      "140:  }",
      "141:  else if (strcmp(name, \"SELinux\") == 0) {",
      "142:   if (write(labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
      "144:    ret = -1;",
      "147:  }",
      "148:  else {",
      "150:   ret = -1;",
      "157:  if (labelfd != -1)",
      "158:   close(labelfd);",
      "160:  return ret;",
      "",
      "[Added Lines]",
      "88: static int lsm_openat(int procfd, pid_t pid, int on_exec)",
      "89: {",
      "90:  int ret = -1;",
      "93: #define __LSMATTRLEN /* /proc */ (5 + /* /pid-to-str */ 21 + /* /current */ 7 + /* \\0 */ 1)",
      "94:  char path[__LSMATTRLEN];",
      "99:   return 0;",
      "102:   return 0;",
      "109:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);",
      "110:   if (ret < 0 || ret >= __LSMATTRLEN)",
      "111:    return -1;",
      "112:   labelfd = openat(procfd, path, O_RDWR);",
      "113:  } else {",
      "114:   ret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);",
      "115:   if (ret < 0 || ret >= __LSMATTRLEN)",
      "116:    return -1;",
      "117:   labelfd = openat(procfd, path, O_RDWR);",
      "122:   return -1;",
      "125:  return labelfd;",
      "126: }",
      "128: static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)",
      "129: {",
      "130:  int fret = -1;",
      "131:  const char* name;",
      "132:  char *command = NULL;",
      "134:  name = lsm_name();",
      "136:  if (strcmp(name, \"nop\") == 0)",
      "137:   return 0;",
      "139:  if (strcmp(name, \"none\") == 0)",
      "140:   return 0;",
      "143:  if (strcmp(name, \"AppArmor\") == 0)",
      "144:   on_exec = 0;",
      "161:   if (write(lsm_labelfd, command, size + 1) < 0) {",
      "162:    SYSERROR(\"Unable to set LSM label: %s.\", command);",
      "165:   INFO(\"Set LSM label to: %s.\", command);",
      "166:  } else if (strcmp(name, \"SELinux\") == 0) {",
      "167:   if (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
      "171:   INFO(\"Set LSM label to: %s.\", lsm_label);",
      "172:  } else {",
      "176:  fret = 0;",
      "181:  if (lsm_labelfd != -1)",
      "182:   close(lsm_labelfd);",
      "184:  return fret;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "646:  struct lxc_proc_context_info* init_ctx;",
      "647:  lxc_attach_exec_t exec_function;",
      "648:  void* exec_payload;",
      "650: };",
      "652: static int attach_child_main(void* data);",
      "",
      "[Removed Lines]",
      "649:  int procfd;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "744:  char* cwd;",
      "745:  char* new_cwd;",
      "746:  int ipc_sockets[2];",
      "748:  signed long personality;",
      "750:  if (!options)",
      "",
      "[Removed Lines]",
      "747:  int procfd;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "854:  }",
      "856:  if (pid) {",
      "857:   pid_t to_cleanup_pid = pid;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "884:   int procfd = -1;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "868:     goto cleanup_error;",
      "869:   }",
      "872:   status = 0;",
      "873:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "902:   procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);",
      "903:   if (procfd < 0) {",
      "904:    SYSERROR(\"Unable to open /proc.\");",
      "905:    goto cleanup_error;",
      "906:   }",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "911:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
      "912:   if (ret <= 0) {",
      "913:    if (ret != 0)",
      "915:    goto cleanup_error;",
      "916:   }",
      "",
      "[Removed Lines]",
      "914:     ERROR(\"error using IPC to receive notification from attached process (1)\");",
      "",
      "[Added Lines]",
      "951:     ERROR(\"error using IPC to receive notification \"",
      "952:           \"from attached process (1)\");",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "919:   status = 2;",
      "920:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
      "921:   if (ret <= 0) {",
      "923:    goto cleanup_error;",
      "924:   }",
      "927:   shutdown(ipc_sockets[0], SHUT_RDWR);",
      "928:   close(ipc_sockets[0]);",
      "",
      "[Removed Lines]",
      "922:    ERROR(\"error using IPC to notify attached process for initialization (2)\");",
      "",
      "[Added Lines]",
      "960:    ERROR(\"Error using IPC to notify attached process for \"",
      "961:          \"initialization (2): %s.\", strerror(errno));",
      "968:   expected = 3;",
      "969:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
      "970:   if (ret <= 0) {",
      "971:    ERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",",
      "972:          strerror(errno));",
      "973:    goto cleanup_error;",
      "974:   }",
      "977:   if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
      "978:    int on_exec, labelfd;",
      "979:    on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
      "981:    labelfd = lsm_openat(procfd, attached_pid, on_exec);",
      "982:    if (labelfd < 0)",
      "983:     goto cleanup_error;",
      "986:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
      "987:    if (ret <= 0) {",
      "988:     ERROR(\"Error using IPC to send child LSM fd (4): %s.\",",
      "989:       strerror(errno));",
      "990:     goto cleanup_error;",
      "991:    }",
      "992:   }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "943:   shutdown(ipc_sockets[0], SHUT_RDWR);",
      "944:   close(ipc_sockets[0]);",
      "945:   if (to_cleanup_pid)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1011:   if (procfd >= 0)",
      "1012:    close(procfd);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "966:  if ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())",
      "967:   options->namespaces |= CLONE_NEWCGROUP;",
      "",
      "[Removed Lines]",
      "969:  procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY);",
      "970:  if (procfd < 0) {",
      "971:   SYSERROR(\"Unable to open /proc\");",
      "972:   shutdown(ipc_sockets[1], SHUT_RDWR);",
      "973:   rexit(-1);",
      "974:  }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "1001:    .init_ctx = init_ctx,",
      "1002:    .exec_function = exec_function,",
      "1003:    .exec_payload = exec_payload,",
      "1005:   };",
      "",
      "[Removed Lines]",
      "1004:    .procfd = procfd",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "1039: {",
      "1040:  struct attach_clone_payload* payload = (struct attach_clone_payload*)data;",
      "1041:  int ipc_socket = payload->ipc_socket;",
      "1043:  lxc_attach_options_t* options = payload->options;",
      "1044:  struct lxc_proc_context_info* init_ctx = payload->init_ctx;",
      "1045: #if HAVE_SYS_PERSONALITY_H",
      "",
      "[Removed Lines]",
      "1042:  int procfd = payload->procfd;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "1050:  int expected;",
      "1051:  long flags;",
      "1052:  int fd;",
      "1053:  uid_t new_uid;",
      "1054:  gid_t new_gid;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1114:  int lsm_labelfd;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "1060:  status = -1;",
      "1061:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
      "1062:  if (ret <= 0) {",
      "1064:   shutdown(ipc_socket, SHUT_RDWR);",
      "1065:   rexit(-1);",
      "1066:  }",
      "",
      "[Removed Lines]",
      "1063:   ERROR(\"error using IPC to receive notification from initial process (0)\");",
      "",
      "[Added Lines]",
      "1125:   ERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "1159:  status = 1;",
      "1160:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
      "1161:  if (ret != sizeof(status)) {",
      "1163:   shutdown(ipc_socket, SHUT_RDWR);",
      "1164:   rexit(-1);",
      "1165:  }",
      "",
      "[Removed Lines]",
      "1162:   ERROR(\"error using IPC to notify initial process for initialization (1)\");",
      "",
      "[Added Lines]",
      "1224:   ERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "1171:  status = -1;",
      "1172:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
      "1173:  if (ret <= 0) {",
      "1175:   shutdown(ipc_socket, SHUT_RDWR);",
      "1176:   rexit(-1);",
      "1177:  }",
      "1182:  if ((init_ctx->container && init_ctx->container->lxc_conf &&",
      "1183:       init_ctx->container->lxc_conf->no_new_privs) ||",
      "1184:      (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {",
      "",
      "[Removed Lines]",
      "1174:   ERROR(\"error using IPC to receive final notification from initial process (2)\");",
      "1179:  shutdown(ipc_socket, SHUT_RDWR);",
      "1180:  close(ipc_socket);",
      "",
      "[Added Lines]",
      "1236:   ERROR(\"Error using IPC to receive message from initial process \"",
      "1237:         \"that it is done pre-initializing (2): %s\",",
      "1238:         strerror(errno));",
      "",
      "---------------",
      "--- Hunk 17 ---",
      "[Context before]",
      "1186:    SYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"",
      "1187:      \"Process can use execve() gainable \"",
      "1188:      \"privileges.\");",
      "1189:    rexit(-1);",
      "1190:   }",
      "1191:   INFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"",
      "1192:        \"gainable privileges.\");",
      "1193:  }",
      "1196:  if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
      "1197:   int on_exec;",
      "1199:   on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
      "1201:    rexit(-1);",
      "1202:   }",
      "1203:  }",
      "1204:  if (init_ctx->container && init_ctx->container->lxc_conf &&",
      "1205:      init_ctx->container->lxc_conf->seccomp &&",
      "1206:      (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {",
      "1207:   ERROR(\"Loading seccomp policy\");",
      "1208:   rexit(-1);",
      "1209:  }",
      "1210:  lxc_proc_put_context_info(init_ctx);",
      "",
      "[Removed Lines]",
      "1200:   if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {",
      "",
      "[Added Lines]",
      "1250:    shutdown(ipc_socket, SHUT_RDWR);",
      "1258:  status = 3;",
      "1259:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
      "1260:  if (ret <= 0) {",
      "1261:   ERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));",
      "1262:   shutdown(ipc_socket, SHUT_RDWR);",
      "1263:   rexit(-1);",
      "1264:  }",
      "1269:   ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);",
      "1270:   if (ret <= 0) {",
      "1271:    ERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));",
      "1272:    shutdown(ipc_socket, SHUT_RDWR);",
      "1273:    rexit(-1);",
      "1274:   }",
      "1278:   if (lsm_set_label_at(lsm_labelfd, on_exec, init_ctx->lsm_label) < 0) {",
      "1279:    SYSERROR(\"Failed to set LSM label.\");",
      "1280:    shutdown(ipc_socket, SHUT_RDWR);",
      "1281:    close(lsm_labelfd);",
      "1284:   close(lsm_labelfd);",
      "1291:   shutdown(ipc_socket, SHUT_RDWR);",
      "1295:  shutdown(ipc_socket, SHUT_RDWR);",
      "1296:  close(ipc_socket);",
      "",
      "---------------",
      "--- Hunk 18 ---",
      "[Context before]",
      "1245:     SYSERROR(\"Unable to clear CLOEXEC from fd\");",
      "1246:  }",
      "1252:  rexit(payload->exec_function(payload->exec_payload));",
      "1253: }",
      "",
      "[Removed Lines]",
      "1249:  close(procfd);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2e812c16a502b03abe79ee00025de50d1928ad5e",
      "candidate_info": {
        "commit_hash": "2e812c16a502b03abe79ee00025de50d1928ad5e",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/2e812c16a502b03abe79ee00025de50d1928ad5e",
        "files": [
          "src/lxc/attach.c"
        ],
        "message": "attach: use PR_SET_NO_NEW_PRIVS\n\n- When we detect that the container, we want to attach to, has been stared with\n  PR_SET_NO_NEW_PRIVS we attach with PR_SET_NO_NEW_PRIVS as well. (We might\n  relax this restriction later but let's be strict for now.)\n- When LXC_ATTACH_NO_NEW_PRIVS is set in the flags passed to\n  lxc_attach()/attach_child_main() then we set PR_SET_NO_NEW_PRIVS irrespective\n  of whether the container was started with PR_SET_NO_NEW_PRIVS or not.\n- Set no_new_privs before lsm and seccomp. We probably don't want attach() to\n  be able to change the lsm or seccomp policy if the container was started with\n  PR_SET_NO_NEW_PRIVS enabled.\n\nSigned-off-by: Christian Brauner <christian.brauner@canonical.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "692:   return false;",
          "693:  }",
          "695:  return true;",
          "696: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "695:  INFO(\"Retrieved seccomp policy.\");",
          "696:  return true;",
          "697: }",
          "699: static bool no_new_privs(struct lxc_proc_context_info *ctx,",
          "700:     lxc_attach_options_t *options)",
          "701: {",
          "702:  struct lxc_container *c;",
          "703:  char *val;",
          "705:  c = ctx->container;",
          "708:  if (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {",
          "709:   return false;",
          "710:  }",
          "713:  val = c->get_running_config_item(c, \"lxc.no_new_privs\");",
          "714:  if (!val) {",
          "715:   INFO(\"Failed to get running config item for lxc.no_new_privs.\");",
          "716:   return false;",
          "717:  }",
          "720:  if (!c->set_config_item(c, \"lxc.no_new_privs\", val)) {",
          "721:   free(val);",
          "722:   return false;",
          "723:  }",
          "724:  free(val);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "748:  if (!fetch_seccomp(init_ctx, options))",
          "749:   WARN(\"Failed to get seccomp policy\");",
          "751:  cwd = getcwd(NULL, 0);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "782:  if (!no_new_privs(init_ctx, options))",
          "783:   WARN(\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\");",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1147:  shutdown(ipc_socket, SHUT_RDWR);",
          "1148:  close(ipc_socket);",
          "1151:  if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "1152:   int on_exec;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1184:  if ((init_ctx->container && init_ctx->container->lxc_conf &&",
          "1185:       init_ctx->container->lxc_conf->no_new_privs) ||",
          "1186:      (options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {",
          "1187:   if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {",
          "1188:    SYSERROR(\"PR_SET_NO_NEW_PRIVS could not be set. \"",
          "1189:      \"Process can use execve() gainable \"",
          "1190:      \"privileges.\");",
          "1191:    rexit(-1);",
          "1192:   }",
          "1193:   INFO(\"PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() \"",
          "1194:        \"gainable privileges.\");",
          "1195:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6f4f19370433b88557c860a4f5dc2ecbec297275",
      "candidate_info": {
        "commit_hash": "6f4f19370433b88557c860a4f5dc2ecbec297275",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/6f4f19370433b88557c860a4f5dc2ecbec297275",
        "files": [
          "src/lxc/attach.c",
          "src/lxc/attach.h"
        ],
        "message": "attach: non-functional changes\n\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c",
          "src/lxc/attach.h||src/lxc/attach.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #define _GNU_SOURCE",
          "30: #include <errno.h>",
          "31: #include <fcntl.h>",
          "32: #include <grp.h>",
          "33: #include <sys/param.h>",
          "34: #include <sys/prctl.h>",
          "36: #include <sys/socket.h>",
          "37: #include <sys/syscall.h>",
          "38: #include <sys/wait.h>",
          "42: #ifndef HAVE_DECL_PR_CAPBSET_DROP",
          "43: #define PR_CAPBSET_DROP 24",
          "",
          "[Removed Lines]",
          "25: #include <unistd.h>",
          "26: #include <stdio.h>",
          "27: #include <string.h>",
          "28: #include <stdlib.h>",
          "29: #include <signal.h>",
          "35: #include <sys/mount.h>",
          "39: #include <linux/unistd.h>",
          "40: #include <pwd.h>",
          "",
          "[Added Lines]",
          "28: #include <pwd.h>",
          "29: #include <signal.h>",
          "30: #include <stdio.h>",
          "31: #include <stdlib.h>",
          "32: #include <string.h>",
          "33: #include <unistd.h>",
          "34: #include <linux/unistd.h>",
          "35: #include <sys/mount.h>",
          "42: #include <lxc/lxccontainer.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51: #define PR_GET_NO_NEW_PRIVS 39",
          "52: #endif",
          "56: #include \"af_unix.h\"",
          "57: #include \"attach.h\"",
          "58: #include \"caps.h\"",
          "62: #include \"cgroup.h\"",
          "64: #include \"conf.h\"",
          "68: #include \"confile.h\"",
          "70: #if HAVE_SYS_PERSONALITY_H",
          "71: #include <sys/personality.h>",
          "72: #endif",
          "74: #ifndef SOCK_CLOEXEC",
          "76: #endif",
          "78: #ifndef MS_REC",
          "",
          "[Removed Lines]",
          "54: #include \"namespace.h\"",
          "55: #include \"log.h\"",
          "59: #include \"config.h\"",
          "60: #include \"utils.h\"",
          "61: #include \"commands.h\"",
          "63: #include \"lxclock.h\"",
          "65: #include \"lxcseccomp.h\"",
          "66: #include <lxc/lxccontainer.h>",
          "67: #include \"lsm/lsm.h\"",
          "75: #  define SOCK_CLOEXEC                02000000",
          "",
          "[Added Lines]",
          "60: #include \"commands.h\"",
          "62: #include \"config.h\"",
          "64: #include \"log.h\"",
          "65: #include \"lsm/lsm.h\"",
          "66: #include \"lxclock.h\"",
          "67: #include \"lxcseccomp.h\"",
          "68: #include \"namespace.h\"",
          "69: #include \"utils.h\"",
          "76: #define SOCK_CLOEXEC 02000000",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "80: #endif",
          "82: #ifndef MS_SLAVE",
          "84: #endif",
          "86: lxc_log_define(lxc_attach, lxc);",
          "",
          "[Removed Lines]",
          "83: #define MS_SLAVE (1<<19)",
          "",
          "[Added Lines]",
          "84: #define MS_SLAVE (1 << 19)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "125: static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)",
          "126: {",
          "127:  int fret = -1;",
          "129:  char *command = NULL;",
          "131:  name = lsm_name();",
          "",
          "[Removed Lines]",
          "128:  const char* name;",
          "",
          "[Added Lines]",
          "129:  const char *name;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "143:  if (strcmp(name, \"AppArmor\") == 0) {",
          "144:   int size;",
          "147:   if (!command) {",
          "148:    SYSERROR(\"Failed to write apparmor profile.\");",
          "149:    goto out;",
          "",
          "[Removed Lines]",
          "146:   command = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);",
          "",
          "[Added Lines]",
          "147:   command =",
          "148:       malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "185: #define __PROC_STATUS_LEN (5 + (LXC_NUMSTRLEN64) + 7 + 1)",
          "186: static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)",
          "187: {",
          "188:  FILE *proc_file;",
          "189:  char proc_fn[__PROC_STATUS_LEN];",
          "193:  size_t line_bufsz = 0;",
          "194:  struct lxc_proc_context_info *info = NULL;",
          "",
          "[Removed Lines]",
          "190:  bool found;",
          "191:  int ret;",
          "192:  char *line = NULL;",
          "",
          "[Added Lines]",
          "190:  int ret;",
          "191:  bool found;",
          "195:  char *line = NULL;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "224:  fclose(proc_file);",
          "226:  if (!found) {",
          "228:   errno = ENOENT;",
          "229:   goto on_error;",
          "230:  }",
          "",
          "[Removed Lines]",
          "227:   SYSERROR(\"Could not read capability bounding set from %s.\", proc_fn);",
          "",
          "[Added Lines]",
          "229:   SYSERROR(\"Could not read capability bounding set from %s.\",",
          "230:     proc_fn);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "275:     close(fd[j]);",
          "277:    errno = saved_errno;",
          "279:    return -1;",
          "280:   }",
          "281:  }",
          "",
          "[Removed Lines]",
          "278:    SYSERROR(\"Failed to open namespace: \\\"%s\\\".\", ns_info[i].proc_name);",
          "",
          "[Added Lines]",
          "280:    SYSERROR(\"Failed to open namespace: \\\"%s\\\".\",",
          "281:      ns_info[i].proc_name);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "291:     close(fd[j]);",
          "293:    errno = saved_errno;",
          "295:    return -1;",
          "296:   }",
          "",
          "[Removed Lines]",
          "294:    SYSERROR(\"Failed to attach to namespace \\\"%s\\\".\", ns_info[i].proc_name);",
          "",
          "[Added Lines]",
          "297:    SYSERROR(\"Failed to attach to namespace \\\"%s\\\".\",",
          "298:      ns_info[i].proc_name);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "314:  }",
          "316:  if (detect_shared_rootfs()) {",
          "318:    SYSERROR(\"Failed to make / rslave.\");",
          "319:    ERROR(\"Continuing...\");",
          "320:   }",
          "",
          "[Removed Lines]",
          "317:   if (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {",
          "",
          "[Added Lines]",
          "321:   if (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL)) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "355: static int lxc_attach_drop_privs(struct lxc_proc_context_info *ctx)",
          "356: {",
          "360:  for (cap = 0; cap <= last_cap; cap++) {",
          "361:   if (ctx->capability_mask & (1LL << cap))",
          "362:    continue;",
          "",
          "[Removed Lines]",
          "357:  int last_cap = lxc_caps_last_cap();",
          "358:  int cap;",
          "",
          "[Added Lines]",
          "361:  int cap, last_cap;",
          "363:  last_cap = lxc_caps_last_cap();",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "370:  return 0;",
          "371: }",
          "374: {",
          "375:  if (policy == LXC_ATTACH_CLEAR_ENV) {",
          "377:   int path_kept = 0;",
          "379:   if (extra_keep) {",
          "380:    size_t count, i;",
          "",
          "[Removed Lines]",
          "373: static int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy, char** extra_env, char** extra_keep)",
          "376:   char **extra_keep_store = NULL;",
          "",
          "[Added Lines]",
          "377: static int lxc_attach_set_environment(enum lxc_attach_env_policy_t policy,",
          "378:           char **extra_env, char **extra_keep)",
          "382:   char **extra_keep_store = NULL;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "470: static char *lxc_attach_getpwshell(uid_t uid)",
          "471: {",
          "472:  pid_t pid;",
          "473:  int pipes[2];",
          "476:  char *result = NULL;",
          "",
          "[Removed Lines]",
          "474:  int ret;",
          "475:  int fd;",
          "",
          "[Added Lines]",
          "479:  int fd, ret;",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "490:  }",
          "492:  if (pid) {",
          "493:   FILE *pipe_f;",
          "496:   int found = 0;",
          "499:   close(pipes[1]);",
          "501:   pipe_f = fdopen(pipes[0], \"r\");",
          "502:   while (getline(&line, &line_bufsz, pipe_f) != -1) {",
          "507:    int i;",
          "",
          "[Removed Lines]",
          "494:   char *line = NULL;",
          "495:   size_t line_bufsz = 0;",
          "497:   int status;",
          "503:    char *token;",
          "504:    char *saveptr = NULL;",
          "505:    long value;",
          "506:    char *endptr = NULL;",
          "",
          "[Added Lines]",
          "499:   int status;",
          "502:   size_t line_bufsz = 0;",
          "503:   char *line = NULL;",
          "510:    long value;",
          "511:    char *token;",
          "512:    char *endptr = NULL, *saveptr = NULL;",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "615:  }",
          "616: }",
          "619: {",
          "620:  FILE *proc_file;",
          "621:  char proc_fn[__PROC_STATUS_LEN];",
          "",
          "[Removed Lines]",
          "618: static void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)",
          "",
          "[Added Lines]",
          "623: static void lxc_attach_get_init_uidgid(uid_t *init_uid, gid_t *init_gid)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "640:   ret = sscanf(line, \"Uid: %ld\", &value);",
          "641:   if (ret != EOF && ret == 1) {",
          "643:   } else {",
          "644:    ret = sscanf(line, \"Gid: %ld\", &value);",
          "645:    if (ret != EOF && ret == 1)",
          "647:   }",
          "648:   if (uid != (uid_t)-1 && gid != (gid_t)-1)",
          "649:    break;",
          "",
          "[Removed Lines]",
          "642:    uid = (uid_t) value;",
          "646:     gid = (gid_t) value;",
          "",
          "[Added Lines]",
          "647:    uid = (uid_t)value;",
          "651:     gid = (gid_t)value;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "666: struct attach_clone_payload {",
          "667:  int ipc_socket;",
          "670:  lxc_attach_exec_t exec_function;",
          "672: };",
          "674: static int attach_child_main(void* data);",
          "680: static lxc_attach_options_t attach_static_default_options = LXC_ATTACH_OPTIONS_DEFAULT;",
          "",
          "[Removed Lines]",
          "668:  lxc_attach_options_t* options;",
          "669:  struct lxc_proc_context_info* init_ctx;",
          "671:  void* exec_payload;",
          "677: #define rexit(c)  do { int __c = (c); _exit(__c); return __c; } while(0)",
          "",
          "[Added Lines]",
          "673:  lxc_attach_options_t *options;",
          "674:  struct lxc_proc_context_info *init_ctx;",
          "676:  void *exec_payload;",
          "682: #define rexit(c)                                                               \\",
          "683:  do {                                                                   \\",
          "684:   int __c = (c);                                                 \\",
          "685:   _exit(__c);                                                    \\",
          "686:   return __c;                                                    \\",
          "687:  } while (0)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "684: {",
          "685:  char *path;",
          "688:   free(c->lxc_conf->seccomp);",
          "689:   c->lxc_conf->seccomp = NULL;",
          "690:   return true;",
          "",
          "[Removed Lines]",
          "687:  if (!(options->namespaces & CLONE_NEWNS) || !(options->attach_flags & LXC_ATTACH_LSM)) {",
          "",
          "[Added Lines]",
          "697:  if (!(options->namespaces & CLONE_NEWNS) ||",
          "698:      !(options->attach_flags & LXC_ATTACH_LSM)) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "724:  return true;",
          "725: }",
          "729: {",
          "730:  char *val;",
          "734:   return false;",
          "738:  val = c->get_running_config_item(c, \"lxc.no_new_privs\");",
          "",
          "[Removed Lines]",
          "727: static bool no_new_privs(struct lxc_container *c,",
          "728:     lxc_attach_options_t *options)",
          "733:  if (!c->set_config_item(c, \"lxc.no_new_privs\", \"\")) {",
          "735:  }",
          "",
          "[Added Lines]",
          "738: static bool no_new_privs(struct lxc_container *c, lxc_attach_options_t *options)",
          "743:  if (!c->set_config_item(c, \"lxc.no_new_privs\", \"\"))",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "754: static signed long get_personality(const char *name, const char *lxcpath)",
          "755: {",
          "757:  signed long ret;",
          "759:  if (!p)",
          "760:   return -1;",
          "761:  ret = lxc_config_parse_arch(p);",
          "762:  free(p);",
          "763:  return ret;",
          "764: }",
          "767: {",
          "768:  int ret, status;",
          "773:  int ipc_sockets[2];",
          "774:  signed long personality;",
          "776:  if (!options)",
          "777:   options = &attach_static_default_options;",
          "",
          "[Removed Lines]",
          "756:  char *p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);",
          "766: int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)",
          "769:  pid_t init_pid, pid, attached_pid, expected;",
          "770:  struct lxc_proc_context_info *init_ctx;",
          "771:  char* cwd;",
          "772:  char* new_cwd;",
          "",
          "[Added Lines]",
          "765:  char *p;",
          "768:  p = lxc_cmd_get_config_item(name, \"lxc.arch\", lxcpath);",
          "778: int lxc_attach(const char *name, const char *lxcpath,",
          "779:         lxc_attach_exec_t exec_function, void *exec_payload,",
          "780:         lxc_attach_options_t *options, pid_t *attached_process)",
          "784:  char *cwd, *new_cwd;",
          "786:  pid_t attached_pid, expected, init_pid, pid;",
          "787:  struct lxc_proc_context_info *init_ctx;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "785:  init_ctx = lxc_proc_get_context_info(init_pid);",
          "786:  if (!init_ctx) {",
          "789:   return -1;",
          "790:  }",
          "792:  personality = get_personality(name, lxcpath);",
          "793:  if (init_ctx->personality < 0) {",
          "795:   lxc_proc_put_context_info(init_ctx);",
          "796:   return -1;",
          "797:  }",
          "",
          "[Removed Lines]",
          "787:   ERROR(\"Failed to get context of init process: %ld.\",",
          "788:         (long)init_pid);",
          "794:   ERROR(\"Failed to get personality of the container.\");",
          "",
          "[Added Lines]",
          "800:   ERROR(\"Failed to get context of init process: %ld\", (long)init_pid);",
          "806:   ERROR(\"Failed to get personality of the container\");",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "901:   }",
          "",
          "[Removed Lines]",
          "904:   if (!lxc_list_empty(&init_ctx->container->lxc_conf->limits) && setup_resource_limits(&init_ctx->container->lxc_conf->limits, pid)) {",
          "905:    goto on_error;",
          "906:   }",
          "",
          "[Added Lines]",
          "915:   if (!lxc_list_empty(&init_ctx->container->lxc_conf->limits))",
          "916:    if (setup_resource_limits(&init_ctx->container->lxc_conf->limits, pid) < 0)",
          "917:     goto on_error;",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "924:   }",
          "928:   if (ret <= 0) {",
          "929:    if (ret != 0)",
          "930:     ERROR(\"Expected to receive pid: %s.\", strerror(errno));",
          "",
          "[Removed Lines]",
          "927:   ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);",
          "",
          "[Added Lines]",
          "938:   ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid,",
          "939:           sizeof(attached_pid), NULL);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "957:   expected = 1;",
          "959:   if (ret <= 0) {",
          "960:    if (ret != 0)",
          "961:     ERROR(\"Expected to receive sequence number 1: %s.\", strerror(errno));",
          "",
          "[Removed Lines]",
          "958:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
          "",
          "[Added Lines]",
          "970:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status,",
          "971:           sizeof(status), &expected);",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "976:   expected = 3;",
          "978:   if (ret <= 0) {",
          "979:    ERROR(\"Expected to receive sequence number 3: %s.\",",
          "980:          strerror(errno));",
          "",
          "[Removed Lines]",
          "977:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
          "",
          "[Added Lines]",
          "990:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status,",
          "991:           sizeof(status), &expected);",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "982:   }",
          "986:    int on_exec, saved_errno;",
          "987:    int labelfd = -1;",
          "988:    on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
          "990:    labelfd = lsm_openat(procfd, attached_pid, on_exec);",
          "",
          "[Removed Lines]",
          "985:   if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "",
          "[Added Lines]",
          "999:   if ((options->namespaces & CLONE_NEWNS) &&",
          "1000:       (options->attach_flags & LXC_ATTACH_LSM) &&",
          "1001:       init_ctx->lsm_label) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1025:   shutdown(ipc_sockets[0], SHUT_RDWR);",
          "1026:   close(ipc_sockets[0]);",
          "1027:   if (to_cleanup_pid)",
          "1029:   lxc_proc_put_context_info(init_ctx);",
          "1030:   return -1;",
          "1031:  }",
          "",
          "[Removed Lines]",
          "1028:    (void) wait_for_pid(to_cleanup_pid);",
          "",
          "[Added Lines]",
          "1045:    (void)wait_for_pid(to_cleanup_pid);",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1039:  expected = 0;",
          "1040:  status = -1;",
          "1042:  if (ret <= 0) {",
          "1043:   ERROR(\"Expected to receive sequence number 0: %s.\", strerror(errno));",
          "1044:   shutdown(ipc_sockets[1], SHUT_RDWR);",
          "",
          "[Removed Lines]",
          "1041:  ret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);",
          "",
          "[Added Lines]",
          "1058:  ret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status),",
          "1059:          &expected);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1113: static int attach_child_main(void* data)",
          "1114: {",
          "1119: #if HAVE_SYS_PERSONALITY_H",
          "1120:  long new_personality;",
          "1121: #endif",
          "1128:  uid_t new_uid;",
          "1129:  gid_t new_gid;",
          "",
          "[Removed Lines]",
          "1115:  struct attach_clone_payload* payload = (struct attach_clone_payload*)data;",
          "1116:  int ipc_socket = payload->ipc_socket;",
          "1117:  lxc_attach_options_t* options = payload->options;",
          "1118:  struct lxc_proc_context_info* init_ctx = payload->init_ctx;",
          "1122:  int ret;",
          "1123:  int status;",
          "1124:  int expected;",
          "1125:  long flags;",
          "1126:  int fd;",
          "1127:  int lsm_labelfd;",
          "",
          "[Added Lines]",
          "1133:  int expected, fd, lsm_labelfd, ret, status;",
          "1134:  long flags;",
          "1140:  struct attach_clone_payload* payload = (struct attach_clone_payload*)data;",
          "1141:  int ipc_socket = payload->ipc_socket;",
          "1142:  lxc_attach_options_t* options = payload->options;",
          "1143:  struct lxc_proc_context_info* init_ctx = payload->init_ctx;",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1149:   ret = lxc_attach_remount_sys_proc();",
          "1150:   if (ret < 0) {",
          "1151:    shutdown(ipc_socket, SHUT_RDWR);",
          "",
          "[Removed Lines]",
          "1148:  if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {",
          "",
          "[Added Lines]",
          "1162:  if (!(options->namespaces & CLONE_NEWNS) &&",
          "1163:      (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1186:  if (ret < 0) {",
          "1187:   ERROR(\"Could not set initial environment for attached process.\");",
          "1188:   shutdown(ipc_socket, SHUT_RDWR);",
          "",
          "[Removed Lines]",
          "1185:  ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);",
          "",
          "[Added Lines]",
          "1200:  ret = lxc_attach_set_environment(options->env_policy,",
          "1201:       options->extra_env_vars,",
          "1202:       options->extra_keep_env);",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1226:    rexit(-1);",
          "1227:   }",
          "1228:  }",
          "1230:   SYSERROR(\"Switching to container uid.\");",
          "1231:   shutdown(ipc_socket, SHUT_RDWR);",
          "1232:   rexit(-1);",
          "",
          "[Removed Lines]",
          "1229:  if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {",
          "",
          "[Added Lines]",
          "1246:  if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) &&",
          "1247:      setuid(new_uid)) {",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1276:   rexit(-1);",
          "1277:  }",
          "1280:   int on_exec;",
          "1282:   ret = lxc_abstract_unix_recv_fds(ipc_socket, &lsm_labelfd, 1, NULL, 0);",
          "",
          "[Removed Lines]",
          "1279:  if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "",
          "[Added Lines]",
          "1297:  if ((options->namespaces & CLONE_NEWNS) &&",
          "1298:      (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "",
          "---------------"
        ],
        "src/lxc/attach.h||src/lxc/attach.h": [
          "File: src/lxc/attach.h -> src/lxc/attach.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifndef __LXC_ATTACH_H",
          "25: #define __LXC_ATTACH_H",
          "28: #include <lxc/attach_options.h>",
          "30: struct lxc_conf;",
          "",
          "[Removed Lines]",
          "27: #include <sys/types.h>",
          "",
          "[Added Lines]",
          "28: #include <sys/types.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:  unsigned long long capability_mask;",
          "37: };",
          "",
          "[Removed Lines]",
          "39: extern int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process);",
          "41: #endif",
          "",
          "[Added Lines]",
          "39: extern int lxc_attach(const char *name, const char *lxcpath,",
          "40:         lxc_attach_exec_t exec_function, void *exec_payload,",
          "41:         lxc_attach_options_t *options, pid_t *attached_process);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ae467c546bb15f16cad3a83b958c19136cdd7e91",
      "candidate_info": {
        "commit_hash": "ae467c546bb15f16cad3a83b958c19136cdd7e91",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/ae467c546bb15f16cad3a83b958c19136cdd7e91",
        "files": [
          "src/lxc/af_unix.c",
          "src/lxc/af_unix.h",
          "src/lxc/attach.c",
          "src/lxc/commands.c",
          "src/lxc/conf.c",
          "src/lxc/start.c"
        ],
        "message": "af_unix: abstract lxc_abstract_unix_{send,recv}_fd\n\n- Enable lxc_abstract_unix_{send,recv}_fd() to send and receive multiple fds at\n  once.\n- lxc_abstract_unix_{send,recv}_fd() -> lxc_abstract_unix_{send,recv}_fds()\n- Send tty fds from child to parent all at once.\n\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/af_unix.c||src/lxc/af_unix.c",
          "src/lxc/af_unix.h||src/lxc/af_unix.h",
          "src/lxc/attach.c||src/lxc/attach.c",
          "src/lxc/commands.c||src/lxc/commands.c",
          "src/lxc/conf.c||src/lxc/conf.c",
          "src/lxc/start.c||src/lxc/start.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/af_unix.c||src/lxc/af_unix.c": [
          "File: src/lxc/af_unix.c -> src/lxc/af_unix.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "23: #include \"config.h\"",
          "25: #include <stddef.h>",
          "26: #include <string.h>",
          "27: #include <unistd.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "25: #include <stdio.h>",
          "26: #include <stdlib.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "133:  return fd;",
          "134: }",
          "137: {",
          "139:  struct iovec iov;",
          "142:  char buf[1] = {0};",
          "145:  msg.msg_control = cmsgbuf;",
          "148:  cmsg = CMSG_FIRSTHDR(&msg);",
          "150:  cmsg->cmsg_level = SOL_SOCKET;",
          "151:  cmsg->cmsg_type = SCM_RIGHTS;",
          "158:  iov.iov_base = data ? data : buf;",
          "159:  iov.iov_len = data ? size : sizeof(buf);",
          "160:  msg.msg_iov = &iov;",
          "161:  msg.msg_iovlen = 1;",
          "164: }",
          "167: {",
          "169:  struct iovec iov;",
          "173:  char buf[1] = {0};",
          "177:  msg.msg_control = cmsgbuf;",
          "180:  iov.iov_base = data ? data : buf;",
          "181:  iov.iov_len = data ? size : sizeof(buf);",
          "",
          "[Removed Lines]",
          "136: int lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size)",
          "138:  struct msghdr msg = { 0 };",
          "140:  struct cmsghdr *cmsg;",
          "141:  char cmsgbuf[CMSG_SPACE(sizeof(int))] = {0};",
          "143:  int *val;",
          "146:  msg.msg_controllen = sizeof(cmsgbuf);",
          "149:  cmsg->cmsg_len = CMSG_LEN(sizeof(int));",
          "152:  val = (int *)(CMSG_DATA(cmsg));",
          "155:  msg.msg_name = NULL;",
          "156:  msg.msg_namelen = 0;",
          "163:  return sendmsg(fd, &msg, MSG_NOSIGNAL);",
          "166: int lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size)",
          "168:  struct msghdr msg = { 0 };",
          "170:  struct cmsghdr *cmsg;",
          "171:  int ret, *val;",
          "172:  char cmsgbuf[CMSG_SPACE(sizeof(int))] = {0};",
          "175:  msg.msg_name = NULL;",
          "176:  msg.msg_namelen = 0;",
          "178:  msg.msg_controllen = sizeof(cmsgbuf);",
          "",
          "[Added Lines]",
          "138: int lxc_abstract_unix_send_fds(int fd, int *sendfds, int num_sendfds,",
          "139:           void *data, size_t size)",
          "141:  int ret;",
          "142:  struct msghdr msg;",
          "144:  struct cmsghdr *cmsg = NULL;",
          "146:  char *cmsgbuf;",
          "147:  size_t cmsgbufsize = CMSG_SPACE(num_sendfds * sizeof(int));",
          "149:  memset(&msg, 0, sizeof(msg));",
          "150:  memset(&iov, 0, sizeof(iov));",
          "152:  cmsgbuf = malloc(cmsgbufsize);",
          "153:  if (!cmsgbuf)",
          "154:   return -1;",
          "157:  msg.msg_controllen = cmsgbufsize;",
          "162:  cmsg->cmsg_len = CMSG_LEN(num_sendfds * sizeof(int));",
          "164:  msg.msg_controllen = cmsg->cmsg_len;",
          "166:  memcpy(CMSG_DATA(cmsg), sendfds, num_sendfds * sizeof(int));",
          "173:  ret = sendmsg(fd, &msg, MSG_NOSIGNAL);",
          "174:  free(cmsgbuf);",
          "175:  return ret;",
          "178: int lxc_abstract_unix_recv_fds(int fd, int *recvfds, int num_recvfds,",
          "179:           void *data, size_t size)",
          "181:  int ret;",
          "182:  struct msghdr msg;",
          "184:  struct cmsghdr *cmsg = NULL;",
          "186:  char *cmsgbuf;",
          "187:  size_t cmsgbufsize = CMSG_SPACE(num_recvfds * sizeof(int));",
          "189:  memset(&msg, 0, sizeof(msg));",
          "190:  memset(&iov, 0, sizeof(iov));",
          "192:  cmsgbuf = malloc(cmsgbufsize);",
          "193:  if (!cmsgbuf)",
          "194:   return -1;",
          "197:  msg.msg_controllen = cmsgbufsize;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "189:  cmsg = CMSG_FIRSTHDR(&msg);",
          "200:  }",
          "201: out:",
          "202:  return ret;",
          "203: }",
          "",
          "[Removed Lines]",
          "195:  if (cmsg && cmsg->cmsg_len == CMSG_LEN(sizeof(int)) &&",
          "196:    cmsg->cmsg_level == SOL_SOCKET &&",
          "197:    cmsg->cmsg_type == SCM_RIGHTS) {",
          "198:   val = (int *) CMSG_DATA(cmsg);",
          "",
          "[Added Lines]",
          "210:  memset(recvfds, -1, num_recvfds * sizeof(int));",
          "211:  if (cmsg && cmsg->cmsg_len == CMSG_LEN(num_recvfds * sizeof(int)) &&",
          "212:      cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {",
          "213:   memcpy(recvfds, CMSG_DATA(cmsg), num_recvfds * sizeof(int));",
          "217:  free(cmsgbuf);",
          "",
          "---------------"
        ],
        "src/lxc/af_unix.h||src/lxc/af_unix.h": [
          "File: src/lxc/af_unix.h -> src/lxc/af_unix.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #ifndef __LXC_AF_UNIX_H",
          "25: #define __LXC_AF_UNIX_H",
          "28: extern int lxc_abstract_unix_open(const char *path, int type, int flags);",
          "29: extern int lxc_abstract_unix_close(int fd);",
          "31: extern int lxc_abstract_unix_connect(const char *path);",
          "34: extern int lxc_abstract_unix_send_credential(int fd, void *data, size_t size);",
          "35: extern int lxc_abstract_unix_rcv_credential(int fd, void *data, size_t size);",
          "",
          "[Removed Lines]",
          "32: extern int lxc_abstract_unix_send_fd(int fd, int sendfd, void *data, size_t size);",
          "33: extern int lxc_abstract_unix_recv_fd(int fd, int *recvfd, void *data, size_t size);",
          "",
          "[Added Lines]",
          "27: #include <stdio.h>",
          "34: extern int lxc_abstract_unix_send_fds(int fd, int *sendfds, int num_sendfds,",
          "35:           void *data, size_t size);",
          "36: extern int lxc_abstract_unix_recv_fds(int fd, int *recvfds, int num_recvfds,",
          "37:           void *data, size_t size);",
          "",
          "---------------"
        ],
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "986:     goto on_error;",
          "990:    saved_errno = errno;",
          "991:    close(labelfd);",
          "992:    if (ret <= 0) {",
          "",
          "[Removed Lines]",
          "989:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
          "",
          "[Added Lines]",
          "989:    ret = lxc_abstract_unix_send_fds(ipc_sockets[0], &labelfd, 1, NULL, 0);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1273:  if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "1274:   int on_exec;",
          "1277:   if (ret <= 0) {",
          "1278:    ERROR(\"Expected to receive file descriptor: %s.\", strerror(errno));",
          "1279:    shutdown(ipc_socket, SHUT_RDWR);",
          "",
          "[Removed Lines]",
          "1276:   ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);",
          "",
          "[Added Lines]",
          "1276:   ret = lxc_abstract_unix_recv_fds(ipc_socket, &lsm_labelfd, 1, NULL, 0);",
          "",
          "---------------"
        ],
        "src/lxc/commands.c||src/lxc/commands.c": [
          "File: src/lxc/commands.c -> src/lxc/commands.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:  int ret,rspfd;",
          "172:  struct lxc_cmd_rsp *rsp = &cmd->rsp;",
          "175:  if (ret < 0) {",
          "176:   WARN(\"Command %s failed to receive response: %s.\",",
          "177:        lxc_cmd_str(cmd->req.cmd), strerror(errno));",
          "",
          "[Removed Lines]",
          "174:  ret = lxc_abstract_unix_recv_fd(sock, &rspfd, rsp, sizeof(*rsp));",
          "",
          "[Added Lines]",
          "174:  ret = lxc_abstract_unix_recv_fds(sock, &rspfd, 1, rsp, sizeof(*rsp));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "757:  memset(&rsp, 0, sizeof(rsp));",
          "758:  rsp.data = INT_TO_PTR(ttynum);",
          "760:   ERROR(\"Failed to send tty to client.\");",
          "761:   lxc_console_free(handler->conf, fd);",
          "762:   goto out_close;",
          "",
          "[Removed Lines]",
          "759:  if (lxc_abstract_unix_send_fd(fd, masterfd, &rsp, sizeof(rsp)) < 0) {",
          "",
          "[Added Lines]",
          "759:  if (lxc_abstract_unix_send_fds(fd, &masterfd, 1, &rsp, sizeof(rsp)) < 0) {",
          "",
          "---------------"
        ],
        "src/lxc/conf.c||src/lxc/conf.c": [
          "File: src/lxc/conf.c -> src/lxc/conf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4093:  return true;",
          "4094: }",
          "4097: {",
          "4112:  struct lxc_conf *conf = handler->conf;",
          "4113:  const struct lxc_tty_info *tty_info = &conf->tty_info;",
          "4114:  int sock = handler->ttysock[0];",
          "4122:         \"parent\",",
          "4123:         pty_info->name, pty_info->master, pty_info->slave);",
          "4135:  }",
          "4137:  close(handler->ttysock[0]);",
          "4138:  close(handler->ttysock[1]);",
          "4145: }",
          "4147: int lxc_setup(struct lxc_handler *handler)",
          "",
          "[Removed Lines]",
          "4096: static int send_fd(int sock, int fd)",
          "4098:  int ret = lxc_abstract_unix_send_fd(sock, fd, NULL, 0);",
          "4101:  if (ret < 0) {",
          "4102:   SYSERROR(\"Error sending tty fd to parent\");",
          "4103:   return -1;",
          "4104:  }",
          "4106:  return 0;",
          "4107: }",
          "4109: static int send_ttys_to_parent(struct lxc_handler *handler)",
          "4110: {",
          "4111:  int i, ret;",
          "4116:  for (i = 0; i < tty_info->nbtty; i++) {",
          "4117:   struct lxc_pty_info *pty_info = &tty_info->pty_info[i];",
          "4118:   ret = send_fd(sock, pty_info->slave);",
          "4119:   if (ret >= 0)",
          "4120:    send_fd(sock, pty_info->master);",
          "4121:   TRACE(\"sending pty \\\"%s\\\" with master fd %d and slave fd %d to \"",
          "4124:   close(pty_info->slave);",
          "4125:   pty_info->slave = -1;",
          "4126:   close(pty_info->master);",
          "4127:   pty_info->master = -1;",
          "4128:   if (ret < 0) {",
          "4129:    ERROR(\"failed to send pty \\\"%s\\\" with master fd %d and \"",
          "4130:          \"slave fd %d to parent : %s\",",
          "4131:          pty_info->name, pty_info->master, pty_info->slave,",
          "4132:          strerror(errno));",
          "4133:    goto bad;",
          "4134:   }",
          "4140:  return 0;",
          "4142: bad:",
          "4143:  ERROR(\"Error writing tty fd to parent\");",
          "4144:  return -1;",
          "",
          "[Added Lines]",
          "4096: static int lxc_send_ttys_to_parent(struct lxc_handler *handler)",
          "4098:  int i;",
          "4099:  int *ttyfds;",
          "4100:  struct lxc_pty_info *pty_info;",
          "4104:  int ret = -1;",
          "4105:  size_t num_ttyfds = (2 * conf->tty);",
          "4107:  ttyfds = malloc(num_ttyfds * sizeof(int));",
          "4108:  if (!ttyfds)",
          "4109:   return -1;",
          "4111:  for (i = 0; i < num_ttyfds; i++) {",
          "4112:   pty_info = &tty_info->pty_info[i / 2];",
          "4113:   ttyfds[i++] = pty_info->slave;",
          "4114:   ttyfds[i] = pty_info->master;",
          "4115:   TRACE(\"send pty \\\"%s\\\" with master fd %d and slave fd %d to \"",
          "4120:  ret = lxc_abstract_unix_send_fds(sock, ttyfds, num_ttyfds, NULL, 0);",
          "4121:  if (ret < 0)",
          "4122:   ERROR(\"failed to send %d ttys to parent: %s\", conf->tty,",
          "4123:         strerror(errno));",
          "4124:  else",
          "4125:   TRACE(\"sent %d ttys to parent\", conf->tty);",
          "4130:  for (i = 0; i < num_ttyfds; i++)",
          "4131:   close(ttyfds[i]);",
          "4133:  free(ttyfds);",
          "4135:  return ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4260:   return -1;",
          "4261:  }",
          "4264:   ERROR(\"failure sending console info to parent\");",
          "4265:   return -1;",
          "4266:  }",
          "",
          "[Removed Lines]",
          "4263:  if (send_ttys_to_parent(handler) < 0) {",
          "",
          "[Added Lines]",
          "4254:  if (lxc_send_ttys_to_parent(handler) < 0) {",
          "",
          "---------------"
        ],
        "src/lxc/start.c||src/lxc/start.c": [
          "File: src/lxc/start.c -> src/lxc/start.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1008:  return 0;",
          "1009: }",
          "1012: {",
          "1025:  int sock = handler->ttysock[1];",
          "1026:  struct lxc_conf *conf = handler->conf;",
          "1027:  struct lxc_tty_info *tty_info = &conf->tty_info;",
          "1029:  if (!conf->tty)",
          "1030:   return 0;",
          "",
          "[Removed Lines]",
          "1011: static int recv_fd(int sock, int *fd)",
          "1013:  if (lxc_abstract_unix_recv_fd(sock, fd, NULL, 0) < 0) {",
          "1014:   SYSERROR(\"Error receiving tty file descriptor from child process.\");",
          "1015:   return -1;",
          "1016:  }",
          "1017:  if (*fd == -1)",
          "1018:   return -1;",
          "1019:  return 0;",
          "1020: }",
          "1022: static int recv_ttys_from_child(struct lxc_handler *handler)",
          "1023: {",
          "1024:  int i, ret;",
          "",
          "[Added Lines]",
          "1011: static int lxc_recv_ttys_from_child(struct lxc_handler *handler)",
          "1013:  int i;",
          "1014:  int *ttyfds;",
          "1015:  struct lxc_pty_info *pty_info;",
          "1016:  int ret = -1;",
          "1020:  size_t num_ttyfds = (2 * conf->tty);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1033:  if (!tty_info->pty_info)",
          "1034:   return -1;",
          "1038:   pty_info->busy = 0;",
          "1051:  }",
          "1052:  tty_info->nbtty = conf->tty;",
          "1055: }",
          "1057: void resolve_clone_flags(struct lxc_handler *handler)",
          "",
          "[Removed Lines]",
          "1036:  for (i = 0; i < conf->tty; i++) {",
          "1037:   struct lxc_pty_info *pty_info = &tty_info->pty_info[i];",
          "1039:   ret = recv_fd(sock, &pty_info->slave);",
          "1040:   if (ret >= 0)",
          "1041:    recv_fd(sock, &pty_info->master);",
          "1042:   if (ret < 0) {",
          "1043:    ERROR(\"failed to receive pty with master fd %d and \"",
          "1044:          \"slave fd %d from child: %s\",",
          "1045:          pty_info->master, pty_info->slave,",
          "1046:          strerror(errno));",
          "1047:    return -1;",
          "1048:   }",
          "1049:   TRACE(\"received pty with master fd %d and slave fd %d from child\",",
          "1050:         pty_info->master, pty_info->slave);",
          "1054:  return 0;",
          "",
          "[Added Lines]",
          "1029:  ttyfds = malloc(num_ttyfds * sizeof(int));",
          "1030:  if (!ttyfds)",
          "1031:   return -1;",
          "1033:  ret = lxc_abstract_unix_recv_fds(sock, ttyfds, num_ttyfds, NULL, 0);",
          "1034:  for (i = 0; (ret >= 0 && *ttyfds != -1) && (i < num_ttyfds); i++) {",
          "1035:   pty_info = &tty_info->pty_info[i / 2];",
          "1037:   pty_info->slave = ttyfds[i++];",
          "1038:   pty_info->master = ttyfds[i];",
          "1039:   TRACE(\"received pty with master fd %d and slave fd %d from \"",
          "1040:         \"parent\", pty_info->master, pty_info->slave);",
          "1045:  free(ttyfds);",
          "1047:  if (ret < 0)",
          "1048:   ERROR(\"failed to receive %d ttys from child: %s\", conf->tty,",
          "1049:         strerror(errno));",
          "1050:  else",
          "1051:   TRACE(\"received %d ttys from child\", conf->tty);",
          "1053:  return ret;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1294:  cgroups_connected = false;",
          "1298:   ERROR(\"Failed to receive tty info from child process.\");",
          "1299:   goto out_delete_net;",
          "1300:  }",
          "",
          "[Removed Lines]",
          "1297:  if (recv_ttys_from_child(handler) < 0) {",
          "",
          "[Added Lines]",
          "1296:  if (lxc_recv_ttys_from_child(handler) < 0) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1d8e5ca2dfe4443449b35ae082c1d83ab74c903f",
      "candidate_info": {
        "commit_hash": "1d8e5ca2dfe4443449b35ae082c1d83ab74c903f",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/1d8e5ca2dfe4443449b35ae082c1d83ab74c903f",
        "files": [
          "src/lxc/attach.c"
        ],
        "message": "attach: close lsm label file descriptor\n\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "974:   if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {",
          "976:    on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;",
          "978:    labelfd = lsm_openat(procfd, attached_pid, on_exec);",
          "",
          "[Removed Lines]",
          "975:    int on_exec, labelfd;",
          "",
          "[Added Lines]",
          "975:    int on_exec;",
          "976:    int labelfd = -1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "983:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
          "984:    if (ret <= 0) {",
          "985:     ERROR(\"Intended to send file descriptor %d: %s.\", labelfd, strerror(errno));",
          "986:     goto on_error;",
          "987:    }",
          "988:   }",
          "991:   shutdown(ipc_sockets[0], SHUT_RDWR);",
          "992:   close(ipc_sockets[0]);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "985:    close(labelfd);",
          "992:   if (procfd >= 0)",
          "993:    close(procfd);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8ce83369ef2eb2f981317f63cf885925c81e75c9",
      "candidate_info": {
        "commit_hash": "8ce83369ef2eb2f981317f63cf885925c81e75c9",
        "repo": "lxc/lxc",
        "commit_url": "https://github.com/lxc/lxc/commit/8ce83369ef2eb2f981317f63cf885925c81e75c9",
        "files": [
          "src/lxc/attach.c"
        ],
        "message": "attach: non-functional changes\n\n- improve logging\n- simplify functions\n\nSigned-off-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "before_after_code_files": [
          "src/lxc/attach.c||src/lxc/attach.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ],
          "candidate": [
            "src/lxc/attach.c||src/lxc/attach.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lxc/attach.c||src/lxc/attach.c": [
          "File: src/lxc/attach.c -> src/lxc/attach.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:   command = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);",
          "147:   if (!command) {",
          "149:    goto out;",
          "150:   }",
          "152:   size = sprintf(command, \"changeprofile %s\", lsm_label);",
          "153:   if (size < 0) {",
          "155:    goto out;",
          "156:   }",
          "",
          "[Removed Lines]",
          "148:    SYSERROR(\"Failed to write apparmor profile\");",
          "154:    SYSERROR(\"Failed to write apparmor profile\");",
          "",
          "[Added Lines]",
          "148:    SYSERROR(\"Failed to write apparmor profile.\");",
          "154:    SYSERROR(\"Failed to write apparmor profile.\");",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "162:   INFO(\"Set LSM label to: %s.\", command);",
          "163:  } else if (strcmp(name, \"SELinux\") == 0) {",
          "164:   if (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {",
          "166:    goto out;",
          "167:   }",
          "168:   INFO(\"Set LSM label to: %s.\", lsm_label);",
          "169:  } else {",
          "171:   goto out;",
          "172:  }",
          "173:  fret = 0;",
          "",
          "[Removed Lines]",
          "165:    SYSERROR(\"Unable to set LSM label\");",
          "170:   ERROR(\"Unable to restore label for unknown LSM: %s\", name);",
          "",
          "[Added Lines]",
          "165:    SYSERROR(\"Unable to set LSM label: %s.\", lsm_label);",
          "170:   ERROR(\"Unable to restore label for unknown LSM: %s.\", name);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "181:  return fret;",
          "182: }",
          "184: static struct lxc_proc_context_info *lxc_proc_get_context_info(pid_t pid)",
          "185: {",
          "187:  FILE *proc_file;",
          "189:  char *line = NULL;",
          "190:  size_t line_bufsz = 0;",
          "201:  proc_file = fopen(proc_fn, \"r\");",
          "202:  if (!proc_file) {",
          "205:  }",
          "208:  while (getline(&line, &line_bufsz, proc_file) != -1) {",
          "209:   ret = sscanf(line, \"CapBnd: %llx\", &info->capability_mask);",
          "212:    break;",
          "213:   }",
          "214:  }",
          "",
          "[Removed Lines]",
          "186:  struct lxc_proc_context_info *info = calloc(1, sizeof(*info));",
          "188:  char proc_fn[MAXPATHLEN];",
          "191:  int ret, found;",
          "193:  if (!info) {",
          "194:   SYSERROR(\"Could not allocate memory.\");",
          "195:   return NULL;",
          "196:  }",
          "199:  snprintf(proc_fn, MAXPATHLEN, \"/proc/%d/status\", pid);",
          "203:   SYSERROR(\"Could not open %s\", proc_fn);",
          "204:   goto out_error;",
          "207:  found = 0;",
          "210:   if (ret != EOF && ret > 0) {",
          "211:    found = 1;",
          "",
          "[Added Lines]",
          "185: #define __PROC_STATUS_LEN (5 + 21 + 7 + 1)",
          "189:  char proc_fn[__PROC_STATUS_LEN];",
          "190:  bool found;",
          "191:  int ret;",
          "194:  struct lxc_proc_context_info *info = NULL;",
          "197:  ret = snprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", pid);",
          "198:  if (ret < 0 || ret >= __PROC_STATUS_LEN)",
          "199:   goto on_error;",
          "203:   SYSERROR(\"Could not open %s.\", proc_fn);",
          "204:   goto on_error;",
          "207:  info = calloc(1, sizeof(*info));",
          "208:  if (!info) {",
          "209:   SYSERROR(\"Could not allocate memory.\");",
          "210:   return NULL;",
          "211:  }",
          "213:  found = false;",
          "216:   if (ret != EOF && ret == 1) {",
          "217:    found = true;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "217:  fclose(proc_file);",
          "219:  if (!found) {",
          "221:   errno = ENOENT;",
          "223:  }",
          "225:  info->lsm_label = lsm_process_label_get(pid);",
          "227:  return info;",
          "230:  free(info);",
          "231:  return NULL;",
          "232: }",
          "",
          "[Removed Lines]",
          "220:   SYSERROR(\"Could not read capability bounding set from %s\", proc_fn);",
          "222:   goto out_error;",
          "229: out_error:",
          "",
          "[Added Lines]",
          "226:   SYSERROR(\"Could not read capability bounding set from %s.\", proc_fn);",
          "228:   goto on_error;",
          "235: on_error:",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "248:  if (access(\"/proc/self/ns\", X_OK)) {",
          "250:   return -1;",
          "251:  }",
          "253:  for (i = 0; i < LXC_NS_MAX; i++) {",
          "257:   if (which != -1 && !(which & ns_info[i].clone_flag)) {",
          "258:    fd[i] = -1;",
          "259:    continue;",
          "",
          "[Removed Lines]",
          "249:   ERROR(\"Does this kernel version support 'attach' ?\");",
          "",
          "[Added Lines]",
          "255:   ERROR(\"Does this kernel version support namespaces?\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "263:   if (fd[i] < 0) {",
          "264:    saved_errno = errno;",
          "269:    for (j = 0; j < i; j++)",
          "270:     close(fd[j]);",
          "272:    errno = saved_errno;",
          "274:    return -1;",
          "275:   }",
          "276:  }",
          "",
          "[Removed Lines]",
          "273:    SYSERROR(\"failed to open namespace: '%s'.\", ns_info[i].proc_name);",
          "",
          "[Added Lines]",
          "277:    SYSERROR(\"Failed to open namespace: \\\"%s\\\".\", ns_info[i].proc_name);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "305:  ret = unshare(CLONE_NEWNS);",
          "306:  if (ret < 0) {",
          "308:   return -1;",
          "309:  }",
          "311:  if (detect_shared_rootfs()) {",
          "312:   if (mount(NULL, \"/\", NULL, MS_SLAVE|MS_REC, NULL)) {",
          "314:    ERROR(\"Continuing...\");",
          "315:   }",
          "316:  }",
          "319:  ret = umount2(\"/proc\", MNT_DETACH);",
          "320:  if (ret < 0) {",
          "322:   return -1;",
          "323:  }",
          "325:  ret = mount(\"none\", \"/proc\", \"proc\", 0, NULL);",
          "326:  if (ret < 0) {",
          "328:   return -1;",
          "329:  }",
          "335:  ret = umount2(\"/sys\", MNT_DETACH);",
          "336:  if (ret < 0 && errno != EINVAL) {",
          "338:   return -1;",
          "339:  } else if (ret == 0) {",
          "341:   ret = mount(\"none\", \"/sys\", \"sysfs\", 0, NULL);",
          "342:   if (ret < 0) {",
          "344:    return -1;",
          "345:   }",
          "346:  }",
          "",
          "[Removed Lines]",
          "307:   SYSERROR(\"failed to unshare mount namespace\");",
          "313:    SYSERROR(\"Failed to make / rslave\");",
          "321:   SYSERROR(\"failed to unmount /proc\");",
          "327:   SYSERROR(\"failed to remount /proc\");",
          "337:   SYSERROR(\"failed to unmount /sys\");",
          "343:    SYSERROR(\"failed to remount /sys\");",
          "",
          "[Added Lines]",
          "311:   SYSERROR(\"Failed to unshare mount namespace.\");",
          "317:    SYSERROR(\"Failed to make / rslave.\");",
          "325:   SYSERROR(\"Failed to unmount /proc.\");",
          "331:   SYSERROR(\"Failed to remount /proc.\");",
          "340:   SYSERROR(\"Failed to unmount /sys.\");",
          "346:    SYSERROR(\"Failed to remount /sys.\");",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "358:    continue;",
          "360:   if (prctl(PR_CAPBSET_DROP, cap, 0, 0, 0)) {",
          "362:    return -1;",
          "363:   }",
          "364:  }",
          "",
          "[Removed Lines]",
          "361:    SYSERROR(\"failed to remove capability id %d\", cap);",
          "",
          "[Added Lines]",
          "364:    SYSERROR(\"Failed to remove capability id %d.\", cap);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "380:    extra_keep_store = calloc(count, sizeof(char *));",
          "381:    if (!extra_keep_store) {",
          "384:     return -1;",
          "385:    }",
          "386:    for (i = 0; i < count; i++) {",
          "",
          "[Removed Lines]",
          "382:     SYSERROR(\"failed to allocate memory for storing current \"",
          "383:              \"environment variable values that will be kept\");",
          "",
          "[Added Lines]",
          "385:     SYSERROR(\"Failed to allocate memory for storing current \"",
          "386:              \"environment variable values that will be kept.\");",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "388:     if (v) {",
          "389:      extra_keep_store[i] = strdup(v);",
          "390:      if (!extra_keep_store[i]) {",
          "393:       while (i > 0)",
          "394:        free(extra_keep_store[--i]);",
          "395:       free(extra_keep_store);",
          "",
          "[Removed Lines]",
          "391:       SYSERROR(\"failed to allocate memory for storing current \"",
          "392:                \"environment variable values that will be kept\");",
          "",
          "[Added Lines]",
          "394:       SYSERROR(\"Failed to allocate memory for storing current \"",
          "395:                \"environment variable values that will be kept.\");",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "398:      if (strcmp(extra_keep[i], \"PATH\") == 0)",
          "399:       path_kept = 1;",
          "400:     }",
          "403:    }",
          "404:   }",
          "406:   if (clearenv()) {",
          "407:    char **p;",
          "409:    if (extra_keep_store) {",
          "410:     for (p = extra_keep_store; *p; p++)",
          "411:      free(*p);",
          "",
          "[Removed Lines]",
          "408:    SYSERROR(\"failed to clear environment\");",
          "",
          "[Added Lines]",
          "412:    SYSERROR(\"Failed to clear environment.\");",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "419:    for (i = 0; extra_keep[i]; i++) {",
          "420:     if (extra_keep_store[i]) {",
          "421:      if (setenv(extra_keep[i], extra_keep_store[i], 1) < 0)",
          "423:     }",
          "424:     free(extra_keep_store[i]);",
          "425:    }",
          "426:    free(extra_keep_store);",
          "427:   }",
          "434:   if (!path_kept)",
          "435:    setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1);",
          "436:  }",
          "438:  if (putenv(\"container=lxc\")) {",
          "440:   return -1;",
          "441:  }",
          "444:  if (extra_env) {",
          "445:   for (; *extra_env; extra_env++) {",
          "449:    char *p = strdup(*extra_env);",
          "452:    if (!p) {",
          "455:     return -1;",
          "456:    }",
          "457:    putenv(p);",
          "",
          "[Removed Lines]",
          "422:       SYSERROR(\"Unable to set environment variable\");",
          "439:   SYSERROR(\"failed to set environment variable\");",
          "453:     SYSERROR(\"failed to allocate memory for additional environment \"",
          "454:              \"variables\");",
          "",
          "[Added Lines]",
          "426:       SYSERROR(\"Unable to set environment variable.\");",
          "443:   SYSERROR(\"Failed to set environment variable.\");",
          "458:     SYSERROR(\"Failed to allocate memory for additional environment \"",
          "459:              \"variables.\");",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "617: static void lxc_attach_get_init_uidgid(uid_t* init_uid, gid_t* init_gid)",
          "618: {",
          "619:  FILE *proc_file;",
          "621:  char *line = NULL;",
          "622:  size_t line_bufsz = 0;",
          "624:  long value = -1;",
          "625:  uid_t uid = (uid_t)-1;",
          "626:  gid_t gid = (gid_t)-1;",
          "631:  proc_file = fopen(proc_fn, \"r\");",
          "632:  if (!proc_file)",
          "633:   return;",
          "635:  while (getline(&line, &line_bufsz, proc_file) != -1) {",
          "639:   ret = sscanf(line, \"Uid: %ld\", &value);",
          "641:    uid = (uid_t) value;",
          "642:   } else {",
          "643:    ret = sscanf(line, \"Gid: %ld\", &value);",
          "645:     gid = (gid_t) value;",
          "646:   }",
          "647:   if (uid != (uid_t)-1 && gid != (gid_t)-1)",
          "",
          "[Removed Lines]",
          "620:  char proc_fn[MAXPATHLEN];",
          "623:  int ret;",
          "629:  snprintf(proc_fn, MAXPATHLEN, \"/proc/%d/status\", 1);",
          "640:   if (ret != EOF && ret > 0) {",
          "644:    if (ret != EOF && ret > 0)",
          "",
          "[Added Lines]",
          "620:  char proc_fn[__PROC_STATUS_LEN];",
          "621:  int ret;",
          "629:  snprintf(proc_fn, __PROC_STATUS_LEN, \"/proc/%d/status\", 1);",
          "640:   if (ret != EOF && ret == 1) {",
          "644:    if (ret != EOF && ret == 1)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "693:   return false;",
          "694:  }",
          "697:  path = c->get_running_config_item(c, \"lxc.seccomp\");",
          "698:  if (!path) {",
          "699:   INFO(\"Failed to get running config item for lxc.seccomp.\");",
          "700:   return true;",
          "701:  }",
          "704:  if (!c->set_config_item(c, \"lxc.seccomp\", path)) {",
          "705:   free(path);",
          "706:   return false;",
          "707:  }",
          "708:  free(path);",
          "711:  if (lxc_read_seccomp_config(c->lxc_conf) < 0) {",
          "713:   return false;",
          "714:  }",
          "",
          "[Removed Lines]",
          "712:   ERROR(\"Error reading seccomp policy\");",
          "",
          "[Added Lines]",
          "713:   ERROR(\"Error reading seccomp policy.\");",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "772:  init_pid = lxc_cmd_get_init_pid(name, lxcpath);",
          "773:  if (init_pid < 0) {",
          "775:   return -1;",
          "776:  }",
          "778:  init_ctx = lxc_proc_get_context_info(init_pid);",
          "779:  if (!init_ctx) {",
          "781:   return -1;",
          "782:  }",
          "784:  personality = get_personality(name, lxcpath);",
          "785:  if (init_ctx->personality < 0) {",
          "787:   lxc_proc_put_context_info(init_ctx);",
          "788:   return -1;",
          "789:  }",
          "",
          "[Removed Lines]",
          "774:   ERROR(\"failed to get the init pid\");",
          "780:   ERROR(\"failed to get context of the init process, pid = %ld\", (long)init_pid);",
          "786:   ERROR(\"Failed to get personality of the container\");",
          "",
          "[Added Lines]",
          "775:   ERROR(\"Failed to get init pid.\");",
          "781:   ERROR(\"Failed to get context of init process: %ld.\",",
          "782:         (long)init_pid);",
          "788:   ERROR(\"Failed to get personality of the container.\");",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "794:   return -1;",
          "796:  if (!fetch_seccomp(init_ctx->container, options))",
          "799:  if (!no_new_privs(init_ctx->container, options))",
          "800:   WARN(\"Could not determine whether PR_SET_NO_NEW_PRIVS is set.\");",
          "802:  cwd = getcwd(NULL, 0);",
          "807:  if (options->namespaces == -1) {",
          "808:   options->namespaces = lxc_cmd_get_clone_flags(name, lxcpath);",
          "810:   if (options->namespaces == -1) {",
          "813:    free(cwd);",
          "814:    lxc_proc_put_context_info(init_ctx);",
          "815:    return -1;",
          "816:   }",
          "817:  }",
          "",
          "[Removed Lines]",
          "797:   WARN(\"Failed to get seccomp policy\");",
          "811:    ERROR(\"failed to automatically determine the \"",
          "812:          \"namespaces which the container unshared\");",
          "",
          "[Added Lines]",
          "799:   WARN(\"Failed to get seccomp policy.\");",
          "813:    ERROR(\"Failed to automatically determine the \"",
          "814:          \"namespaces which the container uses.\");",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "851:  ret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);",
          "852:  if (ret < 0) {",
          "854:   free(cwd);",
          "855:   lxc_proc_put_context_info(init_ctx);",
          "856:   return -1;",
          "857:  }",
          "871:  pid = fork();",
          "873:  if (pid < 0) {",
          "875:   free(cwd);",
          "876:   lxc_proc_put_context_info(init_ctx);",
          "877:   return -1;",
          "",
          "[Removed Lines]",
          "853:   SYSERROR(\"could not set up required IPC mechanism for attaching\");",
          "874:   SYSERROR(\"failed to create first subprocess\");",
          "",
          "[Added Lines]",
          "856:   SYSERROR(\"Could not set up required IPC mechanism for attaching.\");",
          "875:   SYSERROR(\"Failed to create first subprocess.\");",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "881:   int procfd = -1;",
          "882:   pid_t to_cleanup_pid = pid;",
          "887:   close(ipc_sockets[1]);",
          "888:   free(cwd);",
          "891:   if (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {",
          "892:    if (!cgroup_attach(name, lxcpath, pid))",
          "894:   }",
          "",
          "[Removed Lines]",
          "893:     goto cleanup_error;",
          "",
          "[Added Lines]",
          "894:     goto on_error;",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "899:   procfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);",
          "900:   if (procfd < 0) {",
          "901:    SYSERROR(\"Unable to open /proc.\");",
          "903:   }",
          "906:   status = 0;",
          "907:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
          "908:   if (ret <= 0) {",
          "911:   }",
          "914:   ret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);",
          "915:   if (ret <= 0) {",
          "916:    if (ret != 0)",
          "919:   }",
          "922:   if (options->stdin_fd == 0) {",
          "923:    signal(SIGINT, SIG_IGN);",
          "924:    signal(SIGQUIT, SIG_IGN);",
          "925:   }",
          "928:   ret = wait_for_pid(pid);",
          "929:   if (ret < 0)",
          "933:   to_cleanup_pid = attached_pid;",
          "936:   status = 0;",
          "937:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
          "938:   if (ret <= 0) {",
          "941:   }",
          "944:   expected = 1;",
          "945:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
          "946:   if (ret <= 0) {",
          "947:    if (ret != 0)",
          "951:   }",
          "954:   status = 2;",
          "955:   ret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));",
          "956:   if (ret <= 0) {",
          "960:   }",
          "",
          "[Removed Lines]",
          "902:    goto cleanup_error;",
          "909:    ERROR(\"error using IPC to notify attached process for initialization (0)\");",
          "910:    goto cleanup_error;",
          "917:     ERROR(\"error using IPC to receive pid of attached process\");",
          "918:    goto cleanup_error;",
          "930:    goto cleanup_error;",
          "939:    ERROR(\"error using IPC to notify attached process for initialization (0)\");",
          "940:    goto cleanup_error;",
          "948:     ERROR(\"error using IPC to receive notification \"",
          "949:           \"from attached process (1)\");",
          "950:    goto cleanup_error;",
          "957:    ERROR(\"Error using IPC to notify attached process for \"",
          "958:          \"initialization (2): %s.\", strerror(errno));",
          "959:    goto cleanup_error;",
          "",
          "[Added Lines]",
          "903:    goto on_error;",
          "910:    ERROR(\"Intended to send sequence number 0: %s.\",",
          "911:          strerror(errno));",
          "912:    goto on_error;",
          "919:     ERROR(\"Expected to receive pid: %s.\", strerror(errno));",
          "920:    goto on_error;",
          "932:    goto on_error;",
          "941:    ERROR(\"Intended to send sequence number 0: %s.\", strerror(errno));",
          "942:    goto on_error;",
          "950:     ERROR(\"Expected to receive sequence number 1: %s.\", strerror(errno));",
          "951:    goto on_error;",
          "958:    ERROR(\"Intended to send sequence number 2: %s.\", strerror(errno));",
          "959:    goto on_error;",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "965:   expected = 3;",
          "966:   ret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);",
          "967:   if (ret <= 0) {",
          "969:          strerror(errno));",
          "971:   }",
          "",
          "[Removed Lines]",
          "968:    ERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",",
          "970:    goto cleanup_error;",
          "",
          "[Added Lines]",
          "968:    ERROR(\"Expected to receive sequence number 3: %s.\",",
          "970:    goto on_error;",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "978:    labelfd = lsm_openat(procfd, attached_pid, on_exec);",
          "979:    if (labelfd < 0)",
          "983:    ret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);",
          "984:    if (ret <= 0) {",
          "988:    }",
          "989:   }",
          "992:   shutdown(ipc_sockets[0], SHUT_RDWR);",
          "993:   close(ipc_sockets[0]);",
          "994:   lxc_proc_put_context_info(init_ctx);",
          "1002:   return 0;",
          "1008:   if (procfd >= 0)",
          "1009:    close(procfd);",
          "",
          "[Removed Lines]",
          "980:     goto cleanup_error;",
          "985:     ERROR(\"Error using IPC to send child LSM fd (4): %s.\",",
          "986:       strerror(errno));",
          "987:     goto cleanup_error;",
          "1004:  cleanup_error:",
          "",
          "[Added Lines]",
          "980:     goto on_error;",
          "985:     ERROR(\"Intended to send file descriptor %d: %s.\", labelfd, strerror(errno));",
          "986:     goto on_error;",
          "1003:  on_error:",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "1015:   return -1;",
          "1016:  }",
          "1021:  close(ipc_sockets[0]);",
          "1024:  expected = 0;",
          "1025:  status = -1;",
          "1026:  ret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);",
          "1027:  if (ret <= 0) {",
          "1029:   shutdown(ipc_sockets[1], SHUT_RDWR);",
          "1030:   rexit(-1);",
          "1031:  }",
          "",
          "[Removed Lines]",
          "1028:   ERROR(\"error communicating with child process\");",
          "",
          "[Added Lines]",
          "1027:   ERROR(\"Expected to receive sequence number 0: %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "1033:  if ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())",
          "1034:   options->namespaces |= CLONE_NEWCGROUP;",
          "1039:  ret = lxc_attach_to_ns(init_pid, options->namespaces);",
          "1040:  if (ret < 0) {",
          "1042:   shutdown(ipc_sockets[1], SHUT_RDWR);",
          "1043:   rexit(-1);",
          "1044:  }",
          "1047:  if (options->initial_cwd)",
          "1048:   new_cwd = options->initial_cwd;",
          "1049:  else",
          "1050:   new_cwd = cwd;",
          "1051:  ret = chdir(new_cwd);",
          "1052:  if (ret < 0)",
          "1054:  free(cwd);",
          "1057:  {",
          "1058:   struct attach_clone_payload payload = {",
          "1059:    .ipc_socket = ipc_sockets[1],",
          "",
          "[Removed Lines]",
          "1041:   ERROR(\"failed to enter the namespace\");",
          "1053:   WARN(\"could not change directory to '%s'\", new_cwd);",
          "",
          "[Added Lines]",
          "1040:   ERROR(\"Failed to enter namespaces.\");",
          "1052:   WARN(\"Could not change directory to \\\"%s\\\".\", new_cwd);",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "1062:    .exec_function = exec_function,",
          "1063:    .exec_payload = exec_payload,",
          "1064:   };",
          "1069:   pid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);",
          "1070:  }",
          "1073:  if (pid <= 0) {",
          "1075:   shutdown(ipc_sockets[1], SHUT_RDWR);",
          "1076:   rexit(-1);",
          "1077:  }",
          "1080:  ret = lxc_write_nointr(ipc_sockets[1], &pid, sizeof(pid));",
          "1081:  if (ret != sizeof(pid)) {",
          "1089:   shutdown(ipc_sockets[1], SHUT_RDWR);",
          "1090:   rexit(-1);",
          "1091:  }",
          "1094:  rexit(0);",
          "1095: }",
          "",
          "[Removed Lines]",
          "1074:   SYSERROR(\"failed to create subprocess\");",
          "1088:   ERROR(\"error using IPC to notify main process of pid of the attached process\");",
          "",
          "[Added Lines]",
          "1074:   SYSERROR(\"Failed to create subprocess.\");",
          "1088:   ERROR(\"Intended to send pid %d: %s.\", pid, strerror(errno));",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "1112:  uid_t new_uid;",
          "1113:  gid_t new_gid;",
          "1118:  expected = 0;",
          "1119:  status = -1;",
          "1120:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
          "1121:  if (ret <= 0) {",
          "1123:   shutdown(ipc_socket, SHUT_RDWR);",
          "1124:   rexit(-1);",
          "1125:  }",
          "1132:  if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {",
          "1133:   ret = lxc_attach_remount_sys_proc();",
          "",
          "[Removed Lines]",
          "1122:   ERROR(\"Error using IPC to receive notification from initial process (0): %s.\", strerror(errno));",
          "",
          "[Added Lines]",
          "1122:   ERROR(\"Expected to receive sequence number 0: %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "1147:  if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {",
          "1148:   ret = personality(new_personality);",
          "1149:   if (ret < 0) {",
          "1151:    shutdown(ipc_socket, SHUT_RDWR);",
          "1152:    rexit(-1);",
          "1153:   }",
          "",
          "[Removed Lines]",
          "1150:    SYSERROR(\"could not ensure correct architecture\");",
          "",
          "[Added Lines]",
          "1150:    SYSERROR(\"Could not ensure correct architecture.\");",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "1157:  if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {",
          "1158:   ret = lxc_attach_drop_privs(init_ctx);",
          "1159:   if (ret < 0) {",
          "1161:    shutdown(ipc_socket, SHUT_RDWR);",
          "1162:    rexit(-1);",
          "1163:   }",
          "1164:  }",
          "1167:  ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);",
          "1168:  if (ret < 0) {",
          "1170:   shutdown(ipc_socket, SHUT_RDWR);",
          "1171:   rexit(-1);",
          "1172:  }",
          "1175:  new_uid = 0;",
          "1176:  new_gid = 0;",
          "1180:  if (options->namespaces & CLONE_NEWUSER)",
          "1181:   lxc_attach_get_init_uidgid(&new_uid, &new_gid);",
          "",
          "[Removed Lines]",
          "1160:    ERROR(\"could not drop privileges\");",
          "1169:   ERROR(\"could not set initial environment for attached process\");",
          "",
          "[Added Lines]",
          "1160:    ERROR(\"Could not drop privileges.\");",
          "1171:   ERROR(\"Could not set initial environment for attached process.\");",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "1185:  if (options->gid != (gid_t)-1)",
          "1186:   new_gid = options->gid;",
          "1189:  if (options->stdin_fd && isatty(options->stdin_fd)) {",
          "1190:   if (setsid() < 0) {",
          "1192:    shutdown(ipc_socket, SHUT_RDWR);",
          "1193:    rexit(-1);",
          "1194:   }",
          "1196:   if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {",
          "1198:    shutdown(ipc_socket, SHUT_RDWR);",
          "1199:    rexit(-1);",
          "1200:   }",
          "1201:  }",
          "1204:  if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {",
          "1205:   if (setgid(new_gid) || setgroups(0, NULL)) {",
          "1207:    shutdown(ipc_socket, SHUT_RDWR);",
          "1208:    rexit(-1);",
          "1209:   }",
          "1210:  }",
          "1211:  if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {",
          "1213:   shutdown(ipc_socket, SHUT_RDWR);",
          "1214:   rexit(-1);",
          "1215:  }",
          "1218:  status = 1;",
          "1219:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
          "1220:  if (ret != sizeof(status)) {",
          "1222:   shutdown(ipc_socket, SHUT_RDWR);",
          "1223:   rexit(-1);",
          "1224:  }",
          "1229:  expected = 2;",
          "1230:  status = -1;",
          "1231:  ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);",
          "1232:  if (ret <= 0) {",
          "1236:   shutdown(ipc_socket, SHUT_RDWR);",
          "1237:   rexit(-1);",
          "1238:  }",
          "",
          "[Removed Lines]",
          "1191:    SYSERROR(\"unable to setsid\");",
          "1197:    SYSERROR(\"unable to TIOCSTTY\");",
          "1206:    SYSERROR(\"switching to container gid\");",
          "1212:   SYSERROR(\"switching to container uid\");",
          "1221:   ERROR(\"Error using IPC to notify initial process for initialization (1): %s.\", strerror(errno));",
          "1233:   ERROR(\"Error using IPC to receive message from initial process \"",
          "1234:         \"that it is done pre-initializing (2): %s\",",
          "1235:         strerror(errno));",
          "",
          "[Added Lines]",
          "1193:    SYSERROR(\"Unable to setsid.\");",
          "1199:    SYSERROR(\"Unable to set TIOCSTTY.\");",
          "1208:    SYSERROR(\"Switching to container gid.\");",
          "1214:   SYSERROR(\"Switching to container uid.\");",
          "1223:   ERROR(\"Intended to send sequence number 1: %s.\", strerror(errno));",
          "1235:   ERROR(\"Expected to receive sequence number 2: %s\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "1255:  status = 3;",
          "1256:  ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));",
          "1257:  if (ret <= 0) {",
          "1259:   shutdown(ipc_socket, SHUT_RDWR);",
          "1260:   rexit(-1);",
          "1261:  }",
          "",
          "[Removed Lines]",
          "1258:   ERROR(\"Error using IPC to tell parent to set up LSM labels (3): %s.\", strerror(errno));",
          "",
          "[Added Lines]",
          "1258:   ERROR(\"Intended to send sequence number 3: %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "1266:   ret = lxc_abstract_unix_recv_fd(ipc_socket, &lsm_labelfd, NULL, 0);",
          "1267:   if (ret <= 0) {",
          "1269:    shutdown(ipc_socket, SHUT_RDWR);",
          "1270:    rexit(-1);",
          "1271:   }",
          "",
          "[Removed Lines]",
          "1268:    ERROR(\"Error using IPC for parent to tell us LSM label fd (4): %s.\", strerror(errno));",
          "",
          "[Added Lines]",
          "1268:    ERROR(\"Expected to receive file descriptor: %s.\", strerror(errno));",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1284:  if (init_ctx->container && init_ctx->container->lxc_conf &&",
          "1285:      init_ctx->container->lxc_conf->seccomp &&",
          "1286:      (lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {",
          "1288:   shutdown(ipc_socket, SHUT_RDWR);",
          "1289:   rexit(-1);",
          "1290:  }",
          "",
          "[Removed Lines]",
          "1287:   ERROR(\"Loading seccomp policy\");",
          "",
          "[Added Lines]",
          "1287:   ERROR(\"Failed to load seccomp policy.\");",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1318:  if (options->stderr_fd > 2)",
          "1319:   close(options->stderr_fd);",
          "1323:  for (fd = 0; fd <= 2; fd++) {",
          "1324:   flags = fcntl(fd, F_GETFL);",
          "1325:   if (flags < 0)",
          "1326:    continue;",
          "1327:   if (flags & FD_CLOEXEC)",
          "1328:    if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)",
          "1330:  }",
          "1333:  rexit(payload->exec_function(payload->exec_payload));",
          "1334: }",
          "",
          "[Removed Lines]",
          "1329:     SYSERROR(\"Unable to clear CLOEXEC from fd\");",
          "",
          "[Added Lines]",
          "1329:     SYSERROR(\"Unable to clear FD_CLOEXEC from file descriptor.\");",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1338:  lxc_attach_command_t* cmd = (lxc_attach_command_t*)payload;",
          "1340:  execvp(cmd->program, cmd->argv);",
          "1342:  return -1;",
          "1343: }",
          "",
          "[Removed Lines]",
          "1341:  SYSERROR(\"failed to exec '%s'\", cmd->program);",
          "",
          "[Added Lines]",
          "1341:  SYSERROR(\"Failed to exec \\\"%s\\\".\", cmd->program);",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1369:  if (user_shell)",
          "1370:   execlp(user_shell, user_shell, (char *)NULL);",
          "1375:  execlp(\"/bin/sh\", \"/bin/sh\", (char *)NULL);",
          "1377:  return -1;",
          "1378: }",
          "",
          "[Removed Lines]",
          "1376:  SYSERROR(\"failed to exec shell\");",
          "",
          "[Added Lines]",
          "1375:  SYSERROR(\"Failed to exec shell.\");",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2013-7022",
  "cve_desc": "The g2m_init_buffers function in libavcodec/g2meet.c in FFmpeg before 2.1 does not properly allocate memory for tiles, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Go2Webinar data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "e07ac727c1cc9eed39e7f9117c97006f719864bd",
  "patch_info": {
    "commit_hash": "e07ac727c1cc9eed39e7f9117c97006f719864bd",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/e07ac727c1cc9eed39e7f9117c97006f719864bd",
    "files": [
      "libavcodec/g2meet.c"
    ],
    "message": "avcodec/g2meet: Fix framebuf size\n\nCurrently the code can in some cases draw tiles that hang outside the\nallocated buffer. This patch increases the buffer size to avoid out\nof array accesses. An alternative would be to fail if such tiles are\nencountered.\nI do not know if any valid files use such hanging tiles.\n\nFixes Ticket2971\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/g2meet.c||libavcodec/g2meet.c"
    ]
  },
  "patch_diff": {
    "libavcodec/g2meet.c||libavcodec/g2meet.c": [
      "File: libavcodec/g2meet.c -> libavcodec/g2meet.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "443:     int aligned_height;",
      "445:     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {",
      "448:         av_free(c->framebuf);",
      "449:         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);",
      "450:         if (!c->framebuf)",
      "",
      "[Removed Lines]",
      "446:         c->framebuf_stride = FFALIGN(c->width * 3, 16);",
      "447:         aligned_height     = FFALIGN(c->height,    16);",
      "",
      "[Added Lines]",
      "446:         c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;",
      "447:         aligned_height     = c->height + 15;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2b06f5f8f15a4464c74405cd7da57da2d6be5d36",
      "candidate_info": {
        "commit_hash": "2b06f5f8f15a4464c74405cd7da57da2d6be5d36",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2b06f5f8f15a4464c74405cd7da57da2d6be5d36",
        "files": [
          "libavcodec/g2meet.c"
        ],
        "message": "avcodec/g2meet: Fix framebuf size\n\nCurrently the code can in some cases draw tiles that hang outside the\nallocated buffer. This patch increases the buffer size to avoid out\nof array accesses. An alternative would be to fail if such tiles are\nencountered.\nI do not know if any valid files use such hanging tiles.\n\nFixes Ticket2971\nFound-by: ami_stuff\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>\n(cherry picked from commit e07ac727c1cc9eed39e7f9117c97006f719864bd)\n\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/g2meet.c||libavcodec/g2meet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/g2meet.c||libavcodec/g2meet.c"
          ],
          "candidate": [
            "libavcodec/g2meet.c||libavcodec/g2meet.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/g2meet.c||libavcodec/g2meet.c": [
          "File: libavcodec/g2meet.c -> libavcodec/g2meet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "443:     int aligned_height;",
          "445:     if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {",
          "448:         av_free(c->framebuf);",
          "449:         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);",
          "450:         if (!c->framebuf)",
          "",
          "[Removed Lines]",
          "446:         c->framebuf_stride = FFALIGN(c->width * 3, 16);",
          "447:         aligned_height     = FFALIGN(c->height,    16);",
          "",
          "[Added Lines]",
          "446:         c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;",
          "447:         aligned_height     = c->height + 15;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2d66a58ccde05e764594bd7e5f0f9244634d0b2c",
      "candidate_info": {
        "commit_hash": "2d66a58ccde05e764594bd7e5f0f9244634d0b2c",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2d66a58ccde05e764594bd7e5f0f9244634d0b2c",
        "files": [
          "Changelog",
          "configure",
          "doc/general.texi",
          "libavcodec/Makefile",
          "libavcodec/allcodecs.c",
          "libavcodec/avcodec.h",
          "libavcodec/codec_desc.c",
          "libavcodec/g2meet.c",
          "libavcodec/version.h",
          "libavformat/riff.c"
        ],
        "message": "Go2Webinar decoder",
        "before_after_code_files": [
          "libavcodec/allcodecs.c||libavcodec/allcodecs.c",
          "libavcodec/avcodec.h||libavcodec/avcodec.h",
          "libavcodec/codec_desc.c||libavcodec/codec_desc.c",
          "libavcodec/g2meet.c||libavcodec/g2meet.c",
          "libavcodec/version.h||libavcodec/version.h",
          "libavformat/riff.c||libavformat/riff.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/g2meet.c||libavcodec/g2meet.c"
          ],
          "candidate": [
            "libavcodec/g2meet.c||libavcodec/g2meet.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/allcodecs.c||libavcodec/allcodecs.c": [
          "File: libavcodec/allcodecs.c -> libavcodec/allcodecs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "146:     REGISTER_DECODER(FOURXM,            fourxm);",
          "147:     REGISTER_DECODER(FRAPS,             fraps);",
          "148:     REGISTER_DECODER(FRWU,              frwu);",
          "149:     REGISTER_ENCDEC (GIF,               gif);",
          "150:     REGISTER_ENCDEC (H261,              h261);",
          "151:     REGISTER_ENCDEC (H263,              h263);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "149:     REGISTER_DECODER(G2M,               g2m);",
          "",
          "---------------"
        ],
        "libavcodec/avcodec.h||libavcodec/avcodec.h": [
          "File: libavcodec/avcodec.h -> libavcodec/avcodec.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "270:     AV_CODEC_ID_VP9,",
          "271:     AV_CODEC_ID_AIC,",
          "272:     AV_CODEC_ID_ESCAPE130,",
          "275:     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273:     AV_CODEC_ID_G2M,",
          "",
          "---------------"
        ],
        "libavcodec/codec_desc.c||libavcodec/codec_desc.c": [
          "File: libavcodec/codec_desc.c -> libavcodec/codec_desc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1221:         .long_name = NULL_IF_CONFIG_SMALL(\"Escape 130\"),",
          "1222:         .props     = AV_CODEC_PROP_LOSSY,",
          "1223:     },",
          "1226:     {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1224:     {",
          "1225:         .id        = AV_CODEC_ID_G2M,",
          "1226:         .type      = AVMEDIA_TYPE_VIDEO,",
          "1227:         .name      = \"g2m\",",
          "1228:         .long_name = NULL_IF_CONFIG_SMALL(\"Go2Meeting\"),",
          "1229:         .props     = AV_CODEC_PROP_LOSSY,",
          "1230:     },",
          "",
          "---------------"
        ],
        "libavcodec/g2meet.c||libavcodec/g2meet.c": [
          "File: libavcodec/g2meet.c -> libavcodec/g2meet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "27: #include <zlib.h>",
          "29: #include \"libavutil/intreadwrite.h\"",
          "30: #include \"avcodec.h\"",
          "31: #include \"bytestream.h\"",
          "32: #include \"dsputil.h\"",
          "33: #include \"get_bits.h\"",
          "34: #include \"internal.h\"",
          "35: #include \"mjpeg.h\"",
          "37: enum ChunkType {",
          "38:     FRAME_INFO = 0xC8,",
          "39:     TILE_DATA,",
          "40:     CURSOR_POS,",
          "41:     CURSOR_SHAPE,",
          "42:     CHUNK_CC,",
          "43:     CHUNK_CD",
          "44: };",
          "46: enum Compression {",
          "47:     COMPR_EPIC_J_B = 2,",
          "48:     COMPR_KEMPF_J_B,",
          "49: };",
          "51: static const uint8_t luma_quant[64] = {",
          "52:      8,  6,  5,  8, 12, 20, 26, 31,",
          "53:      6,  6,  7, 10, 13, 29, 30, 28,",
          "54:      7,  7,  8, 12, 20, 29, 35, 28,",
          "55:      7,  9, 11, 15, 26, 44, 40, 31,",
          "56:      9, 11, 19, 28, 34, 55, 52, 39,",
          "57:     12, 18, 28, 32, 41, 52, 57, 46,",
          "58:     25, 32, 39, 44, 52, 61, 60, 51,",
          "59:     36, 46, 48, 49, 56, 50, 52, 50",
          "60: };",
          "62: static const uint8_t chroma_quant[64] = {",
          "63:      9,  9, 12, 24, 50, 50, 50, 50,",
          "64:      9, 11, 13, 33, 50, 50, 50, 50,",
          "65:     12, 13, 28, 50, 50, 50, 50, 50,",
          "66:     24, 33, 50, 50, 50, 50, 50, 50,",
          "67:     50, 50, 50, 50, 50, 50, 50, 50,",
          "68:     50, 50, 50, 50, 50, 50, 50, 50,",
          "69:     50, 50, 50, 50, 50, 50, 50, 50,",
          "70:     50, 50, 50, 50, 50, 50, 50, 50,",
          "71: };",
          "73: typedef struct JPGContext {",
          "74:     DSPContext dsp;",
          "75:     ScanTable  scantable;",
          "77:     VLC        dc_vlc[2], ac_vlc[2];",
          "78:     int        prev_dc[3];",
          "79:     DECLARE_ALIGNED(16, int16_t, block)[6][64];",
          "81:     uint8_t    *buf;",
          "82: } JPGContext;",
          "84: typedef struct G2MContext {",
          "85:     JPGContext jc;",
          "86:     int        version;",
          "88:     int        compression;",
          "89:     int        width, height, bpp;",
          "90:     int        tile_width, tile_height;",
          "91:     int        tiles_x, tiles_y, tile_x, tile_y;",
          "93:     int        got_header;",
          "95:     uint8_t    *framebuf;",
          "96:     int        framebuf_stride, old_width, old_height;",
          "98:     uint8_t    *synth_tile, *jpeg_tile;",
          "99:     int        tile_stride, old_tile_w, old_tile_h;",
          "101:     uint8_t    *kempf_buf, *kempf_flags;",
          "103:     uint8_t    *cursor;",
          "104:     int        cursor_stride;",
          "105:     int        cursor_fmt;",
          "106:     int        cursor_w, cursor_h, cursor_x, cursor_y;",
          "107:     int        cursor_hot_x, cursor_hot_y;",
          "108: } G2MContext;",
          "110: static av_cold int build_vlc(VLC *vlc, const uint8_t *bits_table,",
          "111:                              const uint8_t *val_table, int nb_codes,",
          "112:                              int is_ac)",
          "113: {",
          "114:     uint8_t  huff_size[256] = { 0 };",
          "115:     uint16_t huff_code[256];",
          "116:     uint16_t huff_sym[256];",
          "117:     int i;",
          "119:     ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);",
          "121:     for (i = 0; i < 256; i++)",
          "122:         huff_sym[i] = i + 16 * is_ac;",
          "124:     if (is_ac)",
          "125:         huff_sym[0] = 16 * 256;",
          "127:     return ff_init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,",
          "128:                               huff_code, 2, 2, huff_sym, 2, 2, 0);",
          "129: }",
          "131: static av_cold int jpg_init(AVCodecContext *avctx, JPGContext *c)",
          "132: {",
          "133:     int ret;",
          "135:     ret = build_vlc(&c->dc_vlc[0], avpriv_mjpeg_bits_dc_luminance,",
          "136:                     avpriv_mjpeg_val_dc, 12, 0);",
          "137:     if (ret)",
          "138:         return ret;",
          "139:     ret = build_vlc(&c->dc_vlc[1], avpriv_mjpeg_bits_dc_chrominance,",
          "140:                     avpriv_mjpeg_val_dc, 12, 0);",
          "141:     if (ret)",
          "142:         return ret;",
          "143:     ret = build_vlc(&c->ac_vlc[0], avpriv_mjpeg_bits_ac_luminance,",
          "144:                     avpriv_mjpeg_val_ac_luminance, 251, 1);",
          "145:     if (ret)",
          "146:         return ret;",
          "147:     ret = build_vlc(&c->ac_vlc[1], avpriv_mjpeg_bits_ac_chrominance,",
          "148:                     avpriv_mjpeg_val_ac_chrominance, 251, 1);",
          "149:     if (ret)",
          "150:         return ret;",
          "152:     ff_dsputil_init(&c->dsp, avctx);",
          "153:     ff_init_scantable(c->dsp.idct_permutation, &c->scantable,",
          "154:                       ff_zigzag_direct);",
          "156:     return 0;",
          "157: }",
          "159: static av_cold void jpg_free_context(JPGContext *ctx)",
          "160: {",
          "161:     int i;",
          "163:     for (i = 0; i < 2; i++) {",
          "164:         ff_free_vlc(&ctx->dc_vlc[i]);",
          "165:         ff_free_vlc(&ctx->ac_vlc[i]);",
          "166:     }",
          "168:     av_freep(&ctx->buf);",
          "169: }",
          "171: static void jpg_unescape(const uint8_t *src, int src_size,",
          "172:                          uint8_t *dst, int *dst_size)",
          "173: {",
          "174:     const uint8_t *src_end = src + src_size;",
          "175:     uint8_t *dst_start = dst;",
          "177:     while (src < src_end) {",
          "178:         uint8_t x = *src++;",
          "182:         if (x == 0xFF && !*src)",
          "183:             src++;",
          "184:     }",
          "186: }",
          "188: static int jpg_decode_block(JPGContext *c, GetBitContext *gb,",
          "189:                             int plane, int16_t *block)",
          "190: {",
          "191:     int dc, val, pos;",
          "192:     const int is_chroma = !!plane;",
          "193:     const uint8_t *qmat = is_chroma ? chroma_quant : luma_quant;",
          "195:     c->dsp.clear_block(block);",
          "196:     dc = get_vlc2(gb, c->dc_vlc[is_chroma].table, 9, 3);",
          "197:     if (dc < 0)",
          "198:         return AVERROR_INVALIDDATA;",
          "199:     if (dc)",
          "200:         dc = get_xbits(gb, dc);",
          "201:     dc = dc * qmat[0] + c->prev_dc[plane];",
          "202:     block[0] = dc;",
          "203:     c->prev_dc[plane] = dc;",
          "205:     pos = 0;",
          "206:     while (pos < 63) {",
          "207:         val = get_vlc2(gb, c->ac_vlc[is_chroma].table, 9, 3);",
          "208:         if (val < 0)",
          "209:             return AVERROR_INVALIDDATA;",
          "210:         pos += val >> 4;",
          "211:         val &= 0xF;",
          "212:         if (pos > 63)",
          "213:             return val ? AVERROR_INVALIDDATA : 0;",
          "214:         if (val) {",
          "215:             int nbits = val;",
          "217:             val = get_xbits(gb, nbits);",
          "218:             val *= qmat[ff_zigzag_direct[pos]];",
          "219:             block[c->scantable.permutated[pos]] = val;",
          "220:         }",
          "221:     }",
          "222:     return 0;",
          "223: }",
          "225: static inline void yuv2rgb(uint8_t *out, int Y, int U, int V)",
          "226: {",
          "227:     out[0] = av_clip_uint8(Y + (             91881 * V + 32768 >> 16));",
          "228:     out[1] = av_clip_uint8(Y + (-22554 * U - 46802 * V + 32768 >> 16));",
          "229:     out[2] = av_clip_uint8(Y + (116130 * U             + 32768 >> 16));",
          "230: }",
          "232: static int jpg_decode_data(JPGContext *c, int width, int height,",
          "233:                            const uint8_t *src, int src_size,",
          "234:                            uint8_t *dst, int dst_stride,",
          "235:                            const uint8_t *mask, int mask_stride, int num_mbs,",
          "236:                            int swapuv)",
          "237: {",
          "238:     GetBitContext gb;",
          "239:     uint8_t *tmp;",
          "240:     int mb_w, mb_h, mb_x, mb_y, i, j;",
          "241:     int bx, by;",
          "242:     int unesc_size;",
          "243:     int ret;",
          "245:     tmp = av_realloc(c->buf, src_size + FF_INPUT_BUFFER_PADDING_SIZE);",
          "246:     if (!tmp)",
          "247:         return AVERROR(ENOMEM);",
          "248:     c->buf = tmp;",
          "249:     jpg_unescape(src, src_size, c->buf, &unesc_size);",
          "250:     memset(c->buf + unesc_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);",
          "251:     init_get_bits(&gb, c->buf, unesc_size * 8);",
          "253:     width = FFALIGN(width, 16);",
          "254:     mb_w  =  width        >> 4;",
          "255:     mb_h  = (height + 15) >> 4;",
          "257:     if (!num_mbs)",
          "258:         num_mbs = mb_w * mb_h;",
          "260:     for (i = 0; i < 3; i++)",
          "261:         c->prev_dc[i] = 1024;",
          "262:     bx = by = 0;",
          "263:     for (mb_y = 0; mb_y < mb_h; mb_y++) {",
          "264:         for (mb_x = 0; mb_x < mb_w; mb_x++) {",
          "265:             if (mask && !mask[mb_x]) {",
          "266:                 bx += 16;",
          "267:                 continue;",
          "268:             }",
          "269:             for (j = 0; j < 2; j++) {",
          "270:                 for (i = 0; i < 2; i++) {",
          "271:                     if ((ret = jpg_decode_block(c, &gb, 0,",
          "272:                                                 c->block[i + j * 2])) != 0)",
          "273:                         return ret;",
          "274:                     c->dsp.idct(c->block[i + j * 2]);",
          "275:                 }",
          "276:             }",
          "277:             for (i = 1; i < 3; i++) {",
          "278:                 if ((ret = jpg_decode_block(c, &gb, i, c->block[i + 3])) != 0)",
          "279:                     return ret;",
          "280:                 c->dsp.idct(c->block[i + 3]);",
          "281:             }",
          "283:             for (j = 0; j < 16; j++) {",
          "284:                 uint8_t *out = dst + bx * 3 + (by + j) * dst_stride;",
          "285:                 for (i = 0; i < 16; i++) {",
          "286:                     int Y, U, V;",
          "288:                     Y = c->block[(j >> 3) * 2 + (i >> 3)][(i & 7) + (j & 7) * 8];",
          "289:                     U = c->block[4 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;",
          "290:                     V = c->block[5 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;",
          "291:                     yuv2rgb(out + i * 3, Y, U, V);",
          "292:                 }",
          "293:             }",
          "295:             if (!--num_mbs)",
          "296:                 return 0;",
          "297:             bx += 16;",
          "298:         }",
          "299:         bx  = 0;",
          "300:         by += 16;",
          "301:         if (mask)",
          "302:             mask += mask_stride;",
          "303:     }",
          "305:     return 0;",
          "306: }",
          "308: static void kempf_restore_buf(const uint8_t *src, int len,",
          "309:                               uint8_t *dst, int stride,",
          "310:                               const uint8_t *jpeg_tile, int tile_stride,",
          "311:                               int width, int height,",
          "312:                               const uint8_t *pal, int npal, int tidx)",
          "313: {",
          "314:     GetBitContext gb;",
          "315:     int i, j, nb, col;",
          "317:     init_get_bits(&gb, src, len * 8);",
          "319:     if (npal <= 2)       nb = 1;",
          "320:     else if (npal <= 4)  nb = 2;",
          "321:     else if (npal <= 16) nb = 4;",
          "322:     else                 nb = 8;",
          "324:     for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {",
          "325:         if (get_bits(&gb, 8))",
          "326:             continue;",
          "327:         for (i = 0; i < width; i++) {",
          "328:             col = get_bits(&gb, nb);",
          "329:             if (col != tidx)",
          "330:                 memcpy(dst + i * 3, pal + col * 3, 3);",
          "331:             else",
          "332:                 memcpy(dst + i * 3, jpeg_tile + i * 3, 3);",
          "333:         }",
          "334:     }",
          "335: }",
          "337: static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,",
          "338:                              const uint8_t *src, int src_size)",
          "339: {",
          "340:     int width, height;",
          "341:     int hdr, zsize, npal, tidx = -1, ret;",
          "342:     int i, j;",
          "343:     const uint8_t *src_end = src + src_size;",
          "344:     uint8_t pal[768], transp[3];",
          "345:     uLongf dlen = (c->tile_width + 1) * c->tile_height;",
          "346:     int sub_type;",
          "347:     int nblocks, cblocks, bstride;",
          "348:     int bits, bitbuf, coded;",
          "349:     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +",
          "350:                    tile_y * c->tile_height * c->framebuf_stride;",
          "352:     if (src_size < 2)",
          "353:         return AVERROR_INVALIDDATA;",
          "355:     width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);",
          "356:     height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);",
          "358:     hdr = *src++;",
          "359:     sub_type = hdr >> 5;",
          "360:     if (sub_type == 0) {",
          "361:         int j;",
          "362:         memcpy(transp, src, 3);",
          "363:         src += 3;",
          "364:         for (j = 0; j < height; j++, dst += c->framebuf_stride)",
          "365:             for (i = 0; i < width; i++)",
          "366:                 memcpy(dst + i * 3, transp, 3);",
          "367:         return 0;",
          "368:     } else if (sub_type == 1) {",
          "369:         return jpg_decode_data(&c->jc, width, height, src, src_end - src,",
          "370:                                dst, c->framebuf_stride, NULL, 0, 0, 0);",
          "371:     }",
          "373:     if (sub_type != 2) {",
          "374:         memcpy(transp, src, 3);",
          "375:         src += 3;",
          "376:     }",
          "377:     npal = *src++ + 1;",
          "378:     memcpy(pal, src, npal * 3); src += npal * 3;",
          "379:     if (sub_type != 2) {",
          "380:         for (i = 0; i < npal; i++) {",
          "381:             if (!memcmp(pal + i * 3, transp, 3)) {",
          "382:                tidx = i;",
          "383:                break;",
          "384:             }",
          "385:         }",
          "386:     }",
          "388:     if (src_end - src < 2)",
          "389:         return 0;",
          "390:     zsize = (src[0] << 8) | src[1]; src += 2;",
          "392:     if (src_end - src < zsize)",
          "393:         return AVERROR_INVALIDDATA;",
          "395:     ret = uncompress(c->kempf_buf, &dlen, src, zsize);",
          "396:     if (ret)",
          "397:         return AVERROR_INVALIDDATA;",
          "398:     src += zsize;",
          "400:     if (sub_type == 2) {",
          "401:         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,",
          "402:                           NULL, 0, width, height, pal, npal, tidx);",
          "403:         return 0;",
          "404:     }",
          "406:     nblocks = *src++ + 1;",
          "407:     cblocks = 0;",
          "408:     bstride = FFALIGN(width, 16) >> 4;",
          "410:     bits = 0;",
          "411:     for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {",
          "412:         for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {",
          "413:             if (!bits) {",
          "414:                 bitbuf = *src++;",
          "415:                 bits   = 8;",
          "416:             }",
          "417:             coded = bitbuf & 1;",
          "418:             bits--;",
          "419:             bitbuf >>= 1;",
          "420:             cblocks += coded;",
          "421:             if (cblocks > nblocks)",
          "422:                 return AVERROR_INVALIDDATA;",
          "423:             c->kempf_flags[j + i * bstride] = coded;",
          "424:         }",
          "425:     }",
          "427:     memset(c->jpeg_tile, 0, c->tile_stride * height);",
          "428:     jpg_decode_data(&c->jc, width, height, src, src_end - src,",
          "429:                     c->jpeg_tile, c->tile_stride,",
          "430:                     c->kempf_flags, bstride, nblocks, 0);",
          "432:     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,",
          "433:                       c->jpeg_tile, c->tile_stride,",
          "434:                       width, height, pal, npal, tidx);",
          "436:     return 0;",
          "437: }",
          "439: static int g2m_init_buffers(G2MContext *c)",
          "440: {",
          "441:     int aligned_height;",
          "443:     if (!c->framebuf || c->old_width < c->width || c->height < c->height) {",
          "444:         c->framebuf_stride = FFALIGN(c->width * 3, 16);",
          "445:         aligned_height     = FFALIGN(c->height,    16);",
          "446:         av_free(c->framebuf);",
          "447:         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);",
          "448:         if (!c->framebuf)",
          "449:             return AVERROR(ENOMEM);",
          "450:     }",
          "451:     if (!c->synth_tile || !c->jpeg_tile ||",
          "452:         c->old_tile_w < c->tile_width ||",
          "453:         c->old_tile_h < c->tile_height) {",
          "454:         c->tile_stride = FFALIGN(c->tile_width * 3, 16);",
          "455:         aligned_height = FFALIGN(c->tile_height,    16);",
          "456:         av_free(c->synth_tile);",
          "457:         av_free(c->jpeg_tile);",
          "458:         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);",
          "459:         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);",
          "460:         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height",
          "461:                                     + FF_INPUT_BUFFER_PADDING_SIZE);",
          "462:         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);",
          "463:         if (!c->synth_tile || !c->jpeg_tile ||",
          "464:             !c->kempf_buf || !c->kempf_flags)",
          "465:             return AVERROR(ENOMEM);",
          "466:     }",
          "468:     return 0;",
          "469: }",
          "471: static int g2m_load_cursor(G2MContext *c, GetByteContext *gb)",
          "472: {",
          "473:     int i, j, k;",
          "474:     uint8_t *dst;",
          "475:     uint32_t bits;",
          "477:     c->cursor_stride = c->cursor_w * 4;",
          "478:     c->cursor        = av_realloc(c->cursor, c->cursor_stride * c->cursor_h);",
          "479:     if (!c->cursor)",
          "480:         return AVERROR(ENOMEM);",
          "482:     dst = c->cursor;",
          "483:     switch (c->cursor_fmt) {",
          "484:     case 1: // old monochrome",
          "485:         for (j = 0; j < c->cursor_h; j++) {",
          "486:             for (i = 0; i < c->cursor_w; i += 32) {",
          "487:                 bits = bytestream2_get_be32(gb);",
          "488:                 for (k = 0; k < 32; k++) {",
          "489:                     dst[0] = !!(bits & 0x80000000);",
          "490:                     dst += 4;",
          "491:                     bits <<= 1;",
          "492:                 }",
          "493:             }",
          "494:         }",
          "496:         dst = c->cursor;",
          "497:         for (j = 0; j < c->cursor_h; j++) {",
          "498:             for (i = 0; i < c->cursor_w; i += 32) {",
          "499:                 bits = bytestream2_get_be32(gb);",
          "500:                 for (k = 0; k < 32; k++) {",
          "501:                     int mask_bit = !!(bits & 0x80000000);",
          "502:                     switch (dst[0] * 2 + mask_bit) {",
          "503:                     case 0:",
          "504:                         dst[0] = 0xFF; dst[1] = 0x00;",
          "505:                         dst[2] = 0x00; dst[3] = 0x00;",
          "506:                         break;",
          "507:                     case 1:",
          "508:                         dst[0] = 0xFF; dst[1] = 0xFF;",
          "509:                         dst[2] = 0xFF; dst[3] = 0xFF;",
          "510:                         break;",
          "511:                     default:",
          "512:                         dst[0] = 0x00; dst[1] = 0x00;",
          "513:                         dst[2] = 0x00; dst[3] = 0x00;",
          "514:                     }",
          "515:                     dst += 4;",
          "516:                     bits <<= 1;",
          "517:                 }",
          "518:             }",
          "519:         }",
          "520:         break;",
          "521:     case 32: // full colour",
          "523:         bytestream2_skip(gb, c->cursor_h * (FFALIGN(c->cursor_w, 32) >> 3));",
          "524:         for (j = 0; j < c->cursor_h; j++) {",
          "525:             for (i = 0; i < c->cursor_w; i++) {",
          "526:                 int val = bytestream2_get_be32(gb);",
          "531:             }",
          "532:         }",
          "533:         break;",
          "534:     default:",
          "535:         return AVERROR_PATCHWELCOME;",
          "536:     }",
          "537:     return 0;",
          "538: }",
          "540: #define APPLY_ALPHA(src, new, alpha) \\",
          "541:     src = (src * (256 - alpha) + new * alpha) >> 8",
          "543: static void g2m_paint_cursor(G2MContext *c, uint8_t *dst, int stride)",
          "544: {",
          "545:     int i, j;",
          "546:     int x, y, w, h;",
          "547:     const uint8_t *cursor;",
          "549:     if (!c->cursor)",
          "550:         return;",
          "552:     x = c->cursor_x - c->cursor_hot_x;",
          "553:     y = c->cursor_y - c->cursor_hot_y;",
          "555:     cursor = c->cursor;",
          "556:     w      = c->cursor_w;",
          "557:     h      = c->cursor_h;",
          "559:     if (x + w > c->width)",
          "560:         w = c->width - x;",
          "561:     if (y + h > c->height)",
          "562:         h = c->height - y;",
          "563:     if (x < 0) {",
          "564:         w      +=  x;",
          "565:         cursor += -x * 4;",
          "566:     } else {",
          "567:         dst    +=  x * 3;",
          "568:     }",
          "569:     if (y < 0) {",
          "570:         h      +=  y;",
          "571:         cursor += -y * c->cursor_stride;",
          "572:     } else {",
          "573:         dst    +=  y * stride;",
          "574:     }",
          "575:     if (w < 0 || h < 0)",
          "576:         return;",
          "578:     for (j = 0; j < h; j++) {",
          "579:         for (i = 0; i < w; i++) {",
          "580:             uint8_t alpha = cursor[i * 4];",
          "581:             APPLY_ALPHA(dst[i * 3 + 0], cursor[i * 4 + 1], alpha);",
          "582:             APPLY_ALPHA(dst[i * 3 + 1], cursor[i * 4 + 2], alpha);",
          "583:             APPLY_ALPHA(dst[i * 3 + 2], cursor[i * 4 + 3], alpha);",
          "584:         }",
          "585:         dst    += stride;",
          "586:         cursor += c->cursor_stride;",
          "587:     }",
          "588: }",
          "590: static int g2m_decode_frame(AVCodecContext *avctx, void *data,",
          "591:                             int *got_picture_ptr, AVPacket *avpkt)",
          "592: {",
          "593:     const uint8_t *buf = avpkt->data;",
          "594:     int buf_size = avpkt->size;",
          "595:     G2MContext *c = avctx->priv_data;",
          "596:     AVFrame *pic = data;",
          "597:     GetByteContext bc, tbc;",
          "598:     int magic;",
          "599:     int got_header = 0;",
          "600:     uint32_t chunk_size, cur_size;",
          "601:     int chunk_type;",
          "602:     int i;",
          "603:     int ret;",
          "605:     if (buf_size < 12) {",
          "606:         av_log(avctx, AV_LOG_ERROR,",
          "607:                \"Frame should have at least 12 bytes, got %d instead\\n\",",
          "608:                buf_size);",
          "609:         return AVERROR_INVALIDDATA;",
          "610:     }",
          "612:     bytestream2_init(&bc, buf, buf_size);",
          "614:     magic = bytestream2_get_be32(&bc);",
          "615:     if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') ||",
          "616:         (magic & 0xF) < 2 || (magic & 0xF) > 4) {",
          "617:         av_log(avctx, AV_LOG_ERROR, \"Wrong magic %08X\\n\", magic);",
          "618:         return AVERROR_INVALIDDATA;",
          "619:     }",
          "621:     if ((magic & 0xF) != 4) {",
          "622:         av_log(avctx, AV_LOG_ERROR, \"G2M2 and G2M3 are not yet supported\\n\");",
          "623:         return AVERROR(ENOSYS);",
          "624:     }",
          "626:     while (bytestream2_get_bytes_left(&bc) > 5) {",
          "627:         chunk_size = bytestream2_get_le32(&bc) - 1;",
          "628:         chunk_type = bytestream2_get_byte(&bc);",
          "629:         if (chunk_size > bytestream2_get_bytes_left(&bc)) {",
          "630:             av_log(avctx, AV_LOG_ERROR, \"Invalid chunk size %d type %02X\\n\",",
          "631:                    chunk_size, chunk_type);",
          "632:             break;",
          "633:         }",
          "634:         switch (chunk_type) {",
          "635:         case FRAME_INFO:",
          "636:             c->got_header = 0;",
          "637:             if (chunk_size < 21) {",
          "638:                 av_log(avctx, AV_LOG_ERROR, \"Invalid frame info size %d\\n\",",
          "639:                        chunk_size);",
          "640:                 break;",
          "641:             }",
          "642:             c->width  = bytestream2_get_be32(&bc);",
          "643:             c->height = bytestream2_get_be32(&bc);",
          "644:             if (c->width  < 16 || c->width  > avctx->width ||",
          "645:                 c->height < 16 || c->height > avctx->height) {",
          "646:                 av_log(avctx, AV_LOG_ERROR,",
          "647:                        \"Invalid frame dimensions %dx%d\\n\",",
          "648:                        c->width, c->height);",
          "649:                 c->width = c->height = 0;",
          "650:                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));",
          "651:             }",
          "652:             if (c->width != avctx->width || c->height != avctx->height)",
          "653:                 avcodec_set_dimensions(avctx, c->width, c->height);",
          "654:             c->compression = bytestream2_get_be32(&bc);",
          "655:             if (c->compression != 2 && c->compression != 3) {",
          "656:                 av_log(avctx, AV_LOG_ERROR,",
          "657:                        \"Unknown compression method %d\\n\",",
          "658:                        c->compression);",
          "659:                 return AVERROR_PATCHWELCOME;",
          "660:             }",
          "661:             c->tile_width  = bytestream2_get_be32(&bc);",
          "662:             c->tile_height = bytestream2_get_be32(&bc);",
          "663:             if (!c->tile_width || !c->tile_height) {",
          "664:                 av_log(avctx, AV_LOG_ERROR,",
          "665:                        \"Invalid tile dimensions %dx%d\\n\",",
          "666:                        c->tile_width, c->tile_height);",
          "667:                 return AVERROR_INVALIDDATA;",
          "668:             }",
          "669:             c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;",
          "670:             c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;",
          "671:             c->bpp = bytestream2_get_byte(&bc);",
          "672:             chunk_size -= 21;",
          "673:             bytestream2_skip(&bc, chunk_size);",
          "674:             if (g2m_init_buffers(c))",
          "675:                 return AVERROR(ENOMEM);",
          "676:             got_header = 1;",
          "677:             break;",
          "678:         case TILE_DATA:",
          "679:             if (!c->tiles_x || !c->tiles_y) {",
          "680:                 av_log(avctx, AV_LOG_WARNING,",
          "681:                        \"No frame header - skipping tile\\n\");",
          "682:                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));",
          "683:                 break;",
          "684:             }",
          "685:             if (chunk_size < 2) {",
          "686:                 av_log(avctx, AV_LOG_ERROR, \"Invalid tile data size %d\\n\",",
          "687:                        chunk_size);",
          "688:                 break;",
          "689:             }",
          "690:             c->tile_x = bytestream2_get_byte(&bc);",
          "691:             c->tile_y = bytestream2_get_byte(&bc);",
          "692:             if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {",
          "693:                 av_log(avctx, AV_LOG_ERROR,",
          "694:                        \"Invalid tile pos %d,%d (in %dx%d grid)\\n\",",
          "695:                        c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);",
          "696:                 break;",
          "697:             }",
          "698:             chunk_size -= 2;",
          "699:             ret = 0;",
          "700:             switch (c->compression) {",
          "701:             case COMPR_EPIC_J_B:",
          "702:                 av_log(avctx, AV_LOG_ERROR,",
          "703:                        \"ePIC j-b compression is not implemented yet\\n\");",
          "704:                 return AVERROR(ENOSYS);",
          "705:             case COMPR_KEMPF_J_B:",
          "706:                 ret = kempf_decode_tile(c, c->tile_x, c->tile_y,",
          "707:                                         buf + bytestream2_tell(&bc),",
          "708:                                         chunk_size);",
          "709:                 break;",
          "710:             }",
          "711:             if (ret && c->framebuf)",
          "712:                 av_log(avctx, AV_LOG_ERROR, \"Error decoding tile %d,%d\\n\",",
          "713:                        c->tile_x, c->tile_y);",
          "714:             bytestream2_skip(&bc, chunk_size);",
          "715:             break;",
          "716:         case CURSOR_POS:",
          "717:             if (chunk_size < 5) {",
          "718:                 av_log(avctx, AV_LOG_ERROR, \"Invalid cursor pos size %d\\n\",",
          "719:                        chunk_size);",
          "720:                 break;",
          "721:             }",
          "722:             c->cursor_x = bytestream2_get_be16(&bc);",
          "723:             c->cursor_y = bytestream2_get_be16(&bc);",
          "724:             bytestream2_skip(&bc, chunk_size - 4);",
          "725:             break;",
          "726:         case CURSOR_SHAPE:",
          "727:             if (chunk_size < 8) {",
          "728:                 av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",",
          "729:                        chunk_size);",
          "730:                 break;",
          "731:             }",
          "732:             bytestream2_init(&tbc, buf + bytestream2_tell(&bc),",
          "733:                              chunk_size - 4);",
          "734:             cur_size        = bytestream2_get_be32(&tbc);",
          "735:             c->cursor_w     = bytestream2_get_byte(&tbc);",
          "736:             c->cursor_h     = bytestream2_get_byte(&tbc);",
          "737:             c->cursor_hot_x = bytestream2_get_byte(&tbc);",
          "738:             c->cursor_hot_y = bytestream2_get_byte(&tbc);",
          "739:             c->cursor_fmt   = bytestream2_get_byte(&tbc);",
          "740:             if (cur_size >= chunk_size ||",
          "741:                 c->cursor_w * c->cursor_h / 4 > cur_size) {",
          "742:                 av_log(avctx, AV_LOG_ERROR, \"Invalid cursor data size %d\\n\",",
          "743:                        chunk_size);",
          "744:                 break;",
          "745:             }",
          "746:             g2m_load_cursor(c, &tbc);",
          "747:             bytestream2_skip(&bc, chunk_size);",
          "748:             break;",
          "749:         case CHUNK_CC:",
          "750:         case CHUNK_CD:",
          "751:             bytestream2_skip(&bc, chunk_size);",
          "752:             break;",
          "753:         default:",
          "754:             av_log(avctx, AV_LOG_WARNING, \"Skipping chunk type %02X\\n\",",
          "755:                    chunk_type);",
          "756:             bytestream2_skip(&bc, chunk_size);",
          "757:         }",
          "758:     }",
          "759:     if (got_header)",
          "760:         c->got_header = 1;",
          "762:     if (c->width && c->height) {",
          "763:         if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) {",
          "764:             av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "765:             return ret;",
          "766:         }",
          "768:         pic->key_frame = got_header;",
          "769:         pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;",
          "771:         for (i = 0; i < avctx->height; i++)",
          "772:             memcpy(pic->data[0] + i * pic->linesize[0],",
          "773:                    c->framebuf  + i * c->framebuf_stride,",
          "774:                    c->width * 3);",
          "775:         g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);",
          "778:     }",
          "780:     return buf_size;",
          "781: }",
          "783: static av_cold int g2m_decode_init(AVCodecContext *avctx)",
          "784: {",
          "785:     G2MContext * const c = avctx->priv_data;",
          "786:     int ret;",
          "788:     if ((ret = jpg_init(avctx, &c->jc)) != 0) {",
          "789:         av_log(avctx, AV_LOG_ERROR, \"Cannot initialise VLCs\\n\");",
          "790:         jpg_free_context(&c->jc);",
          "791:         return AVERROR(ENOMEM);",
          "792:     }",
          "794:     avctx->pix_fmt     = PIX_FMT_RGB24;",
          "796:     return 0;",
          "797: }",
          "799: static av_cold int g2m_decode_end(AVCodecContext *avctx)",
          "800: {",
          "801:     G2MContext * const c = avctx->priv_data;",
          "803:     jpg_free_context(&c->jc);",
          "805:     av_freep(&c->kempf_buf);",
          "806:     av_freep(&c->kempf_flags);",
          "807:     av_freep(&c->synth_tile);",
          "808:     av_freep(&c->jpeg_tile);",
          "809:     av_freep(&c->cursor);",
          "810:     av_freep(&c->framebuf);",
          "812:     return 0;",
          "813: }",
          "815: AVCodec ff_g2m_decoder = {",
          "816:     .name           = \"g2m\",",
          "817:     .long_name      = NULL_IF_CONFIG_SMALL(\"Go2Meeting\"),",
          "818:     .type           = AVMEDIA_TYPE_VIDEO,",
          "819:     .id             = AV_CODEC_ID_G2M,",
          "820:     .priv_data_size = sizeof(G2MContext),",
          "821:     .init           = g2m_decode_init,",
          "822:     .close          = g2m_decode_end,",
          "823:     .decode         = g2m_decode_frame,",
          "824:     .capabilities   = CODEC_CAP_DR1,",
          "825: };",
          "",
          "---------------"
        ],
        "libavcodec/version.h||libavcodec/version.h": [
          "File: libavcodec/version.h -> libavcodec/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "29: #define LIBAVCODEC_VERSION_MAJOR 55",
          "33: #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \\",
          "34:                                                LIBAVCODEC_VERSION_MINOR, \\",
          "",
          "[Removed Lines]",
          "30: #define LIBAVCODEC_VERSION_MINOR  7",
          "31: #define LIBAVCODEC_VERSION_MICRO  2",
          "",
          "[Added Lines]",
          "30: #define LIBAVCODEC_VERSION_MINOR  8",
          "31: #define LIBAVCODEC_VERSION_MICRO  0",
          "",
          "---------------"
        ],
        "libavformat/riff.c||libavformat/riff.c": [
          "File: libavformat/riff.c -> libavformat/riff.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "312:     { AV_CODEC_ID_CLLC,         MKTAG('C', 'L', 'L', 'C') },",
          "313:     { AV_CODEC_ID_MSS2,         MKTAG('M', 'S', 'S', '2') },",
          "314:     { AV_CODEC_ID_SVQ3,         MKTAG('S', 'V', 'Q', '3') },",
          "315:     { AV_CODEC_ID_NONE,         0 }",
          "316: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "315:     { AV_CODEC_ID_G2M,          MKTAG('G', '2', 'M', '2') },",
          "316:     { AV_CODEC_ID_G2M,          MKTAG('G', '2', 'M', '3') },",
          "317:     { AV_CODEC_ID_G2M,          MKTAG('G', '2', 'M', '4') },",
          "",
          "---------------"
        ]
      }
    }
  ]
}
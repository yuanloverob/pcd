{
  "cve_id": "CVE-2019-11413",
  "cve_desc": "An issue was discovered in Artifex MuJS 1.0.5. It has unlimited recursion because the match function in regexp.c lacks a depth check.",
  "repo": "ccxvii/mujs",
  "patch_hash": "00d4606c3baf813b7b1c176823b2729bf51002a2",
  "patch_info": {
    "commit_hash": "00d4606c3baf813b7b1c176823b2729bf51002a2",
    "repo": "ccxvii/mujs",
    "commit_url": "https://github.com/ccxvii/mujs/commit/00d4606c3baf813b7b1c176823b2729bf51002a2",
    "files": [
      "jsregexp.c",
      "jsstring.c",
      "regexp.c"
    ],
    "message": "Bug 700937: Limit recursion in regexp matcher.\n\nAlso handle negative return code as an error in the JS bindings.",
    "before_after_code_files": [
      "jsregexp.c||jsregexp.c",
      "jsstring.c||jsstring.c",
      "regexp.c||regexp.c"
    ]
  },
  "patch_diff": {
    "jsregexp.c||jsregexp.c": [
      "File: jsregexp.c -> jsregexp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "30: void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)",
      "31: {",
      "32:  int i;",
      "33:  int opts;",
      "34:  Resub m;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "32:  int result;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "46:   }",
      "47:  }",
      "50:   js_newarray(J);",
      "51:   js_pushstring(J, text);",
      "52:   js_setproperty(J, -2, \"input\");",
      "",
      "[Removed Lines]",
      "49:  if (!js_regexec(re->prog, text, &m, opts)) {",
      "",
      "[Added Lines]",
      "50:  result = js_regexec(re->prog, text, &m, opts);",
      "51:  if (result < 0)",
      "52:   js_error(J, \"regexec failed\");",
      "53:  if (result == 0) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "71: {",
      "72:  js_Regexp *re;",
      "73:  const char *text;",
      "74:  int opts;",
      "75:  Resub m;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "78:  int result;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "90:   }",
      "91:  }",
      "94:   if (re->flags & JS_REGEXP_G)",
      "95:    re->last = re->last + (m.sub[0].ep - text);",
      "96:   js_pushboolean(J, 1);",
      "",
      "[Removed Lines]",
      "93:  if (!js_regexec(re->prog, text, &m, opts)) {",
      "",
      "[Added Lines]",
      "98:  result = js_regexec(re->prog, text, &m, opts);",
      "99:  if (result < 0)",
      "100:   js_error(J, \"regexec failed\");",
      "101:  if (result == 0) {",
      "",
      "---------------"
    ],
    "jsstring.c||jsstring.c": [
      "File: jsstring.c -> jsstring.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "4: #include \"utf.h\"",
      "5: #include \"regexp.h\"",
      "7: static const char *checkstring(js_State *J, int idx)",
      "8: {",
      "9:  if (!js_iscoercible(J, idx))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "7: static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)",
      "8: {",
      "9:  int result = js_regexec(prog, string, sub, eflags);",
      "10:  if (result < 0)",
      "11:   js_error(J, \"regexec failed\");",
      "12:  return result;",
      "13: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "343:  a = text;",
      "344:  e = text + strlen(text);",
      "345:  while (a <= e) {",
      "347:    break;",
      "349:   b = m.sub[0].sp;",
      "",
      "[Removed Lines]",
      "346:   if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))",
      "",
      "[Added Lines]",
      "354:   if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "381:  re = js_toregexp(J, -1);",
      "384:   js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));",
      "385:  else",
      "386:   js_pushnumber(J, -1);",
      "",
      "[Removed Lines]",
      "383:  if (!js_regexec(re->prog, text, &m, 0))",
      "",
      "[Added Lines]",
      "391:  if (!js_doregexec(J, re->prog, text, &m, 0))",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "397:  source = checkstring(J, 0);",
      "398:  re = js_toregexp(J, 1);",
      "401:   js_copy(J, 0);",
      "402:   return;",
      "403:  }",
      "",
      "[Removed Lines]",
      "400:  if (js_regexec(re->prog, source, &m, 0)) {",
      "",
      "[Added Lines]",
      "408:  if (js_doregexec(J, re->prog, source, &m, 0)) {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "471:    else",
      "472:     goto end;",
      "473:   }",
      "475:    goto loop;",
      "476:  }",
      "",
      "[Removed Lines]",
      "474:   if (!js_regexec(re->prog, source, &m, REG_NOTBOL))",
      "",
      "[Added Lines]",
      "482:   if (!js_doregexec(J, re->prog, source, &m, REG_NOTBOL))",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "578:  if (e == text) {",
      "580:    if (len == limit) return;",
      "581:    js_pushliteral(J, \"\");",
      "582:    js_setindex(J, -2, 0);",
      "",
      "[Removed Lines]",
      "579:   if (js_regexec(re->prog, text, &m, 0)) {",
      "",
      "[Added Lines]",
      "587:   if (js_doregexec(J, re->prog, text, &m, 0)) {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "587:  p = a = text;",
      "588:  while (a < e) {",
      "592:   b = m.sub[0].sp;",
      "",
      "[Removed Lines]",
      "589:   if (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))",
      "",
      "[Added Lines]",
      "597:   if (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))",
      "",
      "---------------"
    ],
    "regexp.c||regexp.c": [
      "File: regexp.c -> regexp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "16: #define REPINF 255",
      "17: #define MAXSUB REG_MAXSUB",
      "18: #define MAXPROG (32 << 10)",
      "20: typedef struct Reclass Reclass;",
      "21: typedef struct Renode Renode;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "19: #define MAXREC 1024",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "967:  return 0;",
      "968: }",
      "971: {",
      "972:  Resub scratch;",
      "973:  int i;",
      "974:  Rune c;",
      "976:  for (;;) {",
      "977:   switch (pc->opcode) {",
      "978:   case I_END:",
      "980:   case I_JUMP:",
      "981:    pc = pc->x;",
      "982:    break;",
      "983:   case I_SPLIT:",
      "984:    scratch = *out;",
      "988:    }",
      "989:    pc = pc->y;",
      "990:    break;",
      "992:   case I_PLA:",
      "995:    pc = pc->y;",
      "996:    break;",
      "997:   case I_NLA:",
      "998:    scratch = *out;",
      "1001:    pc = pc->y;",
      "1002:    break;",
      "1004:   case I_ANYNL:",
      "1005:    sp += chartorune(&c, sp);",
      "1006:    if (c == 0)",
      "1008:    pc = pc + 1;",
      "1009:    break;",
      "1010:   case I_ANY:",
      "1011:    sp += chartorune(&c, sp);",
      "1012:    if (c == 0)",
      "1014:    if (isnewline(c))",
      "1016:    pc = pc + 1;",
      "1017:    break;",
      "1018:   case I_CHAR:",
      "1019:    sp += chartorune(&c, sp);",
      "1020:    if (c == 0)",
      "1022:    if (flags & REG_ICASE)",
      "1023:     c = canon(c);",
      "1024:    if (c != pc->c)",
      "1026:    pc = pc + 1;",
      "1027:    break;",
      "1028:   case I_CCLASS:",
      "1029:    sp += chartorune(&c, sp);",
      "1030:    if (c == 0)",
      "1032:    if (flags & REG_ICASE) {",
      "1033:     if (!incclasscanon(pc->cc, canon(c)))",
      "1035:    } else {",
      "1036:     if (!incclass(pc->cc, c))",
      "1038:    }",
      "1039:    pc = pc + 1;",
      "1040:    break;",
      "1041:   case I_NCCLASS:",
      "1042:    sp += chartorune(&c, sp);",
      "1043:    if (c == 0)",
      "1045:    if (flags & REG_ICASE) {",
      "1046:     if (incclasscanon(pc->cc, canon(c)))",
      "1048:    } else {",
      "1049:     if (incclass(pc->cc, c))",
      "1051:    }",
      "1052:    pc = pc + 1;",
      "1053:    break;",
      "",
      "[Removed Lines]",
      "970: static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out)",
      "979:    return 1;",
      "985:    if (match(pc->x, sp, bol, flags, &scratch)) {",
      "987:     return 1;",
      "993:    if (!match(pc->x, sp, bol, flags, out))",
      "994:     return 0;",
      "999:    if (match(pc->x, sp, bol, flags, &scratch))",
      "1000:     return 0;",
      "1007:     return 0;",
      "1013:     return 0;",
      "1015:     return 0;",
      "1021:     return 0;",
      "1025:     return 0;",
      "1031:     return 0;",
      "1034:      return 0;",
      "1037:      return 0;",
      "1044:     return 0;",
      "1047:      return 0;",
      "1050:      return 0;",
      "",
      "[Added Lines]",
      "971: static int match(Reinst *pc, const char *sp, const char *bol, int flags, Resub *out, int depth)",
      "974:  int result;",
      "979:  if (depth > MAXREC)",
      "980:   return -1;",
      "985:    return 0;",
      "991:    result = match(pc->x, sp, bol, flags, &scratch, depth+1);",
      "992:    if (result == -1)",
      "993:     return -1;",
      "994:    if (result == 0) {",
      "996:     return 0;",
      "1002:    result = match(pc->x, sp, bol, flags, out, depth+1);",
      "1003:    if (result == -1)",
      "1004:     return -1;",
      "1005:    if (result == 1)",
      "1006:     return 1;",
      "1011:    result = match(pc->x, sp, bol, flags, &scratch, depth+1);",
      "1012:    if (result == -1)",
      "1013:     return -1;",
      "1014:    if (result == 0)",
      "1015:     return 1;",
      "1022:     return 1;",
      "1028:     return 1;",
      "1030:     return 1;",
      "1036:     return 1;",
      "1040:     return 1;",
      "1046:     return 1;",
      "1049:      return 1;",
      "1052:      return 1;",
      "1059:     return 1;",
      "1062:      return 1;",
      "1065:      return 1;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "1055:    i = out->sub[pc->n].ep - out->sub[pc->n].sp;",
      "1056:    if (flags & REG_ICASE) {",
      "1057:     if (strncmpcanon(sp, out->sub[pc->n].sp, i))",
      "1059:    } else {",
      "1060:     if (strncmp(sp, out->sub[pc->n].sp, i))",
      "1062:    }",
      "1063:    if (i > 0)",
      "1064:     sp += i;",
      "",
      "[Removed Lines]",
      "1058:      return 0;",
      "1061:      return 0;",
      "",
      "[Added Lines]",
      "1073:      return 1;",
      "1076:      return 1;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "1076:      break;",
      "1077:     }",
      "1078:    }",
      "1080:   case I_EOL:",
      "1081:    if (*sp == 0) {",
      "1082:     pc = pc + 1;",
      "",
      "[Removed Lines]",
      "1079:    return 0;",
      "",
      "[Added Lines]",
      "1094:    return 1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "1088:      break;",
      "1089:     }",
      "1090:    }",
      "1092:   case I_WORD:",
      "1093:    i = sp > bol && iswordchar(sp[-1]);",
      "1094:    i ^= iswordchar(sp[0]);",
      "1095:    if (!i)",
      "1097:    pc = pc + 1;",
      "1098:    break;",
      "1099:   case I_NWORD:",
      "1100:    i = sp > bol && iswordchar(sp[-1]);",
      "1101:    i ^= iswordchar(sp[0]);",
      "1102:    if (i)",
      "1104:    pc = pc + 1;",
      "1105:    break;",
      "",
      "[Removed Lines]",
      "1091:    return 0;",
      "1096:     return 0;",
      "1103:     return 0;",
      "",
      "[Added Lines]",
      "1106:    return 1;",
      "1111:     return 1;",
      "1118:     return 1;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "1113:    pc = pc + 1;",
      "1114:    break;",
      "1115:   default:",
      "1117:   }",
      "1118:  }",
      "1119: }",
      "",
      "[Removed Lines]",
      "1116:    return 0;",
      "",
      "[Added Lines]",
      "1131:    return 1;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "1130:  for (i = 0; i < MAXSUB; ++i)",
      "1131:   sub->sub[i].sp = sub->sub[i].ep = NULL;",
      "1134: }",
      "1136: #ifdef TEST",
      "",
      "[Removed Lines]",
      "1133:  return !match(prog->start, sp, sp, prog->flags | eflags, sub);",
      "",
      "[Added Lines]",
      "1148:  return match(prog->start, sp, sp, prog->flags | eflags, sub, 0);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b4484ab18a8bca9feed3555c2b6f5d029ca2c052",
      "candidate_info": {
        "commit_hash": "b4484ab18a8bca9feed3555c2b6f5d029ca2c052",
        "repo": "ccxvii/mujs",
        "commit_url": "https://github.com/ccxvii/mujs/commit/b4484ab18a8bca9feed3555c2b6f5d029ca2c052",
        "files": [
          "regexp.c",
          "regexp.h"
        ],
        "message": "Issue 118: Add REG_ to limit defines, and use REG_MAXSUB in header.",
        "before_after_code_files": [
          "regexp.c||regexp.c",
          "regexp.h||regexp.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "regexp.c||regexp.c"
          ],
          "candidate": [
            "regexp.c||regexp.c"
          ]
        }
      },
      "candidate_diff": {
        "regexp.c||regexp.c": [
          "File: regexp.c -> regexp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #define nelem(a) (int)(sizeof (a) / sizeof (a)[0])",
          "16: #define REPINF 255",
          "19: #endif",
          "22: #endif",
          "25: #endif",
          "31: #endif",
          "33: typedef struct Reclass Reclass;",
          "",
          "[Removed Lines]",
          "17: #ifndef MAXSUB",
          "18: #define MAXSUB REG_MAXSUB",
          "20: #ifndef MAXPROG",
          "21: #define MAXPROG (32 << 10)",
          "23: #ifndef MAXREC",
          "24: #define MAXREC 1024",
          "26: #ifndef MAXSPAN",
          "27: #define MAXSPAN 64",
          "28: #endif",
          "29: #ifndef MAXCLASS",
          "30: #define MAXCLASS 16",
          "",
          "[Added Lines]",
          "17: #ifndef REG_MAXPROG",
          "18: #define REG_MAXPROG (32 << 10)",
          "20: #ifndef REG_MAXREC",
          "21: #define REG_MAXREC 1024",
          "23: #ifndef REG_MAXSPAN",
          "24: #define REG_MAXSPAN 64",
          "26: #ifndef REG_MAXCLASS",
          "27: #define REG_MAXCLASS 16",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "38: struct Reclass {",
          "39:  Rune *end;",
          "41: };",
          "43: struct Reprog {",
          "44:  Reinst *start, *end;",
          "45:  int flags;",
          "46:  int nsub;",
          "48: };",
          "50: struct cstate {",
          "",
          "[Removed Lines]",
          "40:  Rune spans[MAXSPAN];",
          "47:  Reclass cclass[MAXCLASS];",
          "",
          "[Added Lines]",
          "37:  Rune spans[REG_MAXSPAN];",
          "44:  Reclass cclass[REG_MAXCLASS];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:  const char *source;",
          "55:  int ncclass;",
          "56:  int nsub;",
          "59:  int lookahead;",
          "60:  Rune yychar;",
          "",
          "[Removed Lines]",
          "57:  Renode *sub[MAXSUB];",
          "",
          "[Added Lines]",
          "54:  Renode *sub[REG_MAXSUB];",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "505:   return newnode(g, P_ANY);",
          "506:  if (accept(g, '(')) {",
          "507:   atom = newnode(g, P_PAR);",
          "509:    die(g, \"too many captures\");",
          "510:   atom->n = g->nsub++;",
          "511:   atom->x = parsealt(g);",
          "",
          "[Removed Lines]",
          "508:   if (g->nsub == MAXSUB)",
          "",
          "[Added Lines]",
          "505:   if (g->nsub == REG_MAXSUB)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "625:   if (min == max) n = count(g, node->x) * min;",
          "626:   else if (max < REPINF) n = count(g, node->x) * max + (max - min);",
          "627:   else n = count(g, node->x) * (min + 1) + 2;",
          "629:   return n;",
          "630:  case P_PAR: return count(g, node->x) + 2;",
          "631:  case P_PLA: return count(g, node->x) + 2;",
          "",
          "[Removed Lines]",
          "628:   if (n < 0 || n > MAXPROG) die(g, \"program too large\");",
          "",
          "[Added Lines]",
          "625:   if (n < 0 || n > REG_MAXPROG) die(g, \"program too large\");",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "849:  if (!g.prog)",
          "850:   die(&g, \"cannot allocate regular expression\");",
          "851:  n = strlen(pattern) * 2;",
          "853:   die(&g, \"program too large\");",
          "854:  if (n > 0) {",
          "855:   g.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n);",
          "",
          "[Removed Lines]",
          "852:  if (n > MAXPROG)",
          "",
          "[Added Lines]",
          "849:  if (n > REG_MAXPROG)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "860:  g.source = pattern;",
          "861:  g.ncclass = 0;",
          "862:  g.nsub = 1;",
          "864:   g.sub[i] = 0;",
          "866:  g.prog->flags = cflags;",
          "",
          "[Removed Lines]",
          "863:  for (i = 0; i < MAXSUB; ++i)",
          "",
          "[Added Lines]",
          "860:  for (i = 0; i < REG_MAXSUB; ++i)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "878: #endif",
          "880:  n = 6 + count(&g, node);",
          "882:   die(&g, \"program too large\");",
          "884:  g.prog->nsub = g.nsub;",
          "",
          "[Removed Lines]",
          "881:  if (n < 0 || n > MAXPROG)",
          "",
          "[Added Lines]",
          "878:  if (n < 0 || n > REG_MAXPROG)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "988:  Rune c;",
          "992:   return -1;",
          "994:  for (;;) {",
          "",
          "[Removed Lines]",
          "991:  if (depth > MAXREC)",
          "",
          "[Added Lines]",
          "988:  if (depth > REG_MAXREC)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1154:   sub = &scratch;",
          "1156:  sub->nsub = prog->nsub;",
          "1158:   sub->sub[i].sp = sub->sub[i].ep = NULL;",
          "1160:  return match(prog->start, sp, sp, prog->flags | eflags, sub, 0);",
          "",
          "[Removed Lines]",
          "1157:  for (i = 0; i < MAXSUB; ++i)",
          "",
          "[Added Lines]",
          "1154:  for (i = 0; i < REG_MAXSUB; ++i)",
          "",
          "---------------"
        ],
        "regexp.h||regexp.h": [
          "File: regexp.h -> regexp.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "28:  REG_NOTBOL = 4,",
          "32: };",
          "34: struct Resub {",
          "35:  int nsub;",
          "36:  struct {",
          "",
          "[Removed Lines]",
          "31:  REG_MAXSUB = 10",
          "",
          "[Added Lines]",
          "34: #ifndef REG_MAXSUB",
          "35: #define REG_MAXSUB 10",
          "36: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "8c868344b207fbcaee4622fb6c0b97d1bd5c79a9",
      "candidate_info": {
        "commit_hash": "8c868344b207fbcaee4622fb6c0b97d1bd5c79a9",
        "repo": "ccxvii/mujs",
        "commit_url": "https://github.com/ccxvii/mujs/commit/8c868344b207fbcaee4622fb6c0b97d1bd5c79a9",
        "files": [
          "jsdump.c",
          "jsi.h",
          "regexp.c"
        ],
        "message": "Issue 114: Allow compile time limits to be configured.",
        "before_after_code_files": [
          "jsdump.c||jsdump.c",
          "jsi.h||jsi.h",
          "regexp.c||regexp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "regexp.c||regexp.c"
          ],
          "candidate": [
            "regexp.c||regexp.c"
          ]
        }
      },
      "candidate_diff": {
        "jsdump.c||jsdump.c": [
          "File: jsdump.c -> jsdump.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "800:   switch (c) {",
          "801:   case OP_INTEGER:",
          "803:    break;",
          "804:   case OP_NUMBER:",
          "805:    printf(\" %.9g\", F->numtab[*p++]);",
          "",
          "[Removed Lines]",
          "802:    printf(\" %d\", (*p++) - 32768);",
          "",
          "[Added Lines]",
          "802:    printf(\" %ld\", (long)((*p++) - 32768));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "840:   case OP_JFALSE:",
          "841:   case OP_JCASE:",
          "842:   case OP_TRY:",
          "844:    break;",
          "845:   }",
          "",
          "[Removed Lines]",
          "843:    printf(\" %d\", *p++);",
          "",
          "[Added Lines]",
          "843:    printf(\" %ld\", (long)*p++);",
          "",
          "---------------"
        ],
        "jsi.h||jsi.h": [
          "File: jsi.h -> jsi.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "79: typedef unsigned short js_Instruction;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "72: #ifndef JS_STACKSIZE",
          "74: #endif",
          "75: #ifndef JS_ENVLIMIT",
          "77: #endif",
          "78: #ifndef JS_TRYLIMIT",
          "80: #endif",
          "81: #ifndef JS_GCLIMIT",
          "83: #endif",
          "84: #ifndef JS_ASTLIMIT",
          "86: #endif",
          "90: #ifdef JS_INSTRUCTION",
          "91: typedef JS_INSTRUCTION js_Instruction;",
          "92: #else",
          "94: #endif",
          "",
          "---------------"
        ],
        "regexp.c||regexp.c": [
          "File: regexp.c -> regexp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: #define nelem(a) (int)(sizeof (a) / sizeof (a)[0])",
          "16: #define REPINF 255",
          "17: #define MAXSUB REG_MAXSUB",
          "18: #define MAXPROG (32 << 10)",
          "19: #define MAXREC 1024",
          "21: typedef struct Reclass Reclass;",
          "22: typedef struct Renode Renode;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17: #ifndef MAXSUB",
          "19: #endif",
          "20: #ifndef MAXPROG",
          "22: #endif",
          "23: #ifndef MAXREC",
          "25: #endif",
          "26: #ifndef MAXSPAN",
          "27: #define MAXSPAN 64",
          "28: #endif",
          "29: #ifndef MAXCLASS",
          "30: #define MAXCLASS 16",
          "31: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "26: struct Reclass {",
          "27:  Rune *end;",
          "29: };",
          "31: struct Reprog {",
          "32:  Reinst *start, *end;",
          "33:  int flags;",
          "34:  int nsub;",
          "36: };",
          "38: struct cstate {",
          "",
          "[Removed Lines]",
          "28:  Rune spans[64];",
          "35:  Reclass cclass[16];",
          "",
          "[Added Lines]",
          "40:  Rune spans[MAXSPAN];",
          "47:  Reclass cclass[MAXCLASS];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "194: {",
          "195:  if (a > b)",
          "196:   die(g, \"invalid character class range\");",
          "198:   die(g, \"too many character class ranges\");",
          "",
          "[Removed Lines]",
          "197:  if (g->yycc->end + 2 == g->yycc->spans + nelem(g->yycc->spans))",
          "",
          "[Added Lines]",
          "209:  if (g->yycc->end + 2 >= g->yycc->spans + nelem(g->yycc->spans))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
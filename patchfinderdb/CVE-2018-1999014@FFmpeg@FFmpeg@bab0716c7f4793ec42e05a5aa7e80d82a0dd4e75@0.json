{
  "cve_id": "CVE-2018-1999014",
  "cve_desc": "FFmpeg before commit bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 contains an out of array access vulnerability in MXF format demuxer that can result in DoS. This attack appear to be exploitable via specially crafted MXF file which has to be provided as input. This vulnerability appears to have been fixed in bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 and later.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75",
  "patch_info": {
    "commit_hash": "bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75",
    "files": [
      "libavformat/mxfdec.c"
    ],
    "message": "avformat/mxfdec: Fix av_log context\n\nFixes: out of array access\nFixes: mxf-crash-1c2e59bf07a34675bfb3ada5e1ec22fa9f38f923\n\nFound-by: Paul Ch <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavformat/mxfdec.c||libavformat/mxfdec.c"
    ]
  },
  "patch_diff": {
    "libavformat/mxfdec.c||libavformat/mxfdec.c": [
      "File: libavformat/mxfdec.c -> libavformat/mxfdec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2155:                 MXFEssenceContainerData *essence_data;",
      "2157:                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {",
      "2159:                     continue;",
      "2160:                 }",
      "2161:                 if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {",
      "",
      "[Removed Lines]",
      "2158:                     av_log(mxf, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");",
      "",
      "[Added Lines]",
      "2158:                     av_log(mxf->fc, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a28ab09e2a2ac3fcc61e77ff5d702d9157eb37bc",
      "candidate_info": {
        "commit_hash": "a28ab09e2a2ac3fcc61e77ff5d702d9157eb37bc",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/a28ab09e2a2ac3fcc61e77ff5d702d9157eb37bc",
        "files": [
          "libavformat/mxfdec.c"
        ],
        "message": "avformat/mxfdec: Fix av_log context\n\nFixes: out of array access\nFixes: mxf-crash-1c2e59bf07a34675bfb3ada5e1ec22fa9f38f923\n\nFound-by: Paul Ch <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavformat/mxfdec.c||libavformat/mxfdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/mxfdec.c||libavformat/mxfdec.c"
          ],
          "candidate": [
            "libavformat/mxfdec.c||libavformat/mxfdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/mxfdec.c||libavformat/mxfdec.c": [
          "File: libavformat/mxfdec.c -> libavformat/mxfdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2085:                 MXFEssenceContainerData *essence_data;",
          "2087:                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {",
          "2089:                     continue;",
          "2090:                 }",
          "2091:                 if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {",
          "",
          "[Removed Lines]",
          "2088:                     av_log(mxf, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");",
          "",
          "[Added Lines]",
          "2088:                     av_log(mxf->fc, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9492bb58eeea474158f9c523fd77395629117b57",
      "candidate_info": {
        "commit_hash": "9492bb58eeea474158f9c523fd77395629117b57",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/9492bb58eeea474158f9c523fd77395629117b57",
        "files": [
          "libavformat/mxfdec.c"
        ],
        "message": "avformat/mxfdec: use both body_sid and track_number to find the track of a packet\n\nIn order to do that we have to parse the EssenceContainerData and assign the\nproper body_sid and index_sid to the tracks from the corresponding source\npackages.\n\nThis fixes packets returned in the wrong stream for some OP1-b files.\n\nBased on a patch by Alex Mogurenko from https://github.com/da8eat/FFmpeg\n\nReference: http://mogurenko.com/2018/01/02/mxf-op1b-ffmpeg-part1/\n\nSigned-off-by: Marton Balint <cus@passwd.hu>",
        "before_after_code_files": [
          "libavformat/mxfdec.c||libavformat/mxfdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/mxfdec.c||libavformat/mxfdec.c"
          ],
          "candidate": [
            "libavformat/mxfdec.c||libavformat/mxfdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/mxfdec.c||libavformat/mxfdec.c": [
          "File: libavformat/mxfdec.c -> libavformat/mxfdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "162:     int intra_only;",
          "163:     uint64_t sample_count;",
          "165: } MXFTrack;",
          "167: typedef struct MXFDescriptor {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "165:     int index_sid;",
          "166:     int body_sid;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:     int comment_count;",
          "224: } MXFPackage;",
          "226: typedef struct MXFMetadataSet {",
          "227:     UID uid;",
          "228:     enum MXFMetadataSetType type;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "228: typedef struct MXFEssenceContainerData {",
          "229:     UID uid;",
          "230:     enum MXFMetadataSetType type;",
          "231:     UID package_uid;",
          "232:     UID package_ul;",
          "233:     int index_sid;",
          "234:     int body_sid;",
          "235: } MXFEssenceContainerData;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "247:     MXFOP op;",
          "248:     UID *packages_refs;",
          "249:     int packages_count;",
          "250:     MXFMetadataSet **metadata_sets;",
          "251:     int metadata_sets_count;",
          "252:     AVFormatContext *fc;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "261:     UID *essence_container_data_refs;",
          "262:     int essence_container_data_count;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "385:     return klv->length == -1 ? -1 : 0;",
          "386: }",
          "389: {",
          "390:     int i;",
          "392:     for (i = 0; i < s->nb_streams; i++) {",
          "393:         MXFTrack *track = s->streams[i]->priv_data;",
          "396:             return i;",
          "397:     }",
          "399:     return s->nb_streams == 1 ? 0 : -1;",
          "400: }",
          "403: static int mxf_get_d10_aes3_packet(AVIOContext *pb, AVStream *st, AVPacket *pkt, int64_t length)",
          "404: {",
          "",
          "[Removed Lines]",
          "388: static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)",
          "395:         if (track && !memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))",
          "",
          "[Added Lines]",
          "401: static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv, int body_sid)",
          "408:         if (track && (!body_sid || !track->body_sid || track->body_sid == body_sid) && !memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))",
          "415: static int find_body_sid_by_offset(MXFContext *mxf, int64_t offset)",
          "416: {",
          "418:     int a, b, m;",
          "419:     int64_t this_partition;",
          "421:     a = -1;",
          "422:     b = mxf->partitions_count;",
          "424:     while (b - a > 1) {",
          "425:         m         = (a + b) >> 1;",
          "426:         this_partition = mxf->partitions[m].this_partition;",
          "427:         if (this_partition <= offset)",
          "428:             a = m;",
          "429:         else",
          "430:             b = m;",
          "431:     }",
          "433:     if (a == -1)",
          "434:         return 0;",
          "435:     return mxf->partitions[a].body_sid;",
          "436: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "440:     uint8_t ivec[16];",
          "441:     uint8_t tmpbuf[16];",
          "442:     int index;",
          "444:     if (!mxf->aesc && s->key && s->keylen == 16) {",
          "445:         mxf->aesc = av_aes_alloc();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "479:     int body_sid;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "457:     avio_read(pb, klv->key, 16);",
          "458:     if (!IS_KLV_KEY(klv, mxf_essence_element_key))",
          "459:         return AVERROR_INVALIDDATA;",
          "461:     if (index < 0)",
          "462:         return AVERROR_INVALIDDATA;",
          "",
          "[Removed Lines]",
          "460:     index = mxf_get_stream_index(s, klv);",
          "",
          "[Added Lines]",
          "498:     body_sid = find_body_sid_by_offset(mxf, klv->offset);",
          "499:     index = mxf_get_stream_index(s, klv, body_sid);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "757:             av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple packages_refs\\n\");",
          "758:         av_free(mxf->packages_refs);",
          "759:         return mxf_read_strong_ref_array(pb, &mxf->packages_refs, &mxf->packages_count);",
          "760:     }",
          "761:     return 0;",
          "762: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "799:     case 0x1902:",
          "800:         av_free(mxf->essence_container_data_refs);",
          "801:         return mxf_read_strong_ref_array(pb, &mxf->essence_container_data_refs, &mxf->essence_container_data_count);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "893:     return 0;",
          "894: }",
          "896: static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)",
          "897: {",
          "898:     int i, length;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "938: static int mxf_read_essence_container_data(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)",
          "939: {",
          "940:     MXFEssenceContainerData *essence_data = arg;",
          "941:     switch(tag) {",
          "942:         case 0x2701:",
          "944:             avio_read(pb, essence_data->package_ul, 16);",
          "945:             avio_read(pb, essence_data->package_uid, 16);",
          "946:             break;",
          "947:         case 0x3f06:",
          "948:             essence_data->index_sid = avio_rb32(pb);",
          "949:             break;",
          "950:         case 0x3f07:",
          "951:             essence_data->body_sid = avio_rb32(pb);",
          "952:             break;",
          "953:     }",
          "954:     return 0;",
          "955: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1996:                 av_log(mxf->fc, AV_LOG_ERROR, \"material track %d: no corresponding source track found\\n\", material_track->track_id);",
          "1997:                 break;",
          "1998:             }",
          "1999:             if(source_track && component)",
          "2000:                 break;",
          "2001:         }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2061:             for (k = 0; k < mxf->essence_container_data_count; k++) {",
          "2062:                 MXFEssenceContainerData *essence_data;",
          "2064:                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {",
          "2065:                     av_log(mxf, AV_LOG_TRACE, \"could not resolve essence container data strong ref\\n\");",
          "2066:                     continue;",
          "2067:                 }",
          "2068:                 if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) {",
          "2069:                     source_track->body_sid = essence_data->body_sid;",
          "2070:                     source_track->index_sid = essence_data->index_sid;",
          "2071:                     break;",
          "2072:                 }",
          "2073:             }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2402:     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x0c,0x00 }, mxf_read_pulldown_component, sizeof(MXFPulldownComponent), PulldownComponent },",
          "2403:     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x04,0x01,0x02,0x02,0x00,0x00 }, mxf_read_cryptographic_context, sizeof(MXFCryptoContext), CryptoContext },",
          "2404:     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x02,0x01,0x01,0x10,0x01,0x00 }, mxf_read_index_table_segment, sizeof(MXFIndexTableSegment), IndexTableSegment },",
          "2405:     { { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 }, NULL, 0, AnyType },",
          "2406: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2481:     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x23,0x00 }, mxf_read_essence_container_data, sizeof(MXFEssenceContainerData), EssenceContainerData },",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "3111:         if (IS_KLV_KEY(klv.key, mxf_essence_element_key) ||",
          "3112:             IS_KLV_KEY(klv.key, mxf_canopus_essence_element_key) ||",
          "3113:             IS_KLV_KEY(klv.key, mxf_avid_essence_element_key)) {",
          "3115:             int64_t next_ofs, next_klv;",
          "3116:             AVStream *st;",
          "",
          "[Removed Lines]",
          "3114:             int index = mxf_get_stream_index(s, &klv);",
          "",
          "[Added Lines]",
          "3191:             int body_sid = find_body_sid_by_offset(mxf, klv.offset);",
          "3192:             int index = mxf_get_stream_index(s, &klv, body_sid);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "3237:     int i;",
          "3239:     av_freep(&mxf->packages_refs);",
          "3241:     for (i = 0; i < s->nb_streams; i++)",
          "3242:         s->streams[i]->priv_data = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3318:     av_freep(&mxf->essence_container_data_refs);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
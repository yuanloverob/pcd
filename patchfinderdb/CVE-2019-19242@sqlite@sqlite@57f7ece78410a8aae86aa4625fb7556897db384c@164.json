{
  "cve_id": "CVE-2019-19242",
  "cve_desc": "SQLite 3.30.1 mishandles pExpr->y.pTab, as demonstrated by the TK_COLUMN case in sqlite3ExprCodeTarget in expr.c.",
  "repo": "sqlite/sqlite",
  "patch_hash": "57f7ece78410a8aae86aa4625fb7556897db384c",
  "patch_info": {
    "commit_hash": "57f7ece78410a8aae86aa4625fb7556897db384c",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/57f7ece78410a8aae86aa4625fb7556897db384c",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/expr.c",
      "src/wherecode.c",
      "test/gencol1.test"
    ],
    "message": "Fix a problem that comes up when using generated columns that evaluate to a constant in an index and then making use of that index in a join.\n\nFossilOrigin-Name: 8b12e95fec7ce6e0de82a04ca3dfcf1a8e62e233b7382aa28a8a9be6e862b1af",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/expr.c||src/expr.c",
      "src/wherecode.c||src/wherecode.c",
      "test/gencol1.test||test/gencol1.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 2d53a30cc23e53033af8e8666457654db5dcc453ed6cd176ce1d0bff4f528159",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/expr.c||src/expr.c": [
      "File: src/expr.c -> src/expr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3607:         int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);",
      "3609:         if( aff>SQLITE_AFF_BLOB ){",
      "3610:           static const char zAff[] = \"B\\000C\\000D\\000E\";",
      "3611:           assert( SQLITE_AFF_BLOB=='A' );",
      "",
      "[Removed Lines]",
      "3608:         int aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);",
      "",
      "[Added Lines]",
      "3608:         int aff;",
      "3609:         if( pExpr->y.pTab ){",
      "3610:           aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);",
      "3611:         }else{",
      "3612:           aff = pExpr->affExpr;",
      "3613:         }",
      "",
      "---------------"
    ],
    "src/wherecode.c||src/wherecode.c": [
      "File: src/wherecode.c -> src/wherecode.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1141:   if( pExpr->op==TK_COLUMN ){",
      "1142:     IdxExprTrans *pX = p->u.pIdxTrans;",
      "1143:     if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){",
      "1144:       pExpr->iTable = pX->iIdxCur;",
      "1145:       pExpr->iColumn = pX->iIdxCol;",
      "1146:       pExpr->y.pTab = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1144:       assert( pExpr->y.pTab!=0 );",
      "1145:       pExpr->affExpr = sqlite3TableColumnAffinity(pExpr->y.pTab,pExpr->iColumn);",
      "",
      "---------------"
    ],
    "test/gencol1.test||test/gencol1.test": [
      "File: test/gencol1.test -> test/gencol1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "243:   UPDATE t0 SET c0 = NULL;",
      "244: } {1 {generated column loop on \"c2\"}}",
      "247: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "246: # 2019-11-21 Problems in the new generated column logic",
      "247: # reported by Yongheng Chen and Rui Zhong",
      "248: do_execsql_test gencol1-9.10 {",
      "249:   DROP TABLE IF EXISTS t1;",
      "250:   DROP TABLE IF EXISTS t2;",
      "251:   CREATE TABLE t1(aa , bb AS (17) UNIQUE);",
      "252:   INSERT INTO t1 VALUES(17);",
      "253:   CREATE TABLE t2(cc);",
      "254:   INSERT INTO t2 VALUES(41);",
      "255:   SELECT * FROM t2 JOIN t1 WHERE t1.bb=t1.aa AND t1.bb=17;",
      "256: } {41 17 17}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
      "candidate_info": {
        "commit_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/85bcdce270575e78258148c00f2efff7e81e7bc1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/sqliteInt.h",
          "src/wherecode.c"
        ],
        "message": "Split the code generation for the RHS of IN operators and for SELECT and EXISTS expressions into two separate subroutines, because there is now little commonality between those to functions. This is intended to help make the code easier to read and maintain.\n\nFossilOrigin-Name: 2b6494b1509f0d0189f98aa34c990eee99c775ff57826e79b2c5b0a12b4c97ad",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/wherecode.c||src/wherecode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c",
            "src/wherecode.c||src/wherecode.c"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid",
            "src/expr.c||src/expr.c",
            "src/wherecode.c||src/wherecode.c"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6231485114eb07b258cd0e6e163ca05f7e9cf5664e071808fcb1329b33e4c4f5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "481:   int reg = 0;",
          "482: #ifndef SQLITE_OMIT_SUBQUERY",
          "483:   if( pExpr->op==TK_SELECT ){",
          "485:   }",
          "486: #endif",
          "487:   return reg;",
          "",
          "[Removed Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "",
          "[Added Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2542:     }else if( prRhsHasNull ){",
          "2544:     }",
          "2546:     pParse->nQueryLoop = savedNQueryLoop;",
          "2547:   }else{",
          "2548:     pX->iTable = iTab;",
          "",
          "[Removed Lines]",
          "2545:     sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==IN_INDEX_ROWID);",
          "",
          "[Added Lines]",
          "2545:     assert( pX->op==TK_IN );",
          "2546:     sqlite3CodeRhsOfIN(pParse, pX, eType==IN_INDEX_ROWID);",
          "2547:     if( rMayHaveNull ){",
          "2548:       sqlite3SetHasNullFlag(v, pX->iTable, rMayHaveNull);",
          "2549:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2626:   }",
          "2627: }",
          "2664: ){",
          "",
          "[Removed Lines]",
          "2658: #ifndef SQLITE_OMIT_SUBQUERY",
          "2659: int sqlite3CodeSubselect(",
          "2667:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2668:   if( NEVER(v==0) ) return 0;",
          "",
          "[Added Lines]",
          "2633: #ifndef SQLITE_OMIT_SUBQUERY",
          "2658: void sqlite3CodeRhsOfIN(",
          "2670:   v = sqlite3GetVdbe(pParse);",
          "2671:   assert( v!=0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2681:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2682:   }",
          "2810:       }",
          "2813:       }",
          "2815:     }",
          "2859:       }",
          "2864:       }else{",
          "2870:       }",
          "2874:     }",
          "2875:   }",
          "2879:   }",
          "2881:   if( jmpIfDynamic>=0 ){",
          "2882:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "",
          "[Removed Lines]",
          "2684:   switch( pExpr->op ){",
          "2685:     case TK_IN: {",
          "2691:       nVal = sqlite3ExprVectorSize(pLeft);",
          "2692:       assert( !isRowid || nVal==1 );",
          "2707:       pExpr->iTable = pParse->nTab++;",
          "2708:       addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2709:           pExpr->iTable, (isRowid?0:nVal));",
          "2710:       pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2712:       if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2718:         Select *pSelect = pExpr->x.pSelect;",
          "2719:         ExprList *pEList = pSelect->pEList;",
          "2721:         ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2722:             jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2723:         ));",
          "2724:         assert( !isRowid );",
          "2727:         if( ALWAYS(pEList->nExpr==nVal) ){",
          "2728:           SelectDest dest;",
          "2729:           int i;",
          "2730:           sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2731:           dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2732:           pSelect->iLimit = 0;",
          "2733:           testcase( pSelect->selFlags & SF_Distinct );",
          "2735:           if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2736:             sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2737:             sqlite3KeyInfoUnref(pKeyInfo);",
          "2738:             return 0;",
          "2739:           }",
          "2740:           sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2742:           assert( pEList!=0 );",
          "2743:           assert( pEList->nExpr>0 );",
          "2744:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2745:           for(i=0; i<nVal; i++){",
          "2746:             Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2747:             pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2748:                 pParse, p, pEList->a[i].pExpr",
          "2749:             );",
          "2750:           }",
          "2751:         }",
          "2752:       }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2761:         int i;",
          "2762:         ExprList *pList = pExpr->x.pList;",
          "2763:         struct ExprList_item *pItem;",
          "2764:         int r1, r2, r3;",
          "2765:         affinity = sqlite3ExprAffinity(pLeft);",
          "2766:         if( !affinity ){",
          "2767:           affinity = SQLITE_AFF_BLOB;",
          "2768:         }",
          "2769:         if( pKeyInfo ){",
          "2770:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2771:           pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2772:         }",
          "2775:         r1 = sqlite3GetTempReg(pParse);",
          "2776:         r2 = sqlite3GetTempReg(pParse);",
          "2777:         if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2778:         for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2779:           Expr *pE2 = pItem->pExpr;",
          "2780:           int iValToIns;",
          "2787:           if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2788:             sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2789:             jmpIfDynamic = -1;",
          "2790:           }",
          "2793:           if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2794:             sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2795:           }else{",
          "2796:             r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2797:             if( isRowid ){",
          "2798:               sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2799:                                 sqlite3VdbeCurrentAddr(v)+2);",
          "2800:               VdbeCoverage(v);",
          "2801:               sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2802:             }else{",
          "2803:               sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2804:               sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2805:             }",
          "2806:           }",
          "2807:         }",
          "2808:         sqlite3ReleaseTempReg(pParse, r1);",
          "2809:         sqlite3ReleaseTempReg(pParse, r2);",
          "2811:       if( pKeyInfo ){",
          "2812:         sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2814:       break;",
          "2817:     case TK_EXISTS:",
          "2818:     case TK_SELECT:",
          "2819:     default: {",
          "2838:       testcase( pExpr->op==TK_EXISTS );",
          "2839:       testcase( pExpr->op==TK_SELECT );",
          "2840:       assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2841:       assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2843:       pSel = pExpr->x.pSelect;",
          "2844:       ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2845:             jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2846:       nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2847:       sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2848:       pParse->nMem += nReg;",
          "2849:       if( pExpr->op==TK_SELECT ){",
          "2850:         dest.eDest = SRT_Mem;",
          "2851:         dest.iSdst = dest.iSDParm;",
          "2852:         dest.nSdst = nReg;",
          "2853:         sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2854:         VdbeComment((v, \"Init subquery result\"));",
          "2855:       }else{",
          "2856:         dest.eDest = SRT_Exists;",
          "2857:         sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2858:         VdbeComment((v, \"Init EXISTS result\"));",
          "2860:       pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2861:       if( pSel->pLimit ){",
          "2862:         sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2863:         pSel->pLimit->pLeft = pLimit;",
          "2865:         pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2866:       }",
          "2867:       pSel->iLimit = 0;",
          "2868:       if( sqlite3Select(pParse, pSel, &dest) ){",
          "2869:         return 0;",
          "2871:       rReg = dest.iSDParm;",
          "2872:       ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "2873:       break;",
          "2877:   if( rHasNullFlag ){",
          "2878:     sqlite3SetHasNullFlag(v, pExpr->iTable, rHasNullFlag);",
          "",
          "[Added Lines]",
          "2688:   pLeft = pExpr->pLeft;",
          "2689:   nVal = sqlite3ExprVectorSize(pLeft);",
          "2690:   assert( !isRowid || nVal==1 );",
          "2695:   pExpr->iTable = pParse->nTab++;",
          "2696:   addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2697:       pExpr->iTable, (isRowid?0:nVal));",
          "2698:   pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2700:   if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2706:     Select *pSelect = pExpr->x.pSelect;",
          "2707:     ExprList *pEList = pSelect->pEList;",
          "2709:     ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2710:         jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2711:     ));",
          "2712:     assert( !isRowid );",
          "2715:     if( ALWAYS(pEList->nExpr==nVal) ){",
          "2716:       SelectDest dest;",
          "2717:       int i;",
          "2718:       sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2719:       dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2720:       pSelect->iLimit = 0;",
          "2721:       testcase( pSelect->selFlags & SF_Distinct );",
          "2723:       if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2724:         sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2725:         sqlite3KeyInfoUnref(pKeyInfo);",
          "2726:         return;",
          "2728:       sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2730:       assert( pEList!=0 );",
          "2731:       assert( pEList->nExpr>0 );",
          "2732:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2733:       for(i=0; i<nVal; i++){",
          "2734:         Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2735:         pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2736:             pParse, p, pEList->a[i].pExpr",
          "2737:         );",
          "2740:   }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2749:     int i;",
          "2750:     ExprList *pList = pExpr->x.pList;",
          "2751:     struct ExprList_item *pItem;",
          "2752:     int r1, r2, r3;",
          "2753:     affinity = sqlite3ExprAffinity(pLeft);",
          "2754:     if( !affinity ){",
          "2755:       affinity = SQLITE_AFF_BLOB;",
          "2756:     }",
          "2757:     if( pKeyInfo ){",
          "2758:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2759:       pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2760:     }",
          "2763:     r1 = sqlite3GetTempReg(pParse);",
          "2764:     r2 = sqlite3GetTempReg(pParse);",
          "2765:     if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2766:     for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2767:       Expr *pE2 = pItem->pExpr;",
          "2768:       int iValToIns;",
          "2775:       if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2776:         sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2777:         jmpIfDynamic = -1;",
          "2781:       if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2782:         sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2784:         r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2785:         if( isRowid ){",
          "2786:           sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2787:                             sqlite3VdbeCurrentAddr(v)+2);",
          "2788:           VdbeCoverage(v);",
          "2789:           sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2790:         }else{",
          "2791:           sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2792:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2793:         }",
          "2796:     sqlite3ReleaseTempReg(pParse, r1);",
          "2797:     sqlite3ReleaseTempReg(pParse, r2);",
          "2799:   if( pKeyInfo ){",
          "2800:     sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2801:   }",
          "2802:   if( jmpIfDynamic>=0 ){",
          "2803:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "2804:   }",
          "2805: }",
          "2822: #ifndef SQLITE_OMIT_SUBQUERY",
          "2823: int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){",
          "2830:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2831:   assert( v!=0 );",
          "2843:   if( !ExprHasProperty(pExpr, EP_VarSelect) ){",
          "2844:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2845:   }",
          "2857:   testcase( pExpr->op==TK_EXISTS );",
          "2858:   testcase( pExpr->op==TK_SELECT );",
          "2859:   assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2860:   assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2862:   pSel = pExpr->x.pSelect;",
          "2863:   ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2864:         jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2865:   nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2866:   sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2867:   pParse->nMem += nReg;",
          "2868:   if( pExpr->op==TK_SELECT ){",
          "2869:     dest.eDest = SRT_Mem;",
          "2870:     dest.iSdst = dest.iSDParm;",
          "2871:     dest.nSdst = nReg;",
          "2872:     sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2873:     VdbeComment((v, \"Init subquery result\"));",
          "2874:   }else{",
          "2875:     dest.eDest = SRT_Exists;",
          "2876:     sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2877:     VdbeComment((v, \"Init EXISTS result\"));",
          "2878:   }",
          "2879:   pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2880:   if( pSel->pLimit ){",
          "2881:     sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2882:     pSel->pLimit->pLeft = pLimit;",
          "2883:   }else{",
          "2884:     pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2885:   }",
          "2886:   pSel->iLimit = 0;",
          "2887:   if( sqlite3Select(pParse, pSel, &dest) ){",
          "2888:     return 0;",
          "2890:   rReg = dest.iSDParm;",
          "2891:   ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3343: #if SQLITE_OMIT_SUBQUERY",
          "3344:       iResult = 0;",
          "3345: #else",
          "3347: #endif",
          "3348:     }else{",
          "3349:       int i;",
          "",
          "[Removed Lines]",
          "3346:       iResult = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "3358:       iResult = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3817:       if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){",
          "3818:         sqlite3SubselectError(pParse, nCol, 1);",
          "3819:       }else{",
          "3821:       }",
          "3822:       break;",
          "3823:     }",
          "3824:     case TK_SELECT_COLUMN: {",
          "3825:       int n;",
          "3826:       if( pExpr->pLeft->iTable==0 ){",
          "3828:       }",
          "3829:       assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );",
          "3830:       if( pExpr->iTable",
          "",
          "[Removed Lines]",
          "3820:         return sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "3827:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft, 0, 0);",
          "",
          "[Added Lines]",
          "3832:         return sqlite3CodeSubselect(pParse, pExpr);",
          "3839:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4258: int sqlite3GetToken(const unsigned char *, int *);",
          "4259: void sqlite3NestedParse(Parse*, const char*, ...);",
          "4260: void sqlite3ExpirePreparedStatements(sqlite3*, int);",
          "4262: void sqlite3SelectPrep(Parse*, Select*, NameContext*);",
          "4263: void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);",
          "4264: int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);",
          "",
          "[Removed Lines]",
          "4261: int sqlite3CodeSubselect(Parse*, Expr *, int, int);",
          "",
          "[Added Lines]",
          "4261: void sqlite3CodeRhsOfIN(Parse*, Expr*, int);",
          "4262: int sqlite3CodeSubselect(Parse*, Expr*);",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1076: #ifndef SQLITE_OMIT_SUBQUERY",
          "1077:     if( (p->flags & EP_xIsSelect) ){",
          "1078:       Vdbe *v = pParse->pVdbe;",
          "1080:       sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);",
          "1081:     }else",
          "1082: #endif",
          "",
          "[Removed Lines]",
          "1079:       int iSelect = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "1079:       int iSelect;",
          "1080:       assert( p->op==TK_SELECT );",
          "1081:       iSelect = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a786e453a4c03c958feb30bfda4153a24bb393e6",
      "candidate_info": {
        "commit_hash": "a786e453a4c03c958feb30bfda4153a24bb393e6",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a786e453a4c03c958feb30bfda4153a24bb393e6",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/window.c"
        ],
        "message": "Simplify the windows frame code some. Add a comment explaining some of the VM code generated by sqlite3WindowCodeStep().\n\nFossilOrigin-Name: 6bd1a07949ff3d394056bfcc813444401ef00806e3f0e0423ff6962541e84bdb",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/window.c||src/window.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: e7bced731aa071c95bc398cdecd53c939841bf0c52fbcd06e47ba68f8c5cc35a",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/window.c||src/window.c": [
          "File: src/window.c -> src/window.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1698:   return ret;",
          "1699: }",
          "1774: ){",
          "1775:   Window *pMWin = p->pWin;",
          "1776:   ExprList *pOrderBy = pMWin->pOrderBy;",
          "1777:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "1794:   int addrShortcut = 0;",
          "1810:   assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT",
          "1811:        || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED",
          "",
          "[Removed Lines]",
          "1768: static void windowCodeStep(",
          "1769:   Parse *pParse,",
          "1770:   Select *p,",
          "1771:   WhereInfo *pWInfo,",
          "1772:   int regGosub,",
          "1773:   int addrGosub",
          "1780:   int regArg;",
          "1781:   int csrWrite = pMWin->iEphCsr+1;",
          "1787:   int addrGoto;",
          "1788:   int addrIf;",
          "1789:   int addrGosubFlush;",
          "1790:   int addrInteger;",
          "1791:   int addrCacheRewind;",
          "1792:   int addrCacheNext;",
          "1795:   int addrEmpty = 0;",
          "1796:   int addrPeerJump = 0;",
          "1798:   int bCache = windowCachePartition(pMWin);",
          "1803:   int reg = pParse->nMem+1;",
          "1804:   int regRecord = reg+nSub;",
          "1805:   int regRowid = regRecord+1;",
          "1806:   int regPeer = 0;",
          "1807:   int regNewPeer = 0;",
          "1808:   WindowCodeArg s;",
          "",
          "[Added Lines]",
          "1707: Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){",
          "1708:   Window *pNew = 0;",
          "1709:   if( ALWAYS(p) ){",
          "1710:     pNew = sqlite3DbMallocZero(db, sizeof(Window));",
          "1711:     if( pNew ){",
          "1712:       pNew->zName = sqlite3DbStrDup(db, p->zName);",
          "1713:       pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);",
          "1714:       pNew->pFunc = p->pFunc;",
          "1715:       pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);",
          "1716:       pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);",
          "1717:       pNew->eType = p->eType;",
          "1718:       pNew->eEnd = p->eEnd;",
          "1719:       pNew->eStart = p->eStart;",
          "1720:       pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);",
          "1721:       pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);",
          "1722:       pNew->pOwner = pOwner;",
          "1723:     }",
          "1724:   }",
          "1725:   return pNew;",
          "1726: }",
          "1732: Window *sqlite3WindowListDup(sqlite3 *db, Window *p){",
          "1733:   Window *pWin;",
          "1734:   Window *pRet = 0;",
          "1735:   Window **pp = &pRet;",
          "1737:   for(pWin=p; pWin; pWin=pWin->pNextWin){",
          "1739:     if( *pp==0 ) break;",
          "1740:     pp = &((*pp)->pNextWin);",
          "1741:   }",
          "1743:   return pRet;",
          "1744: }",
          "1946: void sqlite3WindowCodeStep(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1814:        || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING",
          "1815:   );",
          "1817:   memset(&s, 0, sizeof(WindowCodeArg));",
          "1818:   s.pParse = pParse;",
          "1819:   s.pMWin = pMWin;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1989:   bCache = windowCachePartition(pMWin);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1821:   s.regGosub = regGosub;",
          "1822:   s.addrGosub = addrGosub;",
          "1823:   s.current.csr = pMWin->iEphCsr;",
          "1824:   s.start.csr = s.current.csr+2;",
          "1825:   s.end.csr = s.current.csr+3;",
          "1829:   regFlushPart = ++pParse->nMem;",
          "1831:   if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING ){",
          "1832:     regStart = ++pParse->nMem;",
          "1833:   }",
          "",
          "[Removed Lines]",
          "1827:   pParse->nMem += 1 + nSub + 1;",
          "",
          "[Added Lines]",
          "1999:   csrWrite = s.current.csr+1;",
          "2003:   regNew = pParse->nMem+1;",
          "2004:   pParse->nMem += nInput;",
          "2005:   regRecord = ++pParse->nMem;",
          "2006:   regRowid = ++pParse->nMem;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1836:   }",
          "1841:   if( pMWin->eType!=TK_ROWS ){",
          "1842:     int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);",
          "1844:     if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;",
          "1846:     regPeer = pParse->nMem+1;       pParse->nMem += nPeer;",
          "1847:     s.start.reg = pParse->nMem+1;   pParse->nMem += nPeer;",
          "1848:     s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;",
          "",
          "[Removed Lines]",
          "1843:     regNewPeer = reg + pMWin->nBufferCol;",
          "",
          "[Added Lines]",
          "2024:     regNewPeer = regNew + pMWin->nBufferCol;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1850:   }",
          "1857:   }",
          "1866:   if( pMWin->pPartition ){",
          "1867:     int addr;",
          "1868:     ExprList *pPart = pMWin->pPartition;",
          "1869:     int nPart = pPart->nExpr;",
          "1871:     KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);",
          "1873:     addr = sqlite3VdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart, nPart);",
          "",
          "[Removed Lines]",
          "1855:   for(iCol=0; iCol<nSub; iCol++){",
          "1856:     sqlite3VdbeAddOp3(v, OP_Column, iSubCsr, iCol, reg+iCol);",
          "1858:   sqlite3VdbeAddOp3(v, OP_MakeRecord, reg, nSub, regRecord);",
          "1870:     int regNewPart = reg + pMWin->nBufferCol;",
          "",
          "[Added Lines]",
          "2035:   for(iInput=0; iInput<nInput; iInput++){",
          "2036:     sqlite3VdbeAddOp3(v, OP_Column, csrInput, iInput, regNew+iInput);",
          "2038:   sqlite3VdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);",
          "2049:     int regNewPart = regNew + pMWin->nBufferCol;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1893:     }",
          "1894:     addrCacheRewind = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);",
          "1895:   }else{",
          "1897:   }",
          "1902:   if( regStart ){",
          "1903:     sqlite3ExprCode(pParse, pMWin->pStart, regStart);",
          "",
          "[Removed Lines]",
          "1896:     addrIf = sqlite3VdbeAddOp1(v, OP_IfNot, pMWin->regFirst);",
          "1900:   s.regArg = regArg = windowInitAccum(pParse, pMWin);",
          "",
          "[Added Lines]",
          "2075:     addrIfNot = sqlite3VdbeAddOp1(v, OP_IfNot, pMWin->regFirst);",
          "2079:   s.regArg = windowInitAccum(pParse, pMWin);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1950:   addrGoto = sqlite3VdbeAddOp0(v, OP_Goto);",
          "1954:   if( bCache ){",
          "1955:     addrCacheNext = sqlite3VdbeCurrentAddr(v);",
          "1956:     if( pMWin->eType!=TK_ROWS ){",
          "1957:       windowReadPeerValues(&s, csrWrite, regNewPeer);",
          "1958:     }",
          "1959:   }else{",
          "1961:   }",
          "1962:   if( regPeer ){",
          "1963:     addrPeerJump = windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer);",
          "",
          "[Removed Lines]",
          "1953:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep.SECOND_ROW_CODE\"));",
          "1960:     sqlite3VdbeJumpHere(v, addrIf);",
          "",
          "[Added Lines]",
          "2132:   VdbeModuleComment((pParse->pVdbe, \"Begin WindowCodeStep.SECOND_ROW\"));",
          "2139:     sqlite3VdbeJumpHere(v, addrIfNot);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2011:   if( addrPeerJump ){",
          "2012:     sqlite3VdbeJumpHere(v, addrPeerJump);",
          "2013:   }",
          "2017:   sqlite3VdbeJumpHere(v, addrGoto);",
          "",
          "[Removed Lines]",
          "2014:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep.SECOND_ROW_CODE\"));",
          "",
          "[Added Lines]",
          "2193:   VdbeModuleComment((pParse->pVdbe, \"End WindowCodeStep.SECOND_ROW\"));",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2029:     sqlite3VdbeJumpHere(v, addrGosubFlush);",
          "2030:   }",
          "2033:   addrEmpty = sqlite3VdbeAddOp1(v, OP_Rewind, csrWrite);",
          "2034:   if( pMWin->eEnd==TK_PRECEDING ){",
          "2035:     windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);",
          "",
          "[Removed Lines]",
          "2032:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep.FLUSH_CODE\"));",
          "",
          "[Added Lines]",
          "2211:   VdbeModuleComment((pParse->pVdbe, \"Begin WindowCodeStep.FLUSH\"));",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2079:   sqlite3VdbeAddOp1(v, OP_ResetSorter, s.current.csr);",
          "2080:   sqlite3VdbeAddOp2(v, OP_Integer, 0, pMWin->regSize);",
          "2081:   if( bCache==0 ) sqlite3VdbeAddOp2(v, OP_Integer, 1, pMWin->regFirst);",
          "2083:   if( pMWin->pPartition ){",
          "2084:     sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));",
          "2085:     sqlite3VdbeAddOp1(v, OP_Return, regFlushPart);",
          "2086:   }",
          "2087: }",
          "",
          "[Removed Lines]",
          "2082:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep.FLUSH_CODE\"));",
          "2095: Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){",
          "2096:   Window *pNew = 0;",
          "2097:   if( ALWAYS(p) ){",
          "2098:     pNew = sqlite3DbMallocZero(db, sizeof(Window));",
          "2099:     if( pNew ){",
          "2100:       pNew->zName = sqlite3DbStrDup(db, p->zName);",
          "2101:       pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);",
          "2102:       pNew->pFunc = p->pFunc;",
          "2103:       pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);",
          "2104:       pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);",
          "2105:       pNew->eType = p->eType;",
          "2106:       pNew->eEnd = p->eEnd;",
          "2107:       pNew->eStart = p->eStart;",
          "2108:       pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);",
          "2109:       pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);",
          "2110:       pNew->pOwner = pOwner;",
          "2111:     }",
          "2112:   }",
          "2113:   return pNew;",
          "2114: }",
          "2120: Window *sqlite3WindowListDup(sqlite3 *db, Window *p){",
          "2121:   Window *pWin;",
          "2122:   Window *pRet = 0;",
          "2123:   Window **pp = &pRet;",
          "2125:   for(pWin=p; pWin; pWin=pWin->pNextWin){",
          "2127:     if( *pp==0 ) break;",
          "2128:     pp = &((*pp)->pNextWin);",
          "2129:   }",
          "2131:   return pRet;",
          "2132: }",
          "2141: void sqlite3WindowCodeStep(",
          "2147: ){",
          "2148:   VdbeModuleComment((pParse->pVdbe, \"Begin windowCodeStep()\"));",
          "2149:   windowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);",
          "2150:   VdbeModuleComment((pParse->pVdbe, \"End windowCodeStep()\"));",
          "2151: }",
          "",
          "[Added Lines]",
          "2261:   VdbeModuleComment((pParse->pVdbe, \"End WindowCodeStep.FLUSH\"));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b10a50e7f829f7038242db6f52b557e7624df412",
      "candidate_info": {
        "commit_hash": "b10a50e7f829f7038242db6f52b557e7624df412",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b10a50e7f829f7038242db6f52b557e7624df412",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/dbfuzz2.c"
        ],
        "message": "In dbfuzz2, avoid using a malloc in the LLVMFuzzerInitialize() initializer routine, so that no memory leaks are reported.  Also, show the version of SQLite being used when the -v option is on.\n\nFossilOrigin-Name: 824f93246988ffa213bbd41a7de08886999b1a8ae00fdf6b9767acb6e3ec6a1f",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/dbfuzz2.c||test/dbfuzz2.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 97e723d746eeb2159f5bf1701532271ac6a4620879c82d496f4499c178b64479",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/dbfuzz2.c||test/dbfuzz2.c": [
          "File: test/dbfuzz2.c -> test/dbfuzz2.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "134: int LLVMFuzzerInitialize(int *pArgc, char ***pArgv){",
          "135:   int i, j, n;",
          "136:   int argc = *pArgc;",
          "138:   char **argv = *pArgv;",
          "142:   for(i=j=1; i<argc; i++){",
          "143:     char *z = argv[i];",
          "144:     if( z[0]=='-' ){",
          "",
          "[Removed Lines]",
          "137:   char **newArgv;",
          "139:   newArgv = malloc( sizeof(char*)*(argc+1) );",
          "140:   if( newArgv==0 ) return 0;",
          "141:   newArgv[0] = argv[0];",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153:         continue;",
          "154:       }",
          "155:     }",
          "157:   }",
          "161:   return 0;",
          "162: }",
          "",
          "[Removed Lines]",
          "156:     newArgv[j++] = argv[i];",
          "158:   newArgv[j] = 0;",
          "",
          "[Added Lines]",
          "152:     argv[j++] = argv[i];",
          "154:   argv[j] = 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "202:       free(pIn);",
          "203:     }",
          "204:   }",
          "205:   return 0;",
          "206: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "200:   if( eVerbosity>0 ){",
          "201:     printf(\"SQLite %s\\n\", sqlite3_sourceid());",
          "202:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "368bfe8b008d1c4de12059c13750954db1b21dc9",
      "candidate_info": {
        "commit_hash": "368bfe8b008d1c4de12059c13750954db1b21dc9",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/368bfe8b008d1c4de12059c13750954db1b21dc9",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/main.c",
          "src/vdbeapi.c"
        ],
        "message": "Small performance improvement in the sqlite3_bind() family of interfaces.\n\nFossilOrigin-Name: 1dc0c3df32572f09265fc73eeaa0748159e0e9523b9b2d6768b834a29c909968",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/main.c||src/main.c",
          "src/vdbeapi.c||src/vdbeapi.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c96bf6cca220e363b099455ce35195ce7e89d374a52dc787f56e7b11e587bced",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/main.c||src/main.c": [
          "File: src/main.c -> src/main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2405:     z = sqlite3ErrStr(SQLITE_NOMEM_BKPT);",
          "2406:   }else{",
          "2407:     testcase( db->pErr==0 );",
          "2409:     assert( !db->mallocFailed );",
          "2410:     if( z==0 ){",
          "2411:       z = sqlite3ErrStr(db->errCode);",
          "",
          "[Removed Lines]",
          "2408:     z = (char*)sqlite3_value_text(db->pErr);",
          "",
          "[Added Lines]",
          "2408:     z = db->errCode ? (char*)sqlite3_value_text(db->pErr) : 0;",
          "",
          "---------------"
        ],
        "src/vdbeapi.c||src/vdbeapi.c": [
          "File: src/vdbeapi.c -> src/vdbeapi.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1286:   pVar = &p->aVar[i];",
          "1287:   sqlite3VdbeMemRelease(pVar);",
          "1288:   pVar->flags = MEM_Null;",
          "",
          "[Removed Lines]",
          "1289:   sqlite3Error(p->db, SQLITE_OK);",
          "",
          "[Added Lines]",
          "1289:   p->db->errCode = SQLITE_OK;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b3e3a5bb5714b10a98212139280aa976a3fbbd4c",
      "candidate_info": {
        "commit_hash": "b3e3a5bb5714b10a98212139280aa976a3fbbd4c",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b3e3a5bb5714b10a98212139280aa976a3fbbd4c",
        "files": [
          "ext/misc/dbdata.c",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Avoid reading outside a record buffer when extracting an SQL value in the sqlite_dbdata virtual table code.\n\nFossilOrigin-Name: d99bb0c11d62f629bf59da037827af73a9b814e65815006e0cbca1bc41f42e25",
        "before_after_code_files": [
          "ext/misc/dbdata.c||ext/misc/dbdata.c",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/misc/dbdata.c||ext/misc/dbdata.c": [
          "File: ext/misc/dbdata.c -> ext/misc/dbdata.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "382:     case 7:",
          "383:       return 8;",
          "384:     default:",
          "386:   }",
          "387: }",
          "",
          "[Removed Lines]",
          "385:       return ((eType-12) / 2);",
          "",
          "[Added Lines]",
          "385:       if( eType>0 ){",
          "386:         return ((eType-12) / 2);",
          "387:       }",
          "388:       return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "426:       }",
          "436:       }",
          "437:     }",
          "438:   }",
          "439: }",
          "",
          "[Removed Lines]",
          "393: static void dbdataValue(sqlite3_context *pCtx, int eType, u8 *pData){",
          "394:   switch( eType ){",
          "395:     case 0:",
          "396:     case 10:",
          "397:     case 11:",
          "398:       sqlite3_result_null(pCtx);",
          "399:       break;",
          "401:     case 8:",
          "402:       sqlite3_result_int(pCtx, 0);",
          "403:       break;",
          "404:     case 9:",
          "405:       sqlite3_result_int(pCtx, 1);",
          "406:       break;",
          "408:     case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "409:       sqlite3_uint64 v = (signed char)pData[0];",
          "410:       pData++;",
          "411:       switch( eType ){",
          "412:         case 7:",
          "413:         case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "414:         case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "415:         case 4:  v = (v<<8) + pData[0];  pData++;",
          "416:         case 3:  v = (v<<8) + pData[0];  pData++;",
          "417:         case 2:  v = (v<<8) + pData[0];  pData++;",
          "418:       }",
          "420:       if( eType==7 ){",
          "421:         double r;",
          "422:         memcpy(&r, &v, sizeof(r));",
          "423:         sqlite3_result_double(pCtx, r);",
          "424:       }else{",
          "425:         sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "427:       break;",
          "428:     }",
          "430:     default: {",
          "431:       int n = ((eType-12) / 2);",
          "432:       if( eType % 2 ){",
          "433:         sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "434:       }else{",
          "435:         sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "",
          "[Added Lines]",
          "396: static void dbdataValue(",
          "397:   sqlite3_context *pCtx,",
          "398:   int eType,",
          "399:   u8 *pData,",
          "400:   int nData",
          "401: ){",
          "402:   if( eType>=0 && dbdataValueBytes(eType)<=nData ){",
          "403:     switch( eType ){",
          "404:       case 0:",
          "405:       case 10:",
          "406:       case 11:",
          "407:         sqlite3_result_null(pCtx);",
          "408:         break;",
          "410:       case 8:",
          "411:         sqlite3_result_int(pCtx, 0);",
          "412:         break;",
          "413:       case 9:",
          "414:         sqlite3_result_int(pCtx, 1);",
          "415:         break;",
          "417:       case 1: case 2: case 3: case 4: case 5: case 6: case 7: {",
          "418:         sqlite3_uint64 v = (signed char)pData[0];",
          "419:         pData++;",
          "420:         switch( eType ){",
          "421:           case 7:",
          "422:           case 6:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "423:           case 5:  v = (v<<16) + (pData[0]<<8) + pData[1];  pData += 2;",
          "424:           case 4:  v = (v<<8) + pData[0];  pData++;",
          "425:           case 3:  v = (v<<8) + pData[0];  pData++;",
          "426:           case 2:  v = (v<<8) + pData[0];  pData++;",
          "427:         }",
          "429:         if( eType==7 ){",
          "430:           double r;",
          "431:           memcpy(&r, &v, sizeof(r));",
          "432:           sqlite3_result_double(pCtx, r);",
          "433:         }else{",
          "434:           sqlite3_result_int64(pCtx, (sqlite3_int64)v);",
          "435:         }",
          "436:         break;",
          "439:       default: {",
          "440:         int n = ((eType-12) / 2);",
          "441:         if( eType % 2 ){",
          "442:           sqlite3_result_text(pCtx, (const char*)pData, n, SQLITE_TRANSIENT);",
          "443:         }else{",
          "444:           sqlite3_result_blob(pCtx, pData, n, SQLITE_TRANSIENT);",
          "445:         }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "728:         }else{",
          "729:           sqlite3_int64 iType;",
          "730:           dbdataGetVarint(pCsr->pHdrPtr, &iType);",
          "732:         }",
          "733:         break;",
          "734:       }",
          "",
          "[Removed Lines]",
          "731:           dbdataValue(ctx, iType, pCsr->pPtr);",
          "",
          "[Added Lines]",
          "740:           dbdataValue(",
          "741:               ctx, iType, pCsr->pPtr, &pCsr->pRec[pCsr->nRec] - pCsr->pPtr",
          "742:           );",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: ec9373031d76b34163a45d0ed05e43c0c9d585c8d47aa255f670340673bc7875",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
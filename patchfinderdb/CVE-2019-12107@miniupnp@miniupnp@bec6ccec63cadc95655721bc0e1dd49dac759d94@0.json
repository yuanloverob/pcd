{
  "cve_id": "CVE-2019-12107",
  "cve_desc": "The upnp_event_prepare function in upnpevents.c in MiniUPnP MiniUPnPd through 2.1 allows a remote attacker to leak information from the heap due to improper validation of an snprintf return value.",
  "repo": "miniupnp/miniupnp",
  "patch_hash": "bec6ccec63cadc95655721bc0e1dd49dac759d94",
  "patch_info": {
    "commit_hash": "bec6ccec63cadc95655721bc0e1dd49dac759d94",
    "repo": "miniupnp/miniupnp",
    "commit_url": "https://github.com/miniupnp/miniupnp/commit/bec6ccec63cadc95655721bc0e1dd49dac759d94",
    "files": [
      "miniupnpd/upnpevents.c"
    ],
    "message": "upnp_event_prepare(): check the return value of snprintf()",
    "before_after_code_files": [
      "miniupnpd/upnpevents.c||miniupnpd/upnpevents.c"
    ]
  },
  "patch_diff": {
    "miniupnpd/upnpevents.c||miniupnpd/upnpevents.c": [
      "File: miniupnpd/upnpevents.c -> miniupnpd/upnpevents.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "443:   l = 0;",
      "444:  }",
      "445:  obj->buffersize = 1024;",
      "451:   }",
      "454:  }",
      "459:  if(xml) {",
      "460:   free(xml);",
      "461:   xml = NULL;",
      "",
      "[Removed Lines]",
      "446:  obj->buffer = malloc(obj->buffersize);",
      "447:  if(!obj->buffer) {",
      "448:   syslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");",
      "449:   if(xml) {",
      "450:    free(xml);",
      "452:   obj->state = EError;",
      "453:   return;",
      "455:  obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,",
      "456:                         obj->path, obj->addrstr, obj->portstr, l+2,",
      "457:                         obj->sub->uuid, obj->sub->seq,",
      "458:                         l, xml);",
      "",
      "[Added Lines]",
      "446:  for (;;) {",
      "447:   obj->buffer = malloc(obj->buffersize);",
      "448:   if(!obj->buffer) {",
      "449:    syslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");",
      "450:    if(xml) {",
      "451:     free(xml);",
      "452:    }",
      "453:    obj->state = EError;",
      "454:    return;",
      "456:   obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,",
      "457:                          obj->path, obj->addrstr, obj->portstr, l+2,",
      "458:                          obj->sub->uuid, obj->sub->seq,",
      "459:                          l, xml);",
      "460:   if (obj->tosend < 0) {",
      "461:    syslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");",
      "462:    if(xml) {",
      "463:     free(xml);",
      "464:    }",
      "465:    obj->state = EError;",
      "466:    return;",
      "467:   } else if (obj->tosend < obj->buffersize) {",
      "469:   }",
      "471:   free(obj->buffer);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "1ef1deec01bca16d4bbf3f690cbc06ddd19adedc",
      "candidate_info": {
        "commit_hash": "1ef1deec01bca16d4bbf3f690cbc06ddd19adedc",
        "repo": "miniupnp/miniupnp",
        "commit_url": "https://github.com/miniupnp/miniupnp/commit/1ef1deec01bca16d4bbf3f690cbc06ddd19adedc",
        "files": [
          "miniupnpd/Changelog.txt",
          "miniupnpd/upnpevents.c"
        ],
        "message": "upnpevents.c: properly handle urls in the form http://ip:port\n\nFix buffer over-read in upnpevents.c with urls in the form http://ip:port\n(without path).\nAssume / when the path is empty\n\nfixes #361",
        "before_after_code_files": [
          "miniupnpd/upnpevents.c||miniupnpd/upnpevents.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "miniupnpd/upnpevents.c||miniupnpd/upnpevents.c"
          ],
          "candidate": [
            "miniupnpd/upnpevents.c||miniupnpd/upnpevents.c"
          ]
        }
      },
      "candidate_diff": {
        "miniupnpd/upnpevents.c||miniupnpd/upnpevents.c": [
          "File: miniupnpd/upnpevents.c -> miniupnpd/upnpevents.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "341:   i = 1;",
          "342:   p++;",
          "343:   port = (unsigned short)atoi(p);",
          "345:    if(i<7) obj->portstr[i++] = *p;",
          "346:    p++;",
          "347:   }",
          "",
          "[Removed Lines]",
          "344:   while(*p != '/') {",
          "",
          "[Added Lines]",
          "344:   while(*p != '\\0' && *p != '/') {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "454:    return;",
          "455:   }",
          "456:   obj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,",
          "458:                          obj->sub->uuid, obj->sub->seq,",
          "459:                          l, xml);",
          "460:   if (obj->tosend < 0) {",
          "",
          "[Removed Lines]",
          "457:                          obj->path, obj->addrstr, obj->portstr, l+2,",
          "",
          "[Added Lines]",
          "457:                          (obj->path[0] != '\\0') ? obj->path : \"/\",",
          "458:                          obj->addrstr, obj->portstr, l+2,",
          "",
          "---------------"
        ]
      }
    }
  ]
}
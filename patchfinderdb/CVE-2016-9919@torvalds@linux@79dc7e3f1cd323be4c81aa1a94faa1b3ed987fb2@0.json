{
  "cve_id": "CVE-2016-9919",
  "cve_desc": "The icmp6_send function in net/ipv6/icmp.c in the Linux kernel through 4.8.12 omits a certain check of the dst data structure, which allows remote attackers to cause a denial of service (panic) via a fragmented IPv6 packet.",
  "repo": "torvalds/linux",
  "patch_hash": "79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2",
  "patch_info": {
    "commit_hash": "79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/79dc7e3f1cd323be4c81aa1a94faa1b3ed987fb2",
    "files": [
      "net/ipv6/icmp.c"
    ],
    "message": "net: handle no dst on skb in icmp6_send\n\nAndrey reported the following while fuzzing the kernel with syzkaller:\n\nkasan: CONFIG_KASAN_INLINE enabled\nkasan: GPF could be caused by NULL-ptr deref or user memory access\ngeneral protection fault: 0000 [#1] SMP KASAN\nModules linked in:\nCPU: 0 PID: 3859 Comm: a.out Not tainted 4.9.0-rc6+ #429\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\ntask: ffff8800666d4200 task.stack: ffff880067348000\nRIP: 0010:[<ffffffff833617ec>]  [<ffffffff833617ec>]\nicmp6_send+0x5fc/0x1e30 net/ipv6/icmp.c:451\nRSP: 0018:ffff88006734f2c0  EFLAGS: 00010206\nRAX: ffff8800666d4200 RBX: 0000000000000000 RCX: 0000000000000000\nRDX: 0000000000000000 RSI: dffffc0000000000 RDI: 0000000000000018\nRBP: ffff88006734f630 R08: ffff880064138418 R09: 0000000000000003\nR10: dffffc0000000000 R11: 0000000000000005 R12: 0000000000000000\nR13: ffffffff84e7e200 R14: ffff880064138484 R15: ffff8800641383c0\nFS:  00007fb3887a07c0(0000) GS:ffff88006cc00000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000020000000 CR3: 000000006b040000 CR4: 00000000000006f0\nStack:\n ffff8800666d4200 ffff8800666d49f8 ffff8800666d4200 ffffffff84c02460\n ffff8800666d4a1a 1ffff1000ccdaa2f ffff88006734f498 0000000000000046\n ffff88006734f440 ffffffff832f4269 ffff880064ba7456 0000000000000000\nCall Trace:\n [<ffffffff83364ddc>] icmpv6_param_prob+0x2c/0x40 net/ipv6/icmp.c:557\n [<     inline     >] ip6_tlvopt_unknown net/ipv6/exthdrs.c:88\n [<ffffffff83394405>] ip6_parse_tlv+0x555/0x670 net/ipv6/exthdrs.c:157\n [<ffffffff8339a759>] ipv6_parse_hopopts+0x199/0x460 net/ipv6/exthdrs.c:663\n [<ffffffff832ee773>] ipv6_rcv+0xfa3/0x1dc0 net/ipv6/ip6_input.c:191\n ...\n\nicmp6_send / icmpv6_send is invoked for both rx and tx paths. In both\ncases the dst->dev should be preferred for determining the L3 domain\nif the dst has been set on the skb. Fallback to the skb->dev if it has\nnot. This covers the case reported here where icmp6_send is invoked on\nRx before the route lookup.\n\nFixes: 5d41ce29e (\"net: icmp6_send should use dst dev to determine L3 domain\")\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: David Ahern <dsa@cumulusnetworks.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/ipv6/icmp.c||net/ipv6/icmp.c"
    ]
  },
  "patch_diff": {
    "net/ipv6/icmp.c||net/ipv6/icmp.c": [
      "File: net/ipv6/icmp.c -> net/ipv6/icmp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "448:  if (__ipv6_addr_needs_scope_id(addr_type))",
      "449:   iif = skb->dev->ifindex;",
      "",
      "[Removed Lines]",
      "450:  else",
      "451:   iif = l3mdev_master_ifindex(skb_dst(skb)->dev);",
      "",
      "[Added Lines]",
      "450:  else {",
      "451:   dst = skb_dst(skb);",
      "452:   iif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);",
      "453:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "80cca775cdc4f8555612d2943a2872076b33e0ff",
      "candidate_info": {
        "commit_hash": "80cca775cdc4f8555612d2943a2872076b33e0ff",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/80cca775cdc4f8555612d2943a2872076b33e0ff",
        "files": [
          "drivers/net/ethernet/freescale/fec.h",
          "drivers/net/ethernet/freescale/fec_main.c"
        ],
        "message": "net: fec: cache statistics while device is down\n\nExecution 'ethtool -S' on fec device that is down causes OOPS on Vybrid\nboard:\n\nUnhandled fault: external abort on non-linefetch (0x1008) at 0xe0898200\npgd = ddecc000\n[e0898200] *pgd=9e406811, *pte=400d1653, *ppte=400d1453\nInternal error: : 1008 [#1] SMP ARM\n...\n\nReason of OOPS is that fec_enet_get_ethtool_stats() accesses fec\nregisters while IPG clock is stopped by PM.\n\nFix that by caching statistics in fec_enet_private. Cache is initialized\nat device probe time, and updated at statistics request time if device\nis up, and also just before turning device off on down path.\n\nAdditional locking is not needed, since cached statistics is accessed\neither before device is registered, or under rtnl_lock().\n\nSigned-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/ethernet/freescale/fec.h||drivers/net/ethernet/freescale/fec.h",
          "drivers/net/ethernet/freescale/fec_main.c||drivers/net/ethernet/freescale/fec_main.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/freescale/fec.h||drivers/net/ethernet/freescale/fec.h": [
          "File: drivers/net/ethernet/freescale/fec.h -> drivers/net/ethernet/freescale/fec.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "574:  unsigned int reload_period;",
          "575:  int pps_enable;",
          "576:  unsigned int next_counter;",
          "577: };",
          "579: void fec_ptp_init(struct platform_device *pdev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "578:  u64 ethtool_stats[0];",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/freescale/fec_main.c||drivers/net/ethernet/freescale/fec_main.c": [
          "File: drivers/net/ethernet/freescale/fec_main.c -> drivers/net/ethernet/freescale/fec_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2313:  { \"IEEE_rx_octets_ok\", IEEE_R_OCTETS_OK },",
          "2314: };",
          "2318: {",
          "2319:  struct fec_enet_private *fep = netdev_priv(dev);",
          "2320:  int i;",
          "2322:  for (i = 0; i < ARRAY_SIZE(fec_stats); i++)",
          "2324: }",
          "2326: static void fec_enet_get_strings(struct net_device *netdev,",
          "",
          "[Removed Lines]",
          "2316: static void fec_enet_get_ethtool_stats(struct net_device *dev,",
          "2317:  struct ethtool_stats *stats, u64 *data)",
          "2323:   data[i] = readl(fep->hwp + fec_stats[i].offset);",
          "",
          "[Added Lines]",
          "2316: static void fec_enet_update_ethtool_stats(struct net_device *dev)",
          "2322:   fep->ethtool_stats[i] = readl(fep->hwp + fec_stats[i].offset);",
          "2323: }",
          "2325: static void fec_enet_get_ethtool_stats(struct net_device *dev,",
          "2326:            struct ethtool_stats *stats, u64 *data)",
          "2327: {",
          "2328:  struct fec_enet_private *fep = netdev_priv(dev);",
          "2330:  if (netif_running(dev))",
          "2331:   fec_enet_update_ethtool_stats(dev);",
          "2333:  memcpy(data, fep->ethtool_stats, ARRAY_SIZE(fec_stats) * sizeof(u64));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2874:  if (fep->quirks & FEC_QUIRK_ERR006687)",
          "2875:   imx6q_cpuidle_fec_irqs_unused();",
          "2877:  fec_enet_clk_enable(ndev, false);",
          "2878:  pinctrl_pm_select_sleep_state(&fep->pdev->dev);",
          "2879:  pm_runtime_mark_last_busy(&fep->pdev->dev);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2887:  fec_enet_update_ethtool_stats(ndev);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3181:  fec_restart(ndev);",
          "3183:  return 0;",
          "3184: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3195:  fec_enet_update_ethtool_stats(ndev);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "3278:  fec_enet_get_queue_num(pdev, &num_tx_qs, &num_rx_qs);",
          "3282:       num_tx_qs, num_rx_qs);",
          "3283:  if (!ndev)",
          "3284:   return -ENOMEM;",
          "",
          "[Removed Lines]",
          "3281:  ndev = alloc_etherdev_mqs(sizeof(struct fec_enet_private),",
          "",
          "[Added Lines]",
          "3295:  ndev = alloc_etherdev_mqs(sizeof(struct fec_enet_private) +",
          "3296:       ARRAY_SIZE(fec_stats) * sizeof(u64),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "741dc7bf1c7c7d93b853bb55efe77baa27e1b0a9",
      "candidate_info": {
        "commit_hash": "741dc7bf1c7c7d93b853bb55efe77baa27e1b0a9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/741dc7bf1c7c7d93b853bb55efe77baa27e1b0a9",
        "files": [
          "arch/parisc/kernel/cache.c",
          "arch/parisc/kernel/setup.c"
        ],
        "message": "parisc: Fix races in parisc_setup_cache_timing()\n\nHelge reported to me the following startup crash:\n\n[    0.000000] Linux version 4.8.0-1-parisc64-smp (debian-kernel@lists.debian.org) (gcc version 5.4.1 20161019 (GCC) ) #1 SMP Debian 4.8.7-1 (2016-11-13)\n[    0.000000] The 64-bit Kernel has started...\n[    0.000000] Kernel default page size is 4 KB. Huge pages enabled with 1 MB physical and 2 MB virtual size.\n[    0.000000] Determining PDC firmware type: System Map.\n[    0.000000] model 9000/785/J5000\n[    0.000000] Total Memory: 2048 MB\n[    0.000000] Memory: 2018528K/2097152K available (9272K kernel code, 3053K rwdata, 1319K rodata, 1024K init, 840K bss, 78624K reserved, 0K cma-reserved)\n[    0.000000] virtual kernel memory layout:\n[    0.000000]     vmalloc : 0x0000000000008000 - 0x000000003f000000   (1007 MB)\n[    0.000000]     memory  : 0x0000000040000000 - 0x00000000c0000000   (2048 MB)\n[    0.000000]       .init : 0x0000000040100000 - 0x0000000040200000   (1024 kB)\n[    0.000000]       .data : 0x0000000040b0e000 - 0x0000000040f533e0   (4372 kB)\n[    0.000000]       .text : 0x0000000040200000 - 0x0000000040b0e000   (9272 kB)\n[    0.768910] Brought up 1 CPUs\n[    0.992465] NET: Registered protocol family 16\n[    2.429981] Releasing cpu 1 now, hpa=fffffffffffa2000\n[    2.635751] CPU(s): 2 out of 2 PA8500 (PCX-W) at 440.000000 MHz online\n[    2.726692] Setting cache flush threshold to 1024 kB\n[    2.729932] Not-handled unaligned insn 0x43ffff80\n[    2.798114] Setting TLB flush threshold to 140 kB\n[    2.928039] Unaligned handler failed, ret = -1\n[    3.000419]       _______________________________\n[    3.000419]      < Your System ate a SPARC! Gah! >\n[    3.000419]       -------------------------------\n[    3.000419]              \\   ^__^\n[    3.000419]                  (__)\\       )\\/\\\n[    3.000419]                   U  ||----w |\n[    3.000419]                      ||     ||\n[    9.340055] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.8.0-1-parisc64-smp #1 Debian 4.8.7-1\n[    9.448082] task: 00000000bfd48060 task.stack: 00000000bfd50000\n[    9.528040]\n[   10.760029] IASQ: 0000000000000000 0000000000000000 IAOQ: 000000004025d154 000000004025d158\n[   10.868052]  IIR: 43ffff80    ISR: 0000000000340000  IOR: 000001ff54150960\n[   10.960029]  CPU:        1   CR30: 00000000bfd50000 CR31: 0000000011111111\n[   11.052057]  ORIG_R28: 000000004021e3b4\n[   11.100045]  IAOQ[0]: irq_exit+0x94/0x120\n[   11.152062]  IAOQ[1]: irq_exit+0x98/0x120\n[   11.208031]  RP(r2): irq_exit+0xb8/0x120\n[   11.256074] Backtrace:\n[   11.288067]  [<00000000402cd944>] cpu_startup_entry+0x1e4/0x598\n[   11.368058]  [<0000000040109528>] smp_callin+0x2c0/0x2f0\n[   11.436308]  [<00000000402b53fc>] update_curr+0x18c/0x2d0\n[   11.508055]  [<00000000402b73b8>] dequeue_entity+0x2c0/0x1030\n[   11.584040]  [<00000000402b3cc0>] set_next_entity+0x80/0xd30\n[   11.660069]  [<00000000402c1594>] pick_next_task_fair+0x614/0x720\n[   11.740085]  [<000000004020dd34>] __schedule+0x394/0xa60\n[   11.808054]  [<000000004020e488>] schedule+0x88/0x118\n[   11.876039]  [<0000000040283d3c>] rescuer_thread+0x4d4/0x5b0\n[   11.948090]  [<000000004028fc4c>] kthread+0x1ec/0x248\n[   12.016053]  [<0000000040205020>] end_fault_vector+0x20/0xc0\n[   12.092239]  [<00000000402050c0>] _switch_to_ret+0x0/0xf40\n[   12.164044]\n[   12.184036] CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.8.0-1-parisc64-smp #1 Debian 4.8.7-1\n[   12.244040] Backtrace:\n[   12.244040]  [<000000004021c480>] show_stack+0x68/0x80\n[   12.244040]  [<00000000406f332c>] dump_stack+0xec/0x168\n[   12.244040]  [<000000004021c74c>] die_if_kernel+0x25c/0x430\n[   12.244040]  [<000000004022d320>] handle_unaligned+0xb48/0xb50\n[   12.244040]\n[   12.632066] ---[ end trace 9ca05a7215c7bbb2 ]---\n[   12.692036] Kernel panic - not syncing: Attempted to kill the idle task!\n\nWe have the insn 0x43ffff80 in IIR but from IAOQ we should have:\n   4025d150:   0f f3 20 df     ldd,s r19(r31),r31\n   4025d154:   0f 9f 00 9c     ldw r31(ret0),ret0\n   4025d158:   bf 80 20 58     cmpb,*<> r0,ret0,4025d18c <irq_exit+0xcc>\n\nCpu0 has just completed running parisc_setup_cache_timing:\n\n[    2.429981] Releasing cpu 1 now, hpa=fffffffffffa2000\n[    2.635751] CPU(s): 2 out of 2 PA8500 (PCX-W) at 440.000000 MHz online\n[    2.726692] Setting cache flush threshold to 1024 kB\n[    2.729932] Not-handled unaligned insn 0x43ffff80\n[    2.798114] Setting TLB flush threshold to 140 kB\n[    2.928039] Unaligned handler failed, ret = -1\n\nFrom the backtrace, cpu1 is in smp_callin:\n\nvoid __init smp_callin(void)\n{\n       int slave_id = cpu_now_booting;\n\n       smp_cpu_init(slave_id);\n       preempt_disable();\n\n       flush_cache_all_local(); /* start with known state */\n       flush_tlb_all_local(NULL);\n\n       local_irq_enable();  /* Interrupts have been off until now */\n\n       cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);\n\nSo, it has just flushed its caches and the TLB. It would seem either the\nflushes in parisc_setup_cache_timing or smp_callin have corrupted kernel\nmemory.\n\nThe attached patch reworks parisc_setup_cache_timing to remove the races\nin setting the cache and TLB flush thresholds. It also corrects the\nnumber of bytes flushed in the TLB calculation.\n\nThe patch flushes the cache and TLB on cpu0 before starting the\nsecondary processors so that they are started from a known state.\n\nTested with a few reboots on c8000.\n\nSigned-off-by: John David Anglin  <dave.anglin@bell.net>\nCc: <stable@vger.kernel.org> # v3.18+\nSigned-off-by: Helge Deller <deller@gmx.de>",
        "before_after_code_files": [
          "arch/parisc/kernel/cache.c||arch/parisc/kernel/cache.c",
          "arch/parisc/kernel/setup.c||arch/parisc/kernel/setup.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/parisc/kernel/cache.c||arch/parisc/kernel/cache.c": [
          "File: arch/parisc/kernel/cache.c -> arch/parisc/kernel/cache.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "369: {",
          "370:  unsigned long rangetime, alltime;",
          "371:  unsigned long size, start;",
          "373:  alltime = mfctl(16);",
          "374:  flush_data_cache();",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "372:  unsigned long threshold;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "382:  printk(KERN_DEBUG \"Whole cache flush %lu cycles, flushing %lu bytes %lu cycles\\n\",",
          "383:   alltime, size, rangetime);",
          "396:   parisc_cache_flush_threshold/1024);",
          "",
          "[Removed Lines]",
          "386:  parisc_cache_flush_threshold = size * alltime / rangetime;",
          "388:  parisc_cache_flush_threshold = L1_CACHE_ALIGN(parisc_cache_flush_threshold);",
          "389:  if (!parisc_cache_flush_threshold)",
          "390:   parisc_cache_flush_threshold = FLUSH_THRESHOLD;",
          "392:  if (parisc_cache_flush_threshold > cache_info.dc_size)",
          "393:   parisc_cache_flush_threshold = cache_info.dc_size;",
          "395:  printk(KERN_INFO \"Setting cache flush threshold to %lu kB\\n\",",
          "",
          "[Added Lines]",
          "386:  threshold = L1_CACHE_ALIGN(size * alltime / rangetime);",
          "387:  if (threshold > cache_info.dc_size)",
          "388:   threshold = cache_info.dc_size;",
          "389:  if (threshold)",
          "390:   parisc_cache_flush_threshold = threshold;",
          "391:  printk(KERN_INFO \"Cache flush threshold set to %lu KiB\\n\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "401:  flush_tlb_all();",
          "402:  alltime = mfctl(16) - alltime;",
          "405:  start = (unsigned long) _text;",
          "406:  rangetime = mfctl(16);",
          "407:  while (start < (unsigned long) _end) {",
          "",
          "[Removed Lines]",
          "404:  size = PAGE_SIZE;",
          "",
          "[Added Lines]",
          "400:  size = 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "414:  printk(KERN_DEBUG \"Whole TLB flush %lu cycles, flushing %lu bytes %lu cycles\\n\",",
          "415:   alltime, size, rangetime);",
          "424:   parisc_tlb_flush_threshold/1024);",
          "425: }",
          "",
          "[Removed Lines]",
          "417:  parisc_tlb_flush_threshold = size * alltime / rangetime;",
          "418:  parisc_tlb_flush_threshold *= num_online_cpus();",
          "419:  parisc_tlb_flush_threshold = PAGE_ALIGN(parisc_tlb_flush_threshold);",
          "420:  if (!parisc_tlb_flush_threshold)",
          "421:   parisc_tlb_flush_threshold = FLUSH_TLB_THRESHOLD;",
          "423:  printk(KERN_INFO \"Setting TLB flush threshold to %lu kB\\n\",",
          "",
          "[Added Lines]",
          "413:  threshold = PAGE_ALIGN(num_online_cpus() * size * alltime / rangetime);",
          "414:  if (threshold)",
          "415:   parisc_tlb_flush_threshold = threshold;",
          "416:  printk(KERN_INFO \"TLB flush threshold set to %lu KiB\\n\",",
          "",
          "---------------"
        ],
        "arch/parisc/kernel/setup.c||arch/parisc/kernel/setup.c": [
          "File: arch/parisc/kernel/setup.c -> arch/parisc/kernel/setup.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "335:  pdc_stable_write(0x40, &osid, sizeof(osid));",
          "337:  processor_init();",
          "338: #ifdef CONFIG_SMP",
          "339:  pr_info(\"CPU(s): %d out of %d %s at %d.%06d MHz online\\n\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "338:  flush_cache_all_local();",
          "339:  flush_tlb_all_local(NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "747e5a5ff2a2ae84715c33d6679ac3c5220a3aec",
      "candidate_info": {
        "commit_hash": "747e5a5ff2a2ae84715c33d6679ac3c5220a3aec",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/747e5a5ff2a2ae84715c33d6679ac3c5220a3aec",
        "files": [
          "drivers/gpu/drm/arm/hdlcd_drv.c"
        ],
        "message": "drm: hdlcd: Fix cleanup order\n\nIf hdlcd_drm_bind() fails at drm_fbdev_cma_init(), its cleanup will call\ndrm_mode_config_cleanup() as if to balance drm_mode_config_reset(). The\nnet result is that drm_connector_cleanup() will clean up the active\nconnectors long before component_unbind_all() gets called, so when the\nconnector later tries to clean up itself after being unbound, Bad Things\ncan happen:\n\n[    4.121888] Unable to handle kernel NULL pointer dereference at\nvirtual address 00000000\n[    4.129951] pgd = ffffff80091e0000\n[    4.133345] [00000000] *pgd=00000009ffffe003, *pud=00000009ffffe003,\n*pmd=0000000000000000\n[    4.141613] Internal error: Oops: 96000005 [#1] PREEMPT SMP\n[    4.147144] Modules linked in:\n[    4.150188] CPU: 0 PID: 122 Comm: kworker/u12:2 Not tainted\n4.8.0-rc2+ #989\n[    4.157097] Hardware name: ARM Juno development board (r1) (DT)\n[    4.162981] Workqueue: deferwq deferred_probe_work_func\n[    4.168173] task: ffffffc975d93200 task.stack: ffffffc975dac000\n[    4.174055] PC is at drm_connector_cleanup+0x58/0x1c0\n[    4.179074] LR is at tda998x_unbind+0x24/0x40\n[    4.183401] pc : [<ffffff80084c46f0>] lr : [<ffffff800850414c>]\npstate: 00000045\n[    4.190750] sp : ffffffc975dafa10\n[    4.194041] x29: ffffffc975dafa10 x28: ffffffc9768152a8\n[    4.199325] x27: ffffffc97ff46450 x26: ffffff8008d99000\n[    4.204608] x25: dead000000000100 x24: dead000000000200\n[    4.209891] x23: ffffffc976bf91e8 x22: 0000000000000000\n[    4.215172] x21: ffffffc976bf9170 x20: ffffffc976bf9170\n[    4.220454] x19: ffffffc976bf9018 x18: 0000000000000000\n[    4.225737] x17: 0000000074ce71ee x16: 000000008ff5d35f\n[    4.231019] x15: ffffffc97681e91c x14: ffffffffffffffff\n[    4.236301] x13: ffffffc97681e185 x12: 0000000000000038\n[    4.241583] x11: 0101010101010101 x10: 0000000000000000\n[    4.246866] x9 : 0000000040000000 x8 : 0000000000210d00\n[    4.252148] x7 : ffffffc97fea8c00 x6 : 000000000000001b\n[    4.257430] x5 : ffffff80084b7b8c x4 : 0000000000000080\n[    4.262712] x3 : ffffff8008504128 x2 : ffffffc975df3800\n[    4.267993] x1 : 0000000000000000 x0 : 0000000000000000\n...\n[    4.750937] [<ffffff80084c46f0>] drm_connector_cleanup+0x58/0x1c0\n[    4.756990] [<ffffff800850414c>] tda998x_unbind+0x24/0x40\n[    4.762354] [<ffffff8008507918>] component_unbind.isra.4+0x28/0x50\n[    4.768492] [<ffffff8008507a0c>] component_unbind_all+0xcc/0xd8\n[    4.774373] [<ffffff80084d5adc>] hdlcd_drm_bind+0x234/0x418\n[    4.779909] [<ffffff8008507b58>] try_to_bring_up_master+0x140/0x1a0\n[    4.786133] [<ffffff8008507c50>] component_add+0x98/0x170\n[    4.791496] [<ffffff8008504b90>] tda998x_probe+0x18/0x20\n[    4.796774] [<ffffff80086bf914>] i2c_device_probe+0x164/0x258\n[    4.802481] [<ffffff800850d094>] driver_probe_device+0x204/0x2b0\n[    4.808447] [<ffffff800850d28c>] __device_attach_driver+0x9c/0xf8\n[    4.814498] [<ffffff800850b108>] bus_for_each_drv+0x58/0x98\n[    4.820033] [<ffffff800850cd64>] __device_attach+0xc4/0x138\n[    4.825567] [<ffffff800850d338>] device_initial_probe+0x10/0x18\n[    4.831446] [<ffffff800850c124>] bus_probe_device+0x94/0xa0\n[    4.836981] [<ffffff800850c5b0>] deferred_probe_work_func+0x78/0xb0\n[    4.843207] [<ffffff80080d2998>] process_one_work+0x118/0x378\n[    4.848914] [<ffffff80080d2c40>] worker_thread+0x48/0x498\n[    4.854276] [<ffffff80080d8918>] kthread+0xd0/0xe8\n[    4.859036] [<ffffff8008082e90>] ret_from_fork+0x10/0x40\n[    4.864314] Code: f2fbd5b9 f2fbd5b8 f8478ee0 eb17001f (f9400013)\n[    4.870472] ---[ end trace a643cfe4ce1d838b ]---\n\nFix this by moving the drm_mode_config_cleanup() much later such that it\ncorrectly balances drm_mode_config_init().\n\nSuggested-by: Russell King <linux@armlinux.org.uk>\nSigned-off-by: Robin Murphy <robin.murphy@arm.com>\nSigned-off-by: Liviu Dudau <Liviu.Dudau@arm.com>",
        "before_after_code_files": [
          "drivers/gpu/drm/arm/hdlcd_drv.c||drivers/gpu/drm/arm/hdlcd_drv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/arm/hdlcd_drv.c||drivers/gpu/drm/arm/hdlcd_drv.c": [
          "File: drivers/gpu/drm/arm/hdlcd_drv.c -> drivers/gpu/drm/arm/hdlcd_drv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "376: err_fbdev:",
          "377:  drm_kms_helper_poll_fini(drm);",
          "379:  drm_vblank_cleanup(drm);",
          "380: err_vblank:",
          "381:  pm_runtime_disable(drm->dev);",
          "",
          "[Removed Lines]",
          "378:  drm_mode_config_cleanup(drm);",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "387:  drm_irq_uninstall(drm);",
          "388:  of_reserved_mem_device_release(drm->dev);",
          "389: err_free:",
          "390:  dev_set_drvdata(dev, NULL);",
          "391:  drm_dev_unref(drm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "389:  drm_mode_config_cleanup(drm);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "529e71e16403830ae0d737a66c55c5f360f3576b",
      "candidate_info": {
        "commit_hash": "529e71e16403830ae0d737a66c55c5f360f3576b",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/529e71e16403830ae0d737a66c55c5f360f3576b",
        "files": [
          "drivers/block/zram/zram_drv.c"
        ],
        "message": "zram: fix unbalanced idr management at hot removal\n\nThe zram hot removal code calls idr_remove() even when zram_remove()\nreturns an error (typically -EBUSY).  This results in a leftover at the\ndevice release, eventually leading to a crash when the module is\nreloaded.\n\nAs described in the bug report below, the following procedure would\ncause an Oops with zram:\n\n - provision three zram devices via modprobe zram num_devices=3\n - configure a size for each device\n   + echo \"1G\" > /sys/block/$zram_name/disksize\n - mkfs and mount zram0 only\n - attempt to hot remove all three devices\n   + echo 2 > /sys/class/zram-control/hot_remove\n   + echo 1 > /sys/class/zram-control/hot_remove\n   + echo 0 > /sys/class/zram-control/hot_remove\n     - zram0 removal fails with EBUSY, as expected\n - unmount zram0\n - try zram0 hot remove again\n   + echo 0 > /sys/class/zram-control/hot_remove\n     - fails with ENODEV (unexpected)\n - unload zram kernel module\n   + completes successfully\n - zram0 device node still exists\n - attempt to mount /dev/zram0\n   + mount command is killed\n   + following BUG is encountered\n\n BUG: unable to handle kernel paging request at ffffffffa0002ba0\n IP: get_disk+0x16/0x50\n Oops: 0000 [#1] SMP\n CPU: 0 PID: 252 Comm: mount Not tainted 4.9.0-rc6 #176\n Call Trace:\n   exact_lock+0xc/0x20\n   kobj_lookup+0xdc/0x160\n   get_gendisk+0x2f/0x110\n   __blkdev_get+0x10c/0x3c0\n   blkdev_get+0x19d/0x2e0\n   blkdev_open+0x56/0x70\n   do_dentry_open.isra.19+0x1ff/0x310\n   vfs_open+0x43/0x60\n   path_openat+0x2c9/0xf30\n   do_filp_open+0x79/0xd0\n   do_sys_open+0x114/0x1e0\n   SyS_open+0x19/0x20\n   entry_SYSCALL_64_fastpath+0x13/0x94\n\nThis patch adds the proper error check in hot_remove_store() not to call\nidr_remove() unconditionally.\n\nFixes: 17ec4cd98578 (\"zram: don't call idr_remove() from zram_remove()\")\nBugzilla: https://bugzilla.opensuse.org/show_bug.cgi?id=1010970\nLink: http://lkml.kernel.org/r/20161121132140.12683-1-tiwai@suse.de\nSigned-off-by: Takashi Iwai <tiwai@suse.de>\nReviewed-by: David Disseldorp <ddiss@suse.de>\nReported-by: David Disseldorp <ddiss@suse.de>\nTested-by: David Disseldorp <ddiss@suse.de>\nAcked-by: Minchan Kim <minchan@kernel.org>\nAcked-by: Sergey Senozhatsky <sergey.senozhatsky@gmail.com>\nCc: <stable@vger.kernel.org>    [4.4+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "drivers/block/zram/zram_drv.c||drivers/block/zram/zram_drv.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/block/zram/zram_drv.c||drivers/block/zram/zram_drv.c": [
          "File: drivers/block/zram/zram_drv.c -> drivers/block/zram/zram_drv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1403:  zram = idr_find(&zram_index_idr, dev_id);",
          "1404:  if (zram) {",
          "1405:   ret = zram_remove(zram);",
          "1407:  } else {",
          "1408:   ret = -ENODEV;",
          "1409:  }",
          "",
          "[Removed Lines]",
          "1406:   idr_remove(&zram_index_idr, dev_id);",
          "",
          "[Added Lines]",
          "1406:   if (!ret)",
          "1407:    idr_remove(&zram_index_idr, dev_id);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "18ae68fff392e445af3c2d8be9bef8a16e1c72a7",
      "candidate_info": {
        "commit_hash": "18ae68fff392e445af3c2d8be9bef8a16e1c72a7",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/18ae68fff392e445af3c2d8be9bef8a16e1c72a7",
        "files": [
          "drivers/net/wireless/ath/ath10k/wmi-ops.h"
        ],
        "message": "ath10k: fix null deref on wmi-tlv when trying spectral scan\n\nWMI ops wrappers did not properly check for null\nfunction pointers for spectral scan. This caused\nnull dereference crash with WMI-TLV based firmware\nwhich doesn't implement spectral scan.\n\nThe crash could be triggered with:\n\n  ip link set dev wlan0 up\n  echo background > /sys/kernel/debug/ieee80211/phy0/ath10k/spectral_scan_ctl\n\nThe crash looked like this:\n\n  [  168.031989] BUG: unable to handle kernel NULL pointer dereference at           (null)\n  [  168.037406] IP: [<          (null)>]           (null)\n  [  168.040395] PGD cdd4067 PUD fa0f067 PMD 0\n  [  168.043303] Oops: 0010 [#1] SMP\n  [  168.045377] Modules linked in: ath10k_pci(O) ath10k_core(O) ath mac80211 cfg80211 [last unloaded: cfg80211]\n  [  168.051560] CPU: 1 PID: 1380 Comm: bash Tainted: G        W  O    4.8.0 #78\n  [  168.054336] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.7.5-20140531_083030-gandalf 04/01/2014\n  [  168.059183] task: ffff88000c460c00 task.stack: ffff88000d4bc000\n  [  168.061736] RIP: 0010:[<0000000000000000>]  [<          (null)>]           (null)\n  ...\n  [  168.100620] Call Trace:\n  [  168.101910]  [<ffffffffa03b9566>] ? ath10k_spectral_scan_config+0x96/0x200 [ath10k_core]\n  [  168.104871]  [<ffffffff811386e2>] ? filemap_fault+0xb2/0x4a0\n  [  168.106696]  [<ffffffffa03b97e6>] write_file_spec_scan_ctl+0x116/0x280 [ath10k_core]\n  [  168.109618]  [<ffffffff812da3a1>] full_proxy_write+0x51/0x80\n  [  168.111443]  [<ffffffff811957b8>] __vfs_write+0x28/0x120\n  [  168.113090]  [<ffffffff812f1a2d>] ? security_file_permission+0x3d/0xc0\n  [  168.114932]  [<ffffffff8109b912>] ? percpu_down_read+0x12/0x60\n  [  168.116680]  [<ffffffff811965f8>] vfs_write+0xb8/0x1a0\n  [  168.118293]  [<ffffffff81197966>] SyS_write+0x46/0xa0\n  [  168.119912]  [<ffffffff818f2972>] entry_SYSCALL_64_fastpath+0x1a/0xa4\n  [  168.121737] Code:  Bad RIP value.\n  [  168.123318] RIP  [<          (null)>]           (null)\n\nSigned-off-by: Michal Kazior <michal.kazior@tieto.com>\nSigned-off-by: Kalle Valo <kvalo@qca.qualcomm.com>",
        "before_after_code_files": [
          "drivers/net/wireless/ath/ath10k/wmi-ops.h||drivers/net/wireless/ath/ath10k/wmi-ops.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/wireless/ath/ath10k/wmi-ops.h||drivers/net/wireless/ath/ath10k/wmi-ops.h": [
          "File: drivers/net/wireless/ath/ath10k/wmi-ops.h -> drivers/net/wireless/ath/ath10k/wmi-ops.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "660:  struct sk_buff *skb;",
          "661:  u32 cmd_id;",
          "663:  skb = ar->wmi.ops->gen_vdev_spectral_conf(ar, arg);",
          "664:  if (IS_ERR(skb))",
          "665:   return PTR_ERR(skb);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "663:  if (!ar->wmi.ops->gen_vdev_spectral_conf)",
          "664:   return -EOPNOTSUPP;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "675:  struct sk_buff *skb;",
          "676:  u32 cmd_id;",
          "678:  skb = ar->wmi.ops->gen_vdev_spectral_enable(ar, vdev_id, trigger,",
          "679:           enable);",
          "680:  if (IS_ERR(skb))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "681:  if (!ar->wmi.ops->gen_vdev_spectral_enable)",
          "682:   return -EOPNOTSUPP;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2014-8541",
  "cve_desc": "libavcodec/mjpegdec.c in FFmpeg before 2.4.2 considers only dimension differences, and not bits-per-pixel differences, when determining whether an image size has changed, which allows remote attackers to cause a denial of service (out-of-bounds access) or possibly have unspecified other impact via crafted MJPEG data.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "5c378d6a6df8243f06c87962b873bd563e58cd39",
  "patch_info": {
    "commit_hash": "5c378d6a6df8243f06c87962b873bd563e58cd39",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/5c378d6a6df8243f06c87962b873bd563e58cd39",
    "files": [
      "libavcodec/mjpegdec.c"
    ],
    "message": "avcodec/mjpegdec: check bits per pixel for changes similar to dimensions\n\nFixes out of array accesses\nFixes: asan_heap-oob_16668e9_2_asan_heap-oob_16668e9_346_miss_congeniality_pegasus_mjpg.avi\n\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
    "before_after_code_files": [
      "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
    ]
  },
  "patch_diff": {
    "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c": [
      "File: libavcodec/mjpegdec.c -> libavcodec/mjpegdec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "245: int ff_mjpeg_decode_sof(MJpegDecodeContext *s)",
      "246: {",
      "248:     int h_count[MAX_COMPONENTS];",
      "249:     int v_count[MAX_COMPONENTS];",
      "",
      "[Removed Lines]",
      "247:     int len, nb_components, i, width, height, pix_fmt_id, ret;",
      "",
      "[Added Lines]",
      "247:     int len, nb_components, i, width, height, bits, pix_fmt_id, ret;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "255:     len     = get_bits(&s->gb, 16);",
      "256:     s->avctx->bits_per_raw_sample =",
      "259:     if (s->pegasus_rct)",
      "262:         s->rct  = 1;    // FIXME ugly",
      "264:     if(s->lossless && s->avctx->lowres){",
      "",
      "[Removed Lines]",
      "257:     s->bits = get_bits(&s->gb, 8);",
      "260:         s->bits = 9;",
      "261:     if (s->bits == 9 && !s->pegasus_rct)",
      "",
      "[Added Lines]",
      "257:     bits = get_bits(&s->gb, 8);",
      "260:         bits = 9;",
      "261:     if (bits == 9 && !s->pegasus_rct)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "291:             return AVERROR_INVALIDDATA;",
      "292:         }",
      "293:     }",
      "295:         avpriv_report_missing_feature(s->avctx,",
      "296:                                       \"JPEG-LS that is not <= 8 \"",
      "297:                                       \"bits/component or 16-bit gray\");",
      "",
      "[Removed Lines]",
      "294:     if (s->ls && !(s->bits <= 8 || nb_components == 1)) {",
      "",
      "[Added Lines]",
      "294:     if (s->ls && !(bits <= 8 || nb_components == 1)) {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "339:     if (   width != s->width || height != s->height",
      "340:         || memcmp(s->h_count, h_count, sizeof(h_count))",
      "341:         || memcmp(s->v_count, v_count, sizeof(v_count))) {",
      "343:         s->width      = width;",
      "344:         s->height     = height;",
      "345:         memcpy(s->h_count, h_count, sizeof(h_count));",
      "346:         memcpy(s->v_count, v_count, sizeof(v_count));",
      "347:         s->interlaced = 0;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "340:         || bits != s->bits",
      "346:         s->bits       = bits;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "2cd94ad5bff929d98eeb50aed46831b950421281",
      "candidate_info": {
        "commit_hash": "2cd94ad5bff929d98eeb50aed46831b950421281",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/2cd94ad5bff929d98eeb50aed46831b950421281",
        "files": [
          "libavcodec/mjpegdec.c"
        ],
        "message": "mjpegdec: stop using deprecated avcodec_set_dimensions",
        "before_after_code_files": [
          "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
          ],
          "candidate": [
            "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c": [
          "File: libavcodec/mjpegdec.c -> libavcodec/mjpegdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "212: int ff_mjpeg_decode_sof(MJpegDecodeContext *s)",
          "213: {",
          "217:     len     = get_bits(&s->gb, 16);",
          "",
          "[Removed Lines]",
          "214:     int len, nb_components, i, width, height, pix_fmt_id;",
          "",
          "[Added Lines]",
          "214:     int len, nb_components, i, width, height, pix_fmt_id, ret;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "309:             height *= 2;",
          "310:         }",
          "314:         s->first_picture = 0;",
          "315:     }",
          "",
          "[Removed Lines]",
          "312:         avcodec_set_dimensions(s->avctx, width, height);",
          "",
          "[Added Lines]",
          "312:         ret = ff_set_dimensions(s->avctx, width, height);",
          "313:         if (ret < 0)",
          "314:             return ret;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7e2ba2df287c068112e3745b22b38a680877db9e",
      "candidate_info": {
        "commit_hash": "7e2ba2df287c068112e3745b22b38a680877db9e",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/7e2ba2df287c068112e3745b22b38a680877db9e",
        "files": [
          "libavcodec/mjpegdec.c"
        ],
        "message": "mjpeg: update whitespaces to qatar",
        "before_after_code_files": [
          "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
          ],
          "candidate": [
            "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c": [
          "File: libavcodec/mjpegdec.c -> libavcodec/mjpegdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "43: #include \"jpeglsdec.h\"",
          "48: {",
          "49:     uint8_t huff_size[256];",
          "50:     uint16_t huff_code[256];",
          "",
          "[Removed Lines]",
          "46: static int build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table,",
          "47:                       int nb_codes, int use_static, int is_ac)",
          "",
          "[Added Lines]",
          "46: static int build_vlc(VLC *vlc, const uint8_t *bits_table,",
          "47:                      const uint8_t *val_table, int nb_codes,",
          "48:                      int use_static, int is_ac)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56:     memset(huff_size, 0, sizeof(huff_size));",
          "57:     ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);",
          "65: }",
          "68:     build_vlc(&s->vlcs[0][0], ff_mjpeg_bits_dc_luminance,",
          "69:               ff_mjpeg_val_dc, 12, 0, 0);",
          "70:     build_vlc(&s->vlcs[0][1], ff_mjpeg_bits_dc_chrominance,",
          "",
          "[Removed Lines]",
          "59:     for(i=0; i<256; i++)",
          "60:         huff_sym[i]= i + 16*is_ac;",
          "62:     if(is_ac) huff_sym[0]= 16*256;",
          "64:     return init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2, huff_sym, 2, 2, use_static);",
          "67: static void build_basic_mjpeg_vlc(MJpegDecodeContext * s) {",
          "",
          "[Added Lines]",
          "60:     for (i = 0; i < 256; i++)",
          "61:         huff_sym[i] = i + 16 * is_ac;",
          "63:     if (is_ac)",
          "64:         huff_sym[0] = 16 * 256;",
          "66:     return init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,",
          "67:                            huff_code, 2, 2, huff_sym, 2, 2, use_static);",
          "70: static void build_basic_mjpeg_vlc(MJpegDecodeContext *s)",
          "71: {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90:     s->avctx = avctx;",
          "91:     dsputil_init(&s->dsp, avctx);",
          "92:     ff_init_scantable(s->dsp.idct_permutation, &s->scantable, ff_zigzag_direct);",
          "96:     s->first_picture = 1;",
          "98:     avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;",
          "100:     build_basic_mjpeg_vlc(s);",
          "",
          "[Removed Lines]",
          "93:     s->buffer_size = 0;",
          "94:     s->buffer = NULL;",
          "95:     s->start_code = -1;",
          "97:     s->org_height = avctx->coded_height;",
          "",
          "[Added Lines]",
          "97:     s->buffer_size   = 0;",
          "98:     s->buffer        = NULL;",
          "99:     s->start_code    = -1;",
          "101:     s->org_height    = avctx->coded_height;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "103:     if (avctx->flags & CODEC_FLAG_EXTERN_HUFF)",
          "104:         s->extern_huff = 1;",
          "105: #endif",
          "108:         av_log(avctx, AV_LOG_INFO, \"mjpeg: using external huffman table\\n\");",
          "110:         if (ff_mjpeg_decode_dht(s)) {",
          "112:             build_basic_mjpeg_vlc(s);",
          "113:         }",
          "114:     }",
          "117:         av_log(avctx, AV_LOG_DEBUG, \"mjpeg bottom field first\\n\");",
          "118:     }",
          "119:     if (avctx->codec->id == CODEC_ID_AMV)",
          "",
          "[Removed Lines]",
          "106:     if (s->extern_huff)",
          "107:     {",
          "109:         init_get_bits(&s->gb, avctx->extradata, avctx->extradata_size*8);",
          "111:             av_log(avctx, AV_LOG_ERROR, \"mjpeg: error using external huffman table, switching back to internal\\n\");",
          "",
          "[Added Lines]",
          "110:     if (s->extern_huff) {",
          "112:         init_get_bits(&s->gb, avctx->extradata, avctx->extradata_size * 8);",
          "114:             av_log(avctx, AV_LOG_ERROR,",
          "115:                    \"mjpeg: error using external huffman table, switching back to internal\\n\");",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "133:     while (len >= 65) {",
          "137:             av_log(s->avctx, AV_LOG_ERROR, \"dqt: 16bit precision\\n\");",
          "138:             return -1;",
          "139:         }",
          "",
          "[Removed Lines]",
          "135:         if (get_bits(&s->gb, 4) != 0)",
          "136:         {",
          "",
          "[Added Lines]",
          "139:         if (get_bits(&s->gb, 4) != 0) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "142:             return -1;",
          "143:         av_log(s->avctx, AV_LOG_DEBUG, \"index=%d\\n\", index);",
          "146:             j = s->scantable.permutated[i];",
          "147:             s->quant_matrixes[index][j] = get_bits(&s->gb, 8);",
          "148:         }",
          "155:         len -= 65;",
          "156:     }",
          "158:     return 0;",
          "159: }",
          "",
          "[Removed Lines]",
          "145:         for(i=0;i<64;i++) {",
          "151:         s->qscale[index]= FFMAX(",
          "152:             s->quant_matrixes[index][s->scantable.permutated[1]],",
          "153:             s->quant_matrixes[index][s->scantable.permutated[8]]) >> 1;",
          "154:         av_log(s->avctx, AV_LOG_DEBUG, \"qscale[%d]: %d\\n\", index, s->qscale[index]);",
          "",
          "[Added Lines]",
          "148:         for (i = 0; i < 64; i++) {",
          "154:         s->qscale[index] = FFMAX(s->quant_matrixes[index][s->scantable.permutated[1]],",
          "155:                                  s->quant_matrixes[index][s->scantable.permutated[8]]) >> 1;",
          "156:         av_log(s->avctx, AV_LOG_DEBUG, \"qscale[%d]: %d\\n\",",
          "157:                index, s->qscale[index]);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "177:         if (index >= 4)",
          "178:             return -1;",
          "179:         n = 0;",
          "181:             bits_table[i] = get_bits(&s->gb, 8);",
          "182:             n += bits_table[i];",
          "183:         }",
          "",
          "[Removed Lines]",
          "180:         for(i=1;i<=16;i++) {",
          "",
          "[Added Lines]",
          "182:         for (i = 1; i <= 16; i++) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "186:             return -1;",
          "188:         code_max = 0;",
          "190:             v = get_bits(&s->gb, 8);",
          "191:             if (v > code_max)",
          "192:                 code_max = v;",
          "",
          "[Removed Lines]",
          "189:         for(i=0;i<n;i++) {",
          "",
          "[Added Lines]",
          "191:         for (i = 0; i < n; i++) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "198:         free_vlc(&s->vlcs[class][index]);",
          "199:         av_log(s->avctx, AV_LOG_DEBUG, \"class=%d index=%d nb_codes=%d\\n\",",
          "200:                class, index, code_max + 1);",
          "202:             return -1;",
          "206:             free_vlc(&s->vlcs[2][index]);",
          "210:         }",
          "211:     }",
          "212:     return 0;",
          "",
          "[Removed Lines]",
          "201:         if(build_vlc(&s->vlcs[class][index], bits_table, val_table, code_max + 1, 0, class > 0) < 0){",
          "203:         }",
          "205:         if(class>0){",
          "207:             if(build_vlc(&s->vlcs[2][index], bits_table, val_table, code_max + 1, 0, 0) < 0){",
          "208:             return -1;",
          "209:             }",
          "",
          "[Added Lines]",
          "203:         if (build_vlc(&s->vlcs[class][index], bits_table, val_table,",
          "204:                       code_max + 1, 0, class > 0) < 0)",
          "207:         if (class > 0) {",
          "209:             if (build_vlc(&s->vlcs[2][index], bits_table, val_table,",
          "210:                           code_max + 1, 0, 0) < 0)",
          "211:                 return -1;",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "219:     s->cur_scan = 0;",
          "229:         av_log(s->avctx, AV_LOG_ERROR, \"only 8 bits/component accepted\\n\");",
          "230:         return -1;",
          "231:     }",
          "",
          "[Removed Lines]",
          "222:     len = get_bits(&s->gb, 16);",
          "223:     s->bits= get_bits(&s->gb, 8);",
          "225:     if(s->pegasus_rct) s->bits=9;",
          "226:     if(s->bits==9 && !s->pegasus_rct) s->rct=1;    //FIXME ugly",
          "228:     if (s->bits != 8 && !s->lossless){",
          "",
          "[Added Lines]",
          "224:     len     = get_bits(&s->gb, 16);",
          "225:     s->bits = get_bits(&s->gb, 8);",
          "227:     if (s->pegasus_rct)",
          "228:         s->bits = 9;",
          "229:     if (s->bits == 9 && !s->pegasus_rct)",
          "230:         s->rct  = 1;    // FIXME ugly",
          "232:     if (s->bits != 8 && !s->lossless) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "236:     }",
          "238:     height = get_bits(&s->gb, 16);",
          "243:         height= s->height;",
          "245:     av_log(s->avctx, AV_LOG_DEBUG, \"sof0: picture: %dx%d\\n\", width, height);",
          "247:         return -1;",
          "249:     nb_components = get_bits(&s->gb, 8);",
          "250:     if (nb_components <= 0 ||",
          "251:         nb_components > MAX_COMPONENTS)",
          "252:         return -1;",
          "255:         return -1;",
          "256:     }",
          "257:     s->nb_components = nb_components;",
          "262:         s->component_id[i] = get_bits(&s->gb, 8) - 1;",
          "266:         if (s->h_count[i] > s->h_max)",
          "267:             s->h_max = s->h_count[i];",
          "",
          "[Removed Lines]",
          "239:     width = get_bits(&s->gb, 16);",
          "242:     if(s->interlaced && s->width == width && s->height == height + 1)",
          "246:     if(av_image_check_size(width, height, 0, s->avctx))",
          "253:     if (s->ls && !(s->bits <= 8 || nb_components == 1)){",
          "254:         av_log(s->avctx, AV_LOG_ERROR, \"only <= 8 bits/component or 16-bit gray accepted for JPEG-LS\\n\");",
          "258:     s->h_max = 1;",
          "259:     s->v_max = 1;",
          "260:     for(i=0;i<nb_components;i++) {",
          "263:         s->h_count[i] = get_bits(&s->gb, 4);",
          "264:         s->v_count[i] = get_bits(&s->gb, 4);",
          "",
          "[Added Lines]",
          "243:     width  = get_bits(&s->gb, 16);",
          "246:     if (s->interlaced && s->width == width && s->height == height + 1)",
          "250:     if (av_image_check_size(width, height, 0, s->avctx))",
          "257:     if (s->ls && !(s->bits <= 8 || nb_components == 1)) {",
          "258:         av_log(s->avctx, AV_LOG_ERROR,",
          "259:                \"only <= 8 bits/component or 16-bit gray accepted for JPEG-LS\\n\");",
          "263:     s->h_max         = 1;",
          "264:     s->v_max         = 1;",
          "265:     for (i = 0; i < nb_components; i++) {",
          "268:         s->h_count[i]      = get_bits(&s->gb, 4);",
          "269:         s->v_count[i]      = get_bits(&s->gb, 4);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "270:         s->quant_index[i] = get_bits(&s->gb, 8);",
          "271:         if (s->quant_index[i] >= 4)",
          "272:             return -1;",
          "275:     }",
          "279:         return -1;",
          "280:     }",
          "286:     if (width != s->width || height != s->height) {",
          "287:         av_freep(&s->qscale_table);",
          "291:         s->interlaced = 0;",
          "295:             s->org_height != 0 &&",
          "296:             s->height < ((s->org_height * 3) / 4)) {",
          "299:             s->picture_ptr->interlaced_frame = 1;",
          "301:             height *= 2;",
          "302:         }",
          "304:         avcodec_set_dimensions(s->avctx, width, height);",
          "308:         s->first_picture = 0;",
          "309:     }",
          "312:         return 0;",
          "",
          "[Removed Lines]",
          "273:         av_log(s->avctx, AV_LOG_DEBUG, \"component %d %d:%d id: %d quant:%d\\n\", i, s->h_count[i],",
          "274:                s->v_count[i], s->component_id[i], s->quant_index[i]);",
          "277:     if(s->ls && (s->h_max > 1 || s->v_max > 1)) {",
          "278:         av_log(s->avctx, AV_LOG_ERROR, \"Subsampling in JPEG-LS is not supported.\\n\");",
          "282:     if(s->v_max==1 && s->h_max==1 && s->lossless==1 && nb_components==3) s->rgb=1;",
          "289:         s->width = width;",
          "290:         s->height = height;",
          "294:         if (s->first_picture &&",
          "297:             s->interlaced = 1;",
          "298:             s->bottom_field = s->interlace_polarity;",
          "300:             s->picture_ptr->top_field_first = !s->interlace_polarity;",
          "306:         s->qscale_table= av_mallocz((s->width+15)/16);",
          "311:     if(s->interlaced && (s->bottom_field == !s->interlace_polarity))",
          "",
          "[Added Lines]",
          "278:         av_log(s->avctx, AV_LOG_DEBUG, \"component %d %d:%d id: %d quant:%d\\n\",",
          "279:                i, s->h_count[i], s->v_count[i],",
          "280:                s->component_id[i], s->quant_index[i]);",
          "283:     if (s->ls && (s->h_max > 1 || s->v_max > 1)) {",
          "284:         av_log(s->avctx, AV_LOG_ERROR,",
          "285:                \"Subsampling in JPEG-LS is not supported.\\n\");",
          "289:     if (s->v_max == 1 && s->h_max == 1 && s->lossless==1 && nb_components==3)",
          "290:         s->rgb = 1;",
          "297:         s->width      = width;",
          "298:         s->height     = height;",
          "302:         if (s->first_picture   &&",
          "305:             s->interlaced                    = 1;",
          "306:             s->bottom_field                  = s->interlace_polarity;",
          "308:             s->picture_ptr->top_field_first  = !s->interlace_polarity;",
          "314:         s->qscale_table  = av_mallocz((s->width + 15) / 16);",
          "318:     if (s->interlaced && (s->bottom_field == !s->interlace_polarity))",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "317:                  (s->h_count[2] << 12) | (s->v_count[2] <<  8) |",
          "318:                  (s->h_count[3] <<  4) |  s->v_count[3];",
          "319:     av_log(s->avctx, AV_LOG_DEBUG, \"pix fmt id %x\\n\", pix_fmt_id);",
          "327:     case 0x11111100:",
          "329:             s->avctx->pix_fmt = PIX_FMT_BGR24;",
          "332:                 s->avctx->pix_fmt = PIX_FMT_GBR24P;",
          "334:             s->avctx->pix_fmt = s->cs_itu601 ? PIX_FMT_YUV444P : PIX_FMT_YUVJ444P;",
          "335:             s->avctx->color_range = s->cs_itu601 ? AVCOL_RANGE_MPEG : AVCOL_RANGE_JPEG;",
          "336:             }",
          "337:         }",
          "339:         break;",
          "340:     case 0x12121100:",
          "341:     case 0x22122100:",
          "",
          "[Removed Lines]",
          "321:     if(!(pix_fmt_id & 0xD0D0D0D0))",
          "322:         pix_fmt_id-= (pix_fmt_id & 0xF0F0F0F0)>>1;",
          "323:     if(!(pix_fmt_id & 0x0D0D0D0D))",
          "324:         pix_fmt_id-= (pix_fmt_id & 0x0F0F0F0F)>>1;",
          "326:     switch(pix_fmt_id){",
          "328:         if(s->rgb){",
          "330:         }else{",
          "331:             if(s->component_id[0] == 'Q' && s->component_id[1] == 'F' && s->component_id[2] == 'A'){",
          "333:             }else{",
          "338:         assert(s->nb_components==3);",
          "",
          "[Added Lines]",
          "329:     if (!(pix_fmt_id & 0xD0D0D0D0))",
          "330:         pix_fmt_id -= (pix_fmt_id & 0xF0F0F0F0) >> 1;",
          "331:     if (!(pix_fmt_id & 0x0D0D0D0D))",
          "332:         pix_fmt_id -= (pix_fmt_id & 0x0F0F0F0F) >> 1;",
          "334:     switch (pix_fmt_id) {",
          "336:         if (s->rgb)",
          "338:         else {",
          "339:             if (s->component_id[0] == 'Q' && s->component_id[1] == 'F' && s->component_id[2] == 'A') {",
          "341:             } else {",
          "346:         assert(s->nb_components == 3);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "392:         av_log(s->avctx, AV_LOG_ERROR, \"Unhandled pixel format 0x%x\\n\", pix_fmt_id);",
          "393:         return -1;",
          "394:     }",
          "397:             s->avctx->pix_fmt = PIX_FMT_RGB24;",
          "399:             s->avctx->pix_fmt = PIX_FMT_GRAY8;",
          "400:         else",
          "401:             s->avctx->pix_fmt = PIX_FMT_GRAY16;",
          "402:     }",
          "405:         s->avctx->release_buffer(s->avctx, s->picture_ptr);",
          "408:         av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");",
          "409:         return -1;",
          "410:     }",
          "423:         av_log(s->avctx, AV_LOG_DEBUG, \"decode_sof0: error, len(%d) mismatch\\n\", len);",
          "431:             int size = bw * bh * s->h_count[i] * s->v_count[i];",
          "432:             av_freep(&s->blocks[i]);",
          "433:             av_freep(&s->last_nnz[i]);",
          "436:             s->block_stride[i] = bw * s->h_count[i];",
          "437:         }",
          "438:         memset(s->coefs_finished, 0, sizeof(s->coefs_finished));",
          "",
          "[Removed Lines]",
          "395:     if(s->ls){",
          "396:         if(s->nb_components > 1)",
          "398:         else if(s->bits <= 8)",
          "404:     if(s->picture_ptr->data[0])",
          "407:     if(s->avctx->get_buffer(s->avctx, s->picture_ptr) < 0){",
          "411:     s->picture_ptr->pict_type= AV_PICTURE_TYPE_I;",
          "412:     s->picture_ptr->key_frame= 1;",
          "413:     s->got_picture = 1;",
          "415:     for(i=0; i<3; i++){",
          "416:         s->linesize[i]= s->picture_ptr->linesize[i] << s->interlaced;",
          "417:     }",
          "421:     if (len != (8+(3*nb_components)))",
          "422:     {",
          "424:     }",
          "427:     if(s->progressive){",
          "428:         int bw = (width  + s->h_max*8-1) / (s->h_max*8);",
          "429:         int bh = (height + s->v_max*8-1) / (s->v_max*8);",
          "430:         for(i=0; i<s->nb_components; i++) {",
          "434:             s->blocks[i] = av_malloc(size * sizeof(**s->blocks));",
          "435:             s->last_nnz[i] = av_mallocz(size * sizeof(**s->last_nnz));",
          "",
          "[Added Lines]",
          "403:     if (s->ls) {",
          "404:         if (s->nb_components > 1)",
          "406:         else if (s->bits <= 8)",
          "412:     if (s->picture_ptr->data[0])",
          "415:     if (s->avctx->get_buffer(s->avctx, s->picture_ptr) < 0) {",
          "419:     s->picture_ptr->pict_type = AV_PICTURE_TYPE_I;",
          "420:     s->picture_ptr->key_frame = 1;",
          "421:     s->got_picture            = 1;",
          "423:     for (i = 0; i < 3; i++)",
          "424:         s->linesize[i] = s->picture_ptr->linesize[i] << s->interlaced;",
          "430:     if (len != (8 + (3 * nb_components)))",
          "434:     if (s->progressive) {",
          "435:         int bw = (width  + s->h_max * 8 - 1) / (s->h_max * 8);",
          "436:         int bh = (height + s->v_max * 8 - 1) / (s->v_max * 8);",
          "437:         for (i = 0; i < s->nb_components; i++) {",
          "441:             s->blocks[i]       = av_malloc(size * sizeof(**s->blocks));",
          "442:             s->last_nnz[i]     = av_mallocz(size * sizeof(**s->last_nnz));",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "444: {",
          "445:     int code;",
          "446:     code = get_vlc2(&s->gb, s->vlcs[0][dc_index].table, 9, 2);",
          "451:         return 0xffff;",
          "452:     }",
          "455:         return get_xbits(&s->gb, code);",
          "456:     else",
          "457:         return 0;",
          "458: }",
          "463: {",
          "464:     int code, i, j, level, val;",
          "",
          "[Removed Lines]",
          "447:     if (code < 0)",
          "448:     {",
          "449:         av_log(s->avctx, AV_LOG_WARNING, \"mjpeg_decode_dc: bad vlc: %d:%d (%p)\\n\", 0, dc_index,",
          "450:                &s->vlcs[0][dc_index]);",
          "454:     if(code)",
          "461: static int decode_block(MJpegDecodeContext *s, DCTELEM *block,",
          "462:                         int component, int dc_index, int ac_index, int16_t *quant_matrix)",
          "",
          "[Added Lines]",
          "454:     if (code < 0) {",
          "455:         av_log(s->avctx, AV_LOG_WARNING,",
          "456:                \"mjpeg_decode_dc: bad vlc: %d:%d (%p)\\n\",",
          "457:                0, dc_index, &s->vlcs[0][dc_index]);",
          "461:     if (code)",
          "468: static int decode_block(MJpegDecodeContext *s, DCTELEM *block, int component,",
          "469:                         int dc_index, int ac_index, int16_t *quant_matrix)",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "482:         i += ((unsigned)code) >> 4;",
          "483:             code &= 0xf;",
          "486:                 UPDATE_CACHE(re, &s->gb);",
          "488:             {",
          "492:             }",
          "494:             LAST_SKIP_BITS(re, &s->gb, code);",
          "",
          "[Removed Lines]",
          "484:         if(code){",
          "485:             if(code > MIN_CACHE_BITS - 16){",
          "487:             }",
          "489:                 int cache=GET_CACHE(re,&s->gb);",
          "490:                 int sign=(~cache)>>31;",
          "491:                 level = (NEG_USR32(sign ^ cache,code) ^ sign) - sign;",
          "",
          "[Added Lines]",
          "491:         if (code) {",
          "492:             if (code > MIN_CACHE_BITS - 16)",
          "496:                 int cache = GET_CACHE(re, &s->gb);",
          "497:                 int sign  = (~cache) >> 31;",
          "498:                 level     = (NEG_USR32(sign ^ cache,code) ^ sign) - sign;",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "497:                 av_log(s->avctx, AV_LOG_ERROR, \"error count: %d\\n\", i);",
          "498:                 return -1;",
          "499:             }",
          "501:             block[j] = level * quant_matrix[j];",
          "502:         }",
          "504:     CLOSE_READER(re, &s->gb);}",
          "506:     return 0;",
          "507: }",
          "511: {",
          "512:     int val;",
          "513:     s->dsp.clear_block(block);",
          "",
          "[Removed Lines]",
          "500:             j = s->scantable.permutated[i];",
          "503:     }while(i<63);",
          "509: static int decode_dc_progressive(MJpegDecodeContext *s, DCTELEM *block, int component,",
          "510:                                  int dc_index, int16_t *quant_matrix, int Al)",
          "",
          "[Added Lines]",
          "507:             j        = s->scantable.permutated[i];",
          "510:     } while (i < 63);",
          "516: static int decode_dc_progressive(MJpegDecodeContext *s, DCTELEM *block,",
          "517:                                  int component, int dc_index,",
          "518:                                  int16_t *quant_matrix, int Al)",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "523: }",
          "528:                                     int ss, int se, int Al, int *EOBRUN)",
          "529: {",
          "530:     int code, i, j, level, val, run;",
          "533:         (*EOBRUN)--;",
          "534:         return 0;",
          "535:     }",
          "561:                 }",
          "570:                 if (i >= se) {",
          "572:                     return -1;",
          "573:                 }",
          "580:                 }",
          "583:             }",
          "584:         }",
          "585:     }",
          "589:     return 0;",
          "590: }",
          "597: }",
          "614: }",
          "620: {",
          "624:     OPEN_READER(re, &s->gb);",
          "626:         (*EOBRUN)--;",
          "629:             UPDATE_CACHE(re, &s->gb);",
          "630:             GET_VLC(code, re, &s->gb, s->vlcs[2][ac_index].table, 9, 2);",
          "633:                 run = ((unsigned) code) >> 4;",
          "634:                 UPDATE_CACHE(re, &s->gb);",
          "635:                 val = SHOW_UBITS(re, &s->gb, 1);",
          "",
          "[Removed Lines]",
          "526: static int decode_block_progressive(MJpegDecodeContext *s, DCTELEM *block, uint8_t *last_nnz,",
          "527:                                     int ac_index, int16_t *quant_matrix,",
          "532:     if(*EOBRUN){",
          "536:     {OPEN_READER(re, &s->gb);",
          "537:     for(i=ss;;i++) {",
          "538:         UPDATE_CACHE(re, &s->gb);",
          "539:         GET_VLC(code, re, &s->gb, s->vlcs[2][ac_index].table, 9, 2);",
          "541:         run = ((unsigned) code) >> 4;",
          "542:         code &= 0xF;",
          "543:         if(code) {",
          "544:             i += run;",
          "545:             if(code > MIN_CACHE_BITS - 16){",
          "546:                 UPDATE_CACHE(re, &s->gb);",
          "547:             }",
          "548:             {",
          "549:                 int cache=GET_CACHE(re,&s->gb);",
          "550:                 int sign=(~cache)>>31;",
          "551:                 level = (NEG_USR32(sign ^ cache,code) ^ sign) - sign;",
          "552:             }",
          "554:             LAST_SKIP_BITS(re, &s->gb, code);",
          "556:             if (i >= se) {",
          "557:                 if(i == se){",
          "558:                     j = s->scantable.permutated[se];",
          "559:                     block[j] = level * quant_matrix[j] << Al;",
          "560:                     break;",
          "562:                 av_log(s->avctx, AV_LOG_ERROR, \"error count: %d\\n\", i);",
          "563:                 return -1;",
          "564:             }",
          "565:             j = s->scantable.permutated[i];",
          "566:             block[j] = level * quant_matrix[j] << Al;",
          "567:         }else{",
          "568:             if(run == 0xF){// ZRL - skip 15 coefficients",
          "569:                 i += 15;",
          "571:                     av_log(s->avctx, AV_LOG_ERROR, \"ZRL overflow: %d\\n\", i);",
          "574:             }else{",
          "575:                 val = (1 << run);",
          "576:                 if(run){",
          "577:                     UPDATE_CACHE(re, &s->gb);",
          "578:                     val += NEG_USR32(GET_CACHE(re, &s->gb), run);",
          "579:                     LAST_SKIP_BITS(re, &s->gb, run);",
          "582:                 break;",
          "586:     CLOSE_READER(re, &s->gb);}",
          "587:     if(i > *last_nnz)",
          "592: #define REFINE_BIT(j) {\\",
          "593:     UPDATE_CACHE(re, &s->gb);\\",
          "594:     sign = block[j]>>15;\\",
          "595:     block[j] += SHOW_UBITS(re, &s->gb, 1) * ((quant_matrix[j]^sign)-sign) << Al;\\",
          "596:     LAST_SKIP_BITS(re, &s->gb, 1);\\",
          "599: #define ZERO_RUN \\",
          "600: for(;;i++) {\\",
          "601:     if(i > last) {\\",
          "602:         i += run;\\",
          "603:         if(i > se) {\\",
          "604:             av_log(s->avctx, AV_LOG_ERROR, \"error count: %d\\n\", i);\\",
          "605:             return -1;\\",
          "606:         }\\",
          "607:         break;\\",
          "608:     }\\",
          "609:     j = s->scantable.permutated[i];\\",
          "610:     if(block[j])\\",
          "611:         REFINE_BIT(j)\\",
          "612:     else if(run-- == 0)\\",
          "613:         break;\\",
          "617: static int decode_block_refinement(MJpegDecodeContext *s, DCTELEM *block, uint8_t *last_nnz,",
          "618:                         int ac_index, int16_t *quant_matrix,",
          "619:                         int ss, int se, int Al, int *EOBRUN)",
          "621:     int code, i=ss, j, sign, val, run;",
          "622:     int last = FFMIN(se, *last_nnz);",
          "625:     if(*EOBRUN)",
          "627:     else {",
          "628:         for(;;i++) {",
          "632:             if(code & 0xF) {",
          "",
          "[Added Lines]",
          "534: static int decode_block_progressive(MJpegDecodeContext *s, DCTELEM *block,",
          "535:                                     uint8_t *last_nnz, int ac_index,",
          "536:                                     int16_t *quant_matrix,",
          "541:     if (*EOBRUN) {",
          "546:     {",
          "547:         OPEN_READER(re, &s->gb);",
          "548:         for (i = ss; ; i++) {",
          "549:             UPDATE_CACHE(re, &s->gb);",
          "550:             GET_VLC(code, re, &s->gb, s->vlcs[2][ac_index].table, 9, 2);",
          "552:             run = ((unsigned) code) >> 4;",
          "553:             code &= 0xF;",
          "554:             if (code) {",
          "555:                 i += run;",
          "556:                 if (code > MIN_CACHE_BITS - 16)",
          "557:                     UPDATE_CACHE(re, &s->gb);",
          "559:                 {",
          "560:                     int cache = GET_CACHE(re, &s->gb);",
          "561:                     int sign  = (~cache) >> 31;",
          "562:                     level     = (NEG_USR32(sign ^ cache,code) ^ sign) - sign;",
          "565:                 LAST_SKIP_BITS(re, &s->gb, code);",
          "568:                     if (i == se) {",
          "569:                         j = s->scantable.permutated[se];",
          "570:                         block[j] = level * quant_matrix[j] << Al;",
          "571:                         break;",
          "572:                     }",
          "573:                     av_log(s->avctx, AV_LOG_ERROR, \"error count: %d\\n\", i);",
          "576:                 j = s->scantable.permutated[i];",
          "577:                 block[j] = level * quant_matrix[j] << Al;",
          "578:             } else {",
          "579:                 if (run == 0xF) {// ZRL - skip 15 coefficients",
          "580:                     i += 15;",
          "581:                     if (i >= se) {",
          "582:                         av_log(s->avctx, AV_LOG_ERROR, \"ZRL overflow: %d\\n\", i);",
          "583:                         return -1;",
          "584:                     }",
          "585:                 } else {",
          "586:                     val = (1 << run);",
          "587:                     if (run) {",
          "588:                         UPDATE_CACHE(re, &s->gb);",
          "589:                         val += NEG_USR32(GET_CACHE(re, &s->gb), run);",
          "590:                         LAST_SKIP_BITS(re, &s->gb, run);",
          "591:                     }",
          "593:                     break;",
          "597:         CLOSE_READER(re, &s->gb);",
          "600:     if (i > *last_nnz)",
          "606: #define REFINE_BIT(j) {                                             \\",
          "607:     UPDATE_CACHE(re, &s->gb);                                       \\",
          "608:     sign = block[j] >> 15;                                          \\",
          "609:     block[j] += SHOW_UBITS(re, &s->gb, 1) *                         \\",
          "610:                 ((quant_matrix[j] ^ sign) - sign) << Al;            \\",
          "611:     LAST_SKIP_BITS(re, &s->gb, 1);                                  \\",
          "614: #define ZERO_RUN                                                    \\",
          "615: for (; ; i++) {                                                     \\",
          "616:     if (i > last) {                                                 \\",
          "617:         i += run;                                                   \\",
          "618:         if (i > se) {                                               \\",
          "619:             av_log(s->avctx, AV_LOG_ERROR, \"error count: %d\\n\", i); \\",
          "620:             return -1;                                              \\",
          "621:         }                                                           \\",
          "622:         break;                                                      \\",
          "623:     }                                                               \\",
          "624:     j = s->scantable.permutated[i];                                 \\",
          "625:     if (block[j])                                                   \\",
          "626:         REFINE_BIT(j)                                               \\",
          "627:     else if (run-- == 0)                                            \\",
          "628:         break;                                                      \\",
          "632: static int decode_block_refinement(MJpegDecodeContext *s, DCTELEM *block,",
          "633:                                    uint8_t *last_nnz,",
          "634:                                    int ac_index, int16_t *quant_matrix,",
          "635:                                    int ss, int se, int Al, int *EOBRUN)",
          "637:     int code, i = ss, j, sign, val, run;",
          "638:     int last    = FFMIN(se, *last_nnz);",
          "641:     if (*EOBRUN) {",
          "643:     } else {",
          "644:         for (; ; i++) {",
          "648:             if (code & 0xF) {",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "637:                 ZERO_RUN;",
          "638:                 j = s->scantable.permutated[i];",
          "639:                 val--;",
          "644:                     CLOSE_READER(re, &s->gb);",
          "645:                     return 0;",
          "646:                 }",
          "648:                 run = ((unsigned) code) >> 4;",
          "650:                     ZERO_RUN;",
          "652:                     val = run;",
          "653:                     run = (1 << run);",
          "655:                         UPDATE_CACHE(re, &s->gb);",
          "656:                         run += SHOW_UBITS(re, &s->gb, val);",
          "657:                         LAST_SKIP_BITS(re, &s->gb, val);",
          "",
          "[Removed Lines]",
          "640:                 block[j] = ((quant_matrix[j]^val)-val) << Al;",
          "641:                 if(i == se) {",
          "642:                     if(i > *last_nnz)",
          "647:             }else{",
          "649:                 if(run == 0xF){",
          "651:                 }else{",
          "654:                     if(val) {",
          "",
          "[Added Lines]",
          "656:                 block[j] = ((quant_matrix[j]^val) - val) << Al;",
          "657:                 if (i == se) {",
          "658:                     if (i > *last_nnz)",
          "663:             } else {",
          "665:                 if (run == 0xF) {",
          "667:                 } else {",
          "670:                     if (val) {",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "662:             }",
          "663:         }",
          "667:     }",
          "670:         j = s->scantable.permutated[i];",
          "672:             REFINE_BIT(j)",
          "673:     }",
          "674:     CLOSE_READER(re, &s->gb);",
          "",
          "[Removed Lines]",
          "665:         if(i > *last_nnz)",
          "669:     for(;i<=last;i++) {",
          "671:         if(block[j])",
          "",
          "[Added Lines]",
          "681:         if (i > *last_nnz)",
          "685:     for (; i <= last; i++) {",
          "687:         if (block[j])",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "678: #undef REFINE_BIT",
          "679: #undef ZERO_RUN",
          "682:     int i, mb_x, mb_y;",
          "683:     uint16_t (*buffer)[4];",
          "684:     int left[3], top[3], topleft[3];",
          "687:     int resync_mb_y = 0;",
          "688:     int resync_mb_x = 0;",
          "697:         uint8_t *ptr = s->picture.data[0] + (linesize * mb_y);",
          "699:         if (s->interlaced && s->bottom_field)",
          "700:             ptr += linesize >> 1;",
          "706:             int modified_predictor = predictor;",
          "708:             if (s->restart_interval && !s->restart_count){",
          "",
          "[Removed Lines]",
          "681: static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform){",
          "685:     const int linesize= s->linesize[0];",
          "686:     const int mask= (1<<s->bits)-1;",
          "690:     av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size, (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));",
          "691:     buffer= s->ljpeg_buffer;",
          "693:     for(i=0; i<3; i++){",
          "694:         buffer[0][i]= 1 << (s->bits - 1);",
          "695:     }",
          "696:     for(mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "702:         for(i=0; i<3; i++){",
          "703:             top[i]= left[i]= topleft[i]= buffer[0][i];",
          "704:         }",
          "705:         for(mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "",
          "[Added Lines]",
          "697: static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform)",
          "698: {",
          "702:     const int linesize = s->linesize[0];",
          "703:     const int mask     = (1 << s->bits) - 1;",
          "707:     av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size,",
          "708:                    (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));",
          "709:     buffer = s->ljpeg_buffer;",
          "711:     for (i = 0; i < 3; i++)",
          "712:         buffer[0][i] = 1 << (s->bits - 1);",
          "714:     for (mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "720:         for (i = 0; i < 3; i++)",
          "721:             top[i] = left[i] = topleft[i] = buffer[0][i];",
          "723:         for (mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "",
          "---------------",
          "--- Hunk 22 ---",
          "[Context before]",
          "710:                 resync_mb_x = mb_x;",
          "711:                 resync_mb_y = mb_y;",
          "712:                 for(i=0; i<3; i++)",
          "714:             }",
          "715:             if (mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x)",
          "716:                 modified_predictor = 1;",
          "719:                 int pred, dc;",
          "724:                 PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);",
          "",
          "[Removed Lines]",
          "713:                     top[i]= left[i]= topleft[i]= 1 << (s->bits - 1);",
          "718:             for(i=0;i<nb_components;i++) {",
          "721:                 topleft[i]= top[i];",
          "722:                 top[i]= buffer[mb_x][i];",
          "",
          "[Added Lines]",
          "731:                     top[i] = left[i]= topleft[i]= 1 << (s->bits - 1);",
          "736:             for (i=0;i<nb_components;i++) {",
          "739:                 topleft[i] = top[i];",
          "740:                 top[i]     = buffer[mb_x][i];",
          "",
          "---------------",
          "--- Hunk 23 ---",
          "[Context before]",
          "727:                 if(dc == 0xFFFF)",
          "728:                     return -1;",
          "732:             }",
          "734:             if (s->restart_interval && !--s->restart_count) {",
          "",
          "[Removed Lines]",
          "730:                 left[i]=",
          "731:                 buffer[mb_x][i]= mask & (pred + (dc << point_transform));",
          "",
          "[Added Lines]",
          "748:                 left[i] = buffer[mb_x][i] =",
          "749:                     mask & (pred + (dc << point_transform));",
          "",
          "---------------",
          "--- Hunk 24 ---",
          "[Context before]",
          "737:             }",
          "738:         }",
          "745:             }",
          "751:             }",
          "754:                 int c= s->comp_index[i];",
          "755:                 for(mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "756:                     ptr[3*mb_x+2-c] = buffer[mb_x][i];",
          "",
          "[Removed Lines]",
          "740:         if(s->rct){",
          "741:             for(mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "742:                 ptr[3*mb_x+1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200)>>2);",
          "743:                 ptr[3*mb_x+0] = buffer[mb_x][1] + ptr[3*mb_x+1];",
          "744:                 ptr[3*mb_x+2] = buffer[mb_x][2] + ptr[3*mb_x+1];",
          "746:         }else if(s->pegasus_rct){",
          "747:             for(mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "748:                 ptr[3*mb_x+1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2])>>2);",
          "749:                 ptr[3*mb_x+0] = buffer[mb_x][1] + ptr[3*mb_x+1];",
          "750:                 ptr[3*mb_x+2] = buffer[mb_x][2] + ptr[3*mb_x+1];",
          "752:         }else{",
          "753:             for(i=0;i<nb_components;i++) {",
          "",
          "[Added Lines]",
          "758:         if (s->rct) {",
          "759:             for (mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "760:                 ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);",
          "761:                 ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];",
          "762:                 ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];",
          "764:         } else if (s->pegasus_rct) {",
          "765:             for (mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "766:                 ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2]) >> 2);",
          "767:                 ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];",
          "768:                 ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];",
          "770:         } else {",
          "771:             for(i=0; i<nb_components; i++) {",
          "",
          "---------------",
          "--- Hunk 25 ---",
          "[Context before]",
          "761:     return 0;",
          "762: }",
          "765:     int i, mb_x, mb_y;",
          "766:     const int nb_components=s->nb_components;",
          "767:     int bits= (s->bits+7)&~7;",
          "",
          "[Removed Lines]",
          "764: static int ljpeg_decode_yuv_scan(MJpegDecodeContext *s, int predictor, int point_transform){",
          "",
          "[Added Lines]",
          "782: static int ljpeg_decode_yuv_scan(MJpegDecodeContext *s, int predictor,",
          "783:                                  int point_transform)",
          "784: {",
          "",
          "---------------",
          "--- Hunk 26 ---",
          "[Context before]",
          "773:     av_assert0(nb_components==1 || nb_components==3);",
          "777:             if (s->restart_interval && !s->restart_count){",
          "778:                 s->restart_count = s->restart_interval;",
          "779:                 resync_mb_x = mb_x;",
          "",
          "[Removed Lines]",
          "775:     for(mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "776:         for(mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "",
          "[Added Lines]",
          "795:     for (mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "796:         for (mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "",
          "---------------",
          "--- Hunk 27 ---",
          "[Context before]",
          "783:             if(!mb_x || mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || s->interlaced){",
          "784:                 int toprow  = mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x;",
          "785:                 int leftcol = !mb_x || mb_y == resync_mb_y && mb_x == resync_mb_x;",
          "787:                     uint8_t *ptr;",
          "788:                     uint16_t *ptr16;",
          "789:                     int n, h, v, x, y, c, j, linesize;",
          "",
          "[Removed Lines]",
          "786:                 for(i=0;i<nb_components;i++) {",
          "",
          "[Added Lines]",
          "806:                 for (i = 0; i < nb_components; i++) {",
          "",
          "---------------",
          "--- Hunk 28 ---",
          "[Context before]",
          "850:                         }",
          "851:                     }",
          "852:                 }",
          "855:                     uint8_t *ptr;",
          "856:                     uint16_t *ptr16;",
          "857:                     int n, h, v, x, y, c, j, linesize, dc;",
          "866:                     if(bits>8) linesize /= 2;",
          "869:                         int pred;",
          "871:                         dc = mjpeg_decode_dc(s, s->dc_index[i]);",
          "872:                         if(dc == 0xFFFF)",
          "873:                             return -1;",
          "874:                         if(bits<=8){",
          "880:                         }else{",
          "881:                             ptr16 = s->picture.data[c] + 2*(linesize * (v * mb_y + y)) + 2*(h * mb_x + x); //FIXME optimize this crap",
          "882:                             PREDICT(pred, ptr16[-linesize-1], ptr16[-linesize], ptr16[-1], predictor);",
          "",
          "[Removed Lines]",
          "853:             }else{",
          "854:                 for(i=0;i<nb_components;i++) {",
          "858:                     n = s->nb_blocks[i];",
          "859:                     c = s->comp_index[i];",
          "860:                     h = s->h_scount[i];",
          "861:                     v = s->v_scount[i];",
          "862:                     x = 0;",
          "863:                     y = 0;",
          "864:                     linesize= s->linesize[c];",
          "868:                     for(j=0; j<n; j++) {",
          "875:                         ptr = s->picture.data[c] + (linesize * (v * mb_y + y)) + (h * mb_x + x); //FIXME optimize this crap",
          "876:                         PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);",
          "878:                         pred &= (-1)<<(8-s->bits);",
          "",
          "[Added Lines]",
          "873:             } else {",
          "874:                 for (i = 0; i < nb_components; i++) {",
          "878:                     n        = s->nb_blocks[i];",
          "879:                     c        = s->comp_index[i];",
          "880:                     h        = s->h_scount[i];",
          "881:                     v        = s->v_scount[i];",
          "882:                     x        = 0;",
          "883:                     y        = 0;",
          "884:                     linesize = s->linesize[c];",
          "888:                     for (j = 0; j < n; j++) {",
          "895:                             ptr = s->picture.data[c] +",
          "896:                               (linesize * (v * mb_y + y)) +",
          "897:                               (h * mb_x + x); //FIXME optimize this crap",
          "898:                             PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor);",
          "900:                             pred &= (-1)<<(8-s->bits);",
          "",
          "---------------",
          "--- Hunk 29 ---",
          "[Context before]",
          "915:     }",
          "916: }",
          "920:     int i, mb_x, mb_y;",
          "922:     const uint8_t *reference_data[MAX_COMPONENTS];",
          "923:     int linesize[MAX_COMPONENTS];",
          "924:     GetBitContext mb_bitmask_gb;",
          "932:         s->flipped = 0;",
          "933:     }",
          "936:         data[c] = s->picture_ptr->data[c];",
          "937:         reference_data[c] = reference ? reference->data[c] : NULL;",
          "939:         s->coefs_finished[c] |= 1;",
          "944:             reference_data[c] += offset;",
          "946:         }",
          "947:     }",
          "951:             const int copy_mb = mb_bitmask && !get_bits1(&mb_bitmask_gb);",
          "953:             if (s->restart_interval && !s->restart_count)",
          "954:                 s->restart_count = s->restart_interval;",
          "958:                 return -1;",
          "959:             }",
          "961:                 uint8_t *ptr;",
          "962:                 int n, h, v, x, y, c, j;",
          "963:                 int block_offset;",
          "",
          "[Removed Lines]",
          "918: static int mjpeg_decode_scan(MJpegDecodeContext *s, int nb_components, int Ah, int Al,",
          "919:                              const uint8_t *mb_bitmask, const AVFrame *reference){",
          "921:     uint8_t* data[MAX_COMPONENTS];",
          "926:     if (mb_bitmask) {",
          "927:         init_get_bits(&mb_bitmask_gb, mb_bitmask, s->mb_width*s->mb_height);",
          "928:     }",
          "930:     if(s->flipped && s->avctx->flags & CODEC_FLAG_EMU_EDGE) {",
          "931:         av_log(s->avctx, AV_LOG_ERROR, \"Can not flip image with CODEC_FLAG_EMU_EDGE set!\\n\");",
          "934:     for(i=0; i < nb_components; i++) {",
          "935:         int c = s->comp_index[i];",
          "938:         linesize[c]=s->linesize[c];",
          "940:         if(s->flipped) {",
          "942:             int offset = (linesize[c] * (s->v_scount[i] * (8 * s->mb_height -((s->height/s->v_max)&7)) - 1 ));",
          "943:             data[c] += offset;",
          "945:             linesize[c] *= -1;",
          "949:     for(mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "950:         for(mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "956:             if(get_bits_count(&s->gb)>s->gb.size_in_bits){",
          "957:                 av_log(s->avctx, AV_LOG_ERROR, \"overread %d\\n\", get_bits_count(&s->gb) - s->gb.size_in_bits);",
          "960:             for(i=0;i<nb_components;i++) {",
          "",
          "[Added Lines]",
          "941: static int mjpeg_decode_scan(MJpegDecodeContext *s, int nb_components, int Ah,",
          "942:                              int Al, const uint8_t *mb_bitmask,",
          "943:                              const AVFrame *reference)",
          "944: {",
          "946:     uint8_t *data[MAX_COMPONENTS];",
          "951:     if (mb_bitmask)",
          "952:         init_get_bits(&mb_bitmask_gb, mb_bitmask, s->mb_width * s->mb_height);",
          "954:     if (s->flipped && s->avctx->flags & CODEC_FLAG_EMU_EDGE) {",
          "955:         av_log(s->avctx, AV_LOG_ERROR,",
          "956:                \"Can not flip image with CODEC_FLAG_EMU_EDGE set!\\n\");",
          "960:     for (i = 0; i < nb_components; i++) {",
          "961:         int c   = s->comp_index[i];",
          "964:         linesize[c] = s->linesize[c];",
          "966:         if (s->flipped) {",
          "968:             int offset = (linesize[c] * (s->v_scount[i] *",
          "969:                          (8 * s->mb_height - ((s->height / s->v_max) & 7)) - 1));",
          "970:             data[c]           += offset;",
          "972:             linesize[c]       *= -1;",
          "976:     for (mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "977:         for (mb_x = 0; mb_x < s->mb_width; mb_x++) {",
          "983:             if (get_bits_count(&s->gb)>s->gb.size_in_bits) {",
          "984:                 av_log(s->avctx, AV_LOG_ERROR, \"overread %d\\n\",",
          "985:                        get_bits_count(&s->gb) - s->gb.size_in_bits);",
          "988:             for (i = 0; i < nb_components; i++) {",
          "",
          "---------------",
          "--- Hunk 30 ---",
          "[Context before]",
          "967:                 v = s->v_scount[i];",
          "968:                 x = 0;",
          "969:                 y = 0;",
          "971:                     block_offset = (((linesize[c] * (v * mb_y + y) * 8) +",
          "972:                                      (h * mb_x + x) * 8) >> s->avctx->lowres);",
          "975:                         block_offset += linesize[c] >> 1;",
          "976:                     ptr = data[c] + block_offset;",
          "989:                         }",
          "990:                     } else {",
          "992:                         DCTELEM *block = s->blocks[c][block_idx];",
          "997:                             return -1;",
          "998:                         }",
          "999:                     }",
          "1002:                     if (++x == h) {",
          "1003:                         x = 0;",
          "1004:                         y++;",
          "",
          "[Removed Lines]",
          "970:                 for(j=0;j<n;j++) {",
          "974:                     if(s->interlaced && s->bottom_field)",
          "977:                     if(!s->progressive) {",
          "978:                         if (copy_mb) {",
          "979:                             mjpeg_copy_block(ptr, reference_data[c] + block_offset, linesize[c], s->avctx->lowres);",
          "980:                         } else {",
          "981:                         s->dsp.clear_block(s->block);",
          "982:                         if(decode_block(s, s->block, i,",
          "983:                                      s->dc_index[i], s->ac_index[i],",
          "984:                                      s->quant_matrixes[ s->quant_index[c] ]) < 0) {",
          "985:                             av_log(s->avctx, AV_LOG_ERROR, \"error y=%d x=%d\\n\", mb_y, mb_x);",
          "986:                             return -1;",
          "987:                         }",
          "988:                         s->dsp.idct_put(ptr, linesize[c], s->block);",
          "991:                         int block_idx = s->block_stride[c] * (v * mb_y + y) + (h * mb_x + x);",
          "993:                         if(Ah)",
          "994:                             block[0] += get_bits1(&s->gb) * s->quant_matrixes[ s->quant_index[c] ][0] << Al;",
          "995:                         else if(decode_dc_progressive(s, block, i, s->dc_index[i], s->quant_matrixes[ s->quant_index[c] ], Al) < 0) {",
          "996:                             av_log(s->avctx, AV_LOG_ERROR, \"error y=%d x=%d\\n\", mb_y, mb_x);",
          "",
          "[Added Lines]",
          "998:                 for (j = 0; j < n; j++) {",
          "1002:                     if (s->interlaced && s->bottom_field)",
          "1005:                     if (!s->progressive) {",
          "1006:                         if (copy_mb)",
          "1007:                             mjpeg_copy_block(ptr, reference_data[c] + block_offset,",
          "1008:                                              linesize[c], s->avctx->lowres);",
          "1009:                         else {",
          "1010:                             s->dsp.clear_block(s->block);",
          "1011:                             if (decode_block(s, s->block, i,",
          "1012:                                              s->dc_index[i], s->ac_index[i],",
          "1013:                                              s->quant_matrixes[s->quant_index[c]]) < 0) {",
          "1014:                                 av_log(s->avctx, AV_LOG_ERROR,",
          "1015:                                        \"error y=%d x=%d\\n\", mb_y, mb_x);",
          "1016:                                 return -1;",
          "1017:                             }",
          "1018:                             s->dsp.idct_put(ptr, linesize[c], s->block);",
          "1021:                         int block_idx  = s->block_stride[c] * (v * mb_y + y) +",
          "1022:                                          (h * mb_x + x);",
          "1024:                         if (Ah)",
          "1025:                             block[0] += get_bits1(&s->gb) *",
          "1026:                                         s->quant_matrixes[s->quant_index[c]][0] << Al;",
          "1027:                         else if (decode_dc_progressive(s, block, i, s->dc_index[i],",
          "1028:                                                        s->quant_matrixes[s->quant_index[c]],",
          "1029:                                                        Al) < 0) {",
          "1030:                             av_log(s->avctx, AV_LOG_ERROR,",
          "1031:                                    \"error y=%d x=%d\\n\", mb_y, mb_x);",
          "",
          "---------------",
          "--- Hunk 31 ---",
          "[Context before]",
          "1018:                     if (get_bits_left(&s->gb) >= 8 && (get_bits(&s->gb, 8) & 0xF8) == 0xD0) {",
          "1020:                             s->last_dc[i] = 1024;",
          "1022:                         skip_bits_long(&s->gb, pos - get_bits_count(&s->gb));",
          "1024:                 }",
          "1025:             }",
          "1026:         }",
          "",
          "[Removed Lines]",
          "1021:                     } else {",
          "1023:                     }",
          "",
          "[Added Lines]",
          "1059:                     } else",
          "",
          "---------------",
          "--- Hunk 32 ---",
          "[Context before]",
          "1028:     return 0;",
          "1029: }",
          "1032:     int mb_x, mb_y;",
          "1033:     int EOBRUN = 0;",
          "1034:     int c = s->comp_index[0];",
          "1037:     int last_scan = 0;",
          "1042:         last_scan = !~s->coefs_finished[c];",
          "1043:     }",
          "1046:         data += linesize >> 1;",
          "1051:         DCTELEM (*block)[64] = &s->blocks[c][block_idx];",
          "1068:             }",
          "1069:         }",
          "1070:     }",
          "1071:     return 0;",
          "1072: }",
          "1076: {",
          "1077:     int len, nb_components, i, h, v, predictor, point_transform;",
          "1078:     int index, id;",
          "1080:     int ilv, prev_shift;",
          "1083:     len = get_bits(&s->gb, 16);",
          "1084:     nb_components = get_bits(&s->gb, 8);",
          "1087:         return -1;",
          "1088:     }",
          "1091:         av_log(s->avctx, AV_LOG_ERROR, \"decode_sos: invalid len (%d)\\n\", len);",
          "1092:         return -1;",
          "1093:     }",
          "1095:         id = get_bits(&s->gb, 8) - 1;",
          "1096:         av_log(s->avctx, AV_LOG_DEBUG, \"component: %d\\n\", id);",
          "1099:             if (id == s->component_id[index])",
          "1100:                 break;",
          "1104:             return -1;",
          "1105:         }",
          "",
          "[Removed Lines]",
          "1031: static int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss, int se, int Ah, int Al){",
          "1035:     uint8_t* data = s->picture.data[c];",
          "1036:     int linesize = s->linesize[c];",
          "1038:     int16_t *quant_matrix = s->quant_matrixes[ s->quant_index[c] ];",
          "1040:     if(!Al) {",
          "1041:         s->coefs_finished[c] |= (1LL<<(se+1))-(1LL<<ss);",
          "1045:     if(s->interlaced && s->bottom_field)",
          "1048:     for(mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "1049:         uint8_t *ptr = data + (mb_y*linesize*8 >> s->avctx->lowres);",
          "1050:         int block_idx = mb_y * s->block_stride[c];",
          "1052:         uint8_t *last_nnz = &s->last_nnz[c][block_idx];",
          "1053:         for(mb_x = 0; mb_x < s->mb_width; mb_x++, block++, last_nnz++) {",
          "1054:             int ret;",
          "1055:             if(Ah)",
          "1056:                 ret = decode_block_refinement(s, *block, last_nnz, s->ac_index[0],",
          "1057:                                               quant_matrix, ss, se, Al, &EOBRUN);",
          "1058:             else",
          "1059:                 ret = decode_block_progressive(s, *block, last_nnz, s->ac_index[0],",
          "1060:                                                quant_matrix, ss, se, Al, &EOBRUN);",
          "1061:             if(ret < 0) {",
          "1062:                 av_log(s->avctx, AV_LOG_ERROR, \"error y=%d x=%d\\n\", mb_y, mb_x);",
          "1063:                 return -1;",
          "1064:             }",
          "1065:             if(last_scan) {",
          "1066:                 s->dsp.idct_put(ptr, linesize, *block);",
          "1067:                 ptr += 8 >> s->avctx->lowres;",
          "1074: int ff_mjpeg_decode_sos(MJpegDecodeContext *s,",
          "1075:                         const uint8_t *mb_bitmask, const AVFrame *reference)",
          "1079:     const int block_size= s->lossless ? 1 : 8;",
          "1085:     if (nb_components == 0 || nb_components > MAX_COMPONENTS){",
          "1086:         av_log(s->avctx, AV_LOG_ERROR, \"decode_sos: nb_components (%d) unsupported\\n\", nb_components);",
          "1089:     if (len != 6+2*nb_components)",
          "1090:     {",
          "1094:     for(i=0;i<nb_components;i++) {",
          "1098:         for(index=0;index<s->nb_components;index++)",
          "1101:         if (index == s->nb_components)",
          "1102:         {",
          "1103:             av_log(s->avctx, AV_LOG_ERROR, \"decode_sos: index(%d) out of components\\n\", index);",
          "",
          "[Added Lines]",
          "1068: static int mjpeg_decode_scan_progressive_ac(MJpegDecodeContext *s, int ss,",
          "1069:                                             int se, int Ah, int Al)",
          "1070: {",
          "1074:     uint8_t *data = s->picture.data[c];",
          "1075:     int linesize  = s->linesize[c];",
          "1077:     int16_t *quant_matrix = s->quant_matrixes[s->quant_index[c]];",
          "1079:     if (!Al) {",
          "1080:         s->coefs_finished[c] |= (1LL << (se + 1)) - (1LL << ss);",
          "1084:     if (s->interlaced && s->bottom_field)",
          "1087:     for (mb_y = 0; mb_y < s->mb_height; mb_y++) {",
          "1088:         uint8_t *ptr     = data + (mb_y * linesize * 8 >> s->avctx->lowres);",
          "1089:         int block_idx    = mb_y * s->block_stride[c];",
          "1091:         uint8_t *last_nnz    = &s->last_nnz[c][block_idx];",
          "1092:         for (mb_x = 0; mb_x < s->mb_width; mb_x++, block++, last_nnz++) {",
          "1093:                 int ret;",
          "1094:                 if (Ah)",
          "1095:                     ret = decode_block_refinement(s, *block, last_nnz, s->ac_index[0],",
          "1096:                                                   quant_matrix, ss, se, Al, &EOBRUN);",
          "1097:                 else",
          "1098:                     ret = decode_block_progressive(s, *block, last_nnz, s->ac_index[0],",
          "1099:                                                    quant_matrix, ss, se, Al, &EOBRUN);",
          "1100:                 if (ret < 0) {",
          "1101:                     av_log(s->avctx, AV_LOG_ERROR,",
          "1102:                            \"error y=%d x=%d\\n\", mb_y, mb_x);",
          "1103:                     return -1;",
          "1104:                 }",
          "1106:             if (last_scan) {",
          "1107:                     s->dsp.idct_put(ptr, linesize, *block);",
          "1108:                     ptr += 8 >> s->avctx->lowres;",
          "1115: int ff_mjpeg_decode_sos(MJpegDecodeContext *s, const uint8_t *mb_bitmask,",
          "1116:                         const AVFrame *reference)",
          "1120:     const int block_size = s->lossless ? 1 : 8;",
          "1126:     if (nb_components == 0 || nb_components > MAX_COMPONENTS) {",
          "1127:         av_log(s->avctx, AV_LOG_ERROR,",
          "1128:                \"decode_sos: nb_components (%d) unsupported\\n\", nb_components);",
          "1131:     if (len != 6 + 2 * nb_components) {",
          "1135:     for (i = 0; i < nb_components; i++) {",
          "1139:         for (index = 0; index < s->nb_components; index++)",
          "1142:         if (index == s->nb_components) {",
          "1143:             av_log(s->avctx, AV_LOG_ERROR,",
          "1144:                    \"decode_sos: index(%d) out of components\\n\", index);",
          "",
          "---------------",
          "--- Hunk 33 ---",
          "[Context before]",
          "1114:         s->comp_index[i] = index;",
          "1116:         s->nb_blocks[i] = s->h_count[index] * s->v_count[index];",
          "1120:         s->dc_index[i] = get_bits(&s->gb, 4);",
          "1121:         s->ac_index[i] = get_bits(&s->gb, 4);",
          "",
          "[Removed Lines]",
          "1117:         s->h_scount[i] = s->h_count[index];",
          "1118:         s->v_scount[i] = s->v_count[index];",
          "",
          "[Added Lines]",
          "1158:         s->h_scount[i]  = s->h_count[index];",
          "1159:         s->v_scount[i]  = s->v_count[index];",
          "",
          "---------------",
          "--- Hunk 34 ---",
          "[Context before]",
          "1127:             goto out_of_range;",
          "1128:     }",
          "1132:     if(s->avctx->codec_tag != AV_RL32(\"CJPG\")){",
          "1135:     }else",
          "1139:         s->last_dc[i] = 1024;",
          "1141:     if (nb_components > 1) {",
          "1143:         s->mb_width  = (s->width  + s->h_max * block_size - 1) / (s->h_max * block_size);",
          "1144:         s->mb_height = (s->height + s->v_max * block_size - 1) / (s->v_max * block_size);",
          "1146:         h = s->h_max / s->h_scount[0];",
          "1147:         v = s->v_max / s->v_scount[0];",
          "1150:         s->nb_blocks[0] = 1;",
          "1153:     }",
          "1157:                predictor, point_transform, ilv, s->bits, s->mjpb_skiptosod,",
          "1158:                s->pegasus_rct ? \"PRCT\" : (s->rct ? \"RCT\" : \"\"), nb_components);",
          "",
          "[Removed Lines]",
          "1136:         prev_shift= point_transform= 0;",
          "1138:     for(i=0;i<nb_components;i++)",
          "1148:         s->mb_width  = (s->width  + h * block_size - 1) / (h * block_size);",
          "1149:         s->mb_height = (s->height + v * block_size - 1) / (v * block_size);",
          "1151:         s->h_scount[0] = 1;",
          "1152:         s->v_scount[0] = 1;",
          "1155:     if(s->avctx->debug & FF_DEBUG_PICT_INFO)",
          "1156:         av_log(s->avctx, AV_LOG_DEBUG, \"%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\\n\", s->lossless ? \"lossless\" : \"sequential DCT\", s->rgb ? \"RGB\" : \"\",",
          "",
          "[Added Lines]",
          "1177:         prev_shift = point_transform = 0;",
          "1179:     for (i = 0; i < nb_components; i++)",
          "1189:         s->mb_width     = (s->width  + h * block_size - 1) / (h * block_size);",
          "1190:         s->mb_height    = (s->height + v * block_size - 1) / (v * block_size);",
          "1192:         s->h_scount[0]  = 1;",
          "1193:         s->v_scount[0]  = 1;",
          "1196:     if (s->avctx->debug & FF_DEBUG_PICT_INFO)",
          "1197:         av_log(s->avctx, AV_LOG_DEBUG, \"%s %s p:%d >>:%d ilv:%d bits:%d skip:%d %s comp:%d\\n\",",
          "1198:                s->lossless ? \"lossless\" : \"sequential DCT\", s->rgb ? \"RGB\" : \"\",",
          "",
          "---------------",
          "--- Hunk 35 ---",
          "[Context before]",
          "1162:     for (i = s->mjpb_skiptosod; i > 0; i--)",
          "1163:         skip_bits(&s->gb, 8);",
          "1166:         av_assert0(s->picture_ptr == &s->picture);",
          "1172:                 return -1;",
          "1176:                     return -1;",
          "1179:                     return -1;",
          "1180:             }",
          "1181:         }",
          "1184:             av_assert0(s->picture_ptr == &s->picture);",
          "1186:                 return -1;",
          "1187:         } else {",
          "1190:                 return -1;",
          "1191:         }",
          "1192:     }",
          "",
          "[Removed Lines]",
          "1165:     if(s->lossless){",
          "1167:         if(CONFIG_JPEGLS_DECODER && s->ls){",
          "1171:             if(ff_jpegls_decode_picture(s, predictor, point_transform, ilv) < 0)",
          "1173:         }else{",
          "1174:             if(s->rgb){",
          "1175:                 if(ljpeg_decode_rgb_scan(s, nb_components, predictor, point_transform) < 0)",
          "1177:             }else{",
          "1178:                 if(ljpeg_decode_yuv_scan(s, predictor, point_transform) < 0)",
          "1182:     }else{",
          "1183:         if(s->progressive && predictor) {",
          "1185:             if(mjpeg_decode_scan_progressive_ac(s, predictor, ilv, prev_shift, point_transform) < 0)",
          "1188:             if(mjpeg_decode_scan(s, nb_components, prev_shift, point_transform,",
          "1189:                                  mb_bitmask, reference) < 0)",
          "",
          "[Added Lines]",
          "1207:     if (s->lossless) {",
          "1209:         if (CONFIG_JPEGLS_DECODER && s->ls) {",
          "1213:             if (ff_jpegls_decode_picture(s, predictor, point_transform, ilv) < 0)",
          "1215:         } else {",
          "1216:             if (s->rgb) {",
          "1217:                 if (ljpeg_decode_rgb_scan(s, nb_components, predictor, point_transform) < 0)",
          "1219:             } else {",
          "1220:                 if (ljpeg_decode_yuv_scan(s, predictor, point_transform) < 0)",
          "1224:     } else {",
          "1225:         if (s->progressive && predictor) {",
          "1227:             if (mjpeg_decode_scan_progressive_ac(s, predictor, ilv, prev_shift,",
          "1228:                                                  point_transform) < 0)",
          "1231:             if (mjpeg_decode_scan(s, nb_components, prev_shift, point_transform,",
          "1232:                                   mb_bitmask, reference) < 0)",
          "",
          "---------------",
          "--- Hunk 36 ---",
          "[Context before]",
          "1224:     if (get_bits(&s->gb, 16) != 4)",
          "1225:         return -1;",
          "1226:     s->restart_interval = get_bits(&s->gb, 16);",
          "1230:     return 0;",
          "1231: }",
          "",
          "[Removed Lines]",
          "1227:     s->restart_count = 0;",
          "1228:     av_log(s->avctx, AV_LOG_DEBUG, \"restart interval: %d\\n\", s->restart_interval);",
          "",
          "[Added Lines]",
          "1270:     s->restart_count    = 0;",
          "1271:     av_log(s->avctx, AV_LOG_DEBUG, \"restart interval: %d\\n\",",
          "1272:            s->restart_interval);",
          "",
          "---------------",
          "--- Hunk 37 ---",
          "[Context before]",
          "1237:     len = get_bits(&s->gb, 16);",
          "1238:     if (len < 5)",
          "1239:         return -1;",
          "1241:         return -1;",
          "1245:     len -= 6;",
          "1248:         av_log(s->avctx, AV_LOG_DEBUG, \"APPx %8X\\n\", id);",
          "1257:             4bytes      AVI1",
          "1258:             1bytes      polarity",
          "",
          "[Removed Lines]",
          "1240:     if(8*len + get_bits_count(&s->gb) > s->gb.size_in_bits)",
          "1243:     id = get_bits_long(&s->gb, 32);",
          "1244:     id = av_be2ne32(id);",
          "1247:     if(s->avctx->debug & FF_DEBUG_STARTCODE){",
          "1249:     }",
          "1254:     if (id == AV_RL32(\"AVI1\"))",
          "1255:     {",
          "",
          "[Added Lines]",
          "1284:     if (8 * len + get_bits_count(&s->gb) > s->gb.size_in_bits)",
          "1287:     id   = get_bits_long(&s->gb, 32);",
          "1288:     id   = av_be2ne32(id);",
          "1291:     if (s->avctx->debug & FF_DEBUG_STARTCODE)",
          "1297:     if (id == AV_RL32(\"AVI1\")) {",
          "",
          "---------------",
          "--- Hunk 38 ---",
          "[Context before]",
          "1283:         int t_w, t_h, v1, v2;",
          "1287:         skip_bits(&s->gb, 8);",
          "1292:         if (s->avctx->debug & FF_DEBUG_PICT_INFO)",
          "1299:         t_w = get_bits(&s->gb, 8);",
          "1300:         t_h = get_bits(&s->gb, 8);",
          "1306:         }",
          "1307:         len -= 10;",
          "1308:         goto out;",
          "1309:     }",
          "1313:         if (s->avctx->debug & FF_DEBUG_PICT_INFO)",
          "1314:             av_log(s->avctx, AV_LOG_INFO, \"mjpeg: Adobe header found\\n\");",
          "1319:         len -= 7;",
          "1320:         goto out;",
          "1321:     }",
          "1324:         if (s->avctx->debug & FF_DEBUG_PICT_INFO)",
          "1331:         case 1:",
          "1334:             break;",
          "1335:         case 2:",
          "1338:             break;",
          "1339:         default:",
          "1340:             av_log(s->avctx, AV_LOG_ERROR, \"unknown colorspace\\n\");",
          "",
          "[Removed Lines]",
          "1281:     if (id == AV_RL32(\"JFIF\"))",
          "1282:     {",
          "1285:         v1= get_bits(&s->gb, 8);",
          "1286:         v2= get_bits(&s->gb, 8);",
          "1289:         s->avctx->sample_aspect_ratio.num= get_bits(&s->gb, 16);",
          "1290:         s->avctx->sample_aspect_ratio.den= get_bits(&s->gb, 16);",
          "1293:             av_log(s->avctx, AV_LOG_INFO, \"mjpeg: JFIF header found (version: %x.%x) SAR=%d/%d\\n\",",
          "1294:                 v1, v2,",
          "1295:                 s->avctx->sample_aspect_ratio.num,",
          "1296:                 s->avctx->sample_aspect_ratio.den",
          "1297:             );",
          "1301:         if (t_w && t_h)",
          "1302:         {",
          "1304:             if (len-10-(t_w*t_h*3) > 0)",
          "1305:                 len -= t_w*t_h*3;",
          "1311:     if (id == AV_RL32(\"Adob\") && (get_bits(&s->gb, 8) == 'e'))",
          "1312:     {",
          "1323:     if (id == AV_RL32(\"LJIF\")){",
          "1325:             av_log(s->avctx, AV_LOG_INFO, \"Pegasus lossless jpeg header found\\n\");",
          "1330:         switch( get_bits(&s->gb, 8)){",
          "1332:             s->rgb= 1;",
          "1333:             s->pegasus_rct=0;",
          "1336:             s->rgb= 1;",
          "1337:             s->pegasus_rct=1;",
          "",
          "[Added Lines]",
          "1323:     if (id == AV_RL32(\"JFIF\")) {",
          "1326:         v1 = get_bits(&s->gb, 8);",
          "1327:         v2 = get_bits(&s->gb, 8);",
          "1330:         s->avctx->sample_aspect_ratio.num = get_bits(&s->gb, 16);",
          "1331:         s->avctx->sample_aspect_ratio.den = get_bits(&s->gb, 16);",
          "1334:             av_log(s->avctx, AV_LOG_INFO,",
          "1335:                    \"mjpeg: JFIF header found (version: %x.%x) SAR=%d/%d\\n\",",
          "1336:                    v1, v2,",
          "1337:                    s->avctx->sample_aspect_ratio.num,",
          "1338:                    s->avctx->sample_aspect_ratio.den);",
          "1342:         if (t_w && t_h) {",
          "1344:             if (len -10 - (t_w * t_h * 3) > 0)",
          "1345:                 len -= t_w * t_h * 3;",
          "1351:     if (id == AV_RL32(\"Adob\") && (get_bits(&s->gb, 8) == 'e')) {",
          "1362:     if (id == AV_RL32(\"LJIF\")) {",
          "1364:             av_log(s->avctx, AV_LOG_INFO,",
          "1365:                    \"Pegasus lossless jpeg header found\\n\");",
          "1370:         switch (get_bits(&s->gb, 8)) {",
          "1372:             s->rgb         = 1;",
          "1373:             s->pegasus_rct = 0;",
          "1376:             s->rgb         = 1;",
          "1377:             s->pegasus_rct = 1;",
          "",
          "---------------",
          "--- Hunk 39 ---",
          "[Context before]",
          "1344:     }",
          "1351:         len -= 4;",
          "1354: #if 0",
          "",
          "[Removed Lines]",
          "1347:     if ((s->start_code == APP1) && (len > (0x28 - 8)))",
          "1348:     {",
          "1349:         id = get_bits_long(&s->gb, 32);",
          "1350:         id = av_be2ne32(id);",
          "1353:         {",
          "",
          "[Added Lines]",
          "1387:     if ((s->start_code == APP1) && (len > (0x28 - 8))) {",
          "1388:         id   = get_bits_long(&s->gb, 32);",
          "1389:         id   = av_be2ne32(id);",
          "1392:         if (id == AV_RL32(\"mjpg\")) {",
          "",
          "---------------",
          "--- Hunk 40 ---",
          "[Context before]",
          "1369: out:",
          "1371:     if (len < 0)",
          "1374:         skip_bits(&s->gb, 8);",
          "1376:     return 0;",
          "",
          "[Removed Lines]",
          "1372:         av_log(s->avctx, AV_LOG_ERROR, \"mjpeg: error, decode_app parser read over the end\\n\");",
          "1373:     while(--len > 0)",
          "",
          "[Added Lines]",
          "1411:         av_log(s->avctx, AV_LOG_ERROR,",
          "1412:                \"mjpeg: error, decode_app parser read over the end\\n\");",
          "1413:     while (--len > 0)",
          "",
          "---------------",
          "--- Hunk 41 ---",
          "[Context before]",
          "1379: static int mjpeg_decode_com(MJpegDecodeContext *s)",
          "1380: {",
          "1381:     int len = get_bits(&s->gb, 16);",
          "1383:         char *cbuf = av_malloc(len - 1);",
          "1384:         if (cbuf) {",
          "1385:             int i;",
          "1386:             for (i = 0; i < len - 2; i++)",
          "1387:                 cbuf[i] = get_bits(&s->gb, 8);",
          "1390:             else",
          "1391:                 cbuf[i] = 0;",
          "1394:                 av_log(s->avctx, AV_LOG_INFO, \"mjpeg comment: '%s'\\n\", cbuf);",
          "1399:                 s->buggy_avid = 1;",
          "1408:                 s->flipped = 1;",
          "1411:             av_free(cbuf);",
          "1412:         }",
          "",
          "[Removed Lines]",
          "1382:     if (len >= 2 && 8*len - 16 + get_bits_count(&s->gb) <= s->gb.size_in_bits) {",
          "1388:             if (i > 0 && cbuf[i-1] == '\\n')",
          "1389:                 cbuf[i-1] = 0;",
          "1393:             if(s->avctx->debug & FF_DEBUG_PICT_INFO)",
          "1397:             if (!strcmp(cbuf, \"AVID\"))",
          "1398:             {",
          "1402:             }",
          "1403:             else if(!strcmp(cbuf, \"CS=ITU601\")){",
          "1404:                 s->cs_itu601= 1;",
          "1405:             }",
          "1406:             else if((len > 20 && !strncmp(cbuf, \"Intel(R) JPEG Library\", 21)) ||",
          "1407:                     (len > 19 && !strncmp(cbuf, \"Metasoft MJPEG Codec\", 20))){",
          "1409:             }",
          "",
          "[Added Lines]",
          "1422:     if (len >= 2 &&",
          "1423:         8 * len - 16 + get_bits_count(&s->gb) <= s->gb.size_in_bits) {",
          "1429:             if (i > 0 && cbuf[i - 1] == '\\n')",
          "1430:                 cbuf[i - 1] = 0;",
          "1434:             if (s->avctx->debug & FF_DEBUG_PICT_INFO)",
          "1438:             if (!strcmp(cbuf, \"AVID\")) {",
          "1442:             } else if (!strcmp(cbuf, \"CS=ITU601\"))",
          "1443:                 s->cs_itu601 = 1;",
          "1444:             else if ((len > 20 && !strncmp(cbuf, \"Intel(R) JPEG Library\", 21)) ||",
          "1445:                      (len > 19 && !strncmp(cbuf, \"Metasoft MJPEG Codec\", 20)))",
          "",
          "---------------",
          "--- Hunk 42 ---",
          "[Context before]",
          "1422:     const uint8_t *buf_ptr;",
          "1423:     unsigned int v, v2;",
          "1424:     int val;",
          "1427:     buf_ptr = *pbuf_ptr;",
          "1428:     while (buf_ptr < buf_end) {",
          "1430:         v2 = *buf_ptr;",
          "1431:         if ((v == 0xff) && (v2 >= 0xc0) && (v2 <= 0xfe) && buf_ptr < buf_end) {",
          "1432:             val = *buf_ptr++;",
          "",
          "[Removed Lines]",
          "1425:     int skipped=0;",
          "1429:         v = *buf_ptr++;",
          "",
          "[Added Lines]",
          "1462:     int skipped = 0;",
          "1466:         v  = *buf_ptr++;",
          "",
          "---------------",
          "--- Hunk 43 ---",
          "[Context before]",
          "1444: int ff_mjpeg_find_marker(MJpegDecodeContext *s,",
          "1445:                          const uint8_t **buf_ptr, const uint8_t *buf_end,",
          "1447: {",
          "1448:     int start_code;",
          "1449:     start_code = find_marker(buf_ptr, buf_end);",
          "1529:                 }",
          "1534:                 }",
          "1536:     return start_code;",
          "1537: }",
          "1542: {",
          "1543:     const uint8_t *buf = avpkt->data;",
          "1545:     MJpegDecodeContext *s = avctx->priv_data;",
          "1546:     const uint8_t *buf_end, *buf_ptr;",
          "1547:     const uint8_t *unescaped_buf_ptr;",
          "",
          "[Removed Lines]",
          "1446:                          const uint8_t **unescaped_buf_ptr, int *unescaped_buf_size)",
          "1451:                 if ((buf_end - *buf_ptr) > s->buffer_size)",
          "1452:                 {",
          "1453:                     av_free(s->buffer);",
          "1454:                     s->buffer_size = buf_end - *buf_ptr;",
          "1455:                     s->buffer = av_malloc(s->buffer_size + FF_INPUT_BUFFER_PADDING_SIZE);",
          "1456:                     av_log(s->avctx, AV_LOG_DEBUG, \"buffer too small, expanding to %d bytes\\n\",",
          "1457:                         s->buffer_size);",
          "1458:                 }",
          "1461:                 if (start_code == SOS && !s->ls)",
          "1462:                 {",
          "1463:                     const uint8_t *src = *buf_ptr;",
          "1464:                     uint8_t *dst = s->buffer;",
          "1466:                     while (src<buf_end)",
          "1467:                     {",
          "1468:                         uint8_t x = *(src++);",
          "1471:                         if (s->avctx->codec_id != CODEC_ID_THP)",
          "1472:                         {",
          "1473:                             if (x == 0xff) {",
          "1474:                                 while (src < buf_end && x == 0xff)",
          "1475:                                     x = *(src++);",
          "1477:                                 if (x >= 0xd0 && x <= 0xd7)",
          "1479:                                 else if (x)",
          "1480:                                     break;",
          "1481:                             }",
          "1482:                         }",
          "1483:                     }",
          "1487:                     av_log(s->avctx, AV_LOG_DEBUG, \"escaping removed %td bytes\\n\",",
          "1488:                            (buf_end - *buf_ptr) - (dst - s->buffer));",
          "1489:                 }",
          "1490:                 else if(start_code == SOS && s->ls){",
          "1491:                     const uint8_t *src = *buf_ptr;",
          "1492:                     uint8_t *dst = s->buffer;",
          "1493:                     int bit_count = 0;",
          "1494:                     int t = 0, b = 0;",
          "1495:                     PutBitContext pb;",
          "1497:                     s->cur_scan++;",
          "1500:                     while (src + t < buf_end){",
          "1501:                         uint8_t x = src[t++];",
          "1502:                         if (x == 0xff){",
          "1503:                             while((src + t < buf_end) && x == 0xff)",
          "1504:                                 x = src[t++];",
          "1505:                             if (x & 0x80) {",
          "1506:                                 t -= 2;",
          "1507:                                 break;",
          "1508:                             }",
          "1509:                         }",
          "1510:                     }",
          "1511:                     bit_count = t * 8;",
          "1513:                     init_put_bits(&pb, dst, t);",
          "1516:                     while(b < t){",
          "1517:                         uint8_t x = src[b++];",
          "1518:                         put_bits(&pb, 8, x);",
          "1519:                         if(x == 0xFF){",
          "1520:                             x = src[b++];",
          "1521:                             put_bits(&pb, 7, x);",
          "1522:                             bit_count--;",
          "1523:                         }",
          "1524:                     }",
          "1525:                     flush_put_bits(&pb);",
          "1530:                 else",
          "1531:                 {",
          "1539: int ff_mjpeg_decode_frame(AVCodecContext *avctx,",
          "1540:                               void *data, int *data_size,",
          "1541:                               AVPacket *avpkt)",
          "1544:     int buf_size = avpkt->size;",
          "",
          "[Added Lines]",
          "1483:                          const uint8_t **unescaped_buf_ptr,",
          "1484:                          int *unescaped_buf_size)",
          "1489:     if ((buf_end - *buf_ptr) > s->buffer_size) {",
          "1490:         av_free(s->buffer);",
          "1491:         s->buffer_size = buf_end - *buf_ptr;",
          "1492:         s->buffer      = av_malloc(s->buffer_size + FF_INPUT_BUFFER_PADDING_SIZE);",
          "1493:         av_log(s->avctx, AV_LOG_DEBUG,",
          "1494:                \"buffer too small, expanding to %d bytes\\n\", s->buffer_size);",
          "1495:     }",
          "1498:     if (start_code == SOS && !s->ls) {",
          "1499:         const uint8_t *src = *buf_ptr;",
          "1500:         uint8_t *dst = s->buffer;",
          "1502:         while (src < buf_end) {",
          "1503:             uint8_t x = *(src++);",
          "1506:             if (s->avctx->codec_id != CODEC_ID_THP) {",
          "1507:                 if (x == 0xff) {",
          "1508:                     while (src < buf_end && x == 0xff)",
          "1509:                         x = *(src++);",
          "1511:                     if (x >= 0xd0 && x <= 0xd7)",
          "1513:                     else if (x)",
          "1514:                         break;",
          "1516:             }",
          "1517:         }",
          "1521:         av_log(s->avctx, AV_LOG_DEBUG, \"escaping removed %td bytes\\n\",",
          "1522:                (buf_end - *buf_ptr) - (dst - s->buffer));",
          "1523:     } else if (start_code == SOS && s->ls) {",
          "1524:         const uint8_t *src = *buf_ptr;",
          "1525:         uint8_t *dst  = s->buffer;",
          "1526:         int bit_count = 0;",
          "1527:         int t = 0, b = 0;",
          "1528:         PutBitContext pb;",
          "1530:         s->cur_scan++;",
          "1533:         while (src + t < buf_end) {",
          "1534:             uint8_t x = src[t++];",
          "1535:             if (x == 0xff) {",
          "1536:                 while ((src + t < buf_end) && x == 0xff)",
          "1537:                     x = src[t++];",
          "1538:                 if (x & 0x80) {",
          "1539:                     t -= 2;",
          "1540:                     break;",
          "1542:             }",
          "1543:         }",
          "1544:         bit_count = t * 8;",
          "1545:         init_put_bits(&pb, dst, t);",
          "1548:         while (b < t) {",
          "1549:             uint8_t x = src[b++];",
          "1550:             put_bits(&pb, 8, x);",
          "1551:             if (x == 0xFF) {",
          "1552:                 x = src[b++];",
          "1553:                 put_bits(&pb, 7, x);",
          "1554:                 bit_count--;",
          "1555:             }",
          "1556:         }",
          "1557:         flush_put_bits(&pb);",
          "1561:     } else {",
          "1564:     }",
          "1569: int ff_mjpeg_decode_frame(AVCodecContext *avctx, void *data, int *data_size,",
          "1570:                           AVPacket *avpkt)",
          "1573:     int buf_size       = avpkt->size;",
          "",
          "---------------",
          "--- Hunk 44 ---",
          "[Context before]",
          "1555:     while (buf_ptr < buf_end) {",
          "1557:         start_code = ff_mjpeg_find_marker(s, &buf_ptr, buf_end,",
          "1582:                 }",
          "1634: eoi_parser:",
          "1638:                         break;",
          "1657:                     }",
          "1683:                     break;",
          "1693:             }",
          "1694:         }",
          "1695:     }",
          "1696:     if (s->got_picture) {",
          "",
          "[Removed Lines]",
          "1558:                                           &unescaped_buf_ptr, &unescaped_buf_size);",
          "1559:         {",
          "1561:             if (start_code < 0) {",
          "1562:                 goto the_end;",
          "1563:             } else {",
          "1564:                 av_log(avctx, AV_LOG_DEBUG, \"marker=%x avail_size_in_buf=%td\\n\", start_code, buf_end - buf_ptr);",
          "1566:                 init_get_bits(&s->gb, unescaped_buf_ptr, unescaped_buf_size*8);",
          "1568:                 s->start_code = start_code;",
          "1569:                 if(s->avctx->debug & FF_DEBUG_STARTCODE){",
          "1570:                     av_log(avctx, AV_LOG_DEBUG, \"startcode: %X\\n\", start_code);",
          "1571:                 }",
          "1574:                 if (start_code >= 0xd0 && start_code <= 0xd7) {",
          "1575:                     av_log(avctx, AV_LOG_DEBUG, \"restart marker: %d\\n\", start_code&0x0f);",
          "1577:                 } else if (start_code >= APP0 && start_code <= APP15) {",
          "1578:                     mjpeg_decode_app(s);",
          "1580:                 } else if (start_code == COM){",
          "1581:                     mjpeg_decode_com(s);",
          "1584:                 switch(start_code) {",
          "1585:                 case SOI:",
          "1586:                     s->restart_interval = 0;",
          "1588:                     s->restart_count = 0;",
          "1590:                     break;",
          "1591:                 case DQT:",
          "1592:                     ff_mjpeg_decode_dqt(s);",
          "1593:                     break;",
          "1594:                 case DHT:",
          "1595:                     if(ff_mjpeg_decode_dht(s) < 0){",
          "1596:                         av_log(avctx, AV_LOG_ERROR, \"huffman table decode error\\n\");",
          "1597:                         return -1;",
          "1598:                     }",
          "1599:                     break;",
          "1600:                 case SOF0:",
          "1601:                 case SOF1:",
          "1602:                     s->lossless=0;",
          "1603:                     s->ls=0;",
          "1604:                     s->progressive=0;",
          "1605:                     if (ff_mjpeg_decode_sof(s) < 0)",
          "1606:                         return -1;",
          "1607:                     break;",
          "1608:                 case SOF2:",
          "1609:                     s->lossless=0;",
          "1610:                     s->ls=0;",
          "1611:                     s->progressive=1;",
          "1612:                     if (ff_mjpeg_decode_sof(s) < 0)",
          "1613:                         return -1;",
          "1614:                     break;",
          "1615:                 case SOF3:",
          "1616:                     s->lossless=1;",
          "1617:                     s->ls=0;",
          "1618:                     s->progressive=0;",
          "1619:                     if (ff_mjpeg_decode_sof(s) < 0)",
          "1620:                         return -1;",
          "1621:                     break;",
          "1622:                 case SOF48:",
          "1623:                     s->lossless=1;",
          "1624:                     s->ls=1;",
          "1625:                     s->progressive=0;",
          "1626:                     if (ff_mjpeg_decode_sof(s) < 0)",
          "1627:                         return -1;",
          "1628:                     break;",
          "1629:                 case LSE:",
          "1630:                     if (!CONFIG_JPEGLS_DECODER || ff_jpegls_decode_lse(s) < 0)",
          "1631:                         return -1;",
          "1632:                     break;",
          "1633:                 case EOI:",
          "1635:                     s->cur_scan = 0;",
          "1636:                     if (!s->got_picture) {",
          "1637:                         av_log(avctx, AV_LOG_WARNING, \"Found EOI before any SOF, ignoring\\n\");",
          "1639:                     }",
          "1640:                     if (s->interlaced) {",
          "1641:                         s->bottom_field ^= 1;",
          "1643:                         if (s->bottom_field == !s->interlace_polarity)",
          "1644:                             break;",
          "1645:                     }",
          "1649:                     if(!s->lossless){",
          "1650:                         picture->quality= FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2]);",
          "1651:                         picture->qstride= 0;",
          "1652:                         picture->qscale_table= s->qscale_table;",
          "1653:                         memset(picture->qscale_table, picture->quality, (s->width+15)/16);",
          "1654:                         if(avctx->debug & FF_DEBUG_QP)",
          "1655:                             av_log(avctx, AV_LOG_DEBUG, \"QP: %d\\n\", picture->quality);",
          "1656:                         picture->quality*= FF_QP2LAMBDA;",
          "1659:                     goto the_end;",
          "1660:                 case SOS:",
          "1661:                     if (!s->got_picture) {",
          "1662:                         av_log(avctx, AV_LOG_WARNING, \"Can not process SOS before SOF, skipping\\n\");",
          "1663:                         break;",
          "1664:                     }",
          "1665:                     if (ff_mjpeg_decode_sos(s, NULL, NULL) < 0 &&",
          "1666:                         (avctx->err_recognition & AV_EF_EXPLODE))",
          "1667:                       return AVERROR_INVALIDDATA;",
          "1668:                     break;",
          "1669:                 case DRI:",
          "1670:                     mjpeg_decode_dri(s);",
          "1671:                     break;",
          "1672:                 case SOF5:",
          "1673:                 case SOF6:",
          "1674:                 case SOF7:",
          "1675:                 case SOF9:",
          "1676:                 case SOF10:",
          "1677:                 case SOF11:",
          "1678:                 case SOF13:",
          "1679:                 case SOF14:",
          "1680:                 case SOF15:",
          "1681:                 case JPG:",
          "1682:                     av_log(avctx, AV_LOG_ERROR, \"mjpeg: unsupported coding type (%x)\\n\", start_code);",
          "1687:                 }",
          "1690:                 buf_ptr += (get_bits_count(&s->gb)+7)/8;",
          "1691:                 av_log(avctx, AV_LOG_DEBUG, \"marker parser used %d bytes (%d bits)\\n\",",
          "1692:                        (get_bits_count(&s->gb)+7)/8, get_bits_count(&s->gb));",
          "",
          "[Added Lines]",
          "1587:                                           &unescaped_buf_ptr,",
          "1588:                                           &unescaped_buf_size);",
          "1590:         if (start_code < 0) {",
          "1591:             goto the_end;",
          "1592:         } else {",
          "1593:             av_log(avctx, AV_LOG_DEBUG, \"marker=%x avail_size_in_buf=%td\\n\",",
          "1594:                    start_code, buf_end - buf_ptr);",
          "1596:             init_get_bits(&s->gb, unescaped_buf_ptr, unescaped_buf_size * 8);",
          "1598:             s->start_code = start_code;",
          "1599:             if (s->avctx->debug & FF_DEBUG_STARTCODE)",
          "1600:                 av_log(avctx, AV_LOG_DEBUG, \"startcode: %X\\n\", start_code);",
          "1603:             if (start_code >= 0xd0 && start_code <= 0xd7)",
          "1604:                 av_log(avctx, AV_LOG_DEBUG,",
          "1605:                        \"restart marker: %d\\n\", start_code & 0x0f);",
          "1607:             else if (start_code >= APP0 && start_code <= APP15)",
          "1608:                 mjpeg_decode_app(s);",
          "1610:             else if (start_code == COM)",
          "1611:                 mjpeg_decode_com(s);",
          "1613:             switch (start_code) {",
          "1614:             case SOI:",
          "1615:                 s->restart_interval = 0;",
          "1616:                 s->restart_count    = 0;",
          "1618:                 break;",
          "1619:             case DQT:",
          "1620:                 ff_mjpeg_decode_dqt(s);",
          "1621:                 break;",
          "1622:             case DHT:",
          "1623:                 if (ff_mjpeg_decode_dht(s) < 0) {",
          "1624:                     av_log(avctx, AV_LOG_ERROR, \"huffman table decode error\\n\");",
          "1625:                     return -1;",
          "1627:                 break;",
          "1628:             case SOF0:",
          "1629:             case SOF1:",
          "1630:                 s->lossless    = 0;",
          "1631:                 s->ls          = 0;",
          "1632:                 s->progressive = 0;",
          "1633:                 if (ff_mjpeg_decode_sof(s) < 0)",
          "1634:                     return -1;",
          "1635:                 break;",
          "1636:             case SOF2:",
          "1637:                 s->lossless    = 0;",
          "1638:                 s->ls          = 0;",
          "1639:                 s->progressive = 1;",
          "1640:                 if (ff_mjpeg_decode_sof(s) < 0)",
          "1641:                     return -1;",
          "1642:                 break;",
          "1643:             case SOF3:",
          "1644:                 s->lossless    = 1;",
          "1645:                 s->ls          = 0;",
          "1646:                 s->progressive = 0;",
          "1647:                 if (ff_mjpeg_decode_sof(s) < 0)",
          "1648:                     return -1;",
          "1649:                 break;",
          "1650:             case SOF48:",
          "1651:                 s->lossless    = 1;",
          "1652:                 s->ls          = 1;",
          "1653:                 s->progressive = 0;",
          "1654:                 if (ff_mjpeg_decode_sof(s) < 0)",
          "1655:                     return -1;",
          "1656:                 break;",
          "1657:             case LSE:",
          "1658:                 if (!CONFIG_JPEGLS_DECODER || ff_jpegls_decode_lse(s) < 0)",
          "1659:                     return -1;",
          "1660:                 break;",
          "1661:             case EOI:",
          "1663:                 s->cur_scan = 0;",
          "1664:                 if (!s->got_picture) {",
          "1665:                     av_log(avctx, AV_LOG_WARNING,",
          "1666:                            \"Found EOI before any SOF, ignoring\\n\");",
          "1667:                     break;",
          "1668:                 }",
          "1669:                 if (s->interlaced) {",
          "1670:                     s->bottom_field ^= 1;",
          "1672:                     if (s->bottom_field == !s->interlace_polarity)",
          "1674:                 }",
          "1678:                     if (!s->lossless) {",
          "1679:                         picture->quality      = FFMAX3(s->qscale[0],",
          "1680:                                                        s->qscale[1],",
          "1681:                                                        s->qscale[2]);",
          "1682:                         picture->qstride      = 0;",
          "1683:                         picture->qscale_table = s->qscale_table;",
          "1684:                         memset(picture->qscale_table, picture->quality,",
          "1685:                                (s->width + 15) / 16);",
          "1686:                         if (avctx->debug & FF_DEBUG_QP)",
          "1687:                             av_log(avctx, AV_LOG_DEBUG,",
          "1688:                                    \"QP: %d\\n\", picture->quality);",
          "1689:                         picture->quality *= FF_QP2LAMBDA;",
          "1692:                 goto the_end;",
          "1693:             case SOS:",
          "1694:                 if (!s->got_picture) {",
          "1695:                     av_log(avctx, AV_LOG_WARNING,",
          "1696:                            \"Can not process SOS before SOF, skipping\\n\");",
          "1698:                     }",
          "1699:                 if (ff_mjpeg_decode_sos(s, NULL, NULL) < 0 &&",
          "1700:                     (avctx->err_recognition & AV_EF_EXPLODE))",
          "1701:                     return AVERROR_INVALIDDATA;",
          "1702:                 break;",
          "1703:             case DRI:",
          "1704:                 mjpeg_decode_dri(s);",
          "1705:                 break;",
          "1706:             case SOF5:",
          "1707:             case SOF6:",
          "1708:             case SOF7:",
          "1709:             case SOF9:",
          "1710:             case SOF10:",
          "1711:             case SOF11:",
          "1712:             case SOF13:",
          "1713:             case SOF14:",
          "1714:             case SOF15:",
          "1715:             case JPG:",
          "1716:                 av_log(avctx, AV_LOG_ERROR,",
          "1717:                        \"mjpeg: unsupported coding type (%x)\\n\", start_code);",
          "1718:                 break;",
          "1725:             buf_ptr += (get_bits_count(&s->gb) + 7) / 8;",
          "1726:             av_log(avctx, AV_LOG_DEBUG,",
          "1727:                    \"marker parser used %d bytes (%d bits)\\n\",",
          "1728:                    (get_bits_count(&s->gb) + 7) / 8, get_bits_count(&s->gb));",
          "",
          "---------------",
          "--- Hunk 45 ---",
          "[Context before]",
          "1700:     av_log(avctx, AV_LOG_FATAL, \"No JPEG data found in image\\n\");",
          "1701:     return -1;",
          "1702: the_end:",
          "1705:     return buf_ptr - buf;",
          "1706: }",
          "",
          "[Removed Lines]",
          "1703:     av_log(avctx, AV_LOG_DEBUG, \"mjpeg decode frame unused %td bytes\\n\", buf_end - buf_ptr);",
          "",
          "[Added Lines]",
          "1738:     av_log(avctx, AV_LOG_DEBUG, \"mjpeg decode frame unused %td bytes\\n\",",
          "1739:            buf_end - buf_ptr);",
          "",
          "---------------",
          "--- Hunk 46 ---",
          "[Context before]",
          "1716:     av_free(s->buffer);",
          "1717:     av_free(s->qscale_table);",
          "1718:     av_freep(&s->ljpeg_buffer);",
          "1723:             free_vlc(&s->vlcs[i][j]);",
          "1724:     }",
          "1726:         av_freep(&s->blocks[i]);",
          "1727:         av_freep(&s->last_nnz[i]);",
          "1728:     }",
          "",
          "[Removed Lines]",
          "1719:     s->ljpeg_buffer_size=0;",
          "1721:     for(i=0;i<3;i++) {",
          "1722:         for(j=0;j<4;j++)",
          "1725:     for(i=0; i<MAX_COMPONENTS; i++) {",
          "",
          "[Added Lines]",
          "1755:     s->ljpeg_buffer_size = 0;",
          "1757:     for (i = 0; i < 3; i++) {",
          "1758:         for (j = 0; j < 4; j++)",
          "1761:     for (i = 0; i < MAX_COMPONENTS; i++) {",
          "",
          "---------------",
          "--- Hunk 47 ---",
          "[Context before]",
          "1732: #define OFFSET(x) offsetof(MJpegDecodeContext, x)",
          "1733: #define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM",
          "1734: static const AVOption options[] = {",
          "1736:     { NULL },",
          "1737: };",
          "",
          "[Removed Lines]",
          "1735:     { \"extern_huff\",        \"Use external huffman table.\",  OFFSET(extern_huff), AV_OPT_TYPE_INT, { 0 }, 0, 1, VD },",
          "",
          "[Added Lines]",
          "1771:     { \"extern_huff\", \"Use external huffman table.\",",
          "1772:       OFFSET(extern_huff), AV_OPT_TYPE_INT, { 0 }, 0, 1, VD },",
          "",
          "---------------",
          "--- Hunk 48 ---",
          "[Context before]",
          "1752:     .close          = ff_mjpeg_decode_end,",
          "1753:     .decode         = ff_mjpeg_decode_frame,",
          "1754:     .capabilities   = CODEC_CAP_DR1,",
          "1757:     .priv_class     = &mjpegdec_class,",
          "1758: };",
          "",
          "[Removed Lines]",
          "1755:     .max_lowres = 3,",
          "1756:     .long_name = NULL_IF_CONFIG_SMALL(\"MJPEG (Motion JPEG)\"),",
          "",
          "[Added Lines]",
          "1792:     .max_lowres     = 3,",
          "1793:     .long_name      = NULL_IF_CONFIG_SMALL(\"MJPEG (Motion JPEG)\"),",
          "",
          "---------------",
          "--- Hunk 49 ---",
          "[Context before]",
          "1766:     .close          = ff_mjpeg_decode_end,",
          "1767:     .decode         = ff_mjpeg_decode_frame,",
          "1768:     .capabilities   = CODEC_CAP_DR1,",
          "1771: };",
          "",
          "[Removed Lines]",
          "1769:     .max_lowres = 3,",
          "1770:     .long_name = NULL_IF_CONFIG_SMALL(\"Nintendo Gamecube THP video\"),",
          "",
          "[Added Lines]",
          "1806:     .max_lowres     = 3,",
          "1807:     .long_name      = NULL_IF_CONFIG_SMALL(\"Nintendo Gamecube THP video\"),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "970a8f1c256f08d2f6414d573a54f2fa035c8e7a",
      "candidate_info": {
        "commit_hash": "970a8f1c256f08d2f6414d573a54f2fa035c8e7a",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/970a8f1c256f08d2f6414d573a54f2fa035c8e7a",
        "files": [
          "libavcodec/mjpegdec.c"
        ],
        "message": "avcodec/mjpegdec: Fix integer overflow in shift\n\nFixes: signal_sigabrt_7ffff6ac7bb9_2683_cov_4120310995_m_ijpg.avi\nFound-by: Mateusz \"j00ru\" Jurczyk and Gynvael Coldwind\nSigned-off-by: Michael Niedermayer <michaelni@gmx.at>",
        "before_after_code_files": [
          "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
          ],
          "candidate": [
            "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/mjpegdec.c||libavcodec/mjpegdec.c": [
          "File: libavcodec/mjpegdec.c -> libavcodec/mjpegdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "245: int ff_mjpeg_decode_sof(MJpegDecodeContext *s)",
          "246: {",
          "248:     int h_count[MAX_COMPONENTS];",
          "249:     int v_count[MAX_COMPONENTS];",
          "",
          "[Removed Lines]",
          "247:     int len, nb_components, i, width, height, bits, pix_fmt_id, ret;",
          "",
          "[Added Lines]",
          "247:     int len, nb_components, i, width, height, bits, ret;",
          "248:     unsigned pix_fmt_id;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "383:         else if (!s->lossless)",
          "384:             s->rgb = 0;",
          "387:                  (s->h_count[1] << 20) | (s->v_count[1] << 16) |",
          "388:                  (s->h_count[2] << 12) | (s->v_count[2] <<  8) |",
          "389:                  (s->h_count[3] <<  4) |  s->v_count[3];",
          "",
          "[Removed Lines]",
          "386:     pix_fmt_id = (s->h_count[0] << 28) | (s->v_count[0] << 24) |",
          "",
          "[Added Lines]",
          "387:     pix_fmt_id = ((unsigned)s->h_count[0] << 28) | (s->v_count[0] << 24) |",
          "",
          "---------------"
        ]
      }
    }
  ]
}
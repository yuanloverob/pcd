{
  "cve_id": "CVE-2019-18885",
  "cve_desc": "fs/btrfs/volumes.c in the Linux kernel before 5.1 allows a btrfs_verify_dev_extents NULL pointer dereference via a crafted btrfs image because fs_devices->devices is mishandled within find_device, aka CID-09ba3bc9dd15.",
  "repo": "torvalds/linux",
  "patch_hash": "09ba3bc9dd150457c506e4661380a6183af651c1",
  "patch_info": {
    "commit_hash": "09ba3bc9dd150457c506e4661380a6183af651c1",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/09ba3bc9dd150457c506e4661380a6183af651c1",
    "files": [
      "fs/btrfs/dev-replace.c",
      "fs/btrfs/ioctl.c",
      "fs/btrfs/scrub.c",
      "fs/btrfs/volumes.c",
      "fs/btrfs/volumes.h"
    ],
    "message": "btrfs: merge btrfs_find_device and find_device\n\nBoth btrfs_find_device() and find_device() does the same thing except\nthat the latter does not take the seed device onto account in the device\nscanning context. We can merge them.\n\nSigned-off-by: Anand Jain <anand.jain@oracle.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
    "before_after_code_files": [
      "fs/btrfs/dev-replace.c||fs/btrfs/dev-replace.c",
      "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c",
      "fs/btrfs/scrub.c||fs/btrfs/scrub.c",
      "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
      "fs/btrfs/volumes.h||fs/btrfs/volumes.h"
    ]
  },
  "patch_diff": {
    "fs/btrfs/dev-replace.c||fs/btrfs/dev-replace.c": [
      "File: fs/btrfs/dev-replace.c -> fs/btrfs/dev-replace.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "112:  case BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:",
      "113:  case BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:",
      "114:   dev_replace->srcdev = btrfs_find_device(fs_info->fs_devices,",
      "116:   dev_replace->tgtdev = btrfs_find_device(fs_info->fs_devices,",
      "117:        BTRFS_DEV_REPLACE_DEVID,",
      "",
      "[Removed Lines]",
      "115:        src_devid, NULL, NULL);",
      "118:        NULL, NULL);",
      "",
      "[Added Lines]",
      "115:       src_devid, NULL, NULL, true);",
      "118:        NULL, NULL, true);",
      "",
      "---------------"
    ],
    "fs/btrfs/ioctl.c||fs/btrfs/ioctl.c": [
      "File: fs/btrfs/ioctl.c -> fs/btrfs/ioctl.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1642:   btrfs_info(fs_info, \"resizing devid %llu\", devid);",
      "1643:  }",
      "1646:  if (!device) {",
      "1647:   btrfs_info(fs_info, \"resizer unable to find device %llu\",",
      "1648:       devid);",
      "",
      "[Removed Lines]",
      "1645:  device = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);",
      "",
      "[Added Lines]",
      "1645:  device = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3180:  rcu_read_lock();",
      "3181:  dev = btrfs_find_device(fs_info->fs_devices, di_args->devid, s_uuid,",
      "3184:  if (!dev) {",
      "3185:   ret = -ENODEV;",
      "",
      "[Removed Lines]",
      "3182:     NULL);",
      "",
      "[Added Lines]",
      "3182:     NULL, true);",
      "",
      "---------------"
    ],
    "fs/btrfs/scrub.c||fs/btrfs/scrub.c": [
      "File: fs/btrfs/scrub.c -> fs/btrfs/scrub.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3835:   return PTR_ERR(sctx);",
      "3837:  mutex_lock(&fs_info->fs_devices->device_list_mutex);",
      "3839:  if (!dev || (test_bit(BTRFS_DEV_STATE_MISSING, &dev->dev_state) &&",
      "3840:        !is_dev_replace)) {",
      "3841:   mutex_unlock(&fs_info->fs_devices->device_list_mutex);",
      "",
      "[Removed Lines]",
      "3838:  dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);",
      "",
      "[Added Lines]",
      "3838:  dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "4012:  struct scrub_ctx *sctx = NULL;",
      "4014:  mutex_lock(&fs_info->fs_devices->device_list_mutex);",
      "4016:  if (dev)",
      "4017:   sctx = dev->scrub_ctx;",
      "4018:  if (sctx)",
      "",
      "[Removed Lines]",
      "4015:  dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);",
      "",
      "[Added Lines]",
      "4015:  dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);",
      "",
      "---------------"
    ],
    "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
      "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "415:  return dev;",
      "416: }",
      "439: static noinline struct btrfs_fs_devices *find_fsid(",
      "440:   const u8 *fsid, const u8 *metadata_fsid)",
      "441: {",
      "",
      "[Removed Lines]",
      "425: static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,",
      "426:   u64 devid, const u8 *uuid)",
      "427: {",
      "428:  struct btrfs_device *dev;",
      "430:  list_for_each_entry(dev, &fs_devices->devices, dev_list) {",
      "431:   if (dev->devid == devid &&",
      "432:       (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {",
      "433:    return dev;",
      "434:   }",
      "435:  }",
      "436:  return NULL;",
      "437: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "984:   device = NULL;",
      "985:  } else {",
      "986:   mutex_lock(&fs_devices->device_list_mutex);",
      "",
      "[Removed Lines]",
      "987:   device = find_device(fs_devices, devid,",
      "988:     disk_super->dev_item.uuid);",
      "",
      "[Added Lines]",
      "966:   device = btrfs_find_device(fs_devices, devid,",
      "967:     disk_super->dev_item.uuid, NULL, false);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "2402:  dev_uuid = disk_super->dev_item.uuid;",
      "2403:  if (btrfs_fs_incompat(fs_info, METADATA_UUID))",
      "2404:   device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,",
      "2406:  else",
      "2407:   device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,",
      "2410:  brelse(bh);",
      "2411:  if (!device)",
      "",
      "[Removed Lines]",
      "2405:         disk_super->metadata_uuid);",
      "2408:         disk_super->fsid);",
      "",
      "[Added Lines]",
      "2384:         disk_super->metadata_uuid, true);",
      "2387:         disk_super->fsid, true);",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "2426:  if (devid) {",
      "2427:   device = btrfs_find_device(fs_info->fs_devices, devid, NULL,",
      "2429:   if (!device)",
      "2430:    return ERR_PTR(-ENOENT);",
      "2431:   return device;",
      "",
      "[Removed Lines]",
      "2428:         NULL);",
      "",
      "[Added Lines]",
      "2407:         NULL, true);",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "2568:   read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),",
      "2569:        BTRFS_FSID_SIZE);",
      "2570:   device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,",
      "2574:   if (device->fs_devices->seeding) {",
      "",
      "[Removed Lines]",
      "2571:         fs_uuid);",
      "",
      "[Added Lines]",
      "2550:         fs_uuid, true);",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "6621:  return BLK_STS_OK;",
      "6622: }",
      "6624: struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,",
      "6626: {",
      "6627:  struct btrfs_device *device;",
      "6629:  while (fs_devices) {",
      "6630:   if (!fsid ||",
      "6631:       !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {",
      "6635:   }",
      "6637:  }",
      "6638:  return NULL;",
      "6639: }",
      "",
      "[Removed Lines]",
      "6625:            u64 devid, u8 *uuid, u8 *fsid)",
      "6632:    device = find_device(fs_devices, devid, uuid);",
      "6633:    if (device)",
      "6634:     return device;",
      "6636:   fs_devices = fs_devices->seed;",
      "",
      "[Added Lines]",
      "6613:            u64 devid, u8 *uuid, u8 *fsid,",
      "6614:            bool seed)",
      "6621:    list_for_each_entry(device, &fs_devices->devices,",
      "6622:          dev_list) {",
      "6623:     if (device->devid == devid &&",
      "6624:         (!uuid || memcmp(device->uuid, uuid,",
      "6625:            BTRFS_UUID_SIZE) == 0))",
      "6626:      return device;",
      "6627:    }",
      "6629:   if (seed)",
      "6630:    fs_devices = fs_devices->seed;",
      "6631:   else",
      "6632:    return NULL;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "6879:        btrfs_stripe_dev_uuid_nr(chunk, i),",
      "6880:        BTRFS_UUID_SIZE);",
      "6881:   map->stripes[i].dev = btrfs_find_device(fs_info->fs_devices,",
      "6883:   if (!map->stripes[i].dev &&",
      "6884:       !btrfs_test_opt(fs_info, DEGRADED)) {",
      "6885:    free_extent_map(em);",
      "",
      "[Removed Lines]",
      "6882:        devid, uuid, NULL);",
      "",
      "[Added Lines]",
      "6878:        devid, uuid, NULL, true);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "7019:  }",
      "7021:  device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,",
      "7023:  if (!device) {",
      "7024:   if (!btrfs_test_opt(fs_info, DEGRADED)) {",
      "7025:    btrfs_report_missing_device(fs_info, devid,",
      "",
      "[Removed Lines]",
      "7022:        fs_uuid);",
      "",
      "[Added Lines]",
      "7018:        fs_uuid, true);",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "7609:  int i;",
      "7611:  mutex_lock(&fs_devices->device_list_mutex);",
      "7613:  mutex_unlock(&fs_devices->device_list_mutex);",
      "7615:  if (!dev) {",
      "",
      "[Removed Lines]",
      "7612:  dev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);",
      "",
      "[Added Lines]",
      "7608:  dev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL,",
      "7609:     true);",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "7823:  }",
      "7827:  if (!dev) {",
      "7828:   btrfs_err(fs_info, \"failed to find devid %llu\", devid);",
      "7829:   ret = -EUCLEAN;",
      "",
      "[Removed Lines]",
      "7826:  dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);",
      "",
      "[Added Lines]",
      "7823:  dev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "7834:  if (dev->disk_total_bytes == 0) {",
      "7836:   if (!dev) {",
      "7837:    btrfs_err(fs_info, \"failed to find seed devid %llu\",",
      "7838:       devid);",
      "",
      "[Removed Lines]",
      "7835:   dev = find_device(fs_info->fs_devices->seed, devid, NULL);",
      "",
      "[Added Lines]",
      "7832:   dev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,",
      "7833:      NULL, false);",
      "",
      "---------------"
    ],
    "fs/btrfs/volumes.h||fs/btrfs/volumes.h": [
      "File: fs/btrfs/volumes.h -> fs/btrfs/volumes.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "434: int btrfs_grow_device(struct btrfs_trans_handle *trans,",
      "435:         struct btrfs_device *device, u64 new_size);",
      "436: struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,",
      "438: int btrfs_shrink_device(struct btrfs_device *device, u64 new_size);",
      "439: int btrfs_init_new_device(struct btrfs_fs_info *fs_info, const char *path);",
      "440: int btrfs_balance(struct btrfs_fs_info *fs_info,",
      "",
      "[Removed Lines]",
      "437:            u64 devid, u8 *uuid, u8 *fsid);",
      "",
      "[Added Lines]",
      "437:            u64 devid, u8 *uuid, u8 *fsid, bool seed);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9c6d173ea6e4c8c939ae6c257c7fc18f7b320316",
      "candidate_info": {
        "commit_hash": "9c6d173ea6e4c8c939ae6c257c7fc18f7b320316",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/9c6d173ea6e4c8c939ae6c257c7fc18f7b320316",
        "files": [
          "fs/btrfs/volumes.c"
        ],
        "message": "btrfs: extend locked section when adding a new device in device_list_add\n\nMake sure the device_list_lock is held the whole time:\n\n* when the device is being looked up\n* new device is initialized and put to the list\n* the list counters are updated (fs_devices::opened, fs_devices::total_devices)\n\nSigned-off-by: Anand Jain <anand.jain@oracle.com>\n[ update changelog ]\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ],
          "candidate": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "762:   if (IS_ERR(fs_devices))",
          "763:    return ERR_CAST(fs_devices);",
          "765:   list_add(&fs_devices->fs_list, &fs_uuids);",
          "767:   device = NULL;",
          "768:  } else {",
          "769:   device = find_device(fs_devices, devid,",
          "770:     disk_super->dev_item.uuid);",
          "771:  }",
          "773:  if (!device) {",
          "775:    return ERR_PTR(-EBUSY);",
          "777:   device = btrfs_alloc_device(NULL, &devid,",
          "778:          disk_super->dev_item.uuid);",
          "779:   if (IS_ERR(device)) {",
          "781:    return device;",
          "782:   }",
          "",
          "[Removed Lines]",
          "774:   if (fs_devices->opened)",
          "",
          "[Added Lines]",
          "765:   mutex_lock(&fs_devices->device_list_mutex);",
          "770:   mutex_lock(&fs_devices->device_list_mutex);",
          "776:   if (fs_devices->opened) {",
          "777:    mutex_unlock(&fs_devices->device_list_mutex);",
          "779:   }",
          "784:    mutex_unlock(&fs_devices->device_list_mutex);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "784:   name = rcu_string_strdup(path, GFP_NOFS);",
          "785:   if (!name) {",
          "786:    btrfs_free_device(device);",
          "787:    return ERR_PTR(-ENOMEM);",
          "788:   }",
          "789:   rcu_assign_pointer(device->name, name);",
          "792:   list_add_rcu(&device->dev_list, &fs_devices->devices);",
          "793:   fs_devices->num_devices++;",
          "796:   device->fs_devices = fs_devices;",
          "",
          "[Removed Lines]",
          "791:   mutex_lock(&fs_devices->device_list_mutex);",
          "794:   mutex_unlock(&fs_devices->device_list_mutex);",
          "",
          "[Added Lines]",
          "792:    mutex_unlock(&fs_devices->device_list_mutex);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "841:    return ERR_PTR(-EEXIST);",
          "842:   }",
          "844:   name = rcu_string_strdup(path, GFP_NOFS);",
          "846:    return ERR_PTR(-ENOMEM);",
          "847:   rcu_string_free(device->name);",
          "848:   rcu_assign_pointer(device->name, name);",
          "849:   if (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)) {",
          "",
          "[Removed Lines]",
          "845:   if (!name)",
          "",
          "[Added Lines]",
          "845:    mutex_unlock(&fs_devices->device_list_mutex);",
          "850:   if (!name) {",
          "851:    mutex_unlock(&fs_devices->device_list_mutex);",
          "853:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "864:  fs_devices->total_devices = btrfs_super_num_devices(disk_super);",
          "866:  return device;",
          "867: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "873:  mutex_unlock(&fs_devices->device_list_mutex);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7239ff4b2be8ec0c3160da7fdd1475785fdb4cb9",
      "candidate_info": {
        "commit_hash": "7239ff4b2be8ec0c3160da7fdd1475785fdb4cb9",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7239ff4b2be8ec0c3160da7fdd1475785fdb4cb9",
        "files": [
          "fs/btrfs/ctree.c",
          "fs/btrfs/ctree.h",
          "fs/btrfs/disk-io.c",
          "fs/btrfs/extent-tree.c",
          "fs/btrfs/volumes.c",
          "fs/btrfs/volumes.h",
          "include/uapi/linux/btrfs.h",
          "include/uapi/linux/btrfs_tree.h"
        ],
        "message": "btrfs: Introduce support for FSID change without metadata rewrite\n\nThis field is going to be used when the user wants to change the UUID\nof the filesystem without having to rewrite all metadata blocks. This\nfield adds another level of indirection such that when the FSID is\nchanged what really happens is the current UUID (the one with which the\nfs was created) is copied to the 'metadata_uuid' field in the superblock\nas well as a new incompat flag is set METADATA_UUID. When the kernel\ndetects this flag is set it knows that the superblock in fact has 2\nUUIDs:\n\n1. Is the UUID which is user-visible, currently known as FSID.\n2. Metadata UUID - this is the UUID which is stamped into all on-disk\n   datastructures belonging to this file system.\n\nWhen the new incompat flag is present device scanning checks whether\nboth fsid/metadata_uuid of the scanned device match any of the\nregistered filesystems. When the flag is not set then both UUIDs are\nequal and only the FSID is retained on disk, metadata_uuid is set only\nin-memory during mount.\n\nAdditionally a new metadata_uuid field is also added to the fs_info\nstruct. It's initialised either with the FSID in case METADATA_UUID\nincompat flag is not set or with the metdata_uuid of the superblock\notherwise.\n\nThis commit introduces the new fields as well as the new incompat flag\nand switches all users of the fsid to the new logic.\n\nSigned-off-by: Nikolay Borisov <nborisov@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\n[ minor updates in comments ]\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/ctree.c||fs/btrfs/ctree.c",
          "fs/btrfs/ctree.h||fs/btrfs/ctree.h",
          "fs/btrfs/disk-io.c||fs/btrfs/disk-io.c",
          "fs/btrfs/extent-tree.c||fs/btrfs/extent-tree.c",
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
          "fs/btrfs/volumes.h||fs/btrfs/volumes.h",
          "include/uapi/linux/btrfs.h||include/uapi/linux/btrfs.h",
          "include/uapi/linux/btrfs_tree.h||include/uapi/linux/btrfs_tree.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
            "fs/btrfs/volumes.h||fs/btrfs/volumes.h"
          ],
          "candidate": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
            "fs/btrfs/volumes.h||fs/btrfs/volumes.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/ctree.c||fs/btrfs/ctree.c": [
          "File: fs/btrfs/ctree.c -> fs/btrfs/ctree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "224:  else",
          "225:   btrfs_set_header_owner(cow, new_root_objectid);",
          "229:  WARN_ON(btrfs_header_generation(buf) > trans->transid);",
          "230:  if (new_root_objectid == BTRFS_TREE_RELOC_OBJECTID)",
          "",
          "[Removed Lines]",
          "227:  write_extent_buffer_fsid(cow, fs_info->fsid);",
          "",
          "[Added Lines]",
          "227:  write_extent_buffer_fsid(cow, fs_info->metadata_fsid);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1050:  else",
          "1051:   btrfs_set_header_owner(cow, root->root_key.objectid);",
          "1055:  ret = update_ref_for_cow(trans, root, buf, cow, &last_ref);",
          "1056:  if (ret) {",
          "",
          "[Removed Lines]",
          "1053:  write_extent_buffer_fsid(cow, fs_info->fsid);",
          "",
          "[Added Lines]",
          "1053:  write_extent_buffer_fsid(cow, fs_info->metadata_fsid);",
          "",
          "---------------"
        ],
        "fs/btrfs/ctree.h||fs/btrfs/ctree.h": [
          "File: fs/btrfs/ctree.h -> fs/btrfs/ctree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "197: struct btrfs_super_block {",
          "202:  __le64 flags;",
          "",
          "[Removed Lines]",
          "198:  u8 csum[BTRFS_CSUM_SIZE];",
          "",
          "[Added Lines]",
          "199:  u8 csum[BTRFS_CSUM_SIZE];",
          "201:  u8 fsid[BTRFS_FSID_SIZE];",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "234:  __le64 cache_generation;",
          "235:  __le64 uuid_tree_generation;",
          "239:  u8 sys_chunk_array[BTRFS_SYSTEM_CHUNK_ARRAY_SIZE];",
          "240:  struct btrfs_root_backup super_roots[BTRFS_NUM_BACKUP_ROOTS];",
          "241: } __attribute__ ((__packed__));",
          "",
          "[Removed Lines]",
          "238:  __le64 reserved[30];",
          "",
          "[Added Lines]",
          "239:  u8 metadata_uuid[BTRFS_FSID_SIZE];",
          "242:  __le64 reserved[28];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "265:   BTRFS_FEATURE_INCOMPAT_RAID56 |  \\",
          "266:   BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF |  \\",
          "267:   BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA | \\",
          "270: #define BTRFS_FEATURE_INCOMPAT_SAFE_SET   \\",
          "271:  (BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF)",
          "",
          "[Removed Lines]",
          "268:   BTRFS_FEATURE_INCOMPAT_NO_HOLES)",
          "",
          "[Added Lines]",
          "272:   BTRFS_FEATURE_INCOMPAT_NO_HOLES | \\",
          "273:   BTRFS_FEATURE_INCOMPAT_METADATA_UUID)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "768: #define BTRFS_FS_BALANCE_RUNNING  18",
          "770: struct btrfs_fs_info {",
          "771:  u8 fsid[BTRFS_FSID_SIZE];",
          "772:  u8 chunk_tree_uuid[BTRFS_UUID_SIZE];",
          "773:  unsigned long flags;",
          "774:  struct btrfs_root *extent_root;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "779:  u8 metadata_fsid[BTRFS_FSID_SIZE];",
          "",
          "---------------"
        ],
        "fs/btrfs/disk-io.c||fs/btrfs/disk-io.c": [
          "File: fs/btrfs/disk-io.c -> fs/btrfs/disk-io.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "542:  if (WARN_ON(!PageUptodate(page)))",
          "543:   return -EUCLEAN;",
          "546:    btrfs_header_fsid(), BTRFS_FSID_SIZE) == 0);",
          "548:  return csum_tree_block(fs_info, eb, 0);",
          "",
          "[Removed Lines]",
          "545:  ASSERT(memcmp_extent_buffer(eb, fs_info->fsid,",
          "",
          "[Added Lines]",
          "545:  ASSERT(memcmp_extent_buffer(eb, fs_info->metadata_fsid,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "558:  read_extent_buffer(eb, fsid, btrfs_header_fsid(), BTRFS_FSID_SIZE);",
          "559:  while (fs_devices) {",
          "561:    ret = 0;",
          "562:    break;",
          "563:   }",
          "",
          "[Removed Lines]",
          "560:   if (!memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE)) {",
          "",
          "[Added Lines]",
          "560:   u8 *metadata_uuid;",
          "567:   if (fs_devices == fs_info->fs_devices &&",
          "568:       btrfs_fs_incompat(fs_info, METADATA_UUID))",
          "569:    metadata_uuid = fs_devices->metadata_uuid;",
          "570:   else",
          "571:    metadata_uuid = fs_devices->fsid;",
          "573:   if (!memcmp(fsid, metadata_uuid, BTRFS_FSID_SIZE)) {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2443:   ret = -EINVAL;",
          "2444:  }",
          "2447:   btrfs_err(fs_info,",
          "2450:   ret = -EINVAL;",
          "2451:  }",
          "",
          "[Removed Lines]",
          "2446:  if (memcmp(fs_info->fsid, sb->dev_item.fsid, BTRFS_FSID_SIZE) != 0) {",
          "2448:       \"dev_item UUID does not match fsid: %pU != %pU\",",
          "2449:       fs_info->fsid, sb->dev_item.fsid);",
          "",
          "[Added Lines]",
          "2459:  if (memcmp(fs_info->metadata_fsid, sb->dev_item.fsid,",
          "2460:      BTRFS_FSID_SIZE) != 0) {",
          "2462:    \"dev_item UUID does not match metadata fsid: %pU != %pU\",",
          "2463:    fs_info->metadata_fsid, sb->dev_item.fsid);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2790:  brelse(bh);",
          "2792:  memcpy(fs_info->fsid, fs_info->super_copy->fsid, BTRFS_FSID_SIZE);",
          "2794:  ret = btrfs_validate_mount_super(fs_info);",
          "2795:  if (ret) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2807:  if (btrfs_fs_incompat(fs_info, METADATA_UUID)) {",
          "2808:   memcpy(fs_info->metadata_fsid,",
          "2809:          fs_info->super_copy->metadata_uuid, BTRFS_FSID_SIZE);",
          "2810:  } else {",
          "2811:   memcpy(fs_info->metadata_fsid, fs_info->fsid, BTRFS_FSID_SIZE);",
          "2812:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3728:   btrfs_set_stack_device_io_width(dev_item, dev->io_width);",
          "3729:   btrfs_set_stack_device_sector_size(dev_item, dev->sector_size);",
          "3730:   memcpy(dev_item->uuid, dev->uuid, BTRFS_UUID_SIZE);",
          "3733:   flags = btrfs_super_flags(sb);",
          "3734:   btrfs_set_super_flags(sb, flags | BTRFS_HEADER_FLAG_WRITTEN);",
          "",
          "[Removed Lines]",
          "3731:   memcpy(dev_item->fsid, dev->fs_devices->fsid, BTRFS_FSID_SIZE);",
          "",
          "[Added Lines]",
          "3751:   memcpy(dev_item->fsid, dev->fs_devices->metadata_uuid,",
          "3752:          BTRFS_FSID_SIZE);",
          "",
          "---------------"
        ],
        "fs/btrfs/extent-tree.c||fs/btrfs/extent-tree.c": [
          "File: fs/btrfs/extent-tree.c -> fs/btrfs/extent-tree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "8312:  btrfs_set_header_generation(buf, trans->transid);",
          "8313:  btrfs_set_header_backref_rev(buf, BTRFS_MIXED_BACKREF_REV);",
          "8314:  btrfs_set_header_owner(buf, owner);",
          "8316:  write_extent_buffer_chunk_tree_uuid(buf, fs_info->chunk_tree_uuid);",
          "8317:  if (root->root_key.objectid == BTRFS_TREE_LOG_OBJECTID) {",
          "8318:   buf->log_index = root->log_transid % 2;",
          "",
          "[Removed Lines]",
          "8315:  write_extent_buffer_fsid(buf, fs_info->fsid);",
          "",
          "[Added Lines]",
          "8315:  write_extent_buffer_fsid(buf, fs_info->metadata_fsid);",
          "",
          "---------------"
        ],
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "255: {",
          "256:  struct btrfs_fs_devices *fs_devs;",
          "",
          "[Removed Lines]",
          "254: static struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid)",
          "",
          "[Added Lines]",
          "255: static struct btrfs_fs_devices *alloc_fs_devices(const u8 *fsid,",
          "256:        const u8 *metadata_fsid)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "268:  if (fsid)",
          "269:   memcpy(fs_devs->fsid, fsid, BTRFS_FSID_SIZE);",
          "271:  return fs_devs;",
          "272: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273:  if (metadata_fsid)",
          "274:   memcpy(fs_devs->metadata_uuid, metadata_fsid, BTRFS_FSID_SIZE);",
          "275:  else if (fsid)",
          "276:   memcpy(fs_devs->metadata_uuid, fsid, BTRFS_FSID_SIZE);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "375:  return NULL;",
          "376: }",
          "379: {",
          "380:  struct btrfs_fs_devices *fs_devices;",
          "382:  list_for_each_entry(fs_devices, &fs_uuids, fs_list) {",
          "385:  }",
          "386:  return NULL;",
          "387: }",
          "",
          "[Removed Lines]",
          "378: static noinline struct btrfs_fs_devices *find_fsid(u8 *fsid)",
          "383:   if (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)",
          "384:    return fs_devices;",
          "",
          "[Added Lines]",
          "385: static noinline struct btrfs_fs_devices *find_fsid(",
          "386:   const u8 *fsid, const u8 *metadata_fsid)",
          "390:  ASSERT(fsid);",
          "393:   if (metadata_fsid) {",
          "394:    if (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0",
          "395:        && memcmp(metadata_fsid, fs_devices->metadata_uuid,",
          "396:           BTRFS_FSID_SIZE) == 0)",
          "397:     return fs_devices;",
          "398:   } else {",
          "399:    if (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0)",
          "400:     return fs_devices;",
          "401:   }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "716:  device->generation = btrfs_super_generation(disk_super);",
          "718:  if (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_SEEDING) {",
          "719:   clear_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state);",
          "720:   fs_devices->seeding = 1;",
          "721:  } else {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "736:   if (btrfs_super_incompat_flags(disk_super) &",
          "737:       BTRFS_FEATURE_INCOMPAT_METADATA_UUID) {",
          "738:    pr_err(",
          "739:   \"BTRFS: Invalid seeding and uuid-changed device detected\\n\");",
          "740:    goto error_brelse;",
          "741:   }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "766:  struct rcu_string *name;",
          "767:  u64 found_transid = btrfs_super_generation(disk_super);",
          "768:  u64 devid = btrfs_stack_device_id(&disk_super->dev_item);",
          "771:  if (!fs_devices) {",
          "773:   if (IS_ERR(fs_devices))",
          "774:    return ERR_CAST(fs_devices);",
          "",
          "[Removed Lines]",
          "770:  fs_devices = find_fsid(disk_super->fsid);",
          "772:   fs_devices = alloc_fs_devices(disk_super->fsid);",
          "",
          "[Added Lines]",
          "793:  bool has_metadata_uuid = (btrfs_super_incompat_flags(disk_super) &",
          "794:   BTRFS_FEATURE_INCOMPAT_METADATA_UUID);",
          "796:  if (has_metadata_uuid)",
          "797:   fs_devices = find_fsid(disk_super->fsid, disk_super->metadata_uuid);",
          "798:  else",
          "799:   fs_devices = find_fsid(disk_super->fsid, NULL);",
          "802:   if (has_metadata_uuid)",
          "803:    fs_devices = alloc_fs_devices(disk_super->fsid,",
          "804:             disk_super->metadata_uuid);",
          "805:   else",
          "806:    fs_devices = alloc_fs_devices(disk_super->fsid, NULL);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "920:  struct btrfs_device *device;",
          "921:  struct btrfs_device *orig_dev;",
          "924:  if (IS_ERR(fs_devices))",
          "925:   return fs_devices;",
          "",
          "[Removed Lines]",
          "923:  fs_devices = alloc_fs_devices(orig->fsid);",
          "",
          "[Added Lines]",
          "958:  fs_devices = alloc_fs_devices(orig->fsid, NULL);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1745:  ptr = btrfs_device_uuid(dev_item);",
          "1746:  write_extent_buffer(leaf, device->uuid, ptr, BTRFS_UUID_SIZE);",
          "1747:  ptr = btrfs_device_fsid(dev_item);",
          "1749:  btrfs_mark_buffer_dirty(leaf);",
          "1751:  ret = 0;",
          "",
          "[Removed Lines]",
          "1748:  write_extent_buffer(leaf, trans->fs_info->fsid, ptr, BTRFS_FSID_SIZE);",
          "",
          "[Added Lines]",
          "1783:  write_extent_buffer(leaf, trans->fs_info->metadata_fsid, ptr,",
          "1784:        BTRFS_FSID_SIZE);",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "2176:  disk_super = (struct btrfs_super_block *)bh->b_data;",
          "2177:  devid = btrfs_stack_device_id(&disk_super->dev_item);",
          "2178:  dev_uuid = disk_super->dev_item.uuid;",
          "2180:  brelse(bh);",
          "2181:  if (!device)",
          "2182:   device = ERR_PTR(-ENOENT);",
          "",
          "[Removed Lines]",
          "2179:  device = btrfs_find_device(fs_info, devid, dev_uuid, disk_super->fsid);",
          "",
          "[Added Lines]",
          "2215:  if (btrfs_fs_incompat(fs_info, METADATA_UUID))",
          "2216:   device = btrfs_find_device(fs_info, devid, dev_uuid,",
          "2217:     disk_super->metadata_uuid);",
          "2218:  else",
          "2219:   device = btrfs_find_device(fs_info, devid,",
          "2220:     dev_uuid, disk_super->fsid);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "2246:  if (!fs_devices->seeding)",
          "2247:   return -EINVAL;",
          "2250:  if (IS_ERR(seed_devices))",
          "2251:   return PTR_ERR(seed_devices);",
          "",
          "[Removed Lines]",
          "2249:  seed_devices = alloc_fs_devices(NULL);",
          "",
          "[Added Lines]",
          "2291:  seed_devices = alloc_fs_devices(NULL, NULL);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "2284:  generate_random_uuid(fs_devices->fsid);",
          "2285:  memcpy(fs_info->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);",
          "2286:  memcpy(disk_super->fsid, fs_devices->fsid, BTRFS_FSID_SIZE);",
          "2287:  mutex_unlock(&fs_devices->device_list_mutex);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2328:  memcpy(fs_devices->metadata_uuid, fs_devices->fsid, BTRFS_FSID_SIZE);",
          "2329:  memcpy(fs_info->metadata_fsid, fs_devices->fsid, BTRFS_FSID_SIZE);",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "6294:  cur_devices = fs_info->fs_devices;",
          "6295:  while (cur_devices) {",
          "6296:   if (!fsid ||",
          "6298:    device = find_device(cur_devices, devid, uuid);",
          "6299:    if (device)",
          "6300:     return device;",
          "",
          "[Removed Lines]",
          "6297:       !memcmp(cur_devices->fsid, fsid, BTRFS_FSID_SIZE)) {",
          "",
          "[Added Lines]",
          "6341:       !memcmp(cur_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "6623:   fs_devices = fs_devices->seed;",
          "6624:  }",
          "6627:  if (!fs_devices) {",
          "6628:   if (!btrfs_test_opt(fs_info, DEGRADED))",
          "6629:    return ERR_PTR(-ENOENT);",
          "6632:   if (IS_ERR(fs_devices))",
          "6633:    return fs_devices;",
          "",
          "[Removed Lines]",
          "6626:  fs_devices = find_fsid(fsid);",
          "6631:   fs_devices = alloc_fs_devices(fsid);",
          "",
          "[Added Lines]",
          "6670:  fs_devices = find_fsid(fsid, NULL);",
          "6675:   fs_devices = alloc_fs_devices(fsid, NULL);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "6678:  read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item),",
          "6679:       BTRFS_FSID_SIZE);",
          "6682:   fs_devices = open_seed_devices(fs_info, fs_uuid);",
          "6683:   if (IS_ERR(fs_devices))",
          "6684:    return PTR_ERR(fs_devices);",
          "",
          "[Removed Lines]",
          "6681:  if (memcmp(fs_uuid, fs_info->fsid, BTRFS_FSID_SIZE)) {",
          "",
          "[Added Lines]",
          "6725:  if (memcmp(fs_uuid, fs_info->metadata_fsid, BTRFS_FSID_SIZE)) {",
          "",
          "---------------"
        ],
        "fs/btrfs/volumes.h||fs/btrfs/volumes.h": [
          "File: fs/btrfs/volumes.h -> fs/btrfs/volumes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "211: struct btrfs_fs_devices {",
          "213:  struct list_head fs_list;",
          "215:  u64 num_devices;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "213:  u8 metadata_uuid[BTRFS_FSID_SIZE];",
          "",
          "---------------"
        ],
        "include/uapi/linux/btrfs.h||include/uapi/linux/btrfs.h": [
          "File: include/uapi/linux/btrfs.h -> include/uapi/linux/btrfs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "269: #define BTRFS_FEATURE_INCOMPAT_RAID56  (1ULL << 7)",
          "270: #define BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA (1ULL << 8)",
          "271: #define BTRFS_FEATURE_INCOMPAT_NO_HOLES  (1ULL << 9)",
          "273: struct btrfs_ioctl_feature_flags {",
          "274:  __u64 compat_flags;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "272: #define BTRFS_FEATURE_INCOMPAT_METADATA_UUID (1ULL << 10)",
          "",
          "---------------"
        ],
        "include/uapi/linux/btrfs_tree.h||include/uapi/linux/btrfs_tree.h": [
          "File: include/uapi/linux/btrfs_tree.h -> include/uapi/linux/btrfs_tree.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "458: #define BTRFS_SUPER_FLAG_METADUMP (1ULL << 33)",
          "459: #define BTRFS_SUPER_FLAG_METADUMP_V2 (1ULL << 34)",
          "460: #define BTRFS_SUPER_FLAG_CHANGING_FSID (1ULL << 35)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "461: #define BTRFS_SUPER_FLAG_CHANGING_FSID_V2 (1ULL << 36)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a27a94c2b0c727517c17cf2ca3a9f7291caadfbc",
      "candidate_info": {
        "commit_hash": "a27a94c2b0c727517c17cf2ca3a9f7291caadfbc",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a27a94c2b0c727517c17cf2ca3a9f7291caadfbc",
        "files": [
          "fs/btrfs/dev-replace.c",
          "fs/btrfs/volumes.c",
          "fs/btrfs/volumes.h"
        ],
        "message": "btrfs: Make btrfs_find_device_by_devspec return btrfs_device directly\n\nInstead of returning an error value and using one of the parameters for\nreturning the actual object we are interested in just refactor the\nfunction to directly return btrfs_device *. Also bubble up the error\nhandling for the special BTRFS_ERROR_DEV_MISSING_NOT_FOUND value into\nbtrfs_rm_device. No functional changes.\n\nSigned-off-by: Nikolay Borisov <nborisov@suse.com>\nReviewed-by: Qu Wenruo <wqu@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/dev-replace.c||fs/btrfs/dev-replace.c",
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
          "fs/btrfs/volumes.h||fs/btrfs/volumes.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/dev-replace.c||fs/btrfs/dev-replace.c",
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
            "fs/btrfs/volumes.h||fs/btrfs/volumes.h"
          ],
          "candidate": [
            "fs/btrfs/dev-replace.c||fs/btrfs/dev-replace.c",
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c",
            "fs/btrfs/volumes.h||fs/btrfs/volumes.h"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/dev-replace.c||fs/btrfs/dev-replace.c": [
          "File: fs/btrfs/dev-replace.c -> fs/btrfs/dev-replace.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "409:  struct btrfs_device *tgt_device = NULL;",
          "410:  struct btrfs_device *src_device = NULL;",
          "417:  ret = btrfs_init_dev_replace_tgtdev(fs_info, tgtdev_name,",
          "418:          src_device, &tgt_device);",
          "",
          "[Removed Lines]",
          "412:  ret = btrfs_find_device_by_devspec(fs_info, srcdevid,",
          "413:          srcdev_name, &src_device);",
          "414:  if (ret)",
          "415:   return ret;",
          "",
          "[Added Lines]",
          "412:  src_device = btrfs_find_device_by_devspec(fs_info, srcdevid,",
          "413:         srcdev_name);",
          "414:  if (IS_ERR(src_device))",
          "415:   return PTR_ERR(src_device);",
          "",
          "---------------"
        ],
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1889:  if (ret)",
          "1890:   goto out;",
          "1895:   goto out;",
          "1897:  if (test_bit(BTRFS_DEV_STATE_REPLACE_TGT, &device->dev_state)) {",
          "1898:   ret = BTRFS_ERROR_DEV_TGT_REPLACE;",
          "",
          "[Removed Lines]",
          "1892:  ret = btrfs_find_device_by_devspec(fs_info, devid, device_path,",
          "1893:         &device);",
          "1894:  if (ret)",
          "",
          "[Added Lines]",
          "1892:  device = btrfs_find_device_by_devspec(fs_info, devid, device_path);",
          "1894:  if (IS_ERR(device)) {",
          "1895:   if (PTR_ERR(device) == -ENOENT &&",
          "1896:       strcmp(device_path, \"missing\") == 0)",
          "1897:    ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;",
          "1898:   else",
          "1899:    ret = PTR_ERR(device);",
          "1901:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2169: {",
          "2172:  if (devid) {",
          "2176:  } else {",
          "2177:   if (!devpath || !devpath[0])",
          "2188:  }",
          "2190: }",
          "",
          "[Removed Lines]",
          "2166: int btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info, u64 devid,",
          "2167:      const char *devpath,",
          "2168:      struct btrfs_device **device)",
          "2170:  int ret = 0;",
          "2174:   if (!*device)",
          "2175:    ret = -ENOENT;",
          "2178:    return -EINVAL;",
          "2181:   if (IS_ERR(*device)) {",
          "2182:    if (PTR_ERR(*device) == -ENOENT &&",
          "2183:        strcmp(devpath, \"missing\") == 0)",
          "2184:     ret = BTRFS_ERROR_DEV_MISSING_NOT_FOUND;",
          "2185:    else",
          "2186:     ret = PTR_ERR(*device);",
          "2187:   }",
          "2189:  return ret;",
          "",
          "[Added Lines]",
          "2172: struct btrfs_device *btrfs_find_device_by_devspec(",
          "2173:   struct btrfs_fs_info *fs_info, u64 devid, const char *devpath)",
          "2175:  struct btrfs_device *device;",
          "2178:   device = btrfs_find_device(fs_info, devid, NULL, NULL);",
          "2179:   if (!device)",
          "2180:    return ERR_PTR(-ENOENT);",
          "2183:    return ERR_PTR(-EINVAL);",
          "2184:   device = btrfs_find_device_missing_or_by_path(fs_info, devpath);",
          "2186:  return device;",
          "",
          "---------------"
        ],
        "fs/btrfs/volumes.h||fs/btrfs/volumes.h": [
          "File: fs/btrfs/volumes.h -> fs/btrfs/volumes.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "410: void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step);",
          "411: void btrfs_assign_next_active_device(struct btrfs_device *device,",
          "412:          struct btrfs_device *this_dev);",
          "416: struct btrfs_device *btrfs_alloc_device(struct btrfs_fs_info *fs_info,",
          "417:      const u64 *devid,",
          "418:      const u8 *uuid);",
          "",
          "[Removed Lines]",
          "413: int btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info, u64 devid,",
          "414:       const char *devpath,",
          "415:       struct btrfs_device **device);",
          "",
          "[Added Lines]",
          "413: struct btrfs_device *btrfs_find_device_by_devspec(struct btrfs_fs_info *fs_info,",
          "414:         u64 devid,",
          "415:         const char *devpath);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7a62d0f07377b51a9033eb12fa537c264bcba3e5",
      "candidate_info": {
        "commit_hash": "7a62d0f07377b51a9033eb12fa537c264bcba3e5",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/7a62d0f07377b51a9033eb12fa537c264bcba3e5",
        "files": [
          "fs/btrfs/volumes.c"
        ],
        "message": "btrfs: Handle one more split-brain scenario during fsid change\n\nThis commit continues hardening the scanning code to handle cases where\npower loss could have caused disks in a multi-disk filesystem to be\nin inconsistent state. Namely handle the situation that can occur when\nsome of the disks in multi-disk fs have completed their fsid change i.e\nthey have METADATA_UUID incompat flag set, have cleared the\nCHANGING_FSID_V2 flag and their fsid/metadata_uuid are different. At\nthe same time the other half of the disks will have their\nfsid/metadata_uuid unchanged and will only have CHANGING_FSID_V2 flag.\n\nThis is handled by introducing code in the scan path which:\n\n a) Handles the case when a device with CHANGING_FSID_V2 flag is\n scanned and as a result btrfs_fs_devices is created with matching\n fsid/metdata_uuid. Subsequently, when a device with completed fsid\n change is scanned it will detect this via the new code in find_fsid\n i.e that such an fs_devices exist that fsid_change flag is set to true,\n it's metadata_uuid/fsid match and the metadata_uuid of the scanned\n device matches that of the fs_devices. In this case, it's important to\n note that the devices which has its fsid change completed will have a\n higher generation number than the device with FSID_CHANGING_V2 flag\n set, so its superblock block will be used during mount. To prevent an\n assertion triggering because the sb used for mounting will have\n differing fsid/metadata_uuid than the ones in the fs_devices struct\n also add code in device_list_add which overwrites the values in\n fs_devices.\n\n b) Alternatively we can end up with a device that completed its\n fsid change be scanned first which will create the respective\n btrfs_fs_devices struct with differing fsid/metadata_uuid. In this\n case when a device with FSID_CHANGING_V2 flag set is scanned it will\n call the newly added find_fsid_inprogress function which will return\n the correct fs_devices.\n\nSigned-off-by: Nikolay Borisov <nborisov@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ],
          "candidate": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "390:  ASSERT(fsid);",
          "392:  list_for_each_entry(fs_devices, &fs_uuids, fs_list) {",
          "393:   if (metadata_fsid) {",
          "394:    if (memcmp(fsid, fs_devices->fsid, BTRFS_FSID_SIZE) == 0",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "392:  if (metadata_fsid) {",
          "399:   list_for_each_entry(fs_devices, &fs_uuids, fs_list) {",
          "400:    if (fs_devices->fsid_change &&",
          "401:        memcmp(metadata_fsid, fs_devices->fsid,",
          "402:        BTRFS_FSID_SIZE) == 0 &&",
          "403:        memcmp(fs_devices->fsid, fs_devices->metadata_uuid,",
          "404:        BTRFS_FSID_SIZE) == 0) {",
          "405:     return fs_devices;",
          "406:    }",
          "407:   }",
          "408:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "774:  return -EINVAL;",
          "775: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "800: static struct btrfs_fs_devices *find_fsid_inprogress(",
          "801:      struct btrfs_super_block *disk_super)",
          "802: {",
          "803:  struct btrfs_fs_devices *fs_devices;",
          "805:  list_for_each_entry(fs_devices, &fs_uuids, fs_list) {",
          "806:   if (memcmp(fs_devices->metadata_uuid, fs_devices->fsid,",
          "807:       BTRFS_FSID_SIZE) != 0 &&",
          "808:       memcmp(fs_devices->metadata_uuid, disk_super->fsid,",
          "809:       BTRFS_FSID_SIZE) == 0 && !fs_devices->fsid_change) {",
          "810:    return fs_devices;",
          "811:   }",
          "812:  }",
          "814:  return NULL;",
          "815: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "786:       bool *new_device_added)",
          "787: {",
          "788:  struct btrfs_device *device;",
          "790:  struct rcu_string *name;",
          "791:  u64 found_transid = btrfs_super_generation(disk_super);",
          "792:  u64 devid = btrfs_stack_device_id(&disk_super->dev_item);",
          "",
          "[Removed Lines]",
          "789:  struct btrfs_fs_devices *fs_devices;",
          "",
          "[Added Lines]",
          "829:  struct btrfs_fs_devices *fs_devices = NULL;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "795:  bool fsid_change_in_progress = (btrfs_super_flags(disk_super) &",
          "796:      BTRFS_SUPER_FLAG_CHANGING_FSID_V2);",
          "801:   fs_devices = find_fsid(disk_super->fsid, NULL);",
          "803:  if (!fs_devices) {",
          "804:   if (has_metadata_uuid)",
          "",
          "[Removed Lines]",
          "798:  if (has_metadata_uuid)",
          "799:   fs_devices = find_fsid(disk_super->fsid, disk_super->metadata_uuid);",
          "800:  else",
          "",
          "[Added Lines]",
          "838:  if (fsid_change_in_progress && !has_metadata_uuid) {",
          "845:   fs_devices = find_fsid_inprogress(disk_super);",
          "846:   if (!fs_devices)",
          "847:    fs_devices = find_fsid(disk_super->fsid, NULL);",
          "849:  } else if (has_metadata_uuid) {",
          "850:   fs_devices = find_fsid(disk_super->fsid,",
          "851:            disk_super->metadata_uuid);",
          "852:  } else {",
          "854:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "820:   mutex_lock(&fs_devices->device_list_mutex);",
          "821:   device = find_device(fs_devices, devid,",
          "822:     disk_super->dev_item.uuid);",
          "823:  }",
          "825:  if (!device) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "883:   if (has_metadata_uuid && fs_devices->fsid_change &&",
          "884:       found_transid > fs_devices->latest_generation) {",
          "885:    memcpy(fs_devices->fsid, disk_super->fsid,",
          "886:      BTRFS_FSID_SIZE);",
          "887:    memcpy(fs_devices->metadata_uuid,",
          "888:      disk_super->metadata_uuid, BTRFS_FSID_SIZE);",
          "890:    fs_devices->fsid_change = false;",
          "891:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "05a37c48604c19b50873fd9663f9140c150469d1",
      "candidate_info": {
        "commit_hash": "05a37c48604c19b50873fd9663f9140c150469d1",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/05a37c48604c19b50873fd9663f9140c150469d1",
        "files": [
          "fs/btrfs/volumes.c"
        ],
        "message": "btrfs: volumes: Make sure no dev extent is beyond device boundary\n\nAdd extra dev extent end check against device boundary.\n\nSigned-off-by: Qu Wenruo <wqu@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "before_after_code_files": [
          "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ],
          "candidate": [
            "fs/btrfs/volumes.c||fs/btrfs/volumes.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/volumes.c||fs/btrfs/volumes.c": [
          "File: fs/btrfs/volumes.c -> fs/btrfs/volumes.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "7387:  struct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;",
          "7388:  struct extent_map *em;",
          "7389:  struct map_lookup *map;",
          "7390:  u64 stripe_len;",
          "7391:  bool found = false;",
          "7392:  int ret = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7390:  struct btrfs_device *dev;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "7436:    physical_offset, devid);",
          "7437:   ret = -EUCLEAN;",
          "7438:  }",
          "7439: out:",
          "7440:  free_extent_map(em);",
          "7441:  return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "7442:  dev = btrfs_find_device(fs_info, devid, NULL, NULL);",
          "7443:  if (!dev) {",
          "7444:   btrfs_err(fs_info, \"failed to find devid %llu\", devid);",
          "7445:   ret = -EUCLEAN;",
          "7446:   goto out;",
          "7447:  }",
          "7448:  if (physical_offset + physical_len > dev->disk_total_bytes) {",
          "7449:   btrfs_err(fs_info,",
          "7450: \"dev extent devid %llu physical offset %llu len %llu is beyond device boundary %llu\",",
          "7451:      devid, physical_offset, physical_len,",
          "7452:      dev->disk_total_bytes);",
          "7453:   ret = -EUCLEAN;",
          "7454:   goto out;",
          "7455:  }",
          "",
          "---------------"
        ]
      }
    }
  ]
}
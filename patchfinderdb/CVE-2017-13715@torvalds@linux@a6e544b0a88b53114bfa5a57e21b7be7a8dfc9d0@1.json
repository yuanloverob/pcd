{
  "cve_id": "CVE-2017-13715",
  "cve_desc": "The __skb_flow_dissect function in net/core/flow_dissector.c in the Linux kernel before 4.3 does not ensure that n_proto, ip_proto, and thoff are initialized, which allows remote attackers to cause a denial of service (system crash) or possibly execute arbitrary code via a single crafted MPLS packet.",
  "repo": "torvalds/linux",
  "patch_hash": "a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
  "patch_info": {
    "commit_hash": "a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a6e544b0a88b53114bfa5a57e21b7be7a8dfc9d0",
    "files": [
      "net/core/flow_dissector.c"
    ],
    "message": "flow_dissector: Jump to exit code in __skb_flow_dissect\n\nInstead of returning immediately (on a parsing failure for instance) we\njump to cleanup code. This always sets protocol values in key_control\n(even on a failure there is still valid information in the key_tags that\nwas set before the problem was hit).\n\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "net/core/flow_dissector.c||net/core/flow_dissector.c"
    ]
  },
  "patch_diff": {
    "net/core/flow_dissector.c||net/core/flow_dissector.c": [
      "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "130:  struct flow_dissector_key_tags *key_tags;",
      "131:  struct flow_dissector_key_keyid *key_keyid;",
      "132:  u8 ip_proto = 0;",
      "134:  if (!data) {",
      "135:   data = skb->data;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "133:  bool ret = false;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "171: ip:",
      "172:   iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);",
      "173:   if (!iph || iph->ihl < 5)",
      "175:   nhoff += iph->ihl * 4;",
      "177:   ip_proto = iph->protocol;",
      "",
      "[Removed Lines]",
      "174:    return false;",
      "",
      "[Added Lines]",
      "175:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "197: ipv6:",
      "198:   iph = __skb_header_pointer(skb, nhoff, sizeof(_iph), data, hlen, &_iph);",
      "199:   if (!iph)",
      "202:   ip_proto = iph->nexthdr;",
      "203:   nhoff += sizeof(struct ipv6hdr);",
      "",
      "[Removed Lines]",
      "200:    return false;",
      "",
      "[Added Lines]",
      "201:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "235:   vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);",
      "236:   if (!vlan)",
      "239:   if (skb_flow_dissector_uses_key(flow_dissector,",
      "240:       FLOW_DISSECTOR_KEY_VLANID)) {",
      "",
      "[Removed Lines]",
      "237:    return false;",
      "",
      "[Added Lines]",
      "238:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "256:   } *hdr, _hdr;",
      "257:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
      "258:   if (!hdr)",
      "260:   proto = hdr->proto;",
      "261:   nhoff += PPPOE_SES_HLEN;",
      "262:   switch (proto) {",
      "",
      "[Removed Lines]",
      "259:    return false;",
      "",
      "[Added Lines]",
      "260:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "265:   case htons(PPP_IPV6):",
      "266:    goto ipv6;",
      "267:   default:",
      "269:   }",
      "270:  }",
      "271:  case htons(ETH_P_TIPC): {",
      "",
      "[Removed Lines]",
      "268:    return false;",
      "",
      "[Added Lines]",
      "269:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "275:   } *hdr, _hdr;",
      "276:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
      "277:   if (!hdr)",
      "282:   if (skb_flow_dissector_uses_key(flow_dissector,",
      "283:       FLOW_DISSECTOR_KEY_TIPC_ADDRS)) {",
      "",
      "[Removed Lines]",
      "278:    return false;",
      "279:   key_basic->n_proto = proto;",
      "280:   key_control->thoff = (u16)nhoff;",
      "",
      "[Added Lines]",
      "279:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "287:    key_addrs->tipcaddrs.srcnode = hdr->srcnode;",
      "288:    key_control->addr_type = FLOW_DISSECTOR_KEY_TIPC_ADDRS;",
      "289:   }",
      "291:  }",
      "293:  case htons(ETH_P_MPLS_UC):",
      "",
      "[Removed Lines]",
      "290:   return true;",
      "",
      "[Added Lines]",
      "289:   goto out_good;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "297:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data,",
      "298:         hlen, &_hdr);",
      "299:   if (!hdr)",
      "302:   if ((ntohl(hdr[0].entry) & MPLS_LS_LABEL_MASK) >>",
      "303:        MPLS_LS_LABEL_SHIFT == MPLS_LABEL_ENTROPY) {",
      "",
      "[Removed Lines]",
      "300:    return false;",
      "",
      "[Added Lines]",
      "299:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "310:      htonl(MPLS_LS_LABEL_MASK);",
      "311:    }",
      "318:   }",
      "321:  }",
      "323:  case htons(ETH_P_FCOE):",
      "324:   key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
      "326:  default:",
      "328:  }",
      "330: ip_proto_again:",
      "",
      "[Removed Lines]",
      "313:    key_basic->n_proto = proto;",
      "314:    key_basic->ip_proto = ip_proto;",
      "315:    key_control->thoff = (u16)nhoff;",
      "317:    return true;",
      "320:   return true;",
      "327:   return false;",
      "",
      "[Added Lines]",
      "312:    goto out_good;",
      "315:   goto out_good;",
      "322:   goto out_bad;",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "338:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
      "339:   if (!hdr)",
      "",
      "[Removed Lines]",
      "340:    return false;",
      "",
      "[Added Lines]",
      "335:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "357:            data, hlen, &_keyid);",
      "359:    if (!keyid)",
      "362:    if (skb_flow_dissector_uses_key(flow_dissector,",
      "363:        FLOW_DISSECTOR_KEY_GRE_KEYID)) {",
      "",
      "[Removed Lines]",
      "360:     return false;",
      "",
      "[Added Lines]",
      "355:     goto out_bad;",
      "",
      "---------------",
      "--- Hunk 13 ---",
      "[Context before]",
      "378:          sizeof(_eth),",
      "379:          data, hlen, &_eth);",
      "380:    if (!eth)",
      "382:    proto = eth->h_proto;",
      "383:    nhoff += sizeof(*eth);",
      "384:   }",
      "",
      "[Removed Lines]",
      "381:     return false;",
      "",
      "[Added Lines]",
      "376:     goto out_bad;",
      "",
      "---------------",
      "--- Hunk 14 ---",
      "[Context before]",
      "395:   opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),",
      "396:            data, hlen, &_opthdr);",
      "397:   if (!opthdr)",
      "400:   ip_proto = opthdr[0];",
      "401:   nhoff += (opthdr[1] + 1) << 3;",
      "",
      "[Removed Lines]",
      "398:    return false;",
      "",
      "[Added Lines]",
      "393:    goto out_bad;",
      "",
      "---------------",
      "--- Hunk 15 ---",
      "[Context before]",
      "415:   break;",
      "416:  }",
      "422:  if (skb_flow_dissector_uses_key(flow_dissector,",
      "423:      FLOW_DISSECTOR_KEY_PORTS)) {",
      "424:   key_ports = skb_flow_dissector_target(flow_dissector,",
      "",
      "[Removed Lines]",
      "418:  key_basic->n_proto = proto;",
      "419:  key_basic->ip_proto = ip_proto;",
      "420:  key_control->thoff = (u16)nhoff;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 16 ---",
      "[Context before]",
      "428:        data, hlen);",
      "429:  }",
      "432: }",
      "433: EXPORT_SYMBOL(__skb_flow_dissect);",
      "",
      "[Removed Lines]",
      "431:  return true;",
      "",
      "[Added Lines]",
      "422: out_good:",
      "423:  ret = true;",
      "425: out_bad:",
      "426:  key_basic->n_proto = proto;",
      "427:  key_basic->ip_proto = ip_proto;",
      "428:  key_control->thoff = (u16)nhoff;",
      "430:  return ret;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "08bfc9cb76e26d2489c401fb1d2de58d06fd1ded",
      "candidate_info": {
        "commit_hash": "08bfc9cb76e26d2489c401fb1d2de58d06fd1ded",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/08bfc9cb76e26d2489c401fb1d2de58d06fd1ded",
        "files": [
          "net/core/flow_dissector.c"
        ],
        "message": "flow_dissector: add tipc support\n\nThe flows are hashed on the sending node address, which allows us\nto spread out the TIPC link processing to RPS enabled cores. There\nis no point to include the destination address in the hash as that\nwill always be the same for all inbound links. We have experimented\nwith a 3-tuple hash over [srcnode, sport, dport], but this showed to\ngive slightly lower performance because of increased lock contention\nwhen the same link was handled by multiple cores.\n\nSigned-off-by: Ying Xue <ying.xue@windriver.com>\nSigned-off-by: Erik Hugne <erik.hugne@ericsson.com>\nReviewed-by: Jon Maloy <jon.maloy@ericsson.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/core/flow_dissector.c||net/core/flow_dissector.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "178:    return false;",
          "179:   }",
          "180:  }",
          "181:  case htons(ETH_P_FCOE):",
          "182:   flow->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "181:  case htons(ETH_P_TIPC): {",
          "182:   struct {",
          "183:    __be32 pre[3];",
          "184:    __be32 srcnode;",
          "185:   } *hdr, _hdr;",
          "186:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
          "187:   if (!hdr)",
          "188:    return false;",
          "189:   flow->src = hdr->srcnode;",
          "190:   flow->dst = 0;",
          "191:   flow->n_proto = proto;",
          "192:   flow->thoff = (u16)nhoff;",
          "193:   return true;",
          "194:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "42aecaa9bb2bd57eb8d61b4565cee5d3640863fb",
      "candidate_info": {
        "commit_hash": "42aecaa9bb2bd57eb8d61b4565cee5d3640863fb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/42aecaa9bb2bd57eb8d61b4565cee5d3640863fb",
        "files": [
          "include/linux/skbuff.h",
          "include/net/flow_dissector.h",
          "include/net/ip.h",
          "include/net/ipv6.h",
          "net/core/flow_dissector.c",
          "net/sched/cls_flower.c"
        ],
        "message": "net: Get skb hash over flow_keys structure\n\nThis patch changes flow hashing to use jhash2 over the flow_keys\nstructure instead just doing jhash_3words over src, dst, and ports.\nThis method will allow us take more input into the hashing function\nso that we can include full IPv6 addresses, VLAN, flow labels etc.\nwithout needing to resort to xor'ing which makes for a poor hash.\n\nAcked-by: Jiri Pirko <jiri@resnulli.us>\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "include/linux/skbuff.h||include/linux/skbuff.h",
          "include/net/flow_dissector.h||include/net/flow_dissector.h",
          "include/net/ip.h||include/net/ip.h",
          "include/net/ipv6.h||include/net/ipv6.h",
          "net/core/flow_dissector.c||net/core/flow_dissector.c",
          "net/sched/cls_flower.c||net/sched/cls_flower.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "include/linux/skbuff.h||include/linux/skbuff.h": [
          "File: include/linux/skbuff.h -> include/linux/skbuff.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1943:  if (skb_transport_header_was_set(skb))",
          "1944:   return;",
          "1945:  else if (skb_flow_dissect_flow_keys(skb, &keys))",
          "1947:  else",
          "1948:   skb_set_transport_header(skb, offset_hint);",
          "1949: }",
          "",
          "[Removed Lines]",
          "1946:   skb_set_transport_header(skb, keys.basic.thoff);",
          "",
          "[Added Lines]",
          "1946:   skb_set_transport_header(skb, keys.control.thoff);",
          "",
          "---------------"
        ],
        "include/net/flow_dissector.h||include/net/flow_dissector.h": [
          "File: include/net/flow_dissector.h -> include/net/flow_dissector.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "6: #include <linux/in6.h>",
          "7: #include <uapi/linux/if_ether.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: struct flow_dissector_key_control {",
          "14:  u16 thoff;",
          "15:  u16 padding;",
          "16: };",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "15: struct flow_dissector_key_basic {",
          "17:  __be16 n_proto;",
          "18:  u8 ip_proto;",
          "19: };",
          "",
          "[Removed Lines]",
          "16:  u16 thoff;",
          "",
          "[Added Lines]",
          "27:  u8 padding;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "109: }",
          "111: struct flow_keys {",
          "114:  struct flow_dissector_key_basic basic;",
          "115: };",
          "117: extern struct flow_dissector flow_keys_dissector;",
          "118: extern struct flow_dissector flow_keys_buf_dissector;",
          "",
          "[Removed Lines]",
          "112:  struct flow_dissector_key_addrs addrs;",
          "113:  struct flow_dissector_key_ports ports;",
          "",
          "[Added Lines]",
          "122:  struct flow_dissector_key_control control;",
          "123: #define FLOW_KEYS_HASH_START_FIELD basic",
          "125:  struct flow_dissector_key_ports ports;",
          "126:  struct flow_dissector_key_addrs addrs;",
          "129: #define FLOW_KEYS_HASH_OFFSET  \\",
          "130:  offsetof(struct flow_keys, FLOW_KEYS_HASH_START_FIELD)",
          "",
          "---------------"
        ],
        "include/net/ip.h||include/net/ip.h": [
          "File: include/net/ip.h -> include/net/ip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "360:  struct inet_sock *inet = inet_sk(sk);",
          "361:  struct flow_keys keys;",
          "363:  keys.addrs.src = inet->inet_saddr;",
          "364:  keys.addrs.dst = inet->inet_daddr;",
          "365:  keys.ports.src = inet->inet_sport;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "363:  memset(&keys, 0, sizeof(keys));",
          "",
          "---------------"
        ],
        "include/net/ipv6.h||include/net/ipv6.h": [
          "File: include/net/ipv6.h -> include/net/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "699:  struct ipv6_pinfo *np = inet6_sk(sk);",
          "700:  struct flow_keys keys;",
          "702:  keys.addrs.src = (__force __be32)ipv6_addr_hash(&np->saddr);",
          "703:  keys.addrs.dst = (__force __be32)ipv6_addr_hash(&sk->sk_v6_daddr);",
          "704:  keys.ports.src = inet->inet_sport;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "702:  memset(&keys, 0, sizeof(keys));",
          "",
          "---------------"
        ],
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "57:   flow_dissector->offset[key->key_id] = key->offset;",
          "58:  }",
          "63:  BUG_ON(!skb_flow_dissector_uses_key(flow_dissector,",
          "64:          FLOW_DISSECTOR_KEY_BASIC));",
          "65: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "63:  BUG_ON(!skb_flow_dissector_uses_key(flow_dissector,",
          "64:          FLOW_DISSECTOR_KEY_CONTROL));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:    void *target_container,",
          "121:    void *data, __be16 proto, int nhoff, int hlen)",
          "122: {",
          "123:  struct flow_dissector_key_basic *key_basic;",
          "124:  struct flow_dissector_key_addrs *key_addrs;",
          "125:  struct flow_dissector_key_ports *key_ports;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125:  struct flow_dissector_key_control *key_control;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "132:   hlen = skb_headlen(skb);",
          "133:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "141:  key_control = skb_flow_dissector_target(flow_dissector,",
          "142:       FLOW_DISSECTOR_KEY_CONTROL,",
          "143:       target_container);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "220:    key_basic->n_proto = proto;",
          "221:    key_basic->ip_proto = ip_proto;",
          "224:    if (skb_flow_dissector_uses_key(flow_dissector,",
          "225:        FLOW_DISSECTOR_KEY_PORTS)) {",
          "",
          "[Removed Lines]",
          "222:    key_basic->thoff = (u16)nhoff;",
          "",
          "[Added Lines]",
          "232:    key_control->thoff = (u16)nhoff;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "275:   if (!hdr)",
          "276:    return false;",
          "277:   key_basic->n_proto = proto;",
          "280:   if (skb_flow_dissector_uses_key(flow_dissector,",
          "281:       FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS)) {",
          "",
          "[Removed Lines]",
          "278:   key_basic->thoff = (u16)nhoff;",
          "",
          "[Added Lines]",
          "288:   key_control->thoff = (u16)nhoff;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "288:   return true;",
          "289:  }",
          "290:  case htons(ETH_P_FCOE):",
          "293:  default:",
          "294:   return false;",
          "",
          "[Removed Lines]",
          "291:   key_basic->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
          "",
          "[Added Lines]",
          "301:   key_control->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "346:  key_basic->n_proto = proto;",
          "347:  key_basic->ip_proto = ip_proto;",
          "350:  if (skb_flow_dissector_uses_key(flow_dissector,",
          "351:      FLOW_DISSECTOR_KEY_PORTS)) {",
          "",
          "[Removed Lines]",
          "348:  key_basic->thoff = (u16) nhoff;",
          "",
          "[Added Lines]",
          "358:  key_control->thoff = (u16)nhoff;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "366:  net_get_random_once(&hashrnd, sizeof(hashrnd));",
          "367: }",
          "370: {",
          "372: }",
          "374: static inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)",
          "",
          "[Removed Lines]",
          "369: static __always_inline u32 __flow_hash_3words(u32 a, u32 b, u32 c, u32 keyval)",
          "371:  return jhash_3words(a, b, c, keyval);",
          "",
          "[Added Lines]",
          "379: static __always_inline u32 __flow_hash_words(u32 *words, u32 length, u32 keyval)",
          "380: {",
          "381:  return jhash2(words, length, keyval);",
          "382: }",
          "384: static inline void *flow_keys_hash_start(struct flow_keys *flow)",
          "386:  BUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));",
          "387:  return (void *)flow + FLOW_KEYS_HASH_OFFSET;",
          "388: }",
          "390: static inline size_t flow_keys_hash_length(struct flow_keys *flow)",
          "391: {",
          "392:  BUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));",
          "393:  return (sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) / sizeof(u32);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "383:   swap(keys->ports.src, keys->ports.dst);",
          "384:  }",
          "390:  if (!hash)",
          "391:   hash = 1;",
          "",
          "[Removed Lines]",
          "386:  hash = __flow_hash_3words((__force u32)keys->addrs.dst,",
          "387:       (__force u32)keys->addrs.src,",
          "388:       (__force u32)keys->ports.ports,",
          "389:       keyval);",
          "",
          "[Added Lines]",
          "408:  hash = __flow_hash_words((u32 *)flow_keys_hash_start(keys),",
          "409:      flow_keys_hash_length(keys), keyval);",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "473: u32 __skb_get_poff(const struct sk_buff *skb, void *data,",
          "474:      const struct flow_keys *keys, int hlen)",
          "475: {",
          "478:  switch (keys->basic.ip_proto) {",
          "479:  case IPPROTO_TCP: {",
          "",
          "[Removed Lines]",
          "476:  u32 poff = keys->basic.thoff;",
          "",
          "[Added Lines]",
          "496:  u32 poff = keys->control.thoff;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "536: }",
          "538: static const struct flow_dissector_key flow_keys_dissector_keys[] = {",
          "539:  {",
          "540:   .key_id = FLOW_DISSECTOR_KEY_BASIC,",
          "541:   .offset = offsetof(struct flow_keys, basic),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "559:  {",
          "560:   .key_id = FLOW_DISSECTOR_KEY_CONTROL,",
          "561:   .offset = offsetof(struct flow_keys, control),",
          "562:  },",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "555: };",
          "557: static const struct flow_dissector_key flow_keys_buf_dissector_keys[] = {",
          "558:  {",
          "559:   .key_id = FLOW_DISSECTOR_KEY_BASIC,",
          "560:   .offset = offsetof(struct flow_keys, basic),",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "582:  {",
          "583:   .key_id = FLOW_DISSECTOR_KEY_CONTROL,",
          "584:   .offset = offsetof(struct flow_keys, control),",
          "585:  },",
          "",
          "---------------"
        ],
        "net/sched/cls_flower.c||net/sched/cls_flower.c": [
          "File: net/sched/cls_flower.c -> net/sched/cls_flower.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "26: struct fl_flow_key {",
          "27:  int indev_ifindex;",
          "28:  struct flow_dissector_key_basic basic;",
          "29:  struct flow_dissector_key_eth_addrs eth;",
          "30:  union {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:  struct flow_dissector_key_control control;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "347:  struct flow_dissector_key keys[FLOW_DISSECTOR_KEY_MAX];",
          "348:  size_t cnt = 0;",
          "350:  FL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_BASIC, basic);",
          "351:  FL_KEY_SET_IF_IN_RANGE(mask, keys, cnt,",
          "352:           FLOW_DISSECTOR_KEY_ETH_ADDRS, eth);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "351:  FL_KEY_SET(keys, cnt, FLOW_DISSECTOR_KEY_CONTROL, control);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "6a74fcf426f51aaa569f0b973d10ac20468df238",
      "candidate_info": {
        "commit_hash": "6a74fcf426f51aaa569f0b973d10ac20468df238",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/6a74fcf426f51aaa569f0b973d10ac20468df238",
        "files": [
          "net/core/flow_dissector.c"
        ],
        "message": "flow_dissector: add support for dst, hop-by-hop and routing ext hdrs\n\nIf dst, hop-by-hop or routing extension headers are present determine\nlength of the options and skip over them in flow dissection.\n\nSigned-off-by: Tom Herbert <tom@herbertland.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/core/flow_dissector.c||net/core/flow_dissector.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "327:   return false;",
          "328:  }",
          "330:  switch (ip_proto) {",
          "331:  case IPPROTO_GRE: {",
          "332:   struct gre_hdr {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "330: ip_proto_again:",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "383:   }",
          "384:   goto again;",
          "385:  }",
          "386:  case IPPROTO_IPIP:",
          "387:   proto = htons(ETH_P_IP);",
          "388:   goto ip;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "387:  case NEXTHDR_HOP:",
          "388:  case NEXTHDR_ROUTING:",
          "389:  case NEXTHDR_DEST: {",
          "390:   u8 _opthdr[2], *opthdr;",
          "392:   if (proto != htons(ETH_P_IPV6))",
          "393:    break;",
          "395:   opthdr = __skb_header_pointer(skb, nhoff, sizeof(_opthdr),",
          "396:            data, hlen, &_opthdr);",
          "398:   ip_proto = _opthdr[0];",
          "399:   nhoff += (_opthdr[1] + 1) << 3;",
          "401:   goto ip_proto_again;",
          "402:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "06635a35d13d42b95422bba6633f175245cc644e",
      "candidate_info": {
        "commit_hash": "06635a35d13d42b95422bba6633f175245cc644e",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/06635a35d13d42b95422bba6633f175245cc644e",
        "files": [
          "drivers/net/bonding/bond_main.c",
          "drivers/net/ethernet/cisco/enic/enic_clsf.c",
          "drivers/net/ethernet/cisco/enic/enic_ethtool.c",
          "drivers/net/hyperv/netvsc_drv.c",
          "include/linux/skbuff.h",
          "include/net/flow_dissector.h",
          "include/net/ip.h",
          "include/net/ipv6.h",
          "net/core/flow_dissector.c",
          "net/ethernet/eth.c",
          "net/sched/cls_flow.c",
          "net/sched/sch_choke.c"
        ],
        "message": "flow_dissect: use programable dissector in skb_flow_dissect and friends\n\nSigned-off-by: Jiri Pirko <jiri@resnulli.us>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "drivers/net/bonding/bond_main.c||drivers/net/bonding/bond_main.c",
          "drivers/net/ethernet/cisco/enic/enic_clsf.c||drivers/net/ethernet/cisco/enic/enic_clsf.c",
          "drivers/net/ethernet/cisco/enic/enic_ethtool.c||drivers/net/ethernet/cisco/enic/enic_ethtool.c",
          "drivers/net/hyperv/netvsc_drv.c||drivers/net/hyperv/netvsc_drv.c",
          "include/linux/skbuff.h||include/linux/skbuff.h",
          "include/net/flow_dissector.h||include/net/flow_dissector.h",
          "include/net/ip.h||include/net/ip.h",
          "include/net/ipv6.h||include/net/ipv6.h",
          "net/core/flow_dissector.c||net/core/flow_dissector.c",
          "net/ethernet/eth.c||net/ethernet/eth.c",
          "net/sched/cls_flow.c||net/sched/cls_flow.c",
          "net/sched/sch_choke.c||net/sched/sch_choke.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "drivers/net/bonding/bond_main.c||drivers/net/bonding/bond_main.c": [
          "File: drivers/net/bonding/bond_main.c -> drivers/net/bonding/bond_main.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3051:  int noff, proto = -1;",
          "3053:  if (bond->params.xmit_policy > BOND_XMIT_POLICY_LAYER23)",
          "3057:  noff = skb_network_offset(skb);",
          "3058:  if (skb->protocol == htons(ETH_P_IP)) {",
          "3059:   if (unlikely(!pskb_may_pull(skb, noff + sizeof(*iph))))",
          "3060:    return false;",
          "3061:   iph = ip_hdr(skb);",
          "3064:   noff += iph->ihl << 2;",
          "3065:   if (!ip_is_fragment(iph))",
          "3066:    proto = iph->protocol;",
          "",
          "[Removed Lines]",
          "3054:   return skb_flow_dissect(skb, fk);",
          "3056:  fk->ports = 0;",
          "3062:   fk->src = iph->saddr;",
          "3063:   fk->dst = iph->daddr;",
          "",
          "[Added Lines]",
          "3054:   return skb_flow_dissect_flow_keys(skb, fk);",
          "3056:  fk->ports.ports = 0;",
          "3062:   fk->addrs.src = iph->saddr;",
          "3063:   fk->addrs.dst = iph->daddr;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3068:   if (unlikely(!pskb_may_pull(skb, noff + sizeof(*iph6))))",
          "3069:    return false;",
          "3070:   iph6 = ipv6_hdr(skb);",
          "3073:   noff += sizeof(*iph6);",
          "3074:   proto = iph6->nexthdr;",
          "3075:  } else {",
          "3076:   return false;",
          "3077:  }",
          "3078:  if (bond->params.xmit_policy == BOND_XMIT_POLICY_LAYER34 && proto >= 0)",
          "3081:  return true;",
          "3082: }",
          "",
          "[Removed Lines]",
          "3071:   fk->src = (__force __be32)ipv6_addr_hash(&iph6->saddr);",
          "3072:   fk->dst = (__force __be32)ipv6_addr_hash(&iph6->daddr);",
          "3079:   fk->ports = skb_flow_get_ports(skb, noff, proto);",
          "",
          "[Added Lines]",
          "3071:   fk->addrs.src = (__force __be32)ipv6_addr_hash(&iph6->saddr);",
          "3072:   fk->addrs.dst = (__force __be32)ipv6_addr_hash(&iph6->daddr);",
          "3079:   fk->ports.ports = skb_flow_get_ports(skb, noff, proto);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3102:      bond->params.xmit_policy == BOND_XMIT_POLICY_ENCAP23)",
          "3103:   hash = bond_eth_hash(skb);",
          "3104:  else",
          "3107:  hash ^= (hash >> 16);",
          "3108:  hash ^= (hash >> 8);",
          "",
          "[Removed Lines]",
          "3105:   hash = (__force u32)flow.ports;",
          "3106:  hash ^= (__force u32)flow.dst ^ (__force u32)flow.src;",
          "",
          "[Added Lines]",
          "3105:   hash = (__force u32)flow.ports.ports;",
          "3106:  hash ^= (__force u32)flow.addrs.dst ^ (__force u32)flow.addrs.src;",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/cisco/enic/enic_clsf.c||drivers/net/ethernet/cisco/enic/enic_clsf.c": [
          "File: drivers/net/ethernet/cisco/enic/enic_clsf.c -> drivers/net/ethernet/cisco/enic/enic_clsf.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "22:  int res;",
          "23:  struct filter data;",
          "26:  case IPPROTO_TCP:",
          "27:   data.u.ipv4.protocol = PROTO_TCP;",
          "28:   break;",
          "",
          "[Removed Lines]",
          "25:  switch (keys->ip_proto) {",
          "",
          "[Added Lines]",
          "25:  switch (keys->basic.ip_proto) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "33:   return -EPROTONOSUPPORT;",
          "34:  };",
          "35:  data.type = FILTER_IPV4_5TUPLE;",
          "40:  data.u.ipv4.flags = FILTER_FIELDS_IPV4_5TUPLE;",
          "42:  spin_lock_bh(&enic->devcmd_lock);",
          "",
          "[Removed Lines]",
          "36:  data.u.ipv4.src_addr = ntohl(keys->src);",
          "37:  data.u.ipv4.dst_addr = ntohl(keys->dst);",
          "38:  data.u.ipv4.src_port = ntohs(keys->port16[0]);",
          "39:  data.u.ipv4.dst_port = ntohs(keys->port16[1]);",
          "",
          "[Added Lines]",
          "36:  data.u.ipv4.src_addr = ntohl(keys->addrs.src);",
          "37:  data.u.ipv4.dst_addr = ntohl(keys->addrs.dst);",
          "38:  data.u.ipv4.src_port = ntohs(keys->ports.port16[0]);",
          "39:  data.u.ipv4.dst_port = ntohs(keys->ports.port16[1]);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "158:  struct enic_rfs_fltr_node *tpos;",
          "160:  hlist_for_each_entry(tpos, h, node)",
          "166:    return tpos;",
          "167:  return NULL;",
          "168: }",
          "",
          "[Removed Lines]",
          "161:   if (tpos->keys.src == k->src &&",
          "162:       tpos->keys.dst == k->dst &&",
          "163:       tpos->keys.ports == k->ports &&",
          "164:       tpos->keys.ip_proto == k->ip_proto &&",
          "165:       tpos->keys.n_proto == k->n_proto)",
          "",
          "[Added Lines]",
          "161:   if (tpos->keys.addrs.src == k->addrs.src &&",
          "162:       tpos->keys.addrs.dst == k->addrs.dst &&",
          "163:       tpos->keys.ports.ports == k->ports.ports &&",
          "164:       tpos->keys.basic.ip_proto == k->basic.ip_proto &&",
          "165:       tpos->keys.basic.n_proto == k->basic.n_proto)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "177:  int res, i;",
          "179:  enic = netdev_priv(dev);",
          "183:   return -EPROTONOSUPPORT;",
          "185:  tbl_idx = skb_get_hash_raw(skb) & ENIC_RFS_FLW_MASK;",
          "",
          "[Removed Lines]",
          "180:  res = skb_flow_dissect(skb, &keys);",
          "181:  if (!res || keys.n_proto != htons(ETH_P_IP) ||",
          "182:      (keys.ip_proto != IPPROTO_TCP && keys.ip_proto != IPPROTO_UDP))",
          "",
          "[Added Lines]",
          "180:  res = skb_flow_dissect_flow_keys(skb, &keys);",
          "181:  if (!res || keys.basic.n_proto != htons(ETH_P_IP) ||",
          "182:      (keys.basic.ip_proto != IPPROTO_TCP &&",
          "183:       keys.basic.ip_proto != IPPROTO_UDP))",
          "",
          "---------------"
        ],
        "drivers/net/ethernet/cisco/enic/enic_ethtool.c||drivers/net/ethernet/cisco/enic/enic_ethtool.c": [
          "File: drivers/net/ethernet/cisco/enic/enic_ethtool.c -> drivers/net/ethernet/cisco/enic/enic_ethtool.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "334:  n = htbl_fltr_search(enic, (u16)fsp->location);",
          "335:  if (!n)",
          "336:   return -EINVAL;",
          "338:  case IPPROTO_TCP:",
          "339:   fsp->flow_type = TCP_V4_FLOW;",
          "340:   break;",
          "",
          "[Removed Lines]",
          "337:  switch (n->keys.ip_proto) {",
          "",
          "[Added Lines]",
          "337:  switch (n->keys.basic.ip_proto) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "346:   break;",
          "347:  }",
          "350:  fsp->m_u.tcp_ip4_spec.ip4src = (__u32)~0;",
          "353:  fsp->m_u.tcp_ip4_spec.ip4dst = (__u32)~0;",
          "356:  fsp->m_u.tcp_ip4_spec.psrc = (__u16)~0;",
          "359:  fsp->m_u.tcp_ip4_spec.pdst = (__u16)~0;",
          "361:  fsp->ring_cookie = n->rq_id;",
          "",
          "[Removed Lines]",
          "349:  fsp->h_u.tcp_ip4_spec.ip4src = n->keys.src;",
          "352:  fsp->h_u.tcp_ip4_spec.ip4dst = n->keys.dst;",
          "355:  fsp->h_u.tcp_ip4_spec.psrc = n->keys.port16[0];",
          "358:  fsp->h_u.tcp_ip4_spec.pdst = n->keys.port16[1];",
          "",
          "[Added Lines]",
          "349:  fsp->h_u.tcp_ip4_spec.ip4src = n->keys.addrs.src;",
          "352:  fsp->h_u.tcp_ip4_spec.ip4dst = n->keys.addrs.dst;",
          "355:  fsp->h_u.tcp_ip4_spec.psrc = n->keys.ports.port16[0];",
          "358:  fsp->h_u.tcp_ip4_spec.pdst = n->keys.ports.port16[1];",
          "",
          "---------------"
        ],
        "drivers/net/hyperv/netvsc_drv.c||drivers/net/hyperv/netvsc_drv.c": [
          "File: drivers/net/hyperv/netvsc_drv.c -> drivers/net/hyperv/netvsc_drv.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "196:  struct flow_keys flow;",
          "197:  int data_len;",
          "202:   return false;",
          "205:   data_len = 12;",
          "206:  else",
          "207:   data_len = 8;",
          "",
          "[Removed Lines]",
          "199:  if (!skb_flow_dissect(skb, &flow) ||",
          "200:      !(flow.n_proto == htons(ETH_P_IP) ||",
          "201:        flow.n_proto == htons(ETH_P_IPV6)))",
          "204:  if (flow.ip_proto == IPPROTO_TCP)",
          "",
          "[Added Lines]",
          "199:  if (!skb_flow_dissect_flow_keys(skb, &flow) ||",
          "200:      !(flow.basic.n_proto == htons(ETH_P_IP) ||",
          "201:        flow.basic.n_proto == htons(ETH_P_IPV6)))",
          "204:  if (flow.basic.ip_proto == IPPROTO_TCP)",
          "",
          "---------------"
        ],
        "include/linux/skbuff.h||include/linux/skbuff.h": [
          "File: include/linux/skbuff.h -> include/linux/skbuff.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "1936:  if (skb_transport_header_was_set(skb))",
          "1937:   return;",
          "1940:  else",
          "1941:   skb_set_transport_header(skb, offset_hint);",
          "1942: }",
          "",
          "[Removed Lines]",
          "1938:  else if (skb_flow_dissect(skb, &keys))",
          "1939:   skb_set_transport_header(skb, keys.thoff);",
          "",
          "[Added Lines]",
          "1938:  else if (skb_flow_dissect_flow_keys(skb, &keys))",
          "1939:   skb_set_transport_header(skb, keys.basic.thoff);",
          "",
          "---------------"
        ],
        "include/net/flow_dissector.h||include/net/flow_dissector.h": [
          "File: include/net/flow_dissector.h -> include/net/flow_dissector.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "59:  unsigned short int offset[FLOW_DISSECTOR_KEY_MAX];",
          "60: };",
          "88: void skb_flow_dissector_init(struct flow_dissector *flow_dissector,",
          "89:         const struct flow_dissector_key *key,",
          "90:         unsigned int key_count);",
          "92:    void *data, __be16 proto, int nhoff, int hlen);",
          "94: static inline bool skb_flow_dissect(const struct sk_buff *skb,",
          "96: {",
          "98: }",
          "100: __be32 __skb_flow_get_ports(const struct sk_buff *skb, int thoff, u8 ip_proto,",
          "",
          "[Removed Lines]",
          "75: struct flow_keys {",
          "77:  __be32 src;",
          "78:  __be32 dst;",
          "79:  union {",
          "80:   __be32 ports;",
          "81:   __be16 port16[2];",
          "82:  };",
          "83:  u16 thoff;",
          "84:  __be16 n_proto;",
          "85:  u8 ip_proto;",
          "86: };",
          "91: bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,",
          "95:         struct flow_keys *flow)",
          "97:  return __skb_flow_dissect(skb, flow, NULL, 0, 0, 0);",
          "",
          "[Added Lines]",
          "66: bool __skb_flow_dissect(const struct sk_buff *skb,",
          "67:    struct flow_dissector *flow_dissector,",
          "68:    void *target_container,",
          "72:         struct flow_dissector *flow_dissector,",
          "73:         void *target_container)",
          "74: {",
          "75:  return __skb_flow_dissect(skb, flow_dissector, target_container,",
          "76:       NULL, 0, 0, 0);",
          "77: }",
          "79: struct flow_keys {",
          "80:  struct flow_dissector_key_addrs addrs;",
          "81:  struct flow_dissector_key_ports ports;",
          "82:  struct flow_dissector_key_basic basic;",
          "83: };",
          "85: extern struct flow_dissector flow_keys_dissector;",
          "86: extern struct flow_dissector flow_keys_buf_dissector;",
          "88: static inline bool skb_flow_dissect_flow_keys(const struct sk_buff *skb,",
          "89:            struct flow_keys *flow)",
          "90: {",
          "91:  memset(flow, 0, sizeof(*flow));",
          "92:  return __skb_flow_dissect(skb, &flow_keys_dissector, flow,",
          "93:       NULL, 0, 0, 0);",
          "94: }",
          "96: static inline bool skb_flow_dissect_flow_keys_buf(struct flow_keys *flow,",
          "97:         void *data, __be16 proto,",
          "98:         int nhoff, int hlen)",
          "100:  memset(flow, 0, sizeof(*flow));",
          "101:  return __skb_flow_dissect(NULL, &flow_keys_buf_dissector, flow,",
          "102:       data, proto, nhoff, hlen);",
          "",
          "---------------"
        ],
        "include/net/ip.h||include/net/ip.h": [
          "File: include/net/ip.h -> include/net/ip.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "360:  struct inet_sock *inet = inet_sk(sk);",
          "361:  struct flow_keys keys;",
          "368:  sk->sk_txhash = flow_hash_from_keys(&keys);",
          "369: }",
          "",
          "[Removed Lines]",
          "363:  keys.src = inet->inet_saddr;",
          "364:  keys.dst = inet->inet_daddr;",
          "365:  keys.port16[0] = inet->inet_sport;",
          "366:  keys.port16[1] = inet->inet_dport;",
          "",
          "[Added Lines]",
          "363:  keys.addrs.src = inet->inet_saddr;",
          "364:  keys.addrs.dst = inet->inet_daddr;",
          "365:  keys.ports.port16[0] = inet->inet_sport;",
          "366:  keys.ports.port16[1] = inet->inet_dport;",
          "",
          "---------------"
        ],
        "include/net/ipv6.h||include/net/ipv6.h": [
          "File: include/net/ipv6.h -> include/net/ipv6.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "698:  struct ipv6_pinfo *np = inet6_sk(sk);",
          "699:  struct flow_keys keys;",
          "706:  sk->sk_txhash = flow_hash_from_keys(&keys);",
          "707: }",
          "",
          "[Removed Lines]",
          "701:  keys.src = (__force __be32)ipv6_addr_hash(&np->saddr);",
          "702:  keys.dst = (__force __be32)ipv6_addr_hash(&sk->sk_v6_daddr);",
          "703:  keys.port16[0] = inet->inet_sport;",
          "704:  keys.port16[1] = inet->inet_dport;",
          "",
          "[Added Lines]",
          "701:  keys.addrs.src = (__force __be32)ipv6_addr_hash(&np->saddr);",
          "702:  keys.addrs.dst = (__force __be32)ipv6_addr_hash(&sk->sk_v6_daddr);",
          "703:  keys.ports.port16[0] = inet->inet_sport;",
          "704:  keys.ports.port16[1] = inet->inet_dport;",
          "",
          "---------------"
        ],
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: #include <linux/if_tunnel.h>",
          "14: #include <linux/if_pppox.h>",
          "15: #include <linux/ppp_defs.h>",
          "16: #include <net/flow_dissector.h>",
          "17: #include <scsi/fc/fc_fcoe.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: #include <linux/stddef.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "63: }",
          "64: EXPORT_SYMBOL(skb_flow_dissector_init);",
          "",
          "[Removed Lines]",
          "70: static void iph_to_flow_copy_addrs(struct flow_keys *flow, const struct iphdr *iph)",
          "71: {",
          "72:  BUILD_BUG_ON(offsetof(typeof(*flow), dst) !=",
          "73:        offsetof(typeof(*flow), src) + sizeof(flow->src));",
          "74:  memcpy(&flow->src, &iph->saddr, sizeof(flow->src) + sizeof(flow->dst));",
          "75: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "123:    void *data, __be16 proto, int nhoff, int hlen)",
          "124: {",
          "125:  u8 ip_proto;",
          "127:  if (!data) {",
          "",
          "[Removed Lines]",
          "122: bool __skb_flow_dissect(const struct sk_buff *skb, struct flow_keys *flow,",
          "",
          "[Added Lines]",
          "117: bool __skb_flow_dissect(const struct sk_buff *skb,",
          "118:    struct flow_dissector *flow_dissector,",
          "119:    void *target_container,",
          "122:  struct flow_dissector_key_basic *key_basic;",
          "123:  struct flow_dissector_key_addrs *key_addrs;",
          "124:  struct flow_dissector_key_ports *key_ports;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "131:   hlen = skb_headlen(skb);",
          "132:  }",
          "136: again:",
          "137:  switch (proto) {",
          "",
          "[Removed Lines]",
          "134:  memset(flow, 0, sizeof(*flow));",
          "",
          "[Added Lines]",
          "137:  key_basic = skb_flow_dissector_target(flow_dissector,",
          "138:            FLOW_DISSECTOR_KEY_BASIC,",
          "139:            target_container);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "148:   if (ip_is_fragment(iph))",
          "149:    ip_proto = 0;",
          "156:    break;",
          "159:   break;",
          "160:  }",
          "161:  case htons(ETH_P_IPV6): {",
          "",
          "[Removed Lines]",
          "155:   if (!skb)",
          "158:   iph_to_flow_copy_addrs(flow, iph);",
          "",
          "[Added Lines]",
          "156:   if (!skb_flow_dissector_uses_key(flow_dissector,",
          "157:        FLOW_DISSECTOR_KEY_IPV4_ADDRS))",
          "159:   key_addrs = skb_flow_dissector_target(flow_dissector,",
          "160:             FLOW_DISSECTOR_KEY_IPV4_ADDRS,",
          "161:             target_container);",
          "162:   memcpy(key_addrs, &iph->saddr, sizeof(*key_addrs));",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "171:   ip_proto = iph->nexthdr;",
          "172:   nhoff += sizeof(struct ipv6hdr);",
          "176:    break;",
          "181:   flow_label = ip6_flowlabel(iph);",
          "182:   if (flow_label) {",
          "",
          "[Removed Lines]",
          "175:   if (!skb)",
          "178:   flow->src = (__force __be32)ipv6_addr_hash(&iph->saddr);",
          "179:   flow->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);",
          "",
          "[Added Lines]",
          "178:   if (!skb_flow_dissector_uses_key(flow_dissector,",
          "179:        FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS))",
          "181:   key_addrs = skb_flow_dissector_target(flow_dissector,",
          "182:             FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS,",
          "183:             target_container);",
          "185:   key_addrs->src = (__force __be32)ipv6_addr_hash(&iph->saddr);",
          "186:   key_addrs->dst = (__force __be32)ipv6_addr_hash(&iph->daddr);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "192:    return true;",
          "193:   }",
          "",
          "[Removed Lines]",
          "187:    flow->n_proto = proto;",
          "188:    flow->ip_proto = ip_proto;",
          "189:    flow->ports = flow_label;",
          "190:    flow->thoff = (u16)nhoff;",
          "",
          "[Added Lines]",
          "195:    key_basic->n_proto = proto;",
          "196:    key_basic->ip_proto = ip_proto;",
          "197:    key_basic->thoff = (u16)nhoff;",
          "199:    if (!skb_flow_dissector_uses_key(flow_dissector,",
          "200:         FLOW_DISSECTOR_KEY_PORTS))",
          "201:     break;",
          "202:    key_ports = skb_flow_dissector_target(flow_dissector,",
          "203:              FLOW_DISSECTOR_KEY_PORTS,",
          "204:              target_container);",
          "205:    key_ports->ports = flow_label;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "234:   hdr = __skb_header_pointer(skb, nhoff, sizeof(_hdr), data, hlen, &_hdr);",
          "235:   if (!hdr)",
          "236:    return false;",
          "241:   return true;",
          "242:  }",
          "243:  case htons(ETH_P_FCOE):",
          "246:  default:",
          "247:   return false;",
          "",
          "[Removed Lines]",
          "237:   flow->src = hdr->srcnode;",
          "238:   flow->dst = 0;",
          "239:   flow->n_proto = proto;",
          "240:   flow->thoff = (u16)nhoff;",
          "244:   flow->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
          "",
          "[Added Lines]",
          "252:   key_basic->n_proto = proto;",
          "253:   key_basic->thoff = (u16)nhoff;",
          "255:   if (skb_flow_dissector_uses_key(flow_dissector,",
          "256:       FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS)) {",
          "257:    return true;",
          "258:    key_addrs = skb_flow_dissector_target(flow_dissector,",
          "259:              FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS,",
          "260:              target_container);",
          "261:    key_addrs->src = hdr->srcnode;",
          "262:    key_addrs->dst = 0;",
          "263:   }",
          "267:   key_basic->thoff = (u16)(nhoff + FCOE_HEADER_LEN);",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "296:   break;",
          "297:  }",
          "308:  return true;",
          "309: }",
          "",
          "[Removed Lines]",
          "299:  flow->n_proto = proto;",
          "300:  flow->ip_proto = ip_proto;",
          "301:  flow->thoff = (u16) nhoff;",
          "304:  if (skb)",
          "305:   flow->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,",
          "306:          data, hlen);",
          "",
          "[Added Lines]",
          "325:  key_basic = skb_flow_dissector_target(flow_dissector,",
          "326:            FLOW_DISSECTOR_KEY_BASIC,",
          "327:            target_container);",
          "328:  key_basic->n_proto = proto;",
          "329:  key_basic->ip_proto = ip_proto;",
          "330:  key_basic->thoff = (u16) nhoff;",
          "332:  if (skb_flow_dissector_uses_key(flow_dissector,",
          "333:      FLOW_DISSECTOR_KEY_PORTS)) {",
          "334:   key_ports = skb_flow_dissector_target(flow_dissector,",
          "335:             FLOW_DISSECTOR_KEY_PORTS,",
          "336:             target_container);",
          "337:   key_ports->ports = __skb_flow_get_ports(skb, nhoff, ip_proto,",
          "338:        data, hlen);",
          "339:  }",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "325:  u32 hash;",
          "333:  }",
          "338:       keyval);",
          "339:  if (!hash)",
          "340:   hash = 1;",
          "",
          "[Removed Lines]",
          "328:  if (((__force u32)keys->dst < (__force u32)keys->src) ||",
          "329:      (((__force u32)keys->dst == (__force u32)keys->src) &&",
          "330:       ((__force u16)keys->port16[1] < (__force u16)keys->port16[0]))) {",
          "331:   swap(keys->dst, keys->src);",
          "332:   swap(keys->port16[0], keys->port16[1]);",
          "335:  hash = __flow_hash_3words((__force u32)keys->dst,",
          "336:       (__force u32)keys->src,",
          "337:       (__force u32)keys->ports,",
          "",
          "[Added Lines]",
          "361:  if (((__force u32)keys->addrs.dst < (__force u32)keys->addrs.src) ||",
          "362:      (((__force u32)keys->addrs.dst == (__force u32)keys->addrs.src) &&",
          "363:       ((__force u16)keys->ports.port16[1] < (__force u16)keys->ports.port16[0]))) {",
          "364:   swap(keys->addrs.dst, keys->addrs.src);",
          "365:   swap(keys->ports.port16[0], keys->ports.port16[1]);",
          "368:  hash = __flow_hash_3words((__force u32)keys->addrs.dst,",
          "369:       (__force u32)keys->addrs.src,",
          "370:       (__force u32)keys->ports.ports,",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "352: static inline u32 ___skb_get_hash(const struct sk_buff *skb,",
          "353:       struct flow_keys *keys, u32 keyval)",
          "354: {",
          "356:   return 0;",
          "358:  return __flow_hash_from_keys(keys, keyval);",
          "",
          "[Removed Lines]",
          "355:  if (!skb_flow_dissect(skb, keys))",
          "",
          "[Added Lines]",
          "388:  if (!skb_flow_dissect_flow_keys(skb, keys))",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "378:  memset(digest, 0, sizeof(*digest));",
          "385: }",
          "386: EXPORT_SYMBOL(make_flow_keys_digest);",
          "",
          "[Removed Lines]",
          "380:  data->n_proto = flow->n_proto;",
          "381:  data->ip_proto = flow->ip_proto;",
          "382:  data->ports = flow->ports;",
          "383:  data->src = flow->src;",
          "384:  data->dst = flow->dst;",
          "",
          "[Added Lines]",
          "413:  data->n_proto = flow->basic.n_proto;",
          "414:  data->ip_proto = flow->basic.ip_proto;",
          "415:  data->ports = flow->ports.ports;",
          "416:  data->src = flow->addrs.src;",
          "417:  data->dst = flow->addrs.dst;",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "404:  hash = ___skb_get_hash(skb, &keys, hashrnd);",
          "405:  if (!hash)",
          "406:   return;",
          "408:   skb->l4_hash = 1;",
          "409:  skb->sw_hash = 1;",
          "410:  skb->hash = hash;",
          "",
          "[Removed Lines]",
          "407:  if (keys.ports)",
          "",
          "[Added Lines]",
          "440:  if (keys.ports.ports)",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "422: u32 __skb_get_poff(const struct sk_buff *skb, void *data,",
          "423:      const struct flow_keys *keys, int hlen)",
          "424: {",
          "428:  case IPPROTO_TCP: {",
          "430:   const u8 *doff;",
          "",
          "[Removed Lines]",
          "425:  u32 poff = keys->thoff;",
          "427:  switch (keys->ip_proto) {",
          "",
          "[Added Lines]",
          "458:  u32 poff = keys->basic.thoff;",
          "460:  switch (keys->basic.ip_proto) {",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "478: {",
          "479:  struct flow_keys keys;",
          "482:   return 0;",
          "484:  return __skb_get_poff(skb, skb->data, &keys, skb_headlen(skb));",
          "485: }",
          "",
          "[Removed Lines]",
          "481:  if (!skb_flow_dissect(skb, &keys))",
          "",
          "[Added Lines]",
          "514:  if (!skb_flow_dissect_flow_keys(skb, &keys))",
          "520: static const struct flow_dissector_key flow_keys_dissector_keys[] = {",
          "521:  {",
          "522:   .key_id = FLOW_DISSECTOR_KEY_BASIC,",
          "523:   .offset = offsetof(struct flow_keys, basic),",
          "524:  },",
          "525:  {",
          "526:   .key_id = FLOW_DISSECTOR_KEY_IPV4_ADDRS,",
          "527:   .offset = offsetof(struct flow_keys, addrs),",
          "528:  },",
          "529:  {",
          "530:   .key_id = FLOW_DISSECTOR_KEY_IPV6_HASH_ADDRS,",
          "531:   .offset = offsetof(struct flow_keys, addrs),",
          "532:  },",
          "533:  {",
          "534:   .key_id = FLOW_DISSECTOR_KEY_PORTS,",
          "535:   .offset = offsetof(struct flow_keys, ports),",
          "536:  },",
          "537: };",
          "539: static const struct flow_dissector_key flow_keys_buf_dissector_keys[] = {",
          "540:  {",
          "541:   .key_id = FLOW_DISSECTOR_KEY_BASIC,",
          "542:   .offset = offsetof(struct flow_keys, basic),",
          "543:  },",
          "544: };",
          "546: struct flow_dissector flow_keys_dissector __read_mostly;",
          "547: EXPORT_SYMBOL(flow_keys_dissector);",
          "549: struct flow_dissector flow_keys_buf_dissector __read_mostly;",
          "551: static int __init init_default_flow_dissectors(void)",
          "552: {",
          "553:  skb_flow_dissector_init(&flow_keys_dissector,",
          "554:     flow_keys_dissector_keys,",
          "555:     ARRAY_SIZE(flow_keys_dissector_keys));",
          "556:  skb_flow_dissector_init(&flow_keys_buf_dissector,",
          "557:     flow_keys_buf_dissector_keys,",
          "558:     ARRAY_SIZE(flow_keys_buf_dissector_keys));",
          "559:  return 0;",
          "560: }",
          "562: late_initcall_sync(init_default_flow_dissectors);",
          "",
          "---------------"
        ],
        "net/ethernet/eth.c||net/ethernet/eth.c": [
          "File: net/ethernet/eth.c -> net/ethernet/eth.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:   return len;",
          "139:  return min_t(u32, __skb_get_poff(NULL, data, &keys, len), len);",
          "",
          "[Removed Lines]",
          "134:  if (!__skb_flow_dissect(NULL, &keys, data,",
          "135:     eth->h_proto, sizeof(*eth), len))",
          "136:   return max_t(u32, keys.thoff, sizeof(*eth));",
          "",
          "[Added Lines]",
          "134:  if (!skb_flow_dissect_flow_keys_buf(&keys, data, eth->h_proto,",
          "135:          sizeof(*eth), len))",
          "136:   return max_t(u32, keys.basic.thoff, sizeof(*eth));",
          "",
          "---------------"
        ],
        "net/sched/cls_flow.c||net/sched/cls_flow.c": [
          "File: net/sched/cls_flow.c -> net/sched/cls_flow.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69: static u32 flow_get_src(const struct sk_buff *skb, const struct flow_keys *flow)",
          "70: {",
          "73:  return addr_fold(skb->sk);",
          "74: }",
          "76: static u32 flow_get_dst(const struct sk_buff *skb, const struct flow_keys *flow)",
          "77: {",
          "80:  return addr_fold(skb_dst(skb)) ^ (__force u16) tc_skb_protocol(skb);",
          "81: }",
          "83: static u32 flow_get_proto(const struct sk_buff *skb, const struct flow_keys *flow)",
          "84: {",
          "86: }",
          "88: static u32 flow_get_proto_src(const struct sk_buff *skb, const struct flow_keys *flow)",
          "89: {",
          "93:  return addr_fold(skb->sk);",
          "94: }",
          "96: static u32 flow_get_proto_dst(const struct sk_buff *skb, const struct flow_keys *flow)",
          "97: {",
          "101:  return addr_fold(skb_dst(skb)) ^ (__force u16) tc_skb_protocol(skb);",
          "102: }",
          "",
          "[Removed Lines]",
          "71:  if (flow->src)",
          "72:   return ntohl(flow->src);",
          "78:  if (flow->dst)",
          "79:   return ntohl(flow->dst);",
          "85:  return flow->ip_proto;",
          "90:  if (flow->ports)",
          "91:   return ntohs(flow->port16[0]);",
          "98:  if (flow->ports)",
          "99:   return ntohs(flow->port16[1]);",
          "",
          "[Added Lines]",
          "71:  if (flow->addrs.src)",
          "72:   return ntohl(flow->addrs.src);",
          "78:  if (flow->addrs.dst)",
          "79:   return ntohl(flow->addrs.dst);",
          "85:  return flow->basic.ip_proto;",
          "90:  if (flow->ports.ports)",
          "91:   return ntohs(flow->ports.port16[0]);",
          "98:  if (flow->ports.ports)",
          "99:   return ntohs(flow->ports.port16[1]);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "296:   keymask = f->keymask;",
          "297:   if (keymask & FLOW_KEYS_NEEDED)",
          "300:   for (n = 0; n < f->nkeys; n++) {",
          "301:    key = ffs(keymask) - 1;",
          "",
          "[Removed Lines]",
          "298:    skb_flow_dissect(skb, &flow_keys);",
          "",
          "[Added Lines]",
          "298:    skb_flow_dissect_flow_keys(skb, &flow_keys);",
          "",
          "---------------"
        ],
        "net/sched/sch_choke.c||net/sched/sch_choke.c": [
          "File: net/sched/sch_choke.c -> net/sched/sch_choke.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "171:  if (!choke_skb_cb(skb1)->keys_valid) {",
          "172:   choke_skb_cb(skb1)->keys_valid = 1;",
          "174:   make_flow_keys_digest(&choke_skb_cb(skb1)->keys, &temp);",
          "175:  }",
          "177:  if (!choke_skb_cb(skb2)->keys_valid) {",
          "178:   choke_skb_cb(skb2)->keys_valid = 1;",
          "180:   make_flow_keys_digest(&choke_skb_cb(skb2)->keys, &temp);",
          "181:  }",
          "",
          "[Removed Lines]",
          "173:   skb_flow_dissect(skb1, &temp);",
          "179:   skb_flow_dissect(skb2, &temp);",
          "",
          "[Added Lines]",
          "173:   skb_flow_dissect_flow_keys(skb1, &temp);",
          "179:   skb_flow_dissect_flow_keys(skb2, &temp);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "d5709f7ab77679d407a7687fc5ad7cc7442cc651",
      "candidate_info": {
        "commit_hash": "d5709f7ab77679d407a7687fc5ad7cc7442cc651",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d5709f7ab77679d407a7687fc5ad7cc7442cc651",
        "files": [
          "net/core/flow_dissector.c"
        ],
        "message": "flow_dissector: For stripped vlan, get vlan info from skb->vlan_tci\n\nEarly in the datapath skb_vlan_untag function is called, stripped\nthe vlan from the skb and set skb->vlan_tci and skb->vlan_proto fields.\n\nThe current dissection doesn't handle stripped vlan packets correctly.\nIn some flows, vlan doesn't exist in skb->data anymore when applying\nflow dissection on the skb, fix that.\n\nIn case vlan info wasn't stripped before applying flow_dissector (RPS\nflow for example), or in case of skb with multiple vlans (e.g. 802.1ad),\nget the vlan info from skb->data. The flow_dissector correctly skips\nany number of vlans and stores only the first level vlan.\n\nFixes: 0744dd00c1b1 ('net: introduce skb_flow_dissect()')\nSigned-off-by: Hadar Hen Zion <hadarh@mellanox.com>\nAcked-by: Jiri Pirko <jiri@mellanox.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "net/core/flow_dissector.c||net/core/flow_dissector.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ],
          "candidate": [
            "net/core/flow_dissector.c||net/core/flow_dissector.c"
          ]
        }
      },
      "candidate_diff": {
        "net/core/flow_dissector.c||net/core/flow_dissector.c": [
          "File: net/core/flow_dissector.c -> net/core/flow_dissector.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "119:  struct flow_dissector_key_ports *key_ports;",
          "120:  struct flow_dissector_key_tags *key_tags;",
          "121:  struct flow_dissector_key_keyid *key_keyid;",
          "122:  u8 ip_proto = 0;",
          "123:  bool ret = false;",
          "125:  if (!data) {",
          "126:   data = skb->data;",
          "128:   nhoff = skb_network_offset(skb);",
          "129:   hlen = skb_headlen(skb);",
          "130:  }",
          "",
          "[Removed Lines]",
          "127:   proto = skb->protocol;",
          "",
          "[Added Lines]",
          "122:  bool skip_vlan = false;",
          "128:   proto = skb_vlan_tag_present(skb) ?",
          "129:     skb->vlan_proto : skb->protocol;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "243:  case htons(ETH_P_8021AD):",
          "244:  case htons(ETH_P_8021Q): {",
          "245:   const struct vlan_hdr *vlan;",
          "252:   if (dissector_uses_key(flow_dissector,",
          "253:            FLOW_DISSECTOR_KEY_VLANID)) {",
          "254:    key_tags = skb_flow_dissector_target(flow_dissector,",
          "255:             FLOW_DISSECTOR_KEY_VLANID,",
          "256:             target_container);",
          "259:   }",
          "263:   goto again;",
          "264:  }",
          "265:  case htons(ETH_P_PPP_SES): {",
          "",
          "[Removed Lines]",
          "246:   struct vlan_hdr _vlan;",
          "248:   vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan), data, hlen, &_vlan);",
          "249:   if (!vlan)",
          "250:    goto out_bad;",
          "258:    key_tags->vlan_id = skb_vlan_tag_get_id(skb);",
          "261:   proto = vlan->h_vlan_encapsulated_proto;",
          "262:   nhoff += sizeof(*vlan);",
          "",
          "[Added Lines]",
          "249:   if (skb_vlan_tag_present(skb))",
          "250:    proto = skb->protocol;",
          "252:   if (!skb_vlan_tag_present(skb) ||",
          "253:       proto == cpu_to_be16(ETH_P_8021Q) ||",
          "254:       proto == cpu_to_be16(ETH_P_8021AD)) {",
          "255:    struct vlan_hdr _vlan;",
          "257:    vlan = __skb_header_pointer(skb, nhoff, sizeof(_vlan),",
          "258:           data, hlen, &_vlan);",
          "259:    if (!vlan)",
          "260:     goto out_bad;",
          "261:    proto = vlan->h_vlan_encapsulated_proto;",
          "262:    nhoff += sizeof(*vlan);",
          "263:    if (skip_vlan)",
          "264:     goto again;",
          "265:   }",
          "267:   skip_vlan = true;",
          "274:    if (skb_vlan_tag_present(skb))",
          "275:     key_tags->vlan_id = skb_vlan_tag_get_id(skb);",
          "276:    else",
          "277:     key_tags->vlan_id = ntohs(vlan->h_vlan_TCI) &",
          "278:      VLAN_VID_MASK;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
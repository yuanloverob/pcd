{
  "cve_id": "CVE-2014-9710",
  "cve_desc": "The Btrfs implementation in the Linux kernel before 3.19 does not ensure that the visible xattr state is consistent with a requested replacement, which allows local users to bypass intended ACL settings and gain privileges via standard filesystem operations (1) during an xattr-replacement time window, related to a race condition, or (2) after an xattr-replacement attempt that fails because the data does not fit.",
  "repo": "torvalds/linux",
  "patch_hash": "5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339",
  "patch_info": {
    "commit_hash": "5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339",
    "files": [
      "fs/btrfs/ctree.c",
      "fs/btrfs/ctree.h",
      "fs/btrfs/dir-item.c",
      "fs/btrfs/xattr.c"
    ],
    "message": "Btrfs: make xattr replace operations atomic\n\nReplacing a xattr consists of doing a lookup for its existing value, delete\nthe current value from the respective leaf, release the search path and then\nfinally insert the new value. This leaves a time window where readers (getxattr,\nlistxattrs) won't see any value for the xattr. Xattrs are used to store ACLs,\nso this has security implications.\n\nThis change also fixes 2 other existing issues which were:\n\n*) Deleting the old xattr value without verifying first if the new xattr will\n   fit in the existing leaf item (in case multiple xattrs are packed in the\n   same item due to name hash collision);\n\n*) Returning -EEXIST when the flag XATTR_CREATE is given and the xattr doesn't\n   exist but we have have an existing item that packs muliple xattrs with\n   the same name hash as the input xattr. In this case we should return ENOSPC.\n\nA test case for xfstests follows soon.\n\nThanks to Alexandre Oliva for reporting the non-atomicity of the xattr replace\nimplementation.\n\nReported-by: Alexandre Oliva <oliva@gnu.org>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: Chris Mason <clm@fb.com>",
    "before_after_code_files": [
      "fs/btrfs/ctree.c||fs/btrfs/ctree.c",
      "fs/btrfs/ctree.h||fs/btrfs/ctree.h",
      "fs/btrfs/dir-item.c||fs/btrfs/dir-item.c",
      "fs/btrfs/xattr.c||fs/btrfs/xattr.c"
    ]
  },
  "patch_diff": {
    "fs/btrfs/ctree.c||fs/btrfs/ctree.c": [
      "File: fs/btrfs/ctree.c -> fs/btrfs/ctree.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2940:  if (!p->leave_spinning)",
      "2941:   btrfs_set_path_blocking(p);",
      "2943:   btrfs_release_path(p);",
      "2944:  return ret;",
      "2945: }",
      "",
      "[Removed Lines]",
      "2942:  if (ret < 0)",
      "",
      "[Added Lines]",
      "2942:  if (ret < 0 && !p->skip_release_on_error)",
      "",
      "---------------"
    ],
    "fs/btrfs/ctree.h||fs/btrfs/ctree.h": [
      "File: fs/btrfs/ctree.h -> fs/btrfs/ctree.h",
      "--- Hunk 1 ---",
      "[Context before]",
      "607:  unsigned int leave_spinning:1;",
      "608:  unsigned int search_commit_root:1;",
      "609:  unsigned int need_commit_sem:1;",
      "610: };",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "610:  unsigned int skip_release_on_error:1;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "3690: int verify_dir_item(struct btrfs_root *root,",
      "3691:       struct extent_buffer *leaf,",
      "3692:       struct btrfs_dir_item *dir_item);",
      "3695: int btrfs_insert_orphan_item(struct btrfs_trans_handle *trans,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "3694: struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,",
      "3695:        struct btrfs_path *path,",
      "3696:        const char *name,",
      "3697:        int name_len);",
      "",
      "---------------"
    ],
    "fs/btrfs/dir-item.c||fs/btrfs/dir-item.c": [
      "File: fs/btrfs/dir-item.c -> fs/btrfs/dir-item.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "21: #include \"hash.h\"",
      "22: #include \"transaction.h\"",
      "",
      "[Removed Lines]",
      "24: static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,",
      "25:          struct btrfs_path *path,",
      "26:          const char *name, int name_len);",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "389: {",
      "390:  struct btrfs_dir_item *dir_item;",
      "391:  unsigned long name_ptr;",
      "",
      "[Removed Lines]",
      "386: static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,",
      "387:          struct btrfs_path *path,",
      "388:          const char *name, int name_len)",
      "",
      "[Added Lines]",
      "382: struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,",
      "383:        struct btrfs_path *path,",
      "384:        const char *name, int name_len)",
      "",
      "---------------"
    ],
    "fs/btrfs/xattr.c||fs/btrfs/xattr.c": [
      "File: fs/btrfs/xattr.c -> fs/btrfs/xattr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "29: #include \"xattr.h\"",
      "30: #include \"disk-io.h\"",
      "31: #include \"props.h\"",
      "34: ssize_t __btrfs_getxattr(struct inode *inode, const char *name,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "32: #include \"locking.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "91:          struct inode *inode, const char *name,",
      "92:          const void *value, size_t size, int flags)",
      "93: {",
      "95:  struct btrfs_root *root = BTRFS_I(inode)->root;",
      "96:  struct btrfs_path *path;",
      "97:  size_t name_len = strlen(name);",
      "",
      "[Removed Lines]",
      "94:  struct btrfs_dir_item *di;",
      "",
      "[Added Lines]",
      "95:  struct btrfs_dir_item *di = NULL;",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "103:  path = btrfs_alloc_path();",
      "104:  if (!path)",
      "105:   return -ENOMEM;",
      "107:  if (flags & XATTR_REPLACE) {",
      "114:    ret = -ENODATA;",
      "115:    goto out;",
      "116:   }",
      "120:   btrfs_release_path(path);",
      "132:    goto out;",
      "133:   }",
      "137:  }",
      "151:   ret = -EEXIST;",
      "171:   }",
      "184:  }",
      "185: out:",
      "186:  btrfs_free_path(path);",
      "",
      "[Removed Lines]",
      "108:   di = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode), name,",
      "109:      name_len, -1);",
      "110:   if (IS_ERR(di)) {",
      "111:    ret = PTR_ERR(di);",
      "112:    goto out;",
      "113:   } else if (!di) {",
      "117:   ret = btrfs_delete_one_dir_name(trans, root, path, di);",
      "118:   if (ret)",
      "119:    goto out;",
      "125:   if (!value)",
      "126:    goto out;",
      "127:  } else {",
      "128:   di = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),",
      "129:      name, name_len, 0);",
      "130:   if (IS_ERR(di)) {",
      "131:    ret = PTR_ERR(di);",
      "134:   if (!di && !value)",
      "135:    goto out;",
      "136:   btrfs_release_path(path);",
      "139: again:",
      "140:  ret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),",
      "141:           name, name_len, value, size);",
      "150:  if (ret == -EOVERFLOW)",
      "153:  if (ret == -EEXIST) {",
      "154:   if (flags & XATTR_CREATE)",
      "155:    goto out;",
      "161:   btrfs_release_path(path);",
      "162:   di = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),",
      "163:      name, name_len, -1);",
      "164:   if (IS_ERR(di)) {",
      "165:    ret = PTR_ERR(di);",
      "166:    goto out;",
      "167:   } else if (!di) {",
      "169:    btrfs_release_path(path);",
      "170:    goto again;",
      "173:   ret = btrfs_delete_one_dir_name(trans, root, path, di);",
      "174:   if (ret)",
      "175:    goto out;",
      "180:   if (value) {",
      "181:    btrfs_release_path(path);",
      "182:    goto again;",
      "183:   }",
      "",
      "[Added Lines]",
      "107:  path->skip_release_on_error = 1;",
      "109:  if (!value) {",
      "110:   di = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),",
      "111:      name, name_len, -1);",
      "112:   if (!di && (flags & XATTR_REPLACE))",
      "113:    ret = -ENODATA;",
      "114:   else if (di)",
      "115:    ret = btrfs_delete_one_dir_name(trans, root, path, di);",
      "116:   goto out;",
      "117:  }",
      "127:   ASSERT(mutex_is_locked(&inode->i_mutex));",
      "128:   di = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),",
      "129:      name, name_len, 0);",
      "130:   if (!di) {",
      "135:   di = NULL;",
      "136:  }",
      "138:  ret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),",
      "139:           name, name_len, value, size);",
      "140:  if (ret == -EOVERFLOW) {",
      "146:   ret = 0;",
      "147:   btrfs_assert_tree_locked(path->nodes[0]);",
      "148:   di = btrfs_match_dir_item_name(root, path, name, name_len);",
      "149:   if (!di && !(flags & XATTR_REPLACE)) {",
      "150:    ret = -ENOSPC;",
      "153:  } else if (ret == -EEXIST) {",
      "154:   ret = 0;",
      "155:   di = btrfs_match_dir_item_name(root, path, name, name_len);",
      "157:  } else if (ret) {",
      "158:   goto out;",
      "161:  if (di && (flags & XATTR_CREATE)) {",
      "163:   goto out;",
      "164:  }",
      "166:  if (di) {",
      "174:   const int slot = path->slots[0];",
      "175:   struct extent_buffer *leaf = path->nodes[0];",
      "176:   const u16 old_data_len = btrfs_dir_data_len(leaf, di);",
      "177:   const u32 item_size = btrfs_item_size_nr(leaf, slot);",
      "178:   const u32 data_size = sizeof(*di) + name_len + size;",
      "179:   struct btrfs_item *item;",
      "180:   unsigned long data_ptr;",
      "181:   char *ptr;",
      "183:   if (size > old_data_len) {",
      "184:    if (btrfs_leaf_free_space(root, leaf) <",
      "185:        (size - old_data_len)) {",
      "186:     ret = -ENOSPC;",
      "187:     goto out;",
      "188:    }",
      "191:   if (old_data_len + name_len + sizeof(*di) == item_size) {",
      "193:    if (size > old_data_len)",
      "194:     btrfs_extend_item(root, path,",
      "195:         size - old_data_len);",
      "196:    else if (size < old_data_len)",
      "197:     btrfs_truncate_item(root, path, data_size, 1);",
      "198:   } else {",
      "200:    ret = btrfs_delete_one_dir_name(trans, root, path, di);",
      "201:    if (ret)",
      "202:     goto out;",
      "203:    btrfs_extend_item(root, path, data_size);",
      "204:   }",
      "206:   item = btrfs_item_nr(slot);",
      "207:   ptr = btrfs_item_ptr(leaf, slot, char);",
      "208:   ptr += btrfs_item_size(leaf, item) - data_size;",
      "209:   di = (struct btrfs_dir_item *)ptr;",
      "210:   btrfs_set_dir_data_len(leaf, di, size);",
      "211:   data_ptr = ((unsigned long)(di + 1)) + name_len;",
      "212:   write_extent_buffer(leaf, value, data_ptr, size);",
      "213:   btrfs_mark_buffer_dirty(leaf);",
      "214:  } else {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5cdf83edb8e41cad1ec8eab2d402b4f9d9eb7ee0",
      "candidate_info": {
        "commit_hash": "5cdf83edb8e41cad1ec8eab2d402b4f9d9eb7ee0",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5cdf83edb8e41cad1ec8eab2d402b4f9d9eb7ee0",
        "files": [
          "fs/btrfs/xattr.c"
        ],
        "message": "Btrfs: do not ignore errors from btrfs_lookup_xattr in do_setxattr\n\nThe return value from btrfs_lookup_xattr() can be a pointer encoding an\nerror, therefore deal with it. This fixes commit 5f5bc6b1e2d5\n(\"Btrfs: make xattr replace operations atomic\").\n\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nSigned-off-by: Chris Mason <clm@fb.com>",
        "before_after_code_files": [
          "fs/btrfs/xattr.c||fs/btrfs/xattr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "fs/btrfs/xattr.c||fs/btrfs/xattr.c"
          ],
          "candidate": [
            "fs/btrfs/xattr.c||fs/btrfs/xattr.c"
          ]
        }
      },
      "candidate_diff": {
        "fs/btrfs/xattr.c||fs/btrfs/xattr.c": [
          "File: fs/btrfs/xattr.c -> fs/btrfs/xattr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "111:      name, name_len, -1);",
          "112:   if (!di && (flags & XATTR_REPLACE))",
          "113:    ret = -ENODATA;",
          "114:   else if (di)",
          "115:    ret = btrfs_delete_one_dir_name(trans, root, path, di);",
          "116:   goto out;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:   else if (IS_ERR(di))",
          "115:    ret = PTR_ERR(di);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "127:   ASSERT(mutex_is_locked(&inode->i_mutex));",
          "128:   di = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),",
          "129:      name, name_len, 0);",
          "131:    ret = -ENODATA;",
          "132:    goto out;",
          "134:   btrfs_release_path(path);",
          "135:   di = NULL;",
          "136:  }",
          "",
          "[Removed Lines]",
          "130:   if (!di) {",
          "133:   }",
          "",
          "[Added Lines]",
          "132:   if (!di)",
          "134:   else if (IS_ERR(di))",
          "135:    ret = PTR_ERR(di);",
          "136:   if (ret)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
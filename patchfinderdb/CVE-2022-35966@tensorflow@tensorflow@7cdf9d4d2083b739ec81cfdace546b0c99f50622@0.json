{
  "cve_id": "CVE-2022-35966",
  "cve_desc": "TensorFlow is an open source platform for machine learning. If `QuantizedAvgPool` is given `min_input` or `max_input` tensors of a nonzero rank, it results in a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 7cdf9d4d2083b739ec81cfdace546b0c99f50622. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.",
  "repo": "tensorflow/tensorflow",
  "patch_hash": "7cdf9d4d2083b739ec81cfdace546b0c99f50622",
  "patch_info": {
    "commit_hash": "7cdf9d4d2083b739ec81cfdace546b0c99f50622",
    "repo": "tensorflow/tensorflow",
    "commit_url": "https://github.com/tensorflow/tensorflow/commit/7cdf9d4d2083b739ec81cfdace546b0c99f50622",
    "files": [
      "tensorflow/core/kernels/quantized_pooling_ops.cc",
      "tensorflow/core/kernels/quantized_pooling_ops_test.cc",
      "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
    ],
    "message": "Fix QuantizedAvgPool invalid rank issue.\n\nPassing in an invalid rank in eager mode led to a runtime crash.\nUpdated the runtime error to match the one generated by the\nshape function for better consistency.\n\nPiperOrigin-RevId: 462419362",
    "before_after_code_files": [
      "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
      "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
      "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
    ]
  },
  "patch_diff": {
    "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc": [
      "File: tensorflow/core/kernels/quantized_pooling_ops.cc -> tensorflow/core/kernels/quantized_pooling_ops.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "20: #define EIGEN_USE_THREADS",
      "22: #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"",
      "23: #include \"tensorflow/core/framework/numeric_op.h\"",
      "24: #include \"tensorflow/core/framework/op_kernel.h\"",
      "25: #include \"tensorflow/core/framework/tensor.h\"",
      "26: #include \"tensorflow/core/framework/tensor_shape.h\"",
      "27: #include \"tensorflow/core/kernels/ops_util.h\"",
      "28: #include \"tensorflow/core/kernels/pooling_ops_common.h\"",
      "29: #include \"tensorflow/core/lib/core/errors.h\"",
      "30: #include \"tensorflow/core/platform/logging.h\"",
      "31: #include \"tensorflow/core/util/padding.h\"",
      "32: #include \"tensorflow/core/util/tensor_format.h\"",
      "",
      "[Removed Lines]",
      "18: #include \"tensorflow/core/framework/op_requires.h\"",
      "19: #include \"tensorflow/core/platform/errors.h\"",
      "",
      "[Added Lines]",
      "23: #include \"tensorflow/core/framework/op_requires.h\"",
      "29: #include \"tensorflow/core/platform/errors.h\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "67:       return;",
      "68:     }",
      "73:     OP_REQUIRES(context, params.depth_window == 1,",
      "74:                 errors::Unimplemented(\"Non-spatial pooling is not \"",
      "",
      "[Removed Lines]",
      "70:     const float min_input = context->input(1).flat<float>()(0);",
      "71:     const float max_input = context->input(2).flat<float>()(0);",
      "",
      "[Added Lines]",
      "70:     const Tensor& min_input_tensor = context->input(1);",
      "71:     const Tensor& max_input_tensor = context->input(2);",
      "72:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
      "73:                 errors::InvalidArgument(",
      "74:                     \"min_input shape must be rank 0 but is rank \",",
      "75:                     min_input_tensor.dims(),",
      "76:                     \", received shape: \", min_input_tensor.shape()));",
      "77:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
      "78:                 errors::InvalidArgument(",
      "79:                     \"max_input shape must be rank 0 but is rank \",",
      "80:                     max_input_tensor.dims(),",
      "81:                     \", received shape: \", max_input_tensor.shape()));",
      "82:     const float min_input = context->input(1).scalar<float>()();",
      "83:     const float max_input = context->input(2).scalar<float>()();",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "119:       : MaxPoolingOp<Device, T>(context) {}",
      "121:   void Compute(OpKernelContext* context) override {",
      "136:     MaxPoolingOp<Device, T>::Compute(context);",
      "137:     Tensor* output_min = nullptr;",
      "138:     OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));",
      "",
      "[Removed Lines]",
      "122:     auto min_input_tensor = context->input(1);",
      "123:     auto max_input_tensor = context->input(2);",
      "124:     OP_REQUIRES(",
      "125:         context, min_input_tensor.NumElements() == 1,",
      "126:         errors::InvalidArgument(",
      "127:             \"min_input must be a scalar float value, got tensor with shape \",",
      "128:             min_input_tensor.shape()));",
      "129:     OP_REQUIRES(",
      "130:         context, max_input_tensor.NumElements() == 1,",
      "131:         errors::InvalidArgument(",
      "132:             \"max_input must be a scalar float value, got tensor with shape \",",
      "133:             max_input_tensor.shape()));",
      "134:     const float min_input = context->input(1).flat<float>()(0);",
      "135:     const float max_input = context->input(2).flat<float>()(0);",
      "",
      "[Added Lines]",
      "134:     const Tensor& min_input_tensor = context->input(1);",
      "135:     const Tensor& max_input_tensor = context->input(2);",
      "136:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
      "137:                 errors::InvalidArgument(",
      "138:                     \"min_input shape must be rank 0 but is rank \",",
      "139:                     min_input_tensor.dims(),",
      "140:                     \", received shape: \", min_input_tensor.shape()));",
      "141:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
      "142:                 errors::InvalidArgument(",
      "143:                     \"max_input shape must be rank 0 but is rank \",",
      "144:                     max_input_tensor.dims(),",
      "145:                     \", received shape: \", max_input_tensor.shape()));",
      "146:     const float min_input = context->input(1).scalar<float>()();",
      "147:     const float max_input = context->input(2).scalar<float>()();",
      "",
      "---------------"
    ],
    "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc": [
      "File: tensorflow/core/kernels/quantized_pooling_ops_test.cc -> tensorflow/core/kernels/quantized_pooling_ops_test.cc",
      "--- Hunk 1 ---",
      "[Context before]",
      "70:   AddInputFromArray<quint8>(input_quantized.shape(),",
      "71:                             input_quantized.flat<quint8>());",
      "74:   TF_ASSERT_OK(RunOpKernel());",
      "75:   const Tensor& output_quantized = *GetOutput(0);",
      "76:   const float output_min = GetOutput(1)->flat<float>()(0);",
      "",
      "[Removed Lines]",
      "72:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
      "73:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
      "",
      "[Added Lines]",
      "72:   AddInputFromArray<float>(TensorShape({}), {input_min});",
      "73:   AddInputFromArray<float>(TensorShape({}), {input_max});",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "115:   AddInputFromArray<quint8>(input_quantized.shape(),",
      "116:                             input_quantized.flat<quint8>());",
      "119:   TF_ASSERT_OK(RunOpKernel());",
      "120:   const Tensor& output_quantized = *GetOutput(0);",
      "121:   const float output_min = GetOutput(1)->flat<float>()(0);",
      "",
      "[Removed Lines]",
      "117:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
      "118:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
      "",
      "[Added Lines]",
      "117:   AddInputFromArray<float>(TensorShape({}), {input_min});",
      "118:   AddInputFromArray<float>(TensorShape({}), {input_max});",
      "",
      "---------------"
    ],
    "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py": [
      "File: tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py -> tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py",
      "--- Hunk 1 ---",
      "[Context before]",
      "154:               x=inputs, x_min=[[1.0], [2.0], [4.0]], x_max=1.0))",
      "157: class RequantizeOpTest(test_util.TensorFlowTestCase):",
      "159:   @test_util.run_in_graph_and_eager_modes",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "157: class QuantizedAvgPoolingOpTest(test_util.TensorFlowTestCase):",
      "159:   @test_util.run_in_graph_and_eager_modes",
      "160:   def test_invalid_inputs(self):",
      "161:     inputs = constant_op.constant(",
      "162:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
      "163:     ksize = [1, 1, 1, 1]",
      "164:     strides = [1, 1, 1, 1]",
      "165:     padding = \"SAME\"",
      "167:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
      "168:                                 \"must be.* rank 0\"):",
      "169:       self.evaluate(",
      "170:           nn_ops.quantized_avg_pool(",
      "171:               input=inputs,",
      "172:               min_input=[],",
      "173:               max_input=1.0,",
      "174:               ksize=ksize,",
      "175:               strides=strides,",
      "176:               padding=padding))",
      "178:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
      "179:                                 \"must be.* rank 0\"):",
      "180:       self.evaluate(",
      "181:           nn_ops.quantized_avg_pool(",
      "182:               input=inputs,",
      "183:               min_input=0.0,",
      "184:               max_input=[],",
      "185:               ksize=ksize,",
      "186:               strides=strides,",
      "187:               padding=padding))",
      "190: class QuantizedMaxPoolingOpTest(test_util.TensorFlowTestCase):",
      "192:   @test_util.run_in_graph_and_eager_modes",
      "193:   def test_invalid_inputs(self):",
      "194:     inputs = constant_op.constant(",
      "195:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
      "196:     ksize = [1, 1, 1, 1]",
      "197:     strides = [1, 1, 1, 1]",
      "198:     padding = \"SAME\"",
      "200:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
      "201:                                 \"must be.* rank 0\"):",
      "202:       self.evaluate(",
      "203:           nn_ops.quantized_max_pool(",
      "204:               input=inputs,",
      "205:               min_input=[],",
      "206:               max_input=1.0,",
      "207:               ksize=ksize,",
      "208:               strides=strides,",
      "209:               padding=padding))",
      "211:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
      "212:                                 \"must be.* rank 0\"):",
      "213:       self.evaluate(",
      "214:           nn_ops.quantized_max_pool(",
      "215:               input=inputs,",
      "216:               min_input=0.0,",
      "217:               max_input=[],",
      "218:               ksize=ksize,",
      "219:               strides=strides,",
      "220:               padding=padding))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "53b0dd6dc5957652f35964af16b892ec9af4a559",
      "candidate_info": {
        "commit_hash": "53b0dd6dc5957652f35964af16b892ec9af4a559",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/53b0dd6dc5957652f35964af16b892ec9af4a559",
        "files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc"
        ],
        "message": "Fix nullptr exception in QuantizedMaxPool op when empty list is sent to min_input or max_input parameters.\n\nPiperOrigin-RevId: 413960973\nChange-Id: I9e3ded593f3c4eabf0d6d5dc356e6a19a3ad2682",
        "before_after_code_files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc"
          ],
          "candidate": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc": [
          "File: tensorflow/core/kernels/quantized_pooling_ops.cc -> tensorflow/core/kernels/quantized_pooling_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "18: #define EIGEN_USE_THREADS",
          "20: #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: #include \"tensorflow/core/framework/op_requires.h\"",
          "19: #include \"tensorflow/core/platform/errors.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "117:       : MaxPoolingOp<Device, T>(context) {}",
          "119:   void Compute(OpKernelContext* context) override {",
          "120:     const float min_input = context->input(1).flat<float>()(0);",
          "121:     const float max_input = context->input(2).flat<float>()(0);",
          "122:     MaxPoolingOp<Device, T>::Compute(context);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:     auto min_input_tensor = context->input(1);",
          "123:     auto max_input_tensor = context->input(2);",
          "124:     OP_REQUIRES(",
          "125:         context, min_input_tensor.NumElements() == 1,",
          "126:         errors::InvalidArgument(",
          "127:             \"min_input must be a scalar float value, got tensor with shape \",",
          "128:             min_input_tensor.shape()));",
          "129:     OP_REQUIRES(",
          "130:         context, max_input_tensor.NumElements() == 1,",
          "131:         errors::InvalidArgument(",
          "132:             \"max_input must be a scalar float value, got tensor with shape \",",
          "133:             max_input_tensor.shape()));",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94521ecd10ffa4c4d73787b30290825c0539bf33",
      "candidate_info": {
        "commit_hash": "94521ecd10ffa4c4d73787b30290825c0539bf33",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/94521ecd10ffa4c4d73787b30290825c0539bf33",
        "files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc",
          "tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
        ],
        "message": "Fix QuantizedAvgPool invalid rank issue.\n\nPassing in an invalid rank in eager mode led to a runtime crash.\nUpdated the runtime error to match the one generated by the\nshape function for better consistency.\n\nPiperOrigin-RevId: 462419362",
        "before_after_code_files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
          "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
            "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
            "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
            "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
            "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc": [
          "File: tensorflow/core/kernels/quantized_pooling_ops.cc -> tensorflow/core/kernels/quantized_pooling_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"",
          "23: #include \"tensorflow/core/framework/numeric_op.h\"",
          "24: #include \"tensorflow/core/framework/op_kernel.h\"",
          "25: #include \"tensorflow/core/framework/tensor.h\"",
          "26: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "27: #include \"tensorflow/core/kernels/ops_util.h\"",
          "28: #include \"tensorflow/core/kernels/pooling_ops_common.h\"",
          "29: #include \"tensorflow/core/lib/core/errors.h\"",
          "30: #include \"tensorflow/core/platform/logging.h\"",
          "31: #include \"tensorflow/core/util/padding.h\"",
          "32: #include \"tensorflow/core/util/tensor_format.h\"",
          "",
          "[Removed Lines]",
          "18: #include \"tensorflow/core/framework/op_requires.h\"",
          "19: #include \"tensorflow/core/platform/errors.h\"",
          "",
          "[Added Lines]",
          "23: #include \"tensorflow/core/framework/op_requires.h\"",
          "29: #include \"tensorflow/core/platform/errors.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:       return;",
          "68:     }",
          "73:     OP_REQUIRES(context, params.depth_window == 1,",
          "74:                 errors::Unimplemented(\"Non-spatial pooling is not \"",
          "",
          "[Removed Lines]",
          "70:     const float min_input = context->input(1).flat<float>()(0);",
          "71:     const float max_input = context->input(2).flat<float>()(0);",
          "",
          "[Added Lines]",
          "70:     const Tensor& min_input_tensor = context->input(1);",
          "71:     const Tensor& max_input_tensor = context->input(2);",
          "72:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
          "73:                 errors::InvalidArgument(",
          "74:                     \"min_input shape must be rank 0 but is rank \",",
          "75:                     min_input_tensor.dims(),",
          "76:                     \", received shape: \", min_input_tensor.shape()));",
          "77:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
          "78:                 errors::InvalidArgument(",
          "79:                     \"max_input shape must be rank 0 but is rank \",",
          "80:                     max_input_tensor.dims(),",
          "81:                     \", received shape: \", max_input_tensor.shape()));",
          "82:     const float min_input = context->input(1).scalar<float>()();",
          "83:     const float max_input = context->input(2).scalar<float>()();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:       : MaxPoolingOp<Device, T>(context) {}",
          "121:   void Compute(OpKernelContext* context) override {",
          "136:     MaxPoolingOp<Device, T>::Compute(context);",
          "137:     Tensor* output_min = nullptr;",
          "138:     OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));",
          "",
          "[Removed Lines]",
          "122:     auto min_input_tensor = context->input(1);",
          "123:     auto max_input_tensor = context->input(2);",
          "124:     OP_REQUIRES(",
          "125:         context, min_input_tensor.NumElements() == 1,",
          "126:         errors::InvalidArgument(",
          "127:             \"min_input must be a scalar float value, got tensor with shape \",",
          "128:             min_input_tensor.shape()));",
          "129:     OP_REQUIRES(",
          "130:         context, max_input_tensor.NumElements() == 1,",
          "131:         errors::InvalidArgument(",
          "132:             \"max_input must be a scalar float value, got tensor with shape \",",
          "133:             max_input_tensor.shape()));",
          "134:     const float min_input = context->input(1).flat<float>()(0);",
          "135:     const float max_input = context->input(2).flat<float>()(0);",
          "",
          "[Added Lines]",
          "134:     const Tensor& min_input_tensor = context->input(1);",
          "135:     const Tensor& max_input_tensor = context->input(2);",
          "136:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
          "137:                 errors::InvalidArgument(",
          "138:                     \"min_input shape must be rank 0 but is rank \",",
          "139:                     min_input_tensor.dims(),",
          "140:                     \", received shape: \", min_input_tensor.shape()));",
          "141:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
          "142:                 errors::InvalidArgument(",
          "143:                     \"max_input shape must be rank 0 but is rank \",",
          "144:                     max_input_tensor.dims(),",
          "145:                     \", received shape: \", max_input_tensor.shape()));",
          "146:     const float min_input = context->input(1).scalar<float>()();",
          "147:     const float max_input = context->input(2).scalar<float>()();",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc": [
          "File: tensorflow/core/kernels/quantized_pooling_ops_test.cc -> tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:   AddInputFromArray<quint8>(input_quantized.shape(),",
          "71:                             input_quantized.flat<quint8>());",
          "74:   TF_ASSERT_OK(RunOpKernel());",
          "75:   const Tensor& output_quantized = *GetOutput(0);",
          "76:   const float output_min = GetOutput(1)->flat<float>()(0);",
          "",
          "[Removed Lines]",
          "72:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
          "73:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
          "",
          "[Added Lines]",
          "72:   AddInputFromArray<float>(TensorShape({}), {input_min});",
          "73:   AddInputFromArray<float>(TensorShape({}), {input_max});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115:   AddInputFromArray<quint8>(input_quantized.shape(),",
          "116:                             input_quantized.flat<quint8>());",
          "119:   TF_ASSERT_OK(RunOpKernel());",
          "120:   const Tensor& output_quantized = *GetOutput(0);",
          "121:   const float output_min = GetOutput(1)->flat<float>()(0);",
          "",
          "[Removed Lines]",
          "117:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
          "118:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
          "",
          "[Added Lines]",
          "117:   AddInputFromArray<float>(TensorShape({}), {input_min});",
          "118:   AddInputFromArray<float>(TensorShape({}), {input_max});",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py": [
          "File: tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py -> tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:               x=inputs, x_min=[[1.0], [2.0], [4.0]], x_max=1.0))",
          "157: class RequantizeOpTest(test_util.TensorFlowTestCase):",
          "159:   @test_util.run_in_graph_and_eager_modes",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "157: class QuantizedAvgPoolingOpTest(test_util.TensorFlowTestCase):",
          "159:   @test_util.run_in_graph_and_eager_modes",
          "160:   def test_invalid_inputs(self):",
          "161:     inputs = constant_op.constant(",
          "162:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
          "163:     ksize = [1, 1, 1, 1]",
          "164:     strides = [1, 1, 1, 1]",
          "165:     padding = \"SAME\"",
          "167:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "168:                                 \"must be.* rank 0\"):",
          "169:       self.evaluate(",
          "170:           nn_ops.quantized_avg_pool(",
          "171:               input=inputs,",
          "172:               min_input=[],",
          "173:               max_input=1.0,",
          "174:               ksize=ksize,",
          "175:               strides=strides,",
          "176:               padding=padding))",
          "178:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "179:                                 \"must be.* rank 0\"):",
          "180:       self.evaluate(",
          "181:           nn_ops.quantized_avg_pool(",
          "182:               input=inputs,",
          "183:               min_input=0.0,",
          "184:               max_input=[],",
          "185:               ksize=ksize,",
          "186:               strides=strides,",
          "187:               padding=padding))",
          "190: class QuantizedMaxPoolingOpTest(test_util.TensorFlowTestCase):",
          "192:   @test_util.run_in_graph_and_eager_modes",
          "193:   def test_invalid_inputs(self):",
          "194:     inputs = constant_op.constant(",
          "195:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
          "196:     ksize = [1, 1, 1, 1]",
          "197:     strides = [1, 1, 1, 1]",
          "198:     padding = \"SAME\"",
          "200:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "201:                                 \"must be.* rank 0\"):",
          "202:       self.evaluate(",
          "203:           nn_ops.quantized_max_pool(",
          "204:               input=inputs,",
          "205:               min_input=[],",
          "206:               max_input=1.0,",
          "207:               ksize=ksize,",
          "208:               strides=strides,",
          "209:               padding=padding))",
          "211:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "212:                                 \"must be.* rank 0\"):",
          "213:       self.evaluate(",
          "214:           nn_ops.quantized_max_pool(",
          "215:               input=inputs,",
          "216:               min_input=0.0,",
          "217:               max_input=[],",
          "218:               ksize=ksize,",
          "219:               strides=strides,",
          "220:               padding=padding))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "1a1d14ef96d8d2d2b19ec6df619742a0c35d149d",
      "candidate_info": {
        "commit_hash": "1a1d14ef96d8d2d2b19ec6df619742a0c35d149d",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/1a1d14ef96d8d2d2b19ec6df619742a0c35d149d",
        "files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc",
          "tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
        ],
        "message": "Fix QuantizedAvgPool invalid rank issue.\n\nPassing in an invalid rank in eager mode led to a runtime crash.\nUpdated the runtime error to match the one generated by the\nshape function for better consistency.\n\nPiperOrigin-RevId: 462419362",
        "before_after_code_files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
          "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
            "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
            "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
            "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
            "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc": [
          "File: tensorflow/core/kernels/quantized_pooling_ops.cc -> tensorflow/core/kernels/quantized_pooling_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"",
          "23: #include \"tensorflow/core/framework/numeric_op.h\"",
          "24: #include \"tensorflow/core/framework/op_kernel.h\"",
          "25: #include \"tensorflow/core/framework/tensor.h\"",
          "26: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "27: #include \"tensorflow/core/kernels/ops_util.h\"",
          "28: #include \"tensorflow/core/kernels/pooling_ops_common.h\"",
          "29: #include \"tensorflow/core/lib/core/errors.h\"",
          "30: #include \"tensorflow/core/platform/logging.h\"",
          "31: #include \"tensorflow/core/util/padding.h\"",
          "32: #include \"tensorflow/core/util/tensor_format.h\"",
          "",
          "[Removed Lines]",
          "18: #include \"tensorflow/core/framework/op_requires.h\"",
          "19: #include \"tensorflow/core/platform/errors.h\"",
          "",
          "[Added Lines]",
          "23: #include \"tensorflow/core/framework/op_requires.h\"",
          "29: #include \"tensorflow/core/platform/errors.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:       return;",
          "68:     }",
          "73:     OP_REQUIRES(context, params.depth_window == 1,",
          "74:                 errors::Unimplemented(\"Non-spatial pooling is not \"",
          "",
          "[Removed Lines]",
          "70:     const float min_input = context->input(1).flat<float>()(0);",
          "71:     const float max_input = context->input(2).flat<float>()(0);",
          "",
          "[Added Lines]",
          "70:     const Tensor& min_input_tensor = context->input(1);",
          "71:     const Tensor& max_input_tensor = context->input(2);",
          "72:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
          "73:                 errors::InvalidArgument(",
          "74:                     \"min_input shape must be rank 0 but is rank \",",
          "75:                     min_input_tensor.dims(),",
          "76:                     \", received shape: \", min_input_tensor.shape()));",
          "77:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
          "78:                 errors::InvalidArgument(",
          "79:                     \"max_input shape must be rank 0 but is rank \",",
          "80:                     max_input_tensor.dims(),",
          "81:                     \", received shape: \", max_input_tensor.shape()));",
          "82:     const float min_input = context->input(1).scalar<float>()();",
          "83:     const float max_input = context->input(2).scalar<float>()();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:       : MaxPoolingOp<Device, T>(context) {}",
          "121:   void Compute(OpKernelContext* context) override {",
          "136:     MaxPoolingOp<Device, T>::Compute(context);",
          "137:     Tensor* output_min = nullptr;",
          "138:     OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));",
          "",
          "[Removed Lines]",
          "122:     auto min_input_tensor = context->input(1);",
          "123:     auto max_input_tensor = context->input(2);",
          "124:     OP_REQUIRES(",
          "125:         context, min_input_tensor.NumElements() == 1,",
          "126:         errors::InvalidArgument(",
          "127:             \"min_input must be a scalar float value, got tensor with shape \",",
          "128:             min_input_tensor.shape()));",
          "129:     OP_REQUIRES(",
          "130:         context, max_input_tensor.NumElements() == 1,",
          "131:         errors::InvalidArgument(",
          "132:             \"max_input must be a scalar float value, got tensor with shape \",",
          "133:             max_input_tensor.shape()));",
          "134:     const float min_input = context->input(1).flat<float>()(0);",
          "135:     const float max_input = context->input(2).flat<float>()(0);",
          "",
          "[Added Lines]",
          "134:     const Tensor& min_input_tensor = context->input(1);",
          "135:     const Tensor& max_input_tensor = context->input(2);",
          "136:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
          "137:                 errors::InvalidArgument(",
          "138:                     \"min_input shape must be rank 0 but is rank \",",
          "139:                     min_input_tensor.dims(),",
          "140:                     \", received shape: \", min_input_tensor.shape()));",
          "141:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
          "142:                 errors::InvalidArgument(",
          "143:                     \"max_input shape must be rank 0 but is rank \",",
          "144:                     max_input_tensor.dims(),",
          "145:                     \", received shape: \", max_input_tensor.shape()));",
          "146:     const float min_input = context->input(1).scalar<float>()();",
          "147:     const float max_input = context->input(2).scalar<float>()();",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc": [
          "File: tensorflow/core/kernels/quantized_pooling_ops_test.cc -> tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:   AddInputFromArray<quint8>(input_quantized.shape(),",
          "71:                             input_quantized.flat<quint8>());",
          "74:   TF_ASSERT_OK(RunOpKernel());",
          "75:   const Tensor& output_quantized = *GetOutput(0);",
          "76:   const float output_min = GetOutput(1)->flat<float>()(0);",
          "",
          "[Removed Lines]",
          "72:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
          "73:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
          "",
          "[Added Lines]",
          "72:   AddInputFromArray<float>(TensorShape({}), {input_min});",
          "73:   AddInputFromArray<float>(TensorShape({}), {input_max});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115:   AddInputFromArray<quint8>(input_quantized.shape(),",
          "116:                             input_quantized.flat<quint8>());",
          "119:   TF_ASSERT_OK(RunOpKernel());",
          "120:   const Tensor& output_quantized = *GetOutput(0);",
          "121:   const float output_min = GetOutput(1)->flat<float>()(0);",
          "",
          "[Removed Lines]",
          "117:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
          "118:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
          "",
          "[Added Lines]",
          "117:   AddInputFromArray<float>(TensorShape({}), {input_min});",
          "118:   AddInputFromArray<float>(TensorShape({}), {input_max});",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py": [
          "File: tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py -> tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:               x=inputs, x_min=[[1.0], [2.0], [4.0]], x_max=1.0))",
          "157: class RequantizeOpTest(test_util.TensorFlowTestCase):",
          "159:   @test_util.run_in_graph_and_eager_modes",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "157: class QuantizedAvgPoolingOpTest(test_util.TensorFlowTestCase):",
          "159:   @test_util.run_in_graph_and_eager_modes",
          "160:   def test_invalid_inputs(self):",
          "161:     inputs = constant_op.constant(",
          "162:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
          "163:     ksize = [1, 1, 1, 1]",
          "164:     strides = [1, 1, 1, 1]",
          "165:     padding = \"SAME\"",
          "167:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "168:                                 \"must be.* rank 0\"):",
          "169:       self.evaluate(",
          "170:           nn_ops.quantized_avg_pool(",
          "171:               input=inputs,",
          "172:               min_input=[],",
          "173:               max_input=1.0,",
          "174:               ksize=ksize,",
          "175:               strides=strides,",
          "176:               padding=padding))",
          "178:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "179:                                 \"must be.* rank 0\"):",
          "180:       self.evaluate(",
          "181:           nn_ops.quantized_avg_pool(",
          "182:               input=inputs,",
          "183:               min_input=0.0,",
          "184:               max_input=[],",
          "185:               ksize=ksize,",
          "186:               strides=strides,",
          "187:               padding=padding))",
          "190: class QuantizedMaxPoolingOpTest(test_util.TensorFlowTestCase):",
          "192:   @test_util.run_in_graph_and_eager_modes",
          "193:   def test_invalid_inputs(self):",
          "194:     inputs = constant_op.constant(",
          "195:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
          "196:     ksize = [1, 1, 1, 1]",
          "197:     strides = [1, 1, 1, 1]",
          "198:     padding = \"SAME\"",
          "200:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "201:                                 \"must be.* rank 0\"):",
          "202:       self.evaluate(",
          "203:           nn_ops.quantized_max_pool(",
          "204:               input=inputs,",
          "205:               min_input=[],",
          "206:               max_input=1.0,",
          "207:               ksize=ksize,",
          "208:               strides=strides,",
          "209:               padding=padding))",
          "211:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "212:                                 \"must be.* rank 0\"):",
          "213:       self.evaluate(",
          "214:           nn_ops.quantized_max_pool(",
          "215:               input=inputs,",
          "216:               min_input=0.0,",
          "217:               max_input=[],",
          "218:               ksize=ksize,",
          "219:               strides=strides,",
          "220:               padding=padding))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "55a2e6542687ca48cd5b43909a519545319a8863",
      "candidate_info": {
        "commit_hash": "55a2e6542687ca48cd5b43909a519545319a8863",
        "repo": "tensorflow/tensorflow",
        "commit_url": "https://github.com/tensorflow/tensorflow/commit/55a2e6542687ca48cd5b43909a519545319a8863",
        "files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc",
          "tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
        ],
        "message": "Fix QuantizedAvgPool invalid rank issue.\n\nPassing in an invalid rank in eager mode led to a runtime crash.\nUpdated the runtime error to match the one generated by the\nshape function for better consistency.\n\nPiperOrigin-RevId: 462419362",
        "before_after_code_files": [
          "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
          "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
            "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
            "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
          ],
          "candidate": [
            "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc",
            "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc",
            "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py"
          ]
        }
      },
      "candidate_diff": {
        "tensorflow/core/kernels/quantized_pooling_ops.cc||tensorflow/core/kernels/quantized_pooling_ops.cc": [
          "File: tensorflow/core/kernels/quantized_pooling_ops.cc -> tensorflow/core/kernels/quantized_pooling_ops.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "20: #define EIGEN_USE_THREADS",
          "22: #include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"",
          "23: #include \"tensorflow/core/framework/numeric_op.h\"",
          "24: #include \"tensorflow/core/framework/op_kernel.h\"",
          "25: #include \"tensorflow/core/framework/tensor.h\"",
          "26: #include \"tensorflow/core/framework/tensor_shape.h\"",
          "27: #include \"tensorflow/core/kernels/ops_util.h\"",
          "28: #include \"tensorflow/core/kernels/pooling_ops_common.h\"",
          "29: #include \"tensorflow/core/lib/core/errors.h\"",
          "30: #include \"tensorflow/core/platform/logging.h\"",
          "31: #include \"tensorflow/core/util/padding.h\"",
          "32: #include \"tensorflow/core/util/tensor_format.h\"",
          "",
          "[Removed Lines]",
          "18: #include \"tensorflow/core/framework/op_requires.h\"",
          "19: #include \"tensorflow/core/platform/errors.h\"",
          "",
          "[Added Lines]",
          "23: #include \"tensorflow/core/framework/op_requires.h\"",
          "29: #include \"tensorflow/core/platform/errors.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:       return;",
          "68:     }",
          "73:     OP_REQUIRES(context, params.depth_window == 1,",
          "74:                 errors::Unimplemented(\"Non-spatial pooling is not \"",
          "",
          "[Removed Lines]",
          "70:     const float min_input = context->input(1).flat<float>()(0);",
          "71:     const float max_input = context->input(2).flat<float>()(0);",
          "",
          "[Added Lines]",
          "70:     const Tensor& min_input_tensor = context->input(1);",
          "71:     const Tensor& max_input_tensor = context->input(2);",
          "72:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
          "73:                 errors::InvalidArgument(",
          "74:                     \"min_input shape must be rank 0 but is rank \",",
          "75:                     min_input_tensor.dims(),",
          "76:                     \", received shape: \", min_input_tensor.shape()));",
          "77:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
          "78:                 errors::InvalidArgument(",
          "79:                     \"max_input shape must be rank 0 but is rank \",",
          "80:                     max_input_tensor.dims(),",
          "81:                     \", received shape: \", max_input_tensor.shape()));",
          "82:     const float min_input = context->input(1).scalar<float>()();",
          "83:     const float max_input = context->input(2).scalar<float>()();",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:       : MaxPoolingOp<Device, T>(context) {}",
          "121:   void Compute(OpKernelContext* context) override {",
          "136:     MaxPoolingOp<Device, T>::Compute(context);",
          "137:     Tensor* output_min = nullptr;",
          "138:     OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));",
          "",
          "[Removed Lines]",
          "122:     auto min_input_tensor = context->input(1);",
          "123:     auto max_input_tensor = context->input(2);",
          "124:     OP_REQUIRES(",
          "125:         context, min_input_tensor.NumElements() == 1,",
          "126:         errors::InvalidArgument(",
          "127:             \"min_input must be a scalar float value, got tensor with shape \",",
          "128:             min_input_tensor.shape()));",
          "129:     OP_REQUIRES(",
          "130:         context, max_input_tensor.NumElements() == 1,",
          "131:         errors::InvalidArgument(",
          "132:             \"max_input must be a scalar float value, got tensor with shape \",",
          "133:             max_input_tensor.shape()));",
          "134:     const float min_input = context->input(1).flat<float>()(0);",
          "135:     const float max_input = context->input(2).flat<float>()(0);",
          "",
          "[Added Lines]",
          "134:     const Tensor& min_input_tensor = context->input(1);",
          "135:     const Tensor& max_input_tensor = context->input(2);",
          "136:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),",
          "137:                 errors::InvalidArgument(",
          "138:                     \"min_input shape must be rank 0 but is rank \",",
          "139:                     min_input_tensor.dims(),",
          "140:                     \", received shape: \", min_input_tensor.shape()));",
          "141:     OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),",
          "142:                 errors::InvalidArgument(",
          "143:                     \"max_input shape must be rank 0 but is rank \",",
          "144:                     max_input_tensor.dims(),",
          "145:                     \", received shape: \", max_input_tensor.shape()));",
          "146:     const float min_input = context->input(1).scalar<float>()();",
          "147:     const float max_input = context->input(2).scalar<float>()();",
          "",
          "---------------"
        ],
        "tensorflow/core/kernels/quantized_pooling_ops_test.cc||tensorflow/core/kernels/quantized_pooling_ops_test.cc": [
          "File: tensorflow/core/kernels/quantized_pooling_ops_test.cc -> tensorflow/core/kernels/quantized_pooling_ops_test.cc",
          "--- Hunk 1 ---",
          "[Context before]",
          "70:   AddInputFromArray<quint8>(input_quantized.shape(),",
          "71:                             input_quantized.flat<quint8>());",
          "74:   TF_ASSERT_OK(RunOpKernel());",
          "75:   const Tensor& output_quantized = *GetOutput(0);",
          "76:   const float output_min = GetOutput(1)->flat<float>()(0);",
          "",
          "[Removed Lines]",
          "72:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
          "73:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
          "",
          "[Added Lines]",
          "72:   AddInputFromArray<float>(TensorShape({}), {input_min});",
          "73:   AddInputFromArray<float>(TensorShape({}), {input_max});",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "115:   AddInputFromArray<quint8>(input_quantized.shape(),",
          "116:                             input_quantized.flat<quint8>());",
          "119:   TF_ASSERT_OK(RunOpKernel());",
          "120:   const Tensor& output_quantized = *GetOutput(0);",
          "121:   const float output_min = GetOutput(1)->flat<float>()(0);",
          "",
          "[Removed Lines]",
          "117:   AddInputFromArray<float>(TensorShape({1}), {input_min});",
          "118:   AddInputFromArray<float>(TensorShape({1}), {input_max});",
          "",
          "[Added Lines]",
          "117:   AddInputFromArray<float>(TensorShape({}), {input_min});",
          "118:   AddInputFromArray<float>(TensorShape({}), {input_max});",
          "",
          "---------------"
        ],
        "tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py||tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py": [
          "File: tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py -> tensorflow/python/kernel_tests/quantization_ops/quantization_ops_test.py",
          "--- Hunk 1 ---",
          "[Context before]",
          "154:               x=inputs, x_min=[[1.0], [2.0], [4.0]], x_max=1.0))",
          "157: class RequantizeOpTest(test_util.TensorFlowTestCase):",
          "159:   @test_util.run_in_graph_and_eager_modes",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "157: class QuantizedAvgPoolingOpTest(test_util.TensorFlowTestCase):",
          "159:   @test_util.run_in_graph_and_eager_modes",
          "160:   def test_invalid_inputs(self):",
          "161:     inputs = constant_op.constant(",
          "162:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
          "163:     ksize = [1, 1, 1, 1]",
          "164:     strides = [1, 1, 1, 1]",
          "165:     padding = \"SAME\"",
          "167:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "168:                                 \"must be.* rank 0\"):",
          "169:       self.evaluate(",
          "170:           nn_ops.quantized_avg_pool(",
          "171:               input=inputs,",
          "172:               min_input=[],",
          "173:               max_input=1.0,",
          "174:               ksize=ksize,",
          "175:               strides=strides,",
          "176:               padding=padding))",
          "178:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "179:                                 \"must be.* rank 0\"):",
          "180:       self.evaluate(",
          "181:           nn_ops.quantized_avg_pool(",
          "182:               input=inputs,",
          "183:               min_input=0.0,",
          "184:               max_input=[],",
          "185:               ksize=ksize,",
          "186:               strides=strides,",
          "187:               padding=padding))",
          "190: class QuantizedMaxPoolingOpTest(test_util.TensorFlowTestCase):",
          "192:   @test_util.run_in_graph_and_eager_modes",
          "193:   def test_invalid_inputs(self):",
          "194:     inputs = constant_op.constant(",
          "195:         np.uint8(0), shape=[3, 3, 3, 3], dtype=dtypes.quint8)",
          "196:     ksize = [1, 1, 1, 1]",
          "197:     strides = [1, 1, 1, 1]",
          "198:     padding = \"SAME\"",
          "200:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "201:                                 \"must be.* rank 0\"):",
          "202:       self.evaluate(",
          "203:           nn_ops.quantized_max_pool(",
          "204:               input=inputs,",
          "205:               min_input=[],",
          "206:               max_input=1.0,",
          "207:               ksize=ksize,",
          "208:               strides=strides,",
          "209:               padding=padding))",
          "211:     with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),",
          "212:                                 \"must be.* rank 0\"):",
          "213:       self.evaluate(",
          "214:           nn_ops.quantized_max_pool(",
          "215:               input=inputs,",
          "216:               min_input=0.0,",
          "217:               max_input=[],",
          "218:               ksize=ksize,",
          "219:               strides=strides,",
          "220:               padding=padding))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0520464870756b67be3f75ab8c8b02e583e16524",
      "candidate_info": {
        "commit_hash": "0520464870756b67be3f75ab8c8b02e583e16524",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/0520464870756b67be3f75ab8c8b02e583e16524",
        "files": [
          "src/queue.h"
        ],
        "message": "queue: strengthen type checks\n\nRewrite some of the macros in a way that:\n\n  a) makes them more likely to trigger compile-time errors if used\n     inappropriately, and\n\n  b) makes C++ compilers happy",
        "before_after_code_files": [
          "src/queue.h||src/queue.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/queue.h||src/queue.h": [
          "File: src/queue.h -> src/queue.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "19: typedef void *QUEUE[2];",
          "28: #define QUEUE_DATA(ptr, type, field)                                          \\",
          "29:   ((type *) ((char *) (ptr) - ((char *) &((type *) 0)->field)))",
          "31: #define QUEUE_FOREACH(q, h)                                                   \\",
          "34: #define QUEUE_EMPTY(q)                                                        \\",
          "37: #define QUEUE_HEAD(q)                                                         \\",
          "38:   (QUEUE_NEXT(q))",
          "",
          "[Removed Lines]",
          "22: #define QUEUE_NEXT(q)       ((*(q))[0])",
          "23: #define QUEUE_PREV(q)       ((*(q))[1])",
          "24: #define QUEUE_PREV_NEXT(q)  (QUEUE_NEXT((QUEUE *) QUEUE_PREV(q)))",
          "25: #define QUEUE_NEXT_PREV(q)  (QUEUE_PREV((QUEUE *) QUEUE_NEXT(q)))",
          "32:   for ((q) = (QUEUE *) (*(h))[0]; (q) != (h); (q) = (QUEUE *) (*(q))[0])",
          "35:   (QUEUE_NEXT(q) == (q))",
          "",
          "[Added Lines]",
          "22: #define QUEUE_NEXT(q)       (*(QUEUE **) &((*(q))[0]))",
          "23: #define QUEUE_PREV(q)       (*(QUEUE **) &((*(q))[1]))",
          "24: #define QUEUE_PREV_NEXT(q)  (QUEUE_NEXT(QUEUE_PREV(q)))",
          "25: #define QUEUE_NEXT_PREV(q)  (QUEUE_PREV(QUEUE_NEXT(q)))",
          "32:   for ((q) = QUEUE_NEXT(h); (q) != (h); (q) = QUEUE_NEXT(q))",
          "35:   ((const QUEUE *) (q) == (const QUEUE *) QUEUE_NEXT(q))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "38323c9fbff49aee990528c145609c2a8241ad03",
      "candidate_info": {
        "commit_hash": "38323c9fbff49aee990528c145609c2a8241ad03",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/38323c9fbff49aee990528c145609c2a8241ad03",
        "files": [
          "src/unix/openbsd.c"
        ],
        "message": "openbsd: avoid requiring privileges for uv_resident_set_memory",
        "before_after_code_files": [
          "src/unix/openbsd.c||src/unix/openbsd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/openbsd.c||src/unix/openbsd.c": [
          "File: src/unix/openbsd.c -> src/unix/openbsd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "182: int uv_resident_set_memory(size_t* rss) {",
          "187:   size_t page_size = getpagesize();",
          "201:   return 0;",
          "206: }",
          "",
          "[Removed Lines]",
          "183:   kvm_t *kd = NULL;",
          "184:   struct kinfo_proc *kinfo = NULL;",
          "185:   pid_t pid;",
          "186:   int nprocs, max_size = sizeof(struct kinfo_proc);",
          "189:   pid = getpid();",
          "191:   kd = kvm_open(NULL, _PATH_MEM, NULL, O_RDONLY, \"kvm_open\");",
          "192:   if (kd == NULL) goto error;",
          "194:   kinfo = kvm_getprocs(kd, KERN_PROC_PID, pid, max_size, &nprocs);",
          "195:   if (kinfo == NULL) goto error;",
          "199:   kvm_close(kd);",
          "203: error:",
          "204:   if (kd) kvm_close(kd);",
          "205:   return -EPERM;",
          "",
          "[Added Lines]",
          "183:   struct kinfo_proc kinfo;",
          "185:   size_t size = sizeof(struct kinfo_proc);",
          "186:   int mib[6];",
          "188:   mib[0] = CTL_KERN;",
          "189:   mib[1] = KERN_PROC;",
          "190:   mib[2] = KERN_PROC_PID;",
          "191:   mib[3] = getpid();",
          "192:   mib[4] = sizeof(struct kinfo_proc);",
          "193:   mib[5] = 1;",
          "195:   if (sysctl(mib, 6, &kinfo, &size, NULL, 0) < 0)",
          "196:     return -errno;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4fac9427e4a652cdebf241803ce7443dd59a4451",
      "candidate_info": {
        "commit_hash": "4fac9427e4a652cdebf241803ce7443dd59a4451",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/4fac9427e4a652cdebf241803ce7443dd59a4451",
        "files": [
          "src/inet.c",
          "test/test-ip6-addr.c"
        ],
        "message": "unix, windows: fix parsing scoped IPv6 addresses\n\nSigned-off-by: Sa\u00fal Ibarra Corretg\u00e9 <saghul@gmail.com>",
        "before_after_code_files": [
          "src/inet.c||src/inet.c",
          "test/test-ip6-addr.c||test/test-ip6-addr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/inet.c||src/inet.c": [
          "File: src/inet.c -> src/inet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "161: int uv_inet_pton(int af, const char* src, void* dst) {",
          "162:   switch (af) {",
          "163:   case AF_INET:",
          "164:     return (inet_pton4(src, dst));",
          "167:   default:",
          "168:     return UV_EAFNOSUPPORT;",
          "169:   }",
          "",
          "[Removed Lines]",
          "165:   case AF_INET6:",
          "166:     return (inet_pton6(src, dst));",
          "",
          "[Added Lines]",
          "162:   if (src == NULL || dst == NULL)",
          "163:     return UV_EINVAL;",
          "168:   case AF_INET6: {",
          "169:     int len;",
          "170:     char tmp[UV__INET6_ADDRSTRLEN], *s, *p;",
          "171:     s = (char*) src;",
          "172:     p = strchr(src, '%');",
          "173:     if (p != NULL) {",
          "174:       s = tmp;",
          "175:       len = p - src;",
          "176:       if (len > UV__INET6_ADDRSTRLEN-1)",
          "177:         return UV_EINVAL;",
          "178:       memcpy(s, src, len);",
          "179:       s[len] = '\\0';",
          "180:     }",
          "181:     return inet_pton6(s, dst);",
          "182:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "228:   curtok = src;",
          "229:   seen_xdigits = 0;",
          "230:   val = 0;",
          "232:     const char *pch;",
          "234:     if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)",
          "",
          "[Removed Lines]",
          "231:   while ((ch = *src++) != '\\0' && ch != '%') {",
          "",
          "[Added Lines]",
          "247:   while ((ch = *src++) != '\\0') {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "259:       continue;",
          "260:     }",
          "261:     if (ch == '.' && ((tp + sizeof(struct in_addr)) <= endp)) {",
          "275:       if (err == 0) {",
          "276:         tp += sizeof(struct in_addr);",
          "277:         seen_xdigits = 0;",
          "",
          "[Removed Lines]",
          "262:       int err;",
          "265:       pch = strchr(curtok, '%');",
          "266:       if (pch != NULL) {",
          "267:         char tmp[sizeof \"255.255.255.255\"];",
          "269:         memcpy(tmp, curtok, pch - curtok);",
          "270:         curtok = tmp;",
          "271:         src = pch;",
          "272:       }",
          "274:       err = inet_pton4(curtok, tp);",
          "",
          "[Added Lines]",
          "278:       int err = inet_pton4(curtok, tp);",
          "",
          "---------------"
        ],
        "test/test-ip6-addr.c||test/test-ip6-addr.c": [
          "File: test/test-ip6-addr.c -> test/test-ip6-addr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103:     X(\"fe80::2acf:daff:fedd:342a\")                                            \\",
          "104:     X(\"fe80:0:0:0:2acf:daff:fedd:342a\")                                       \\",
          "105:     X(\"fe80:0:0:0:2acf:daff:1.2.3.4\")                                         \\",
          "107: #define BAD_ADDR_LIST(X)                                                      \\",
          "108:     X(\":::1\")                                                                 \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "106:     X(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255\")                        \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "110:     X(\"fe80:0:0:0:2acf:daff:fedd:342a:5678\")                                  \\",
          "111:     X(\"fe80:0:0:0:2acf:daff:abcd:1.2.3.4\")                                    \\",
          "112:     X(\"fe80:0:0:2acf:daff:1.2.3.4.5\")                                         \\",
          "114: #define TEST_GOOD(ADDR)                                                       \\",
          "115:     ASSERT(0 == uv_inet_pton(AF_INET6, ADDR, &addr));                         \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "114:     X(\"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255.255\")                    \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "06f9e1438ed20dd83618bca78759ea8635a79289",
      "candidate_info": {
        "commit_hash": "06f9e1438ed20dd83618bca78759ea8635a79289",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/06f9e1438ed20dd83618bca78759ea8635a79289",
        "files": [
          "include/uv.h"
        ],
        "message": "core: add a reserved field to uv_handle_t and uv_req_t\n\nJust in case we need to work hard in keeping ABI compatibility.",
        "before_after_code_files": [
          "include/uv.h||include/uv.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "503:   uv_req_type type;                                                           \\",
          "505:   void* active_queue[2];                                                      \\",
          "506:   UV_REQ_PRIVATE_FIELDS                                                       \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "506:   void* reserved[4];                                                          \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "545:   uv_close_cb close_cb;                                                       \\",
          "546:   void* handle_queue[2];                                                      \\",
          "547:   UV_HANDLE_PRIVATE_FIELDS                                                    \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "548:   void* reserved[4];                                                          \\",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b44edf313c1a312e261932b36e3dc40790d48266",
      "candidate_info": {
        "commit_hash": "b44edf313c1a312e261932b36e3dc40790d48266",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/b44edf313c1a312e261932b36e3dc40790d48266",
        "files": [
          "test/test-spawn.c"
        ],
        "message": "test: allow UV_EACCES in spawn_fails\n\nAllow UV_EACCES as a successful return value when uv_spawn fails.\n\nWhen the PATH environment variable contains a directory which the\nuser cannot access, execvp may return EACCES instead of ENOENT.\n\nfix #1045.",
        "before_after_code_files": [
          "test/test-spawn.c||test/test-spawn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-spawn.c||test/test-spawn.c": [
          "File: test/test-spawn.c -> test/test-spawn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "148: TEST_IMPL(spawn_fails) {",
          "149:   init_process_options(\"\", fail_cb);",
          "150:   options.file = options.args[0] = \"program-that-had-better-not-exist\";",
          "153:   ASSERT(0 == uv_is_active((uv_handle_t*) &process));",
          "154:   ASSERT(0 == uv_run(uv_default_loop(), UV_RUN_DEFAULT));",
          "",
          "[Removed Lines]",
          "152:   ASSERT(UV_ENOENT == uv_spawn(uv_default_loop(), &process, &options));",
          "",
          "[Added Lines]",
          "149:   int r;",
          "154:   r = uv_spawn(uv_default_loop(), &process, &options);",
          "155:   ASSERT(r == UV_ENOENT || r == UV_EACCES);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
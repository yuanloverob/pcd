{
  "cve_id": "CVE-2014-2889",
  "cve_desc": "Off-by-one error in the bpf_jit_compile function in arch/x86/net/bpf_jit_comp.c in the Linux kernel before 3.1.8, when BPF JIT is enabled, allows local users to cause a denial of service (system crash) or possibly gain privileges via a long jump after a conditional jump.",
  "repo": "torvalds/linux",
  "patch_hash": "a03ffcf873fe0f2565386ca8ef832144c42e67fa",
  "patch_info": {
    "commit_hash": "a03ffcf873fe0f2565386ca8ef832144c42e67fa",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/a03ffcf873fe0f2565386ca8ef832144c42e67fa",
    "files": [
      "arch/x86/net/bpf_jit_comp.c"
    ],
    "message": "net: bpf_jit: fix an off-one bug in x86_64 cond jump target\n\nx86 jump instruction size is 2 or 5 bytes (near/long jump), not 2 or 6\nbytes.\n\nIn case a conditional jump is followed by a long jump, conditional jump\ntarget is one byte past the start of target instruction.\n\nSigned-off-by: Markus K\u00f6tter <nepenthesdev@gmail.com>\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
    "before_after_code_files": [
      "arch/x86/net/bpf_jit_comp.c||arch/x86/net/bpf_jit_comp.c"
    ]
  },
  "patch_diff": {
    "arch/x86/net/bpf_jit_comp.c||arch/x86/net/bpf_jit_comp.c": [
      "File: arch/x86/net/bpf_jit_comp.c -> arch/x86/net/bpf_jit_comp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "568:      break;",
      "569:     }",
      "570:     if (filter[i].jt != 0) {",
      "573:      EMIT_COND_JMP(t_op, t_offset);",
      "574:      if (filter[i].jf)",
      "575:       EMIT_JMP(f_offset);",
      "",
      "[Removed Lines]",
      "571:      if (filter[i].jf)",
      "572:       t_offset += is_near(f_offset) ? 2 : 6;",
      "",
      "[Added Lines]",
      "571:      if (filter[i].jf && f_offset)",
      "572:       t_offset += is_near(f_offset) ? 2 : 5;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "0a14842f5a3c0e88a1e59fac5c3025db39721f74",
      "candidate_info": {
        "commit_hash": "0a14842f5a3c0e88a1e59fac5c3025db39721f74",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/0a14842f5a3c0e88a1e59fac5c3025db39721f74",
        "files": [
          "Documentation/sysctl/net.txt",
          "MAINTAINERS",
          "arch/x86/Kbuild",
          "arch/x86/Kconfig",
          "arch/x86/net/Makefile",
          "arch/x86/net/bpf_jit.S",
          "arch/x86/net/bpf_jit_comp.c",
          "include/linux/filter.h",
          "include/linux/netdevice.h",
          "include/linux/skbuff.h",
          "net/Kconfig",
          "net/core/filter.c",
          "net/core/sysctl_net_core.c",
          "net/packet/af_packet.c"
        ],
        "message": "net: filter: Just In Time compiler for x86-64\n\nIn order to speedup packet filtering, here is an implementation of a\nJIT compiler for x86_64\n\nIt is disabled by default, and must be enabled by the admin.\n\necho 1 >/proc/sys/net/core/bpf_jit_enable\n\nIt uses module_alloc() and module_free() to get memory in the 2GB text\nkernel range since we call helpers functions from the generated code.\n\nEAX : BPF A accumulator\nEBX : BPF X accumulator\nRDI : pointer to skb   (first argument given to JIT function)\nRBP : frame pointer (even if CONFIG_FRAME_POINTER=n)\nr9d : skb->len - skb->data_len (headlen)\nr8  : skb->data\n\nTo get a trace of generated code, use :\n\necho 2 >/proc/sys/net/core/bpf_jit_enable\n\nExample of generated code :\n\n# tcpdump -p -n -s 0 -i eth1 host 192.168.20.0/24\n\nflen=18 proglen=147 pass=3 image=ffffffffa00b5000\nJIT code: ffffffffa00b5000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 60\nJIT code: ffffffffa00b5010: 44 2b 4f 64 4c 8b 87 b8 00 00 00 be 0c 00 00 00\nJIT code: ffffffffa00b5020: e8 24 7b f7 e0 3d 00 08 00 00 75 28 be 1a 00 00\nJIT code: ffffffffa00b5030: 00 e8 fe 7a f7 e0 24 00 3d 00 14 a8 c0 74 49 be\nJIT code: ffffffffa00b5040: 1e 00 00 00 e8 eb 7a f7 e0 24 00 3d 00 14 a8 c0\nJIT code: ffffffffa00b5050: 74 36 eb 3b 3d 06 08 00 00 74 07 3d 35 80 00 00\nJIT code: ffffffffa00b5060: 75 2d be 1c 00 00 00 e8 c8 7a f7 e0 24 00 3d 00\nJIT code: ffffffffa00b5070: 14 a8 c0 74 13 be 26 00 00 00 e8 b5 7a f7 e0 24\nJIT code: ffffffffa00b5080: 00 3d 00 14 a8 c0 75 07 b8 ff ff 00 00 eb 02 31\nJIT code: ffffffffa00b5090: c0 c9 c3\n\nBPF program is 144 bytes long, so native program is almost same size ;)\n\n(000) ldh      [12]\n(001) jeq      #0x800           jt 2    jf 8\n(002) ld       [26]\n(003) and      #0xffffff00\n(004) jeq      #0xc0a81400      jt 16   jf 5\n(005) ld       [30]\n(006) and      #0xffffff00\n(007) jeq      #0xc0a81400      jt 16   jf 17\n(008) jeq      #0x806           jt 10   jf 9\n(009) jeq      #0x8035          jt 10   jf 17\n(010) ld       [28]\n(011) and      #0xffffff00\n(012) jeq      #0xc0a81400      jt 16   jf 13\n(013) ld       [38]\n(014) and      #0xffffff00\n(015) jeq      #0xc0a81400      jt 16   jf 17\n(016) ret      #65535\n(017) ret      #0\n\nSigned-off-by: Eric Dumazet <eric.dumazet@gmail.com>\nCc: Arnaldo Carvalho de Melo <acme@infradead.org>\nCc: Ben Hutchings <bhutchings@solarflare.com>\nCc: Hagen Paul Pfeifer <hagen@jauu.net>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "before_after_code_files": [
          "arch/x86/net/bpf_jit.S||arch/x86/net/bpf_jit.S",
          "arch/x86/net/bpf_jit_comp.c||arch/x86/net/bpf_jit_comp.c",
          "include/linux/filter.h||include/linux/filter.h",
          "include/linux/netdevice.h||include/linux/netdevice.h",
          "include/linux/skbuff.h||include/linux/skbuff.h",
          "net/core/filter.c||net/core/filter.c",
          "net/core/sysctl_net_core.c||net/core/sysctl_net_core.c",
          "net/packet/af_packet.c||net/packet/af_packet.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/x86/net/bpf_jit_comp.c||arch/x86/net/bpf_jit_comp.c"
          ],
          "candidate": [
            "arch/x86/net/bpf_jit_comp.c||arch/x86/net/bpf_jit_comp.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/x86/net/bpf_jit.S||arch/x86/net/bpf_jit.S": [
          "File: arch/x86/net/bpf_jit.S -> arch/x86/net/bpf_jit.S",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <linux/linkage.h>",
          "11: #include <asm/dwarf2.h>",
          "20: #define SKBDATA %r8",
          "22: sk_load_word_ind:",
          "23:  .globl sk_load_word_ind",
          "27:  js bpf_error",
          "29: sk_load_word:",
          "30:  .globl sk_load_word",
          "32:  mov %r9d,%eax  # hlen",
          "33:  sub %esi,%eax  # hlen - offset",
          "34:  cmp $3,%eax",
          "35:  jle bpf_slow_path_word",
          "36:  mov     (SKBDATA,%rsi),%eax",
          "38:  ret",
          "41: sk_load_half_ind:",
          "42:  .globl sk_load_half_ind",
          "45:  js bpf_error",
          "47: sk_load_half:",
          "48:  .globl sk_load_half",
          "50:  mov %r9d,%eax",
          "51:  sub %esi,%eax  # hlen - offset",
          "52:  cmp $1,%eax",
          "53:  jle bpf_slow_path_half",
          "54:  movzwl (SKBDATA,%rsi),%eax",
          "55:  rol $8,%ax   # ntohs()",
          "56:  ret",
          "58: sk_load_byte_ind:",
          "59:  .globl sk_load_byte_ind",
          "61:  js bpf_error",
          "63: sk_load_byte:",
          "64:  .globl sk_load_byte",
          "67:  jle bpf_slow_path_byte",
          "68:  movzbl (SKBDATA,%rsi),%eax",
          "69:  ret",
          "78: ENTRY(sk_load_byte_msh)",
          "79:  CFI_STARTPROC",
          "81:  jle bpf_slow_path_byte_msh",
          "82:  movzbl (SKBDATA,%rsi),%ebx",
          "83:  and $15,%bl",
          "84:  shl $2,%bl",
          "85:  ret",
          "86:  CFI_ENDPROC",
          "87: ENDPROC(sk_load_byte_msh)",
          "89: bpf_error:",
          "90: # force a return 0 from jit handler",
          "91:  xor  %eax,%eax",
          "92:  mov  -8(%rbp),%rbx",
          "93:  leaveq",
          "94:  ret",
          "97: #define bpf_slow_path_common(LEN)  \\",
          "98:  push %rdi;    /* save skb */  \\",
          "99:  push %r9;    \\",
          "100:  push SKBDATA;   \\",
          "102:  mov $LEN,%ecx; /* len */ \\",
          "103:  lea -12(%rbp),%rdx;   \\",
          "104:  call skb_copy_bits;   \\",
          "105:  test    %eax,%eax;   \\",
          "106:  pop SKBDATA;   \\",
          "107:  pop %r9;    \\",
          "108:  pop %rdi",
          "111: bpf_slow_path_word:",
          "112:  bpf_slow_path_common(4)",
          "113:  js bpf_error",
          "114:  mov -12(%rbp),%eax",
          "115:  bswap %eax",
          "116:  ret",
          "118: bpf_slow_path_half:",
          "119:  bpf_slow_path_common(2)",
          "120:  js bpf_error",
          "121:  mov -12(%rbp),%ax",
          "122:  rol $8,%ax",
          "123:  movzwl %ax,%eax",
          "124:  ret",
          "126: bpf_slow_path_byte:",
          "127:  bpf_slow_path_common(1)",
          "128:  js bpf_error",
          "129:  movzbl -12(%rbp),%eax",
          "130:  ret",
          "132: bpf_slow_path_byte_msh:",
          "134:  bpf_slow_path_common(1)",
          "135:  js bpf_error",
          "136:  movzbl -12(%rbp),%eax",
          "137:  and $15,%al",
          "138:  shl $2,%al",
          "139:  xchg %eax,%ebx",
          "140:  ret",
          "",
          "---------------"
        ],
        "arch/x86/net/bpf_jit_comp.c||arch/x86/net/bpf_jit_comp.c": [
          "File: arch/x86/net/bpf_jit_comp.c -> arch/x86/net/bpf_jit_comp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "10: #include <linux/moduleloader.h>",
          "11: #include <asm/cacheflush.h>",
          "12: #include <linux/netdevice.h>",
          "13: #include <linux/filter.h>",
          "27: int bpf_jit_enable __read_mostly;",
          "32: extern u8 sk_load_word[], sk_load_half[], sk_load_byte[], sk_load_byte_msh[];",
          "33: extern u8 sk_load_word_ind[], sk_load_half_ind[], sk_load_byte_ind[];",
          "35: static inline u8 *emit_code(u8 *ptr, u32 bytes, unsigned int len)",
          "36: {",
          "37:  if (len == 1)",
          "39:  else if (len == 2)",
          "41:  else {",
          "43:   barrier();",
          "44:  }",
          "45:  return ptr + len;",
          "46: }",
          "48: #define EMIT(bytes, len) do { prog = emit_code(prog, bytes, len); } while (0)",
          "50: #define EMIT1(b1)  EMIT(b1, 1)",
          "51: #define EMIT2(b1, b2)  EMIT((b1) + ((b2) << 8), 2)",
          "52: #define EMIT3(b1, b2, b3) EMIT((b1) + ((b2) << 8) + ((b3) << 16), 3)",
          "53: #define EMIT4(b1, b2, b3, b4)   EMIT((b1) + ((b2) << 8) + ((b3) << 16) + ((b4) << 24), 4)",
          "54: #define EMIT1_off32(b1, off) do { EMIT1(b1); EMIT(off, 4);} while (0)",
          "59: static inline bool is_imm8(int value)",
          "60: {",
          "61:  return value <= 127 && value >= -128;",
          "62: }",
          "64: static inline bool is_near(int offset)",
          "65: {",
          "66:  return offset <= 127 && offset >= -128;",
          "67: }",
          "69: #define EMIT_JMP(offset)      \\",
          "70: do {         \\",
          "71:  if (offset) {       \\",
          "72:   if (is_near(offset))     \\",
          "73:    EMIT2(0xeb, offset); /* jmp .+off8 */  \\",
          "74:   else       \\",
          "75:    EMIT1_off32(0xe9, offset); /* jmp .+off32 */ \\",
          "76:  }        \\",
          "77: } while (0)",
          "82: #define X86_JB  0x72",
          "83: #define X86_JAE 0x73",
          "84: #define X86_JE  0x74",
          "85: #define X86_JNE 0x75",
          "86: #define X86_JBE 0x76",
          "87: #define X86_JA  0x77",
          "89: #define EMIT_COND_JMP(op, offset)    \\",
          "90: do {        \\",
          "91:  if (is_near(offset))     \\",
          "92:   EMIT2(op, offset); /* jxx .+off8 */  \\",
          "93:  else {       \\",
          "94:   EMIT2(0x0f, op + 0x10);    \\",
          "95:   EMIT(offset, 4); /* jxx .+off32 */  \\",
          "96:  }       \\",
          "97: } while (0)",
          "99: #define COND_SEL(CODE, TOP, FOP) \\",
          "100:  case CODE:   \\",
          "101:   t_op = TOP;  \\",
          "102:   f_op = FOP;  \\",
          "103:   goto cond_branch",
          "110: static inline void bpf_flush_icache(void *start, void *end)",
          "111: {",
          "112:  mm_segment_t old_fs = get_fs();",
          "114:  set_fs(KERNEL_DS);",
          "115:  smp_wmb();",
          "116:  flush_icache_range((unsigned long)start, (unsigned long)end);",
          "117:  set_fs(old_fs);",
          "118: }",
          "121: void bpf_jit_compile(struct sk_filter *fp)",
          "122: {",
          "123:  u8 temp[64];",
          "124:  u8 *prog;",
          "125:  unsigned int proglen, oldproglen = 0;",
          "126:  int ilen, i;",
          "127:  int t_offset, f_offset;",
          "128:  u8 t_op, f_op, seen = 0, pass;",
          "129:  u8 *image = NULL;",
          "130:  u8 *func;",
          "133:  unsigned int *addrs;",
          "134:  const struct sock_filter *filter = fp->insns;",
          "135:  int flen = fp->len;",
          "137:  if (!bpf_jit_enable)",
          "138:   return;",
          "140:  addrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);",
          "141:  if (addrs == NULL)",
          "142:   return;",
          "147:  for (proglen = 0, i = 0; i < flen; i++) {",
          "148:   proglen += 64;",
          "149:   addrs[i] = proglen;",
          "150:  }",
          "153:  for (pass = 0; pass < 10; pass++) {",
          "155:   proglen = 0;",
          "156:   prog = temp;",
          "158:   if (seen) {",
          "162:    if (seen & (SEEN_XREG | SEEN_DATAREF))",
          "164:    if (seen & SEEN_XREG)",
          "173:    if (seen & SEEN_DATAREF) {",
          "174:     if (offsetof(struct sk_buff, len) <= 127)",
          "176:      EMIT4(0x44, 0x8b, 0x4f, offsetof(struct sk_buff, len));",
          "177:     else {",
          "179:      EMIT3(0x44, 0x8b, 0x8f);",
          "180:      EMIT(offsetof(struct sk_buff, len), 4);",
          "181:     }",
          "182:     if (is_imm8(offsetof(struct sk_buff, data_len)))",
          "184:      EMIT4(0x44, 0x2b, 0x4f, offsetof(struct sk_buff, data_len));",
          "185:     else {",
          "186:      EMIT3(0x44, 0x2b, 0x8f);",
          "187:      EMIT(offsetof(struct sk_buff, data_len), 4);",
          "188:     }",
          "190:     if (is_imm8(offsetof(struct sk_buff, data)))",
          "192:      EMIT4(0x4c, 0x8b, 0x47, offsetof(struct sk_buff, data));",
          "193:     else {",
          "195:      EMIT3(0x4c, 0x8b, 0x87);",
          "196:      EMIT(offsetof(struct sk_buff, data), 4);",
          "197:     }",
          "198:    }",
          "199:   }",
          "201:   switch (filter[0].code) {",
          "202:   case BPF_S_RET_K:",
          "203:   case BPF_S_LD_W_LEN:",
          "204:   case BPF_S_ANC_PROTOCOL:",
          "205:   case BPF_S_ANC_IFINDEX:",
          "206:   case BPF_S_ANC_MARK:",
          "207:   case BPF_S_ANC_RXHASH:",
          "208:   case BPF_S_ANC_CPU:",
          "209:   case BPF_S_ANC_QUEUE:",
          "210:   case BPF_S_LD_W_ABS:",
          "211:   case BPF_S_LD_H_ABS:",
          "212:   case BPF_S_LD_B_ABS:",
          "214:    break;",
          "215:   default:",
          "218:   }",
          "220:   for (i = 0; i < flen; i++) {",
          "221:    unsigned int K = filter[i].k;",
          "223:    switch (filter[i].code) {",
          "225:     seen |= SEEN_XREG;",
          "227:     break;",
          "229:     if (!K)",
          "230:      break;",
          "231:     if (is_imm8(K))",
          "233:     else",
          "235:     break;",
          "237:     seen |= SEEN_XREG;",
          "239:     break;",
          "241:     if (!K)",
          "242:      break;",
          "243:     if (is_imm8(K))",
          "245:     else",
          "247:     break;",
          "249:     seen |= SEEN_XREG;",
          "251:     break;",
          "253:     if (is_imm8(K))",
          "255:     else {",
          "257:      EMIT(K, 4);",
          "258:     }",
          "259:     break;",
          "261:     seen |= SEEN_XREG;",
          "263:     if (pc_ret0 != -1)",
          "264:      EMIT_COND_JMP(X86_JE, addrs[pc_ret0] - (addrs[i] - 4));",
          "265:     else {",
          "266:      EMIT_COND_JMP(X86_JNE, 2 + 5);",
          "267:      CLEAR_A();",
          "269:     }",
          "271:     break;",
          "274:     EMIT(K, 4);",
          "276:     break;",
          "277:    case BPF_S_ALU_AND_X:",
          "278:     seen |= SEEN_XREG;",
          "280:     break;",
          "281:    case BPF_S_ALU_AND_K:",
          "282:     if (K >= 0xFFFFFF00) {",
          "284:     } else if (K >= 0xFFFF0000) {",
          "286:      EMIT2(K, 2);",
          "287:     } else {",
          "289:     }",
          "290:     break;",
          "291:    case BPF_S_ALU_OR_X:",
          "292:     seen |= SEEN_XREG;",
          "294:     break;",
          "295:    case BPF_S_ALU_OR_K:",
          "296:     if (is_imm8(K))",
          "298:     else",
          "300:     break;",
          "302:     seen |= SEEN_XREG;",
          "304:     break;",
          "305:    case BPF_S_ALU_LSH_K:",
          "306:     if (K == 0)",
          "307:      break;",
          "308:     else if (K == 1)",
          "310:     else",
          "311:      EMIT3(0xc1, 0xe0, K);",
          "312:     break;",
          "314:     seen |= SEEN_XREG;",
          "316:     break;",
          "318:     if (K == 0)",
          "319:      break;",
          "320:     else if (K == 1)",
          "322:     else",
          "323:      EMIT3(0xc1, 0xe8, K);",
          "324:     break;",
          "325:    case BPF_S_ALU_NEG:",
          "327:     break;",
          "328:    case BPF_S_RET_K:",
          "329:     if (!K) {",
          "330:      if (pc_ret0 == -1)",
          "331:       pc_ret0 = i;",
          "332:      CLEAR_A();",
          "333:     } else {",
          "335:     }",
          "337:    case BPF_S_RET_A:",
          "338:     if (seen) {",
          "339:      if (i != flen - 1) {",
          "340:       EMIT_JMP(cleanup_addr - addrs[i]);",
          "341:       break;",
          "342:      }",
          "343:      if (seen & SEEN_XREG)",
          "346:     }",
          "348:     break;",
          "350:     seen |= SEEN_XREG;",
          "352:     break;",
          "354:     seen |= SEEN_XREG;",
          "356:     break;",
          "358:     if (!K)",
          "359:      CLEAR_A();",
          "360:     else",
          "362:     break;",
          "364:     seen |= SEEN_XREG;",
          "365:     if (!K)",
          "366:      CLEAR_X();",
          "367:     else",
          "369:     break;",
          "371:     seen |= SEEN_MEM;",
          "372:     EMIT3(0x8b, 0x45, 0xf0 - K*4);",
          "373:     break;",
          "375:     seen |= SEEN_XREG | SEEN_MEM;",
          "376:     EMIT3(0x8b, 0x5d, 0xf0 - K*4);",
          "377:     break;",
          "379:     seen |= SEEN_MEM;",
          "380:     EMIT3(0x89, 0x45, 0xf0 - K*4);",
          "381:     break;",
          "383:     seen |= SEEN_XREG | SEEN_MEM;",
          "384:     EMIT3(0x89, 0x5d, 0xf0 - K*4);",
          "385:     break;",
          "387:     BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, len) != 4);",
          "388:     if (is_imm8(offsetof(struct sk_buff, len)))",
          "390:      EMIT3(0x8b, 0x47, offsetof(struct sk_buff, len));",
          "391:     else {",
          "392:      EMIT2(0x8b, 0x87);",
          "393:      EMIT(offsetof(struct sk_buff, len), 4);",
          "394:     }",
          "395:     break;",
          "397:     seen |= SEEN_XREG;",
          "398:     if (is_imm8(offsetof(struct sk_buff, len)))",
          "400:      EMIT3(0x8b, 0x5f, offsetof(struct sk_buff, len));",
          "401:     else {",
          "402:      EMIT2(0x8b, 0x9f);",
          "403:      EMIT(offsetof(struct sk_buff, len), 4);",
          "404:     }",
          "405:     break;",
          "407:     BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, protocol) != 2);",
          "408:     if (is_imm8(offsetof(struct sk_buff, protocol))) {",
          "410:      EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, protocol));",
          "411:     } else {",
          "413:      EMIT(offsetof(struct sk_buff, protocol), 4);",
          "414:     }",
          "416:     break;",
          "417:    case BPF_S_ANC_IFINDEX:",
          "418:     if (is_imm8(offsetof(struct sk_buff, dev))) {",
          "420:      EMIT4(0x48, 0x8b, 0x47, offsetof(struct sk_buff, dev));",
          "421:     } else {",
          "423:      EMIT(offsetof(struct sk_buff, dev), 4);",
          "424:     }",
          "426:     EMIT_COND_JMP(X86_JE, cleanup_addr - (addrs[i] - 6));",
          "427:     BUILD_BUG_ON(FIELD_SIZEOF(struct net_device, ifindex) != 4);",
          "429:     EMIT(offsetof(struct net_device, ifindex), 4);",
          "430:     break;",
          "431:    case BPF_S_ANC_MARK:",
          "432:     BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, mark) != 4);",
          "433:     if (is_imm8(offsetof(struct sk_buff, mark))) {",
          "435:      EMIT3(0x8b, 0x47, offsetof(struct sk_buff, mark));",
          "436:     } else {",
          "437:      EMIT2(0x8b, 0x87);",
          "438:      EMIT(offsetof(struct sk_buff, mark), 4);",
          "439:     }",
          "440:     break;",
          "441:    case BPF_S_ANC_RXHASH:",
          "442:     BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, rxhash) != 4);",
          "443:     if (is_imm8(offsetof(struct sk_buff, rxhash))) {",
          "445:      EMIT3(0x8b, 0x47, offsetof(struct sk_buff, rxhash));",
          "446:     } else {",
          "447:      EMIT2(0x8b, 0x87);",
          "448:      EMIT(offsetof(struct sk_buff, rxhash), 4);",
          "449:     }",
          "450:     break;",
          "451:    case BPF_S_ANC_QUEUE:",
          "452:     BUILD_BUG_ON(FIELD_SIZEOF(struct sk_buff, queue_mapping) != 2);",
          "453:     if (is_imm8(offsetof(struct sk_buff, queue_mapping))) {",
          "455:      EMIT4(0x0f, 0xb7, 0x47, offsetof(struct sk_buff, queue_mapping));",
          "456:     } else {",
          "458:      EMIT(offsetof(struct sk_buff, queue_mapping), 4);",
          "459:     }",
          "460:     break;",
          "461:    case BPF_S_ANC_CPU:",
          "462: #ifdef CONFIG_SMP",
          "465: #else",
          "466:     CLEAR_A();",
          "467: #endif",
          "468:     break;",
          "469:    case BPF_S_LD_W_ABS:",
          "470:     func = sk_load_word;",
          "471: common_load:   seen |= SEEN_DATAREF;",
          "472:     if ((int)K < 0)",
          "473:      goto out;",
          "474:     t_offset = func - (image + addrs[i]);",
          "477:     break;",
          "478:    case BPF_S_LD_H_ABS:",
          "479:     func = sk_load_half;",
          "480:     goto common_load;",
          "481:    case BPF_S_LD_B_ABS:",
          "482:     func = sk_load_byte;",
          "483:     goto common_load;",
          "484:    case BPF_S_LDX_B_MSH:",
          "485:     if ((int)K < 0) {",
          "486:      if (pc_ret0 != -1) {",
          "487:       EMIT_JMP(addrs[pc_ret0] - addrs[i]);",
          "488:       break;",
          "489:      }",
          "490:      CLEAR_A();",
          "491:      EMIT_JMP(cleanup_addr - addrs[i]);",
          "492:      break;",
          "493:     }",
          "494:     seen |= SEEN_DATAREF | SEEN_XREG;",
          "495:     t_offset = sk_load_byte_msh - (image + addrs[i]);",
          "498:     break;",
          "499:    case BPF_S_LD_W_IND:",
          "500:     func = sk_load_word_ind;",
          "501: common_load_ind:  seen |= SEEN_DATAREF | SEEN_XREG;",
          "502:     t_offset = func - (image + addrs[i]);",
          "505:     break;",
          "506:    case BPF_S_LD_H_IND:",
          "507:     func = sk_load_half_ind;",
          "508:     goto common_load_ind;",
          "509:    case BPF_S_LD_B_IND:",
          "510:     func = sk_load_byte_ind;",
          "511:     goto common_load_ind;",
          "512:    case BPF_S_JMP_JA:",
          "513:     t_offset = addrs[i + K] - addrs[i];",
          "514:     EMIT_JMP(t_offset);",
          "515:     break;",
          "516:    COND_SEL(BPF_S_JMP_JGT_K, X86_JA, X86_JBE);",
          "517:    COND_SEL(BPF_S_JMP_JGE_K, X86_JAE, X86_JB);",
          "518:    COND_SEL(BPF_S_JMP_JEQ_K, X86_JE, X86_JNE);",
          "519:    COND_SEL(BPF_S_JMP_JSET_K,X86_JNE, X86_JE);",
          "520:    COND_SEL(BPF_S_JMP_JGT_X, X86_JA, X86_JBE);",
          "521:    COND_SEL(BPF_S_JMP_JGE_X, X86_JAE, X86_JB);",
          "522:    COND_SEL(BPF_S_JMP_JEQ_X, X86_JE, X86_JNE);",
          "523:    COND_SEL(BPF_S_JMP_JSET_X,X86_JNE, X86_JE);",
          "525: cond_branch:   f_offset = addrs[i + filter[i].jf] - addrs[i];",
          "526:     t_offset = addrs[i + filter[i].jt] - addrs[i];",
          "529:     if (filter[i].jt == filter[i].jf) {",
          "530:      EMIT_JMP(t_offset);",
          "531:      break;",
          "532:     }",
          "534:     switch (filter[i].code) {",
          "535:     case BPF_S_JMP_JGT_X:",
          "536:     case BPF_S_JMP_JGE_X:",
          "537:     case BPF_S_JMP_JEQ_X:",
          "538:      seen |= SEEN_XREG;",
          "540:      break;",
          "541:     case BPF_S_JMP_JSET_X:",
          "542:      seen |= SEEN_XREG;",
          "544:      break;",
          "545:     case BPF_S_JMP_JEQ_K:",
          "546:      if (K == 0) {",
          "548:       break;",
          "549:      }",
          "550:     case BPF_S_JMP_JGT_K:",
          "551:     case BPF_S_JMP_JGE_K:",
          "552:      if (K <= 127)",
          "554:      else",
          "556:      break;",
          "557:     case BPF_S_JMP_JSET_K:",
          "558:      if (K <= 0xFF)",
          "560:      else if (!(K & 0xFFFF00FF))",
          "562:      else if (K <= 0xFFFF) {",
          "564:       EMIT(K, 2);",
          "565:      } else {",
          "567:      }",
          "568:      break;",
          "569:     }",
          "570:     if (filter[i].jt != 0) {",
          "571:      if (filter[i].jf)",
          "572:       t_offset += is_near(f_offset) ? 2 : 6;",
          "573:      EMIT_COND_JMP(t_op, t_offset);",
          "574:      if (filter[i].jf)",
          "575:       EMIT_JMP(f_offset);",
          "576:      break;",
          "577:     }",
          "578:     EMIT_COND_JMP(f_op, f_offset);",
          "579:     break;",
          "580:    default:",
          "582:     goto out;",
          "583:    }",
          "584:    ilen = prog - temp;",
          "585:    if (image) {",
          "586:     if (unlikely(proglen + ilen > oldproglen)) {",
          "587:      pr_err(\"bpb_jit_compile fatal error\\n\");",
          "588:      kfree(addrs);",
          "589:      module_free(NULL, image);",
          "590:      return;",
          "591:     }",
          "592:     memcpy(image + proglen, temp, ilen);",
          "593:    }",
          "594:    proglen += ilen;",
          "595:    addrs[i] = proglen;",
          "596:    prog = temp;",
          "597:   }",
          "602:   if (seen)",
          "604:   if (seen & SEEN_XREG)",
          "607:   if (image) {",
          "608:    WARN_ON(proglen != oldproglen);",
          "609:    break;",
          "610:   }",
          "611:   if (proglen == oldproglen) {",
          "612:    image = module_alloc(max_t(unsigned int,",
          "613:          proglen,",
          "614:          sizeof(struct work_struct)));",
          "615:    if (!image)",
          "616:     goto out;",
          "617:   }",
          "618:   oldproglen = proglen;",
          "619:  }",
          "620:  if (bpf_jit_enable > 1)",
          "621:   pr_err(\"flen=%d proglen=%u pass=%d image=%p\\n\",",
          "622:          flen, proglen, pass, image);",
          "624:  if (image) {",
          "625:   if (bpf_jit_enable > 1)",
          "626:    print_hex_dump(KERN_ERR, \"JIT code: \", DUMP_PREFIX_ADDRESS,",
          "627:            16, 1, image, proglen, false);",
          "629:   bpf_flush_icache(image, image + proglen);",
          "631:   fp->bpf_func = (void *)image;",
          "632:  }",
          "633: out:",
          "634:  kfree(addrs);",
          "635:  return;",
          "636: }",
          "638: static void jit_free_defer(struct work_struct *arg)",
          "639: {",
          "640:  module_free(NULL, arg);",
          "641: }",
          "646: void bpf_jit_free(struct sk_filter *fp)",
          "647: {",
          "648:  if (fp->bpf_func != sk_run_filter) {",
          "649:   struct work_struct *work = (struct work_struct *)fp->bpf_func;",
          "651:   INIT_WORK(work, jit_free_defer);",
          "652:   schedule_work(work);",
          "653:  }",
          "654: }",
          "",
          "---------------"
        ],
        "include/linux/filter.h||include/linux/filter.h": [
          "File: include/linux/filter.h -> include/linux/filter.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "135: {",
          "136:  atomic_t  refcnt;",
          "138:  struct rcu_head  rcu;",
          "139:  struct sock_filter      insns[0];",
          "140: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "138:  unsigned int  (*bpf_func)(const struct sk_buff *skb,",
          "139:          const struct sock_filter *filter);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "153: extern int sk_attach_filter(struct sock_fprog *fprog, struct sock *sk);",
          "154: extern int sk_detach_filter(struct sock *sk);",
          "155: extern int sk_chk_filter(struct sock_filter *filter, int flen);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "159: #ifdef CONFIG_BPF_JIT",
          "160: extern void bpf_jit_compile(struct sk_filter *fp);",
          "161: extern void bpf_jit_free(struct sk_filter *fp);",
          "162: #define SK_RUN_FILTER(FILTER, SKB) (*FILTER->bpf_func)(SKB, FILTER->insns)",
          "163: #else",
          "164: static inline void bpf_jit_compile(struct sk_filter *fp)",
          "165: {",
          "166: }",
          "167: static inline void bpf_jit_free(struct sk_filter *fp)",
          "168: {",
          "169: }",
          "170: #define SK_RUN_FILTER(FILTER, SKB) sk_run_filter(SKB, FILTER->insns)",
          "171: #endif",
          "173: enum {",
          "174:  BPF_S_RET_K = 1,",
          "175:  BPF_S_RET_A,",
          "176:  BPF_S_ALU_ADD_K,",
          "177:  BPF_S_ALU_ADD_X,",
          "178:  BPF_S_ALU_SUB_K,",
          "179:  BPF_S_ALU_SUB_X,",
          "180:  BPF_S_ALU_MUL_K,",
          "181:  BPF_S_ALU_MUL_X,",
          "182:  BPF_S_ALU_DIV_X,",
          "183:  BPF_S_ALU_AND_K,",
          "184:  BPF_S_ALU_AND_X,",
          "185:  BPF_S_ALU_OR_K,",
          "186:  BPF_S_ALU_OR_X,",
          "187:  BPF_S_ALU_LSH_K,",
          "188:  BPF_S_ALU_LSH_X,",
          "189:  BPF_S_ALU_RSH_K,",
          "190:  BPF_S_ALU_RSH_X,",
          "191:  BPF_S_ALU_NEG,",
          "192:  BPF_S_LD_W_ABS,",
          "193:  BPF_S_LD_H_ABS,",
          "194:  BPF_S_LD_B_ABS,",
          "195:  BPF_S_LD_W_LEN,",
          "196:  BPF_S_LD_W_IND,",
          "197:  BPF_S_LD_H_IND,",
          "198:  BPF_S_LD_B_IND,",
          "199:  BPF_S_LD_IMM,",
          "200:  BPF_S_LDX_W_LEN,",
          "201:  BPF_S_LDX_B_MSH,",
          "202:  BPF_S_LDX_IMM,",
          "203:  BPF_S_MISC_TAX,",
          "204:  BPF_S_MISC_TXA,",
          "205:  BPF_S_ALU_DIV_K,",
          "206:  BPF_S_LD_MEM,",
          "207:  BPF_S_LDX_MEM,",
          "208:  BPF_S_ST,",
          "209:  BPF_S_STX,",
          "210:  BPF_S_JMP_JA,",
          "211:  BPF_S_JMP_JEQ_K,",
          "212:  BPF_S_JMP_JEQ_X,",
          "213:  BPF_S_JMP_JGE_K,",
          "214:  BPF_S_JMP_JGE_X,",
          "215:  BPF_S_JMP_JGT_K,",
          "216:  BPF_S_JMP_JGT_X,",
          "217:  BPF_S_JMP_JSET_K,",
          "218:  BPF_S_JMP_JSET_X,",
          "220:  BPF_S_ANC_PROTOCOL,",
          "221:  BPF_S_ANC_PKTTYPE,",
          "222:  BPF_S_ANC_IFINDEX,",
          "223:  BPF_S_ANC_NLATTR,",
          "224:  BPF_S_ANC_NLATTR_NEST,",
          "225:  BPF_S_ANC_MARK,",
          "226:  BPF_S_ANC_QUEUE,",
          "227:  BPF_S_ANC_HATYPE,",
          "228:  BPF_S_ANC_RXHASH,",
          "229:  BPF_S_ANC_CPU,",
          "230: };",
          "",
          "---------------"
        ],
        "include/linux/netdevice.h||include/linux/netdevice.h": [
          "File: include/linux/netdevice.h -> include/linux/netdevice.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "2514: extern int  netdev_max_backlog;",
          "2515: extern int  netdev_tstamp_prequeue;",
          "2516: extern int  weight_p;",
          "2517: extern int  netdev_set_master(struct net_device *dev, struct net_device *master);",
          "2518: extern int netdev_set_bond_master(struct net_device *dev,",
          "2519:       struct net_device *master);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2517: extern int  bpf_jit_enable;",
          "",
          "---------------"
        ],
        "include/linux/skbuff.h||include/linux/skbuff.h": [
          "File: include/linux/skbuff.h -> include/linux/skbuff.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "392:  __u32   rxhash;",
          "394:  kmemcheck_bitfield_begin(flags2);",
          "396: #ifdef CONFIG_IPV6_NDISC_NODETYPE",
          "397:  __u8   ndisc_nodetype:2;",
          "398: #endif",
          "",
          "[Removed Lines]",
          "395:  __u16   queue_mapping:16;",
          "",
          "[Added Lines]",
          "394:  __u16   queue_mapping;",
          "",
          "---------------"
        ],
        "net/core/filter.c||net/core/filter.c": [
          "File: net/core/filter.c -> net/core/filter.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "39: #include <linux/filter.h>",
          "40: #include <linux/reciprocal_div.h>",
          "102: static void *__load_pointer(const struct sk_buff *skb, int k, unsigned int size)",
          "103: {",
          "",
          "[Removed Lines]",
          "42: enum {",
          "43:  BPF_S_RET_K = 1,",
          "44:  BPF_S_RET_A,",
          "45:  BPF_S_ALU_ADD_K,",
          "46:  BPF_S_ALU_ADD_X,",
          "47:  BPF_S_ALU_SUB_K,",
          "48:  BPF_S_ALU_SUB_X,",
          "49:  BPF_S_ALU_MUL_K,",
          "50:  BPF_S_ALU_MUL_X,",
          "51:  BPF_S_ALU_DIV_X,",
          "52:  BPF_S_ALU_AND_K,",
          "53:  BPF_S_ALU_AND_X,",
          "54:  BPF_S_ALU_OR_K,",
          "55:  BPF_S_ALU_OR_X,",
          "56:  BPF_S_ALU_LSH_K,",
          "57:  BPF_S_ALU_LSH_X,",
          "58:  BPF_S_ALU_RSH_K,",
          "59:  BPF_S_ALU_RSH_X,",
          "60:  BPF_S_ALU_NEG,",
          "61:  BPF_S_LD_W_ABS,",
          "62:  BPF_S_LD_H_ABS,",
          "63:  BPF_S_LD_B_ABS,",
          "64:  BPF_S_LD_W_LEN,",
          "65:  BPF_S_LD_W_IND,",
          "66:  BPF_S_LD_H_IND,",
          "67:  BPF_S_LD_B_IND,",
          "68:  BPF_S_LD_IMM,",
          "69:  BPF_S_LDX_W_LEN,",
          "70:  BPF_S_LDX_B_MSH,",
          "71:  BPF_S_LDX_IMM,",
          "72:  BPF_S_MISC_TAX,",
          "73:  BPF_S_MISC_TXA,",
          "74:  BPF_S_ALU_DIV_K,",
          "75:  BPF_S_LD_MEM,",
          "76:  BPF_S_LDX_MEM,",
          "77:  BPF_S_ST,",
          "78:  BPF_S_STX,",
          "79:  BPF_S_JMP_JA,",
          "80:  BPF_S_JMP_JEQ_K,",
          "81:  BPF_S_JMP_JEQ_X,",
          "82:  BPF_S_JMP_JGE_K,",
          "83:  BPF_S_JMP_JGE_X,",
          "84:  BPF_S_JMP_JGT_K,",
          "85:  BPF_S_JMP_JGT_X,",
          "86:  BPF_S_JMP_JSET_K,",
          "87:  BPF_S_JMP_JSET_X,",
          "89:  BPF_S_ANC_PROTOCOL,",
          "90:  BPF_S_ANC_PKTTYPE,",
          "91:  BPF_S_ANC_IFINDEX,",
          "92:  BPF_S_ANC_NLATTR,",
          "93:  BPF_S_ANC_NLATTR_NEST,",
          "94:  BPF_S_ANC_MARK,",
          "95:  BPF_S_ANC_QUEUE,",
          "96:  BPF_S_ANC_HATYPE,",
          "97:  BPF_S_ANC_RXHASH,",
          "98:  BPF_S_ANC_CPU,",
          "99: };",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "145:  rcu_read_lock();",
          "146:  filter = rcu_dereference(sk->sk_filter);",
          "147:  if (filter) {",
          "150:   err = pkt_len ? pskb_trim(skb, pkt_len) : -EPERM;",
          "151:  }",
          "",
          "[Removed Lines]",
          "148:   unsigned int pkt_len = sk_run_filter(skb, filter->insns);",
          "",
          "[Added Lines]",
          "89:   unsigned int pkt_len = SK_RUN_FILTER(filter, skb);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "638: {",
          "639:  struct sk_filter *fp = container_of(rcu, struct sk_filter, rcu);",
          "641:  kfree(fp);",
          "642: }",
          "643: EXPORT_SYMBOL(sk_filter_release_rcu);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "582:  bpf_jit_free(fp);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "673:  atomic_set(&fp->refcnt, 1);",
          "674:  fp->len = fprog->len;",
          "676:  err = sk_chk_filter(fp->insns, fp->len);",
          "677:  if (err) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "617:  fp->bpf_func = sk_run_filter;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "679:   return err;",
          "680:  }",
          "682:  old_fp = rcu_dereference_protected(sk->sk_filter,",
          "683:         sock_owned_by_user(sk));",
          "684:  rcu_assign_pointer(sk->sk_filter, fp);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "625:  bpf_jit_compile(fp);",
          "",
          "---------------"
        ],
        "net/core/sysctl_net_core.c||net/core/sysctl_net_core.c": [
          "File: net/core/sysctl_net_core.c -> net/core/sysctl_net_core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "122:   .mode  = 0644,",
          "123:   .proc_handler = proc_dointvec",
          "124:  },",
          "125:  {",
          "126:   .procname = \"netdev_tstamp_prequeue\",",
          "127:   .data  = &netdev_tstamp_prequeue,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "125: #ifdef CONFIG_BPF_JIT",
          "126:  {",
          "127:   .procname = \"bpf_jit_enable\",",
          "128:   .data  = &bpf_jit_enable,",
          "129:   .maxlen  = sizeof(int),",
          "130:   .mode  = 0644,",
          "131:   .proc_handler = proc_dointvec",
          "132:  },",
          "133: #endif",
          "",
          "---------------"
        ],
        "net/packet/af_packet.c||net/packet/af_packet.c": [
          "File: net/packet/af_packet.c -> net/packet/af_packet.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "538:  rcu_read_lock();",
          "539:  filter = rcu_dereference(sk->sk_filter);",
          "540:  if (filter != NULL)",
          "542:  rcu_read_unlock();",
          "544:  return res;",
          "",
          "[Removed Lines]",
          "541:   res = sk_run_filter(skb, filter->insns);",
          "",
          "[Added Lines]",
          "541:   res = SK_RUN_FILTER(filter, skb);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
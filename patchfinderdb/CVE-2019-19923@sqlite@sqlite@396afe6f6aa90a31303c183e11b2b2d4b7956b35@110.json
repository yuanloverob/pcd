{
  "cve_id": "CVE-2019-19923",
  "cve_desc": "flattenSubquery in select.c in SQLite 3.30.1 mishandles certain uses of SELECT DISTINCT involving a LEFT JOIN in which the right-hand side is a view. This can cause a NULL pointer dereference (or incorrect results).",
  "repo": "sqlite/sqlite",
  "patch_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
  "patch_info": {
    "commit_hash": "396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/396afe6f6aa90a31303c183e11b2b2d4b7956b35",
    "files": [
      "manifest",
      "manifest.uuid",
      "src/select.c",
      "test/join.test"
    ],
    "message": "Continue to back away from the LEFT JOIN optimization of check-in [41c27bc0ff1d3135] by disallowing query flattening if the outer query is DISTINCT.  Without this fix, if an index scan is run on the table within the view on the right-hand side of the LEFT JOIN, stale result registers might be accessed yielding incorrect results, and/or an OP_IfNullRow opcode might be invoked on the un-opened table, resulting in a NULL-pointer dereference.  This problem was found by the Yongheng and Rui fuzzer.\n\nFossilOrigin-Name: 862974312edf00e9d1068115d1a39b7235b7db68b6d86b81d38a12f025a4748e",
    "before_after_code_files": [
      "manifest.uuid||manifest.uuid",
      "src/select.c||src/select.c",
      "test/join.test||test/join.test"
    ]
  },
  "patch_diff": {
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 289158aa24b066c453d2bce4bc2dead1c56fb0b23c3f7c4810b34b13627cef34",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ],
    "src/select.c||src/select.c": [
      "File: src/select.c -> src/select.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "3797:   if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){",
      "3798:     isLeftJoin = 1;",
      "3801:       return 0;",
      "3802:     }",
      "3803:   }",
      "",
      "[Removed Lines]",
      "3799:     if( pSubSrc->nSrc>1 || isAgg || IsVirtual(pSubSrc->a[0].pTab) ){",
      "",
      "[Added Lines]",
      "3804:     ){",
      "",
      "---------------"
    ],
    "test/join.test||test/join.test": [
      "File: test/join.test -> test/join.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "975:   SELECT 24, * FROM t1 LEFT JOIN t0 ON +aa ISNULL;",
      "976: } {13 1 {} 14 1 {} 23 1 {} 24 1 {}}",
      "978: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "978: # 2019-12-18 problem with a LEFT JOIN where the RHS is a view.",
      "979: # Detected by Yongheng and Rui.",
      "980: # Follows from the optimization attempt of check-in 41c27bc0ff1d3135",
      "981: # on 2017-04-18",
      "982: #",
      "983: reset_db",
      "984: do_execsql_test join-22.10 {",
      "985:   CREATE TABLE t0(a, b);",
      "986:   CREATE INDEX t0a ON t0(a);",
      "987:   INSERT INTO t0 VALUES(10,10),(10,11),(10,12);",
      "988:   SELECT DISTINCT c FROM t0 LEFT JOIN (SELECT a+1 AS c FROM t0) ORDER BY c ;",
      "989: } {11}",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e45985b5951c8afc544361157c819717641df7ee",
      "candidate_info": {
        "commit_hash": "e45985b5951c8afc544361157c819717641df7ee",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/e45985b5951c8afc544361157c819717641df7ee",
        "files": [
          "manifest",
          "manifest.uuid",
          "test/fuzzcheck.c"
        ],
        "message": "Fix a bug in the custom in-memory VFS used by fuzzcheck.  This bug masks other bugs that should have caused some existing fuzzdata7.db entries to fail, and so this fix is initially on a branch until those other bugs can be repaired.\n\nFossilOrigin-Name: e0994e99955cf11f23dba029b5ed7f150f467887558848d5f03510e2fb5855f9",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "test/fuzzcheck.c||test/fuzzcheck.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 18740bd448887d618fafee0b5a7c004aa2f2632244f7d29e2428772baa36b828",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "test/fuzzcheck.c||test/fuzzcheck.c": [
          "File: test/fuzzcheck.c -> test/fuzzcheck.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "447:   if( iOfst+iAmt>pVFile->sz ){",
          "448:     memset(pData, 0, iAmt);",
          "449:     iAmt = (int)(pVFile->sz - iOfst);",
          "451:     return SQLITE_IOERR_SHORT_READ;",
          "452:   }",
          "453:   memcpy(pData, pVFile->a + iOfst, iAmt);",
          "",
          "[Removed Lines]",
          "450:     memcpy(pData, pVFile->a, iAmt);",
          "",
          "[Added Lines]",
          "450:     memcpy(pData, pVFile->a + iOfst, iAmt);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b008e4d744175052c219ab78db1ea3732682ceb3",
      "candidate_info": {
        "commit_hash": "b008e4d744175052c219ab78db1ea3732682ceb3",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b008e4d744175052c219ab78db1ea3732682ceb3",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/loadext.c",
          "test/without_rowid1.test",
          "test/without_rowid6.test",
          "test/without_rowid7.test"
        ],
        "message": "Fix some test script issues that come up with SQLITE_OMIT_VIRTUALTABLE builds.\n\nFossilOrigin-Name: 3934d2d08ee14d644dc01f967c10f219b76b172c963c90a7a8141f2b08a7d5bf",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/loadext.c||src/loadext.c",
          "test/without_rowid1.test||test/without_rowid1.test",
          "test/without_rowid6.test||test/without_rowid6.test",
          "test/without_rowid7.test||test/without_rowid7.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 9e0d5d2640a92070967bc9fdf5c5b1653e41b9c04e04dcb70f18ead10f053aef",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/loadext.c||src/loadext.c": [
          "File: src/loadext.c -> src/loadext.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "463:   sqlite3_stmt_isexplain,",
          "464:   sqlite3_value_frombind,",
          "466:   sqlite3_drop_modules,",
          "467: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "466: #ifndef SQLITE_OMIT_VIRTUALTABLE",
          "468: #else",
          "469:   0,",
          "470: #endif",
          "",
          "---------------"
        ],
        "test/without_rowid1.test||test/without_rowid1.test": [
          "File: test/without_rowid1.test -> test/without_rowid1.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: source $testdir/tester.tcl",
          "18: set testprefix without_rowid1",
          "20: # Create and query a WITHOUT ROWID table.",
          "21: #",
          "22: do_execsql_test without_rowid1-1.0 {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: proc do_execsql_test_if_vtab {tn sql {res {}}} {",
          "21:   ifcapable vtab { uplevel [list do_execsql_test $tn $sql $res] }",
          "22: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "32: integrity_check without_rowid1-1.0ic",
          "35:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "36: } {c 1 a 1 b 0 d 0}",
          "",
          "[Removed Lines]",
          "34: do_execsql_test without_rowid1-1.0ixi {",
          "",
          "[Added Lines]",
          "38: do_execsql_test_if_vtab without_rowid1-1.0ixi {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "119:   UPDATE t4 SET a = 'ABC';",
          "120:   SELECT * FROM t4;",
          "121: } {ABC def}",
          "123:   SELECT name, coll, key FROM pragma_index_xinfo('t4');",
          "124: } {a nocase 1 b BINARY 0}",
          "",
          "[Removed Lines]",
          "122: do_execsql_test 2.1.3 {",
          "",
          "[Added Lines]",
          "126: do_execsql_test_if_vtab 2.1.3 {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "135:   SELECT * FROM t4;",
          "136: } {xyz ABC}",
          "139:   SELECT name, coll, key FROM pragma_index_xinfo('t4');",
          "140: } {a nocase 1 b BINARY 0}",
          "",
          "[Removed Lines]",
          "138: do_execsql_test 2.2.3 {",
          "",
          "[Added Lines]",
          "142: do_execsql_test_if_vtab 2.2.3 {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "146:   UPDATE t5 SET a='abc', b='def';",
          "147: } {}",
          "150:   SELECT name, coll, key FROM pragma_index_xinfo('t5');",
          "151: } {b BINARY 1 a BINARY 1}",
          "",
          "[Removed Lines]",
          "149: do_execsql_test 2.3.2 {",
          "",
          "[Added Lines]",
          "153: do_execsql_test_if_vtab 2.3.2 {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "165:   SELECT * FROM t6 ORDER BY c;",
          "166: } {ABC def ghi ABC def ghi}",
          "169:   SELECT name, coll, key FROM pragma_index_xinfo('t6');",
          "170: } {b BINARY 1 a nocase 1 c BINARY 0}",
          "",
          "[Removed Lines]",
          "168: do_execsql_test 2.4.3 {",
          "",
          "[Added Lines]",
          "172: do_execsql_test_if_vtab 2.4.3 {",
          "",
          "---------------"
        ],
        "test/without_rowid6.test||test/without_rowid6.test": [
          "File: test/without_rowid6.test -> test/without_rowid6.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: set testdir [file dirname $argv0]",
          "17: source $testdir/tester.tcl",
          "19: do_execsql_test without_rowid6-100 {",
          "20:   CREATE TABLE t1(a,b,c,d,e, PRIMARY KEY(a,b,c,a,b,c,d,a,b,c)) WITHOUT ROWID;",
          "21:   CREATE INDEX t1a ON t1(b, b);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "19: proc do_execsql_test_if_vtab {tn sql {res {}}} {",
          "20:   ifcapable vtab { uplevel [list do_execsql_test $tn $sql $res] }",
          "21: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "24:   INSERT INTO t1(a,b,c,d,e) SELECT i, i+1000, printf('x%dy',i), 0, 0 FROM c;",
          "25:   ANALYZE;",
          "26: } {}",
          "28:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "29: } {a 1 b 1 c 1 d 1 e 0}",
          "30: do_execsql_test without_rowid6-110 {",
          "",
          "[Removed Lines]",
          "27: do_execsql_test without_rowid6-101 {",
          "",
          "[Added Lines]",
          "31: do_execsql_test_if_vtab without_rowid6-101 {",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "54:   INSERT INTO t1(a,b,c) VALUES(1,8,3),(4,5,6),(7,2,9);",
          "55:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "56: } {4 1}",
          "58:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "59: } {b 1 a 0 c 0}",
          "60: do_execsql_test without_rowid6-210 {",
          "",
          "[Removed Lines]",
          "57: do_execsql_test without_rowid6-201 {",
          "",
          "[Added Lines]",
          "61: do_execsql_test_if_vtab without_rowid6-201 {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "111:   INSERT INTO t1(a,b,c) VALUES(1,8,3),(4,5,6),(7,2,9);",
          "112:   SELECT a FROM t1 WHERE b>3 ORDER BY b;",
          "113: } {4 1}",
          "115:   SELECT name, key FROM pragma_index_xinfo('t1');",
          "116: } {b 1 c 1 a 0}",
          "117: do_execsql_test without_rowid6-510 {",
          "",
          "[Removed Lines]",
          "114: do_execsql_test without_rowid6-501 {",
          "",
          "[Added Lines]",
          "118: do_execsql_test_if_vtab without_rowid6-501 {",
          "",
          "---------------"
        ],
        "test/without_rowid7.test||test/without_rowid7.test": [
          "File: test/without_rowid7.test -> test/without_rowid7.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: source $testdir/tester.tcl",
          "16: set testprefix without_rowid7",
          "18: do_execsql_test 1.0 {",
          "19:   CREATE TABLE t1(a, b COLLATE nocase, PRIMARY KEY(a, a, b)) WITHOUT ROWID;",
          "20: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18: proc do_execsql_test_if_vtab {tn sql {res {}}} {",
          "19:   ifcapable vtab { uplevel [list do_execsql_test $tn $sql $res] }",
          "20: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36: do_execsql_test 2.2a {",
          "37:   PRAGMA index_info(t2);",
          "38: } {0 0 a 1 0 a}",
          "40:   SELECT *, '|' FROM pragma_index_info('t2');",
          "41: } {0 0 a | 1 0 a |}",
          "42: do_execsql_test 2.3a {",
          "43:   PRAGMA index_xinfo(t2);",
          "44: } {0 0 a 0 nocase 1 1 0 a 0 BINARY 1 2 1 b 0 BINARY 0}",
          "46:   SELECT *, '|' FROM pragma_index_xinfo('t2');",
          "47: } {0 0 a 0 nocase 1 | 1 0 a 0 BINARY 1 | 2 1 b 0 BINARY 0 |}",
          "",
          "[Removed Lines]",
          "39: do_execsql_test 2.2b {",
          "45: do_execsql_test 2.3b {",
          "",
          "[Added Lines]",
          "43: do_execsql_test_if_vtab 2.2b {",
          "49: do_execsql_test_if_vtab 2.3b {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
      "candidate_info": {
        "commit_hash": "85bcdce270575e78258148c00f2efff7e81e7bc1",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/85bcdce270575e78258148c00f2efff7e81e7bc1",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/expr.c",
          "src/sqliteInt.h",
          "src/wherecode.c"
        ],
        "message": "Split the code generation for the RHS of IN operators and for SELECT and EXISTS expressions into two separate subroutines, because there is now little commonality between those to functions. This is intended to help make the code easier to read and maintain.\n\nFossilOrigin-Name: 2b6494b1509f0d0189f98aa34c990eee99c775ff57826e79b2c5b0a12b4c97ad",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/expr.c||src/expr.c",
          "src/sqliteInt.h||src/sqliteInt.h",
          "src/wherecode.c||src/wherecode.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6231485114eb07b258cd0e6e163ca05f7e9cf5664e071808fcb1329b33e4c4f5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/expr.c||src/expr.c": [
          "File: src/expr.c -> src/expr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "481:   int reg = 0;",
          "482: #ifndef SQLITE_OMIT_SUBQUERY",
          "483:   if( pExpr->op==TK_SELECT ){",
          "485:   }",
          "486: #endif",
          "487:   return reg;",
          "",
          "[Removed Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "",
          "[Added Lines]",
          "484:     reg = sqlite3CodeSubselect(pParse, pExpr);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2542:     }else if( prRhsHasNull ){",
          "2544:     }",
          "2546:     pParse->nQueryLoop = savedNQueryLoop;",
          "2547:   }else{",
          "2548:     pX->iTable = iTab;",
          "",
          "[Removed Lines]",
          "2545:     sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==IN_INDEX_ROWID);",
          "",
          "[Added Lines]",
          "2545:     assert( pX->op==TK_IN );",
          "2546:     sqlite3CodeRhsOfIN(pParse, pX, eType==IN_INDEX_ROWID);",
          "2547:     if( rMayHaveNull ){",
          "2548:       sqlite3SetHasNullFlag(v, pX->iTable, rMayHaveNull);",
          "2549:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "2626:   }",
          "2627: }",
          "2664: ){",
          "",
          "[Removed Lines]",
          "2658: #ifndef SQLITE_OMIT_SUBQUERY",
          "2659: int sqlite3CodeSubselect(",
          "2667:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2668:   if( NEVER(v==0) ) return 0;",
          "",
          "[Added Lines]",
          "2633: #ifndef SQLITE_OMIT_SUBQUERY",
          "2658: void sqlite3CodeRhsOfIN(",
          "2670:   v = sqlite3GetVdbe(pParse);",
          "2671:   assert( v!=0 );",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "2681:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2682:   }",
          "2810:       }",
          "2813:       }",
          "2815:     }",
          "2859:       }",
          "2864:       }else{",
          "2870:       }",
          "2874:     }",
          "2875:   }",
          "2879:   }",
          "2881:   if( jmpIfDynamic>=0 ){",
          "2882:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "",
          "[Removed Lines]",
          "2684:   switch( pExpr->op ){",
          "2685:     case TK_IN: {",
          "2691:       nVal = sqlite3ExprVectorSize(pLeft);",
          "2692:       assert( !isRowid || nVal==1 );",
          "2707:       pExpr->iTable = pParse->nTab++;",
          "2708:       addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2709:           pExpr->iTable, (isRowid?0:nVal));",
          "2710:       pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2712:       if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2718:         Select *pSelect = pExpr->x.pSelect;",
          "2719:         ExprList *pEList = pSelect->pEList;",
          "2721:         ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2722:             jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2723:         ));",
          "2724:         assert( !isRowid );",
          "2727:         if( ALWAYS(pEList->nExpr==nVal) ){",
          "2728:           SelectDest dest;",
          "2729:           int i;",
          "2730:           sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2731:           dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2732:           pSelect->iLimit = 0;",
          "2733:           testcase( pSelect->selFlags & SF_Distinct );",
          "2735:           if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2736:             sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2737:             sqlite3KeyInfoUnref(pKeyInfo);",
          "2738:             return 0;",
          "2739:           }",
          "2740:           sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2742:           assert( pEList!=0 );",
          "2743:           assert( pEList->nExpr>0 );",
          "2744:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2745:           for(i=0; i<nVal; i++){",
          "2746:             Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2747:             pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2748:                 pParse, p, pEList->a[i].pExpr",
          "2749:             );",
          "2750:           }",
          "2751:         }",
          "2752:       }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2761:         int i;",
          "2762:         ExprList *pList = pExpr->x.pList;",
          "2763:         struct ExprList_item *pItem;",
          "2764:         int r1, r2, r3;",
          "2765:         affinity = sqlite3ExprAffinity(pLeft);",
          "2766:         if( !affinity ){",
          "2767:           affinity = SQLITE_AFF_BLOB;",
          "2768:         }",
          "2769:         if( pKeyInfo ){",
          "2770:           assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2771:           pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2772:         }",
          "2775:         r1 = sqlite3GetTempReg(pParse);",
          "2776:         r2 = sqlite3GetTempReg(pParse);",
          "2777:         if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2778:         for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2779:           Expr *pE2 = pItem->pExpr;",
          "2780:           int iValToIns;",
          "2787:           if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2788:             sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2789:             jmpIfDynamic = -1;",
          "2790:           }",
          "2793:           if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2794:             sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2795:           }else{",
          "2796:             r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2797:             if( isRowid ){",
          "2798:               sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2799:                                 sqlite3VdbeCurrentAddr(v)+2);",
          "2800:               VdbeCoverage(v);",
          "2801:               sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2802:             }else{",
          "2803:               sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2804:               sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2805:             }",
          "2806:           }",
          "2807:         }",
          "2808:         sqlite3ReleaseTempReg(pParse, r1);",
          "2809:         sqlite3ReleaseTempReg(pParse, r2);",
          "2811:       if( pKeyInfo ){",
          "2812:         sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2814:       break;",
          "2817:     case TK_EXISTS:",
          "2818:     case TK_SELECT:",
          "2819:     default: {",
          "2838:       testcase( pExpr->op==TK_EXISTS );",
          "2839:       testcase( pExpr->op==TK_SELECT );",
          "2840:       assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2841:       assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2843:       pSel = pExpr->x.pSelect;",
          "2844:       ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2845:             jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2846:       nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2847:       sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2848:       pParse->nMem += nReg;",
          "2849:       if( pExpr->op==TK_SELECT ){",
          "2850:         dest.eDest = SRT_Mem;",
          "2851:         dest.iSdst = dest.iSDParm;",
          "2852:         dest.nSdst = nReg;",
          "2853:         sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2854:         VdbeComment((v, \"Init subquery result\"));",
          "2855:       }else{",
          "2856:         dest.eDest = SRT_Exists;",
          "2857:         sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2858:         VdbeComment((v, \"Init EXISTS result\"));",
          "2860:       pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2861:       if( pSel->pLimit ){",
          "2862:         sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2863:         pSel->pLimit->pLeft = pLimit;",
          "2865:         pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2866:       }",
          "2867:       pSel->iLimit = 0;",
          "2868:       if( sqlite3Select(pParse, pSel, &dest) ){",
          "2869:         return 0;",
          "2871:       rReg = dest.iSDParm;",
          "2872:       ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "2873:       break;",
          "2877:   if( rHasNullFlag ){",
          "2878:     sqlite3SetHasNullFlag(v, pExpr->iTable, rHasNullFlag);",
          "",
          "[Added Lines]",
          "2688:   pLeft = pExpr->pLeft;",
          "2689:   nVal = sqlite3ExprVectorSize(pLeft);",
          "2690:   assert( !isRowid || nVal==1 );",
          "2695:   pExpr->iTable = pParse->nTab++;",
          "2696:   addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral,",
          "2697:       pExpr->iTable, (isRowid?0:nVal));",
          "2698:   pKeyInfo = isRowid ? 0 : sqlite3KeyInfoAlloc(pParse->db, nVal, 1);",
          "2700:   if( ExprHasProperty(pExpr, EP_xIsSelect) ){",
          "2706:     Select *pSelect = pExpr->x.pSelect;",
          "2707:     ExprList *pEList = pSelect->pEList;",
          "2709:     ExplainQueryPlan((pParse, 1, \"%sLIST SUBQUERY\",",
          "2710:         jmpIfDynamic>=0?\"\":\"CORRELATED \"",
          "2711:     ));",
          "2712:     assert( !isRowid );",
          "2715:     if( ALWAYS(pEList->nExpr==nVal) ){",
          "2716:       SelectDest dest;",
          "2717:       int i;",
          "2718:       sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);",
          "2719:       dest.zAffSdst = exprINAffinity(pParse, pExpr);",
          "2720:       pSelect->iLimit = 0;",
          "2721:       testcase( pSelect->selFlags & SF_Distinct );",
          "2723:       if( sqlite3Select(pParse, pSelect, &dest) ){",
          "2724:         sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2725:         sqlite3KeyInfoUnref(pKeyInfo);",
          "2726:         return;",
          "2728:       sqlite3DbFree(pParse->db, dest.zAffSdst);",
          "2730:       assert( pEList!=0 );",
          "2731:       assert( pEList->nExpr>0 );",
          "2732:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2733:       for(i=0; i<nVal; i++){",
          "2734:         Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);",
          "2735:         pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(",
          "2736:             pParse, p, pEList->a[i].pExpr",
          "2737:         );",
          "2740:   }else if( ALWAYS(pExpr->x.pList!=0) ){",
          "2749:     int i;",
          "2750:     ExprList *pList = pExpr->x.pList;",
          "2751:     struct ExprList_item *pItem;",
          "2752:     int r1, r2, r3;",
          "2753:     affinity = sqlite3ExprAffinity(pLeft);",
          "2754:     if( !affinity ){",
          "2755:       affinity = SQLITE_AFF_BLOB;",
          "2756:     }",
          "2757:     if( pKeyInfo ){",
          "2758:       assert( sqlite3KeyInfoIsWriteable(pKeyInfo) );",
          "2759:       pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);",
          "2760:     }",
          "2763:     r1 = sqlite3GetTempReg(pParse);",
          "2764:     r2 = sqlite3GetTempReg(pParse);",
          "2765:     if( isRowid ) sqlite3VdbeAddOp4(v, OP_Blob, 0, r2, 0, \"\", P4_STATIC);",
          "2766:     for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){",
          "2767:       Expr *pE2 = pItem->pExpr;",
          "2768:       int iValToIns;",
          "2775:       if( jmpIfDynamic>=0 && !sqlite3ExprIsConstant(pE2) ){",
          "2776:         sqlite3VdbeChangeToNoop(v, jmpIfDynamic);",
          "2777:         jmpIfDynamic = -1;",
          "2781:       if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){",
          "2782:         sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);",
          "2784:         r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);",
          "2785:         if( isRowid ){",
          "2786:           sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,",
          "2787:                             sqlite3VdbeCurrentAddr(v)+2);",
          "2788:           VdbeCoverage(v);",
          "2789:           sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);",
          "2790:         }else{",
          "2791:           sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);",
          "2792:           sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pExpr->iTable, r2, r3, 1);",
          "2793:         }",
          "2796:     sqlite3ReleaseTempReg(pParse, r1);",
          "2797:     sqlite3ReleaseTempReg(pParse, r2);",
          "2799:   if( pKeyInfo ){",
          "2800:     sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, P4_KEYINFO);",
          "2801:   }",
          "2802:   if( jmpIfDynamic>=0 ){",
          "2803:     sqlite3VdbeJumpHere(v, jmpIfDynamic);",
          "2804:   }",
          "2805: }",
          "2822: #ifndef SQLITE_OMIT_SUBQUERY",
          "2823: int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){",
          "2830:   Vdbe *v = sqlite3GetVdbe(pParse);",
          "2831:   assert( v!=0 );",
          "2843:   if( !ExprHasProperty(pExpr, EP_VarSelect) ){",
          "2844:     jmpIfDynamic = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);",
          "2845:   }",
          "2857:   testcase( pExpr->op==TK_EXISTS );",
          "2858:   testcase( pExpr->op==TK_SELECT );",
          "2859:   assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );",
          "2860:   assert( ExprHasProperty(pExpr, EP_xIsSelect) );",
          "2862:   pSel = pExpr->x.pSelect;",
          "2863:   ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY\",",
          "2864:         jmpIfDynamic>=0?\"\":\"CORRELATED \"));",
          "2865:   nReg = pExpr->op==TK_SELECT ? pSel->pEList->nExpr : 1;",
          "2866:   sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);",
          "2867:   pParse->nMem += nReg;",
          "2868:   if( pExpr->op==TK_SELECT ){",
          "2869:     dest.eDest = SRT_Mem;",
          "2870:     dest.iSdst = dest.iSDParm;",
          "2871:     dest.nSdst = nReg;",
          "2872:     sqlite3VdbeAddOp3(v, OP_Null, 0, dest.iSDParm, dest.iSDParm+nReg-1);",
          "2873:     VdbeComment((v, \"Init subquery result\"));",
          "2874:   }else{",
          "2875:     dest.eDest = SRT_Exists;",
          "2876:     sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iSDParm);",
          "2877:     VdbeComment((v, \"Init EXISTS result\"));",
          "2878:   }",
          "2879:   pLimit = sqlite3ExprAlloc(pParse->db, TK_INTEGER,&sqlite3IntTokens[1], 0);",
          "2880:   if( pSel->pLimit ){",
          "2881:     sqlite3ExprDelete(pParse->db, pSel->pLimit->pLeft);",
          "2882:     pSel->pLimit->pLeft = pLimit;",
          "2883:   }else{",
          "2884:     pSel->pLimit = sqlite3PExpr(pParse, TK_LIMIT, pLimit, 0);",
          "2885:   }",
          "2886:   pSel->iLimit = 0;",
          "2887:   if( sqlite3Select(pParse, pSel, &dest) ){",
          "2888:     return 0;",
          "2890:   rReg = dest.iSDParm;",
          "2891:   ExprSetVVAProperty(pExpr, EP_NoReduce);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "3343: #if SQLITE_OMIT_SUBQUERY",
          "3344:       iResult = 0;",
          "3345: #else",
          "3347: #endif",
          "3348:     }else{",
          "3349:       int i;",
          "",
          "[Removed Lines]",
          "3346:       iResult = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "3358:       iResult = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "3817:       if( op==TK_SELECT && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){",
          "3818:         sqlite3SubselectError(pParse, nCol, 1);",
          "3819:       }else{",
          "3821:       }",
          "3822:       break;",
          "3823:     }",
          "3824:     case TK_SELECT_COLUMN: {",
          "3825:       int n;",
          "3826:       if( pExpr->pLeft->iTable==0 ){",
          "3828:       }",
          "3829:       assert( pExpr->iTable==0 || pExpr->pLeft->op==TK_SELECT );",
          "3830:       if( pExpr->iTable",
          "",
          "[Removed Lines]",
          "3820:         return sqlite3CodeSubselect(pParse, pExpr, 0, 0);",
          "3827:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft, 0, 0);",
          "",
          "[Added Lines]",
          "3832:         return sqlite3CodeSubselect(pParse, pExpr);",
          "3839:         pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "4258: int sqlite3GetToken(const unsigned char *, int *);",
          "4259: void sqlite3NestedParse(Parse*, const char*, ...);",
          "4260: void sqlite3ExpirePreparedStatements(sqlite3*, int);",
          "4262: void sqlite3SelectPrep(Parse*, Select*, NameContext*);",
          "4263: void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);",
          "4264: int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);",
          "",
          "[Removed Lines]",
          "4261: int sqlite3CodeSubselect(Parse*, Expr *, int, int);",
          "",
          "[Added Lines]",
          "4261: void sqlite3CodeRhsOfIN(Parse*, Expr*, int);",
          "4262: int sqlite3CodeSubselect(Parse*, Expr*);",
          "",
          "---------------"
        ],
        "src/wherecode.c||src/wherecode.c": [
          "File: src/wherecode.c -> src/wherecode.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1076: #ifndef SQLITE_OMIT_SUBQUERY",
          "1077:     if( (p->flags & EP_xIsSelect) ){",
          "1078:       Vdbe *v = pParse->pVdbe;",
          "1080:       sqlite3VdbeAddOp3(v, OP_Copy, iSelect, iReg, nReg-1);",
          "1081:     }else",
          "1082: #endif",
          "",
          "[Removed Lines]",
          "1079:       int iSelect = sqlite3CodeSubselect(pParse, p, 0, 0);",
          "",
          "[Added Lines]",
          "1079:       int iSelect;",
          "1080:       assert( p->op==TK_SELECT );",
          "1081:       iSelect = sqlite3CodeSubselect(pParse, p);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b15f19c75e74a939f13fe86e57820571aaa2295b",
      "candidate_info": {
        "commit_hash": "b15f19c75e74a939f13fe86e57820571aaa2295b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b15f19c75e74a939f13fe86e57820571aaa2295b",
        "files": [
          "ext/fts5/fts5Int.h",
          "ext/fts5/fts5_hash.c",
          "ext/fts5/fts5_index.c",
          "ext/fts5/test/fts5aa.test",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Fix an fts5 problem with interleaving reads and writes in a single transaction.\n\nFossilOrigin-Name: 45c73deb440496e848cb24d4c1326d4105dacfee8bbafb115e567051855e6518",
        "before_after_code_files": [
          "ext/fts5/fts5Int.h||ext/fts5/fts5Int.h",
          "ext/fts5/fts5_hash.c||ext/fts5/fts5_hash.c",
          "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c",
          "ext/fts5/test/fts5aa.test||ext/fts5/test/fts5aa.test",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/fts5/fts5Int.h||ext/fts5/fts5Int.h": [
          "File: ext/fts5/fts5Int.h -> ext/fts5/fts5Int.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "584: int sqlite3Fts5HashQuery(",
          "589: );",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "586:   int nPre,",
          "",
          "---------------"
        ],
        "ext/fts5/fts5_hash.c||ext/fts5/fts5_hash.c": [
          "File: ext/fts5/fts5_hash.c -> ext/fts5/fts5_hash.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "187:   return SQLITE_OK;",
          "188: }",
          "191:   if( p->iSzPoslist ){",
          "193:     if( pHash->eDetail==FTS5_DETAIL_NONE ){",
          "195:       if( p->bDel ){",
          "197:         if( p->bContent ){",
          "199:         }",
          "200:       }",
          "201:     }else{",
          "205:       assert( p->bDel==0 || p->bDel==1 );",
          "",
          "[Removed Lines]",
          "190: static void fts5HashAddPoslistSize(Fts5Hash *pHash, Fts5HashEntry *p){",
          "192:     u8 *pPtr = (u8*)p;",
          "194:       assert( p->nData==p->iSzPoslist );",
          "196:         pPtr[p->nData++] = 0x00;",
          "198:           pPtr[p->nData++] = 0x00;",
          "",
          "[Added Lines]",
          "190: static int fts5HashAddPoslistSize(",
          "191:   Fts5Hash *pHash,",
          "192:   Fts5HashEntry *p,",
          "193:   Fts5HashEntry *p2",
          "194: ){",
          "195:   int nRet = 0;",
          "197:     u8 *pPtr = p2 ? (u8*)p2 : (u8*)p;",
          "198:     int nData = p->nData;",
          "200:       assert( nData==p->iSzPoslist );",
          "202:         pPtr[nData++] = 0x00;",
          "204:           pPtr[nData++] = 0x00;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "209:         int nByte = sqlite3Fts5GetVarintLen((u32)nPos);",
          "210:         memmove(&pPtr[p->iSzPoslist + nByte], &pPtr[p->iSzPoslist + 1], nSz);",
          "211:         sqlite3Fts5PutVarint(&pPtr[p->iSzPoslist], nPos);",
          "213:       }",
          "214:     }",
          "219:   }",
          "220: }",
          "",
          "[Removed Lines]",
          "212:         p->nData += (nByte-1);",
          "216:     p->iSzPoslist = 0;",
          "217:     p->bDel = 0;",
          "218:     p->bContent = 0;",
          "",
          "[Added Lines]",
          "218:         nData += (nByte-1);",
          "222:     nRet = nData - p->nData;",
          "223:     if( p2==0 ){",
          "224:       p->iSzPoslist = 0;",
          "225:       p->bDel = 0;",
          "226:       p->bContent = 0;",
          "227:       p->nData = nData;",
          "228:     }",
          "230:   return nRet;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "330:   if( iRowid!=p->iRowid ){",
          "332:     p->nData += sqlite3Fts5PutVarint(&pPtr[p->nData], iRowid - p->iRowid);",
          "333:     p->iRowid = iRowid;",
          "334:     bNew = 1;",
          "",
          "[Removed Lines]",
          "331:     fts5HashAddPoslistSize(pHash, p);",
          "",
          "[Added Lines]",
          "342:     fts5HashAddPoslistSize(pHash, p, 0);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "474: int sqlite3Fts5HashQuery(",
          "479: ){",
          "480:   unsigned int iHash = fts5HashKey(pHash->nSlot, (const u8*)pTerm, nTerm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "487:   int nPre,",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "488:   }",
          "490:   if( p ){",
          "494:   }else{",
          "497:   }",
          "",
          "[Removed Lines]",
          "491:     fts5HashAddPoslistSize(pHash, p);",
          "",
          "[Added Lines]",
          "503:     int nHashPre = sizeof(Fts5HashEntry) + nTerm + 1;",
          "504:     int nList = p->nData - nHashPre;",
          "505:     u8 *pRet = (u8*)(*ppOut = sqlite3_malloc64(nPre + nList + 10));",
          "506:     if( pRet ){",
          "507:       Fts5HashEntry *pFaux = (Fts5HashEntry*)&pRet[nPre-nHashPre];",
          "508:       memcpy(&pRet[nPre], &((u8*)p)[nHashPre], nList);",
          "509:       nList += fts5HashAddPoslistSize(pHash, p, pFaux);",
          "511:     }else{",
          "513:       return SQLITE_NOMEM;",
          "514:     }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "525:   if( (p = pHash->pScan) ){",
          "526:     char *zKey = fts5EntryKey(p);",
          "527:     int nTerm = (int)strlen(zKey);",
          "",
          "[Removed Lines]",
          "528:     fts5HashAddPoslistSize(pHash, p);",
          "",
          "[Added Lines]",
          "549:     fts5HashAddPoslistSize(pHash, p, 0);",
          "",
          "---------------"
        ],
        "ext/fts5/fts5_index.c||ext/fts5/fts5_index.c": [
          "File: ext/fts5/fts5_index.c -> ext/fts5/fts5_index.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2459: ){",
          "2461:   int nList = 0;",
          "2462:   const u8 *z = 0;",
          "2463:   int n = 0;",
          "2465:   assert( p->pHash );",
          "2466:   assert( p->rc==SQLITE_OK );",
          "2468:   if( pTerm==0 || (flags & FTS5INDEX_QUERY_SCAN) ){",
          "2469:     p->rc = sqlite3Fts5HashScanInit(p->pHash, (const char*)pTerm, nTerm);",
          "2470:     sqlite3Fts5HashScanEntry(p->pHash, (const char**)&z, &pList, &nList);",
          "2471:     n = (z ? (int)strlen((const char*)z) : 0);",
          "2472:   }else{",
          "2475:     z = pTerm;",
          "2476:     n = nTerm;",
          "2477:   }",
          "2481:     sqlite3Fts5BufferSet(&p->rc, &pIter->term, n, z);",
          "2485:     pLeaf->nn = pLeaf->szLeaf = nList;",
          "2486:     pIter->pLeaf = pLeaf;",
          "2487:     pIter->iLeafOffset = fts5GetVarint(pLeaf->p, (u64*)&pIter->iRowid);",
          "",
          "[Removed Lines]",
          "2460:   const u8 *pList = 0;",
          "2473:     pIter->flags |= FTS5_SEGITER_ONETERM;",
          "2474:     sqlite3Fts5HashQuery(p->pHash, (const char*)pTerm, nTerm, &pList, &nList);",
          "2479:   if( pList ){",
          "2480:     Fts5Data *pLeaf;",
          "2482:     pLeaf = fts5IdxMalloc(p, sizeof(Fts5Data));",
          "2483:     if( pLeaf==0 ) return;",
          "2484:     pLeaf->p = (u8*)pList;",
          "",
          "[Added Lines]",
          "2463:   Fts5Data *pLeaf = 0;",
          "2469:     const u8 *pList = 0;",
          "2474:     if( pList ){",
          "2475:       pLeaf = fts5IdxMalloc(p, sizeof(Fts5Data));",
          "2476:       if( pLeaf ){",
          "2477:         pLeaf->p = pList;",
          "2478:       }",
          "2479:     }",
          "2481:     p->rc = sqlite3Fts5HashQuery(p->pHash, sizeof(Fts5Data),",
          "2482:         (const char*)pTerm, nTerm, (void**)&pLeaf, &nList",
          "2483:     );",
          "2484:     if( pLeaf ){",
          "2485:       pLeaf->p = (u8*)&pLeaf[1];",
          "2486:     }",
          "2489:     pIter->flags |= FTS5_SEGITER_ONETERM;",
          "2492:   if( pLeaf ){",
          "",
          "---------------"
        ],
        "ext/fts5/test/fts5aa.test||ext/fts5/test/fts5aa.test": [
          "File: ext/fts5/test/fts5aa.test -> ext/fts5/test/fts5aa.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "427:   db eval { UPDATE n1_config SET v=50 WHERE k='version' }",
          "428:   set fd [db incrblob main n1_data block 10]",
          "429:   fconfigure $fd -encoding binary -translation binary",
          "431:   close $fd",
          "432: }",
          "433: db func funk funk",
          "",
          "[Removed Lines]",
          "430:   puts -nonewline $fd \"\\x44\\x45\"",
          "",
          "[Added Lines]",
          "430: #  puts -nonewline $fd \"\\x44\\x45\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "603:   SELECT * FROM t11, t10 WHERE t10.rowid IS NULL;",
          "604: }",
          "606: }",
          "608: expand_all_sql db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "606: #-------------------------------------------------------------------------",
          "607: do_execsql_test 24.0 {",
          "608:   CREATE VIRTUAL TABLE t12 USING fts5(x, detail=%DETAIL%);",
          "609:   INSERT INTO t12 VALUES('aaaa');",
          "610: }",
          "611: do_execsql_test 24.1 {",
          "612:   BEGIN;",
          "613:     DELETE FROM t12 WHERE rowid=1;",
          "614:     SELECT * FROM t12('aaaa');",
          "615:     INSERT INTO t12 VALUES('aaaa');",
          "616:   END;",
          "617: }",
          "618: do_execsql_test 24.2 {",
          "619:   INSERT INTO t12(t12) VALUES('integrity-check');",
          "620: }",
          "621: do_execsql_test 24.3 {",
          "622:     SELECT * FROM t12('aaaa');",
          "623: } {aaaa}",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: c2f50aa4e7bad8821e91a7490283dd53e44047d10a8cfebc3e2da26c770a5218",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "89dec01e4867f2ab888bc33adbf4a65c2cf7b16a",
      "candidate_info": {
        "commit_hash": "89dec01e4867f2ab888bc33adbf4a65c2cf7b16a",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/89dec01e4867f2ab888bc33adbf4a65c2cf7b16a",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/test_vfs.c",
          "test/walvfs.test"
        ],
        "message": "Add a few more test cases to walvfs.test.\n\nFossilOrigin-Name: 14a64df36efe0dc36795311d58385f9c65dc465b214059e07c2ee6b95ea99c87",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/test_vfs.c||src/test_vfs.c",
          "test/walvfs.test||test/walvfs.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 6cae81cd1ffb0180e0260d5ba921502c7dee2f54637bff3558a4d1cb5dfd3f32",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/test_vfs.c||src/test_vfs.c": [
          "File: src/test_vfs.c -> src/test_vfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "234:     { SQLITE_LOCKED,   \"SQLITE_LOCKED\" },",
          "235:     { SQLITE_BUSY,     \"SQLITE_BUSY\"   },",
          "236:     { SQLITE_READONLY, \"SQLITE_READONLY\"   },",
          "237:   };",
          "239:   const char *z;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "237:     { SQLITE_READONLY_CANTINIT, \"SQLITE_READONLY_CANTINIT\"   },",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "919:   if( rc==SQLITE_OK && isWrite && !pFd->pShm->aPage[iPage] ){",
          "920:     tvfsAllocPage(pFd->pShm, iPage, pgsz);",
          "921:   }",
          "924:   return rc;",
          "925: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "923:   if( rc==SQLITE_OK || rc==SQLITE_READONLY ){",
          "925:   }",
          "",
          "---------------"
        ],
        "test/walvfs.test||test/walvfs.test": [
          "File: test/walvfs.test -> test/walvfs.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "106: #-------------------------------------------------------------------------",
          "107: # Test that a checkpoint may be interrupted using sqlite3_interrupt().",
          "108: #",
          "109: reset_db",
          "110: db close",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "109: # And that the error code is SQLITE_NOMEM, not SQLITE_INTERRUPT, if",
          "110: # an OOM error occurs just before the sqlite3_interrupt() call.",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "137:   PRAGMA wal_checkpoint",
          "138: } {1 interrupted}",
          "140: #-------------------------------------------------------------------------",
          "141: #",
          "142: reset_db",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "143: set ::cnt 2",
          "144: proc xWrite {method file args} {",
          "145:   if {[file tail $file]==\"test.db\"} {",
          "146:     incr ::cnt -1",
          "147:     if {$::cnt==0} {",
          "148:       sqlite3_memdebug_fail 5 -repeat 0",
          "149:       catchsql { SELECT 'a big long string!' }",
          "150:       sqlite3_interrupt db",
          "151:     }",
          "152:   }",
          "153:   return SQLITE_OK",
          "154: }",
          "156: do_catchsql_test 3.2 {",
          "157:   PRAGMA wal_checkpoint",
          "158: } {1 {out of memory}}",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "235:   execsql { SELECT count(*) FROM t1 }",
          "236: } {20}",
          "238: #-------------------------------------------------------------------------",
          "239: # Cause an SQLITE_PROTOCOL while attempting to restart the wal file.",
          "240: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "258: vfs_set_readmark db main 1 100",
          "259: vfs_set_readmark db main 2 100",
          "260: vfs_set_readmark db main 3 100",
          "261: vfs_set_readmark db main 4 100",
          "263: tvfs script xShmMapLock",
          "264: tvfs filter {xShmLock xShmMap}",
          "265: proc xShmMapLock {method args} {",
          "266:   if {$method==\"xShmMap\"} {",
          "267:     return \"SQLITE_READONLY\"",
          "268:   }",
          "269:   return SQLITE_BUSY",
          "270: }",
          "272: sqlite3 db2 test.db -vfs tvfs",
          "273: breakpoint",
          "274: do_test 5.5 {",
          "275:   list [catch { execsql { SELECT count(*) FROM t1 } db2 } msg] $msg",
          "276: } {1 {attempt to write a readonly database}}",
          "278: tvfs filter {}",
          "279: vfs_set_readmark db main 1 1",
          "281: do_test 5.6 {",
          "282:   list [catch { execsql { SELECT count(*) FROM t1 } db2 } msg] $msg",
          "283: } {0 20}",
          "284: db2 close",
          "285: db close",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "259: } {}",
          "261: tvfs filter xShmLock",
          "262: set ::flag 0",
          "263: proc xShmLock {method file handle spec} {",
          "264:   if {$::flag && [lrange $spec 2 end]==\"lock shared\"} {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "311: tvfs script xShmLock",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "306:   PRAGMA wal_checkpoint",
          "307: } {1 -1 -1}",
          "309: db close",
          "310: tvfs delete",
          "311: finish_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "359: #-------------------------------------------------------------------------",
          "360: # Check that the page cache is correctly flushed if a checkpointer using",
          "361: # a version 2 VFS makes a checkpoint with an out-of-date cache.",
          "362: #",
          "363: reset_db",
          "364: testvfs tvfs2 -iversion 2",
          "365: db close",
          "366: sqlite3 db test.db -vfs tvfs2",
          "367: do_execsql_test 8.0 {",
          "368:   PRAGMA auto_vacuum = 0;",
          "369:   PRAGMA page_size = 1024;",
          "370:   CREATE TABLE t1(x);",
          "371:   PRAGMA journal_mode = wal;",
          "372:   WITH s(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM s LIMIT 20 )",
          "373:   INSERT INTO t1 SELECT randomblob(75) FROM s;",
          "374: } {wal}",
          "376: do_execsql_test 8.1 { SELECT count(*) FROM t1 } {20}",
          "378: do_test 8.2 {",
          "379:   sqlite3 db2 test.db -vfs tvfs2",
          "380:   execsql {",
          "381:     INSERT INTO t1 VALUES(randomblob(75));",
          "382:   } db2",
          "383:   db2 close",
          "384: } {}",
          "386: do_execsql_test 8.3 {",
          "387:   PRAGMA wal_checkpoint;",
          "388:   SELECT count(*) FROM t1",
          "389: } {0 5 5 21}",
          "390: tvfs2 delete",
          "392: #-------------------------------------------------------------------------",
          "393: reset_db",
          "394: db close",
          "395: sqlite3 db test.db -vfs tvfs",
          "396: do_execsql_test 9.0 {",
          "397:   PRAGMA auto_vacuum = 0;",
          "398:   PRAGMA page_size = 1024;",
          "399:   CREATE TABLE t1(x);",
          "400:   PRAGMA journal_mode = wal;",
          "401:   WITH s(i) AS ( SELECT 1 UNION ALL SELECT i+1 FROM s LIMIT 20 )",
          "402:   INSERT INTO t1 SELECT randomblob(75) FROM s;",
          "403: } {wal}",
          "405: sqlite3 db2 test.db -vfs tvfs",
          "406: tvfs filter {xShmMap xShmLock}",
          "407: tvfs script xShmMap",
          "408: proc xShmMap {method file handle args} {",
          "409:   switch -- $method {",
          "410:     xShmMap {",
          "411:       return \"SQLITE_READONLY_CANTINIT\"",
          "412:     }",
          "413:     xShmLock {",
          "414:       if {$args==\"{3 1 lock shared}\"} {",
          "415:         return \"SQLITE_IOERR\"",
          "416:       }",
          "417:     }",
          "418:   }",
          "419: }",
          "421: do_test 9.1 {",
          "422:   catchsql { SELECT count(*) FROM t1 } db2",
          "423: } {1 {disk I/O error}}",
          "426: db2 close",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-18625",
  "cve_desc": "An issue was discovered in Suricata 5.0.0. It was possible to bypass/evade any tcp based signature by faking a closed TCP session using an evil server. After the TCP SYN packet, it is possible to inject a RST ACK and a FIN ACK packet with a bad TCP Timestamp option. The client will ignore the RST ACK and the FIN ACK packets because of the bad TCP Timestamp option. Both linux and windows client are ignoring the injected packets.",
  "repo": "OISF/suricata",
  "patch_hash": "ea0659de7640cf6a51de5bbd1dbbb0414e4623a0",
  "patch_info": {
    "commit_hash": "ea0659de7640cf6a51de5bbd1dbbb0414e4623a0",
    "repo": "OISF/suricata",
    "commit_url": "https://github.com/OISF/suricata/commit/ea0659de7640cf6a51de5bbd1dbbb0414e4623a0",
    "files": [
      "src/stream-tcp.c"
    ],
    "message": "stream: fix SYN_SENT RST/FIN injection\n\nRST injection during the SYN_SENT state could trick Suricata into marking\na session as CLOSED. The way this was done is: using invalid TSECR value\nin RST+ACK packet. The ACK was needed to force Linux into considering the\nTSECR value and compare it to the TSVAL from the SYN packet.\n\nThe second works only against Windows. The client would not use a TSVAL\nbut the RST packet would. Windows will reject this, but Suricata considered\nthe RST valid and triggered the CLOSED logic.\n\nThis patch addresses both. When the SYN packet used timestamp support\nthe timestamp of incoming packet is validated. Otherwise, packet responding\nshould not have a timestamp.\n\nBug #3286\n\nReported-by: Nicolas Adba\n(cherry picked from commit 9f0294fadca3dcc18c919424242a41e01f3e8318)",
    "before_after_code_files": [
      "src/stream-tcp.c||src/stream-tcp.c"
    ]
  },
  "patch_diff": {
    "src/stream-tcp.c||src/stream-tcp.c": [
      "File: src/stream-tcp.c -> src/stream-tcp.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1349:     ssn->flags &=~ STREAMTCP_FLAG_4WHS;",
      "1350: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1358: static inline bool StateSynSentValidateTimestamp(TcpSession *ssn, Packet *p)",
      "1359: {",
      "1361:     if (PKT_IS_TOSERVER(p) || !(TCP_HAS_TS(p))) {",
      "1362:         return true;",
      "1363:     }",
      "1365:     TcpStream *receiver_stream = &ssn->client;",
      "1366:     uint32_t ts_echo = TCP_GET_TSECR(p);",
      "1367:     if ((receiver_stream->flags & STREAMTCP_STREAM_FLAG_TIMESTAMP) != 0) {",
      "1368:         if (receiver_stream->last_ts != 0 && ts_echo != 0 &&",
      "1369:             ts_echo != receiver_stream->last_ts)",
      "1370:         {",
      "1371:             SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,",
      "1372:                     ts_echo, receiver_stream->last_ts);",
      "1373:             return false;",
      "1374:         }",
      "1375:     } else {",
      "1376:         if (receiver_stream->last_ts == 0 && ts_echo != 0) {",
      "1377:             SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,",
      "1378:                     ts_echo, receiver_stream->last_ts);",
      "1379:             return false;",
      "1380:         }",
      "1381:     }",
      "1382:     return true;",
      "1383: }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "1368:     SCLogDebug(\"ssn %p: pkt received: %s\", ssn, PKT_IS_TOCLIENT(p) ?",
      "1369:                \"toclient\":\"toserver\");",
      "1372:     if (p->tcph->th_flags & TH_RST) {",
      "1373:         if (!StreamTcpValidateRst(ssn, p))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1405:     if (StateSynSentValidateTimestamp(ssn, p) == false)",
      "1406:         return -1;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "9f0294fadca3dcc18c919424242a41e01f3e8318",
      "candidate_info": {
        "commit_hash": "9f0294fadca3dcc18c919424242a41e01f3e8318",
        "repo": "OISF/suricata",
        "commit_url": "https://github.com/OISF/suricata/commit/9f0294fadca3dcc18c919424242a41e01f3e8318",
        "files": [
          "src/stream-tcp.c"
        ],
        "message": "stream: fix SYN_SENT RST/FIN injection\n\nRST injection during the SYN_SENT state could trick Suricata into marking\na session as CLOSED. The way this was done is: using invalid TSECR value\nin RST+ACK packet. The ACK was needed to force Linux into considering the\nTSECR value and compare it to the TSVAL from the SYN packet.\n\nThe second works only against Windows. The client would not use a TSVAL\nbut the RST packet would. Windows will reject this, but Suricata considered\nthe RST valid and triggered the CLOSED logic.\n\nThis patch addresses both. When the SYN packet used timestamp support\nthe timestamp of incoming packet is validated. Otherwise, packet responding\nshould not have a timestamp.\n\nBug #3286\n\nReported-by: Nicolas Adba",
        "before_after_code_files": [
          "src/stream-tcp.c||src/stream-tcp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "src/stream-tcp.c||src/stream-tcp.c"
          ],
          "candidate": [
            "src/stream-tcp.c||src/stream-tcp.c"
          ]
        }
      },
      "candidate_diff": {
        "src/stream-tcp.c||src/stream-tcp.c": [
          "File: src/stream-tcp.c -> src/stream-tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1363:     ssn->flags &=~ STREAMTCP_FLAG_4WHS;",
          "1364: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1372: static inline bool StateSynSentValidateTimestamp(TcpSession *ssn, Packet *p)",
          "1373: {",
          "1375:     if (PKT_IS_TOSERVER(p) || !(TCP_HAS_TS(p))) {",
          "1376:         return true;",
          "1377:     }",
          "1379:     TcpStream *receiver_stream = &ssn->client;",
          "1380:     uint32_t ts_echo = TCP_GET_TSECR(p);",
          "1381:     if ((receiver_stream->flags & STREAMTCP_STREAM_FLAG_TIMESTAMP) != 0) {",
          "1382:         if (receiver_stream->last_ts != 0 && ts_echo != 0 &&",
          "1383:             ts_echo != receiver_stream->last_ts)",
          "1384:         {",
          "1385:             SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,",
          "1386:                     ts_echo, receiver_stream->last_ts);",
          "1387:             return false;",
          "1388:         }",
          "1389:     } else {",
          "1390:         if (receiver_stream->last_ts == 0 && ts_echo != 0) {",
          "1391:             SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,",
          "1392:                     ts_echo, receiver_stream->last_ts);",
          "1393:             return false;",
          "1394:         }",
          "1395:     }",
          "1396:     return true;",
          "1397: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1382:     SCLogDebug(\"ssn %p: pkt received: %s\", ssn, PKT_IS_TOCLIENT(p) ?",
          "1383:                \"toclient\":\"toserver\");",
          "1386:     if (p->tcph->th_flags & TH_RST) {",
          "1387:         if (!StreamTcpValidateRst(ssn, p))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1419:     if (StateSynSentValidateTimestamp(ssn, p) == false)",
          "1420:         return -1;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
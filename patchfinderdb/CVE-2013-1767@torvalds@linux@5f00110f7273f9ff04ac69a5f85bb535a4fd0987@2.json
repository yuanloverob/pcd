{
  "cve_id": "CVE-2013-1767",
  "cve_desc": "Use-after-free vulnerability in the shmem_remount_fs function in mm/shmem.c in the Linux kernel before 3.7.10 allows local users to gain privileges or cause a denial of service (system crash) by remounting a tmpfs filesystem without specifying a required mpol (aka mempolicy) mount option.",
  "repo": "torvalds/linux",
  "patch_hash": "5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
  "patch_info": {
    "commit_hash": "5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/5f00110f7273f9ff04ac69a5f85bb535a4fd0987",
    "files": [
      "mm/shmem.c"
    ],
    "message": "tmpfs: fix use-after-free of mempolicy object\n\nThe tmpfs remount logic preserves filesystem mempolicy if the mpol=M\noption is not specified in the remount request.  A new policy can be\nspecified if mpol=M is given.\n\nBefore this patch remounting an mpol bound tmpfs without specifying\nmpol= mount option in the remount request would set the filesystem's\nmempolicy object to a freed mempolicy object.\n\nTo reproduce the problem boot a DEBUG_PAGEALLOC kernel and run:\n    # mkdir /tmp/x\n\n    # mount -t tmpfs -o size=100M,mpol=interleave nodev /tmp/x\n\n    # grep /tmp/x /proc/mounts\n    nodev /tmp/x tmpfs rw,relatime,size=102400k,mpol=interleave:0-3 0 0\n\n    # mount -o remount,size=200M nodev /tmp/x\n\n    # grep /tmp/x /proc/mounts\n    nodev /tmp/x tmpfs rw,relatime,size=204800k,mpol=??? 0 0\n        # note ? garbage in mpol=... output above\n\n    # dd if=/dev/zero of=/tmp/x/f count=1\n        # panic here\n\nPanic:\n    BUG: unable to handle kernel NULL pointer dereference at           (null)\n    IP: [<          (null)>]           (null)\n    [...]\n    Oops: 0010 [#1] SMP DEBUG_PAGEALLOC\n    Call Trace:\n      mpol_shared_policy_init+0xa5/0x160\n      shmem_get_inode+0x209/0x270\n      shmem_mknod+0x3e/0xf0\n      shmem_create+0x18/0x20\n      vfs_create+0xb5/0x130\n      do_last+0x9a1/0xea0\n      path_openat+0xb3/0x4d0\n      do_filp_open+0x42/0xa0\n      do_sys_open+0xfe/0x1e0\n      compat_sys_open+0x1b/0x20\n      cstar_dispatch+0x7/0x1f\n\nNon-debug kernels will not crash immediately because referencing the\ndangling mpol will not cause a fault.  Instead the filesystem will\nreference a freed mempolicy object, which will cause unpredictable\nbehavior.\n\nThe problem boils down to a dropped mpol reference below if\nshmem_parse_options() does not allocate a new mpol:\n\n    config = *sbinfo\n    shmem_parse_options(data, &config, true)\n    mpol_put(sbinfo->mpol)\n    sbinfo->mpol = config.mpol  /* BUG: saves unreferenced mpol */\n\nThis patch avoids the crash by not releasing the mempolicy if\nshmem_parse_options() doesn't create a new mpol.\n\nHow far back does this issue go? I see it in both 2.6.36 and 3.3.  I did\nnot look back further.\n\nSigned-off-by: Greg Thelen <gthelen@google.com>\nAcked-by: Hugh Dickins <hughd@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
    "before_after_code_files": [
      "mm/shmem.c||mm/shmem.c"
    ]
  },
  "patch_diff": {
    "mm/shmem.c||mm/shmem.c": [
      "File: mm/shmem.c -> mm/shmem.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2486:  unsigned long inodes;",
      "2487:  int error = -EINVAL;",
      "2489:  if (shmem_parse_options(data, &config, true))",
      "2490:   return error;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2489:  config.mpol = NULL;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "2510:  sbinfo->max_inodes  = config.max_inodes;",
      "2511:  sbinfo->free_inodes = config.max_inodes - inodes;",
      "2515: out:",
      "2516:  spin_unlock(&sbinfo->stat_lock);",
      "2517:  return error;",
      "",
      "[Removed Lines]",
      "2513:  mpol_put(sbinfo->mpol);",
      "",
      "[Added Lines]",
      "2517:  if (config.mpol) {",
      "2518:   mpol_put(sbinfo->mpol);",
      "2520:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "8a356ce38e134b3b09b439e88dc770f8f5567648",
      "candidate_info": {
        "commit_hash": "8a356ce38e134b3b09b439e88dc770f8f5567648",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/8a356ce38e134b3b09b439e88dc770f8f5567648",
        "files": [
          "mm/sparse.c"
        ],
        "message": "memory-hotplug: consider compound pages when free memmap\n\nusemap could also be allocated as compound pages.  Should also consider\ncompound pages when freeing memmap.\n\nIf we don't fix it, there could be problems when we free vmemmap\npagetables which are stored in compound pages.  The old pagetables will\nnot be freed properly, and when we add the memory again, no new\npagetable will be created.  And the old pagetable entry is used, than\nthe kernel will panic.\n\nThe call trace is like the following:\n\n  BUG: unable to handle kernel paging request at ffffea0040000000\n  IP: [<ffffffff816a483f>] sparse_add_one_section+0xef/0x166\n  PGD 7ff7d4067 PUD 78e035067 PMD 78e11d067 PTE 0\n  Oops: 0002 [#1] SMP\n  Modules linked in: ip6table_filter ip6_tables ebtable_nat ebtables nf_conntrack_ipv4 nf_defrag_ipv4 xt_state nf_conntrack ipt_REJECT xt_CHECKSUM iptable_mangle iptable_filter ip_tables bridge stp llc sunrpc binfmt_misc dm_mirror dm_region_hash dm_log dm_mod vhost_net macvtap macvlan tun uinput iTCO_wdt iTCO_vendor_support coretemp kvm_intel kvm crc32c_intel microcode pcspkr sg lpc_ich mfd_core i2c_i801 i2c_core i7core_edac edac_core ioatdma e1000e igb dca ptp pps_core sd_mod crc_t10dif megaraid_sas mptsas mptscsih mptbase scsi_transport_sas scsi_mod\n  CPU 0\n  Pid: 4, comm: kworker/0:0 Tainted: G        W 3.8.0-rc3-phy-hot-remove+ #3 FUJITSU-SV PRIMEQUEST 1800E/SB\n  RIP: 0010:[<ffffffff816a483f>]  [<ffffffff816a483f>] sparse_add_one_section+0xef/0x166\n  RSP: 0018:ffff8807bdcb35d8  EFLAGS: 00010006\n  RAX: 0000000000000000 RBX: 0000000000000200 RCX: 0000000000200000\n  RDX: ffff88078df01148 RSI: 0000000000000282 RDI: ffffea0040000000\n  RBP: ffff8807bdcb3618 R08: 4cf05005b019467a R09: 0cd98fa09631467a\n  R10: 0000000000000000 R11: 0000000000030e20 R12: 0000000000008000\n  R13: ffffea0040000000 R14: ffff88078df66248 R15: ffff88078ea13b10\n  FS:  0000000000000000(0000) GS:ffff8807c1a00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\n  CR2: ffffea0040000000 CR3: 0000000001c0c000 CR4: 00000000000007f0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n  Process kworker/0:0 (pid: 4, threadinfo ffff8807bdcb2000, task ffff8807bde18000)\n  Call Trace:\n    __add_pages+0x85/0x120\n    arch_add_memory+0x71/0xf0\n    add_memory+0xd6/0x1f0\n    acpi_memory_device_add+0x170/0x20c\n    acpi_device_probe+0x50/0x18a\n    really_probe+0x6c/0x320\n    driver_probe_device+0x47/0xa0\n    __device_attach+0x53/0x60\n    bus_for_each_drv+0x6c/0xa0\n    device_attach+0xa8/0xc0\n    bus_probe_device+0xb0/0xe0\n    device_add+0x301/0x570\n    device_register+0x1e/0x30\n    acpi_device_register+0x1d8/0x27c\n    acpi_add_single_object+0x1df/0x2b9\n    acpi_bus_check_add+0x112/0x18f\n    acpi_ns_walk_namespace+0x105/0x255\n    acpi_walk_namespace+0xcf/0x118\n    acpi_bus_scan+0x5b/0x7c\n    acpi_bus_add+0x2a/0x2c\n    container_notify_cb+0x112/0x1a9\n    acpi_ev_notify_dispatch+0x46/0x61\n    acpi_os_execute_deferred+0x27/0x34\n    process_one_work+0x20e/0x5c0\n    worker_thread+0x12e/0x370\n    kthread+0xee/0x100\n    ret_from_fork+0x7c/0xb0\n  Code: 00 00 48 89 df 48 89 45 c8 e8 3e 71 b1 ff 48 89 c2 48 8b 75 c8 b8 ef ff ff ff f6 02 01 75 4b 49 63 cc 31 c0 4c 89 ef 48 c1 e1 06 <f3> aa 48 8b 02 48 83 c8 01 48 85 d2 48 89 02 74 29 a8 01 74 25\n  RIP  [<ffffffff816a483f>] sparse_add_one_section+0xef/0x166\n   RSP <ffff8807bdcb35d8>\n  CR2: ffffea0040000000\n  ---[ end trace e7f94e3a34c442d4 ]---\n  Kernel panic - not syncing: Fatal exception\n\nSigned-off-by: Wen Congyang <wency@cn.fujitsu.com>\nSigned-off-by: Tang Chen <tangchen@cn.fujitsu.com>\nCc: Jiang Liu <jiang.liu@huawei.com>\nCc: Jianguo Wu <wujianguo@huawei.com>\nCc: Kamezawa Hiroyuki <kamezawa.hiroyu@jp.fujitsu.com>\nCc: Lai Jiangshan <laijs@cn.fujitsu.com>\nCc: Yasuaki Ishimatsu <isimatu.yasuaki@jp.fujitsu.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/sparse.c||mm/sparse.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/sparse.c||mm/sparse.c": [
          "File: mm/sparse.c -> mm/sparse.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "702:   kfree(usemap);",
          "703:   if (memmap)",
          "704:    __kfree_section_memmap(memmap, PAGES_PER_SECTION);",
          "",
          "[Removed Lines]",
          "701:  if (PageSlab(usemap_page)) {",
          "",
          "[Added Lines]",
          "701:  if (PageSlab(usemap_page) || PageCompound(usemap_page)) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a47970ff7814718fec31b7d966747c6aa1a3545f",
      "candidate_info": {
        "commit_hash": "a47970ff7814718fec31b7d966747c6aa1a3545f",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a47970ff7814718fec31b7d966747c6aa1a3545f",
        "files": [
          "fs/nfs/nfs4proc.c"
        ],
        "message": "NFSv4.1: Hold reference to layout hdr in layoutget\n\nThis fixes an oops where a LAYOUTGET is in still in the rpciod queue,\nbut the requesting processes has been killed.  Without this, killing\nthe process does the final pnfs_put_layout_hdr() and sets NFS_I(inode)->layout\nto NULL while the LAYOUTGET rpc task still references it.\n\nExample oops:\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000080\nIP: [<ffffffffa01bd586>] pnfs_choose_layoutget_stateid+0x37/0xef [nfsv4]\nPGD 7365b067 PUD 7365d067 PMD 0\nOops: 0000 [#1] SMP DEBUG_PAGEALLOC\nModules linked in: nfs_layout_nfsv41_files nfsv4 auth_rpcgss nfs lockd sunrpc ipt_MASQUERADE ip6table_mangle ip6t_REJECT nf_conntrack_ipv6 nf_defrag_ipv6 iptable_nat nf_nat_ipv4 nf_nat iptable_mangle ip6table_filter ip6_tables ppdev e1000 i2c_piix4 i2c_core shpchp parport_pc parport crc32c_intel aesni_intel xts aes_x86_64 lrw gf128mul ablk_helper cryptd mptspi scsi_transport_spi mptscsih mptbase floppy autofs4\nCPU 0\nPid: 27, comm: kworker/0:1 Not tainted 3.8.0-dros_cthon2013+ #4 VMware, Inc. VMware Virtual Platform/440BX Desktop Reference Platform\nRIP: 0010:[<ffffffffa01bd586>]  [<ffffffffa01bd586>] pnfs_choose_layoutget_stateid+0x37/0xef [nfsv4]\nRSP: 0018:ffff88007b0c1c88  EFLAGS: 00010246\nRAX: ffff88006ed36678 RBX: 0000000000000000 RCX: 0000000ea877e3bc\nRDX: ffff88007a729da8 RSI: 0000000000000000 RDI: ffff88007a72b958\nRBP: ffff88007b0c1ca8 R08: 0000000000000002 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000000 R12: ffff88007a72b958\nR13: ffff88007a729da8 R14: 0000000000000000 R15: ffffffffa011077e\nFS:  0000000000000000(0000) GS:ffff88007f600000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nCR2: 0000000000000080 CR3: 00000000735f8000 CR4: 00000000001407f0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess kworker/0:1 (pid: 27, threadinfo ffff88007b0c0000, task ffff88007c2fa0c0)\nStack:\n ffff88006fc05388 ffff88007a72b908 ffff88007b240900 ffff88006fc05388\n ffff88007b0c1cd8 ffffffffa01a2170 ffff88007b240900 ffff88007b240900\n ffff88007b240970 ffffffffa011077e ffff88007b0c1ce8 ffffffffa0110791\nCall Trace:\n [<ffffffffa01a2170>] nfs4_layoutget_prepare+0x7b/0x92 [nfsv4]\n [<ffffffffa011077e>] ? __rpc_atrun+0x15/0x15 [sunrpc]\n [<ffffffffa0110791>] rpc_prepare_task+0x13/0x15 [sunrpc]\n\nReported-by: Tigran Mkrtchyan <tigran.mkrtchyan@desy.de>\nSigned-off-by: Weston Andros Adamson <dros@netapp.com>\nCc: stable@kernel.org\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4proc.c||fs/nfs/nfs4proc.c": [
          "File: fs/nfs/nfs4proc.c -> fs/nfs/nfs4proc.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6129: static void nfs4_layoutget_release(void *calldata)",
          "6130: {",
          "6131:  struct nfs4_layoutget *lgp = calldata;",
          "6133:  size_t max_pages = max_response_pages(server);",
          "6135:  dprintk(\"--> %s\\n\", __func__);",
          "6136:  nfs4_free_pages(lgp->args.layout.pages, max_pages);",
          "6137:  put_nfs_open_context(lgp->args.ctx);",
          "6138:  kfree(calldata);",
          "6139:  dprintk(\"<-- %s\\n\", __func__);",
          "",
          "[Removed Lines]",
          "6132:  struct nfs_server *server = NFS_SERVER(lgp->args.inode);",
          "",
          "[Added Lines]",
          "6132:  struct inode *inode = lgp->args.inode;",
          "6133:  struct nfs_server *server = NFS_SERVER(inode);",
          "6138:  pnfs_put_layout_hdr(NFS_I(inode)->layout);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6148: struct pnfs_layout_segment *",
          "6149: nfs4_proc_layoutget(struct nfs4_layoutget *lgp, gfp_t gfp_flags)",
          "6150: {",
          "6152:  size_t max_pages = max_response_pages(server);",
          "6153:  struct rpc_task *task;",
          "6154:  struct rpc_message msg = {",
          "",
          "[Removed Lines]",
          "6151:  struct nfs_server *server = NFS_SERVER(lgp->args.inode);",
          "",
          "[Added Lines]",
          "6153:  struct inode *inode = lgp->args.inode;",
          "6154:  struct nfs_server *server = NFS_SERVER(inode);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "6178:  lgp->res.layoutp = &lgp->args.layout;",
          "6179:  lgp->res.seq_res.sr_slot = NULL;",
          "6180:  nfs41_init_sequence(&lgp->args.seq_args, &lgp->res.seq_res, 0);",
          "6181:  task = rpc_run_task(&task_setup_data);",
          "6182:  if (IS_ERR(task))",
          "6183:   return ERR_CAST(task);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "6186:  pnfs_get_layout_hdr(NFS_I(inode)->layout);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "78f33277f96430ea001c39e952f6b8200b2ab850",
      "candidate_info": {
        "commit_hash": "78f33277f96430ea001c39e952f6b8200b2ab850",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/78f33277f96430ea001c39e952f6b8200b2ab850",
        "files": [
          "fs/nfs/nfs4filelayout.c",
          "fs/nfs/pnfs.c",
          "fs/nfs/pnfs.h"
        ],
        "message": "pnfs: fix resend_to_mds for directio\n\nPass the directio request on pageio_init to clean up the API.\n\nPercolate pg_dreq from original nfs_pageio_descriptor to the\npnfs_{read,write}_done_resend_to_mds and use it on respective\ncall to nfs_pageio_init_{read,write} on the newly created\nnfs_pageio_descriptor.\n\nReproduced by command:\n mount -o vers=4.1 server:/ /mnt\n dd bs=128k count=8 if=/dev/zero of=/mnt/dd.out oflag=direct\n\nBUG: unable to handle kernel NULL pointer dereference at 0000000000000028\nIP: [<ffffffffa021a3a8>] atomic_inc+0x4/0x9 [nfs]\nPGD 34786067 PUD 34794067 PMD 0\nOops: 0002 [#1] SMP\nModules linked in: nfs_layout_nfsv41_files nfsv4 nfs nfsd lockd nfs_acl auth_rpcgss exportfs sunrpc btrfs zlib_deflate libcrc32c ipv6 autofs4\nCPU 1\nPid: 259, comm: kworker/1:2 Not tainted 3.8.0-rc6 #2 Bochs Bochs\nRIP: 0010:[<ffffffffa021a3a8>]  [<ffffffffa021a3a8>] atomic_inc+0x4/0x9 [nfs]\nRSP: 0018:ffff880038f8fa68  EFLAGS: 00010206\nRAX: ffffffffa021a6a9 RBX: ffff880038f8fb48 RCX: 00000000000a0000\nRDX: ffffffffa021e616 RSI: ffff8800385e9a40 RDI: 0000000000000028\nRBP: ffff880038f8fa68 R08: ffffffff81ad6720 R09: ffff8800385e9510\nR10: ffffffffa0228450 R11: ffff880038e87418 R12: ffff8800385e9a40\nR13: ffff8800385e9a70 R14: ffff880038f8fb38 R15: ffffffffa0148878\nFS:  0000000000000000(0000) GS:ffff88003e400000(0000) knlGS:0000000000000000\nCS:  0010 DS: 0000 ES: 0000 CR0: 000000008005003b\nCR2: 0000000000000028 CR3: 0000000034789000 CR4: 00000000000006e0\nDR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\nDR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\nProcess kworker/1:2 (pid: 259, threadinfo ffff880038f8e000, task ffff880038302480)\nStack:\n ffff880038f8fa78 ffffffffa021a6bf ffff880038f8fa88 ffffffffa021bb82\n ffff880038f8fae8 ffffffffa021f454 ffff880038f8fae8 ffffffff8109689d\n ffff880038f8fab8 ffffffff00000006 0000000000000000 ffff880038f8fb48\nCall Trace:\n [<ffffffffa021a6bf>] nfs_direct_pgio_init+0x16/0x18 [nfs]\n [<ffffffffa021bb82>] nfs_pgheader_init+0x6a/0x6c [nfs]\n [<ffffffffa021f454>] nfs_generic_pg_writepages+0x51/0xf8 [nfs]\n [<ffffffff8109689d>] ? mark_held_locks+0x71/0x99\n [<ffffffffa0148878>] ? rpc_release_resources_task+0x37/0x37 [sunrpc]\n [<ffffffffa021bc25>] nfs_pageio_doio+0x1a/0x43 [nfs]\n [<ffffffffa021be7c>] nfs_pageio_complete+0x16/0x2c [nfs]\n [<ffffffffa02608be>] pnfs_write_done_resend_to_mds+0x95/0xc5 [nfsv4]\n [<ffffffffa0148878>] ? rpc_release_resources_task+0x37/0x37 [sunrpc]\n [<ffffffffa028e27f>] filelayout_reset_write+0x8c/0x99 [nfs_layout_nfsv41_files]\n [<ffffffffa028e5f9>] filelayout_write_done_cb+0x4d/0xc1 [nfs_layout_nfsv41_files]\n [<ffffffffa024587a>] nfs4_write_done+0x36/0x49 [nfsv4]\n [<ffffffffa021f996>] nfs_writeback_done+0x53/0x1cc [nfs]\n [<ffffffffa021fb1d>] nfs_writeback_done_common+0xe/0x10 [nfs]\n [<ffffffffa028e03d>] filelayout_write_call_done+0x28/0x2a [nfs_layout_nfsv41_files]\n [<ffffffffa01488a1>] rpc_exit_task+0x29/0x87 [sunrpc]\n [<ffffffffa014a0c9>] __rpc_execute+0x11d/0x3cc [sunrpc]\n [<ffffffff810969dc>] ? trace_hardirqs_on_caller+0x117/0x173\n [<ffffffffa014a39f>] rpc_async_schedule+0x27/0x32 [sunrpc]\n [<ffffffffa014a378>] ? __rpc_execute+0x3cc/0x3cc [sunrpc]\n [<ffffffff8105f8c1>] process_one_work+0x226/0x422\n [<ffffffff8105f7f4>] ? process_one_work+0x159/0x422\n [<ffffffff81094757>] ? lock_acquired+0x210/0x249\n [<ffffffffa014a378>] ? __rpc_execute+0x3cc/0x3cc [sunrpc]\n [<ffffffff810600d8>] worker_thread+0x126/0x1c4\n [<ffffffff8105ffb2>] ? manage_workers+0x240/0x240\n [<ffffffff81064ef8>] kthread+0xb1/0xb9\n [<ffffffff81064e47>] ? __kthread_parkme+0x65/0x65\n [<ffffffff815206ec>] ret_from_fork+0x7c/0xb0\n [<ffffffff81064e47>] ? __kthread_parkme+0x65/0x65\nCode: 00 83 38 02 74 12 48 81 4b 50 00 00 01 00 c7 83 60 07 00 00 01 00 00 00 48 89 df e8 55 fe ff ff 5b 41 5c 5d c3 66 90 55 48 89 e5 <f0> ff 07 5d c3 55 48 89 e5 f0 ff 0f 0f 94 c0 84 c0 0f 95 c0 0f\nRIP  [<ffffffffa021a3a8>] atomic_inc+0x4/0x9 [nfs]\n RSP <ffff880038f8fa68>\nCR2: 0000000000000028\n\nSigned-off-by: Benny Halevy <bhalevy@tonian.com>\nCc: stable@kernel.org [>= 3.6]\nSigned-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",
        "before_after_code_files": [
          "fs/nfs/nfs4filelayout.c||fs/nfs/nfs4filelayout.c",
          "fs/nfs/pnfs.c||fs/nfs/pnfs.c",
          "fs/nfs/pnfs.h||fs/nfs/pnfs.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "fs/nfs/nfs4filelayout.c||fs/nfs/nfs4filelayout.c": [
          "File: fs/nfs/nfs4filelayout.c -> fs/nfs/nfs4filelayout.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "100:   task->tk_status = pnfs_write_done_resend_to_mds(hdr->inode,",
          "101:        &hdr->pages,",
          "103:  }",
          "104: }",
          "",
          "[Removed Lines]",
          "102:        hdr->completion_ops);",
          "",
          "[Added Lines]",
          "102:        hdr->completion_ops,",
          "103:        hdr->dreq);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "120:   task->tk_status = pnfs_read_done_resend_to_mds(hdr->inode,",
          "121:        &hdr->pages,",
          "123:  }",
          "124: }",
          "",
          "[Removed Lines]",
          "122:        hdr->completion_ops);",
          "",
          "[Added Lines]",
          "123:        hdr->completion_ops,",
          "124:        hdr->dreq);",
          "",
          "---------------"
        ],
        "fs/nfs/pnfs.c||fs/nfs/pnfs.c": [
          "File: fs/nfs/pnfs.c -> fs/nfs/pnfs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1423: int pnfs_write_done_resend_to_mds(struct inode *inode,",
          "1424:     struct list_head *head,",
          "1426: {",
          "1427:  struct nfs_pageio_descriptor pgio;",
          "1428:  LIST_HEAD(failed);",
          "1431:  nfs_pageio_init_write(&pgio, inode, FLUSH_STABLE, compl_ops);",
          "1432:  while (!list_empty(head)) {",
          "1433:   struct nfs_page *req = nfs_list_entry(head->next);",
          "",
          "[Removed Lines]",
          "1425:     const struct nfs_pgio_completion_ops *compl_ops)",
          "",
          "[Added Lines]",
          "1425:     const struct nfs_pgio_completion_ops *compl_ops,",
          "1426:     struct nfs_direct_req *dreq)",
          "1433:  pgio.pg_dreq = dreq;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1463:  if (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))",
          "1464:   data->task.tk_status = pnfs_write_done_resend_to_mds(hdr->inode,",
          "1465:        &hdr->pages,",
          "1467: }",
          "",
          "[Removed Lines]",
          "1466:        hdr->completion_ops);",
          "",
          "[Added Lines]",
          "1468:        hdr->completion_ops,",
          "1469:        hdr->dreq);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1579: int pnfs_read_done_resend_to_mds(struct inode *inode,",
          "1580:     struct list_head *head,",
          "1582: {",
          "1583:  struct nfs_pageio_descriptor pgio;",
          "1584:  LIST_HEAD(failed);",
          "1587:  nfs_pageio_init_read(&pgio, inode, compl_ops);",
          "1588:  while (!list_empty(head)) {",
          "1589:   struct nfs_page *req = nfs_list_entry(head->next);",
          "",
          "[Removed Lines]",
          "1581:     const struct nfs_pgio_completion_ops *compl_ops)",
          "",
          "[Added Lines]",
          "1584:     const struct nfs_pgio_completion_ops *compl_ops,",
          "1585:     struct nfs_direct_req *dreq)",
          "1592:  pgio.pg_dreq = dreq;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1615:  if (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))",
          "1616:   data->task.tk_status = pnfs_read_done_resend_to_mds(hdr->inode,",
          "1617:        &hdr->pages,",
          "1619: }",
          "",
          "[Removed Lines]",
          "1618:        hdr->completion_ops);",
          "",
          "[Added Lines]",
          "1623:        hdr->completion_ops,",
          "1624:        hdr->dreq);",
          "",
          "---------------"
        ],
        "fs/nfs/pnfs.h||fs/nfs/pnfs.h": [
          "File: fs/nfs/pnfs.h -> fs/nfs/pnfs.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "231: void nfs4_deviceid_mark_client_invalid(struct nfs_client *clp);",
          "232: int pnfs_read_done_resend_to_mds(struct inode *inode, struct list_head *head,",
          "234: int pnfs_write_done_resend_to_mds(struct inode *inode, struct list_head *head,",
          "236: struct nfs4_threshold *pnfs_mdsthreshold_alloc(void);",
          "",
          "[Removed Lines]",
          "233:    const struct nfs_pgio_completion_ops *compl_ops);",
          "235:    const struct nfs_pgio_completion_ops *compl_ops);",
          "",
          "[Added Lines]",
          "233:    const struct nfs_pgio_completion_ops *compl_ops,",
          "234:    struct nfs_direct_req *dreq);",
          "236:    const struct nfs_pgio_completion_ops *compl_ops,",
          "237:    struct nfs_direct_req *dreq);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
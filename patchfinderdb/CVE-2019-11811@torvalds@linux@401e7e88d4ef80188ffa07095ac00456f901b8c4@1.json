{
  "cve_id": "CVE-2019-11811",
  "cve_desc": "An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",
  "repo": "torvalds/linux",
  "patch_hash": "401e7e88d4ef80188ffa07095ac00456f901b8c4",
  "patch_info": {
    "commit_hash": "401e7e88d4ef80188ffa07095ac00456f901b8c4",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4",
    "files": [
      "drivers/char/ipmi/ipmi_si_intf.c",
      "drivers/char/ipmi/ipmi_si_mem_io.c",
      "drivers/char/ipmi/ipmi_si_port_io.c"
    ],
    "message": "ipmi_si: fix use-after-free of resource->name\n\nWhen we excute the following commands, we got oops\nrmmod ipmi_si\ncat /proc/ioports\n\n[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478\n[ 1623.482382] Mem abort info:\n[ 1623.482383]   ESR = 0x96000007\n[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits\n[ 1623.482386]   SET = 0, FnV = 0\n[ 1623.482387]   EA = 0, S1PTW = 0\n[ 1623.482388] Data abort info:\n[ 1623.482389]   ISV = 0, ISS = 0x00000007\n[ 1623.482390]   CM = 0, WnR = 0\n[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66\n[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000\n[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP\n[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]\n[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168\n[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017\n[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)\n[ 1623.553684] pc : string+0x28/0x98\n[ 1623.557040] lr : vsnprintf+0x368/0x5e8\n[ 1623.560837] sp : ffff000013213a80\n[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5\n[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049\n[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5\n[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000\n[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000\n[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff\n[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000\n[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000\n[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000\n[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000\n[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f\n[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe\n[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478\n[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000\n[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff\n[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)\n[ 1623.651592] Call trace:\n[ 1623.654068]  string+0x28/0x98\n[ 1623.657071]  vsnprintf+0x368/0x5e8\n[ 1623.660517]  seq_vprintf+0x70/0x98\n[ 1623.668009]  seq_printf+0x7c/0xa0\n[ 1623.675530]  r_show+0xc8/0xf8\n[ 1623.682558]  seq_read+0x330/0x440\n[ 1623.689877]  proc_reg_read+0x78/0xd0\n[ 1623.697346]  __vfs_read+0x60/0x1a0\n[ 1623.704564]  vfs_read+0x94/0x150\n[ 1623.711339]  ksys_read+0x6c/0xd8\n[ 1623.717939]  __arm64_sys_read+0x24/0x30\n[ 1623.725077]  el0_svc_common+0x120/0x148\n[ 1623.732035]  el0_svc_handler+0x30/0x40\n[ 1623.738757]  el0_svc+0x8/0xc\n[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)\n[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---\n[ 1623.760871] Kernel panic - not syncing: Fatal exception\n[ 1623.768935] SMP: stopping secondary CPUs\n[ 1623.775718] Kernel Offset: disabled\n[ 1623.781998] CPU features: 0x002,21006008\n[ 1623.788777] Memory Limit: none\n[ 1623.798329] Starting crashdump kernel...\n[ 1623.805202] Bye!\n\nIf io_setup is called successful in try_smi_init() but try_smi_init()\ngoes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()\nwill not be called while removing module. It leads to the resource that\nallocated in io_setup() can not be freed, but the name(DEVICE_NAME) of\nresource is freed while removing the module. It causes use-after-free\nwhen cat /proc/ioports.\n\nFix this by calling io_cleanup() while try_smi_init() goes to out_err.\nand don't call io_cleanup() until io_setup() returns successful to avoid\nwarning prints.\n\nFixes: 93c303d2045b (\"ipmi_si: Clean up shutdown a bit\")\nCc: stable@vger.kernel.org\nReported-by: NuoHan Qiao <qiaonuohan@huawei.com>\nSuggested-by: Corey Minyard <cminyard@mvista.com>\nSigned-off-by: Yang Yingliang <yangyingliang@huawei.com>\nSigned-off-by: Corey Minyard <cminyard@mvista.com>",
    "before_after_code_files": [
      "drivers/char/ipmi/ipmi_si_intf.c||drivers/char/ipmi/ipmi_si_intf.c",
      "drivers/char/ipmi/ipmi_si_mem_io.c||drivers/char/ipmi/ipmi_si_mem_io.c",
      "drivers/char/ipmi/ipmi_si_port_io.c||drivers/char/ipmi/ipmi_si_port_io.c"
    ]
  },
  "patch_diff": {
    "drivers/char/ipmi/ipmi_si_intf.c||drivers/char/ipmi/ipmi_si_intf.c": [
      "File: drivers/char/ipmi/ipmi_si_intf.c -> drivers/char/ipmi/ipmi_si_intf.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2085:  WARN_ON(new_smi->io.dev->init_name != NULL);",
      "2087:  out_err:",
      "2088:  kfree(init_name);",
      "2089:  return rv;",
      "2090: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "2088:  if (rv && new_smi->io.io_cleanup) {",
      "2089:   new_smi->io.io_cleanup(&new_smi->io);",
      "2090:   new_smi->io.io_cleanup = NULL;",
      "2091:  }",
      "",
      "---------------"
    ],
    "drivers/char/ipmi/ipmi_si_mem_io.c||drivers/char/ipmi/ipmi_si_mem_io.c": [
      "File: drivers/char/ipmi/ipmi_si_mem_io.c -> drivers/char/ipmi/ipmi_si_mem_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "81:  if (!addr)",
      "82:   return -ENODEV;",
      "",
      "[Removed Lines]",
      "84:  io->io_cleanup = mem_cleanup;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "141:   mem_region_cleanup(io, io->io_size);",
      "142:   return -EIO;",
      "143:  }",
      "144:  return 0;",
      "145: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "143:  io->io_cleanup = mem_cleanup;",
      "",
      "---------------"
    ],
    "drivers/char/ipmi/ipmi_si_port_io.c||drivers/char/ipmi/ipmi_si_port_io.c": [
      "File: drivers/char/ipmi/ipmi_si_port_io.c -> drivers/char/ipmi/ipmi_si_port_io.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "68:  if (!addr)",
      "69:   return -ENODEV;",
      "",
      "[Removed Lines]",
      "71:  io->io_cleanup = port_cleanup;",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "109:    return -EIO;",
      "110:   }",
      "111:  }",
      "112:  return 0;",
      "113: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "111:  io->io_cleanup = port_cleanup;",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "ed7dc6777400937b4686e9ec1db1533ea4546864",
      "candidate_info": {
        "commit_hash": "ed7dc6777400937b4686e9ec1db1533ea4546864",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/ed7dc6777400937b4686e9ec1db1533ea4546864",
        "files": [
          "drivers/gpu/drm/i915/i915_scheduler.c"
        ],
        "message": "drm/i915: Reacquire priolist cache after dropping the engine lock\n\nIf we drop the engine lock, we may run execlists_dequeue which may free\nthe priolist. Therefore if we ever drop the execution lock on the\nengine, we have to discard our cache and refetch the priolist to ensure\nwe do not use a stale pointer.\n\n[  506.418935] [IGT] gem_exec_whisper: starting subtest contexts-priority\n[  593.240825] general protection fault: 0000 [#1] SMP\n[  593.240863] CPU: 1 PID: 494 Comm: gem_exec_whispe Tainted: G     U            5.0.0-rc6+ #100\n[  593.240879] Hardware name:  /NUC6CAYB, BIOS AYAPLCEL.86A.0029.2016.1124.1625 11/24/2016\n[  593.240965] RIP: 0010:__i915_schedule+0x1fe/0x320 [i915]\n[  593.240981] Code: 48 8b 0c 24 48 89 c3 49 8b 45 28 49 8b 75 20 4c 89 3c 24 48 89 46 08 48 89 30 48 8b 43 08 48 89 4b 08 49 89 5d 20 49 89 45 28 <48> 89 08 45 39 a7 b8 03 00 00 7d 44 45 89 a7 b8 03 00 00 49 8b 85\n[  593.240999] RSP: 0018:ffffc90000057a60 EFLAGS: 00010046\n[  593.241013] RAX: 6b6b6b6b6b6b6b6b RBX: ffff8882582d7870 RCX: ffff88826baba6f0\n[  593.241026] RDX: 0000000000000000 RSI: ffff8882582d6e70 RDI: ffff888273482194\n[  593.241049] RBP: ffffc90000057a68 R08: ffff8882582d7680 R09: ffff8882582d7840\n[  593.241068] R10: 0000000000000000 R11: ffffea00095ebe08 R12: 0000000000000728\n[  593.241105] R13: ffff88826baba6d0 R14: ffffc90000057a40 R15: ffff888273482158\n[  593.241120] FS:  00007f4613fb3900(0000) GS:ffff888277a80000(0000) knlGS:0000000000000000\n[  593.241133] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n[  593.241146] CR2: 00007f57d3c66a84 CR3: 000000026e2b6000 CR4: 00000000001406e0\n[  593.241158] Call Trace:\n[  593.241233]  i915_schedule+0x1f/0x30 [i915]\n[  593.241326]  i915_request_add+0x1a9/0x290 [i915]\n[  593.241393]  i915_gem_do_execbuffer+0x45f/0x1150 [i915]\n[  593.241411]  ? init_object+0x49/0x80\n[  593.241425]  ? ___slab_alloc.constprop.91+0x4b8/0x4e0\n[  593.241491]  ? i915_gem_execbuffer2_ioctl+0x99/0x380 [i915]\n[  593.241563]  ? i915_gem_execbuffer_ioctl+0x270/0x270 [i915]\n[  593.241629]  i915_gem_execbuffer2_ioctl+0x1bb/0x380 [i915]\n[  593.241705]  ? i915_gem_execbuffer_ioctl+0x270/0x270 [i915]\n[  593.241724]  drm_ioctl_kernel+0x81/0xd0\n[  593.241738]  drm_ioctl+0x1a7/0x310\n[  593.241803]  ? i915_gem_execbuffer_ioctl+0x270/0x270 [i915]\n[  593.241819]  ? __update_load_avg_se+0x1c9/0x240\n[  593.241834]  ? pick_next_entity+0x7e/0x120\n[  593.241851]  do_vfs_ioctl+0x88/0x5d0\n[  593.241880]  ksys_ioctl+0x35/0x70\n[  593.241894]  __x64_sys_ioctl+0x11/0x20\n[  593.241907]  do_syscall_64+0x44/0xf0\n[  593.241924]  entry_SYSCALL_64_after_hwframe+0x44/0xa9\n[  593.241940] RIP: 0033:0x7f4615ffe757\n[  593.241952] Code: 00 00 90 48 8b 05 39 a7 0c 00 64 c7 00 26 00 00 00 48 c7 c0 ff ff ff ff c3 66 2e 0f 1f 84 00 00 00 00 00 b8 10 00 00 00 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 8b 0d 09 a7 0c 00 f7 d8 64 89 01 48\n[  593.241970] RSP: 002b:00007ffc1030ddf8 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n[  593.241984] RAX: ffffffffffffffda RBX: 00007ffc10324420 RCX: 00007f4615ffe757\n[  593.241997] RDX: 00007ffc1030e220 RSI: 0000000040406469 RDI: 0000000000000003\n[  593.242010] RBP: 00007ffc1030e220 R08: 00007f46160c9208 R09: 00007f46160c9240\n[  593.242022] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000040406469\n[  593.242038] R13: 0000000000000003 R14: 0000000000000000 R15: 0000000000000000\n[  593.242058] Modules linked in: i915 intel_gtt drm_kms_helper prime_numbers\n\nv2: Track the local engine cache and explicitly clear it when switching\nengine locks.\n\nFixes: a02eb975be78 (\"drm/i915/execlists: Cache the priolist when rescheduling\")\nTestcase: igt/gem_exec_whisper/contexts-priority # rare!\nSigned-off-by: Chris Wilson <chris@chris-wilson.co.uk>\nCc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>\nCc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nCc: Micha\u0142 Winiarski <michal.winiarski@intel.com>\nReviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>\nLink: https://patchwork.freedesktop.org/patch/msgid/20190211204647.26723-1-chris@chris-wilson.co.uk",
        "before_after_code_files": [
          "drivers/gpu/drm/i915/i915_scheduler.c||drivers/gpu/drm/i915/i915_scheduler.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/gpu/drm/i915/i915_scheduler.c||drivers/gpu/drm/i915/i915_scheduler.c": [
          "File: drivers/gpu/drm/i915/i915_scheduler.c -> drivers/gpu/drm/i915/i915_scheduler.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "223:  return &p->requests[idx];",
          "224: }",
          "226: static struct intel_engine_cs *",
          "228: {",
          "229:  struct intel_engine_cs *engine = node_to_request(node)->engine;",
          "",
          "[Removed Lines]",
          "227: sched_lock_engine(struct i915_sched_node *node, struct intel_engine_cs *locked)",
          "",
          "[Added Lines]",
          "226: struct sched_cache {",
          "227:  struct list_head *priolist;",
          "228: };",
          "231: sched_lock_engine(const struct i915_sched_node *node,",
          "232:     struct intel_engine_cs *locked,",
          "233:     struct sched_cache *cache)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "233:  if (engine != locked) {",
          "234:   spin_unlock(&locked->timeline.lock);",
          "235:   spin_lock(&engine->timeline.lock);",
          "236:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "241:   memset(cache, 0, sizeof(*cache));",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "253: static void __i915_schedule(struct i915_request *rq,",
          "254:        const struct i915_sched_attr *attr)",
          "255: {",
          "258:  struct i915_dependency *dep, *p;",
          "259:  struct i915_dependency stack;",
          "260:  const int prio = attr->priority;",
          "261:  LIST_HEAD(dfs);",
          "",
          "[Removed Lines]",
          "256:  struct list_head *uninitialized_var(pl);",
          "257:  struct intel_engine_cs *engine, *last;",
          "",
          "[Added Lines]",
          "263:  struct intel_engine_cs *engine;",
          "267:  struct sched_cache cache;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "328:   __list_del_entry(&stack.dfs_link);",
          "329:  }",
          "332:  engine = rq->engine;",
          "333:  spin_lock_irq(&engine->timeline.lock);",
          "",
          "[Removed Lines]",
          "331:  last = NULL;",
          "",
          "[Added Lines]",
          "338:  memset(&cache, 0, sizeof(cache));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "339:   INIT_LIST_HEAD(&dep->dfs_link);",
          "342:   lockdep_assert_held(&engine->timeline.lock);",
          "",
          "[Removed Lines]",
          "341:   engine = sched_lock_engine(node, engine);",
          "",
          "[Added Lines]",
          "348:   engine = sched_lock_engine(node, engine, &cache);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "348:   node->attr.priority = prio;",
          "349:   if (!list_empty(&node->link)) {",
          "355:   } else {",
          "",
          "[Removed Lines]",
          "350:    if (last != engine) {",
          "351:     pl = i915_sched_lookup_priolist(engine, prio);",
          "352:     last = engine;",
          "353:    }",
          "354:    list_move_tail(&node->link, pl);",
          "",
          "[Added Lines]",
          "357:    if (!cache.priolist)",
          "358:     cache.priolist =",
          "359:      i915_sched_lookup_priolist(engine,",
          "360:            prio);",
          "361:    list_move_tail(&node->link, cache.priolist);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c208556ab3627b5f53144e9cbf739d6371d80543",
      "candidate_info": {
        "commit_hash": "c208556ab3627b5f53144e9cbf739d6371d80543",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/c208556ab3627b5f53144e9cbf739d6371d80543",
        "files": [
          "drivers/scsi/scsi_debug.c"
        ],
        "message": "scsi: scsi_debug: Fix a recently introduced regression\n\nA recent commit removed an element from opcode_info_arr[] but did not\nmodify opcode_ind_arr[] nor was SDEB_I_XDWRITEREAD removed. Remove\nSDEB_I_XDWRITEREAD and bring the two arrays again in sync. This patch\navoids that the following is reported:\n\nBUG: KASAN: null-ptr-deref in scsi_debug_queuecommand+0x60f/0xc90 [scsi_debug]\nRead of size 1 at addr 0000000000000001 by task iscsi-test-cu/683\nCPU: 3 PID: 683 Comm: iscsi-test-cu Not tainted 5.0.0-rc5-dbg+ #1\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1 04/01/2014\nCall Trace:\n dump_stack+0x86/0xca\n kasan_report.cold.3+0x5/0x3e\n __asan_load1+0x47/0x50\n scsi_debug_queuecommand+0x60f/0xc90 [scsi_debug]\n scsi_queue_rq+0xc17/0x12e0\n blk_mq_dispatch_rq_list+0x5fc/0xb10\n blk_mq_sched_dispatch_requests+0x2f7/0x300\n __blk_mq_run_hw_queue+0xd6/0x180\n __blk_mq_delay_run_hw_queue+0x25c/0x290\n blk_mq_run_hw_queue+0x119/0x1b0\n blk_mq_sched_insert_request+0x274/0x350\n blk_execute_rq_nowait+0x78/0x90\n blk_execute_rq+0xcc/0x140\n sg_io+0x30f/0x700\n scsi_cmd_ioctl+0x4d4/0x540\n scsi_cmd_blk_ioctl+0x7b/0x8b\n sd_ioctl+0xba/0x150\n blkdev_ioctl+0x6e1/0xea0\n block_ioctl+0x79/0x90\n do_vfs_ioctl+0x12b/0x9b0\n ksys_ioctl+0x41/0x80\n __x64_sys_ioctl+0x43/0x50\n do_syscall_64+0x71/0x210\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nCc: Christoph Hellwig <hch@lst.de>\nCc: Douglas Gilbert <dgilbert@interlog.com>\nFixes: ae3d56d81507 (\"scsi: remove bidirectional command support\")\nSigned-off-by: Bart Van Assche <bvanassche@acm.org>\nReviewed-by: Christoph Hellwig <hch@lst.de>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "before_after_code_files": [
          "drivers/scsi/scsi_debug.c||drivers/scsi/scsi_debug.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/scsi/scsi_debug.c||drivers/scsi/scsi_debug.c": [
          "File: drivers/scsi/scsi_debug.c -> drivers/scsi/scsi_debug.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "352:  SDEB_I_SEND_DIAG = 23,",
          "353:  SDEB_I_UNMAP = 24,",
          "360: };",
          "",
          "[Removed Lines]",
          "355:  SDEB_I_WRITE_BUFFER = 26,",
          "358:  SDEB_I_COMP_WRITE = 29,",
          "",
          "[Added Lines]",
          "354:  SDEB_I_WRITE_BUFFER = 25,",
          "357:  SDEB_I_COMP_WRITE = 28,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "378:  0, SDEB_I_WRITE_SAME, SDEB_I_UNMAP, 0, 0, 0, 0, 0,",
          "379:  0, 0, 0, 0, 0, SDEB_I_LOG_SENSE, 0, 0,",
          "381:      SDEB_I_RELEASE,",
          "382:  0, 0, SDEB_I_MODE_SENSE, 0, 0, 0, 0, 0,",
          "",
          "[Removed Lines]",
          "380:  0, 0, 0, SDEB_I_XDWRITEREAD, 0, SDEB_I_MODE_SELECT, SDEB_I_RESERVE,",
          "",
          "[Added Lines]",
          "379:  0, 0, 0, 0, 0, SDEB_I_MODE_SELECT, SDEB_I_RESERVE,",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "81ec3f3c4c4d78f2d3b6689c9816bfbdf7417dbb",
      "candidate_info": {
        "commit_hash": "81ec3f3c4c4d78f2d3b6689c9816bfbdf7417dbb",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/81ec3f3c4c4d78f2d3b6689c9816bfbdf7417dbb",
        "files": [
          "arch/x86/events/core.c",
          "arch/x86/events/intel/core.c",
          "arch/x86/events/perf_event.h",
          "include/linux/perf_event.h",
          "kernel/events/core.c"
        ],
        "message": "perf/x86: Add check_period PMU callback\n\nVince (and later on Ravi) reported crashes in the BTS code during\nfuzzing with the following backtrace:\n\n  general protection fault: 0000 [#1] SMP PTI\n  ...\n  RIP: 0010:perf_prepare_sample+0x8f/0x510\n  ...\n  Call Trace:\n   <IRQ>\n   ? intel_pmu_drain_bts_buffer+0x194/0x230\n   intel_pmu_drain_bts_buffer+0x160/0x230\n   ? tick_nohz_irq_exit+0x31/0x40\n   ? smp_call_function_single_interrupt+0x48/0xe0\n   ? call_function_single_interrupt+0xf/0x20\n   ? call_function_single_interrupt+0xa/0x20\n   ? x86_schedule_events+0x1a0/0x2f0\n   ? x86_pmu_commit_txn+0xb4/0x100\n   ? find_busiest_group+0x47/0x5d0\n   ? perf_event_set_state.part.42+0x12/0x50\n   ? perf_mux_hrtimer_restart+0x40/0xb0\n   intel_pmu_disable_event+0xae/0x100\n   ? intel_pmu_disable_event+0xae/0x100\n   x86_pmu_stop+0x7a/0xb0\n   x86_pmu_del+0x57/0x120\n   event_sched_out.isra.101+0x83/0x180\n   group_sched_out.part.103+0x57/0xe0\n   ctx_sched_out+0x188/0x240\n   ctx_resched+0xa8/0xd0\n   __perf_event_enable+0x193/0x1e0\n   event_function+0x8e/0xc0\n   remote_function+0x41/0x50\n   flush_smp_call_function_queue+0x68/0x100\n   generic_smp_call_function_single_interrupt+0x13/0x30\n   smp_call_function_single_interrupt+0x3e/0xe0\n   call_function_single_interrupt+0xf/0x20\n   </IRQ>\n\nThe reason is that while event init code does several checks\nfor BTS events and prevents several unwanted config bits for\nBTS event (like precise_ip), the PERF_EVENT_IOC_PERIOD allows\nto create BTS event without those checks being done.\n\nFollowing sequence will cause the crash:\n\nIf we create an 'almost' BTS event with precise_ip and callchains,\nand it into a BTS event it will crash the perf_prepare_sample()\nfunction because precise_ip events are expected to come\nin with callchain data initialized, but that's not the\ncase for intel_pmu_drain_bts_buffer() caller.\n\nAdding a check_period callback to be called before the period\nis changed via PERF_EVENT_IOC_PERIOD. It will deny the change\nif the event would become BTS. Plus adding also the limit_period\ncheck as well.\n\nReported-by: Vince Weaver <vincent.weaver@maine.edu>\nSigned-off-by: Jiri Olsa <jolsa@kernel.org>\nAcked-by: Peter Zijlstra <peterz@infradead.org>\nCc: <stable@vger.kernel.org>\nCc: Alexander Shishkin <alexander.shishkin@linux.intel.com>\nCc: Arnaldo Carvalho de Melo <acme@kernel.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>\nCc: Ravi Bangoria <ravi.bangoria@linux.ibm.com>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nLink: http://lkml.kernel.org/r/20190204123532.GA4794@krava\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "before_after_code_files": [
          "arch/x86/events/core.c||arch/x86/events/core.c",
          "arch/x86/events/intel/core.c||arch/x86/events/intel/core.c",
          "arch/x86/events/perf_event.h||arch/x86/events/perf_event.h",
          "include/linux/perf_event.h||include/linux/perf_event.h",
          "kernel/events/core.c||kernel/events/core.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "arch/x86/events/core.c||arch/x86/events/core.c": [
          "File: arch/x86/events/core.c -> arch/x86/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "2278:   x86_pmu.check_microcode();",
          "2279: }",
          "2281: static struct pmu pmu = {",
          "2282:  .pmu_enable  = x86_pmu_enable,",
          "2283:  .pmu_disable  = x86_pmu_disable,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2281: static int x86_pmu_check_period(struct perf_event *event, u64 value)",
          "2282: {",
          "2283:  if (x86_pmu.check_period && x86_pmu.check_period(event, value))",
          "2284:   return -EINVAL;",
          "2286:  if (value && x86_pmu.limit_period) {",
          "2287:   if (x86_pmu.limit_period(event, value) > value)",
          "2288:    return -EINVAL;",
          "2289:  }",
          "2291:  return 0;",
          "2292: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2302:  .event_idx  = x86_pmu_event_idx,",
          "2303:  .sched_task  = x86_pmu_sched_task,",
          "2304:  .task_ctx_size          = sizeof(struct x86_perf_task_context),",
          "2305: };",
          "2307: void arch_perf_update_userpage(struct perf_event *event,",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2318:  .check_period  = x86_pmu_check_period,",
          "",
          "---------------"
        ],
        "arch/x86/events/intel/core.c||arch/x86/events/intel/core.c": [
          "File: arch/x86/events/intel/core.c -> arch/x86/events/intel/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "3587:  intel_pmu_lbr_sched_task(ctx, sched_in);",
          "3588: }",
          "3590: PMU_FORMAT_ATTR(offcore_rsp, \"config1:0-63\");",
          "3592: PMU_FORMAT_ATTR(ldlat, \"config1:0-15\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3590: static int intel_pmu_check_period(struct perf_event *event, u64 value)",
          "3591: {",
          "3592:  return intel_pmu_has_bts_period(event, value) ? -EINVAL : 0;",
          "3593: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "3667:  .cpu_starting  = intel_pmu_cpu_starting,",
          "3668:  .cpu_dying  = intel_pmu_cpu_dying,",
          "3669:  .cpu_dead  = intel_pmu_cpu_dead,",
          "3670: };",
          "3672: static struct attribute *intel_pmu_attrs[];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3676:  .check_period  = intel_pmu_check_period,",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "3712:  .guest_get_msrs  = intel_guest_get_msrs,",
          "3713:  .sched_task  = intel_pmu_sched_task,",
          "3714: };",
          "3716: static __init void intel_clovertown_quirk(void)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "3722:  .check_period  = intel_pmu_check_period,",
          "",
          "---------------"
        ],
        "arch/x86/events/perf_event.h||arch/x86/events/perf_event.h": [
          "File: arch/x86/events/perf_event.h -> arch/x86/events/perf_event.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "648:  struct perf_guest_switch_msr *(*guest_get_msrs)(int *nr);",
          "649: };",
          "651: struct x86_perf_task_context {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "653:  int (*check_period) (struct perf_event *event, u64 period);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "858: #ifdef CONFIG_CPU_SUP_INTEL",
          "861: {",
          "862:  struct hw_perf_event *hwc = &event->hw;",
          "863:  unsigned int hw_event, bts_event;",
          "",
          "[Removed Lines]",
          "860: static inline bool intel_pmu_has_bts(struct perf_event *event)",
          "",
          "[Added Lines]",
          "865: static inline bool intel_pmu_has_bts_period(struct perf_event *event, u64 period)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "868:  hw_event = hwc->config & INTEL_ARCH_EVENT_MASK;",
          "869:  bts_event = x86_pmu.event_map(PERF_COUNT_HW_BRANCH_INSTRUCTIONS);",
          "872: }",
          "874: int intel_pmu_save_and_restart(struct perf_event *event);",
          "",
          "[Removed Lines]",
          "871:  return hw_event == bts_event && hwc->sample_period == 1;",
          "",
          "[Added Lines]",
          "876:  return hw_event == bts_event && period == 1;",
          "877: }",
          "879: static inline bool intel_pmu_has_bts(struct perf_event *event)",
          "880: {",
          "881:  struct hw_perf_event *hwc = &event->hw;",
          "883:  return intel_pmu_has_bts_period(event, hwc->sample_period);",
          "",
          "---------------"
        ],
        "include/linux/perf_event.h||include/linux/perf_event.h": [
          "File: include/linux/perf_event.h -> include/linux/perf_event.h"
        ],
        "kernel/events/core.c||kernel/events/core.c": [
          "File: kernel/events/core.c -> kernel/events/core.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "4963:  }",
          "4964: }",
          "4966: static int perf_event_period(struct perf_event *event, u64 __user *arg)",
          "4967: {",
          "4968:  u64 value;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4966: static int perf_event_check_period(struct perf_event *event, u64 value)",
          "4967: {",
          "4968:  return event->pmu->check_period(event, value);",
          "4969: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "4979:  if (event->attr.freq && value > sysctl_perf_event_sample_rate)",
          "4980:   return -EINVAL;",
          "4982:  event_function_call(event, __perf_event_period, &value);",
          "4984:  return 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4987:  if (perf_event_check_period(event, value))",
          "4988:   return -EINVAL;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "9391:  return 0;",
          "9392: }",
          "9394: static DEFINE_PER_CPU(unsigned int, nop_txn_flags);",
          "9396: static void perf_pmu_start_txn(struct pmu *pmu, unsigned int flags)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9402: static int perf_event_nop_int(struct perf_event *event, u64 value)",
          "9403: {",
          "9404:  return 0;",
          "9405: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "9691:   pmu->pmu_disable = perf_pmu_nop_void;",
          "9692:  }",
          "9694:  if (!pmu->event_idx)",
          "9695:   pmu->event_idx = perf_event_idx_default;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9707:  if (!pmu->check_period)",
          "9708:   pmu->check_period = perf_event_nop_int;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a3906855890d94736d240f0f637585c1470d8d02",
      "candidate_info": {
        "commit_hash": "a3906855890d94736d240f0f637585c1470d8d02",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/a3906855890d94736d240f0f637585c1470d8d02",
        "files": [
          "drivers/vfio/vfio_iommu_spapr_tce.c"
        ],
        "message": "vfio/spapr_tce: Skip unsetting already unset table\n\nVFIO TCE IOMMU v2 owns IOMMU tables. When we detach an IOMMU group from\na container, we need to unset these tables from the group which we do by\ncalling unset_window(). We also unset tables when removing a DMA window\nvia the VFIO_IOMMU_SPAPR_TCE_REMOVE ioctl.\n\nThe window removal checks if the table actually exists (hidden inside\ntce_iommu_find_table()) but the group detaching does not so the user\nmay see duplicating messages:\npci 0009:03     : [PE# fd] Removing DMA window #0\npci 0009:03     : [PE# fd] Removing DMA window #1\npci 0009:03     : [PE# fd] Removing DMA window #0\npci 0009:03     : [PE# fd] Removing DMA window #1\n\nAt the moment this is not a problem as the second invocation\nof unset_window() writes zeroes to the HW registers again and exits early\nas there is no table.\n\nSigned-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>\nReviewed-by: David Gibson <david@gibson.dropbear.id.au>\nSigned-off-by: Alex Williamson <alex.williamson@redhat.com>",
        "before_after_code_files": [
          "drivers/vfio/vfio_iommu_spapr_tce.c||drivers/vfio/vfio_iommu_spapr_tce.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/vfio/vfio_iommu_spapr_tce.c||drivers/vfio/vfio_iommu_spapr_tce.c": [
          "File: drivers/vfio/vfio_iommu_spapr_tce.c -> drivers/vfio/vfio_iommu_spapr_tce.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1235:  }",
          "1237:  for (i = 0; i < IOMMU_TABLE_GROUP_MAX_TABLES; ++i)",
          "1240:  table_group->ops->release_ownership(table_group);",
          "1241: }",
          "",
          "[Removed Lines]",
          "1238:   table_group->ops->unset_window(table_group, i);",
          "",
          "[Added Lines]",
          "1238:   if (container->tables[i])",
          "1239:    table_group->ops->unset_window(table_group, i);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "376991db4b6464e906d699ef07681e2ffa8ab08c",
      "candidate_info": {
        "commit_hash": "376991db4b6464e906d699ef07681e2ffa8ab08c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/376991db4b6464e906d699ef07681e2ffa8ab08c",
        "files": [
          "drivers/base/dd.c"
        ],
        "message": "driver core: Postpone DMA tear-down until after devres release\n\nWhen unbinding the (IOMMU-enabled) R-Car SATA device on Salvator-XS\n(R-Car H3 ES2.0), in preparation of rebinding against vfio-platform for\ndevice pass-through for virtualization:\n\n\u00a0 \u00a0 echo ee300000.sata > /sys/bus/platform/drivers/sata_rcar/unbind\n\nthe kernel crashes with:\n\n\u00a0 \u00a0 Unable to handle kernel paging request at virtual address ffffffbf029ffffc\n\u00a0 \u00a0 Mem abort info:\n\u00a0 \u00a0 \u00a0 ESR = 0x96000006\n\u00a0 \u00a0 \u00a0 Exception class = DABT (current EL), IL = 32 bits\n\u00a0 \u00a0 \u00a0 SET = 0, FnV = 0\n\u00a0 \u00a0 \u00a0 EA = 0, S1PTW = 0\n\u00a0 \u00a0 Data abort info:\n\u00a0 \u00a0 \u00a0 ISV = 0, ISS = 0x00000006\n\u00a0 \u00a0 \u00a0 CM = 0, WnR = 0\n\u00a0 \u00a0 swapper pgtable: 4k pages, 39-bit VAs, pgdp = 000000007e8c586c\n\u00a0 \u00a0 [ffffffbf029ffffc] pgd=000000073bfc6003, pud=000000073bfc6003, pmd=0000000000000000\n\u00a0 \u00a0 Internal error: Oops: 96000006 [#1] SMP\n\u00a0 \u00a0 Modules linked in:\n\u00a0 \u00a0 CPU: 0 PID: 1098 Comm: bash Not tainted 5.0.0-rc5-salvator-x-00452-g37596f884f4318ef #287\n\u00a0 \u00a0 Hardware name: Renesas Salvator-X 2nd version board based on r8a7795 ES2.0+ (DT)\n\u00a0 \u00a0 pstate: 60400005 (nZCv daif +PAN -UAO)\n\u00a0 \u00a0 pc : __free_pages+0x8/0x58\n\u00a0 \u00a0 lr : __dma_direct_free_pages+0x50/0x5c\n\u00a0 \u00a0 sp : ffffff801268baa0\n\u00a0 \u00a0 x29: ffffff801268baa0 x28: 0000000000000000\n\u00a0 \u00a0 x27: ffffffc6f9c60bf0 x26: ffffffc6f9c60bf0\n\u00a0 \u00a0 x25: ffffffc6f9c60810 x24: 0000000000000000\n\u00a0 \u00a0 x23: 00000000fffff000 x22: ffffff8012145000\n\u00a0 \u00a0 x21: 0000000000000800 x20: ffffffbf029fffc8\n\u00a0 \u00a0 x19: 0000000000000000 x18: ffffffc6f86c42c8\n\u00a0 \u00a0 x17: 0000000000000000 x16: 0000000000000070\n\u00a0 \u00a0 x15: 0000000000000003 x14: 0000000000000000\n\u00a0 \u00a0 x13: ffffff801103d7f8 x12: 0000000000000028\n\u00a0 \u00a0 x11: ffffff8011117604 x10: 0000000000009ad8\n\u00a0 \u00a0 x9 : ffffff80110126d0 x8 : ffffffc6f7563000\n\u00a0 \u00a0 x7 : 6b6b6b6b6b6b6b6b x6 : 0000000000000018\n\u00a0 \u00a0 x5 : ffffff8011cf3cc8 x4 : 0000000000004000\n\u00a0 \u00a0 x3 : 0000000000080000 x2 : 0000000000000001\n\u00a0 \u00a0 x1 : 0000000000000000 x0 : ffffffbf029fffc8\n\u00a0 \u00a0 Process bash (pid: 1098, stack limit = 0x00000000c38e3e32)\n\u00a0 \u00a0 Call trace:\n\u00a0 \u00a0 \u00a0__free_pages+0x8/0x58\n\u00a0 \u00a0 \u00a0__dma_direct_free_pages+0x50/0x5c\n\u00a0 \u00a0 \u00a0arch_dma_free+0x1c/0x98\n\u00a0 \u00a0 \u00a0dma_direct_free+0x14/0x24\n\u00a0 \u00a0 \u00a0dma_free_attrs+0x9c/0xdc\n\u00a0 \u00a0 \u00a0dmam_release+0x18/0x20\n\u00a0 \u00a0 \u00a0release_nodes+0x25c/0x28c\n\u00a0 \u00a0 \u00a0devres_release_all+0x48/0x4c\n\u00a0 \u00a0 \u00a0device_release_driver_internal+0x184/0x1f0\n\u00a0 \u00a0 \u00a0device_release_driver+0x14/0x1c\n\u00a0 \u00a0 \u00a0unbind_store+0x70/0xb8\n\u00a0 \u00a0 \u00a0drv_attr_store+0x24/0x34\n\u00a0 \u00a0 \u00a0sysfs_kf_write+0x4c/0x64\n\u00a0 \u00a0 \u00a0kernfs_fop_write+0x154/0x1c4\n\u00a0 \u00a0 \u00a0__vfs_write+0x34/0x164\n\u00a0 \u00a0 \u00a0vfs_write+0xb4/0x16c\n\u00a0 \u00a0 \u00a0ksys_write+0x5c/0xbc\n\u00a0 \u00a0 \u00a0__arm64_sys_write+0x14/0x1c\n\u00a0 \u00a0 \u00a0el0_svc_common+0x98/0x114\n\u00a0 \u00a0 \u00a0el0_svc_handler+0x1c/0x24\n\u00a0 \u00a0 \u00a0el0_svc+0x8/0xc\n\u00a0 \u00a0 Code: d51b4234 17fffffa a9bf7bfd 910003fd (b9403404)\n\u00a0 \u00a0 ---[ end trace 8c564cdd3a1a840f ]---\n\nWhile I've bisected this to commit e8e683ae9a736407 (\"iommu/of: Fix\nprobe-deferral\"), and reverting that commit on post-v5.0-rc4 kernels\ndoes fix the problem, this turned out to be a red herring.\n\nOn arm64, arch_teardown_dma_ops() resets dev->dma_ops to NULL.\nHence if a driver has used a managed DMA allocation API, the allocated\nDMA memory will be freed using the direct DMA ops, while it may have\nbeen allocated using a custom DMA ops (iommu_dma_ops in this case).\n\nFix this by reversing the order of the calls to devres_release_all() and\narch_teardown_dma_ops().\n\nSigned-off-by: Geert Uytterhoeven <geert+renesas@glider.be>\nAcked-by: Christoph Hellwig <hch@lst.de>\nReviewed-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>\nCc: stable <stable@vger.kernel.org>\nReviewed-by: Robin Murphy <robin.murphy@arm.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/base/dd.c||drivers/base/dd.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/base/dd.c||drivers/base/dd.c": [
          "File: drivers/base/dd.c -> drivers/base/dd.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1058:    drv->remove(dev);",
          "1060:   device_links_driver_cleanup(dev);",
          "1063:   devres_release_all(dev);",
          "1064:   dev->driver = NULL;",
          "1065:   dev_set_drvdata(dev, NULL);",
          "1066:   if (dev->pm_domain && dev->pm_domain->dismiss)",
          "",
          "[Removed Lines]",
          "1061:   arch_teardown_dma_ops(dev);",
          "",
          "[Added Lines]",
          "1063:   arch_teardown_dma_ops(dev);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
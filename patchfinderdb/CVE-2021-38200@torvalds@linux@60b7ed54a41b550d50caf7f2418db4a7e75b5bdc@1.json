{
  "cve_id": "CVE-2021-38200",
  "cve_desc": "arch/powerpc/perf/core-book3s.c in the Linux kernel before 5.12.13, on systems with perf_event_paranoid=-1 and no specific PMU driver support registered, allows local users to cause a denial of service (perf_instruction_pointer NULL pointer dereference and OOPS) via a \"perf record\" command.",
  "repo": "torvalds/linux",
  "patch_hash": "60b7ed54a41b550d50caf7f2418db4a7e75b5bdc",
  "patch_info": {
    "commit_hash": "60b7ed54a41b550d50caf7f2418db4a7e75b5bdc",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/60b7ed54a41b550d50caf7f2418db4a7e75b5bdc",
    "files": [
      "arch/powerpc/perf/core-book3s.c"
    ],
    "message": "powerpc/perf: Fix crash in perf_instruction_pointer() when ppmu is not set\n\nOn systems without any specific PMU driver support registered, running\nperf record causes Oops.\n\nThe relevant portion from call trace:\n\n  BUG: Kernel NULL pointer dereference on read at 0x00000040\n  Faulting instruction address: 0xc0021f0c\n  Oops: Kernel access of bad area, sig: 11 [#1]\n  BE PAGE_SIZE=4K PREEMPT CMPCPRO\n  SAF3000 DIE NOTIFICATION\n  CPU: 0 PID: 442 Comm: null_syscall Not tainted 5.13.0-rc6-s3k-dev-01645-g7649ee3d2957 #5164\n  NIP:  c0021f0c LR: c00e8ad8 CTR: c00d8a5c\n  NIP perf_instruction_pointer+0x10/0x60\n  LR  perf_prepare_sample+0x344/0x674\n  Call Trace:\n    perf_prepare_sample+0x7c/0x674 (unreliable)\n    perf_event_output_forward+0x3c/0x94\n    __perf_event_overflow+0x74/0x14c\n    perf_swevent_hrtimer+0xf8/0x170\n    __hrtimer_run_queues.constprop.0+0x160/0x318\n    hrtimer_interrupt+0x148/0x3b0\n    timer_interrupt+0xc4/0x22c\n    Decrementer_virt+0xb8/0xbc\n\nDuring perf record session, perf_instruction_pointer() is called to\ncapture the sample IP. This function in core-book3s accesses\nppmu->flags. If a platform specific PMU driver is not registered, ppmu\nis set to NULL and accessing its members results in a crash. Fix this\ncrash by checking if ppmu is set.\n\nFixes: 2ca13a4cc56c (\"powerpc/perf: Use regs->nip when SIAR is zero\")\nCc: stable@vger.kernel.org # v5.11+\nReported-by: Christophe Leroy <christophe.leroy@csgroup.eu>\nSigned-off-by: Athira Rajeev <atrajeev@linux.vnet.ibm.com>\nTested-by: Christophe Leroy <christophe.leroy@csgroup.eu>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/1623952506-1431-1-git-send-email-atrajeev@linux.vnet.ibm.com",
    "before_after_code_files": [
      "arch/powerpc/perf/core-book3s.c||arch/powerpc/perf/core-book3s.c"
    ]
  },
  "patch_diff": {
    "arch/powerpc/perf/core-book3s.c||arch/powerpc/perf/core-book3s.c": [
      "File: arch/powerpc/perf/core-book3s.c -> arch/powerpc/perf/core-book3s.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "2254:  bool use_siar = regs_use_siar(regs);",
      "2255:  unsigned long siar = mfspr(SPRN_SIAR);",
      "2258:   if (siar)",
      "2259:    return siar;",
      "2260:   else",
      "",
      "[Removed Lines]",
      "2257:  if (ppmu->flags & PPMU_P10_DD1) {",
      "",
      "[Added Lines]",
      "2257:  if (ppmu && (ppmu->flags & PPMU_P10_DD1)) {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b31d9d6d7abbf6483b871b6370bc31c930d53f54",
      "candidate_info": {
        "commit_hash": "b31d9d6d7abbf6483b871b6370bc31c930d53f54",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/b31d9d6d7abbf6483b871b6370bc31c930d53f54",
        "files": [
          "drivers/usb/host/xhci-mem.c"
        ],
        "message": "xhci: solve a double free problem while doing s4\n\nwhen system is doing s4, the process of xhci_resume may be as below:\n1\u3001xhci_mem_cleanup\n2\u3001xhci_init->xhci_mem_init->xhci_mem_cleanup(when memory is not enough).\nxhci_mem_cleanup will be executed twice when system is out of memory.\nxhci->port_caps is freed in xhci_mem_cleanup,but it isn't set to NULL.\nIt will be freed twice when xhci_mem_cleanup is called the second time.\n\nWe got following bug when system resumes from s4:\n\nkernel BUG at mm/slub.c:309!\nInternal error: Oops - BUG: 0 [#1] PREEMPT SMP\nCPU: 0 PID: 5929 Tainted: G S   W   5.4.96-arm64-desktop #1\npc : __slab_free+0x5c/0x424\nlr : kfree+0x30c/0x32c\n\nCall trace:\n __slab_free+0x5c/0x424\n kfree+0x30c/0x32c\n xhci_mem_cleanup+0x394/0x3cc\n xhci_mem_init+0x9ac/0x1070\n xhci_init+0x8c/0x1d0\n xhci_resume+0x1cc/0x5fc\n xhci_plat_resume+0x64/0x70\n platform_pm_thaw+0x28/0x60\n dpm_run_callback+0x54/0x24c\n device_resume+0xd0/0x200\n async_resume+0x24/0x60\n async_run_entry_fn+0x44/0x110\n process_one_work+0x1f0/0x490\n worker_thread+0x5c/0x450\n kthread+0x158/0x160\n ret_from_fork+0x10/0x24\n\nOriginal patch that caused this issue was backported to 4.4 stable,\nso this should be backported to 4.4 stabe as well.\n\nFixes: cf0ee7c60c89 (\"xhci: Fix memory leak when caching protocol extended capability PSI tables - take 2\")\nCc: stable@vger.kernel.org # v4.4+\nSigned-off-by: Jiantao Zhang <water.zhangjiantao@huawei.com>\nSigned-off-by: Tao Xue <xuetao09@huawei.com>\nSigned-off-by: Mathias Nyman <mathias.nyman@linux.intel.com>\nLink: https://lore.kernel.org/r/20210617150354.1512157-5-mathias.nyman@linux.intel.com\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "before_after_code_files": [
          "drivers/usb/host/xhci-mem.c||drivers/ushost/xhci-mem.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/usb/host/xhci-mem.c||drivers/ushost/xhci-mem.c": [
          "File: drivers/usb/host/xhci-mem.c -> drivers/ushost/xhci-mem.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1924:  xhci->hw_ports = NULL;",
          "1925:  xhci->rh_bw = NULL;",
          "1926:  xhci->ext_caps = NULL;",
          "1928:  xhci->page_size = 0;",
          "1929:  xhci->page_shift = 0;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5de691bffe57fd0fc2b4dcdcf13815c56d11db10",
      "candidate_info": {
        "commit_hash": "5de691bffe57fd0fc2b4dcdcf13815c56d11db10",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/5de691bffe57fd0fc2b4dcdcf13815c56d11db10",
        "files": [
          "MAINTAINERS",
          "drivers/platform/x86/Kconfig",
          "drivers/platform/x86/Makefile",
          "drivers/platform/x86/intel-int3472/Kconfig",
          "drivers/platform/x86/intel-int3472/Makefile",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_clk_and_regulator.c",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_common.c",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_common.h",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_discrete.c",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_tps68470.c"
        ],
        "message": "platform/x86: Add intel_skl_int3472 driver\n\nACPI devices with _HID INT3472 are currently matched to the tps68470\ndriver, however this does not cover all situations in which that _HID\noccurs. We've encountered three possibilities:\n\n1. On Chrome OS devices, an ACPI device with _HID INT3472 (representing\na physical TPS68470 device) that requires a GPIO and OpRegion driver\n2. On devices designed for Windows, an ACPI device with _HID INT3472\n(again representing a physical TPS68470 device) which requires GPIO,\nClock and Regulator drivers.\n3. On other devices designed for Windows, an ACPI device with _HID\nINT3472 which does **not** represent a physical TPS68470, and is instead\nused as a dummy device to group some system GPIO lines which are meant\nto be consumed by the sensor that is dependent on this entry.\n\nThis commit adds a new module, registering a platform driver to deal\nwith the 3rd scenario plus an i2c driver to deal with #1 and #2, by\nquerying the CLDB buffer found against INT3472 entries to determine\nwhich is most appropriate.\n\nSuggested-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>\nSigned-off-by: Daniel Scally <djrscally@gmail.com>\nLink: https://lore.kernel.org/r/20210603224007.120560-6-djrscally@gmail.com\n[hdegoede@redhat.com Make skl_int3472_tps68470_calc_type() static]\nSigned-off-by: Hans de Goede <hdegoede@redhat.com>",
        "before_after_code_files": [
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_clk_and_regulator.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_clk_and_regulator.c",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_common.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_common.c",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_common.h||drivers/platform/x86/intel-int3472/intel_skl_int3472_common.h",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_discrete.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_discrete.c",
          "drivers/platform/x86/intel-int3472/intel_skl_int3472_tps68470.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_tps68470.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/platform/x86/intel-int3472/intel_skl_int3472_clk_and_regulator.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_clk_and_regulator.c": [
          "File: drivers/platform/x86/intel-int3472/intel_skl_int3472_clk_and_regulator.c -> drivers/platform/x86/intel-int3472/intel_skl_int3472_clk_and_regulator.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include <linux/acpi.h>",
          "5: #include <linux/clkdev.h>",
          "6: #include <linux/clk-provider.h>",
          "7: #include <linux/device.h>",
          "8: #include <linux/gpio/consumer.h>",
          "9: #include <linux/regulator/driver.h>",
          "10: #include <linux/slab.h>",
          "12: #include \"intel_skl_int3472_common.h\"",
          "19: static const struct regulator_ops int3472_gpio_regulator_ops;",
          "21: static int skl_int3472_clk_prepare(struct clk_hw *hw)",
          "22: {",
          "23:  struct int3472_gpio_clock *clk = to_int3472_clk(hw);",
          "25:  gpiod_set_value_cansleep(clk->ena_gpio, 1);",
          "26:  gpiod_set_value_cansleep(clk->led_gpio, 1);",
          "28:  return 0;",
          "29: }",
          "31: static void skl_int3472_clk_unprepare(struct clk_hw *hw)",
          "32: {",
          "33:  struct int3472_gpio_clock *clk = to_int3472_clk(hw);",
          "35:  gpiod_set_value_cansleep(clk->ena_gpio, 0);",
          "36:  gpiod_set_value_cansleep(clk->led_gpio, 0);",
          "37: }",
          "39: static int skl_int3472_clk_enable(struct clk_hw *hw)",
          "40: {",
          "47:  return 0;",
          "48: }",
          "50: static void skl_int3472_clk_disable(struct clk_hw *hw)",
          "51: {",
          "53: }",
          "55: static unsigned int skl_int3472_get_clk_frequency(struct int3472_discrete_device *int3472)",
          "56: {",
          "57:  union acpi_object *obj;",
          "58:  unsigned int freq;",
          "60:  obj = skl_int3472_get_acpi_buffer(int3472->sensor, \"SSDB\");",
          "61:  if (IS_ERR(obj))",
          "64:  if (obj->buffer.length < CIO2_SENSOR_SSDB_MCLKSPEED_OFFSET + sizeof(u32)) {",
          "65:   dev_err(int3472->dev, \"The buffer is too small\\n\");",
          "66:   kfree(obj);",
          "67:   return 0;",
          "68:  }",
          "70:  freq = *(u32 *)(obj->buffer.pointer + CIO2_SENSOR_SSDB_MCLKSPEED_OFFSET);",
          "72:  kfree(obj);",
          "73:  return freq;",
          "74: }",
          "76: static unsigned long skl_int3472_clk_recalc_rate(struct clk_hw *hw,",
          "77:        unsigned long parent_rate)",
          "78: {",
          "79:  struct int3472_gpio_clock *clk = to_int3472_clk(hw);",
          "81:  return clk->frequency;",
          "82: }",
          "84: static const struct clk_ops skl_int3472_clock_ops = {",
          "85:  .prepare = skl_int3472_clk_prepare,",
          "86:  .unprepare = skl_int3472_clk_unprepare,",
          "87:  .enable = skl_int3472_clk_enable,",
          "88:  .disable = skl_int3472_clk_disable,",
          "89:  .recalc_rate = skl_int3472_clk_recalc_rate,",
          "90: };",
          "92: int skl_int3472_register_clock(struct int3472_discrete_device *int3472)",
          "93: {",
          "94:  struct clk_init_data init = {",
          "95:   .ops = &skl_int3472_clock_ops,",
          "96:   .flags = CLK_GET_RATE_NOCACHE,",
          "97:  };",
          "98:  int ret;",
          "100:  init.name = kasprintf(GFP_KERNEL, \"%s-clk\",",
          "101:          acpi_dev_name(int3472->adev));",
          "102:  if (!init.name)",
          "103:   return -ENOMEM;",
          "105:  int3472->clock.frequency = skl_int3472_get_clk_frequency(int3472);",
          "107:  int3472->clock.clk_hw.init = &init;",
          "108:  int3472->clock.clk = clk_register(&int3472->adev->dev,",
          "109:        &int3472->clock.clk_hw);",
          "110:  if (IS_ERR(int3472->clock.clk)) {",
          "111:   ret = PTR_ERR(int3472->clock.clk);",
          "112:   goto out_free_init_name;",
          "113:  }",
          "115:  int3472->clock.cl = clkdev_create(int3472->clock.clk, NULL,",
          "116:        int3472->sensor_name);",
          "117:  if (!int3472->clock.cl) {",
          "118:   ret = -ENOMEM;",
          "119:   goto err_unregister_clk;",
          "120:  }",
          "122:  kfree(init.name);",
          "123:  return 0;",
          "125: err_unregister_clk:",
          "126:  clk_unregister(int3472->clock.clk);",
          "127: out_free_init_name:",
          "128:  kfree(init.name);",
          "130:  return ret;",
          "131: }",
          "133: int skl_int3472_register_regulator(struct int3472_discrete_device *int3472,",
          "134:        struct acpi_resource *ares)",
          "135: {",
          "136:  char *path = ares->data.gpio.resource_source.string_ptr;",
          "137:  const struct int3472_sensor_config *sensor_config;",
          "138:  struct regulator_consumer_supply supply_map;",
          "139:  struct regulator_init_data init_data = { };",
          "140:  struct regulator_config cfg = { };",
          "141:  int ret;",
          "143:  sensor_config = int3472->sensor_config;",
          "144:  if (IS_ERR(sensor_config)) {",
          "145:   dev_err(int3472->dev, \"No sensor module config\\n\");",
          "146:   return PTR_ERR(sensor_config);",
          "147:  }",
          "149:  if (!sensor_config->supply_map.supply) {",
          "150:   dev_err(int3472->dev, \"No supply name defined\\n\");",
          "151:   return -ENODEV;",
          "152:  }",
          "154:  init_data.constraints.valid_ops_mask = REGULATOR_CHANGE_STATUS;",
          "155:  init_data.num_consumer_supplies = 1;",
          "156:  supply_map = sensor_config->supply_map;",
          "157:  supply_map.dev_name = int3472->sensor_name;",
          "158:  init_data.consumer_supplies = &supply_map;",
          "160:  snprintf(int3472->regulator.regulator_name,",
          "161:    sizeof(int3472->regulator.regulator_name), \"%s-regulator\",",
          "162:    acpi_dev_name(int3472->adev));",
          "163:  snprintf(int3472->regulator.supply_name,",
          "164:    GPIO_REGULATOR_SUPPLY_NAME_LENGTH, \"supply-0\");",
          "166:  int3472->regulator.rdesc = INT3472_REGULATOR(",
          "167:       int3472->regulator.regulator_name,",
          "168:       int3472->regulator.supply_name,",
          "169:       &int3472_gpio_regulator_ops);",
          "171:  int3472->regulator.gpio = acpi_get_and_request_gpiod(path,",
          "172:             ares->data.gpio.pin_table[0],",
          "173:             \"int3472,regulator\");",
          "174:  if (IS_ERR(int3472->regulator.gpio)) {",
          "175:   dev_err(int3472->dev, \"Failed to get regulator GPIO line\\n\");",
          "176:   return PTR_ERR(int3472->regulator.gpio);",
          "177:  }",
          "179:  cfg.dev = &int3472->adev->dev;",
          "180:  cfg.init_data = &init_data;",
          "181:  cfg.ena_gpiod = int3472->regulator.gpio;",
          "183:  int3472->regulator.rdev = regulator_register(&int3472->regulator.rdesc,",
          "184:            &cfg);",
          "185:  if (IS_ERR(int3472->regulator.rdev)) {",
          "186:   ret = PTR_ERR(int3472->regulator.rdev);",
          "187:   goto err_free_gpio;",
          "188:  }",
          "190:  return 0;",
          "192: err_free_gpio:",
          "193:  gpiod_put(int3472->regulator.gpio);",
          "195:  return ret;",
          "196: }",
          "",
          "---------------"
        ],
        "drivers/platform/x86/intel-int3472/intel_skl_int3472_common.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_common.c": [
          "File: drivers/platform/x86/intel-int3472/intel_skl_int3472_common.c -> drivers/platform/x86/intel-int3472/intel_skl_int3472_common.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include <linux/acpi.h>",
          "5: #include <linux/i2c.h>",
          "6: #include <linux/platform_device.h>",
          "7: #include <linux/slab.h>",
          "9: #include \"intel_skl_int3472_common.h\"",
          "11: union acpi_object *skl_int3472_get_acpi_buffer(struct acpi_device *adev, char *id)",
          "12: {",
          "13:  struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };",
          "14:  acpi_handle handle = adev->handle;",
          "15:  union acpi_object *obj;",
          "16:  acpi_status status;",
          "18:  status = acpi_evaluate_object(handle, id, NULL, &buffer);",
          "19:  if (ACPI_FAILURE(status))",
          "20:   return ERR_PTR(-ENODEV);",
          "22:  obj = buffer.pointer;",
          "23:  if (!obj)",
          "24:   return ERR_PTR(-ENODEV);",
          "26:  if (obj->type != ACPI_TYPE_BUFFER) {",
          "27:   acpi_handle_err(handle, \"%s object is not an ACPI buffer\\n\", id);",
          "28:   kfree(obj);",
          "29:   return ERR_PTR(-EINVAL);",
          "30:  }",
          "32:  return obj;",
          "33: }",
          "35: int skl_int3472_fill_cldb(struct acpi_device *adev, struct int3472_cldb *cldb)",
          "36: {",
          "37:  union acpi_object *obj;",
          "38:  int ret;",
          "40:  obj = skl_int3472_get_acpi_buffer(adev, \"CLDB\");",
          "41:  if (IS_ERR(obj))",
          "42:   return PTR_ERR(obj);",
          "44:  if (obj->buffer.length > sizeof(*cldb)) {",
          "45:   acpi_handle_err(adev->handle, \"The CLDB buffer is too large\\n\");",
          "46:   ret = -EINVAL;",
          "47:   goto out_free_obj;",
          "48:  }",
          "50:  memcpy(cldb, obj->buffer.pointer, obj->buffer.length);",
          "51:  ret = 0;",
          "53: out_free_obj:",
          "54:  kfree(obj);",
          "55:  return ret;",
          "56: }",
          "58: static const struct acpi_device_id int3472_device_id[] = {",
          "59:  { \"INT3472\", 0 },",
          "60:  { }",
          "61: };",
          "62: MODULE_DEVICE_TABLE(acpi, int3472_device_id);",
          "64: static struct platform_driver int3472_discrete = {",
          "65:  .driver = {",
          "66:   .name = \"int3472-discrete\",",
          "67:   .acpi_match_table = int3472_device_id,",
          "68:  },",
          "69:  .probe = skl_int3472_discrete_probe,",
          "70:  .remove = skl_int3472_discrete_remove,",
          "71: };",
          "73: static struct i2c_driver int3472_tps68470 = {",
          "74:  .driver = {",
          "75:   .name = \"int3472-tps68470\",",
          "76:   .acpi_match_table = int3472_device_id,",
          "77:  },",
          "78:  .probe_new = skl_int3472_tps68470_probe,",
          "79: };",
          "81: static int skl_int3472_init(void)",
          "82: {",
          "83:  int ret;",
          "85:  ret = platform_driver_register(&int3472_discrete);",
          "86:  if (ret)",
          "87:   return ret;",
          "89:  ret = i2c_register_driver(THIS_MODULE, &int3472_tps68470);",
          "90:  if (ret)",
          "91:   platform_driver_unregister(&int3472_discrete);",
          "93:  return ret;",
          "94: }",
          "95: module_init(skl_int3472_init);",
          "97: static void skl_int3472_exit(void)",
          "98: {",
          "99:  platform_driver_unregister(&int3472_discrete);",
          "100:  i2c_del_driver(&int3472_tps68470);",
          "101: }",
          "102: module_exit(skl_int3472_exit);",
          "104: MODULE_DESCRIPTION(\"Intel SkyLake INT3472 ACPI Device Driver\");",
          "105: MODULE_AUTHOR(\"Daniel Scally <djrscally@gmail.com>\");",
          "106: MODULE_LICENSE(\"GPL v2\");",
          "",
          "---------------"
        ],
        "drivers/platform/x86/intel-int3472/intel_skl_int3472_common.h||drivers/platform/x86/intel-int3472/intel_skl_int3472_common.h": [
          "File: drivers/platform/x86/intel-int3472/intel_skl_int3472_common.h -> drivers/platform/x86/intel-int3472/intel_skl_int3472_common.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #ifndef _INTEL_SKL_INT3472_H",
          "5: #define _INTEL_SKL_INT3472_H",
          "7: #include <linux/clk-provider.h>",
          "8: #include <linux/gpio/machine.h>",
          "9: #include <linux/regulator/driver.h>",
          "10: #include <linux/regulator/machine.h>",
          "11: #include <linux/types.h>",
          "14: #ifndef I2C_DEV_NAME_FORMAT",
          "15: #define I2C_DEV_NAME_FORMAT     \"i2c-%s\"",
          "16: #endif",
          "19: #define INT3472_GPIO_TYPE_RESET     0x00",
          "20: #define INT3472_GPIO_TYPE_POWERDOWN    0x01",
          "21: #define INT3472_GPIO_TYPE_POWER_ENABLE    0x0b",
          "22: #define INT3472_GPIO_TYPE_CLK_ENABLE    0x0c",
          "23: #define INT3472_GPIO_TYPE_PRIVACY_LED    0x0d",
          "25: #define INT3472_PDEV_MAX_NAME_LEN    23",
          "26: #define INT3472_MAX_SENSOR_GPIOS    3",
          "28: #define GPIO_REGULATOR_NAME_LENGTH    21",
          "29: #define GPIO_REGULATOR_SUPPLY_NAME_LENGTH   9",
          "31: #define CIO2_SENSOR_SSDB_MCLKSPEED_OFFSET   86",
          "33: #define INT3472_REGULATOR(_name, _supply, _ops)   \\",
          "34:  (const struct regulator_desc) {    \\",
          "35:   .name = _name,     \\",
          "36:   .supply_name = _supply,    \\",
          "37:   .type = REGULATOR_VOLTAGE,   \\",
          "38:   .ops = _ops,     \\",
          "39:   .owner = THIS_MODULE,    \\",
          "40:  }",
          "42: #define to_int3472_clk(hw)     \\",
          "43:  container_of(hw, struct int3472_gpio_clock, clk_hw)",
          "45: #define to_int3472_device(clk)     \\",
          "46:  container_of(clk, struct int3472_discrete_device, clock)",
          "48: struct acpi_device;",
          "49: struct i2c_client;",
          "50: struct platform_device;",
          "52: struct int3472_cldb {",
          "53:  u8 version;",
          "61:  u8 control_logic_type;",
          "62:  u8 control_logic_id;",
          "63:  u8 sensor_card_sku;",
          "64:  u8 reserved[28];",
          "65: };",
          "67: struct int3472_gpio_function_remap {",
          "68:  const char *documented;",
          "69:  const char *actual;",
          "70: };",
          "72: struct int3472_sensor_config {",
          "73:  const char *sensor_module_name;",
          "74:  struct regulator_consumer_supply supply_map;",
          "75:  const struct int3472_gpio_function_remap *function_maps;",
          "76: };",
          "78: struct int3472_discrete_device {",
          "79:  struct acpi_device *adev;",
          "80:  struct device *dev;",
          "81:  struct acpi_device *sensor;",
          "82:  const char *sensor_name;",
          "84:  const struct int3472_sensor_config *sensor_config;",
          "86:  struct int3472_gpio_regulator {",
          "87:   char regulator_name[GPIO_REGULATOR_NAME_LENGTH];",
          "88:   char supply_name[GPIO_REGULATOR_SUPPLY_NAME_LENGTH];",
          "89:   struct gpio_desc *gpio;",
          "90:   struct regulator_dev *rdev;",
          "91:   struct regulator_desc rdesc;",
          "92:  } regulator;",
          "94:  struct int3472_gpio_clock {",
          "95:   struct clk *clk;",
          "96:   struct clk_hw clk_hw;",
          "97:   struct clk_lookup *cl;",
          "98:   struct gpio_desc *ena_gpio;",
          "99:   struct gpio_desc *led_gpio;",
          "100:   u32 frequency;",
          "101:  } clock;",
          "105:  struct gpiod_lookup_table gpios;",
          "106: };",
          "108: int skl_int3472_discrete_probe(struct platform_device *pdev);",
          "109: int skl_int3472_discrete_remove(struct platform_device *pdev);",
          "110: int skl_int3472_tps68470_probe(struct i2c_client *client);",
          "111: union acpi_object *skl_int3472_get_acpi_buffer(struct acpi_device *adev,",
          "112:             char *id);",
          "113: int skl_int3472_fill_cldb(struct acpi_device *adev, struct int3472_cldb *cldb);",
          "114: int skl_int3472_register_clock(struct int3472_discrete_device *int3472);",
          "115: int skl_int3472_register_regulator(struct int3472_discrete_device *int3472,",
          "116:        struct acpi_resource *ares);",
          "118: #endif",
          "",
          "---------------"
        ],
        "drivers/platform/x86/intel-int3472/intel_skl_int3472_discrete.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_discrete.c": [
          "File: drivers/platform/x86/intel-int3472/intel_skl_int3472_discrete.c -> drivers/platform/x86/intel-int3472/intel_skl_int3472_discrete.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include <linux/acpi.h>",
          "5: #include <linux/clkdev.h>",
          "6: #include <linux/clk-provider.h>",
          "7: #include <linux/device.h>",
          "8: #include <linux/gpio/consumer.h>",
          "9: #include <linux/gpio/machine.h>",
          "10: #include <linux/i2c.h>",
          "11: #include <linux/kernel.h>",
          "12: #include <linux/module.h>",
          "13: #include <linux/overflow.h>",
          "14: #include <linux/platform_device.h>",
          "15: #include <linux/uuid.h>",
          "17: #include \"intel_skl_int3472_common.h\"",
          "26: static const guid_t int3472_gpio_guid =",
          "27:  GUID_INIT(0x79234640, 0x9e10, 0x4fea,",
          "28:     0xa5, 0xc1, 0xb5, 0xaa, 0x8b, 0x19, 0x75, 0x6f);",
          "35: static const guid_t cio2_sensor_module_guid =",
          "36:  GUID_INIT(0x822ace8f, 0x2814, 0x4174,",
          "37:     0xa5, 0x6b, 0x5f, 0x02, 0x9f, 0xe0, 0x79, 0xee);",
          "52: static const struct int3472_gpio_function_remap ov2680_gpio_function_remaps[] = {",
          "53:  { \"reset\", NULL },",
          "54:  { \"powerdown\", \"reset\" },",
          "55:  { }",
          "56: };",
          "58: static const struct int3472_sensor_config int3472_sensor_configs[] = {",
          "60:  { \"GNDF140809R\", { 0 }, ov2680_gpio_function_remaps },",
          "62:  { \"GEFF150023R\", REGULATOR_SUPPLY(\"avdd\", NULL), NULL },",
          "64:  { \"YHCU\", REGULATOR_SUPPLY(\"avdd\", NULL), NULL },",
          "65: };",
          "67: static const struct int3472_sensor_config *",
          "68: skl_int3472_get_sensor_module_config(struct int3472_discrete_device *int3472)",
          "69: {",
          "70:  union acpi_object *obj;",
          "71:  unsigned int i;",
          "73:  obj = acpi_evaluate_dsm_typed(int3472->sensor->handle,",
          "74:           &cio2_sensor_module_guid, 0x00,",
          "75:           0x01, NULL, ACPI_TYPE_STRING);",
          "77:  if (!obj) {",
          "78:   dev_err(int3472->dev,",
          "79:    \"Failed to get sensor module string from _DSM\\n\");",
          "80:   return ERR_PTR(-ENODEV);",
          "81:  }",
          "83:  if (obj->string.type != ACPI_TYPE_STRING) {",
          "84:   dev_err(int3472->dev,",
          "85:    \"Sensor _DSM returned a non-string value\\n\");",
          "87:   ACPI_FREE(obj);",
          "88:   return ERR_PTR(-EINVAL);",
          "89:  }",
          "91:  for (i = 0; i < ARRAY_SIZE(int3472_sensor_configs); i++) {",
          "92:   if (!strcmp(int3472_sensor_configs[i].sensor_module_name,",
          "93:        obj->string.pointer))",
          "94:    break;",
          "95:  }",
          "97:  ACPI_FREE(obj);",
          "99:  if (i >= ARRAY_SIZE(int3472_sensor_configs))",
          "100:   return ERR_PTR(-EINVAL);",
          "102:  return &int3472_sensor_configs[i];",
          "103: }",
          "105: static int skl_int3472_map_gpio_to_sensor(struct int3472_discrete_device *int3472,",
          "106:        struct acpi_resource *ares,",
          "107:        const char *func, u32 polarity)",
          "108: {",
          "109:  char *path = ares->data.gpio.resource_source.string_ptr;",
          "110:  const struct int3472_sensor_config *sensor_config;",
          "111:  struct gpiod_lookup *table_entry;",
          "112:  struct acpi_device *adev;",
          "113:  acpi_handle handle;",
          "114:  acpi_status status;",
          "115:  int ret;",
          "117:  if (int3472->n_sensor_gpios >= INT3472_MAX_SENSOR_GPIOS) {",
          "118:   dev_warn(int3472->dev, \"Too many GPIOs mapped\\n\");",
          "119:   return -EINVAL;",
          "120:  }",
          "122:  sensor_config = int3472->sensor_config;",
          "123:  if (!IS_ERR(sensor_config) && sensor_config->function_maps) {",
          "124:   const struct int3472_gpio_function_remap *remap;",
          "126:   for (remap = sensor_config->function_maps; remap->documented; remap++) {",
          "127:    if (!strcmp(func, remap->documented)) {",
          "128:     func = remap->actual;",
          "129:     break;",
          "130:    }",
          "131:   }",
          "132:  }",
          "135:  if (!func)",
          "136:   return 0;",
          "138:  status = acpi_get_handle(NULL, path, &handle);",
          "139:  if (ACPI_FAILURE(status))",
          "140:   return -EINVAL;",
          "142:  ret = acpi_bus_get_device(handle, &adev);",
          "143:  if (ret)",
          "144:   return -ENODEV;",
          "146:  table_entry = &int3472->gpios.table[int3472->n_sensor_gpios];",
          "147:  table_entry->key = acpi_dev_name(adev);",
          "148:  table_entry->chip_hwnum = ares->data.gpio.pin_table[0];",
          "149:  table_entry->con_id = func;",
          "150:  table_entry->idx = 0;",
          "151:  table_entry->flags = polarity;",
          "153:  int3472->n_sensor_gpios++;",
          "155:  return 0;",
          "156: }",
          "158: static int skl_int3472_map_gpio_to_clk(struct int3472_discrete_device *int3472,",
          "159:            struct acpi_resource *ares, u8 type)",
          "160: {",
          "161:  char *path = ares->data.gpio.resource_source.string_ptr;",
          "162:  struct gpio_desc *gpio;",
          "164:  switch (type) {",
          "165:  case INT3472_GPIO_TYPE_CLK_ENABLE:",
          "166:   gpio = acpi_get_and_request_gpiod(path, ares->data.gpio.pin_table[0],",
          "167:         \"int3472,clk-enable\");",
          "168:   if (IS_ERR(gpio))",
          "169:    return (PTR_ERR(gpio));",
          "171:   int3472->clock.ena_gpio = gpio;",
          "172:   break;",
          "173:  case INT3472_GPIO_TYPE_PRIVACY_LED:",
          "174:   gpio = acpi_get_and_request_gpiod(path, ares->data.gpio.pin_table[0],",
          "175:         \"int3472,privacy-led\");",
          "176:   if (IS_ERR(gpio))",
          "177:    return (PTR_ERR(gpio));",
          "179:   int3472->clock.led_gpio = gpio;",
          "180:   break;",
          "181:  default:",
          "182:   dev_err(int3472->dev, \"Invalid GPIO type 0x%02x for clock\\n\", type);",
          "183:   break;",
          "184:  }",
          "186:  return 0;",
          "187: }",
          "221: static int skl_int3472_handle_gpio_resources(struct acpi_resource *ares,",
          "222:           void *data)",
          "223: {",
          "224:  struct int3472_discrete_device *int3472 = data;",
          "225:  struct acpi_resource_gpio *agpio;",
          "226:  union acpi_object *obj;",
          "227:  const char *err_msg;",
          "228:  int ret;",
          "229:  u8 type;",
          "231:  if (!acpi_gpio_get_io_resource(ares, &agpio))",
          "232:   return 1;",
          "238:  obj = acpi_evaluate_dsm_typed(int3472->adev->handle,",
          "239:           &int3472_gpio_guid, 0x00,",
          "240:           int3472->ngpios + 2,",
          "241:           NULL, ACPI_TYPE_INTEGER);",
          "243:  if (!obj) {",
          "244:   dev_warn(int3472->dev, \"No _DSM entry for GPIO pin %u\\n\",",
          "245:     ares->data.gpio.pin_table[0]);",
          "246:   return 1;",
          "247:  }",
          "249:  type = obj->integer.value & 0xff;",
          "251:  switch (type) {",
          "252:  case INT3472_GPIO_TYPE_RESET:",
          "253:   ret = skl_int3472_map_gpio_to_sensor(int3472, ares, \"reset\",",
          "254:            GPIO_ACTIVE_LOW);",
          "255:   if (ret)",
          "256:    err_msg = \"Failed to map reset pin to sensor\\n\";",
          "258:   break;",
          "259:  case INT3472_GPIO_TYPE_POWERDOWN:",
          "260:   ret = skl_int3472_map_gpio_to_sensor(int3472, ares,",
          "261:            \"powerdown\",",
          "262:            GPIO_ACTIVE_LOW);",
          "263:   if (ret)",
          "264:    err_msg = \"Failed to map powerdown pin to sensor\\n\";",
          "266:   break;",
          "267:  case INT3472_GPIO_TYPE_CLK_ENABLE:",
          "268:  case INT3472_GPIO_TYPE_PRIVACY_LED:",
          "269:   ret = skl_int3472_map_gpio_to_clk(int3472, ares, type);",
          "270:   if (ret)",
          "271:    err_msg = \"Failed to map GPIO to clock\\n\";",
          "273:   break;",
          "274:  case INT3472_GPIO_TYPE_POWER_ENABLE:",
          "275:   ret = skl_int3472_register_regulator(int3472, ares);",
          "276:   if (ret)",
          "277:    err_msg = \"Failed to map regulator to sensor\\n\";",
          "279:   break;",
          "280:  default:",
          "281:   dev_warn(int3472->dev,",
          "282:     \"GPIO type 0x%02x unknown; the sensor may not work\\n\",",
          "283:     type);",
          "284:   ret = 1;",
          "285:   break;",
          "286:  }",
          "288:  int3472->ngpios++;",
          "289:  ACPI_FREE(obj);",
          "291:  if (ret)",
          "292:   return dev_err_probe(int3472->dev, ret, err_msg);",
          "294:  return 0;",
          "295: }",
          "297: static int skl_int3472_parse_crs(struct int3472_discrete_device *int3472)",
          "298: {",
          "299:  LIST_HEAD(resource_list);",
          "300:  int ret;",
          "306:  int3472->sensor_config = skl_int3472_get_sensor_module_config(int3472);",
          "308:  ret = acpi_dev_get_resources(int3472->adev, &resource_list,",
          "309:          skl_int3472_handle_gpio_resources,",
          "310:          int3472);",
          "311:  if (ret)",
          "312:   goto out_free_res_list;",
          "319:  if (int3472->clock.ena_gpio) {",
          "320:   ret = skl_int3472_register_clock(int3472);",
          "321:   if (ret)",
          "322:    goto out_free_res_list;",
          "323:  } else {",
          "324:   if (int3472->clock.led_gpio)",
          "325:    dev_warn(int3472->dev,",
          "326:      \"No clk GPIO. The privacy LED won't work\\n\");",
          "327:  }",
          "329:  int3472->gpios.dev_id = int3472->sensor_name;",
          "330:  gpiod_add_lookup_table(&int3472->gpios);",
          "332: out_free_res_list:",
          "333:  acpi_dev_free_resource_list(&resource_list);",
          "335:  return ret;",
          "336: }",
          "338: int skl_int3472_discrete_probe(struct platform_device *pdev)",
          "339: {",
          "340:  struct acpi_device *adev = ACPI_COMPANION(&pdev->dev);",
          "341:  struct int3472_discrete_device *int3472;",
          "342:  struct int3472_cldb cldb;",
          "343:  int ret;",
          "345:  ret = skl_int3472_fill_cldb(adev, &cldb);",
          "346:  if (ret) {",
          "347:   dev_err(&pdev->dev, \"Couldn't fill CLDB structure\\n\");",
          "348:   return ret;",
          "349:  }",
          "351:  if (cldb.control_logic_type != 1) {",
          "352:   dev_err(&pdev->dev, \"Unsupported control logic type %u\\n\",",
          "353:    cldb.control_logic_type);",
          "354:   return -EINVAL;",
          "355:  }",
          "358:  int3472 = devm_kzalloc(&pdev->dev, struct_size(int3472, gpios.table,",
          "359:           INT3472_MAX_SENSOR_GPIOS + 1), GFP_KERNEL);",
          "360:  if (!int3472)",
          "361:   return -ENOMEM;",
          "363:  int3472->adev = adev;",
          "364:  int3472->dev = &pdev->dev;",
          "365:  platform_set_drvdata(pdev, int3472);",
          "367:  int3472->sensor = acpi_dev_get_first_consumer_dev(adev);",
          "368:  if (!int3472->sensor) {",
          "369:   dev_err(&pdev->dev, \"INT3472 seems to have no dependents.\\n\");",
          "370:   return -ENODEV;",
          "371:  }",
          "373:  int3472->sensor_name = devm_kasprintf(int3472->dev, GFP_KERNEL,",
          "374:            I2C_DEV_NAME_FORMAT,",
          "375:            acpi_dev_name(int3472->sensor));",
          "376:  if (!int3472->sensor_name) {",
          "377:   ret = -ENOMEM;",
          "378:   goto err_put_sensor;",
          "379:  }",
          "385:  INIT_LIST_HEAD(&int3472->gpios.list);",
          "387:  ret = skl_int3472_parse_crs(int3472);",
          "388:  if (ret) {",
          "389:   skl_int3472_discrete_remove(pdev);",
          "390:   return ret;",
          "391:  }",
          "393:  return 0;",
          "395: err_put_sensor:",
          "396:  acpi_dev_put(int3472->sensor);",
          "398:  return ret;",
          "399: }",
          "401: int skl_int3472_discrete_remove(struct platform_device *pdev)",
          "402: {",
          "403:  struct int3472_discrete_device *int3472 = platform_get_drvdata(pdev);",
          "405:  gpiod_remove_lookup_table(&int3472->gpios);",
          "406:  regulator_unregister(int3472->regulator.rdev);",
          "407:  clk_unregister(int3472->clock.clk);",
          "409:  if (int3472->clock.cl)",
          "410:   clkdev_drop(int3472->clock.cl);",
          "412:  gpiod_put(int3472->regulator.gpio);",
          "413:  gpiod_put(int3472->clock.ena_gpio);",
          "414:  gpiod_put(int3472->clock.led_gpio);",
          "416:  return 0;",
          "417: }",
          "",
          "---------------"
        ],
        "drivers/platform/x86/intel-int3472/intel_skl_int3472_tps68470.c||drivers/platform/x86/intel-int3472/intel_skl_int3472_tps68470.c": [
          "File: drivers/platform/x86/intel-int3472/intel_skl_int3472_tps68470.c -> drivers/platform/x86/intel-int3472/intel_skl_int3472_tps68470.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4: #include <linux/i2c.h>",
          "5: #include <linux/mfd/core.h>",
          "6: #include <linux/mfd/tps68470.h>",
          "7: #include <linux/platform_device.h>",
          "8: #include <linux/regmap.h>",
          "10: #include \"intel_skl_int3472_common.h\"",
          "12: #define DESIGNED_FOR_CHROMEOS  1",
          "13: #define DESIGNED_FOR_WINDOWS  2",
          "15: static const struct mfd_cell tps68470_cros[] = {",
          "16:  { .name = \"tps68470-gpio\" },",
          "17:  { .name = \"tps68470_pmic_opregion\" },",
          "18: };",
          "20: static const struct mfd_cell tps68470_win[] = {",
          "21:  { .name = \"tps68470-gpio\" },",
          "22:  { .name = \"tps68470-clk\" },",
          "23:  { .name = \"tps68470-regulator\" },",
          "24: };",
          "26: static const struct regmap_config tps68470_regmap_config = {",
          "27:  .reg_bits = 8,",
          "28:  .val_bits = 8,",
          "29:  .max_register = TPS68470_REG_MAX,",
          "30: };",
          "32: static int tps68470_chip_init(struct device *dev, struct regmap *regmap)",
          "33: {",
          "34:  unsigned int version;",
          "35:  int ret;",
          "38:  ret = regmap_write(regmap, TPS68470_REG_RESET, TPS68470_REG_RESET_MASK);",
          "39:  if (ret)",
          "40:   return ret;",
          "42:  ret = regmap_read(regmap, TPS68470_REG_REVID, &version);",
          "43:  if (ret) {",
          "44:   dev_err(dev, \"Failed to read revision register: %d\\n\", ret);",
          "45:   return ret;",
          "46:  }",
          "48:  dev_info(dev, \"TPS68470 REVID: 0x%02x\\n\", version);",
          "50:  return 0;",
          "51: }",
          "76: static int skl_int3472_tps68470_calc_type(struct acpi_device *adev)",
          "77: {",
          "78:  struct int3472_cldb cldb = { 0 };",
          "79:  int ret;",
          "85:  ret = skl_int3472_fill_cldb(adev, &cldb);",
          "86:  if (ret && ret != -ENODEV)",
          "87:   return ret;",
          "89:  if (ret)",
          "90:   return DESIGNED_FOR_CHROMEOS;",
          "92:  if (cldb.control_logic_type != 2)",
          "93:   return -EINVAL;",
          "95:  return DESIGNED_FOR_WINDOWS;",
          "96: }",
          "98: int skl_int3472_tps68470_probe(struct i2c_client *client)",
          "99: {",
          "100:  struct acpi_device *adev = ACPI_COMPANION(&client->dev);",
          "101:  struct regmap *regmap;",
          "102:  int device_type;",
          "103:  int ret;",
          "105:  regmap = devm_regmap_init_i2c(client, &tps68470_regmap_config);",
          "106:  if (IS_ERR(regmap)) {",
          "107:   dev_err(&client->dev, \"Failed to create regmap: %ld\\n\", PTR_ERR(regmap));",
          "108:   return PTR_ERR(regmap);",
          "109:  }",
          "111:  i2c_set_clientdata(client, regmap);",
          "113:  ret = tps68470_chip_init(&client->dev, regmap);",
          "114:  if (ret < 0) {",
          "115:   dev_err(&client->dev, \"TPS68470 init error %d\\n\", ret);",
          "116:   return ret;",
          "117:  }",
          "119:  device_type = skl_int3472_tps68470_calc_type(adev);",
          "120:  switch (device_type) {",
          "121:  case DESIGNED_FOR_WINDOWS:",
          "122:   ret = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_NONE,",
          "123:         tps68470_win, ARRAY_SIZE(tps68470_win),",
          "124:         NULL, 0, NULL);",
          "125:   break;",
          "126:  case DESIGNED_FOR_CHROMEOS:",
          "127:   ret = devm_mfd_add_devices(&client->dev, PLATFORM_DEVID_NONE,",
          "128:         tps68470_cros, ARRAY_SIZE(tps68470_cros),",
          "129:         NULL, 0, NULL);",
          "130:   break;",
          "131:  default:",
          "132:   dev_err(&client->dev, \"Failed to add MFD devices\\n\");",
          "133:   return device_type;",
          "134:  }",
          "136:  return ret;",
          "137: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2058cc9c8041fde9c0bdd8e868c72b137cff8563",
      "candidate_info": {
        "commit_hash": "2058cc9c8041fde9c0bdd8e868c72b137cff8563",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2058cc9c8041fde9c0bdd8e868c72b137cff8563",
        "files": [
          "drivers/net/ethernet/mellanox/mlx5/core/dev.c"
        ],
        "message": "net/mlx5: Check that driver was probed prior attaching the device\n\nThe device can be requested to be attached despite being not probed.\nThis situation is possible if devlink reload races with module removal,\nand the following kernel panic is an outcome of such race.\n\n mlx5_core 0000:00:09.0: firmware version: 4.7.9999\n mlx5_core 0000:00:09.0: 0.000 Gb/s available PCIe bandwidth (8.0 GT/s PCIe x255 link)\n BUG: unable to handle page fault for address: fffffffffffffff0\n #PF: supervisor read access in kernel mode\n #PF: error_code(0x0000) - not-present page\n PGD 3218067 P4D 3218067 PUD 321a067 PMD 0\n Oops: 0000 [#1] SMP KASAN NOPTI\n CPU: 7 PID: 250 Comm: devlink Not tainted 5.12.0-rc2+ #2836\n Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014\n RIP: 0010:mlx5_attach_device+0x80/0x280 [mlx5_core]\n Code: f8 48 c1 e8 03 42 80 3c 38 00 0f 85 80 01 00 00 48 8b 45 68 48 8d 78 f0 48 89 fe 48 c1 ee 03 42 80 3c 3e 00 0f 85 70 01 00 00 <48> 8b 40 f0 48 85 c0 74 0d 48 89 ef ff d0 85 c0 0f 85 84 05 0e 00\n RSP: 0018:ffff8880129675f0 EFLAGS: 00010246\n RAX: 0000000000000000 RBX: 0000000000000001 RCX: ffffffff827407f1\n RDX: 1ffff110011336cf RSI: 1ffffffffffffffe RDI: fffffffffffffff0\n RBP: ffff888008e0c000 R08: 0000000000000008 R09: ffffffffa0662ee7\n R10: fffffbfff40cc5dc R11: 0000000000000000 R12: ffff88800ea002e0\n R13: ffffed1001d459f7 R14: ffffffffa05ef4f8 R15: dffffc0000000000\n FS:  00007f51dfeaf740(0000) GS:ffff88806d5c0000(0000) knlGS:0000000000000000\n CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n CR2: fffffffffffffff0 CR3: 000000000bc82006 CR4: 0000000000370ea0\n DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n Call Trace:\n  mlx5_load_one+0x117/0x1d0 [mlx5_core]\n  devlink_reload+0x2d5/0x520\n  ? devlink_remote_reload_actions_performed+0x30/0x30\n  ? mutex_trylock+0x24b/0x2d0\n  ? devlink_nl_cmd_reload+0x62b/0x1070\n  devlink_nl_cmd_reload+0x66d/0x1070\n  ? devlink_reload+0x520/0x520\n  ? devlink_nl_pre_doit+0x64/0x4d0\n  genl_family_rcv_msg_doit+0x1e9/0x2f0\n  ? mutex_lock_io_nested+0x1130/0x1130\n  ? genl_family_rcv_msg_attrs_parse.constprop.0+0x240/0x240\n  ? security_capable+0x51/0x90\n  genl_rcv_msg+0x27f/0x4a0\n  ? genl_get_cmd+0x3c0/0x3c0\n  ? lock_acquire+0x1a9/0x6d0\n  ? devlink_reload+0x520/0x520\n  ? lock_release+0x6c0/0x6c0\n  netlink_rcv_skb+0x11d/0x340\n  ? genl_get_cmd+0x3c0/0x3c0\n  ? netlink_ack+0x9f0/0x9f0\n  ? lock_release+0x1f9/0x6c0\n  genl_rcv+0x24/0x40\n  netlink_unicast+0x433/0x700\n  ? netlink_attachskb+0x730/0x730\n  ? _copy_from_iter_full+0x178/0x650\n  ? __alloc_skb+0x113/0x2b0\n  netlink_sendmsg+0x6f1/0xbd0\n  ? netlink_unicast+0x700/0x700\n  ? netlink_unicast+0x700/0x700\n  sock_sendmsg+0xb0/0xe0\n  __sys_sendto+0x193/0x240\n  ? __x64_sys_getpeername+0xb0/0xb0\n  ? copy_page_range+0x2300/0x2300\n  ? __up_read+0x1a1/0x7b0\n  ? do_user_addr_fault+0x219/0xdc0\n  __x64_sys_sendto+0xdd/0x1b0\n  ? syscall_enter_from_user_mode+0x1d/0x50\n  do_syscall_64+0x2d/0x40\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7f51dffb514a\n Code: d8 64 89 02 48 c7 c0 ff ff ff ff eb b8 0f 1f 00 f3 0f 1e fa 41 89 ca 64 8b 04 25 18 00 00 00 85 c0 75 15 b8 2c 00 00 00 0f 05 <48> 3d 00 f0 ff ff 77 76 c3 0f 1f 44 00 00 55 48 83 ec 30 44 89 4c\n RSP: 002b:00007ffcaef22e78 EFLAGS: 00000246 ORIG_RAX: 000000000000002c\n RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 00007f51dffb514a\n RDX: 0000000000000030 RSI: 000055750daf2440 RDI: 0000000000000003\n RBP: 000055750daf2410 R08: 00007f51e0081200 R09: 000000000000000c\n R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000\n Modules linked in: mlx5_core(-) ptp pps_core ib_ipoib rdma_ucm rdma_cm iw_cm ib_cm ib_umad ib_uverbs ib_core [last unloaded: mlx5_ib]\n CR2: fffffffffffffff0\n ---[ end trace 7789831bfe74fa42 ]---\n\nFixes: a925b5e309c9 (\"net/mlx5: Register mlx5 devices to auxiliary virtual bus\")\nSigned-off-by: Leon Romanovsky <leonro@nvidia.com>\nReviewed-by: Parav Pandit <parav@nvidia.com>\nSigned-off-by: Saeed Mahameed <saeedm@nvidia.com>",
        "before_after_code_files": [
          "drivers/net/ethernet/mellanox/mlx5/core/dev.c||drivers/net/ethernet/mellanox/mlx5/core/dev.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "drivers/net/ethernet/mellanox/mlx5/core/dev.c||drivers/net/ethernet/mellanox/mlx5/core/dev.c": [
          "File: drivers/net/ethernet/mellanox/mlx5/core/dev.c -> drivers/net/ethernet/mellanox/mlx5/core/dev.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "320:    }",
          "321:   } else {",
          "322:    adev = &priv->adev[i]->adev;",
          "323:    adrv = to_auxiliary_drv(adev->dev.driver);",
          "325:    if (adrv->resume)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "331:    if (!adev->dev.driver)",
          "332:     continue;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "350:    continue;",
          "352:   adev = &priv->adev[i]->adev;",
          "353:   adrv = to_auxiliary_drv(adev->dev.driver);",
          "355:   if (adrv->suspend) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "364:   if (!adev->dev.driver)",
          "365:    goto skip_suspend;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "357:    continue;",
          "358:   }",
          "360:   del_adev(&priv->adev[i]->adev);",
          "361:   priv->adev[i] = NULL;",
          "362:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "374: skip_suspend:",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e8675d291ac007e1c636870db880f837a9ea112a",
      "candidate_info": {
        "commit_hash": "e8675d291ac007e1c636870db880f837a9ea112a",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/e8675d291ac007e1c636870db880f837a9ea112a",
        "files": [
          "mm/memory-failure.c"
        ],
        "message": "mm/memory-failure: make sure wait for page writeback in memory_failure\n\nOur syzkaller trigger the \"BUG_ON(!list_empty(&inode->i_wb_list))\" in\nclear_inode:\n\n  kernel BUG at fs/inode.c:519!\n  Internal error: Oops - BUG: 0 [#1] SMP\n  Modules linked in:\n  Process syz-executor.0 (pid: 249, stack limit = 0x00000000a12409d7)\n  CPU: 1 PID: 249 Comm: syz-executor.0 Not tainted 4.19.95\n  Hardware name: linux,dummy-virt (DT)\n  pstate: 80000005 (Nzcv daif -PAN -UAO)\n  pc : clear_inode+0x280/0x2a8\n  lr : clear_inode+0x280/0x2a8\n  Call trace:\n    clear_inode+0x280/0x2a8\n    ext4_clear_inode+0x38/0xe8\n    ext4_free_inode+0x130/0xc68\n    ext4_evict_inode+0xb20/0xcb8\n    evict+0x1a8/0x3c0\n    iput+0x344/0x460\n    do_unlinkat+0x260/0x410\n    __arm64_sys_unlinkat+0x6c/0xc0\n    el0_svc_common+0xdc/0x3b0\n    el0_svc_handler+0xf8/0x160\n    el0_svc+0x10/0x218\n  Kernel panic - not syncing: Fatal exception\n\nA crash dump of this problem show that someone called __munlock_pagevec\nto clear page LRU without lock_page: do_mmap -> mmap_region -> do_munmap\n-> munlock_vma_pages_range -> __munlock_pagevec.\n\nAs a result memory_failure will call identify_page_state without\nwait_on_page_writeback.  And after truncate_error_page clear the mapping\nof this page.  end_page_writeback won't call sb_clear_inode_writeback to\nclear inode->i_wb_list.  That will trigger BUG_ON in clear_inode!\n\nFix it by checking PageWriteback too to help determine should we skip\nwait_on_page_writeback.\n\nLink: https://lkml.kernel.org/r/20210604084705.3729204-1-yangerkun@huawei.com\nFixes: 0bc1f8b0682c (\"hwpoison: fix the handling path of the victimized page frame that belong to non-LRU\")\nSigned-off-by: yangerkun <yangerkun@huawei.com>\nAcked-by: Naoya Horiguchi <naoya.horiguchi@nec.com>\nCc: Jan Kara <jack@suse.cz>\nCc: Theodore Ts'o <tytso@mit.edu>\nCc: Oscar Salvador <osalvador@suse.de>\nCc: Yu Kuai <yukuai3@huawei.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "before_after_code_files": [
          "mm/memory-failure.c||mm/memory-failure.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_issue": 1,
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "mm/memory-failure.c||mm/memory-failure.c": [
          "File: mm/memory-failure.c -> mm/memory-failure.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1552:   return 0;",
          "1553:  }",
          "1556:   goto identify_page_state;",
          "",
          "[Removed Lines]",
          "1555:  if (!PageTransTail(p) && !PageLRU(p))",
          "",
          "[Added Lines]",
          "1560:  if (!PageTransTail(p) && !PageLRU(p) && !PageWriteback(p))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "2ca13a4cc56c920a6c9fc8ee45d02bccacd7f46c",
      "candidate_info": {
        "commit_hash": "2ca13a4cc56c920a6c9fc8ee45d02bccacd7f46c",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/2ca13a4cc56c920a6c9fc8ee45d02bccacd7f46c",
        "files": [
          "arch/powerpc/perf/core-book3s.c"
        ],
        "message": "powerpc/perf: Use regs->nip when SIAR is zero\n\nIn power10 DD1, there is an issue where the SIAR (Sampled Instruction\nAddress Register) is not latching to the sampled address during random\nsampling. This results in value of 0s in the SIAR. Add a check to use\nregs->nip when SIAR is zero.\n\nSigned-off-by: Madhavan Srinivasan <maddy@linux.ibm.com>\nSigned-off-by: Michael Ellerman <mpe@ellerman.id.au>\nLink: https://lore.kernel.org/r/20201021085329.384535-5-maddy@linux.ibm.com",
        "before_after_code_files": [
          "arch/powerpc/perf/core-book3s.c||arch/powerpc/perf/core-book3s.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "arch/powerpc/perf/core-book3s.c||arch/powerpc/perf/core-book3s.c"
          ],
          "candidate": [
            "arch/powerpc/perf/core-book3s.c||arch/powerpc/perf/core-book3s.c"
          ]
        }
      },
      "candidate_diff": {
        "arch/powerpc/perf/core-book3s.c||arch/powerpc/perf/core-book3s.c": [
          "File: arch/powerpc/perf/core-book3s.c -> arch/powerpc/perf/core-book3s.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "265:  if (marked && (ppmu->flags & PPMU_P10_DD1)) {",
          "269:  }",
          "",
          "[Removed Lines]",
          "266:   if (is_kernel_addr(mfspr(SPRN_SIAR)))",
          "267:    return PERF_RECORD_MISC_KERNEL;",
          "268:   return PERF_RECORD_MISC_USER;",
          "",
          "[Added Lines]",
          "266:   unsigned long siar = mfspr(SPRN_SIAR);",
          "267:   if (siar) {",
          "268:    if (is_kernel_addr(siar))",
          "269:     return PERF_RECORD_MISC_KERNEL;",
          "270:    return PERF_RECORD_MISC_USER;",
          "271:   } else {",
          "272:    if (is_kernel_addr(regs->nip))",
          "273:     return PERF_RECORD_MISC_KERNEL;",
          "274:    return PERF_RECORD_MISC_USER;",
          "275:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "2199: unsigned long perf_instruction_pointer(struct pt_regs *regs)",
          "2200: {",
          "2201:  bool use_siar = regs_use_siar(regs);",
          "2204:   return mfspr(SPRN_SIAR) + perf_ip_adjust(regs);",
          "2205:  else if (use_siar)",
          "2206:   return 0;  // no valid instruction pointer",
          "",
          "[Removed Lines]",
          "2203:  if (use_siar && siar_valid(regs))",
          "",
          "[Added Lines]",
          "2209:  unsigned long siar = mfspr(SPRN_SIAR);",
          "2211:  if (ppmu->flags & PPMU_P10_DD1) {",
          "2212:   if (siar)",
          "2213:    return siar;",
          "2214:   else",
          "2215:    return regs->nip;",
          "2216:  } else if (use_siar && siar_valid(regs))",
          "",
          "---------------"
        ]
      }
    }
  ]
}
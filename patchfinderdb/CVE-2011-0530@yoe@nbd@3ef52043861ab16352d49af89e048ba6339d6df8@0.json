{
  "cve_id": "CVE-2011-0530",
  "cve_desc": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.",
  "repo": "yoe/nbd",
  "patch_hash": "3ef52043861ab16352d49af89e048ba6339d6df8",
  "patch_info": {
    "commit_hash": "3ef52043861ab16352d49af89e048ba6339d6df8",
    "repo": "yoe/nbd",
    "commit_url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8",
    "files": [
      "nbd-server.c"
    ],
    "message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.",
    "before_after_code_files": [
      "nbd-server.c||nbd-server.c"
    ]
  },
  "patch_diff": {
    "nbd-server.c||nbd-server.c": [
      "File: nbd-server.c -> nbd-server.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1390:   if (request.magic != htonl(NBD_REQUEST_MAGIC))",
      "1391:    err(\"Not enough magic.\");",
      "1393:    err(\"Request too big!\");",
      "1394: #ifdef DODBG",
      "1395:   printf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :",
      "",
      "[Removed Lines]",
      "1392:   if (len > BUFSIZE + sizeof(struct nbd_reply))",
      "",
      "[Added Lines]",
      "1392:   if (len > BUFSIZE - sizeof(struct nbd_reply))",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "236c340cfa713b4ba0f06f57253ebddd2ada28e4",
      "candidate_info": {
        "commit_hash": "236c340cfa713b4ba0f06f57253ebddd2ada28e4",
        "repo": "yoe/nbd",
        "commit_url": "https://github.com/yoe/nbd/commit/236c340cfa713b4ba0f06f57253ebddd2ada28e4",
        "files": [
          "nbd-server.c"
        ],
        "message": "Fix buffer size checking\n\nYes, this means we've re-introduced CVE-2005-3534. Sigh.",
        "before_after_code_files": [
          "nbd-server.c||nbd-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_message": 1,
        "olp_code_files": {
          "patch": [
            "nbd-server.c||nbd-server.c"
          ],
          "candidate": [
            "nbd-server.c||nbd-server.c"
          ]
        }
      },
      "candidate_diff": {
        "nbd-server.c||nbd-server.c": [
          "File: nbd-server.c -> nbd-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1265:   if (request.magic != htonl(NBD_REQUEST_MAGIC))",
          "1266:    err(\"Not enough magic.\");",
          "1268:    err(\"Request too big!\");",
          "1269: #ifdef DODBG",
          "1270:   printf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :",
          "",
          "[Removed Lines]",
          "1267:   if (len > BUFSIZE + sizeof(struct nbd_reply))",
          "",
          "[Added Lines]",
          "1267:   if (len > BUFSIZE - sizeof(struct nbd_reply))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c6efc78b2882500d1a2fd6581e7040063d5fceb5",
      "candidate_info": {
        "commit_hash": "c6efc78b2882500d1a2fd6581e7040063d5fceb5",
        "repo": "yoe/nbd",
        "commit_url": "https://github.com/yoe/nbd/commit/c6efc78b2882500d1a2fd6581e7040063d5fceb5",
        "files": [
          "nbd-server.c"
        ],
        "message": "Fix handling of oversized requests\n\nPreviously, nbd-server would not serve requests that were over 1MB in\nsize. This was a problem, and even a bug since the kernel does send such\nrequests.\n\nModify the server so that it loops if the request is larger than 1MB.",
        "before_after_code_files": [
          "nbd-server.c||nbd-server.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "nbd-server.c||nbd-server.c"
          ],
          "candidate": [
            "nbd-server.c||nbd-server.c"
          ]
        }
      },
      "candidate_diff": {
        "nbd-server.c||nbd-server.c": [
          "File: nbd-server.c -> nbd-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1364:  reply.error = 0;",
          "1365:  while (go_on) {",
          "1366:   char buf[BUFSIZE];",
          "1367:   size_t len;",
          "1368: #ifdef DODBG",
          "1369:   i++;",
          "1370:   printf(\"%d: \", i);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1367:   char* p;",
          "1369:   size_t currlen;",
          "1370:   size_t writelen;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "1390:   if (request.magic != htonl(NBD_REQUEST_MAGIC))",
          "1391:    err(\"Not enough magic.\");",
          "1394: #ifdef DODBG",
          "1395:   printf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :",
          "1396:     \"READ\", (unsigned long long)request.from,",
          "",
          "[Removed Lines]",
          "1392:   if (len > BUFSIZE - sizeof(struct nbd_reply))",
          "1393:    err(\"Request too big!\");",
          "",
          "[Added Lines]",
          "1395:   if (len > BUFSIZE - sizeof(struct nbd_reply)) {",
          "1396:    currlen = BUFSIZE - sizeof(struct nbd_reply);",
          "1397:    msg(\"INFO: oversized request (this is not a problem)\");",
          "1398:   } else {",
          "1399:    currlen = len;",
          "1400:   }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1412:   if (request.type==NBD_CMD_WRITE) {",
          "1413:    DEBUG(\"wr: net->buf, \");",
          "1426:    }",
          "1429:    continue;",
          "1430:   }",
          "1433:   DEBUG(\"exp->buf, \");",
          "1441:   memcpy(buf, &reply, sizeof(struct nbd_reply));",
          "1443:   DEBUG(\"OK!\\n\");",
          "1444:  }",
          "1445:  return 0;",
          "",
          "[Removed Lines]",
          "1414:    readit(client->net, buf, len);",
          "1415:    DEBUG(\"buf->exp, \");",
          "1416:    if ((client->server->flags & F_READONLY) ||",
          "1417:        (client->server->flags & F_AUTOREADONLY)) {",
          "1418:     DEBUG(\"[WRITE to READONLY!]\");",
          "1419:     ERROR(client, reply, EPERM);",
          "1420:     continue;",
          "1421:    }",
          "1422:    if (expwrite(request.from, buf, len, client)) {",
          "1423:     DEBUG(\"Write failed: %m\" );",
          "1424:     ERROR(client, reply, errno);",
          "1425:     continue;",
          "1427:    SEND(client->net, reply);",
          "1428:    DEBUG(\"OK!\\n\");",
          "1434:   if (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {",
          "1435:    DEBUG(\"Read failed: %m\");",
          "1436:    ERROR(client, reply, errno);",
          "1437:    continue;",
          "1438:   }",
          "1440:   DEBUG(\"buf->net, \");",
          "1442:   writeit(client->net, buf, len + sizeof(struct nbd_reply));",
          "",
          "[Added Lines]",
          "1421:    while(len > 0) {",
          "1422:     readit(client->net, buf, currlen);",
          "1423:     DEBUG(\"buf->exp, \");",
          "1424:     if ((client->server->flags & F_READONLY) ||",
          "1425:         (client->server->flags & F_AUTOREADONLY)) {",
          "1426:      DEBUG(\"[WRITE to READONLY!]\");",
          "1427:      ERROR(client, reply, EPERM);",
          "1428:      continue;",
          "1429:     }",
          "1430:     if (expwrite(request.from, buf, len, client)) {",
          "1431:      DEBUG(\"Write failed: %m\" );",
          "1432:      ERROR(client, reply, errno);",
          "1433:      continue;",
          "1434:     }",
          "1435:     SEND(client->net, reply);",
          "1436:     DEBUG(\"OK!\\n\");",
          "1437:     len -= currlen;",
          "1438:     currlen = (len < BUFSIZE) ? len : BUFSIZE;",
          "1446:   p = buf + sizeof(struct nbd_reply);",
          "1447:   writelen = currlen + sizeof(struct nbd_reply);",
          "1448:   while(len > 0) {",
          "1449:    if (expread(request.from, p, currlen, client)) {",
          "1450:     DEBUG(\"Read failed: %m\");",
          "1451:     ERROR(client, reply, errno);",
          "1452:     continue;",
          "1453:    }",
          "1455:    DEBUG(\"buf->net, \");",
          "1456:    writeit(client->net, buf, writelen);",
          "1457:    len -= currlen;",
          "1458:    currlen = (len < BUFSIZE) ? len : BUFSIZE;",
          "1459:    p = buf;",
          "1460:    writelen = currlen;",
          "1461:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9434be09a2a906d52ab113d7352dc5bb5d280314",
      "candidate_info": {
        "commit_hash": "9434be09a2a906d52ab113d7352dc5bb5d280314",
        "repo": "yoe/nbd",
        "commit_url": "https://github.com/yoe/nbd/commit/9434be09a2a906d52ab113d7352dc5bb5d280314",
        "files": [
          "Makefile.am",
          "nbd-server.c",
          "nbd-tester-client.c",
          "simple_test"
        ],
        "message": "Test request blocks that are larger than 1MB, too.",
        "before_after_code_files": [
          "Makefile.am||Makefile.am",
          "nbd-server.c||nbd-server.c",
          "nbd-tester-client.c||nbd-tester-client.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "nbd-server.c||nbd-server.c"
          ],
          "candidate": [
            "nbd-server.c||nbd-server.c"
          ]
        }
      },
      "candidate_diff": {
        "Makefile.am||Makefile.am": [
          "File: Makefile.am -> Makefile.am",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: sbin_PROGRAMS = @NBD_CLIENT_NAME@",
          "4: EXTRA_PROGRAMS = nbd-client knbd-client",
          "5: TESTS_ENVIRONMENT=$(srcdir)/simple_test",
          "7: check_PROGRAMS = nbd-tester-client",
          "8: knbd_client_SOURCES = nbd-client.c cliserv.h",
          "9: nbd_client_SOURCES = nbd-client.c cliserv.h",
          "",
          "[Removed Lines]",
          "6: TESTS = cmd cfg1 cfgmulti cfgnew",
          "",
          "[Added Lines]",
          "6: TESTS = cmd cfg1 cfgmulti cfgnew cfgsize",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "20: cfg1:",
          "21: cfgmulti:",
          "22: cfgnew:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23: cfgsize:",
          "",
          "---------------"
        ],
        "nbd-server.c||nbd-server.c": [
          "File: nbd-server.c -> nbd-server.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1394:    err(\"Not enough magic.\");",
          "1395:   if (len > BUFSIZE - sizeof(struct nbd_reply)) {",
          "1396:    currlen = BUFSIZE - sizeof(struct nbd_reply);",
          "1398:   } else {",
          "1399:    currlen = len;",
          "1400:   }",
          "",
          "[Removed Lines]",
          "1397:    msg(\"INFO: oversized request (this is not a problem)\");",
          "",
          "[Added Lines]",
          "1397:    msg2(LOG_INFO, \"oversized request (this is not a problem)\");",
          "",
          "---------------"
        ],
        "nbd-tester-client.c||nbd-tester-client.c": [
          "File: nbd-tester-client.c -> nbd-tester-client.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "24: #include <stdlib.h>",
          "25: #include <stdio.h>",
          "26: #include <string.h>",
          "27: #include <sys/time.h>",
          "28: #include <sys/types.h>",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "26: #include <stdbool.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "212:  return retval;",
          "213: }",
          "215: int throughput_test(gchar* hostname, int port, char* name, int sock, char sock_is_open, char close_sock) {",
          "216:  long long int i;",
          "217:  char buf[1024];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "216: int oversize_test(gchar* hostname, int port, char* name, int sock, char sock_is_open, char close_sock) {",
          "217:  int retval=0;",
          "218:  struct nbd_request req;",
          "219:  struct nbd_reply rep;",
          "220:  int request=0;",
          "221:  int i=0;",
          "222:  pid_t mypid = getpid();",
          "223:  char buf[((1024*1024)+sizeof(struct nbd_request)/2)<<1];",
          "224:  bool got_err;",
          "227:  if(!sock_is_open) {",
          "228:   if((sock=setup_connection(hostname, port, name, CONNECTION_TYPE_FULL))<0) {",
          "229:    g_warning(\"Could not open socket: %s\", errstr);",
          "230:    retval=-1;",
          "231:    goto err;",
          "232:   }",
          "233:  }",
          "234:  req.magic=htonl(NBD_REQUEST_MAGIC);",
          "235:  req.type=htonl(NBD_CMD_READ);",
          "236:  req.len=htonl(1024*1024);",
          "237:  memcpy(&(req.handle),&i,sizeof(i));",
          "238:  req.from=htonll(i);",
          "239:  write(sock, &req, sizeof(req));",
          "240:  printf(\"%d: testing oversized request: %d: \", getpid(), ntohl(req.len));",
          "241:  read_all(sock, &rep, sizeof(struct nbd_reply));",
          "242:  read_all(sock, &buf, ntohl(req.len));",
          "243:  if(rep.error) {",
          "244:   printf(\"Received unexpected error\\n\");",
          "245:   retval=-1;",
          "246:   goto err;",
          "247:  } else {",
          "248:   printf(\"OK\\n\");",
          "249:  }",
          "251:  i++; req.from=htonll(i);",
          "252:  req.len = htonl(ntohl(req.len) + sizeof(struct nbd_request) / 2);",
          "253:  write(sock, &req, sizeof(req));",
          "254:  printf(\"%d: testing oversized request: %d: \", getpid(), ntohl(req.len));",
          "255:  read_all(sock, &rep, sizeof(struct nbd_reply));",
          "256:  read_all(sock, &buf, ntohl(req.len));",
          "257:  if(rep.error) {",
          "258:   printf(\"Received expected error\\n\");",
          "259:   got_err=true;",
          "260:  } else {",
          "261:   printf(\"OK\\n\");",
          "262:   got_err=false;",
          "263:  }",
          "265:  i++; req.from=htonll(i);",
          "266:  req.len = htonl(ntohl(req.len) << 1);",
          "267:  write(sock, &req, sizeof(req));",
          "268:  printf(\"%d: testing oversized request: %d: \", getpid(), ntohl(req.len));",
          "269:  read_all(sock, &rep, sizeof(struct nbd_reply));",
          "270:  read_all(sock, &buf, ntohl(req.len));",
          "271:  if(rep.error) {",
          "272:   printf(\"error\\n\");",
          "273:  } else {",
          "274:   printf(\"OK\\n\");",
          "275:  }",
          "276:  if((rep.error && !got_err) || (!rep.error && got_err)) {",
          "277:   printf(\"Received unexpected error\\n\");",
          "278:   retval=-1;",
          "279:  }",
          "280:   err:",
          "281:  return retval;",
          "282: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "315:   speed>>=10;",
          "316:   speedchar[0]='G';",
          "317:  }",
          "320: err_open:",
          "321:  if(close_sock) {",
          "",
          "[Removed Lines]",
          "318:  g_message(\"%d: Throughput test complete. Took %.3f seconds to complete, %d%sB/s\", (int)getpid(), timespan,speed,speedchar);",
          "",
          "[Added Lines]",
          "387:  g_message(\"%d: Throughput test complete. Took %.3f seconds to complete, %d%siB/s\", (int)getpid(), timespan,speed,speedchar);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "325:  return retval;",
          "326: }",
          "328: int main(int argc, char**argv) {",
          "329:  gchar *hostname;",
          "330:  long int p = 0;",
          "332:  char* name = NULL;",
          "333:  int sock=0;",
          "335:  if(argc<3) {",
          "336:   g_message(\"%d: Not enough arguments\", (int)getpid());",
          "",
          "[Removed Lines]",
          "331:  int port;",
          "",
          "[Added Lines]",
          "397: typedef int (*testfunc)(gchar*, int, char*, int, char, char);",
          "404:  char c;",
          "405:  bool want_port = TRUE;",
          "406:  int nonopt=0;",
          "407:  testfunc test = throughput_test;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "339:   exit(EXIT_FAILURE);",
          "340:  }",
          "341:  logging();",
          "351:   }",
          "352:  }",
          "357:   exit(EXIT_FAILURE);",
          "358:  }",
          "",
          "[Removed Lines]",
          "342:  hostname=g_strdup(argv[1]);",
          "343:  if(!strncmp(argv[2], \"-N\", 2)) {",
          "344:   name = g_strdup(argv[3]);",
          "345:   p = 10809;",
          "346:  } else {",
          "347:   p=(strtol(argv[2], NULL, 0));",
          "348:   if(p==LONG_MIN||p==LONG_MAX) {",
          "349:    g_critical(\"Could not parse port number: %s\", strerror(errno));",
          "350:    exit(EXIT_FAILURE);",
          "353:  port=(int)p;",
          "355:  if(throughput_test(hostname, port, name, sock, FALSE, TRUE)<0) {",
          "356:   g_warning(\"Could not run throughput test: %s\", errstr);",
          "",
          "[Added Lines]",
          "416:  while((c=getopt(argc, argv, \"-N:o\"))>=0) {",
          "417:   switch(c) {",
          "418:    case 1:",
          "419:     switch(nonopt) {",
          "420:      case 0:",
          "421:       hostname=g_strdup(optarg);",
          "422:       nonopt++;",
          "423:       break;",
          "424:      case 1:",
          "425:       if(want_port)",
          "426:       p=(strtol(argv[2], NULL, 0));",
          "427:       if(p==LONG_MIN||p==LONG_MAX) {",
          "428:        g_critical(\"Could not parse port number: %s\", strerror(errno));",
          "429:        exit(EXIT_FAILURE);",
          "430:       }",
          "431:       break;",
          "432:     }",
          "433:     break;",
          "434:    case 'N':",
          "435:     name=g_strdup(optarg);",
          "436:     p = 10809;",
          "437:     want_port = false;",
          "438:     break;",
          "439:    case 'o':",
          "440:     test=oversize_test;",
          "441:     break;",
          "445:  if(test(hostname, (int)p, name, sock, FALSE, TRUE)<0) {",
          "446:   g_warning(\"Could not run test: %s\", errstr);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
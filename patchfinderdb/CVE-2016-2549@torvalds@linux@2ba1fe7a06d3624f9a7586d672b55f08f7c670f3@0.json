{
  "cve_id": "CVE-2016-2549",
  "cve_desc": "sound/core/hrtimer.c in the Linux kernel before 4.4.1 does not prevent recursive callback access, which allows local users to cause a denial of service (deadlock) via a crafted ioctl call.",
  "repo": "torvalds/linux",
  "patch_hash": "2ba1fe7a06d3624f9a7586d672b55f08f7c670f3",
  "patch_info": {
    "commit_hash": "2ba1fe7a06d3624f9a7586d672b55f08f7c670f3",
    "repo": "torvalds/linux",
    "commit_url": "https://github.com/torvalds/linux/commit/2ba1fe7a06d3624f9a7586d672b55f08f7c670f3",
    "files": [
      "sound/core/hrtimer.c"
    ],
    "message": "ALSA: hrtimer: Fix stall by hrtimer_cancel()\n\nhrtimer_cancel() waits for the completion from the callback, thus it\nmust not be called inside the callback itself.  This was already a\nproblem in the past with ALSA hrtimer driver, and the early commit\n[fcfdebe70759: ALSA: hrtimer - Fix lock-up] tried to address it.\n\nHowever, the previous fix is still insufficient: it may still cause a\nlockup when the ALSA timer instance reprograms itself in its callback.\nThen it invokes the start function even in snd_timer_interrupt() that\nis called in hrtimer callback itself, results in a CPU stall.  This is\nno hypothetical problem but actually triggered by syzkaller fuzzer.\n\nThis patch tries to fix the issue again.  Now we call\nhrtimer_try_to_cancel() at both start and stop functions so that it\nwon't fall into a deadlock, yet giving some chance to cancel the queue\nif the functions have been called outside the callback.  The proper\nhrtimer_cancel() is called in anyway at closing, so this should be\nenough.\n\nReported-and-tested-by: Dmitry Vyukov <dvyukov@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
    "before_after_code_files": [
      "sound/core/hrtimer.c||sound/core/hrtimer.c"
    ]
  },
  "patch_diff": {
    "sound/core/hrtimer.c||sound/core/hrtimer.c": [
      "File: sound/core/hrtimer.c -> sound/core/hrtimer.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "90:  struct snd_hrtimer *stime = t->private_data;",
      "92:  atomic_set(&stime->running, 0);",
      "94:  hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),",
      "95:         HRTIMER_MODE_REL);",
      "96:  atomic_set(&stime->running, 1);",
      "",
      "[Removed Lines]",
      "93:  hrtimer_cancel(&stime->hrt);",
      "",
      "[Added Lines]",
      "93:  hrtimer_try_to_cancel(&stime->hrt);",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "101: {",
      "102:  struct snd_hrtimer *stime = t->private_data;",
      "103:  atomic_set(&stime->running, 0);",
      "104:  return 0;",
      "105: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "104:  hrtimer_try_to_cancel(&stime->hrt);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "d2c5cf88d5282de258f4eb6ab40040b80a075cd8",
      "candidate_info": {
        "commit_hash": "d2c5cf88d5282de258f4eb6ab40040b80a075cd8",
        "repo": "torvalds/linux",
        "commit_url": "https://github.com/torvalds/linux/commit/d2c5cf88d5282de258f4eb6ab40040b80a075cd8",
        "files": [
          "sound/core/hrtimer.c"
        ],
        "message": "ALSA: hrtimer: Handle start/stop more properly\n\nThis patch tries to address the still remaining issues in ALSA hrtimer\ndriver:\n- Spurious use-after-free was detected in hrtimer callback\n- Incorrect rescheduling due to delayed start\n- WARN_ON() is triggered in hrtimer_forward() invoked in hrtimer\n  callback\n\nThe first issue happens only when the new timer is scheduled even\nwhile hrtimer is being closed.  It's related with the second and third\nitems; since ALSA timer core invokes hw.start callback during hrtimer\ninterrupt, this may result in the explicit call of hrtimer_start().\n\nAlso, the similar problem is seen for the stop; ALSA timer core\ninvokes hw.stop callback even in the hrtimer handler, too.  Since we\nmust not call the synced hrtimer_cancel() in such a context, it's just\na hrtimer_try_to_cancel() call that doesn't properly work.\n\nAnother culprit of the second and third items is the call of\nhrtimer_forward_now() before snd_timer_interrupt().  The timer->stick\nvalue may change during snd_timer_interrupt() call, but this\npossibility is ignored completely.\n\nFor covering these subtle and messy issues, the following changes have\nbeen done in this patch:\n- A new flag, in_callback, is introduced in the private data to\n  indicate that the hrtimer handler is being processed.\n- Both start and stop callbacks skip when called from (during)\n  in_callback flag.\n- The hrtimer handler returns properly HRTIMER_RESTART and NORESTART\n  depending on the running state now.\n- The hrtimer handler reprograms the expiry properly after\n  snd_timer_interrupt() call, instead of before.\n- The close callback clears running flag and sets in_callback flag\n  to block any further start/stop calls.\n\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "before_after_code_files": [
          "sound/core/hrtimer.c||sound/core/hrtimer.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "sound/core/hrtimer.c||sound/core/hrtimer.c"
          ],
          "candidate": [
            "sound/core/hrtimer.c||sound/core/hrtimer.c"
          ]
        }
      },
      "candidate_diff": {
        "sound/core/hrtimer.c||sound/core/hrtimer.c": [
          "File: sound/core/hrtimer.c -> sound/core/hrtimer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "38: struct snd_hrtimer {",
          "39:  struct snd_timer *timer;",
          "40:  struct hrtimer hrt;",
          "42: };",
          "44: static enum hrtimer_restart snd_hrtimer_callback(struct hrtimer *hrt)",
          "45: {",
          "46:  struct snd_hrtimer *stime = container_of(hrt, struct snd_hrtimer, hrt);",
          "47:  struct snd_timer *t = stime->timer;",
          "59: }",
          "61: static int snd_hrtimer_open(struct snd_timer *t)",
          "62: {",
          "63:  struct snd_hrtimer *stime;",
          "66:  if (!stime)",
          "67:   return -ENOMEM;",
          "68:  hrtimer_init(&stime->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);",
          "69:  stime->timer = t;",
          "70:  stime->hrt.function = snd_hrtimer_callback;",
          "72:  t->private_data = stime;",
          "73:  return 0;",
          "74: }",
          "",
          "[Removed Lines]",
          "41:  atomic_t running;",
          "48:  unsigned long oruns;",
          "50:  if (!atomic_read(&stime->running))",
          "51:   return HRTIMER_NORESTART;",
          "53:  oruns = hrtimer_forward_now(hrt, ns_to_ktime(t->sticks * resolution));",
          "54:  snd_timer_interrupt(stime->timer, t->sticks * oruns);",
          "56:  if (!atomic_read(&stime->running))",
          "57:   return HRTIMER_NORESTART;",
          "58:  return HRTIMER_RESTART;",
          "65:  stime = kmalloc(sizeof(*stime), GFP_KERNEL);",
          "71:  atomic_set(&stime->running, 0);",
          "",
          "[Added Lines]",
          "41:  bool in_callback;",
          "48:  ktime_t delta;",
          "49:  unsigned long ticks;",
          "50:  enum hrtimer_restart ret = HRTIMER_NORESTART;",
          "52:  spin_lock(&t->lock);",
          "53:  if (!t->running)",
          "55:  stime->in_callback = true;",
          "56:  ticks = t->sticks;",
          "57:  spin_unlock(&t->lock);",
          "60:  delta = ktime_sub(hrt->base->get_time(), hrtimer_get_expires(hrt));",
          "61:  if (delta.tv64 > 0)",
          "62:   ticks += ktime_divns(delta, ticks * resolution);",
          "64:  snd_timer_interrupt(stime->timer, ticks);",
          "66:  spin_lock(&t->lock);",
          "67:  if (t->running) {",
          "68:   hrtimer_add_expires_ns(hrt, t->sticks * resolution);",
          "69:   ret = HRTIMER_RESTART;",
          "70:  }",
          "72:  stime->in_callback = false;",
          "73:  out:",
          "74:  spin_unlock(&t->lock);",
          "75:  return ret;",
          "82:  stime = kzalloc(sizeof(*stime), GFP_KERNEL);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "78:  struct snd_hrtimer *stime = t->private_data;",
          "80:  if (stime) {",
          "81:   hrtimer_cancel(&stime->hrt);",
          "82:   kfree(stime);",
          "83:   t->private_data = NULL;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "97:   spin_lock_irq(&t->lock);",
          "100:   spin_unlock_irq(&t->lock);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "89: {",
          "90:  struct snd_hrtimer *stime = t->private_data;",
          "94:  hrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),",
          "95:         HRTIMER_MODE_REL);",
          "97:  return 0;",
          "98: }",
          "100: static int snd_hrtimer_stop(struct snd_timer *t)",
          "101: {",
          "102:  struct snd_hrtimer *stime = t->private_data;",
          "104:  hrtimer_try_to_cancel(&stime->hrt);",
          "105:  return 0;",
          "106: }",
          "",
          "[Removed Lines]",
          "92:  atomic_set(&stime->running, 0);",
          "93:  hrtimer_try_to_cancel(&stime->hrt);",
          "96:  atomic_set(&stime->running, 1);",
          "103:  atomic_set(&stime->running, 0);",
          "",
          "[Added Lines]",
          "113:  if (stime->in_callback)",
          "114:   return 0;",
          "124:  if (stime->in_callback)",
          "125:   return 0;",
          "",
          "---------------"
        ]
      }
    }
  ]
}
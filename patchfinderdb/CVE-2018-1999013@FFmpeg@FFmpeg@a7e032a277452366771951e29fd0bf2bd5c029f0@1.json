{
  "cve_id": "CVE-2018-1999013",
  "cve_desc": "FFmpeg before commit a7e032a277452366771951e29fd0bf2bd5c029f0 contains a use-after-free vulnerability in the realmedia demuxer that can result in vulnerability allows attacker to read heap memory. This attack appear to be exploitable via specially crafted RM file has to be provided as input. This vulnerability appears to have been fixed in a7e032a277452366771951e29fd0bf2bd5c029f0 and later.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "a7e032a277452366771951e29fd0bf2bd5c029f0",
  "patch_info": {
    "commit_hash": "a7e032a277452366771951e29fd0bf2bd5c029f0",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/a7e032a277452366771951e29fd0bf2bd5c029f0",
    "files": [
      "libavformat/rmdec.c"
    ],
    "message": "avformat/rmdec: Do not pass mime type in rm_read_multi() to ff_rm_read_mdpr_codecdata()\n\nFixes: use after free()\nFixes: rmdec-crash-ffe85b4cab1597d1cfea6955705e53f1f5c8a362\n\nFound-by: Paul Ch <paulcher@icloud.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavformat/rmdec.c||libavformat/rmdec.c"
    ]
  },
  "patch_diff": {
    "libavformat/rmdec.c||libavformat/rmdec.c": [
      "File: libavformat/rmdec.c -> libavformat/rmdec.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "523:         size2 = avio_rb32(pb);",
      "524:         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,",
      "526:         if (ret < 0)",
      "527:             return ret;",
      "528:     }",
      "",
      "[Removed Lines]",
      "525:                                         size2, mime);",
      "",
      "[Added Lines]",
      "525:                                         size2, NULL);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "35bbc1955a58ba74552c50d9161084644f00bbd3",
      "candidate_info": {
        "commit_hash": "35bbc1955a58ba74552c50d9161084644f00bbd3",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/35bbc1955a58ba74552c50d9161084644f00bbd3",
        "files": [
          "Changelog",
          "doc/general.texi",
          "libavformat/Makefile",
          "libavformat/allformats.c",
          "libavformat/rmdec.c",
          "libavformat/version.h"
        ],
        "message": "avformat: add IVR demuxer\n\nSigned-off-by: Paul B Mahol <onemda@gmail.com>",
        "before_after_code_files": [
          "libavformat/allformats.c||libavformat/allformats.c",
          "libavformat/rmdec.c||libavformat/rmdec.c",
          "libavformat/version.h||libavformat/version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavformat/rmdec.c||libavformat/rmdec.c"
          ],
          "candidate": [
            "libavformat/rmdec.c||libavformat/rmdec.c"
          ]
        }
      },
      "candidate_diff": {
        "libavformat/allformats.c||libavformat/allformats.c": [
          "File: libavformat/allformats.c -> libavformat/allformats.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "169:     REGISTER_DEMUXER (ISS,              iss);",
          "170:     REGISTER_DEMUXER (IV8,              iv8);",
          "171:     REGISTER_MUXDEMUX(IVF,              ivf);",
          "172:     REGISTER_MUXDEMUX(JACOSUB,          jacosub);",
          "173:     REGISTER_DEMUXER (JV,               jv);",
          "174:     REGISTER_MUXER   (LATM,             latm);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "172:     REGISTER_DEMUXER (IVR,              ivr);",
          "",
          "---------------"
        ],
        "libavformat/rmdec.c||libavformat/rmdec.c": [
          "File: libavformat/rmdec.c -> libavformat/rmdec.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "63:     int remaining_len;",
          "64:     int audio_stream_num; ///< Stream number for audio packets",
          "65:     int audio_pkt_cnt; ///< Output packet counter",
          "66: } RMDemuxContext;",
          "68: static int rm_read_close(AVFormatContext *s);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "66:     int data_end;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "488:     return rm_read_audio_stream_info(s, s->pb, st, st->priv_data, 1);",
          "489: }",
          "491: static int rm_read_header(AVFormatContext *s)",
          "492: {",
          "493:     RMDemuxContext *rm = s->priv_data;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "492: static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,",
          "493:                          AVStream *st, char *mime)",
          "494: {",
          "495:     int number_of_streams = avio_rb16(pb);",
          "496:     int number_of_mdpr;",
          "497:     int i, ret;",
          "498:     unsigned size2;",
          "499:     for (i = 0; i<number_of_streams; i++)",
          "500:         avio_rb16(pb);",
          "501:     number_of_mdpr = avio_rb16(pb);",
          "502:     if (number_of_mdpr != 1) {",
          "503:         avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);",
          "504:     }",
          "505:     for (i = 0; i < number_of_mdpr; i++) {",
          "506:         AVStream *st2;",
          "507:         if (i > 0) {",
          "508:             st2 = avformat_new_stream(s, NULL);",
          "509:             if (!st2) {",
          "510:                 ret = AVERROR(ENOMEM);",
          "511:                 return ret;",
          "512:             }",
          "513:             st2->id = st->id + (i<<16);",
          "514:             st2->codec->bit_rate = st->codec->bit_rate;",
          "515:             st2->start_time = st->start_time;",
          "516:             st2->duration   = st->duration;",
          "517:             st2->codec->codec_type = AVMEDIA_TYPE_DATA;",
          "518:             st2->priv_data = ff_rm_alloc_rmstream();",
          "519:             if (!st2->priv_data)",
          "520:                 return AVERROR(ENOMEM);",
          "521:         } else",
          "522:             st2 = st;",
          "524:         size2 = avio_rb32(pb);",
          "525:         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,",
          "526:                                         size2, mime);",
          "527:         if (ret < 0)",
          "528:             return ret;",
          "529:     }",
          "530:     return 0;",
          "531: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "579:             ffio_ensure_seekback(pb, 4);",
          "580:             v = avio_rb32(pb);",
          "581:             if (v == MKBETAG('M', 'L', 'T', 'I')) {",
          "616:                 avio_seek(pb, codec_pos + size, SEEK_SET);",
          "617:             } else {",
          "618:                 avio_skip(pb, -4);",
          "",
          "[Removed Lines]",
          "582:                 int number_of_streams = avio_rb16(pb);",
          "583:                 int number_of_mdpr;",
          "584:                 int i;",
          "585:                 unsigned size2;",
          "586:                 for (i = 0; i<number_of_streams; i++)",
          "587:                     avio_rb16(pb);",
          "588:                 number_of_mdpr = avio_rb16(pb);",
          "589:                 if (number_of_mdpr != 1) {",
          "590:                     avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);",
          "591:                 }",
          "592:                 for (i = 0; i < number_of_mdpr; i++) {",
          "593:                     AVStream *st2;",
          "594:                     if (i > 0) {",
          "595:                         st2 = avformat_new_stream(s, NULL);",
          "596:                         if (!st2) {",
          "597:                             ret = AVERROR(ENOMEM);",
          "598:                             goto fail;",
          "599:                         }",
          "600:                         st2->id = st->id + (i<<16);",
          "601:                         st2->codec->bit_rate = st->codec->bit_rate;",
          "602:                         st2->start_time = st->start_time;",
          "603:                         st2->duration   = st->duration;",
          "604:                         st2->codec->codec_type = AVMEDIA_TYPE_DATA;",
          "605:                         st2->priv_data = ff_rm_alloc_rmstream();",
          "606:                         if (!st2->priv_data)",
          "607:                             return AVERROR(ENOMEM);",
          "608:                     } else",
          "609:                         st2 = st;",
          "611:                     size2 = avio_rb32(pb);",
          "612:                     if (ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,",
          "613:                                                   size2, mime) < 0)",
          "614:                         goto fail;",
          "615:                 }",
          "",
          "[Added Lines]",
          "624:                 ret = rm_read_multi(s, s->pb, st, mime);",
          "625:                 if (ret < 0)",
          "626:                     goto fail;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1155:     .read_close     = rm_read_close,",
          "1156:     .flags          = AVFMT_NOFILE,",
          "1157: };",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1170: static int ivr_probe(AVProbeData *p)",
          "1171: {",
          "1172:     if (memcmp(p->buf, \".R1M\\x0\\x1\\x1\", 7) &&",
          "1173:         memcmp(p->buf, \".REC\", 4))",
          "1174:         return 0;",
          "1176:     return AVPROBE_SCORE_MAX;",
          "1177: }",
          "1179: static int ivr_read_header(AVFormatContext *s)",
          "1180: {",
          "1181:     unsigned tag, type, len, tlen, value;",
          "1182:     int i, j, n, count, nb_streams, ret;",
          "1183:     uint8_t key[256], val[256];",
          "1184:     AVIOContext *pb = s->pb;",
          "1185:     AVStream *st;",
          "1186:     int64_t pos, offset, temp;",
          "1188:     pos = avio_tell(pb);",
          "1189:     tag = avio_rl32(pb);",
          "1190:     if (tag == MKTAG('.','R','1','M')) {",
          "1191:         if (avio_rb16(pb) != 1)",
          "1192:             return AVERROR_INVALIDDATA;",
          "1193:         if (avio_r8(pb) != 1)",
          "1194:             return AVERROR_INVALIDDATA;",
          "1195:         len = avio_rb32(pb);",
          "1196:         avio_skip(pb, len);",
          "1197:         avio_skip(pb, 5);",
          "1198:         temp = avio_rb64(pb);",
          "1199:         while (!avio_feof(pb) && temp) {",
          "1200:             offset = temp;",
          "1201:             temp = avio_rb64(pb);",
          "1202:         }",
          "1203:         avio_skip(pb, offset - avio_tell(pb));",
          "1204:         if (avio_r8(pb) != 1)",
          "1205:             return AVERROR_INVALIDDATA;",
          "1206:         len = avio_rb32(pb);",
          "1207:         avio_skip(pb, len);",
          "1208:         if (avio_r8(pb) != 2)",
          "1209:             return AVERROR_INVALIDDATA;",
          "1210:         avio_skip(pb, 16);",
          "1211:         pos = avio_tell(pb);",
          "1212:         tag = avio_rl32(pb);",
          "1213:     }",
          "1215:     if (tag != MKTAG('.','R','E','C'))",
          "1216:         return AVERROR_INVALIDDATA;",
          "1218:     if (avio_r8(pb) != 0)",
          "1219:         return AVERROR_INVALIDDATA;",
          "1220:     count = avio_rb32(pb);",
          "1221:     for (i = 0; i < count; i++) {",
          "1222:         if (avio_feof(pb))",
          "1223:             return AVERROR_INVALIDDATA;",
          "1225:         type = avio_r8(pb);",
          "1226:         tlen = avio_rb32(pb);",
          "1227:         avio_get_str(pb, tlen, key, sizeof(key));",
          "1228:         len = avio_rb32(pb);",
          "1229:         if (type == 5) {",
          "1230:             avio_get_str(pb, len, val, sizeof(val));",
          "1231:             av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);",
          "1232:         } else if (type == 4) {",
          "1233:             av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);",
          "1234:             for (j = 0; j < len; j++)",
          "1235:                 av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));",
          "1236:             av_log(s, AV_LOG_DEBUG, \"'\\n\");",
          "1237:         } else if (len == 4 && type == 3 && !strncmp(key, \"StreamCount\", tlen)) {",
          "1238:             nb_streams = value = avio_rb32(pb);",
          "1239:         } else if (len == 4 && type == 3) {",
          "1240:             value = avio_rb32(pb);",
          "1241:             av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);",
          "1242:         } else {",
          "1243:             av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);",
          "1244:             avio_skip(pb, len);",
          "1245:         }",
          "1246:     }",
          "1248:     for (n = 0; n < nb_streams; n++) {",
          "1249:         st = avformat_new_stream(s, NULL);",
          "1250:         if (!st)",
          "1251:             return AVERROR(ENOMEM);",
          "1252:         st->priv_data = ff_rm_alloc_rmstream();",
          "1253:         if (!st->priv_data)",
          "1254:             return AVERROR(ENOMEM);",
          "1256:         if (avio_r8(pb) != 1)",
          "1257:             return AVERROR_INVALIDDATA;",
          "1259:         count = avio_rb32(pb);",
          "1260:         for (i = 0; i < count; i++) {",
          "1261:             if (avio_feof(pb))",
          "1262:                 return AVERROR_INVALIDDATA;",
          "1264:             type = avio_r8(pb);",
          "1265:             tlen  = avio_rb32(pb);",
          "1266:             avio_get_str(pb, tlen, key, sizeof(key));",
          "1267:             len  = avio_rb32(pb);",
          "1268:             if (type == 5) {",
          "1269:                 avio_get_str(pb, len, val, sizeof(val));",
          "1270:                 av_log(s, AV_LOG_DEBUG, \"%s = '%s'\\n\", key, val);",
          "1271:             } else if (type == 4 && !strncmp(key, \"OpaqueData\", tlen)) {",
          "1272:                 ret = ffio_ensure_seekback(pb, 4);",
          "1273:                 if (ret < 0)",
          "1274:                     return ret;",
          "1275:                 if (avio_rb32(pb) == MKBETAG('M', 'L', 'T', 'I')) {",
          "1276:                     ret = rm_read_multi(s, pb, st, NULL);",
          "1277:                 } else {",
          "1278:                     avio_seek(pb, -4, SEEK_CUR);",
          "1279:                     ret = ff_rm_read_mdpr_codecdata(s, pb, st, st->priv_data, len, NULL);",
          "1280:                 }",
          "1282:                 if (ret < 0)",
          "1283:                     return ret;",
          "1284:             } else if (type == 4) {",
          "1285:                 int j;",
          "1287:                 av_log(s, AV_LOG_DEBUG, \"%s = '0x\", key);",
          "1288:                 for (j = 0; j < len; j++)",
          "1289:                     av_log(s, AV_LOG_DEBUG, \"%X\", avio_r8(pb));",
          "1290:                 av_log(s, AV_LOG_DEBUG, \"'\\n\");",
          "1291:             } else if (len == 4 && type == 3 && !strncmp(key, \"Duration\", tlen)) {",
          "1292:                 st->duration = avio_rb32(pb);",
          "1293:             } else if (len == 4 && type == 3) {",
          "1294:                 value = avio_rb32(pb);",
          "1295:                 av_log(s, AV_LOG_DEBUG, \"%s = %d\\n\", key, value);",
          "1296:             } else {",
          "1297:                 av_log(s, AV_LOG_DEBUG, \"Skipping unsupported key: %s\\n\", key);",
          "1298:                 avio_skip(pb, len);",
          "1299:             }",
          "1300:         }",
          "1301:     }",
          "1303:     if (avio_r8(pb) != 6)",
          "1304:         return AVERROR_INVALIDDATA;",
          "1305:     avio_skip(pb, 12);",
          "1306:     avio_skip(pb, avio_rb64(pb) + pos - avio_tell(s->pb));",
          "1307:     if (avio_r8(pb) != 8)",
          "1308:         return AVERROR_INVALIDDATA;",
          "1309:     avio_skip(pb, 8);",
          "1311:     return 0;",
          "1312: }",
          "1314: static int ivr_read_packet(AVFormatContext *s, AVPacket *pkt)",
          "1315: {",
          "1316:     RMDemuxContext *rm = s->priv_data;",
          "1317:     int ret = AVERROR_EOF, opcode;",
          "1318:     AVIOContext *pb = s->pb;",
          "1319:     unsigned size, index;",
          "1320:     int64_t pos, pts;",
          "1322:     if (avio_feof(pb) || rm->data_end)",
          "1323:         return AVERROR_EOF;",
          "1325:     pos = avio_tell(pb);",
          "1327:     for (;;) {",
          "1328:         if (rm->audio_pkt_cnt) {",
          "1330:             AVStream *st;",
          "1332:             st = s->streams[rm->audio_stream_num];",
          "1333:             ret = ff_rm_retrieve_cache(s, pb, st, st->priv_data, pkt);",
          "1334:             if (ret < 0) {",
          "1335:                 return ret;",
          "1336:             }",
          "1337:         } else {",
          "1338:             if (rm->remaining_len) {",
          "1339:                 avio_skip(pb, rm->remaining_len);",
          "1340:                 rm->remaining_len = 0;",
          "1341:             }",
          "1343:             if (avio_feof(pb))",
          "1344:                 return AVERROR_EOF;",
          "1346:             opcode = avio_r8(pb);",
          "1347:             if (opcode == 2) {",
          "1348:                 AVStream *st;",
          "1349:                 int seq = 1;",
          "1351:                 pts = avio_rb32(pb);",
          "1352:                 index = avio_rb16(pb);",
          "1353:                 if (index >= s->nb_streams)",
          "1354:                     return AVERROR_INVALIDDATA;",
          "1356:                 avio_skip(pb, 4);",
          "1357:                 size = avio_rb32(pb);",
          "1358:                 avio_skip(pb, 4);",
          "1360:                 st = s->streams[index];",
          "1361:                 ret = ff_rm_parse_packet(s, pb, st, st->priv_data, size, pkt,",
          "1362:                                          &seq, 0, pts);",
          "1363:                 if (ret < -1) {",
          "1364:                     return ret;",
          "1365:                 } else if (ret) {",
          "1366:                     continue;",
          "1367:                 }",
          "1369:                 pkt->pos = pos;",
          "1370:                 pkt->pts = pts;",
          "1371:                 pkt->stream_index = index;",
          "1372:             } else if (opcode == 7) {",
          "1373:                 pos = avio_rb64(pb);",
          "1374:                 if (!pos) {",
          "1375:                     rm->data_end = 1;",
          "1376:                     return AVERROR_EOF;",
          "1377:                 }",
          "1378:             } else {",
          "1379:                 av_log(s, AV_LOG_ERROR, \"Unsupported opcode=%d at %lX\\n\", opcode, avio_tell(pb) - 1);",
          "1380:                 return AVERROR(EIO);",
          "1381:             }",
          "1382:         }",
          "1384:         break;",
          "1385:     }",
          "1387:     return ret;",
          "1388: }",
          "1390: AVInputFormat ff_ivr_demuxer = {",
          "1391:     .name           = \"ivr\",",
          "1392:     .long_name      = NULL_IF_CONFIG_SMALL(\"IVR (Internet Video Recording)\"),",
          "1393:     .priv_data_size = sizeof(RMDemuxContext),",
          "1394:     .read_probe     = ivr_probe,",
          "1395:     .read_header    = ivr_read_header,",
          "1396:     .read_packet    = ivr_read_packet,",
          "1397:     .extensions     = \"ivr\",",
          "1398: };",
          "",
          "---------------"
        ],
        "libavformat/version.h||libavformat/version.h": [
          "File: libavformat/version.h -> libavformat/version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "30: #include \"libavutil/version.h\"",
          "32: #define LIBAVFORMAT_VERSION_MAJOR  57",
          "34: #define LIBAVFORMAT_VERSION_MICRO 100",
          "36: #define LIBAVFORMAT_VERSION_INT AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, \\",
          "",
          "[Removed Lines]",
          "33: #define LIBAVFORMAT_VERSION_MINOR  14",
          "",
          "[Added Lines]",
          "33: #define LIBAVFORMAT_VERSION_MINOR  15",
          "",
          "---------------"
        ]
      }
    }
  ]
}
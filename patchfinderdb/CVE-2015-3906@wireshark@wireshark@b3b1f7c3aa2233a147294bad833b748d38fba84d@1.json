{
  "cve_id": "CVE-2015-3906",
  "cve_desc": "The logcat_dump_text function in wiretap/logcat.c in the Android Logcat file parser in Wireshark 1.12.x before 1.12.5 does not properly handle a lack of \\0 termination, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted message in a packet, a different vulnerability than CVE-2015-3815.",
  "repo": "wireshark/wireshark",
  "patch_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
  "patch_info": {
    "commit_hash": "b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "repo": "wireshark/wireshark",
    "commit_url": "https://github.com/wireshark/wireshark/commit/b3b1f7c3aa2233a147294bad833b748d38fba84d",
    "files": [
      "wiretap/logcat.c"
    ],
    "message": "logcat: improve (crash) robustness, improve names\n\nThe logcat version detector would crash with ASAN enabled because it did\nnot validate the payload length and hence a payload length of 0 would\ntrigger out-of-bounds access. (This happened on non-logcat data.)\n\nThis patch tries to get rid of all magic numbers by using a structure,\nimproves the version detector to validate the payload length and\nprevents crashes due to missing nul-terminators in the input. Older\nAndroid kernels would create entries with __pad with random contents, so\nthat cannot be used to determine version for v1. Instead, use heuristics\non the priority, tag and maybe the msg field.\n\nFurthermore, Android is mostly (if not, always?) Little-Endian, so add\nconversions where necessary (just in case WS supports BE arches).\n\n\"microseconds\" has been renamed to \"milliseconds\" because that is what\nthey are, actually. A duplicate logcat_log loop has been refactored\nsuch that one loop is sufficient, instead of separate buffers for each\nlog part, a single one is now used. get_priority does not really need\na pointer, just make it accept a character.\n\nThe output has been validated against v1 and v2 logcat binary formats\nwith __pad (hdr_size) equal to 0, and on attachment 9906.\n\nChange-Id: I46c8813e76fe705b293ffdee85b4c1bfff7d8362\nReviewed-on: https://code.wireshark.org/review/2803\nReviewed-by: Michal Labedzki <michal.labedzki@tieto.com>\nTested-by: Michal Labedzki <michal.labedzki@tieto.com>",
    "before_after_code_files": [
      "wiretap/logcat.c||wiretap/logcat.c"
    ]
  },
  "patch_diff": {
    "wiretap/logcat.c||wiretap/logcat.c": [
      "File: wiretap/logcat.c -> wiretap/logcat.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "43:     enum dump_type_t type;",
      "44: };",
      "47:     static gchar priorities[] = \"??VDIWEFS\";",
      "50:         return '?';",
      "53: }",
      "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
      "57:         const gchar *log)",
      "58: {",
      "59:     gchar  time_buffer[15];",
      "",
      "[Removed Lines]",
      "46: static gchar get_priority(const guint8 *priority) {",
      "49:     if (*priority >= (guint8) sizeof(priorities))",
      "52:     return priorities[(int) *priority];",
      "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "[Added Lines]",
      "51: #define LOGGER_ENTRY_MAX_PAYLOAD 4076",
      "53: struct logger_entry {",
      "61: };",
      "63: struct logger_entry_v2 {",
      "70:     union {",
      "74:     };",
      "76: };",
      "79: static gchar get_priority(const guint8 priority) {",
      "82:     if (priority >= (guint8) sizeof(priorities))",
      "85:     return priorities[priority];",
      "89:         gint milliseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "80:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "81:                     gmtime(&datetime));",
      "82:             return g_strdup_printf(\"%s.%03i %c/%-8s(%5i): %s\\n\",",
      "84:         case DUMP_THREADTIME:",
      "85:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "86:                     gmtime(&datetime));",
      "87:             return g_strdup_printf(\"%s.%03i %5i %5i %c %-8s: %s\\n\",",
      "89:         case DUMP_LONG:",
      "90:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
      "91:                     gmtime(&datetime));",
      "92:             return g_strdup_printf(\"[ %s.%03i %5i:0x%02x %c/%s ]\\n%s\\n\\n\",",
      "94:         default:",
      "95:             return NULL;",
      "96:     }",
      "",
      "[Removed Lines]",
      "83:                     time_buffer, microseconds, priority, tag, pid, log);",
      "88:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "93:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
      "",
      "[Added Lines]",
      "116:                     time_buffer, milliseconds, priority, tag, pid, log);",
      "121:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "126:                     time_buffer, milliseconds, pid, tid, priority, tag, log);",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "100: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
      "101: {",
      "113:     bytes_read = file_read(&tmp, 2, wth->fh);",
      "114:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "102:     gint     bytes_read;",
      "103:     guint16  payload_length;",
      "104:     guint16  try_header_size;",
      "105:     guint8  *buffer;",
      "106:     gint64   file_offset;",
      "107:     guint32  log_length;",
      "108:     guint32  tag_length;",
      "109:     guint16  tmp;",
      "111:     file_offset = file_tell(wth->fh);",
      "",
      "[Added Lines]",
      "135:     gint                     bytes_read;",
      "136:     guint16                  payload_length;",
      "137:     guint16                  hdr_size;",
      "138:     guint16                  read_sofar;",
      "139:     guint16                  entry_len;",
      "140:     gint                     version;",
      "141:     struct logger_entry     *log_entry;",
      "142:     struct logger_entry_v2  *log_entry_v2;",
      "143:     guint8                  *buffer;",
      "144:     guint16                  tmp;",
      "145:     guint8                  *msg_payload, *msg_part, *msg_end;",
      "146:     guint16                  msg_len;",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "127:         return -1;",
      "128:     }",
      "136:             if (*err == 0 && bytes_read != 0)",
      "140:         }",
      "159:         g_free(buffer);",
      "161:     }",
      "163:     g_free(buffer);",
      "165: }",
      "167: static gboolean logcat_read_packet(struct logcat_phdr *logcat, FILE_T fh,",
      "",
      "[Removed Lines]",
      "129:     try_header_size = pletoh16(&tmp);",
      "131:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
      "132:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
      "133:     if (bytes_read != 5 * 4 + payload_length) {",
      "134:         if (bytes_read != 4 * 4 + payload_length) {",
      "138:             g_free(buffer);",
      "139:             return -1;",
      "141:     }",
      "143:     if (try_header_size == 24) {",
      "144:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
      "145:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
      "146:         if (payload_length == 1 + tag_length + log_length) {",
      "147:             g_free(buffer);",
      "148:             return 2;",
      "149:         }",
      "150:     }",
      "152:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
      "153:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
      "154:     if (payload_length == 1 + tag_length + log_length) {",
      "155:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
      "156:             g_free(buffer);",
      "157:             return -1;",
      "158:         }",
      "160:         return 1;",
      "164:     return 0;",
      "",
      "[Added Lines]",
      "166:     hdr_size = pletoh16(&tmp);",
      "167:     read_sofar = 4;",
      "170:     if (payload_length < 3)",
      "171:         return -1;",
      "173:     if (payload_length > LOGGER_ENTRY_MAX_PAYLOAD)",
      "174:         return -1;",
      "177:     buffer = (guint8 *) g_malloc(sizeof(*log_entry_v2) + payload_length);",
      "178:     log_entry_v2 = (struct logger_entry_v2 *) buffer;",
      "179:     log_entry = (struct logger_entry *) buffer;",
      "183:     for (version = 1; version <= 2; ++version) {",
      "184:         if (version == 1) {",
      "185:             msg_payload = log_entry->msg;",
      "186:             entry_len = sizeof(*log_entry) + payload_length;",
      "187:         } else if (version == 2) {",
      "189:             msg_payload = log_entry_v2->msg;",
      "190:             entry_len = sizeof(*log_entry_v2) + payload_length;",
      "191:             if (hdr_size != sizeof(*log_entry_v2))",
      "192:                 continue;",
      "193:         }",
      "195:         bytes_read = file_read(buffer + read_sofar, entry_len - read_sofar,",
      "196:                 wth->fh);",
      "197:         if (bytes_read != entry_len - read_sofar) {",
      "202:             version = -1;",
      "203:             break;",
      "205:         read_sofar += bytes_read;",
      "208:         if (get_priority(msg_payload[0]) == '?')",
      "209:             continue;",
      "212:         msg_part = (guint8 *) memchr(msg_payload, '\\0', payload_length - 1);",
      "213:         if (msg_part == NULL)",
      "214:             continue;",
      "217:         ++msg_part;",
      "218:         msg_len = payload_length - (msg_part - msg_payload);",
      "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
      "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
      "222:             continue;",
      "225:         return version;",
      "229:     return -1;",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "172:     guint16              payload_length;",
      "173:     guint                tmp[2];",
      "174:     guint8              *pd;",
      "176:     bytes_read = file_read(&tmp, 2, fh);",
      "177:     if (bytes_read != 2) {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "240:     struct logger_entry *log_entry;",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "183:     payload_length = pletoh16(tmp);",
      "185:     if (logcat->version == 1) {",
      "187:     } else if (logcat->version == 2) {",
      "189:     } else {",
      "190:         return FALSE;",
      "191:     }",
      "193:     buffer_assure_space(buf, packet_size);",
      "194:     pd = buffer_start_ptr(buf);",
      "197:     memcpy(pd, tmp, 2);",
      "",
      "[Removed Lines]",
      "186:         packet_size = 5 * 4 + payload_length;",
      "188:         packet_size = 6 * 4 + payload_length;",
      "",
      "[Added Lines]",
      "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
      "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
      "261:     log_entry = (struct logger_entry *) pd;",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "208:     phdr->rec_type = REC_TYPE_PACKET;",
      "209:     phdr->presence_flags = WTAP_HAS_TS;",
      "212:     phdr->caplen = packet_size;",
      "213:     phdr->len = packet_size;",
      "",
      "[Removed Lines]",
      "210:     phdr->ts.secs = (time_t) pletoh32(pd + 12);",
      "211:     phdr->ts.nsecs = (int) pletoh32(pd + 16);",
      "",
      "[Added Lines]",
      "277:     phdr->ts.secs = (time_t) GINT32_FROM_LE(log_entry->sec);",
      "278:     phdr->ts.nsecs = GINT32_FROM_LE(log_entry->nsec);",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "340:     gchar                          *buf;",
      "341:     gint                            length;",
      "342:     gchar                           priority;",
      "343:     const gchar                    *tag;",
      "347:     gchar                          *log_part;",
      "352:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
      "353:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
      "",
      "[Removed Lines]",
      "344:     const gint                     *pid;",
      "345:     const gint                     *tid;",
      "346:     const gchar                    *log;",
      "348:     const gchar                    *str_begin;",
      "349:     const gchar                    *str_end;",
      "350:     const guint32                  *datetime;",
      "351:     const guint32                  *nanoseconds;",
      "",
      "[Added Lines]",
      "410:     const struct logger_entry      *log_entry = (struct logger_entry *) pd;",
      "411:     const struct logger_entry_v2   *log_entry_v2 = (struct logger_entry_v2 *) pd;",
      "412:     gint                            payload_length;",
      "414:     gint32                          pid;",
      "415:     gint32                          tid;",
      "416:     gint32                          seconds;",
      "417:     gint32                          milliseconds;",
      "418:     const gchar                    *msg_begin;",
      "419:     gint                            msg_pre_skip;",
      "420:     gchar                          *log;",
      "422:     gchar                          *log_next;",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "358:         return FALSE;",
      "359:     }",
      "361:     if (pseudo_header->logcat.version == 1) {",
      "369:     } else if (pseudo_header->logcat.version == 2) {",
      "377:     } else {",
      "379:         return FALSE;",
      "380:     }",
      "401:         }",
      "413:                 priority, tag, log_part);",
      "414:         if (!buf) {",
      "416:             return FALSE;",
      "417:         }",
      "419:         length = (guint32)strlen(buf);",
      "421:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "423:             return FALSE;",
      "424:         }",
      "426:         wdh->bytes_dumped += length;",
      "430:     return TRUE;",
      "431: }",
      "",
      "[Removed Lines]",
      "362:         pid = (const gint *) (pd + 4);",
      "363:         tid = (const gint *) (pd + 2 * 4);",
      "364:         datetime = (const guint32 *) (pd + 3 * 4);",
      "365:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "366:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
      "367:         tag = (const gchar *) (pd + 5 * 4 + 1);",
      "368:         log = tag + strlen(tag) + 1;",
      "370:         pid = (const gint *) (pd + 4);",
      "371:         tid = (const gint *) (pd + 2 * 4);",
      "372:         datetime = (const guint32 *) (pd + 3 * 4);",
      "373:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
      "374:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
      "375:         tag = (const char *) (pd + 6 * 4 + 1);",
      "376:         log = tag + strlen(tag) + 1;",
      "382:     str_begin = str_end = log;",
      "383:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
      "384:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
      "385:         g_strlcpy(log_part, str_begin, str_end - str_begin + 1);",
      "387:         str_begin = str_end + 1;",
      "389:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "390:                 priority, tag, log_part);",
      "391:         if (!buf) {",
      "392:             g_free(log_part);",
      "393:             return FALSE;",
      "394:         }",
      "395:         g_free(log_part);",
      "396:         length = (guint32)strlen(buf);",
      "398:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
      "399:             g_free(buf);",
      "400:             return FALSE;",
      "403:         wdh->bytes_dumped += length;",
      "405:         g_free(buf);",
      "406:     }",
      "408:     if (*str_begin != '\\0') {",
      "409:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
      "410:         g_strlcpy(log_part, str_begin, strlen(str_begin) + 1);",
      "412:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
      "415:             g_free(log_part);",
      "418:         g_free(log_part);",
      "422:             g_free(buf);",
      "427:         g_free(buf);",
      "428:     }",
      "",
      "[Added Lines]",
      "432:     payload_length = GINT32_FROM_LE(log_entry->len);",
      "433:     pid = GINT32_FROM_LE(log_entry->pid);",
      "434:     tid = GINT32_FROM_LE(log_entry->tid);",
      "435:     seconds = GINT32_FROM_LE(log_entry->sec);",
      "436:     milliseconds = GINT32_FROM_LE(log_entry->nsec) / 1000000;",
      "440:         priority = get_priority(log_entry->msg[0]);",
      "441:         tag = log_entry->msg + 1;",
      "442:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "443:         msg_begin = log_entry->msg + msg_pre_skip;",
      "445:         priority = get_priority(log_entry_v2->msg[0]);",
      "446:         tag = log_entry_v2->msg + 1;",
      "447:         msg_pre_skip = 1 + strlen(tag) + 1;",
      "448:         msg_begin = log_entry_v2->msg + msg_pre_skip;",
      "455:     log = g_strndup(msg_begin, payload_length - msg_pre_skip);",
      "459:     log_next = log;",
      "460:     do {",
      "461:         log_part = log_next;",
      "462:         if (dumper->type == DUMP_LONG) {",
      "464:             log_next = NULL;",
      "465:         } else {",
      "467:             log_next = strchr(log_part, '\\n');",
      "468:             if (log_next != NULL) {",
      "470:                 ++log_next;",
      "472:                 if (*log_next == '\\0') {",
      "473:                     log_next = NULL;",
      "474:                 }",
      "475:             }",
      "478:         buf = logcat_log(dumper, seconds, milliseconds, pid, tid,",
      "481:             g_free(log);",
      "487:             g_free(log);",
      "492:     } while (log_next != NULL);",
      "494:     g_free(log);",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "a68e3a410c210e798aa9c96c03ef5cc075f19ca9",
      "candidate_info": {
        "commit_hash": "a68e3a410c210e798aa9c96c03ef5cc075f19ca9",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/a68e3a410c210e798aa9c96c03ef5cc075f19ca9",
        "files": [
          "epan/dissectors/packet-logcat.c",
          "wiretap/CMakeLists.txt",
          "wiretap/Makefile.common",
          "wiretap/file_access.c",
          "wiretap/logcat.c",
          "wiretap/logcat.h",
          "wiretap/wtap.h"
        ],
        "message": "Wiretap: Add support for Android Logcat\n\nNow Androit Logcat (Logger) binary logs are supported.\nTry \"adb logcat -Bf /sdcard/log.logcat; adb pull /sdcard/log.logcat\".\nAlso there is possibility to save logs to text format like by \"adb\".\n\nChange-Id: If7bfc53d3fbd549a0978d1dbf96f3fff671fd601\nReviewed-on: https://code.wireshark.org/review/235\nReviewed-by: Anders Broman <a.broman58@gmail.com>",
        "before_after_code_files": [
          "epan/dissectors/packet-logcat.c||epan/dissectors/packet-logcat.c",
          "wiretap/Makefile.common||wiretap/Makefile.common",
          "wiretap/file_access.c||wiretap/file_access.c",
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/logcat.h||wiretap/logcat.h",
          "wiretap/wtap.h||wiretap/wtap.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "epan/dissectors/packet-logcat.c||epan/dissectors/packet-logcat.c": [
          "File: epan/dissectors/packet-logcat.c -> epan/dissectors/packet-logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "28: #include <epan/expert.h>",
          "29: #include <epan/exported_pdu.h>",
          "30: #include <epan/tap.h>",
          "32: static int proto_logcat = -1;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "31: #include <wiretap/wtap.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "282: void",
          "283: proto_reg_handoff_logcat(void)",
          "284: {",
          "285:     dissector_add_handle(\"tcp.port\", logcat_handle);",
          "287:     exported_pdu_tap = find_tap_id(EXPORT_PDU_TAP_NAME_LOGCAT);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "286:     dissector_add_uint(\"wtap_encap\", WTAP_ENCAP_LOGCAT, logcat_handle);",
          "",
          "---------------"
        ],
        "wiretap/Makefile.common||wiretap/Makefile.common": [
          "File: wiretap/Makefile.common -> wiretap/Makefile.common",
          "--- Hunk 1 ---",
          "[Context before]",
          "56:  mime_file.c  \\",
          "57:  k12.c   \\",
          "58:  lanalyzer.c  \\",
          "59:  libpcap.c  \\",
          "60:  merge.c   \\",
          "61:  mpeg.c   \\",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59:  logcat.c  \\",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "114:  k12.h   \\",
          "115:  lanalyzer.h  \\",
          "116:  libpcap.h  \\",
          "117:  merge.h   \\",
          "118:  mpeg.h   \\",
          "120:  mp2t.h   \\",
          "121:  netmon.h  \\",
          "122:  netscreen.h  \\",
          "",
          "[Removed Lines]",
          "119:  mpeg.h   \\",
          "",
          "[Added Lines]",
          "118:  logcat.h  \\",
          "",
          "---------------"
        ],
        "wiretap/file_access.c||wiretap/file_access.c": [
          "File: wiretap/file_access.c -> wiretap/file_access.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "64: #include \"5views.h\"",
          "65: #include \"erf.h\"",
          "66: #include \"hcidump.h\"",
          "67: #include \"network_instruments.h\"",
          "68: #include \"k12.h\"",
          "69: #include \"ber.h\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "67: #include \"logcat.h\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "360:     { \"Hcidump\",                     OPEN_INFO_HEURISTIC, hcidump_open,             NULL,       NULL },",
          "361:     { \"Commview\",                    OPEN_INFO_HEURISTIC, commview_open,            \"ncf\",      NULL },",
          "362:     { \"Nstrace\",                     OPEN_INFO_HEURISTIC, nstrace_open,             \"txt\",      NULL },",
          "364:     { \"Ascend\",                      OPEN_INFO_HEURISTIC, ascend_open,              \"txt\",      NULL },",
          "365:     { \"Toshiba\",                     OPEN_INFO_HEURISTIC, toshiba_open,             \"txt\",      NULL },",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "364:     { \"Logcat \",                     OPEN_INFO_HEURISTIC, logcat_open,              \"logcat\",   NULL },",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "1421:  { \"NetScaler Trace (Version 3.0)\", \"nstrace30\", \"cap\", NULL,",
          "1422:    TRUE, FALSE, 0,",
          "1425: };",
          "",
          "[Removed Lines]",
          "1423:    nstrace_30_dump_can_write_encap, nstrace_dump_open, NULL }",
          "",
          "[Added Lines]",
          "1425:    nstrace_30_dump_can_write_encap, nstrace_dump_open, NULL },",
          "1428:  { \"Android Logcat Binary format\",          \"logcat\",         \"logcat\", NULL,",
          "1429:    FALSE, FALSE, 0,",
          "1430:    logcat_dump_can_write_encap, logcat_binary_dump_open, NULL },",
          "1431:  { \"Android Logcat Brief text format\",      \"logcat-brief\",      NULL, NULL,",
          "1432:    FALSE, FALSE, 0,",
          "1433:    logcat_dump_can_write_encap, logcat_text_brief_dump_open, NULL },",
          "1434:  { \"Android Logcat Process text format\",    \"logcat-process\",    NULL, NULL,",
          "1435:    FALSE, FALSE, 0,",
          "1436:    logcat_dump_can_write_encap, logcat_text_process_dump_open, NULL },",
          "1437:  { \"Android Logcat Tag text format\",        \"logcat-tag\",        NULL, NULL,",
          "1438:    FALSE, FALSE, 0,",
          "1439:    logcat_dump_can_write_encap, logcat_text_tag_dump_open, NULL },",
          "1440:  { \"Android Logcat Time text format\",       \"logcat-time\",       NULL, NULL,",
          "1441:    FALSE, FALSE, 0,",
          "1442:    logcat_dump_can_write_encap, logcat_text_time_dump_open, NULL },",
          "1443:  { \"Android Logcat Thread text format\",     \"logcat-thread\",     NULL, NULL,",
          "1444:    FALSE, FALSE, 0,",
          "1445:    logcat_dump_can_write_encap, logcat_text_thread_dump_open, NULL },",
          "1446:  { \"Android Logcat Threadtime text format\", \"logcat-threadtime\", NULL, NULL,",
          "1447:    FALSE, FALSE, 0,",
          "1448:    logcat_dump_can_write_encap, logcat_text_threadtime_dump_open, NULL },",
          "1449:  { \"Android Logcat Long text format\",       \"logcat-long\",       NULL, NULL,",
          "1450:    FALSE, FALSE, 0,",
          "1451:    logcat_dump_can_write_encap, logcat_text_long_dump_open, NULL }",
          "",
          "---------------"
        ],
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "20: #include \"config.h\"",
          "22: #include <string.h>",
          "23: #include <time.h>",
          "25: #include \"wtap-int.h\"",
          "26: #include \"file_wrappers.h\"",
          "27: #include \"buffer.h\"",
          "29: #include \"logcat.h\"",
          "31: enum dump_type_t {",
          "32:     DUMP_BINARY,",
          "33:     DUMP_BRIEF,",
          "34:     DUMP_PROCESS,",
          "35:     DUMP_TAG,",
          "36:     DUMP_TIME,",
          "37:     DUMP_THREAD,",
          "38:     DUMP_THREADTIME,",
          "39:     DUMP_LONG",
          "40: };",
          "42: struct dumper_t {",
          "43:     enum dump_type_t type;",
          "44: };",
          "46: static gchar get_priority(const guint8 *priority) {",
          "47:     static gchar priorities[] = \"??VDIWEFS\";",
          "49:     if (*priority >= (guint8) sizeof(priorities))",
          "50:         return '?';",
          "52:     return priorities[(int) *priority];",
          "53: }",
          "55: static gchar *logcat_log(const struct dumper_t *dumper, guint32 seconds,",
          "56:         gint microseconds, gint pid, gint tid, gchar priority, const gchar *tag,",
          "57:         const gchar *log)",
          "58: {",
          "59:     gchar  time_buffer[15];",
          "60:     time_t datetime;",
          "62:     datetime = (time_t) seconds;",
          "64:     switch (dumper->type) {",
          "65:         case DUMP_BRIEF:",
          "66:             return g_strdup_printf(\"%c/%s(%5i): %s\\n\",",
          "67:                     priority, tag, pid, log);",
          "68:         case DUMP_PROCESS:",
          "69:             return g_strdup_printf(\"%c(%5i) %s  (%s)\\n\",",
          "70:                     priority, pid, log, tag);",
          "71:         case DUMP_TAG:",
          "72:             return g_strdup_printf(\"%c/%s: %s\\n\",",
          "73:                    priority, tag, log);",
          "74:         case DUMP_THREAD:",
          "75:             return g_strdup_printf(\"%c(%5i:%5i) %s\\n\",",
          "76:                     priority, pid, tid, log);",
          "77:         case DUMP_TIME:",
          "78:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "79:                     gmtime(&datetime));",
          "80:             return g_strdup_printf(\"%s.%03i %c/%s(%5i): %s\\n\",",
          "81:                     time_buffer, microseconds, priority, tag, pid, log);",
          "82:         case DUMP_THREADTIME:",
          "83:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "84:                     gmtime(&datetime));",
          "85:             return g_strdup_printf(\"%s.%03i %5i:%5i %c %s: %s\\n\",",
          "86:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "87:         case DUMP_LONG:",
          "88:             strftime(time_buffer, sizeof(time_buffer), \"%m-%d %H:%M:%S\",",
          "89:                     gmtime(&datetime));",
          "90:             return g_strdup_printf(\"[ %s.%03i %5i:%5i %c/%s ]\\n%s\\n\\n\",",
          "91:                     time_buffer, microseconds, pid, tid, priority, tag, log);",
          "92:         default:",
          "93:             return NULL;",
          "94:     }",
          "96: }",
          "98: static gint detect_version(wtap *wth, int *err, gchar **err_info)",
          "99: {",
          "100:     gint     bytes_read;",
          "101:     guint16  payload_length;",
          "102:     guint16  try_header_size;",
          "103:     guint8  *buffer;",
          "104:     gint64   file_offset;",
          "105:     guint32  log_length;",
          "106:     guint32  tag_length;",
          "107:     guint16  tmp;",
          "109:     file_offset = file_tell(wth->fh);",
          "111:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "112:     if (bytes_read != 2) {",
          "114:         if (*err == 0 && bytes_read != 0)",
          "116:         return -1;",
          "117:     }",
          "118:     payload_length = pletoh16(&tmp);",
          "120:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "121:     if (bytes_read != 2) {",
          "123:         if (*err == 0 && bytes_read != 0)",
          "125:         return -1;",
          "126:     }",
          "127:     try_header_size = pletoh16(&tmp);",
          "129:     buffer = (guint8 *) g_malloc(5 * 4 + payload_length);",
          "130:     bytes_read = file_read(buffer, 5 * 4 + payload_length, wth->fh);",
          "131:     if (bytes_read != 5 * 4 + payload_length) {",
          "132:         if (bytes_read != 4 * 4 + payload_length) {",
          "134:             if (*err == 0 && bytes_read != 0)",
          "136:             g_free(buffer);",
          "137:             return -1;",
          "138:         }",
          "139:     }",
          "141:     if (try_header_size == 24) {",
          "142:         tag_length = strlen(buffer + 5 * 4 + 1) + 1;",
          "143:         log_length = strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "144:         if (payload_length == 1 + tag_length + log_length) {",
          "145:             g_free(buffer);",
          "146:             return 2;",
          "147:         }",
          "148:     }",
          "150:     tag_length = strlen(buffer + 4 * 4 + 1) + 1;",
          "151:     log_length = strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "152:     if (payload_length == 1 + tag_length + log_length) {",
          "153:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
          "154:             g_free(buffer);",
          "155:             return -1;",
          "156:         }",
          "157:         g_free(buffer);",
          "158:         return 1;",
          "159:     }",
          "161:     g_free(buffer);",
          "162:     return 0;",
          "163: }",
          "165: static gboolean logcat_read(wtap *wth, int *err, gchar **err_info,",
          "166:     gint64 *data_offset)",
          "167: {",
          "168:     gint                 bytes_read;",
          "169:     gint                 packet_size;",
          "170:     guint16              payload_length;",
          "171:     guint16              tmp;",
          "172:     guint8              *buf;",
          "173:     struct logcat_phdr  *logcat;",
          "177:     bytes_read = file_read(&tmp, 2, wth->fh);",
          "178:     if (bytes_read != 2) {",
          "180:         if (*err == 0 && bytes_read != 0)",
          "182:         return FALSE;",
          "183:     }",
          "184:     payload_length = pletoh16(&tmp);",
          "186:     if (file_seek(wth->fh, *data_offset, SEEK_SET, err) == -1)",
          "187:         return FALSE;",
          "189:     logcat = (struct logcat_phdr *) wth->priv;",
          "191:     if (logcat->version == 1) {",
          "192:         packet_size = 5 * 4 + payload_length;",
          "193:     } else if (logcat->version == 2) {",
          "194:         packet_size = 6 * 4 + payload_length;",
          "195:     } else {",
          "196:         return FALSE;",
          "197:     }",
          "199:     buffer_assure_space(wth->frame_buffer, packet_size);",
          "200:     buf = buffer_start_ptr(wth->frame_buffer);",
          "202:     bytes_read = file_read(buf, packet_size, wth->fh);",
          "203:     if (bytes_read != packet_size) {",
          "205:         if (*err == 0)",
          "207:         return FALSE;",
          "208:     }",
          "210:     wth->phdr.presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN;",
          "211:     wth->phdr.ts.secs = (time_t) pletoh32(buf + 12);",
          "212:     wth->phdr.ts.nsecs = (int) pletoh32(buf + 16);",
          "213:     wth->phdr.caplen = packet_size;",
          "214:     wth->phdr.len = packet_size;",
          "216:     wth->phdr.pseudo_header.logcat.version = logcat->version;",
          "218:     return TRUE;",
          "219: }",
          "221: static gboolean logcat_seek_read(wtap *wth, gint64 seek_off,",
          "222:     struct wtap_pkthdr *phdr, Buffer *buf,",
          "223:     int *err, gchar **err_info)",
          "224: {",
          "225:     gint                 bytes_read;",
          "226:     gint                 packet_size;",
          "227:     guint16              payload_length;",
          "228:     guint                tmp[4];",
          "229:     struct logcat_phdr  *logcat;",
          "231:     if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "232:         return FALSE;",
          "234:     bytes_read = file_read(&tmp, 2, wth->random_fh);",
          "235:     if (bytes_read != 2) {",
          "237:         if (*err == 0 && bytes_read != 0)",
          "239:         return FALSE;",
          "240:     }",
          "241:     payload_length = pletoh16(tmp);",
          "243:     logcat = (struct logcat_phdr *) wth->priv;",
          "245:     if (logcat->version == 1) {",
          "246:         packet_size = 5 * 4 + payload_length;",
          "247:     } else if (logcat->version == 2) {",
          "248:         packet_size = 6 * 4 + payload_length;",
          "249:     } else {",
          "250:         return FALSE;",
          "251:     }",
          "253:     if (file_seek(wth->random_fh, seek_off + 12, SEEK_SET, err) == -1)",
          "254:         return FALSE;",
          "256:     bytes_read = file_read(&tmp, 4, wth->random_fh);",
          "257:     if (bytes_read != 4) {",
          "259:         if (*err == 0 && bytes_read != 0)",
          "261:         return FALSE;",
          "262:     }",
          "264:     phdr->ts.secs = (time_t) pletoh32(tmp);",
          "266:     bytes_read = file_read(tmp, 4, wth->random_fh);",
          "267:     if (bytes_read != 4) {",
          "269:         if (*err == 0 && bytes_read != 0)",
          "271:         return FALSE;",
          "272:     }",
          "274:     phdr->ts.nsecs = (int) pletoh32(tmp);",
          "276:     phdr->presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN;",
          "277:     phdr->caplen = packet_size;",
          "278:     phdr->len = packet_size;",
          "280:     phdr->pseudo_header.logcat.version = logcat->version;",
          "282:     if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1)",
          "283:         return FALSE;",
          "285:     return wtap_read_packet_bytes(wth->random_fh, buf, packet_size, err, err_info);",
          "286: }",
          "288: int logcat_open(wtap *wth, int *err, gchar **err_info _U_)",
          "289: {",
          "290:     int                 local_err;",
          "291:     gchar              *local_err_info;",
          "292:     gint                version;",
          "293:     gint                tmp_version;",
          "294:     struct logcat_phdr *logcat;",
          "297:     version = detect_version(wth, &local_err, &local_err_info);",
          "298:     if (version <= 0)",
          "299:         return 0;",
          "301:     tmp_version = detect_version(wth, &local_err, &local_err_info);",
          "302:     if (tmp_version < 0 && !file_eof(wth->fh)) {",
          "303:         return 0;",
          "304:     } else if (tmp_version > 0) {",
          "305:         if (tmp_version != version)",
          "306:             return 0;",
          "308:         tmp_version = detect_version(wth, &local_err, &local_err_info);",
          "309:         if (tmp_version != version && !file_eof(wth->fh))",
          "310:             return 0;",
          "311:     }",
          "313:     if (file_seek(wth->fh, 0, SEEK_SET, err) == -1)",
          "314:         return -1;",
          "316:     logcat = (struct logcat_phdr *) g_malloc(sizeof(struct logcat_phdr));",
          "317:     logcat->version = version;",
          "319:     wth->priv = logcat;",
          "321:     wth->file_type_subtype = WTAP_FILE_TYPE_SUBTYPE_LOGCAT;",
          "322:     wth->file_encap = WTAP_ENCAP_LOGCAT;",
          "323:     wth->snapshot_length = 0;",
          "325:     wth->subtype_read = logcat_read;",
          "326:     wth->subtype_seek_read = logcat_seek_read;",
          "327:     wth->tsprecision = WTAP_FILE_TSPREC_USEC;",
          "329:     return 1;",
          "330: }",
          "332: int logcat_dump_can_write_encap(int encap)",
          "333: {",
          "334:     if (encap == WTAP_ENCAP_PER_PACKET)",
          "335:         return WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED;",
          "337:     if (encap != WTAP_ENCAP_LOGCAT)",
          "338:         return WTAP_ERR_UNSUPPORTED_ENCAP;",
          "340:     return 0;",
          "341: }",
          "343: static gboolean logcat_binary_dump(wtap_dumper *wdh,",
          "344:     const struct wtap_pkthdr *phdr,",
          "345:     const guint8 *pd, int *err)",
          "346: {",
          "347:     if (!wtap_dump_file_write(wdh, pd, phdr->caplen, err))",
          "348:         return FALSE;",
          "350:     wdh->bytes_dumped += phdr->caplen;",
          "352:     return TRUE;",
          "353: }",
          "355: gboolean logcat_binary_dump_open(wtap_dumper *wdh, int *err)",
          "356: {",
          "357:     wdh->subtype_write = logcat_binary_dump;",
          "358:     wdh->subtype_close = NULL;",
          "360:     switch (wdh->file_type_subtype) {",
          "361:         case WTAP_FILE_TYPE_SUBTYPE_LOGCAT:",
          "362:             wdh->tsprecision = WTAP_FILE_TSPREC_USEC;",
          "363:             break;",
          "365:         default:",
          "367:             return FALSE;",
          "368:     }",
          "370:     return TRUE;",
          "371: }",
          "373: static gboolean logcat_dump_text(wtap_dumper *wdh,",
          "374:     const struct wtap_pkthdr *phdr,",
          "375:     const guint8 *pd, int *err)",
          "376: {",
          "377:     gchar                          *buf;",
          "378:     gint                            length;",
          "379:     gchar                           priority;",
          "380:     const gchar                    *tag;",
          "381:     const gint                     *pid;",
          "382:     const gint                     *tid;",
          "383:     const gchar                    *log;",
          "384:     gchar                          *log_part;",
          "385:     const gchar                    *str_begin;",
          "386:     const gchar                    *str_end;",
          "387:     const guint32                  *datetime;",
          "388:     const guint32                  *nanoseconds;",
          "389:     const union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;",
          "390:     const struct dumper_t          *dumper        = (const struct dumper_t *) wdh->priv;",
          "392:     if (pseudo_header->logcat.version == 1) {",
          "393:         pid = (const gint *) (pd + 4);",
          "394:         tid = (const gint *) (pd + 2 * 4);",
          "395:         datetime = (const guint32 *) (pd + 3 * 4);",
          "396:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "397:         priority = get_priority((const guint8 *) (pd + 5 * 4));",
          "398:         tag = (const gchar *) (pd + 5 * 4 + 1);",
          "399:         log = tag + strlen(tag) + 1;",
          "400:     } else if (pseudo_header->logcat.version == 2) {",
          "401:         pid = (const gint *) (pd + 4);",
          "402:         tid = (const gint *) (pd + 2 * 4);",
          "403:         datetime = (const guint32 *) (pd + 3 * 4);",
          "404:         nanoseconds = (const guint32 *) (pd + 4 * 4);",
          "405:         priority = get_priority((const guint8 *) (pd + 6 * 4));",
          "406:         tag = (const char *) (pd + 6 * 4 + 1);",
          "407:         log = tag + strlen(tag) + 1;",
          "408:     } else {",
          "410:         return FALSE;",
          "411:     }",
          "413:     str_begin = str_end = log;",
          "414:     while (dumper->type != DUMP_LONG && (str_end = strchr(str_begin, '\\n'))) {",
          "415:         log_part = (gchar *) g_malloc(str_end - str_begin + 1);",
          "416:         strncpy(log_part, str_begin, str_end - str_begin);",
          "417:         log_part[str_end - str_begin] = '\\0';",
          "418:         str_begin = str_end + 1;",
          "420:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "421:                 priority, tag, log_part);",
          "422:         if (!buf) {",
          "423:             g_free(log_part);",
          "424:             return FALSE;",
          "425:         }",
          "426:         g_free(log_part);",
          "427:         length = strlen(buf);",
          "429:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "430:             g_free(buf);",
          "431:             return FALSE;",
          "432:         }",
          "434:         wdh->bytes_dumped += length;",
          "436:         g_free(buf);",
          "437:     }",
          "439:     if (*str_begin != '\\0') {",
          "440:         log_part = (gchar *) g_malloc(strlen(str_begin) + 1);",
          "441:         strncpy(log_part, str_begin, strlen(str_begin));",
          "442:         log_part[strlen(str_begin)] = '\\0';",
          "444:         buf = logcat_log(dumper, *datetime, *nanoseconds / 1000000, *pid, *tid,",
          "445:                 priority, tag, log_part);",
          "446:         if (!buf) {",
          "447:             g_free(log_part);",
          "448:             return FALSE;",
          "449:         }",
          "450:         g_free(log_part);",
          "451:         length = strlen(buf);",
          "453:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "454:             g_free(buf);",
          "455:             return FALSE;",
          "456:         }",
          "458:         wdh->bytes_dumped += length;",
          "459:         g_free(buf);",
          "460:     }",
          "462:     return TRUE;",
          "463: }",
          "465: gboolean logcat_text_brief_dump_open(wtap_dumper *wdh, int *err _U_)",
          "466: {",
          "467:     struct dumper_t *dumper;",
          "469:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "470:     dumper->type = DUMP_BRIEF;",
          "472:     wdh->priv = dumper;",
          "473:     wdh->subtype_write = logcat_dump_text;",
          "474:     wdh->subtype_close = NULL;",
          "476:     return TRUE;",
          "477: }",
          "479: gboolean logcat_text_process_dump_open(wtap_dumper *wdh, int *err _U_)",
          "480: {",
          "481:     struct dumper_t *dumper;",
          "483:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "484:     dumper->type = DUMP_PROCESS;",
          "486:     wdh->priv = dumper;",
          "487:     wdh->subtype_write = logcat_dump_text;",
          "488:     wdh->subtype_close = NULL;",
          "490:     return TRUE;",
          "491: }",
          "493: gboolean logcat_text_tag_dump_open(wtap_dumper *wdh, int *err _U_)",
          "494: {",
          "495:     struct dumper_t *dumper;",
          "497:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "498:     dumper->type = DUMP_TAG;",
          "500:     wdh->priv = dumper;",
          "501:     wdh->subtype_write = logcat_dump_text;",
          "502:     wdh->subtype_close = NULL;",
          "504:     return TRUE;",
          "505: }",
          "507: gboolean logcat_text_time_dump_open(wtap_dumper *wdh, int *err _U_)",
          "508: {",
          "509:     struct dumper_t *dumper;",
          "511:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "512:     dumper->type = DUMP_TIME;",
          "514:     wdh->priv = dumper;",
          "515:     wdh->subtype_write = logcat_dump_text;",
          "516:     wdh->subtype_close = NULL;",
          "518:     return TRUE;",
          "519: }",
          "521: gboolean logcat_text_thread_dump_open(wtap_dumper *wdh, int *err _U_)",
          "522: {",
          "523:     struct dumper_t *dumper;",
          "525:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "526:     dumper->type = DUMP_THREAD;",
          "528:     wdh->priv = dumper;",
          "529:     wdh->subtype_write = logcat_dump_text;",
          "530:     wdh->subtype_close = NULL;",
          "532:     return TRUE;",
          "533: }",
          "535: gboolean logcat_text_threadtime_dump_open(wtap_dumper *wdh, int *err _U_)",
          "536: {",
          "537:     struct dumper_t *dumper;",
          "539:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "540:     dumper->type = DUMP_THREADTIME;",
          "542:     wdh->priv = dumper;",
          "543:     wdh->subtype_write = logcat_dump_text;",
          "544:     wdh->subtype_close = NULL;",
          "546:     return TRUE;",
          "547: }",
          "549: gboolean logcat_text_long_dump_open(wtap_dumper *wdh, int *err _U_)",
          "550: {",
          "551:     struct dumper_t *dumper;",
          "553:     dumper = (struct dumper_t *) g_malloc(sizeof(struct dumper_t));",
          "554:     dumper->type = DUMP_LONG;",
          "556:     wdh->priv = dumper;",
          "557:     wdh->subtype_write = logcat_dump_text;",
          "558:     wdh->subtype_close = NULL;",
          "560:     return TRUE;",
          "561: }",
          "",
          "---------------"
        ],
        "wiretap/logcat.h||wiretap/logcat.h": [
          "File: wiretap/logcat.h -> wiretap/logcat.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21: #ifndef __LOGCAT_H__",
          "22: #define __LOGCAT_H__",
          "24: #include <glib.h>",
          "26: #include \"wtap.h\"",
          "28: int      logcat_open(wtap *wth, int *err, gchar **err_info);",
          "30: gboolean logcat_binary_dump_open(wtap_dumper *wdh, int *err);",
          "31: gboolean logcat_text_brief_dump_open(wtap_dumper *wdh, int *err);",
          "32: gboolean logcat_text_process_dump_open(wtap_dumper *wdh, int *err);",
          "33: gboolean logcat_text_tag_dump_open(wtap_dumper *wdh, int *err);",
          "34: gboolean logcat_text_time_dump_open(wtap_dumper *wdh, int *err);",
          "35: gboolean logcat_text_thread_dump_open(wtap_dumper *wdh, int *err);",
          "36: gboolean logcat_text_threadtime_dump_open(wtap_dumper *wdh, int *err);",
          "37: gboolean logcat_text_long_dump_open(wtap_dumper *wdh, int *err);",
          "39: int      logcat_dump_can_write_encap(int encap);",
          "41: #endif",
          "",
          "---------------"
        ],
        "wiretap/wtap.h||wiretap/wtap.h": [
          "File: wiretap/wtap.h -> wiretap/wtap.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "254: #define WTAP_ENCAP_BLUETOOTH_BREDR_BB           161",
          "255: #define WTAP_ENCAP_BLUETOOTH_LE_LL_WITH_PHDR    162",
          "256: #define WTAP_ENCAP_NSTRACE_3_0                  163",
          "259: #define WTAP_NUM_ENCAP_TYPES                    wtap_get_num_encap_types()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "257: #define WTAP_ENCAP_LOGCAT                       164",
          "258: #define WTAP_ENCAP_LOGCAT_BRIEF                 165",
          "259: #define WTAP_ENCAP_LOGCAT_PROCESS               166",
          "260: #define WTAP_ENCAP_LOGCAT_TAG                   167",
          "261: #define WTAP_ENCAP_LOGCAT_THREAD                168",
          "262: #define WTAP_ENCAP_LOGCAT_TIME                  169",
          "263: #define WTAP_ENCAP_LOGCAT_THREADTIME            170",
          "264: #define WTAP_ENCAP_LOGCAT_LONG                  171",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "330: #define WTAP_FILE_TYPE_SUBTYPE_CAMINS                        64",
          "331: #define WTAP_FILE_TYPE_SUBTYPE_STANAG_4607                   65",
          "332: #define WTAP_FILE_TYPE_SUBTYPE_NETSCALER_3_0                 66",
          "334: #define WTAP_NUM_FILE_TYPES_SUBTYPES  wtap_get_num_file_types_subtypes()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "341: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT                        67",
          "342: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_BRIEF                  68",
          "343: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_PROCESS                69",
          "344: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TAG                    70",
          "345: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREAD                 71",
          "346: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_TIME                   72",
          "347: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_THREADTIME             73",
          "348: #define WTAP_FILE_TYPE_SUBTYPE_LOGCAT_LONG                   74",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "865: #define GSM_UM_CHANNEL_AGCH     7",
          "866: #define GSM_UM_CHANNEL_PCH      8",
          "868: union wtap_pseudo_header {",
          "869:     struct eth_phdr     eth;",
          "870:     struct x25_phdr     x25;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "885: struct logcat_phdr {",
          "886:     gint version;",
          "887: };",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "890:     struct nstr_phdr    nstr;",
          "891:     struct nokia_phdr   nokia;",
          "892:     struct llcp_phdr    llcp;",
          "893: };",
          "895: struct wtap_pkthdr {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "914:     struct logcat_phdr  logcat;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "71550ba98a38508ae90df43bddd0644b2df2f717",
      "candidate_info": {
        "commit_hash": "71550ba98a38508ae90df43bddd0644b2df2f717",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/71550ba98a38508ae90df43bddd0644b2df2f717",
        "files": [
          "wiretap/k12.c",
          "wiretap/lanalyzer.c",
          "wiretap/logcat.c",
          "wiretap/network_instruments.c",
          "wiretap/ngsniffer.c",
          "wiretap/packetlogger.c",
          "wiretap/peekclassic.c",
          "wiretap/radcom.c"
        ],
        "message": "Make the code a bit more like the pre-new-APIs code.\n\nChange-Id: I40282d8825936d24480c9b77e2e7d9374b1de6b5\nReviewed-on: https://code.wireshark.org/review/4534\nReviewed-by: Guy Harris <guy@alum.mit.edu>",
        "before_after_code_files": [
          "wiretap/k12.c||wiretap/k12.c",
          "wiretap/lanalyzer.c||wiretap/lanalyzer.c",
          "wiretap/logcat.c||wiretap/logcat.c",
          "wiretap/network_instruments.c||wiretap/network_instruments.c",
          "wiretap/ngsniffer.c||wiretap/ngsniffer.c",
          "wiretap/packetlogger.c||wiretap/packetlogger.c",
          "wiretap/peekclassic.c||wiretap/peekclassic.c",
          "wiretap/radcom.c||wiretap/radcom.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/k12.c||wiretap/k12.c": [
          "File: wiretap/k12.c -> wiretap/k12.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "855:     if ( !wtap_read_bytes(wth->fh,header_buffer,K12_FILE_HDR_LEN,err,err_info) ) {",
          "856:         K12_DBG(1,(\"k12_open: FILE HEADER TOO SHORT OR READ ERROR\"));",
          "858:             return -1;",
          "859:         return 0;",
          "860:     }",
          "",
          "[Removed Lines]",
          "857:         if (*err != WTAP_ERR_SHORT_READ)",
          "",
          "[Added Lines]",
          "857:         if (*err != WTAP_ERR_SHORT_READ) {",
          "859:         }",
          "",
          "---------------"
        ],
        "wiretap/lanalyzer.c||wiretap/lanalyzer.c": [
          "File: wiretap/lanalyzer.c -> wiretap/lanalyzer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "313:  }",
          "314:  if (!wtap_read_bytes(wth->fh, &header_fixed, sizeof header_fixed,",
          "315:      err, err_info)) {",
          "324:  }",
          "325:  record_length -= sizeof header_fixed;",
          "",
          "[Removed Lines]",
          "316:   if (*err == WTAP_ERR_SHORT_READ) {",
          "321:    return 0;",
          "322:   }",
          "323:   return -1;",
          "",
          "[Added Lines]",
          "316:   if (*err != WTAP_ERR_SHORT_READ)",
          "317:    return -1;",
          "318:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "329:   comment = (char *)g_malloc(record_length + 1);",
          "330:   if (!wtap_read_bytes(wth->fh, comment, record_length,",
          "331:       err, err_info)) {",
          "340:   }",
          "341:   comment[record_length] = '\\0';",
          "342:   wth->shb_hdr.opt_comment = comment;",
          "",
          "[Removed Lines]",
          "332:    if (*err == WTAP_ERR_SHORT_READ) {",
          "337:     return 0;",
          "338:    }",
          "339:    return -1;",
          "",
          "[Added Lines]",
          "327:    if (*err != WTAP_ERR_SHORT_READ)",
          "328:     return -1;",
          "329:    return 0;",
          "",
          "---------------"
        ],
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "71:             return -2;",
          "72:         }",
          "80:     }",
          "81:     payload_length = pletoh16(&tmp);",
          "",
          "[Removed Lines]",
          "73:         if (*err == WTAP_ERR_SHORT_READ) {",
          "77:             return 0;",
          "78:         }",
          "79:         return -1;",
          "",
          "[Added Lines]",
          "73:         if (*err != WTAP_ERR_SHORT_READ)",
          "74:             return -1;",
          "75:         return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "91:     if (!wtap_read_bytes(fh, &tmp, 2, err, err_info)) {",
          "99:     }",
          "100:     hdr_size = pletoh16(&tmp);",
          "101:     read_sofar = 4;",
          "",
          "[Removed Lines]",
          "92:         if (*err == WTAP_ERR_SHORT_READ) {",
          "96:             return 0;",
          "97:         }",
          "98:         return -1;",
          "",
          "[Added Lines]",
          "88:         if (*err != WTAP_ERR_SHORT_READ)",
          "89:             return -1;",
          "90:         return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "122:         if (!wtap_read_bytes(fh, buffer + read_sofar, entry_len - read_sofar, err, err_info)) {",
          "123:             g_free(buffer);",
          "131:         }",
          "132:         read_sofar += entry_len - read_sofar;",
          "",
          "[Removed Lines]",
          "124:             if (*err == WTAP_ERR_SHORT_READ) {",
          "128:                 return 0;",
          "129:             }",
          "130:             return -1;",
          "",
          "[Added Lines]",
          "116:             if (*err != WTAP_ERR_SHORT_READ)",
          "117:                 return -1;",
          "118:             return 0;",
          "",
          "---------------"
        ],
        "wiretap/network_instruments.c||wiretap/network_instruments.c": [
          "File: wiretap/network_instruments.c -> wiretap/network_instruments.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "103: static gboolean process_packet_header(wtap *wth,",
          "104:     packet_entry_header *packet_header, struct wtap_pkthdr *phdr, int *err,",
          "105:     gchar **err_info);",
          "109: static gboolean skip_to_next_packet(wtap *wth, int offset_to_next_packet,",
          "110:     int current_offset_from_packet_header, int *err, char **err_info);",
          "111: static gboolean observer_dump(wtap_dumper *wdh, const struct wtap_pkthdr *phdr,",
          "",
          "[Removed Lines]",
          "106: static int read_packet_data(FILE_T fh, int offset_to_frame,",
          "107:     int current_offset_from_packet_header, Buffer *buf, int length,",
          "108:     int *err, char **err_info);",
          "",
          "[Added Lines]",
          "106: static int read_packet_data(FILE_T fh, int offset_to_frame, int current_offset_from_packet_header,",
          "107:     Buffer *buf, int length, int *err, char **err_info);",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "339:     if (!wtap_read_bytes_or_eof(fh, packet_header, sizeof *packet_header,",
          "340:                                 err, err_info)) {",
          "344:     }",
          "345:     offset += (int)sizeof *packet_header;",
          "346:     PACKET_ENTRY_HEADER_FROM_LE_IN_PLACE(*packet_header);",
          "",
          "[Removed Lines]",
          "341:         if (*err == 0)",
          "343:         return -1;",
          "",
          "[Added Lines]",
          "340:         if (*err != 0)",
          "341:             return -1;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "498: }",
          "500: static int",
          "504: {",
          "505:     int seek_increment;",
          "506:     int bytes_consumed = 0;",
          "",
          "[Removed Lines]",
          "501: read_packet_data(FILE_T fh, int offset_to_frame,",
          "502:     int current_offset_from_packet_header, Buffer *buf, int length,",
          "503:     int *err, char **err_info)",
          "",
          "[Added Lines]",
          "500: read_packet_data(FILE_T fh, int offset_to_frame, int current_offset_from_packet_header, Buffer *buf,",
          "501:     int length, int *err, char **err_info)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "534: }",
          "536: static gboolean",
          "539: {",
          "540:     int seek_increment;",
          "",
          "[Removed Lines]",
          "537: skip_to_next_packet(wtap *wth, int offset_to_next_packet,",
          "538:     int current_offset_from_packet_header, int *err, char **err_info)",
          "",
          "[Added Lines]",
          "535: skip_to_next_packet(wtap *wth, int offset_to_next_packet, int current_offset_from_packet_header, int *err,",
          "536:     char **err_info)",
          "",
          "---------------"
        ],
        "wiretap/ngsniffer.c||wiretap/ngsniffer.c": [
          "File: wiretap/ngsniffer.c -> wiretap/ngsniffer.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "790:  for (;;) {",
          "791:   errno = WTAP_ERR_CANT_READ;",
          "792:   if (!wtap_read_bytes_or_eof(wth->fh, record_type, 2, err, err_info)) {",
          "796:   }",
          "798:   type = pletoh16(record_type);",
          "",
          "[Removed Lines]",
          "793:    if (*err == 0)",
          "795:    return -1;",
          "",
          "[Added Lines]",
          "793:    if (*err != 0)",
          "794:     return -1;",
          "",
          "---------------"
        ],
        "wiretap/packetlogger.c||wiretap/packetlogger.c": [
          "File: wiretap/packetlogger.c -> wiretap/packetlogger.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:  }",
          "69:  if (!wtap_read_bytes(wth->fh, &type, 1, err, err_info)) {",
          "78:  }",
          "",
          "[Removed Lines]",
          "70:   if (*err == WTAP_ERR_SHORT_READ) {",
          "75:    return 0;",
          "76:   }",
          "77:   return -1;",
          "",
          "[Added Lines]",
          "70:   if (*err != WTAP_ERR_SHORT_READ)",
          "71:    return -1;",
          "72:   return 0;",
          "",
          "---------------"
        ],
        "wiretap/peekclassic.c||wiretap/peekclassic.c": [
          "File: wiretap/peekclassic.c -> wiretap/peekclassic.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:           PEEKCLASSIC_V567_HDR_SIZE);",
          "200:   if (!wtap_read_bytes(wth->fh, &ep_hdr.secondary.v567,",
          "201:       (int)sizeof(ep_hdr.secondary.v567), err, err_info)) {",
          "210:   }",
          "212:   if ((0 != ep_hdr.secondary.v567.reserved[0]) ||",
          "",
          "[Removed Lines]",
          "202:    if (*err == WTAP_ERR_SHORT_READ) {",
          "207:     return 0;",
          "208:    }",
          "209:    return -1;",
          "",
          "[Added Lines]",
          "202:    if (*err != WTAP_ERR_SHORT_READ)",
          "203:     return -1;",
          "204:    return 0;",
          "",
          "---------------"
        ],
        "wiretap/radcom.c||wiretap/radcom.c": [
          "File: wiretap/radcom.c -> wiretap/radcom.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "123:  errno = WTAP_ERR_CANT_READ;",
          "124:  if (!wtap_read_bytes(wth->fh, t_magic, 11, err, err_info)) {",
          "133:  }",
          "134:  while (memcmp(t_magic, active_time_magic, 11) != 0)",
          "135:  {",
          "",
          "[Removed Lines]",
          "125:   if (*err == WTAP_ERR_SHORT_READ) {",
          "130:    return 0;",
          "131:   }",
          "132:   return -1;",
          "",
          "[Added Lines]",
          "125:   if (*err != WTAP_ERR_SHORT_READ)",
          "126:    return -1;",
          "127:   return 0;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "137:    return -1;",
          "138:   errno = WTAP_ERR_CANT_READ;",
          "139:   if (!wtap_read_bytes(wth->fh, t_magic, 11, err, err_info)) {",
          "148:   }",
          "149:  }",
          "150:  if (file_seek(wth->fh, -43, SEEK_CUR, err) == -1) return -1;",
          "",
          "[Removed Lines]",
          "140:    if (*err == WTAP_ERR_SHORT_READ) {",
          "145:     return 0;",
          "146:    }",
          "147:    return -1;",
          "",
          "[Added Lines]",
          "135:    if (*err != WTAP_ERR_SHORT_READ)",
          "136:     return -1;",
          "137:    return 0;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "153:  errno = WTAP_ERR_CANT_READ;",
          "154:  if (!wtap_read_bytes(wth->fh, &start_date, sizeof(struct frame_date),",
          "155:      err, err_info)) {",
          "164:  }",
          "166:  if (file_seek(wth->fh, sizeof(struct frame_date), SEEK_CUR, err) == -1)",
          "",
          "[Removed Lines]",
          "156:   if (*err == WTAP_ERR_SHORT_READ) {",
          "161:    return 0;",
          "162:   }",
          "163:   return -1;",
          "",
          "[Added Lines]",
          "146:   if (*err != WTAP_ERR_SHORT_READ)",
          "147:    return -1;",
          "148:   return 0;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "170:   errno = WTAP_ERR_CANT_READ;",
          "171:   if (!wtap_read_bytes(wth->fh, search_encap, 4,",
          "172:       err, err_info)) {",
          "181:   }",
          "183:   if (memcmp(encap_magic, search_encap, 4) == 0)",
          "",
          "[Removed Lines]",
          "173:    if (*err == WTAP_ERR_SHORT_READ) {",
          "178:     return 0;",
          "179:    }",
          "180:    return -1;",
          "",
          "[Added Lines]",
          "158:    if (*err != WTAP_ERR_SHORT_READ)",
          "159:     return -1;",
          "160:    return 0;",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "196:   return -1;",
          "197:  errno = WTAP_ERR_CANT_READ;",
          "198:  if (!wtap_read_bytes(wth->fh, search_encap, 4, err, err_info)) {",
          "207:  }",
          "",
          "[Removed Lines]",
          "199:   if (*err == WTAP_ERR_SHORT_READ) {",
          "204:    return 0;",
          "205:   }",
          "206:   return -1;",
          "",
          "[Added Lines]",
          "179:   if (*err != WTAP_ERR_SHORT_READ)",
          "180:    return -1;",
          "181:   return 0;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "804409747357071631867ccbabc16a5575f5f364",
      "candidate_info": {
        "commit_hash": "804409747357071631867ccbabc16a5575f5f364",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/804409747357071631867ccbabc16a5575f5f364",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Fix the x64 builds after the commit:b3b1f7c3aa2233a147294bad833b748d38fba84d From Change: 2803\n\nChange-Id: Ic57fb0e3c1e0450561aebe48a873a3fdb2e8e105\nReviewed-on: https://code.wireshark.org/review/3014\nReviewed-by: Graham Bloice <graham.bloice@trihedral.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "217:         ++msg_part;",
          "219:         msg_end = (guint8 *) memchr(msg_part, '\\0', msg_len);",
          "221:         if (msg_end && (msg_payload + payload_length - 1 != msg_end))",
          "",
          "[Removed Lines]",
          "218:         msg_len = payload_length - (msg_part - msg_payload);",
          "",
          "[Added Lines]",
          "218:         msg_len = (guint16)(payload_length - (msg_part - msg_payload));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "249:     payload_length = pletoh16(tmp);",
          "251:     if (logcat->version == 1) {",
          "253:     } else if (logcat->version == 2) {",
          "255:     } else {",
          "256:         return FALSE;",
          "257:     }",
          "",
          "[Removed Lines]",
          "252:         packet_size = sizeof(struct logger_entry) + payload_length;",
          "254:         packet_size = sizeof(struct logger_entry_v2) + payload_length;",
          "",
          "[Added Lines]",
          "252:         packet_size = (gint)sizeof(struct logger_entry) + payload_length;",
          "254:         packet_size = (gint)sizeof(struct logger_entry_v2) + payload_length;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ef1b11f622ce61bc363e13ec6b80afaae9642441",
      "candidate_info": {
        "commit_hash": "ef1b11f622ce61bc363e13ec6b80afaae9642441",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/ef1b11f622ce61bc363e13ec6b80afaae9642441",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Fix Dead Store (Dead assignement/Dead increment) warning found by Clang\n\nChange-Id: I17dc2259e039586b9a06944bd1c2b552dd23855d\nReviewed-on: https://code.wireshark.org/review/3052\nReviewed-by: Evan Huus <eapache@gmail.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "199:             if (*err == 0 && bytes_read != 0)",
          "203:             break;",
          "204:         }",
          "205:         read_sofar += bytes_read;",
          "",
          "[Removed Lines]",
          "202:             version = -1;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5b7ad8278ac70ffb26ca12960dfe45ba4cab8368",
      "candidate_info": {
        "commit_hash": "5b7ad8278ac70ffb26ca12960dfe45ba4cab8368",
        "repo": "wireshark/wireshark",
        "commit_url": "https://github.com/wireshark/wireshark/commit/5b7ad8278ac70ffb26ca12960dfe45ba4cab8368",
        "files": [
          "wiretap/logcat.c"
        ],
        "message": "Try to fix Buildbot (Mac OS X and Windows) about conversion\n\nlogcat.c: In function 'detect_version':\nlogcat.c:142: warning: implicit conversion shortens 64-bit value into a 32-bit value\nlogcat.c:143: warning: implicit conversion shortens 64-bit value into a 32-bit value\nlogcat.c:150: warning: implicit conversion shortens 64-bit value into a 32-bit value\nlogcat.c:151: warning: implicit conversion shortens 64-bit value into a 32-bit value\nlogcat.c: In function 'logcat_dump_text':\nlogcat.c:427: warning: implicit conversion shortens 64-bit value into a 32-bit value\nlogcat.c:451: warning: implicit conversion shortens 64-bit value into a 32-bit value\n\nChange-Id: I4361567e599b7d04f422fccd7f8b1bccc897f114\nReviewed-on: https://code.wireshark.org/review/744\nReviewed-by: Alexis La Goutte <alexis.lagoutte@gmail.com>",
        "before_after_code_files": [
          "wiretap/logcat.c||wiretap/logcat.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ],
          "candidate": [
            "wiretap/logcat.c||wiretap/logcat.c"
          ]
        }
      },
      "candidate_diff": {
        "wiretap/logcat.c||wiretap/logcat.c": [
          "File: wiretap/logcat.c -> wiretap/logcat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "139:     }",
          "141:     if (try_header_size == 24) {",
          "144:         if (payload_length == 1 + tag_length + log_length) {",
          "145:             g_free(buffer);",
          "146:             return 2;",
          "147:         }",
          "148:     }",
          "152:     if (payload_length == 1 + tag_length + log_length) {",
          "153:         if (file_seek(wth->fh, file_offset + 4 * 4 + 1 + tag_length + log_length, SEEK_SET, err) == -1) {",
          "154:             g_free(buffer);",
          "",
          "[Removed Lines]",
          "142:         tag_length = strlen(buffer + 5 * 4 + 1) + 1;",
          "143:         log_length = strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "150:     tag_length = strlen(buffer + 4 * 4 + 1) + 1;",
          "151:     log_length = strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "",
          "[Added Lines]",
          "142:         tag_length = (guint32)strlen(buffer + 5 * 4 + 1) + 1;",
          "143:         log_length = (guint32)strlen(buffer + 5 * 4 + 1 + tag_length) + 1;",
          "150:     tag_length = (guint32)strlen(buffer + 4 * 4 + 1) + 1;",
          "151:     log_length = (guint32)strlen(buffer + 4 * 4 + 1 + tag_length) + 1;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "424:             return FALSE;",
          "425:         }",
          "426:         g_free(log_part);",
          "429:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "430:             g_free(buf);",
          "",
          "[Removed Lines]",
          "427:         length = strlen(buf);",
          "",
          "[Added Lines]",
          "427:         length = (guint32)strlen(buf);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "448:             return FALSE;",
          "449:         }",
          "450:         g_free(log_part);",
          "453:         if (!wtap_dump_file_write(wdh, buf, length, err)) {",
          "454:             g_free(buf);",
          "",
          "[Removed Lines]",
          "451:         length = strlen(buf);",
          "",
          "[Added Lines]",
          "451:         length = (guint32)strlen(buf);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-19963",
  "cve_desc": "An issue was discovered in wolfSSL before 4.3.0 in a non-default configuration where DSA is enabled. DSA signing uses the BEEA algorithm during modular inversion of the nonce, leading to a side-channel attack against the nonce.",
  "repo": "wolfSSL/wolfssl",
  "patch_hash": "7e391f0fd57f2ef375b1174d752a56ce34b2b190",
  "patch_info": {
    "commit_hash": "7e391f0fd57f2ef375b1174d752a56ce34b2b190",
    "repo": "wolfSSL/wolfssl",
    "commit_url": "https://github.com/wolfSSL/wolfssl/commit/7e391f0fd57f2ef375b1174d752a56ce34b2b190",
    "files": [
      "wolfcrypt/src/dsa.c",
      "src/internal.c",
      "src/ocsp.c",
      "src/ssl.c",
      "src/tls13.c",
      "tests/api.c",
      "wolfcrypt/src/asn.c",
      "wolfcrypt/src/evp.c",
      "wolfcrypt/src/integer.c",
      "wolfcrypt/src/poly1305_asm.S",
      "wolfcrypt/src/sp_int.c",
      "wolfcrypt/src/tfm.c",
      "wolfcrypt/test/test.c",
      "wolfssl/error-ssl.h",
      "wolfssl/internal.h",
      "wolfssl/openssl/ssl.h",
      "wolfssl/ssl.h",
      "wolfssl/wolfcrypt/asn.h",
      "wolfssl/wolfcrypt/asn_public.h",
      "wolfssl/wolfcrypt/settings.h",
      "wolfssl/wolfcrypt/types.h"
    ],
    "message": "Merge pull request #2629 from SparkiDev/dsa_blinding\n\nBlinding for DSA sign",
    "before_after_code_files": [
      "wolfcrypt/src/dsa.c||wolfcrypt/src/dsa.c"
    ]
  },
  "patch_diff": {
    "wolfcrypt/src/dsa.c||wolfcrypt/src/dsa.c": [
      "File: wolfcrypt/src/dsa.c -> wolfcrypt/src/dsa.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "663: int wc_DsaSign(const byte* digest, byte* out, DsaKey* key, WC_RNG* rng)",
      "664: {",
      "665:     mp_int  k, kInv, r, s, H;",
      "666:     mp_int* qMinus1;",
      "667:     int     ret = 0, sz;",
      "668:     byte    buffer[DSA_HALF_SIZE];",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "666: #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
      "667:     mp_int  b;",
      "668: #endif",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "677:     sz = min((int)sizeof(buffer), mp_unsigned_bin_size(&key->q));",
      "679:     if (mp_init_multi(&k, &kInv, &r, &s, &H, 0) != MP_OKAY)",
      "680:         return MP_INIT_E;",
      "681:     qMinus1 = &kInv;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "682: #ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
      "684: #else",
      "685:     if (mp_init_multi(&k, &kInv, &r, &s, &H, &b) != MP_OKAY)",
      "686: #endif",
      "687:     {",
      "689:     }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "708:     if (ret == 0 && mp_add_d(&k, 1, &k) != MP_OKAY)",
      "709:         ret = MP_MOD_E;",
      "712:     if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)",
      "713:         ret = MP_INVMOD_E;",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "720: #ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "735:     if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)",
      "736:         ret = MP_MULMOD_E;",
      "739:     if (ret == 0 && (mp_iszero(&r) == MP_YES || mp_iszero(&s) == MP_YES))",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "747: #else",
      "751:     if (ret == 0) {",
      "752:         do {",
      "753:             ret = wc_RNG_GenerateBlock(rng, buffer, sz);",
      "754:             if (ret == 0 && mp_read_unsigned_bin(&b, buffer, sz) != MP_OKAY)",
      "755:                 ret = MP_READ_E;",
      "756:         } while (ret == 0 && mp_cmp(&b, qMinus1) != MP_LT);",
      "757:     }",
      "758:     if (ret == 0 && mp_add_d(&b, 1, &b) != MP_OKAY)",
      "759:         ret = MP_MOD_E;",
      "762:     if (ret == 0 && mp_read_unsigned_bin(&H, digest,",
      "763:                                                WC_SHA_DIGEST_SIZE) != MP_OKAY) {",
      "764:         ret = MP_READ_E;",
      "765:     }",
      "768:     if (ret == 0 && mp_exptmod_ex(&key->g, &k, key->q.used, &key->p,",
      "769:                                                                &r) != MP_OKAY) {",
      "770:         ret = MP_EXPTMOD_E;",
      "771:     }",
      "777:     if (ret == 0 && mp_mulmod(&k, &b, &key->q, &k) != MP_OKAY)",
      "778:         ret = MP_MULMOD_E;",
      "781:     if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)",
      "782:         ret = MP_INVMOD_E;",
      "784:     if (ret == 0 && mp_mod(&r, &key->q, &r) != MP_OKAY)",
      "785:         ret = MP_MOD_E;",
      "788:     if (ret == 0 && mp_mul(&key->x, &r, &s) != MP_OKAY)",
      "789:         ret = MP_MUL_E;",
      "792:     if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)",
      "793:         ret = MP_MULMOD_E;",
      "796:     if (ret == 0 && mp_mulmod(&H, &kInv, &key->q, &H) != MP_OKAY)",
      "797:         ret = MP_MULMOD_E;",
      "801:     if (ret == 0 && mp_add(&s, &H, &s) != MP_OKAY)",
      "802:         ret = MP_ADD_E;",
      "806:     if (ret == 0 && mp_mulmod(&s, &b, &key->q, &s) != MP_OKAY)",
      "807:         ret = MP_MULMOD_E;",
      "810:     if (ret == 0 && mp_mod(&s, &key->q, &s) != MP_OKAY)",
      "811:         ret = MP_MOD_E;",
      "812: #endif",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "759:         }",
      "760:     }",
      "762:     mp_clear(&H);",
      "763:     mp_clear(&s);",
      "764:     mp_clear(&r);",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "838:     ForceZero(buffer, sz);",
      "839:     mp_forcezero(&kInv);",
      "840:     mp_forcezero(&k);",
      "841: #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
      "842:     mp_forcezero(&b);",
      "844:     mp_clear(&b);",
      "845: #endif",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b9a82204e2fd7df7bcba15bf1d2654f206c9f6bb",
      "candidate_info": {
        "commit_hash": "b9a82204e2fd7df7bcba15bf1d2654f206c9f6bb",
        "repo": "wolfSSL/wolfssl",
        "commit_url": "https://github.com/wolfSSL/wolfssl/commit/b9a82204e2fd7df7bcba15bf1d2654f206c9f6bb",
        "files": [
          "wolfcrypt/src/dsa.c"
        ],
        "message": "Blinding for DSA sign",
        "before_after_code_files": [
          "wolfcrypt/src/dsa.c||wolfcrypt/src/dsa.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/wolfSSL/wolfssl/pull/2629"
        ],
        "olp_code_files": {
          "patch": [
            "wolfcrypt/src/dsa.c||wolfcrypt/src/dsa.c"
          ],
          "candidate": [
            "wolfcrypt/src/dsa.c||wolfcrypt/src/dsa.c"
          ]
        }
      },
      "candidate_diff": {
        "wolfcrypt/src/dsa.c||wolfcrypt/src/dsa.c": [
          "File: wolfcrypt/src/dsa.c -> wolfcrypt/src/dsa.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "663: int wc_DsaSign(const byte* digest, byte* out, DsaKey* key, WC_RNG* rng)",
          "664: {",
          "665:     mp_int  k, kInv, r, s, H;",
          "666:     mp_int* qMinus1;",
          "667:     int     ret = 0, sz;",
          "668:     byte    buffer[DSA_HALF_SIZE];",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "666: #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
          "667:     mp_int  b;",
          "668: #endif",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "677:     sz = min((int)sizeof(buffer), mp_unsigned_bin_size(&key->q));",
          "679:     if (mp_init_multi(&k, &kInv, &r, &s, &H, 0) != MP_OKAY)",
          "680:         return MP_INIT_E;",
          "681:     qMinus1 = &kInv;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "682: #ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
          "684: #else",
          "685:     if (mp_init_multi(&k, &kInv, &r, &s, &H, &b) != MP_OKAY)",
          "686: #endif",
          "687:     {",
          "689:     }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "708:     if (ret == 0 && mp_add_d(&k, 1, &k) != MP_OKAY)",
          "709:         ret = MP_MOD_E;",
          "712:     if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)",
          "713:         ret = MP_INVMOD_E;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "720: #ifdef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "735:     if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)",
          "736:         ret = MP_MULMOD_E;",
          "739:     if (ret == 0 && (mp_iszero(&r) == MP_YES || mp_iszero(&s) == MP_YES))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "747: #else",
          "751:     if (ret == 0) {",
          "752:         do {",
          "753:             ret = wc_RNG_GenerateBlock(rng, buffer, sz);",
          "754:             if (ret == 0 && mp_read_unsigned_bin(&b, buffer, sz) != MP_OKAY)",
          "755:                 ret = MP_READ_E;",
          "756:         } while (ret == 0 && mp_cmp(&b, qMinus1) != MP_LT);",
          "757:     }",
          "758:     if (ret == 0 && mp_add_d(&b, 1, &b) != MP_OKAY)",
          "759:         ret = MP_MOD_E;",
          "762:     if (ret == 0 && mp_read_unsigned_bin(&H, digest,",
          "763:                                                WC_SHA_DIGEST_SIZE) != MP_OKAY) {",
          "764:         ret = MP_READ_E;",
          "765:     }",
          "768:     if (ret == 0 && mp_exptmod_ex(&key->g, &k, key->q.used, &key->p,",
          "769:                                                                &r) != MP_OKAY) {",
          "770:         ret = MP_EXPTMOD_E;",
          "771:     }",
          "777:     if (ret == 0 && mp_mulmod(&k, &b, &key->q, &k) != MP_OKAY)",
          "778:         ret = MP_MULMOD_E;",
          "781:     if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)",
          "782:         ret = MP_INVMOD_E;",
          "784:     if (ret == 0 && mp_mod(&r, &key->q, &r) != MP_OKAY)",
          "785:         ret = MP_MOD_E;",
          "788:     if (ret == 0 && mp_mul(&key->x, &r, &s) != MP_OKAY)",
          "789:         ret = MP_MUL_E;",
          "792:     if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)",
          "793:         ret = MP_MULMOD_E;",
          "796:     if (ret == 0 && mp_mulmod(&H, &kInv, &key->q, &H) != MP_OKAY)",
          "797:         ret = MP_MULMOD_E;",
          "801:     if (ret == 0 && mp_add(&s, &H, &s) != MP_OKAY)",
          "802:         ret = MP_ADD_E;",
          "806:     if (ret == 0 && mp_mulmod(&s, &b, &key->q, &s) != MP_OKAY)",
          "807:         ret = MP_MULMOD_E;",
          "810:     if (ret == 0 && mp_mod(&s, &key->q, &s) != MP_OKAY)",
          "811:         ret = MP_MOD_E;",
          "812: #endif",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "759:         }",
          "760:     }",
          "762:     mp_clear(&H);",
          "763:     mp_clear(&s);",
          "764:     mp_clear(&r);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "838:     ForceZero(buffer, sz);",
          "839:     mp_forcezero(&kInv);",
          "840:     mp_forcezero(&k);",
          "841: #ifndef WOLFSSL_MP_INVMOD_CONSTANT_TIME",
          "842:     mp_forcezero(&b);",
          "844:     mp_clear(&b);",
          "845: #endif",
          "",
          "---------------"
        ]
      }
    }
  ]
}
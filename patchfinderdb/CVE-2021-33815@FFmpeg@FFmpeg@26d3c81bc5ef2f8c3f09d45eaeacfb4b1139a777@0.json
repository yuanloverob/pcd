{
  "cve_id": "CVE-2021-33815",
  "cve_desc": "dwa_uncompress in libavcodec/exr.c in FFmpeg 4.4 allows an out-of-bounds array access because dc_count is not strictly checked.",
  "repo": "FFmpeg/FFmpeg",
  "patch_hash": "26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777",
  "patch_info": {
    "commit_hash": "26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777",
    "repo": "FFmpeg/FFmpeg",
    "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777",
    "files": [
      "libavcodec/exr.c"
    ],
    "message": "avcodec/exr: More strictly check dc_count\n\nFixes: out of array access\nFixes: exr/deneme\n\nFound-by: Burak \u00c7ar\u0131k\u00e7\u0131 <burakcarikci@crypttech.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
    "before_after_code_files": [
      "libavcodec/exr.c||libavcodec/exr.c"
    ]
  },
  "patch_diff": {
    "libavcodec/exr.c||libavcodec/exr.c": [
      "File: libavcodec/exr.c -> libavcodec/exr.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "1059:         bytestream2_skip(&gb, ac_size);",
      "1060:     }",
      "1063:         unsigned long dest_len = dc_count * 2LL;",
      "1064:         GetByteContext agb = gb;",
      "1067:             return AVERROR_INVALIDDATA;",
      "1069:         av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);",
      "",
      "[Removed Lines]",
      "1062:     if (dc_size > 0) {",
      "1066:         if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)",
      "",
      "[Added Lines]",
      "1062:     {",
      "1066:         if (dc_count != dc_w * dc_h * 3)",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "43bdf562c3f69261d742dd35dfe5147fb3c007d0",
      "candidate_info": {
        "commit_hash": "43bdf562c3f69261d742dd35dfe5147fb3c007d0",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/43bdf562c3f69261d742dd35dfe5147fb3c007d0",
        "files": [
          "libavcodec/exr.c"
        ],
        "message": "avcodec/exr: More strictly check dc_count\n\nFixes: out of array access\nFixes: exr/deneme\n\nFound-by: Burak \u00c7ar\u0131k\u00e7\u0131 <burakcarikci@crypttech.com>\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>\n(cherry picked from commit 26d3c81bc5ef2f8c3f09d45eaeacfb4b1139a777)\nSigned-off-by: Michael Niedermayer <michael@niedermayer.cc>",
        "before_after_code_files": [
          "libavcodec/exr.c||libavcodec/exr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_cherry_pick": 1,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ],
          "candidate": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/exr.c||libavcodec/exr.c": [
          "File: libavcodec/exr.c -> libavcodec/exr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "1059:         bytestream2_skip(&gb, ac_size);",
          "1060:     }",
          "1063:         unsigned long dest_len = dc_count * 2LL;",
          "1064:         GetByteContext agb = gb;",
          "1067:             return AVERROR_INVALIDDATA;",
          "1069:         av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);",
          "",
          "[Removed Lines]",
          "1062:     if (dc_size > 0) {",
          "1066:         if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)",
          "",
          "[Added Lines]",
          "1062:     {",
          "1066:         if (dc_count != dc_w * dc_h * 3)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cc85ca1cb347570a95d8615b7d4c7b542042b7f0",
      "candidate_info": {
        "commit_hash": "cc85ca1cb347570a95d8615b7d4c7b542042b7f0",
        "repo": "FFmpeg/FFmpeg",
        "commit_url": "https://github.com/FFmpeg/FFmpeg/commit/cc85ca1cb347570a95d8615b7d4c7b542042b7f0",
        "files": [
          "libavcodec/exr.c"
        ],
        "message": "avcodec/exr: add DWA decompression support",
        "before_after_code_files": [
          "libavcodec/exr.c||libavcodec/exr.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ],
          "candidate": [
            "libavcodec/exr.c||libavcodec/exr.c"
          ]
        }
      },
      "candidate_diff": {
        "libavcodec/exr.c||libavcodec/exr.c": [
          "File: libavcodec/exr.c -> libavcodec/exr.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:     EXR_PXR24,",
          "67:     EXR_B44,",
          "68:     EXR_B44A,",
          "71:     EXR_UNKN,",
          "72: };",
          "",
          "[Removed Lines]",
          "69:     EXR_DWA,",
          "70:     EXR_DWB,",
          "",
          "[Added Lines]",
          "69:     EXR_DWAA,",
          "70:     EXR_DWAB,",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "119:     uint8_t *bitmap;",
          "120:     uint16_t *lut;",
          "122:     int ysize, xsize;",
          "124:     int channel_line_size;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "122:     uint8_t *ac_data;",
          "123:     unsigned ac_size;",
          "125:     uint8_t *dc_data;",
          "126:     unsigned dc_size;",
          "128:     uint8_t *rle_data;",
          "129:     unsigned rle_size;",
          "131:     uint8_t *rle_raw_data;",
          "132:     unsigned rle_raw_size;",
          "134:     float block[3][64];",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "256:     return 0;",
          "257: }",
          "261: {",
          "263:     const int8_t *s = src;",
          "264:     int ssize       = compressed_size;",
          "265:     int dsize       = uncompressed_size;",
          "",
          "[Removed Lines]",
          "259: static int rle_uncompress(EXRContext *ctx, const uint8_t *src, int compressed_size,",
          "260:                           int uncompressed_size, EXRThreadData *td)",
          "262:     uint8_t *d      = td->tmp;",
          "",
          "[Added Lines]",
          "273: static int rle(uint8_t *dst, const uint8_t *src,",
          "274:                int compressed_size, int uncompressed_size)",
          "276:     uint8_t *d      = dst;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "295:     if (dend != d)",
          "296:         return AVERROR_INVALIDDATA;",
          "298:     av_assert1(uncompressed_size % 2 == 0);",
          "300:     ctx->dsp.predictor(td->tmp, uncompressed_size);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "312:     return 0;",
          "313: }",
          "315: static int rle_uncompress(EXRContext *ctx, const uint8_t *src, int compressed_size,",
          "316:                           int uncompressed_size, EXRThreadData *td)",
          "317: {",
          "318:     rle(td->tmp, src, compressed_size, uncompressed_size);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "475:                           GetByteContext *gb,",
          "476:                           uint16_t *dst, int dst_size)",
          "477: {",
          "479:     uint32_t nBits;",
          "480:     int ret;",
          "483:     im       = bytestream2_get_le32(gb);",
          "484:     iM       = bytestream2_get_le32(gb);",
          "485:     bytestream2_skip(gb, 4);",
          "486:     nBits = bytestream2_get_le32(gb);",
          "487:     if (im < 0 || im >= HUF_ENCSIZE ||",
          "490:         return AVERROR_INVALIDDATA;",
          "492:     bytestream2_skip(gb, 4);",
          "",
          "[Removed Lines]",
          "478:     int32_t src_size, im, iM;",
          "482:     src_size = bytestream2_get_le32(gb);",
          "488:         iM < 0 || iM >= HUF_ENCSIZE ||",
          "489:         src_size < 0)",
          "",
          "[Added Lines]",
          "500:     int32_t im, iM;",
          "509:         iM < 0 || iM >= HUF_ENCSIZE)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "660:     maxval = reverse_lut(td->bitmap, td->lut);",
          "662:     ret = huf_uncompress(s, td, &gb, tmp, dsize / sizeof(uint16_t));",
          "663:     if (ret)",
          "664:         return ret;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "682:     bytestream2_skip(&gb, 4);",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "917:     return 0;",
          "918: }",
          "920: static int decode_block(AVCodecContext *avctx, void *tdata,",
          "921:                         int jobnr, int threadnr)",
          "922: {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "941: static int ac_uncompress(EXRContext *s, GetByteContext *gb, float *block)",
          "942: {",
          "943:     int ret = 0, n = 1;",
          "945:     while (n < 64) {",
          "946:         uint16_t val = bytestream2_get_ne16(gb);",
          "948:         if (val == 0xff00) {",
          "949:             n = 64;",
          "950:         } else if ((val >> 8) == 0xff) {",
          "951:             n += val & 0xff;",
          "952:         } else {",
          "953:             ret = n;",
          "954:             block[ff_zigzag_direct[n]] = exr_half2float(val).f;",
          "955:             n++;",
          "956:         }",
          "957:     }",
          "959:     return ret;",
          "960: }",
          "962: static void idct_1d(float *blk, int step)",
          "963: {",
          "964:     const float a = .5f * cosf(    M_PI / 4.f);",
          "965:     const float b = .5f * cosf(    M_PI / 16.f);",
          "966:     const float c = .5f * cosf(    M_PI / 8.f);",
          "967:     const float d = .5f * cosf(3.f*M_PI / 16.f);",
          "968:     const float e = .5f * cosf(5.f*M_PI / 16.f);",
          "969:     const float f = .5f * cosf(3.f*M_PI / 8.f);",
          "970:     const float g = .5f * cosf(7.f*M_PI / 16.f);",
          "972:     float alpha[4], beta[4], theta[4], gamma[4];",
          "974:     alpha[0] = c * blk[2 * step];",
          "975:     alpha[1] = f * blk[2 * step];",
          "976:     alpha[2] = c * blk[6 * step];",
          "977:     alpha[3] = f * blk[6 * step];",
          "979:     beta[0] = b * blk[1 * step] + d * blk[3 * step] + e * blk[5 * step] + g * blk[7 * step];",
          "980:     beta[1] = d * blk[1 * step] - g * blk[3 * step] - b * blk[5 * step] - e * blk[7 * step];",
          "981:     beta[2] = e * blk[1 * step] - b * blk[3 * step] + g * blk[5 * step] + d * blk[7 * step];",
          "982:     beta[3] = g * blk[1 * step] - e * blk[3 * step] + d * blk[5 * step] - b * blk[7 * step];",
          "984:     theta[0] = a * (blk[0 * step] + blk[4 * step]);",
          "985:     theta[3] = a * (blk[0 * step] - blk[4 * step]);",
          "987:     theta[1] = alpha[0] + alpha[3];",
          "988:     theta[2] = alpha[1] - alpha[2];",
          "990:     gamma[0] = theta[0] + theta[1];",
          "991:     gamma[1] = theta[3] + theta[2];",
          "992:     gamma[2] = theta[3] - theta[2];",
          "993:     gamma[3] = theta[0] - theta[1];",
          "995:     blk[0 * step] = gamma[0] + beta[0];",
          "996:     blk[1 * step] = gamma[1] + beta[1];",
          "997:     blk[2 * step] = gamma[2] + beta[2];",
          "998:     blk[3 * step] = gamma[3] + beta[3];",
          "1000:     blk[4 * step] = gamma[3] - beta[3];",
          "1001:     blk[5 * step] = gamma[2] - beta[2];",
          "1002:     blk[6 * step] = gamma[1] - beta[1];",
          "1003:     blk[7 * step] = gamma[0] - beta[0];",
          "1004: }",
          "1006: static void dct_inverse(float *block)",
          "1007: {",
          "1008:     for (int i = 0; i < 8; i++)",
          "1009:         idct_1d(block + i, 8);",
          "1011:     for (int i = 0; i < 8; i++) {",
          "1012:         idct_1d(block, 1);",
          "1013:         block += 8;",
          "1014:     }",
          "1015: }",
          "1017: static void convert(float y, float u, float v,",
          "1018:                     float *b, float *g, float *r)",
          "1019: {",
          "1023: }",
          "1025: static float to_linear(float x, float scale)",
          "1026: {",
          "1027:     float ax = fabsf(x);",
          "1029:     if (ax <= 1.f) {",
          "1030:         return FFSIGN(x) * powf(ax, 2.2f * scale);",
          "1031:     } else {",
          "1032:         const float log_base = expf(2.2f * scale);",
          "1034:         return FFSIGN(x) * powf(log_base, ax - 1.f);",
          "1035:     }",
          "1036: }",
          "1038: static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,",
          "1039:                           int uncompressed_size, EXRThreadData *td)",
          "1040: {",
          "1041:     int64_t version, lo_usize, lo_size;",
          "1042:     int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size;",
          "1043:     int64_t ac_count, dc_count, ac_compression;",
          "1044:     const int dc_w = td->xsize >> 3;",
          "1045:     const int dc_h = td->ysize >> 3;",
          "1046:     GetByteContext gb, agb;",
          "1047:     int skip, ret;",
          "1049:     if (compressed_size <= 88)",
          "1050:         return AVERROR_INVALIDDATA;",
          "1052:     version = AV_RL64(src + 0);",
          "1053:     if (version != 2)",
          "1054:         return AVERROR_INVALIDDATA;",
          "1056:     lo_usize = AV_RL64(src + 8);",
          "1057:     lo_size = AV_RL64(src + 16);",
          "1058:     ac_size = AV_RL64(src + 24);",
          "1059:     dc_size = AV_RL64(src + 32);",
          "1060:     rle_csize = AV_RL64(src + 40);",
          "1061:     rle_usize = AV_RL64(src + 48);",
          "1062:     rle_raw_size = AV_RL64(src + 56);",
          "1063:     ac_count = AV_RL64(src + 64);",
          "1064:     dc_count = AV_RL64(src + 72);",
          "1065:     ac_compression = AV_RL64(src + 80);",
          "1067:     if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize)",
          "1068:         return AVERROR_INVALIDDATA;",
          "1070:     bytestream2_init(&gb, src + 88, compressed_size - 88);",
          "1071:     skip = bytestream2_get_le16(&gb);",
          "1072:     if (skip < 2)",
          "1073:         return AVERROR_INVALIDDATA;",
          "1075:     bytestream2_skip(&gb, skip - 2);",
          "1077:     if (lo_size > 0) {",
          "1078:         if (lo_usize > uncompressed_size)",
          "1079:             return AVERROR_INVALIDDATA;",
          "1080:         bytestream2_skip(&gb, lo_size);",
          "1081:     }",
          "1083:     if (ac_size > 0) {",
          "1084:         unsigned long dest_len = ac_count * 2LL;",
          "1085:         GetByteContext agb = gb;",
          "1087:         if (ac_count > 3LL * td->xsize * s->scan_lines_per_block)",
          "1088:             return AVERROR_INVALIDDATA;",
          "1090:         av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len);",
          "1091:         if (!td->ac_data)",
          "1092:             return AVERROR(ENOMEM);",
          "1094:         switch (ac_compression) {",
          "1095:         case 0:",
          "1096:             ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count);",
          "1097:             if (ret < 0)",
          "1098:                 return ret;",
          "1099:             break;",
          "1100:         case 1:",
          "1101:             if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK ||",
          "1102:                 dest_len != ac_count * 2LL)",
          "1103:                 return AVERROR_INVALIDDATA;",
          "1104:             break;",
          "1105:         default:",
          "1106:             return AVERROR_INVALIDDATA;",
          "1107:         }",
          "1109:         bytestream2_skip(&gb, ac_size);",
          "1110:     }",
          "1112:     if (dc_size > 0) {",
          "1113:         unsigned long dest_len = dc_count * 2LL;",
          "1114:         GetByteContext agb = gb;",
          "1116:         if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64)",
          "1117:             return AVERROR_INVALIDDATA;",
          "1119:         av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2);",
          "1120:         if (!td->dc_data)",
          "1121:             return AVERROR(ENOMEM);",
          "1123:         if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK ||",
          "1124:             (dest_len != dc_count * 2LL))",
          "1125:             return AVERROR_INVALIDDATA;",
          "1127:         s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len);",
          "1128:         s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len);",
          "1130:         bytestream2_skip(&gb, dc_size);",
          "1131:     }",
          "1133:     if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) {",
          "1134:         unsigned long dest_len = rle_usize;",
          "1136:         av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize);",
          "1137:         if (!td->rle_data)",
          "1138:             return AVERROR(ENOMEM);",
          "1140:         av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size);",
          "1141:         if (!td->rle_raw_data)",
          "1142:             return AVERROR(ENOMEM);",
          "1144:         if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK ||",
          "1145:             (dest_len != rle_usize))",
          "1146:             return AVERROR_INVALIDDATA;",
          "1148:         ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size);",
          "1149:         if (ret < 0)",
          "1150:             return ret;",
          "1151:         bytestream2_skip(&gb, rle_csize);",
          "1152:     }",
          "1154:     bytestream2_init(&agb, td->ac_data, ac_count * 2);",
          "1156:     for (int y = 0; y < td->ysize; y += 8) {",
          "1157:         for (int x = 0; x < td->xsize; x += 8) {",
          "1158:             memset(td->block, 0, sizeof(td->block));",
          "1160:             for (int j = 0; j < 3; j++) {",
          "1161:                 float *block = td->block[j];",
          "1162:                 const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j;",
          "1163:                 uint16_t *dc = (uint16_t *)td->dc_data;",
          "1164:                 float dc_val = dc[idx];",
          "1166:                 dc_val = exr_half2float(dc_val).f;",
          "1167:                 block[0] = dc_val;",
          "1168:                 ac_uncompress(s, &agb, block);",
          "1169:                 dct_inverse(block);",
          "1170:             }",
          "1172:             {",
          "1173:                 const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f;",
          "1174:                 const int o = s->nb_channels == 4;",
          "1175:                 float *bo = ((float *)td->uncompressed_data) +",
          "1176:                     y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x;",
          "1177:                 float *go = ((float *)td->uncompressed_data) +",
          "1178:                     y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x;",
          "1179:                 float *ro = ((float *)td->uncompressed_data) +",
          "1180:                     y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x;",
          "1181:                 float *yb = td->block[0];",
          "1182:                 float *ub = td->block[1];",
          "1183:                 float *vb = td->block[2];",
          "1185:                 for (int yy = 0; yy < 8; yy++) {",
          "1186:                     for (int xx = 0; xx < 8; xx++) {",
          "1187:                         const int idx = xx + yy * 8;",
          "1189:                         convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]);",
          "1191:                         bo[xx] = to_linear(bo[xx], scale);",
          "1192:                         go[xx] = to_linear(go[xx], scale);",
          "1193:                         ro[xx] = to_linear(ro[xx], scale);",
          "1194:                     }",
          "1196:                     bo += td->xsize * s->nb_channels;",
          "1197:                     go += td->xsize * s->nb_channels;",
          "1198:                     ro += td->xsize * s->nb_channels;",
          "1199:                 }",
          "1200:             }",
          "1201:         }",
          "1202:     }",
          "1204:     if (s->nb_channels < 4)",
          "1205:         return 0;",
          "1207:     for (int y = 0; y < td->ysize && td->rle_raw_data; y++) {",
          "1208:         uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels;",
          "1209:         uint8_t *ai0 = td->rle_raw_data + y * td->xsize;",
          "1210:         uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2;",
          "1212:         for (int x = 0; x < td->xsize; x++)",
          "1213:             ao[x] = exr_half2float(ai0[x] | (ai1[x] << 8)).i;",
          "1214:     }",
          "1216:     return 0;",
          "1217: }",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1072:         case EXR_B44A:",
          "1073:             ret = b44_uncompress(s, src, data_size, uncompressed_size, td);",
          "1074:             break;",
          "1075:         }",
          "1076:         if (ret < 0) {",
          "1077:             av_log(avctx, AV_LOG_ERROR, \"decode_block() failed.\\n\");",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1374:         case EXR_DWAA:",
          "1375:         case EXR_DWAB:",
          "1376:             ret = dwa_uncompress(s, src, data_size, uncompressed_size, td);",
          "1377:             break;",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1121:                 memset(ptr_x, 0, bxmin);",
          "1122:                 ptr_x += window_xoffset;",
          "1126:                     union av_intfloat32 t;",
          "1127:                     if (trc_func && c < 3) {",
          "",
          "[Removed Lines]",
          "1124:                 if (s->pixel_type == EXR_FLOAT) {",
          "",
          "[Added Lines]",
          "1426:                 if (s->pixel_type == EXR_FLOAT ||",
          "1427:                     s->compression == EXR_DWAA ||",
          "1428:                     s->compression == EXR_DWAB) {",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1766:     if ((ret = decode_header(s, picture)) < 0)",
          "1767:         return ret;",
          "1769:     switch (s->pixel_type) {",
          "1770:     case EXR_FLOAT:",
          "1771:     case EXR_HALF:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2073:     if ((s->compression == EXR_DWAA || s->compression == EXR_DWAB) &&",
          "2074:         s->pixel_type == EXR_HALF) {",
          "2075:         s->current_channel_offset *= 2;",
          "2076:         for (int i = 0; i < 4; i++)",
          "2077:             s->channel_offsets[i] *= 2;",
          "2078:     }",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1820:     case EXR_PIZ:",
          "1821:     case EXR_B44:",
          "1822:     case EXR_B44A:",
          "1823:         s->scan_lines_per_block = 32;",
          "1824:         break;",
          "1825:     default:",
          "1826:         avpriv_report_missing_feature(avctx, \"Compression %d\", s->compression);",
          "1827:         return AVERROR_PATCHWELCOME;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2134:     case EXR_DWAA:",
          "2137:     case EXR_DWAB:",
          "2138:         s->scan_lines_per_block = 256;",
          "2139:         break;",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "1981:         av_freep(&td->lut);",
          "1982:         av_freep(&td->he);",
          "1983:         av_freep(&td->freq);",
          "1984:         ff_free_vlc(&td->vlc);",
          "1985:     }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "2299:         av_freep(&td->ac_data);",
          "2300:         av_freep(&td->dc_data);",
          "2301:         av_freep(&td->rle_data);",
          "2302:         av_freep(&td->rle_raw_data);",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2021-20223",
  "cve_desc": "",
  "repo": "sqlite/sqlite",
  "patch_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
  "patch_info": {
    "commit_hash": "d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "repo": "sqlite/sqlite",
    "commit_url": "https://github.com/sqlite/sqlite/commit/d1d43efa4fb0f2098c0e2c5bf2e807c58d5ec05b",
    "files": [
      "ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test",
      "manifest",
      "manifest.uuid"
    ],
    "message": "Prevent fts5 tokenizer unicode61 from considering '\\0' to be a token characters, even if other characters of class \"Cc\" are.\n\nFossilOrigin-Name: b7b7bde9b7a03665e3691c6d51118965f216d2dfb1617f138b9f9e60e418ed2f",
    "before_after_code_files": [
      "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c",
      "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test",
      "manifest.uuid||manifest.uuid"
    ]
  },
  "patch_diff": {
    "ext/fts5/fts5_unicode2.c||ext/fts5/fts5_unicode2.c": [
      "File: ext/fts5/fts5_unicode2.c -> ext/fts5/fts5_unicode2.c"
    ],
    "ext/fts5/test/fts5tok1.test||ext/fts5/test/fts5tok1.test": [
      "File: ext/fts5/test/fts5tok1.test -> ext/fts5/test/fts5tok1.test",
      "--- Hunk 1 ---",
      "[Context before]",
      "111:   SELECT * FROM t4;",
      "112: } {1 {SQL logic error}}",
      "115: finish_test",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "114: #-------------------------------------------------------------------------",
      "115: # Embedded 0x00 characters.",
      "116: #",
      "117: reset_db",
      "118: do_execsql_test 3.1.0 {",
      "119:   CREATE VIRTUAL TABLE t1 USING fts5(z);",
      "120:   CREATE VIRTUAL TABLE tt USING fts5vocab(t1, 'instance');",
      "121:   INSERT INTO t1 VALUES('abc' || char(0) || 'def');",
      "122:   SELECT * FROM tt;",
      "123: } { abc 1 z 0 def 1 z 1 }",
      "124: do_execsql_test 3.1.1 {",
      "125:   SELECT hex(z) FROM t1;",
      "126: } {61626300646566}",
      "127: do_execsql_test 3.1.2 {",
      "128:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "129: } {}",
      "131: do_execsql_test 3.2.0 {",
      "132:   CREATE VIRTUAL TABLE t2 USING fts5(z,",
      "133:       tokenize=\"unicode61 categories 'L* N* Co Cc'\"",
      "134:   );",
      "135:   CREATE VIRTUAL TABLE tu USING fts5vocab(t2, 'instance');",
      "137:   INSERT INTO t2 VALUES('abc' || char(0) || 'def');",
      "138:   SELECT * FROM tu;",
      "139: } { abc 1 z 0 def 1 z 1 }",
      "141: do_execsql_test 3.2.1 {",
      "142:   SELECT hex(z) FROM t1;",
      "143: } {61626300646566}",
      "145: do_execsql_test 3.2.2 {",
      "146:   INSERT INTO t1(t1) VALUES('integrity-check');",
      "147: } {}",
      "",
      "---------------"
    ],
    "manifest.uuid||manifest.uuid": [
      "File: manifest.uuid -> manifest.uuid",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "1: 0e7e113d9f2c929c1f8a85e2cfad8e2e60f0e8770212b5e5320fb2a2c42911f8",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "b7e519956a3a38f4a5b0c1c52a654d47b199f070",
      "candidate_info": {
        "commit_hash": "b7e519956a3a38f4a5b0c1c52a654d47b199f070",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b7e519956a3a38f4a5b0c1c52a654d47b199f070",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/treeview.c"
        ],
        "message": "In the TreeView debugging output, show a \"DDL\" mark on SrcList and Expr nodes that derive from a non-TEMP schema.\n\nFossilOrigin-Name: fe7472fd2a70b4df6cb62041b72ed1638ba27ed1e6ceb8aaf56d1c8a82d91889",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/treeview.c||src/treeview.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 5962921fceaf2ec645379a5f1d18e2c2c13abbf92cf64606caee69f45a21c500",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/treeview.c||src/treeview.c": [
          "File: src/treeview.c -> src/treeview.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "147:     if( pItem->fg.jointype & JT_LEFT ){",
          "148:       sqlite3_str_appendf(&x, \" LEFT-JOIN\");",
          "149:     }",
          "150:     sqlite3StrAccumFinish(&x);",
          "151:     sqlite3TreeViewItem(pView, zLine, i<pSrc->nSrc-1);",
          "152:     if( pItem->pSelect ){",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "150:     if( pItem->fg.fromDDL ){",
          "151:       sqlite3_str_appendf(&x, \" DDL\");",
          "152:     }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "403:     return;",
          "404:   }",
          "405:   if( pExpr->flags || pExpr->affExpr ){",
          "406:     if( ExprHasProperty(pExpr, EP_FromJoin) ){",
          "413:     }",
          "414:   }else{",
          "415:     zFlgs[0] = 0;",
          "416:   }",
          "",
          "[Removed Lines]",
          "407:       sqlite3_snprintf(sizeof(zFlgs),zFlgs,\"  fg.af=%x.%c iRJT=%d\",",
          "408:                        pExpr->flags, pExpr->affExpr ? pExpr->affExpr : 'n',",
          "409:                        pExpr->iRightJoinTable);",
          "410:     }else{",
          "411:       sqlite3_snprintf(sizeof(zFlgs),zFlgs,\"  fg.af=%x.%c\",",
          "412:                        pExpr->flags, pExpr->affExpr ? pExpr->affExpr : 'n');",
          "",
          "[Added Lines]",
          "409:     StrAccum x;",
          "410:     sqlite3StrAccumInit(&x, 0, zFlgs, sizeof(zFlgs), 0);",
          "411:     sqlite3_str_appendf(&x, \" fg.af=%x.%c\",",
          "412:       pExpr->flags, pExpr->affExpr ? pExpr->affExpr : 'n');",
          "414:       sqlite3_str_appendf(&x, \" iRJT=%d\", pExpr->iRightJoinTable);",
          "416:     if( ExprHasProperty(pExpr, EP_FromDDL) ){",
          "417:       sqlite3_str_appendf(&x, \" DDL\");",
          "418:     }",
          "419:     sqlite3StrAccumFinish(&x);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a2d50283dbb176c6fd5853a3d821f1ace2ef008b",
      "candidate_info": {
        "commit_hash": "a2d50283dbb176c6fd5853a3d821f1ace2ef008b",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/a2d50283dbb176c6fd5853a3d821f1ace2ef008b",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/btree.c",
          "src/sqliteInt.h"
        ],
        "message": "Early detection of database corruption in balance_deeper().\n\nFossilOrigin-Name: 61c2233654158e65a3d3baeea947903a919a569fcc4a5b342b2e9a68cec1b6f3",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/btree.c||src/btree.c",
          "src/sqliteInt.h||src/sqliteInt.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 2f17974912ec5e99089dc0da803e7ff1bf033377a49762d2689a812c005f2641",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/btree.c||src/btree.c": [
          "File: src/btree.c -> src/btree.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "5724:   if( idx>=pPage->nCell ){",
          "5725:     if( !pPage->leaf ){",
          "",
          "[Removed Lines]",
          "5722:   testcase( idx>pPage->nCell );",
          "",
          "[Added Lines]",
          "5725:   harmless( idx>pPage->nCell );",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "8308:   return SQLITE_OK;",
          "8309: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "8325: static int anotherValidCursor(BtCursor *pCur){",
          "8326:   BtCursor *pOther;",
          "8327:   for(pOther=pCur->pBt->pCursor; pOther; pOther=pOther->pNext){",
          "8328:     if( pOther!=pCur",
          "8329:      && pOther->eState==CURSOR_VALID",
          "8330:      && pOther->pPage==pCur->pPage",
          "8331:     ){",
          "8332:       return SQLITE_CORRUPT_BKPT;",
          "8333:     }",
          "8334:   }",
          "8335:   return SQLITE_OK;",
          "8336: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "8335:     if( pPage->nOverflow==0 && pPage->nFree<=nMin ){",
          "8336:       break;",
          "8337:     }else if( (iPage = pCur->iPage)==0 ){",
          "",
          "[Removed Lines]",
          "8338:       if( pPage->nOverflow ){",
          "",
          "[Added Lines]",
          "8365:       if( pPage->nOverflow && (rc = anotherValidCursor(pCur))==SQLITE_OK ){",
          "",
          "---------------"
        ],
        "src/sqliteInt.h||src/sqliteInt.h": [
          "File: src/sqliteInt.h -> src/sqliteInt.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "446: # define NEVER(X)       (X)",
          "447: #endif",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "463: #ifdef SQLITE_DEBUG",
          "464: # define harmless(X)  assert(!(X));",
          "465: #else",
          "466: # define harmless(X)",
          "467: #endif",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "c40076a8cf32c0b54edc09a407d7d7c1c3ee9ae9",
      "candidate_info": {
        "commit_hash": "c40076a8cf32c0b54edc09a407d7d7c1c3ee9ae9",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/c40076a8cf32c0b54edc09a407d7d7c1c3ee9ae9",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/vdbe.c"
        ],
        "message": "Improved performance by manually in-lining the sqlite3VdbeIdxKeyCompare() routine for the OP_IdxGT opcode and its kin.\n\nFossilOrigin-Name: 2206a2c848a122ee220c89427f9be0460cba0706f58852139d7b37184ce29a29",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/vdbe.c||src/vdbe.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 8fd7d8dfcd515aa6b65d6eb27b033d3b3a31db467b9100cc13c62bc60113019e",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/vdbe.c||src/vdbe.c": [
          "File: src/vdbe.c -> src/vdbe.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "6026:     }",
          "6027:   }",
          "6028: #endif",
          "6031:   assert( (OP_IdxLE&1)==(OP_IdxLT&1) && (OP_IdxGE&1)==(OP_IdxGT&1) );",
          "6032:   if( (pOp->opcode&1)==(OP_IdxLT&1) ){",
          "6033:     assert( pOp->opcode==OP_IdxLE || pOp->opcode==OP_IdxLT );",
          "",
          "[Removed Lines]",
          "6030:   rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);",
          "",
          "[Added Lines]",
          "6031:   {",
          "6032:     i64 nCellKey = 0;",
          "6033:     BtCursor *pCur;",
          "6034:     Mem m;",
          "6036:     assert( pC->eCurType==CURTYPE_BTREE );",
          "6037:     pCur = pC->uc.pCursor;",
          "6038:     assert( sqlite3BtreeCursorIsValid(pCur) );",
          "6039:     nCellKey = sqlite3BtreePayloadSize(pCur);",
          "6042:     if( nCellKey<=0 || nCellKey>0x7fffffff ){",
          "6043:       rc = SQLITE_CORRUPT_BKPT;",
          "6044:       goto abort_due_to_error;",
          "6045:     }",
          "6046:     sqlite3VdbeMemInit(&m, db, 0);",
          "6047:     rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, (u32)nCellKey, &m);",
          "6048:     if( rc ) goto abort_due_to_error;",
          "6049:     res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, &r, 0);",
          "6050:     sqlite3VdbeMemRelease(&m);",
          "6051:   }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "6037:     res++;",
          "6038:   }",
          "6039:   VdbeBranchTaken(res>0,2);",
          "6041:   if( res>0 ) goto jump_to_p2;",
          "6042:   break;",
          "6043: }",
          "",
          "[Removed Lines]",
          "6040:   if( rc ) goto abort_due_to_error;",
          "",
          "[Added Lines]",
          "6063:   assert( rc==SQLITE_OK );",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "cde342df7063b09a47e960da640d03ca3e3a5e8f",
      "candidate_info": {
        "commit_hash": "cde342df7063b09a47e960da640d03ca3e3a5e8f",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/cde342df7063b09a47e960da640d03ca3e3a5e8f",
        "files": [
          "manifest",
          "manifest.uuid",
          "src/dbstat.c",
          "test/stat.test"
        ],
        "message": "Enhancements to DBSTAT:  (1) Make name=? queries efficient.  (2) Add the ability to aggregate results across each individual btree using the aggregate=TRUE constraint in the WHERE clause.\n\nFossilOrigin-Name: a48f6e17599d7ec794cfcd60858d6a69cf05caaae9321048b111fedd86a3b5b2",
        "before_after_code_files": [
          "manifest.uuid||manifest.uuid",
          "src/dbstat.c||src/dbstat.c",
          "test/stat.test||test/stat.test"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: 4330f0795dbc2ab41dddd41d5979331fb9b78c477c66367c4be52f929531a45f",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "src/dbstat.c||src/dbstat.c": [
          "File: src/dbstat.c -> src/dbstat.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "75: typedef struct StatTable StatTable;",
          "76: typedef struct StatCursor StatCursor;",
          "77: typedef struct StatPage StatPage;",
          "78: typedef struct StatCell StatCell;",
          "80: struct StatCell {",
          "",
          "[Removed Lines]",
          "59: #define VTAB_SCHEMA                                                         \\",
          "60:   \"CREATE TABLE xx( \"                                                       \\",
          "61:   \"  name       TEXT,             /* Name of table or index */\"             \\",
          "62:   \"  path       TEXT,             /* Path to page from root */\"             \\",
          "63:   \"  pageno     INTEGER,          /* Page number */\"                        \\",
          "64:   \"  pagetype   TEXT,             /* 'internal', 'leaf' or 'overflow' */\"   \\",
          "65:   \"  ncell      INTEGER,          /* Cells on page (0 for overflow) */\"     \\",
          "66:   \"  payload    INTEGER,          /* Bytes of payload on this page */\"      \\",
          "67:   \"  unused     INTEGER,          /* Bytes of unused space on this page */\" \\",
          "68:   \"  mx_payload INTEGER,          /* Largest payload size of all cells */\"  \\",
          "69:   \"  pgoffset   INTEGER,          /* Offset of page in file */\"             \\",
          "70:   \"  pgsize     INTEGER,          /* Size of the page */\"                   \\",
          "71:   \"  schema     TEXT HIDDEN       /* Database schema being analyzed */\"     \\",
          "72:   \");\"",
          "",
          "[Added Lines]",
          "59: static const char zDbstatSchema[] =",
          "60:   \"CREATE TABLE x(\"",
          "73:   \")\"",
          "74: ;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "87: };",
          "89: struct StatPage {",
          "",
          "[Removed Lines]",
          "90:   u32 iPgno;",
          "91:   DbPage *pPg;",
          "92:   int iCell;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "103: };",
          "105: struct StatCursor {",
          "125: };",
          "127: struct StatTable {",
          "131: };",
          "",
          "[Removed Lines]",
          "106:   sqlite3_vtab_cursor base;",
          "111:   StatPage aPage[32];",
          "128:   sqlite3_vtab base;",
          "129:   sqlite3 *db;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "159:   }else{",
          "160:     iDb = 0;",
          "161:   }",
          "163:   if( rc==SQLITE_OK ){",
          "164:     pTab = (StatTable *)sqlite3_malloc64(sizeof(StatTable));",
          "165:     if( pTab==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Removed Lines]",
          "162:   rc = sqlite3_declare_vtab(db, VTAB_SCHEMA);",
          "",
          "[Added Lines]",
          "170:   rc = sqlite3_declare_vtab(db, zDbstatSchema);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "185: }",
          "194: static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){",
          "195:   int i;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "207:   int iSchema = -1;",
          "208:   int iName = -1;",
          "209:   int iAgg = -1;",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "202:   for(i=0; i<pIdxInfo->nConstraint; i++){",
          "205:     if( pIdxInfo->aConstraint[i].op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;",
          "211:   }",
          "",
          "[Removed Lines]",
          "203:     if( pIdxInfo->aConstraint[i].iColumn!=10 ) continue;",
          "204:     if( pIdxInfo->aConstraint[i].usable==0 ) return SQLITE_CONSTRAINT;",
          "206:     pIdxInfo->idxNum = 1;",
          "207:     pIdxInfo->estimatedCost = 1.0;",
          "208:     pIdxInfo->aConstraintUsage[i].argvIndex = 1;",
          "209:     pIdxInfo->aConstraintUsage[i].omit = 1;",
          "210:     break;",
          "",
          "[Added Lines]",
          "218:     if( pIdxInfo->aConstraint[i].usable==0 ){",
          "220:       return SQLITE_CONSTRAINT;",
          "221:     }",
          "222:     switch( pIdxInfo->aConstraint[i].iColumn ){",
          "224:         iName = i;",
          "225:         break;",
          "226:       }",
          "228:         iSchema = i;",
          "229:         break;",
          "230:       }",
          "232:         iAgg = i;",
          "233:         break;",
          "234:       }",
          "235:     }",
          "237:   i = 0;",
          "238:   if( iSchema>=0 ){",
          "239:     pIdxInfo->aConstraintUsage[iSchema].argvIndex = ++i;",
          "240:     pIdxInfo->aConstraintUsage[iSchema].omit = 1;",
          "241:     pIdxInfo->idxNum |= 0x01;",
          "242:   }",
          "243:   if( iName>=0 ){",
          "244:     pIdxInfo->aConstraintUsage[iName].argvIndex = ++i;",
          "245:     pIdxInfo->aConstraintUsage[iName].omit = 1;",
          "246:     pIdxInfo->idxNum |= 0x02;",
          "247:   }",
          "248:   if( iAgg>=0 ){",
          "249:     pIdxInfo->aConstraintUsage[iAgg].argvIndex = ++i;",
          "250:     pIdxInfo->aConstraintUsage[iAgg].omit = 1;",
          "251:     pIdxInfo->idxNum |= 0x04;",
          "252:   }",
          "253:   pIdxInfo->estimatedCost = 1.0;",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "227:      )",
          "228:   ){",
          "229:     pIdxInfo->orderByConsumed = 1;",
          "230:   }",
          "232:   return SQLITE_OK;",
          "233: }",
          "238: static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){",
          "239:   StatTable *pTab = (StatTable *)pVTab;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "271:     pIdxInfo->idxNum |= 0x08;",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "283:   pCsr->isEof = 0;",
          "284: }",
          "289: static int statClose(sqlite3_vtab_cursor *pCursor){",
          "290:   StatCursor *pCsr = (StatCursor *)pCursor;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "329: static void statResetCounts(StatCursor *pCsr){",
          "330:   pCsr->nCell = 0;",
          "331:   pCsr->nMxPayload = 0;",
          "332:   pCsr->nUnused = 0;",
          "333:   pCsr->nPayload = 0;",
          "334:   pCsr->szPage = 0;",
          "335:   pCsr->nPage = 0;",
          "336: }",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "294:   return SQLITE_OK;",
          "295: }",
          "302: ){",
          "303:   int nLocal;",
          "304:   int nMinLocal;",
          "",
          "[Removed Lines]",
          "297: static void getLocalPayload(",
          "",
          "[Added Lines]",
          "354: static int getLocalPayload(",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "315:   nLocal = nMinLocal + (nTotal - nMinLocal) % (nUsable - 4);",
          "316:   if( nLocal>nMaxLocal ) nLocal = nMinLocal;",
          "318: }",
          "320: static int statDecodePage(Btree *pBt, StatPage *p){",
          "321:   int nUnused;",
          "322:   int iOff;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "373:   return nLocal;",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "387:           iOff += sqlite3GetVarint(&aData[iOff], &dummy);",
          "388:         }",
          "389:         if( nPayload>(u32)p->nMxPayload ) p->nMxPayload = nPayload;",
          "391:         if( nLocal<0 ) goto statPageIsCorrupt;",
          "392:         pCell->nLocal = nLocal;",
          "393:         assert( nPayload>=(u32)nLocal );",
          "",
          "[Removed Lines]",
          "390:         getLocalPayload(nUsable, p->flags, nPayload, &nLocal);",
          "",
          "[Added Lines]",
          "449:         nLocal = getLocalPayload(nUsable, p->flags, nPayload);",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "437:   sqlite3_file *fd;",
          "438:   sqlite3_int64 x[2];",
          "447:   fd = sqlite3PagerFile(pPager);",
          "448:   x[0] = pCsr->iPageno;",
          "449:   if( sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){",
          "450:     pCsr->iOffset = x[0];",
          "452:   }",
          "453: }",
          "458: static int statNext(sqlite3_vtab_cursor *pCursor){",
          "459:   int rc;",
          "",
          "[Removed Lines]",
          "441:   pCsr->szPage = sqlite3BtreeGetPageSize(pBt);",
          "442:   pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "451:     pCsr->szPage = (int)x[1];",
          "",
          "[Added Lines]",
          "506:     pCsr->szPage += x[1];",
          "507:   }else{",
          "509:     pCsr->szPage += sqlite3BtreeGetPageSize(pBt);",
          "510:     pCsr->iOffset = (i64)pCsr->szPage * (pCsr->iPageno - 1);",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "470: statNextRestart:",
          "471:   if( pCsr->aPage[0].pPg==0 ){",
          "472:     rc = sqlite3_step(pCsr->pStmt);",
          "473:     if( rc==SQLITE_ROW ){",
          "474:       int nPage;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "534:     statResetCounts(pCsr);",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "481:       rc = sqlite3PagerGet(pPager, iRoot, &pCsr->aPage[0].pPg, 0);",
          "482:       pCsr->aPage[0].iPgno = iRoot;",
          "483:       pCsr->aPage[0].iCell = 0;",
          "485:       pCsr->iPage = 0;",
          "487:     }else{",
          "488:       pCsr->isEof = 1;",
          "489:       return sqlite3_reset(pCsr->pStmt);",
          "490:     }",
          "491:   }else{",
          "494:     StatPage *p = &pCsr->aPage[pCsr->iPage];",
          "496:     while( p->iCell<p->nCell ){",
          "497:       StatCell *pCell = &p->aCell[p->iCell];",
          "500:         sqlite3BtreeEnter(pBt);",
          "501:         nUsable = sqlite3BtreeGetPageSize(pBt) -",
          "502:                         sqlite3BtreeGetReserveNoMutex(pBt);",
          "503:         sqlite3BtreeLeave(pBt);",
          "512:         if( pCell->iOvfl<pCell->nOvfl-1 ){",
          "515:         }else{",
          "518:         }",
          "519:         pCell->iOvfl++;",
          "522:       }",
          "523:       if( p->iRightChildPg ) break;",
          "524:       p->iCell++;",
          "",
          "[Removed Lines]",
          "484:       pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "486:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "498:       if( pCell->iOvfl<pCell->nOvfl ){",
          "499:         int nUsable;",
          "504:         pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "505:         pCsr->iPageno = pCell->aOvfl[pCell->iOvfl];",
          "506:         pCsr->zPagetype = \"overflow\";",
          "507:         pCsr->nCell = 0;",
          "508:         pCsr->nMxPayload = 0;",
          "509:         pCsr->zPath = z = sqlite3_mprintf(",
          "510:             \"%s%.3x+%.6x\", p->zPath, p->iCell, pCell->iOvfl",
          "511:         );",
          "513:           pCsr->nUnused = 0;",
          "514:           pCsr->nPayload = nUsable - 4;",
          "516:           pCsr->nPayload = pCell->nLastOvfl;",
          "517:           pCsr->nUnused = nUsable - 4 - pCsr->nPayload;",
          "520:         statSizeAndOffset(pCsr);",
          "521:         return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "",
          "[Added Lines]",
          "547:       if( !pCsr->isAgg ){",
          "548:         pCsr->aPage[0].zPath = z = sqlite3_mprintf(\"/\");",
          "549:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "550:       }",
          "552:       pCsr->nPage = 1;",
          "560:     if( !pCsr->isAgg ) statResetCounts(pCsr);",
          "563:       while( pCell->iOvfl<pCell->nOvfl ){",
          "564:         int nUsable, iOvfl;",
          "569:         pCsr->nPage++;",
          "570:         statSizeAndOffset(pCsr);",
          "572:           pCsr->nPayload += nUsable - 4;",
          "574:           pCsr->nPayload += pCell->nLastOvfl;",
          "575:           pCsr->nUnused += nUsable - 4 - pCell->nLastOvfl;",
          "577:         iOvfl = pCell->iOvfl;",
          "579:         if( !pCsr->isAgg ){",
          "580:           pCsr->zName = (char *)sqlite3_column_text(pCsr->pStmt, 0);",
          "581:           pCsr->iPageno = pCell->aOvfl[iOvfl];",
          "582:           pCsr->zPagetype = \"overflow\";",
          "583:           pCsr->zPath = z = sqlite3_mprintf(",
          "584:               \"%s%.3x+%.6x\", p->zPath, p->iCell, iOvfl",
          "585:           );",
          "586:           return z==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;",
          "587:         }",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "527:     if( !p->iRightChildPg || p->iCell>p->nCell ){",
          "528:       statClearPage(p);",
          "532:     }",
          "533:     pCsr->iPage++;",
          "",
          "[Removed Lines]",
          "529:       if( pCsr->iPage==0 ) return statNext(pCursor);",
          "530:       pCsr->iPage--;",
          "",
          "[Added Lines]",
          "595:       if( pCsr->iPage>0 ){",
          "596:         pCsr->iPage--;",
          "597:       }else if( pCsr->isAgg ){",
          "600:         return SQLITE_OK;",
          "601:       }",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "543:       p[1].iPgno = p->aCell[p->iCell].iChildPg;",
          "544:     }",
          "545:     rc = sqlite3PagerGet(pPager, p[1].iPgno, &p[1].pPg, 0);",
          "546:     p[1].iCell = 0;",
          "548:     p->iCell++;",
          "550:   }",
          "",
          "[Removed Lines]",
          "547:     p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "549:     if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "",
          "[Added Lines]",
          "617:     pCsr->nPage++;",
          "619:     if( !pCsr->isAgg ){",
          "620:       p[1].zPath = z = sqlite3_mprintf(\"%s%.3x/\", p->zPath, p->iCell);",
          "621:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "622:     }",
          "",
          "---------------",
          "--- Hunk 17 ---",
          "[Context before]",
          "576:           pCsr->zPagetype = \"corrupted\";",
          "577:           break;",
          "578:       }",
          "584:       nPayload = 0;",
          "585:       for(i=0; i<p->nCell; i++){",
          "586:         nPayload += p->aCell[i].nLocal;",
          "587:       }",
          "589:     }",
          "590:   }",
          "",
          "[Removed Lines]",
          "579:       pCsr->nCell = p->nCell;",
          "580:       pCsr->nUnused = p->nUnused;",
          "581:       pCsr->nMxPayload = p->nMxPayload;",
          "582:       pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "583:       if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "588:       pCsr->nPayload = nPayload;",
          "",
          "[Added Lines]",
          "653:       pCsr->nCell += p->nCell;",
          "654:       pCsr->nUnused += p->nUnused;",
          "655:       if( p->nMxPayload>pCsr->nMxPayload ) pCsr->nMxPayload = p->nMxPayload;",
          "656:       if( !pCsr->isAgg ){",
          "657:         pCsr->zPath = z = sqlite3_mprintf(\"%s\", p->zPath);",
          "658:         if( z==0 ) rc = SQLITE_NOMEM_BKPT;",
          "659:       }",
          "664:       pCsr->nPayload += nPayload;",
          "669:       if( pCsr->isAgg ) goto statNextRestart;",
          "",
          "---------------",
          "--- Hunk 18 ---",
          "[Context before]",
          "604: ){",
          "605:   StatCursor *pCsr = (StatCursor *)pCursor;",
          "606:   StatTable *pTab = (StatTable*)(pCursor->pVtab);",
          "612:     pCsr->iDb = sqlite3FindDbName(pTab->db, zDbase);",
          "613:     if( pCsr->iDb<0 ){",
          "614:       sqlite3_free(pCursor->pVtab->zErrMsg);",
          "",
          "[Removed Lines]",
          "607:   char *zSql;",
          "608:   int rc = SQLITE_OK;",
          "610:   if( idxNum==1 ){",
          "611:     const char *zDbase = (const char*)sqlite3_value_text(argv[0]);",
          "",
          "[Added Lines]",
          "698:   statResetCsr(pCsr);",
          "699:   sqlite3_finalize(pCsr->pStmt);",
          "700:   pCsr->pStmt = 0;",
          "701:   if( idxNum & 0x01 ){",
          "703:     const char *zDbase = (const char*)sqlite3_value_text(argv[iArg++]);",
          "",
          "---------------",
          "--- Hunk 19 ---",
          "[Context before]",
          "618:   }else{",
          "619:     pCsr->iDb = pTab->iDb;",
          "620:   }",
          "630:   if( zSql==0 ){",
          "631:     return SQLITE_NOMEM_BKPT;",
          "632:   }else{",
          "",
          "[Removed Lines]",
          "621:   statResetCsr(pCsr);",
          "622:   sqlite3_finalize(pCsr->pStmt);",
          "623:   pCsr->pStmt = 0;",
          "624:   zSql = sqlite3_mprintf(",
          "625:       \"SELECT 'sqlite_master' AS name, 1 AS rootpage, 'table' AS type\"",
          "626:       \"  UNION ALL  \"",
          "627:       \"SELECT name, rootpage, type\"",
          "628:       \"  FROM \\\"%w\\\".sqlite_master WHERE rootpage!=0\"",
          "629:       \"  ORDER BY name\", pTab->db->aDb[pCsr->iDb].zDbSName);",
          "",
          "[Added Lines]",
          "713:   if( idxNum & 0x02 ){",
          "715:     zName = (const char*)sqlite3_value_text(argv[iArg++]);",
          "716:   }",
          "717:   if( idxNum & 0x04 ){",
          "719:     pCsr->isAgg = sqlite3_value_double(argv[iArg++])!=0.0;",
          "720:   }else{",
          "721:     pCsr->isAgg = 0;",
          "722:   }",
          "723:   pSql = sqlite3_str_new(pTab->db);",
          "724:   sqlite3_str_appendf(pSql,",
          "725:       \"SELECT * FROM (\"",
          "726:         \"SELECT 'sqlite_master' AS name,1 AS rootpage,'table' AS type\"",
          "727:         \" UNION ALL \"",
          "728:         \"SELECT name,rootpage,type\"",
          "729:         \" FROM \\\"%w\\\".sqlite_master WHERE rootpage!=0)\",",
          "730:       pTab->db->aDb[pCsr->iDb].zDbSName);",
          "731:   if( zName ){",
          "732:     sqlite3_str_appendf(pSql, \"WHERE name=%Q\", zName);",
          "733:   }",
          "734:   if( idxNum & 0x08 ){",
          "735:     sqlite3_str_appendf(pSql, \" ORDER BY name\");",
          "736:   }",
          "737:   zSql = sqlite3_str_finish(pSql);",
          "",
          "---------------",
          "--- Hunk 20 ---",
          "[Context before]",
          "651:       sqlite3_result_text(ctx, pCsr->zName, -1, SQLITE_TRANSIENT);",
          "652:       break;",
          "655:       break;",
          "658:       break;",
          "661:       break;",
          "663:       sqlite3_result_int(ctx, pCsr->nCell);",
          "",
          "[Removed Lines]",
          "654:       sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "657:       sqlite3_result_int64(ctx, pCsr->iPageno);",
          "660:       sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "",
          "[Added Lines]",
          "762:       if( !pCsr->isAgg ){",
          "763:         sqlite3_result_text(ctx, pCsr->zPath, -1, SQLITE_TRANSIENT);",
          "764:       }",
          "767:       if( pCsr->isAgg ){",
          "768:         sqlite3_result_int64(ctx, pCsr->nPage);",
          "769:       }else{",
          "770:         sqlite3_result_int64(ctx, pCsr->iPageno);",
          "771:       }",
          "774:       if( !pCsr->isAgg ){",
          "775:         sqlite3_result_text(ctx, pCsr->zPagetype, -1, SQLITE_STATIC);",
          "776:       }",
          "",
          "---------------",
          "--- Hunk 21 ---",
          "[Context before]",
          "672:       sqlite3_result_int(ctx, pCsr->nMxPayload);",
          "673:       break;",
          "676:       break;",
          "678:       sqlite3_result_int(ctx, pCsr->szPage);",
          "679:       break;",
          "681:       sqlite3 *db = sqlite3_context_db_handle(ctx);",
          "682:       int iDb = pCsr->iDb;",
          "683:       sqlite3_result_text(ctx, db->aDb[iDb].zDbSName, -1, SQLITE_STATIC);",
          "684:       break;",
          "685:     }",
          "686:   }",
          "687:   return SQLITE_OK;",
          "688: }",
          "",
          "[Removed Lines]",
          "675:       sqlite3_result_int64(ctx, pCsr->iOffset);",
          "",
          "[Added Lines]",
          "791:       if( !pCsr->isAgg ){",
          "792:         sqlite3_result_int64(ctx, pCsr->iOffset);",
          "793:       }",
          "805:       sqlite3_result_int(ctx, pCsr->isAgg);",
          "806:       break;",
          "807:     }",
          "",
          "---------------"
        ],
        "test/stat.test||test/stat.test": [
          "File: test/stat.test -> test/stat.test",
          "--- Hunk 1 ---",
          "[Context before]",
          "108:   INSERT INTO t3 SELECT a_string(110+rowid), a_string(221+rowid) FROM t3",
          "109:    ORDER BY rowid;",
          "110:   SELECT name, path, pageno, pagetype, ncell, payload, unused, mx_payload",
          "112: } [list \\",
          "113:   sqlite_autoindex_t3_1 / 3 internal 3 368 623 125       \\",
          "114:   sqlite_autoindex_t3_1 /000/ 8 leaf 8 946 46 123        \\",
          "",
          "[Removed Lines]",
          "111:     FROM stat WHERE name != 'sqlite_master';",
          "",
          "[Added Lines]",
          "111:     FROM stat WHERE name != 'sqlite_master' ORDER BY name;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "134:   t3 /00f/ 23 leaf 2 738 268 370                         \\",
          "135: ]",
          "137: # With every index entry overflowing, make sure no pages are missed",
          "138: # (other than the locking page which is 64 in this test build.)",
          "139: #",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "137: do_execsql_test stat-2.1agg {",
          "138:   SELECT * FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "139: } [list \\",
          "140:   sqlite_autoindex_t3_1 {}  5 {} 32  3898 1065 132 {}  5120 \\",
          "141:   sqlite_master         {}  1 {}  2    84  824  49 {}  1024 \\",
          "142:   t3                    {} 17 {} 47 11188 5815 370 {} 17408 \\",
          "143: ]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "150:   CREATE INDEX i4 ON t4(x);",
          "151:   INSERT INTO t4(rowid, x) VALUES(2, a_string(7777));",
          "152:   SELECT name, path, pageno, pagetype, ncell, payload, unused, mx_payload",
          "154: } [list \\",
          "155:   i4 / 3 leaf 1 103 905 7782                 \\",
          "156:   i4 /000+000000 4 overflow 0 1020 0 0       \\",
          "",
          "[Removed Lines]",
          "153:     FROM stat WHERE name != 'sqlite_master';",
          "",
          "[Added Lines]",
          "161:     FROM stat WHERE name != 'sqlite_master' ORDER BY name;",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "171:   t4 /000+000006 18 overflow 0 1020 0 0      \\",
          "172: ]",
          "174: do_execsql_test stat-4.1 {",
          "175:   CREATE TABLE t5(x);",
          "176:   CREATE INDEX i5 ON t5(x);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "182: do_execsql_test stat-3.2 {",
          "183:   SELECT *, '|' FROM dbstat WHERE aggregate=TRUE ORDER BY name;",
          "184: } [list \\",
          "185:   i4            {} 9 {} 1 7782 1386 7782 {} 9216 | \\",
          "186:   sqlite_master {} 1 {} 2   74  834   40 {} 1024 | \\",
          "187:   t4            {} 8 {} 1 7780  367 7780 {} 8192 | \\",
          "188: ]",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "201:   t1 /001+000000 4 overflow 0 1020 0 0    \\",
          "202: ]",
          "204: do_catchsql_test stat-6.1 {",
          "205:   CREATE VIRTUAL TABLE temp.s2 USING dbstat(mainx);",
          "206: } {1 {no such database: mainx}}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "221: do_execsql_test stat-5.20 {",
          "222:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "223:          unused, mx_payload, '|' FROM dbstat('main',1);",
          "224: } {sqlite_master NULL 1 NULL 1 34 878 34 | tx NULL 1 NULL 0 0 1016 0 |}",
          "225: do_execsql_test stat-5.21 {",
          "226:   SELECT name, quote(path), pageno, quote(pagetype), ncell, payload,",
          "227:          unused, mx_payload, '|' FROM dbstat('aux1',1);",
          "228: } {sqlite_master NULL 1 NULL 1 34 878 34 | t1 NULL 3 NULL 2 3033 5 1517 |}",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b88eaf1619cf1be8c8cf2a0ffb9a2767a840b27e",
      "candidate_info": {
        "commit_hash": "b88eaf1619cf1be8c8cf2a0ffb9a2767a840b27e",
        "repo": "sqlite/sqlite",
        "commit_url": "https://github.com/sqlite/sqlite/commit/b88eaf1619cf1be8c8cf2a0ffb9a2767a840b27e",
        "files": [
          "ext/expert/sqlite3expert.h",
          "manifest",
          "manifest.uuid"
        ],
        "message": "Add header guard to the expert extension.\n\nFossilOrigin-Name: 7e3151855fd4370fb7d4fff20516c2c2d1980134620df924106e6989bc130583",
        "before_after_code_files": [
          "ext/expert/sqlite3expert.h||ext/expert/sqlite3expert.h",
          "manifest.uuid||manifest.uuid"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "manifest.uuid||manifest.uuid"
          ],
          "candidate": [
            "manifest.uuid||manifest.uuid"
          ]
        }
      },
      "candidate_diff": {
        "ext/expert/sqlite3expert.h||ext/expert/sqlite3expert.h": [
          "File: ext/expert/sqlite3expert.h -> ext/expert/sqlite3expert.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: #include \"sqlite3.h\"",
          "17: typedef struct sqlite3expert sqlite3expert;",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "13: #if !defined(SQLITEEXPERT_H)",
          "14: #define SQLITEEXPERT_H 1",
          "",
          "---------------"
        ],
        "manifest.uuid||manifest.uuid": [
          "File: manifest.uuid -> manifest.uuid",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: fa2416f623d83fe93253137302a74fcd6cdd041da337a0756df344d7d09a19f5",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
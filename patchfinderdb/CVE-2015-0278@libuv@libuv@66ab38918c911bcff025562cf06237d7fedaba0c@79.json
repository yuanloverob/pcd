{
  "cve_id": "CVE-2015-0278",
  "cve_desc": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
  "repo": "libuv/libuv",
  "patch_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
  "patch_info": {
    "commit_hash": "66ab38918c911bcff025562cf06237d7fedaba0c",
    "repo": "libuv/libuv",
    "commit_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
    "files": [
      "src/unix/process.c"
    ],
    "message": "unix: call setgoups before calling setuid/setgid\n\nPartial fix for #1093",
    "before_after_code_files": [
      "src/unix/process.c||src/unix/process.c"
    ]
  },
  "patch_diff": {
    "src/unix/process.c||src/unix/process.c": [
      "File: src/unix/process.c -> src/unix/process.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "330:     _exit(127);",
      "331:   }",
      "333:   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {",
      "334:     uv__write_int(error_fd, -errno);",
      "335:     perror(\"setgid()\");",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "333:   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
      "341:     SAVE_ERRNO(setgroups(0, NULL));",
      "342:   }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "e3ea6c1179cc8b42d6bc48df3d359a2149ebbab5",
      "candidate_info": {
        "commit_hash": "e3ea6c1179cc8b42d6bc48df3d359a2149ebbab5",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/e3ea6c1179cc8b42d6bc48df3d359a2149ebbab5",
        "files": [
          ".mailmap",
          "AUTHORS",
          "ChangeLog",
          "configure.ac",
          "include/uv-version.h"
        ],
        "message": "2014.10.21, Version 1.0.0-rc2 (Pre-release)\n\nChanges since version 1.0.0-rc1:\n\n* build: add missing fixtures to distribution tarball (Rob Adams)\n\n* doc: update references to current stable branch (Zachary Newman)\n\n* fs: fix readdir on empty directory (Fedor Indutny)\n\n* fs: rename uv_fs_readdir to uv_fs_scandir (Sa\u00fal Ibarra Corretg\u00e9)\n\n* doc: document uv_alloc_cb (Sa\u00fal Ibarra Corretg\u00e9)\n\n* doc: add migration guide from version 0.10 (Sa\u00fal Ibarra Corretg\u00e9)\n\n* build: add DragonFly BSD support in autotools (Robin Hahling)\n\n* doc: document missing stream related structures (Sa\u00fal Ibarra Corretg\u00e9)\n\n* doc: clarify uv_loop_t.data field lifetime (Sa\u00fal Ibarra Corretg\u00e9)\n\n* doc: add documentation for missing functions and structures (Sa\u00fal\n  Ibarra Corretg\u00e9)\n\n* doc: fix punctuation and grammar in README (Jeff Widman)\n\n* windows: return libuv error codes in uv_poll_init() (cjihrig)\n\n* unix, windows: add uv_fs_access() (cjihrig)\n\n* windows: fix netmask detection (Alexis Campailla)\n\n* unix, windows: don't include null byte in uv_cwd size (Sa\u00fal Ibarra\n  Corretg\u00e9)\n\n* unix, windows: add uv_thread_equal (Tomasz Ko\u0142odziejski)\n\n* windows: fix fs_write with nbufs > 1 and offset (Unknown W. Brackets)",
        "before_after_code_files": [
          "configure.ac||configure.ac",
          "include/uv-version.h||include/uv-version.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "configure.ac||configure.ac": [
          "File: configure.ac -> configure.ac",
          "--- Hunk 1 ---",
          "[Context before]",
          "13: # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.",
          "15: AC_PREREQ(2.57)",
          "17: AC_CONFIG_MACRO_DIR([m4])",
          "18: m4_include([m4/libuv-extra-automake-flags.m4])",
          "19: m4_include([m4/as_case.m4])",
          "",
          "[Removed Lines]",
          "16: AC_INIT([libuv], [1.0.0], [https://github.com/joyent/libuv/issues])",
          "",
          "[Added Lines]",
          "16: AC_INIT([libuv], [1.0.0-rc2], [https://github.com/joyent/libuv/issues])",
          "",
          "---------------"
        ],
        "include/uv-version.h||include/uv-version.h": [
          "File: include/uv-version.h -> include/uv-version.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "33: #define UV_VERSION_MAJOR 1",
          "34: #define UV_VERSION_MINOR 0",
          "35: #define UV_VERSION_PATCH 0",
          "37: #define UV_VERSION_SUFFIX \"rc2\"",
          "",
          "[Removed Lines]",
          "36: #define UV_VERSION_IS_RELEASE 0",
          "",
          "[Added Lines]",
          "36: #define UV_VERSION_IS_RELEASE 1",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "9d60f1ebda0cdedc67ee439997e60b74a40f2f3f",
      "candidate_info": {
        "commit_hash": "9d60f1ebda0cdedc67ee439997e60b74a40f2f3f",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/9d60f1ebda0cdedc67ee439997e60b74a40f2f3f",
        "files": [
          "src/unix/udp.c"
        ],
        "message": "linux: don't turn on SO_REUSEPORT socket option\n\nOn the BSDs, SO_REUSEPORT is pretty much SO_REUSEADDR with some special\ncasing for IP multicast.  When two processes (that don't do multicast)\nbind to the same address, only the last one receives traffic.  It allows\none to \"steal\" the bound address from another process.  (Both processes\nhave to enable SO_REUSEPORT though, so it only works in a cooperative\nsetting.)\n\nOn Linux however, it enables port sharing, not stealing - both processes\nreceive a share of the traffic.  This is a desirable trait but pre-3.9\nkernels don't support the socket option and a libuv program therefore\nbehaves differently with older kernels or on another platform.\n\nThe difference in behavior (sharing vs. stealing) is, in my opinion,\nbig enough and confusing enough that it merits a rollback.  People\nthat want this kind of functionality can prepare the socket manually\nand hand it off to uv_udp_open().\n\nThis commit effectively reverts commit 17452cd.",
        "before_after_code_files": [
          "src/unix/udp.c||src/unix/udp.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/udp.c||src/unix/udp.c": [
          "File: src/unix/udp.c -> src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "280: }",
          "296: static int uv__set_reuse(int fd) {",
          "297:   int yes;",
          "317:   yes = 1;",
          "318:   if (setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, &yes, sizeof(yes)))",
          "319:     return -errno;",
          "",
          "[Removed Lines]",
          "298: #if defined(__linux__)",
          "299:   static int no_so_reuseport;",
          "301:   if (no_so_reuseport)",
          "302:     goto no_so_reuseport;",
          "304:   yes = 1;",
          "305:   if (setsockopt(fd, SOL_SOCKET, 15 /* SO_REUSEPORT */, &yes, sizeof(yes))) {",
          "306:     if (errno != EINVAL && errno != ENOPROTOOPT)",
          "307:       return -errno;",
          "308:     no_so_reuseport = 1;",
          "309:   }",
          "311: no_so_reuseport:",
          "313:   yes = 1;",
          "314:   if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)))",
          "315:     return -errno;",
          "316: #elif defined(SO_REUSEPORT)",
          "",
          "[Added Lines]",
          "294: #if defined(SO_REUSEPORT) && !defined(__linux__)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7a4c42a0548b2a62de220f6063ebe349a8fb30b3",
      "candidate_info": {
        "commit_hash": "7a4c42a0548b2a62de220f6063ebe349a8fb30b3",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/7a4c42a0548b2a62de220f6063ebe349a8fb30b3",
        "files": [
          "src/unix/internal.h",
          "src/unix/tcp.c",
          "src/unix/udp.c",
          "src/win/internal.h",
          "test/test-udp-multicast-interface6.c"
        ],
        "message": "unix: add UV_HANDLE_IPV6 flag to tcp and udp handles",
        "before_after_code_files": [
          "src/unix/internal.h||src/unix/internal.h",
          "src/unix/tcp.c||src/unix/tcp.c",
          "src/unix/udp.c||src/unix/udp.c",
          "src/win/internal.h||src/win/internal.h",
          "test/test-udp-multicast-interface6.c||test/test-udp-multicast-interface6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "src/unix/internal.h||src/unix/internal.h": [
          "File: src/unix/internal.h -> src/unix/internal.h"
        ],
        "src/unix/tcp.c||src/unix/tcp.c": [
          "File: src/unix/tcp.c -> src/unix/tcp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "89:   errno = 0;",
          "90:   if (bind(tcp->io_watcher.fd, addr, addrlen) && errno != EADDRINUSE)",
          "91:     return -errno;",
          "93:   tcp->delayed_error = -errno;",
          "94:   return 0;",
          "95: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:   if (addr->sa_family == AF_INET6)",
          "95:     tcp->flags |= UV_HANDLE_IPV6;",
          "",
          "---------------"
        ],
        "src/unix/udp.c||src/unix/udp.c": [
          "File: src/unix/udp.c -> src/unix/udp.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "349:     goto out;",
          "350:   }",
          "352:   return 0;",
          "354: out:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "352:   if (addr->sa_family == AF_INET6)",
          "353:     handle->flags |= UV_HANDLE_IPV6;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "635:   if (!interface_addr) {",
          "636:     memset(&addr_st, 0, sizeof addr_st);",
          "639:   } else if (uv_ip4_addr(interface_addr, 0, addr4) == 0) {",
          "641:   } else if (uv_ip6_addr(interface_addr, 0, addr6) == 0) {",
          "",
          "[Removed Lines]",
          "637:     addr_st.ss_family = AF_INET;",
          "638:     addr4->sin_addr.s_addr = htonl(INADDR_ANY);",
          "",
          "[Added Lines]",
          "640:     if (handle->flags & UV_HANDLE_IPV6) {",
          "641:       addr_st.ss_family = AF_INET6;",
          "642:       addr6->sin6_scope_id = 0;",
          "643:     } else {",
          "644:       addr_st.ss_family = AF_INET;",
          "645:       addr4->sin_addr.s_addr = htonl(INADDR_ANY);",
          "646:     }",
          "",
          "---------------"
        ],
        "src/win/internal.h||src/win/internal.h": [
          "File: src/win/internal.h -> src/win/internal.h"
        ],
        "test/test-udp-multicast-interface6.c||test/test-udp-multicast-interface6.c": [
          "File: test/test-udp-multicast-interface6.c -> test/test-udp-multicast-interface6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "72: #if defined(__APPLE__)",
          "73:   r = uv_udp_set_multicast_interface(&server, \"::1%lo0\");",
          "74: #else",
          "76: #endif",
          "77:   ASSERT(r == 0);",
          "",
          "[Removed Lines]",
          "75:   r = uv_udp_set_multicast_interface(&server, \"::1\");",
          "",
          "[Added Lines]",
          "75:   r = uv_udp_set_multicast_interface(&server, NULL);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a669f21bf88fdd06f445e5507ed1f834c0ba6432",
      "candidate_info": {
        "commit_hash": "a669f21bf88fdd06f445e5507ed1f834c0ba6432",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/a669f21bf88fdd06f445e5507ed1f834c0ba6432",
        "files": [
          "include/uv.h",
          "src/win/fs.c"
        ],
        "message": "windows: use OpenBSD implementation for uv_fs_mkdtemp",
        "before_after_code_files": [
          "include/uv.h||include/uv.h",
          "src/win/fs.c||src/win/fs.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "include/uv.h||include/uv.h": [
          "File: include/uv.h -> include/uv.h"
        ],
        "src/win/fs.c||src/win/fs.c": [
          "File: src/win/fs.c -> src/win/fs.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "36: #include \"req-inl.h\"",
          "37: #include \"handle-inl.h\"",
          "40: #define UV_FS_FREE_PATHS         0x0002",
          "41: #define UV_FS_FREE_PTR           0x0008",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "39: #include <wincrypt.h>",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "721: }",
          "725: void fs__mkdtemp(uv_fs_t* req) {",
          "727:     L\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";",
          "728:   size_t len;",
          "750:   len = wcslen(req->pathw);",
          "752:     SET_REQ_UV_ERROR(req, UV_EINVAL, ERROR_INVALID_PARAMETER);",
          "753:     return;",
          "754:   }",
          "781:       len = strlen(req->path);",
          "783:       SET_REQ_RESULT(req, 0);",
          "785:     } else if (errno != EEXIST) {",
          "786:       SET_REQ_RESULT(req, -1);",
          "788:     }",
          "793: }",
          "",
          "[Removed Lines]",
          "726:   static const WCHAR letters[] =",
          "729:   WCHAR* template_part;",
          "730:   static uint64_t value;",
          "731:   unsigned int count;",
          "732:   int fd;",
          "735:      generate. The maximum total number of temporary file names that",
          "736:      can exist for a given template is 62**6. It should never be",
          "737:      necessary to try all these combinations. Instead if a reasonable",
          "738:      number of names is tried (we define reasonable as 62**3) fail to",
          "740: #define ATTEMPTS_MIN (62 * 62 * 62)",
          "744: #if ATTEMPTS_MIN < TMP_MAX",
          "745:   unsigned int attempts = TMP_MAX;",
          "746: #else",
          "747:   unsigned int attempts = ATTEMPTS_MIN;",
          "748: #endif",
          "751:   if (len < 6 || wcsncmp(&req->pathw[len - 6], L\"XXXXXX\", 6)) {",
          "757:   template_part = &req->pathw[len - 6];",
          "760:   value += uv_hrtime() ^ _getpid();",
          "762:   for (count = 0; count < attempts; value += 7777, ++count) {",
          "763:     uint64_t v = value;",
          "766:     template_part[0] = letters[v % 62];",
          "767:     v /= 62;",
          "768:     template_part[1] = letters[v % 62];",
          "769:     v /= 62;",
          "770:     template_part[2] = letters[v % 62];",
          "771:     v /= 62;",
          "772:     template_part[3] = letters[v % 62];",
          "773:     v /= 62;",
          "774:     template_part[4] = letters[v % 62];",
          "775:     v /= 62;",
          "776:     template_part[5] = letters[v % 62];",
          "778:     fd = _wmkdir(req->pathw);",
          "780:     if (fd >= 0) {",
          "782:       wcstombs((char*) req->path + len - 6, template_part, 6);",
          "784:       return;",
          "787:       return;",
          "789:   }",
          "792:   SET_REQ_RESULT(req, -1);",
          "",
          "[Added Lines]",
          "728:   static const WCHAR *tempchars =",
          "730:   static const size_t num_chars = 62;",
          "731:   static const size_t num_x = 6;",
          "732:   WCHAR *cp, *ep;",
          "733:   unsigned int tries, i;",
          "735:   HCRYPTPROV h_crypt_prov;",
          "736:   uint64_t v;",
          "737:   BOOL released;",
          "740:   ep = req->pathw + len;",
          "741:   if (len < num_x || wcsncmp(ep - num_x, L\"XXXXXX\", num_x)) {",
          "746:   if (!CryptAcquireContext(&h_crypt_prov, NULL, NULL, PROV_RSA_FULL,",
          "747:                            CRYPT_VERIFYCONTEXT)) {",
          "748:     SET_REQ_WIN32_ERROR(req, GetLastError());",
          "749:     return;",
          "750:   }",
          "752:   tries = TMP_MAX;",
          "753:   do {",
          "754:     if (!CryptGenRandom(h_crypt_prov, sizeof(v), (BYTE*) &v)) {",
          "755:       SET_REQ_WIN32_ERROR(req, GetLastError());",
          "756:       break;",
          "757:     }",
          "759:     cp = ep - num_x;",
          "760:     for (i = 0; i < num_x; i++) {",
          "762:       v /= num_chars;",
          "763:     }",
          "765:     if (_wmkdir(req->pathw) == 0) {",
          "767:       wcstombs((char*) req->path + len - num_x, ep - num_x, num_x);",
          "769:       break;",
          "772:       break;",
          "774:   } while (--tries);",
          "776:   released = CryptReleaseContext(h_crypt_prov, 0);",
          "777:   assert(released);",
          "778:   if (tries == 0) {",
          "779:     SET_REQ_RESULT(req, -1);",
          "780:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "94c7a13f0a4e25856c2597f8fe54fed674b5aff6",
      "candidate_info": {
        "commit_hash": "94c7a13f0a4e25856c2597f8fe54fed674b5aff6",
        "repo": "libuv/libuv",
        "commit_url": "https://github.com/libuv/libuv/commit/94c7a13f0a4e25856c2597f8fe54fed674b5aff6",
        "files": [
          "test/test-udp-multicast-interface6.c"
        ],
        "message": "test: fix udp_multicast_interface6 on FreeBSD",
        "before_after_code_files": [
          "test/test-udp-multicast-interface6.c||test/test-udp-multicast-interface6.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/libuv/libuv/pull/41"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "test/test-udp-multicast-interface6.c||test/test-udp-multicast-interface6.c": [
          "File: test/test-udp-multicast-interface6.c -> test/test-udp-multicast-interface6.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "69:   r = uv_udp_bind(&server, (const struct sockaddr*)&baddr, 0);",
          "70:   ASSERT(r == 0);",
          "73:   r = uv_udp_set_multicast_interface(&server, \"::1%lo0\");",
          "74: #else",
          "75:   r = uv_udp_set_multicast_interface(&server, NULL);",
          "",
          "[Removed Lines]",
          "72: #if defined(__APPLE__)",
          "",
          "[Added Lines]",
          "72: #if defined(__APPLE__) || defined(__FreeBSD__)",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2019-10664",
  "cve_desc": "Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.",
  "repo": "domoticz/domoticz",
  "patch_hash": "ee70db46f81afa582c96b887b73bcd2a86feda00",
  "patch_info": {
    "commit_hash": "ee70db46f81afa582c96b887b73bcd2a86feda00",
    "repo": "domoticz/domoticz",
    "commit_url": "https://github.com/domoticz/domoticz/commit/ee70db46f81afa582c96b887b73bcd2a86feda00",
    "files": [
      "main/WebServer.cpp"
    ],
    "message": "Fixed possible SQL Injection Vulnerability (Thanks to Fabio Carretto!)",
    "before_after_code_files": [
      "main/WebServer.cpp||main/WebServer.cpp"
    ]
  },
  "patch_diff": {
    "main/WebServer.cpp||main/WebServer.cpp": [
      "File: main/WebServer.cpp -> main/WebServer.cpp",
      "--- Hunk 1 ---",
      "[Context before]",
      "10772:     return;",
      "10773:    }",
      "10774:    std::vector<std::vector<std::string> > result;",
      "10776:    if (result.empty())",
      "10777:     return;",
      "10778:    reply::set_content(&rep, result[0][0].begin(), result[0][0].end());",
      "",
      "[Removed Lines]",
      "10775:    result = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());",
      "",
      "[Added Lines]",
      "10775:    result = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%d\", atol(idx.c_str()));",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "4abb67b73177cbdd453e6fcb8dcbf50c8351ce9b",
      "candidate_info": {
        "commit_hash": "4abb67b73177cbdd453e6fcb8dcbf50c8351ce9b",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/4abb67b73177cbdd453e6fcb8dcbf50c8351ce9b",
        "files": [
          "hardware/DenkoviDevices.cpp",
          "hardware/DenkoviTCPDevices.cpp",
          "hardware/DenkoviTCPDevices.h",
          "hardware/DenkoviUSBDevices.cpp",
          "hardware/DenkoviUSBDevices.h"
        ],
        "message": "Denkovi, Fixed compile warnings introduced by #2606",
        "before_after_code_files": [
          "hardware/DenkoviDevices.cpp||hardware/DenkoviDevices.cpp",
          "hardware/DenkoviTCPDevices.cpp||hardware/DenkoviTCPDevices.cpp",
          "hardware/DenkoviTCPDevices.h||hardware/DenkoviTCPDevices.h",
          "hardware/DenkoviUSBDevices.cpp||hardware/DenkoviUSBDevices.cpp",
          "hardware/DenkoviUSBDevices.h||hardware/DenkoviUSBDevices.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/DenkoviDevices.cpp||hardware/DenkoviDevices.cpp": [
          "File: hardware/DenkoviDevices.cpp -> hardware/DenkoviDevices.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "757:  return b;",
          "758: }",
          "762: float CDenkoviDevices::DAEnetIP2CalculateAi(int adc, const int &valType) {",
          "763:  if (valType == DAENETIP2_AI_TEMPERATURE) {",
          "765:  }",
          "766:  else if (valType == DAENETIP2_AI_VOLTAGE) {",
          "768:  }",
          "770: }",
          "772: void CDenkoviDevices::GetMeterDetails()",
          "",
          "[Removed Lines]",
          "764:   return (10000 * ((1.2*204.8)*adc / (120 * 1024) + 0) / 100);",
          "767:   return (10000 * ((1.2*0.377)*adc / (4.7 * 1024) + 0) / 100);",
          "769:  return 0;",
          "",
          "[Added Lines]",
          "762:   return static_cast<float>(10000 * ((1.2*204.8)*adc / (120 * 1024) + 0) / 100);",
          "765:   return static_cast<float>(10000 * ((1.2*0.377)*adc / (4.7 * 1024) + 0) / 100);",
          "767:  return 0.0f;",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "960:   return;",
          "961:  }",
          "964:  std::string tmpstr;",
          "965:  int tmpState;",
          "966:  int tmpValue;",
          "",
          "[Removed Lines]",
          "963:  size_t ii;",
          "",
          "[Added Lines]",
          "961:  int ii;",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "977:   bool bHaveAnalogInput = false;",
          "978:   bool bHaveTemperatureInput = false;",
          "979:   bool bHaveRelay = false;",
          "981:   {",
          "982:    tmpstr = stdstring_trim(results[ii]);",
          "",
          "[Removed Lines]",
          "980:   for (ii = 1; ii < results.size(); ii++)",
          "",
          "[Added Lines]",
          "978:   for (ii = 1; ii < (int)results.size(); ii++)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1043:     name = \"Temperature Input (\" + name + \")\";",
          "1044:     std::vector<std::string> vMeasure;",
          "1045:     StringSplit(tmpMeasure, \" \", vMeasure);",
          "1047:     if (tmpMeasure.find(\"F\") != std::string::npos)",
          "1048:      tmpTiValue = (float)ConvertToCelsius((double)tmpTiValue);",
          "1049:     SendTempSensor(Idx, 255, tmpTiValue, name);",
          "",
          "[Removed Lines]",
          "1046:     tmpTiValue = atof(tmpMeasure.c_str());",
          "",
          "[Added Lines]",
          "1044:     tmpTiValue = static_cast<float>(atof(tmpMeasure.c_str()));",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "1175:  }",
          "1176:  case DDEV_SmartDEN_IP_16_Relays: {//has only relays",
          "1177:   bool bHaveRelays = false;",
          "1179:   {",
          "1180:    tmpstr = stdstring_trim(results[ii]);",
          "",
          "[Removed Lines]",
          "1178:   for (ii = 1; ii < results.size(); ii++)",
          "",
          "[Added Lines]",
          "1176:   for (ii = 1; ii < (int)results.size(); ii++)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "1204:  }",
          "1205:  case DDEV_SmartDEN_IP_Watchdog: {//has only relays",
          "1206:   bool bHaveRelays = false;",
          "1208:   {",
          "1209:    tmpstr = stdstring_trim(results[ii]);",
          "",
          "[Removed Lines]",
          "1207:   for (ii = 1; ii < results.size(); ii++)",
          "",
          "[Added Lines]",
          "1205:   for (ii = 1; ii < (int)results.size(); ii++)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "1235:   bool bHaveDigitalInput = false;",
          "1236:   bool bHaveAnalogInput = false;",
          "1237:   bool bHaveTemperatureInput = false;",
          "1239:   {",
          "1240:    tmpstr = stdstring_trim(results[ii]);",
          "",
          "[Removed Lines]",
          "1238:   for (ii = 1; ii < results.size(); ii++)",
          "",
          "[Added Lines]",
          "1236:   for (ii = 1; ii < (int)results.size(); ii++)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "1297:   bool bHaveDigitalInput = false;",
          "1298:   bool bHaveAnalogInput = false;",
          "1299:   bool bHaveTemperatureInput = false;",
          "1301:   {",
          "1302:    tmpstr = stdstring_trim(results[ii]);",
          "",
          "[Removed Lines]",
          "1300:   for (ii = 1; ii < results.size(); ii++)",
          "",
          "[Added Lines]",
          "1298:   for (ii = 1; ii < (int)results.size(); ii++)",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "1369:   bool bHaveAnalogOutput = false;",
          "1370:   bool bHaveAnalogInput = false;",
          "1371:   bool bHaveRelay = false;",
          "1373:   {",
          "1374:    tmpstr = stdstring_trim(results[ii]);",
          "",
          "[Removed Lines]",
          "1372:   for (ii = 1; ii < results.size(); ii++)",
          "",
          "[Added Lines]",
          "1370:   for (ii = 1; ii < (int)results.size(); ii++)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "1425:     else {",
          "1426:      name = \"Analog Input \" + std::to_string(Idx) + \" (\" + name + \")\";",
          "1427:      if (vMeasure.size() == 2) {",
          "1429:       if (vMeasure[1] == \"degF\")",
          "1430:        tmpTiValue = (float)ConvertToCelsius((double)tmpTiValue);",
          "1431:       SendTempSensor(Idx, 255, tmpTiValue, name);",
          "",
          "[Removed Lines]",
          "1428:       tmpTiValue = atof(vMeasure[0].c_str());",
          "",
          "[Added Lines]",
          "1426:       tmpTiValue = static_cast<float>(atof(vMeasure[0].c_str()));",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "1464:   bool bHaveDigitalOutput = false;",
          "1465:   bool bHaveAnalogInput = false;",
          "1466:   bool bHavePWM = false;",
          "1468:   {",
          "1469:    tmpstr = stdstring_trim(results[ii]);",
          "",
          "[Removed Lines]",
          "1467:   for (ii = 1; ii < results.size(); ii++)",
          "",
          "[Added Lines]",
          "1465:   for (ii = 1; ii < (int)results.size(); ii++)",
          "",
          "---------------"
        ],
        "hardware/DenkoviTCPDevices.cpp||hardware/DenkoviTCPDevices.cpp": [
          "File: hardware/DenkoviTCPDevices.cpp -> hardware/DenkoviTCPDevices.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #include \"stdafx.h\"",
          "2: #include \"DenkoviTCPDevices.h\"",
          "3: #include \"../main/Helper.h\"",
          "4: #include \"../main/Logger.h\"",
          "5: #include \"../httpclient/HTTPClient.h\"",
          "6: #include \"hardwaretypes.h\"",
          "7: #include \"../main/localtime_r.h\"",
          "8: #include \"../main/mainworker.h\"",
          "9: #include \"../main/SQLHelper.h\"",
          "10: #include <sstream>",
          "12: #define MAX_POLL_INTERVAL 30*1000",
          "14: enum _eDaeTcpState",
          "15: {",
          "16:  RESPOND_RECEIVED = 0,  //0",
          "17:  DAE_WIFI16_UPDATE_IO,  //1",
          "18:  DAE_WIFI16_ASK_CMD,   //2",
          "19:  DAE_READ_COILS_CMD,   //3",
          "20:  DAE_WRITE_COIL_CMD,   //4",
          "21: };",
          "23: #define DAE_IO_TYPE_RELAY   2",
          "25: #define READ_COILS_CMD_LENGTH    11",
          "26: #define WRITE_SINGLE_COIL_CMD_LENGTH  12",
          "29: CDenkoviTCPDevices::CDenkoviTCPDevices(const int ID, const std::string &IPAddress, const unsigned short usIPPort, const int pollInterval, const int model, const int slaveId) :",
          "30:  m_szIPAddress(IPAddress),",
          "31:  m_pollInterval(pollInterval)",
          "32: {",
          "33:  m_HwdID = ID;",
          "34:  m_usIPPort = usIPPort;",
          "35:  m_stoprequested = false;",
          "36:  m_bOutputLog = false;",
          "37:  m_iModel = model;",
          "38:  m_slaveId = slaveId;",
          "39:  m_Cmd = 0;",
          "40:  if (m_pollInterval < 500)",
          "41:   m_pollInterval = 500;",
          "42:  else if (m_pollInterval > MAX_POLL_INTERVAL)",
          "43:   m_pollInterval = MAX_POLL_INTERVAL;",
          "44:  Init();",
          "45: }",
          "48: CDenkoviTCPDevices::~CDenkoviTCPDevices()",
          "49: {",
          "50: }",
          "52: void CDenkoviTCPDevices::Init()",
          "53: {",
          "54: }",
          "56: bool CDenkoviTCPDevices::StartHardware()",
          "57: {",
          "58:  Init();",
          "60:  m_stoprequested = false;",
          "61:  m_bIsStarted = true;",
          "62:  transactionCounter = 0;",
          "63:  pReq = new _sDenkoviTCPModbusRequest;",
          "64:  pResp = new _sDenkoviTCPModbusResponse;",
          "65:  receivedDataLength = 0;",
          "68:  m_thread = std::make_shared<std::thread>(&CDenkoviTCPDevices::Do_Work, this);",
          "70:  m_bIsStarted = true;",
          "71:  switch (m_iModel) {",
          "72:  case DDEV_WIFI_16R:",
          "73:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Started\");",
          "74:   break;",
          "75:  case DDEV_WIFI_16R_Modbus:",
          "76:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Started\");",
          "77:   break;",
          "78:  }",
          "79:  return (m_thread != NULL);",
          "80: }",
          "82: void CDenkoviTCPDevices::copyBuffer(const uint8_t * source, uint8_t * destination, size_t length) {",
          "83:  for (uint8_t ii = 0; ii < length; ii++) {",
          "84:   destination[ii] = source[ii];",
          "85:  }",
          "86: }",
          "88: void CDenkoviTCPDevices::OnData(const unsigned char * pData, size_t length)",
          "89: {",
          "90:  std::lock_guard<std::mutex> l(readQueueMutex);",
          "94:   readingNow = false;",
          "95:   return; //receiving not enabled",
          "98:  switch (m_iModel) {",
          "99:  case DDEV_WIFI_16R: {",
          "100:   if (m_Cmd == DAE_WIFI16_ASK_CMD) {",
          "101:    uint8_t firstEight, secondEight;",
          "102:    if (length == 2) {",
          "103:     firstEight = (unsigned char)pData[0];",
          "104:     secondEight = (unsigned char)pData[1];",
          "105:    }",
          "106:    else {",
          "107:     _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Response error.\");",
          "108:     return;",
          "109:    }",
          "110:    uint8_t z = 0;",
          "111:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "112:     z = (firstEight >> (8 - ii)) & 0x01;",
          "113:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii, 255, (((firstEight >> (8 - ii)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(ii));",
          "114:    }",
          "115:    for (uint8_t ii = 1; ii < 9; ii++)",
          "116:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii + 8, 255, ((secondEight >> (8 - ii) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(8 + ii));",
          "117:   }",
          "118:   break;",
          "119:  }",
          "120:  case DDEV_WIFI_16R_Modbus: {",
          "121:   copyBuffer(pData, (uint8_t *)&pResp[receivedDataLength], length);",
          "122:   receivedDataLength += length;",
          "124:   if (m_Cmd == DAE_READ_COILS_CMD && receivedDataLength >= READ_COILS_CMD_LENGTH) {",
          "125:    receivedDataLength = 0;",
          "126:    if (pReq->trId[0] != pResp->trId[0] || pReq->trId[1] != pResp->trId[1]) {",
          "127:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Transaction ID.\");",
          "128:     break;",
          "129:    }",
          "130:    if (pResp->length[0] != 0 || pResp->length[1] != 5) {",
          "131:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Length of Response.\");",
          "132:     break;",
          "133:    }",
          "134:    uint8_t firstEight, secondEight;",
          "135:    firstEight = (uint8_t)pResp->data[0];",
          "136:    secondEight = (uint8_t)pResp->data[1];",
          "137:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "138:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii, 255, (((firstEight >> (ii-1)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(ii));",
          "139:    }",
          "140:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "141:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, 8 + ii, 255, (((secondEight >> (ii - 1)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(8 + ii));",
          "142:    }",
          "143:   }",
          "144:   else if (m_Cmd == DAE_WRITE_COIL_CMD && receivedDataLength >= WRITE_SINGLE_COIL_CMD_LENGTH) {",
          "145:    copyBuffer(pData, (uint8_t *)&pResp[receivedDataLength], length);",
          "146:    receivedDataLength = 0;",
          "147:    if (pReq->trId[0] != pResp->trId[0] || pReq->trId[1] != pResp->trId[1]) {",
          "148:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Transaction ID.\");",
          "149:     break;",
          "150:    }",
          "151:    if (pResp->length[0] != 0 || pResp->length[1] != 6) {",
          "152:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Data Received.\");",
          "153:     break;",
          "154:    }",
          "155:   }",
          "156:   break;",
          "157:  }",
          "158:  }",
          "159:  updateIo = false;",
          "160:  readingNow = false;",
          "161: }",
          "163: void CDenkoviTCPDevices::OnConnect() {",
          "164:  sOnConnected(this);",
          "165:  GetMeterDetails();",
          "166: }",
          "168: void CDenkoviTCPDevices::OnDisconnect() {",
          "169:  switch (m_iModel) {",
          "170:  case DDEV_WIFI_16R:",
          "171:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Disconnected\");",
          "172:   break;",
          "173:  case DDEV_WIFI_16R_Modbus:",
          "174:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Disconnected\");",
          "175:   break;",
          "176:  }",
          "177: }",
          "179: void CDenkoviTCPDevices::OnError(const boost::system::error_code& error) {",
          "180:  switch (m_iModel) {",
          "181:  case DDEV_WIFI_16R:",
          "182:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Error occured.\");",
          "183:   break;",
          "184:  case DDEV_WIFI_16R_Modbus:",
          "185:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Error occured.\");",
          "186:   break;",
          "187:  }",
          "188: }",
          "190: void CDenkoviTCPDevices::OnError(const std::exception e)",
          "191: {",
          "192:  switch (m_iModel) {",
          "193:  case DDEV_WIFI_16R:",
          "194:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Error: %s\", e.what());",
          "195:   break;",
          "196:  case DDEV_WIFI_16R_Modbus:",
          "197:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Error: %s\", e.what());",
          "198:   break;",
          "199:  }",
          "200: }",
          "202: bool CDenkoviTCPDevices::StopHardware()",
          "203: {",
          "204:  if (m_thread != NULL)",
          "205:  {",
          "206:   assert(m_thread);",
          "207:   m_stoprequested = true;",
          "208:   m_thread->join();",
          "209:  }",
          "210:  m_bIsStarted = false;",
          "211:  return true;",
          "212: }",
          "214: void CDenkoviTCPDevices::Do_Work()",
          "215: {",
          "216:  int poll_interval = m_pollInterval / 100;",
          "217:  int poll_counter = poll_interval - 2;",
          "219:  int msec_counter = 0;",
          "221:  while (!m_stoprequested)",
          "222:  {",
          "223:   m_LastHeartbeat = mytime(NULL);",
          "224:   if (bFirstTime)",
          "225:   {",
          "226:    bFirstTime = false;",
          "227:    if (!mIsConnected)",
          "228:    {",
          "229:     m_rxbufferpos = 0;",
          "230:     connect(m_szIPAddress, m_usIPPort);",
          "231:    }",
          "232:   }",
          "233:   else",
          "234:   {",
          "235:    sleep_milliseconds(100);",
          "236:    update();",
          "237:    if (msec_counter++ >= poll_interval) {",
          "238:     msec_counter = 0;",
          "239:     if (readingNow == false && updateIo == false)",
          "240:      GetMeterDetails();",
          "241:    }",
          "242:   }",
          "243:  }",
          "245:  switch (m_iModel) {",
          "246:  case DDEV_WIFI_16R:",
          "247:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Worker stopped...\");",
          "248:   break;",
          "249:  case DDEV_WIFI_16R_Modbus:",
          "250:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Worker stopped...\");",
          "251:   break;",
          "252:  }",
          "253: }",
          "255: bool CDenkoviTCPDevices::WriteToHardware(const char *pdata, const unsigned char length)",
          "256: {",
          "257:  updateIo = true;",
          "258:  const _tGeneralSwitch *pSen = reinterpret_cast<const _tGeneralSwitch*>(pdata);",
          "259:  if (m_bIsStarted == false)",
          "260:   return false;",
          "262:  switch (m_iModel) {",
          "263:  case DDEV_WIFI_16R: {",
          "264:   std::stringstream szCmd;",
          "265:   int ioType = pSen->id;",
          "266:   if (ioType != DAE_IO_TYPE_RELAY)",
          "267:   {",
          "268:    _log.Log(LOG_ERROR, \"WiFi 16 Relays-VCP: Not a valid Relay\");",
          "269:    return false;",
          "270:   }",
          "271:   int io = pSen->unitcode;//Relay1 to Relay16",
          "272:   if (io > 16)",
          "273:    return false;",
          "275:   szCmd << (io < 10 ? \"0\" : \"\") << io;",
          "276:   if (pSen->cmnd == light2_sOff)",
          "277:    szCmd << \"-//\";",
          "278:   else",
          "279:    szCmd << \"+//\";",
          "280:   m_Cmd = DAE_WIFI16_UPDATE_IO;",
          "281:   write(szCmd.str());",
          "282:   return true;",
          "283:  }",
          "284:  case DDEV_WIFI_16R_Modbus: {",
          "285:   std::stringstream szCmd;",
          "286:   int ioType = pSen->id;",
          "287:   if (ioType != DAE_IO_TYPE_RELAY)",
          "288:   {",
          "289:    _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Not a valid Relay\");",
          "290:    return false;",
          "291:   }",
          "292:   int io = pSen->unitcode;//Relay1 to Relay16",
          "293:   if (io > 16)",
          "294:    return false;",
          "296:   pReq->prId[0] = 0;",
          "297:   pReq->prId[1] = 0;",
          "299:   transactionCounter++;",
          "300:   pReq->trId[0] = (uint8_t)(transactionCounter >> 8);",
          "301:   pReq->trId[1] = (uint8_t)(transactionCounter);",
          "302:   pReq->unitId = m_slaveId;",
          "303:   pReq->address[0] = 0;",
          "304:   pReq->address[1] = io - 1;",
          "305:   pReq->fc = DMODBUS_WRITE_SINGLE_COIL;",
          "306:   pReq->length[0] = 0;",
          "307:   pReq->length[1] = 6;",
          "308:   if (pSen->cmnd == light2_sOff)",
          "309:    pReq->data[0] = 0x00;",
          "310:   else",
          "311:    pReq->data[0] = 0xFF;",
          "312:   pReq->data[1] = 0x00;",
          "313:   size_t dataLength = pReq->length[1] + 6;",
          "315:   m_Cmd = DAE_WRITE_COIL_CMD;",
          "316:   write(\"\");",
          "317:   write(\"\");",
          "318:   write(\"\");",
          "319:   write(\"\");",
          "320:   write((uint8_t*)pReq, dataLength);",
          "321:   return true;",
          "322:  }",
          "323:  }",
          "325:  _log.Log(LOG_ERROR, \"Denkovi: Unknown Device!\");",
          "326:  return false;",
          "327: }",
          "329: uint16_t CDenkoviTCPDevices::ByteSwap(uint16_t in)",
          "330: { uint16_t out;",
          "331:  uint8_t *indata = (uint8_t *)&in;",
          "332:  uint8_t *outdata = (uint8_t *)&out;",
          "333:  outdata[0] = indata[1];",
          "334:  outdata[1] = indata[0];",
          "335:  return out;",
          "336: }",
          "338: void CDenkoviTCPDevices::SwapRequestBytes()",
          "339: {",
          "341:  tmpVar = ((pReq->trId & 0x00ff) << 8) | ((pReq->trId & 0xff00) >> 8);",
          "342:  pReq->trId = tmpVar;",
          "343:  tmpVar = ((pReq->length & 0x00ff) << 8) | ((pReq->length & 0xff00) >> 8);",
          "344:  pReq->length = tmpVar;",
          "345:  tmpVar = ((pReq->address & 0x00ff) << 8) | ((pReq->address & 0xff00) >> 8);",
          "350: }",
          "352: void CDenkoviTCPDevices::SwapResponseBytes()",
          "353: {",
          "355:  tmpVar = ((pResp->trId & 0x00ff) << 8) | ((pResp->trId & 0xff00) >> 8);",
          "356:  pResp->trId = tmpVar;",
          "357:  tmpVar = ((pResp->length & 0x00ff) << 8) | ((pResp->length & 0xff00) >> 8);",
          "361: }",
          "363: void CDenkoviTCPDevices::GetMeterDetails()",
          "364: {",
          "365:  switch (m_iModel) {",
          "366:  case DDEV_WIFI_16R: {",
          "367:   m_Cmd = DAE_WIFI16_ASK_CMD;",
          "368:   write(\"ask//\");",
          "369:   break;",
          "370:  }",
          "371:  case DDEV_WIFI_16R_Modbus: {",
          "372:   m_Cmd = DAE_READ_COILS_CMD;",
          "373:   pReq->prId[0] = 0;",
          "374:   pReq->prId[1] = 0;",
          "375:   transactionCounter++;",
          "376:   pReq->trId[0] = (uint8_t)(transactionCounter >> 8);",
          "377:   pReq->trId[1] = (uint8_t)(transactionCounter);",
          "378:   pReq->address[0] = 0;",
          "379:   pReq->address[1] = 0;",
          "380:   pReq->fc = DMODBUS_READ_COILS;",
          "381:   pReq->length[0] = 0;",
          "382:   pReq->length[1] = 6;",
          "383:   pReq->unitId = m_slaveId;",
          "384:   pReq->data[0] = 0;",
          "385:   pReq->data[1] = 16;",
          "386:   size_t dataLength = pReq->length[1] + 6;",
          "388:   write(\"\");",
          "389:   write(\"\");",
          "390:   write(\"\");",
          "391:   write(\"\");",
          "392:   write((uint8_t*)pReq, dataLength);",
          "393:   break;",
          "394:  }",
          "395:  }",
          "396: }",
          "",
          "[Added Lines]",
          "1: #include \"stdafx.h\"",
          "2: #include \"DenkoviTCPDevices.h\"",
          "3: #include \"../main/Helper.h\"",
          "4: #include \"../main/Logger.h\"",
          "5: #include \"../httpclient/HTTPClient.h\"",
          "6: #include \"hardwaretypes.h\"",
          "7: #include \"../main/localtime_r.h\"",
          "8: #include \"../main/mainworker.h\"",
          "9: #include \"../main/SQLHelper.h\"",
          "10: #include <sstream>",
          "12: #define MAX_POLL_INTERVAL 30*1000",
          "14: enum _eDaeTcpState",
          "15: {",
          "16:  RESPOND_RECEIVED = 0,  //0",
          "17:  DAE_WIFI16_UPDATE_IO,  //1",
          "18:  DAE_WIFI16_ASK_CMD,   //2",
          "19:  DAE_READ_COILS_CMD,   //3",
          "20:  DAE_WRITE_COIL_CMD,   //4",
          "21: };",
          "23: #define DAE_IO_TYPE_RELAY   2",
          "25: #define READ_COILS_CMD_LENGTH    11",
          "26: #define WRITE_SINGLE_COIL_CMD_LENGTH  12",
          "29: CDenkoviTCPDevices::CDenkoviTCPDevices(const int ID, const std::string &IPAddress, const unsigned short usIPPort, const int pollInterval, const int model, const int slaveId) :",
          "30:  m_szIPAddress(IPAddress),",
          "31:  m_pollInterval(pollInterval)",
          "32: {",
          "33:  m_HwdID = ID;",
          "34:  m_usIPPort = usIPPort;",
          "35:  m_stoprequested = false;",
          "36:  m_bOutputLog = false;",
          "37:  m_iModel = model;",
          "38:  m_slaveId = slaveId;",
          "39:  m_Cmd = 0;",
          "40:  if (m_pollInterval < 500)",
          "41:   m_pollInterval = 500;",
          "42:  else if (m_pollInterval > MAX_POLL_INTERVAL)",
          "43:   m_pollInterval = MAX_POLL_INTERVAL;",
          "44:  Init();",
          "45: }",
          "48: CDenkoviTCPDevices::~CDenkoviTCPDevices()",
          "49: {",
          "50: }",
          "52: void CDenkoviTCPDevices::Init()",
          "53: {",
          "54: }",
          "56: bool CDenkoviTCPDevices::StartHardware()",
          "57: {",
          "58:  Init();",
          "60:  m_stoprequested = false;",
          "61:  m_bIsStarted = true;",
          "62:  transactionCounter = 0;",
          "63:  pReq = new _sDenkoviTCPModbusRequest;",
          "64:  pResp = new _sDenkoviTCPModbusResponse;",
          "65:  receivedDataLength = 0;",
          "68:  m_thread = std::make_shared<std::thread>(&CDenkoviTCPDevices::Do_Work, this);",
          "70:  m_bIsStarted = true;",
          "71:  switch (m_iModel) {",
          "72:  case DDEV_WIFI_16R:",
          "73:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Started\");",
          "74:   break;",
          "75:  case DDEV_WIFI_16R_Modbus:",
          "76:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Started\");",
          "77:   break;",
          "78:  }",
          "79:  return (m_thread != NULL);",
          "80: }",
          "82: void CDenkoviTCPDevices::copyBuffer(const uint8_t * source, uint8_t * destination, size_t length) {",
          "83:  for (uint8_t ii = 0; ii < length; ii++) {",
          "84:   destination[ii] = source[ii];",
          "85:  }",
          "86: }",
          "88: void CDenkoviTCPDevices::OnData(const unsigned char * pData, size_t length)",
          "89: {",
          "90:  std::lock_guard<std::mutex> l(readQueueMutex);",
          "94:   readingNow = false;",
          "95:   return; //receiving not enabled",
          "98:  switch (m_iModel) {",
          "99:  case DDEV_WIFI_16R: {",
          "100:   if (m_Cmd == DAE_WIFI16_ASK_CMD) {",
          "101:    uint8_t firstEight, secondEight;",
          "102:    if (length == 2) {",
          "103:     firstEight = (unsigned char)pData[0];",
          "104:     secondEight = (unsigned char)pData[1];",
          "105:    }",
          "106:    else {",
          "107:     _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Response error.\");",
          "108:     return;",
          "109:    }",
          "110:    uint8_t z = 0;",
          "111:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "112:     z = (firstEight >> (8 - ii)) & 0x01;",
          "113:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii, 255, (((firstEight >> (8 - ii)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(ii));",
          "114:    }",
          "115:    for (uint8_t ii = 1; ii < 9; ii++)",
          "116:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii + 8, 255, ((secondEight >> (8 - ii) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(8 + ii));",
          "117:   }",
          "118:   break;",
          "119:  }",
          "120:  case DDEV_WIFI_16R_Modbus: {",
          "121:   copyBuffer(pData, (uint8_t *)&pResp[receivedDataLength], length);",
          "122:   receivedDataLength += (uint16_t)length;",
          "124:   if (m_Cmd == DAE_READ_COILS_CMD && receivedDataLength >= READ_COILS_CMD_LENGTH) {",
          "125:    receivedDataLength = 0;",
          "126:    if (pReq->trId[0] != pResp->trId[0] || pReq->trId[1] != pResp->trId[1]) {",
          "127:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Transaction ID.\");",
          "128:     break;",
          "129:    }",
          "130:    if (pResp->length[0] != 0 || pResp->length[1] != 5) {",
          "131:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Length of Response.\");",
          "132:     break;",
          "133:    }",
          "134:    uint8_t firstEight, secondEight;",
          "135:    firstEight = (uint8_t)pResp->data[0];",
          "136:    secondEight = (uint8_t)pResp->data[1];",
          "137:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "138:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii, 255, (((firstEight >> (ii-1)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(ii));",
          "139:    }",
          "140:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "141:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, 8 + ii, 255, (((secondEight >> (ii - 1)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(8 + ii));",
          "142:    }",
          "143:   }",
          "144:   else if (m_Cmd == DAE_WRITE_COIL_CMD && receivedDataLength >= WRITE_SINGLE_COIL_CMD_LENGTH) {",
          "145:    copyBuffer(pData, (uint8_t *)&pResp[receivedDataLength], length);",
          "146:    receivedDataLength = 0;",
          "147:    if (pReq->trId[0] != pResp->trId[0] || pReq->trId[1] != pResp->trId[1]) {",
          "148:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Transaction ID.\");",
          "149:     break;",
          "150:    }",
          "151:    if (pResp->length[0] != 0 || pResp->length[1] != 6) {",
          "152:     _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Wrong Data Received.\");",
          "153:     break;",
          "154:    }",
          "155:   }",
          "156:   break;",
          "157:  }",
          "158:  }",
          "159:  updateIo = false;",
          "160:  readingNow = false;",
          "161: }",
          "163: void CDenkoviTCPDevices::OnConnect() {",
          "164:  sOnConnected(this);",
          "165:  GetMeterDetails();",
          "166: }",
          "168: void CDenkoviTCPDevices::OnDisconnect() {",
          "169:  switch (m_iModel) {",
          "170:  case DDEV_WIFI_16R:",
          "171:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Disconnected\");",
          "172:   break;",
          "173:  case DDEV_WIFI_16R_Modbus:",
          "174:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Disconnected\");",
          "175:   break;",
          "176:  }",
          "177: }",
          "179: void CDenkoviTCPDevices::OnError(const boost::system::error_code& error) {",
          "180:  switch (m_iModel) {",
          "181:  case DDEV_WIFI_16R:",
          "182:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Error occured.\");",
          "183:   break;",
          "184:  case DDEV_WIFI_16R_Modbus:",
          "185:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Error occured.\");",
          "186:   break;",
          "187:  }",
          "188: }",
          "190: void CDenkoviTCPDevices::OnError(const std::exception e)",
          "191: {",
          "192:  switch (m_iModel) {",
          "193:  case DDEV_WIFI_16R:",
          "194:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Error: %s\", e.what());",
          "195:   break;",
          "196:  case DDEV_WIFI_16R_Modbus:",
          "197:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Error: %s\", e.what());",
          "198:   break;",
          "199:  }",
          "200: }",
          "202: bool CDenkoviTCPDevices::StopHardware()",
          "203: {",
          "204:  if (m_thread != NULL)",
          "205:  {",
          "206:   assert(m_thread);",
          "207:   m_stoprequested = true;",
          "208:   m_thread->join();",
          "209:  }",
          "210:  m_bIsStarted = false;",
          "211:  return true;",
          "212: }",
          "214: void CDenkoviTCPDevices::Do_Work()",
          "215: {",
          "216:  int poll_interval = m_pollInterval / 100;",
          "217:  int poll_counter = poll_interval - 2;",
          "219:  int msec_counter = 0;",
          "221:  while (!m_stoprequested)",
          "222:  {",
          "223:   m_LastHeartbeat = mytime(NULL);",
          "224:   if (bFirstTime)",
          "225:   {",
          "226:    bFirstTime = false;",
          "227:    if (!mIsConnected)",
          "228:    {",
          "229:     m_rxbufferpos = 0;",
          "230:     connect(m_szIPAddress, m_usIPPort);",
          "231:    }",
          "232:   }",
          "233:   else",
          "234:   {",
          "235:    sleep_milliseconds(100);",
          "236:    update();",
          "237:    if (msec_counter++ >= poll_interval) {",
          "238:     msec_counter = 0;",
          "239:     if (readingNow == false && updateIo == false)",
          "240:      GetMeterDetails();",
          "241:    }",
          "242:   }",
          "243:  }",
          "245:  switch (m_iModel) {",
          "246:  case DDEV_WIFI_16R:",
          "247:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-VCP: Worker stopped...\");",
          "248:   break;",
          "249:  case DDEV_WIFI_16R_Modbus:",
          "250:   _log.Log(LOG_STATUS, \"WiFi 16 Relays-TCP Modbus: Worker stopped...\");",
          "251:   break;",
          "252:  }",
          "253: }",
          "255: bool CDenkoviTCPDevices::WriteToHardware(const char *pdata, const unsigned char length)",
          "256: {",
          "257:  updateIo = true;",
          "258:  const _tGeneralSwitch *pSen = reinterpret_cast<const _tGeneralSwitch*>(pdata);",
          "259:  if (m_bIsStarted == false)",
          "260:   return false;",
          "262:  switch (m_iModel) {",
          "263:  case DDEV_WIFI_16R: {",
          "264:   std::stringstream szCmd;",
          "265:   int ioType = pSen->id;",
          "266:   if (ioType != DAE_IO_TYPE_RELAY)",
          "267:   {",
          "268:    _log.Log(LOG_ERROR, \"WiFi 16 Relays-VCP: Not a valid Relay\");",
          "269:    return false;",
          "270:   }",
          "271:   int io = pSen->unitcode;//Relay1 to Relay16",
          "272:   if (io > 16)",
          "273:    return false;",
          "275:   szCmd << (io < 10 ? \"0\" : \"\") << io;",
          "276:   if (pSen->cmnd == light2_sOff)",
          "277:    szCmd << \"-//\";",
          "278:   else",
          "279:    szCmd << \"+//\";",
          "280:   m_Cmd = DAE_WIFI16_UPDATE_IO;",
          "281:   write(szCmd.str());",
          "282:   return true;",
          "283:  }",
          "284:  case DDEV_WIFI_16R_Modbus: {",
          "285:   std::stringstream szCmd;",
          "286:   int ioType = pSen->id;",
          "287:   if (ioType != DAE_IO_TYPE_RELAY)",
          "288:   {",
          "289:    _log.Log(LOG_ERROR, \"WiFi 16 Relays-TCP Modbus: Not a valid Relay\");",
          "290:    return false;",
          "291:   }",
          "292:   int io = pSen->unitcode;//Relay1 to Relay16",
          "293:   if (io > 16)",
          "294:    return false;",
          "296:   pReq->prId[0] = 0;",
          "297:   pReq->prId[1] = 0;",
          "299:   transactionCounter++;",
          "300:   pReq->trId[0] = (uint8_t)(transactionCounter >> 8);",
          "301:   pReq->trId[1] = (uint8_t)(transactionCounter);",
          "302:   pReq->unitId = m_slaveId;",
          "303:   pReq->address[0] = 0;",
          "304:   pReq->address[1] = io - 1;",
          "305:   pReq->fc = DMODBUS_WRITE_SINGLE_COIL;",
          "306:   pReq->length[0] = 0;",
          "307:   pReq->length[1] = 6;",
          "308:   if (pSen->cmnd == light2_sOff)",
          "309:    pReq->data[0] = 0x00;",
          "310:   else",
          "311:    pReq->data[0] = 0xFF;",
          "312:   pReq->data[1] = 0x00;",
          "313:   size_t dataLength = pReq->length[1] + 6;",
          "315:   m_Cmd = DAE_WRITE_COIL_CMD;",
          "316:   write(\"\");",
          "317:   write(\"\");",
          "318:   write(\"\");",
          "319:   write(\"\");",
          "320:   write((uint8_t*)pReq, dataLength);",
          "321:   return true;",
          "322:  }",
          "323:  }",
          "325:  _log.Log(LOG_ERROR, \"Denkovi: Unknown Device!\");",
          "326:  return false;",
          "327: }",
          "329: uint16_t CDenkoviTCPDevices::ByteSwap(uint16_t in)",
          "330: { uint16_t out;",
          "331:  uint8_t *indata = (uint8_t *)&in;",
          "332:  uint8_t *outdata = (uint8_t *)&out;",
          "333:  outdata[0] = indata[1];",
          "334:  outdata[1] = indata[0];",
          "335:  return out;",
          "336: }",
          "338: void CDenkoviTCPDevices::SwapRequestBytes()",
          "339: {",
          "341:  tmpVar = ((pReq->trId & 0x00ff) << 8) | ((pReq->trId & 0xff00) >> 8);",
          "342:  pReq->trId = tmpVar;",
          "343:  tmpVar = ((pReq->length & 0x00ff) << 8) | ((pReq->length & 0xff00) >> 8);",
          "344:  pReq->length = tmpVar;",
          "345:  tmpVar = ((pReq->address & 0x00ff) << 8) | ((pReq->address & 0xff00) >> 8);",
          "350: }",
          "352: void CDenkoviTCPDevices::SwapResponseBytes()",
          "353: {",
          "355:  tmpVar = ((pResp->trId & 0x00ff) << 8) | ((pResp->trId & 0xff00) >> 8);",
          "356:  pResp->trId = tmpVar;",
          "357:  tmpVar = ((pResp->length & 0x00ff) << 8) | ((pResp->length & 0xff00) >> 8);",
          "361: }",
          "363: void CDenkoviTCPDevices::GetMeterDetails()",
          "364: {",
          "365:  switch (m_iModel) {",
          "366:  case DDEV_WIFI_16R: {",
          "367:   m_Cmd = DAE_WIFI16_ASK_CMD;",
          "368:   write(\"ask//\");",
          "369:   break;",
          "370:  }",
          "371:  case DDEV_WIFI_16R_Modbus: {",
          "372:   m_Cmd = DAE_READ_COILS_CMD;",
          "373:   pReq->prId[0] = 0;",
          "374:   pReq->prId[1] = 0;",
          "375:   transactionCounter++;",
          "376:   pReq->trId[0] = (uint8_t)(transactionCounter >> 8);",
          "377:   pReq->trId[1] = (uint8_t)(transactionCounter);",
          "378:   pReq->address[0] = 0;",
          "379:   pReq->address[1] = 0;",
          "380:   pReq->fc = DMODBUS_READ_COILS;",
          "381:   pReq->length[0] = 0;",
          "382:   pReq->length[1] = 6;",
          "383:   pReq->unitId = m_slaveId;",
          "384:   pReq->data[0] = 0;",
          "385:   pReq->data[1] = 16;",
          "386:   size_t dataLength = pReq->length[1] + 6;",
          "388:   write(\"\");",
          "389:   write(\"\");",
          "390:   write(\"\");",
          "391:   write(\"\");",
          "392:   write((uint8_t*)pReq, dataLength);",
          "393:   break;",
          "394:  }",
          "395:  }",
          "396: }",
          "",
          "---------------"
        ],
        "hardware/DenkoviTCPDevices.h||hardware/DenkoviTCPDevices.h": [
          "File: hardware/DenkoviTCPDevices.h -> hardware/DenkoviTCPDevices.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #pragma once",
          "3: #include \"DomoticzHardware.h\"",
          "4: #include \"ASyncTCP.h\"",
          "5: #include <iosfwd>",
          "7: enum _eDenkoviTCPDevice",
          "8: {",
          "9:  DDEV_WIFI_16R = 0,      //0",
          "10:  DDEV_WIFI_16R_Modbus,      //1",
          "11:  DDEV_DAEnet_IP401",
          "12: };",
          "14: #define DMODBUS_READ_COILS      1",
          "15: #define DMODBUS_WRITE_SINGLE_COIL    5",
          "16: #define DMODBUS_WRITE_MULTIPLE_COILS   15",
          "17: #define DMODBUS_READ_REGISTERS     3",
          "18: #define DMODBUS_WRITE_SINGLE_REGISTER   6",
          "19: #define DMODBUS_WRITE_MULTIPLE_REGISTERS  16",
          "21: struct _sDenkoviTCPModbusRequest {",
          "22:  uint8_t trId[2] = {0,0};//transaction ID",
          "23:  uint8_t prId[2] = {0,0};//protocol ID",
          "24:  uint8_t length[2] = { 0,6 };//message length",
          "25:  uint8_t unitId = 1;//unit ID",
          "26:  uint8_t fc = 1;//function code",
          "27:  uint8_t address[2] = { 0,0 };//address of first Register/Coil",
          "28:  uint8_t data[100] = { 16 };//different data for different Function Code",
          "29: };",
          "31: struct _sDenkoviTCPModbusResponse {",
          "32:  uint8_t trId[2] = { 0,0 };//transaction ID",
          "33:  uint8_t prId[2] = { 0,0 };//protocol ID",
          "34:  uint8_t length[2] = { 0,6 };//message length",
          "35:  uint8_t unitId = 1;//unit ID",
          "36:  uint8_t fc = 1;//function code",
          "37:  uint8_t dataLength = 2;//data buffer length",
          "38:  uint8_t data[100] = { 16 };//different data for different Function Code",
          "39: };",
          "42:  uint16_t trId = 0;//transaction ID",
          "43:  uint16_t prId = 0;//protocol ID",
          "44:  uint16_t length = 6;//message length",
          "45:  uint8_t unitId = 1;//unit ID",
          "46:  uint8_t fc = 1;//function code",
          "47:  uint16_t address = 0;//address of first Register/Coil",
          "48:  uint8_t data[100] = {16};//different data for different Function Code",
          "49: };",
          "51: struct _sDenkoviTCPModbusResponse {",
          "52:  uint16_t trId = 0;//transaction ID",
          "53:  uint16_t prId = 0;//protocol ID",
          "54:  uint16_t length = 5;//message length",
          "55:  uint8_t unitId = 1;//unit ID",
          "56:  uint8_t fc = 1;//function code",
          "57:  uint8_t dataLength = 2;//data buffer length",
          "58:  uint8_t data[100] = { 16 };//different data for different Function Code",
          "61: class CDenkoviTCPDevices : public CDomoticzHardwareBase, ASyncTCP",
          "62: {",
          "63: public:",
          "64:  CDenkoviTCPDevices(const int ID, const std::string &IPAddress, const unsigned short usIPPort, const int pollInterval, const int model, const int slaveId);",
          "65:  ~CDenkoviTCPDevices(void);",
          "66:  bool WriteToHardware(const char *pdata, const unsigned char length) override;",
          "67: private:",
          "68:  void Init();",
          "69:  bool StartHardware() override;",
          "70:  bool StopHardware() override;",
          "71:  void Do_Work();",
          "72:  void GetMeterDetails();",
          "73:  void readCallBack(const char * data, size_t len);",
          "74:  uint16_t ByteSwap(uint16_t in);",
          "75:  void SwapRequestBytes();",
          "76:  void SwapResponseBytes();",
          "77:  void copyBuffer(const uint8_t * source, uint8_t * destination, size_t length);",
          "78: private:",
          "79:  std::string m_szIPAddress;",
          "80:  unsigned short m_usIPPort;",
          "81:  std::string m_Password;",
          "82:  int m_pollInterval;",
          "83:  int m_slaveId;",
          "84:  volatile bool m_stoprequested;",
          "85:  int m_iModel;",
          "87:  std::shared_ptr<std::thread> m_thread;",
          "88:  int m_Cmd;",
          "89:  bool readingNow = false;",
          "90:  bool updateIo = false;",
          "91:  bool bFirstTime = true;",
          "93:  _sDenkoviTCPModbusRequest *pReq;// = new _sDenkoviTCPModbusRequest;// &sReq;",
          "95:  _sDenkoviTCPModbusResponse *pResp;// = new _sDenkoviTCPModbusResponse;// &sResp;",
          "96:  uint16_t receivedDataLength = 0;",
          "97:  uint16_t transactionCounter = 0;",
          "99: protected:",
          "100:  void OnConnect();",
          "101:  void OnDisconnect();",
          "102:  void OnData(const unsigned char *pData, size_t length);",
          "103:  void OnError(const std::exception e);",
          "104:  void OnError(const boost::system::error_code& error);",
          "105: };",
          "",
          "[Added Lines]",
          "1: #pragma once",
          "3: #include \"DomoticzHardware.h\"",
          "4: #include \"ASyncTCP.h\"",
          "5: #include <iosfwd>",
          "7: enum _eDenkoviTCPDevice",
          "8: {",
          "9:  DDEV_WIFI_16R = 0,      //0",
          "10:  DDEV_WIFI_16R_Modbus,      //1",
          "11:  DDEV_DAEnet_IP401",
          "12: };",
          "14: #define DMODBUS_READ_COILS      1",
          "15: #define DMODBUS_WRITE_SINGLE_COIL    5",
          "16: #define DMODBUS_WRITE_MULTIPLE_COILS   15",
          "17: #define DMODBUS_READ_REGISTERS     3",
          "18: #define DMODBUS_WRITE_SINGLE_REGISTER   6",
          "19: #define DMODBUS_WRITE_MULTIPLE_REGISTERS  16",
          "21: struct _sDenkoviTCPModbusRequest {",
          "22:  uint8_t trId[2] = {0,0};//transaction ID",
          "23:  uint8_t prId[2] = {0,0};//protocol ID",
          "24:  uint8_t length[2] = { 0,6 };//message length",
          "25:  uint8_t unitId = 1;//unit ID",
          "26:  uint8_t fc = 1;//function code",
          "27:  uint8_t address[2] = { 0,0 };//address of first Register/Coil",
          "28:  uint8_t data[100] = { 16 };//different data for different Function Code",
          "29: };",
          "31: struct _sDenkoviTCPModbusResponse {",
          "32:  uint8_t trId[2] = { 0,0 };//transaction ID",
          "33:  uint8_t prId[2] = { 0,0 };//protocol ID",
          "34:  uint8_t length[2] = { 0,6 };//message length",
          "35:  uint8_t unitId = 1;//unit ID",
          "36:  uint8_t fc = 1;//function code",
          "37:  uint8_t dataLength = 2;//data buffer length",
          "38:  uint8_t data[100] = { 16 };//different data for different Function Code",
          "39: };",
          "42:  uint16_t trId = 0;//transaction ID",
          "43:  uint16_t prId = 0;//protocol ID",
          "44:  uint16_t length = 6;//message length",
          "45:  uint8_t unitId = 1;//unit ID",
          "46:  uint8_t fc = 1;//function code",
          "47:  uint16_t address = 0;//address of first Register/Coil",
          "48:  uint8_t data[100] = {16};//different data for different Function Code",
          "49: };",
          "51: struct _sDenkoviTCPModbusResponse {",
          "52:  uint16_t trId = 0;//transaction ID",
          "53:  uint16_t prId = 0;//protocol ID",
          "54:  uint16_t length = 5;//message length",
          "55:  uint8_t unitId = 1;//unit ID",
          "56:  uint8_t fc = 1;//function code",
          "57:  uint8_t dataLength = 2;//data buffer length",
          "58:  uint8_t data[100] = { 16 };//different data for different Function Code",
          "61: class CDenkoviTCPDevices : public CDomoticzHardwareBase, ASyncTCP",
          "62: {",
          "63: public:",
          "64:  CDenkoviTCPDevices(const int ID, const std::string &IPAddress, const unsigned short usIPPort, const int pollInterval, const int model, const int slaveId);",
          "65:  ~CDenkoviTCPDevices(void);",
          "66:  bool WriteToHardware(const char *pdata, const unsigned char length) override;",
          "67: private:",
          "68:  void Init();",
          "69:  bool StartHardware() override;",
          "70:  bool StopHardware() override;",
          "71:  void Do_Work();",
          "72:  void GetMeterDetails();",
          "73:  void readCallBack(const char * data, size_t len);",
          "74:  uint16_t ByteSwap(uint16_t in);",
          "75:  void SwapRequestBytes();",
          "76:  void SwapResponseBytes();",
          "77:  void copyBuffer(const uint8_t * source, uint8_t * destination, size_t length);",
          "78: private:",
          "79:  std::string m_szIPAddress;",
          "80:  unsigned short m_usIPPort;",
          "81:  std::string m_Password;",
          "82:  int m_pollInterval;",
          "83:  int m_slaveId;",
          "84:  volatile bool m_stoprequested;",
          "85:  int m_iModel;",
          "87:  std::shared_ptr<std::thread> m_thread;",
          "88:  int m_Cmd;",
          "89:  bool readingNow = false;",
          "90:  bool updateIo = false;",
          "91:  bool bFirstTime = true;",
          "93:  _sDenkoviTCPModbusRequest *pReq;// = new _sDenkoviTCPModbusRequest;// &sReq;",
          "95:  _sDenkoviTCPModbusResponse *pResp;// = new _sDenkoviTCPModbusResponse;// &sResp;",
          "96:  uint16_t receivedDataLength = 0;",
          "97:  uint16_t transactionCounter = 0;",
          "99: protected:",
          "100:  void OnConnect();",
          "101:  void OnDisconnect();",
          "102:  void OnData(const unsigned char *pData, size_t length);",
          "103:  void OnError(const std::exception e);",
          "104:  void OnError(const boost::system::error_code& error);",
          "105: };",
          "",
          "---------------"
        ],
        "hardware/DenkoviUSBDevices.cpp||hardware/DenkoviUSBDevices.cpp": [
          "File: hardware/DenkoviUSBDevices.cpp -> hardware/DenkoviUSBDevices.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #include \"stdafx.h\"",
          "2: #include \"DenkoviUSBDevices.h\"",
          "3: #include \"../main/Logger.h\"",
          "4: #include \"../main/Helper.h\"",
          "5: #include \"../main/localtime_r.h\"",
          "6: #include \"../main/mainworker.h\"",
          "8: #include <iostream>",
          "9: #include <boost/lexical_cast.hpp>",
          "11: #define MAX_POLL_INTERVAL 30*1000",
          "13: enum _edaeUsbState",
          "14: {",
          "15:  RESPOND_RECEIVED = 0,  //0",
          "16:  DAE_USB16_UPDATE_IO,     //1",
          "17:  DAE_USB16_ASK_CMD    //2",
          "18: };",
          "20: #define DAE_IO_TYPE_RELAY  2",
          "22: CDenkoviUSBDevices::CDenkoviUSBDevices(const int ID, const std::string& comPort, const int model) :",
          "23:  m_szSerialPort(comPort)",
          "24: {",
          "25:  m_HwdID = ID;",
          "26:  m_stoprequested = false;",
          "27:  m_bOutputLog = false;",
          "28:  m_iModel = model;",
          "29:  m_pollInterval = 1000;",
          "31:   m_pollInterval = 500;",
          "32:  else if (m_pollInterval > MAX_POLL_INTERVAL)",
          "34:  Init();",
          "35: }",
          "38: CDenkoviUSBDevices::~CDenkoviUSBDevices()",
          "39: {",
          "40: }",
          "42: void CDenkoviUSBDevices::Init()",
          "43: {",
          "44: }",
          "46: bool CDenkoviUSBDevices::StartHardware()",
          "47: {",
          "48:  m_stoprequested = false;",
          "49:  m_thread = std::make_shared<std::thread>(&CDenkoviUSBDevices::Do_Work, this);",
          "52:  if (m_iModel == DDEV_USB_16R)",
          "53:   m_baudRate = 9600;",
          "56:  try",
          "57:  {",
          "58:   open(",
          "59:    m_szSerialPort,",
          "60:    m_baudRate,",
          "61:    boost::asio::serial_port_base::parity(",
          "62:     boost::asio::serial_port_base::parity::none),",
          "63:    boost::asio::serial_port_base::character_size(8),",
          "64:    boost::asio::serial_port_base::flow_control(",
          "65:    boost::asio::serial_port_base::flow_control::none),",
          "66:    boost::asio::serial_port_base::stop_bits(boost::asio::serial_port_base::stop_bits::one)",
          "67:   );",
          "68:  }",
          "69:  catch (boost::exception & e)",
          "70:  {",
          "71:   if (m_iModel == DDEV_USB_16R)",
          "72:    _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Error opening serial port!\");",
          "73:   (void)e;",
          "74:   return false;",
          "75:  }",
          "76:  catch (...)",
          "77:  {",
          "78:   if (m_iModel == DDEV_USB_16R)",
          "79:    _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Error opening serial port!\");",
          "80:   return false;",
          "81:  }",
          "82:  m_bIsStarted = true;",
          "83:  setReadCallback(boost::bind(&CDenkoviUSBDevices::readCallBack, this, _1, _2));",
          "85:  sOnConnected(this);",
          "86:  return true;",
          "87: }",
          "89: void CDenkoviUSBDevices::readCallBack(const char * data, size_t len)",
          "90: {",
          "91:  std::lock_guard<std::mutex> l(readQueueMutex);",
          "94:  if (!m_bEnableReceive) {",
          "95:   readingNow = false;",
          "96:   return; //receiving not enabled",
          "97:  }",
          "98:  uint8_t tmp = (unsigned char)data[0];",
          "100:  switch (m_iModel) {",
          "101:  case DDEV_USB_16R:",
          "102:   if (m_Cmd == DAE_USB16_ASK_CMD) {",
          "103:    uint8_t firstEight, secondEight;",
          "104:    if (len == 2) {",
          "105:     firstEight = (unsigned char)data[0];",
          "106:     secondEight = (unsigned char)data[1];",
          "107:    }",
          "108:    else {",
          "109:     _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Response error.\");",
          "110:     return;",
          "111:    }",
          "112:    uint8_t z = 0;",
          "113:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "114:     z = (firstEight >> (8 - ii)) & 0x01;",
          "115:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii, 255, (((firstEight >> (8 - ii)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(ii));",
          "116:    }",
          "117:    for (uint8_t ii = 1; ii < 9; ii++)",
          "118:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii + 8, 255, ((secondEight >> (8 - ii) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(8+ii));",
          "119:   }",
          "120:   break;",
          "121:  }",
          "122:  updateIo = false;",
          "123:  readingNow = false;",
          "124: }",
          "127: void CDenkoviUSBDevices::OnData(const unsigned char *pData, size_t length)",
          "128: {",
          "129:  std::lock_guard<std::mutex> l(readQueueMutex);",
          "131:  uint8_t firstEight, secondEight;",
          "132:  if (length == 2) {",
          "133:   firstEight = (unsigned char)pData[0];",
          "134:   secondEight = (unsigned char)pData[1];",
          "135:  }",
          "136: }",
          "138: void CDenkoviUSBDevices::OnError(const std::exception e)",
          "139: {",
          "140:  _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Error: %s\", e.what());",
          "141: }",
          "143: bool CDenkoviUSBDevices::StopHardware()",
          "144: {",
          "145:  if (m_thread != NULL)",
          "146:  {",
          "147:   assert(m_thread);",
          "148:   m_stoprequested = true;",
          "149:   m_thread->join();",
          "150:  }",
          "151:  m_bIsStarted = false;",
          "152:  return true;",
          "153: }",
          "155: void CDenkoviUSBDevices::Do_Work()",
          "156: {",
          "157:  int poll_interval = m_pollInterval / 100;",
          "158:  int poll_counter = poll_interval - 2;",
          "160:  int msec_counter = 0;",
          "162:  while (!m_stoprequested)",
          "163:  {",
          "164:   m_LastHeartbeat = mytime(NULL);",
          "165:   sleep_milliseconds(40);",
          "166:   if (msec_counter++ >= 100) {",
          "167:    msec_counter = 0;",
          "168:    if (readingNow == false && updateIo == false)",
          "169:     GetMeterDetails();",
          "170:   }",
          "171:  }",
          "173:  switch (m_iModel) {",
          "174:  case DDEV_USB_16R:",
          "175:   _log.Log(LOG_STATUS, \"USB 16 Relays-VCP: Worker stopped...\");",
          "176:   break;",
          "177:  }",
          "178: }",
          "180: bool CDenkoviUSBDevices::WriteToHardware(const char *pdata, const unsigned char length)",
          "181: {",
          "182:  updateIo = true;",
          "183:  const _tGeneralSwitch *pSen = reinterpret_cast<const _tGeneralSwitch*>(pdata);",
          "184:  if (m_bIsStarted == false)",
          "185:   return false;",
          "187:  switch (m_iModel) {",
          "188:  case DDEV_USB_16R: {",
          "189:   std::stringstream szCmd;",
          "190:   int ioType = pSen->id;",
          "191:   if (ioType != DAE_IO_TYPE_RELAY)",
          "192:   {",
          "193:    _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Not a valid Relay\");",
          "194:    return false;",
          "195:   }",
          "196:   int io = pSen->unitcode;//Relay1 to Relay16",
          "197:   if (io > 16)",
          "198:    return false;",
          "200:   szCmd << (io < 10 ? \"0\" : \"\") << io;",
          "201:   if (pSen->cmnd == light2_sOff)",
          "202:    szCmd << \"-//\";",
          "203:   else if (pSen->cmnd == light2_sOn)",
          "204:    szCmd << \"+//\";",
          "205:   m_Cmd = DAE_USB16_UPDATE_IO;",
          "206:   write(szCmd.str());",
          "207:   return true;",
          "208:  }",
          "209:  }",
          "210:  _log.Log(LOG_ERROR, \"Denkovi: Unknown Device!\");",
          "211:  return false;",
          "212: }",
          "214: void CDenkoviUSBDevices::GetMeterDetails()",
          "215: {",
          "216:  readingNow = true;",
          "217:  std::string sResult, sResult2;",
          "218:  std::stringstream szURL, szURL2;",
          "220:  switch (m_iModel) {",
          "221:  case DDEV_USB_16R:",
          "222:   m_Cmd = DAE_USB16_ASK_CMD;",
          "223:   write(\"ask//\");",
          "224:   break;",
          "225:  }",
          "226: }",
          "",
          "[Added Lines]",
          "1: #include \"stdafx.h\"",
          "2: #include \"DenkoviUSBDevices.h\"",
          "3: #include \"../main/Logger.h\"",
          "4: #include \"../main/Helper.h\"",
          "5: #include \"../main/localtime_r.h\"",
          "6: #include \"../main/mainworker.h\"",
          "8: #include <iostream>",
          "9: #include <boost/lexical_cast.hpp>",
          "11: #define MAX_POLL_INTERVAL 30*1000",
          "13: enum _edaeUsbState",
          "14: {",
          "15:  RESPOND_RECEIVED = 0,  //0",
          "16:  DAE_USB16_UPDATE_IO,     //1",
          "17:  DAE_USB16_ASK_CMD    //2",
          "18: };",
          "20: #define DAE_IO_TYPE_RELAY  2",
          "22: CDenkoviUSBDevices::CDenkoviUSBDevices(const int ID, const std::string& comPort, const int model) :",
          "23:  m_szSerialPort(comPort)",
          "24: {",
          "25:  m_HwdID = ID;",
          "26:  m_stoprequested = false;",
          "27:  m_bOutputLog = false;",
          "28:  m_iModel = model;",
          "29:  m_pollInterval = 1000;",
          "31:   m_pollInterval = 500;",
          "32:  else if (m_pollInterval > MAX_POLL_INTERVAL)",
          "34:  Init();",
          "35: }",
          "38: CDenkoviUSBDevices::~CDenkoviUSBDevices()",
          "39: {",
          "40: }",
          "42: void CDenkoviUSBDevices::Init()",
          "43: {",
          "44: }",
          "46: bool CDenkoviUSBDevices::StartHardware()",
          "47: {",
          "48:  m_stoprequested = false;",
          "49:  m_thread = std::make_shared<std::thread>(&CDenkoviUSBDevices::Do_Work, this);",
          "52:  if (m_iModel == DDEV_USB_16R)",
          "53:   m_baudRate = 9600;",
          "56:  try",
          "57:  {",
          "58:   open(",
          "59:    m_szSerialPort,",
          "60:    m_baudRate,",
          "61:    boost::asio::serial_port_base::parity(",
          "62:     boost::asio::serial_port_base::parity::none),",
          "63:    boost::asio::serial_port_base::character_size(8),",
          "64:    boost::asio::serial_port_base::flow_control(",
          "65:    boost::asio::serial_port_base::flow_control::none),",
          "66:    boost::asio::serial_port_base::stop_bits(boost::asio::serial_port_base::stop_bits::one)",
          "67:   );",
          "68:  }",
          "69:  catch (boost::exception & e)",
          "70:  {",
          "71:   if (m_iModel == DDEV_USB_16R)",
          "72:    _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Error opening serial port!\");",
          "73:   (void)e;",
          "74:   return false;",
          "75:  }",
          "76:  catch (...)",
          "77:  {",
          "78:   if (m_iModel == DDEV_USB_16R)",
          "79:    _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Error opening serial port!\");",
          "80:   return false;",
          "81:  }",
          "82:  m_bIsStarted = true;",
          "83:  setReadCallback(boost::bind(&CDenkoviUSBDevices::readCallBack, this, _1, _2));",
          "85:  sOnConnected(this);",
          "86:  return true;",
          "87: }",
          "89: void CDenkoviUSBDevices::readCallBack(const char * data, size_t len)",
          "90: {",
          "91:  std::lock_guard<std::mutex> l(readQueueMutex);",
          "94:  if (!m_bEnableReceive) {",
          "95:   readingNow = false;",
          "96:   return; //receiving not enabled",
          "97:  }",
          "98:  uint8_t tmp = (unsigned char)data[0];",
          "100:  switch (m_iModel) {",
          "101:  case DDEV_USB_16R:",
          "102:   if (m_Cmd == DAE_USB16_ASK_CMD) {",
          "103:    uint8_t firstEight, secondEight;",
          "104:    if (len == 2) {",
          "105:     firstEight = (unsigned char)data[0];",
          "106:     secondEight = (unsigned char)data[1];",
          "107:    }",
          "108:    else {",
          "109:     _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Response error.\");",
          "110:     return;",
          "111:    }",
          "112:    uint8_t z = 0;",
          "113:    for (uint8_t ii = 1; ii < 9; ii++) {",
          "114:     z = (firstEight >> (8 - ii)) & 0x01;",
          "115:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii, 255, (((firstEight >> (8 - ii)) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(ii));",
          "116:    }",
          "117:    for (uint8_t ii = 1; ii < 9; ii++)",
          "118:     SendGeneralSwitch(DAE_IO_TYPE_RELAY, ii + 8, 255, ((secondEight >> (8 - ii) & 0x01) != 0) ? true : false, 100, \"Relay \" + std::to_string(8+ii));",
          "119:   }",
          "120:   break;",
          "121:  }",
          "122:  updateIo = false;",
          "123:  readingNow = false;",
          "124: }",
          "127: void CDenkoviUSBDevices::OnData(const unsigned char *pData, size_t length)",
          "128: {",
          "129:  std::lock_guard<std::mutex> l(readQueueMutex);",
          "131:  uint8_t firstEight, secondEight;",
          "132:  if (length == 2) {",
          "133:   firstEight = (unsigned char)pData[0];",
          "134:   secondEight = (unsigned char)pData[1];",
          "135:  }",
          "136: }",
          "138: void CDenkoviUSBDevices::OnError(const std::exception e)",
          "139: {",
          "140:  _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Error: %s\", e.what());",
          "141: }",
          "143: bool CDenkoviUSBDevices::StopHardware()",
          "144: {",
          "145:  if (m_thread != NULL)",
          "146:  {",
          "147:   assert(m_thread);",
          "148:   m_stoprequested = true;",
          "149:   m_thread->join();",
          "150:  }",
          "151:  m_bIsStarted = false;",
          "152:  return true;",
          "153: }",
          "155: void CDenkoviUSBDevices::Do_Work()",
          "156: {",
          "157:  int poll_interval = m_pollInterval / 100;",
          "158:  int poll_counter = poll_interval - 2;",
          "160:  int msec_counter = 0;",
          "162:  while (!m_stoprequested)",
          "163:  {",
          "164:   m_LastHeartbeat = mytime(NULL);",
          "165:   sleep_milliseconds(40);",
          "166:   if (msec_counter++ >= 100) {",
          "167:    msec_counter = 0;",
          "168:    if (readingNow == false && updateIo == false)",
          "169:     GetMeterDetails();",
          "170:   }",
          "171:  }",
          "173:  switch (m_iModel) {",
          "174:  case DDEV_USB_16R:",
          "175:   _log.Log(LOG_STATUS, \"USB 16 Relays-VCP: Worker stopped...\");",
          "176:   break;",
          "177:  }",
          "178: }",
          "180: bool CDenkoviUSBDevices::WriteToHardware(const char *pdata, const unsigned char length)",
          "181: {",
          "182:  updateIo = true;",
          "183:  const _tGeneralSwitch *pSen = reinterpret_cast<const _tGeneralSwitch*>(pdata);",
          "184:  if (m_bIsStarted == false)",
          "185:   return false;",
          "187:  switch (m_iModel) {",
          "188:  case DDEV_USB_16R: {",
          "189:   std::stringstream szCmd;",
          "190:   int ioType = pSen->id;",
          "191:   if (ioType != DAE_IO_TYPE_RELAY)",
          "192:   {",
          "193:    _log.Log(LOG_ERROR, \"USB 16 Relays-VCP: Not a valid Relay\");",
          "194:    return false;",
          "195:   }",
          "196:   int io = pSen->unitcode;//Relay1 to Relay16",
          "197:   if (io > 16)",
          "198:    return false;",
          "200:   szCmd << (io < 10 ? \"0\" : \"\") << io;",
          "201:   if (pSen->cmnd == light2_sOff)",
          "202:    szCmd << \"-//\";",
          "203:   else if (pSen->cmnd == light2_sOn)",
          "204:    szCmd << \"+//\";",
          "205:   m_Cmd = DAE_USB16_UPDATE_IO;",
          "206:   write(szCmd.str());",
          "207:   return true;",
          "208:  }",
          "209:  }",
          "210:  _log.Log(LOG_ERROR, \"Denkovi: Unknown Device!\");",
          "211:  return false;",
          "212: }",
          "214: void CDenkoviUSBDevices::GetMeterDetails()",
          "215: {",
          "216:  readingNow = true;",
          "217:  std::string sResult, sResult2;",
          "218:  std::stringstream szURL, szURL2;",
          "220:  switch (m_iModel) {",
          "221:  case DDEV_USB_16R:",
          "222:   m_Cmd = DAE_USB16_ASK_CMD;",
          "223:   write(\"ask//\");",
          "224:   break;",
          "225:  }",
          "226: }",
          "",
          "---------------"
        ],
        "hardware/DenkoviUSBDevices.h||hardware/DenkoviUSBDevices.h": [
          "File: hardware/DenkoviUSBDevices.h -> hardware/DenkoviUSBDevices.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "1: #pragma once",
          "3: #include \"DomoticzHardware.h\"",
          "4: #include \"ASyncSerial.h\"",
          "5: #include <iosfwd>",
          "7: enum _eDenkoviUSBDevice",
          "8: {",
          "9:  DDEV_USB_16R = 0,      //0",
          "10:  DDEV_USB_16R_Modbus,      //1",
          "11:  DDEV_DAEnet_IP40",
          "12: };",
          "14: class CDenkoviUSBDevices : public CDomoticzHardwareBase, AsyncSerial",
          "15: {",
          "16: public:",
          "17:  CDenkoviUSBDevices(const int ID, const std::string& comPort, const int model);",
          "18:  ~CDenkoviUSBDevices(void);",
          "19:  bool WriteToHardware(const char *pdata, const unsigned char length) override;",
          "20: private:",
          "21:  void Init();",
          "22:  bool StartHardware() override;",
          "23:  bool StopHardware() override;",
          "24:  void Do_Work();",
          "25:  void GetMeterDetails();",
          "26:  void readCallBack(const char * data, size_t len);",
          "27: private:",
          "28:  std::string m_szSerialPort;",
          "29:  int m_baudRate;",
          "30:  int m_pollInterval;",
          "31:  volatile bool m_stoprequested;",
          "32:  int m_iModel;",
          "33:  std::shared_ptr<std::thread> m_thread;",
          "35:  int m_Cmd;",
          "36:  bool readingNow = false;",
          "37:  bool updateIo = false;",
          "39: protected:",
          "40:  void OnData(const unsigned char *pData, size_t length);",
          "41:  void OnError(const std::exception e);",
          "42: };",
          "",
          "[Added Lines]",
          "1: #pragma once",
          "3: #include \"DomoticzHardware.h\"",
          "4: #include \"ASyncSerial.h\"",
          "5: #include <iosfwd>",
          "7: enum _eDenkoviUSBDevice",
          "8: {",
          "9:  DDEV_USB_16R = 0,      //0",
          "10:  DDEV_USB_16R_Modbus,      //1",
          "11:  DDEV_DAEnet_IP40",
          "12: };",
          "14: class CDenkoviUSBDevices : public CDomoticzHardwareBase, AsyncSerial",
          "15: {",
          "16: public:",
          "17:  CDenkoviUSBDevices(const int ID, const std::string& comPort, const int model);",
          "18:  ~CDenkoviUSBDevices(void);",
          "19:  bool WriteToHardware(const char *pdata, const unsigned char length) override;",
          "20: private:",
          "21:  void Init();",
          "22:  bool StartHardware() override;",
          "23:  bool StopHardware() override;",
          "24:  void Do_Work();",
          "25:  void GetMeterDetails();",
          "26:  void readCallBack(const char * data, size_t len);",
          "27: private:",
          "28:  std::string m_szSerialPort;",
          "29:  int m_baudRate;",
          "30:  int m_pollInterval;",
          "31:  volatile bool m_stoprequested;",
          "32:  int m_iModel;",
          "33:  std::shared_ptr<std::thread> m_thread;",
          "35:  int m_Cmd;",
          "36:  bool readingNow = false;",
          "37:  bool updateIo = false;",
          "39: protected:",
          "40:  void OnData(const unsigned char *pData, size_t length);",
          "41:  void OnError(const std::exception e);",
          "42: };",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "e695a8aa63e44e67de4533de88249170898baa76",
      "candidate_info": {
        "commit_hash": "e695a8aa63e44e67de4533de88249170898baa76",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/e695a8aa63e44e67de4533de88249170898baa76",
        "files": [
          "main/Helper.cpp",
          "main/Helper.h",
          "main/domoticz.cpp"
        ],
        "message": "Fix user data folder ending",
        "before_after_code_files": [
          "main/Helper.cpp||main/Helper.cpp",
          "main/Helper.h||main/Helper.h",
          "main/domoticz.cpp||main/domoticz.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "main/Helper.cpp||main/Helper.cpp": [
          "File: main/Helper.cpp -> main/Helper.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "842:  return 12;",
          "843: }",
          "845: bool dirent_is_directory(const std::string &dir, struct dirent *ent)",
          "846: {",
          "847:  if (ent->d_type == DT_DIR)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "845: void FixFolderEnding(std::string &folder)",
          "846: {",
          "847: #if defined(WIN32)",
          "848:  if (folder.at(folder.length() - 1) != '\\\\')",
          "849:   folder += \"\\\\\";",
          "850: #else",
          "851:  if (folder.at(folder.length() - 1) != '/')",
          "852:   folder += \"/\";",
          "853: #endif",
          "854: }",
          "",
          "---------------"
        ],
        "main/Helper.h||main/Helper.h": [
          "File: main/Helper.h -> main/Helper.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "57: int MStoBeaufort(const float ms);",
          "59: struct dirent;",
          "60: bool dirent_is_directory(const std::string &dir, struct dirent *ent);",
          "61: bool dirent_is_file(const std::string &dir, struct dirent *ent);",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "59: void FixFolderEnding(std::string &folder);",
          "",
          "---------------"
        ],
        "main/domoticz.cpp||main/domoticz.cpp": [
          "File: main/domoticz.cpp -> main/domoticz.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "837:    }",
          "838:    std::string szroot = cmdLine.GetSafeArgument(\"-userdata\", 0, \"\");",
          "839:    if (szroot.size() != 0)",
          "840:     szUserDataFolder = szroot;",
          "841:   }",
          "842:   if (cmdLine.HasSwitch(\"-startupdelay\"))",
          "843:   {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "840:    {",
          "842:     FixFolderEnding(szUserDataFolder);",
          "843:    }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4058344254b1899f293be585716f3c83256736b5",
      "candidate_info": {
        "commit_hash": "4058344254b1899f293be585716f3c83256736b5",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/4058344254b1899f293be585716f3c83256736b5",
        "files": [
          "hardware/plugins/PluginTransports.cpp"
        ],
        "message": "Bug fix: Transport code could crash on zero length message",
        "before_after_code_files": [
          "hardware/plugins/PluginTransports.cpp||hardware/plugins/PluginTransports.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/plugins/PluginTransports.cpp||hardware/plugins/PluginTransports.cpp": [
          "File: hardware/plugins/PluginTransports.cpp -> hardware/plugins/PluginTransports.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "975:  void CPluginTransportSerial::handleWrite(const std::vector<byte>& data)",
          "976:  {",
          "978:  }",
          "980:  bool CPluginTransportSerial::handleDisconnect()",
          "",
          "[Removed Lines]",
          "977:   write((const char *)&data[0], data.size());",
          "",
          "[Added Lines]",
          "977:   if (data.size())",
          "978:   {",
          "979:    write((const char *)&data[0], data.size());",
          "980:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "11ef59cc99ba1ecd103f3c05e4054356f89533ad",
      "candidate_info": {
        "commit_hash": "11ef59cc99ba1ecd103f3c05e4054356f89533ad",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/11ef59cc99ba1ecd103f3c05e4054356f89533ad",
        "files": [
          "hardware/PhilipsHue/PhilipsHue.cpp"
        ],
        "message": "PhilipsHue,using normal iterators again",
        "before_after_code_files": [
          "hardware/PhilipsHue/PhilipsHue.cpp||hardware/PhilipsHue/PhilipsHue.cpp"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/PhilipsHue/PhilipsHue.cpp||hardware/PhilipsHue/PhilipsHue.cpp": [
          "File: hardware/PhilipsHue/PhilipsHue.cpp -> hardware/PhilipsHue/PhilipsHue.cpp",
          "--- Hunk 1 ---",
          "[Context before]",
          "282:  bool setCt = false;",
          "283:  bool setMode = false;",
          "284:  _eHueColorMode mode;",
          "287:  if (LCmd==\"On\")",
          "288:  {",
          "",
          "[Removed Lines]",
          "285:  _tHueLightState *pState = NULL;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "331:  }",
          "334:  if (nodeID < 1000)",
          "335:  {",
          "338:   if (ittLight != m_lights.end())",
          "339:   {",
          "340:    pState = &ittLight->second;",
          "",
          "[Removed Lines]",
          "337:   auto && ittLight = m_lights.find(nodeID);",
          "",
          "[Added Lines]",
          "333:  _tHueLightState *pState = NULL;",
          "338:   std::map<int, _tHueLightState>::iterator ittLight = m_lights.find(nodeID);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "343:  else if (nodeID < 2000)",
          "344:  {",
          "347:   if (ittGroup != m_groups.end())",
          "348:   {",
          "349:    pState = &ittGroup->second.gstate;",
          "",
          "[Removed Lines]",
          "346:   auto && ittGroup = m_groups.find(nodeID - 1000);",
          "",
          "[Added Lines]",
          "347:   std::map<int, _tHueGroup>::iterator ittGroup = m_groups.find(nodeID - 1000);",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "828:    _eHueLightType LType;",
          "829:    LightStateFromJSON(light[\"state\"], tlight, LType);",
          "832:    if (myLight != m_lights.end())",
          "833:    {",
          "834:     if (!StatesSimilar(myLight->second, tlight))",
          "",
          "[Removed Lines]",
          "831:    auto && myLight = m_lights.find(lID);",
          "",
          "[Added Lines]",
          "832:    std::map<int, _tHueLightState>::iterator myLight = m_lights.find(lID);",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "863:    _eHueLightType LType;",
          "864:    LightStateFromJSON(group[\"action\"], tstate, LType); //TODO: Verify there is no crash with \"bad\" key",
          "867:    if (myGroup != m_groups.end())",
          "868:    {",
          "869:     if (!StatesSimilar(myGroup->second.gstate, tstate))",
          "",
          "[Removed Lines]",
          "866:    auto && myGroup = m_groups.find(gID);",
          "",
          "[Added Lines]",
          "867:    std::map<int, _tHueGroup>::iterator myGroup = m_groups.find(gID);",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "941:  }",
          "943:  int gID = 0;",
          "945:  if (myGroup != m_groups.end())",
          "946:  {",
          "947:   if (!StatesSimilar(myGroup->second.gstate, tstate))",
          "",
          "[Removed Lines]",
          "944:  auto && myGroup = m_groups.find(gID);",
          "",
          "[Added Lines]",
          "945:  std::map<int, _tHueGroup>::iterator myGroup = m_groups.find(gID);",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0e3e15d4bbd05c71b3669f75480627ce39e5d765",
      "candidate_info": {
        "commit_hash": "0e3e15d4bbd05c71b3669f75480627ce39e5d765",
        "repo": "domoticz/domoticz",
        "commit_url": "https://github.com/domoticz/domoticz/commit/0e3e15d4bbd05c71b3669f75480627ce39e5d765",
        "files": [
          "hardware/ASyncTCP.h"
        ],
        "message": "ASyncTCP, Removed unneeded typedef declaration",
        "before_after_code_files": [
          "hardware/ASyncTCP.h||hardware/ASyncTCP.h"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/domoticz/domoticz/pull/3180"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "hardware/ASyncTCP.h||hardware/ASyncTCP.h": [
          "File: hardware/ASyncTCP.h -> hardware/ASyncTCP.h",
          "--- Hunk 1 ---",
          "[Context before]",
          "11: namespace boost { namespace system { class error_code; } }",
          "15: class ASyncTCP",
          "16: {",
          "17: public:",
          "",
          "[Removed Lines]",
          "13: typedef std::shared_ptr<class ASyncTCP> ASyncTCPRef;",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ]
      }
    }
  ]
}
{
  "cve_id": "CVE-2020-15473",
  "cve_desc": "In nDPI through 3.2, the OpenVPN dissector is vulnerable to a heap-based buffer over-read in ndpi_search_openvpn in lib/protocols/openvpn.c.",
  "repo": "ntop/nDPI",
  "patch_hash": "8e7b1ea7a136cc4e4aa9880072ec2d69900a825e",
  "patch_info": {
    "commit_hash": "8e7b1ea7a136cc4e4aa9880072ec2d69900a825e",
    "repo": "ntop/nDPI",
    "commit_url": "https://github.com/ntop/nDPI/commit/8e7b1ea7a136cc4e4aa9880072ec2d69900a825e",
    "files": [
      "src/lib/protocols/openvpn.c"
    ],
    "message": "Fix for potential heap-buffer-overflow in ndpi_search_openvpn",
    "before_after_code_files": [
      "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
    ]
  },
  "patch_diff": {
    "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c": [
      "File: src/lib/protocols/openvpn.c -> src/lib/protocols/openvpn.c",
      "--- Hunk 1 ---",
      "[Context before]",
      "72:   u_int8_t alen;",
      "73:   int8_t hmac_size;",
      "74:   int8_t failed = 0;",
      "78:     if(packet->tcp != NULL)",
      "81:     opcode = ovpn_payload[0] & P_OPCODE_MASK;",
      "",
      "[Removed Lines]",
      "76:   if(packet->payload_packet_len >= 40) {",
      "79:       ovpn_payload += 2;",
      "",
      "[Added Lines]",
      "77:   if(ovpn_payload_len >= 40) {",
      "80:       ovpn_payload += 2, ovpn_payload_len -= 2;;",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "85:       printf(\"[packet_id: %u][opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\",",
      "86:       flow->num_processed_pkts,",
      "87:       opcode, check_pkid_and_detect_hmac_size(ovpn_payload),",
      "89: #endif",
      "91:       if(",
      "92:   (flow->num_processed_pkts == 1)",
      "93:   && (",
      "95:        && ((opcode == 168) || (opcode == 192))",
      "96:        )",
      "98:    && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168) || (opcode == 200)))",
      "99:       )) {",
      "100:  NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
      "",
      "[Removed Lines]",
      "88:       htons(packet->udp->source), htons(packet->udp->dest), packet->payload_packet_len);",
      "94:       ((packet->payload_packet_len == 112)",
      "97:       || ((packet->payload_packet_len == 80)",
      "",
      "[Added Lines]",
      "89:       htons(packet->udp->source), htons(packet->udp->dest), ovpn_payload_len);",
      "95:       ((ovpn_payload_len == 112)",
      "98:       || ((ovpn_payload_len == 80)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "119:       hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);",
      "121:       if(hmac_size > 0) {",
      "123:         if (alen > 0) {",
      "138:           failed = 1;",
      "139:       } else",
      "140:         failed = 1;",
      "",
      "[Removed Lines]",
      "122:         alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];",
      "124:    session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;",
      "126:           if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {",
      "127:      NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
      "128:      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
      "129:      return;",
      "130:    } else {",
      "131:             NDPI_LOG_DBG2(ndpi_struct,",
      "132:      \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",",
      "133:      session_remote[0], session_remote[1], session_remote[2], session_remote[3],",
      "134:      session_remote[4], session_remote[5], session_remote[6], session_remote[7]);",
      "135:             failed = 1;",
      "136:           }",
      "137:         } else",
      "",
      "[Added Lines]",
      "123:  u_int16_t offset = P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size);",
      "125:         alen = ovpn_payload[offset];",
      "128:    offset += 1 + alen * 4;",
      "130:    if((offset+8) <= ovpn_payload_len) {",
      "131:      session_remote = &ovpn_payload[offset];",
      "133:      if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {",
      "134:        NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
      "135:        ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
      "136:        return;",
      "137:      } else {",
      "138:        NDPI_LOG_DBG2(ndpi_struct,",
      "139:        \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",",
      "140:        session_remote[0], session_remote[1], session_remote[2], session_remote[3],",
      "141:        session_remote[4], session_remote[5], session_remote[6], session_remote[7]);",
      "142:        failed = 1;",
      "143:      }",
      "144:    } else",
      "145:      failed = 1;",
      "146:  } else",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "179b93d625f7f7f597329d2ffb322c19da5d7958",
      "candidate_info": {
        "commit_hash": "179b93d625f7f7f597329d2ffb322c19da5d7958",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/179b93d625f7f7f597329d2ffb322c19da5d7958",
        "files": [
          "src/lib/protocols/openvpn.c"
        ],
        "message": "Better UDP flow handling",
        "before_after_code_files": [
          "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
          ],
          "candidate": [
            "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c": [
          "File: src/lib/protocols/openvpn.c -> src/lib/protocols/openvpn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "90:     if(packet->udp) {",
          "91: #ifdef DEBUG",
          "93:       htons(packet->udp->source), htons(packet->udp->dest), packet->payload_packet_len);",
          "94: #endif",
          "96:       if(",
          "101:  NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
          "104:       }",
          "105:     }",
          "",
          "[Removed Lines]",
          "92:       printf(\"[opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\", opcode, check_pkid_and_detect_hmac_size(ovpn_payload),",
          "97:   ((packet->payload_packet_len == 112) && (opcode == 168))",
          "98:   || ((packet->payload_packet_len == 80)",
          "99:       && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168)))",
          "100:   ) {",
          "102:    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
          "103:    return;",
          "",
          "[Added Lines]",
          "92:       printf(\"[packet_id: %u][opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\",",
          "93:       flow->num_processed_pkts,",
          "94:       opcode, check_pkid_and_detect_hmac_size(ovpn_payload),",
          "99:   (flow->num_processed_pkts == 1)",
          "100:   && (",
          "101:       ((packet->payload_packet_len == 112)",
          "102:        && ((opcode == 168) || (opcode == 192))",
          "103:        )",
          "104:       || ((packet->payload_packet_len == 80)",
          "105:    && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168) || (opcode == 200)))",
          "106:       )) {",
          "108:  ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
          "109:  return;",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "b66606bc16f785ad20c8bf301d05373fabd2daf3",
      "candidate_info": {
        "commit_hash": "b66606bc16f785ad20c8bf301d05373fabd2daf3",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/b66606bc16f785ad20c8bf301d05373fabd2daf3",
        "files": [
          "src/lib/protocols/openvpn.c"
        ],
        "message": "Improved OpenVPN support for UDP-based VPNs",
        "before_after_code_files": [
          "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
          ],
          "candidate": [
            "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c": [
          "File: src/lib/protocols/openvpn.c -> src/lib/protocols/openvpn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "40: #define P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)  (P_HARD_RESET_PACKET_ID_OFFSET(hmac_size) + 8)",
          "41: #define P_HARD_RESET_CLIENT_MAX_COUNT  5",
          "43: static",
          "44: #ifndef WIN32",
          "45: inline",
          "46: #endif",
          "47: u_int32_t get_packet_id(const u_int8_t * payload, u_int8_t hms) {",
          "49: }",
          "51: static",
          "",
          "[Removed Lines]",
          "48:   return ntohl(*(u_int32_t*)(payload + P_HARD_RESET_PACKET_ID_OFFSET(hms)));",
          "",
          "[Added Lines]",
          "43: static void ndpi_int_openvpn_add_connection(struct ndpi_detection_module_struct",
          "45:   NDPI_LOG_INFO(ndpi_struct, \"found memcached\\n\");",
          "46:   ndpi_set_detected_protocol(ndpi_struct, flow,",
          "47:         NDPI_PROTOCOL_MEMCACHED, NDPI_PROTOCOL_UNKNOWN);",
          "48: }",
          "55:   return(ntohl(*(u_int32_t*)(payload + P_HARD_RESET_PACKET_ID_OFFSET(hms))));",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "54: #endif",
          "55: int8_t check_pkid_and_detect_hmac_size(const u_int8_t * payload) {",
          "58:     return P_HMAC_160;",
          "60:     return P_HMAC_128;",
          "62: }",
          "64: void ndpi_search_openvpn(struct ndpi_detection_module_struct* ndpi_struct,",
          "",
          "[Removed Lines]",
          "57:   if (get_packet_id(payload, P_HMAC_160) == 1)",
          "59:   if (get_packet_id(payload, P_HMAC_128) == 1)",
          "61:   return -1;",
          "",
          "[Added Lines]",
          "64:   if(get_packet_id(payload, P_HMAC_160) == 1)",
          "67:   if(get_packet_id(payload, P_HMAC_128) == 1)",
          "70:   return(-1);",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "71:   int8_t hmac_size;",
          "72:   int8_t failed = 0;",
          "77:       ovpn_payload += 2;",
          "79:     opcode = ovpn_payload[0] & P_OPCODE_MASK;",
          "82:         opcode == P_CONTROL_HARD_RESET_CLIENT_V2)) {",
          "85:         memcpy(flow->ovpn_session_id, ovpn_payload+1, 8);",
          "87:         NDPI_LOG_DBG2(ndpi_struct,",
          "",
          "[Removed Lines]",
          "74:   if (packet->payload_packet_len >= 40) {",
          "76:     if (packet->tcp != NULL)",
          "81:     if (flow->ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && (opcode == P_CONTROL_HARD_RESET_CLIENT_V1 ||",
          "84:       if (check_pkid_and_detect_hmac_size(ovpn_payload) > 0) {",
          "",
          "[Added Lines]",
          "83:   if(packet->payload_packet_len >= 40) {",
          "85:     if(packet->tcp != NULL)",
          "90:     if(packet->udp) {",
          "91: #ifdef DEBUG",
          "92:       printf(\"[opcode: %u][Packet ID: %d][%u <-> %u][len: %u]\\n\", opcode, check_pkid_and_detect_hmac_size(ovpn_payload),",
          "93:       htons(packet->udp->source), htons(packet->udp->dest), packet->payload_packet_len);",
          "94: #endif",
          "96:       if(",
          "97:   ((packet->payload_packet_len == 112) && (opcode == 168))",
          "98:   || ((packet->payload_packet_len == 80)",
          "99:       && ((opcode == 184) || (opcode == 88) || (opcode == 160) || (opcode == 168)))",
          "100:   ) {",
          "101:  NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
          "102:    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
          "103:    return;",
          "104:       }",
          "105:     }",
          "107:     if(flow->ovpn_counter < P_HARD_RESET_CLIENT_MAX_COUNT && (opcode == P_CONTROL_HARD_RESET_CLIENT_V1 ||",
          "109:       if(check_pkid_and_detect_hmac_size(ovpn_payload) > 0) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "89:    flow->ovpn_session_id[0], flow->ovpn_session_id[1], flow->ovpn_session_id[2], flow->ovpn_session_id[3],",
          "90:    flow->ovpn_session_id[4], flow->ovpn_session_id[5], flow->ovpn_session_id[6], flow->ovpn_session_id[7]);",
          "91:       }",
          "93:             (opcode == P_CONTROL_HARD_RESET_SERVER_V1 || opcode == P_CONTROL_HARD_RESET_SERVER_V2)) {",
          "95:       hmac_size = check_pkid_and_detect_hmac_size(ovpn_payload);",
          "98:         alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];",
          "99:         session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;",
          "106:           NDPI_LOG_DBG2(ndpi_struct,",
          "107:      \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",",
          "108:      session_remote[0], session_remote[1], session_remote[2], session_remote[3],",
          "",
          "[Removed Lines]",
          "92:     } else if (flow->ovpn_counter >= 1 && flow->ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT &&",
          "97:       if (hmac_size > 0) {",
          "101:         if (memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {",
          "102:   NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
          "103:            ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
          "104:    }",
          "105:         else {",
          "",
          "[Added Lines]",
          "117:     } else if(flow->ovpn_counter >= 1 && flow->ovpn_counter <= P_HARD_RESET_CLIENT_MAX_COUNT &&",
          "122:       if(hmac_size > 0) {",
          "126:         if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {",
          "127:    NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
          "128:    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
          "129:    return;",
          "130:  } else {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "117:     flow->ovpn_counter++;",
          "120:       NDPI_EXCLUDE_PROTO(ndpi_struct, flow);",
          "121:     }",
          "122:   }",
          "123: }",
          "127:   ndpi_set_bitmask_protocol_detection(\"OpenVPN\", ndpi_struct, detection_bitmask, *id,",
          "128:           NDPI_PROTOCOL_OPENVPN,",
          "129:           ndpi_search_openvpn,",
          "",
          "[Removed Lines]",
          "119:     if (failed) {",
          "125: void init_openvpn_dissector(struct ndpi_detection_module_struct *ndpi_struct, u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask)",
          "126: {",
          "",
          "[Added Lines]",
          "144:     if(failed) {",
          "150: void init_openvpn_dissector(struct ndpi_detection_module_struct *ndpi_struct,",
          "151:        u_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "498571354d2c22c192bb80bc79058b70d455b363",
      "candidate_info": {
        "commit_hash": "498571354d2c22c192bb80bc79058b70d455b363",
        "repo": "ntop/nDPI",
        "commit_url": "https://github.com/ntop/nDPI/commit/498571354d2c22c192bb80bc79058b70d455b363",
        "files": [
          "src/lib/protocols/openvpn.c"
        ],
        "message": "openvpn: fix heap-overflow error",
        "before_after_code_files": [
          "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
          ],
          "candidate": [
            "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c"
          ]
        }
      },
      "candidate_diff": {
        "src/lib/protocols/openvpn.c||src/lib/protocols/openvpn.c": [
          "File: src/lib/protocols/openvpn.c -> src/lib/protocols/openvpn.c",
          "--- Hunk 1 ---",
          "[Context before]",
          "121:       if(hmac_size > 0) {",
          "122:         alen = ovpn_payload[P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size)];",
          "131:      \"key mismatch: %02x%02x%02x%02x%02x%02x%02x%02x\\n\",",
          "132:      session_remote[0], session_remote[1], session_remote[2], session_remote[3],",
          "133:      session_remote[4], session_remote[5], session_remote[6], session_remote[7]);",
          "134:           failed = 1;",
          "136:       } else",
          "137:         failed = 1;",
          "138:     } else",
          "",
          "[Removed Lines]",
          "123:         session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;",
          "125:         if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {",
          "126:    NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
          "127:    ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
          "128:    return;",
          "129:  } else {",
          "130:           NDPI_LOG_DBG2(ndpi_struct,",
          "135:         }",
          "",
          "[Added Lines]",
          "123:         if (alen > 0) {",
          "124:    session_remote = ovpn_payload + P_PACKET_ID_ARRAY_LEN_OFFSET(hmac_size) + 1 + alen * 4;",
          "126:           if(memcmp(flow->ovpn_session_id, session_remote, 8) == 0) {",
          "127:      NDPI_LOG_INFO(ndpi_struct,\"found openvpn\\n\");",
          "128:      ndpi_set_detected_protocol(ndpi_struct, flow, NDPI_PROTOCOL_OPENVPN, NDPI_PROTOCOL_UNKNOWN);",
          "129:      return;",
          "130:    } else {",
          "131:             NDPI_LOG_DBG2(ndpi_struct,",
          "135:             failed = 1;",
          "136:           }",
          "137:         } else",
          "",
          "---------------"
        ]
      }
    }
  ]
}
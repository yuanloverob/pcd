{
  "cve_id": "CVE-2024-53263",
  "cve_desc": "Git LFS is a Git extension for versioning large files. When Git LFS requests credentials from Git for a remote host, it passes portions of the host's URL to the `git-credential(1)` command without checking for embedded line-ending control characters, and then sends any credentials it receives back from the Git credential helper to the remote host. By inserting URL-encoded control characters such as line feed (LF) or carriage return (CR) characters into the URL, an attacker may be able to retrieve a user's Git credentials. This problem exists in all previous versions and is patched in v3.6.1. All users should upgrade to v3.6.1. There are no workarounds known at this time.",
  "repo": "git-lfs/git-lfs",
  "patch_hash": "0345b6f816e611d050c0df67b61f0022916a1c90",
  "patch_info": {
    "commit_hash": "0345b6f816e611d050c0df67b61f0022916a1c90",
    "repo": "git-lfs/git-lfs",
    "commit_url": "https://github.com/git-lfs/git-lfs/commit/0345b6f816e611d050c0df67b61f0022916a1c90",
    "files": [
      "creds/creds.go",
      "creds/creds_test.go",
      "t/t-credentials-protect.sh"
    ],
    "message": "creds/creds.go: reject LF bytes in credential data\n\nAs reported in CVE-2024-53263, when Git LFS writes credential request\nkeys and values to a Git credential helper via the git-credential(1)\ncommand, it does not remove any line feed (LF) control characters\nincluded in the values, which may allow a malicious server to insert\nspurious keys and values into the credential request.\n\nBecause the \"git credential fill\" command receives these values as its\ninput, it is not able to disambiguate the line feed characters we add\nat the end of each input line from those which are the result of\ndecoding URL-encoded characters.\n\nWhen Git processes a URL and passes values from that URL to a credential\nhelper, any line feed characters which have been decoded are detected by\na check in the credential_write_item() function of the credential.c\nsource file and cause Git to exit with an error.  This check was added\nin commit git/git@9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b and released\nin Git version 2.17.4 (and other patch releases) to address the\nvulnerability reported in CVE-2020-5260:\n\n  https://github.com/git/git/blob/v2.47.1/credential.c#L391-L392\n\nGiven that the Git security issue in CVE-2020-5260 has the same cause\nand effect as the one reported for Git LFS in CVE-2024-53263, we adopt\nthe same approach as Git to resolve the latter issue now.  To do this\nwe revise the buffer() method of the Creds structure in our \"creds\"\npackage (which we refactored from a bufferCreds() function in a prior\ncommit in this PR) so it returns an error if any of the values it\nprocesses have an embedded line feed character.  We then alter the sole\ncaller of this method, the exec() method of our commandCredentialHelper\nstructure in the same package, to detect and return any error from the\nbuffer() method.\n\nTo verify these changes we add a TestCredsBufferProtect() test function,\nwhich checks that the buffer() method returns an error when one of the\nvalues it is given contains a line feed character.\n\nWe also create a new t/t-credentials-protect.sh test script with one\ninitial test named \"credentials rejected with line feed\".  This test\nconfirms that an error is reported and no Git LFS object is pushed if a\nvalue which would be passed to a \"git credential fill\" command contains\na bare line feed character decoded from a URL-encoded line feed character\nfound in a URL.\n\nWe use the \"localhost\" hostname in this URL rather than the 127.0.0.1\naddress on which our lfstest-gitserver utility listens for requests\nbecause otherwise Git LFS will detect that the scheme and the host\nsubcomponent of the URL for the Git LFS API match those of the URL of\nthe current Git remote, and will then use the Git remote's URL when\nquerying for credentials.  As that URL does not contain a URL-encoded\nline feed character, our test would not achieve its purpose, so we\ninstead use the \"localhost\" alias in the test's Git LFS configuration.\n\nAs this test makes use of the \"localhost\" hostname, we provide a\ncredential record file associated with that hostname for our\ngit-credential-lfstest helper to find and use.  To establish this file\nwe copy the record file associated with the 127.0.0.1 address, as\nthat file has already been created by the setup_creds() function from\nour t/testhelpers.sh library.\n\nThis test does not actually depend on the existence of a credential\nrecord file for the \"localhost\" hostname, as we expect the credential\nhelper to never be consulted due to the presence of a line feed character\nin the values that would be sent to it.  However, we expect to add\nanother test to our new test script in a subsequent commit in this PR,\nand that test will depend on the credential helper finding a record file\nfor the \"localhost\" hostname.\n\nThe presence of the record file also ensures that if in the future a\nregression should be introduced such that values containing a bare\nline feed character are passed to the credential helper, our test would\nnot continue to pass.  If we did not establish a record file, and a\nregression caused the bare line feed character to be ignored, the\n\"git lfs push\" command would still fail because it would not find\ncredentials for the \"localhost\" hostname, and so no object would be\npushed, as the test expects, and thus the test would continue to pass.\n\nInstead, in the case of a regression we want the \"git lfs push\" command\nto succeed, and then the subsequent call to the refute_server_object()\nfunction to fail and cause the test to fail.  We therefore create a\nvalid credential record file even though it is not used at present.\n\nSome of the tests in the existing t/t-credentials.sh test script depend\non a credential record file for the \"localhost\" hostname not existing,\nthough, which is why we define our new test in a new, separate test\nscript.  We can then set a unique path for the CREDSDIR environment\nvariable in that script, which guarantees that any modifications the\nscript makes to the set of credential record files do not affect any\nother script's tests.\n\nReported-by: RyotaK from Flatt Security Inc.",
    "before_after_code_files": [
      "creds/creds.go||creds/creds.go",
      "creds/creds_test.go||creds/creds_test.go",
      "t/t-credentials-protect.sh||t/t-credentials-protect.sh"
    ]
  },
  "patch_diff": {
    "creds/creds.go||creds/creds.go": [
      "File: creds/creds.go -> creds/creds.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "58:  return slices.Contains([]string{\"1\", \"true\"}, FirstEntryForKey(c, \"continue\"))",
      "59: }",
      "62:  buf := new(bytes.Buffer)",
      "64:  buf.Write([]byte(\"capability[]=authtype\\n\"))",
      "65:  buf.Write([]byte(\"capability[]=state\\n\"))",
      "66:  for k, v := range c {",
      "67:   for _, item := range v {",
      "68:    buf.Write([]byte(k))",
      "69:    buf.Write([]byte(\"=\"))",
      "70:    buf.Write([]byte(item))",
      "",
      "[Removed Lines]",
      "61: func (c Creds) buffer() *bytes.Buffer {",
      "",
      "[Added Lines]",
      "61: func (c Creds) buffer() (*bytes.Buffer, error) {",
      "68:    if strings.Contains(item, \"\\n\") {",
      "69:     return nil, errors.Errorf(tr.Tr.Get(\"credential value for %s contains newline: %q\", k, item))",
      "70:    }",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "72:   }",
      "73:  }",
      "76: }",
      "78: type CredentialHelperContext struct {",
      "",
      "[Removed Lines]",
      "75:  return buf",
      "",
      "[Added Lines]",
      "79:  return buf, nil",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "338:  if err != nil {",
      "339:   return nil, errors.New(tr.Tr.Get(\"failed to find `git credential %s`: %v\", subcommand, err))",
      "340:  }",
      "342:  cmd.Stdout = output",
      "344:     There is a reason we don't read from stderr here:",
      "",
      "[Removed Lines]",
      "341:  cmd.Stdin = input.buffer()",
      "",
      "[Added Lines]",
      "345:  cmd.Stdin, err = input.buffer()",
      "346:  if err != nil {",
      "347:   return nil, errors.New(tr.Tr.Get(\"invalid input to `git credential %s`: %v\", subcommand, err))",
      "348:  }",
      "",
      "---------------"
    ],
    "creds/creds_test.go||creds/creds_test.go": [
      "File: creds/creds_test.go -> creds/creds_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "26:  expected := []string{\"capability[]=authtype\\n\", \"capability[]=state\\n\"}",
      "29:  assertCredsLinesMatch(t, expected, buf)",
      "31:  creds[\"protocol\"] = []string{\"https\"}",
      "",
      "[Removed Lines]",
      "28:  buf := creds.buffer()",
      "",
      "[Added Lines]",
      "28:  buf, err := creds.buffer()",
      "29:  assert.NoError(t, err)",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "34:  expectedPrefix := strings.Join(expected, \"\")",
      "35:  expected = append(expected, \"protocol=https\\n\", \"host=example.com\\n\")",
      "38:  assert.True(t, strings.HasPrefix(buf.String(), expectedPrefix))",
      "39:  assertCredsLinesMatch(t, expected, buf)",
      "",
      "[Removed Lines]",
      "37:  buf = creds.buffer()",
      "",
      "[Added Lines]",
      "38:  buf, err = creds.buffer()",
      "39:  assert.NoError(t, err)",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "43:  expected = append(expected, \"wwwauth[]=Basic realm=test\\n\")",
      "44:  expected = append(expected, \"wwwauth[]=Negotiate\\n\")",
      "47:  assert.True(t, strings.HasPrefix(buf.String(), expectedPrefix))",
      "48:  assertCredsLinesMatch(t, expected, buf)",
      "49: }",
      "51: type testCredHelper struct {",
      "52:  fillErr    error",
      "53:  approveErr error",
      "",
      "[Removed Lines]",
      "46:  buf = creds.buffer()",
      "",
      "[Added Lines]",
      "48:  buf, err = creds.buffer()",
      "49:  assert.NoError(t, err)",
      "54: func TestCredsBufferProtect(t *testing.T) {",
      "55:  creds := make(Creds)",
      "58:  creds[\"protocol\"] = []string{\"https\"}",
      "59:  creds[\"host\"] = []string{\"one.example.com\\nhost=two.example.com\"}",
      "61:  buf, err := creds.buffer()",
      "62:  assert.Error(t, err)",
      "63:  assert.Nil(t, buf)",
      "64: }",
      "",
      "---------------"
    ],
    "t/t-credentials-protect.sh||t/t-credentials-protect.sh": [
      "File: t/t-credentials-protect.sh -> t/t-credentials-protect.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "[No context available]",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "1: #!/usr/bin/env bash",
      "3: . \"$(dirname \"$0\")/testlib.sh\"",
      "5: ensure_git_version_isnt $VERSION_LOWER \"2.3.0\"",
      "7: export CREDSDIR=\"$REMOTEDIR/creds-credentials-protect\"",
      "8: setup_creds",
      "10: # Copy the default record file for the test credential helper to match the",
      "11: # hostname used in the Git LFS configurations of the tests.",
      "12: cp \"$CREDSDIR/127.0.0.1\" \"$CREDSDIR/localhost\"",
      "14: begin_test \"credentials rejected with line feed\"",
      "15: (",
      "16:   set -e",
      "18:   reponame=\"protect-linefeed\"",
      "19:   setup_remote_repo \"$reponame\"",
      "20:   clone_repo \"$reponame\" \"$reponame\"",
      "22:   contents=\"a\"",
      "23:   contents_oid=$(calc_oid \"$contents\")",
      "25:   git lfs track \"*.dat\"",
      "26:   printf \"%s\" \"$contents\" >a.dat",
      "27:   git add .gitattributes a.dat",
      "28:   git commit -m \"add a.dat\"",
      "30:   # Using localhost instead of 127.0.0.1 in the LFS API URL ensures this URL",
      "31:   # is used when filling credentials rather than the Git remote URL, which",
      "32:   # would otherwise be used since it would have the same scheme and hostname.",
      "33:   gitserver=\"$(echo \"$GITSERVER\" | sed 's/127\\.0\\.0\\.1/localhost/')\"",
      "34:   testreponame=\"test%0a$reponame\"",
      "35:   git config lfs.url \"$gitserver/$testreponame.git/info/lfs\"",
      "37:   GIT_TRACE=1 git lfs push origin main 2>&1 | tee push.log",
      "38:   if [ \"0\" -eq \"${PIPESTATUS[0]}\" ]; then",
      "39:     echo >&2 \"fatal: expected 'git lfs push' to fail ...\"",
      "40:     exit 1",
      "41:   fi",
      "42:   grep \"batch response: Git credentials for $gitserver.* not found\" push.log",
      "43:   grep \"credential value for path contains newline\" push.log",
      "44:   refute_server_object \"$testreponame\" \"$contents_oid\"",
      "45: )",
      "46: end_test",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "f6904cc1228c063be75cc77de83fd9331b6d9b92",
      "candidate_info": {
        "commit_hash": "f6904cc1228c063be75cc77de83fd9331b6d9b92",
        "repo": "git-lfs/git-lfs",
        "commit_url": "https://github.com/git-lfs/git-lfs/commit/f6904cc1228c063be75cc77de83fd9331b6d9b92",
        "files": [
          "creds/creds.go",
          "creds/creds_test.go"
        ],
        "message": "creds/creds.go: convert bufferCreds() into method\n\nThe Creds structure in our \"creds\" package was first introduced in\ncommit e8de7a3b82f65cf0a53b4705d2fcd90305d87395, where it was part of\na different package in an early pre-alpha version of the Git LFS client.\nA single method was defined for the structure in that commit, the\nBuffer() method, which formatted lines of key/value pairs to be sent\nto the git-credential(1) command.\n\nIn commit 3a271b1aa4eea994fc411cd65a71f461bbe4e671 of PR #1839 this\nmethod was converted into the current bufferCreds() function, a change\nmade to avoid exporting the method out of the \"lfsapi\" package, where\nthe structure was defined at that time.\n\nWe next moved the Creds structure (which was then a simple map of\nstrings to strings) and its one function into the current \"creds\"\npackage in commit c752dcdf51b8752626f79abb43c6287ce5451ac6 of PR #3270.\nLater, in commits 5d5f90e286b1fbae6b6894463a1017d055d840ec of PR #5381\nand 67830784dbdc54c7fddf926653c18c4097124a8f of PR #5803 we revised the\nCreds structure so its map contains arrays of strings, and added the\nIsMultistage() method, so we again have a single method defined for\nthis structure.\n\nIn subsequent commits in this PR we will refactor the bufferCreds()\nfunction to accept and return additional values.  As a first step, in\norder to keep our code as consistent as possible, we convert it back into\na method, as it was originally defined, except with the lowercase name of\nbuffer() so it is not exported outside of the \"creds\" package.  This\nretains the intent of commit 3a271b1aa4eea994fc411cd65a71f461bbe4e671\nfrom PR #1839, but uses a naming pattern that is more idiomatic for the\nGo language.\n\nAs well, we add a test function named TestCredsBufferFormat() to the\naccompanying creds/creds_test.go source file.  This test function simply\nverifies the behaviour of the former bufferCreds() function that we have\nnow renamed to the buffer() method.  To permit comparison of the contents\nof the method's output buffer with the lines of key/value pairs expected\nby the test function, we also add an assertCredsLinesMatch() helper\nfunction which splits and sorts the lines in the buffer and compares\nthem with the sorted set of expected output lines.",
        "before_after_code_files": [
          "creds/creds.go||creds/creds.go",
          "creds/creds_test.go||creds/creds_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "creds/creds.go||creds/creds.go",
            "creds/creds_test.go||creds/creds_test.go"
          ],
          "candidate": [
            "creds/creds.go||creds/creds.go",
            "creds/creds_test.go||creds/creds_test.go"
          ]
        }
      },
      "candidate_diff": {
        "creds/creds.go||creds/creds.go": [
          "File: creds/creds.go -> creds/creds.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:  return slices.Contains([]string{\"1\", \"true\"}, FirstEntryForKey(c, \"continue\"))",
          "59: }",
          "62:  buf := new(bytes.Buffer)",
          "64:  buf.Write([]byte(\"capability[]=authtype\\n\"))",
          "",
          "[Removed Lines]",
          "61: func bufferCreds(c Creds) *bytes.Buffer {",
          "",
          "[Added Lines]",
          "61: func (c Creds) buffer() *bytes.Buffer {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "338:  if err != nil {",
          "339:   return nil, errors.New(tr.Tr.Get(\"failed to find `git credential %s`: %v\", subcommand, err))",
          "340:  }",
          "342:  cmd.Stdout = output",
          "344:     There is a reason we don't read from stderr here:",
          "",
          "[Removed Lines]",
          "341:  cmd.Stdin = bufferCreds(input)",
          "",
          "[Added Lines]",
          "341:  cmd.Stdin = input.buffer()",
          "",
          "---------------"
        ],
        "creds/creds_test.go||creds/creds_test.go": [
          "File: creds/creds_test.go -> creds/creds_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: package creds",
          "3: import (",
          "4:  \"errors\"",
          "5:  \"testing\"",
          "7:  \"github.com/stretchr/testify/assert\"",
          "8: )",
          "10: type testCredHelper struct {",
          "11:  fillErr    error",
          "12:  approveErr error",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "4:  \"bytes\"",
          "6:  \"slices\"",
          "7:  \"strings\"",
          "13: func assertCredsLinesMatch(t *testing.T, expected []string, buf *bytes.Buffer) {",
          "14:  expected = append(expected, \"\")",
          "15:  actual := strings.SplitAfter(buf.String(), \"\\n\")",
          "17:  slices.Sort(expected)",
          "18:  slices.Sort(actual)",
          "20:  assert.Equal(t, expected, actual)",
          "21: }",
          "23: func TestCredsBufferFormat(t *testing.T) {",
          "24:  creds := make(Creds)",
          "26:  expected := []string{\"capability[]=authtype\\n\", \"capability[]=state\\n\"}",
          "28:  buf := creds.buffer()",
          "29:  assertCredsLinesMatch(t, expected, buf)",
          "31:  creds[\"protocol\"] = []string{\"https\"}",
          "32:  creds[\"host\"] = []string{\"example.com\"}",
          "34:  expectedPrefix := strings.Join(expected, \"\")",
          "35:  expected = append(expected, \"protocol=https\\n\", \"host=example.com\\n\")",
          "37:  buf = creds.buffer()",
          "38:  assert.True(t, strings.HasPrefix(buf.String(), expectedPrefix))",
          "39:  assertCredsLinesMatch(t, expected, buf)",
          "41:  creds[\"wwwauth[]\"] = []string{\"Basic realm=test\", \"Negotiate\"}",
          "43:  expected = append(expected, \"wwwauth[]=Basic realm=test\\n\")",
          "44:  expected = append(expected, \"wwwauth[]=Negotiate\\n\")",
          "46:  buf = creds.buffer()",
          "47:  assert.True(t, strings.HasPrefix(buf.String(), expectedPrefix))",
          "48:  assertCredsLinesMatch(t, expected, buf)",
          "49: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a06ae195185ebc0fb00f3e4eef5a138d17338773",
      "candidate_info": {
        "commit_hash": "a06ae195185ebc0fb00f3e4eef5a138d17338773",
        "repo": "git-lfs/git-lfs",
        "commit_url": "https://github.com/git-lfs/git-lfs/commit/a06ae195185ebc0fb00f3e4eef5a138d17338773",
        "files": [
          "commands/command_dedup.go",
          "commands/command_migrate.go",
          "commands/command_migrate_export.go",
          "commands/command_migrate_import.go",
          "commands/command_migrate_info.go",
          "commands/command_smudge.go",
          "creds/creds.go",
          "errors/types.go",
          "git/githistory/rewriter_test.go",
          "lfs/diff_index_scanner.go",
          "lfshttp/standalone/standalone.go",
          "ssh/connection.go",
          "tq/basic_download.go",
          "tq/basic_upload.go",
          "tq/custom.go",
          "tq/ssh.go",
          "tq/transfer_queue.go",
          "tq/tus_upload.go"
        ],
        "message": "avoid new error format strings without arguments\n\nWhen we report an error, we often call the Errorf() function in our\ncustom \"errors\" package, which accepts both a format string and a\nvariable number of additional arguments.  The intent of this function\nis for the additional arguments to be interpolated into the format\nstring, and then an error created using the string which results from\nthe interpolation.\n\nIn many instances we originally made use of the interpolation capability\nof the Errorf() function by passing at least one additional argument to\nit other than the format string.  In other cases, though, we used the\nErrorf() function with just a single fixed string argument, so the\nthe New() function of the same \"errors\" package would have sufficed\ninstead.\n\nIn PR #4781 we then updated our code to allow for localization of most\nof our output messages by inserting calls to the Get() method of the Tr\nstructure of our \"tr\" package.  In the instances where we call the\nErrorf() function, the consequence is that we now pass the format string\nand any additional arguments to the Get() method, and then just pass\nthe string it returns to the Errorf() function as a single argument.\n\nAs of Go 1.24, if the Go version number in the \"go.mod\" file is set to\n1.24 or higher, the \"go vet\" command now reports misuses of non-constant\nstrings as format strings.  This includes all the cases where we pass\nthe output from the Get() method of the Tr structure to an Errorf()\nfunction as a single argument.  To resolve this concern, we revise\nall such instances to use the New() function of our \"errors\" package\nin place of the Errorf() function.",
        "before_after_code_files": [
          "commands/command_dedup.go||commands/command_dedup.go",
          "commands/command_migrate.go||commands/command_migrate.go",
          "commands/command_migrate_export.go||commands/command_migrate_export.go",
          "commands/command_migrate_import.go||commands/command_migrate_import.go",
          "commands/command_migrate_info.go||commands/command_migrate_info.go",
          "commands/command_smudge.go||commands/command_smudge.go",
          "creds/creds.go||creds/creds.go",
          "errors/types.go||errors/types.go",
          "git/githistory/rewriter_test.go||git/githistory/rewriter_test.go",
          "lfs/diff_index_scanner.go||lfs/diff_index_scanner.go",
          "lfshttp/standalone/standalone.go||lfshttp/standalone/standalone.go",
          "ssh/connection.go||ssh/connection.go",
          "tq/basic_download.go||tq/basic_download.go",
          "tq/basic_upload.go||tq/basic_upload.go",
          "tq/custom.go||tq/custom.go",
          "tq/ssh.go||tq/ssh.go",
          "tq/transfer_queue.go||tq/transfer_queue.go",
          "tq/tus_upload.go||tq/tus_upload.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "creds/creds.go||creds/creds.go"
          ],
          "candidate": [
            "creds/creds.go||creds/creds.go"
          ]
        }
      },
      "candidate_diff": {
        "commands/command_dedup.go||commands/command_dedup.go": [
          "File: commands/command_dedup.go -> commands/command_dedup.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "129:  if ok, err := tools.CloneFileByPath(dstFile, srcFile); err != nil {",
          "130:   return false, err",
          "131:  } else if !ok {",
          "133:  }",
          "",
          "[Removed Lines]",
          "132:   return false, errors.Errorf(tr.Tr.Get(\"unknown clone file error\"))",
          "",
          "[Added Lines]",
          "132:   return false, errors.New(tr.Tr.Get(\"unknown clone file error\"))",
          "",
          "---------------"
        ],
        "commands/command_migrate.go||commands/command_migrate.go": [
          "File: commands/command_migrate.go -> commands/command_migrate.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "319:  if current.Type == git.RefTypeOther ||",
          "320:   current.Type == git.RefTypeRemoteBranch {",
          "323:  }",
          "324:  return current, nil",
          "325: }",
          "",
          "[Removed Lines]",
          "322:   return nil, errors.Errorf(tr.Tr.Get(\"Cannot migrate non-local ref: %s\", current.Name))",
          "",
          "[Added Lines]",
          "322:   return nil, errors.New(tr.Tr.Get(\"Cannot migrate non-local ref: %s\", current.Name))",
          "",
          "---------------"
        ],
        "commands/command_migrate_export.go||commands/command_migrate_export.go": [
          "File: commands/command_migrate_export.go -> commands/command_migrate_export.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "36:  filter := rewriter.Filter()",
          "37:  if len(filter.Include()) <= 0 {",
          "39:  }",
          "41:  tracked := trackedFromExportFilter(filter)",
          "",
          "[Removed Lines]",
          "38:   ExitWithError(errors.Errorf(tr.Tr.Get(\"One or more files must be specified with --include\")))",
          "",
          "[Added Lines]",
          "38:   ExitWithError(errors.New(tr.Tr.Get(\"One or more files must be specified with --include\")))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116:  }",
          "117:  remoteURL := getAPIClient().Endpoints.RemoteEndpoint(\"download\", remote).Url",
          "118:  if remoteURL == \"\" && cmd.Flag(\"remote\").Changed {",
          "120:  }",
          "",
          "[Removed Lines]",
          "119:   ExitWithError(errors.Errorf(tr.Tr.Get(\"Invalid remote %s provided\", remote)))",
          "",
          "[Added Lines]",
          "119:   ExitWithError(errors.New(tr.Tr.Get(\"Invalid remote %s provided\", remote)))",
          "",
          "---------------"
        ],
        "commands/command_migrate_import.go||commands/command_migrate_import.go": [
          "File: commands/command_migrate_import.go -> commands/command_migrate_import.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "45:  if migrateNoRewrite {",
          "46:   if migrateFixup {",
          "48:   }",
          "50:   if len(args) == 0 {",
          "52:   }",
          "54:   ref, err := git.CurrentRef()",
          "",
          "[Removed Lines]",
          "47:    ExitWithError(errors.Errorf(tr.Tr.Get(\"--no-rewrite and --fixup cannot be combined\")))",
          "51:    ExitWithError(errors.Errorf(tr.Tr.Get(\"Expected one or more files with --no-rewrite\")))",
          "",
          "[Added Lines]",
          "47:    ExitWithError(errors.New(tr.Tr.Get(\"--no-rewrite and --fixup cannot be combined\")))",
          "51:    ExitWithError(errors.New(tr.Tr.Get(\"Expected one or more files with --no-rewrite\")))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "67:   filter := git.GetAttributeFilter(cfg.LocalWorkingDir(), cfg.LocalGitDir())",
          "68:   if len(filter.Include()) == 0 {",
          "70:   }",
          "72:   gf := lfs.NewGitFilter(cfg)",
          "74:   for _, file := range args {",
          "75:    if !filter.Allows(file) {",
          "77:    }",
          "78:   }",
          "",
          "[Removed Lines]",
          "69:    ExitWithError(errors.Errorf(tr.Tr.Get(\"No Git LFS filters found in '.gitattributes'\")))",
          "76:     ExitWithError(errors.Errorf(tr.Tr.Get(\"File %s did not match any Git LFS filters in '.gitattributes'\", file)))",
          "",
          "[Added Lines]",
          "69:    ExitWithError(errors.New(tr.Tr.Get(\"No Git LFS filters found in '.gitattributes'\")))",
          "76:     ExitWithError(errors.New(tr.Tr.Get(\"File %s did not match any Git LFS filters in '.gitattributes'\", file)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "124:  if migrateFixup {",
          "125:   include, exclude := getIncludeExcludeArgs(cmd)",
          "126:   if include != nil || exclude != nil {",
          "128:   }",
          "129:  }",
          "",
          "[Removed Lines]",
          "127:    ExitWithError(errors.Errorf(tr.Tr.Get(\"Cannot use --fixup with --include, --exclude\")))",
          "",
          "[Added Lines]",
          "127:    ExitWithError(errors.New(tr.Tr.Get(\"Cannot use --fixup with --include, --exclude\")))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "142:  if above > 0 {",
          "143:   include, exclude := getIncludeExcludeArgs(cmd)",
          "144:   if include != nil || exclude != nil || migrateFixup {",
          "146:   }",
          "147:  }",
          "",
          "[Removed Lines]",
          "145:    ExitWithError(errors.Errorf(tr.Tr.Get(\"Cannot use --above with --include, --exclude, --fixup\")))",
          "",
          "[Added Lines]",
          "145:    ExitWithError(errors.New(tr.Tr.Get(\"Cannot use --above with --include, --exclude, --fixup\")))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "396:   index := findEntry(tree, splits[0])",
          "397:   if index < 0 {",
          "399:   }",
          "401:   blobEntry := tree.Entries[index]",
          "",
          "[Removed Lines]",
          "398:    return nil, errors.Errorf(tr.Tr.Get(\"unable to find entry %s in tree\", splits[0]))",
          "",
          "[Added Lines]",
          "398:    return nil, errors.New(tr.Tr.Get(\"unable to find entry %s in tree\", splits[0]))",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "434:   index := findEntry(tree, head)",
          "435:   if index < 0 {",
          "437:   }",
          "439:   subtreeEntry := tree.Entries[index]",
          "",
          "[Removed Lines]",
          "436:    return nil, errors.Errorf(tr.Tr.Get(\"unable to find entry %s in tree\", head))",
          "",
          "[Added Lines]",
          "436:    return nil, errors.New(tr.Tr.Get(\"unable to find entry %s in tree\", head))",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "455:   return db.WriteTree(tree)",
          "457:  default:",
          "459:  }",
          "460: }",
          "",
          "[Removed Lines]",
          "458:   return nil, errors.Errorf(tr.Tr.Get(\"error parsing path %s\", path))",
          "",
          "[Added Lines]",
          "458:   return nil, errors.New(tr.Tr.Get(\"error parsing path %s\", path))",
          "",
          "---------------"
        ],
        "commands/command_migrate_info.go||commands/command_migrate_info.go": [
          "File: commands/command_migrate_info.go -> commands/command_migrate_info.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "96:   case \"ignore\":",
          "97:    migrateInfoPointersMode = migrateInfoPointersIgnore",
          "98:   default:",
          "100:   }",
          "101:  }",
          "103:  if migrateFixup {",
          "104:   include, exclude := getIncludeExcludeArgs(cmd)",
          "105:   if include != nil || exclude != nil {",
          "107:   }",
          "108:   if pointers.Changed && migrateInfoPointersMode != migrateInfoPointersIgnore {",
          "110:   }",
          "111:   migrateInfoPointersMode = migrateInfoPointersIgnore",
          "112:  }",
          "",
          "[Removed Lines]",
          "99:    ExitWithError(errors.Errorf(tr.Tr.Get(\"Unsupported --pointers option value\")))",
          "106:    ExitWithError(errors.Errorf(tr.Tr.Get(\"Cannot use --fixup with --include, --exclude\")))",
          "109:    ExitWithError(errors.Errorf(tr.Tr.Get(\"Cannot use --fixup with --pointers=%s\", pointers.Value.String())))",
          "",
          "[Added Lines]",
          "99:    ExitWithError(errors.New(tr.Tr.Get(\"Unsupported --pointers option value\")))",
          "106:    ExitWithError(errors.New(tr.Tr.Get(\"Cannot use --fixup with --include, --exclude\")))",
          "109:    ExitWithError(errors.New(tr.Tr.Get(\"Cannot use --fixup with --pointers=%s\", pointers.Value.String())))",
          "",
          "---------------"
        ],
        "commands/command_smudge.go||commands/command_smudge.go": [
          "File: commands/command_smudge.go -> commands/command_smudge.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "44:   }",
          "46:   if n != 0 {",
          "48:     tr.Tr.Get(\"Unable to parse pointer at: %q\", filename),",
          "49:    ))",
          "50:   }",
          "",
          "[Removed Lines]",
          "47:    return 0, false, nil, errors.NewNotAPointerError(errors.Errorf(",
          "",
          "[Added Lines]",
          "47:    return 0, false, nil, errors.NewNotAPointerError(errors.New(",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "107:   }",
          "109:   if n != 0 {",
          "111:     tr.Tr.Get(\"Unable to parse pointer at: %q\", filename),",
          "112:    ))",
          "113:   }",
          "",
          "[Removed Lines]",
          "110:    return 0, errors.NewNotAPointerError(errors.Errorf(",
          "",
          "[Added Lines]",
          "110:    return 0, errors.NewNotAPointerError(errors.New(",
          "",
          "---------------"
        ],
        "creds/creds.go||creds/creds.go": [
          "File: creds/creds.go -> creds/creds.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "66:  for k, v := range c {",
          "67:   for _, item := range v {",
          "68:    if strings.Contains(item, \"\\n\") {",
          "70:    }",
          "71:    if protectProtocol && strings.Contains(item, \"\\r\") {",
          "73:    }",
          "74:    if strings.Contains(item, string(rune(0))) {",
          "76:    }",
          "78:    buf.Write([]byte(k))",
          "",
          "[Removed Lines]",
          "69:     return nil, errors.Errorf(tr.Tr.Get(\"credential value for %s contains newline: %q\", k, item))",
          "72:     return nil, errors.Errorf(tr.Tr.Get(\"credential value for %s contains carriage return: %q\\nIf this is intended, set `credential.protectProtocol=false`\", k, item))",
          "75:     return nil, errors.Errorf(tr.Tr.Get(\"credential value for %s contains null byte: %q\", k, item))",
          "",
          "[Added Lines]",
          "69:     return nil, errors.New(tr.Tr.Get(\"credential value for %s contains newline: %q\", k, item))",
          "72:     return nil, errors.New(tr.Tr.Get(\"credential value for %s contains carriage return: %q\\nIf this is intended, set `credential.protectProtocol=false`\", k, item))",
          "75:     return nil, errors.New(tr.Tr.Get(\"credential value for %s contains null byte: %q\", k, item))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "249:  case credValueTypePassword:",
          "250:   valueString = \"password\"",
          "251:  default:",
          "253:  }",
          "",
          "[Removed Lines]",
          "252:   return \"\", errors.Errorf(tr.Tr.Get(\"Invalid Credential type queried from AskPass\"))",
          "",
          "[Added Lines]",
          "252:   return \"\", errors.New(tr.Tr.Get(\"Invalid Credential type queried from AskPass\"))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "274:  case credValueTypePassword:",
          "275:   valueString = \"Password\"",
          "276:  default:",
          "278:  }",
          "",
          "[Removed Lines]",
          "277:   return \"\", errors.Errorf(tr.Tr.Get(\"Invalid Credential type queried from AskPass\"))",
          "",
          "[Added Lines]",
          "277:   return \"\", errors.New(tr.Tr.Get(\"Invalid Credential type queried from AskPass\"))",
          "",
          "---------------"
        ],
        "errors/types.go||errors/types.go": [
          "File: errors/types.go -> errors/types.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "386: }",
          "388: func NewBadPointerKeyError(expected, actual string) error {",
          "390:  return badPointerKeyError{expected, actual, newWrappedError(err, tr.Tr.Get(\"pointer parsing\"))}",
          "391: }",
          "",
          "[Removed Lines]",
          "389:  err := Errorf(tr.Tr.Get(\"Expected key %s, got %s\", expected, actual))",
          "",
          "[Added Lines]",
          "389:  err := New(tr.Tr.Get(\"Expected key %s, got %s\", expected, actual))",
          "",
          "---------------"
        ],
        "git/githistory/rewriter_test.go||git/githistory/rewriter_test.go": [
          "File: git/githistory/rewriter_test.go -> git/githistory/rewriter_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "377: }",
          "379: func TestHistoryRewriterTreePreCallbackPropagatesErrors(t *testing.T) {",
          "382:  db := DatabaseFromFixture(t, \"linear-history.git\")",
          "383:  r := NewRewriter(db)",
          "",
          "[Removed Lines]",
          "380:  expected := errors.Errorf(\"my error\")",
          "",
          "[Added Lines]",
          "380:  expected := errors.New(\"my error\")",
          "",
          "---------------"
        ],
        "lfs/diff_index_scanner.go||lfs/diff_index_scanner.go": [
          "File: lfs/diff_index_scanner.go -> lfs/diff_index_scanner.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "186:  parts := strings.Split(line, \"\\t\")",
          "187:  if len(parts) < 2 {",
          "189:  }",
          "191:  desc := strings.Fields(parts[0])",
          "192:  if len(desc) < 5 {",
          "194:  }",
          "196:  entry := &DiffIndexEntry{",
          "",
          "[Removed Lines]",
          "188:   return nil, errors.Errorf(tr.Tr.Get(\"invalid line: %s\", line))",
          "193:   return nil, errors.Errorf(tr.Tr.Get(\"invalid description: %s\", parts[0]))",
          "",
          "[Added Lines]",
          "188:   return nil, errors.New(tr.Tr.Get(\"invalid line: %s\", line))",
          "193:   return nil, errors.New(tr.Tr.Get(\"invalid description: %s\", parts[0]))",
          "",
          "---------------"
        ],
        "lfshttp/standalone/standalone.go||lfshttp/standalone/standalone.go": [
          "File: lfshttp/standalone/standalone.go -> lfshttp/standalone/standalone.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "256: func (h *fileHandler) download(oid string, size int64) (string, string, error) {",
          "257:  if !h.remoteConfig.LFSObjectExists(oid, size) {",
          "258:   tracerx.Printf(\"missing object in %q (%s)\", h.remotePath, oid)",
          "260:  }",
          "262:  src, err := h.remoteConfig.Filesystem().ObjectPath(oid)",
          "",
          "[Removed Lines]",
          "259:   return oid, \"\", errors.Errorf(tr.Tr.Get(\"remote missing object %s\", oid))",
          "",
          "[Added Lines]",
          "259:   return oid, \"\", errors.New(tr.Tr.Get(\"remote missing object %s\", oid))",
          "",
          "---------------"
        ],
        "ssh/connection.go||ssh/connection.go": [
          "File: ssh/connection.go -> ssh/connection.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: import (",
          "4:  \"bytes\"",
          "6:  \"sync\"",
          "8:  \"github.com/git-lfs/git-lfs/v3/config\"",
          "",
          "[Removed Lines]",
          "5:  \"fmt\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "80:   r.Close()",
          "81:   w.Close()",
          "82:   cmd.Wait()",
          "84:   tracerx.Printf(\"pure SSH connection unsuccessful (#%d)\", id)",
          "85:  } else {",
          "86:   tracerx.Printf(\"pure SSH connection successful (#%d)\", id)",
          "",
          "[Removed Lines]",
          "83:   err = errors.Combine([]error{err, fmt.Errorf(tr.Tr.Get(\"Failed to connect to remote SSH server: %s\", cmd.Stderr))})",
          "",
          "[Added Lines]",
          "82:   err = errors.Combine([]error{err, errors.New(tr.Tr.Get(\"Failed to connect to remote SSH server: %s\", cmd.Stderr))})",
          "",
          "---------------"
        ],
        "tq/basic_download.go||tq/basic_download.go": [
          "File: tq/basic_download.go -> tq/basic_download.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "118:   return err",
          "119:  }",
          "120:  if rel == nil {",
          "122:  }",
          "124:  req, err := a.newHTTPRequest(\"GET\", rel)",
          "",
          "[Removed Lines]",
          "121:   return errors.Errorf(tr.Tr.Get(\"Object %s not found on the server.\", t.Oid))",
          "",
          "[Added Lines]",
          "121:   return errors.New(tr.Tr.Get(\"Object %s not found on the server.\", t.Oid))",
          "",
          "---------------"
        ],
        "tq/basic_upload.go||tq/basic_upload.go": [
          "File: tq/basic_upload.go -> tq/basic_upload.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "47:   return err",
          "48:  }",
          "49:  if rel == nil {",
          "51:  }",
          "53:  req, err := a.newHTTPRequest(\"PUT\", rel)",
          "",
          "[Removed Lines]",
          "50:   return errors.Errorf(tr.Tr.Get(\"No upload action for object: %s\", t.Oid))",
          "",
          "[Added Lines]",
          "50:   return errors.New(tr.Tr.Get(\"No upload action for object: %s\", t.Oid))",
          "",
          "---------------"
        ],
        "tq/custom.go||tq/custom.go": [
          "File: tq/custom.go -> tq/custom.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "272:   return err",
          "273:  }",
          "274:  if rel == nil && !a.standalone {",
          "276:  }",
          "277:  var req *customAdapterTransferRequest",
          "278:  if a.direction == Upload {",
          "",
          "[Removed Lines]",
          "275:   return errors.Errorf(tr.Tr.Get(\"Object %s not found on the server.\", t.Oid))",
          "",
          "[Added Lines]",
          "275:   return errors.New(tr.Tr.Get(\"Object %s not found on the server.\", t.Oid))",
          "",
          "---------------"
        ],
        "tq/ssh.go||tq/ssh.go": [
          "File: tq/ssh.go -> tq/ssh.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "194:   return err",
          "195:  }",
          "196:  if rel == nil {",
          "198:  }",
          "200:  f, err := tools.TempFile(a.tempDir(), t.Oid, a.fs)",
          "",
          "[Removed Lines]",
          "197:   return errors.Errorf(tr.Tr.Get(\"No download action for object: %s\", t.Oid))",
          "",
          "[Added Lines]",
          "197:   return errors.New(tr.Tr.Get(\"No download action for object: %s\", t.Oid))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "346:   return err",
          "347:  }",
          "348:  if rel == nil {",
          "350:  }",
          "352:  f, err := os.OpenFile(t.Path, os.O_RDONLY, 0644)",
          "",
          "[Removed Lines]",
          "349:   return errors.Errorf(tr.Tr.Get(\"No upload action for object: %s\", t.Oid))",
          "",
          "[Added Lines]",
          "349:   return errors.New(tr.Tr.Get(\"No upload action for object: %s\", t.Oid))",
          "",
          "---------------"
        ],
        "tq/transfer_queue.go||tq/transfer_queue.go": [
          "File: tq/transfer_queue.go -> tq/transfer_queue.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "653:    q.Skip(o.Size)",
          "654:    q.wait.Done()",
          "",
          "[Removed Lines]",
          "651:    q.errorc <- errors.Errorf(tr.Tr.Get(\"[%v] The server returned an unknown OID.\", o.Oid))",
          "",
          "[Added Lines]",
          "651:    q.errorc <- errors.New(tr.Tr.Get(\"[%v] The server returned an unknown OID.\", o.Oid))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "748:   var err error",
          "750:   if t.Size < 0 {",
          "752:   } else {",
          "753:    fd, serr := os.Stat(t.Path)",
          "754:    if serr != nil {",
          "",
          "[Removed Lines]",
          "751:    err = errors.Errorf(tr.Tr.Get(\"object %q has invalid size (got: %d)\", t.Oid, t.Size))",
          "",
          "[Added Lines]",
          "751:    err = errors.New(tr.Tr.Get(\"object %q has invalid size (got: %d)\", t.Oid, t.Size))",
          "",
          "---------------"
        ],
        "tq/tus_upload.go||tq/tus_upload.go": [
          "File: tq/tus_upload.go -> tq/tus_upload.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "34:   return err",
          "35:  }",
          "36:  if rel == nil {",
          "38:  }",
          "",
          "[Removed Lines]",
          "37:   return errors.Errorf(tr.Tr.Get(\"No upload action for object: %s\", t.Oid))",
          "",
          "[Added Lines]",
          "37:   return errors.New(tr.Tr.Get(\"No upload action for object: %s\", t.Oid))",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "44236960abcebdcc5889d8814e274fbe66d0f4e1",
      "candidate_info": {
        "commit_hash": "44236960abcebdcc5889d8814e274fbe66d0f4e1",
        "repo": "git-lfs/git-lfs",
        "commit_url": "https://github.com/git-lfs/git-lfs/commit/44236960abcebdcc5889d8814e274fbe66d0f4e1",
        "files": [
          "creds/creds.go",
          "creds/creds_test.go",
          "t/cmd/lfstest-gitserver.go",
          "t/t-credentials-protect.sh"
        ],
        "message": "creds/creds.go: reject CR bytes in credential data\n\nAs reported in CVE-2024-52006, when Git writes credential request keys\nand values to a Git credential helper, it does not remove any bare\ncarriage return (CR) control characters included in the values, which\nmay allow a malicious server to insert spurious keys and values into\nthe credential request if the helper happens to parse bare CR characters\nas line delimiters.\n\nA similar problem due to bare line feed (LF) characters in credential\nrequest values was reported in CVE-2020-5260, and was addressed in Git by\nrevising the credential_write_item() function of the credential.c source\nfile to check for line feed characters before writing a value.  This\nchange from commit git/git@9a6bbee8006c24b46a85d29e7b38cfa79e9ab21b was\nthen released in Git version 2.17.4 (and other patch releases):\n\n  https://github.com/git/git/blob/v2.47.1/credential.c#L391-L392\n\nBecause some credential helpers may also accept bare carriage return\ncharacters as line delimiters, future versions of Git will now also\ncheck for those in the credential_write_item() function.  However, this\nbehaviour may be disabled by setting a new \"credential.protectProtocol\"\nGit configuration option to a value equivalent to \"false\".\n\nBecause Git LFS may be used with older versions of Git which do not have\nthis additional protection, we can not assume that the git-credential(1)\ncommand we execute will, when appropriate, detect and reject bare\ncarriage return characters in the values we send to it.\n\nWe therefore adopt similar measures as future versions of Git will take,\nand revise the buffer() method of the Creds structure in our \"creds\"\npackage (which we refactored from a bufferCreds() function in a prior\ncommit in this PR) so it returns an error if any of the values it\nprocesses have an embedded carriage return character, unless the\n\"credential.protectProtocol\" Git configuration option is set to a value\nequivalent to \"false\".\n\nTo support the new Git configuration option we add a protectProtocol\nfield to our commandCredentialHelper structure and populate it from\nthe value of the \"credential.protectProtocol\" option (which may also\nbe scoped to a specific URL as a \"credential.<url>.protectProtocol\"\noption).  The protectProtocol field defaults to \"true\", which aligns\nwith how Git will implement this new option.\n\nWe then pass the protectProtocol field's value as a new, additional\nargument to the buffer() method of the Creds structure.  If the value\nof the argument is \"true\", the method checks for carriage return\ncharacters in each value it will write to its buffer.\n\nTo verify these changes we expand the TestCredsBufferProtect() test\nfunction, which we added in a prior commit in this PR, so that it\nchecks three additional conditions.  First, it tests whether the\nbuffer() method always returns an error when one of the values passed\nto it contains a line feed character, even if the method's new\nprotectProtocol argument is set to \"false\".  Next, the test function\nchecks that when the protectProtocol argument is set to \"true\" the\nbuffer() method returns an error if any of the values it is given\ncontain a carriage return character.  Last, the test function confirms\nthat if the protectProtocol argument is set to \"false\" then the buffer()\nmethod will not return an error, regardless of whether one of the\nvalues passed to it contains a carriage return character.\n\nWe also add a new \"credentials rejected with carriage return\" test to\nour t/t-credentials-protect.sh test script, and expand the \"credentials\nrejected with line feed\" test that we introduced with that script in a\nprior commit in this PR.\n\nIn the case of the existing test from that prior commit, we now verify\nthat even when the \"credential.protectProtocol\" Git configuration option\nis set to \"false\", an error is reported and no Git LFS object is pushed\nif a value which would be passed to a \"git credential fill\" command\ncontains a bare line feed character.\n\nIn our new \"credentials rejected with carriage return\" test we first\nperform a check similar to the initial one made by the \"credentials\nrejected with line feed\" test.  This check confirms that in the default\ncase an error is reported and no Git LFS object is pushed if a value\nwhich would be passed to a \"git credential fill\" command contains a\nbare carriage return character.\n\nUnlike the test for embedded line feed characters, though, our new test\nthen checks that when the \"credential.protectProtocol\" option is set\nto \"false\", no error is reported and a push of a Git LFS object succeeds\ndespite the presence of a bare carriage return character in the values\npassed to the \"git credential fill\" command.\n\nAs with the existing \"credentials rejected with line feed\" test, in our\nnew test we again use the \"localhost\" hostname in the URL which contains\na URL-encoded control character.  If we used the 127.0.0.1 address on\nwhich our lfstest-gitserver listens for requests, then Git LFS would\ndetect that the scheme and the host subcomponent of the URL for the Git\nLFS API matched those of the URL of the current Git remote, and would\nthen use the Git remote's URL when querying for credentials.  As that\nURL does not contain a URL-encoded carriage return character, our test\nwould not achieve its purpose, so we instead use the \"localhost\" alias\nin the test's Git LFS configuration.\n\nBecause we make use of the \"localhost\" hostname, our new test's\nfinal check will only succeed in pushing a Git LFS object if our\ngit-credential-lfstest helper program can locate the appropriate\ncredentials.  Therefore, unlike the existing \"credentials rejected\nwith line feed\" test, a credential record file associated with the\n\"localhost\" hostname must exist.\n\nAs explained in the previous commit where we added that test, though,\nit is partly for this reason that the t/t-credentials-protect.sh test\nscript already copies the record file associated with the 127.0.0.1\naddress to create a record file for the \"localhost\" hostname, before\nrunning any tests.\n\nThe presence of this record file also helps ensure that our tests will\nfail in the case of a future regression in the checks made by the\nbuffer() method for bare line feed or carriage return characters.\n\nFinally, we have to make a small change to our lfstest-gitserver test\nutility in order for our new test's final check to succeed.  The\nlfstest-gitserver program provides a basic implementation of the Git LFS\nBatch API, and when the Git LFS client sends an initial request to it\nto upload an object, the program replies with a JSON response that\nincludes the URL to be used to transfer the object's data.\n\nThese per-object URLs are generated by the lfstest-gitserver program's\ninternal lfsUrl() function, which creates a URL that includes an \"r\"\nquery parameter whose value is the set of URL path segments from the\ninitial Batch API request.  However, the lfsUrl() function does not\nURL-encode the \"r\" query parameter's value, which has been URL-decoded\nfrom the URL of the original API request.\n\nBecause our test makes a request to the Git LFS API with a URL-encoded\ncarriage return character in the URL path of the request, without any\nchanges to the lfsUrl() function the per-object URL the client receives\nback would contain a bare carriage return character.  (Technically,\nthe character would be formatted in the JSON response as a \"\\r\" escape\nsequence, which would then be interpreted as a carriage return character\nwhen the JSON was parsed by the Git LFS client.)  The per-object URL\nwould then in turn be rejected by the Parse() function of the standard\nGo library's \"net/url\" package as containing a bare control character,\nresulting in an error that would prevent the Git LFS client from\ncompleting the transfer of the object.\n\nTo avoid this problem, we simply revise the lfsUrl() function of our\nlfstest-gitserver test utility to correctly URL-encode the value it\nsets for the \"r\" query parameter.",
        "before_after_code_files": [
          "creds/creds.go||creds/creds.go",
          "creds/creds_test.go||creds/creds_test.go",
          "t/cmd/lfstest-gitserver.go||t/cmd/lfstest-gitserver.go",
          "t/t-credentials-protect.sh||t/t-credentials-protect.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "creds/creds.go||creds/creds.go",
            "creds/creds_test.go||creds/creds_test.go",
            "t/t-credentials-protect.sh||t/t-credentials-protect.sh"
          ],
          "candidate": [
            "creds/creds.go||creds/creds.go",
            "creds/creds_test.go||creds/creds_test.go",
            "t/t-credentials-protect.sh||t/t-credentials-protect.sh"
          ]
        }
      },
      "candidate_diff": {
        "creds/creds.go||creds/creds.go": [
          "File: creds/creds.go -> creds/creds.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "58:  return slices.Contains([]string{\"1\", \"true\"}, FirstEntryForKey(c, \"continue\"))",
          "59: }",
          "62:  buf := new(bytes.Buffer)",
          "64:  buf.Write([]byte(\"capability[]=authtype\\n\"))",
          "",
          "[Removed Lines]",
          "61: func (c Creds) buffer() (*bytes.Buffer, error) {",
          "",
          "[Added Lines]",
          "61: func (c Creds) buffer(protectProtocol bool) (*bytes.Buffer, error) {",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68:    if strings.Contains(item, \"\\n\") {",
          "69:     return nil, errors.Errorf(tr.Tr.Get(\"credential value for %s contains newline: %q\", k, item))",
          "70:    }",
          "72:    buf.Write([]byte(k))",
          "73:    buf.Write([]byte(\"=\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "71:    if protectProtocol && strings.Contains(item, \"\\r\") {",
          "72:     return nil, errors.Errorf(tr.Tr.Get(\"credential value for %s contains carriage return: %q\\nIf this is intended, set `credential.protectProtocol=false`\", k, item))",
          "73:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "172:    helpers = append(helpers, ctxt.askpassCredHelper)",
          "173:   }",
          "174:  }",
          "175:  return CredentialHelperWrapper{CredentialHelper: NewCredentialHelpers(append(helpers, ctxt.commandCredHelper)), Input: input, Url: u}",
          "176: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "179:  ctxt.commandCredHelper.protectProtocol = ctxt.urlConfig.Bool(\"credential\", rawurl, \"protectProtocol\", true)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "311: }",
          "313: type commandCredentialHelper struct {",
          "315: }",
          "317: func (h *commandCredentialHelper) Fill(creds Creds) (Creds, error) {",
          "",
          "[Removed Lines]",
          "314:  SkipPrompt bool",
          "",
          "[Added Lines]",
          "320:  SkipPrompt      bool",
          "321:  protectProtocol bool",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "342:  if err != nil {",
          "343:   return nil, errors.New(tr.Tr.Get(\"failed to find `git credential %s`: %v\", subcommand, err))",
          "344:  }",
          "346:  if err != nil {",
          "347:   return nil, errors.New(tr.Tr.Get(\"invalid input to `git credential %s`: %v\", subcommand, err))",
          "348:  }",
          "",
          "[Removed Lines]",
          "345:  cmd.Stdin, err = input.buffer()",
          "",
          "[Added Lines]",
          "352:  cmd.Stdin, err = input.buffer(h.protectProtocol)",
          "",
          "---------------"
        ],
        "creds/creds_test.go||creds/creds_test.go": [
          "File: creds/creds_test.go -> creds/creds_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:  expected := []string{\"capability[]=authtype\\n\", \"capability[]=state\\n\"}",
          "29:  assert.NoError(t, err)",
          "30:  assertCredsLinesMatch(t, expected, buf)",
          "",
          "[Removed Lines]",
          "28:  buf, err := creds.buffer()",
          "",
          "[Added Lines]",
          "28:  buf, err := creds.buffer(true)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "35:  expectedPrefix := strings.Join(expected, \"\")",
          "36:  expected = append(expected, \"protocol=https\\n\", \"host=example.com\\n\")",
          "39:  assert.NoError(t, err)",
          "40:  assert.True(t, strings.HasPrefix(buf.String(), expectedPrefix))",
          "41:  assertCredsLinesMatch(t, expected, buf)",
          "",
          "[Removed Lines]",
          "38:  buf, err = creds.buffer()",
          "",
          "[Added Lines]",
          "38:  buf, err = creds.buffer(true)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "45:  expected = append(expected, \"wwwauth[]=Basic realm=test\\n\")",
          "46:  expected = append(expected, \"wwwauth[]=Negotiate\\n\")",
          "49:  assert.NoError(t, err)",
          "50:  assert.True(t, strings.HasPrefix(buf.String(), expectedPrefix))",
          "51:  assertCredsLinesMatch(t, expected, buf)",
          "",
          "[Removed Lines]",
          "48:  buf, err = creds.buffer()",
          "",
          "[Added Lines]",
          "48:  buf, err = creds.buffer(true)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "58:  creds[\"protocol\"] = []string{\"https\"}",
          "59:  creds[\"host\"] = []string{\"one.example.com\\nhost=two.example.com\"}",
          "62:  assert.Error(t, err)",
          "63:  assert.Nil(t, buf)",
          "64: }",
          "",
          "[Removed Lines]",
          "61:  buf, err := creds.buffer()",
          "",
          "[Added Lines]",
          "61:  buf, err := creds.buffer(false)",
          "62:  assert.Error(t, err)",
          "63:  assert.Nil(t, buf)",
          "65:  buf, err = creds.buffer(true)",
          "66:  assert.Error(t, err)",
          "67:  assert.Nil(t, buf)",
          "70:  creds[\"host\"] = []string{\"one.example.com\\rhost=two.example.com\"}",
          "72:  expected := []string{",
          "73:   \"capability[]=authtype\\n\",",
          "74:   \"capability[]=state\\n\",",
          "75:   \"protocol=https\\n\",",
          "76:   \"host=one.example.com\\rhost=two.example.com\\n\",",
          "77:  }",
          "79:  buf, err = creds.buffer(false)",
          "80:  assert.NoError(t, err)",
          "81:  assertCredsLinesMatch(t, expected, buf)",
          "83:  buf, err = creds.buffer(true)",
          "",
          "---------------"
        ],
        "t/cmd/lfstest-gitserver.go||t/cmd/lfstest-gitserver.go": [
          "File: t/cmd/lfstest-gitserver.go -> t/cmd/lfstest-gitserver.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "26:  \"net/http\"",
          "27:  \"net/http/httptest\"",
          "28:  \"net/textproto\"",
          "29:  \"os\"",
          "30:  \"os/exec\"",
          "31:  \"regexp\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "29:  \"net/url\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "257: }",
          "259: func lfsUrl(repo, oid string, redirect bool) string {",
          "260:  if redirect {",
          "261:   return server.URL + \"/redirect307/objects/\" + oid + \"?r=\" + repo",
          "262:  }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "261:  repo = url.QueryEscape(repo)",
          "",
          "---------------"
        ],
        "t/t-credentials-protect.sh||t/t-credentials-protect.sh": [
          "File: t/t-credentials-protect.sh -> t/t-credentials-protect.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "42:   grep \"batch response: Git credentials for $gitserver.* not found\" push.log",
          "43:   grep \"credential value for path contains newline\" push.log",
          "44:   refute_server_object \"$testreponame\" \"$contents_oid\"",
          "45: )",
          "46: end_test",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "46:   git config credential.protectProtocol false",
          "48:   GIT_TRACE=1 git lfs push origin main 2>&1 | tee push.log",
          "49:   if [ \"0\" -eq \"${PIPESTATUS[0]}\" ]; then",
          "50:     echo >&2 \"fatal: expected 'git lfs push' to fail ...\"",
          "51:     exit 1",
          "52:   fi",
          "53:   grep \"batch response: Git credentials for $gitserver.* not found\" push.log",
          "54:   grep \"credential value for path contains newline\" push.log",
          "55:   refute_server_object \"$testreponame\" \"$contents_oid\"",
          "56: )",
          "57: end_test",
          "59: begin_test \"credentials rejected with carriage return\"",
          "60: (",
          "61:   set -e",
          "63:   reponame=\"protect-return\"",
          "64:   setup_remote_repo \"$reponame\"",
          "65:   clone_repo \"$reponame\" \"$reponame\"",
          "67:   contents=\"a\"",
          "68:   contents_oid=$(calc_oid \"$contents\")",
          "70:   git lfs track \"*.dat\"",
          "71:   printf \"%s\" \"$contents\" >a.dat",
          "72:   git add .gitattributes a.dat",
          "73:   git commit -m \"add a.dat\"",
          "75:   # Using localhost instead of 127.0.0.1 in the LFS API URL ensures this URL",
          "76:   # is used when filling credentials rather than the Git remote URL, which",
          "77:   # would otherwise be used since it would have the same scheme and hostname.",
          "78:   gitserver=\"$(echo \"$GITSERVER\" | sed 's/127\\.0\\.0\\.1/localhost/')\"",
          "79:   testreponame=\"test%0d$reponame\"",
          "80:   git config lfs.url \"$gitserver/$testreponame.git/info/lfs\"",
          "82:   GIT_TRACE=1 git lfs push origin main 2>&1 | tee push.log",
          "83:   if [ \"0\" -eq \"${PIPESTATUS[0]}\" ]; then",
          "84:     echo >&2 \"fatal: expected 'git lfs push' to fail ...\"",
          "85:     exit 1",
          "86:   fi",
          "87:   grep \"batch response: Git credentials for $gitserver.* not found\" push.log",
          "88:   grep \"credential value for path contains carriage return\" push.log",
          "89:   refute_server_object \"$testreponame\" \"$contents_oid\"",
          "91:   git config credential.protectProtocol false",
          "93:   git lfs push origin main 2>&1 | tee push.log",
          "94:   if [ \"0\" -ne \"${PIPESTATUS[0]}\" ]; then",
          "95:     echo >&2 \"fatal: expected 'git lfs push' to succeed ...\"",
          "96:     exit 1",
          "97:   fi",
          "98:   [ $(grep -c \"Uploading LFS objects: 100% (1/1)\" push.log) -eq 1 ]",
          "99:   assert_server_object \"$testreponame\" \"$contents_oid\"",
          "",
          "---------------"
        ]
      }
    }
  ]
}
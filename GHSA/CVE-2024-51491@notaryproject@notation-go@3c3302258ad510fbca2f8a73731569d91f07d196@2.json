{
  "cve_id": "CVE-2024-51491",
  "cve_desc": "notion-go is a collection of libraries for supporting sign and verify OCI artifacts. Based on Notary Project specifications. The issue was identified during Quarkslab's security audit on the Certificate Revocation List (CRL) based revocation check feature.\nAfter retrieving the CRL, notation-go attempts to update the CRL cache using the os.Rename method. However, this operation may fail due to operating system-specific limitations, particularly when the source and destination paths are on different mount points. This failure could lead to an unexpected program termination. In method `crl.(*FileCache).Set`, a temporary file is created in the OS dedicated area (like /tmp for, usually, Linux/Unix). The file is written and then it is tried to move it to the dedicated `notation` cache directory thanks `os.Rename`. As specified in Go documentation, OS specific restriction may apply. When used with Linux OS, it is relying on rename syscall from the libc and as per the documentation, moving a file to a different mountpoint raises an EXDEV error, interpreted as Cross device link not permitted error. Some Linux distribution, like RedHat use a dedicated filesystem (tmpfs), mounted on a specific mountpoint (usually /tmp) for temporary files. When using such OS, revocation check based on CRL will repeatedly crash notation. As a result the signature verification process is aborted as process crashes. This issue has been addressed in version 1.3.0-rc.2 and all users are advised to upgrade. There are no known workarounds for this vulnerability.",
  "repo": "notaryproject/notation-go",
  "patch_hash": "3c3302258ad510fbca2f8a73731569d91f07d196",
  "patch_info": {
    "commit_hash": "3c3302258ad510fbca2f8a73731569d91f07d196",
    "repo": "notaryproject/notation-go",
    "commit_url": "https://github.com/notaryproject/notation-go/commit/3c3302258ad510fbca2f8a73731569d91f07d196",
    "files": [
      "internal/file/file.go",
      "internal/file/file_test.go",
      "verifier/crl/crl.go"
    ],
    "message": "fix: OS error when setting CRL cache leads to denial of signature verification\n\nSigned-off-by: Junjie Gao <junjiegao@microsoft.com>\nSigned-off-by: Patrick Zheng <patrickzheng@microsoft.com>",
    "before_after_code_files": [
      "internal/file/file.go||internal/file/file.go",
      "internal/file/file_test.go||internal/file/file_test.go",
      "verifier/crl/crl.go||verifier/crl/crl.go"
    ]
  },
  "patch_diff": {
    "internal/file/file.go||internal/file/file.go": [
      "File: internal/file/file.go -> internal/file/file.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "124:  if err != nil {",
      "125:   return fmt.Errorf(\"failed to create temp file: %w\", err)",
      "126:  }",
      "",
      "[Removed Lines]",
      "122: func WriteFile(path string, content []byte) (writeErr error) {",
      "123:  tempFile, err := os.CreateTemp(\"\", tempFileNamePrefix)",
      "",
      "[Added Lines]",
      "129: func WriteFile(tempDir, path string, content []byte) (writeErr error) {",
      "130:  tempFile, err := os.CreateTemp(tempDir, tempFileNamePrefix)",
      "",
      "---------------"
    ],
    "internal/file/file_test.go||internal/file/file_test.go": [
      "File: internal/file/file_test.go -> internal/file/file_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "30:   if err := os.MkdirAll(filepath.Dir(filename), 0700); err != nil {",
      "31:    t.Fatal(err)",
      "32:   }",
      "34:    t.Fatal(err)",
      "35:   }",
      "",
      "[Removed Lines]",
      "33:   if err := WriteFile(filename, data); err != nil {",
      "",
      "[Added Lines]",
      "33:   if err := WriteFile(tempDir, filename, data); err != nil {",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "52:   if err := os.MkdirAll(filepath.Dir(filename), 0700); err != nil {",
      "53:    t.Fatal(err)",
      "54:   }",
      "56:    t.Fatal(err)",
      "57:   }",
      "",
      "[Removed Lines]",
      "55:   if err := WriteFile(filename, data); err != nil {",
      "",
      "[Added Lines]",
      "55:   if err := WriteFile(tempDir, filename, data); err != nil {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "87:   if err := os.MkdirAll(filepath.Dir(filename), 0700); err != nil {",
      "88:    t.Fatal(err)",
      "89:   }",
      "91:    t.Fatal(err)",
      "92:   }",
      "",
      "[Removed Lines]",
      "90:   if err := WriteFile(filename, data); err != nil {",
      "",
      "[Added Lines]",
      "90:   if err := WriteFile(tempDir, filename, data); err != nil {",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "113:   if err := os.MkdirAll(filepath.Dir(filename), 0700); err != nil {",
      "114:    t.Fatal(err)",
      "115:   }",
      "117:    t.Fatal(err)",
      "118:   }",
      "",
      "[Removed Lines]",
      "116:   if err := WriteFile(filename, data); err != nil {",
      "",
      "[Added Lines]",
      "116:   if err := WriteFile(tempDir, filename, data); err != nil {",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "139:   if err := os.MkdirAll(filepath.Dir(filename), 0700); err != nil {",
      "140:    t.Fatal(err)",
      "141:   }",
      "143:    t.Fatal(err)",
      "144:   }",
      "",
      "[Removed Lines]",
      "142:   if err := WriteFile(filename, data); err != nil {",
      "",
      "[Added Lines]",
      "142:   if err := WriteFile(tempDir, filename, data); err != nil {",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "159:   if err := os.MkdirAll(filepath.Dir(filename), 0700); err != nil {",
      "160:    t.Fatal(err)",
      "161:   }",
      "163:    t.Fatal(err)",
      "164:   }",
      "",
      "[Removed Lines]",
      "162:   if err := WriteFile(filename, data); err != nil {",
      "",
      "[Added Lines]",
      "162:   if err := WriteFile(tempDir, filename, data); err != nil {",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "192:   if err != nil {",
      "193:    t.Fatal(err)",
      "194:   }",
      "196:   if err == nil || !strings.Contains(err.Error(), \"permission denied\") {",
      "197:    t.Fatalf(\"expected permission denied error, but got %s\", err)",
      "198:   }",
      "",
      "[Removed Lines]",
      "195:   err = WriteFile(filepath.Join(tempDir, \"testFile\"), content)",
      "",
      "[Added Lines]",
      "195:   err = WriteFile(tempDir, filepath.Join(tempDir, \"testFile\"), content)",
      "",
      "---------------"
    ],
    "verifier/crl/crl.go||verifier/crl/crl.go": [
      "File: verifier/crl/crl.go -> verifier/crl/crl.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "144:  if err != nil {",
      "145:   return fmt.Errorf(\"failed to store crl bundle in file cache: %w\", err)",
      "146:  }",
      "148:   return fmt.Errorf(\"failed to store crl bundle in file cache: %w\", err)",
      "149:  }",
      "150:  return nil",
      "",
      "[Removed Lines]",
      "147:  if err := file.WriteFile(filepath.Join(c.root, c.fileName(url)), contentBytes); err != nil {",
      "",
      "[Added Lines]",
      "147:  if err := file.WriteFile(c.root, filepath.Join(c.root, c.fileName(url)), contentBytes); err != nil {",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "5395b659c4fa8c5ccfb78a93ffc8e46fc057675b",
      "candidate_info": {
        "commit_hash": "5395b659c4fa8c5ccfb78a93ffc8e46fc057675b",
        "repo": "notaryproject/notation-go",
        "commit_url": "https://github.com/notaryproject/notation-go/commit/5395b659c4fa8c5ccfb78a93ffc8e46fc057675b",
        "files": [
          "go.mod",
          "go.sum"
        ],
        "message": "build(deps): bump golang.org/x/crypto from 0.28.0 to 0.29.0 (#476)\n\nSigned-off-by: Patrick Zheng <patrickzheng@microsoft.com>",
        "before_after_code_files": [
          "go.mod||go.mod",
          "go.sum||go.sum"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/notaryproject/notation-go/pull/487"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "go.mod||go.mod": [
          "File: go.mod -> go.mod",
          "--- Hunk 1 ---",
          "[Context before]",
          "10:  github.com/opencontainers/go-digest v1.0.0",
          "11:  github.com/opencontainers/image-spec v1.1.0",
          "12:  github.com/veraison/go-cose v1.3.0",
          "14:  golang.org/x/mod v0.21.0",
          "15:  oras.land/oras-go/v2 v2.5.0",
          "16: )",
          "",
          "[Removed Lines]",
          "13:  golang.org/x/crypto v0.28.0",
          "",
          "[Added Lines]",
          "13:  golang.org/x/crypto v0.29.0",
          "",
          "---------------"
        ],
        "go.sum||go.sum": [
          "File: go.sum -> go.sum",
          "--- Hunk 1 ---",
          "[Context before]",
          "62: golang.org/x/crypto v0.6.0/go.mod h1:OFC/31mSvZgRz0V1QTNCzfAI1aIRzbiufJtkMIlEp58=",
          "63: golang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=",
          "64: golang.org/x/crypto v0.21.0/go.mod h1:0BP7YvVV9gBbVKyeTG0Gyn+gZm94bibOW5BjDEYAOMs=",
          "67: golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=",
          "68: golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=",
          "69: golang.org/x/mod v0.21.0 h1:vvrHzRwRfVKSiLrG+d4FMl/Qi4ukBCE6kZlTUkDYRT0=",
          "",
          "[Removed Lines]",
          "65: golang.org/x/crypto v0.28.0 h1:GBDwsMXVQi34v5CCYUm2jkJvu4cbtru2U4TN2PSyQnw=",
          "66: golang.org/x/crypto v0.28.0/go.mod h1:rmgy+3RHxRZMyY0jjAJShp2zgEdOqj2AO7U0pYmeQ7U=",
          "",
          "[Added Lines]",
          "65: golang.org/x/crypto v0.29.0 h1:L5SG1JTTXupVV3n6sUqMTeWbjAyfPwoda2DLX8J8FrQ=",
          "66: golang.org/x/crypto v0.29.0/go.mod h1:+F4F4N5hv6v38hfeYwTdx20oUvLLc+QfrE9Ax9HtgRg=",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "5384dde419424c7c38ff7c4e1dfd0d674319c156",
      "candidate_info": {
        "commit_hash": "5384dde419424c7c38ff7c4e1dfd0d674319c156",
        "repo": "notaryproject/notation-go",
        "commit_url": "https://github.com/notaryproject/notation-go/commit/5384dde419424c7c38ff7c4e1dfd0d674319c156",
        "files": [
          "go.mod",
          "go.sum"
        ],
        "message": "build(deps): bump golang.org/x/mod from 0.21.0 to 0.22.0 (#477)\n\nSigned-off-by: Patrick Zheng <patrickzheng@microsoft.com>",
        "before_after_code_files": [
          "go.mod||go.mod",
          "go.sum||go.sum"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/notaryproject/notation-go/pull/487"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "go.mod||go.mod": [
          "File: go.mod -> go.mod",
          "--- Hunk 1 ---",
          "[Context before]",
          "11:  github.com/opencontainers/image-spec v1.1.0",
          "12:  github.com/veraison/go-cose v1.3.0",
          "13:  golang.org/x/crypto v0.29.0",
          "15:  oras.land/oras-go/v2 v2.5.0",
          "16: )",
          "",
          "[Removed Lines]",
          "14:  golang.org/x/mod v0.21.0",
          "",
          "[Added Lines]",
          "14:  golang.org/x/mod v0.22.0",
          "",
          "---------------"
        ],
        "go.sum||go.sum": [
          "File: go.sum -> go.sum",
          "--- Hunk 1 ---",
          "[Context before]",
          "66: golang.org/x/crypto v0.29.0/go.mod h1:+F4F4N5hv6v38hfeYwTdx20oUvLLc+QfrE9Ax9HtgRg=",
          "67: golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=",
          "68: golang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=",
          "71: golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=",
          "72: golang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=",
          "73: golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=",
          "",
          "[Removed Lines]",
          "69: golang.org/x/mod v0.21.0 h1:vvrHzRwRfVKSiLrG+d4FMl/Qi4ukBCE6kZlTUkDYRT0=",
          "70: golang.org/x/mod v0.21.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=",
          "",
          "[Added Lines]",
          "69: golang.org/x/mod v0.22.0 h1:D4nJWe9zXqHOmWqj4VMOJhvzj7bEZg4wEYa759z1pH4=",
          "70: golang.org/x/mod v0.22.0/go.mod h1:6SkKJ3Xj0I0BrPOZoBy3bdMptDDU9oJrpohJ3eWZ1fY=",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "0a9ff2a2e200ab9bf756d188f84607a83346d4a6",
      "candidate_info": {
        "commit_hash": "0a9ff2a2e200ab9bf756d188f84607a83346d4a6",
        "repo": "notaryproject/notation-go",
        "commit_url": "https://github.com/notaryproject/notation-go/commit/0a9ff2a2e200ab9bf756d188f84607a83346d4a6",
        "files": [
          "verifier/verifier.go"
        ],
        "message": "fix: add warning message for non-revokable certificate (#479)\n\nFix:\n- added warning message for non-revokable certificate\n\n---------\n\nSigned-off-by: Junjie Gao <junjiegao@microsoft.com>\nSigned-off-by: Patrick Zheng <patrickzheng@microsoft.com>",
        "before_after_code_files": [
          "verifier/verifier.go||verifier/verifier.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/notaryproject/notation-go/pull/487"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "verifier/verifier.go||verifier/verifier.go": [
          "File: verifier/verifier.go -> verifier/verifier.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "704:     revokedCertSubject = problematicCertSubject",
          "705:    }",
          "706:   }",
          "707:  }",
          "708:  if revokedFound {",
          "709:   problematicCertSubject = revokedCertSubject",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "708:   if i < len(certResults)-1 && certResult.Result == revocationresult.ResultNonRevokable {",
          "709:    logger.Warnf(\"Certificate #%d in the chain with subject %v neither has an OCSP nor a CRL revocation method.\", (i + 1), cert.Subject.String())",
          "710:   }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "ffc04d8aa8e7d725092eacb11141212425fff21e",
      "candidate_info": {
        "commit_hash": "ffc04d8aa8e7d725092eacb11141212425fff21e",
        "repo": "notaryproject/notation-go",
        "commit_url": "https://github.com/notaryproject/notation-go/commit/ffc04d8aa8e7d725092eacb11141212425fff21e",
        "files": [
          "go.mod",
          "go.sum",
          "verifier/timestamp_test.go",
          "verifier/verifier.go"
        ],
        "message": "fix: timestamping (#478)\n\nSigned-off-by: Patrick Zheng <patrickzheng@microsoft.com>\nCo-authored-by: Pritesh Bandi <priteshbandi@gmail.com>\nSigned-off-by: Patrick Zheng <patrickzheng@microsoft.com>",
        "before_after_code_files": [
          "go.mod||go.mod",
          "go.sum||go.sum",
          "verifier/timestamp_test.go||verifier/timestamp_test.go",
          "verifier/verifier.go||verifier/verifier.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/notaryproject/notation-go/pull/487"
        ],
        "olp_code_files": {
          "patch": [],
          "candidate": []
        }
      },
      "candidate_diff": {
        "go.mod||go.mod": [
          "File: go.mod -> go.mod",
          "--- Hunk 1 ---",
          "[Context before]",
          "5: require (",
          "6:  github.com/go-ldap/ldap/v3 v3.4.8",
          "8:  github.com/notaryproject/notation-plugin-framework-go v1.0.0",
          "10:  github.com/opencontainers/go-digest v1.0.0",
          "11:  github.com/opencontainers/image-spec v1.1.0",
          "12:  github.com/veraison/go-cose v1.3.0",
          "",
          "[Removed Lines]",
          "7:  github.com/notaryproject/notation-core-go v1.2.0-rc.1",
          "9:  github.com/notaryproject/tspclient-go v0.2.0",
          "",
          "[Added Lines]",
          "7:  github.com/notaryproject/notation-core-go v1.2.0-rc.1.0.20241112001243-33af15a18954",
          "9:  github.com/notaryproject/tspclient-go v0.2.1-0.20241030015323-90a141e7525c",
          "",
          "---------------"
        ],
        "go.sum||go.sum": [
          "File: go.sum -> go.sum",
          "--- Hunk 1 ---",
          "[Context before]",
          "32: github.com/jcmturner/gokrb5/v8 v8.4.4/go.mod h1:1btQEpgT6k+unzCwX1KdWMEwPPkkgBtP+F6aCACiMrs=",
          "33: github.com/jcmturner/rpc/v2 v2.0.3 h1:7FXXj8Ti1IaVFpSAziCZWNzbNuZmnvw/i6CqLNdWfZY=",
          "34: github.com/jcmturner/rpc/v2 v2.0.3/go.mod h1:VUJYCIDm3PVOEHw8sgt091/20OJjskO/YJki3ELg/Hc=",
          "37: github.com/notaryproject/notation-plugin-framework-go v1.0.0 h1:6Qzr7DGXoCgXEQN+1gTZWuJAZvxh3p8Lryjn5FaLzi4=",
          "38: github.com/notaryproject/notation-plugin-framework-go v1.0.0/go.mod h1:RqWSrTOtEASCrGOEffq0n8pSg2KOgKYiWqFWczRSics=",
          "41: github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=",
          "42: github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=",
          "43: github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=",
          "",
          "[Removed Lines]",
          "35: github.com/notaryproject/notation-core-go v1.2.0-rc.1 h1:VMFlG+9a1JoNAQ3M96g8iqCq0cDRtE7XBaiTD8Ouvqw=",
          "36: github.com/notaryproject/notation-core-go v1.2.0-rc.1/go.mod h1:b/70rA4OgOHlg0A7pb8zTWKJadFO6781zS3a37KHEJQ=",
          "39: github.com/notaryproject/tspclient-go v0.2.0 h1:g/KpQGmyk/h7j60irIRG1mfWnibNOzJ8WhLqAzuiQAQ=",
          "40: github.com/notaryproject/tspclient-go v0.2.0/go.mod h1:LGyA/6Kwd2FlM0uk8Vc5il3j0CddbWSHBj/4kxQDbjs=",
          "",
          "[Added Lines]",
          "35: github.com/notaryproject/notation-core-go v1.2.0-rc.1.0.20241112001243-33af15a18954 h1:UbjH/ePjxU8jcYMca9NVYqU8Qcr7pP1SKDWCxl++ToA=",
          "36: github.com/notaryproject/notation-core-go v1.2.0-rc.1.0.20241112001243-33af15a18954/go.mod h1:phjvE2bqHsLfJMqMUYqRCqNIH3TQ4GCcFQuEVyQTpDg=",
          "39: github.com/notaryproject/tspclient-go v0.2.1-0.20241030015323-90a141e7525c h1:bX6gGxFw9+DShmYTgbD+vr6neF1SoXIMUU2fDgdLsfA=",
          "40: github.com/notaryproject/tspclient-go v0.2.1-0.20241030015323-90a141e7525c/go.mod h1:LGyA/6Kwd2FlM0uk8Vc5il3j0CddbWSHBj/4kxQDbjs=",
          "",
          "---------------"
        ],
        "verifier/timestamp_test.go||verifier/timestamp_test.go": [
          "File: verifier/timestamp_test.go -> verifier/timestamp_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "216:    VerificationLevel: trustpolicy.LevelStrict,",
          "217:   }",
          "218:   authenticTimestampResult := verifyAuthenticTimestamp(context.Background(), dummyTrustPolicy.Name, dummyTrustPolicy.TrustStores, dummyTrustPolicy.SignatureVerification, trustStore, revocationTimestampingValidator, outcome)",
          "220:   if err := authenticTimestampResult.Error; err == nil || err.Error() != expectedErrMsg {",
          "221:    t.Fatalf(\"expected %s, but got %s\", expectedErrMsg, err)",
          "222:   }",
          "",
          "[Removed Lines]",
          "219:   expectedErrMsg := \"failed to parse timestamp countersignature with error: unexpected content type: 1.2.840.113549.1.7.1\"",
          "",
          "[Added Lines]",
          "219:   expectedErrMsg := \"failed to parse timestamp countersignature with error: unexpected content type: 1.2.840.113549.1.7.1. Expected to be id-ct-TSTInfo (1.2.840.113549.1.9.16.1.4)\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "287:   }",
          "288:  })",
          "290:  t.Run(\"verify Authentic Timestamp failed due to trust store does not exist\", func(t *testing.T) {",
          "291:   dummyTrustPolicy := &trustpolicy.TrustPolicy{",
          "292:    Name:           \"test-timestamp\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "290:  t.Run(\"verify Authentic Timestamp failed due to signing time after timestamp value\", func(t *testing.T) {",
          "291:   signedToken, err := os.ReadFile(\"testdata/timestamp/countersignature/TimeStampToken.p7s\")",
          "292:   if err != nil {",
          "293:    t.Fatalf(\"failed to get signedToken: %v\", err)",
          "294:   }",
          "295:   envContent, err := parseEnvContent(\"testdata/timestamp/sigEnv/withoutTimestamp.sig\", jws.MediaTypeEnvelope)",
          "296:   if err != nil {",
          "297:    t.Fatalf(\"failed to get signature envelope content: %v\", err)",
          "298:   }",
          "299:   envContent.SignerInfo.UnsignedAttributes.TimestampSignature = signedToken",
          "300:   envContent.SignerInfo.Signature = []byte(\"notation\")",
          "301:   envContent.SignerInfo.SignedAttributes.SigningTime = time.Date(3000, time.November, 10, 23, 0, 0, 0, time.UTC)",
          "302:   outcome := &notation.VerificationOutcome{",
          "303:    EnvelopeContent:   envContent,",
          "304:    VerificationLevel: trustpolicy.LevelStrict,",
          "305:   }",
          "306:   authenticTimestampResult := verifyAuthenticTimestamp(context.Background(), dummyTrustPolicy.Name, dummyTrustPolicy.TrustStores, dummyTrustPolicy.SignatureVerification, trustStore, revocationTimestampingValidator, outcome)",
          "307:   expectedErrMsg := \"timestamp [2021-09-17T14:09:09Z, 2021-09-17T14:09:11Z] is not bounded after the signing time \\\"3000-11-10 23:00:00 +0000 UTC\\\"\"",
          "308:   if err := authenticTimestampResult.Error; err == nil || err.Error() != expectedErrMsg {",
          "309:    t.Fatalf(\"expected %s, but got %s\", expectedErrMsg, err)",
          "310:   }",
          "311:  })",
          "",
          "---------------"
        ],
        "verifier/verifier.go||verifier/verifier.go": [
          "File: verifier/verifier.go -> verifier/verifier.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "924:  if err != nil {",
          "925:   return fmt.Errorf(\"failed to verify the timestamp countersignature with error: %w\", err)",
          "926:  }",
          "929:  logger.Debug(\"Validating timestamping certificate chain...\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "927:  if !timestamp.BoundedAfter(signerInfo.SignedAttributes.SigningTime) {",
          "928:   return fmt.Errorf(\"timestamp %s is not bounded after the signing time %q\", timestamp.Format(time.RFC3339), signerInfo.SignedAttributes.SigningTime)",
          "929:  }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "85a5bb9826c6baa9c6f2a0b984d09bc26cc59527",
      "candidate_info": {
        "commit_hash": "85a5bb9826c6baa9c6f2a0b984d09bc26cc59527",
        "repo": "notaryproject/notation-go",
        "commit_url": "https://github.com/notaryproject/notation-go/commit/85a5bb9826c6baa9c6f2a0b984d09bc26cc59527",
        "files": [
          "internal/file/file.go",
          "internal/file/file_test.go",
          "internal/semver/semver.go",
          "internal/semver/semver_test.go",
          "plugin/errors.go",
          "plugin/manager.go",
          "plugin/manager_test.go",
          "plugin/manager_unix.go",
          "plugin/manager_windows.go",
          "plugin/plugin.go",
          "plugin/plugin_test.go",
          "plugin/testdata/plugins/foo/libfoo",
          "verifier/helpers.go",
          "verifier/verifier.go"
        ],
        "message": "feat: add install method to plugin CLIManager (#364)\n\nSigned-off-by: Patrick Zheng <patrickzheng@microsoft.com>",
        "before_after_code_files": [
          "internal/file/file.go||internal/file/file.go",
          "internal/file/file_test.go||internal/file/file_test.go",
          "internal/semver/semver.go||internal/semver/semver.go",
          "internal/semver/semver_test.go||internal/semver/semver_test.go",
          "plugin/errors.go||plugin/errors.go",
          "plugin/manager.go||plugin/manager.go",
          "plugin/manager_test.go||plugin/manager_test.go",
          "plugin/manager_unix.go||plugin/manager_unix.go",
          "plugin/manager_windows.go||plugin/manager_windows.go",
          "plugin/plugin.go||plugin/plugin.go",
          "plugin/plugin_test.go||plugin/plugin_test.go",
          "verifier/helpers.go||verifier/helpers.go",
          "verifier/verifier.go||verifier/verifier.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 1,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "internal/file/file.go||internal/file/file.go",
            "internal/file/file_test.go||internal/file/file_test.go"
          ],
          "candidate": [
            "internal/file/file.go||internal/file/file.go",
            "internal/file/file_test.go||internal/file/file_test.go"
          ]
        }
      },
      "candidate_diff": {
        "internal/file/file.go||internal/file/file.go": [
          "File: internal/file/file.go -> internal/file/file.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: package file",
          "19: func IsValidFileName(fileName string) bool {",
          "20:  return regexp.MustCompile(`^[a-zA-Z0-9_.-]+$`).MatchString(fileName)",
          "21: }",
          "",
          "[Removed Lines]",
          "16: import \"regexp\"",
          "",
          "[Added Lines]",
          "16: import (",
          "17:  \"errors\"",
          "18:  \"io\"",
          "19:  \"io/fs\"",
          "20:  \"os\"",
          "21:  \"path/filepath\"",
          "22:  \"regexp\"",
          "23:  \"strings\"",
          "24: )",
          "27: var ErrNotRegularFile = errors.New(\"not regular file\")",
          "30: var ErrNotDirectory = errors.New(\"not directory\")",
          "43: func CopyToDir(src, dst string) error {",
          "44:  sourceFileInfo, err := os.Stat(src)",
          "45:  if err != nil {",
          "46:   return err",
          "47:  }",
          "48:  if !sourceFileInfo.Mode().IsRegular() {",
          "49:   return ErrNotRegularFile",
          "50:  }",
          "51:  source, err := os.Open(src)",
          "52:  if err != nil {",
          "53:   return err",
          "54:  }",
          "55:  defer source.Close()",
          "56:  if err := os.MkdirAll(dst, 0755); err != nil {",
          "57:   return err",
          "58:  }",
          "59:  dstFile := filepath.Join(dst, filepath.Base(src))",
          "60:  destination, err := os.Create(dstFile)",
          "61:  if err != nil {",
          "62:   return err",
          "63:  }",
          "64:  defer destination.Close()",
          "65:  err = destination.Chmod(sourceFileInfo.Mode() & os.FileMode(0755))",
          "66:  if err != nil {",
          "67:   return err",
          "68:  }",
          "69:  _, err = io.Copy(destination, source)",
          "70:  return err",
          "71: }",
          "75: func CopyDirToDir(src, dst string) error {",
          "76:  fi, err := os.Stat(src)",
          "77:  if err != nil {",
          "78:   return err",
          "79:  }",
          "80:  if !fi.Mode().IsDir() {",
          "81:   return ErrNotDirectory",
          "82:  }",
          "83:  return filepath.WalkDir(src, func(path string, d fs.DirEntry, err error) error {",
          "84:   if err != nil {",
          "85:    return err",
          "86:   }",
          "88:   if d.IsDir() && d.Name() != filepath.Base(path) {",
          "89:    return fs.SkipDir",
          "90:   }",
          "91:   info, err := d.Info()",
          "92:   if err != nil {",
          "93:    return err",
          "94:   }",
          "96:   if info.Mode().IsRegular() {",
          "97:    return CopyToDir(path, dst)",
          "98:   }",
          "99:   return nil",
          "100:  })",
          "101: }",
          "110: func TrimFileExtension(fileName string) string {",
          "111:  return strings.TrimSuffix(fileName, filepath.Ext(fileName))",
          "112: }",
          "",
          "---------------"
        ],
        "internal/file/file_test.go||internal/file/file_test.go": [
          "File: internal/file/file_test.go -> internal/file/file_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: package file",
          "16: import (",
          "17:  \"bytes\"",
          "18:  \"os\"",
          "19:  \"path/filepath\"",
          "20:  \"runtime\"",
          "21:  \"testing\"",
          "22: )",
          "24: func TestCopyToDir(t *testing.T) {",
          "25:  t.Run(\"copy file\", func(t *testing.T) {",
          "26:   tempDir := t.TempDir()",
          "27:   data := []byte(\"data\")",
          "28:   filename := filepath.Join(tempDir, \"a\", \"file.txt\")",
          "29:   if err := writeFile(filename, data); err != nil {",
          "30:    t.Fatal(err)",
          "31:   }",
          "33:   destDir := filepath.Join(tempDir, \"b\")",
          "34:   if err := CopyToDir(filename, destDir); err != nil {",
          "35:    t.Fatal(err)",
          "36:   }",
          "37:  })",
          "39:  t.Run(\"source directory permission error\", func(t *testing.T) {",
          "40:   if runtime.GOOS == \"windows\" {",
          "41:    t.Skip(\"skipping test on Windows\")",
          "42:   }",
          "44:   tempDir := t.TempDir()",
          "45:   destDir := t.TempDir()",
          "46:   data := []byte(\"data\")",
          "47:   filename := filepath.Join(tempDir, \"a\", \"file.txt\")",
          "48:   if err := writeFile(filename, data); err != nil {",
          "49:    t.Fatal(err)",
          "50:   }",
          "52:   if err := os.Chmod(tempDir, 0000); err != nil {",
          "53:    t.Fatal(err)",
          "54:   }",
          "55:   defer os.Chmod(tempDir, 0700)",
          "57:   if err := CopyToDir(filename, destDir); err == nil {",
          "58:    t.Fatal(\"should have error\")",
          "59:   }",
          "60:  })",
          "62:  t.Run(\"not a regular file\", func(t *testing.T) {",
          "63:   tempDir := t.TempDir()",
          "64:   destDir := t.TempDir()",
          "65:   if err := CopyToDir(tempDir, destDir); err == nil {",
          "66:    t.Fatal(\"should have error\")",
          "67:   }",
          "68:  })",
          "70:  t.Run(\"source file permission error\", func(t *testing.T) {",
          "71:   if runtime.GOOS == \"windows\" {",
          "72:    t.Skip(\"skipping test on Windows\")",
          "73:   }",
          "75:   tempDir := t.TempDir()",
          "76:   destDir := t.TempDir()",
          "77:   data := []byte(\"data\")",
          "79:   filename := filepath.Join(tempDir, \"a\", \"file.txt\")",
          "80:   if err := writeFile(filename, data); err != nil {",
          "81:    t.Fatal(err)",
          "82:   }",
          "84:   if err := os.Chmod(filename, 0000); err != nil {",
          "85:    t.Fatal(err)",
          "86:   }",
          "87:   defer os.Chmod(filename, 0600)",
          "88:   if err := CopyToDir(filename, destDir); err == nil {",
          "89:    t.Fatal(\"should have error\")",
          "90:   }",
          "91:  })",
          "93:  t.Run(\"dest directory permission error\", func(t *testing.T) {",
          "94:   if runtime.GOOS == \"windows\" {",
          "95:    t.Skip(\"skipping test on Windows\")",
          "96:   }",
          "98:   tempDir := t.TempDir()",
          "99:   destTempDir := t.TempDir()",
          "100:   data := []byte(\"data\")",
          "102:   filename := filepath.Join(tempDir, \"a\", \"file.txt\")",
          "103:   if err := writeFile(filename, data); err != nil {",
          "104:    t.Fatal(err)",
          "105:   }",
          "107:   if err := os.Chmod(destTempDir, 0000); err != nil {",
          "108:    t.Fatal(err)",
          "109:   }",
          "110:   defer os.Chmod(destTempDir, 0700)",
          "111:   if err := CopyToDir(filename, filepath.Join(destTempDir, \"a\")); err == nil {",
          "112:    t.Fatal(\"should have error\")",
          "113:   }",
          "114:  })",
          "116:  t.Run(\"dest directory permission error 2\", func(t *testing.T) {",
          "117:   if runtime.GOOS == \"windows\" {",
          "118:    t.Skip(\"skipping test on Windows\")",
          "119:   }",
          "121:   tempDir := t.TempDir()",
          "122:   destTempDir := t.TempDir()",
          "123:   data := []byte(\"data\")",
          "125:   filename := filepath.Join(tempDir, \"a\", \"file.txt\")",
          "126:   if err := writeFile(filename, data); err != nil {",
          "127:    t.Fatal(err)",
          "128:   }",
          "130:   if err := os.Chmod(destTempDir, 0000); err != nil {",
          "131:    t.Fatal(err)",
          "132:   }",
          "133:   defer os.Chmod(destTempDir, 0700)",
          "134:   if err := CopyToDir(filename, destTempDir); err == nil {",
          "135:    t.Fatal(\"should have error\")",
          "136:   }",
          "137:  })",
          "139:  t.Run(\"copy file and check content\", func(t *testing.T) {",
          "140:   tempDir := t.TempDir()",
          "141:   data := []byte(\"data\")",
          "142:   filename := filepath.Join(tempDir, \"a\", \"file.txt\")",
          "143:   if err := writeFile(filename, data); err != nil {",
          "144:    t.Fatal(err)",
          "145:   }",
          "147:   destDir := filepath.Join(tempDir, \"b\")",
          "148:   if err := CopyToDir(filename, destDir); err != nil {",
          "149:    t.Fatal(err)",
          "150:   }",
          "151:   validFileContent(t, filepath.Join(destDir, \"file.txt\"), data)",
          "152:  })",
          "153: }",
          "155: func TestFileNameWithoutExtension(t *testing.T) {",
          "156:  input := \"testfile.tar.gz\"",
          "157:  expectedOutput := \"testfile.tar\"",
          "158:  actualOutput := TrimFileExtension(input)",
          "159:  if actualOutput != expectedOutput {",
          "160:   t.Errorf(\"expected '%s', but got '%s'\", expectedOutput, actualOutput)",
          "161:  }",
          "162: }",
          "164: func validFileContent(t *testing.T, filename string, content []byte) {",
          "165:  b, err := os.ReadFile(filename)",
          "166:  if err != nil {",
          "167:   t.Fatal(err)",
          "168:  }",
          "169:  if !bytes.Equal(content, b) {",
          "170:   t.Fatal(\"file content is not correct\")",
          "171:  }",
          "172: }",
          "174: func writeFile(path string, data []byte) error {",
          "175:  if err := os.MkdirAll(filepath.Dir(path), 0700); err != nil {",
          "176:   return err",
          "177:  }",
          "178:  return os.WriteFile(path, data, 0600)",
          "179: }",
          "",
          "---------------"
        ],
        "internal/semver/semver.go||internal/semver/semver.go": [
          "File: internal/semver/semver.go -> internal/semver/semver.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "16: package semver",
          "18: import (",
          "19:  \"fmt\"",
          "20:  \"regexp\"",
          "22:  \"golang.org/x/mod/semver\"",
          "23: )",
          "26: var semVerRegEx = regexp.MustCompile(`^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$`)",
          "29: func IsValid(version string) bool {",
          "30:  return semVerRegEx.MatchString(version)",
          "31: }",
          "36: func ComparePluginVersion(v, w string) (int, error) {",
          "38:  if !IsValid(v) {",
          "39:   return 0, fmt.Errorf(\"%s is not a valid semantic version\", v)",
          "40:  }",
          "41:  if !IsValid(w) {",
          "42:   return 0, fmt.Errorf(\"%s is not a valid semantic version\", w)",
          "43:  }",
          "48:  return semver.Compare(\"v\"+v, \"v\"+w), nil",
          "49: }",
          "",
          "---------------"
        ],
        "internal/semver/semver_test.go||internal/semver/semver_test.go": [
          "File: internal/semver/semver_test.go -> internal/semver/semver_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: package semver",
          "16: import \"testing\"",
          "18: func TestComparePluginVersion(t *testing.T) {",
          "19:  t.Run(\"compare with lower version\", func(t *testing.T) {",
          "20:   comp, err := ComparePluginVersion(\"1.0.0\", \"1.0.1\")",
          "21:   if err != nil || comp >= 0 {",
          "22:    t.Fatal(\"expected nil err and negative comp\")",
          "23:   }",
          "24:  })",
          "26:  t.Run(\"compare with equal version\", func(t *testing.T) {",
          "27:   comp, err := ComparePluginVersion(\"1.0.1\", \"1.0.1\")",
          "28:   if err != nil || comp != 0 {",
          "29:    t.Fatal(\"expected nil err and comp equal to 0\")",
          "30:   }",
          "31:  })",
          "33:  t.Run(\"failed due to invalid semantic version\", func(t *testing.T) {",
          "34:   expectedErrMsg := \"v1.0.0 is not a valid semantic version\"",
          "35:   _, err := ComparePluginVersion(\"v1.0.0\", \"1.0.1\")",
          "36:   if err == nil || err.Error() != expectedErrMsg {",
          "37:    t.Fatalf(\"expected err %s, but got %s\", expectedErrMsg, err)",
          "38:   }",
          "39:  })",
          "40: }",
          "",
          "---------------"
        ],
        "plugin/errors.go||plugin/errors.go": [
          "File: plugin/errors.go -> plugin/errors.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "14: package plugin",
          "16: import \"errors\"",
          "20: var ErrNotCompliant = errors.New(\"plugin not compliant\")",
          "23: var ErrNotRegularFile = errors.New(\"not regular file\")",
          "27: type PluginDowngradeError struct {",
          "28:  Msg string",
          "29: }",
          "31: func (e PluginDowngradeError) Error() string {",
          "32:  if e.Msg != \"\" {",
          "33:   return e.Msg",
          "34:  }",
          "35:  return \"installing plugin with version lower than the existing plugin version\"",
          "36: }",
          "40: type InstallEqualVersionError struct {",
          "41:  Msg string",
          "42: }",
          "44: func (e InstallEqualVersionError) Error() string {",
          "45:  if e.Msg != \"\" {",
          "46:   return e.Msg",
          "47:  }",
          "48:  return \"installing plugin with version equal to the existing plugin version\"",
          "49: }",
          "",
          "---------------"
        ],
        "plugin/manager.go||plugin/manager.go": [
          "File: plugin/manager.go -> plugin/manager.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: import (",
          "17:  \"context\"",
          "18:  \"errors\"",
          "19:  \"io/fs\"",
          "20:  \"os\"",
          "21:  \"path\"",
          "23:  \"github.com/notaryproject/notation-go/dir\"",
          "24: )",
          "34: type Manager interface {",
          "35:  Get(ctx context.Context, name string) (Plugin, error)",
          "",
          "[Removed Lines]",
          "28: var ErrNotCompliant = errors.New(\"plugin not compliant\")",
          "31: var ErrNotRegularFile = errors.New(\"not regular file\")",
          "",
          "[Added Lines]",
          "19:  \"fmt\"",
          "23:  \"path/filepath\"",
          "26:  \"github.com/notaryproject/notation-go/internal/file\"",
          "27:  \"github.com/notaryproject/notation-go/internal/semver\"",
          "28:  \"github.com/notaryproject/notation-go/plugin/proto\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "84:  return plugins, nil",
          "85: }",
          "89: func (m *CLIManager) Uninstall(ctx context.Context, name string) error {",
          "90:  pluginDirPath, err := m.pluginFS.SysPath(name)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "86: type CLIInstallOptions struct {",
          "96:  PluginPath string",
          "99:  Overwrite bool",
          "100: }",
          "115: func (m *CLIManager) Install(ctx context.Context, installOpts CLIInstallOptions) (*proto.GetMetadataResponse, *proto.GetMetadataResponse, error) {",
          "117:  overwrite := installOpts.Overwrite",
          "118:  if installOpts.PluginPath == \"\" {",
          "119:   return nil, nil, errors.New(\"plugin source path cannot be empty\")",
          "120:  }",
          "121:  var installFromNonDir bool",
          "122:  pluginExecutableFile, pluginName, err := parsePluginFromDir(installOpts.PluginPath)",
          "123:  if err != nil {",
          "124:   if !errors.Is(err, file.ErrNotDirectory) {",
          "125:    return nil, nil, fmt.Errorf(\"failed to read plugin from directory %s: %w\", installOpts.PluginPath, err)",
          "126:   }",
          "128:   installFromNonDir = true",
          "129:   pluginExecutableFile = installOpts.PluginPath",
          "130:   pluginName, err = ParsePluginName(filepath.Base(pluginExecutableFile))",
          "131:   if err != nil {",
          "132:    return nil, nil, fmt.Errorf(\"failed to read plugin name from file path %s: %w\", pluginExecutableFile, err)",
          "133:   }",
          "134:   isExec, err := isExecutableFile(pluginExecutableFile)",
          "135:   if err != nil {",
          "136:    return nil, nil, fmt.Errorf(\"failed to check if file %s is executable: %w\", pluginExecutableFile, err)",
          "137:   }",
          "138:   if !isExec {",
          "139:    return nil, nil, fmt.Errorf(\"file %s is not executable\", pluginExecutableFile)",
          "140:   }",
          "141:  }",
          "143:  if err := validatePluginFileExtensionAgainstOS(filepath.Base(pluginExecutableFile), pluginName); err != nil {",
          "144:   return nil, nil, err",
          "145:  }",
          "146:  newPlugin, err := NewCLIPlugin(ctx, pluginName, pluginExecutableFile)",
          "147:  if err != nil {",
          "148:   return nil, nil, fmt.Errorf(\"failed to create new CLI plugin: %w\", err)",
          "149:  }",
          "150:  newPluginMetadata, err := newPlugin.GetMetadata(ctx, &proto.GetMetadataRequest{})",
          "151:  if err != nil {",
          "152:   return nil, nil, fmt.Errorf(\"failed to get metadata of new plugin: %w\", err)",
          "153:  }",
          "155:  var existingPluginMetadata *proto.GetMetadataResponse",
          "156:  existingPlugin, err := m.Get(ctx, pluginName)",
          "157:  if err != nil {",
          "159:   if !errors.Is(err, os.ErrNotExist) && !overwrite {",
          "160:    return nil, nil, fmt.Errorf(\"failed to check plugin existence: %w\", err)",
          "161:   }",
          "162:  } else { // plugin already exists",
          "163:   existingPluginMetadata, err = existingPlugin.GetMetadata(ctx, &proto.GetMetadataRequest{})",
          "164:   if err != nil && !overwrite { // fail only if overwrite is not set",
          "165:    return nil, nil, fmt.Errorf(\"failed to get metadata of existing plugin: %w\", err)",
          "166:   }",
          "168:   if !overwrite {",
          "169:    comp, err := semver.ComparePluginVersion(newPluginMetadata.Version, existingPluginMetadata.Version)",
          "170:    if err != nil {",
          "171:     return nil, nil, fmt.Errorf(\"failed to compare plugin versions: %w\", err)",
          "172:    }",
          "173:    switch {",
          "174:    case comp < 0:",
          "175:     return nil, nil, PluginDowngradeError{Msg: fmt.Sprintf(\"failed to install plugin %s. The installing plugin version %s is lower than the existing plugin version %s\", pluginName, newPluginMetadata.Version, existingPluginMetadata.Version)}",
          "176:    case comp == 0:",
          "177:     return nil, nil, InstallEqualVersionError{Msg: fmt.Sprintf(\"plugin %s with version %s already exists\", pluginName, existingPluginMetadata.Version)}",
          "178:    }",
          "179:   }",
          "180:  }",
          "182:  if err := m.Uninstall(ctx, pluginName); err != nil {",
          "183:   if !errors.Is(err, os.ErrNotExist) {",
          "184:    return nil, nil, fmt.Errorf(\"failed to clean up plugin %s before installation: %w\", pluginName, err)",
          "185:   }",
          "186:  }",
          "188:  pluginDirPath, err := m.pluginFS.SysPath(pluginName)",
          "189:  if err != nil {",
          "190:   return nil, nil, fmt.Errorf(\"failed to get the system path of plugin %s: %w\", pluginName, err)",
          "191:  }",
          "192:  if installFromNonDir {",
          "193:   if err := file.CopyToDir(pluginExecutableFile, pluginDirPath); err != nil {",
          "194:    return nil, nil, fmt.Errorf(\"failed to copy plugin executable file from %s to %s: %w\", pluginExecutableFile, pluginDirPath, err)",
          "195:   }",
          "196:  } else {",
          "197:   if err := file.CopyDirToDir(installOpts.PluginPath, pluginDirPath); err != nil {",
          "198:    return nil, nil, fmt.Errorf(\"failed to copy plugin files from %s to %s: %w\", installOpts.PluginPath, pluginDirPath, err)",
          "199:   }",
          "200:  }",
          "201:  return existingPluginMetadata, newPluginMetadata, nil",
          "202: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "96:  }",
          "97:  return os.RemoveAll(pluginDirPath)",
          "98: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "223: func parsePluginFromDir(path string) (string, string, error) {",
          "225:  fi, err := os.Stat(path)",
          "226:  if err != nil {",
          "227:   return \"\", \"\", err",
          "228:  }",
          "229:  if !fi.Mode().IsDir() {",
          "230:   return \"\", \"\", file.ErrNotDirectory",
          "231:  }",
          "233:  var pluginExecutableFile, pluginName string",
          "234:  var foundPluginExecutableFile bool",
          "235:  if err := filepath.WalkDir(path, func(p string, d fs.DirEntry, err error) error {",
          "236:   if err != nil {",
          "237:    return err",
          "238:   }",
          "240:   if d.IsDir() && d.Name() != filepath.Base(path) {",
          "241:    return fs.SkipDir",
          "242:   }",
          "243:   info, err := d.Info()",
          "244:   if err != nil {",
          "245:    return err",
          "246:   }",
          "248:   if info.Mode().IsRegular() {",
          "249:    if pluginName, err = ParsePluginName(d.Name()); err != nil {",
          "252:     return nil",
          "253:    }",
          "254:    isExec, err := isExecutableFile(p)",
          "255:    if err != nil {",
          "256:     return err",
          "257:    }",
          "258:    if !isExec {",
          "259:     return nil",
          "260:    }",
          "261:    if foundPluginExecutableFile {",
          "262:     return errors.New(\"found more than one plugin executable files\")",
          "263:    }",
          "264:    foundPluginExecutableFile = true",
          "265:    pluginExecutableFile = p",
          "266:   }",
          "267:   return nil",
          "268:  }); err != nil {",
          "269:   return \"\", \"\", err",
          "270:  }",
          "271:  if !foundPluginExecutableFile {",
          "272:   return \"\", \"\", errors.New(\"no plugin executable file was found\")",
          "273:  }",
          "274:  return pluginExecutableFile, pluginName, nil",
          "275: }",
          "",
          "---------------"
        ],
        "plugin/manager_test.go||plugin/manager_test.go": [
          "File: plugin/manager_test.go -> plugin/manager_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:  \"encoding/json\"",
          "19:  \"io/fs\"",
          "20:  \"os\"",
          "21:  \"reflect\"",
          "22:  \"testing\"",
          "23:  \"testing/fstest\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "21:  \"path/filepath\"",
          "23:  \"runtime\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "36:  return t.stdout, t.stderr, t.err",
          "37: }",
          "39: var validMetadata = proto.GetMetadataResponse{",
          "41:  SupportedContractVersions: []string{\"1.0\"}, Capabilities: []proto.Capability{proto.CapabilitySignatureGenerator},",
          "42: }",
          "",
          "[Removed Lines]",
          "40:  Name: \"foo\", Description: \"friendly\", Version: \"1\", URL: \"example.com\",",
          "",
          "[Added Lines]",
          "41: type testInstallCommander struct {",
          "42:  existedPluginFilePath string",
          "43:  existedPluginStdout   []byte",
          "44:  existedPluginStderr   []byte",
          "45:  existedPluginErr      error",
          "46:  newPluginFilePath     string",
          "47:  newPluginStdout       []byte",
          "48:  newPluginStderr       []byte",
          "49:  newPluginErr          error",
          "50:  err                   error",
          "51: }",
          "53: func (t testInstallCommander) Output(ctx context.Context, path string, command proto.Command, req []byte) ([]byte, []byte, error) {",
          "54:  if path == t.existedPluginFilePath {",
          "55:   return t.existedPluginStdout, t.existedPluginStderr, t.existedPluginErr",
          "56:  }",
          "57:  if path == t.newPluginFilePath {",
          "58:   return t.newPluginStdout, t.newPluginStderr, t.newPluginErr",
          "59:  }",
          "60:  return nil, nil, t.err",
          "61: }",
          "64:  Name: \"foo\", Description: \"friendly\", Version: \"1.0.0\", URL: \"example.com\",",
          "65:  SupportedContractVersions: []string{\"1.0\"}, Capabilities: []proto.Capability{proto.CapabilitySignatureGenerator},",
          "66: }",
          "68: var validMetadataHigherVersion = proto.GetMetadataResponse{",
          "69:  Name: \"foo\", Description: \"friendly\", Version: \"1.1.0\", URL: \"example.com\",",
          "70:  SupportedContractVersions: []string{\"1.0\"}, Capabilities: []proto.Capability{proto.CapabilitySignatureGenerator},",
          "71: }",
          "73: var validMetadataLowerVersion = proto.GetMetadataResponse{",
          "74:  Name: \"foo\", Description: \"friendly\", Version: \"0.1.0\", URL: \"example.com\",",
          "75:  SupportedContractVersions: []string{\"1.0\"}, Capabilities: []proto.Capability{proto.CapabilitySignatureGenerator},",
          "76: }",
          "78: var validMetadataBar = proto.GetMetadataResponse{",
          "79:  Name: \"bar\", Description: \"friendly\", Version: \"1.0.0\", URL: \"example.com\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "52: }",
          "54: func TestManager_Get(t *testing.T) {",
          "55:  executor = testCommander{stdout: metadataJSON(validMetadata)}",
          "56:  mgr := NewCLIManager(mockfs.NewSysFSWithRootMock(fstest.MapFS{}, \"./testdata/plugins\"))",
          "57:  _, err := mgr.Get(context.Background(), \"foo\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "94:  if runtime.GOOS == \"windows\" {",
          "95:   t.Skip(\"skipping test on Windows\")",
          "96:  }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "88:  })",
          "89: }",
          "91: func TestManager_Uninstall(t *testing.T) {",
          "92:  executor = testCommander{stdout: metadataJSON(validMetadata)}",
          "93:  mgr := NewCLIManager(mockfs.NewSysFSWithRootMock(fstest.MapFS{}, \"./testdata/plugins\"))",
          "94:  if err := os.MkdirAll(\"./testdata/plugins/toUninstall\", 0777); err != nil {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "133: func TestManager_Install(t *testing.T) {",
          "134:  if runtime.GOOS == \"windows\" {",
          "135:   t.Skip(\"skipping test on Windows\")",
          "136:  }",
          "137:  existedPluginFilePath := \"testdata/plugins/foo/notation-foo\"",
          "138:  newPluginFilePath := \"testdata/foo/notation-foo\"",
          "139:  newPluginDir := filepath.Dir(newPluginFilePath)",
          "140:  if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "141:   t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "142:  }",
          "143:  defer os.RemoveAll(newPluginDir)",
          "144:  if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "145:   t.Fatal(err)",
          "146:  }",
          "147:  mgr := NewCLIManager(mockfs.NewSysFSWithRootMock(fstest.MapFS{}, \"testdata/plugins\"))",
          "149:  t.Run(\"success install with higher version\", func(t *testing.T) {",
          "150:   executor = testInstallCommander{",
          "151:    existedPluginFilePath: existedPluginFilePath,",
          "152:    newPluginFilePath:     newPluginFilePath,",
          "153:    existedPluginStdout:   metadataJSON(validMetadata),",
          "154:    newPluginStdout:       metadataJSON(validMetadataHigherVersion),",
          "155:   }",
          "156:   installOpts := CLIInstallOptions{",
          "157:    PluginPath: newPluginFilePath,",
          "158:   }",
          "159:   existingPluginMetadata, newPluginMetadata, err := mgr.Install(context.Background(), installOpts)",
          "160:   if err != nil {",
          "161:    t.Fatalf(\"expecting error to be nil, but got %v\", err)",
          "162:   }",
          "163:   if existingPluginMetadata.Version != validMetadata.Version {",
          "164:    t.Fatalf(\"existing plugin version mismatch, existing plugin version: %s, but got: %s\", validMetadata.Version, existingPluginMetadata.Version)",
          "165:   }",
          "166:   if newPluginMetadata.Version != validMetadataHigherVersion.Version {",
          "167:    t.Fatalf(\"new plugin version mismatch, new plugin version: %s, but got: %s\", validMetadataHigherVersion.Version, newPluginMetadata.Version)",
          "168:   }",
          "169:  })",
          "171:  t.Run(\"success install with lower version and overwrite\", func(t *testing.T) {",
          "172:   executor = testInstallCommander{",
          "173:    existedPluginFilePath: existedPluginFilePath,",
          "174:    newPluginFilePath:     newPluginFilePath,",
          "175:    existedPluginStdout:   metadataJSON(validMetadata),",
          "176:    newPluginStdout:       metadataJSON(validMetadataLowerVersion),",
          "177:   }",
          "178:   installOpts := CLIInstallOptions{",
          "179:    PluginPath: newPluginFilePath,",
          "180:    Overwrite:  true,",
          "181:   }",
          "182:   if _, _, err := mgr.Install(context.Background(), installOpts); err != nil {",
          "183:    t.Fatalf(\"expecting error to be nil, but got %v\", err)",
          "184:   }",
          "185:  })",
          "187:  t.Run(\"success install without existing plugin\", func(t *testing.T) {",
          "188:   newPluginFilePath := \"testdata/bar/notation-bar\"",
          "189:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "190:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "191:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "192:   }",
          "193:   defer os.RemoveAll(newPluginDir)",
          "194:   if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "195:    t.Fatal(err)",
          "196:   }",
          "197:   executor = testInstallCommander{",
          "198:    newPluginFilePath: newPluginFilePath,",
          "199:    newPluginStdout:   metadataJSON(validMetadataBar),",
          "200:   }",
          "201:   defer mgr.Uninstall(context.Background(), \"bar\")",
          "202:   installOpts := CLIInstallOptions{",
          "203:    PluginPath: newPluginFilePath,",
          "204:   }",
          "205:   existingPluginMetadata, newPluginMetadata, err := mgr.Install(context.Background(), installOpts)",
          "206:   if err != nil {",
          "207:    t.Fatalf(\"expecting error to be nil, but got %v\", err)",
          "208:   }",
          "209:   if existingPluginMetadata != nil {",
          "210:    t.Fatalf(\"expecting existingPluginMetadata to be nil, but got %v\", existingPluginMetadata)",
          "211:   }",
          "212:   if newPluginMetadata.Version != validMetadataBar.Version {",
          "213:    t.Fatalf(\"new plugin version mismatch, new plugin version: %s, but got: %s\", validMetadataBar.Version, newPluginMetadata.Version)",
          "214:   }",
          "215:  })",
          "217:  t.Run(\"fail to install due to equal version\", func(t *testing.T) {",
          "218:   executor = testInstallCommander{",
          "219:    existedPluginFilePath: existedPluginFilePath,",
          "220:    newPluginFilePath:     newPluginFilePath,",
          "221:    existedPluginStdout:   metadataJSON(validMetadata),",
          "222:    newPluginStdout:       metadataJSON(validMetadata),",
          "223:   }",
          "224:   installOpts := CLIInstallOptions{",
          "225:    PluginPath: newPluginFilePath,",
          "226:   }",
          "227:   expectedErrorMsg := \"plugin foo with version 1.0.0 already exists\"",
          "228:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "229:   if err == nil || err.Error() != expectedErrorMsg {",
          "230:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "231:   }",
          "232:  })",
          "234:  t.Run(\"fail to install due to lower version\", func(t *testing.T) {",
          "235:   executor = testInstallCommander{",
          "236:    existedPluginFilePath: existedPluginFilePath,",
          "237:    newPluginFilePath:     newPluginFilePath,",
          "238:    existedPluginStdout:   metadataJSON(validMetadata),",
          "239:    newPluginStdout:       metadataJSON(validMetadataLowerVersion),",
          "240:   }",
          "241:   installOpts := CLIInstallOptions{",
          "242:    PluginPath: newPluginFilePath,",
          "243:   }",
          "244:   expectedErrorMsg := \"failed to install plugin foo. The installing plugin version 0.1.0 is lower than the existing plugin version 1.0.0\"",
          "245:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "246:   if err == nil || err.Error() != expectedErrorMsg {",
          "247:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "248:   }",
          "249:  })",
          "251:  t.Run(\"fail to install due to wrong plugin executable file name format\", func(t *testing.T) {",
          "252:   newPluginFilePath := \"testdata/bar/bar\"",
          "253:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "254:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "255:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "256:   }",
          "257:   defer os.RemoveAll(newPluginDir)",
          "258:   if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "259:    t.Fatal(err)",
          "260:   }",
          "261:   executor = testInstallCommander{",
          "262:    newPluginFilePath: newPluginFilePath,",
          "263:    newPluginStdout:   metadataJSON(validMetadataBar),",
          "264:   }",
          "265:   installOpts := CLIInstallOptions{",
          "266:    PluginPath: newPluginFilePath,",
          "267:   }",
          "268:   expectedErrorMsg := \"failed to read plugin name from file path testdata/bar/bar: invalid plugin executable file name. Plugin file name requires format notation-{plugin-name}, but got bar\"",
          "269:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "270:   if err == nil || err.Error() != expectedErrorMsg {",
          "271:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "272:   }",
          "273:  })",
          "275:  t.Run(\"fail to install due to wrong plugin file permission\", func(t *testing.T) {",
          "276:   newPluginFilePath := \"testdata/bar/notation-bar\"",
          "277:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "278:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "279:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "280:   }",
          "281:   defer os.RemoveAll(newPluginDir)",
          "282:   if err := createFileAndChmod(newPluginFilePath, 0600); err != nil {",
          "283:    t.Fatal(err)",
          "284:   }",
          "285:   executor = testInstallCommander{",
          "286:    newPluginFilePath: newPluginFilePath,",
          "287:    newPluginStdout:   metadataJSON(validMetadataBar),",
          "288:   }",
          "289:   installOpts := CLIInstallOptions{",
          "290:    PluginPath: newPluginFilePath,",
          "291:   }",
          "292:   expectedErrorMsg := \"file testdata/bar/notation-bar is not executable\"",
          "293:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "294:   if err == nil || err.Error() != expectedErrorMsg {",
          "295:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "296:   }",
          "297:  })",
          "299:  t.Run(\"fail to install due to invalid new plugin file extension\", func(t *testing.T) {",
          "300:   newPluginFilePath := \"testdata/bar/notation-bar.exe\"",
          "301:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "302:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "303:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "304:   }",
          "305:   defer os.RemoveAll(newPluginDir)",
          "306:   if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "307:    t.Fatal(err)",
          "308:   }",
          "309:   executor = testInstallCommander{",
          "310:    newPluginFilePath: newPluginFilePath,",
          "311:    newPluginStdout:   metadataJSON(validMetadataBar),",
          "312:   }",
          "313:   installOpts := CLIInstallOptions{",
          "314:    PluginPath: newPluginFilePath,",
          "315:   }",
          "316:   expectedErrorMsg := \"invalid plugin file extension. Expecting file notation-bar, but got notation-bar.exe\"",
          "317:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "318:   if err == nil || err.Error() != expectedErrorMsg {",
          "319:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "320:   }",
          "321:  })",
          "323:  t.Run(\"fail to install due to new plugin executable file does not exist\", func(t *testing.T) {",
          "324:   newPluginFilePath := \"testdata/bar/notation-bar\"",
          "325:   executor = testInstallCommander{",
          "326:    newPluginFilePath: newPluginFilePath,",
          "327:    newPluginStdout:   metadataJSON(validMetadataBar),",
          "328:   }",
          "329:   installOpts := CLIInstallOptions{",
          "330:    PluginPath: newPluginFilePath,",
          "331:   }",
          "332:   expectedErrorMsg := \"failed to read plugin from directory testdata/bar/notation-bar: stat testdata/bar/notation-bar: no such file or directory\"",
          "333:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "334:   if err == nil || err.Error() != expectedErrorMsg {",
          "335:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "336:   }",
          "337:  })",
          "339:  t.Run(\"fail to install due to invalid new plugin metadata\", func(t *testing.T) {",
          "340:   newPluginFilePath := \"testdata/bar/notation-bar\"",
          "341:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "342:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "343:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "344:   }",
          "345:   defer os.RemoveAll(newPluginDir)",
          "346:   if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "347:    t.Fatal(err)",
          "348:   }",
          "349:   executor = testInstallCommander{",
          "350:    newPluginFilePath: newPluginFilePath,",
          "351:    newPluginStdout:   metadataJSON(invalidMetadataName),",
          "352:   }",
          "353:   installOpts := CLIInstallOptions{",
          "354:    PluginPath: newPluginFilePath,",
          "355:   }",
          "356:   expectedErrorMsg := \"failed to get metadata of new plugin: executable name must be \\\"notation-foobar\\\" instead of \\\"notation-bar\\\"\"",
          "357:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "358:   if err == nil || err.Error() != expectedErrorMsg {",
          "359:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "360:   }",
          "361:  })",
          "363:  t.Run(\"fail to install due to invalid existing plugin metadata\", func(t *testing.T) {",
          "364:   executor = testInstallCommander{",
          "365:    existedPluginFilePath: existedPluginFilePath,",
          "366:    newPluginFilePath:     newPluginFilePath,",
          "367:    existedPluginStdout:   metadataJSON(validMetadataBar),",
          "368:    newPluginStdout:       metadataJSON(validMetadata),",
          "369:   }",
          "370:   installOpts := CLIInstallOptions{",
          "371:    PluginPath: newPluginFilePath,",
          "372:   }",
          "373:   expectedErrorMsg := \"failed to get metadata of existing plugin: executable name must be \\\"notation-bar\\\" instead of \\\"notation-foo\\\"\"",
          "374:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "375:   if err == nil || err.Error() != expectedErrorMsg {",
          "376:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "377:   }",
          "378:  })",
          "380:  t.Run(\"success to install with overwrite and invalid existing plugin metadata\", func(t *testing.T) {",
          "381:   executor = testInstallCommander{",
          "382:    existedPluginFilePath: existedPluginFilePath,",
          "383:    newPluginFilePath:     newPluginFilePath,",
          "384:    existedPluginStdout:   metadataJSON(validMetadataBar),",
          "385:    newPluginStdout:       metadataJSON(validMetadata),",
          "386:   }",
          "387:   installOpts := CLIInstallOptions{",
          "388:    PluginPath: newPluginFilePath,",
          "389:    Overwrite:  true,",
          "390:   }",
          "391:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "392:   if err != nil {",
          "393:    t.Fatalf(\"expecting error to be nil, but got %v\", err)",
          "394:   }",
          "395:  })",
          "397:  t.Run(\"success to install from plugin dir\", func(t *testing.T) {",
          "398:   existedPluginFilePath := \"testdata/plugins/foo/notation-foo\"",
          "399:   newPluginFilePath := \"testdata/foo/notation-foo\"",
          "400:   newPluginLibPath := \"testdata/foo/libfoo\"",
          "401:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "402:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "403:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "404:   }",
          "405:   defer os.RemoveAll(newPluginDir)",
          "406:   if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "407:    t.Fatal(err)",
          "408:   }",
          "409:   if err := createFileAndChmod(newPluginLibPath, 0600); err != nil {",
          "410:    t.Fatal(err)",
          "411:   }",
          "412:   executor = testInstallCommander{",
          "413:    existedPluginFilePath: existedPluginFilePath,",
          "414:    newPluginFilePath:     newPluginFilePath,",
          "415:    existedPluginStdout:   metadataJSON(validMetadata),",
          "416:    newPluginStdout:       metadataJSON(validMetadataHigherVersion),",
          "417:   }",
          "418:   installOpts := CLIInstallOptions{",
          "419:    PluginPath: newPluginDir,",
          "420:   }",
          "421:   existingPluginMetadata, newPluginMetadata, err := mgr.Install(context.Background(), installOpts)",
          "422:   if err != nil {",
          "423:    t.Fatalf(\"expecting nil error, but got %v\", err)",
          "424:   }",
          "425:   if existingPluginMetadata.Version != \"1.0.0\" {",
          "426:    t.Fatalf(\"expecting existing plugin metadata to be 1.0.0, but got %s\", existingPluginMetadata.Version)",
          "427:   }",
          "428:   if newPluginMetadata.Version != \"1.1.0\" {",
          "429:    t.Fatalf(\"expecting new plugin metadata to be 1.1.0, but got %s\", newPluginMetadata.Version)",
          "430:   }",
          "431:  })",
          "433:  t.Run(\"fail to install from plugin dir due to no plugin executable file\", func(t *testing.T) {",
          "434:   existedPluginFilePath := \"testdata/plugins/foo/notation-foo\"",
          "435:   newPluginFilePath := \"testdata/foo/foo\"",
          "436:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "437:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "438:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "439:   }",
          "440:   defer os.RemoveAll(newPluginDir)",
          "441:   if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "442:    t.Fatal(err)",
          "443:   }",
          "444:   executor = testInstallCommander{",
          "445:    existedPluginFilePath: existedPluginFilePath,",
          "446:    newPluginFilePath:     newPluginFilePath,",
          "447:    existedPluginStdout:   metadataJSON(validMetadata),",
          "448:    newPluginStdout:       metadataJSON(validMetadataHigherVersion),",
          "449:   }",
          "450:   installOpts := CLIInstallOptions{",
          "451:    PluginPath: newPluginDir,",
          "452:   }",
          "453:   expectedErrorMsg := \"failed to read plugin from directory testdata/foo: no plugin executable file was found\"",
          "454:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "455:   if err == nil || err.Error() != expectedErrorMsg {",
          "456:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "457:   }",
          "458:  })",
          "460:  t.Run(\"fail to install from plugin dir due to more than one plugin executable files\", func(t *testing.T) {",
          "461:   existedPluginFilePath := \"testdata/plugins/foo/notation-foo\"",
          "462:   newPluginFilePath := \"testdata/foo/notation-foo1\"",
          "463:   newPluginFilePath2 := \"testdata/foo/notation-foo2\"",
          "464:   newPluginDir := filepath.Dir(newPluginFilePath)",
          "465:   if err := os.MkdirAll(newPluginDir, 0777); err != nil {",
          "466:    t.Fatalf(\"failed to create %s: %v\", newPluginDir, err)",
          "467:   }",
          "468:   defer os.RemoveAll(newPluginDir)",
          "469:   if err := createFileAndChmod(newPluginFilePath, 0700); err != nil {",
          "470:    t.Fatal(err)",
          "471:   }",
          "472:   if err := createFileAndChmod(newPluginFilePath2, 0700); err != nil {",
          "473:    t.Fatal(err)",
          "474:   }",
          "475:   executor = testInstallCommander{",
          "476:    existedPluginFilePath: existedPluginFilePath,",
          "477:    newPluginFilePath:     newPluginFilePath,",
          "478:    existedPluginStdout:   metadataJSON(validMetadata),",
          "479:    newPluginStdout:       metadataJSON(validMetadataHigherVersion),",
          "480:   }",
          "481:   installOpts := CLIInstallOptions{",
          "482:    PluginPath: newPluginDir,",
          "483:   }",
          "484:   expectedErrorMsg := \"failed to read plugin from directory testdata/foo: found more than one plugin executable files\"",
          "485:   _, _, err := mgr.Install(context.Background(), installOpts)",
          "486:   if err == nil || err.Error() != expectedErrorMsg {",
          "487:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "488:   }",
          "489:  })",
          "490: }",
          "493:  if runtime.GOOS == \"windows\" {",
          "494:   t.Skip(\"skipping test on Windows\")",
          "495:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "120:  }",
          "121:  return d",
          "122: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "528: func createFileAndChmod(path string, mode fs.FileMode) error {",
          "529:  f, err := os.Create(path)",
          "530:  if err != nil {",
          "531:   return err",
          "532:  }",
          "533:  if err := f.Chmod(mode); err != nil {",
          "534:   return err",
          "535:  }",
          "536:  return f.Close()",
          "537: }",
          "",
          "---------------"
        ],
        "plugin/manager_unix.go||plugin/manager_unix.go": [
          "File: plugin/manager_unix.go -> plugin/manager_unix.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "17: package plugin",
          "21: func binName(name string) string {",
          "22:  return proto.Prefix + name",
          "23: }",
          "",
          "[Removed Lines]",
          "19: import \"github.com/notaryproject/notation-go/plugin/proto\"",
          "",
          "[Added Lines]",
          "19: import (",
          "20:  \"os\"",
          "22:  \"github.com/notaryproject/notation-go/plugin/proto\"",
          "23: )",
          "30: func isExecutableFile(filePath string) (bool, error) {",
          "31:  fi, err := os.Stat(filePath)",
          "32:  if err != nil {",
          "33:   return false, err",
          "34:  }",
          "35:  mode := fi.Mode()",
          "36:  if !mode.IsRegular() {",
          "37:   return false, ErrNotRegularFile",
          "38:  }",
          "39:  return mode.Perm()&0100 != 0, nil",
          "40: }",
          "",
          "---------------"
        ],
        "plugin/manager_windows.go||plugin/manager_windows.go": [
          "File: plugin/manager_windows.go -> plugin/manager_windows.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14: package plugin",
          "18: func binName(name string) string {",
          "19:  return proto.Prefix + name + \".exe\"",
          "20: }",
          "",
          "[Removed Lines]",
          "16: import \"github.com/notaryproject/notation-go/plugin/proto\"",
          "",
          "[Added Lines]",
          "16: import (",
          "17:  \"os\"",
          "18:  \"path/filepath\"",
          "19:  \"strings\"",
          "21:  \"github.com/notaryproject/notation-go/plugin/proto\"",
          "22: )",
          "29: func isExecutableFile(filePath string) (bool, error) {",
          "30:  fi, err := os.Stat(filePath)",
          "31:  if err != nil {",
          "32:   return false, err",
          "33:  }",
          "34:  if !fi.Mode().IsRegular() {",
          "35:   return false, ErrNotRegularFile",
          "36:  }",
          "37:  return strings.EqualFold(filepath.Ext(filepath.Base(filePath)), \".exe\"), nil",
          "38: }",
          "",
          "---------------"
        ],
        "plugin/plugin.go||plugin/plugin.go": [
          "File: plugin/plugin.go -> plugin/plugin.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "25:  \"os\"",
          "26:  \"os/exec\"",
          "27:  \"path/filepath\"",
          "29:  \"github.com/notaryproject/notation-go/internal/slices\"",
          "30:  \"github.com/notaryproject/notation-go/log\"",
          "31:  \"github.com/notaryproject/notation-go/plugin/proto\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "28:  \"strings\"",
          "30:  \"github.com/notaryproject/notation-go/internal/file\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "223:  return stdout.Bytes(), nil, nil",
          "224: }",
          "227: func validate(metadata *proto.GetMetadataResponse) error {",
          "228:  if metadata.Name == \"\" {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "230: func ParsePluginName(fileName string) (string, error) {",
          "231:  fname := file.TrimFileExtension(fileName)",
          "232:  pluginName, found := strings.CutPrefix(fname, proto.Prefix)",
          "233:  if !found {",
          "234:   return \"\", fmt.Errorf(\"invalid plugin executable file name. Plugin file name requires format notation-{plugin-name}, but got %s\", fname)",
          "235:  }",
          "236:  return pluginName, nil",
          "237: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "251:  }",
          "252:  return nil",
          "253: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "273: func validatePluginFileExtensionAgainstOS(fileName, pluginName string) error {",
          "274:  expectedPluginFile := binName(pluginName)",
          "275:  if filepath.Ext(fileName) != filepath.Ext(expectedPluginFile) {",
          "276:   return fmt.Errorf(\"invalid plugin file extension. Expecting file %s, but got %s\", expectedPluginFile, fileName)",
          "277:  }",
          "278:  return nil",
          "279: }",
          "",
          "---------------"
        ],
        "plugin/plugin_test.go||plugin/plugin_test.go": [
          "File: plugin/plugin_test.go -> plugin/plugin_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:  \"fmt\"",
          "21:  \"os\"",
          "22:  \"reflect\"",
          "23:  \"strconv\"",
          "24:  \"strings\"",
          "25:  \"testing\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23:  \"runtime\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "270:   }",
          "271:  })",
          "272: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "275: func TestExtractPluginNameFromExecutableFileName(t *testing.T) {",
          "276:  pluginName, err := ParsePluginName(\"notation-my-plugin\")",
          "277:  if err != nil {",
          "278:   t.Fatalf(\"expected nil err, got %v\", err)",
          "279:  }",
          "280:  if pluginName != \"my-plugin\" {",
          "281:   t.Fatalf(\"expected plugin name my-plugin, but got %s\", pluginName)",
          "282:  }",
          "284:  pluginName, err = ParsePluginName(\"notation-my-plugin.exe\")",
          "285:  if err != nil {",
          "286:   t.Fatalf(\"expected nil err, got %v\", err)",
          "287:  }",
          "288:  if pluginName != \"my-plugin\" {",
          "289:   t.Fatalf(\"expected plugin name my-plugin, but got %s\", pluginName)",
          "290:  }",
          "292:  _, err = ParsePluginName(\"myPlugin\")",
          "293:  expectedErrorMsg := \"invalid plugin executable file name. Plugin file name requires format notation-{plugin-name}, but got myPlugin\"",
          "294:  if err == nil || err.Error() != expectedErrorMsg {",
          "295:   t.Fatalf(\"expected %s, got %v\", expectedErrorMsg, err)",
          "296:  }",
          "298:  _, err = ParsePluginName(\"my-plugin\")",
          "299:  expectedErrorMsg = \"invalid plugin executable file name. Plugin file name requires format notation-{plugin-name}, but got my-plugin\"",
          "300:  if err == nil || err.Error() != expectedErrorMsg {",
          "301:   t.Fatalf(\"expected %s, got %v\", expectedErrorMsg, err)",
          "302:  }",
          "303: }",
          "305: func TestValidatePluginFileExtensionAgainstOS(t *testing.T) {",
          "306:  if runtime.GOOS == \"windows\" {",
          "307:   err := validatePluginFileExtensionAgainstOS(\"notation-foo.exe\", \"foo\")",
          "308:   if err != nil {",
          "309:    t.Fatalf(\"expecting nil error, but got %s\", err)",
          "310:   }",
          "312:   err = validatePluginFileExtensionAgainstOS(\"notation-foo\", \"foo\")",
          "313:   expectedErrorMsg := \"invalid plugin file extension. Expecting file notation-foo.exe, but got notation-foo\"",
          "314:   if err == nil || err.Error() != expectedErrorMsg {",
          "315:    t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "316:   }",
          "317:   return",
          "318:  }",
          "319:  err := validatePluginFileExtensionAgainstOS(\"notation-foo\", \"foo\")",
          "320:  if err != nil {",
          "321:   t.Fatalf(\"expecting nil error, but got %s\", err)",
          "322:  }",
          "324:  err = validatePluginFileExtensionAgainstOS(\"notation-foo.exe\", \"foo\")",
          "325:  expectedErrorMsg := \"invalid plugin file extension. Expecting file notation-foo, but got notation-foo.exe\"",
          "326:  if err == nil || err.Error() != expectedErrorMsg {",
          "327:   t.Fatalf(\"expecting error %s, but got %v\", expectedErrorMsg, err)",
          "328:  }",
          "329: }",
          "",
          "---------------"
        ],
        "verifier/helpers.go||verifier/helpers.go": [
          "File: verifier/helpers.go -> verifier/helpers.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "18:  \"crypto/x509\"",
          "19:  \"errors\"",
          "20:  \"fmt\"",
          "22:  \"strings\"",
          "24:  \"github.com/notaryproject/notation-core-go/signature\"",
          "25:  \"github.com/notaryproject/notation-go\"",
          "26:  set \"github.com/notaryproject/notation-go/internal/container\"",
          "27:  \"github.com/notaryproject/notation-go/internal/slices\"",
          "28:  \"github.com/notaryproject/notation-go/verifier/trustpolicy\"",
          "29:  \"github.com/notaryproject/notation-go/verifier/truststore\"",
          "",
          "[Removed Lines]",
          "21:  \"regexp\"",
          "",
          "[Added Lines]",
          "26:  notationsemver \"github.com/notaryproject/notation-go/internal/semver\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: var errExtendedAttributeNotExist = errors.New(\"extended attribute not exist\")",
          "53: func loadX509TrustStores(ctx context.Context, scheme signature.SigningScheme, policy *trustpolicy.TrustPolicy, x509TrustStore truststore.X509TrustStore) ([]*x509.Certificate, error) {",
          "54:  var typeToLoad truststore.Type",
          "55:  switch scheme {",
          "",
          "[Removed Lines]",
          "51: var semVerRegEx = regexp.MustCompile(`^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$`)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "152:  if strings.TrimSpace(version) == \"\" {",
          "153:   return \"\", fmt.Errorf(\"%v from extended attribute is an empty string\", HeaderVerificationPluginMinVersion)",
          "154:  }",
          "156:   return \"\", fmt.Errorf(\"%v from extended attribute is not a valid SemVer\", HeaderVerificationPluginMinVersion)",
          "157:  }",
          "158:  return version, nil",
          "159: }",
          "",
          "[Removed Lines]",
          "155:  if !isVersionSemverValid(version) {",
          "161: func isVersionSemverValid(version string) bool {",
          "162:  return semVerRegEx.MatchString(version)",
          "163: }",
          "",
          "[Added Lines]",
          "152:  if !notationsemver.IsValid(version) {",
          "",
          "---------------"
        ],
        "verifier/verifier.go||verifier/verifier.go": [
          "File: verifier/verifier.go -> verifier/verifier.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "32:  \"github.com/notaryproject/notation-go/dir\"",
          "33:  \"github.com/notaryproject/notation-go/internal/envelope\"",
          "34:  \"github.com/notaryproject/notation-go/internal/pkix\"",
          "35:  \"github.com/notaryproject/notation-go/internal/slices\"",
          "36:  trustpolicyInternal \"github.com/notaryproject/notation-go/internal/trustpolicy\"",
          "37:  \"github.com/notaryproject/notation-go/log\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "35:  notationsemver \"github.com/notaryproject/notation-go/internal/semver\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "231:   pluginVersion := metadata.Version",
          "235:    return notation.ErrorVerificationInconclusive{Msg: fmt.Sprintf(\"plugin %s has pluginVersion %s which is not in valid semver format\", verificationPluginName, pluginVersion)}",
          "236:   }",
          "",
          "[Removed Lines]",
          "234:   if !isVersionSemverValid(pluginVersion) {",
          "",
          "[Added Lines]",
          "235:   if !notationsemver.IsValid(pluginVersion) {",
          "",
          "---------------"
        ]
      }
    }
  ]
}
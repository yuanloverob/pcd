{
  "cve_id": "CVE-2024-45339",
  "cve_desc": "When logs are written to a widely-writable directory (the default), an unprivileged attacker may predict a privileged process's log file path and pre-create a symbolic link to a sensitive file in its place. When that privileged process runs, it will follow the planted symlink and overwrite that sensitive file. To fix that, glog now causes the program to exit (with status code 2) when it finds that the configured log file already exists.",
  "repo": "golang/glog",
  "patch_hash": "b8741656e406e66d6992bc2c9575e460ecaa0ec2",
  "patch_info": {
    "commit_hash": "b8741656e406e66d6992bc2c9575e460ecaa0ec2",
    "repo": "golang/glog",
    "commit_url": "https://github.com/golang/glog/pull/74/commits/b8741656e406e66d6992bc2c9575e460ecaa0ec2",
    "files": [
      "glog_file.go",
      "glog_test.go"
    ],
    "message": "glog: have createInDir fail if the file already exists\n\nThis prevents an attack like the one described\n[here](https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File#:~:text=On%20Unix%20based,with%20elevated%20permissions.).\nAn unprivileged attacker could use symlinks to trick a privileged\nlogging process to follow a symlink from the log dir and write logs over\nan arbitrary file.\n\nThe components of the log names are program, host, username, tag, date,\ntime and PID. These are all predictable. It's not at all unusual for the\nlogdir to be writable by unprivileged users, and one of the fallback\ndirectories (/tmp) traditionally has broad write privs with the sticky\nbit set on Unix systems.\n\nAs a concrete example, let's say I've got a glog-enabled binary running\nas a root cronjob. I can gauge when that cron job will run and then use\na bash script to spray the log dir with glog-looking symlinks to\n`/etc/shadow` with predicted times and PIDs. When the cronjob runs, the\n`os.Create` call will follow the symlink, truncate `/etc/shadow` and\nthen fill it with logs.\n\nThis change defeats that by setting `O_EXCL`, which will cause the open\ncall to fail if the file already exists.\n\nFixes CVE-2024-45339\n\ncl/712795111 (google-internal)",
    "before_after_code_files": [
      "glog_file.go||glog_file.go",
      "glog_test.go||glog_test.go"
    ]
  },
  "patch_diff": {
    "glog_file.go||glog_file.go": [
      "File: glog_file.go -> glog_file.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "143: func createInDir(dir, tag string, t time.Time) (f *os.File, name string, err error) {",
      "144:  name, link := logName(tag, t)",
      "145:  fname := filepath.Join(dir, name)",
      "147:  if err == nil {",
      "148:   symlink := filepath.Join(dir, link)",
      "149:   os.Remove(symlink)        // ignore err",
      "",
      "[Removed Lines]",
      "146:  f, err = os.Create(fname)",
      "",
      "[Added Lines]",
      "151:  f, err = os.OpenFile(fname, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)",
      "",
      "---------------"
    ],
    "glog_test.go||glog_test.go": [
      "File: glog_test.go -> glog_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "772:    len(c), logsink.MaxLogMessageLen, c)",
      "773:  }",
      "774: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "776: func TestCreateFailsIfExists(t *testing.T) {",
      "777:  tmp := t.TempDir()",
      "778:  now := time.Now()",
      "779:  if _, _, err := create(\"INFO\", now, tmp); err != nil {",
      "780:   t.Errorf(\"create() failed on first call: %v\", err)",
      "781:  }",
      "782:  if _, _, err := create(\"INFO\", now, tmp); err == nil {",
      "783:   t.Errorf(\"create() succeeded on second call, want error\")",
      "784:  }",
      "785: }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "dd58629ba6ced28322bcb149ed86016fb1ec9a5b",
      "candidate_info": {
        "commit_hash": "dd58629ba6ced28322bcb149ed86016fb1ec9a5b",
        "repo": "golang/glog",
        "commit_url": "https://github.com/golang/glog/commit/dd58629ba6ced28322bcb149ed86016fb1ec9a5b",
        "files": [
          "glog_file.go",
          "glog_test.go"
        ],
        "message": "glog: Don't try to create/rotate a given syncBuffer twice in the same second\n\nIf you do, then you truncate the existing file. So logging too much too quickly would lose log data.\n\ncl/709080575 (google-internal)",
        "before_after_code_files": [
          "glog_file.go||glog_file.go",
          "glog_test.go||glog_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_pr": 1,
        "olp_pr_links": [
          "https://github.com/golang/glog/pull/74"
        ],
        "olp_code_files": {
          "patch": [
            "glog_file.go||glog_file.go",
            "glog_test.go||glog_test.go"
          ],
          "candidate": [
            "glog_file.go||glog_file.go",
            "glog_test.go||glog_test.go"
          ]
        }
      },
      "candidate_diff": {
        "glog_file.go||glog_file.go": [
          "File: glog_file.go -> glog_file.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "248:  names  []string",
          "249:  sev    logsink.Severity",
          "250:  nbytes uint64 // The number of bytes written to this file",
          "251: }",
          "253: func (sb *syncBuffer) Sync() error {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "251:  madeAt time.Time",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "255: }",
          "257: func (sb *syncBuffer) Write(p []byte) (n int, err error) {",
          "258:  if sb.nbytes+uint64(len(p)) >= MaxSize {",
          "261:   }",
          "262:  }",
          "263:  n, err = sb.Writer.Write(p)",
          "",
          "[Removed Lines]",
          "259:   if err := sb.rotateFile(time.Now()); err != nil {",
          "260:    return 0, err",
          "",
          "[Added Lines]",
          "262:   now := timeNow()",
          "263:   if now.After(sb.madeAt.Add(1*time.Second)) || now.Second() != sb.madeAt.Second() {",
          "264:    if err := sb.rotateFile(now); err != nil {",
          "265:     return 0, err",
          "266:    }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "276:  var err error",
          "277:  pn := \"<none>\"",
          "278:  file, name, err := create(sb.sev.String(), now)",
          "280:  if sb.file != nil {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "285:  sb.madeAt = now",
          "",
          "---------------"
        ],
        "glog_test.go||glog_test.go": [
          "File: glog_test.go -> glog_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "522: func TestRollover(t *testing.T) {",
          "523:  setFlags()",
          "525:  Info(\"x\") // Be sure we have a file.",
          "526:  info, ok := sinks.file.file[logsink.Info].(*syncBuffer)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "524:  defer func(previous func() time.Time) { timeNow = previous }(timeNow)",
          "527:  fakeNow := time.Date(2024, 12, 23, 1, 23, 45, 0, time.Local)",
          "528:  timeNow = func() time.Time {",
          "529:   return fakeNow",
          "530:  }",
          "532:  tick := func(d time.Duration) {",
          "533:   fakeNow = fakeNow.Add(d)",
          "534:  }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "528:   t.Fatal(\"info wasn't created\")",
          "529:  }",
          "540:  info.Flush()",
          "541:  fi, err := info.file.Stat()",
          "",
          "[Removed Lines]",
          "537:  time.Sleep(1 * time.Second)",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "551:  fname0 := info.file.Name()",
          "554:  Info(longMessage)",
          "555:  Info(longMessage)",
          "556:  info.Flush()",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "558:  tick(1500 * time.Millisecond)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "612:  n, err := Names(\"INFO\")",
          "614:   t.Errorf(\"Names(INFO) wanted [%s, %s]/nil, got %v/%v\", fname0, fname1, n, err)",
          "615:  }",
          "617:  if t.Failed() {",
          "620:  }",
          "621: }",
          "623: func TestLogBacktraceAt(t *testing.T) {",
          "",
          "[Removed Lines]",
          "613:  if len(n) != 2 && err != nil && n[0] != fname0 && n[1] != fname1 {",
          "618:   t.Logf(\"%v:\\n%q\", fname0, f0)",
          "619:   t.Logf(\"%v:\\n%q\", fname1, f1)",
          "",
          "[Added Lines]",
          "618:  if (len(n) != 2 || err != nil) && n[0] != fname0 && n[1] != fname1 {",
          "623:  if fakeNow.Nanosecond() != 5e8 {",
          "624:   t.Fatalf(\"BUG: fake clock should be exactly at .5 seconds\")",
          "625:  }",
          "628:  tick(499 * time.Millisecond)",
          "629:  Info(longMessage)",
          "630:  Info(longMessage)",
          "631:  n, err = Names(\"INFO\")",
          "632:  if got, want := len(n), 2; got != want || err != nil {",
          "633:   t.Errorf(\"Names(INFO) = %v (len=%v), %v, want %d names: expected no rotation within same second\", n, got, err, want)",
          "634:  }",
          "637:  tick(1 * time.Millisecond)",
          "638:  Info(longMessage)",
          "639:  Info(longMessage)",
          "640:  n, err = Names(\"INFO\")",
          "641:  if got, want := len(n), 3; got != want || err != nil {",
          "642:   t.Errorf(\"Names(INFO) = %v (len=%v), %v, want %d names: expected a rotation after under a second when filename does not conflict\", n, got, err, want)",
          "643:  }",
          "646:  tick(time.Minute)",
          "647:  Info(longMessage)",
          "648:  Info(longMessage)",
          "649:  n, err = Names(\"INFO\")",
          "650:  if got, want := len(n), 4; got != want || err != nil {",
          "651:   t.Errorf(\"Names(INFO) = %v (len=%v), %v, want %d names: expected a rotation after one minute since last rotation\", n, got, err, want)",
          "652:  }",
          "655:   t.Logf(\"========================================================\")",
          "656:   t.Logf(\"%s:\\n%s\", fname0, f0)",
          "657:   t.Logf(\"========================================================\")",
          "658:   t.Logf(\"%s:\\n%s\", fname1, f1)",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a0e3c40a0ed0cecc58c84e7684d9ce55a54044ee",
      "candidate_info": {
        "commit_hash": "a0e3c40a0ed0cecc58c84e7684d9ce55a54044ee",
        "repo": "golang/glog",
        "commit_url": "https://github.com/golang/glog/commit/a0e3c40a0ed0cecc58c84e7684d9ce55a54044ee",
        "files": [
          "glog_file.go",
          "glog_test.go"
        ],
        "message": "glog: have createInDir fail if the file already exists\n\nThis prevents an attack like the one described\n[here](https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File#:~:text=On%20Unix%20based,with%20elevated%20permissions.).\nAn unprivileged attacker could use symlinks to trick a privileged\nlogging process to follow a symlink from the log dir and write logs over\nan arbitrary file.\n\nThe components of the log names are program, host, username, tag, date,\ntime and PID. These are all predictable. It's not at all unusual for the\nlogdir to be writable by unprivileged users, and one of the fallback\ndirectories (/tmp) traditionally has broad write privs with the sticky\nbit set on Unix systems.\n\nAs a concrete example, let's say I've got a glog-enabled binary running\nas a root cronjob. I can gauge when that cron job will run and then use\na bash script to spray the log dir with glog-looking symlinks to\n`/etc/shadow` with predicted times and PIDs. When the cronjob runs, the\n`os.Create` call will follow the symlink, truncate `/etc/shadow` and\nthen fill it with logs.\n\nThis change defeats that by setting `O_EXCL`, which will cause the open\ncall to fail if the file already exists.\n\nFixes CVE-2024-45339\n\ncl/712795111 (google-internal)",
        "before_after_code_files": [
          "glog_file.go||glog_file.go",
          "glog_test.go||glog_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "glog_file.go||glog_file.go",
            "glog_test.go||glog_test.go"
          ],
          "candidate": [
            "glog_file.go||glog_file.go",
            "glog_test.go||glog_test.go"
          ]
        }
      },
      "candidate_diff": {
        "glog_file.go||glog_file.go": [
          "File: glog_file.go -> glog_file.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "143: func createInDir(dir, tag string, t time.Time) (f *os.File, name string, err error) {",
          "144:  name, link := logName(tag, t)",
          "145:  fname := filepath.Join(dir, name)",
          "147:  if err == nil {",
          "148:   symlink := filepath.Join(dir, link)",
          "149:   os.Remove(symlink)        // ignore err",
          "",
          "[Removed Lines]",
          "146:  f, err = os.Create(fname)",
          "",
          "[Added Lines]",
          "151:  f, err = os.OpenFile(fname, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)",
          "",
          "---------------"
        ],
        "glog_test.go||glog_test.go": [
          "File: glog_test.go -> glog_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "772:    len(c), logsink.MaxLogMessageLen, c)",
          "773:  }",
          "774: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "776: func TestCreateFailsIfExists(t *testing.T) {",
          "777:  tmp := t.TempDir()",
          "778:  now := time.Now()",
          "779:  if _, _, err := create(\"INFO\", now, tmp); err != nil {",
          "780:   t.Errorf(\"create() failed on first call: %v\", err)",
          "781:  }",
          "782:  if _, _, err := create(\"INFO\", now, tmp); err == nil {",
          "783:   t.Errorf(\"create() succeeded on second call, want error\")",
          "784:  }",
          "785: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "7139da234346c23dba05a8c588284c379b9c0bf8",
      "candidate_info": {
        "commit_hash": "7139da234346c23dba05a8c588284c379b9c0bf8",
        "repo": "golang/glog",
        "commit_url": "https://github.com/golang/glog/commit/7139da234346c23dba05a8c588284c379b9c0bf8",
        "files": [
          "glog_file.go"
        ],
        "message": "glog: introduce createInDir function as in internal version",
        "before_after_code_files": [
          "glog_file.go||glog_file.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "diff_branch_same_aad": 1,
        "olp_code_files": {
          "patch": [
            "glog_file.go||glog_file.go"
          ],
          "candidate": [
            "glog_file.go||glog_file.go"
          ]
        }
      },
      "candidate_diff": {
        "glog_file.go||glog_file.go": [
          "File: glog_file.go -> glog_file.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "120:  onceLogDirs.Do(createLogDirs)",
          "121:  if len(logDirs) == 0 {",
          "122:   return nil, \"\", errors.New(\"log: no log dirs\")",
          "123:  }",
          "125:  var lastErr error",
          "126:  for _, dir := range logDirs {",
          "129:   if err == nil {",
          "139:   }",
          "140:   lastErr = err",
          "141:  }",
          "142:  return nil, \"\", fmt.Errorf(\"log: cannot create log: %v\", lastErr)",
          "143: }",
          "146: type flushSyncWriter interface {",
          "147:  Flush() error",
          "",
          "[Removed Lines]",
          "119: func create(tag string, t time.Time) (f *os.File, filename string, err error) {",
          "124:  name, link := logName(tag, t)",
          "127:   fname := filepath.Join(dir, name)",
          "128:   f, err := os.Create(fname)",
          "130:    symlink := filepath.Join(dir, link)",
          "131:    os.Remove(symlink)        // ignore err",
          "132:    os.Symlink(name, symlink) // ignore err",
          "133:    if *logLink != \"\" {",
          "134:     lsymlink := filepath.Join(*logLink, link)",
          "135:     os.Remove(lsymlink)         // ignore err",
          "136:     os.Symlink(fname, lsymlink) // ignore err",
          "137:    }",
          "138:    return f, fname, nil",
          "",
          "[Added Lines]",
          "119: func create(tag string, t time.Time, dir string) (f *os.File, filename string, err error) {",
          "120:  if dir != \"\" {",
          "121:   f, name, err := createInDir(dir, tag, t)",
          "122:   if err == nil {",
          "123:    return f, name, err",
          "124:   }",
          "125:   return nil, \"\", fmt.Errorf(\"log: cannot create log: %v\", err)",
          "126:  }",
          "134:   f, name, err := createInDir(dir, tag, t)",
          "136:    return f, name, err",
          "143: func createInDir(dir, tag string, t time.Time) (f *os.File, name string, err error) {",
          "144:  name, link := logName(tag, t)",
          "145:  fname := filepath.Join(dir, name)",
          "146:  f, err = os.Create(fname)",
          "147:  if err == nil {",
          "148:   symlink := filepath.Join(dir, link)",
          "149:   os.Remove(symlink)        // ignore err",
          "150:   os.Symlink(name, symlink) // ignore err",
          "151:   if *logLink != \"\" {",
          "152:    lsymlink := filepath.Join(*logLink, link)",
          "153:    os.Remove(lsymlink)         // ignore err",
          "154:    os.Symlink(fname, lsymlink) // ignore err",
          "155:   }",
          "156:   return f, fname, nil",
          "157:  }",
          "158:  return nil, \"\", err",
          "159: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "281: func (sb *syncBuffer) rotateFile(now time.Time) error {",
          "282:  var err error",
          "283:  pn := \"<none>\"",
          "285:  sb.madeAt = now",
          "287:  if sb.file != nil {",
          "",
          "[Removed Lines]",
          "284:  file, name, err := create(sb.sev.String(), now)",
          "",
          "[Added Lines]",
          "300:  file, name, err := create(sb.sev.String(), now, \"\")",
          "",
          "---------------"
        ]
      }
    }
  ]
}
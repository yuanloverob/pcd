{
  "cve_id": "CVE-2024-1725",
  "cve_desc": "A flaw was found in the kubevirt-csi component of OpenShift Virtualization's Hosted Control Plane (HCP). This issue could allow an authenticated attacker to gain access to the root HCP worker node's volume by creating a custom Persistent Volume that matches the name of a worker node.",
  "repo": "kubevirt/csi-driver",
  "patch_hash": "cc28dcbb0afca0a7cb8a73bc998ab49f864ed560",
  "patch_info": {
    "commit_hash": "cc28dcbb0afca0a7cb8a73bc998ab49f864ed560",
    "repo": "kubevirt/csi-driver",
    "commit_url": "https://github.com/kubevirt/csi-driver/commit/cc28dcbb0afca0a7cb8a73bc998ab49f864ed560",
    "files": [
      "Makefile",
      "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
      "e2e/common_test.go",
      "e2e/create-pvc_test.go",
      "hack/cluster-sync.sh",
      "pkg/kubevirt/client.go",
      "pkg/kubevirt/client_test.go",
      "pkg/service/controller.go"
    ],
    "message": "Address CVE-2024-1725:  Restrict access to infrastructure PVCs by requiring matching infraClusterLabels on tenant PVCs (#103)\n\nThe CVE describes how an attacker may create a PV/PVC in a guest cluster to access any PVC in the infra cluster namespace.\nThe infra clusters may belong to other guest clusters or have been created out of band from the kubevirt-csi driver.\n\nThis PR addresses the issue by:\n\n1.  infraClusterLabels are required (but is up to admin to make sure they are unique per tenant)\n2.  guest may only access infra PVCs with matching labels\n3.  guest can only access PVCs with specific prefix (default is \"pvc-\")\n\nShoutout to awels who actually implemented this based on input from davidvossel.\n\nSigned-off-by: Michael Henriksen <mhenriks@redhat.com>\nCo-authored-by: Alexander Wels <awels@redhat.com>",
    "before_after_code_files": [
      "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
      "e2e/common_test.go||e2e/common_test.go",
      "e2e/create-pvc_test.go||e2e/create-pvc_test.go",
      "hack/cluster-sync.sh||hack/cluster-sync.sh",
      "pkg/kubevirt/client.go||pkg/kubevirt/client.go",
      "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go",
      "pkg/service/controller.go||pkg/service/controller.go"
    ]
  },
  "patch_diff": {
    "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go": [
      "File: cmd/kubevirt-csi-driver/kubevirt-csi-driver.go -> cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "25:  infraClusterNamespace  = flag.String(\"infra-cluster-namespace\", \"\", \"The infra-cluster namespace\")",
      "26:  infraClusterKubeconfig = flag.String(\"infra-cluster-kubeconfig\", \"\", \"the infra-cluster kubeconfig file. If not set, defaults to in cluster config.\")",
      "27:  infraClusterLabels     = flag.String(\"infra-cluster-labels\", \"\", \"The infra-cluster labels to use when creating resources in infra cluster. 'name=value' fields separated by a comma\")",
      "29:  infraStorageClassEnforcement = os.Getenv(\"INFRA_STORAGE_CLASS_ENFORCEMENT\")",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "28:  volumePrefix           = flag.String(\"volume-prefix\", \"pvc\", \"The prefix expected for persistent volumes\")",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "54:  }",
      "55:  klog.V(2).Infof(\"Driver vendor %v %v\", service.VendorName, service.VendorVersion)",
      "57:  inClusterConfig, err := rest.InClusterConfig()",
      "58:  if err != nil {",
      "59:   klog.Fatalf(\"Failed to build in cluster config: %v\", err)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "58:  if (infraClusterLabels == nil || *infraClusterLabels == \"\") && !*runNodeService {",
      "59:   klog.Fatal(\"infra-cluster-labels must be set\")",
      "60:  }",
      "61:  if volumePrefix == nil || *volumePrefix == \"\" {",
      "62:   klog.Fatal(\"volume-prefix must be set\")",
      "63:  }",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "86:  infraClusterLabelsMap := parseLabels()",
      "87:  storageClassEnforcement := configureStorageClassEnforcement(infraStorageClassEnforcement)",
      "90:  if err != nil {",
      "91:   klog.Fatal(err)",
      "92:  }",
      "",
      "[Removed Lines]",
      "89:  virtClient, err := kubevirt.NewClient(infraRestConfig, infraClusterLabelsMap, storageClassEnforcement)",
      "",
      "[Added Lines]",
      "97:  virtClient, err := kubevirt.NewClient(infraRestConfig, infraClusterLabelsMap, storageClassEnforcement, *volumePrefix)",
      "",
      "---------------"
    ],
    "e2e/common_test.go||e2e/common_test.go": [
      "File: e2e/common_test.go -> e2e/common_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "22:  \"k8s.io/client-go/tools/clientcmd\"",
      "23:  clientcmdapi \"k8s.io/client-go/tools/clientcmd/api\"",
      "24:  \"k8s.io/klog/v2\"",
      "25: )",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "25:  cdicli \"kubevirt.io/csi-driver/pkg/generated/containerized-data-importer/client-go/clientset/versioned\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "192:  return kubernetes.NewForConfig(restConfig)",
      "193: }",
      "195: func generateInfraSnapClient() (*snapcli.Clientset, error) {",
      "196:  restConfig, err := generateInfraRestConfig()",
      "197:  if err != nil {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "196: func generateInfraCdiClient() (*cdicli.Clientset, error) {",
      "197:  restConfig, err := generateInfraRestConfig()",
      "198:  if err != nil {",
      "199:   return nil, err",
      "200:  }",
      "202:  return cdicli.NewForConfig(restConfig)",
      "203: }",
      "",
      "---------------"
    ],
    "e2e/create-pvc_test.go||e2e/create-pvc_test.go": [
      "File: e2e/create-pvc_test.go -> e2e/create-pvc_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "11:  \"k8s.io/apimachinery/pkg/api/errors\"",
      "12:  v1 \"k8s.io/client-go/kubernetes/typed/core/v1\"",
      "14:  \"k8s.io/client-go/tools/clientcmd\"",
      "15:  kubecli \"kubevirt.io/csi-driver/pkg/generated/kubevirt/client-go/clientset/versioned\"",
      "17:  . \"github.com/onsi/ginkgo/v2\"",
      "18:  . \"github.com/onsi/gomega\"",
      "19:  \"github.com/spf13/pflag\"",
      "20:  k8sv1 \"k8s.io/api/core/v1\"",
      "21:  \"k8s.io/apimachinery/pkg/api/resource\"",
      "22:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
      "23:  \"k8s.io/apimachinery/pkg/util/rand\"",
      "24:  \"k8s.io/client-go/kubernetes\"",
      "25: )",
      "27: var virtClient *kubecli.Clientset",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "13:  \"k8s.io/klog/v2\"",
      "16:  cdicli \"kubevirt.io/csi-driver/pkg/generated/containerized-data-importer/client-go/clientset/versioned\"",
      "28:  cdiv1 \"kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "282:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, attacherPodFs),",
      "283:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, attacherPodBlock),",
      "284:  )",
      "285: })",
      "287: func writerPodFs(volumeName string) *k8sv1.Pod {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "290:  Context(\"Should prevent access to volumes from infra cluster\", func() {",
      "291:   var tenantPVC *k8sv1.PersistentVolumeClaim",
      "292:   var tenantPV *k8sv1.PersistentVolume",
      "293:   var infraDV *cdiv1.DataVolume",
      "294:   var infraCdiClient *cdicli.Clientset",
      "295:   BeforeEach(func() {",
      "296:    var err error",
      "297:    infraCdiClient, err = generateInfraCdiClient()",
      "298:    Expect(err).ToNot(HaveOccurred())",
      "299:   })",
      "301:   AfterEach(func() {",
      "302:    By(\"Cleaning up resources for test\")",
      "303:    if tenantPVC != nil {",
      "304:     err := tenantClient.CoreV1().PersistentVolumeClaims(tenantPVC.Namespace).Delete(context.Background(), tenantPVC.Name, metav1.DeleteOptions{})",
      "305:     Expect(err).ToNot(HaveOccurred())",
      "306:     Eventually(func() bool {",
      "307:      _, err := tenantClient.CoreV1().PersistentVolumeClaims(tenantPVC.Namespace).Get(context.Background(), tenantPVC.Name, metav1.GetOptions{})",
      "308:      return errors.IsNotFound(err)",
      "309:     }, 1*time.Minute, 2*time.Second).Should(BeTrue(), \"tenant pvc should disappear\")",
      "310:     tenantPVC = nil",
      "311:    }",
      "312:    if tenantPV != nil {",
      "313:     err := tenantClient.CoreV1().PersistentVolumes().Delete(context.Background(), tenantPV.Name, metav1.DeleteOptions{})",
      "314:     Expect(err).ToNot(HaveOccurred())",
      "316:     Eventually(func() bool {",
      "317:      _, err := tenantClient.CoreV1().PersistentVolumes().Get(context.Background(), tenantPV.Name, metav1.GetOptions{})",
      "318:      return errors.IsNotFound(err)",
      "319:     }, 3*time.Minute, 2*time.Second).Should(BeTrue(), \"tenant pv should disappear\")",
      "320:     tenantPV = nil",
      "321:    }",
      "322:    if infraDV != nil {",
      "323:     _, err := infraCdiClient.CdiV1beta1().DataVolumes(InfraClusterNamespace).Get(context.Background(), infraDV.Name, metav1.GetOptions{})",
      "324:     Expect(err).ToNot(HaveOccurred())",
      "325:     err = infraCdiClient.CdiV1beta1().DataVolumes(InfraClusterNamespace).Delete(context.Background(), infraDV.Name, metav1.DeleteOptions{})",
      "326:     Expect(err).ToNot(HaveOccurred())",
      "327:     infraDV = nil",
      "328:    }",
      "329:   })",
      "331:   It(\"should not be able to create a PV and access a volume from the infra cluster that is not labeled\", func() {",
      "332:    infraDV = &cdiv1.DataVolume{",
      "333:     ObjectMeta: metav1.ObjectMeta{",
      "334:      Name:      \"infra-pvc\",",
      "335:      Namespace: InfraClusterNamespace,",
      "336:     },",
      "337:     Spec: cdiv1.DataVolumeSpec{",
      "338:      Source: &cdiv1.DataVolumeSource{",
      "339:       Blank: &cdiv1.DataVolumeBlankImage{},",
      "340:      },",
      "341:      Storage: &cdiv1.StorageSpec{",
      "342:       Resources: k8sv1.ResourceRequirements{",
      "343:        Requests: k8sv1.ResourceList{",
      "344:         k8sv1.ResourceStorage: resource.MustParse(\"1Gi\"),",
      "345:        },",
      "346:       },",
      "347:      },",
      "348:     },",
      "349:    }",
      "350:    var err error",
      "351:    infraDV, err = infraCdiClient.CdiV1beta1().DataVolumes(InfraClusterNamespace).Create(context.Background(), infraDV, metav1.CreateOptions{})",
      "352:    Expect(err).ToNot(HaveOccurred())",
      "354:    By(\"Creating a specially crafted PV, attempt to access volume from infra cluster that should not be accessed\")",
      "355:    tenantPV = &k8sv1.PersistentVolume{",
      "356:     ObjectMeta: metav1.ObjectMeta{",
      "357:      Name: \"tenant-pv\",",
      "358:     },",
      "359:     Spec: k8sv1.PersistentVolumeSpec{",
      "360:      AccessModes: []k8sv1.PersistentVolumeAccessMode{k8sv1.ReadWriteOnce},",
      "361:      Capacity:    k8sv1.ResourceList{k8sv1.ResourceStorage: resource.MustParse(\"1Gi\")},",
      "362:      PersistentVolumeSource: k8sv1.PersistentVolumeSource{",
      "363:       CSI: &k8sv1.CSIPersistentVolumeSource{",
      "364:        Driver:       \"csi.kubevirt.io\",",
      "365:        VolumeHandle: infraDV.Name,",
      "366:        VolumeAttributes: map[string]string{",
      "367:         \"bus\":    \"scsi\",",
      "368:         \"serial\": \"abcd\",",
      "369:         \"storage.kubernetes.io/csiProvisionerIdentity\": \"1708112628060-923-csi.kubevirt.io\",",
      "370:        },",
      "371:        FSType: \"ext4\",",
      "372:       },",
      "373:      },",
      "374:      StorageClassName:              \"kubevirt\",",
      "375:      PersistentVolumeReclaimPolicy: k8sv1.PersistentVolumeReclaimDelete,",
      "376:     },",
      "377:    }",
      "378:    _, err = tenantClient.CoreV1().PersistentVolumes().Create(context.Background(), tenantPV, metav1.CreateOptions{})",
      "379:    Expect(err).ToNot(HaveOccurred())",
      "380:    tenantPVC = &k8sv1.PersistentVolumeClaim{",
      "381:     ObjectMeta: metav1.ObjectMeta{",
      "382:      Name: \"tenant-pvc\",",
      "383:     },",
      "384:     Spec: k8sv1.PersistentVolumeClaimSpec{",
      "385:      AccessModes: []k8sv1.PersistentVolumeAccessMode{k8sv1.ReadWriteOnce},",
      "386:      Resources: k8sv1.ResourceRequirements{",
      "387:       Requests: k8sv1.ResourceList{",
      "388:        k8sv1.ResourceStorage: resource.MustParse(\"1Gi\"),",
      "389:       },",
      "390:      },",
      "391:      VolumeName: tenantPV.Name,",
      "392:     },",
      "393:    }",
      "394:    tenantPVC, err = tenantClient.CoreV1().PersistentVolumeClaims(namespace).Create(context.Background(), tenantPVC, metav1.CreateOptions{})",
      "395:    Expect(err).ToNot(HaveOccurred())",
      "396:    pod := writerPodFs(tenantPVC.Name)",
      "397:    By(\"Creating pod that attempts to use the specially crafted PVC\")",
      "398:    pod, err = tenantClient.CoreV1().Pods(namespace).Create(context.Background(), pod, metav1.CreateOptions{})",
      "399:    Expect(err).ToNot(HaveOccurred())",
      "400:    defer deletePod(tenantClient.CoreV1(), namespace, pod.Name)",
      "402:    involvedObject := fmt.Sprintf(\"involvedObject.name=%s\", pod.Name)",
      "403:    By(\"Waiting for error event to show up in pod event log\")",
      "404:    Eventually(func() bool {",
      "405:     list, err := tenantClient.CoreV1().Events(namespace).List(context.Background(), metav1.ListOptions{",
      "406:      FieldSelector: involvedObject, TypeMeta: metav1.TypeMeta{Kind: \"Pod\"},",
      "407:     })",
      "408:     Expect(err).ToNot(HaveOccurred())",
      "409:     for _, event := range list.Items {",
      "410:      klog.Infof(\"Event: %s [%s]\", event.Message, event.Reason)",
      "411:      if event.Reason == \"FailedAttachVolume\" && strings.Contains(event.Message, \"invalid volume name\") {",
      "412:       return true",
      "413:      }",
      "414:     }",
      "415:     return false",
      "416:    }, 30*time.Second, time.Second).Should(BeTrue(), \"error event should show up in pod event log\")",
      "417:   })",
      "418:  })",
      "",
      "---------------"
    ],
    "hack/cluster-sync.sh||hack/cluster-sync.sh": [
      "File: hack/cluster-sync.sh -> hack/cluster-sync.sh",
      "--- Hunk 1 ---",
      "[Context before]",
      "8: REGISTRY=${REGISTRY:-192.168.66.2:5000}",
      "9: TARGET_NAME=${TARGET_NAME:-kubevirt-csi-driver}",
      "10: TAG=${TAG:-latest}",
      "12: function tenant::deploy_kubeconfig_secret() {",
      "13:   TOKEN=$(_kubectl create token kubevirt-csi -n $TENANT_CLUSTER_NAMESPACE)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "11: export INFRACLUSTER_LABELS=${INFRACLUSTER_LABELS:-\"tenant-cluster=${TENANT_CLUSTER_NAMESPACE}\"}",
      "",
      "---------------"
    ],
    "pkg/kubevirt/client.go||pkg/kubevirt/client.go": [
      "File: pkg/kubevirt/client.go -> pkg/kubevirt/client.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "5:  \"encoding/json\"",
      "6:  goerrors \"errors\"",
      "7:  \"fmt\"",
      "8:  \"time\"",
      "10:  snapshotv1 \"github.com/kubernetes-csi/external-snapshotter/client/v6/apis/volumesnapshot/v1\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "8:  \"strings\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "62:  restClient              *rest.RESTClient",
      "63:  storageClassEnforcement util.StorageClassEnforcement",
      "64:  infraLabelMap           map[string]string",
      "65: }",
      "69:  result := &client{}",
      "71:  Scheme := runtime.NewScheme()",
      "",
      "[Removed Lines]",
      "68: func NewClient(config *rest.Config, infraClusterLabelMap map[string]string, storageClassEnforcement util.StorageClassEnforcement) (Client, error) {",
      "",
      "[Added Lines]",
      "66:  volumePrefix            string",
      "70: func NewClient(config *rest.Config, infraClusterLabelMap map[string]string, storageClassEnforcement util.StorageClassEnforcement, prefix string) (Client, error) {",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "108:  result.restClient = restClient",
      "109:  result.snapClient = snapClient",
      "110:  result.infraLabelMap = infraClusterLabelMap",
      "111:  result.storageClassEnforcement = storageClassEnforcement",
      "112:  return result, nil",
      "113: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "113:  result.volumePrefix = fmt.Sprintf(\"%s-\", prefix)",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "213: func (c *client) CreateDataVolume(ctx context.Context, namespace string, dataVolume *cdiv1.DataVolume) (*cdiv1.DataVolume, error) {",
      "215: }",
      "",
      "[Removed Lines]",
      "214:  return c.cdiClient.CdiV1beta1().DataVolumes(namespace).Create(ctx, dataVolume, metav1.CreateOptions{})",
      "",
      "[Added Lines]",
      "217:  if !strings.HasPrefix(dataVolume.GetName(), c.volumePrefix) {",
      "218:   return nil, ErrInvalidVolume",
      "219:  } else {",
      "220:   return c.cdiClient.CdiV1beta1().DataVolumes(namespace).Create(ctx, dataVolume, metav1.CreateOptions{})",
      "221:  }",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "224: func (c *client) DeleteDataVolume(ctx context.Context, namespace string, name string) error {",
      "226: }",
      "228: func (c *client) GetDataVolume(ctx context.Context, namespace string, name string) (*cdiv1.DataVolume, error) {",
      "230: }",
      "232: func (c *client) CreateVolumeSnapshot(ctx context.Context, namespace, name, claimName, snapshotClassName string) (*snapshotv1.VolumeSnapshot, error) {",
      "",
      "[Removed Lines]",
      "225:  return c.cdiClient.CdiV1beta1().DataVolumes(namespace).Delete(ctx, name, metav1.DeleteOptions{})",
      "229:  return c.cdiClient.CdiV1beta1().DataVolumes(namespace).Get(ctx, name, metav1.GetOptions{})",
      "",
      "[Added Lines]",
      "232:  if dv, err := c.GetDataVolume(ctx, namespace, name); errors.IsNotFound(err) {",
      "233:   return nil",
      "234:  } else if err != nil {",
      "235:   return err",
      "236:  } else if dv != nil {",
      "237:   return c.cdiClient.CdiV1beta1().DataVolumes(namespace).Delete(ctx, dv.Name, metav1.DeleteOptions{})",
      "238:  }",
      "239:  return nil",
      "243:  dv, err := c.cdiClient.CdiV1beta1().DataVolumes(namespace).Get(ctx, name, metav1.GetOptions{})",
      "244:  if err != nil {",
      "245:   return nil, err",
      "246:  }",
      "247:  if dv != nil {",
      "248:   if !containsLabels(dv.Labels, c.infraLabelMap) || !strings.HasPrefix(dv.GetName(), c.volumePrefix) {",
      "249:    return nil, ErrInvalidVolume",
      "250:   }",
      "251:  }",
      "252:  return dv, nil",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "407: }",
      "409: var ErrInvalidSnapshot = goerrors.New(\"invalid snapshot name\")",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "433: var ErrInvalidVolume = goerrors.New(\"invalid volume name\")",
      "",
      "---------------"
    ],
    "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go": [
      "File: pkg/kubevirt/client_test.go -> pkg/kubevirt/client_test.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "10:  k8sv1 \"k8s.io/api/core/v1\"",
      "11:  storagev1 \"k8s.io/api/storage/v1\"",
      "12:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
      "13:  \"k8s.io/apimachinery/pkg/runtime\"",
      "14:  k8sfake \"k8s.io/client-go/kubernetes/fake\"",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "12:  \"k8s.io/apimachinery/pkg/api/errors\"",
      "",
      "---------------",
      "--- Hunk 2 ---",
      "[Context before]",
      "20: )",
      "22: const (",
      "24:  defaultStorageClassName      = \"default-storage-class\"",
      "25:  volumeSnapshotClassName      = \"test-volume-snapshot-class\"",
      "26:  provisioner                  = \"test-provisioner\"",
      "27:  nonMatchingProvisioner       = \"non-matching-provisioner-snapshot-class\"",
      "",
      "[Removed Lines]",
      "23:  storageClassName             = \"test-storage-class\"",
      "",
      "[Added Lines]",
      "25:  storageClassName             = \"test-storage-class\"",
      "",
      "---------------",
      "--- Hunk 3 ---",
      "[Context before]",
      "29:  otherVolumeSnapshotClassName = \"other-volume-snapshot-class\"",
      "30:  testVolumeName               = \"test-volume\"",
      "31:  testVolumeNameNotAllowed     = \"test-volume-not-allowed\"",
      "35:  testNamespace                = \"test-namespace\"",
      "36:  unboundTestClaimName         = \"unbound-test-claim\"",
      "37: )",
      "",
      "[Removed Lines]",
      "32:  testClaimName                = \"test-claim\"",
      "33:  testClaimName2               = \"test-claim2\"",
      "34:  testClaimName3               = \"test-claim3\"",
      "",
      "[Added Lines]",
      "33:  validDataVolume              = \"pvc-valid-data-volume\"",
      "34:  nolabelDataVolume            = \"nolabel-data-volume\"",
      "35:  testClaimName                = \"pvc-valid-data-volume\"",
      "36:  testClaimName2               = \"pvc-valid-data-volume2\"",
      "37:  testClaimName3               = \"pvc-valid-data-volume3\"",
      "",
      "---------------",
      "--- Hunk 4 ---",
      "[Context before]",
      "41:   c *client",
      "42:  )",
      "44:  Context(\"Snapshot class\", func() {",
      "45:   BeforeEach(func() {",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "47:  Context(\"volumes\", func() {",
      "48:   BeforeEach(func() {",
      "50:    c = NewFakeClient()",
      "51:    c = NewFakeCdiClient(c, createValidDataVolume(), createNoLabelDataVolume(), createWrongPrefixDataVolume())",
      "52:   })",
      "54:   DescribeTable(\"GetDataVolume should return the right thing\", func(volumeName string, expectedErr error) {",
      "55:    _, err := c.GetDataVolume(context.Background(), testNamespace, volumeName)",
      "56:    if expectedErr != nil {",
      "57:     Expect(err).To(Equal(expectedErr))",
      "58:    } else {",
      "59:     Expect(err).ToNot(HaveOccurred())",
      "60:    }",
      "61:   },",
      "62:    Entry(\"when the data volume exists\", validDataVolume, nil),",
      "63:    Entry(\"when the data volume exists, but no labels\", nolabelDataVolume, ErrInvalidVolume),",
      "64:    Entry(\"when the data volume exists, but no labels\", testVolumeName, ErrInvalidVolume),",
      "65:   )",
      "67:   It(\"should return not exists if the data volume does not exist\", func() {",
      "68:    _, err := c.GetDataVolume(context.Background(), testNamespace, \"notexist\")",
      "69:    Expect(err).To(HaveOccurred())",
      "70:    Expect(errors.IsNotFound(err)).To(BeTrue())",
      "71:   })",
      "73:   It(\"DeleteDataVolume should not delete volumes if the right prefix doesn't exist\", func() {",
      "74:    err := c.DeleteDataVolume(context.Background(), testNamespace, testVolumeName)",
      "75:    Expect(err).To(HaveOccurred())",
      "76:    Expect(err).To(Equal(ErrInvalidVolume))",
      "77:   })",
      "79:   It(\"DeleteDataVolume return nil if volume doesn't exist\", func() {",
      "80:    err := c.DeleteDataVolume(context.Background(), testNamespace, \"notexist\")",
      "81:    Expect(err).ToNot(HaveOccurred())",
      "82:   })",
      "84:   It(\"DeleteDataVolume should delete volumes if valid\", func() {",
      "85:    err := c.DeleteDataVolume(context.Background(), testNamespace, validDataVolume)",
      "86:    Expect(err).ToNot(HaveOccurred())",
      "87:   })",
      "89:   It(\"Should create a volume if a valid volume is passed\", func() {",
      "90:    dataVolume := createValidDataVolume()",
      "91:    dataVolume.Name = \"pvc-test2\"",
      "92:    _, err := c.CreateDataVolume(context.Background(), testNamespace, dataVolume)",
      "93:    Expect(err).ToNot(HaveOccurred())",
      "94:   })",
      "96:   It(\"Should not create a volume if an invalid volume name is passed\", func() {",
      "97:    dataVolume := createValidDataVolume()",
      "98:    dataVolume.Name = \"test\"",
      "99:    _, err := c.CreateDataVolume(context.Background(), testNamespace, dataVolume)",
      "100:    Expect(err).To(Equal(ErrInvalidVolume))",
      "101:   })",
      "102:  })",
      "",
      "---------------",
      "--- Hunk 5 ---",
      "[Context before]",
      "118:  })",
      "120:  Context(\"Snapshot operators\", func() {",
      "131:   BeforeEach(func() {",
      "134:   })",
      "136:   It(\"should return error if the volume snapshot class is not found\", func() {",
      "138:    Expect(err).To(HaveOccurred())",
      "139:    Expect(s).To(BeNil())",
      "140:    Expect(err.Error()).To(ContainSubstring(\"provided volume snapshot class cannot be matched with storage class\"))",
      "",
      "[Removed Lines]",
      "121:   createValidDataVolume := func(name string) *cdiv1.DataVolume {",
      "122:    return &cdiv1.DataVolume{",
      "123:     ObjectMeta: metav1.ObjectMeta{",
      "124:      Name:      name,",
      "125:      Namespace: testNamespace,",
      "126:     },",
      "127:     Spec: cdiv1.DataVolumeSpec{},",
      "128:    }",
      "129:   }",
      "133:    c = NewFakeCdiClient(NewFakeClient(), createValidDataVolume(testClaimName))",
      "137:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", testClaimName, \"non-existing-snapshot-class\")",
      "",
      "[Added Lines]",
      "183:    c = NewFakeCdiClient(NewFakeClient(), createValidDataVolume())",
      "187:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, \"non-existing-snapshot-class\")",
      "",
      "---------------",
      "--- Hunk 6 ---",
      "[Context before]",
      "148:   })",
      "150:   It(\"should delete volumesnapshot if it exists and it valid\", func() {",
      "152:    Expect(err).ToNot(HaveOccurred())",
      "153:    Expect(s.Name).To(Equal(\"snap\"))",
      "154:    err = c.DeleteVolumeSnapshot(context.TODO(), s.GetNamespace(), s.GetName())",
      "",
      "[Removed Lines]",
      "151:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", testClaimName, volumeSnapshotClassName)",
      "",
      "[Added Lines]",
      "201:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
      "",
      "---------------",
      "--- Hunk 7 ---",
      "[Context before]",
      "161:   })",
      "163:   It(\"should return error if get volume returns an error\", func() {",
      "165:    Expect(err).ToNot(HaveOccurred())",
      "166:    Expect(s.Name).To(Equal(\"snap\"))",
      "168:    err = c.DeleteVolumeSnapshot(context.TODO(), s.GetNamespace(), s.GetName())",
      "169:    Expect(err).To(Equal(ErrInvalidSnapshot))",
      "170:   })",
      "172:   It(\"should properly list snapshots\", func() {",
      "174:    Expect(err).ToNot(HaveOccurred())",
      "175:    Expect(s.Name).To(Equal(\"snap\"))",
      "176:    l, err := c.ListVolumeSnapshots(context.TODO(), testNamespace)",
      "",
      "[Removed Lines]",
      "164:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", testClaimName, volumeSnapshotClassName)",
      "167:    c.infraLabelMap = map[string]string{\"test\": \"test\"}",
      "173:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", testClaimName, volumeSnapshotClassName)",
      "",
      "[Added Lines]",
      "214:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
      "217:    c.infraLabelMap = map[string]string{\"test\": \"test2\"}",
      "223:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
      "",
      "---------------",
      "--- Hunk 8 ---",
      "[Context before]",
      "206:     util.StorageClassEnforcement{AllowList: []string{}, AllowDefault: true}, false),",
      "207:   )",
      "208:  })",
      "209: })",
      "211: func NewFakeClient() *client {",
      "212:  storageClass := createStorageClass(storageClassName, provisioner, false)",
      "213:  defaultStorageClass := createStorageClass(defaultStorageClassName, provisioner, true)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "262: func NewFakeCdiClient(c *client, objects ...runtime.Object) *client {",
      "263:  fakeCdiClient := cdicli.NewSimpleClientset(objects...)",
      "264:  c.cdiClient = fakeCdiClient",
      "265:  return c",
      "266: }",
      "",
      "---------------",
      "--- Hunk 9 ---",
      "[Context before]",
      "236:  result := &client{",
      "237:   kubernetesClient: fakeK8sClient,",
      "238:   snapClient:       fakeSnapClient,",
      "239:   storageClassEnforcement: util.StorageClassEnforcement{",
      "240:    AllowList:    []string{storageClassName},",
      "241:    AllowAll:     false,",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "296:   infraLabelMap:    map[string]string{\"test\": \"test\"},",
      "297:   volumePrefix:     \"pvc-\",",
      "",
      "---------------",
      "--- Hunk 10 ---",
      "[Context before]",
      "245:  return result",
      "246: }",
      "254: func createVolumeSnapshotClass(name, provisioner string, isDefault bool) *snapshotv1.VolumeSnapshotClass {",
      "255:  res := &snapshotv1.VolumeSnapshotClass{",
      "256:   ObjectMeta: metav1.ObjectMeta{",
      "",
      "[Removed Lines]",
      "248: func NewFakeCdiClient(c *client, objects ...runtime.Object) *client {",
      "249:  fakeCdiClient := cdicli.NewSimpleClientset(objects...)",
      "250:  c.cdiClient = fakeCdiClient",
      "251:  return c",
      "252: }",
      "",
      "[Added Lines]",
      "[None]",
      "",
      "---------------",
      "--- Hunk 11 ---",
      "[Context before]",
      "282:   ObjectMeta: metav1.ObjectMeta{",
      "283:    Name:      name,",
      "284:    Namespace: testNamespace,",
      "285:   },",
      "286:   Spec: k8sv1.PersistentVolumeClaimSpec{",
      "287:    StorageClassName: ptr.To[string](storageClassName),",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "338:    Labels:    map[string]string{\"test\": \"test\"},",
      "",
      "---------------",
      "--- Hunk 12 ---",
      "[Context before]",
      "304:  }",
      "305:  return res",
      "306: }",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "362: func createDataVolume(name string, labels map[string]string) *cdiv1.DataVolume {",
      "363:  return &cdiv1.DataVolume{",
      "364:   ObjectMeta: metav1.ObjectMeta{",
      "365:    Name:      name,",
      "366:    Namespace: testNamespace,",
      "367:    Labels:    labels,",
      "368:   },",
      "369:   Spec: cdiv1.DataVolumeSpec{},",
      "370:  }",
      "371: }",
      "373: func createValidDataVolume() *cdiv1.DataVolume {",
      "374:  return createDataVolume(validDataVolume, map[string]string{\"test\": \"test\"})",
      "375: }",
      "377: func createNoLabelDataVolume() *cdiv1.DataVolume {",
      "378:  return createDataVolume(nolabelDataVolume, nil)",
      "379: }",
      "381: func createWrongPrefixDataVolume() *cdiv1.DataVolume {",
      "382:  return createDataVolume(testVolumeName, map[string]string{\"test\": \"test\"})",
      "383: }",
      "",
      "---------------"
    ],
    "pkg/service/controller.go||pkg/service/controller.go": [
      "File: pkg/service/controller.go -> pkg/service/controller.go",
      "--- Hunk 1 ---",
      "[Context before]",
      "256:   return nil, err",
      "257:  }",
      "258:  dvName := req.GetVolumeId()",
      "260:  klog.V(3).Infof(\"Attaching DataVolume %s to Node ID %s\", dvName, req.NodeId)",
      "",
      "[Removed Lines]",
      "[None]",
      "",
      "[Added Lines]",
      "259:  if _, err := c.virtClient.GetDataVolume(ctx, c.infraClusterNamespace, dvName); errors.IsNotFound(err) {",
      "260:   return nil, status.Errorf(codes.NotFound, \"volume %s not found\", req.GetVolumeId())",
      "261:  } else if err != nil {",
      "262:   return nil, err",
      "263:  }",
      "",
      "---------------"
    ]
  },
  "candidates": [
    {
      "candidate_hash": "bfd317b7bdb4e0c2a35e39be3c2442b7437b23c6",
      "candidate_info": {
        "commit_hash": "bfd317b7bdb4e0c2a35e39be3c2442b7437b23c6",
        "repo": "kubevirt/csi-driver",
        "commit_url": "https://github.com/kubevirt/csi-driver/commit/bfd317b7bdb4e0c2a35e39be3c2442b7437b23c6",
        "files": [
          "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
          "hack/generate_clients.sh",
          "pkg/kubevirt/client.go",
          "pkg/kubevirt/client_test.go"
        ],
        "message": "Lazy load volume/snapshot mapping (#108)\n\nInstead of eagerly calculating the mapping do it\nlazily when the mapping is requested. This will\nallow the driver to start when the RBAC in the\ntenant cluster might not be complete yet.\n\nSigned-off-by: Alexander Wels <awels@redhat.com>",
        "before_after_code_files": [
          "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
          "hack/generate_clients.sh||hack/generate_clients.sh",
          "pkg/kubevirt/client.go||pkg/kubevirt/client.go",
          "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
            "pkg/kubevirt/client.go||pkg/kubevirt/client.go",
            "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go"
          ],
          "candidate": [
            "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
            "pkg/kubevirt/client.go||pkg/kubevirt/client.go",
            "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go"
          ]
        }
      },
      "candidate_diff": {
        "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go": [
          "File: cmd/kubevirt-csi-driver/kubevirt-csi-driver.go -> cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "97:  }",
          "99:  infraClusterLabelsMap := parseLabels()",
          "100:  storageClassEnforcement := configureStorageClassEnforcement(infraStorageClassEnforcement)",
          "102:  virtClient, err := kubevirt.NewClient(infraRestConfig, infraClusterLabelsMap, tenantClientSet, tenantSnapshotClientSet, storageClassEnforcement, *volumePrefix)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "100:  klog.V(5).Infof(\"Storage class enforcement string: \\n%s\", infraStorageClassEnforcement)",
          "",
          "---------------"
        ],
        "hack/generate_clients.sh||hack/generate_clients.sh": [
          "File: hack/generate_clients.sh -> hack/generate_clients.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "3: set -o nounset",
          "4: set -o pipefail",
          "7: client-gen --input-base=\"kubevirt.io/api/\" --input=\"core/v1\" --output-package=\"kubevirt.io/csi-driver/pkg/generated/kubevirt/client-go/clientset\" --output-base=\"../../\" --clientset-name=\"versioned\" --go-header-file hack/boilerplate.go.txt",
          "9: go get kubevirt.io/containerized-data-importer-api",
          "",
          "[Removed Lines]",
          "6: go install k8s.io/code-generator/cmd/client-gen@latest",
          "",
          "[Added Lines]",
          "6: go install k8s.io/code-generator/cmd/client-gen@v0.28.6",
          "",
          "---------------"
        ],
        "pkg/kubevirt/client.go||pkg/kubevirt/client.go": [
          "File: pkg/kubevirt/client.go -> pkg/kubevirt/client.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "6:  goerrors \"errors\"",
          "7:  \"fmt\"",
          "8:  \"strings\"",
          "9:  \"time\"",
          "11:  snapshotv1 \"github.com/kubernetes-csi/external-snapshotter/client/v6/apis/volumesnapshot/v1\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9:  \"sync\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "68: }",
          "70: type client struct {",
          "81: }",
          "",
          "[Removed Lines]",
          "71:  infraKubernetesClient             kubernetes.Interface",
          "72:  tenantKubernetesClient            kubernetes.Interface",
          "73:  virtClient                        kubecli.Interface",
          "74:  cdiClient                         cdicli.Interface",
          "75:  infraSnapClient                   snapcli.Interface",
          "76:  restClient                        *rest.RESTClient",
          "77:  storageClassEnforcement           util.StorageClassEnforcement",
          "78:  infraLabelMap                     map[string]string",
          "79:  volumePrefix                      string",
          "80:  infraTenantStorageSnapshotMapping []InfraTenantStorageSnapshotMapping",
          "",
          "[Added Lines]",
          "72:  infraKubernetesClient                      kubernetes.Interface",
          "73:  tenantKubernetesClient                     kubernetes.Interface",
          "74:  virtClient                                 kubecli.Interface",
          "75:  cdiClient                                  cdicli.Interface",
          "76:  infraSnapClient                            snapcli.Interface",
          "77:  tenantSnapClient                           snapcli.Interface",
          "78:  restClient                                 *rest.RESTClient",
          "79:  storageClassEnforcement                    util.StorageClassEnforcement",
          "80:  infraLabelMap                              map[string]string",
          "81:  volumePrefix                               string",
          "82:  infraTenantStorageSnapshotMapping          []InfraTenantStorageSnapshotMapping",
          "83:  infraTenantStorageSnapshotMappingPopulated bool",
          "84:  mu                                         sync.Mutex",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "127:  result.volumePrefix = fmt.Sprintf(\"%s-\", prefix)",
          "128:  result.storageClassEnforcement = storageClassEnforcement",
          "129:  result.tenantKubernetesClient = tenantKubernetesClient",
          "135:  return result, nil",
          "136: }",
          "",
          "[Removed Lines]",
          "130:  storageSnapshotMapping, err := result.buildStorageClassSnapshotClassMapping(tenantKubernetesClient, tenantSnapshotClient, storageClassEnforcement.StorageSnapshotMapping)",
          "131:  if err != nil {",
          "132:   return nil, err",
          "133:  }",
          "134:  result.infraTenantStorageSnapshotMapping = storageSnapshotMapping",
          "",
          "[Added Lines]",
          "134:  result.tenantSnapClient = tenantSnapshotClient",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "144:  return true",
          "145: }",
          "148: func (c *client) AddVolumeToVM(ctx context.Context, namespace string, vmName string, hotPlugRequest *kubevirtv1.AddVolumeOptions) error {",
          "149:  uri := fmt.Sprintf(vmiSubresourceURL, kubevirtv1.ApiStorageVersion, namespace, vmName, \"addvolume\")",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "147: func (c *client) getStorageSnapshotMapping() ([]InfraTenantStorageSnapshotMapping, error) {",
          "148:  c.mu.Lock()",
          "149:  defer c.mu.Unlock()",
          "150:  if !c.infraTenantStorageSnapshotMappingPopulated {",
          "151:   storageSnapshotMapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "152:   if err != nil {",
          "153:    return nil, err",
          "154:   }",
          "155:   c.infraTenantStorageSnapshotMapping = storageSnapshotMapping",
          "156:   c.infraTenantStorageSnapshotMappingPopulated = true",
          "157:   klog.V(5).Infof(\"Populated Storage class snapshot class mapping: %#v\", c.infraTenantStorageSnapshotMapping)",
          "158:  }",
          "159:  return c.infraTenantStorageSnapshotMapping, nil",
          "160: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "311:  if storageClassName == \"\" && !c.storageClassEnforcement.AllowDefault {",
          "312:   return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, and default not allowed\")",
          "313:  } else if storageClassName != \"\" && !(util.Contains(c.storageClassEnforcement.AllowList, storageClassName) || c.storageClassEnforcement.AllowAll) {",
          "315:  }",
          "317:  if util.Contains(snapshotClassNames, snapshotClassName) {",
          "318:   return snapshotClassName, nil",
          "319:  }",
          "320:  if !(c.storageClassEnforcement.AllowAll || c.storageClassEnforcement.AllowDefault) {",
          "322:   if len(tenantSnapshotClasses) > 0 {",
          "323:    if snapshotClassName == \"\" {",
          "324:     return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, valid snapshot classes are %v\", tenantSnapshotClasses)",
          "",
          "[Removed Lines]",
          "314:   return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, no valid snapshot classes found\")",
          "316:  snapshotClassNames := c.getInfraSnapshotClassesFromInfraStorageClassName(storageClassName)",
          "321:   tenantSnapshotClasses := c.getTenantSnapshotClassesFromInfraStorageClassName(storageClassName)",
          "",
          "[Added Lines]",
          "329:   return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, no valid snapshot classes found based on storage class [%s]\", storageClassName)",
          "330:  }",
          "331:  snapshotClassNames, err := c.getInfraSnapshotClassesFromInfraStorageClassName(storageClassName)",
          "332:  if err != nil {",
          "333:   return \"\", err",
          "339:   tenantSnapshotClasses, err := c.getTenantSnapshotClassesFromInfraStorageClassName(storageClassName)",
          "340:   if err != nil {",
          "341:    return \"\", err",
          "342:   }",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "332:  return \"\", nil",
          "333: }",
          "337:   for _, storageClass := range storageSnapshotMapping.StorageClasses {",
          "338:    if storageClassName == storageClass {",
          "339:     infraSnapshotClasses := []string{}",
          "340:     for _, snapshotClasses := range storageSnapshotMapping.VolumeSnapshotClasses {",
          "341:      infraSnapshotClasses = append(infraSnapshotClasses, snapshotClasses.Infra)",
          "342:     }",
          "344:    }",
          "345:   }",
          "346:  }",
          "348: }",
          "352:   for _, storageClass := range storageSnapshotMapping.StorageClasses {",
          "353:    if storageClassName == storageClass {",
          "354:     tenantSnapshotClasses := []string{}",
          "355:     for _, snapshotClasses := range storageSnapshotMapping.VolumeSnapshotClasses {",
          "356:      tenantSnapshotClasses = append(tenantSnapshotClasses, snapshotClasses.Tenant)",
          "357:     }",
          "359:    }",
          "360:   }",
          "361:  }",
          "363: }",
          "",
          "[Removed Lines]",
          "335: func (c *client) getInfraSnapshotClassesFromInfraStorageClassName(storageClassName string) []string {",
          "336:  for _, storageSnapshotMapping := range c.infraTenantStorageSnapshotMapping {",
          "343:     return infraSnapshotClasses",
          "347:  return nil",
          "350: func (c *client) getTenantSnapshotClassesFromInfraStorageClassName(storageClassName string) []string {",
          "351:  for _, storageSnapshotMapping := range c.infraTenantStorageSnapshotMapping {",
          "358:     return tenantSnapshotClasses",
          "362:  return nil",
          "",
          "[Added Lines]",
          "356: func (c *client) getInfraSnapshotClassesFromInfraStorageClassName(storageClassName string) ([]string, error) {",
          "357:  infraTenantStorageSnapshotMapping, err := c.getStorageSnapshotMapping()",
          "358:  if err != nil {",
          "359:   return nil, err",
          "360:  }",
          "361:  for _, storageSnapshotMapping := range infraTenantStorageSnapshotMapping {",
          "368:     return infraSnapshotClasses, nil",
          "372:  return nil, nil",
          "375: func (c *client) getTenantSnapshotClassesFromInfraStorageClassName(storageClassName string) ([]string, error) {",
          "376:  infraTenantStorageSnapshotMapping, err := c.getStorageSnapshotMapping()",
          "377:  if err != nil {",
          "378:   return nil, err",
          "379:  }",
          "380:  for _, storageSnapshotMapping := range infraTenantStorageSnapshotMapping {",
          "387:     return tenantSnapshotClasses, nil",
          "391:  return nil, nil",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "369:   klog.Errorf(\"Error getting volume claim %s in namespace %s: %v\", claimName, namespace, err)",
          "370:   return \"\", err",
          "371:  }",
          "373:  storageClassName := \"\"",
          "374:  if volumeClaim.Spec.StorageClassName != nil {",
          "375:   storageClassName = *volumeClaim.Spec.StorageClassName",
          "376:  }",
          "377:  return storageClassName, nil",
          "378: }",
          "",
          "[Removed Lines]",
          "372:  klog.V(5).Infof(\"found volumeClaim %#v\", volumeClaim)",
          "",
          "[Added Lines]",
          "405:  klog.V(5).Infof(\"found storageClassName %s for volume %s\", storageClassName, claimName)",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "411:  })",
          "412: }",
          "415:  provisionerMapping := make([]InfraTenantStorageSnapshotMapping, len(infraStorageSnapMapping))",
          "417:  volumeSnapshotClassList, err := snapshotClient.SnapshotV1().VolumeSnapshotClasses().List(context.Background(), metav1.ListOptions{})",
          "418:  if err != nil {",
          "419:   return nil, err",
          "420:  }",
          "422:  for i, storageSnapshotMapping := range infraStorageSnapMapping {",
          "423:   mapping := &InfraTenantStorageSnapshotMapping{",
          "424:    StorageClasses: storageSnapshotMapping.StorageClasses,",
          "",
          "[Removed Lines]",
          "414: func (c *client) buildStorageClassSnapshotClassMapping(k8sClient kubernetes.Interface, snapshotClient snapcli.Interface, infraStorageSnapMapping []util.StorageSnapshotMapping) ([]InfraTenantStorageSnapshotMapping, error) {",
          "",
          "[Added Lines]",
          "443: func (c *client) buildStorageClassSnapshotClassMapping(snapshotClient snapcli.Interface, infraStorageSnapMapping []util.StorageSnapshotMapping) ([]InfraTenantStorageSnapshotMapping, error) {",
          "444:  klog.V(5).Infof(\"Building storage class snapshot class mapping, %#v\", infraStorageSnapMapping)",
          "451:  klog.V(5).Infof(\"Volume snapshot class list: %#v\", volumeSnapshotClassList.Items)",
          "",
          "---------------"
        ],
        "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go": [
          "File: pkg/kubevirt/client_test.go -> pkg/kubevirt/client_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "136:   DescribeTable(\"should return snapshot class from claim or error\", func(claimName, namespace, snapshotClassName, resultSnapshotClassName string, expectedError bool) {",
          "137:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "140:    Expect(err).ToNot(HaveOccurred())",
          "141:    c.infraTenantStorageSnapshotMapping = mapping",
          "142:    res, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), namespace, claimName, snapshotClassName)",
          "",
          "[Removed Lines]",
          "138:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "139:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "[Added Lines]",
          "138:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "207:   It(\"should delete volumesnapshot if it exists and it valid\", func() {",
          "208:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "211:    Expect(err).ToNot(HaveOccurred())",
          "212:    c.infraTenantStorageSnapshotMapping = mapping",
          "213:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
          "",
          "[Removed Lines]",
          "209:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "210:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "[Added Lines]",
          "208:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "225:   It(\"should return error if get volume returns an error\", func() {",
          "226:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "229:    Expect(err).ToNot(HaveOccurred())",
          "230:    c.infraTenantStorageSnapshotMapping = mapping",
          "231:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
          "",
          "[Removed Lines]",
          "227:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "228:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "[Added Lines]",
          "225:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "239:   It(\"should properly list snapshots\", func() {",
          "240:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "243:    Expect(err).ToNot(HaveOccurred())",
          "244:    c.infraTenantStorageSnapshotMapping = mapping",
          "245:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
          "",
          "[Removed Lines]",
          "241:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "242:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "[Added Lines]",
          "238:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "265:   DescribeTable(\"should properly determine snapshot class from storage class\", func(snapshotClassName, claimName string, enforcement util.StorageClassEnforcement, tenantSnapClient snapcli.Interface, expected, expectedError string) {",
          "266:    c.storageClassEnforcement = enforcement",
          "268:    Expect(err).ToNot(HaveOccurred())",
          "269:    c.infraTenantStorageSnapshotMapping = mapping",
          "270:    res, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), testNamespace, claimName, snapshotClassName)",
          "",
          "[Removed Lines]",
          "267:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "[Added Lines]",
          "263:    c.tenantSnapClient = tenantSnapClient",
          "264:    mapping, err := c.buildStorageClassSnapshotClassMapping(tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "353:   infraKubernetesClient:  fakeK8sClient,",
          "354:   tenantKubernetesClient: fakeTenantK8sClient,",
          "355:   infraSnapClient:        fakeSnapClient,",
          "356:   infraLabelMap:          map[string]string{\"test\": \"test\"},",
          "357:   volumePrefix:           \"pvc-\",",
          "358:   storageClassEnforcement: util.StorageClassEnforcement{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "353:   tenantSnapClient:       snapfake.NewSimpleClientset(),",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "a3163cee0912f67cb991e56087c0adece01e6624",
      "candidate_info": {
        "commit_hash": "a3163cee0912f67cb991e56087c0adece01e6624",
        "repo": "kubevirt/csi-driver",
        "commit_url": "https://github.com/kubevirt/csi-driver/commit/a3163cee0912f67cb991e56087c0adece01e6624",
        "files": [
          "e2e/create-pvc_test.go",
          "e2e/create_pod_helper_test.go",
          "e2e/snapshot_test.go",
          "hack/cluster-sync-split.sh",
          "hack/cluster-up.sh",
          "hack/generate_clients.sh",
          "hack/run-e2e.sh",
          "hack/run-k8s-e2e.sh",
          "hack/test-driver-rwx.yaml",
          "hack/test-driver.yaml",
          "pkg/service/controller.go",
          "pkg/service/controller_test.go"
        ],
        "message": "Support Read Write Many (RWX) access mode with block (#100)\n\n* run e2e tests with 2 guest worker nodes\n\nSigned-off-by: Nahshon Unna-Tsameret <nunnatsa@redhat.com>\n\n* Improve e2e tests\n\nUse option builder for 2e2 pods, so we could have more options for the\npods, without changing the create pod methods API, and to avoid too many\ncreate pod methods.\n\nSigned-off-by: Nahshon Unna-Tsameret <nunnatsa@redhat.com>\n\n* Support Read Write Many (RWX) accessMode + block\n\nReject creation of non-block (FS) volumes with access mode of RWX\n\nSigned-off-by: Nahshon Unna-Tsameret <nunnatsa@redhat.com>\n\n* Add e2e tests for RWX\n\nSigned-off-by: Nahshon Unna-Tsameret <nunnatsa@redhat.com>\n\n* Run the RWX test in K8s e2e\n\nSigned-off-by: Nahshon Unna-Tsameret <nunnatsa@redhat.com>\n\n---------\n\nSigned-off-by: Nahshon Unna-Tsameret <nunnatsa@redhat.com>",
        "before_after_code_files": [
          "e2e/create-pvc_test.go||e2e/create-pvc_test.go",
          "e2e/create_pod_helper_test.go||e2e/create_pod_helper_test.go",
          "e2e/snapshot_test.go||e2e/snapshot_test.go",
          "hack/cluster-sync-split.sh||hack/cluster-sync-split.sh",
          "hack/cluster-up.sh||hack/cluster-up.sh",
          "hack/generate_clients.sh||hack/generate_clients.sh",
          "hack/run-e2e.sh||hack/run-e2e.sh",
          "hack/run-k8s-e2e.sh||hack/run-k8s-e2e.sh",
          "pkg/service/controller.go||pkg/service/controller.go",
          "pkg/service/controller_test.go||pkg/service/controller_test.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "e2e/create-pvc_test.go||e2e/create-pvc_test.go",
            "pkg/service/controller.go||pkg/service/controller.go"
          ],
          "candidate": [
            "e2e/create-pvc_test.go||e2e/create-pvc_test.go",
            "pkg/service/controller.go||pkg/service/controller.go"
          ]
        }
      },
      "candidate_diff": {
        "e2e/create-pvc_test.go||e2e/create-pvc_test.go": [
          "File: e2e/create-pvc_test.go -> e2e/create-pvc_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "8:  \"strings\"",
          "9:  \"time\"",
          "19:  . \"github.com/onsi/ginkgo/v2\"",
          "20:  . \"github.com/onsi/gomega\"",
          "22:  \"github.com/spf13/pflag\"",
          "23:  k8sv1 \"k8s.io/api/core/v1\"",
          "24:  \"k8s.io/apimachinery/pkg/api/resource\"",
          "25:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "26:  \"k8s.io/apimachinery/pkg/util/rand\"",
          "27:  \"k8s.io/client-go/kubernetes\"",
          "28:  cdiv1 \"kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1\"",
          "29: )",
          "31: var virtClient *kubecli.Clientset",
          "33: func defaultInfraClientConfig(flags *pflag.FlagSet) clientcmd.ClientConfig {",
          "",
          "[Removed Lines]",
          "11:  \"k8s.io/apimachinery/pkg/api/errors\"",
          "12:  v1 \"k8s.io/client-go/kubernetes/typed/core/v1\"",
          "13:  \"k8s.io/klog/v2\"",
          "15:  \"k8s.io/client-go/tools/clientcmd\"",
          "16:  cdicli \"kubevirt.io/csi-driver/pkg/generated/containerized-data-importer/client-go/clientset/versioned\"",
          "17:  kubecli \"kubevirt.io/csi-driver/pkg/generated/kubevirt/client-go/clientset/versioned\"",
          "",
          "[Added Lines]",
          "15:  \"k8s.io/apimachinery/pkg/api/errors\"",
          "20:  v1 \"k8s.io/client-go/kubernetes/typed/core/v1\"",
          "21:  \"k8s.io/client-go/tools/clientcmd\"",
          "22:  \"k8s.io/klog/v2\"",
          "26:  cdicli \"kubevirt.io/csi-driver/pkg/generated/containerized-data-importer/client-go/clientset/versioned\"",
          "27:  kubecli \"kubevirt.io/csi-driver/pkg/generated/kubevirt/client-go/clientset/versioned\"",
          "30: const hostNameLabelKey = \"kubernetes.io/hostname\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "50: var _ = Describe(\"CreatePVC\", func() {",
          "54:  var tmpDir string",
          "55:  var tenantClient *kubernetes.Clientset",
          "56:  var infraClient *kubernetes.Clientset",
          "",
          "[Removed Lines]",
          "52:  const hostNameLabelKey = \"kubernetes.io/hostname\"",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "85:   _ = os.RemoveAll(tmpDir)",
          "86:  })",
          "89:   pvcName := \"test-pvc\"",
          "90:   storageClassName := \"kubevirt\"",
          "91:   pvc := pvcSpec(pvcName, storageClassName, \"10Mi\")",
          "",
          "[Removed Lines]",
          "88:  DescribeTable(\"creates a pvc and attaches to pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, podCreationFunc func(string) *k8sv1.Pod) {",
          "",
          "[Added Lines]",
          "87:  DescribeTable(\"creates a pvc and attaches to pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, storageOpt storageOption, attachCmd string) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "96:   Expect(err).ToNot(HaveOccurred())",
          "98:   By(\"creating a pod that attaches pvc\")",
          "99:   runPod(",
          "100:    tenantClient.CoreV1(),",
          "101:    namespace,",
          "103:  },",
          "106:  )",
          "109:   nodes, err := tenantClient.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})",
          "110:   Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "102:    podCreationFunc(pvc.Name))",
          "104:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, attacherPodFs),",
          "105:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, attacherPodBlock),",
          "108:  DescribeTable(\"creates a pvc, attaches to pod, re-attach to another pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, podCreationFunc func(string) *k8sv1.Pod) {",
          "",
          "[Added Lines]",
          "98:   podSpec := createPod(\"test-pod\",",
          "99:    withCommand(attachCmd),",
          "100:    storageOpt(pvc.Name))",
          "105:    podSpec,",
          "106:    true)",
          "108:   Entry(\"Filesystem volume mode\", Label(\"FS\"), k8sv1.PersistentVolumeFilesystem, withFileSystem, fsAttachCommand),",
          "109:   Entry(\"Block volume mode\", Label(\"Block\"), k8sv1.PersistentVolumeBlock, withBlock, blockAttachCommand),",
          "112:  It(\"should creates a RW-Many block pvc and attaches to pod\", Label(\"pvcCreation\", \"RWX\", \"Block\"), func() {",
          "113:   pvcName := \"test-pvc\"",
          "114:   storageClassName := \"kubevirt\"",
          "115:   pvc := pvcSpec(pvcName, storageClassName, \"10Mi\")",
          "116:   volumeMode := k8sv1.PersistentVolumeBlock",
          "117:   pvc.Spec.VolumeMode = &volumeMode",
          "118:   pvc.Spec.AccessModes = []k8sv1.PersistentVolumeAccessMode{k8sv1.ReadWriteMany}",
          "120:   By(\"creating a pvc\")",
          "121:   _, err := tenantClient.CoreV1().PersistentVolumeClaims(namespace).Create(context.Background(), pvc, metav1.CreateOptions{})",
          "122:   Expect(err).ToNot(HaveOccurred())",
          "124:   By(\"creating a pod that attaches pvc\")",
          "125:   const (",
          "126:    labelKey         = \"app\"",
          "127:    writerLabelValue = \"writer\"",
          "128:   )",
          "130:   writerPod := runPod(",
          "131:    tenantClient.CoreV1(),",
          "132:    namespace,",
          "133:    createPod(\"writer-pod\",",
          "134:     withBlock(pvc.Name),",
          "135:     withCommand(blockWriteCommand+\" && sleep 60\"),",
          "136:     withLabel(labelKey, writerLabelValue),",
          "137:    ),",
          "138:    false,",
          "139:   )",
          "141:   GinkgoWriter.Printf(\"[DEBUG] writer pod node: %s\\n\", writerPod.Spec.NodeName)",
          "143:   By(\"creating a different pod that reads from pvc\")",
          "144:   Eventually(func(g Gomega) {",
          "145:    readerPod := runPod(",
          "146:     tenantClient.CoreV1(),",
          "147:     namespace,",
          "148:     createPod(\"reader-pod\",",
          "149:      withCommand(blockReadCommand),",
          "150:      withBlock(pvc.Name),",
          "151:      withPodAntiAffinity(labelKey, writerLabelValue),",
          "152:     ),",
          "153:     true,",
          "154:    )",
          "156:    defer deletePod(tenantClient.CoreV1(), namespace, readerPod.Name)",
          "157:    GinkgoWriter.Printf(\"[DEBUG] reader pod node: %s\\n\", readerPod.Spec.NodeName)",
          "159:    s := tenantClient.CoreV1().Pods(namespace).GetLogs(readerPod.Name, &k8sv1.PodLogOptions{})",
          "160:    reader, err := s.Stream(context.Background())",
          "161:    g.Expect(err).ToNot(HaveOccurred())",
          "162:    defer reader.Close()",
          "163:    buf := new(bytes.Buffer)",
          "164:    n, err := buf.ReadFrom(reader)",
          "165:    g.Expect(err).ToNot(HaveOccurred())",
          "167:    g.Expect(n).To(BeEquivalentTo(len(\"testing\\n\")))",
          "168:    out := buf.String()",
          "169:    g.Expect(strings.TrimSpace(out)).To(Equal(\"testing\"))",
          "171:   }).WithTimeout(120 * time.Second).WithPolling(20 * time.Second).Should(Succeed())",
          "173:   deletePod(tenantClient.CoreV1(), namespace, writerPod.Name)",
          "174:  })",
          "176:  It(\"should reject a RW-Many file-system pvc and attaches to pod\", Label(\"pvcCreation\", \"RWX\", \"FS\"), func() {",
          "177:   const pvcName = \"test-pvc\"",
          "178:   storageClassName := \"kubevirt\"",
          "179:   pvc := pvcSpec(pvcName, storageClassName, \"10Mi\")",
          "180:   volumeMode := k8sv1.PersistentVolumeFilesystem",
          "181:   pvc.Spec.VolumeMode = &volumeMode",
          "182:   pvc.Spec.AccessModes = []k8sv1.PersistentVolumeAccessMode{k8sv1.ReadWriteMany}",
          "184:   By(\"creating a pvc\")",
          "185:   _, err := tenantClient.CoreV1().PersistentVolumeClaims(namespace).Create(context.Background(), pvc, metav1.CreateOptions{})",
          "186:   Expect(err).ToNot(HaveOccurred())",
          "188:   By(\"creating a pod that attaches pvc\")",
          "189:   runPodAndExpectPending(",
          "190:    tenantClient.CoreV1(),",
          "191:    namespace,",
          "192:    createPod(\"test-pod\", withFileSystem(pvc.Name), withCommand(fsAttachCommand)))",
          "194:   Eventually(func(g Gomega) bool {",
          "196:    events, err := tenantClient.CoreV1().Events(namespace).List(context.Background(), metav1.ListOptions{FieldSelector: fmt.Sprintf(\"involvedObject.name=%s\", pvcName), TypeMeta: metav1.TypeMeta{Kind: \"PersistentVolumeClaim\"}})",
          "197:    g.Expect(err).ToNot(HaveOccurred())",
          "199:    foundError := false",
          "200:    GinkgoWriter.Println(\"PVC Events:\")",
          "201:    for _, evt := range events.Items {",
          "202:     GinkgoWriter.Println(evt.Message)",
          "203:     if strings.Contains(evt.Message, \"non-block volume with RWX access mode is not supported\") {",
          "204:      foundError = true",
          "205:     }",
          "206:    }",
          "208:    return foundError",
          "209:   }).WithTimeout(5 * time.Minute).WithPolling(10 * time.Second).Should(BeTrue())",
          "211:  })",
          "213:  DescribeTable(\"creates a pvc, attaches to pod, re-attach to another pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, storageOpt storageOption, attachCmd string) {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "123:   _, err = tenantClient.CoreV1().PersistentVolumeClaims(namespace).Create(context.Background(), pvc, metav1.CreateOptions{})",
          "124:   Expect(err).ToNot(HaveOccurred())",
          "129:   By(fmt.Sprintf(\"creating a pod that attaches pvc on node %s\", host1))",
          "131:   deletePod(tenantClient.CoreV1(), namespace, pod.Name)",
          "133:   pod.Spec.NodeSelector = map[string]string{hostNameLabelKey: host2}",
          "134:   By(fmt.Sprintf(\"creating a pod that attaches pvc on node %s\", host2))",
          "136:   deletePod(tenantClient.CoreV1(), namespace, anotherPod.Name)",
          "137:  },",
          "140:  )",
          "143:   By(\"creating a pvc\")",
          "144:   pvc := pvcSpec(\"test-pvc\", \"kubevirt\", \"10Mi\")",
          "145:   pvc.Spec.VolumeMode = &volumeMode",
          "",
          "[Removed Lines]",
          "126:   podSpec := podCreationFunc(pvc.Name)",
          "127:   podSpec.Spec.NodeSelector = map[string]string{hostNameLabelKey: host1}",
          "130:   pod := runPod(tenantClient.CoreV1(), namespace, podSpec)",
          "135:   anotherPod := runPod(tenantClient.CoreV1(), namespace, podSpec)",
          "138:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, attacherPodFs),",
          "139:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, attacherPodBlock),",
          "142:  DescribeTable(\"verify persistence - creates a pvc, attaches to writer pod, re-attach to a reader pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, podWriterFunc func(string) *k8sv1.Pod, podReaderFunc func(string) *k8sv1.Pod) {",
          "",
          "[Added Lines]",
          "231:   podSpec := createPod(\"test-pod\",",
          "232:    storageOpt(pvc.Name),",
          "233:    withCommand(attachCmd),",
          "234:    withNodeSelector(hostNameLabelKey, host1))",
          "237:   pod := runPod(tenantClient.CoreV1(), namespace, podSpec, true)",
          "242:   anotherPod := runPod(tenantClient.CoreV1(), namespace, podSpec, true)",
          "245:   Entry(\"Filesystem volume mode\", Label(\"FS\"), k8sv1.PersistentVolumeFilesystem, withFileSystem, fsAttachCommand),",
          "246:   Entry(\"Block volume mode\", Label(\"Block\"), k8sv1.PersistentVolumeBlock, withBlock, blockAttachCommand),",
          "249:  DescribeTable(\"verify persistence - creates a pvc, attaches to writer pod, re-attach to a reader pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, storageOpt storageOption, writeCmd, readCmd string) {",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "147:   Expect(err).ToNot(HaveOccurred())",
          "149:   By(\"creating a pod that writes to pvc on node\")",
          "151:   deletePod(tenantClient.CoreV1(), namespace, writerPod.Name)",
          "153:   By(\"creating a different pod that reads from pvc\")",
          "155:   s := tenantClient.CoreV1().Pods(namespace).GetLogs(readerPod.Name, &k8sv1.PodLogOptions{})",
          "156:   reader, err := s.Stream(context.Background())",
          "157:   Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "150:   writerPod := runPod(tenantClient.CoreV1(), namespace, podWriterFunc(pvc.Name))",
          "154:   readerPod := runPod(tenantClient.CoreV1(), namespace, podReaderFunc(pvc.Name))",
          "",
          "[Added Lines]",
          "257:   rPod := createPod(\"writer-pod\",",
          "258:    withCommand(writeCmd),",
          "259:    storageOpt(pvc.Name),",
          "260:   )",
          "261:   writerPod := runPod(tenantClient.CoreV1(), namespace, rPod, true)",
          "265:   wPod := createPod(\"reader-pod\",",
          "266:    withCommand(readCmd),",
          "267:    storageOpt(pvc.Name))",
          "268:   readerPod := runPod(tenantClient.CoreV1(), namespace, wPod, true)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "165:   Expect(strings.TrimSpace(out)).To(Equal(\"testing\"))",
          "166:   deletePod(tenantClient.CoreV1(), namespace, readerPod.Name)",
          "167:  },",
          "170:  )",
          "173:   By(\"creating a pvc\")",
          "174:   pvc1 := pvcSpec(\"test-pvc1\", \"kubevirt\", \"10Mi\")",
          "175:   pvc1.Spec.VolumeMode = &volumeMode",
          "",
          "[Removed Lines]",
          "168:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, writerPodFs, readerPodFs),",
          "169:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, writerPodBlock, readerPodBlock),",
          "172:  DescribeTable(\"multi attach - creates 3 pvcs, attach all 3 to pod, detach all 3 from the pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, podCreationFunc func(string) *k8sv1.Pod) {",
          "",
          "[Added Lines]",
          "282:   Entry(\"Filesystem volume mode\", Label(\"FS\"), k8sv1.PersistentVolumeFilesystem, withFileSystem, fsWriteCommand, fsReadCommand),",
          "283:   Entry(\"Block volume mode\", Label(\"Block\"), k8sv1.PersistentVolumeBlock, withBlock, blockWriteCommand, blockReadCommand),",
          "286:  DescribeTable(\"multi attach - creates 3 pvcs, attach all 3 to pod, detach all 3 from the pod\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, storageOpt storageOption, attachCmd string) {",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "185:   Expect(err).ToNot(HaveOccurred())",
          "187:   By(\"creating a pod that uses 3 PVCs\")",
          "193:   deletePod(tenantClient.CoreV1(), namespace, pod.Name)",
          "194:  },",
          "197:  )",
          "200:   nodes, err := tenantClient.CoreV1().Nodes().List(context.Background(), metav1.ListOptions{})",
          "201:   Expect(err).ToNot(HaveOccurred())",
          "202:   host := nodes.Items[0].Labels[hostNameLabelKey]",
          "",
          "[Removed Lines]",
          "188:   podSpec := podCreationFunc(pvc1.Name)",
          "189:   addPvc(podSpec, pvc2.Name, \"/pv2\")",
          "190:   addPvc(podSpec, pvc3.Name, \"/pv3\")",
          "192:   pod := runPod(tenantClient.CoreV1(), namespace, podSpec)",
          "195:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, attacherPodFs),",
          "196:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, attacherPodBlock),",
          "199:  DescribeTable(\"multi attach - create multiple pods pvcs on same node, and each pod should connect to a different PVC\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, podCreationFunc func(string) *k8sv1.Pod) {",
          "",
          "[Added Lines]",
          "302:   podSpec := createPod(\"test-pod\",",
          "303:    withCommand(attachCmd),",
          "304:    storageOpt(pvc1.Name),",
          "305:    withPVC(pvc2.Name, \"/pv2\"),",
          "306:    withPVC(pvc3.Name, \"/pv3\"))",
          "308:   pod := runPod(tenantClient.CoreV1(), namespace, podSpec, true)",
          "311:   Entry(\"Filesystem volume mode\", Label(\"FS\"), k8sv1.PersistentVolumeFilesystem, withFileSystem, fsAttachCommand),",
          "312:   Entry(\"Block volume mode\", Label(\"Block\"), k8sv1.PersistentVolumeBlock, withBlock, blockAttachCommand),",
          "315:  DescribeTable(\"multi attach - create multiple pods pvcs on same node, and each pod should connect to a different PVC\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, storageOpt storageOption, attachCmd string) {",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "216:   podList := make([]*k8sv1.Pod, 0)",
          "217:   for _, pvc := range pvcList {",
          "221:    By(fmt.Sprintf(\"creating a pod that attaches pvc on node %s\", host))",
          "223:    podList = append(podList, pod)",
          "224:   }",
          "225:   Eventually(func() bool {",
          "",
          "[Removed Lines]",
          "218:    podSpec := podCreationFunc(pvc.Name)",
          "219:    podSpec.Spec.NodeSelector = map[string]string{hostNameLabelKey: host}",
          "222:    pod := runPod(tenantClient.CoreV1(), namespace, podSpec)",
          "",
          "[Added Lines]",
          "334:    podSpec := createPod(\"test-pod\",",
          "335:     storageOpt(pvc.Name),",
          "336:     withCommand(attachCmd),",
          "337:     withNodeSelector(hostNameLabelKey, host))",
          "340:    pod := runPod(tenantClient.CoreV1(), namespace, podSpec, true)",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "240:    deletePod(tenantClient.CoreV1(), namespace, pod.Name)",
          "241:   }",
          "242:  },",
          "245:  )",
          "248:   pvcName := \"test-pvc\"",
          "249:   storageClassName := \"kubevirt\"",
          "250:   pvc := pvcSpec(pvcName, storageClassName, \"10Mi\")",
          "",
          "[Removed Lines]",
          "243:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, attacherPodFs),",
          "244:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, attacherPodBlock),",
          "247:  DescribeTable(\"Verify infra cluster cleanup\", Label(\"pvc cleanup\"), func(volumeMode k8sv1.PersistentVolumeMode, podCreationFunc func(string) *k8sv1.Pod) {",
          "",
          "[Added Lines]",
          "361:   Entry(\"Filesystem volume mode\", Label(\"FS\"), k8sv1.PersistentVolumeFilesystem, withFileSystem, fsAttachCommand),",
          "362:   Entry(\"Block volume mode\", Label(\"Block\"), k8sv1.PersistentVolumeBlock, withBlock, blockAttachCommand),",
          "365:  DescribeTable(\"Verify infra cluster cleanup\", Label(\"pvc cleanup\"), func(volumeMode k8sv1.PersistentVolumeMode, storageOpt storageOption, attachCmd string) {",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "258:   }, time.Second*30, time.Second).Should(Equal(k8sv1.ClaimBound))",
          "259:   volumeName := pvc.Spec.VolumeName",
          "263:   pod, err = tenantClient.CoreV1().Pods(namespace).Get(context.Background(), pod.Name, metav1.GetOptions{})",
          "264:   Expect(err).ToNot(HaveOccurred())",
          "265:   Expect(pod.Status.Phase).To(BeElementOf(k8sv1.PodSucceeded, k8sv1.PodRunning))",
          "",
          "[Removed Lines]",
          "261:   podSpec := podCreationFunc(pvc.Name)",
          "262:   pod := runPod(tenantClient.CoreV1(), namespace, podSpec)",
          "",
          "[Added Lines]",
          "379:   podSpec := createPod(\"test-pod\",",
          "380:    storageOpt(pvc.Name),",
          "381:    withCommand(attachCmd))",
          "383:   pod := runPod(tenantClient.CoreV1(), namespace, podSpec, true)",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "283:    return errors.IsNotFound(err)",
          "284:   }, 1*time.Minute, 2*time.Second).Should(BeTrue(), \"infra pvc should disappear\")",
          "285:  },",
          "288:  )",
          "290:  Context(\"Should prevent access to volumes from infra cluster\", func() {",
          "",
          "[Removed Lines]",
          "286:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, attacherPodFs),",
          "287:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, attacherPodBlock),",
          "",
          "[Added Lines]",
          "407:   Entry(\"Filesystem volume mode\", Label(\"FS\"), k8sv1.PersistentVolumeFilesystem, withFileSystem, fsAttachCommand),",
          "408:   Entry(\"Block volume mode\", Label(\"Block\"), k8sv1.PersistentVolumeBlock, withBlock, blockAttachCommand),",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "393:    }",
          "394:    tenantPVC, err = tenantClient.CoreV1().PersistentVolumeClaims(namespace).Create(context.Background(), tenantPVC, metav1.CreateOptions{})",
          "395:    Expect(err).ToNot(HaveOccurred())",
          "397:    By(\"Creating pod that attempts to use the specially crafted PVC\")",
          "398:    pod, err = tenantClient.CoreV1().Pods(namespace).Create(context.Background(), pod, metav1.CreateOptions{})",
          "399:    Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "396:    pod := writerPodFs(tenantPVC.Name)",
          "",
          "[Added Lines]",
          "517:    pod := createPod(\"reader-pod\", withFileSystem(tenantPVC.Name), withCommand(fsWriteCommand))",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "418:  })",
          "419: })",
          "589: func pvcSpec(pvcName, storageClassName, size string) *k8sv1.PersistentVolumeClaim {",
          "590:  quantity, err := resource.ParseQuantity(size)",
          "591:  Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "421: func writerPodFs(volumeName string) *k8sv1.Pod {",
          "422:  return podWithFilesystemPvcSpec(\"writer-pod\",",
          "423:   volumeName,",
          "424:   []string{\"sh\"},",
          "425:   []string{\"-c\", \"echo testing > /opt/test.txt\"})",
          "426: }",
          "428: func readerPodFs(pvcName string) *k8sv1.Pod {",
          "429:  return podWithFilesystemPvcSpec(\"reader-pod\",",
          "430:   pvcName,",
          "431:   []string{\"sh\"},",
          "432:   []string{\"-c\", \"cat /opt/test.txt\"})",
          "433: }",
          "435: func writerPodBlock(volumeName string) *k8sv1.Pod {",
          "436:  return podWithBlockPvcSpec(\"writer-pod\",",
          "437:   volumeName,",
          "438:   []string{\"sh\"},",
          "439:   []string{\"-c\", \"echo testing > /dev/csi\"})",
          "440: }",
          "442: func readerPodBlock(pvcName string) *k8sv1.Pod {",
          "443:  return podWithBlockPvcSpec(\"reader-pod\",",
          "444:   pvcName,",
          "445:   []string{\"sh\"},",
          "446:   []string{\"-c\", \"head -c 8 /dev/csi\"})",
          "447: }",
          "449: func attacherPodFs(pvcName string) *k8sv1.Pod {",
          "450:  return podWithFilesystemPvcSpec(\"test-pod\",",
          "451:   pvcName,",
          "452:   []string{\"sh\"},",
          "453:   []string{\"-c\", \"ls -la /opt && echo kubevirt-csi-driver && mktemp /opt/test-XXXXXX\"})",
          "454: }",
          "456: func attacherPodBlock(pvcName string) *k8sv1.Pod {",
          "457:  return podWithBlockPvcSpec(\"test-pod\",",
          "458:   pvcName,",
          "459:   []string{\"sh\"},",
          "460:   []string{\"-c\", \"ls -al /dev/csi\"})",
          "461: }",
          "463: func podWithoutPVCSpec(podName string, cmd, args []string) *k8sv1.Pod {",
          "464:  image := \"busybox\"",
          "465:  return &k8sv1.Pod{",
          "466:   ObjectMeta: metav1.ObjectMeta{",
          "467:    GenerateName: podName,",
          "468:   },",
          "469:   Spec: k8sv1.PodSpec{",
          "470:    SecurityContext: &k8sv1.PodSecurityContext{",
          "471:     SeccompProfile: &k8sv1.SeccompProfile{",
          "472:      Type: k8sv1.SeccompProfileTypeRuntimeDefault,",
          "473:     },",
          "474:    },",
          "475:    RestartPolicy: k8sv1.RestartPolicyNever,",
          "476:    Containers: []k8sv1.Container{",
          "477:     {",
          "478:      SecurityContext: &k8sv1.SecurityContext{",
          "479:       Capabilities: &k8sv1.Capabilities{",
          "480:        Drop: []k8sv1.Capability{",
          "481:         \"ALL\",",
          "482:        },",
          "483:       },",
          "484:      },",
          "485:      Name:    podName,",
          "486:      Image:   image,",
          "487:      Command: cmd,",
          "488:      Args:    args,",
          "489:     },",
          "490:    },",
          "492:    Tolerations: []k8sv1.Toleration{",
          "493:     {",
          "494:      Key:      \"node-role.kubernetes.io/master\",",
          "495:      Operator: k8sv1.TolerationOpExists,",
          "496:      Effect:   k8sv1.TaintEffectNoSchedule,",
          "497:     },",
          "498:     {",
          "499:      Key:      \"node-role.kubernetes.io/control-plane\",",
          "500:      Operator: k8sv1.TolerationOpExists,",
          "501:      Effect:   k8sv1.TaintEffectNoSchedule,",
          "502:     },",
          "503:    },",
          "504:   },",
          "505:  }",
          "506: }",
          "508: func podWithBlockPvcSpec(podName, pvcName string, cmd, args []string) *k8sv1.Pod {",
          "509:  podSpec := podWithoutPVCSpec(podName, cmd, args)",
          "510:  volumeName := \"blockpv\"",
          "511:  podSpec.Spec.Volumes = append(podSpec.Spec.Volumes, k8sv1.Volume{",
          "512:   Name: volumeName,",
          "513:   VolumeSource: k8sv1.VolumeSource{",
          "514:    PersistentVolumeClaim: &k8sv1.PersistentVolumeClaimVolumeSource{",
          "515:     ClaimName: pvcName,",
          "516:    },",
          "517:   },",
          "518:  })",
          "519:  podSpec.Spec.Containers[0].VolumeDevices = []k8sv1.VolumeDevice{",
          "520:   {",
          "521:    Name:       volumeName,",
          "522:    DevicePath: \"/dev/csi\",",
          "523:   },",
          "524:  }",
          "525:  return podSpec",
          "526: }",
          "528: func podWithFilesystemPvcSpec(podName, pvcName string, cmd, args []string) *k8sv1.Pod {",
          "529:  podSpec := podWithoutPVCSpec(podName, cmd, args)",
          "530:  volumeName := \"fspv\"",
          "531:  podSpec.Spec.Volumes = append(podSpec.Spec.Volumes, k8sv1.Volume{",
          "532:   Name: volumeName,",
          "533:   VolumeSource: k8sv1.VolumeSource{",
          "534:    PersistentVolumeClaim: &k8sv1.PersistentVolumeClaimVolumeSource{",
          "535:     ClaimName: pvcName,",
          "536:    },",
          "537:   },",
          "538:  })",
          "539:  podSpec.Spec.Containers[0].VolumeMounts = []k8sv1.VolumeMount{",
          "540:   {",
          "541:    Name:      volumeName,",
          "542:    MountPath: \"/opt\",",
          "543:   },",
          "544:  }",
          "545:  return podSpec",
          "546: }",
          "548: func addPvc(podSpec *k8sv1.Pod, pvcName string, mountPath string) *k8sv1.Pod {",
          "549:  volumeName := pvcName",
          "550:  podSpec.Spec.Volumes = append(",
          "551:   podSpec.Spec.Volumes,",
          "552:   k8sv1.Volume{",
          "553:    Name: volumeName,",
          "554:    VolumeSource: k8sv1.VolumeSource{",
          "555:     PersistentVolumeClaim: &k8sv1.PersistentVolumeClaimVolumeSource{",
          "556:      ClaimName: pvcName,",
          "557:     },",
          "558:    },",
          "559:   })",
          "560:  if len(podSpec.Spec.Containers[0].VolumeMounts) > 0 {",
          "561:   podSpec = addVolumeMount(podSpec, volumeName, mountPath)",
          "562:  }",
          "563:  if len(podSpec.Spec.Containers[0].VolumeDevices) > 0 {",
          "564:   podSpec = addVolumeDevice(podSpec, volumeName)",
          "565:  }",
          "566:  return podSpec",
          "567: }",
          "569: func addVolumeMount(podSpec *k8sv1.Pod, volumeName string, mountPath string) *k8sv1.Pod {",
          "570:  podSpec.Spec.Containers[0].VolumeMounts = append(",
          "571:   podSpec.Spec.Containers[0].VolumeMounts,",
          "572:   k8sv1.VolumeMount{",
          "573:    Name:      volumeName,",
          "574:    MountPath: mountPath,",
          "575:   })",
          "576:  return podSpec",
          "577: }",
          "579: func addVolumeDevice(podSpec *k8sv1.Pod, volumeName string) *k8sv1.Pod {",
          "580:  podSpec.Spec.Containers[0].VolumeDevices = append(",
          "581:   podSpec.Spec.Containers[0].VolumeDevices,",
          "582:   k8sv1.VolumeDevice{",
          "583:    Name:       volumeName,",
          "584:    DevicePath: fmt.Sprintf(\"/dev/%s\", volumeName),",
          "585:   })",
          "586:  return podSpec",
          "587: }",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 15 ---",
          "[Context before]",
          "606:  return pvc",
          "607: }",
          "610:  pod, err := client.Pods(namespace).Create(context.Background(), pod, metav1.CreateOptions{})",
          "611:  Expect(err).ToNot(HaveOccurred())",
          "613:  By(\"Wait for pod to reach a completed phase\")",
          "615:   pod, err = client.Pods(namespace).Get(context.Background(), pod.Name, metav1.GetOptions{})",
          "627:  events, err := client.Events(namespace).List(context.Background(), metav1.ListOptions{FieldSelector: fmt.Sprintf(\"involvedObject.name=%s\", pod.Name), TypeMeta: metav1.TypeMeta{Kind: \"Pod\"}})",
          "628:  Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "609: func runPod(client v1.CoreV1Interface, namespace string, pod *k8sv1.Pod) *k8sv1.Pod {",
          "614:  Eventually(func() error {",
          "616:   if err != nil {",
          "617:    return err",
          "618:   }",
          "620:   if pod.Status.Phase != k8sv1.PodSucceeded {",
          "621:    return fmt.Errorf(\"Pod in phase %s, expected Succeeded\", pod.Status.Phase)",
          "622:   }",
          "624:   return nil",
          "625:  }, 3*time.Minute, 5*time.Second).Should(Succeed(), \"Pod should reach Succeeded state\")",
          "",
          "[Added Lines]",
          "563: func runPod(client v1.CoreV1Interface, namespace string, pod *k8sv1.Pod, waitComplete bool) *k8sv1.Pod {",
          "567:  expectedPhase := k8sv1.PodSucceeded",
          "568:  if !waitComplete {",
          "569:   expectedPhase = k8sv1.PodRunning",
          "570:  }",
          "572:  Eventually(func(g Gomega) k8sv1.PodPhase {",
          "574:   g.Expect(err).ToNot(HaveOccurred())",
          "575:   return pod.Status.Phase",
          "576:  }, 3*time.Minute, 5*time.Second).Should(Equal(expectedPhase), \"Pod should reach Succeeded state\")",
          "",
          "---------------",
          "--- Hunk 16 ---",
          "[Context before]",
          "633:  return pod",
          "634: }",
          "636: func deletePod(client v1.CoreV1Interface, ns, podName string) {",
          "637:  By(\"Delete pod\")",
          "638:  zero := int64(0)",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "588: func runPodAndExpectPending(client v1.CoreV1Interface, namespace string, pod *k8sv1.Pod) {",
          "589:  pod, err := client.Pods(namespace).Create(context.Background(), pod, metav1.CreateOptions{})",
          "590:  Expect(err).ToNot(HaveOccurred())",
          "592:  Eventually(func(g Gomega) k8sv1.PodPhase {",
          "593:   pod, err = client.Pods(namespace).Get(context.Background(), pod.Name, metav1.GetOptions{})",
          "594:   g.Expect(err).ToNot(HaveOccurred())",
          "596:   return pod.Status.Phase",
          "597:  }).WithTimeout(60*time.Second).WithPolling(5*time.Second).Should(Equal(k8sv1.PodPending), \"Pod should never reach Succeeded state\")",
          "598: }",
          "",
          "---------------"
        ],
        "e2e/create_pod_helper_test.go||e2e/create_pod_helper_test.go": [
          "File: e2e/create_pod_helper_test.go -> e2e/create_pod_helper_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "[No context available]",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1: package e2e_test",
          "3: import (",
          "4:  \"fmt\"",
          "6:  k8sv1 \"k8s.io/api/core/v1\"",
          "7:  metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "8: )",
          "10: const (",
          "11:  fsCommonFile    = \"/opt/test.txt\"",
          "12:  fsWriteCommand  = \"echo testing > \" + fsCommonFile",
          "13:  fsReadCommand   = \"cat \" + fsCommonFile",
          "14:  fsAttachCommand = \"ls -la /opt && echo kubevirt-csi-driver && mktemp /opt/test-XXXXXX\"",
          "16:  blockCommonFile    = \"/dev/csi\"",
          "17:  blockWriteCommand  = \"echo testing > \" + blockCommonFile",
          "18:  blockReadCommand   = \"head -c 8 \" + blockCommonFile",
          "19:  blockAttachCommand = \"ls -al /dev/csi\"",
          "20: )",
          "22: type podOption func(pod *k8sv1.Pod)",
          "23: type storageOption func(string) podOption",
          "25: func createPod(podName string, opts ...podOption) *k8sv1.Pod {",
          "26:  pod := &k8sv1.Pod{",
          "27:   ObjectMeta: metav1.ObjectMeta{",
          "28:    GenerateName: podName,",
          "29:   },",
          "30:   Spec: k8sv1.PodSpec{",
          "31:    SecurityContext: &k8sv1.PodSecurityContext{",
          "32:     SeccompProfile: &k8sv1.SeccompProfile{",
          "33:      Type: k8sv1.SeccompProfileTypeRuntimeDefault,",
          "34:     },",
          "35:    },",
          "36:    RestartPolicy: k8sv1.RestartPolicyNever,",
          "37:    Containers: []k8sv1.Container{",
          "38:     {",
          "39:      SecurityContext: &k8sv1.SecurityContext{",
          "40:       Capabilities: &k8sv1.Capabilities{",
          "41:        Drop: []k8sv1.Capability{",
          "42:         \"ALL\",",
          "43:        },",
          "44:       },",
          "45:      },",
          "46:      Name:  podName,",
          "47:      Image: \"busybox\",",
          "48:     },",
          "49:    },",
          "51:    Tolerations: []k8sv1.Toleration{",
          "52:     {",
          "53:      Key:      \"node-role.kubernetes.io/master\",",
          "54:      Operator: k8sv1.TolerationOpExists,",
          "55:      Effect:   k8sv1.TaintEffectNoSchedule,",
          "56:     },",
          "57:     {",
          "58:      Key:      \"node-role.kubernetes.io/control-plane\",",
          "59:      Operator: k8sv1.TolerationOpExists,",
          "60:      Effect:   k8sv1.TaintEffectNoSchedule,",
          "61:     },",
          "62:    },",
          "63:   },",
          "64:  }",
          "66:  for _, o := range opts {",
          "67:   o(pod)",
          "68:  }",
          "70:  return pod",
          "71: }",
          "73: func withCommand(cmd string) podOption {",
          "74:  return func(pod *k8sv1.Pod) {",
          "75:   pod.Spec.Containers[0].Command = []string{\"sh\"}",
          "76:   pod.Spec.Containers[0].Args = []string{\"-c\", cmd}",
          "77:  }",
          "78: }",
          "80: func withBlock(pvcName string) podOption {",
          "81:  const volumeName = \"blockpv\"",
          "82:  return func(pod *k8sv1.Pod) {",
          "83:   pod.Spec.Volumes = append(pod.Spec.Volumes, getVolume(volumeName, pvcName))",
          "84:   pod.Spec.Containers[0].VolumeDevices = []k8sv1.VolumeDevice{",
          "85:    {",
          "86:     Name:       volumeName,",
          "87:     DevicePath: \"/dev/csi\",",
          "88:    },",
          "89:   }",
          "90:  }",
          "91: }",
          "93: func withFileSystem(pvcName string) podOption {",
          "94:  const volumeName = \"fspv\"",
          "95:  return func(pod *k8sv1.Pod) {",
          "96:   pod.Spec.Volumes = append(pod.Spec.Volumes, getVolume(volumeName, pvcName))",
          "97:   pod.Spec.Containers[0].VolumeMounts = []k8sv1.VolumeMount{",
          "98:    {",
          "99:     Name:      volumeName,",
          "100:     MountPath: \"/opt\",",
          "101:    },",
          "102:   }",
          "103:  }",
          "104: }",
          "106: func withNodeSelector(key, value string) podOption {",
          "107:  return func(pod *k8sv1.Pod) {",
          "108:   if pod.Spec.NodeSelector == nil {",
          "109:    pod.Spec.NodeSelector = make(map[string]string)",
          "110:   }",
          "111:   pod.Spec.NodeSelector[key] = value",
          "112:  }",
          "113: }",
          "115: func withLabel(key, value string) podOption {",
          "116:  return func(pod *k8sv1.Pod) {",
          "117:   if pod.Labels == nil {",
          "118:    pod.Labels = make(map[string]string)",
          "119:   }",
          "120:   pod.Labels[key] = value",
          "121:  }",
          "122: }",
          "124: func withPodAntiAffinity(key, value string) podOption {",
          "125:  return func(pod *k8sv1.Pod) {",
          "126:   pod.Spec.Affinity = &k8sv1.Affinity{",
          "127:    PodAntiAffinity: &k8sv1.PodAntiAffinity{",
          "128:     RequiredDuringSchedulingIgnoredDuringExecution: []k8sv1.PodAffinityTerm{",
          "129:      {",
          "130:       LabelSelector: &metav1.LabelSelector{",
          "131:        MatchExpressions: []metav1.LabelSelectorRequirement{",
          "132:         {",
          "133:          Key:      key,",
          "134:          Operator: metav1.LabelSelectorOpIn,",
          "135:          Values:   []string{value},",
          "136:         },",
          "137:        },",
          "138:       },",
          "139:       TopologyKey: hostNameLabelKey,",
          "140:      },",
          "141:     },",
          "142:    },",
          "143:   }",
          "144:  }",
          "145: }",
          "147: func getVolume(volumeName, pvcName string) k8sv1.Volume {",
          "148:  return k8sv1.Volume{",
          "149:   Name: volumeName,",
          "150:   VolumeSource: k8sv1.VolumeSource{",
          "151:    PersistentVolumeClaim: &k8sv1.PersistentVolumeClaimVolumeSource{",
          "152:     ClaimName: pvcName,",
          "153:    },",
          "154:   },",
          "155:  }",
          "156: }",
          "158: func withPVC(pvcName string, mountPath string) podOption {",
          "159:  return func(pod *k8sv1.Pod) {",
          "160:   pod.Spec.Volumes = append(pod.Spec.Volumes, getVolume(pvcName, pvcName))",
          "161:   if len(pod.Spec.Containers[0].VolumeMounts) > 0 {",
          "162:    addVolumeMount(pod, pvcName, mountPath)",
          "163:   }",
          "164:   if len(pod.Spec.Containers[0].VolumeDevices) > 0 {",
          "165:    addVolumeDevice(pod, pvcName)",
          "166:   }",
          "168:  }",
          "169: }",
          "171: func addVolumeMount(podSpec *k8sv1.Pod, volumeName string, mountPath string) {",
          "172:  podSpec.Spec.Containers[0].VolumeMounts = append(",
          "173:   podSpec.Spec.Containers[0].VolumeMounts,",
          "174:   k8sv1.VolumeMount{",
          "175:    Name:      volumeName,",
          "176:    MountPath: mountPath,",
          "177:   })",
          "178: }",
          "180: func addVolumeDevice(podSpec *k8sv1.Pod, volumeName string) {",
          "181:  podSpec.Spec.Containers[0].VolumeDevices = append(",
          "182:   podSpec.Spec.Containers[0].VolumeDevices,",
          "183:   k8sv1.VolumeDevice{",
          "184:    Name:       volumeName,",
          "185:    DevicePath: fmt.Sprintf(\"/dev/%s\", volumeName),",
          "186:   })",
          "187: }",
          "",
          "---------------"
        ],
        "e2e/snapshot_test.go||e2e/snapshot_test.go": [
          "File: e2e/snapshot_test.go -> e2e/snapshot_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "6:  \"os\"",
          "7:  \"time\"",
          "9:  . \"github.com/onsi/ginkgo/v2\"",
          "10:  . \"github.com/onsi/gomega\"",
          "11:  k8sv1 \"k8s.io/api/core/v1\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "9:  snapshotv1 \"github.com/kubernetes-csi/external-snapshotter/client/v6/apis/volumesnapshot/v1\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "13:  \"k8s.io/apimachinery/pkg/util/rand\"",
          "14:  \"k8s.io/client-go/kubernetes\"",
          "15:  \"k8s.io/utils/ptr\"",
          "19: )",
          "21: var _ = Describe(\"Snapshot\", func() {",
          "",
          "[Removed Lines]",
          "16:  snapcli \"kubevirt.io/csi-driver/pkg/generated/external-snapshotter/client-go/clientset/versioned\"",
          "18:  snapshotv1 \"github.com/kubernetes-csi/external-snapshotter/client/v6/apis/volumesnapshot/v1\"",
          "",
          "[Added Lines]",
          "18:  snapcli \"kubevirt.io/csi-driver/pkg/generated/external-snapshotter/client-go/clientset/versioned\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "59:   _ = os.RemoveAll(tmpDir)",
          "60:  })",
          "63:   pvcName := \"test-pvc\"",
          "64:   storageClassName := \"kubevirt\"",
          "65:   pvc := pvcSpec(pvcName, storageClassName, \"10Mi\")",
          "",
          "[Removed Lines]",
          "62:  DescribeTable(\"creates a pvc and attaches to pod, then create snapshot\", Label(\"pvcCreation\"), func(volumeMode k8sv1.PersistentVolumeMode, podCreationFunc, podReaderFunc func(string) *k8sv1.Pod) {",
          "",
          "[Added Lines]",
          "62:  DescribeTable(\"creates a pvc and attaches to pod, then create snapshot\", Label(\"pvcCreation\", \"snapshot\"), func(volumeMode k8sv1.PersistentVolumeMode, storageOpt storageOption, writeCmd, readCmd string) {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "70:   Expect(err).ToNot(HaveOccurred())",
          "72:   By(\"creating a pod that attaches pvc\")",
          "73:   runPod(",
          "74:    tenantClient.CoreV1(),",
          "75:    namespace,",
          "78:   By(\"creating a snapshot\")",
          "79:   snapshotName := \"test-snapshot\"",
          "",
          "[Removed Lines]",
          "76:    podCreationFunc(pvc.Name))",
          "",
          "[Added Lines]",
          "73:   wPod := createPod(\"writer-pod\",",
          "74:    withCommand(writeCmd),",
          "75:    storageOpt(pvc.Name),",
          "76:   )",
          "80:    wPod,",
          "81:    true)",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "125:   Expect(err).ToNot(HaveOccurred())",
          "127:   By(\"creating a pod that attaches the restored pvc, and checks the changes are there\")",
          "128:   runPod(",
          "129:    tenantClient.CoreV1(),",
          "130:    namespace,",
          "133:  },",
          "136:  )",
          "137: })",
          "",
          "[Removed Lines]",
          "131:    podReaderFunc(pvc.Name))",
          "134:   Entry(\"Filesystem volume mode\", k8sv1.PersistentVolumeFilesystem, writerPodFs, readerPodFs),",
          "135:   Entry(\"Block volume mode\", k8sv1.PersistentVolumeBlock, writerPodBlock, readerPodBlock),",
          "",
          "[Added Lines]",
          "133:   rPod := createPod(\"reader-pod\",",
          "134:    withCommand(readCmd),",
          "135:    storageOpt(pvc.Name))",
          "139:    rPod,",
          "140:    true)",
          "143:   Entry(\"Filesystem volume mode\", Label(\"FS\"), k8sv1.PersistentVolumeFilesystem, withFileSystem, fsWriteCommand, fsReadCommand),",
          "144:   Entry(\"Block volume mode\", Label(\"Block\"), k8sv1.PersistentVolumeBlock, withBlock, blockWriteCommand, blockReadCommand),",
          "",
          "---------------"
        ],
        "hack/cluster-sync-split.sh||hack/cluster-sync-split.sh": [
          "File: hack/cluster-sync-split.sh -> hack/cluster-sync-split.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "101: # ******************************************************",
          "102: # Wait for driver to rollout",
          "103: # ******************************************************",
          "104: _kubectl_tenant rollout status ds/kubevirt-csi-node -n $CSI_DRIVER_NAMESPACE --timeout=10m",
          "105: _kubectl rollout status deployment/kubevirt-csi-controller -n $TENANT_CLUSTER_NAMESPACE --timeout=10m",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "104: _kubectl_tenant rollout restart ds/kubevirt-csi-node -n $CSI_DRIVER_NAMESPACE",
          "105: _kubectl rollout restart deployment/kubevirt-csi-controller -n $TENANT_CLUSTER_NAMESPACE",
          "",
          "---------------"
        ],
        "hack/cluster-up.sh||hack/cluster-up.sh": [
          "File: hack/cluster-up.sh -> hack/cluster-up.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "16: ./kubevirtci create-cluster",
          "18: echo \"Waiting for $TENANT_CLUSTER_NAMESPACE vmis to be ready\"",
          "21: echo \"Installing networking (calico)\"",
          "22: ./kubevirtci install-calico",
          "",
          "[Removed Lines]",
          "19: ./kubevirtci kubectl wait --for=condition=Ready vmi -l capk.cluster.x-k8s.io/kubevirt-machine-namespace=$TENANT_CLUSTER_NAMESPACE -n $TENANT_CLUSTER_NAMESPACE",
          "",
          "[Added Lines]",
          "19: ./kubevirtci kubectl wait --for=condition=Ready vmi -l capk.cluster.x-k8s.io/kubevirt-machine-namespace=$TENANT_CLUSTER_NAMESPACE -n $TENANT_CLUSTER_NAMESPACE --timeout=300s",
          "",
          "---------------"
        ],
        "hack/generate_clients.sh||hack/generate_clients.sh": [
          "File: hack/generate_clients.sh -> hack/generate_clients.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "4: set -o pipefail",
          "6: go install k8s.io/code-generator/cmd/client-gen@latest",
          "8: client-gen --input-base=\"kubevirt.io/api/\" --input=\"core/v1\" --output-package=\"kubevirt.io/csi-driver/pkg/generated/kubevirt/client-go/clientset\" --output-base=\"../../\" --clientset-name=\"versioned\" --go-header-file hack/boilerplate.go.txt",
          "10: go get kubevirt.io/containerized-data-importer-api",
          "",
          "[Removed Lines]",
          "7: go get kubevirt.io/api",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "hack/run-e2e.sh||hack/run-e2e.sh": [
          "File: hack/run-e2e.sh -> hack/run-e2e.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "30:         curl -L \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\" -o ${KUBECTL_PATH}",
          "31:         chmod u+x ${KUBECTL_PATH}",
          "32: fi",
          "34: rm -rf $TEST_WORKING_DIR",
          "35: mkdir -p $TEST_WORKING_DIR",
          "",
          "[Removed Lines]",
          "37: $BIN_DIR/e2e.test -ginkgo.v -test.v -ginkgo.no-color --kubectl-path $KUBECTL_PATH --clusterctl-path $CLUSTERCTL_PATH  --virtctl-path $VIRTCTL_PATH --working-dir $TEST_WORKING_DIR --dump-path $DUMP_PATH --infra-kubeconfig=$KUBECONFIG --infra-cluster-namespace=${INFRA_CLUSTER_NAMESPACE}",
          "",
          "[Added Lines]",
          "34: GINKGO_LABELS=\"\"",
          "35: if [[ -n ${LABELS} ]]; then",
          "36:   GINKGO_LABELS=\"--ginkgo.label-filter=${LABELS}\"",
          "37: fi",
          "42: $BIN_DIR/e2e.test \\",
          "43:   -ginkgo.v \\",
          "44:   -test.v \\",
          "45:   -ginkgo.no-color \\",
          "46:   --kubectl-path \"${KUBECTL_PATH}\" \\",
          "47:   --clusterctl-path \"${CLUSTERCTL_PATH}\"  \\",
          "48:   --virtctl-path \"${VIRTCTL_PATH}\" \\",
          "49:   --working-dir \"${TEST_WORKING_DIR}\" \\",
          "50:   --dump-path \"${DUMP_PATH}\" \\",
          "51:   --infra-kubeconfig=\"${KUBECONFIG}\" \\",
          "52:   --infra-cluster-namespace=\"${INFRA_CLUSTER_NAMESPACE}\" \\",
          "53:   ${GINKGO_LABELS}",
          "",
          "---------------"
        ],
        "hack/run-k8s-e2e.sh||hack/run-k8s-e2e.sh": [
          "File: hack/run-k8s-e2e.sh -> hack/run-k8s-e2e.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "49: function create_test_driver_cm {",
          "50:     echo \"Creating test-driver CM\"",
          "52: }",
          "54: function create_capk_secret {",
          "",
          "[Removed Lines]",
          "51:     ./kubevirtci kubectl create configmap -n $TENANT_CLUSTER_NAMESPACE $test_driver_cm --from-file=./hack/test-driver.yaml",
          "",
          "[Added Lines]",
          "51:     ./kubevirtci kubectl create configmap -n $TENANT_CLUSTER_NAMESPACE $test_driver_cm --from-file=./hack/test-driver.yaml --from-file=./hack/test-driver-rwx.yaml",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95:     - -c",
          "96:     - |",
          "97:       cd /tmp",
          "99:       chmod +x e2e.test",
          "100:       curl -LO \"https://dl.k8s.io/release/v1.26.0/bin/linux/amd64/kubectl\"",
          "101:       chmod +x kubectl",
          "105:       while [ ! -f /tmp/exit.txt ]; do",
          "106:         sleep 2",
          "107:       done",
          "109:     volumeMounts:",
          "110:     - name: kubeconfig",
          "111:       mountPath: \"/etc/kubernetes/kubeconfig\"",
          "",
          "[Removed Lines]",
          "98:       curl --location https://dl.k8s.io/v1.26.0/kubernetes-test-linux-amd64.tar.gz |   tar --strip-components=3 -zxf - kubernetes/test/bin/e2e.test kubernetes/test/bin/ginkgo",
          "102:       echo \\$TEST_DRIVER_PATH",
          "103:       ./e2e.test -kubeconfig \\${KUBECONFIG} -kubectl-path ./kubectl -ginkgo.v -ginkgo.timeout=2h -ginkgo.focus='External.Storage.*csi.kubevirt.io.*' -ginkgo.skip='CSI Ephemeral-volume*' -ginkgo.skip='SELinuxMountReadWriteOncePod.*' -storage.testdriver=\\${TEST_DRIVER_PATH}/test-driver.yaml -provider=local -report-dir=/tmp",
          "104:       ret=\\$?",
          "108:       exit \\$ret",
          "",
          "[Added Lines]",
          "98:       curl --location https://dl.k8s.io/v1.26.0/kubernetes-test-linux-amd64.tar.gz | tar --strip-components=3 -zxf - kubernetes/test/bin/e2e.test kubernetes/test/bin/ginkgo",
          "102:       echo \\${TEST_DRIVER_PATH}",
          "103:       ./e2e.test -kubeconfig \\${KUBECONFIG} \\",
          "104:             -kubectl-path ./kubectl \\",
          "105:             -ginkgo.v \\",
          "106:             -ginkgo.timeout=2h \\",
          "107:             -ginkgo.focus='External.Storage.*csi.kubevirt.io.*' \\",
          "108:             -ginkgo.skip='CSI Ephemeral-volume*' \\",
          "109:             -ginkgo.skip='SELinuxMountReadWriteOncePod.*' \\",
          "110:             -storage.testdriver=\\${TEST_DRIVER_PATH}/test-driver.yaml \\",
          "111:             -provider=local -report-dir=/tmp",
          "112:       ret1=\\$?",
          "113:       if [[ \\${ret1} -ne 0 ]]; then",
          "114:         echo \"kubernetes e2e test failed\"",
          "115:       fi",
          "116:       ./e2e.test -kubeconfig \\${KUBECONFIG} \\",
          "117:             -kubectl-path ./kubectl \\",
          "118:             -ginkgo.v \\",
          "119:             -ginkgo.timeout=2h \\",
          "120:             -ginkgo.focus='External.Storage.*csi.kubevirt.io.*should concurrently access the single volume from pods on different node.*' \\",
          "121:             -ginkgo.skip='CSI Ephemeral-volume*' \\",
          "122:             -ginkgo.skip='SELinuxMountReadWriteOncePod' \\",
          "123:             -ginkgo.skip='\\((?:xfs|filesystem volmode|ntfs|ext4)\\).* multiVolume \\[Slow]' \\",
          "124:             -storage.testdriver=\\${TEST_DRIVER_PATH}/test-driver-rwx.yaml \\",
          "125:             -report-prefix=\"rwx_\" \\",
          "126:             -provider=local -report-dir=/tmp",
          "127:       ret2=\\$?",
          "128:       if [[ \\${ret2} -ne 0 ]]; then",
          "129:         echo \"kubernetes e2e RWX test failed\"",
          "130:       fi",
          "134:       if [[ \\${ret1} -ne 0 ]]; then",
          "135:          exit \\ret1",
          "136:        fi",
          "137:        exit \\$ret2",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135: fi",
          "136: }",
          "138: trap cleanup EXIT SIGSTOP SIGKILL SIGTERM",
          "139: ensure_cluster_up",
          "140: ensure_synced",
          "141: create_test_driver_cm",
          "142: create_capk_secret",
          "143: patch_local_storage_profile",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "167: function make_control_plane_schedulable() {",
          "168:   for node in $(./kubevirtci kubectl-tenant get nodes -l node-role.kubernetes.io/control-plane -o custom-columns=:.metadata.name --no-headers 2>/dev/null | tail -n +2); do",
          "169:     ./kubevirtci kubectl-tenant patch node --type=json -p '[{\"op\": \"remove\", \"path\": \"/spec/taints\"}]' \"${node}\" | tail -n +2 || true",
          "170:   done",
          "171: }",
          "176: make_control_plane_schedulable",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "150:   sleep 30",
          "151: done",
          "153: if [[ -n \"$ARTIFACTS\" ]]; then",
          "154:   echo \"Copying results\"",
          "156: fi",
          "158: ./kubevirtci kubectl exec -n $TENANT_CLUSTER_NAMESPACE ${test_pod} -- touch /tmp/exit.txt",
          "",
          "[Removed Lines]",
          "155:   ./kubevirtci kubectl cp ${TENANT_CLUSTER_NAMESPACE}/${test_pod}:/tmp/junit_01.xml $ARTIFACTS/junit.functest.xml",
          "",
          "[Added Lines]",
          "189: while [[ ! $(./kubevirtci kubectl exec -n $TENANT_CLUSTER_NAMESPACE ${test_pod} -- ls /tmp/junit_rwx_01.xml 2>/dev/null) ]]; do",
          "190:   sleep 30",
          "191: done",
          "195:   ./kubevirtci kubectl cp \"${TENANT_CLUSTER_NAMESPACE}/${test_pod}:/tmp/junit_01.xml\" \"${ARTIFACTS}/junit.functest.xml\"",
          "196:   ./kubevirtci kubectl cp \"${TENANT_CLUSTER_NAMESPACE}/${test_pod}:/tmp/junit_rwx_01.xml\" \"${ARTIFACTS}/junit.functest-rwx.xml\"",
          "",
          "---------------"
        ],
        "pkg/service/controller.go||pkg/service/controller.go": [
          "File: pkg/service/controller.go -> pkg/service/controller.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "15:  corev1 \"k8s.io/api/core/v1\"",
          "16:  \"k8s.io/apimachinery/pkg/api/errors\"",
          "17:  \"k8s.io/apimachinery/pkg/api/resource\"",
          "18:  \"k8s.io/apimachinery/pkg/util/wait\"",
          "19:  \"k8s.io/klog/v2\"",
          "20:  kubevirtv1 \"kubevirt.io/api/core/v1\"",
          "21:  cdiv1 \"kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "18:  v1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"",
          "21:  \"k8s.io/utils/ptr\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "51:  csi.ControllerServiceCapability_RPC_LIST_SNAPSHOTS,",
          "52: }",
          "55:  if req == nil {",
          "57:  }",
          "59:  if len(req.GetName()) == 0 {",
          "61:  }",
          "62:  caps := req.GetVolumeCapabilities()",
          "63:  if caps == nil {",
          "65:  }",
          "67:  if c.storageClassEnforcement.AllowAll {",
          "69:  }",
          "71:  storageClassName := req.Parameters[infraStorageClassNameParameter]",
          "72:  if storageClassName == \"\" {",
          "73:   if c.storageClassEnforcement.AllowDefault {",
          "75:   } else {",
          "77:   }",
          "78:  }",
          "79:  if !util.Contains(c.storageClassEnforcement.AllowList, storageClassName) {",
          "81:  }",
          "84: }",
          "",
          "[Removed Lines]",
          "54: func (c *ControllerService) validateCreateVolumeRequest(req *csi.CreateVolumeRequest) error {",
          "56:   return status.Error(codes.InvalidArgument, \"missing request\")",
          "60:   return status.Error(codes.InvalidArgument, \"name missing in request\")",
          "64:   return status.Error(codes.InvalidArgument, \"volume capabilities missing in request\")",
          "68:   return nil",
          "74:    return nil",
          "76:    return unallowedStorageClass",
          "80:   return unallowedStorageClass",
          "83:  return nil",
          "",
          "[Added Lines]",
          "56: func (c *ControllerService) validateCreateVolumeRequest(req *csi.CreateVolumeRequest) (bool, error) {",
          "58:   return false, status.Error(codes.InvalidArgument, \"missing request\")",
          "62:   return false, status.Error(codes.InvalidArgument, \"name missing in request\")",
          "67:   return false, status.Error(codes.InvalidArgument, \"volume capabilities missing in request\")",
          "68:  }",
          "70:  isBlock, isRWX := getAccessMode(caps)",
          "72:  if isRWX && !isBlock {",
          "73:   return false, status.Error(codes.InvalidArgument, \"non-block volume with RWX access mode is not supported\")",
          "77:   return isRWX, nil",
          "83:    return isRWX, nil",
          "85:    return false, unallowedStorageClass",
          "89:   return false, unallowedStorageClass",
          "90:  }",
          "92:  return isRWX, nil",
          "93: }",
          "95: func getAccessMode(caps []*csi.VolumeCapability) (bool, bool) {",
          "96:  isBlock := false",
          "97:  isRWX := false",
          "99:  for _, capability := range caps {",
          "100:   if capability != nil {",
          "101:    if capability.GetBlock() != nil {",
          "102:     isBlock = true",
          "103:    }",
          "105:    if am := capability.GetAccessMode(); am != nil {",
          "106:     if am.Mode == csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER {",
          "107:      isRWX = true",
          "108:     }",
          "109:    }",
          "110:   }",
          "113:  return isBlock, isRWX",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "90:  if req != nil {",
          "91:   klog.V(3).Infof(\"Create Volume Request: %+v\", *req)",
          "92:  }",
          "94:   return nil, err",
          "95:  }",
          "",
          "[Removed Lines]",
          "93:  if err := c.validateCreateVolumeRequest(req); err != nil {",
          "",
          "[Added Lines]",
          "123:  isRWX, err := c.validateCreateVolumeRequest(req)",
          "124:  if err != nil {",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "107:  }",
          "123:   },",
          "124:  }",
          "",
          "[Removed Lines]",
          "110:  dv := &cdiv1.DataVolume{}",
          "111:  dv.Name = dvName",
          "112:  dv.Namespace = c.infraClusterNamespace",
          "113:  dv.Kind = \"DataVolume\"",
          "114:  dv.APIVersion = cdiv1.SchemeGroupVersion.String()",
          "115:  dv.ObjectMeta.Labels = c.infraClusterLabels",
          "116:  dv.ObjectMeta.Annotations = map[string]string{",
          "117:   \"cdi.kubevirt.io/storage.deleteAfterCompletion\": \"false\",",
          "118:  }",
          "119:  dv.Spec.Storage = &cdiv1.StorageSpec{",
          "120:   Resources: corev1.ResourceRequirements{",
          "121:    Requests: corev1.ResourceList{",
          "122:     corev1.ResourceStorage: *resource.NewScaledQuantity(storageSize, 0)},",
          "",
          "[Added Lines]",
          "141:  source, err := c.determineDvSource(ctx, req)",
          "142:  if err != nil {",
          "143:   return nil, err",
          "144:  }",
          "146:  dv := &cdiv1.DataVolume{",
          "147:   TypeMeta: v1.TypeMeta{",
          "148:    Kind:       \"DataVolume\",",
          "149:    APIVersion: cdiv1.SchemeGroupVersion.String(),",
          "150:   },",
          "151:   ObjectMeta: v1.ObjectMeta{",
          "152:    Name:      dvName,",
          "153:    Namespace: c.infraClusterNamespace,",
          "154:    Labels:    c.infraClusterLabels,",
          "155:    Annotations: map[string]string{",
          "156:     \"cdi.kubevirt.io/storage.deleteAfterCompletion\": \"false\",",
          "157:    },",
          "158:   },",
          "159:   Spec: cdiv1.DataVolumeSpec{",
          "160:    Storage: &cdiv1.StorageSpec{",
          "161:     Resources: corev1.ResourceRequirements{",
          "162:      Requests: corev1.ResourceList{",
          "163:       corev1.ResourceStorage: *resource.NewScaledQuantity(storageSize, 0)},",
          "164:     },",
          "165:    },",
          "166:    Source: source,",
          "170:  if isRWX {",
          "171:   dv.Spec.Storage.VolumeMode = ptr.To(corev1.PersistentVolumeBlock)",
          "172:   dv.Spec.Storage.AccessModes = []corev1.PersistentVolumeAccessMode{corev1.ReadWriteMany}",
          "173:  }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "130:   dv.Spec.Storage.StorageClassName = &storageClassName",
          "131:  }",
          "139:  if existingDv, err := c.virtClient.GetDataVolume(ctx, c.infraClusterNamespace, dvName); errors.IsNotFound(err) {",
          "141:   dv, err = c.virtClient.CreateDataVolume(ctx, c.infraClusterNamespace, dv)",
          "142:   if err != nil {",
          "143:    klog.Error(\"failed creating DataVolume \" + dvName)",
          "",
          "[Removed Lines]",
          "133:  var err error",
          "134:  dv.Spec.Source, err = c.determineDvSource(ctx, req)",
          "135:  if err != nil {",
          "136:   return nil, err",
          "137:  }",
          "",
          "[Added Lines]",
          "184:   klog.Infof(\"creating new DataVolume %s/%s\", c.infraClusterNamespace, req.Name)",
          "",
          "---------------"
        ],
        "pkg/service/controller_test.go||pkg/service/controller_test.go": [
          "File: pkg/service/controller_test.go -> pkg/service/controller_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "38:   client := &ControllerClientMock{}",
          "39:   controller := ControllerService{client, testInfraNamespace, testInfraLabels, storageClassEnforcement}",
          "42:   Expect(err).ToNot(HaveOccurred())",
          "43:   Expect(testVolumeName).To(Equal(response.GetVolume().GetVolumeId()))",
          "44:   Expect(testDataVolumeUID).To(Equal(response.GetVolume().VolumeContext[serialParameter]))",
          "",
          "[Removed Lines]",
          "41:   response, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest())",
          "",
          "[Added Lines]",
          "42:   response, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest(getVolumeCapability(corev1.PersistentVolumeFilesystem, csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER)))",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "48: })",
          "50: var _ = Describe(\"CreateVolume\", func() {",
          "52:   client := &ControllerClientMock{}",
          "53:   controller := ControllerService{client, testInfraNamespace, testInfraLabels, storageClassEnforcement}",
          "56:   Expect(err).ToNot(HaveOccurred())",
          "62:  })",
          "64:  It(\"should propagate error from CreateVolume\", func() {",
          "65:   client := &ControllerClientMock{FailCreateDataVolume: true}",
          "66:   controller := ControllerService{client, testInfraNamespace, testInfraLabels, storageClassEnforcement}",
          "69:   Expect(err).To(HaveOccurred())",
          "70:  })",
          "",
          "[Removed Lines]",
          "51:  It(\"should successfully create a volume\", func() {",
          "55:   response, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest())",
          "58:   Expect(testVolumeName).To(Equal(response.GetVolume().GetVolumeId()))",
          "59:   Expect(testDataVolumeUID).To(Equal(response.GetVolume().VolumeContext[serialParameter]))",
          "60:   Expect(string(getBusType())).To(Equal(response.GetVolume().VolumeContext[busParameter]))",
          "61:   Expect(testVolumeStorageSize).To(Equal(response.GetVolume().GetCapacityBytes()))",
          "68:   _, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest())",
          "",
          "[Added Lines]",
          "52:  DescribeTable(\"should successfully create a volume\", func(cap *csi.VolumeCapability, expectedAC *corev1.PersistentVolumeAccessMode, expectedVolumeMode *corev1.PersistentVolumeMode) {",
          "56:   request := getCreateVolumeRequest(cap)",
          "57:   response, err := controller.CreateVolume(context.TODO(), request)",
          "60:   Expect(response.GetVolume().GetVolumeId()).To(Equal(testVolumeName))",
          "61:   Expect(response.GetVolume().VolumeContext[serialParameter]).To(Equal(testDataVolumeUID))",
          "62:   Expect(response.GetVolume().VolumeContext[busParameter]).To(Equal(string(getBusType())))",
          "63:   Expect(response.GetVolume().GetCapacityBytes()).To(Equal(testVolumeStorageSize))",
          "65:   dv, err := client.GetDataVolume(context.TODO(), testInfraNamespace, request.Name)",
          "66:   Expect(err).ToNot(HaveOccurred())",
          "67:   Expect(dv).ToNot(BeNil())",
          "69:   if expectedAC != nil {",
          "70:    Expect(dv.Spec.Storage).ToNot(BeNil())",
          "71:    Expect(dv.Spec.Storage.AccessModes).ToNot(BeEmpty())",
          "72:    Expect(dv.Spec.Storage.AccessModes[0]).To(Equal(*expectedAC))",
          "73:   } else if dv.Spec.Storage != nil {",
          "74:    Expect(dv.Spec.Storage.AccessModes).To(BeEmpty())",
          "75:   }",
          "77:   if expectedVolumeMode != nil {",
          "78:    Expect(dv.Spec.Storage).ToNot(BeNil())",
          "79:    Expect(dv.Spec.Storage.VolumeMode).To(HaveValue(Equal(*expectedVolumeMode)))",
          "80:   } else if dv.Spec.Storage != nil {",
          "81:    Expect(dv.Spec.Storage.VolumeMode).To(BeNil())",
          "82:   }",
          "83:  },",
          "84:   Entry(\"volume mode = block; [RWX]\", getVolumeCapability(corev1.PersistentVolumeBlock, csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER), ptr.To(corev1.ReadWriteMany), ptr.To(corev1.PersistentVolumeBlock)),",
          "85:   Entry(\"volume mode = block; [RWO]\", getVolumeCapability(corev1.PersistentVolumeBlock, csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER), nil, nil),",
          "86:   Entry(\"volume mode = filesystem; [RWO]\", getVolumeCapability(corev1.PersistentVolumeFilesystem, csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER), nil, nil),",
          "87:  )",
          "89:  It(\"should reject create volume request for FS & RWX\", func() {",
          "90:   client := &ControllerClientMock{}",
          "91:   controller := ControllerService{client, testInfraNamespace, testInfraLabels, storageClassEnforcement}",
          "93:   response, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest(getVolumeCapability(corev1.PersistentVolumeFilesystem, csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER)))",
          "94:   Expect(err).To(MatchError(ContainSubstring(\"non-block volume with RWX access mode is not supported\")))",
          "95:   Expect(response).To(BeNil())",
          "102:   _, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest(getVolumeCapability(corev1.PersistentVolumeFilesystem, csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER)))",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "76:   busTypeLocal := kubevirtv1.DiskBusVirtio",
          "77:   testBusType = &busTypeLocal",
          "80:   Expect(err).ToNot(HaveOccurred())",
          "81:   Expect(response.GetVolume().GetVolumeContext()[busParameter]).To(Equal(string(busTypeLocal)))",
          "82:  })",
          "84:  It(\"should not allow storage class not in the allow list\", func() {",
          "85:   client := &ControllerClientMock{}",
          "88:   storageClassEnforcement = util.StorageClassEnforcement{",
          "89:    AllowList:    []string{\"allowedClass\"},",
          "90:    AllowAll:     false,",
          "",
          "[Removed Lines]",
          "79:   response, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest())",
          "86:   allowedStorageClasses = []string{\"allowedClass\"}",
          "87:   allowAllStorageClasses = false",
          "",
          "[Added Lines]",
          "113:   response, err := controller.CreateVolume(context.TODO(), getCreateVolumeRequest(getVolumeCapability(corev1.PersistentVolumeFilesystem, csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER)))",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "92:   }",
          "93:   controller := ControllerService{client, testInfraNamespace, testInfraLabels, storageClassEnforcement}",
          "96:   request.Parameters[infraStorageClassNameParameter] = \"notAllowedClass\"",
          "98:   _, err := controller.CreateVolume(context.TODO(), request)",
          "",
          "[Removed Lines]",
          "95:   request := getCreateVolumeRequest()",
          "",
          "[Added Lines]",
          "127:   request := getCreateVolumeRequest(getVolumeCapability(corev1.PersistentVolumeFilesystem, csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER))",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "474:  testVMName                                    = \"test-vm\"",
          "475:  testVMUID                                     = \"6fc9c805-b3a0-570b-9d1b-3b8b9cfc9fb7\"",
          "476:  testDataVolumeUID                             = \"2d0111d5-494f-4731-8f67-122b27d3c366\"",
          "478:  testBusType               *kubevirtv1.DiskBus = nil // nil==do not pass bus type",
          "479:  testInfraLabels                               = map[string]string{\"infra-label-name\": \"infra-label-value\"}",
          "482:  storageClassEnforcement                       = util.StorageClassEnforcement{",
          "483:   AllowAll:     true,",
          "484:   AllowDefault: true,",
          "",
          "[Removed Lines]",
          "477:  testVolumeMode                                = corev1.PersistentVolumeFilesystem",
          "480:  allowedStorageClasses                         = []string{}",
          "481:  allowAllStorageClasses                        = true",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "493:  }",
          "494: }",
          "498:  var volumeCapability *csi.VolumeCapability",
          "501:   volumeCapability = &csi.VolumeCapability{",
          "502:    AccessType: &csi.VolumeCapability_Mount{},",
          "503:   }",
          "504:  } else {",
          "505:   volumeCapability = &csi.VolumeCapability{",
          "507:   }",
          "508:  }",
          "510:  parameters := map[string]string{}",
          "511:  if testInfraStorageClassName != \"\" {",
          "512:   parameters[infraStorageClassNameParameter] = testInfraStorageClassName",
          "",
          "[Removed Lines]",
          "496: func getCreateVolumeRequest() *csi.CreateVolumeRequest {",
          "500:  if testVolumeMode == corev1.PersistentVolumeFilesystem {",
          "506:    AccessType: &csi.VolumeCapability_Block{},",
          "",
          "[Added Lines]",
          "525: func getVolumeCapability(volumeMode corev1.PersistentVolumeMode, accessModes csi.VolumeCapability_AccessMode_Mode) *csi.VolumeCapability {",
          "528:  if volumeMode == corev1.PersistentVolumeFilesystem {",
          "534:    AccessType: &csi.VolumeCapability_Block{",
          "535:     Block: &csi.VolumeCapability_BlockVolume{},",
          "536:    },",
          "540:  volumeCapability.AccessMode = &csi.VolumeCapability_AccessMode{",
          "541:   Mode: accessModes,",
          "542:  }",
          "544:  return volumeCapability",
          "545: }",
          "547: func getCreateVolumeRequest(volumeCapability *csi.VolumeCapability) *csi.CreateVolumeRequest {",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "653:  result.SetUID(types.UID(testDataVolumeUID))",
          "655:  return result, nil",
          "656: }",
          "657: func (c *ControllerClientMock) GetDataVolume(_ context.Context, namespace string, name string) (*cdiv1.DataVolume, error) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "693:  if c.datavolumes == nil {",
          "694:   c.datavolumes = make(map[string]*cdiv1.DataVolume)",
          "695:  }",
          "696:  c.datavolumes[getKey(namespace, dataVolume.Name)] = dataVolume",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "4f94084ba0d1302558a021117a4813088947e9ef",
      "candidate_info": {
        "commit_hash": "4f94084ba0d1302558a021117a4813088947e9ef",
        "repo": "kubevirt/csi-driver",
        "commit_url": "https://github.com/kubevirt/csi-driver/commit/4f94084ba0d1302558a021117a4813088947e9ef",
        "files": [
          "README.md",
          "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
          "deploy/tenant/base/deploy.yaml",
          "docs/snapshot-driver-config.md",
          "go.mod",
          "go.sum",
          "hack/cluster-sync-split.sh",
          "hack/cluster-sync.sh",
          "hack/common.sh",
          "pkg/generated/bindata.go",
          "pkg/kubevirt/client.go",
          "pkg/kubevirt/client_test.go",
          "pkg/service/controller.go",
          "pkg/service/controller_test.go",
          "pkg/service/identity.go",
          "pkg/util/util.go",
          "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types.go",
          "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types_swagger_generated.go",
          "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/zz_generated.deepcopy.go",
          "vendor/modules.txt"
        ],
        "message": "Implement storage snapshot mapping (#106)\n\nRead the mapping from the driver-config ConfigMap.\nUse this mapping to determine if a snapshot can be\ncreated with the storage/volume snapshot class combination.\nIf not possible return an error with a list of the\npossible snapshot classes.\n\nSigned-off-by: Alexander Wels <awels@redhat.com>",
        "before_after_code_files": [
          "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
          "go.mod||go.mod",
          "go.sum||go.sum",
          "hack/cluster-sync-split.sh||hack/cluster-sync-split.sh",
          "hack/cluster-sync.sh||hack/cluster-sync.sh",
          "hack/common.sh||hack/common.sh",
          "pkg/generated/bindata.go||pkg/generated/bindata.go",
          "pkg/kubevirt/client.go||pkg/kubevirt/client.go",
          "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go",
          "pkg/service/controller.go||pkg/service/controller.go",
          "pkg/service/controller_test.go||pkg/service/controller_test.go",
          "pkg/service/identity.go||pkg/service/identity.go",
          "pkg/util/util.go||pkg/util/util.go",
          "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types.go||vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types.go",
          "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types_swagger_generated.go||vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types_swagger_generated.go",
          "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/zz_generated.deepcopy.go||vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/zz_generated.deepcopy.go"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
            "hack/cluster-sync.sh||hack/cluster-sync.sh",
            "pkg/kubevirt/client.go||pkg/kubevirt/client.go",
            "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go",
            "pkg/service/controller.go||pkg/service/controller.go"
          ],
          "candidate": [
            "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
            "hack/cluster-sync.sh||hack/cluster-sync.sh",
            "pkg/kubevirt/client.go||pkg/kubevirt/client.go",
            "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go",
            "pkg/service/controller.go||pkg/service/controller.go"
          ]
        }
      },
      "candidate_diff": {
        "cmd/kubevirt-csi-driver/kubevirt-csi-driver.go||cmd/kubevirt-csi-driver/kubevirt-csi-driver.go": [
          "File: cmd/kubevirt-csi-driver/kubevirt-csi-driver.go -> cmd/kubevirt-csi-driver/kubevirt-csi-driver.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "14:  \"k8s.io/client-go/tools/clientcmd\"",
          "15:  klog \"k8s.io/klog/v2\"",
          "17:  \"kubevirt.io/csi-driver/pkg/kubevirt\"",
          "18:  \"kubevirt.io/csi-driver/pkg/service\"",
          "19:  \"kubevirt.io/csi-driver/pkg/util\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "17:  snapcli \"kubevirt.io/csi-driver/pkg/generated/external-snapshotter/client-go/clientset/versioned\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "90:  if err != nil {",
          "91:   klog.Fatalf(\"Failed to build tenant client set: %v\", err)",
          "92:  }",
          "94:  infraClusterLabelsMap := parseLabels()",
          "95:  storageClassEnforcement := configureStorageClassEnforcement(infraStorageClassEnforcement)",
          "98:  if err != nil {",
          "99:   klog.Fatal(err)",
          "100:  }",
          "",
          "[Removed Lines]",
          "97:  virtClient, err := kubevirt.NewClient(infraRestConfig, infraClusterLabelsMap, storageClassEnforcement, *volumePrefix)",
          "",
          "[Added Lines]",
          "94:  tenantSnapshotClientSet, err := snapcli.NewForConfig(tenantRestConfig)",
          "95:  if err != nil {",
          "96:   klog.Fatalf(\"Failed to build tenant snapshot client set: %v\", err)",
          "97:  }",
          "102:  virtClient, err := kubevirt.NewClient(infraRestConfig, infraClusterLabelsMap, tenantClientSet, tenantSnapshotClientSet, storageClassEnforcement, *volumePrefix)",
          "",
          "---------------"
        ],
        "go.mod||go.mod": [
          "File: go.mod -> go.mod",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: module kubevirt.io/csi-driver",
          "5: require (",
          "6:  github.com/container-storage-interface/spec v1.6.0",
          "",
          "[Removed Lines]",
          "3: go 1.20",
          "",
          "[Added Lines]",
          "3: go 1.21",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "25:  k8s.io/klog/v2 v2.120.1",
          "26:  k8s.io/utils v0.0.0-20240102154912-e7106e64919e",
          "27:  kubevirt.io/api v1.1.1",
          "29: )",
          "31: require (",
          "",
          "[Removed Lines]",
          "28:  kubevirt.io/containerized-data-importer-api v1.58.1",
          "",
          "[Added Lines]",
          "28:  kubevirt.io/containerized-data-importer-api v1.59.0",
          "",
          "---------------"
        ],
        "go.sum||go.sum": [
          "File: go.sum -> go.sum",
          "--- Hunk 1 ---",
          "[Context before]",
          "1853: kubevirt.io/api v1.1.1/go.mod h1:CJ4vZsaWhVN3jNbyc9y3lIZhw8nUHbWjap0xHABQiqc=",
          "1854: kubevirt.io/containerized-data-importer-api v1.58.1 h1:Zbf0pCvxb4fBvtMR6uI2OIJZ4UfwFxripzOLMO4HPbI=",
          "1855: kubevirt.io/containerized-data-importer-api v1.58.1/go.mod h1:Y/8ETgHS1GjO89bl682DPtQOYEU/1ctPFBz6Sjxm4DM=",
          "1856: kubevirt.io/controller-lifecycle-operator-sdk/api v0.0.0-20220329064328-f3cc58c6ed90 h1:QMrd0nKP0BGbnxTqakhDZAUhGKxPiPiN5gSDqKUmGGc=",
          "1857: kubevirt.io/controller-lifecycle-operator-sdk/api v0.0.0-20220329064328-f3cc58c6ed90/go.mod h1:018lASpFYBsYN6XwmA2TIrPCx6e0gviTd/ZNtSitKgc=",
          "1858: lukechampine.com/uint128 v1.1.1/go.mod h1:c4eWIwlEGaxC/+H1VguhU4PHXNWDCDMUlWdIWl2j1gk=",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1856: kubevirt.io/containerized-data-importer-api v1.59.0 h1:GdDt9BlR0qHejpMaPfASbsG8JWDmBf1s7xZBj5W9qn0=",
          "1857: kubevirt.io/containerized-data-importer-api v1.59.0/go.mod h1:4yOGtCE7HvgKp7wftZZ3TBvDJ0x9d6N6KaRjRYcUFpE=",
          "",
          "---------------"
        ],
        "hack/cluster-sync-split.sh||hack/cluster-sync-split.sh": [
          "File: hack/cluster-sync-split.sh -> hack/cluster-sync-split.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "67: mkdir -p ./deploy/controller-infra/dev-overlay",
          "68: mkdir -p ./deploy/tenant/dev-overlay",
          "71: cluster::generate_tenant_dev_kustomization",
          "72: cluster::generate_controller_dev_kustomization \"controller-infra\" $TENANT_CLUSTER_NAMESPACE",
          "73: tenant::deploy_csidriver_namespace $CSI_DRIVER_NAMESPACE",
          "",
          "[Removed Lines]",
          "70: cluster::generate_controller_rbac $TENANT_CLUSTER_NAMESPACE",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "hack/cluster-sync.sh||hack/cluster-sync.sh": [
          "File: hack/cluster-sync.sh -> hack/cluster-sync.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "93: mkdir -p ./deploy/controller-tenant/dev-overlay",
          "94: mkdir -p ./deploy/tenant/dev-overlay",
          "97: cluster::generate_tenant_dev_kustomization",
          "98: cluster::generate_controller_dev_kustomization \"controller-tenant\" $CSI_DRIVER_NAMESPACE",
          "99: tenant::deploy_csidriver_namespace $CSI_DRIVER_NAMESPACE",
          "",
          "[Removed Lines]",
          "96: cluster::generate_controller_rbac $TENANT_CLUSTER_NAMESPACE",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------"
        ],
        "hack/common.sh||hack/common.sh": [
          "File: hack/common.sh -> hack/common.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "131:   ./kubevirtci kubectl-tenant apply -f ./deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshotclasses.yaml",
          "132:   ./kubevirtci kubectl-tenant apply -f ./deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshotcontents.yaml",
          "133:   ./kubevirtci kubectl-tenant apply -f ./deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshots.yaml",
          "134: }",
          "",
          "[Removed Lines]",
          "136: function cluster::generate_controller_rbac() {",
          "137:   cat <<- END | ./kubevirtci kubectl apply -f -",
          "138: ---",
          "139: apiVersion: rbac.authorization.k8s.io/v1",
          "140: kind: ClusterRole",
          "141: metadata:",
          "142:   name: kubevirt-csi-snapshot",
          "143: rules:",
          "144: - apiGroups: [\"storage.k8s.io\"]",
          "145:   resources: [\"storageclasses\"]",
          "146:   verbs: [\"get\"]",
          "147: - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "148:   resources: [\"volumesnapshotclasses\"]",
          "149:   verbs: [\"get\", \"list\"]",
          "150: ---",
          "151: apiVersion: rbac.authorization.k8s.io/v1",
          "152: kind: ClusterRoleBinding",
          "153: metadata:",
          "154:   name: kubevirt-csi-snapshot",
          "155: roleRef:",
          "156:   apiGroup: rbac.authorization.k8s.io",
          "157:   kind: ClusterRole",
          "158:   name: kubevirt-csi-snapshot",
          "159: subjects:",
          "160: - kind: ServiceAccount",
          "161:   name: kubevirt-csi",
          "162:   namespace: $1",
          "163: END",
          "164: }",
          "",
          "[Added Lines]",
          "134:   # Make sure the infra rbd snapshot class is the default snapshot class",
          "135:   ./kubevirtci kubectl patch volumesnapshotclass csi-rbdplugin-snapclass --type merge -p '{\"metadata\": {\"annotations\":{\"snapshot.storage.kubernetes.io/is-default-class\":\"true\"}}}'",
          "",
          "---------------"
        ],
        "pkg/generated/bindata.go||pkg/generated/bindata.go": [
          "File: pkg/generated/bindata.go -> pkg/generated/bindata.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "67:  return nil",
          "68: }",
          "73: metadata:",
          "75: spec:",
          "78: `)",
          "82: }",
          "86:  if err != nil {",
          "87:   return nil, err",
          "88:  }",
          "91:  a := &asset{bytes: bytes, info: info}",
          "92:  return a, nil",
          "93: }",
          "104: `)",
          "108: }",
          "112:  if err != nil {",
          "113:   return nil, err",
          "114:  }",
          "117:  a := &asset{bytes: bytes, info: info}",
          "118:  return a, nil",
          "119: }",
          "123: metadata:",
          "126: ---",
          "127: apiVersion: v1",
          "128: kind: ServiceAccount",
          "",
          "[Removed Lines]",
          "70: var _deploy000CsiDriverYaml = []byte(`#TODO v1beta is deprecated in 1.19+ and promoted to v1",
          "71: apiVersion: storage.k8s.io/v1",
          "72: kind: CSIDriver",
          "74:   name: csi.kubevirt.io",
          "76:   attachRequired: true",
          "77:   podInfoOnMount: true",
          "80: func deploy000CsiDriverYamlBytes() ([]byte, error) {",
          "81:  return _deploy000CsiDriverYaml, nil",
          "84: func deploy000CsiDriverYaml() (*asset, error) {",
          "85:  bytes, err := deploy000CsiDriverYamlBytes()",
          "90:  info := bindataFileInfo{name: \"deploy/000-csi-driver.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "95: var _deploy000NamespaceYaml = []byte(`apiVersion: v1",
          "96: kind: Namespace",
          "97: metadata:",
          "98:   name: kubevirt-csi-driver",
          "99:   annotations:",
          "100:     openshift.io/node-selector: \"\"",
          "101:   labels:",
          "102:     name: kubevirt-csi-driver",
          "106: func deploy000NamespaceYamlBytes() ([]byte, error) {",
          "107:  return _deploy000NamespaceYaml, nil",
          "110: func deploy000NamespaceYaml() (*asset, error) {",
          "111:  bytes, err := deploy000NamespaceYamlBytes()",
          "116:  info := bindataFileInfo{name: \"deploy/000-namespace.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "121: var _deploy020AutorizationYaml = []byte(`apiVersion: v1",
          "122: kind: ServiceAccount",
          "124:   name: kubevirt-csi-node-sa",
          "125:   namespace: kubevirt-csi-driver",
          "",
          "[Added Lines]",
          "83: var _deployControllerInfraBaseDeployYaml = []byte(`kind: Deployment",
          "84: apiVersion: apps/v1",
          "85: metadata:",
          "86:   name: kubevirt-csi-controller",
          "87:   namespace: kubevirt-csi-driver",
          "88:   labels:",
          "89:     app: kubevirt-csi-driver",
          "90: spec:",
          "91:   replicas: 1",
          "92:   selector:",
          "93:     matchLabels:",
          "94:       app: kubevirt-csi-driver",
          "95:   template:",
          "96:     metadata:",
          "97:       labels:",
          "98:         app: kubevirt-csi-driver",
          "99:     spec:",
          "100:       serviceAccount: kubevirt-csi",
          "101:       priorityClassName: system-cluster-critical",
          "102:       nodeSelector:",
          "103:         node-role.kubernetes.io/control-plane: \"\"",
          "104:       tolerations:",
          "105:         - key: CriticalAddonsOnly",
          "106:           operator: Exists",
          "107:         - key: node-role.kubernetes.io/master",
          "108:           operator: Exists",
          "109:           effect: \"NoSchedule\"",
          "110:       containers:",
          "111:         - name: csi-driver",
          "112:           imagePullPolicy: Always",
          "113:           image: quay.io/kubevirt/csi-driver:latest",
          "114:           args:",
          "115:             - \"--endpoint=$(CSI_ENDPOINT)\"",
          "116:             - \"--infra-cluster-namespace=$(INFRACLUSTER_NAMESPACE)\"",
          "117:             - \"--infra-cluster-labels=$(INFRACLUSTER_LABELS)\"",
          "118:             - \"--tenant-cluster-kubeconfig=/var/run/secrets/tenantcluster/value\"",
          "119:             - \"--run-node-service=false\"",
          "120:             - \"--run-controller-service=true\"",
          "121:             - \"--v=5\"",
          "122:           ports:",
          "123:             - name: healthz",
          "124:               containerPort: 10301",
          "125:               protocol: TCP",
          "126:           env:",
          "127:             - name: CSI_ENDPOINT",
          "128:               value: unix:///var/lib/csi/sockets/pluginproxy/csi.sock",
          "129:             - name: KUBE_NODE_NAME",
          "130:               valueFrom:",
          "131:                 fieldRef:",
          "132:                   fieldPath: spec.nodeName",
          "133:             - name: INFRACLUSTER_NAMESPACE",
          "134:               valueFrom:",
          "135:                 configMapKeyRef:",
          "136:                   name: driver-config",
          "137:                   key: infraClusterNamespace",
          "138:             - name: INFRACLUSTER_LABELS",
          "139:               valueFrom:",
          "140:                 configMapKeyRef:",
          "141:                   name: driver-config",
          "142:                   key: infraClusterLabels",
          "143:             - name: INFRA_STORAGE_CLASS_ENFORCEMENT",
          "144:               valueFrom:",
          "145:                 configMapKeyRef:",
          "146:                   name: driver-config",
          "147:                   key: infraStorageClassEnforcement",
          "148:                   optional: true",
          "149:           volumeMounts:",
          "150:             - name: socket-dir",
          "151:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "152:             - name: tenantcluster",
          "153:               mountPath: \"/var/run/secrets/tenantcluster\"",
          "154:           resources:",
          "155:             requests:",
          "156:               memory: 50Mi",
          "157:               cpu: 10m",
          "158:         - name: csi-provisioner",
          "159:           image: quay.io/openshift/origin-csi-external-provisioner:latest",
          "160:           args:",
          "161:             - \"--csi-address=$(ADDRESS)\"",
          "162:             - \"--default-fstype=ext4\"",
          "163:             - \"--kubeconfig=/var/run/secrets/tenantcluster/value\"",
          "164:             - \"--v=5\"",
          "165:             - \"--timeout=3m\"",
          "166:             - \"--retry-interval-max=1m\"",
          "167:           env:",
          "168:             - name: ADDRESS",
          "169:               value: /var/lib/csi/sockets/pluginproxy/csi.sock",
          "170:           volumeMounts:",
          "171:             - name: socket-dir",
          "172:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "173:             - name: tenantcluster",
          "174:               mountPath: \"/var/run/secrets/tenantcluster\"",
          "175:         - name: csi-attacher",
          "176:           image: quay.io/openshift/origin-csi-external-attacher:latest",
          "177:           args:",
          "178:             - \"--csi-address=$(ADDRESS)\"",
          "179:             - \"--kubeconfig=/var/run/secrets/tenantcluster/value\"",
          "180:             - \"--v=5\"",
          "181:             - \"--timeout=3m\"",
          "182:             - \"--retry-interval-max=1m\"",
          "183:           env:",
          "184:             - name: ADDRESS",
          "185:               value: /var/lib/csi/sockets/pluginproxy/csi.sock",
          "186:           volumeMounts:",
          "187:             - name: socket-dir",
          "188:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "189:             - name: tenantcluster",
          "190:               mountPath: \"/var/run/secrets/tenantcluster\"",
          "191:           resources:",
          "192:             requests:",
          "193:               memory: 50Mi",
          "194:               cpu: 10m",
          "195:         - name: csi-liveness-probe",
          "196:           image: quay.io/openshift/origin-csi-livenessprobe:latest",
          "197:           args:",
          "198:             - \"--csi-address=/csi/csi.sock\"",
          "199:             - \"--probe-timeout=3s\"",
          "200:             - \"--health-port=10301\"",
          "201:           volumeMounts:",
          "202:             - name: socket-dir",
          "203:               mountPath: /csi",
          "204:             - name: tenantcluster",
          "205:               mountPath: \"/var/run/secrets/tenantcluster\"",
          "206:           resources:",
          "207:             requests:",
          "208:               memory: 50Mi",
          "209:               cpu: 10m",
          "210:         - name: csi-snapshotter",
          "211:           args:",
          "212:           - \"--v=5\"",
          "213:           - \"--csi-address=/csi/csi.sock\"",
          "214:           - \"--kubeconfig=/var/run/secrets/tenantcluster/value\"",
          "215:           image: k8s.gcr.io/sig-storage/csi-snapshotter:v4.2.1",
          "216:           imagePullPolicy: IfNotPresent",
          "217:           terminationMessagePath: /dev/termination-log",
          "218:           terminationMessagePolicy: File",
          "219:           volumeMounts:",
          "220:           - mountPath: /csi",
          "221:             name: socket-dir",
          "222:           - name: tenantcluster",
          "223:             mountPath: \"/var/run/secrets/tenantcluster\"",
          "224:           resources:",
          "225:             requests:",
          "226:               memory: 20Mi",
          "227:               cpu: 10m",
          "228:       volumes:",
          "229:         - name: socket-dir",
          "230:           emptyDir: {}",
          "231:         - name: tenantcluster",
          "232:           secret:",
          "233:             secretName: kvcluster-kubeconfig",
          "234: `)",
          "236: func deployControllerInfraBaseDeployYamlBytes() ([]byte, error) {",
          "237:  return _deployControllerInfraBaseDeployYaml, nil",
          "238: }",
          "240: func deployControllerInfraBaseDeployYaml() (*asset, error) {",
          "241:  bytes, err := deployControllerInfraBaseDeployYamlBytes()",
          "242:  if err != nil {",
          "243:   return nil, err",
          "244:  }",
          "246:  info := bindataFileInfo{name: \"deploy/controller-infra/base/deploy.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "247:  a := &asset{bytes: bytes, info: info}",
          "248:  return a, nil",
          "249: }",
          "251: var _deployControllerInfraBaseKustomizationYaml = []byte(`commonLabels:",
          "252:   app: kubevirt-csi-driver",
          "253: resources:",
          "254: - deploy.yaml",
          "255: `)",
          "257: func deployControllerInfraBaseKustomizationYamlBytes() ([]byte, error) {",
          "258:  return _deployControllerInfraBaseKustomizationYaml, nil",
          "259: }",
          "261: func deployControllerInfraBaseKustomizationYaml() (*asset, error) {",
          "262:  bytes, err := deployControllerInfraBaseKustomizationYamlBytes()",
          "263:  if err != nil {",
          "264:   return nil, err",
          "265:  }",
          "267:  info := bindataFileInfo{name: \"deploy/controller-infra/base/kustomization.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "268:  a := &asset{bytes: bytes, info: info}",
          "269:  return a, nil",
          "270: }",
          "272: var _deployControllerInfraDevOverlayControllerYaml = []byte(`kind: Deployment",
          "273: apiVersion: apps/v1",
          "274: metadata:",
          "275:   name: kubevirt-csi-controller",
          "276:   namespace: kubevirt-csi-driver",
          "277:   labels:",
          "278:     app: kubevirt-csi-driver",
          "279: spec:",
          "280:   template:",
          "281:     spec:",
          "282:       containers:",
          "283:         - name: csi-driver",
          "284:           image: registry:5000/kubevirt-csi-driver:latest",
          "285: `)",
          "287: func deployControllerInfraDevOverlayControllerYamlBytes() ([]byte, error) {",
          "288:  return _deployControllerInfraDevOverlayControllerYaml, nil",
          "289: }",
          "291: func deployControllerInfraDevOverlayControllerYaml() (*asset, error) {",
          "292:  bytes, err := deployControllerInfraDevOverlayControllerYamlBytes()",
          "293:  if err != nil {",
          "294:   return nil, err",
          "295:  }",
          "297:  info := bindataFileInfo{name: \"deploy/controller-infra/dev-overlay/controller.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "298:  a := &asset{bytes: bytes, info: info}",
          "299:  return a, nil",
          "300: }",
          "302: var _deployControllerInfraDevOverlayInfraNamespaceConfigmapYaml = []byte(`apiVersion: v1",
          "303: kind: ConfigMap",
          "304: metadata:",
          "305:   name: driver-config",
          "306:   namespace: kubevirt-csi-driver",
          "307: data:",
          "308:   infraClusterNamespace: kvcluster",
          "309:   infraClusterLabels: csi-driver/cluster=tenant",
          "310: `)",
          "312: func deployControllerInfraDevOverlayInfraNamespaceConfigmapYamlBytes() ([]byte, error) {",
          "313:  return _deployControllerInfraDevOverlayInfraNamespaceConfigmapYaml, nil",
          "314: }",
          "316: func deployControllerInfraDevOverlayInfraNamespaceConfigmapYaml() (*asset, error) {",
          "317:  bytes, err := deployControllerInfraDevOverlayInfraNamespaceConfigmapYamlBytes()",
          "318:  if err != nil {",
          "319:   return nil, err",
          "320:  }",
          "322:  info := bindataFileInfo{name: \"deploy/controller-infra/dev-overlay/infra-namespace-configmap.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "323:  a := &asset{bytes: bytes, info: info}",
          "324:  return a, nil",
          "325: }",
          "327: var _deployControllerInfraDevOverlayKustomizationYaml = []byte(`resources:",
          "328: - ../base",
          "329: - infra-namespace-configmap.yaml",
          "330: namespace: kvcluster",
          "331: patches:",
          "332: - path: controller.yaml",
          "333: `)",
          "335: func deployControllerInfraDevOverlayKustomizationYamlBytes() ([]byte, error) {",
          "336:  return _deployControllerInfraDevOverlayKustomizationYaml, nil",
          "337: }",
          "339: func deployControllerInfraDevOverlayKustomizationYaml() (*asset, error) {",
          "340:  bytes, err := deployControllerInfraDevOverlayKustomizationYamlBytes()",
          "341:  if err != nil {",
          "342:   return nil, err",
          "343:  }",
          "345:  info := bindataFileInfo{name: \"deploy/controller-infra/dev-overlay/kustomization.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "346:  a := &asset{bytes: bytes, info: info}",
          "347:  return a, nil",
          "348: }",
          "350: var _deployControllerTenantBaseDeployYaml = []byte(`---",
          "351: kind: Deployment",
          "352: apiVersion: apps/v1",
          "353: metadata:",
          "354:   name: kubevirt-csi-controller",
          "355:   namespace: kubevirt-csi-driver",
          "356: spec:",
          "357:   replicas: 1",
          "358:   selector:",
          "359:     matchLabels:",
          "360:       app: kubevirt-csi-driver",
          "361:   template:",
          "362:     metadata:",
          "363:       labels:",
          "364:         app: kubevirt-csi-driver",
          "365:     spec:",
          "366:       serviceAccount: kubevirt-csi-controller-sa",
          "367:       priorityClassName: system-cluster-critical",
          "368:       nodeSelector:",
          "369:         node-role.kubernetes.io/control-plane: \"\"",
          "370:       tolerations:",
          "371:         - key: CriticalAddonsOnly",
          "372:           operator: Exists",
          "373:         - key: node-role.kubernetes.io/master",
          "374:           operator: Exists",
          "375:           effect: \"NoSchedule\"",
          "376:         - key: node-role.kubernetes.io/control-plane",
          "377:           operator: Exists",
          "378:           effect: \"NoSchedule\"",
          "379:       containers:",
          "380:         - name: csi-driver",
          "381:           imagePullPolicy: Always",
          "382:           image: quay.io/kubevirt/csi-driver:latest",
          "383:           args:",
          "384:             - \"--endpoint=$(CSI_ENDPOINT)\"",
          "385:             - \"--infra-cluster-namespace=$(INFRACLUSTER_NAMESPACE)\"",
          "386:             - \"--infra-cluster-kubeconfig=/var/run/secrets/infracluster/kubeconfig\"",
          "387:             - \"--infra-cluster-labels=$(INFRACLUSTER_LABELS)\"",
          "388:             - --v=5",
          "389:           ports:",
          "390:             - name: healthz",
          "391:               containerPort: 10301",
          "392:               protocol: TCP",
          "393:           env:",
          "394:             - name: CSI_ENDPOINT",
          "395:               value: unix:///var/lib/csi/sockets/pluginproxy/csi.sock",
          "396:             - name: KUBE_NODE_NAME",
          "397:               valueFrom:",
          "398:                 fieldRef:",
          "399:                   fieldPath: spec.nodeName",
          "400:             - name: INFRACLUSTER_NAMESPACE",
          "401:               valueFrom:",
          "402:                 configMapKeyRef:",
          "403:                   name: driver-config",
          "404:                   key: infraClusterNamespace",
          "405:             - name: INFRACLUSTER_LABELS",
          "406:               valueFrom:",
          "407:                 configMapKeyRef:",
          "408:                   name: driver-config",
          "409:                   key: infraClusterLabels",
          "410:             - name: INFRA_STORAGE_CLASS_ENFORCEMENT",
          "411:               valueFrom:",
          "412:                 configMapKeyRef:",
          "413:                   name: driver-config",
          "414:                   key: infraStorageClassEnforcement",
          "415:                   optional: true",
          "416:           volumeMounts:",
          "417:             - name: socket-dir",
          "418:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "419:             - name: infracluster",
          "420:               mountPath: \"/var/run/secrets/infracluster\"",
          "421:           resources:",
          "422:             requests:",
          "423:               memory: 50Mi",
          "424:               cpu: 10m",
          "425:             limits:",
          "426:               memory: 500Mi",
          "427:               cpu: 250m",
          "428:         - name: csi-provisioner",
          "429:           image: quay.io/openshift/origin-csi-external-provisioner:latest",
          "430:           args:",
          "431:             - --csi-address=$(ADDRESS)",
          "432:             - --default-fstype=ext4",
          "433:             - --v=5",
          "434:           env:",
          "435:             - name: ADDRESS",
          "436:               value: /var/lib/csi/sockets/pluginproxy/csi.sock",
          "437:           volumeMounts:",
          "438:             - name: socket-dir",
          "439:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "440:           resources:",
          "441:             requests:",
          "442:               memory: 50Mi",
          "443:               cpu: 10m",
          "444:             limits:",
          "445:               memory: 500Mi",
          "446:               cpu: 250m",
          "447:         - name: csi-attacher",
          "448:           image: quay.io/openshift/origin-csi-external-attacher:latest",
          "449:           args:",
          "450:             - --csi-address=$(ADDRESS)",
          "451:             - --v=5",
          "452:           env:",
          "453:             - name: ADDRESS",
          "454:               value: /var/lib/csi/sockets/pluginproxy/csi.sock",
          "455:           volumeMounts:",
          "456:             - name: socket-dir",
          "457:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "458:           resources:",
          "459:             requests:",
          "460:               memory: 50Mi",
          "461:               cpu: 10m",
          "462:             limits:",
          "463:               memory: 500Mi",
          "464:               cpu: 250m",
          "465:         - name: csi-liveness-probe",
          "466:           image: quay.io/openshift/origin-csi-livenessprobe:latest",
          "467:           args:",
          "468:             - --csi-address=/csi/csi.sock",
          "469:             - --probe-timeout=3s",
          "470:             - --health-port=10301",
          "471:           volumeMounts:",
          "472:             - name: socket-dir",
          "473:               mountPath: /csi",
          "474:           resources:",
          "475:             requests:",
          "476:               memory: 50Mi",
          "477:               cpu: 10m",
          "478:             limits:",
          "479:               memory: 500Mi",
          "480:               cpu: 250m",
          "481:         - name: csi-snapshotter",
          "482:           args:",
          "483:           - --v=3",
          "484:           - --csi-address=/csi/csi.sock",
          "485:           image: k8s.gcr.io/sig-storage/csi-snapshotter:v4.2.1",
          "486:           imagePullPolicy: IfNotPresent",
          "487:           securityContext:",
          "488:             privileged: true",
          "489:           terminationMessagePath: /dev/termination-log",
          "490:           terminationMessagePolicy: File",
          "491:           volumeMounts:",
          "492:           - mountPath: /csi",
          "493:             name: socket-dir",
          "494:           resources:",
          "495:             requests:",
          "496:               memory: 20Mi",
          "497:               cpu: 10m",
          "498:             limits:",
          "499:               memory: 500Mi",
          "500:               cpu: 250m",
          "501:       volumes:",
          "502:         - name: socket-dir",
          "503:           emptyDir: {}",
          "504:         - name: infracluster",
          "505:           secret:",
          "506:             secretName: infra-cluster-credentials",
          "507: ---",
          "508: kind: ClusterRoleBinding",
          "509: apiVersion: rbac.authorization.k8s.io/v1",
          "510: metadata:",
          "511:   name: csi-snapshotter-role",
          "512: subjects:",
          "513:   - kind: ServiceAccount",
          "514:     name: kubevirt-csi-controller-sa",
          "515:     namespace: kubevirt-csi-driver",
          "516: roleRef:",
          "517:   kind: ClusterRole",
          "518:   name: external-snapshotter-runner",
          "519:   apiGroup: rbac.authorization.k8s.io",
          "520: `)",
          "522: func deployControllerTenantBaseDeployYamlBytes() ([]byte, error) {",
          "523:  return _deployControllerTenantBaseDeployYaml, nil",
          "524: }",
          "526: func deployControllerTenantBaseDeployYaml() (*asset, error) {",
          "527:  bytes, err := deployControllerTenantBaseDeployYamlBytes()",
          "528:  if err != nil {",
          "529:   return nil, err",
          "530:  }",
          "532:  info := bindataFileInfo{name: \"deploy/controller-tenant/base/deploy.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "533:  a := &asset{bytes: bytes, info: info}",
          "534:  return a, nil",
          "535: }",
          "537: var _deployControllerTenantBaseKustomizationYaml = []byte(`commonLabels:",
          "538:   app: kubevirt-csi-driver",
          "539: resources:",
          "540: - deploy.yaml",
          "541: `)",
          "543: func deployControllerTenantBaseKustomizationYamlBytes() ([]byte, error) {",
          "544:  return _deployControllerTenantBaseKustomizationYaml, nil",
          "545: }",
          "547: func deployControllerTenantBaseKustomizationYaml() (*asset, error) {",
          "548:  bytes, err := deployControllerTenantBaseKustomizationYamlBytes()",
          "549:  if err != nil {",
          "550:   return nil, err",
          "551:  }",
          "553:  info := bindataFileInfo{name: \"deploy/controller-tenant/base/kustomization.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "554:  a := &asset{bytes: bytes, info: info}",
          "555:  return a, nil",
          "556: }",
          "558: var _deployControllerTenantDevOverlayControllerYaml = []byte(`kind: Deployment",
          "559: apiVersion: apps/v1",
          "561:   name: kubevirt-csi-controller",
          "562:   namespace: kubevirt-csi-driver",
          "563:   labels:",
          "564:     app: kubevirt-csi-driver",
          "566:   template:",
          "567:     spec:",
          "568:       containers:",
          "569:         - name: csi-driver",
          "570:           image: 192.168.66.2:5000/kubevirt-csi-driver:latest",
          "571: `)",
          "573: func deployControllerTenantDevOverlayControllerYamlBytes() ([]byte, error) {",
          "574:  return _deployControllerTenantDevOverlayControllerYaml, nil",
          "575: }",
          "577: func deployControllerTenantDevOverlayControllerYaml() (*asset, error) {",
          "578:  bytes, err := deployControllerTenantDevOverlayControllerYamlBytes()",
          "579:  if err != nil {",
          "580:   return nil, err",
          "581:  }",
          "583:  info := bindataFileInfo{name: \"deploy/controller-tenant/dev-overlay/controller.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "584:  a := &asset{bytes: bytes, info: info}",
          "585:  return a, nil",
          "586: }",
          "588: var _deployControllerTenantDevOverlayKustomizationYaml = []byte(`resources:",
          "589: - ../base",
          "590: namespace: kubevirt-csi-driver",
          "591: patches:",
          "592: - path: controller.yaml",
          "593: `)",
          "595: func deployControllerTenantDevOverlayKustomizationYamlBytes() ([]byte, error) {",
          "596:  return _deployControllerTenantDevOverlayKustomizationYaml, nil",
          "597: }",
          "599: func deployControllerTenantDevOverlayKustomizationYaml() (*asset, error) {",
          "600:  bytes, err := deployControllerTenantDevOverlayKustomizationYamlBytes()",
          "601:  if err != nil {",
          "602:   return nil, err",
          "603:  }",
          "605:  info := bindataFileInfo{name: \"deploy/controller-tenant/dev-overlay/kustomization.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "606:  a := &asset{bytes: bytes, info: info}",
          "607:  return a, nil",
          "608: }",
          "610: var _deployExampleInfraclusterKubeconfigYaml = []byte(`apiVersion: v1",
          "611: clusters:",
          "612: - cluster:",
          "613:     certificate-authority-data: <Base64 of CA. Take value from the kubeconfig used to create the ServiceAccount kubevirt-csi>",
          "614:     server: <URL of cluster. E.g.https://api.crc.testing:6443. Take value from the kubeconfig used to create the ServiceAccount kubevirt-csi>",
          "615:   name: infra-cluster",
          "616: contexts:",
          "617: - context:",
          "618:     cluster: infra-cluster",
          "619:     namespace: <optional, not used>",
          "620:     user: kubevirt-csi",
          "621:   name: only-context",
          "622: current-context: only-context",
          "623: kind: Config",
          "624: preferences: {}",
          "625: users:",
          "626: - name: kubevirt-csi",
          "627:   user:",
          "628:     token: <use token from secret in ServiceAccount kubevirt-csi. Decode it from base64 (base64 -d)>",
          "629: `)",
          "631: func deployExampleInfraclusterKubeconfigYamlBytes() ([]byte, error) {",
          "632:  return _deployExampleInfraclusterKubeconfigYaml, nil",
          "633: }",
          "635: func deployExampleInfraclusterKubeconfigYaml() (*asset, error) {",
          "636:  bytes, err := deployExampleInfraclusterKubeconfigYamlBytes()",
          "637:  if err != nil {",
          "638:   return nil, err",
          "639:  }",
          "641:  info := bindataFileInfo{name: \"deploy/example/infracluster-kubeconfig.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "642:  a := &asset{bytes: bytes, info: info}",
          "643:  return a, nil",
          "644: }",
          "646: var _deployExampleKubevirtConfigYaml = []byte(`apiVersion: v1",
          "647: kind: ConfigMap",
          "648: metadata:",
          "649:   name: kubevirt-config",
          "650:   namespace: kubevirt",
          "651: data:",
          "652:   default-network-interface: masquerade",
          "653:   feature-gates: DataVolumes,SRIOV,LiveMigration,CPUManager,CPUNodeDiscovery,Sidecar,Snapshot,HotplugVolumes",
          "654:   selinuxLauncherType: virt_launcher.process",
          "655:   smbios: |-",
          "656:     Family: KubeVirt",
          "657:     Manufacturer: KubeVirt",
          "658:     Product: None",
          "659: `)",
          "661: func deployExampleKubevirtConfigYamlBytes() ([]byte, error) {",
          "662:  return _deployExampleKubevirtConfigYaml, nil",
          "663: }",
          "665: func deployExampleKubevirtConfigYaml() (*asset, error) {",
          "666:  bytes, err := deployExampleKubevirtConfigYamlBytes()",
          "667:  if err != nil {",
          "668:   return nil, err",
          "669:  }",
          "671:  info := bindataFileInfo{name: \"deploy/example/kubevirt-config.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "672:  a := &asset{bytes: bytes, info: info}",
          "673:  return a, nil",
          "674: }",
          "676: var _deployExampleKubevirtYaml = []byte(`apiVersion: kubevirt.io/v1alpha3",
          "677: kind: KubeVirt",
          "678: metadata:",
          "679:   name: kubevirt",
          "680:   namespace: kubevirt",
          "681: spec:",
          "682:   certificateRotateStrategy: {}",
          "683:   configuration:",
          "684:     developerConfiguration:",
          "685:       featureGates:",
          "686:       - DataVolumes",
          "687:       - SRIOV",
          "688:       - LiveMigration",
          "689:       - CPUManager",
          "690:       - CPUNodeDiscovery",
          "691:       - Sidecar",
          "692:       - Snapshot",
          "693:       - HotplugVolumes",
          "694:     network:",
          "695:       defaultNetworkInterface: masquerade",
          "696:     smbios:",
          "697:       family: KubeVirt",
          "698:       manufacturer: KubeVirt",
          "699:       product: None",
          "700:       selinuxLauncherType: virt_launcher.process",
          "701:   customizeComponents: {}",
          "702:   uninstallStrategy: BlockUninstallIfWorkloadsExist",
          "703: `)",
          "705: func deployExampleKubevirtYamlBytes() ([]byte, error) {",
          "706:  return _deployExampleKubevirtYaml, nil",
          "707: }",
          "709: func deployExampleKubevirtYaml() (*asset, error) {",
          "710:  bytes, err := deployExampleKubevirtYamlBytes()",
          "711:  if err != nil {",
          "712:   return nil, err",
          "713:  }",
          "715:  info := bindataFileInfo{name: \"deploy/example/kubevirt.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "716:  a := &asset{bytes: bytes, info: info}",
          "717:  return a, nil",
          "718: }",
          "720: var _deployExampleStorageClaimYaml = []byte(`kind: PersistentVolumeClaim",
          "721: apiVersion: v1",
          "722: metadata:",
          "723:   name: 1g-kubevirt-disk",
          "724: spec:",
          "725:   storageClassName: kubevirt",
          "726:   accessModes:",
          "727:     - ReadWriteOnce",
          "728:   resources:",
          "729:     requests:",
          "730:       storage: 1Gi",
          "731: `)",
          "733: func deployExampleStorageClaimYamlBytes() ([]byte, error) {",
          "734:  return _deployExampleStorageClaimYaml, nil",
          "735: }",
          "737: func deployExampleStorageClaimYaml() (*asset, error) {",
          "738:  bytes, err := deployExampleStorageClaimYamlBytes()",
          "739:  if err != nil {",
          "740:   return nil, err",
          "741:  }",
          "743:  info := bindataFileInfo{name: \"deploy/example/storage-claim.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "744:  a := &asset{bytes: bytes, info: info}",
          "745:  return a, nil",
          "746: }",
          "748: var _deployExampleStorageclassYaml = []byte(`apiVersion: storage.k8s.io/v1",
          "749: kind: StorageClass",
          "750: metadata:",
          "751:   name: kubevirt",
          "752:   annotations:",
          "753:     storageclass.kubernetes.io/is-default-class: \"true\"",
          "754: provisioner: csi.kubevirt.io",
          "755: parameters:",
          "756:   infraStorageClassName: standard",
          "757:   bus: scsi",
          "758: `)",
          "760: func deployExampleStorageclassYamlBytes() ([]byte, error) {",
          "761:  return _deployExampleStorageclassYaml, nil",
          "762: }",
          "764: func deployExampleStorageclassYaml() (*asset, error) {",
          "765:  bytes, err := deployExampleStorageclassYamlBytes()",
          "766:  if err != nil {",
          "767:   return nil, err",
          "768:  }",
          "770:  info := bindataFileInfo{name: \"deploy/example/storageclass.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "771:  a := &asset{bytes: bytes, info: info}",
          "772:  return a, nil",
          "773: }",
          "775: var _deployExampleTestPodYaml = []byte(`apiVersion: v1",
          "776: kind: Pod",
          "777: metadata:",
          "778:   name: testpodwithcsi",
          "779: spec:",
          "780:   containers:",
          "781:   - image: busybox",
          "782:     name: testpodwithcsi",
          "783:     command: [\"sh\", \"-c\", \"while true; do ls -la /opt; echo this file system was made availble using kubevirt-csi-driver; mktmp /opt/test-XXXXXX; sleep 1m; done\"]",
          "784:     imagePullPolicy: Always",
          "785:     volumeMounts:",
          "786:     - name: pv0002",
          "787:       mountPath: \"/opt\"",
          "788:   volumes:",
          "789:   - name: pv0002",
          "790:     persistentVolumeClaim:",
          "791:       claimName: 1g-kubevirt-disk",
          "794: func deployExampleTestPodYamlBytes() ([]byte, error) {",
          "795:  return _deployExampleTestPodYaml, nil",
          "798: func deployExampleTestPodYaml() (*asset, error) {",
          "799:  bytes, err := deployExampleTestPodYamlBytes()",
          "804:  info := bindataFileInfo{name: \"deploy/example/test-pod.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "809: var _deployInfraClusterServiceAccountYaml = []byte(`apiVersion: v1",
          "810: kind: ServiceAccount",
          "811: metadata:",
          "812:   name: kubevirt-csi",
          "813: ---",
          "814: apiVersion: rbac.authorization.k8s.io/v1",
          "815: kind: Role",
          "816: metadata:",
          "817:   name: kubevirt-csi",
          "818: rules:",
          "819: - apiGroups: [\"cdi.kubevirt.io\"]",
          "820:   resources: [\"datavolumes\"]",
          "821:   verbs: [\"get\", \"create\", \"delete\"]",
          "822: - apiGroups: [\"kubevirt.io\"]",
          "823:   resources: [\"virtualmachineinstances\"]",
          "824:   verbs: [\"list\", \"get\"]",
          "825: - apiGroups: [\"subresources.kubevirt.io\"]",
          "826:   resources: [\"virtualmachineinstances/addvolume\", \"virtualmachineinstances/removevolume\"]",
          "827:   verbs: [\"update\"]",
          "828: - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "829:   resources: [\"volumesnapshots\"]",
          "830:   verbs: [\"get\", \"create\", \"delete\"]",
          "831: - apiGroups: [\"\"]",
          "832:   resources: [\"persistentvolumeclaims\"]",
          "833:   verbs: [\"get\"]",
          "834: ---",
          "835: apiVersion: rbac.authorization.k8s.io/v1",
          "836: kind: RoleBinding",
          "837: metadata:",
          "838:   name: kubevirt-csi",
          "839: roleRef:",
          "840:   apiGroup: rbac.authorization.k8s.io",
          "841:   kind: Role",
          "842:   name: kubevirt-csi",
          "843: subjects:",
          "844: - kind: ServiceAccount",
          "845:   name: kubevirt-csi",
          "850: func deployInfraClusterServiceAccountYamlBytes() ([]byte, error) {",
          "851:  return _deployInfraClusterServiceAccountYaml, nil",
          "854: func deployInfraClusterServiceAccountYaml() (*asset, error) {",
          "855:  bytes, err := deployInfraClusterServiceAccountYamlBytes()",
          "860:  info := bindataFileInfo{name: \"deploy/infra-cluster-service-account.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "865: var _deployTenantBaseDeployYaml = []byte(`apiVersion: storage.k8s.io/v1",
          "866: kind: CSIDriver",
          "868:   name: csi.kubevirt.io",
          "869: spec:",
          "870:   attachRequired: true",
          "871:   podInfoOnMount: true",
          "872:   fsGroupPolicy: ReadWriteOnceWithFSType",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "135: metadata:",
          "136:   name: kubevirt-csi-controller-cr",
          "137: rules:",
          "142:   - apiGroups: ['']",
          "143:     resources: ['persistentvolumes']",
          "144:     verbs: ['create', 'delete', 'get', 'list', 'watch', 'update', 'patch']",
          "",
          "[Removed Lines]",
          "138:   # Allow listing and creating CRDs",
          "139:   - apiGroups: ['apiextensions.k8s.io']",
          "140:     resources: ['customresourcedefinitions']",
          "141:     verbs: ['list', 'create']",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "189:     verbs: [\"use\"]",
          "190:     resourceNames: [\"privileged\"]",
          "191: ---",
          "192: apiVersion: rbac.authorization.k8s.io/v1",
          "193: kind: ClusterRole",
          "194: metadata:",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "935: kind: ClusterRoleBinding",
          "936: apiVersion: rbac.authorization.k8s.io/v1",
          "937: metadata:",
          "938:   name: kubevirt-csi-controller-binding",
          "939: subjects:",
          "940:   - kind: ServiceAccount",
          "941:     name: kubevirt-csi-controller-sa",
          "942:     namespace: kubevirt-csi-driver",
          "943: roleRef:",
          "944:   kind: ClusterRole",
          "945:   name: kubevirt-csi-controller-cr",
          "946:   apiGroup: rbac.authorization.k8s.io",
          "947: ---",
          "948: apiVersion: v1",
          "949: kind: ServiceAccount",
          "950: metadata:",
          "951:   name: kubevirt-csi-node-sa",
          "952:   namespace: kubevirt-csi-driver",
          "953: ---",
          "954: apiVersion: v1",
          "955: kind: ServiceAccount",
          "956: metadata:",
          "957:   name: kubevirt-csi-snapshot-sa",
          "958:   namespace: kubevirt-csi-driver",
          "959: ---",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "226:     verbs: [\"use\"]",
          "227:     resourceNames: [\"privileged\"]",
          "228: ---",
          "229: kind: ClusterRoleBinding",
          "230: apiVersion: rbac.authorization.k8s.io/v1",
          "231: metadata:",
          "233: subjects:",
          "234:   - kind: ServiceAccount",
          "236:     namespace: kubevirt-csi-driver",
          "237: roleRef:",
          "238:   kind: ClusterRole",
          "240:   apiGroup: rbac.authorization.k8s.io",
          "241: ---",
          "242: kind: ClusterRoleBinding",
          "243: apiVersion: rbac.authorization.k8s.io/v1",
          "244: metadata:",
          "246: subjects:",
          "247:   - kind: ServiceAccount",
          "249:     namespace: kubevirt-csi-driver",
          "250: roleRef:",
          "251:   kind: ClusterRole",
          "253:   apiGroup: rbac.authorization.k8s.io",
          "254: ---",
          "273: kind: DaemonSet",
          "274: apiVersion: apps/v1",
          "275: metadata:",
          "",
          "[Removed Lines]",
          "232:   name: kubevirt-csi-controller-binding",
          "235:     name: kubevirt-csi-controller-sa",
          "239:   name: kubevirt-csi-controller-cr",
          "245:   name: kubevirt-csi-node-binding",
          "248:     name: kubevirt-csi-node-sa",
          "252:   name: kubevirt-csi-node-cr",
          "255: `)",
          "257: func deploy020AutorizationYamlBytes() ([]byte, error) {",
          "258:  return _deploy020AutorizationYaml, nil",
          "259: }",
          "261: func deploy020AutorizationYaml() (*asset, error) {",
          "262:  bytes, err := deploy020AutorizationYamlBytes()",
          "263:  if err != nil {",
          "264:   return nil, err",
          "265:  }",
          "267:  info := bindataFileInfo{name: \"deploy/020-autorization.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "268:  a := &asset{bytes: bytes, info: info}",
          "269:  return a, nil",
          "270: }",
          "272: var _deploy030NodeYaml = []byte(`#TODO: Force DaemonSet to not run on master - see",
          "",
          "[Added Lines]",
          "997: kind: ClusterRole",
          "998: apiVersion: rbac.authorization.k8s.io/v1",
          "999: metadata:",
          "1000:   name: external-snapshotter-runner",
          "1001: rules:",
          "1002:   - apiGroups: [\"\"]",
          "1003:     resources: [\"events\"]",
          "1004:     verbs: [\"list\", \"watch\", \"create\", \"update\", \"patch\"]",
          "1005:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1006:     resources: [\"volumesnapshotclasses\"]",
          "1007:     verbs: [\"get\", \"list\", \"watch\"]",
          "1008:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1009:     resources: [\"volumesnapshotcontents\"]",
          "1010:     verbs: [\"create\", \"get\", \"list\", \"watch\", \"update\", \"delete\", \"patch\"]",
          "1011:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1012:     resources: [\"volumesnapshotcontents/status\"]",
          "1013:     verbs: [\"update\", \"patch\"]",
          "1014: ---",
          "1018:   name: kubevirt-csi-node-binding",
          "1021:     name: kubevirt-csi-node-sa",
          "1025:   name: kubevirt-csi-node-cr",
          "1031:   name: csi-snapshotter-role",
          "1034:     name: kubevirt-csi-snapshot-sa",
          "1038:   # change the name also here if the ClusterRole gets renamed",
          "1039:   name: external-snapshotter-runner",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "286:       labels:",
          "287:         app: kubevirt-csi-driver",
          "288:     spec:",
          "290:       serviceAccount: kubevirt-csi-node-sa",
          "291:       priorityClassName: system-node-critical",
          "292:       tolerations:",
          "",
          "[Removed Lines]",
          "289:       hostNetwork: true",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "300:           image: quay.io/kubevirt/csi-driver:latest",
          "301:           args:",
          "302:             - \"--endpoint=unix:/csi/csi.sock\"",
          "304:             - \"--node-name=$(KUBE_NODE_NAME)\"",
          "307:           env:",
          "308:             - name: KUBE_NODE_NAME",
          "309:               valueFrom:",
          "310:                 fieldRef:",
          "311:                   fieldPath: spec.nodeName",
          "322:           volumeMounts:",
          "325:             - name: kubelet-dir",
          "326:               mountPath: /var/lib/kubelet",
          "327:               mountPropagation: \"Bidirectional\"",
          "",
          "[Removed Lines]",
          "303:             - \"--namespace=kubevirt-csi-driver\"",
          "305:             - \"--infra-cluster-namespace=$(INFRACLUSTER_NAMESPACE)\"",
          "306:             - \"--infra-cluster-kubeconfig=/var/run/secrets/infracluster/kubeconfig\"",
          "312:             - name: INFRACLUSTER_NAMESPACE",
          "313:               valueFrom:",
          "314:                 configMapKeyRef:",
          "315:                   name: driver-config",
          "316:                   key: infraClusterNamespace",
          "317:             - name: INFRACLUSTER_LABELS",
          "318:               valueFrom:",
          "319:                 configMapKeyRef:",
          "320:                   name: driver-config",
          "321:                   key: infraClusterLabels",
          "323:             - name: infracluster",
          "324:               mountPath: \"/var/run/secrets/infracluster\"",
          "",
          "[Added Lines]",
          "1072:             - \"--run-node-service=true\"",
          "1073:             - \"--run-controller-service=false\"",
          "1074:             - \"--v=5\"",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "333:               mountPath: /run/udev",
          "334:           ports:",
          "335:             - name: healthz",
          "337:               containerPort: 10300",
          "338:               protocol: TCP",
          "339:           livenessProbe:",
          "",
          "[Removed Lines]",
          "336:               # due to hostNetwork, this port is open on a node!",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "349:               memory: 50Mi",
          "350:               cpu: 10m",
          "351:         - name: csi-node-driver-registrar",
          "354:           image: quay.io/openshift/origin-csi-node-driver-registrar:latest",
          "355:           args:",
          "359:           lifecycle:",
          "360:             preStop:",
          "361:               exec:",
          "",
          "[Removed Lines]",
          "352:           securityContext:",
          "353:             privileged: true",
          "356:             - --csi-address=$(ADDRESS)",
          "357:             - --kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)",
          "358:             - --v=5",
          "",
          "[Added Lines]",
          "1109:             - \"--csi-address=$(ADDRESS)\"",
          "1110:             - \"--kubelet-registration-path=$(DRIVER_REG_SOCK_PATH)\"",
          "1111:             - \"--v=5\"",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "377:         - name: csi-liveness-probe",
          "378:           image: quay.io/openshift/origin-csi-livenessprobe:latest",
          "379:           args:",
          "383:           volumeMounts:",
          "384:             - name: plugin-dir",
          "385:               mountPath: /csi",
          "",
          "[Removed Lines]",
          "380:             - --csi-address=/csi/csi.sock",
          "381:             - --probe-timeout=3s",
          "382:             - --health-port=10300",
          "",
          "[Added Lines]",
          "1133:             - \"--csi-address=/csi/csi.sock\"",
          "1134:             - \"--probe-timeout=3s\"",
          "1135:             - \"--health-port=10300\"",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "388:               memory: 20Mi",
          "389:               cpu: 5m",
          "390:       volumes:",
          "394:         - name: kubelet-dir",
          "395:           hostPath:",
          "396:             path: /var/lib/kubelet",
          "",
          "[Removed Lines]",
          "391:         - name: infracluster",
          "392:           secret:",
          "393:             secretName: infra-cluster-credentials",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "410:         - name: udev",
          "411:           hostPath:",
          "412:             path: /run/udev",
          "413: `)",
          "417: }",
          "421:  if err != nil {",
          "422:   return nil, err",
          "423:  }",
          "426:  a := &asset{bytes: bytes, info: info}",
          "427:  return a, nil",
          "428: }",
          "544: `)",
          "563: metadata:",
          "569: `)",
          "573: }",
          "577:  if err != nil {",
          "578:   return nil, err",
          "579:  }",
          "582:  a := &asset{bytes: bytes, info: info}",
          "583:  return a, nil",
          "584: }",
          "605: `)",
          "609: }",
          "613:  if err != nil {",
          "614:   return nil, err",
          "615:  }",
          "618:  a := &asset{bytes: bytes, info: info}",
          "619:  return a, nil",
          "620: }",
          "624: metadata:",
          "635: `)",
          "639: }",
          "643:  if err != nil {",
          "644:   return nil, err",
          "645:  }",
          "648:  a := &asset{bytes: bytes, info: info}",
          "649:  return a, nil",
          "650: }",
          "654: metadata:",
          "657: spec:",
          "679: `)",
          "683: }",
          "687:  if err != nil {",
          "688:   return nil, err",
          "689:  }",
          "692:  a := &asset{bytes: bytes, info: info}",
          "693:  return a, nil",
          "694: }",
          "698: metadata:",
          "700: spec:",
          "707: `)",
          "711: }",
          "715:  if err != nil {",
          "716:   return nil, err",
          "717:  }",
          "720:  a := &asset{bytes: bytes, info: info}",
          "721:  return a, nil",
          "722: }",
          "726: metadata:",
          "734: `)",
          "738: }",
          "742:  if err != nil {",
          "743:   return nil, err",
          "744:  }",
          "747:  a := &asset{bytes: bytes, info: info}",
          "748:  return a, nil",
          "749: }",
          "768: `)",
          "772: }",
          "776:  if err != nil {",
          "777:   return nil, err",
          "778:  }",
          "781:  a := &asset{bytes: bytes, info: info}",
          "782:  return a, nil",
          "783: }",
          "807: metadata:",
          "820: }",
          "824:  if err != nil {",
          "825:   return nil, err",
          "826:  }",
          "829:  a := &asset{bytes: bytes, info: info}",
          "830:  return a, nil",
          "831: }",
          "835: metadata:",
          "843: }",
          "847:  if err != nil {",
          "848:   return nil, err",
          "849:  }",
          "852:  a := &asset{bytes: bytes, info: info}",
          "853:  return a, nil",
          "854: }",
          "",
          "[Removed Lines]",
          "415: func deploy030NodeYamlBytes() ([]byte, error) {",
          "416:  return _deploy030NodeYaml, nil",
          "419: func deploy030NodeYaml() (*asset, error) {",
          "420:  bytes, err := deploy030NodeYamlBytes()",
          "425:  info := bindataFileInfo{name: \"deploy/030-node.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "430: var _deploy040ControllerYaml = []byte(`kind: Deployment",
          "431: apiVersion: apps/v1",
          "432: metadata:",
          "433:   name: kubevirt-csi-controller",
          "434:   namespace: kubevirt-csi-driver",
          "435: spec:",
          "436:   replicas: 1",
          "437:   selector:",
          "438:     matchLabels:",
          "439:       app: kubevirt-csi-driver",
          "440:   template:",
          "441:     metadata:",
          "442:       labels:",
          "443:         app: kubevirt-csi-driver",
          "444:     spec:",
          "445:       hostNetwork: true",
          "446:       serviceAccount: kubevirt-csi-controller-sa",
          "447:       priorityClassName: system-cluster-critical",
          "448:       nodeSelector:",
          "449:         node-role.kubernetes.io/master: \"\"",
          "450:       tolerations:",
          "451:         - key: CriticalAddonsOnly",
          "452:           operator: Exists",
          "453:         - key: node-role.kubernetes.io/master",
          "454:           operator: Exists",
          "455:           effect: \"NoSchedule\"",
          "456:       containers:",
          "457:         - name: csi-driver",
          "458:           imagePullPolicy: Always",
          "459:           image: quay.io/kubevirt/csi-driver:latest",
          "460:           args:",
          "461:             - \"--endpoint=$(CSI_ENDPOINT)\"",
          "462:             - \"--namespace=kubevirt-csi-driver\"",
          "463:             - \"--infra-cluster-namespace=$(INFRACLUSTER_NAMESPACE)\"",
          "464:             - \"--infra-cluster-kubeconfig=/var/run/secrets/infracluster/kubeconfig\"",
          "465:             - \"--infra-cluster-labels=$(INFRACLUSTER_LABELS)\"",
          "466:             - --v=5",
          "467:           ports:",
          "468:             - name: healthz",
          "469:               # Due to hostNetwork, this port is open on a node!",
          "470:               containerPort: 10301",
          "471:               protocol: TCP",
          "472:           env:",
          "473:             - name: CSI_ENDPOINT",
          "474:               value: unix:///var/lib/csi/sockets/pluginproxy/csi.sock",
          "475:             - name: KUBE_NODE_NAME",
          "476:               valueFrom:",
          "477:                 fieldRef:",
          "478:                   fieldPath: spec.nodeName",
          "479:             - name: INFRACLUSTER_NAMESPACE",
          "480:               valueFrom:",
          "481:                 configMapKeyRef:",
          "482:                   name: driver-config",
          "483:                   key: infraClusterNamespace",
          "484:             - name: INFRACLUSTER_LABELS",
          "485:               valueFrom:",
          "486:                 configMapKeyRef:",
          "487:                   name: driver-config",
          "488:                   key: infraClusterLabels",
          "489:           volumeMounts:",
          "490:             - name: socket-dir",
          "491:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "492:             - name: infracluster",
          "493:               mountPath: \"/var/run/secrets/infracluster\"",
          "494:           resources:",
          "495:             requests:",
          "496:               memory: 50Mi",
          "497:               cpu: 10m",
          "498:         - name: csi-provisioner",
          "499:           image: quay.io/openshift/origin-csi-external-provisioner:latest",
          "500:           args:",
          "501:             - --csi-address=$(ADDRESS)",
          "502:             - --default-fstype=ext4",
          "503:             - --v=5",
          "504:           env:",
          "505:             - name: ADDRESS",
          "506:               value: /var/lib/csi/sockets/pluginproxy/csi.sock",
          "507:           volumeMounts:",
          "508:             - name: socket-dir",
          "509:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "510:         - name: csi-attacher",
          "511:           image: quay.io/openshift/origin-csi-external-attacher:latest",
          "512:           args:",
          "513:             - --csi-address=$(ADDRESS)",
          "514:             - --v=5",
          "515:           env:",
          "516:             - name: ADDRESS",
          "517:               value: /var/lib/csi/sockets/pluginproxy/csi.sock",
          "518:           volumeMounts:",
          "519:             - name: socket-dir",
          "520:               mountPath: /var/lib/csi/sockets/pluginproxy/",
          "521:           resources:",
          "522:             requests:",
          "523:               memory: 50Mi",
          "524:               cpu: 10m",
          "525:         - name: csi-liveness-probe",
          "526:           image: quay.io/openshift/origin-csi-livenessprobe:latest",
          "527:           args:",
          "528:             - --csi-address=/csi/csi.sock",
          "529:             - --probe-timeout=3s",
          "530:             - --health-port=10301",
          "531:           volumeMounts:",
          "532:             - name: socket-dir",
          "533:               mountPath: /csi",
          "534:           resources:",
          "535:             requests:",
          "536:               memory: 50Mi",
          "537:               cpu: 10m",
          "538:       volumes:",
          "539:         - name: socket-dir",
          "540:           emptyDir: {}",
          "541:         - name: infracluster",
          "542:           secret:",
          "543:             secretName: infra-cluster-credentials",
          "546: func deploy040ControllerYamlBytes() ([]byte, error) {",
          "547:  return _deploy040ControllerYaml, nil",
          "548: }",
          "550: func deploy040ControllerYaml() (*asset, error) {",
          "551:  bytes, err := deploy040ControllerYamlBytes()",
          "552:  if err != nil {",
          "553:   return nil, err",
          "554:  }",
          "556:  info := bindataFileInfo{name: \"deploy/040-controller.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "557:  a := &asset{bytes: bytes, info: info}",
          "558:  return a, nil",
          "559: }",
          "561: var _deployConfigmapYaml = []byte(`apiVersion: v1",
          "562: kind: ConfigMap",
          "564:   name: driver-config",
          "565:   namespace: kubevirt-csi-driver",
          "566: data:",
          "567:   infraClusterNamespace:",
          "568:   infraClusterLabels: key=value,key=value,...",
          "571: func deployConfigmapYamlBytes() ([]byte, error) {",
          "572:  return _deployConfigmapYaml, nil",
          "575: func deployConfigmapYaml() (*asset, error) {",
          "576:  bytes, err := deployConfigmapYamlBytes()",
          "581:  info := bindataFileInfo{name: \"deploy/configmap.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "586: var _deployExampleInfraclusterKubeconfigYaml = []byte(`apiVersion: v1",
          "587: clusters:",
          "588: - cluster:",
          "589:     certificate-authority-data: <Base64 of CA. Take value from the kubeconfig used to create the ServiceAccount kubevirt-csi>",
          "590:     server: <URL of cluster. E.g.https://api.crc.testing:6443. Take value from the kubeconfig used to create the ServiceAccount kubevirt-csi>",
          "591:   name: infra-cluster",
          "592: contexts:",
          "593: - context:",
          "594:     cluster: infra-cluster",
          "595:     namespace: <optional, not used>",
          "596:     user: kubevirt-csi",
          "597:   name: only-context",
          "598: current-context: only-context",
          "599: kind: Config",
          "600: preferences: {}",
          "601: users:",
          "602: - name: kubevirt-csi",
          "603:   user:",
          "604:     token: <use token from secret in ServiceAccount kubevirt-csi. Decode it from base64 (base64 -d)>",
          "607: func deployExampleInfraclusterKubeconfigYamlBytes() ([]byte, error) {",
          "608:  return _deployExampleInfraclusterKubeconfigYaml, nil",
          "611: func deployExampleInfraclusterKubeconfigYaml() (*asset, error) {",
          "612:  bytes, err := deployExampleInfraclusterKubeconfigYamlBytes()",
          "617:  info := bindataFileInfo{name: \"deploy/example/infracluster-kubeconfig.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "622: var _deployExampleKubevirtConfigYaml = []byte(`apiVersion: v1",
          "623: kind: ConfigMap",
          "625:   name: kubevirt-config",
          "626:   namespace: kubevirt",
          "627: data:",
          "628:   default-network-interface: masquerade",
          "629:   feature-gates: DataVolumes,SRIOV,LiveMigration,CPUManager,CPUNodeDiscovery,Sidecar,Snapshot,HotplugVolumes",
          "630:   selinuxLauncherType: virt_launcher.process",
          "631:   smbios: |-",
          "632:     Family: KubeVirt",
          "633:     Manufacturer: KubeVirt",
          "634:     Product: None",
          "637: func deployExampleKubevirtConfigYamlBytes() ([]byte, error) {",
          "638:  return _deployExampleKubevirtConfigYaml, nil",
          "641: func deployExampleKubevirtConfigYaml() (*asset, error) {",
          "642:  bytes, err := deployExampleKubevirtConfigYamlBytes()",
          "647:  info := bindataFileInfo{name: \"deploy/example/kubevirt-config.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "652: var _deployExampleKubevirtYaml = []byte(`apiVersion: kubevirt.io/v1alpha3",
          "653: kind: KubeVirt",
          "655:   name: kubevirt",
          "656:   namespace: kubevirt",
          "658:   certificateRotateStrategy: {}",
          "659:   configuration:",
          "660:     developerConfiguration:",
          "661:       featureGates:",
          "662:       - DataVolumes",
          "663:       - SRIOV",
          "664:       - LiveMigration",
          "665:       - CPUManager",
          "666:       - CPUNodeDiscovery",
          "667:       - Sidecar",
          "668:       - Snapshot",
          "669:       - HotplugVolumes",
          "670:     network:",
          "671:       defaultNetworkInterface: masquerade",
          "672:     smbios:",
          "673:       family: KubeVirt",
          "674:       manufacturer: KubeVirt",
          "675:       product: None",
          "676:       selinuxLauncherType: virt_launcher.process",
          "677:   customizeComponents: {}",
          "678:   uninstallStrategy: BlockUninstallIfWorkloadsExist",
          "681: func deployExampleKubevirtYamlBytes() ([]byte, error) {",
          "682:  return _deployExampleKubevirtYaml, nil",
          "685: func deployExampleKubevirtYaml() (*asset, error) {",
          "686:  bytes, err := deployExampleKubevirtYamlBytes()",
          "691:  info := bindataFileInfo{name: \"deploy/example/kubevirt.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "696: var _deployExampleStorageClaimYaml = []byte(`kind: PersistentVolumeClaim",
          "697: apiVersion: v1",
          "699:   name: 1g-kubevirt-disk",
          "701:   storageClassName: kubevirt",
          "702:   accessModes:",
          "703:     - ReadWriteOnce",
          "704:   resources:",
          "705:     requests:",
          "706:       storage: 1Gi",
          "709: func deployExampleStorageClaimYamlBytes() ([]byte, error) {",
          "710:  return _deployExampleStorageClaimYaml, nil",
          "713: func deployExampleStorageClaimYaml() (*asset, error) {",
          "714:  bytes, err := deployExampleStorageClaimYamlBytes()",
          "719:  info := bindataFileInfo{name: \"deploy/example/storage-claim.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "724: var _deployExampleStorageclassYaml = []byte(`apiVersion: storage.k8s.io/v1",
          "725: kind: StorageClass",
          "727:   name: kubevirt",
          "728:   annotations:",
          "729:     storageclass.kubernetes.io/is-default-class: \"true\"",
          "730: provisioner: csi.kubevirt.io",
          "731: parameters:",
          "732:   infraStorageClassName: standard",
          "733:   bus: scsi",
          "736: func deployExampleStorageclassYamlBytes() ([]byte, error) {",
          "737:  return _deployExampleStorageclassYaml, nil",
          "740: func deployExampleStorageclassYaml() (*asset, error) {",
          "741:  bytes, err := deployExampleStorageclassYamlBytes()",
          "746:  info := bindataFileInfo{name: \"deploy/example/storageclass.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "751: var _deployExampleTestPodYaml = []byte(`apiVersion: v1",
          "752: kind: Pod",
          "753: metadata:",
          "754:   name: testpodwithcsi",
          "755: spec:",
          "756:   containers:",
          "757:   - image: busybox",
          "758:     name: testpodwithcsi",
          "759:     command: [\"sh\", \"-c\", \"while true; do ls -la /opt; echo this file system was made availble using kubevirt-csi-driver; mktmp /opt/test-XXXXXX; sleep 1m; done\"]",
          "760:     imagePullPolicy: Always",
          "761:     volumeMounts:",
          "762:     - name: pv0002",
          "763:       mountPath: \"/opt\"",
          "764:   volumes:",
          "765:   - name: pv0002",
          "766:     persistentVolumeClaim:",
          "767:       claimName: 1g-kubevirt-disk",
          "770: func deployExampleTestPodYamlBytes() ([]byte, error) {",
          "771:  return _deployExampleTestPodYaml, nil",
          "774: func deployExampleTestPodYaml() (*asset, error) {",
          "775:  bytes, err := deployExampleTestPodYamlBytes()",
          "780:  info := bindataFileInfo{name: \"deploy/example/test-pod.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "785: var _deployInfraClusterServiceAccountYaml = []byte(`apiVersion: v1",
          "786: kind: ServiceAccount",
          "787: metadata:",
          "788:   name: kubevirt-csi",
          "789: ---",
          "790: apiVersion: rbac.authorization.k8s.io/v1",
          "791: kind: Role",
          "792: metadata:",
          "793:   name: kubevirt-csi",
          "794: rules:",
          "795: - apiGroups: [\"cdi.kubevirt.io\"]",
          "796:   resources: [\"datavolumes\"]",
          "797:   verbs: [\"get\", \"create\", \"delete\"]",
          "798: - apiGroups: [\"kubevirt.io\"]",
          "799:   resources: [\"virtualmachineinstances\"]",
          "800:   verbs: [\"list\"]",
          "801: - apiGroups: [\"subresources.kubevirt.io\"]",
          "802:   resources: [\"virtualmachineinstances/addvolume\", \"virtualmachineinstances/removevolume\"]",
          "803:   verbs: [\"update\"]",
          "804: ---",
          "805: apiVersion: rbac.authorization.k8s.io/v1",
          "806: kind: RoleBinding",
          "808:   name: kubevirt-csi",
          "809: roleRef:",
          "810:   apiGroup: rbac.authorization.k8s.io",
          "811:   kind: Role",
          "812:   name: kubevirt-csi",
          "813: subjects:",
          "814: - kind: ServiceAccount",
          "815:   name: kubevirt-csi",
          "816: ---`)",
          "818: func deployInfraClusterServiceAccountYamlBytes() ([]byte, error) {",
          "819:  return _deployInfraClusterServiceAccountYaml, nil",
          "822: func deployInfraClusterServiceAccountYaml() (*asset, error) {",
          "823:  bytes, err := deployInfraClusterServiceAccountYamlBytes()",
          "828:  info := bindataFileInfo{name: \"deploy/infra-cluster-service-account.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "833: var _deploySecretYaml = []byte(`apiVersion: v1",
          "834: kind: Secret",
          "836:   name: infra-cluster-credentials",
          "837:   namespace: kubevirt-csi-driver",
          "838: data:",
          "839:   kubeconfig: `)",
          "841: func deploySecretYamlBytes() ([]byte, error) {",
          "842:  return _deploySecretYaml, nil",
          "845: func deploySecretYaml() (*asset, error) {",
          "846:  bytes, err := deploySecretYamlBytes()",
          "851:  info := bindataFileInfo{name: \"deploy/secret.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "",
          "[Added Lines]",
          "1163: ---",
          "1164: apiVersion: v1",
          "1165: kind: ConfigMap",
          "1166: metadata:",
          "1167:   name: driver-config",
          "1168:   namespace: kubevirt-csi-driver",
          "1169: data:",
          "1170:   infraClusterNamespace:",
          "1171:   infraClusterLabels: csi-driver/cluster=tenant",
          "1172: ---",
          "1173: apiVersion: storage.k8s.io/v1",
          "1174: kind: StorageClass",
          "1175: metadata:",
          "1176:   name: kubevirt",
          "1177:   annotations:",
          "1178:     storageclass.kubernetes.io/is-default-class: \"true\"",
          "1179: provisioner: csi.kubevirt.io",
          "1180: parameters:",
          "1181:   infraStorageClassName: standard",
          "1182:   bus: scsi",
          "1183: ---",
          "1184: apiVersion: snapshot.storage.k8s.io/v1",
          "1185: kind: VolumeSnapshotClass",
          "1186: metadata:",
          "1187:   name: kubevirt-csi-snapclass",
          "1188: driver: csi.kubevirt.io",
          "1189: deletionPolicy: Delete",
          "1192: func deployTenantBaseDeployYamlBytes() ([]byte, error) {",
          "1193:  return _deployTenantBaseDeployYaml, nil",
          "1196: func deployTenantBaseDeployYaml() (*asset, error) {",
          "1197:  bytes, err := deployTenantBaseDeployYamlBytes()",
          "1202:  info := bindataFileInfo{name: \"deploy/tenant/base/deploy.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "1207: var _deployTenantBaseKustomizationYaml = []byte(`commonLabels:",
          "1208:   app: kubevirt-csi-driver",
          "1209: resources:",
          "1210: - rbac-snapshot-controller.yaml",
          "1211: - setup-snapshot-controller.yaml",
          "1212: - snapshot.storage.k8s.io_volumesnapshotclasses.yaml",
          "1213: - snapshot.storage.k8s.io_volumesnapshotcontents.yaml",
          "1214: - snapshot.storage.k8s.io_volumesnapshots.yaml",
          "1215: - deploy.yaml",
          "1218: func deployTenantBaseKustomizationYamlBytes() ([]byte, error) {",
          "1219:  return _deployTenantBaseKustomizationYaml, nil",
          "1220: }",
          "1222: func deployTenantBaseKustomizationYaml() (*asset, error) {",
          "1223:  bytes, err := deployTenantBaseKustomizationYamlBytes()",
          "1224:  if err != nil {",
          "1225:   return nil, err",
          "1226:  }",
          "1228:  info := bindataFileInfo{name: \"deploy/tenant/base/kustomization.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "1229:  a := &asset{bytes: bytes, info: info}",
          "1230:  return a, nil",
          "1231: }",
          "1233: var _deployTenantBaseRbacSnapshotControllerYaml = []byte(`# RBAC file for the snapshot controller.",
          "1234: #",
          "1235: # The snapshot controller implements the control loop for CSI snapshot functionality.",
          "1236: # It should be installed as part of the base Kubernetes distribution in an appropriate",
          "1237: # namespace for components implementing base system functionality. For installing with",
          "1238: # Vanilla Kubernetes, kube-system makes sense for the namespace.",
          "1240: ---",
          "1241: apiVersion: v1",
          "1242: kind: ServiceAccount",
          "1243: metadata:",
          "1244:   name: snapshot-controller",
          "1245:   namespace: kube-system",
          "1247: ---",
          "1248: kind: ClusterRole",
          "1249: apiVersion: rbac.authorization.k8s.io/v1",
          "1250: metadata:",
          "1251:   name: snapshot-controller-runner",
          "1252: rules:",
          "1253:   - apiGroups: [\"\"]",
          "1254:     resources: [\"persistentvolumes\"]",
          "1255:     verbs: [\"get\", \"list\", \"watch\"]",
          "1256:   - apiGroups: [\"\"]",
          "1257:     resources: [\"persistentvolumeclaims\"]",
          "1258:     verbs: [\"get\", \"list\", \"watch\", \"update\"]",
          "1259:   - apiGroups: [\"\"]",
          "1260:     resources: [\"events\"]",
          "1261:     verbs: [\"list\", \"watch\", \"create\", \"update\", \"patch\"]",
          "1262:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1263:     resources: [\"volumesnapshotclasses\"]",
          "1264:     verbs: [\"get\", \"list\", \"watch\"]",
          "1265:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1266:     resources: [\"volumesnapshotcontents\"]",
          "1267:     verbs: [\"create\", \"get\", \"list\", \"watch\", \"update\", \"delete\", \"patch\"]",
          "1268:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1269:     resources: [\"volumesnapshotcontents/status\"]",
          "1270:     verbs: [\"patch\"]",
          "1271:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1272:     resources: [\"volumesnapshots\"]",
          "1273:     verbs: [\"get\", \"list\", \"watch\", \"update\", \"patch\", \"delete\"]",
          "1274:   - apiGroups: [\"snapshot.storage.k8s.io\"]",
          "1275:     resources: [\"volumesnapshots/status\"]",
          "1276:     verbs: [\"update\", \"patch\"]",
          "1278:   - apiGroups: [\"groupsnapshot.storage.k8s.io\"]",
          "1279:     resources: [\"volumegroupsnapshotclasses\"]",
          "1280:     verbs: [\"get\", \"list\", \"watch\"]",
          "1281:   - apiGroups: [\"groupsnapshot.storage.k8s.io\"]",
          "1282:     resources: [\"volumegroupsnapshotcontents\"]",
          "1283:     verbs: [\"create\", \"get\", \"list\", \"watch\", \"update\", \"delete\", \"patch\"]",
          "1284:   - apiGroups: [\"groupsnapshot.storage.k8s.io\"]",
          "1285:     resources: [\"volumegroupsnapshotcontents/status\"]",
          "1286:     verbs: [\"patch\"]",
          "1287:   - apiGroups: [\"groupsnapshot.storage.k8s.io\"]",
          "1288:     resources: [\"volumegroupsnapshots\"]",
          "1289:     verbs: [\"get\", \"list\", \"watch\", \"update\", \"patch\"]",
          "1290:   - apiGroups: [\"groupsnapshot.storage.k8s.io\"]",
          "1291:     resources: [\"volumegroupsnapshots/status\"]",
          "1292:     verbs: [\"update\", \"patch\"]",
          "1294:   # Enable this RBAC rule only when using distributed snapshotting, i.e. when the enable-distributed-snapshotting flag is set to true",
          "1295:   # - apiGroups: [\"\"]",
          "1296:   #   resources: [\"nodes\"]",
          "1297:   #   verbs: [\"get\", \"list\", \"watch\"]",
          "1298: ---",
          "1299: kind: ClusterRoleBinding",
          "1300: apiVersion: rbac.authorization.k8s.io/v1",
          "1301: metadata:",
          "1302:   name: snapshot-controller-role",
          "1303: subjects:",
          "1304:   - kind: ServiceAccount",
          "1305:     name: snapshot-controller",
          "1306:     namespace: kube-system",
          "1307: roleRef:",
          "1308:   kind: ClusterRole",
          "1309:   name: snapshot-controller-runner",
          "1310:   apiGroup: rbac.authorization.k8s.io",
          "1312: ---",
          "1313: kind: Role",
          "1314: apiVersion: rbac.authorization.k8s.io/v1",
          "1315: metadata:",
          "1316:   name: snapshot-controller-leaderelection",
          "1317:   namespace: kube-system",
          "1318: rules:",
          "1319: - apiGroups: [\"coordination.k8s.io\"]",
          "1320:   resources: [\"leases\"]",
          "1321:   verbs: [\"get\", \"watch\", \"list\", \"delete\", \"update\", \"create\"]",
          "1323: ---",
          "1324: kind: RoleBinding",
          "1325: apiVersion: rbac.authorization.k8s.io/v1",
          "1327:   name: snapshot-controller-leaderelection",
          "1328:   namespace: kube-system",
          "1329: subjects:",
          "1330:   - kind: ServiceAccount",
          "1331:     name: snapshot-controller",
          "1332: roleRef:",
          "1333:   kind: Role",
          "1334:   name: snapshot-controller-leaderelection",
          "1335:   apiGroup: rbac.authorization.k8s.io",
          "1338: func deployTenantBaseRbacSnapshotControllerYamlBytes() ([]byte, error) {",
          "1339:  return _deployTenantBaseRbacSnapshotControllerYaml, nil",
          "1342: func deployTenantBaseRbacSnapshotControllerYaml() (*asset, error) {",
          "1343:  bytes, err := deployTenantBaseRbacSnapshotControllerYamlBytes()",
          "1348:  info := bindataFileInfo{name: \"deploy/tenant/base/rbac-snapshot-controller.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "1353: var _deployTenantBaseSetupSnapshotControllerYaml = []byte(`# This YAML file shows how to deploy the snapshot controller",
          "1355: # The snapshot controller implements the control loop for CSI snapshot functionality.",
          "1356: # It should be installed as part of the base Kubernetes distribution in an appropriate",
          "1357: # namespace for components implementing base system functionality. For installing with",
          "1358: # Vanilla Kubernetes, kube-system makes sense for the namespace.",
          "1360: ---",
          "1361: kind: Deployment",
          "1362: apiVersion: apps/v1",
          "1363: metadata:",
          "1364:   name: snapshot-controller",
          "1365:   namespace: kube-system",
          "1366: spec:",
          "1367:   replicas: 2",
          "1368:   selector:",
          "1369:     matchLabels:",
          "1370:       app.kubernetes.io/name: snapshot-controller",
          "1371:   # The snapshot controller won't be marked as ready if the v1 CRDs are unavailable.",
          "1372:   # The flag --retry-crd-interval-max is used to determine how long the controller",
          "1373:   # will wait for the CRDs to become available before exiting. The default is 30 seconds",
          "1374:   # so minReadySeconds should be set slightly higher than the flag value.",
          "1375:   minReadySeconds: 35",
          "1376:   strategy:",
          "1377:     rollingUpdate:",
          "1378:       maxSurge: 0",
          "1379:       maxUnavailable: 1",
          "1380:     type: RollingUpdate",
          "1381:   template:",
          "1382:     metadata:",
          "1383:       labels:",
          "1384:         app.kubernetes.io/name: snapshot-controller",
          "1385:     spec:",
          "1386:       serviceAccountName: snapshot-controller",
          "1387:       containers:",
          "1388:         - name: snapshot-controller",
          "1389:           image: registry.k8s.io/sig-storage/snapshot-controller:v6.3.1",
          "1390:           args:",
          "1391:             - \"--v=5\"",
          "1392:             - \"--leader-election=true\"",
          "1393:             # Add a marker to the snapshot-controller manifests. This is needed to enable feature gates in CSI prow jobs.",
          "1394:             # For example, in https://github.com/kubernetes-csi/csi-release-tools/pull/209, the snapshot-controller YAML is updated to add --prevent-volume-mode-conversion=true so that the feature can be enabled for certain e2e tests.",
          "1395:             # end snapshot controller args",
          "1396:           imagePullPolicy: IfNotPresent",
          "1399: func deployTenantBaseSetupSnapshotControllerYamlBytes() ([]byte, error) {",
          "1400:  return _deployTenantBaseSetupSnapshotControllerYaml, nil",
          "1403: func deployTenantBaseSetupSnapshotControllerYaml() (*asset, error) {",
          "1404:  bytes, err := deployTenantBaseSetupSnapshotControllerYamlBytes()",
          "1409:  info := bindataFileInfo{name: \"deploy/tenant/base/setup-snapshot-controller.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "1414: var _deployTenantBaseSnapshotStorageK8sIo_volumesnapshotclassesYaml = []byte(`---",
          "1415: apiVersion: apiextensions.k8s.io/v1",
          "1416: kind: CustomResourceDefinition",
          "1418:   annotations:",
          "1419:     api-approved.kubernetes.io: \"https://github.com/kubernetes-csi/external-snapshotter/pull/814\"",
          "1420:     controller-gen.kubebuilder.io/version: v0.12.0",
          "1421:   creationTimestamp: null",
          "1422:   name: volumesnapshotclasses.snapshot.storage.k8s.io",
          "1423: spec:",
          "1424:   group: snapshot.storage.k8s.io",
          "1425:   names:",
          "1426:     kind: VolumeSnapshotClass",
          "1427:     listKind: VolumeSnapshotClassList",
          "1428:     plural: volumesnapshotclasses",
          "1429:     shortNames:",
          "1430:     - vsclass",
          "1431:     - vsclasses",
          "1432:     singular: volumesnapshotclass",
          "1433:   scope: Cluster",
          "1434:   versions:",
          "1435:   - additionalPrinterColumns:",
          "1436:     - jsonPath: .driver",
          "1437:       name: Driver",
          "1438:       type: string",
          "1439:     - description: Determines whether a VolumeSnapshotContent created through the",
          "1440:         VolumeSnapshotClass should be deleted when its bound VolumeSnapshot is deleted.",
          "1441:       jsonPath: .deletionPolicy",
          "1442:       name: DeletionPolicy",
          "1443:       type: string",
          "1444:     - jsonPath: .metadata.creationTimestamp",
          "1445:       name: Age",
          "1446:       type: date",
          "1447:     name: v1",
          "1448:     schema:",
          "1449:       openAPIV3Schema:",
          "1450:         description: VolumeSnapshotClass specifies parameters that a underlying storage",
          "1451:           system uses when creating a volume snapshot. A specific VolumeSnapshotClass",
          "1452:           is used by specifying its name in a VolumeSnapshot object. VolumeSnapshotClasses",
          "1453:           are non-namespaced",
          "1454:         properties:",
          "1455:           apiVersion:",
          "1456:             description: 'APIVersion defines the versioned schema of this representation",
          "1457:               of an object. Servers should convert recognized schemas to the latest",
          "1458:               internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'",
          "1459:             type: string",
          "1460:           deletionPolicy:",
          "1461:             description: deletionPolicy determines whether a VolumeSnapshotContent",
          "1462:               created through the VolumeSnapshotClass should be deleted when its bound",
          "1463:               VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\".",
          "1464:               \"Retain\" means that the VolumeSnapshotContent and its physical snapshot",
          "1465:               on underlying storage system are kept. \"Delete\" means that the VolumeSnapshotContent",
          "1466:               and its physical snapshot on underlying storage system are deleted.",
          "1467:               Required.",
          "1468:             enum:",
          "1469:             - Delete",
          "1470:             - Retain",
          "1471:             type: string",
          "1472:           driver:",
          "1473:             description: driver is the name of the storage driver that handles this",
          "1474:               VolumeSnapshotClass. Required.",
          "1475:             type: string",
          "1476:           kind:",
          "1477:             description: 'Kind is a string value representing the REST resource this",
          "1478:               object represents. Servers may infer this from the endpoint the client",
          "1479:               submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "1480:             type: string",
          "1481:           metadata:",
          "1482:             type: object",
          "1483:           parameters:",
          "1484:             additionalProperties:",
          "1485:               type: string",
          "1486:             description: parameters is a key-value map with storage driver specific",
          "1487:               parameters for creating snapshots. These values are opaque to Kubernetes.",
          "1488:             type: object",
          "1489:         required:",
          "1490:         - deletionPolicy",
          "1491:         - driver",
          "1492:         type: object",
          "1493:     served: true",
          "1494:     storage: true",
          "1495:     subresources: {}",
          "1496:   - additionalPrinterColumns:",
          "1497:     - jsonPath: .driver",
          "1498:       name: Driver",
          "1499:       type: string",
          "1500:     - description: Determines whether a VolumeSnapshotContent created through the VolumeSnapshotClass should be deleted when its bound VolumeSnapshot is deleted.",
          "1501:       jsonPath: .deletionPolicy",
          "1502:       name: DeletionPolicy",
          "1503:       type: string",
          "1504:     - jsonPath: .metadata.creationTimestamp",
          "1505:       name: Age",
          "1506:       type: date",
          "1507:     name: v1beta1",
          "1508:     # This indicates the v1beta1 version of the custom resource is deprecated.",
          "1509:     # API requests to this version receive a warning in the server response.",
          "1510:     deprecated: true",
          "1511:     # This overrides the default warning returned to clients making v1beta1 API requests.",
          "1512:     deprecationWarning: \"snapshot.storage.k8s.io/v1beta1 VolumeSnapshotClass is deprecated; use snapshot.storage.k8s.io/v1 VolumeSnapshotClass\"",
          "1513:     schema:",
          "1514:       openAPIV3Schema:",
          "1515:         description: VolumeSnapshotClass specifies parameters that a underlying storage system uses when creating a volume snapshot. A specific VolumeSnapshotClass is used by specifying its name in a VolumeSnapshot object. VolumeSnapshotClasses are non-namespaced",
          "1516:         properties:",
          "1517:           apiVersion:",
          "1518:             description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'",
          "1519:             type: string",
          "1520:           deletionPolicy:",
          "1521:             description: deletionPolicy determines whether a VolumeSnapshotContent created through the VolumeSnapshotClass should be deleted when its bound VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\". \"Retain\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept. \"Delete\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted. Required.",
          "1522:             enum:",
          "1523:             - Delete",
          "1524:             - Retain",
          "1525:             type: string",
          "1526:           driver:",
          "1527:             description: driver is the name of the storage driver that handles this VolumeSnapshotClass. Required.",
          "1528:             type: string",
          "1529:           kind:",
          "1530:             description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "1531:             type: string",
          "1532:           parameters:",
          "1533:             additionalProperties:",
          "1534:               type: string",
          "1535:             description: parameters is a key-value map with storage driver specific parameters for creating snapshots. These values are opaque to Kubernetes.",
          "1536:             type: object",
          "1537:         required:",
          "1538:         - deletionPolicy",
          "1539:         - driver",
          "1540:         type: object",
          "1541:     served: false",
          "1542:     storage: false",
          "1543:     subresources: {}",
          "1544: status:",
          "1545:   acceptedNames:",
          "1546:     kind: \"\"",
          "1547:     plural: \"\"",
          "1548:   conditions: []",
          "1549:   storedVersions: []",
          "1552: func deployTenantBaseSnapshotStorageK8sIo_volumesnapshotclassesYamlBytes() ([]byte, error) {",
          "1553:  return _deployTenantBaseSnapshotStorageK8sIo_volumesnapshotclassesYaml, nil",
          "1556: func deployTenantBaseSnapshotStorageK8sIo_volumesnapshotclassesYaml() (*asset, error) {",
          "1557:  bytes, err := deployTenantBaseSnapshotStorageK8sIo_volumesnapshotclassesYamlBytes()",
          "1562:  info := bindataFileInfo{name: \"deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshotclasses.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "1567: var _deployTenantBaseSnapshotStorageK8sIo_volumesnapshotcontentsYaml = []byte(`---",
          "1568: apiVersion: apiextensions.k8s.io/v1",
          "1569: kind: CustomResourceDefinition",
          "1571:   annotations:",
          "1572:     api-approved.kubernetes.io: \"https://github.com/kubernetes-csi/external-snapshotter/pull/955\"",
          "1573:     controller-gen.kubebuilder.io/version: v0.12.0",
          "1574:   creationTimestamp: null",
          "1575:   name: volumesnapshotcontents.snapshot.storage.k8s.io",
          "1577:   group: snapshot.storage.k8s.io",
          "1578:   names:",
          "1579:     kind: VolumeSnapshotContent",
          "1580:     listKind: VolumeSnapshotContentList",
          "1581:     plural: volumesnapshotcontents",
          "1582:     shortNames:",
          "1583:     - vsc",
          "1584:     - vscs",
          "1585:     singular: volumesnapshotcontent",
          "1586:   scope: Cluster",
          "1587:   versions:",
          "1588:   - additionalPrinterColumns:",
          "1589:     - description: Indicates if the snapshot is ready to be used to restore a volume.",
          "1590:       jsonPath: .status.readyToUse",
          "1591:       name: ReadyToUse",
          "1592:       type: boolean",
          "1593:     - description: Represents the complete size of the snapshot in bytes",
          "1594:       jsonPath: .status.restoreSize",
          "1595:       name: RestoreSize",
          "1596:       type: integer",
          "1597:     - description: Determines whether this VolumeSnapshotContent and its physical",
          "1598:         snapshot on the underlying storage system should be deleted when its bound",
          "1599:         VolumeSnapshot is deleted.",
          "1600:       jsonPath: .spec.deletionPolicy",
          "1601:       name: DeletionPolicy",
          "1602:       type: string",
          "1603:     - description: Name of the CSI driver used to create the physical snapshot on",
          "1604:         the underlying storage system.",
          "1605:       jsonPath: .spec.driver",
          "1606:       name: Driver",
          "1607:       type: string",
          "1608:     - description: Name of the VolumeSnapshotClass to which this snapshot belongs.",
          "1609:       jsonPath: .spec.volumeSnapshotClassName",
          "1610:       name: VolumeSnapshotClass",
          "1611:       type: string",
          "1612:     - description: Name of the VolumeSnapshot object to which this VolumeSnapshotContent",
          "1613:         object is bound.",
          "1614:       jsonPath: .spec.volumeSnapshotRef.name",
          "1615:       name: VolumeSnapshot",
          "1616:       type: string",
          "1617:     - description: Namespace of the VolumeSnapshot object to which this VolumeSnapshotContent object is bound.",
          "1618:       jsonPath: .spec.volumeSnapshotRef.namespace",
          "1619:       name: VolumeSnapshotNamespace",
          "1620:       type: string",
          "1621:     - jsonPath: .metadata.creationTimestamp",
          "1622:       name: Age",
          "1623:       type: date",
          "1624:     name: v1",
          "1625:     schema:",
          "1626:       openAPIV3Schema:",
          "1627:         description: VolumeSnapshotContent represents the actual \"on-disk\" snapshot",
          "1628:           object in the underlying storage system",
          "1629:         properties:",
          "1630:           apiVersion:",
          "1631:             description: 'APIVersion defines the versioned schema of this representation",
          "1632:               of an object. Servers should convert recognized schemas to the latest",
          "1633:               internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'",
          "1634:             type: string",
          "1635:           kind:",
          "1636:             description: 'Kind is a string value representing the REST resource this",
          "1637:               object represents. Servers may infer this from the endpoint the client",
          "1638:               submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "1639:             type: string",
          "1640:           metadata:",
          "1641:             type: object",
          "1642:           spec:",
          "1643:             description: spec defines properties of a VolumeSnapshotContent created",
          "1644:               by the underlying storage system. Required.",
          "1645:             properties:",
          "1646:               deletionPolicy:",
          "1647:                 description: deletionPolicy determines whether this VolumeSnapshotContent",
          "1648:                   and its physical snapshot on the underlying storage system should",
          "1649:                   be deleted when its bound VolumeSnapshot is deleted. Supported values",
          "1650:                   are \"Retain\" and \"Delete\". \"Retain\" means that the VolumeSnapshotContent",
          "1651:                   and its physical snapshot on underlying storage system are kept.",
          "1652:                   \"Delete\" means that the VolumeSnapshotContent and its physical snapshot",
          "1653:                   on underlying storage system are deleted. For dynamically provisioned",
          "1654:                   snapshots, this field will automatically be filled in by the CSI",
          "1655:                   snapshotter sidecar with the \"DeletionPolicy\" field defined in the",
          "1656:                   corresponding VolumeSnapshotClass. For pre-existing snapshots, users",
          "1657:                   MUST specify this field when creating the VolumeSnapshotContent",
          "1658:                   object. Required.",
          "1659:                 enum:",
          "1660:                 - Delete",
          "1661:                 - Retain",
          "1662:                 type: string",
          "1663:               driver:",
          "1664:                 description: driver is the name of the CSI driver used to create the",
          "1665:                   physical snapshot on the underlying storage system. This MUST be",
          "1666:                   the same as the name returned by the CSI GetPluginName() call for",
          "1667:                   that driver. Required.",
          "1668:                 type: string",
          "1669:               source:",
          "1670:                 description: source specifies whether the snapshot is (or should be)",
          "1671:                   dynamically provisioned or already exists, and just requires a Kubernetes",
          "1672:                   object representation. This field is immutable after creation. Required.",
          "1673:                 properties:",
          "1674:                   snapshotHandle:",
          "1675:                     description: snapshotHandle specifies the CSI \"snapshot_id\" of",
          "1676:                       a pre-existing snapshot on the underlying storage system for",
          "1677:                       which a Kubernetes object representation was (or should be)",
          "1678:                       created. This field is immutable.",
          "1679:                     type: string",
          "1680:                   volumeHandle:",
          "1681:                     description: volumeHandle specifies the CSI \"volume_id\" of the",
          "1682:                       volume from which a snapshot should be dynamically taken from.",
          "1683:                       This field is immutable.",
          "1684:                     type: string",
          "1685:                 type: object",
          "1686:                 oneOf:",
          "1687:                 - required: [\"snapshotHandle\"]",
          "1688:                 - required: [\"volumeHandle\"]",
          "1689:               sourceVolumeMode:",
          "1690:                 description: SourceVolumeMode is the mode of the volume whose snapshot",
          "1691:                   is taken. Can be either \u201cFilesystem\u201d or \u201cBlock\u201d. If not specified,",
          "1692:                   it indicates the source volume's mode is unknown. This field is",
          "1693:                   immutable. This field is an alpha field.",
          "1694:                 type: string",
          "1695:               volumeSnapshotClassName:",
          "1696:                 description: name of the VolumeSnapshotClass from which this snapshot",
          "1697:                   was (or will be) created. Note that after provisioning, the VolumeSnapshotClass",
          "1698:                   may be deleted or recreated with different set of values, and as",
          "1699:                   such, should not be referenced post-snapshot creation.",
          "1700:                 type: string",
          "1701:               volumeSnapshotRef:",
          "1702:                 description: volumeSnapshotRef specifies the VolumeSnapshot object",
          "1703:                   to which this VolumeSnapshotContent object is bound. VolumeSnapshot.Spec.VolumeSnapshotContentName",
          "1704:                   field must reference to this VolumeSnapshotContent's name for the",
          "1705:                   bidirectional binding to be valid. For a pre-existing VolumeSnapshotContent",
          "1706:                   object, name and namespace of the VolumeSnapshot object MUST be",
          "1707:                   provided for binding to happen. This field is immutable after creation.",
          "1708:                   Required.",
          "1709:                 properties:",
          "1710:                   apiVersion:",
          "1711:                     description: API version of the referent.",
          "1712:                     type: string",
          "1713:                   fieldPath:",
          "1714:                     description: 'If referring to a piece of an object instead of",
          "1715:                       an entire object, this string should contain a valid JSON/Go",
          "1716:                       field access statement, such as desiredState.manifest.containers[2].",
          "1717:                       For example, if the object reference is to a container within",
          "1718:                       a pod, this would take on a value like: \"spec.containers{name}\"",
          "1719:                       (where \"name\" refers to the name of the container that triggered",
          "1720:                       the event) or if no container name is specified \"spec.containers[2]\"",
          "1721:                       (container with index 2 in this pod). This syntax is chosen",
          "1722:                       only to have some well-defined way of referencing a part of",
          "1723:                       an object. TODO: this design is not final and this field is",
          "1724:                       subject to change in the future.'",
          "1725:                     type: string",
          "1726:                   kind:",
          "1727:                     description: 'Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "1728:                     type: string",
          "1729:                   name:",
          "1730:                     description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'",
          "1731:                     type: string",
          "1732:                   namespace:",
          "1733:                     description: 'Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/'",
          "1734:                     type: string",
          "1735:                   resourceVersion:",
          "1736:                     description: 'Specific resourceVersion to which this reference",
          "1737:                       is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency'",
          "1738:                     type: string",
          "1739:                   uid:",
          "1740:                     description: 'UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids'",
          "1741:                     type: string",
          "1742:                 type: object",
          "1743:                 x-kubernetes-map-type: atomic",
          "1744:             required:",
          "1745:             - deletionPolicy",
          "1746:             - driver",
          "1747:             - source",
          "1748:             - volumeSnapshotRef",
          "1749:             type: object",
          "1750:           status:",
          "1751:             description: status represents the current information of a snapshot.",
          "1752:             properties:",
          "1753:               creationTime:",
          "1754:                 description: creationTime is the timestamp when the point-in-time",
          "1755:                   snapshot is taken by the underlying storage system. In dynamic snapshot",
          "1756:                   creation case, this field will be filled in by the CSI snapshotter",
          "1757:                   sidecar with the \"creation_time\" value returned from CSI \"CreateSnapshot\"",
          "1758:                   gRPC call. For a pre-existing snapshot, this field will be filled",
          "1759:                   with the \"creation_time\" value returned from the CSI \"ListSnapshots\"",
          "1760:                   gRPC call if the driver supports it. If not specified, it indicates",
          "1761:                   the creation time is unknown. The format of this field is a Unix",
          "1762:                   nanoseconds time encoded as an int64. On Unix, the command ` + \"`\" + `date",
          "1763:                   +%s%N` + \"`\" + ` returns the current time in nanoseconds since 1970-01-01",
          "1764:                   00:00:00 UTC.",
          "1765:                 format: int64",
          "1766:                 type: integer",
          "1767:               error:",
          "1768:                 description: error is the last observed error during snapshot creation,",
          "1769:                   if any. Upon success after retry, this error field will be cleared.",
          "1770:                 properties:",
          "1771:                   message:",
          "1772:                     description: 'message is a string detailing the encountered error",
          "1773:                       during snapshot creation if specified. NOTE: message may be",
          "1774:                       logged, and it should not contain sensitive information.'",
          "1775:                     type: string",
          "1776:                   time:",
          "1777:                     description: time is the timestamp when the error was encountered.",
          "1778:                     format: date-time",
          "1779:                     type: string",
          "1780:                 type: object",
          "1781:               readyToUse:",
          "1782:                 description: readyToUse indicates if a snapshot is ready to be used",
          "1783:                   to restore a volume. In dynamic snapshot creation case, this field",
          "1784:                   will be filled in by the CSI snapshotter sidecar with the \"ready_to_use\"",
          "1785:                   value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing",
          "1786:                   snapshot, this field will be filled with the \"ready_to_use\" value",
          "1787:                   returned from the CSI \"ListSnapshots\" gRPC call if the driver supports",
          "1788:                   it, otherwise, this field will be set to \"True\". If not specified,",
          "1789:                   it means the readiness of a snapshot is unknown.",
          "1790:                 type: boolean",
          "1791:               restoreSize:",
          "1792:                 description: restoreSize represents the complete size of the snapshot",
          "1793:                   in bytes. In dynamic snapshot creation case, this field will be",
          "1794:                   filled in by the CSI snapshotter sidecar with the \"size_bytes\" value",
          "1795:                   returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing",
          "1796:                   snapshot, this field will be filled with the \"size_bytes\" value",
          "1797:                   returned from the CSI \"ListSnapshots\" gRPC call if the driver supports",
          "1798:                   it. When restoring a volume from this snapshot, the size of the",
          "1799:                   volume MUST NOT be smaller than the restoreSize if it is specified,",
          "1800:                   otherwise the restoration will fail. If not specified, it indicates",
          "1801:                   that the size is unknown.",
          "1802:                 format: int64",
          "1803:                 minimum: 0",
          "1804:                 type: integer",
          "1805:               snapshotHandle:",
          "1806:                 description: snapshotHandle is the CSI \"snapshot_id\" of a snapshot",
          "1807:                   on the underlying storage system. If not specified, it indicates",
          "1808:                   that dynamic snapshot creation has either failed or it is still",
          "1809:                   in progress.",
          "1810:                 type: string",
          "1811:               volumeGroupSnapshotHandle:",
          "1812:                 description: VolumeGroupSnapshotHandle is the CSI \"group_snapshot_id\"",
          "1813:                   of a group snapshot on the underlying storage system.",
          "1814:                 type: string",
          "1815:             type: object",
          "1816:         required:",
          "1817:         - spec",
          "1818:         type: object",
          "1819:     served: true",
          "1820:     storage: true",
          "1821:     subresources:",
          "1822:       status: {}",
          "1823:   - additionalPrinterColumns:",
          "1824:     - description: Indicates if the snapshot is ready to be used to restore a volume.",
          "1825:       jsonPath: .status.readyToUse",
          "1826:       name: ReadyToUse",
          "1827:       type: boolean",
          "1828:     - description: Represents the complete size of the snapshot in bytes",
          "1829:       jsonPath: .status.restoreSize",
          "1830:       name: RestoreSize",
          "1831:       type: integer",
          "1832:     - description: Determines whether this VolumeSnapshotContent and its physical snapshot on the underlying storage system should be deleted when its bound VolumeSnapshot is deleted.",
          "1833:       jsonPath: .spec.deletionPolicy",
          "1834:       name: DeletionPolicy",
          "1835:       type: string",
          "1836:     - description: Name of the CSI driver used to create the physical snapshot on the underlying storage system.",
          "1837:       jsonPath: .spec.driver",
          "1838:       name: Driver",
          "1839:       type: string",
          "1840:     - description: Name of the VolumeSnapshotClass to which this snapshot belongs.",
          "1841:       jsonPath: .spec.volumeSnapshotClassName",
          "1842:       name: VolumeSnapshotClass",
          "1843:       type: string",
          "1844:     - description: Name of the VolumeSnapshot object to which this VolumeSnapshotContent object is bound.",
          "1845:       jsonPath: .spec.volumeSnapshotRef.name",
          "1846:       name: VolumeSnapshot",
          "1847:       type: string",
          "1848:     - description: Namespace of the VolumeSnapshot object to which this VolumeSnapshotContent object is bound.",
          "1849:       jsonPath: .spec.volumeSnapshotRef.namespace",
          "1850:       name: VolumeSnapshotNamespace",
          "1851:       type: string",
          "1852:     - jsonPath: .metadata.creationTimestamp",
          "1853:       name: Age",
          "1854:       type: date",
          "1855:     name: v1beta1",
          "1856:     # This indicates the v1beta1 version of the custom resource is deprecated.",
          "1857:     # API requests to this version receive a warning in the server response.",
          "1858:     deprecated: true",
          "1859:     # This overrides the default warning returned to clients making v1beta1 API requests.",
          "1860:     deprecationWarning: \"snapshot.storage.k8s.io/v1beta1 VolumeSnapshotContent is deprecated; use snapshot.storage.k8s.io/v1 VolumeSnapshotContent\"",
          "1861:     schema:",
          "1862:       openAPIV3Schema:",
          "1863:         description: VolumeSnapshotContent represents the actual \"on-disk\" snapshot object in the underlying storage system",
          "1864:         properties:",
          "1865:           apiVersion:",
          "1866:             description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'",
          "1867:             type: string",
          "1868:           kind:",
          "1869:             description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "1870:             type: string",
          "1871:           spec:",
          "1872:             description: spec defines properties of a VolumeSnapshotContent created by the underlying storage system. Required.",
          "1873:             properties:",
          "1874:               deletionPolicy:",
          "1875:                 description: deletionPolicy determines whether this VolumeSnapshotContent and its physical snapshot on the underlying storage system should be deleted when its bound VolumeSnapshot is deleted. Supported values are \"Retain\" and \"Delete\". \"Retain\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are kept. \"Delete\" means that the VolumeSnapshotContent and its physical snapshot on underlying storage system are deleted. For dynamically provisioned snapshots, this field will automatically be filled in by the CSI snapshotter sidecar with the \"DeletionPolicy\" field defined in the corresponding VolumeSnapshotClass. For pre-existing snapshots, users MUST specify this field when creating the  VolumeSnapshotContent object. Required.",
          "1876:                 enum:",
          "1877:                 - Delete",
          "1878:                 - Retain",
          "1879:                 type: string",
          "1880:               driver:",
          "1881:                 description: driver is the name of the CSI driver used to create the physical snapshot on the underlying storage system. This MUST be the same as the name returned by the CSI GetPluginName() call for that driver. Required.",
          "1882:                 type: string",
          "1883:               source:",
          "1884:                 description: source specifies whether the snapshot is (or should be) dynamically provisioned or already exists, and just requires a Kubernetes object representation. This field is immutable after creation. Required.",
          "1885:                 properties:",
          "1886:                   snapshotHandle:",
          "1887:                     description: snapshotHandle specifies the CSI \"snapshot_id\" of a pre-existing snapshot on the underlying storage system for which a Kubernetes object representation was (or should be) created. This field is immutable.",
          "1888:                     type: string",
          "1889:                   volumeHandle:",
          "1890:                     description: volumeHandle specifies the CSI \"volume_id\" of the volume from which a snapshot should be dynamically taken from. This field is immutable.",
          "1891:                     type: string",
          "1892:                 type: object",
          "1893:               volumeSnapshotClassName:",
          "1894:                 description: name of the VolumeSnapshotClass from which this snapshot was (or will be) created. Note that after provisioning, the VolumeSnapshotClass may be deleted or recreated with different set of values, and as such, should not be referenced post-snapshot creation.",
          "1895:                 type: string",
          "1896:               volumeSnapshotRef:",
          "1897:                 description: volumeSnapshotRef specifies the VolumeSnapshot object to which this VolumeSnapshotContent object is bound. VolumeSnapshot.Spec.VolumeSnapshotContentName field must reference to this VolumeSnapshotContent's name for the bidirectional binding to be valid. For a pre-existing VolumeSnapshotContent object, name and namespace of the VolumeSnapshot object MUST be provided for binding to happen. This field is immutable after creation. Required.",
          "1898:                 properties:",
          "1899:                   apiVersion:",
          "1900:                     description: API version of the referent.",
          "1901:                     type: string",
          "1902:                   fieldPath:",
          "1903:                     description: 'If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: \"spec.containers{name}\" (where \"name\" refers to the name of the container that triggered the event) or if no container name is specified \"spec.containers[2]\" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object. TODO: this design is not final and this field is subject to change in the future.'",
          "1904:                     type: string",
          "1905:                   kind:",
          "1906:                     description: 'Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "1907:                     type: string",
          "1908:                   name:",
          "1909:                     description: 'Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names'",
          "1910:                     type: string",
          "1911:                   namespace:",
          "1912:                     description: 'Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/'",
          "1913:                     type: string",
          "1914:                   resourceVersion:",
          "1915:                     description: 'Specific resourceVersion to which this reference is made, if any. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency'",
          "1916:                     type: string",
          "1917:                   uid:",
          "1918:                     description: 'UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids'",
          "1919:                     type: string",
          "1920:                 type: object",
          "1921:             required:",
          "1922:             - deletionPolicy",
          "1923:             - driver",
          "1924:             - source",
          "1925:             - volumeSnapshotRef",
          "1926:             type: object",
          "1927:           status:",
          "1928:             description: status represents the current information of a snapshot.",
          "1929:             properties:",
          "1930:               creationTime:",
          "1931:                 description: creationTime is the timestamp when the point-in-time snapshot is taken by the underlying storage system. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"creation_time\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"creation_time\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. If not specified, it indicates the creation time is unknown. The format of this field is a Unix nanoseconds time encoded as an int64. On Unix, the command ` + \"`\" + `date +%s%N` + \"`\" + ` returns the current time in nanoseconds since 1970-01-01 00:00:00 UTC.",
          "1932:                 format: int64",
          "1933:                 type: integer",
          "1934:               error:",
          "1935:                 description: error is the last observed error during snapshot creation, if any. Upon success after retry, this error field will be cleared.",
          "1936:                 properties:",
          "1937:                   message:",
          "1938:                     description: 'message is a string detailing the encountered error during snapshot creation if specified. NOTE: message may be logged, and it should not contain sensitive information.'",
          "1939:                     type: string",
          "1940:                   time:",
          "1941:                     description: time is the timestamp when the error was encountered.",
          "1942:                     format: date-time",
          "1943:                     type: string",
          "1944:                 type: object",
          "1945:               readyToUse:",
          "1946:                 description: readyToUse indicates if a snapshot is ready to be used to restore a volume. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"ready_to_use\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"ready_to_use\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it, otherwise, this field will be set to \"True\". If not specified, it means the readiness of a snapshot is unknown.",
          "1947:                 type: boolean",
          "1948:               restoreSize:",
          "1949:                 description: restoreSize represents the complete size of the snapshot in bytes. In dynamic snapshot creation case, this field will be filled in by the CSI snapshotter sidecar with the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"size_bytes\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. When restoring a volume from this snapshot, the size of the volume MUST NOT be smaller than the restoreSize if it is specified, otherwise the restoration will fail. If not specified, it indicates that the size is unknown.",
          "1950:                 format: int64",
          "1951:                 minimum: 0",
          "1952:                 type: integer",
          "1953:               snapshotHandle:",
          "1954:                 description: snapshotHandle is the CSI \"snapshot_id\" of a snapshot on the underlying storage system. If not specified, it indicates that dynamic snapshot creation has either failed or it is still in progress.",
          "1955:                 type: string",
          "1956:             type: object",
          "1957:         required:",
          "1958:         - spec",
          "1959:         type: object",
          "1960:     served: false",
          "1961:     storage: false",
          "1962:     subresources:",
          "1963:       status: {}",
          "1964: status:",
          "1965:   acceptedNames:",
          "1966:     kind: \"\"",
          "1967:     plural: \"\"",
          "1968:   conditions: []",
          "1969:   storedVersions: []",
          "1972: func deployTenantBaseSnapshotStorageK8sIo_volumesnapshotcontentsYamlBytes() ([]byte, error) {",
          "1973:  return _deployTenantBaseSnapshotStorageK8sIo_volumesnapshotcontentsYaml, nil",
          "1976: func deployTenantBaseSnapshotStorageK8sIo_volumesnapshotcontentsYaml() (*asset, error) {",
          "1977:  bytes, err := deployTenantBaseSnapshotStorageK8sIo_volumesnapshotcontentsYamlBytes()",
          "1982:  info := bindataFileInfo{name: \"deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshotcontents.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "1987: var _deployTenantBaseSnapshotStorageK8sIo_volumesnapshotsYaml = []byte(`---",
          "1988: apiVersion: apiextensions.k8s.io/v1",
          "1989: kind: CustomResourceDefinition",
          "1991:   annotations:",
          "1992:     api-approved.kubernetes.io: \"https://github.com/kubernetes-csi/external-snapshotter/pull/814\"",
          "1993:     controller-gen.kubebuilder.io/version: v0.12.0",
          "1994:   creationTimestamp: null",
          "1995:   name: volumesnapshots.snapshot.storage.k8s.io",
          "1997:   group: snapshot.storage.k8s.io",
          "1998:   names:",
          "1999:     kind: VolumeSnapshot",
          "2000:     listKind: VolumeSnapshotList",
          "2001:     plural: volumesnapshots",
          "2002:     shortNames:",
          "2003:     - vs",
          "2004:     singular: volumesnapshot",
          "2005:   scope: Namespaced",
          "2006:   versions:",
          "2007:   - additionalPrinterColumns:",
          "2008:     - description: Indicates if the snapshot is ready to be used to restore a volume.",
          "2009:       jsonPath: .status.readyToUse",
          "2010:       name: ReadyToUse",
          "2011:       type: boolean",
          "2012:     - description: If a new snapshot needs to be created, this contains the name of",
          "2013:         the source PVC from which this snapshot was (or will be) created.",
          "2014:       jsonPath: .spec.source.persistentVolumeClaimName",
          "2015:       name: SourcePVC",
          "2016:       type: string",
          "2017:     - description: If a snapshot already exists, this contains the name of the existing",
          "2018:         VolumeSnapshotContent object representing the existing snapshot.",
          "2019:       jsonPath: .spec.source.volumeSnapshotContentName",
          "2020:       name: SourceSnapshotContent",
          "2021:       type: string",
          "2022:     - description: Represents the minimum size of volume required to rehydrate from",
          "2023:         this snapshot.",
          "2024:       jsonPath: .status.restoreSize",
          "2025:       name: RestoreSize",
          "2026:       type: string",
          "2027:     - description: The name of the VolumeSnapshotClass requested by the VolumeSnapshot.",
          "2028:       jsonPath: .spec.volumeSnapshotClassName",
          "2029:       name: SnapshotClass",
          "2030:       type: string",
          "2031:     - description: Name of the VolumeSnapshotContent object to which the VolumeSnapshot",
          "2032:         object intends to bind to. Please note that verification of binding actually",
          "2033:         requires checking both VolumeSnapshot and VolumeSnapshotContent to ensure",
          "2034:         both are pointing at each other. Binding MUST be verified prior to usage of",
          "2035:         this object.",
          "2036:       jsonPath: .status.boundVolumeSnapshotContentName",
          "2037:       name: SnapshotContent",
          "2038:       type: string",
          "2039:     - description: Timestamp when the point-in-time snapshot was taken by the underlying",
          "2040:         storage system.",
          "2041:       jsonPath: .status.creationTime",
          "2042:       name: CreationTime",
          "2043:       type: date",
          "2044:     - jsonPath: .metadata.creationTimestamp",
          "2045:       name: Age",
          "2046:       type: date",
          "2047:     name: v1",
          "2048:     schema:",
          "2049:       openAPIV3Schema:",
          "2050:         description: VolumeSnapshot is a user's request for either creating a point-in-time",
          "2051:           snapshot of a persistent volume, or binding to a pre-existing snapshot.",
          "2052:         properties:",
          "2053:           apiVersion:",
          "2054:             description: 'APIVersion defines the versioned schema of this representation",
          "2055:               of an object. Servers should convert recognized schemas to the latest",
          "2056:               internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'",
          "2057:             type: string",
          "2058:           kind:",
          "2059:             description: 'Kind is a string value representing the REST resource this",
          "2060:               object represents. Servers may infer this from the endpoint the client",
          "2061:               submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "2062:             type: string",
          "2063:           metadata:",
          "2064:             type: object",
          "2065:           spec:",
          "2066:             description: 'spec defines the desired characteristics of a snapshot requested",
          "2067:               by a user. More info: https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots",
          "2068:               Required.'",
          "2069:             properties:",
          "2070:               source:",
          "2071:                 description: source specifies where a snapshot will be created from.",
          "2072:                   This field is immutable after creation. Required.",
          "2073:                 properties:",
          "2074:                   persistentVolumeClaimName:",
          "2075:                     description: persistentVolumeClaimName specifies the name of the",
          "2076:                       PersistentVolumeClaim object representing the volume from which",
          "2077:                       a snapshot should be created. This PVC is assumed to be in the",
          "2078:                       same namespace as the VolumeSnapshot object. This field should",
          "2079:                       be set if the snapshot does not exists, and needs to be created.",
          "2080:                       This field is immutable.",
          "2081:                     type: string",
          "2082:                   volumeSnapshotContentName:",
          "2083:                     description: volumeSnapshotContentName specifies the name of a",
          "2084:                       pre-existing VolumeSnapshotContent object representing an existing",
          "2085:                       volume snapshot. This field should be set if the snapshot already",
          "2086:                       exists and only needs a representation in Kubernetes. This field",
          "2087:                       is immutable.",
          "2088:                     type: string",
          "2089:                 type: object",
          "2090:                 oneOf:",
          "2091:                 - required: [\"persistentVolumeClaimName\"]",
          "2092:                 - required: [\"volumeSnapshotContentName\"]",
          "2093:               volumeSnapshotClassName:",
          "2094:                 description: 'VolumeSnapshotClassName is the name of the VolumeSnapshotClass",
          "2095:                   requested by the VolumeSnapshot. VolumeSnapshotClassName may be",
          "2096:                   left nil to indicate that the default SnapshotClass should be used.",
          "2097:                   A given cluster may have multiple default Volume SnapshotClasses:",
          "2098:                   one default per CSI Driver. If a VolumeSnapshot does not specify",
          "2099:                   a SnapshotClass, VolumeSnapshotSource will be checked to figure",
          "2100:                   out what the associated CSI Driver is, and the default VolumeSnapshotClass",
          "2101:                   associated with that CSI Driver will be used. If more than one VolumeSnapshotClass",
          "2102:                   exist for a given CSI Driver and more than one have been marked",
          "2103:                   as default, CreateSnapshot will fail and generate an event. Empty",
          "2104:                   string is not allowed for this field.'",
          "2105:                 type: string",
          "2106:             required:",
          "2107:             - source",
          "2108:             type: object",
          "2109:           status:",
          "2110:             description: status represents the current information of a snapshot.",
          "2111:               Consumers must verify binding between VolumeSnapshot and VolumeSnapshotContent",
          "2112:               objects is successful (by validating that both VolumeSnapshot and VolumeSnapshotContent",
          "2113:               point at each other) before using this object.",
          "2114:             properties:",
          "2115:               boundVolumeSnapshotContentName:",
          "2116:                 description: 'boundVolumeSnapshotContentName is the name of the VolumeSnapshotContent",
          "2117:                   object to which this VolumeSnapshot object intends to bind to. If",
          "2118:                   not specified, it indicates that the VolumeSnapshot object has not",
          "2119:                   been successfully bound to a VolumeSnapshotContent object yet. NOTE:",
          "2120:                   To avoid possible security issues, consumers must verify binding",
          "2121:                   between VolumeSnapshot and VolumeSnapshotContent objects is successful",
          "2122:                   (by validating that both VolumeSnapshot and VolumeSnapshotContent",
          "2123:                   point at each other) before using this object.'",
          "2124:                 type: string",
          "2125:               creationTime:",
          "2126:                 description: creationTime is the timestamp when the point-in-time",
          "2127:                   snapshot is taken by the underlying storage system. In dynamic snapshot",
          "2128:                   creation case, this field will be filled in by the snapshot controller",
          "2129:                   with the \"creation_time\" value returned from CSI \"CreateSnapshot\"",
          "2130:                   gRPC call. For a pre-existing snapshot, this field will be filled",
          "2131:                   with the \"creation_time\" value returned from the CSI \"ListSnapshots\"",
          "2132:                   gRPC call if the driver supports it. If not specified, it may indicate",
          "2133:                   that the creation time of the snapshot is unknown.",
          "2134:                 format: date-time",
          "2135:                 type: string",
          "2136:               error:",
          "2137:                 description: error is the last observed error during snapshot creation,",
          "2138:                   if any. This field could be helpful to upper level controllers(i.e.,",
          "2139:                   application controller) to decide whether they should continue on",
          "2140:                   waiting for the snapshot to be created based on the type of error",
          "2141:                   reported. The snapshot controller will keep retrying when an error",
          "2142:                   occurs during the snapshot creation. Upon success, this error field",
          "2143:                   will be cleared.",
          "2144:                 properties:",
          "2145:                   message:",
          "2146:                     description: 'message is a string detailing the encountered error",
          "2147:                       during snapshot creation if specified. NOTE: message may be",
          "2148:                       logged, and it should not contain sensitive information.'",
          "2149:                     type: string",
          "2150:                   time:",
          "2151:                     description: time is the timestamp when the error was encountered.",
          "2152:                     format: date-time",
          "2153:                     type: string",
          "2154:                 type: object",
          "2155:               readyToUse:",
          "2156:                 description: readyToUse indicates if the snapshot is ready to be used",
          "2157:                   to restore a volume. In dynamic snapshot creation case, this field",
          "2158:                   will be filled in by the snapshot controller with the \"ready_to_use\"",
          "2159:                   value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing",
          "2160:                   snapshot, this field will be filled with the \"ready_to_use\" value",
          "2161:                   returned from the CSI \"ListSnapshots\" gRPC call if the driver supports",
          "2162:                   it, otherwise, this field will be set to \"True\". If not specified,",
          "2163:                   it means the readiness of a snapshot is unknown.",
          "2164:                 type: boolean",
          "2165:               restoreSize:",
          "2166:                 type: string",
          "2167:                 description: restoreSize represents the minimum size of volume required",
          "2168:                   to create a volume from this snapshot. In dynamic snapshot creation",
          "2169:                   case, this field will be filled in by the snapshot controller with",
          "2170:                   the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC call.",
          "2171:                   For a pre-existing snapshot, this field will be filled with the",
          "2172:                   \"size_bytes\" value returned from the CSI \"ListSnapshots\" gRPC call",
          "2173:                   if the driver supports it. When restoring a volume from this snapshot,",
          "2174:                   the size of the volume MUST NOT be smaller than the restoreSize",
          "2175:                   if it is specified, otherwise the restoration will fail. If not",
          "2176:                   specified, it indicates that the size is unknown.",
          "2177:                 pattern: ^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
          "2178:                 x-kubernetes-int-or-string: true",
          "2179:               volumeGroupSnapshotName:",
          "2180:                 description: VolumeGroupSnapshotName is the name of the VolumeGroupSnapshot",
          "2181:                   of which this VolumeSnapshot is a part of.",
          "2182:                 type: string",
          "2183:             type: object",
          "2184:         required:",
          "2185:         - spec",
          "2186:         type: object",
          "2187:     served: true",
          "2188:     storage: true",
          "2189:     subresources:",
          "2190:       status: {}",
          "2191:   - additionalPrinterColumns:",
          "2192:     - description: Indicates if the snapshot is ready to be used to restore a volume.",
          "2193:       jsonPath: .status.readyToUse",
          "2194:       name: ReadyToUse",
          "2195:       type: boolean",
          "2196:     - description: If a new snapshot needs to be created, this contains the name of the source PVC from which this snapshot was (or will be) created.",
          "2197:       jsonPath: .spec.source.persistentVolumeClaimName",
          "2198:       name: SourcePVC",
          "2199:       type: string",
          "2200:     - description: If a snapshot already exists, this contains the name of the existing VolumeSnapshotContent object representing the existing snapshot.",
          "2201:       jsonPath: .spec.source.volumeSnapshotContentName",
          "2202:       name: SourceSnapshotContent",
          "2203:       type: string",
          "2204:     - description: Represents the minimum size of volume required to rehydrate from this snapshot.",
          "2205:       jsonPath: .status.restoreSize",
          "2206:       name: RestoreSize",
          "2207:       type: string",
          "2208:     - description: The name of the VolumeSnapshotClass requested by the VolumeSnapshot.",
          "2209:       jsonPath: .spec.volumeSnapshotClassName",
          "2210:       name: SnapshotClass",
          "2211:       type: string",
          "2212:     - description: Name of the VolumeSnapshotContent object to which the VolumeSnapshot object intends to bind to. Please note that verification of binding actually requires checking both VolumeSnapshot and VolumeSnapshotContent to ensure both are pointing at each other. Binding MUST be verified prior to usage of this object.",
          "2213:       jsonPath: .status.boundVolumeSnapshotContentName",
          "2214:       name: SnapshotContent",
          "2215:       type: string",
          "2216:     - description: Timestamp when the point-in-time snapshot was taken by the underlying storage system.",
          "2217:       jsonPath: .status.creationTime",
          "2218:       name: CreationTime",
          "2219:       type: date",
          "2220:     - jsonPath: .metadata.creationTimestamp",
          "2221:       name: Age",
          "2222:       type: date",
          "2223:     name: v1beta1",
          "2224:     # This indicates the v1beta1 version of the custom resource is deprecated.",
          "2225:     # API requests to this version receive a warning in the server response.",
          "2226:     deprecated: true",
          "2227:     # This overrides the default warning returned to clients making v1beta1 API requests.",
          "2228:     deprecationWarning: \"snapshot.storage.k8s.io/v1beta1 VolumeSnapshot is deprecated; use snapshot.storage.k8s.io/v1 VolumeSnapshot\"",
          "2229:     schema:",
          "2230:       openAPIV3Schema:",
          "2231:         description: VolumeSnapshot is a user's request for either creating a point-in-time snapshot of a persistent volume, or binding to a pre-existing snapshot.",
          "2232:         properties:",
          "2233:           apiVersion:",
          "2234:             description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'",
          "2235:             type: string",
          "2236:           kind:",
          "2237:             description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'",
          "2238:             type: string",
          "2239:           spec:",
          "2240:             description: 'spec defines the desired characteristics of a snapshot requested by a user. More info: https://kubernetes.io/docs/concepts/storage/volume-snapshots#volumesnapshots Required.'",
          "2241:             properties:",
          "2242:               source:",
          "2243:                 description: source specifies where a snapshot will be created from. This field is immutable after creation. Required.",
          "2244:                 properties:",
          "2245:                   persistentVolumeClaimName:",
          "2246:                     description: persistentVolumeClaimName specifies the name of the PersistentVolumeClaim object representing the volume from which a snapshot should be created. This PVC is assumed to be in the same namespace as the VolumeSnapshot object. This field should be set if the snapshot does not exists, and needs to be created. This field is immutable.",
          "2247:                     type: string",
          "2248:                   volumeSnapshotContentName:",
          "2249:                     description: volumeSnapshotContentName specifies the name of a pre-existing VolumeSnapshotContent object representing an existing volume snapshot. This field should be set if the snapshot already exists and only needs a representation in Kubernetes. This field is immutable.",
          "2250:                     type: string",
          "2251:                 type: object",
          "2252:               volumeSnapshotClassName:",
          "2253:                 description: 'VolumeSnapshotClassName is the name of the VolumeSnapshotClass requested by the VolumeSnapshot. VolumeSnapshotClassName may be left nil to indicate that the default SnapshotClass should be used. A given cluster may have multiple default Volume SnapshotClasses: one default per CSI Driver. If a VolumeSnapshot does not specify a SnapshotClass, VolumeSnapshotSource will be checked to figure out what the associated CSI Driver is, and the default VolumeSnapshotClass associated with that CSI Driver will be used. If more than one VolumeSnapshotClass exist for a given CSI Driver and more than one have been marked as default, CreateSnapshot will fail and generate an event. Empty string is not allowed for this field.'",
          "2254:                 type: string",
          "2255:             required:",
          "2256:             - source",
          "2257:             type: object",
          "2258:           status:",
          "2259:             description: status represents the current information of a snapshot. Consumers must verify binding between VolumeSnapshot and VolumeSnapshotContent objects is successful (by validating that both VolumeSnapshot and VolumeSnapshotContent point at each other) before using this object.",
          "2260:             properties:",
          "2261:               boundVolumeSnapshotContentName:",
          "2262:                 description: 'boundVolumeSnapshotContentName is the name of the VolumeSnapshotContent object to which this VolumeSnapshot object intends to bind to. If not specified, it indicates that the VolumeSnapshot object has not been successfully bound to a VolumeSnapshotContent object yet. NOTE: To avoid possible security issues, consumers must verify binding between VolumeSnapshot and VolumeSnapshotContent objects is successful (by validating that both VolumeSnapshot and VolumeSnapshotContent point at each other) before using this object.'",
          "2263:                 type: string",
          "2264:               creationTime:",
          "2265:                 description: creationTime is the timestamp when the point-in-time snapshot is taken by the underlying storage system. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"creation_time\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"creation_time\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. If not specified, it may indicate that the creation time of the snapshot is unknown.",
          "2266:                 format: date-time",
          "2267:                 type: string",
          "2268:               error:",
          "2269:                 description: error is the last observed error during snapshot creation, if any. This field could be helpful to upper level controllers(i.e., application controller) to decide whether they should continue on waiting for the snapshot to be created based on the type of error reported. The snapshot controller will keep retrying when an error occurs during the snapshot creation. Upon success, this error field will be cleared.",
          "2270:                 properties:",
          "2271:                   message:",
          "2272:                     description: 'message is a string detailing the encountered error during snapshot creation if specified. NOTE: message may be logged, and it should not contain sensitive information.'",
          "2273:                     type: string",
          "2274:                   time:",
          "2275:                     description: time is the timestamp when the error was encountered.",
          "2276:                     format: date-time",
          "2277:                     type: string",
          "2278:                 type: object",
          "2279:               readyToUse:",
          "2280:                 description: readyToUse indicates if the snapshot is ready to be used to restore a volume. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"ready_to_use\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"ready_to_use\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it, otherwise, this field will be set to \"True\". If not specified, it means the readiness of a snapshot is unknown.",
          "2281:                 type: boolean",
          "2282:               restoreSize:",
          "2283:                 type: string",
          "2284:                 description: restoreSize represents the minimum size of volume required to create a volume from this snapshot. In dynamic snapshot creation case, this field will be filled in by the snapshot controller with the \"size_bytes\" value returned from CSI \"CreateSnapshot\" gRPC call. For a pre-existing snapshot, this field will be filled with the \"size_bytes\" value returned from the CSI \"ListSnapshots\" gRPC call if the driver supports it. When restoring a volume from this snapshot, the size of the volume MUST NOT be smaller than the restoreSize if it is specified, otherwise the restoration will fail. If not specified, it indicates that the size is unknown.",
          "2285:                 pattern: ^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$",
          "2286:                 x-kubernetes-int-or-string: true",
          "2287:             type: object",
          "2288:         required:",
          "2289:         - spec",
          "2290:         type: object",
          "2291:     served: false",
          "2292:     storage: false",
          "2293:     subresources:",
          "2294:       status: {}",
          "2295: status:",
          "2296:   acceptedNames:",
          "2297:     kind: \"\"",
          "2298:     plural: \"\"",
          "2299:   conditions: []",
          "2300:   storedVersions: []",
          "2303: func deployTenantBaseSnapshotStorageK8sIo_volumesnapshotsYamlBytes() ([]byte, error) {",
          "2304:  return _deployTenantBaseSnapshotStorageK8sIo_volumesnapshotsYaml, nil",
          "2307: func deployTenantBaseSnapshotStorageK8sIo_volumesnapshotsYaml() (*asset, error) {",
          "2308:  bytes, err := deployTenantBaseSnapshotStorageK8sIo_volumesnapshotsYamlBytes()",
          "2313:  info := bindataFileInfo{name: \"deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshots.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "2318: var _deployTenantDevOverlayInfraNamespaceConfigmapYaml = []byte(`apiVersion: v1",
          "2319: kind: ConfigMap",
          "2321:   name: driver-config",
          "2322:   namespace: kubevirt-csi-driver",
          "2323: data:",
          "2324:   infraClusterNamespace: kvcluster",
          "2325:   infraClusterLabels: csi-driver/cluster=tenant",
          "2328: func deployTenantDevOverlayInfraNamespaceConfigmapYamlBytes() ([]byte, error) {",
          "2329:  return _deployTenantDevOverlayInfraNamespaceConfigmapYaml, nil",
          "2332: func deployTenantDevOverlayInfraNamespaceConfigmapYaml() (*asset, error) {",
          "2333:  bytes, err := deployTenantDevOverlayInfraNamespaceConfigmapYamlBytes()",
          "2338:  info := bindataFileInfo{name: \"deploy/tenant/dev-overlay/infra-namespace-configmap.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "2343: var _deployTenantDevOverlayKustomizationYaml = []byte(`resources:",
          "2344: - ../base",
          "2345: namespace: kubevirt-csi-driver",
          "2346: patches:",
          "2347: - path: infra-namespace-configmap.yaml",
          "2348: - path: node.yaml",
          "2349: - path: storageclass.yaml",
          "2352: func deployTenantDevOverlayKustomizationYamlBytes() ([]byte, error) {",
          "2353:  return _deployTenantDevOverlayKustomizationYaml, nil",
          "2356: func deployTenantDevOverlayKustomizationYaml() (*asset, error) {",
          "2357:  bytes, err := deployTenantDevOverlayKustomizationYamlBytes()",
          "2362:  info := bindataFileInfo{name: \"deploy/tenant/dev-overlay/kustomization.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "2367: var _deployTenantDevOverlayNodeYaml = []byte(`kind: DaemonSet",
          "2368: apiVersion: apps/v1",
          "2370:   name: kubevirt-csi-node",
          "2371:   namespace: kubevirt-csi-driver",
          "2372: spec:",
          "2373:   template:",
          "2374:     spec:",
          "2375:       containers:",
          "2376:         - name: csi-driver",
          "2377:           image: 192.168.66.2:5000/kubevirt-csi-driver:latest",
          "2378: `)",
          "2380: func deployTenantDevOverlayNodeYamlBytes() ([]byte, error) {",
          "2381:  return _deployTenantDevOverlayNodeYaml, nil",
          "2384: func deployTenantDevOverlayNodeYaml() (*asset, error) {",
          "2385:  bytes, err := deployTenantDevOverlayNodeYamlBytes()",
          "2390:  info := bindataFileInfo{name: \"deploy/tenant/dev-overlay/node.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "2395: var _deployTenantDevOverlayStorageclassYaml = []byte(`apiVersion: storage.k8s.io/v1",
          "2396: kind: StorageClass",
          "2398:   name: kubevirt",
          "2399:   annotations:",
          "2400:     storageclass.kubernetes.io/is-default-class: \"true\"",
          "2401: provisioner: csi.kubevirt.io",
          "2402: parameters:",
          "2403:   infraStorageClassName: rook-ceph-block",
          "2404:   bus: scsi",
          "2405: `)",
          "2407: func deployTenantDevOverlayStorageclassYamlBytes() ([]byte, error) {",
          "2408:  return _deployTenantDevOverlayStorageclassYaml, nil",
          "2411: func deployTenantDevOverlayStorageclassYaml() (*asset, error) {",
          "2412:  bytes, err := deployTenantDevOverlayStorageclassYamlBytes()",
          "2417:  info := bindataFileInfo{name: \"deploy/tenant/dev-overlay/storageclass.yaml\", size: 0, mode: os.FileMode(0), modTime: time.Unix(0, 0)}",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "907: var _bindata = map[string]func() (*asset, error){",
          "922: }",
          "",
          "[Removed Lines]",
          "908:  \"deploy/000-csi-driver.yaml\":                  deploy000CsiDriverYaml,",
          "909:  \"deploy/000-namespace.yaml\":                   deploy000NamespaceYaml,",
          "910:  \"deploy/020-autorization.yaml\":                deploy020AutorizationYaml,",
          "911:  \"deploy/030-node.yaml\":                        deploy030NodeYaml,",
          "912:  \"deploy/040-controller.yaml\":                  deploy040ControllerYaml,",
          "913:  \"deploy/configmap.yaml\":                       deployConfigmapYaml,",
          "914:  \"deploy/example/infracluster-kubeconfig.yaml\": deployExampleInfraclusterKubeconfigYaml,",
          "915:  \"deploy/example/kubevirt-config.yaml\":         deployExampleKubevirtConfigYaml,",
          "916:  \"deploy/example/kubevirt.yaml\":                deployExampleKubevirtYaml,",
          "917:  \"deploy/example/storage-claim.yaml\":           deployExampleStorageClaimYaml,",
          "918:  \"deploy/example/storageclass.yaml\":            deployExampleStorageclassYaml,",
          "919:  \"deploy/example/test-pod.yaml\":                deployExampleTestPodYaml,",
          "920:  \"deploy/infra-cluster-service-account.yaml\":   deployInfraClusterServiceAccountYaml,",
          "921:  \"deploy/secret.yaml\":                          deploySecretYaml,",
          "",
          "[Added Lines]",
          "2474:  \"deploy/controller-infra/base/deploy.yaml\":                               deployControllerInfraBaseDeployYaml,",
          "2475:  \"deploy/controller-infra/base/kustomization.yaml\":                        deployControllerInfraBaseKustomizationYaml,",
          "2476:  \"deploy/controller-infra/dev-overlay/controller.yaml\":                    deployControllerInfraDevOverlayControllerYaml,",
          "2477:  \"deploy/controller-infra/dev-overlay/infra-namespace-configmap.yaml\":     deployControllerInfraDevOverlayInfraNamespaceConfigmapYaml,",
          "2478:  \"deploy/controller-infra/dev-overlay/kustomization.yaml\":                 deployControllerInfraDevOverlayKustomizationYaml,",
          "2479:  \"deploy/controller-tenant/base/deploy.yaml\":                              deployControllerTenantBaseDeployYaml,",
          "2480:  \"deploy/controller-tenant/base/kustomization.yaml\":                       deployControllerTenantBaseKustomizationYaml,",
          "2481:  \"deploy/controller-tenant/dev-overlay/controller.yaml\":                   deployControllerTenantDevOverlayControllerYaml,",
          "2482:  \"deploy/controller-tenant/dev-overlay/kustomization.yaml\":                deployControllerTenantDevOverlayKustomizationYaml,",
          "2483:  \"deploy/example/infracluster-kubeconfig.yaml\":                            deployExampleInfraclusterKubeconfigYaml,",
          "2484:  \"deploy/example/kubevirt-config.yaml\":                                    deployExampleKubevirtConfigYaml,",
          "2485:  \"deploy/example/kubevirt.yaml\":                                           deployExampleKubevirtYaml,",
          "2486:  \"deploy/example/storage-claim.yaml\":                                      deployExampleStorageClaimYaml,",
          "2487:  \"deploy/example/storageclass.yaml\":                                       deployExampleStorageclassYaml,",
          "2488:  \"deploy/example/test-pod.yaml\":                                           deployExampleTestPodYaml,",
          "2489:  \"deploy/infra-cluster-service-account.yaml\":                              deployInfraClusterServiceAccountYaml,",
          "2490:  \"deploy/tenant/base/deploy.yaml\":                                         deployTenantBaseDeployYaml,",
          "2491:  \"deploy/tenant/base/kustomization.yaml\":                                  deployTenantBaseKustomizationYaml,",
          "2492:  \"deploy/tenant/base/rbac-snapshot-controller.yaml\":                       deployTenantBaseRbacSnapshotControllerYaml,",
          "2493:  \"deploy/tenant/base/setup-snapshot-controller.yaml\":                      deployTenantBaseSetupSnapshotControllerYaml,",
          "2494:  \"deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshotclasses.yaml\":  deployTenantBaseSnapshotStorageK8sIo_volumesnapshotclassesYaml,",
          "2495:  \"deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshotcontents.yaml\": deployTenantBaseSnapshotStorageK8sIo_volumesnapshotcontentsYaml,",
          "2496:  \"deploy/tenant/base/snapshot.storage.k8s.io_volumesnapshots.yaml\":        deployTenantBaseSnapshotStorageK8sIo_volumesnapshotsYaml,",
          "2497:  \"deploy/tenant/dev-overlay/infra-namespace-configmap.yaml\":               deployTenantDevOverlayInfraNamespaceConfigmapYaml,",
          "2498:  \"deploy/tenant/dev-overlay/kustomization.yaml\":                           deployTenantDevOverlayKustomizationYaml,",
          "2499:  \"deploy/tenant/dev-overlay/node.yaml\":                                    deployTenantDevOverlayNodeYaml,",
          "2500:  \"deploy/tenant/dev-overlay/storageclass.yaml\":                            deployTenantDevOverlayStorageclassYaml,",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "964: var _bintree = &bintree{nil, map[string]*bintree{",
          "965:  \"deploy\": {nil, map[string]*bintree{",
          "972:   \"example\": {nil, map[string]*bintree{",
          "973:    \"infracluster-kubeconfig.yaml\": {deployExampleInfraclusterKubeconfigYaml, map[string]*bintree{}},",
          "974:    \"kubevirt-config.yaml\":         {deployExampleKubevirtConfigYaml, map[string]*bintree{}},",
          "",
          "[Removed Lines]",
          "966:   \"000-csi-driver.yaml\":   {deploy000CsiDriverYaml, map[string]*bintree{}},",
          "967:   \"000-namespace.yaml\":    {deploy000NamespaceYaml, map[string]*bintree{}},",
          "968:   \"020-autorization.yaml\": {deploy020AutorizationYaml, map[string]*bintree{}},",
          "969:   \"030-node.yaml\":         {deploy030NodeYaml, map[string]*bintree{}},",
          "970:   \"040-controller.yaml\":   {deploy040ControllerYaml, map[string]*bintree{}},",
          "971:   \"configmap.yaml\":        {deployConfigmapYaml, map[string]*bintree{}},",
          "",
          "[Added Lines]",
          "2547:   \"controller-infra\": {nil, map[string]*bintree{",
          "2548:    \"base\": {nil, map[string]*bintree{",
          "2549:     \"deploy.yaml\":        {deployControllerInfraBaseDeployYaml, map[string]*bintree{}},",
          "2550:     \"kustomization.yaml\": {deployControllerInfraBaseKustomizationYaml, map[string]*bintree{}},",
          "2551:    }},",
          "2552:    \"dev-overlay\": {nil, map[string]*bintree{",
          "2553:     \"controller.yaml\":                {deployControllerInfraDevOverlayControllerYaml, map[string]*bintree{}},",
          "2554:     \"infra-namespace-configmap.yaml\": {deployControllerInfraDevOverlayInfraNamespaceConfigmapYaml, map[string]*bintree{}},",
          "2555:     \"kustomization.yaml\":             {deployControllerInfraDevOverlayKustomizationYaml, map[string]*bintree{}},",
          "2556:    }},",
          "2557:   }},",
          "2558:   \"controller-tenant\": {nil, map[string]*bintree{",
          "2559:    \"base\": {nil, map[string]*bintree{",
          "2560:     \"deploy.yaml\":        {deployControllerTenantBaseDeployYaml, map[string]*bintree{}},",
          "2561:     \"kustomization.yaml\": {deployControllerTenantBaseKustomizationYaml, map[string]*bintree{}},",
          "2562:    }},",
          "2563:    \"dev-overlay\": {nil, map[string]*bintree{",
          "2564:     \"controller.yaml\":    {deployControllerTenantDevOverlayControllerYaml, map[string]*bintree{}},",
          "2565:     \"kustomization.yaml\": {deployControllerTenantDevOverlayKustomizationYaml, map[string]*bintree{}},",
          "2566:    }},",
          "2567:   }},",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "978:    \"test-pod.yaml\":                {deployExampleTestPodYaml, map[string]*bintree{}},",
          "979:   }},",
          "980:   \"infra-cluster-service-account.yaml\": {deployInfraClusterServiceAccountYaml, map[string]*bintree{}},",
          "982:  }},",
          "983: }}",
          "",
          "[Removed Lines]",
          "981:   \"secret.yaml\":                        {deploySecretYaml, map[string]*bintree{}},",
          "",
          "[Added Lines]",
          "2577:   \"tenant\": {nil, map[string]*bintree{",
          "2578:    \"base\": {nil, map[string]*bintree{",
          "2579:     \"deploy.yaml\":                                         {deployTenantBaseDeployYaml, map[string]*bintree{}},",
          "2580:     \"kustomization.yaml\":                                  {deployTenantBaseKustomizationYaml, map[string]*bintree{}},",
          "2581:     \"rbac-snapshot-controller.yaml\":                       {deployTenantBaseRbacSnapshotControllerYaml, map[string]*bintree{}},",
          "2582:     \"setup-snapshot-controller.yaml\":                      {deployTenantBaseSetupSnapshotControllerYaml, map[string]*bintree{}},",
          "2583:     \"snapshot.storage.k8s.io_volumesnapshotclasses.yaml\":  {deployTenantBaseSnapshotStorageK8sIo_volumesnapshotclassesYaml, map[string]*bintree{}},",
          "2584:     \"snapshot.storage.k8s.io_volumesnapshotcontents.yaml\": {deployTenantBaseSnapshotStorageK8sIo_volumesnapshotcontentsYaml, map[string]*bintree{}},",
          "2585:     \"snapshot.storage.k8s.io_volumesnapshots.yaml\":        {deployTenantBaseSnapshotStorageK8sIo_volumesnapshotsYaml, map[string]*bintree{}},",
          "2586:    }},",
          "2587:    \"dev-overlay\": {nil, map[string]*bintree{",
          "2588:     \"infra-namespace-configmap.yaml\": {deployTenantDevOverlayInfraNamespaceConfigmapYaml, map[string]*bintree{}},",
          "2589:     \"kustomization.yaml\":             {deployTenantDevOverlayKustomizationYaml, map[string]*bintree{}},",
          "2590:     \"node.yaml\":                      {deployTenantDevOverlayNodeYaml, map[string]*bintree{}},",
          "2591:     \"storageclass.yaml\":              {deployTenantDevOverlayStorageclassYaml, map[string]*bintree{}},",
          "2592:    }},",
          "2593:   }},",
          "",
          "---------------"
        ],
        "pkg/kubevirt/client.go||pkg/kubevirt/client.go": [
          "File: pkg/kubevirt/client.go -> pkg/kubevirt/client.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: )",
          "29: const (",
          "32: )",
          "",
          "[Removed Lines]",
          "30:  vmiSubresourceURL       = \"/apis/subresources.kubevirt.io/%s/namespaces/%s/virtualmachineinstances/%s/%s\"",
          "31:  annDefaultSnapshotClass = \"snapshot.storage.kubernetes.io/is-default-class\"",
          "",
          "[Added Lines]",
          "30:  vmiSubresourceURL               = \"/apis/subresources.kubevirt.io/%s/namespaces/%s/virtualmachineinstances/%s/%s\"",
          "31:  annDefaultSnapshotClass         = \"snapshot.storage.kubernetes.io/is-default-class\"",
          "32:  InfraStorageClassNameParameter  = \"infraStorageClassName\"",
          "33:  InfraSnapshotClassNameParameter = \"infraSnapshotClassName\"",
          "36: type InfraTenantStorageSnapshotMapping struct {",
          "37:  VolumeSnapshotClasses []InfraToTenantMapping",
          "38:  StorageClasses        []string",
          "39: }",
          "41: type InfraToTenantMapping struct {",
          "42:  Infra  string",
          "43:  Tenant string",
          "44: }",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "56: }",
          "58: type client struct {",
          "67: }",
          "71:  result := &client{}",
          "73:  Scheme := runtime.NewScheme()",
          "74:  Codecs := serializer.NewCodecFactory(Scheme)",
          "77:  shallowCopy.GroupVersion = &kubevirtv1.StorageGroupVersion",
          "78:  shallowCopy.NegotiatedSerializer = serializer.WithoutConversionCodecFactory{CodecFactory: Codecs}",
          "79:  shallowCopy.APIPath = \"/apis\"",
          "80:  shallowCopy.ContentType = runtime.ContentTypeJSON",
          "83:  }",
          "85:  restClient, err := rest.RESTClientFor(&shallowCopy)",
          "",
          "[Removed Lines]",
          "59:  kubernetesClient        kubernetes.Interface",
          "60:  virtClient              kubecli.Interface",
          "61:  cdiClient               cdicli.Interface",
          "62:  snapClient              snapcli.Interface",
          "63:  restClient              *rest.RESTClient",
          "64:  storageClassEnforcement util.StorageClassEnforcement",
          "65:  infraLabelMap           map[string]string",
          "66:  volumePrefix            string",
          "70: func NewClient(config *rest.Config, infraClusterLabelMap map[string]string, storageClassEnforcement util.StorageClassEnforcement, prefix string) (Client, error) {",
          "76:  shallowCopy := *config",
          "81:  if config.UserAgent == \"\" {",
          "82:   config.UserAgent = rest.DefaultKubernetesUserAgent()",
          "",
          "[Added Lines]",
          "71:  infraKubernetesClient             kubernetes.Interface",
          "72:  tenantKubernetesClient            kubernetes.Interface",
          "73:  virtClient                        kubecli.Interface",
          "74:  cdiClient                         cdicli.Interface",
          "75:  infraSnapClient                   snapcli.Interface",
          "76:  restClient                        *rest.RESTClient",
          "77:  storageClassEnforcement           util.StorageClassEnforcement",
          "78:  infraLabelMap                     map[string]string",
          "79:  volumePrefix                      string",
          "80:  infraTenantStorageSnapshotMapping []InfraTenantStorageSnapshotMapping",
          "84: func NewClient(infraConfig *rest.Config, infraClusterLabelMap map[string]string, tenantKubernetesClient kubernetes.Interface, tenantSnapshotClient snapcli.Interface, storageClassEnforcement util.StorageClassEnforcement, prefix string) (Client, error) {",
          "90:  shallowCopy := *infraConfig",
          "95:  if infraConfig.UserAgent == \"\" {",
          "96:   infraConfig.UserAgent = rest.DefaultKubernetesUserAgent()",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "87:   return nil, err",
          "88:  }",
          "91:  if err != nil {",
          "92:   return nil, err",
          "93:  }",
          "96:  if err != nil {",
          "97:   return nil, err",
          "98:  }",
          "100:  if err != nil {",
          "101:   return nil, err",
          "102:  }",
          "104:  if err != nil {",
          "105:   return nil, err",
          "106:  }",
          "",
          "[Removed Lines]",
          "90:  clientset, err := kubernetes.NewForConfig(config)",
          "94:  result.kubernetesClient = clientset",
          "95:  kubevirtClient, err := kubecli.NewForConfig(config)",
          "99:  cdiClient, err := cdicli.NewForConfig(config)",
          "103:  snapClient, err := snapcli.NewForConfig(config)",
          "",
          "[Added Lines]",
          "104:  clientset, err := kubernetes.NewForConfig(infraConfig)",
          "108:  result.infraKubernetesClient = clientset",
          "109:  kubevirtClient, err := kubecli.NewForConfig(infraConfig)",
          "113:  cdiClient, err := cdicli.NewForConfig(infraConfig)",
          "117:  snapClient, err := snapcli.NewForConfig(infraConfig)",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "108:  result.virtClient = kubevirtClient",
          "109:  result.cdiClient = cdiClient",
          "110:  result.restClient = restClient",
          "112:  result.infraLabelMap = infraClusterLabelMap",
          "113:  result.volumePrefix = fmt.Sprintf(\"%s-\", prefix)",
          "114:  result.storageClassEnforcement = storageClassEnforcement",
          "115:  return result, nil",
          "116: }",
          "",
          "[Removed Lines]",
          "111:  result.snapClient = snapClient",
          "",
          "[Added Lines]",
          "125:  result.infraSnapClient = snapClient",
          "129:  result.tenantKubernetesClient = tenantKubernetesClient",
          "130:  storageSnapshotMapping, err := result.buildStorageClassSnapshotClassMapping(tenantKubernetesClient, tenantSnapshotClient, storageClassEnforcement.StorageSnapshotMapping)",
          "131:  if err != nil {",
          "132:   return nil, err",
          "133:  }",
          "134:  result.infraTenantStorageSnapshotMapping = storageSnapshotMapping",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "225: func (c *client) Ping(ctx context.Context) error {",
          "227:  return err",
          "228: }",
          "",
          "[Removed Lines]",
          "226:  _, err := c.kubernetesClient.Discovery().ServerVersion()",
          "",
          "[Added Lines]",
          "246:  _, err := c.infraKubernetesClient.Discovery().ServerVersion()",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "255: func (c *client) CreateVolumeSnapshot(ctx context.Context, namespace, name, claimName, snapshotClassName string) (*snapshotv1.VolumeSnapshot, error) {",
          "256:  if dv, err := c.GetDataVolume(ctx, namespace, claimName); err != nil {",
          "257:   return nil, err",
          "260:   if err != nil {",
          "261:    return nil, err",
          "262:   }",
          "",
          "[Removed Lines]",
          "258:  } else if dv != nil {",
          "259:   snapshotClassName, err := c.getSnapshotClassNameFromVolumeClaimName(ctx, namespace, dv.GetName(), snapshotClassName)",
          "",
          "[Added Lines]",
          "278:  } else {",
          "279:   snapshotClassNameFromStorage, err := c.getSnapshotClassNameFromVolumeClaimName(ctx, namespace, dv.GetName(), snapshotClassName)",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "270:     Source: snapshotv1.VolumeSnapshotSource{",
          "271:      PersistentVolumeClaimName: &claimName,",
          "272:     },",
          "274:    },",
          "275:   }",
          "278:  }",
          "280: }",
          "282: func (c *client) getSnapshotClassNameFromVolumeClaimName(ctx context.Context, namespace, claimName, snapshotClassName string) (string, error) {",
          "283:  storageClassName, err := c.getStorageClassNameFromClaimName(ctx, namespace, claimName)",
          "284:  if err != nil {",
          "285:   klog.V(2).Infof(\"Error getting storage class name for claim %s in namespace %s: %v\", claimName, namespace, err)",
          "301:  }",
          "303: }",
          "315:     }",
          "316:    }",
          "320:    }",
          "323:   }",
          "324:  }",
          "326: }",
          "329: func (c *client) getStorageClassNameFromClaimName(ctx context.Context, namespace, claimName string) (string, error) {",
          "331:  if err != nil {",
          "332:   klog.Errorf(\"Error getting volume claim %s in namespace %s: %v\", claimName, namespace, err)",
          "333:   return \"\", err",
          "",
          "[Removed Lines]",
          "273:     VolumeSnapshotClassName: &snapshotClassName,",
          "276:   klog.V(5).Infof(\"Creating snapshot %s with snapshot class %s, %#v\", name, snapshotClassName, snapshot)",
          "277:   return c.snapClient.SnapshotV1().VolumeSnapshots(namespace).Create(ctx, snapshot, metav1.CreateOptions{})",
          "279:  return nil, nil",
          "286:   return \"\", fmt.Errorf(\"unable to determine snapshot class name for infra source volume\")",
          "287:  }",
          "288:  if storageClassName == \"\" {",
          "289:   return \"\", fmt.Errorf(\"unable to determine storage class name for snapshot creation\")",
          "290:  }",
          "291:  allowed, err := c.isStorageClassAllowed(ctx, storageClassName)",
          "292:  if err != nil {",
          "293:   return \"\", err",
          "294:  }",
          "295:  if !allowed {",
          "296:   return \"\", fmt.Errorf(\"storage class %s is not allowed for snapshot creation\", storageClassName)",
          "297:  }",
          "298:  snapshotClass, err := c.getSnapshotClassFromStorageClass(ctx, storageClassName, snapshotClassName)",
          "299:  if err != nil {",
          "300:   return \"\", err",
          "302:  return snapshotClass.Name, nil",
          "305: func (c *client) isStorageClassAllowed(ctx context.Context, storageClassName string) (bool, error) {",
          "306:  if !c.storageClassEnforcement.AllowAll && !util.Contains(c.storageClassEnforcement.AllowList, storageClassName) {",
          "307:   if c.storageClassEnforcement.AllowDefault {",
          "309:    storageClass, err := c.kubernetesClient.StorageV1().StorageClasses().Get(ctx, storageClassName, metav1.GetOptions{})",
          "310:    if err != nil {",
          "311:     if errors.IsNotFound(err) {",
          "312:      return false, nil",
          "313:     } else {",
          "314:      return false, err",
          "317:    ann := storageClass.GetAnnotations()",
          "318:    if v, ok := ann[\"storageclass.kubernetes.io/is-default-class\"]; !ok || v != \"true\" {",
          "319:     return false, nil",
          "321:   } else {",
          "322:    return false, nil",
          "325:  return true, nil",
          "330:  volumeClaim, err := c.kubernetesClient.CoreV1().PersistentVolumeClaims(namespace).Get(ctx, claimName, metav1.GetOptions{})",
          "",
          "[Added Lines]",
          "297:   if snapshotClassNameFromStorage != \"\" {",
          "298:    snapshot.Spec.VolumeSnapshotClassName = &snapshotClassNameFromStorage",
          "299:   }",
          "300:   klog.V(5).Infof(\"Creating snapshot %s with snapshot class [%s], %#v\", name, snapshotClassName, snapshot)",
          "301:   return c.infraSnapClient.SnapshotV1().VolumeSnapshots(namespace).Create(ctx, snapshot, metav1.CreateOptions{})",
          "309:   return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for infra source volume\")",
          "310:  }",
          "311:  if storageClassName == \"\" && !c.storageClassEnforcement.AllowDefault {",
          "312:   return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, and default not allowed\")",
          "313:  } else if storageClassName != \"\" && !(util.Contains(c.storageClassEnforcement.AllowList, storageClassName) || c.storageClassEnforcement.AllowAll) {",
          "314:   return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, no valid snapshot classes found\")",
          "315:  }",
          "316:  snapshotClassNames := c.getInfraSnapshotClassesFromInfraStorageClassName(storageClassName)",
          "317:  if util.Contains(snapshotClassNames, snapshotClassName) {",
          "318:   return snapshotClassName, nil",
          "319:  }",
          "320:  if !(c.storageClassEnforcement.AllowAll || c.storageClassEnforcement.AllowDefault) {",
          "321:   tenantSnapshotClasses := c.getTenantSnapshotClassesFromInfraStorageClassName(storageClassName)",
          "322:   if len(tenantSnapshotClasses) > 0 {",
          "323:    if snapshotClassName == \"\" {",
          "324:     return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, valid snapshot classes are %v\", tenantSnapshotClasses)",
          "325:    } else {",
          "326:     return \"\", fmt.Errorf(\"volume snapshot class %s is not compatible with PVC with storage class %s, valid snapshot classes for this pvc are %v\", snapshotClassName, storageClassName, tenantSnapshotClasses)",
          "327:    }",
          "328:   } else {",
          "329:    return \"\", fmt.Errorf(\"unable to determine volume snapshot class name for snapshot creation, no valid snapshot classes found\")",
          "330:   }",
          "332:  return \"\", nil",
          "335: func (c *client) getInfraSnapshotClassesFromInfraStorageClassName(storageClassName string) []string {",
          "336:  for _, storageSnapshotMapping := range c.infraTenantStorageSnapshotMapping {",
          "337:   for _, storageClass := range storageSnapshotMapping.StorageClasses {",
          "338:    if storageClassName == storageClass {",
          "339:     infraSnapshotClasses := []string{}",
          "340:     for _, snapshotClasses := range storageSnapshotMapping.VolumeSnapshotClasses {",
          "341:      infraSnapshotClasses = append(infraSnapshotClasses, snapshotClasses.Infra)",
          "343:     return infraSnapshotClasses",
          "345:   }",
          "346:  }",
          "347:  return nil",
          "348: }",
          "350: func (c *client) getTenantSnapshotClassesFromInfraStorageClassName(storageClassName string) []string {",
          "351:  for _, storageSnapshotMapping := range c.infraTenantStorageSnapshotMapping {",
          "352:   for _, storageClass := range storageSnapshotMapping.StorageClasses {",
          "353:    if storageClassName == storageClass {",
          "354:     tenantSnapshotClasses := []string{}",
          "355:     for _, snapshotClasses := range storageSnapshotMapping.VolumeSnapshotClasses {",
          "356:      tenantSnapshotClasses = append(tenantSnapshotClasses, snapshotClasses.Tenant)",
          "357:     }",
          "358:     return tenantSnapshotClasses",
          "362:  return nil",
          "367:  volumeClaim, err := c.infraKubernetesClient.CoreV1().PersistentVolumeClaims(namespace).Get(ctx, claimName, metav1.GetOptions{})",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "340:  return storageClassName, nil",
          "341: }",
          "391: func (c *client) GetVolumeSnapshot(ctx context.Context, namespace, name string) (*snapshotv1.VolumeSnapshot, error) {",
          "393:  if err != nil {",
          "394:   return nil, err",
          "395:  }",
          "",
          "[Removed Lines]",
          "348: func (c *client) getSnapshotClassFromStorageClass(ctx context.Context, storageClassName, volumeSnapshotClassName string) (*snapshotv1.VolumeSnapshotClass, error) {",
          "349:  storageClass, err := c.kubernetesClient.StorageV1().StorageClasses().Get(ctx, storageClassName, metav1.GetOptions{})",
          "350:  if err != nil {",
          "351:   klog.V(2).Infof(\"Error getting storage class %s: %v\", storageClassName, err)",
          "352:   return nil, err",
          "353:  }",
          "354:  provisioner := storageClass.Provisioner",
          "355:  snapshotClasses, err := c.snapClient.SnapshotV1().VolumeSnapshotClasses().List(ctx, metav1.ListOptions{})",
          "356:  if errors.IsNotFound(err) {",
          "357:   klog.V(5).Info(\"No snapshot classes found\")",
          "358:   return nil, nil",
          "359:  } else if err != nil {",
          "360:   klog.V(2).Infof(\"Error getting snapshot classes: %v\", err)",
          "361:   return nil, err",
          "362:  }",
          "363:  var storageClassSnapshotClasses []snapshotv1.VolumeSnapshotClass",
          "364:  for _, snapshotClass := range snapshotClasses.Items {",
          "365:   if snapshotClass.Driver == provisioner {",
          "366:    storageClassSnapshotClasses = append(storageClassSnapshotClasses, snapshotClass)",
          "367:   }",
          "368:  }",
          "370:  var bestMatch *snapshotv1.VolumeSnapshotClass",
          "371:  for i, snapshotClass := range storageClassSnapshotClasses {",
          "372:   klog.V(5).Infof(\"Checking snapshot class %#v\", snapshotClass)",
          "373:   if i == 0 {",
          "374:    bestMatch = &storageClassSnapshotClasses[i]",
          "375:   }",
          "376:   if snapshotClass.Name == volumeSnapshotClassName {",
          "377:    return &snapshotClass, nil",
          "378:   }",
          "379:   ann := snapshotClass.GetAnnotations()",
          "380:   if ann != nil && ann[annDefaultSnapshotClass] == \"true\" {",
          "381:    bestMatch = &storageClassSnapshotClasses[i]",
          "382:   }",
          "383:  }",
          "384:  if volumeSnapshotClassName != \"\" {",
          "385:   klog.V(2).Infof(\"provided volume snapshot class %s cannot be matched with storage class\", volumeSnapshotClassName)",
          "386:   return nil, fmt.Errorf(\"provided volume snapshot class cannot be matched with storage class\")",
          "387:  }",
          "388:  return bestMatch, nil",
          "389: }",
          "392:  s, err := c.snapClient.SnapshotV1().VolumeSnapshots(namespace).Get(ctx, name, metav1.GetOptions{})",
          "",
          "[Added Lines]",
          "381:  s, err := c.infraSnapClient.SnapshotV1().VolumeSnapshots(namespace).Get(ctx, name, metav1.GetOptions{})",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "409:  if err != nil {",
          "410:   return err",
          "411:  }",
          "413: }",
          "415: func (c *client) ListVolumeSnapshots(ctx context.Context, namespace string) (*snapshotv1.VolumeSnapshotList, error) {",
          "",
          "[Removed Lines]",
          "412:  return c.snapClient.SnapshotV1().VolumeSnapshots(s.GetNamespace()).Delete(ctx, s.GetName(), metav1.DeleteOptions{})",
          "",
          "[Added Lines]",
          "401:  return c.infraSnapClient.SnapshotV1().VolumeSnapshots(s.GetNamespace()).Delete(ctx, s.GetName(), metav1.DeleteOptions{})",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "417:  if err != nil {",
          "418:   return nil, err",
          "419:  }",
          "421:   LabelSelector: sl.String(),",
          "422:  })",
          "423: }",
          "425: var ErrInvalidSnapshot = goerrors.New(\"invalid snapshot name\")",
          "426: var ErrInvalidVolume = goerrors.New(\"invalid volume name\")",
          "",
          "[Removed Lines]",
          "420:  return c.snapClient.SnapshotV1().VolumeSnapshots(namespace).List(ctx, metav1.ListOptions{",
          "",
          "[Added Lines]",
          "409:  return c.infraSnapClient.SnapshotV1().VolumeSnapshots(namespace).List(ctx, metav1.ListOptions{",
          "414: func (c *client) buildStorageClassSnapshotClassMapping(k8sClient kubernetes.Interface, snapshotClient snapcli.Interface, infraStorageSnapMapping []util.StorageSnapshotMapping) ([]InfraTenantStorageSnapshotMapping, error) {",
          "415:  provisionerMapping := make([]InfraTenantStorageSnapshotMapping, len(infraStorageSnapMapping))",
          "417:  volumeSnapshotClassList, err := snapshotClient.SnapshotV1().VolumeSnapshotClasses().List(context.Background(), metav1.ListOptions{})",
          "418:  if err != nil {",
          "419:   return nil, err",
          "420:  }",
          "422:  for i, storageSnapshotMapping := range infraStorageSnapMapping {",
          "423:   mapping := &InfraTenantStorageSnapshotMapping{",
          "424:    StorageClasses: storageSnapshotMapping.StorageClasses,",
          "425:   }",
          "426:   mapping = appendVolumeSnapshotInfraTenantMapping(mapping, storageSnapshotMapping.VolumeSnapshotClasses, volumeSnapshotClassList.Items)",
          "427:   provisionerMapping[i] = *mapping",
          "428:  }",
          "430:  return provisionerMapping, nil",
          "431: }",
          "433: func appendVolumeSnapshotInfraTenantMapping(mapping *InfraTenantStorageSnapshotMapping, infraVolumeSnapshotClasses []string, tenantVolumeSnapshotClasses []snapshotv1.VolumeSnapshotClass) *InfraTenantStorageSnapshotMapping {",
          "434:  for _, infraVolumeSnapshotClass := range infraVolumeSnapshotClasses {",
          "435:   tenantVolumeSnapshotClassName := \"\"",
          "436:   for _, tenantVolumeSnapshotClass := range tenantVolumeSnapshotClasses {",
          "437:    if infraVolumeSnapshotClassName, ok := tenantVolumeSnapshotClass.Parameters[InfraSnapshotClassNameParameter]; !ok {",
          "438:     klog.V(4).Infof(\"volume snapshot class %s does not have infraSnapshotClassName parameter\", tenantVolumeSnapshotClass.Name)",
          "439:     continue",
          "440:    } else {",
          "441:     if infraVolumeSnapshotClassName == infraVolumeSnapshotClass {",
          "442:      tenantVolumeSnapshotClassName = tenantVolumeSnapshotClass.Name",
          "443:      break",
          "444:     }",
          "445:    }",
          "446:   }",
          "447:   mapping.VolumeSnapshotClasses = append(mapping.VolumeSnapshotClasses, InfraToTenantMapping{",
          "448:    Infra:  infraVolumeSnapshotClass,",
          "449:    Tenant: tenantVolumeSnapshotClassName,",
          "450:   })",
          "451:  }",
          "452:  return mapping",
          "453: }",
          "",
          "---------------"
        ],
        "pkg/kubevirt/client_test.go||pkg/kubevirt/client_test.go": [
          "File: pkg/kubevirt/client_test.go -> pkg/kubevirt/client_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "16:  \"k8s.io/utils/ptr\"",
          "17:  cdiv1 \"kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1\"",
          "18:  cdicli \"kubevirt.io/csi-driver/pkg/generated/containerized-data-importer/client-go/clientset/versioned/fake\"",
          "19:  snapfake \"kubevirt.io/csi-driver/pkg/generated/external-snapshotter/client-go/clientset/versioned/fake\"",
          "20:  \"kubevirt.io/csi-driver/pkg/util\"",
          "21: )",
          "23: const (",
          "41: )",
          "43: var _ = Describe(\"Client\", func() {",
          "",
          "[Removed Lines]",
          "24:  defaultStorageClassName      = \"default-storage-class\"",
          "25:  storageClassName             = \"test-storage-class\"",
          "26:  volumeSnapshotClassName      = \"test-volume-snapshot-class\"",
          "27:  provisioner                  = \"test-provisioner\"",
          "28:  nonMatchingProvisioner       = \"non-matching-provisioner-snapshot-class\"",
          "29:  otherprovisioner             = \"other-provisioner\"",
          "30:  otherVolumeSnapshotClassName = \"other-volume-snapshot-class\"",
          "31:  testVolumeName               = \"test-volume\"",
          "32:  testVolumeNameNotAllowed     = \"test-volume-not-allowed\"",
          "33:  validDataVolume              = \"pvc-valid-data-volume\"",
          "34:  nolabelDataVolume            = \"nolabel-data-volume\"",
          "35:  testClaimName                = \"pvc-valid-data-volume\"",
          "36:  testClaimName2               = \"pvc-valid-data-volume2\"",
          "37:  testClaimName3               = \"pvc-valid-data-volume3\"",
          "38:  testClaimName4               = \"pvc-default-storage-class\"",
          "39:  testNamespace                = \"test-namespace\"",
          "40:  unboundTestClaimName         = \"unbound-test-claim\"",
          "",
          "[Added Lines]",
          "19:  snapcli \"kubevirt.io/csi-driver/pkg/generated/external-snapshotter/client-go/clientset/versioned\"",
          "25:  defaultStorageClassName         = \"default-storage-class\"",
          "26:  tenantStorageClassName          = \"tenant-storage-class\"",
          "27:  storageClassName                = \"test-storage-class\"",
          "28:  tenantVolumeSnapshotClassName   = \"tenant-volume-snapshot-class\"",
          "29:  volumeSnapshotClassName         = \"test-volume-snapshot-class\"",
          "30:  provisioner                     = \"test-provisioner\"",
          "31:  nonMatchingProvisioner          = \"non-matching-provisioner-snapshot-class\"",
          "32:  otherprovisioner                = \"other-provisioner\"",
          "33:  otherVolumeSnapshotClassName    = \"other-volume-snapshot-class\"",
          "34:  testVolumeName                  = \"test-volume\"",
          "35:  testVolumeNameNotAllowed        = \"test-volume-not-allowed\"",
          "36:  validDataVolume                 = \"pvc-valid-data-volume\"",
          "37:  nolabelDataVolume               = \"nolabel-data-volume\"",
          "38:  testClaimName                   = \"pvc-valid-data-volume\"",
          "39:  testClaimName2                  = \"pvc-valid-data-volume2\"",
          "40:  testClaimNameNotAllowed         = \"pvc-valid-data-volume3\"",
          "41:  testClaimNameDefault            = \"pvc-default-storage-class\"",
          "42:  testNamespace                   = \"test-namespace\"",
          "43:  unboundTestClaimName            = \"unbound-test-claim\"",
          "44:  snapshotClassNotFoundNoDefault  = \"unable to determine volume snapshot class name for snapshot creation, and default not allowed\"",
          "45:  snapshotClassNotFound           = \"unable to determine volume snapshot class name for snapshot creation, no valid snapshot classes found\"",
          "46:  snapshotClassNotFoundSuggestion = \"volume snapshot class other-volume-snapshot-class is not compatible with PVC with storage class test-storage-class, valid snapshot classes for this pvc are [tenant-volume-snapshot-class]\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "108:    c = NewFakeClient()",
          "109:   })",
          "126:   It(\"storage class from claim should return a storage class name\", func() {",
          "127:    storageClassName, err := c.getStorageClassNameFromClaimName(context.TODO(), testNamespace, testClaimName)",
          "128:    Expect(err).ToNot(HaveOccurred())",
          "",
          "[Removed Lines]",
          "111:   DescribeTable(\"should return volume snapshot class or error\", func(storageClassName, volumeSnapshotClassName, resultSnapshotClassName string, expectedError bool) {",
          "112:    res, err := c.getSnapshotClassFromStorageClass(context.TODO(), storageClassName, volumeSnapshotClassName)",
          "113:    if expectedError {",
          "114:     Expect(err).To(HaveOccurred())",
          "115:    } else {",
          "116:     Expect(err).ToNot(HaveOccurred())",
          "117:     Expect(res.Name).To(Equal(resultSnapshotClassName))",
          "118:    }",
          "119:   },",
          "120:    Entry(\"should return volume snapshot class\", storageClassName, volumeSnapshotClassName, volumeSnapshotClassName, false),",
          "121:    Entry(\"should return default snapshot class\", storageClassName, \"\", otherVolumeSnapshotClassName, false),",
          "122:    Entry(\"should return error with non existing storage class\", \"non-existing-storage-class\", \"\", \"\", true),",
          "123:    Entry(\"should return error when provider doesn't match\", storageClassName, nonMatchingProvisioner, \"\", true),",
          "124:   )",
          "",
          "[Added Lines]",
          "[None]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "135:    Expect(volumeName).To(Equal(\"\"))",
          "136:   })",
          "140:    Expect(err).To(HaveOccurred())",
          "141:    Expect(volumeName).To(Equal(\"\"))",
          "142:   })",
          "144:   DescribeTable(\"should return snapshot class from claim or error\", func(claimName, namespace, snapshotClassName, resultSnapshotClassName string, expectedError bool) {",
          "145:    res, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), namespace, claimName, snapshotClassName)",
          "146:    if expectedError {",
          "147:     Expect(err).To(HaveOccurred())",
          "",
          "[Removed Lines]",
          "138:   It(\"snapshot class from claim name should return error if claim has nil storage class\", func() {",
          "139:    volumeName, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), testNamespace, testClaimName4, volumeSnapshotClassName)",
          "",
          "[Added Lines]",
          "129:   It(\"snapshot class from claim name should return error if claim has nil storage class, and not allow default\", func() {",
          "130:    c.storageClassEnforcement.AllowDefault = false",
          "131:    volumeName, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), testNamespace, testClaimNameDefault, volumeSnapshotClassName)",
          "137:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "138:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "139:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "140:    Expect(err).ToNot(HaveOccurred())",
          "141:    c.infraTenantStorageSnapshotMapping = mapping",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "156:   )",
          "158:   It(\"should return error if the storage class is not allowed\", func() {",
          "160:    Expect(err).To(HaveOccurred())",
          "161:    Expect(res).To(Equal(\"\"))",
          "163:   })",
          "166:    c.storageClassEnforcement.AllowAll = true",
          "167:    c.storageClassEnforcement.AllowList = nil",
          "168:    _, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), testNamespace, testClaimName, volumeSnapshotClassName)",
          "",
          "[Removed Lines]",
          "159:    res, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), testNamespace, testClaimName3, volumeSnapshotClassName)",
          "162:    Expect(err.Error()).To(ContainSubstring(\"not allowed for snapshot creation\"))",
          "165:   It(\"should return error if the storage class is not allowed\", func() {",
          "",
          "[Added Lines]",
          "156:    res, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), testNamespace, testClaimNameNotAllowed, volumeSnapshotClassName)",
          "159:    Expect(err.Error()).To(ContainSubstring(snapshotClassNotFound))",
          "162:   It(\"should return not error if the storage class is not allowed, but allowAll is true\", func() {",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "177:   })",
          "179:   It(\"should return error if the volume snapshot class is not found\", func() {",
          "180:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, \"non-existing-snapshot-class\")",
          "181:    Expect(err).To(HaveOccurred())",
          "182:    Expect(s).To(BeNil())",
          "184:   })",
          "186:   It(\"should return error if the DV is not found\", func() {",
          "",
          "[Removed Lines]",
          "183:    Expect(err.Error()).To(ContainSubstring(\"provided volume snapshot class cannot be matched with storage class\"))",
          "",
          "[Added Lines]",
          "177:    c.storageClassEnforcement.AllowDefault = false",
          "181:    Expect(err.Error()).To(ContainSubstring(snapshotClassNotFound))",
          "182:   })",
          "184:   It(\"should return error if the volume snapshot class is not found, and passed in value is empty, and allowDefault = false\", func() {",
          "185:    c.storageClassEnforcement.AllowDefault = false",
          "186:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, \"\")",
          "187:    Expect(err).To(HaveOccurred())",
          "188:    Expect(s).To(BeNil())",
          "189:    Expect(err.Error()).To(ContainSubstring(snapshotClassNotFound))",
          "190:   })",
          "192:   It(\"should return nil with snapshot if the volume snapshot class is not found, and passed in value is empty, and allowDefault = true\", func() {",
          "193:    c.storageClassEnforcement.AllowDefault = true",
          "194:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, \"\")",
          "195:    Expect(err).ToNot(HaveOccurred())",
          "196:    Expect(s).ToNot(BeNil())",
          "197:    Expect(s.Spec.VolumeSnapshotClassName).To(BeNil())",
          "",
          "---------------",
          "--- Hunk 6 ---",
          "[Context before]",
          "191:   })",
          "193:   It(\"should delete volumesnapshot if it exists and it valid\", func() {",
          "194:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
          "195:    Expect(err).ToNot(HaveOccurred())",
          "196:    Expect(s.Name).To(Equal(\"snap\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "208:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "209:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "210:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "211:    Expect(err).ToNot(HaveOccurred())",
          "212:    c.infraTenantStorageSnapshotMapping = mapping",
          "",
          "---------------",
          "--- Hunk 7 ---",
          "[Context before]",
          "204:   })",
          "206:   It(\"should return error if get volume returns an error\", func() {",
          "207:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
          "208:    Expect(err).ToNot(HaveOccurred())",
          "209:    Expect(s.Name).To(Equal(\"snap\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "226:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "227:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "228:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "229:    Expect(err).ToNot(HaveOccurred())",
          "230:    c.infraTenantStorageSnapshotMapping = mapping",
          "",
          "---------------",
          "--- Hunk 8 ---",
          "[Context before]",
          "213:   })",
          "215:   It(\"should properly list snapshots\", func() {",
          "216:    s, err := c.CreateVolumeSnapshot(context.TODO(), testNamespace, \"snap\", validDataVolume, volumeSnapshotClassName)",
          "217:    Expect(err).ToNot(HaveOccurred())",
          "218:    Expect(s.Name).To(Equal(\"snap\"))",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "240:    c.storageClassEnforcement = createDefaultStorageClassEnforcement()",
          "241:    fakeTenantSnapClient := snapfake.NewSimpleClientset()",
          "242:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, fakeTenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "243:    Expect(err).ToNot(HaveOccurred())",
          "244:    c.infraTenantStorageSnapshotMapping = mapping",
          "",
          "---------------",
          "--- Hunk 9 ---",
          "[Context before]",
          "233:    c = NewFakeClient()",
          "234:   })",
          "237:    c.storageClassEnforcement = enforcement",
          "239:    Expect(err).ToNot(HaveOccurred())",
          "240:    Expect(res).To(Equal(expected))",
          "241:   },",
          "250:   )",
          "251:  })",
          "",
          "[Removed Lines]",
          "236:   DescribeTable(\"should properly calculate if storage class is allowed\", func(storageClassName string, enforcement util.StorageClassEnforcement, expected bool) {",
          "238:    res, err := c.isStorageClassAllowed(context.TODO(), storageClassName)",
          "242:    Entry(\"should return true if storage class is in allowedList\", storageClassName,",
          "243:     util.StorageClassEnforcement{AllowList: []string{storageClassName}}, true),",
          "244:    Entry(\"should return false if storage class is not in allowedList\", storageClassName,",
          "245:     util.StorageClassEnforcement{AllowList: []string{}}, false),",
          "246:    Entry(\"should return true if default but not in allowedList\", defaultStorageClassName,",
          "247:     util.StorageClassEnforcement{AllowList: []string{}, AllowDefault: true}, true),",
          "248:    Entry(\"should return false if not default and not in allowedList\", storageClassName,",
          "249:     util.StorageClassEnforcement{AllowList: []string{}, AllowDefault: true}, false),",
          "",
          "[Added Lines]",
          "265:   DescribeTable(\"should properly determine snapshot class from storage class\", func(snapshotClassName, claimName string, enforcement util.StorageClassEnforcement, tenantSnapClient snapcli.Interface, expected, expectedError string) {",
          "267:    mapping, err := c.buildStorageClassSnapshotClassMapping(c.tenantKubernetesClient, tenantSnapClient, c.storageClassEnforcement.StorageSnapshotMapping)",
          "269:    c.infraTenantStorageSnapshotMapping = mapping",
          "270:    res, err := c.getSnapshotClassNameFromVolumeClaimName(context.TODO(), testNamespace, claimName, snapshotClassName)",
          "271:    if expectedError != \"\" {",
          "272:     Expect(err).To(HaveOccurred())",
          "273:     Expect(err.Error()).To(ContainSubstring(expectedError))",
          "274:    } else {",
          "275:     Expect(err).ToNot(HaveOccurred())",
          "276:    }",
          "279:    Entry(\"should return snapshot class if storage class is in allowedList\",",
          "280:     volumeSnapshotClassName,",
          "281:     testClaimName,",
          "282:     createDefaultStorageClassEnforcement(),",
          "283:     snapfake.NewSimpleClientset(),",
          "284:     volumeSnapshotClassName,",
          "285:     \"\"),",
          "286:    Entry(\"should return blank if storage class is not in allowedList\",",
          "287:     volumeSnapshotClassName,",
          "288:     testClaimNameNotAllowed,",
          "289:     createDefaultStorageClassEnforcement(),",
          "290:     snapfake.NewSimpleClientset(),",
          "291:     \"\",",
          "292:     snapshotClassNotFound),",
          "293:    Entry(\"should return blank and no error if AllowDefault but not in allowedList\",",
          "294:     volumeSnapshotClassName,",
          "295:     testClaimNameDefault,",
          "296:     createAllowDefaultStorageClassEnforcement(),",
          "297:     snapfake.NewSimpleClientset(),",
          "298:     \"\",",
          "299:     \"\"),",
          "300:    Entry(\"should return error if not in allowedList\",",
          "301:     volumeSnapshotClassName,",
          "302:     testClaimNameDefault,",
          "303:     createDefaultStorageClassEnforcement(),",
          "304:     snapfake.NewSimpleClientset(),",
          "305:     \"\",",
          "306:     snapshotClassNotFoundNoDefault),",
          "307:    Entry(\"should return error with suggestion if not in allowedList, but valid snapshot classes exist\",",
          "308:     otherVolumeSnapshotClassName,",
          "309:     testClaimName,",
          "310:     createDefaultStorageClassEnforcement(),",
          "311:     snapfake.NewSimpleClientset(createTenantVolumeSnapshotClass(tenantVolumeSnapshotClassName, \"csi.kubevirt.io\", volumeSnapshotClassName), createVolumeSnapshotClass(\"no-parameter\", \"ceph.csi.io\", false)),",
          "312:     \"\",",
          "313:     snapshotClassNotFoundSuggestion),",
          "",
          "---------------",
          "--- Hunk 10 ---",
          "[Context before]",
          "265:  testVolumeNotAllowed := createPersistentVolume(testVolumeNameNotAllowed, \"not-allowed-storage-class\")",
          "266:  testClaim := createPersistentVolumeClaim(testClaimName, testVolumeName, ptr.To[string](storageClassName))",
          "267:  testClaim2 := createPersistentVolumeClaim(testClaimName2, \"testVolumeName2\", ptr.To[string](storageClassName))",
          "270:  unboundClaim := &k8sv1.PersistentVolumeClaim{",
          "271:   ObjectMeta: metav1.ObjectMeta{",
          "272:    Name:      unboundTestClaimName,",
          "",
          "[Removed Lines]",
          "268:  testClaim3 := createPersistentVolumeClaim(testClaimName3, testVolumeNameNotAllowed, ptr.To[string](\"not-allowed-storage-class\"))",
          "269:  testClaimDefault := createPersistentVolumeClaim(testClaimName4, testVolumeName, nil)",
          "",
          "[Added Lines]",
          "332:  testClaim3 := createPersistentVolumeClaim(testClaimNameNotAllowed, testVolumeNameNotAllowed, ptr.To[string](\"not-allowed-storage-class\"))",
          "333:  testClaimDefault := createPersistentVolumeClaim(testClaimNameDefault, testVolumeName, nil)",
          "",
          "---------------",
          "--- Hunk 11 ---",
          "[Context before]",
          "279:  fakeK8sClient := k8sfake.NewSimpleClientset(storageClass, defaultStorageClass, testVolume,",
          "280:   testVolumeNotAllowed, testClaim, testClaim2, testClaim3, unboundClaim, testClaimDefault)",
          "282:  fakeSnapClient := snapfake.NewSimpleClientset(",
          "283:   createVolumeSnapshotClass(volumeSnapshotClassName, provisioner, false),",
          "284:   createVolumeSnapshotClass(nonMatchingProvisioner, otherprovisioner, false),",
          "285:   createVolumeSnapshotClass(otherVolumeSnapshotClassName, provisioner, true),",
          "286:  )",
          "287:  result := &client{",
          "292:   storageClassEnforcement: util.StorageClassEnforcement{",
          "293:    AllowList:    []string{storageClassName},",
          "294:    AllowAll:     false,",
          "",
          "[Removed Lines]",
          "288:   kubernetesClient: fakeK8sClient,",
          "289:   snapClient:       fakeSnapClient,",
          "290:   infraLabelMap:    map[string]string{\"test\": \"test\"},",
          "291:   volumePrefix:     \"pvc-\",",
          "",
          "[Added Lines]",
          "346:  fakeTenantK8sClient := k8sfake.NewSimpleClientset(createTenantStorageClass(tenantStorageClassName, \"csi.kubevirt.io\", storageClassName), createStorageClass(\"no-parameter-storage-class\", \"test.io\", false))",
          "353:   infraKubernetesClient:  fakeK8sClient,",
          "354:   tenantKubernetesClient: fakeTenantK8sClient,",
          "355:   infraSnapClient:        fakeSnapClient,",
          "356:   infraLabelMap:          map[string]string{\"test\": \"test\"},",
          "357:   volumePrefix:           \"pvc-\",",
          "",
          "---------------",
          "--- Hunk 12 ---",
          "[Context before]",
          "313:  return res",
          "314: }",
          "316: func createPersistentVolume(name, storageClassName string) *k8sv1.PersistentVolume {",
          "317:  return &k8sv1.PersistentVolume{",
          "318:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "382: func createTenantVolumeSnapshotClass(name, provisioner, infraSnapshotClassName string) *snapshotv1.VolumeSnapshotClass {",
          "383:  res := &snapshotv1.VolumeSnapshotClass{",
          "384:   ObjectMeta: metav1.ObjectMeta{",
          "385:    Name: name,",
          "386:   },",
          "387:   Driver: provisioner,",
          "388:   Parameters: map[string]string{",
          "389:    InfraSnapshotClassNameParameter: infraSnapshotClassName,",
          "390:   },",
          "391:  }",
          "392:  return res",
          "393: }",
          "",
          "---------------",
          "--- Hunk 13 ---",
          "[Context before]",
          "356:  return res",
          "357: }",
          "359: func createDataVolume(name string, labels map[string]string) *cdiv1.DataVolume {",
          "360:  return &cdiv1.DataVolume{",
          "361:   ObjectMeta: metav1.ObjectMeta{",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "438: func createTenantStorageClass(name, provisioner, infraStorageClassName string) *storagev1.StorageClass {",
          "439:  res := &storagev1.StorageClass{",
          "440:   ObjectMeta: metav1.ObjectMeta{",
          "441:    Name: name,",
          "442:   },",
          "443:   Provisioner: provisioner,",
          "444:   Parameters: map[string]string{",
          "445:    InfraStorageClassNameParameter: infraStorageClassName,",
          "446:   },",
          "447:  }",
          "448:  return res",
          "449: }",
          "",
          "---------------",
          "--- Hunk 14 ---",
          "[Context before]",
          "378: func createWrongPrefixDataVolume() *cdiv1.DataVolume {",
          "379:  return createDataVolume(testVolumeName, map[string]string{\"test\": \"test\"})",
          "380: }",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "474: func createDefaultStorageClassEnforcement() util.StorageClassEnforcement {",
          "475:  return util.StorageClassEnforcement{",
          "476:   AllowList: []string{storageClassName},",
          "477:   AllowAll:  false,",
          "478:   StorageSnapshotMapping: []util.StorageSnapshotMapping{",
          "479:    {",
          "480:     StorageClasses: []string{",
          "481:      storageClassName,",
          "482:     },",
          "483:     VolumeSnapshotClasses: []string{",
          "484:      volumeSnapshotClassName,",
          "485:     },",
          "486:    },",
          "487:   },",
          "488:  }",
          "489: }",
          "491: func createAllowDefaultStorageClassEnforcement() util.StorageClassEnforcement {",
          "492:  return util.StorageClassEnforcement{",
          "493:   AllowAll:     false,",
          "494:   AllowDefault: true,",
          "495:  }",
          "496: }",
          "",
          "---------------"
        ],
        "pkg/service/controller.go||pkg/service/controller.go": [
          "File: pkg/service/controller.go -> pkg/service/controller.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "27: )",
          "29: const (",
          "35: )",
          "37: var (",
          "",
          "[Removed Lines]",
          "30:  infraStorageClassNameParameter  = \"infraStorageClassName\"",
          "31:  infraSnapshotClassNameParameter = \"infraSnapshotClassName\"",
          "32:  busParameter                    = \"bus\"",
          "33:  busDefaultValue                 = kubevirtv1.DiskBus(\"scsi\")",
          "34:  serialParameter                 = \"serial\"",
          "",
          "[Added Lines]",
          "30:  busParameter    = \"bus\"",
          "31:  busDefaultValue = kubevirtv1.DiskBus(\"scsi\")",
          "32:  serialParameter = \"serial\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "77:   return isRWX, nil",
          "78:  }",
          "81:  if storageClassName == \"\" {",
          "82:   if c.storageClassEnforcement.AllowDefault {",
          "83:    return isRWX, nil",
          "",
          "[Removed Lines]",
          "80:  storageClassName := req.Parameters[infraStorageClassNameParameter]",
          "",
          "[Added Lines]",
          "78:  storageClassName := req.Parameters[client.InfraStorageClassNameParameter]",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "126:  }",
          "130:  storageSize := req.GetCapacityRange().GetRequiredBytes()",
          "131:  dvName := req.Name",
          "132:  value, ok := req.Parameters[busParameter]",
          "",
          "[Removed Lines]",
          "129:  storageClassName := req.Parameters[infraStorageClassNameParameter]",
          "",
          "[Added Lines]",
          "127:  storageClassName := req.Parameters[client.InfraStorageClassNameParameter]",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "552:    return nil, status.Errorf(codes.NotFound, \"source volume %s not found\", req.GetSourceVolumeId())",
          "553:   }",
          "556:   volumeSnapshot, err := c.virtClient.CreateVolumeSnapshot(ctx, c.infraClusterNamespace, req.GetName(), req.GetSourceVolumeId(), snapshotClassName)",
          "557:   if err != nil {",
          "558:    return nil, err",
          "",
          "[Removed Lines]",
          "555:   snapshotClassName := req.Parameters[infraSnapshotClassNameParameter]",
          "",
          "[Added Lines]",
          "553:   snapshotClassName := req.Parameters[client.InfraSnapshotClassNameParameter]",
          "",
          "---------------"
        ],
        "pkg/service/controller_test.go||pkg/service/controller_test.go": [
          "File: pkg/service/controller_test.go -> pkg/service/controller_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "20:  kubevirtv1 \"kubevirt.io/api/core/v1\"",
          "21:  cdiv1 \"kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1\"",
          "23:  \"kubevirt.io/csi-driver/pkg/util\"",
          "25:  . \"github.com/onsi/ginkgo/v2\"",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "23:  client \"kubevirt.io/csi-driver/pkg/kubevirt\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "116:  })",
          "118:  It(\"should not allow storage class not in the allow list\", func() {",
          "120:   storageClassEnforcement = util.StorageClassEnforcement{",
          "121:    AllowList:    []string{\"allowedClass\"},",
          "122:    AllowAll:     false,",
          "123:    AllowDefault: true,",
          "124:   }",
          "127:   request := getCreateVolumeRequest(getVolumeCapability(corev1.PersistentVolumeFilesystem, csi.VolumeCapability_AccessMode_SINGLE_NODE_WRITER))",
          "130:   _, err := controller.CreateVolume(context.TODO(), request)",
          "131:   Expect(err).To(HaveOccurred())",
          "",
          "[Removed Lines]",
          "119:   client := &ControllerClientMock{}",
          "125:   controller := ControllerService{client, testInfraNamespace, testInfraLabels, storageClassEnforcement}",
          "128:   request.Parameters[infraStorageClassNameParameter] = \"notAllowedClass\"",
          "",
          "[Added Lines]",
          "120:   cli := &ControllerClientMock{}",
          "126:   controller := ControllerService{cli, testInfraNamespace, testInfraLabels, storageClassEnforcement}",
          "129:   request.Parameters[client.InfraStorageClassNameParameter] = \"notAllowedClass\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "547: func getCreateVolumeRequest(volumeCapability *csi.VolumeCapability) *csi.CreateVolumeRequest {",
          "548:  parameters := map[string]string{}",
          "549:  if testInfraStorageClassName != \"\" {",
          "551:  }",
          "552:  if testBusType != nil {",
          "553:   parameters[busParameter] = string(*testBusType)",
          "",
          "[Removed Lines]",
          "550:   parameters[infraStorageClassNameParameter] = testInfraStorageClassName",
          "",
          "[Added Lines]",
          "551:   parameters[client.InfraStorageClassNameParameter] = testInfraStorageClassName",
          "",
          "---------------"
        ],
        "pkg/service/identity.go||pkg/service/identity.go": [
          "File: pkg/service/identity.go -> pkg/service/identity.go"
        ],
        "pkg/util/util.go||pkg/util/util.go": [
          "File: pkg/util/util.go -> pkg/util/util.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "1: package util",
          "3: type StorageClassEnforcement struct {",
          "7: }",
          "",
          "[Removed Lines]",
          "4:  AllowList    []string `yaml:\"allowList\"`",
          "5:  AllowAll     bool     `yaml:\"allowAll\"`",
          "6:  AllowDefault bool     `yaml:\"allowDefault\"`",
          "",
          "[Added Lines]",
          "4:  AllowList              []string                 `yaml:\"allowList\"`",
          "5:  AllowAll               bool                     `yaml:\"allowAll\"`",
          "6:  AllowDefault           bool                     `yaml:\"allowDefault\"`",
          "7:  StorageSnapshotMapping []StorageSnapshotMapping `yaml:\"storageSnapshotMapping,omitempty\"`",
          "8: }",
          "10: type StorageSnapshotMapping struct {",
          "11:  VolumeSnapshotClasses []string `yaml:\"volumeSnapshotClasses,omitempty\"`",
          "12:  StorageClasses        []string `yaml:\"storageClasses\"`",
          "",
          "---------------"
        ],
        "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types.go||vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types.go": [
          "File: vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types.go -> vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "106:  DataSourceRef *corev1.TypedObjectReference `json:\"dataSourceRef,omitempty\"`",
          "107: }",
          "110: type DataVolumeCheckpoint struct {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110: const PersistentVolumeFromStorageProfile corev1.PersistentVolumeMode = \"FromStorageProfile\"",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "445: type ClaimPropertySet struct {",
          "454: }",
          "",
          "[Removed Lines]",
          "449:  AccessModes []corev1.PersistentVolumeAccessMode `json:\"accessModes,omitempty\" protobuf:\"bytes,1,rep,name=accessModes,casttype=PersistentVolumeAccessMode\"`",
          "453:  VolumeMode *corev1.PersistentVolumeMode `json:\"volumeMode,omitempty\" protobuf:\"bytes,6,opt,name=volumeMode,casttype=PersistentVolumeMode\"`",
          "",
          "[Added Lines]",
          "455:  AccessModes []corev1.PersistentVolumeAccessMode `json:\"accessModes\"`",
          "459:  VolumeMode *corev1.PersistentVolumeMode `json:\"volumeMode\"`",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "826:  UninstallStrategy *CDIUninstallStrategy `json:\"uninstallStrategy,omitempty\"`",
          "833:  CloneStrategyOverride *CDICloneStrategy `json:\"cloneStrategyOverride,omitempty\"`",
          "",
          "[Removed Lines]",
          "828:  Infra sdkapi.NodePlacement `json:\"infra,omitempty\"`",
          "830:  Workloads sdkapi.NodePlacement `json:\"workload,omitempty\"`",
          "",
          "[Added Lines]",
          "834:  Infra ComponentConfig `json:\"infra,omitempty\"`",
          "836:  Workloads           sdkapi.NodePlacement `json:\"workload,omitempty\"`",
          "837:  CustomizeComponents CustomizeComponents  `json:\"customizeComponents,omitempty\"`",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "839:  PriorityClass *CDIPriorityClass `json:\"priorityClass,omitempty\"`",
          "840: }",
          "843: type CDIPriorityClass string",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "850: type ComponentConfig struct {",
          "852:  sdkapi.NodePlacement `json:\",inline\"`",
          "854:  DeploymentReplicas *int32 `json:\"deploymentReplicas,omitempty\"`",
          "856:  APIServerReplicas *int32 `json:\"apiServerReplicas,omitempty\"`",
          "858:  UploadProxyReplicas *int32 `json:\"uploadProxyReplicas,omitempty\"`",
          "859: }",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "856:  CloneStrategyCsiClone CDICloneStrategy = \"csi-clone\"",
          "857: )",
          "860: type DataImportCronSourceFormat string",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "879: type CustomizeComponents struct {",
          "881:  Patches []CustomizeComponentsPatch `json:\"patches,omitempty\"`",
          "884:  Flags *Flags `json:\"flags,omitempty\"`",
          "885: }",
          "891: type Flags struct {",
          "892:  API         map[string]string `json:\"api,omitempty\"`",
          "893:  Controller  map[string]string `json:\"controller,omitempty\"`",
          "894:  UploadProxy map[string]string `json:\"uploadProxy,omitempty\"`",
          "895: }",
          "898: type CustomizeComponentsPatch struct {",
          "900:  ResourceName string `json:\"resourceName\"`",
          "902:  ResourceType string    `json:\"resourceType\"`",
          "903:  Patch        string    `json:\"patch\"`",
          "904:  Type         PatchType `json:\"type\"`",
          "905: }",
          "908: type PatchType string",
          "910: const (",
          "912:  JSONPatchType PatchType = \"json\"",
          "914:  MergePatchType PatchType = \"merge\"",
          "916:  StrategicMergePatchType PatchType = \"strategic\"",
          "917: )",
          "",
          "---------------"
        ],
        "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types_swagger_generated.go||vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types_swagger_generated.go": [
          "File: vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types_swagger_generated.go -> vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/types_swagger_generated.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "182:  return map[string]string{",
          "183:   \"\":                           \"StorageProfileSpec defines specification for StorageProfile\",",
          "184:   \"cloneStrategy\":              \"CloneStrategy defines the preferred method for performing a CDI clone\",",
          "186:   \"dataImportCronSourceFormat\": \"DataImportCronSourceFormat defines the format of the DataImportCron-created disk image sources\",",
          "187:   \"snapshotClass\":              \"SnapshotClass is optional specific VolumeSnapshotClass for CloneStrategySnapshot. If not set, a VolumeSnapshotClass is chosen according to the provisioner.\",",
          "188:  }",
          "",
          "[Removed Lines]",
          "185:   \"claimPropertySets\":          \"ClaimPropertySets is a provided set of properties applicable to PVC\",",
          "",
          "[Added Lines]",
          "185:   \"claimPropertySets\":          \"ClaimPropertySets is a provided set of properties applicable to PVC\\n+kubebuilder:validation:MaxItems=8\",",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "194:   \"storageClass\":               \"The StorageClass name for which capabilities are defined\",",
          "195:   \"provisioner\":                \"The Storage class provisioner plugin name\",",
          "196:   \"cloneStrategy\":              \"CloneStrategy defines the preferred method for performing a CDI clone\",",
          "198:   \"dataImportCronSourceFormat\": \"DataImportCronSourceFormat defines the format of the DataImportCron-created disk image sources\",",
          "199:   \"snapshotClass\":              \"SnapshotClass is optional specific VolumeSnapshotClass for CloneStrategySnapshot. If not set, a VolumeSnapshotClass is chosen according to the provisioner.\",",
          "200:  }",
          "",
          "[Removed Lines]",
          "197:   \"claimPropertySets\":          \"ClaimPropertySets computed from the spec and detected in the system\",",
          "",
          "[Added Lines]",
          "197:   \"claimPropertySets\":          \"ClaimPropertySets computed from the spec and detected in the system\\n+kubebuilder:validation:MaxItems=8\",",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "203: func (ClaimPropertySet) SwaggerDoc() map[string]string {",
          "204:  return map[string]string{",
          "205:   \"\":            \"ClaimPropertySet is a set of properties applicable to PVC\",",
          "208:  }",
          "209: }",
          "",
          "[Removed Lines]",
          "206:   \"accessModes\": \"AccessModes contains the desired access modes the volume should have.\\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1\\n+optional\",",
          "207:   \"volumeMode\":  \"VolumeMode defines what type of volume is required by the claim.\\nValue of Filesystem is implied when not included in claim spec.\\n+optional\",",
          "",
          "[Added Lines]",
          "206:   \"accessModes\": \"AccessModes contains the desired access modes the volume should have.\\nMore info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1\\n+kubebuilder:validation:MaxItems=4\\n+kubebuilder:validation:XValidation:rule=\\\"self.all(am, am in ['ReadWriteOnce', 'ReadOnlyMany', 'ReadWriteMany', 'ReadWriteOncePod'])\\\", message=\\\"Illegal AccessMode\\\"\",",
          "207:   \"volumeMode\":  \"VolumeMode defines what type of volume is required by the claim.\\nValue of Filesystem is implied when not included in claim spec.\\n+kubebuilder:validation:Enum=\\\"Block\\\";\\\"Filesystem\\\"\",",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "428:   \"\":                      \"CDISpec defines our specification for the CDI installation\",",
          "429:   \"imagePullPolicy\":       \"+kubebuilder:validation:Enum=Always;IfNotPresent;Never\\nPullPolicy describes a policy for if/when to pull a container image\",",
          "430:   \"uninstallStrategy\":     \"+kubebuilder:validation:Enum=RemoveWorkloads;BlockUninstallIfWorkloadsExist\\nCDIUninstallStrategy defines the state to leave CDI on uninstall\",",
          "432:   \"workload\":              \"Restrict on which nodes CDI workload pods will be scheduled\",",
          "433:   \"cloneStrategyOverride\": \"Clone strategy override: should we use a host-assisted copy even if snapshots are available?\\n+kubebuilder:validation:Enum=\\\"copy\\\";\\\"snapshot\\\";\\\"csi-clone\\\"\",",
          "434:   \"config\":                \"CDIConfig at CDI level\",",
          "",
          "[Removed Lines]",
          "431:   \"infra\":                 \"Rules on which nodes CDI infrastructure pods will be scheduled\",",
          "",
          "[Added Lines]",
          "431:   \"infra\":                 \"Selectors and tolerations that should apply to cdi infrastructure components\",",
          "",
          "---------------",
          "--- Hunk 5 ---",
          "[Context before]",
          "437:  }",
          "438: }",
          "440: func (CDIStatus) SwaggerDoc() map[string]string {",
          "441:  return map[string]string{",
          "442:   \"\": \"CDIStatus defines the status of the installation\",",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "440: func (ComponentConfig) SwaggerDoc() map[string]string {",
          "441:  return map[string]string{",
          "442:   \"\":                    \"ComponentConfig defines the scheduling and replicas configuration for CDI components\",",
          "443:   \"deploymentReplicas\":  \"DeploymentReplicas set Replicas for cdi-deployment\",",
          "444:   \"apiServerReplicas\":   \"ApiserverReplicas set Replicas for cdi-apiserver\",",
          "445:   \"uploadProxyReplicas\": \"UploadproxyReplicas set Replicas for cdi-uploadproxy\",",
          "446:  }",
          "447: }",
          "449: func (CustomizeComponents) SwaggerDoc() map[string]string {",
          "450:  return map[string]string{",
          "451:   \"\":        \"CustomizeComponents defines patches for components deployed by the CDI operator.\",",
          "452:   \"patches\": \"+listType=atomic\",",
          "453:   \"flags\":   \"Configure the value used for deployment and daemonset resources\",",
          "454:  }",
          "455: }",
          "457: func (Flags) SwaggerDoc() map[string]string {",
          "458:  return map[string]string{",
          "459:   \"\": \"Flags will create a patch that will replace all flags for the container's\\ncommand field. The only flags that will be used are those define. There are no\\nguarantees around forward/backward compatibility.  If set incorrectly this will\\ncause the resource when rolled out to error until flags are updated.\",",
          "460:  }",
          "461: }",
          "463: func (CustomizeComponentsPatch) SwaggerDoc() map[string]string {",
          "464:  return map[string]string{",
          "465:   \"\":             \"CustomizeComponentsPatch defines a patch for some resource.\",",
          "466:   \"resourceName\": \"+kubebuilder:validation:MinLength=1\",",
          "467:   \"resourceType\": \"+kubebuilder:validation:MinLength=1\",",
          "468:  }",
          "469: }",
          "",
          "---------------"
        ],
        "vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/zz_generated.deepcopy.go||vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/zz_generated.deepcopy.go": [
          "File: vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/zz_generated.deepcopy.go -> vendor/kubevirt.io/containerized-data-importer-api/pkg/apis/core/v1beta1/zz_generated.deepcopy.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "303:  }",
          "304:  in.Infra.DeepCopyInto(&out.Infra)",
          "305:  in.Workloads.DeepCopyInto(&out.Workloads)",
          "306:  if in.CloneStrategyOverride != nil {",
          "307:   in, out := &in.CloneStrategyOverride, &out.CloneStrategyOverride",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "306:  in.CustomizeComponents.DeepCopyInto(&out.CustomizeComponents)",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "405:  return out",
          "406: }",
          "409: func (in *ConditionState) DeepCopyInto(out *ConditionState) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "410: func (in *ComponentConfig) DeepCopyInto(out *ComponentConfig) {",
          "412:  in.NodePlacement.DeepCopyInto(&out.NodePlacement)",
          "413:  if in.DeploymentReplicas != nil {",
          "414:   in, out := &in.DeploymentReplicas, &out.DeploymentReplicas",
          "417:  }",
          "418:  if in.APIServerReplicas != nil {",
          "419:   in, out := &in.APIServerReplicas, &out.APIServerReplicas",
          "422:  }",
          "423:  if in.UploadProxyReplicas != nil {",
          "424:   in, out := &in.UploadProxyReplicas, &out.UploadProxyReplicas",
          "427:  }",
          "428:  return",
          "429: }",
          "432: func (in *ComponentConfig) DeepCopy() *ComponentConfig {",
          "433:  if in == nil {",
          "434:   return nil",
          "435:  }",
          "436:  out := new(ComponentConfig)",
          "437:  in.DeepCopyInto(out)",
          "438:  return out",
          "439: }",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "423:  return out",
          "424: }",
          "427: func (in *DataImportCron) DeepCopyInto(out *DataImportCron) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "460: func (in *CustomizeComponents) DeepCopyInto(out *CustomizeComponents) {",
          "462:  if in.Patches != nil {",
          "463:   in, out := &in.Patches, &out.Patches",
          "465:   copy(*out, *in)",
          "466:  }",
          "467:  if in.Flags != nil {",
          "468:   in, out := &in.Flags, &out.Flags",
          "470:   (*in).DeepCopyInto(*out)",
          "471:  }",
          "472:  return",
          "473: }",
          "476: func (in *CustomizeComponents) DeepCopy() *CustomizeComponents {",
          "477:  if in == nil {",
          "478:   return nil",
          "479:  }",
          "480:  out := new(CustomizeComponents)",
          "481:  in.DeepCopyInto(out)",
          "482:  return out",
          "483: }",
          "486: func (in *CustomizeComponentsPatch) DeepCopyInto(out *CustomizeComponentsPatch) {",
          "488:  return",
          "489: }",
          "492: func (in *CustomizeComponentsPatch) DeepCopy() *CustomizeComponentsPatch {",
          "493:  if in == nil {",
          "494:   return nil",
          "495:  }",
          "496:  out := new(CustomizeComponentsPatch)",
          "497:  in.DeepCopyInto(out)",
          "498:  return out",
          "499: }",
          "",
          "---------------",
          "--- Hunk 4 ---",
          "[Context before]",
          "1193:  return out",
          "1194: }",
          "1197: func (in *ImportProxy) DeepCopyInto(out *ImportProxy) {",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "1272: func (in *Flags) DeepCopyInto(out *Flags) {",
          "1274:  if in.API != nil {",
          "1275:   in, out := &in.API, &out.API",
          "1277:   for key, val := range *in {",
          "1278:    (*out)[key] = val",
          "1279:   }",
          "1280:  }",
          "1281:  if in.Controller != nil {",
          "1282:   in, out := &in.Controller, &out.Controller",
          "1284:   for key, val := range *in {",
          "1285:    (*out)[key] = val",
          "1286:   }",
          "1287:  }",
          "1288:  if in.UploadProxy != nil {",
          "1289:   in, out := &in.UploadProxy, &out.UploadProxy",
          "1291:   for key, val := range *in {",
          "1292:    (*out)[key] = val",
          "1293:   }",
          "1294:  }",
          "1295:  return",
          "1296: }",
          "1299: func (in *Flags) DeepCopy() *Flags {",
          "1300:  if in == nil {",
          "1301:   return nil",
          "1302:  }",
          "1303:  out := new(Flags)",
          "1304:  in.DeepCopyInto(out)",
          "1305:  return out",
          "1306: }",
          "",
          "---------------"
        ]
      }
    },
    {
      "candidate_hash": "906c86e7f53f30a0ea29b66575ad4ce8b7d2ed48",
      "candidate_info": {
        "commit_hash": "906c86e7f53f30a0ea29b66575ad4ce8b7d2ed48",
        "repo": "kubevirt/csi-driver",
        "commit_url": "https://github.com/kubevirt/csi-driver/commit/906c86e7f53f30a0ea29b66575ad4ce8b7d2ed48",
        "files": [
          "e2e/create-pvc_test.go",
          "hack/run-e2e.sh",
          "hack/run-k8s-e2e.sh",
          "kubevirtci"
        ],
        "message": "E2E: bump k8s to 1.30 (#113)\n\nSigned-off-by: Nahshon Unna-Tsameret <nunnatsa@redhat.com>",
        "before_after_code_files": [
          "e2e/create-pvc_test.go||e2e/create-pvc_test.go",
          "hack/run-e2e.sh||hack/run-e2e.sh",
          "hack/run-k8s-e2e.sh||hack/run-k8s-e2e.sh"
        ]
      },
      "candidate_patch_features": {
        "candidate_earlier_than_patch": 0,
        "same_branch_evolution": 1,
        "olp_code_files": {
          "patch": [
            "e2e/create-pvc_test.go||e2e/create-pvc_test.go"
          ],
          "candidate": [
            "e2e/create-pvc_test.go||e2e/create-pvc_test.go"
          ]
        }
      },
      "candidate_diff": {
        "e2e/create-pvc_test.go||e2e/create-pvc_test.go": [
          "File: e2e/create-pvc_test.go -> e2e/create-pvc_test.go",
          "--- Hunk 1 ---",
          "[Context before]",
          "495:     tenantPVC = nil",
          "496:    }",
          "497:    if tenantPV != nil {",
          "499:     Expect(err).ToNot(HaveOccurred())",
          "501:     Eventually(func() bool {",
          "",
          "[Removed Lines]",
          "498:     err := tenantClient.CoreV1().PersistentVolumes().Delete(context.Background(), tenantPV.Name, metav1.DeleteOptions{})",
          "",
          "[Added Lines]",
          "498:     By(\"Ensuring volume attachments associated with the PV are deleted\")",
          "499:     attachments, err := tenantClient.StorageV1().VolumeAttachments().List(context.Background(), metav1.ListOptions{})",
          "500:     Expect(err).ToNot(HaveOccurred())",
          "501:     for _, attachment := range attachments.Items {",
          "502:      if attachment.Spec.Source.PersistentVolumeName != nil && *attachment.Spec.Source.PersistentVolumeName == tenantPV.Name {",
          "503:       err = tenantClient.StorageV1().VolumeAttachments().Delete(context.Background(), attachment.Name, metav1.DeleteOptions{})",
          "504:       Expect(err).ToNot(HaveOccurred())",
          "505:      }",
          "506:     }",
          "507:     err = tenantClient.CoreV1().PersistentVolumes().Delete(context.Background(), tenantPV.Name, metav1.DeleteOptions{})",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "540:    tenantPV = &k8sv1.PersistentVolume{",
          "541:     ObjectMeta: metav1.ObjectMeta{",
          "542:      Name: \"tenant-pv\",",
          "543:     },",
          "544:     Spec: k8sv1.PersistentVolumeSpec{",
          "545:      AccessModes: []k8sv1.PersistentVolumeAccessMode{k8sv1.ReadWriteOnce},",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "552:      Annotations: map[string]string{",
          "553:       \"pv.kubernetes.io/provisioned-by\": \"csi.kubevirt.io\",",
          "554:      },",
          "",
          "---------------"
        ],
        "hack/run-e2e.sh||hack/run-e2e.sh": [
          "File: hack/run-e2e.sh -> hack/run-e2e.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "9: DUMP_VERSION=$(curl -L https://storage.googleapis.com/kubevirt-prow/devel/nightly/release/kubevirt/kubevirt/latest)",
          "10: DUMP_PATH=${TOOLS_DIR}/bin/kubevirt-${DUMP_VERSION}-dump",
          "11: TEST_WORKING_DIR=${TOOLS_DIR}/e2e-test-workingdir",
          "12: export ARTIFACTS=${ARTIFACTS:-k8s-reporter}",
          "13: export KUBECONFIG=$(./kubevirtci kubeconfig)",
          "14: export INFRA_CLUSTER_NAMESPACE=${INFRA_CLUSTER_NAMESPACE:-kvcluster}",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "12: BIN_DIR=${BIN_DIR:-bin}",
          "",
          "---------------"
        ],
        "hack/run-k8s-e2e.sh||hack/run-k8s-e2e.sh": [
          "File: hack/run-k8s-e2e.sh -> hack/run-k8s-e2e.sh",
          "--- Hunk 1 ---",
          "[Context before]",
          "15: set -e",
          "16: export TENANT_CLUSTER_NAME=${TENANT_CLUSTER_NAME:-kvcluster}",
          "17: export TENANT_CLUSTER_NAMESPACE=${TENANT_CLUSTER_NAMESPACE:-kvcluster}",
          "20: test_pod=${TENANT_CLUSTER_NAME}-k8s-e2e-suite-runnner",
          "21: test_driver_cm=${TENANT_CLUSTER_NAME}-test-driver",
          "",
          "[Removed Lines]",
          "18: export KUBEVIRTCI_TAG=${KUBEVIRTCI_TAG:-2309141019-029e67a}",
          "",
          "[Added Lines]",
          "18: export KUBEVIRTCI_TAG=${KUBEVIRTCI_TAG:-2405151527-09bcd71}",
          "",
          "---------------",
          "--- Hunk 2 ---",
          "[Context before]",
          "95:     - -c",
          "96:     - |",
          "97:       cd /tmp",
          "99:       chmod +x e2e.test",
          "101:       chmod +x kubectl",
          "102:       echo \\${TEST_DRIVER_PATH}",
          "103:       ./e2e.test -kubeconfig \\${KUBECONFIG} \\",
          "",
          "[Removed Lines]",
          "98:       curl --location https://dl.k8s.io/v1.26.0/kubernetes-test-linux-amd64.tar.gz | tar --strip-components=3 -zxf - kubernetes/test/bin/e2e.test kubernetes/test/bin/ginkgo",
          "100:       curl -LO \"https://dl.k8s.io/release/v1.26.0/bin/linux/amd64/kubectl\"",
          "",
          "[Added Lines]",
          "98:       curl --location https://dl.k8s.io/v1.30.1/kubernetes-test-linux-amd64.tar.gz | tar --strip-components=3 -zxf - kubernetes/test/bin/e2e.test kubernetes/test/bin/ginkgo",
          "100:       curl -LO \"https://dl.k8s.io/release/v1.30.1/bin/linux/amd64/kubectl\"",
          "",
          "---------------",
          "--- Hunk 3 ---",
          "[Context before]",
          "107:             -ginkgo.focus='External.Storage.*csi.kubevirt.io.*' \\",
          "108:             -ginkgo.skip='CSI Ephemeral-volume*' \\",
          "109:             -ginkgo.skip='SELinuxMountReadWriteOncePod.*' \\",
          "110:             -storage.testdriver=\\${TEST_DRIVER_PATH}/test-driver.yaml \\",
          "111:             -provider=local -report-dir=/tmp",
          "112:       ret1=\\$?",
          "",
          "[Removed Lines]",
          "[None]",
          "",
          "[Added Lines]",
          "110:             -ginkgo.skip='should provision correct filesystem size when restoring snapshot to larger size pvc' \\",
          "",
          "---------------"
        ]
      }
    }
  ]
}